ndEnvironmentStrings(szCommand, szExp, ARRAYSIZE(szExp))
                && lstrcmp(szCommand, szExp)) // don't hit the disk a second time if the string hasn't changed
                {
                    SHGetFileInfo(szExp, 0, &sfi, sizeof(sfi), SHGFI_TYPENAME);
                }
            }
            SetDlgItemText(plpd->hDlg, IDD_FILETYPE, sfi.szTypeName);

            // location
            StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), szCommand);
            PathRemoveFileSpec(szBuffer);
            SetDlgItemText(plpd->hDlg, IDD_LOCATION, PathFindFileName(szBuffer));

            // command
            plpd->psl->GetArguments(szBuffer, ARRAYSIZE(szBuffer));
            PathComposeWithArgs(szCommand, szBuffer);
            GetDlgItemText(plpd->hDlg, IDD_FILENAME, szBuffer, ARRAYSIZE(szBuffer));
            // Conditionally change to prevent "Apply" button from enabling
            if (lstrcmp(szCommand, szBuffer) != 0)
                SetDlgItemText(plpd->hDlg, IDD_FILENAME, szCommand);
        }
        else
        {
            LPITEMIDLIST pidl;

            plpd->bIsFile = FALSE;

            EnableWindow(GetDlgItem(plpd->hDlg, IDD_FILENAME), FALSE);
            EnableWindow(GetDlgItem(plpd->hDlg, IDD_PATH), FALSE);

            plpd->psl->GetIDList(&pidl);

            if (pidl)
            {
                SHGetNameAndFlags(pidl, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, szCommand, SIZECHARS(szCommand), NULL);
                ILRemoveLastID(pidl);
                SHGetNameAndFlags(pidl, SHGDN_NORMAL, szBuffer, SIZECHARS(szBuffer), NULL);
                ILFree(pidl);

                SetDlgItemText(plpd->hDlg, IDD_LOCATION, szBuffer);
                SetDlgItemText(plpd->hDlg, IDD_FILETYPE, szCommand);
                SetDlgItemText(plpd->hDlg, IDD_FILENAME, szCommand);
            }
        }
    }

    if (bUpdatePath)
    {
        return;
    }

    plpd->psl->GetWorkingDirectory(szBuffer, ARRAYSIZE(szBuffer));
    SetDlgItemPath(plpd->hDlg, IDD_PATH, szBuffer);

    plpd->psl->GetDescription(szBuffer, ARRAYSIZE(szBuffer));
    SHLoadIndirectString(szBuffer, szBuffer, ARRAYSIZE(szBuffer), NULL);    // will do nothing if the string isn't indirect
    SetDlgItemText(plpd->hDlg, IDD_LINK_DESCRIPTION, szBuffer);

    plpd->psl->GetHotkey(&wHotkey);
    SendDlgItemMessage(plpd->hDlg, IDD_LINK_HOTKEY, HKM_SETHOTKEY, wHotkey, 0);

    //
    // Now initialize the Run SHOW Command combo box
    //
    for (iShowCmd = IDS_RUN_NORMAL; iShowCmd <= IDS_RUN_MAXIMIZED; iShowCmd++)
    {
        LoadString(HINST_THISDLL, iShowCmd, szBuffer, ARRAYSIZE(szBuffer));
        SendDlgItemMessage(plpd->hDlg, IDD_LINK_SHOWCMD, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)szBuffer);
    }

    // Now setup the Show Command - Need to map to index numbers...
    plpd->psl->GetShowCmd(&iShowCmd);

    for (i = 0; i < ARRAYSIZE(c_iShowCmds); i++)
    {
        if (c_iShowCmds[i] == iShowCmd)
            break;
    }
    if (i == ARRAYSIZE(c_iShowCmds))
    {
        ASSERT(0);      // bogus link show cmd
        i = 0;  // SW_SHOWNORMAL
    }

    SendDlgItemMessage(plpd->hDlg, IDD_LINK_SHOWCMD, CB_SETCURSEL, i, 0);

    // the icon
    _UpdateLinkIcon(plpd, NULL);
}

//
// Opens a folder window with the target of the link selected
//
void _FindTarget(LINKPROP_DATA *plpd)
{
    if (plpd->psl->Resolve(plpd->hDlg, 0) == S_OK)
    {
        LPITEMIDLIST pidl;

        _UpdateLinkDlg(plpd, TRUE);

        plpd->psl->GetIDList(&pidl);
        if (pidl)
        {
            SHOpenFolderAndSelectItems(pidl, 0, NULL, 0);
            ILFree(pidl);
        }
    }
}

// let the user pick a new icon for a link...

BOOL _DoPickIcon(LINKPROP_DATA *plpd)
{
    int iIconIndex;
    SHFILEINFO sfi;
    TCHAR * const pszIconPath = sfi.szDisplayName;  // pszIconPath is just an alias for szDisplayName
    IShellLinkDataList *psldl; 
    EXP_SZ_LINK *esli;
    HRESULT hr;

    *pszIconPath = 0;

    //
    // if the user has picked a icon before use it.
    //
    if (plpd->szIconPath[0] != 0 && plpd->iIconIndex >= 0)
    {
        StringCchCopy(pszIconPath, ARRAYSIZE(sfi.szDisplayName), plpd->szIconPath);
        iIconIndex = plpd->iIconIndex;
    }
    else
    {
        //
        // if this link has a icon use that.
        //
        plpd->psl->GetIconLocation(pszIconPath, MAX_PATH, &iIconIndex);

        //
        // check for an escaped version, if its there, use that 
        // 
        if (SUCCEEDED(hr = plpd->psl->QueryInterface(IID_PPV_ARG(IShellLinkDataList, &psldl)))) 
        { 
            if (SUCCEEDED(hr = psldl->CopyDataBlock(EXP_SZ_ICON_SIG, (void **)&esli))) 
            { 
                ASSERT(esli);
                StringCchCopy(pszIconPath, MAX_PATH, esli->swzTarget); 
                LocalFree(esli);
            } 

            psldl->Release(); 
        } 


        if (pszIconPath[0] == TEXT('.'))
        {
            TCHAR szFullIconPath[MAX_PATH];

            // We now allow ".txt" for the icon path, but since the user is clicking
            // on the "Change Icon..." button, we show the current icon that ".txt" is
            // associated with
            GetIconLocationFromExt(pszIconPath, szFullIconPath, ARRAYSIZE(szFullIconPath), &iIconIndex);
            StringCchCopy(pszIconPath, ARRAYSIZE(sfi.szDisplayName), szFullIconPath);
        }
        else if (pszIconPath[0] == 0)
        {
            //
            // link does not have a icon, if it is a link to a file
            // use the file name
            //
            iIconIndex = 0;

            HRESULT hr = _GetPathAndArgs(plpd, pszIconPath, NULL, 0);
            if (SUCCEEDED(hr))
            {
                if (!plpd->bIsFile || !PathIsExe(pszIconPath))
                {
                    //
                    // link is not to a file, go get the icon
                    //
                    SHGetFileInfo(plpd->szFile, 0, &sfi, sizeof(sfi), SHGFI_ICONLOCATION);
                    iIconIndex = sfi.iIcon;
                    ASSERT(pszIconPath == sfi.szDisplayName);
                }
            }
        }
    }

    if (PickIconDlg(plpd->hDlg, pszIconPath, MAX_PATH, &iIconIndex))
    {
        HICON hIcon = ExtractIcon(HINST_THISDLL, pszIconPath, iIconIndex);
        _UpdateLinkIcon(plpd, hIcon);

        // don't save it out to the link yet, just store it in our instance data
        plpd->iIconIndex = iIconIndex;
        StringCchCopy(plpd->szIconPath, ARRAYSIZE(plpd->szIconPath), pszIconPath);

        PropSheet_Changed(GetParent(plpd->hDlg), plpd->hDlg);
        return TRUE;
    }

    return FALSE;
}


STDAPI SaveLink(LINKDATA *pld)
{
    WORD wHotkey;
    int iShowCmd;
    IPersistFile *ppf;
    HRESULT hr;
    TCHAR szBuffer[MAX_PATH];

    if (!(pld->plpd->bIsDirty || (pld->cpd.lpConsole && pld->cpd.bConDirty)))
        return S_OK;

    if (pld->plpd->bIsFile)
    {
        TCHAR szArgs[MAX_PATH];

        hr = _GetPathAndArgs(pld->plpd, szBuffer, szArgs, ARRAYSIZE(szArgs));
        if (SUCCEEDED(hr))
        {
            // set the path (and pidl) of the link
            pld->plpd->psl->SetPath(szBuffer);

            // may be null
            pld->plpd->psl->SetArguments(szArgs);
        }

        if (pld->plpd->bEnableRunInSepVDM && pld->plpd->bRunInSepVDM)
        {
            SetLinkFlags(pld->plpd->psl, SLDF_RUN_IN_SEPARATE, SLDF_RUN_IN_SEPARATE);
        }
        else
        {
            SetLinkFlags(pld->plpd->psl, 0, SLDF_RUN_IN_SEPARATE);
        }

        if (pld->plpd->bRunAsUser)
        {
            SetLinkFlags(pld->plpd->psl, SLDF_RUNAS_USER, SLDF_RUNAS_USER);
        }
        else
        {
            SetLinkFlags(pld->plpd->psl, 0, SLDF_RUNAS_USER);
        }
    }

    if (pld->plpd->bIsFile || (SetLinkFlags(pld->plpd->psl, 0, 0) & SLDF_HAS_DARWINID))
    {
        // set the working directory of the link
        GetDlgItemPath(pld->plpd->hDlg, IDD_PATH, szBuffer);
        pld->plpd->psl->SetWorkingDirectory(szBuffer);
    }

    // set the description of the link if it changed.
    TCHAR szOldComment[MAX_PATH];
    pld->plpd->psl->GetDescription(szOldComment, ARRAYSIZE(szOldComment));
    SHLoadIndirectString(szOldComment, szOldComment, ARRAYSIZE(szOldComment), NULL);    // will do nothing if the string isn't indirect
    GetDlgItemText(pld->plpd->hDlg, IDD_LINK_DESCRIPTION, szBuffer, ARRAYSIZE(szBuffer));
    if (lstrcmp(szBuffer, szOldComment) != 0)
        pld->plpd->psl->SetDescription(szBuffer);

    // the hotkey
    wHotkey = (WORD)SendDlgItemMessage(pld->plpd->hDlg, IDD_LINK_HOTKEY , HKM_GETHOTKEY, 0, 0);
    pld->plpd->psl->SetHotkey(wHotkey);

    // the show command combo box
    iShowCmd = (int)SendDlgItemMessage(pld->plpd->hDlg, IDD_LINK_SHOWCMD, CB_GETCURSEL, 0, 0L);
    if ((iShowCmd >= 0) && (iShowCmd < ARRAYSIZE(c_iShowCmds)))
    {
        pld->plpd->psl->SetShowCmd(c_iShowCmds[iShowCmd]);
    }

    // If the user explicitly selected a new icon, invalidate
    // the icon cache entry for this link and then send around a file
    // sys refresh message to all windows in case they are looking at
    // this link.
    if (pld->plpd->iIconIndex >= 0)
    {
        pld->plpd->psl->SetIconLocation(pld->plpd->szIconPath, pld->plpd->iIconIndex);
    }

    // Update/Save the console information in the pExtraData section of
    // the shell link.
    if (pld->cpd.lpConsole && pld->cpd.bConDirty)
    {
        LinkConsolePagesSave(pld);
    }

    hr = pld->plpd->psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
    if (SUCCEEDED(hr))
    {
        if (ppf->IsDirty() == S_OK)
        {
            // save using existing file name (pld->plpd->szFile)
            hr = ppf->Save(NULL, TRUE);

            if (FAILED(hr))
            {
                SHSysErrorMessageBox(pld->plpd->hDlg, NULL, IDS_LINKCANTSAVE,
                    hr & 0xFFF, PathFindFileName(pld->plpd->szFile),
                    MB_OK | MB_ICONEXCLAMATION);
            }
            else
            {
                pld->plpd->bIsDirty = FALSE;
            }
        }
        ppf->Release();
    }

    return hr;
}

void SetEditFocus(HWND hwnd)
{
    SetFocus(hwnd);
    Edit_SetSel(hwnd, 0, -1);
}

// returns:
//      TRUE    all link fields are valid
//      FALSE   some thing is wrong with what the user has entered

BOOL _ValidateLink(LINKPROP_DATA *plpd)
{
    TCHAR szDir[MAX_PATH], szPath[MAX_PATH], szArgs[MAX_PATH];
    TCHAR szExpPath[MAX_PATH];
    BOOL  bValidPath = FALSE;
    HRESULT hr;

    if (!plpd->bIsFile)
        return TRUE;

    // validate the working directory field

    GetDlgItemPath(plpd->hDlg, IDD_PATH, szDir);

    if (*szDir &&
        StrChr(szDir, TEXT('%')) == NULL &&       // has environement var %USER%
        !IsRemovableDrive(DRIVEID(szDir)) &&
        !PathIsDirectory(szDir))
    {
        ShellMessageBox(HINST_THISDLL, plpd->hDlg, MAKEINTRESOURCE(IDS_LINKBADWORKDIR),
                        MAKEINTRESOURCE(IDS_LINKERROR), MB_OK | MB_ICONEXCLAMATION, szDir);

        SetEditFocus(GetDlgItem(plpd->hDlg, IDD_PATH));

        return FALSE;
    }

    // validate the path (with arguments) field

    hr = _GetPathAndArgs(plpd, szPath, szArgs, ARRAYSIZE(szArgs));
    if (SUCCEEDED(hr))
    {
        if (szPath[0] == 0)
            return TRUE;

        if (PathIsRoot(szPath) && IsRemovableDrive(DRIVEID(szPath)))
            return TRUE;

        if (PathIsLnk(szPath))
        {
            ShellMessageBox(HINST_THISDLL, plpd->hDlg, MAKEINTRESOURCE(IDS_LINKTOLINK),
                            MAKEINTRESOURCE(IDS_LINKERROR), MB_OK | MB_ICONEXCLAMATION);
            SetEditFocus(GetDlgItem(plpd->hDlg, IDD_FILENAME));
            return FALSE;
        }

        LPCTSTR dirs[2];
        dirs[0] = szDir;
        dirs[1] = NULL;
        bValidPath = PathResolve(szPath, dirs, PRF_DONTFINDLNK | PRF_TRYPROGRAMEXTENSIONS);
        if (!bValidPath)
        {
            // The path "as is" was invalid.  See if it has environment variables
            // which need to be expanded.

            hr = _GetPathAndArgs(plpd, szPath, szArgs, ARRAYSIZE(szArgs));
            if (SUCCEEDED(hr))
            {
                if (SHExpandEnvironmentStrings(szPath, szExpPath, ARRAYSIZE(szExpPath)))
                {
                    if (PathIsRoot(szExpPath) && IsRemovableDrive(DRIVEID(szDir)))
                        return TRUE;

                    bValidPath = PathResolve(szExpPath, dirs, PRF_DONTFINDLNK | PRF_TRYPROGRAMEXTENSIONS);
                }
            }
        }

        if (bValidPath)
        {
            BOOL bSave;

            if (plpd->bLinkThreadIsAlive)
            {
                bSave = plpd->bCheckRunInSep;
                plpd->bCheckRunInSep = FALSE;
            }
            PathComposeWithArgs(szPath, szArgs);
            GetDlgItemText(plpd->hDlg, IDD_FILENAME, szExpPath, ARRAYSIZE(szExpPath));
            // only do this if something changed... that way we avoid having the PSM_CHANGED
            // for nothing
            if (lstrcmpi(szPath, szExpPath))
                SetDlgItemText(plpd->hDlg, IDD_FILENAME, szPath);

            if (plpd->bLinkThreadIsAlive)
            {
                plpd->bCheckRunInSep = bSave;
            }

            return TRUE;
        }
    }

    ShellMessageBox(HINST_THISDLL, plpd->hDlg, MAKEINTRESOURCE(IDS_LINKBADPATH),
                        MAKEINTRESOURCE(IDS_LINKERROR), MB_OK | MB_ICONEXCLAMATION, szPath);
    SetEditFocus(GetDlgItem(plpd->hDlg, IDD_FILENAME));
    return FALSE;
}

// Array for context help:
const DWORD aLinkHelpIDs[] = {
    IDD_LINE_1,             NO_HELP,
    IDD_LINE_2,             NO_HELP,
    IDD_ITEMICON,           IDH_FCAB_LINK_ICON,
    IDD_NAME,               IDH_FCAB_LINK_NAME,
    IDD_FILETYPE_TXT,       IDH_FCAB_LINK_LINKTYPE,
    IDD_FILETYPE,           IDH_FCAB_LINK_LINKTYPE,
    IDD_LOCATION_TXT,       IDH_FCAB_LINK_LOCATION,
    IDD_LOCATION,           IDH_FCAB_LINK_LOCATION,
    IDD_FILENAME,           IDH_FCAB_LINK_LINKTO,
    IDD_PATH,               IDH_FCAB_LINK_WORKING,
    IDD_LINK_HOTKEY,        IDH_FCAB_LINK_HOTKEY,
    IDD_LINK_SHOWCMD,       IDH_FCAB_LINK_RUN,
    IDD_LINK_DESCRIPTION,   IDH_FCAB_LINK_DESCRIPTION,
    IDD_FINDORIGINAL,       IDH_FCAB_LINK_FIND,
    IDD_LINKDETAILS,        IDH_FCAB_LINK_CHANGEICON,
    0, 0
};

// Array for context help (Advanced Dlg):
const DWORD aAdvancedLinkHelpIDs[] = {
    IDD_RUNINSEPARATE,      IDH_TRAY_RUN_SEPMEM,
    IDD_LINK_RUNASUSER,     IDH_FCAB_LINK_RUNASUSER,
    0,0
};

UINT g_msgActivateDesktop = 0;

DWORD CALLBACK _LinkAddRefSyncCallBack(void *pv)
{
    LINKPROP_DATA *plpd = (LINKPROP_DATA *)pv;
    AddRef_LinkPropData(plpd);
    plpd->bLinkThreadIsAlive = TRUE;
    return 0;
}

// Dialog proc for the generic link property sheet
//
// uses DLG_LINKPROP template

BOOL_PTR CALLBACK _LinkAdvancedDlgProc(HWND hDlgAdvanced, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LINKPROP_DATA *plpd = (LINKPROP_DATA *)GetWindowLongPtr(hDlgAdvanced, DWLP_USER);

    switch (msg)
    {
    case WM_INITDIALOG:
    {
        TCHAR szFullFile[MAX_PATH];
        DWORD cchVerb;
        UINT cch;

        plpd = (LINKPROP_DATA *)lParam;
        SetWindowLongPtr(hDlgAdvanced, DWLP_USER, (LPARAM)plpd);

        plpd->hDlgAdvanced = hDlgAdvanced;

        cch = _GetTargetOfLink(plpd, szFullFile);

        if ((cch != 0) && (cch < ARRAYSIZE(szFullFile)))
        {
            DWORD dwBinaryType;

            // enable "run in seperate VDM" if this is a 16-bit image 
            if (GetBinaryType(szFullFile, &dwBinaryType) && (dwBinaryType == SCS_WOW_BINARY))
            {
                if (SetLinkFlags(plpd->psl, 0, 0) & SLDF_RUN_IN_SEPARATE)
                {
                    EnableWindow(GetDlgItem(hDlgAdvanced, IDD_RUNINSEPARATE), TRUE);
                    CheckDlgButton(hDlgAdvanced, IDD_RUNINSEPARATE, BST_CHECKED);
                } 
                else 
                {
                    EnableWindow(GetDlgItem(hDlgAdvanced, IDD_RUNINSEPARATE), TRUE);
                    CheckDlgButton(hDlgAdvanced, IDD_RUNINSEPARATE, BST_UNCHECKED);
                }
            } 
            else 
            {
                // check it
                CheckDlgButton(hDlgAdvanced, IDD_RUNINSEPARATE, BST_CHECKED);
                EnableWindow(GetDlgItem(hDlgAdvanced, IDD_RUNINSEPARATE), FALSE);
            }

            // enable "runas" if the link target has that verb 
            if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_COMMAND, szFullFile, TEXT("runas"), NULL, &cchVerb)) &&
                cchVerb)
            {
                EnableWindow(GetDlgItem(hDlgAdvanced, IDD_LINK_RUNASUSER), TRUE);
                CheckDlgButton(hDlgAdvanced, IDD_LINK_RUNASUSER, (SetLinkFlags(plpd->psl, 0, 0) & SLDF_RUNAS_USER) ? BST_CHECKED : BST_UNCHECKED);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlgAdvanced, IDD_LINK_RUNASUSER), FALSE);
                CheckDlgButton(hDlgAdvanced, IDD_LINK_RUNASUSER, BST_UNCHECKED);
            }

        } 
        else 
        {
            // fall back to disabling everything
            CheckDlgButton(hDlgAdvanced, IDD_RUNINSEPARATE, BST_CHECKED);
            EnableWindow(GetDlgItem(hDlgAdvanced, IDD_RUNINSEPARATE), FALSE);
            EnableWindow(GetDlgItem(hDlgAdvanced, IDD_LINK_RUNASUSER), FALSE);
        }

        // get the initial state of the checkboxes
        plpd->bEnableRunInSepVDM = IsWindowEnabled(GetDlgItem(hDlgAdvanced, IDD_RUNINSEPARATE));
        plpd->bRunInSepVDM = IsDlgButtonChecked(hDlgAdvanced, IDD_RUNINSEPARATE);
        plpd->bRunAsUser = IsDlgButtonChecked(hDlgAdvanced, IDD_LINK_RUNASUSER);
    }
    break;

    case WM_COMMAND:
    {
        UINT idControl = GET_WM_COMMAND_ID(wParam, lParam);

        switch (idControl)
        {
        case IDD_RUNINSEPARATE:
        case IDD_LINK_RUNASUSER:
            plpd->bIsDirty = TRUE;
            break;

        case IDOK:
            // get the final state of the checkboxes
            plpd->bEnableRunInSepVDM = IsWindowEnabled(GetDlgItem(hDlgAdvanced, IDD_RUNINSEPARATE));
            plpd->bRunInSepVDM = IsDlgButtonChecked(hDlgAdvanced, IDD_RUNINSEPARATE);
            plpd->bRunAsUser = IsDlgButtonChecked(hDlgAdvanced, IDD_LINK_RUNASUSER);
            // fall through

        case IDCANCEL:
            ReplaceDlgIcon(hDlgAdvanced, IDD_ITEMICON, NULL);
            plpd->hDlgAdvanced = NULL;
            EndDialog(hDlgAdvanced, (idControl == IDCANCEL) ? FALSE : TRUE);
            break;
        }
    }
    break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPTSTR)aAdvancedLinkHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aAdvancedLinkHelpIDs);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


BOOL_PTR CALLBACK _LinkDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LINKDATA *pld = (LINKDATA *)GetWindowLongPtr(hdlg, DWLP_USER);

    switch (msg) 
    {
    case WM_INITDIALOG:

        pld = (LINKDATA *)((PROPSHEETPAGE *)lParam)->lParam;
        SetWindowLongPtr(hdlg, DWLP_USER, (LPARAM)pld);

        // setup dialog state variables

        pld->plpd->hDlg = hdlg;

        SendDlgItemMessage(hdlg, IDD_FILENAME, EM_LIMITTEXT, MAX_PATH-1, 0);
        SetPathWordBreakProc(GetDlgItem(hdlg, IDD_FILENAME), TRUE);
        SendDlgItemMessage(hdlg, IDD_PATH, EM_LIMITTEXT, MAX_PATH-1, 0);
        SetPathWordBreakProc(GetDlgItem(hdlg, IDD_PATH), TRUE);
        SendDlgItemMessage(hdlg, IDD_LINK_DESCRIPTION, EM_LIMITTEXT, MAX_PATH-1, 0);

        // set valid combinations for the hotkey
        SendDlgItemMessage(hdlg, IDD_LINK_HOTKEY, HKM_SETRULES,
                            HKCOMB_NONE | HKCOMB_A | HKCOMB_S | HKCOMB_C,
                            HOTKEYF_CONTROL | HOTKEYF_ALT);

        SHAutoComplete(GetDlgItem(hdlg, IDD_FILENAME), 0);
        SHAutoComplete(GetDlgItem(hdlg, IDD_PATH), 0);

        ASSERT(pld->plpd->bLinkThreadIsAlive == FALSE);

        _UpdateLinkDlg(pld->plpd, FALSE);

        // Set up background thread to handle "Run In Separate Memory Space"
        // check box.
        pld->plpd->bCheckRunInSep = TRUE;
        if (pld->plpd->hCheckNow)
        {
            SHCreateThread(_LinkCheckThreadProc, pld->plpd,  0, _LinkAddRefSyncCallBack);
        }

        // start off clean.
        // do this here because we call some stuff above which generates
        // wm_command/en_changes which we then think makes it dirty
        pld->plpd->bIsDirty = FALSE;

        break;

    case WM_DESTROY:
        ReplaceDlgIcon(pld->plpd->hDlg, IDD_ITEMICON, NULL);
        _StopThread(pld->plpd);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) 
        {
        case PSN_RESET:
                _StopThread(pld->plpd);
            break;
        case PSN_APPLY:

            if ((((PSHNOTIFY *)lParam)->lParam))
                _StopThread(pld->plpd);

            if (FAILED(SaveLink(pld)))
                SetWindowLongPtr(hdlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            break;

        case PSN_KILLACTIVE:
            // we implement the save on page change model, so
            // validate and save changes here.  this works for
            // Apply Now, OK, and Page chagne.

            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, !_ValidateLink(pld->plpd));   // don't allow close
            break;
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) 
        {
        case IDD_FINDORIGINAL:
            _FindTarget(pld->plpd);
            break;

        case IDD_LINKDETAILS:
            if (_DoPickIcon(pld->plpd))
                pld->plpd->bIsDirty = TRUE;
            break;

        case IDD_LINK_SHOWCMD:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE)
            {
                PropSheet_Changed(GetParent(hdlg), hdlg);
                pld->plpd->bIsDirty = TRUE;
            }
            break;

        case IDD_LINK_HOTKEY:
        case IDD_FILENAME:
        case IDD_PATH:
        case IDD_LINK_DESCRIPTION:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
            {
                PropSheet_Changed(GetParent(hdlg), hdlg);
                pld->plpd->bIsDirty = TRUE;
                if (pld->plpd->bLinkThreadIsAlive && pld->plpd->bCheckRunInSep)
                    SetEvent(pld->plpd->hCheckNow);
            }
            break;

        case IDC_ADVANCED:
            if ((DialogBoxParam(HINST_THISDLL,
                                MAKEINTRESOURCE(DLG_LINKPROP_ADVANCED), 
                                hdlg,
                                _LinkAdvancedDlgProc,
                                (LPARAM)pld->plpd) == TRUE) &&
                (pld->plpd->bIsDirty == TRUE))
            {
                // something on the advanced page changed
                PropSheet_Changed(GetParent(hdlg), hdlg);
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aLinkHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aLinkHelpIDs);
        break;

    default:
        if (0 == g_msgActivateDesktop)
            g_msgActivateDesktop = RegisterWindowMessage(TEXT("ActivateDesktop"));

        if (msg == g_msgActivateDesktop)
        {
            HWND hwnd = FindWindow(TEXT(STR_DESKTOPCLASS), NULL);
            SwitchToThisWindow(GetLastActivePopup(hwnd), TRUE);
            SetForegroundWindow(hwnd);
        }
        return FALSE;
    }
    return TRUE;
}

//
// Release the link object allocated during the initialize
//
UINT CALLBACK _LinkPrshtCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    LINKDATA *pld = (LINKDATA *)((PROPSHEETPAGE *)ppsp->lParam);
    switch (uMsg) 
    {
    case PSPCB_RELEASE:
        if (pld->cpd.lpConsole)
        {
            LocalFree(pld->cpd.lpConsole);
        }
        if (pld->cpd.lpFEConsole)
        {
            LocalFree(pld->cpd.lpFEConsole);
        }
        DestroyFonts(&pld->cpd);
        Release_LinkPropData(pld->plpd);
        LocalFree(pld);
        break;
    }

    return 1;
}

STDAPI_(BOOL) AddLinkPage(LPCTSTR pszFile, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    IShellLink *psl;
    if (PathIsLnk(pszFile) && SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, IID_PPV_ARG(IShellLink, &psl))))
    {
        // alloc this data, since is it shared across several pages
        // instead of putting it in as extra data in the page header
        LINKDATA *pld = (LINKDATA *)LocalAlloc(LPTR, sizeof(*pld));
        if (pld)
        {
            pld->plpd = Create_LinkPropData();       
            if (pld->plpd)
            {
                PROPSHEETPAGE psp;

                psp.dwSize      = sizeof(psp);
                psp.dwFlags     = PSP_DEFAULT | PSP_USECALLBACK;
                psp.hInstance   = HINST_THISDLL;
                psp.pszTemplate = MAKEINTRESOURCE(DLG_LINKPROP);
                psp.pfnDlgProc  = _LinkDlgProc;
                psp.pfnCallback = _LinkPrshtCallback;
                psp.lParam      = (LPARAM)pld;  // pass to all dlg procs

                StringCchCopy(pld->plpd->szFile, ARRAYSIZE(pld->plpd->szFile), pszFile);
                pld->plpd->iIconIndex = -1;
                pld->plpd->psl = psl;
                ASSERT(!pld->plpd->szIconPath[0]);

                HPROPSHEETPAGE hpage = CreatePropertySheetPage(&psp);
                if (hpage)
                {
                    if (pfnAddPage(hpage, lParam))
                    {
                        // Add console property pages if appropriate...
                        AddLinkConsolePages(pld, psl, pszFile, pfnAddPage, lParam);
                        return TRUE;    // we added the link page
                    }
                    else
                    {
                        DestroyPropertySheetPage(hpage);
                    }
                }
                Release_LinkPropData(pld->plpd);

            }
            LocalFree(pld);
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\lnkcon.h ===
/*
 * The distinction between the desired and actual font dimensions obtained
 * is important in the case of TrueType fonts, in which there is no guarantee
 * that what you ask for is what you will get.
 *
 * Note that the correspondence between "Desired" and "Actual" is broken
 * whenever the user changes his display driver, because GDI uses driver
 * parameters to control the font rasterization.
 *
 * The SizeDesired is {0, 0} if the font is a raster font.
 */
typedef struct {
    HFONT hFont;
    COORD Size;      // font size obtained
    COORD SizeWant;  // 0;0 if Raster font
    LONG  Weight;
    LPTSTR FaceName;
    BYTE  Family;
    BYTE  tmCharSet;
} FONT_INFO;

typedef struct tagFACENODE {
     struct tagFACENODE *pNext;
     DWORD  dwFlag;
     TCHAR  atch[];
} FACENODE;

//
// TrueType font list
//     This structure shares in windows\inc\wincon.w file
//

// we don't make bold available if BOLD_MARK is in the face name.
#define BOLD_MARK    (L'*')

typedef struct _TT_FONT_LIST {
    SINGLE_LIST_ENTRY List;
    UINT  CodePage;
    BOOL  fDisableBold;
    TCHAR FaceName1[LF_FACESIZE];
    TCHAR FaceName2[LF_FACESIZE];
} TTFONTLIST;

#ifdef MAX_TITLE_LEN
#undef MAX_TITLE_LEN
#endif
#define MAX_TITLE_LEN 256
#define MAXDIMENSTRING     40  // max text in combo box
#define DX_TTBITMAP        20
#define DY_TTBITMAP        12
#define CCH_RASTERFONTS    24
#define CCH_SELECTEDFONT   30

typedef struct {
    IShellLink * psl;
    LPNT_CONSOLE_PROPS lpConsole;
    LPNT_FE_CONSOLE_PROPS lpFEConsole;
    BOOL bConDirty;
    int xScreen;
    int yScreen;
    POINT NonClientSize;
    RECT WindowRect;
    DWORD PreviewFlags;
    FONT_INFO *FontInfo;
    ULONG FontInfoLength;
    ULONG NumberOfFonts;
    BOOL gbEnumerateFaces;
    BOOL gbPointSizeError;
    BOOL gbBold;
    BOOL bFontInit;
    BOOL bColorInit;
    FACENODE *gpFaceNames;
    TCHAR DefaultFaceName[LF_FACESIZE];
    LPTSTR lpFaceName;
#ifndef UNICODE
    CHAR szFaceName[LF_FACESIZE];
#endif
    COORD DefaultFontSize;
    BYTE  DefaultFontFamily;
    ULONG DefaultFontIndex;
    ULONG CurrentFontIndex;
    LONG  FontLong;
    int   Index;
    BYTE  ColorArray[4];
    TCHAR ConsoleTitle[ MAX_TITLE_LEN + 1 ];
    BOOL fChangeCodePage;
    UINT uOEMCP;
    SINGLE_LIST_ENTRY gTTFontList;    // This list contain TTFONTLIST data.
} CONSOLEPROP_DATA;

// got this from wingdip.h so we don't have to compile it all
#define IS_ANY_DBCS_CHARSET( CharSet )                              \
                   ( ((CharSet) == SHIFTJIS_CHARSET)    ? TRUE :    \
                     ((CharSet) == HANGEUL_CHARSET)     ? TRUE :    \
                     ((CharSet) == CHINESEBIG5_CHARSET) ? TRUE :    \
                     ((CharSet) == GB2312_CHARSET)      ? TRUE : FALSE )

#define TM_IS_TT_FONT(x)     (((x) & TMPF_TRUETYPE) == TMPF_TRUETYPE)
#define IS_BOLD(w)           ((w) >= FW_SEMIBOLD)
#define SIZE_EQUAL(s1, s2)   (((s1).X == (s2).X) && ((s1).Y == (s2).Y))
#define POINTS_PER_INCH 72
#define MIN_PIXEL_HEIGHT 5
#define MAX_PIXEL_HEIGHT 72
#define CONSOLE_REGISTRY_CURRENTPAGE  (L"CurrentPage")


#define MAX_SCRBUF_WIDTH  9999
#define MAX_SCRBUF_HEIGHT 9999

#define INITIAL_FONTS 20
#define FONT_INCREMENT 3
#define CONSOLE_MAX_FONT_NAME_LENGTH 256

#define CM_SETCOLOR       (WM_USER+1)
#define CM_PREVIEW_UPDATE (WM_USER+2)
#define CM_PREVIEW_INIT   (WM_USER+3)
#define CM_COLOR_INIT     (WM_USER+4)


#define PREVIEW_HSCROLL  0x01
#define PREVIEW_VSCROLL  0x02

#define FE_ABANDONFONT 0
#define FE_SKIPFONT    1
#define FE_FONTOK      2


#define EF_NEW         0x0001 // a newly available face
#define EF_OLD         0x0002 // a previously available face
#define EF_ENUMERATED  0x0004 // all sizes have been enumerated
#define EF_OEMFONT     0x0008 // an OEM face
#define EF_TTFONT      0x0010 // a TT face
#define EF_DEFFACE     0x0020 // the default face
#define EF_DBCSFONT    0x0040 // the DBCS font


/* ----- Macros ----- */
/*
 *  High-level macros
 *
 *  These macros handle the SendMessages that go tofrom list boxes
 *  and combo boxes.
 *
 *  The "xxx_lcb" prefix stands for leaves CritSect & "list or combo box".
 *
 *  Basically, we're providing mnemonic names for what would otherwise
 *  look like a whole slew of confusing SendMessage's.
 *
 */
#define lcbRESETCONTENT(hWnd, bLB) \
        SendMessage(hWnd, bLB ? LB_RESETCONTENT : CB_RESETCONTENT, 0, 0L)

#define lcbFINDSTRINGEXACT(hWnd, bLB, pwsz) \
        SendMessage(hWnd, bLB ? LB_FINDSTRINGEXACT : CB_FINDSTRINGEXACT, \
                          (DWORD)-1, (LPARAM)pwsz)

#define lcbADDSTRING(hWnd, bLB, pwsz) \
        SendMessage(hWnd, bLB ? LB_ADDSTRING : CB_ADDSTRING, 0, (LPARAM)pwsz)

#define lcbSETITEMDATA(hWnd, bLB, w, nFont) \
        SendMessage(hWnd, bLB ? LB_SETITEMDATA : CB_SETITEMDATA, w, nFont)

#define lcbGETITEMDATA(hWnd, bLB, w) \
        SendMessage(hWnd, bLB ? LB_GETITEMDATA : CB_GETITEMDATA, w, 0L)

#define lcbGETCOUNT(hWnd, bLB) \
        SendMessage(hWnd, bLB ? LB_GETCOUNT : CB_GETCOUNT, 0, 0L)

#define lcbGETCURSEL(hWnd, bLB) \
        SendMessage(hWnd, bLB ? LB_GETCURSEL : CB_GETCURSEL, 0, 0L)

#define lcbSETCURSEL(hWnd, bLB, w) \
        SendMessage(hWnd, bLB ? LB_SETCURSEL : CB_SETCURSEL, w, 0L)

#define NELEM(array) (sizeof(array)/sizeof(array[0]))
#define AttrToRGB(Attr) (pcpd->lpConsole->ColorTable[(Attr) & 0x0F])
#define ScreenTextColor(pcpd) \
            (AttrToRGB(LOBYTE(pcpd->lpConsole->wFillAttribute) & 0x0F))
#define ScreenBkColor(pcpd) \
            (AttrToRGB(LOBYTE(pcpd->lpConsole->wFillAttribute >> 4)))
#define PopupTextColor(pcpd) \
            (AttrToRGB(LOBYTE(pcpd->lpConsole->wPopupFillAttribute) & 0x0F))
#define PopupBkColor(pcpd) \
            (AttrToRGB(LOBYTE(pcpd->lpConsole->wPopupFillAttribute >> 4)))


NTSTATUS InitializeFonts( CONSOLEPROP_DATA *pcpd );

STDAPI_(void) DestroyFonts( CONSOLEPROP_DATA *pcpd );

NTSTATUS EnumerateFonts( CONSOLEPROP_DATA *pcpd, DWORD Flags);

int FindCreateFont(
    CONSOLEPROP_DATA *pcpd,
    DWORD Family,
    LPTSTR ptszFace,
    COORD Size,
    LONG Weight);

BOOL DoFontEnum(
    CONSOLEPROP_DATA *pcpd,
    HDC hDC,
    LPTSTR ptszFace,
    PSHORT pTTPoints,
    UINT nTTPoints);

void GetTitleFromLinkName(LPTSTR szLinkName, LPTSTR szTitle, UINT cchTitle);
void SetRegistryValues(CONSOLEPROP_DATA *pcpd);
void GetRegistryValues(CONSOLEPROP_DATA *pcpd);
void InitRegistryValues(CONSOLEPROP_DATA *pcpd);
void GetRegistryValues(CONSOLEPROP_DATA *pcpd);
void SetFERegistryValues(CONSOLEPROP_DATA *pcpd);
void GetFERegistryValues(CONSOLEPROP_DATA *pcpd);
void InitFERegistryValues(CONSOLEPROP_DATA *pcpd);

NTSTATUS MakeAltRasterFont(
    CONSOLEPROP_DATA *pcpd,
    UINT CodePage,
    COORD *AltFontSize,
    BYTE  *AltFontFamily,
    ULONG *AltFontIndex,
    LPTSTR AltFaceName,
    UINT cchFaceName
    );

NTSTATUS InitializeDbcsMisc(CONSOLEPROP_DATA *pcpd);

BYTE CodePageToCharSet(UINT CodePage);

TTFONTLIST *SearchTTFont(CONSOLEPROP_DATA *pcpd, LPTSTR ptszFace, BOOL fCodePage, UINT CodePage);

BOOL IsAvailableTTFont(CONSOLEPROP_DATA *pcpd, LPTSTR ptszFace);
BOOL IsAvailableTTFontCP(CONSOLEPROP_DATA *pcpd, LPTSTR pwszFace, UINT CodePage);
BOOL IsDisableBoldTTFont(CONSOLEPROP_DATA *pcpd, LPTSTR ptszFace);
LPTSTR GetAltFaceName(CONSOLEPROP_DATA *pcpd, LPTSTR ptszFace);

int LanguageListCreate(HWND hDlg, UINT CodePage);

typedef struct 
{
    LONG   _cRef;
    // input params
    IShellLink *psl;
    // local state variables
    HWND hDlg;
    HWND hDlgAdvanced;
    BOOL bIsFile;
    BOOL bIsDirty;
    int iIconIndex;
    BOOL bLinkThreadIsAlive;
    BOOL bCheckRunInSep;
    HANDLE hCheckNow;
    BOOL bEnableRunInSepVDM;
    BOOL bRunInSepVDM;
    BOOL bRunAsUser;
    TCHAR szFile[MAX_PATH];
    TCHAR szIconPath[MAX_PATH];
} LINKPROP_DATA;


typedef struct {
    LINKPROP_DATA *plpd;
    CONSOLEPROP_DATA cpd;
} LINKDATA;

STDAPI SaveLink(LINKDATA *pld);
STDAPI_(void) LinkConsolePagesSave(LINKDATA *pld);
STDAPI_(void) AddLinkConsolePages(LINKDATA *pld, IShellLink * psl, LPCTSTR pszFile, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\lnkfnt.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fontdlg.dlg

Abstract:

    This module contains the code for console font dialog

Author:

    Therese Stowell (thereses) Feb-3-1992 (swiped from Win3.1)

Revision History:

--*/

#include "shellprv.h"
#pragma hdrstop

#include "lnkcon.h"

HBITMAP g_hbmTT = NULL; // handle of TT logo bitmap
BITMAP  g_bmTT;          // attributes of TT source bitmap
int g_dyFacelistItem = 0;


/* ----- Prototypes ----- */

int FontListCreate(
    CONSOLEPROP_DATA * pcpd,
    HWND hDlg,
    LPTSTR ptszTTFace,
    UINT cchTTFace,
    BOOL bNewFaceList
    );

BOOL ConsolePreviewUpdate(
    CONSOLEPROP_DATA * pcpd,
    HWND hDlg,
    BOOL bLB
    );

int SelectCurrentSize(
    CONSOLEPROP_DATA * pcpd,
    HWND hDlg,
    BOOL bLB,
    int FontIndex);

BOOL ConsolePreviewInit(
    CONSOLEPROP_DATA * pcpd,
    HWND hDlg,
    BOOL* pfRaster);

VOID ConsoleDrawItemFontList(
    CONSOLEPROP_DATA * pcpd,
    const LPDRAWITEMSTRUCT lpdis);

/* ----- Globals ----- */

const TCHAR g_szPreviewText[] = \
    TEXT("C:\\WINDOWS> dir                       \n") \
    TEXT("SYSTEM       <DIR>     10-01-99   5:00a\n") \
    TEXT("SYSTEM32     <DIR>     10-01-99   5:00a\n") \
    TEXT("README   TXT     26926 10-01-99   5:00a\n") \
    TEXT("WINDOWS  BMP     46080 10-01-99   5:00a\n") \
    TEXT("NOTEPAD  EXE    337232 10-01-99   5:00a\n") \
    TEXT("CLOCK    AVI     39594 10-01-99   5:00p\n") \
    TEXT("WIN      INI      7005 10-01-99   5:00a\n");

// Context-sensitive help ids

const static DWORD rgdwHelpFont[] = {
    IDC_CNSL_PREVIEWLABEL,  IDH_DOS_FONT_WINDOW_PREVIEW,
    IDC_CNSL_PREVIEWWINDOW, IDH_DOS_FONT_WINDOW_PREVIEW,
    IDC_CNSL_STATIC,        IDH_CONSOLE_FONT_FONT,
    IDC_CNSL_FACENAME,      IDH_CONSOLE_FONT_FONT,
    IDC_CNSL_FONTSIZE,      IDH_DOS_FONT_SIZE,
    IDC_CNSL_PIXELSLIST,    IDH_DOS_FONT_SIZE,
    IDC_CNSL_POINTSLIST,    IDH_DOS_FONT_SIZE,
    IDC_CNSL_BOLDFONT,      IDH_CONSOLE_FONT_BOLD_FONTS,
    IDC_CNSL_GROUP,         IDH_DOS_FONT_FONT_PREVIEW,
    IDC_CNSL_STATIC2,       IDH_DOS_FONT_FONT_PREVIEW,
    IDC_CNSL_STATIC3,       IDH_DOS_FONT_FONT_PREVIEW,
    IDC_CNSL_STATIC4,       IDH_DOS_FONT_FONT_PREVIEW,
    IDC_CNSL_FONTWIDTH,     IDH_DOS_FONT_FONT_PREVIEW,
    IDC_CNSL_FONTHEIGHT,    IDH_DOS_FONT_FONT_PREVIEW,
    IDC_CNSL_FONTWINDOW,    IDH_DOS_FONT_FONT_PREVIEW,
    0, 0
};

// selelct font based on the current code page
BOOL
SelectCurrentFont(
    CONSOLEPROP_DATA * pcpd,
    HWND hDlg,
    int FontIndex
    );

// Globals strings loaded from resource
TCHAR tszSelectedFont[CCH_SELECTEDFONT+1];
TCHAR tszRasterFonts[CCH_RASTERFONTS+1];


BOOL
CALLBACK
_FontDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the font selection dialog box.
    Returns the near offset into the far table of LOGFONT structures.

--*/

{
    HWND hWndFocus;
    HWND hWndList;
    int FontIndex;
    BOOL bLB;
    TEXTMETRIC tm;
    HDC hDC;
    LINKDATA * pld = (LINKDATA *)GetWindowLongPtr(hDlg, DWLP_USER);
    HRESULT hr;

    switch (wMsg) {
    case WM_INITDIALOG:
        pld = (LINKDATA *)((PROPSHEETPAGE *)lParam)->lParam;

        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pld);
        pld->cpd.bFontInit = FALSE;

        SendDlgItemMessage(hDlg, IDC_CNSL_PREVIEWWINDOW, CM_PREVIEW_INIT, 0, (LPARAM)&pld->cpd );
        SendDlgItemMessage(hDlg, IDC_CNSL_PREVIEWWINDOW, CM_PREVIEW_UPDATE, 0, 0 );

        /*
         * Load the font description strings
         */
        LoadString(HINST_THISDLL, IDS_CNSL_RASTERFONT,
                   tszRasterFonts, NELEM(tszRasterFonts));
        ASSERT(lstrlen(tszRasterFonts) < CCH_RASTERFONTS);

        LoadString(g_hinst, IDS_CNSL_SELECTEDFONT,
                   tszSelectedFont, NELEM(tszSelectedFont));
        ASSERT(lstrlen(tszSelectedFont) < CCH_SELECTEDFONT);

        /* Save current font size as dialog window's user data */
        if (IsFarEastCP(pld->cpd.uOEMCP))
        {
            // Assigning different value when we run on FarEast codepage
            pld->cpd.FontLong =
                      MAKELONG(pld->cpd.FontInfo[pld->cpd.CurrentFontIndex].tmCharSet,
                               pld->cpd.FontInfo[pld->cpd.CurrentFontIndex].Size.Y);
        }
        else
        {
            pld->cpd.FontLong =
                      MAKELONG(pld->cpd.FontInfo[pld->cpd.CurrentFontIndex].Size.X,
                               pld->cpd.FontInfo[pld->cpd.CurrentFontIndex].Size.Y);
        }

        /* Create the list of suitable fonts */
        pld->cpd.gbEnumerateFaces = TRUE;
        bLB = !TM_IS_TT_FONT(pld->cpd.lpConsole->uFontFamily);
        pld->cpd.gbBold = IS_BOLD(pld->cpd.lpConsole->uFontWeight);
        CheckDlgButton(hDlg, IDC_CNSL_BOLDFONT, pld->cpd.gbBold);
        FontListCreate(&pld->cpd, hDlg, bLB ? NULL : pld->cpd.lpFaceName, ARRAYSIZE(pld->cpd.lpFaceName), TRUE);

        /* Initialize the preview window - selects current face & size too */
        if (ConsolePreviewInit(&pld->cpd, hDlg, &bLB))
        {
            ConsolePreviewUpdate(&pld->cpd, hDlg, bLB);

            /* Make sure the list box has the focus */
            hWndList = GetDlgItem(hDlg, bLB ? IDC_CNSL_PIXELSLIST : IDC_CNSL_POINTSLIST);
            SetFocus(hWndList);
            pld->cpd.bFontInit = TRUE;
        }
        else
        {
            EndDialog(hDlg, IDCANCEL);
        }
        break;

    case WM_FONTCHANGE:
        pld->cpd.gbEnumerateFaces = TRUE;
        bLB = !TM_IS_TT_FONT(pld->cpd.lpConsole->uFontFamily);
        FontListCreate(&pld->cpd, hDlg, NULL, 0, TRUE);
        FontIndex = FindCreateFont(&pld->cpd,
                                   pld->cpd.lpConsole->uFontFamily,
                                   pld->cpd.lpFaceName,
                                   pld->cpd.lpConsole->dwFontSize,
                                   pld->cpd.lpConsole->uFontWeight);
        SelectCurrentSize(&pld->cpd, hDlg, bLB, FontIndex);
        return TRUE;

    case WM_PAINT:
        // fChangeCodePage can be TRUE only on FE codepage
        if (pld->cpd.fChangeCodePage)
        {
            pld->cpd.fChangeCodePage = FALSE;

            /* Create the list of suitable fonts */
            bLB = !TM_IS_TT_FONT(pld->cpd.lpConsole->uFontFamily);
            FontIndex = FontListCreate(&pld->cpd, hDlg, !bLB ? NULL : pld->cpd.lpFaceName, ARRAYSIZE(pld->cpd.lpFaceName), TRUE);
            FontIndex = FontListCreate(&pld->cpd, hDlg, bLB ? NULL : pld->cpd.lpFaceName, ARRAYSIZE(pld->cpd.lpFaceName), TRUE);
            pld->cpd.CurrentFontIndex = FontIndex;

            FontIndex = SelectCurrentSize(&pld->cpd, hDlg, bLB, FontIndex);
            SelectCurrentFont(&pld->cpd, hDlg, FontIndex);

            ConsolePreviewUpdate(&pld->cpd, hDlg, bLB);
        }
        break;

    case WM_HELP:               /* F1 or title-bar help button */
        WinHelp( (HWND) ((LPHELPINFO) lParam)->hItemHandle,
                 NULL,
                 HELP_WM_HELP,
                 (ULONG_PTR) (LPVOID) &rgdwHelpFont[0]
                );
        break;

    case WM_CONTEXTMENU:        /* right mouse click */
        WinHelp( (HWND) wParam,
                 NULL,
                 HELP_CONTEXTMENU,
                 (ULONG_PTR) (LPTSTR) &rgdwHelpFont[0]
                );
        break;


    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CNSL_BOLDFONT:
            pld->cpd.gbBold = IsDlgButtonChecked(hDlg, IDC_CNSL_BOLDFONT);
            pld->cpd.bConDirty = TRUE;
            goto RedoFontListAndPreview;

        case IDC_CNSL_FACENAME:
            switch (HIWORD(wParam))
            {
            case LBN_SELCHANGE:
RedoFontListAndPreview:
                if (pld->cpd.bFontInit)
                    PropSheet_Changed( GetParent( hDlg ), hDlg );
                {
                    TCHAR atchNewFace[LF_FACESIZE];
                    LRESULT l;

                    l = SendDlgItemMessage(hDlg, IDC_CNSL_FACENAME, LB_GETCURSEL, 0, 0L);
                    bLB = (BOOL) SendDlgItemMessage(hDlg, IDC_CNSL_FACENAME, LB_GETITEMDATA, l, 0L);
                    if (!bLB) {
                        UINT cch = (UINT)SendDlgItemMessage(hDlg, IDC_CNSL_FACENAME, LB_GETTEXTLEN, l, 0);
                        if (cch < ARRAYSIZE(atchNewFace))
                        {
                            SendDlgItemMessage(hDlg, IDC_CNSL_FACENAME, LB_GETTEXT, l, (LPARAM)atchNewFace);
                        }
                        else
                        {
                            atchNewFace[0] = TEXT('\0');
                        }
                    }
                    FontIndex = FontListCreate(&pld->cpd, hDlg, bLB ? NULL : atchNewFace, ARRAYSIZE(atchNewFace), FALSE);
                    FontIndex = SelectCurrentSize(&pld->cpd, hDlg, bLB, FontIndex);
                    ConsolePreviewUpdate(&pld->cpd, hDlg, bLB);
                    pld->cpd.bConDirty = TRUE;
                    return TRUE;
                }
            }
            break;

        case IDC_CNSL_POINTSLIST:
            switch (HIWORD(wParam)) {
            case CBN_SELCHANGE:
                if (pld->cpd.bFontInit)
                    PropSheet_Changed( GetParent( hDlg ), hDlg );
                ConsolePreviewUpdate(&pld->cpd, hDlg, FALSE);
                pld->cpd.bConDirty = TRUE;
                return TRUE;

            case CBN_KILLFOCUS:
                if (!pld->cpd.gbPointSizeError) {
                    hWndFocus = GetFocus();
                    if (hWndFocus != NULL && IsChild(hDlg, hWndFocus) &&
                        hWndFocus != GetDlgItem(hDlg, IDCANCEL)) {
                        ConsolePreviewUpdate(&pld->cpd, hDlg, FALSE);
                    }
                }
                return TRUE;

            default:
                break;
            }
            break;

        case IDC_CNSL_PIXELSLIST:
            switch (HIWORD(wParam)) {
            case LBN_SELCHANGE:
                if (pld->cpd.bFontInit)
                    PropSheet_Changed( GetParent( hDlg ), hDlg );
                ConsolePreviewUpdate(&pld->cpd, hDlg, TRUE);
                pld->cpd.bConDirty = TRUE;
                return TRUE;

            default:
                break;
            }
            break;

        default:
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) 
        {

        case PSN_APPLY:
            // Write out the state values and exit.
            if (FAILED(SaveLink(pld)))
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            break;

        case PSN_KILLACTIVE:
            //
            // If the TT combo box is visible, update selection
            //
            hWndList = GetDlgItem(hDlg, IDC_CNSL_POINTSLIST);
            if (hWndList != NULL && IsWindowVisible(hWndList)) {
                if (!ConsolePreviewUpdate(&pld->cpd, hDlg, FALSE)) {
                    SetDlgMsgResult(hDlg, PSN_KILLACTIVE, TRUE);
                    return TRUE;
                }
                SetDlgMsgResult(hDlg, PSN_KILLACTIVE, FALSE);
            }

            FontIndex = pld->cpd.CurrentFontIndex;

            if (pld->cpd.FontInfo[FontIndex].SizeWant.Y == 0) {
                // Raster Font, so save actual size
                pld->cpd.lpConsole->dwFontSize = pld->cpd.FontInfo[FontIndex].Size;
            } else {
                // TT Font, so save desired size
                pld->cpd.lpConsole->dwFontSize = pld->cpd.FontInfo[FontIndex].SizeWant;
            }

            pld->cpd.lpConsole->uFontWeight = pld->cpd.FontInfo[FontIndex].Weight;
            pld->cpd.lpConsole->uFontFamily = pld->cpd.FontInfo[FontIndex].Family;

            hr = StringCchCopy(pld->cpd.lpFaceName, ARRAYSIZE(pld->cpd.lpFaceName), pld->cpd.FontInfo[FontIndex].FaceName);
            if (FAILED(hr))
            {
                pld->cpd.lpFaceName[0] = TEXT('\0');
            }
            return TRUE;

        }
        break;

    /*
     *  For WM_MEASUREITEM and WM_DRAWITEM, since there is only one
     *  owner-draw item (combobox) in the entire dialog box, we don't have
     *  to do a GetDlgItem to figure out who he is.
     */
    case WM_MEASUREITEM:
        /*
         * Load the TrueType logo bitmap
         */
        if (g_hbmTT == NULL)
        {
            g_hbmTT = LoadBitmap(NULL, MAKEINTRESOURCE(OBM_TRUETYPE));
            if (g_hbmTT)
            {
                if (!GetObject(g_hbmTT, sizeof(BITMAP), &g_bmTT))
                {
                    DeleteObject(g_hbmTT);
                    g_hbmTT = NULL;
                }
            }
        }

        /*
         * Compute the height of face name listbox entries
         */
        if (g_dyFacelistItem == 0) {
            HFONT hFont;
            hDC = GetDC(hDlg);
            if (hDC)
            {
                hFont = GetWindowFont(hDlg);
                if (hFont) {
                    hFont = SelectObject(hDC, hFont);
                }
                GetTextMetrics(hDC, &tm);
                if (hFont) {
                    SelectObject(hDC, hFont);
                }
                ReleaseDC(hDlg, hDC);

                g_dyFacelistItem = max(tm.tmHeight, g_bmTT.bmHeight);
            }
            else
            {
                // We just failed GetDC: Low memory - we might look corrupted here, but its
                // better than using a null DC or bad textmetrics structure. Prefix 98166
                g_dyFacelistItem = g_bmTT.bmHeight;
            }
        }
        ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = g_dyFacelistItem;
        return TRUE;

    case WM_DRAWITEM:
        ConsoleDrawItemFontList(&pld->cpd, (LPDRAWITEMSTRUCT)lParam);
        return TRUE;

    case WM_DESTROY:

        /*
         * Delete the TrueType logo bitmap
         */
        if (g_hbmTT != NULL) {
            DeleteObject(g_hbmTT);
            g_hbmTT = NULL;
        }
        return TRUE;

    default:
        break;
    }
    return FALSE;
}


int
FontListCreate(
    CONSOLEPROP_DATA * pcpd,
    HWND hDlg,
    LPTSTR ptszTTFace,
    UINT cchTTFace,
    BOOL bNewFaceList
    )

/*++

    Initializes the font list by enumerating all fonts and picking the
    proper ones for our list.

    Returns
        FontIndex of selected font (LB_ERR if none)
--*/

{
    TCHAR tszText[80];
    LONG lListIndex;
    ULONG i;
    HWND hWndShow;      // List or Combo box
    HWND hWndHide;    // Combo or List box
    HWND hWndFaceCombo;
    BOOL bLB;
    int LastShowX = 0;
    int LastShowY = 0;
    int nSameSize = 0;
    UINT CodePage = pcpd->lpFEConsole->uCodePage;
    BOOL fDbcsCharSet = IS_ANY_DBCS_CHARSET( CodePageToCharSet( CodePage ) );
    BOOL fFESystem = IsFarEastCP(pcpd->uOEMCP);
    BOOL fFindTTFont = FALSE;
    LPTSTR ptszAltTTFace = NULL;
    DWORD dwExStyle = 0L;
    bLB = ((ptszTTFace == NULL) || (ptszTTFace[0] == TEXT('\0')));
    if (! bLB) {
        if (IsAvailableTTFont(pcpd, ptszTTFace)) {
            ptszAltTTFace = GetAltFaceName(pcpd, ptszTTFace);
        }
        else {
            ptszAltTTFace = ptszTTFace;
        }
    }

    /*
     * This only enumerates face names if necessary, and
     * it only enumerates font sizes if necessary
     */
    if (STATUS_SUCCESS != EnumerateFonts(pcpd, bLB ? EF_OEMFONT : EF_TTFONT))
    {
        return LB_ERR;
    }

    /* init the TTFaceNames */


    if (bNewFaceList) {
        FACENODE *panFace;
        hWndFaceCombo = GetDlgItem(hDlg, IDC_CNSL_FACENAME);

        SendMessage(hWndFaceCombo, LB_RESETCONTENT, 0, 0);

        lListIndex = (LONG) SendMessage(hWndFaceCombo, LB_ADDSTRING, 0, (LPARAM)tszRasterFonts);
        SendMessage(hWndFaceCombo, LB_SETITEMDATA, lListIndex, TRUE);
        for (panFace = pcpd->gpFaceNames; panFace; panFace = panFace->pNext) {
            if ((panFace->dwFlag & (EF_TTFONT|EF_NEW)) != (EF_TTFONT|EF_NEW)) {
                continue;
            }
            if (!fDbcsCharSet && (panFace->dwFlag & EF_DBCSFONT)) {
                continue;
            }

            if ( ( fDbcsCharSet && IsAvailableTTFontCP(pcpd, panFace->atch, CodePage)) ||
                 ( !fDbcsCharSet && IsAvailableTTFontCP(pcpd, panFace->atch, 0)))
            {

                if ( !bLB &&
                     (lstrcmp(ptszTTFace, panFace->atch) == 0 ||
                      lstrcmp(ptszAltTTFace, panFace->atch) == 0)
                   )
                    fFindTTFont = TRUE;

                lListIndex = (LONG) SendMessage(hWndFaceCombo, LB_ADDSTRING, 0,
                                        (LPARAM)panFace->atch);
                SendMessage(hWndFaceCombo, LB_SETITEMDATA, lListIndex, FALSE);
            }
        }

        if (! bLB && ! fFindTTFont)
        {
            for (panFace = pcpd->gpFaceNames; panFace; panFace = panFace->pNext) {
                if ((panFace->dwFlag & (EF_TTFONT|EF_NEW)) != (EF_TTFONT|EF_NEW)) {
                    continue;
                }
                if ( !fDbcsCharSet && (panFace->dwFlag & EF_DBCSFONT)) {
                    continue;
                }

                if ( (  fDbcsCharSet && IsAvailableTTFontCP(pcpd, panFace->atch, CodePage)) ||
                     (! fDbcsCharSet && IsAvailableTTFontCP(pcpd, panFace->atch, 0))
                   )
                {

                    if (lstrcmp(ptszTTFace, panFace->atch) != 0)
                    {
                        HRESULT hr = StringCchCopy(ptszTTFace, cchTTFace, panFace->atch);
                        if (FAILED(hr))
                        {
                            ptszTTFace[0] = TEXT('\0');
                        }
                        break;
                    }
                }
            }
        }
    } // bNewFaceList == TRUE

    hWndShow = GetDlgItem(hDlg, IDC_CNSL_BOLDFONT);

    // Disable bold font if that will be GDI simulated
    if ( fDbcsCharSet && IsDisableBoldTTFont(pcpd, ptszTTFace) )
    {
        EnableWindow(hWndShow, FALSE);
        pcpd->gbBold = FALSE;
        CheckDlgButton(hDlg, IDC_CNSL_BOLDFONT, FALSE);
    }
    else
    {
        CheckDlgButton(hDlg, IDC_CNSL_BOLDFONT, (bLB || !pcpd->gbBold) ? FALSE : TRUE);
        EnableWindow(hWndShow, bLB ? FALSE : TRUE);
    }

    hWndHide = GetDlgItem(hDlg, bLB ? IDC_CNSL_POINTSLIST : IDC_CNSL_PIXELSLIST);
    ShowWindow(hWndHide, SW_HIDE);
    EnableWindow(hWndHide, FALSE);

    hWndShow = GetDlgItem(hDlg, bLB ? IDC_CNSL_PIXELSLIST : IDC_CNSL_POINTSLIST);
//    hStockFont = GetStockObject(SYSTEM_FIXED_FONT);
//    SendMessage(hWndShow, WM_SETFONT, (DWORD)hStockFont, FALSE);
    ShowWindow(hWndShow, SW_SHOW);
    EnableWindow(hWndShow, TRUE);

    if (bNewFaceList)
    {
        lcbRESETCONTENT(hWndShow, bLB);
    }
    dwExStyle = GetWindowLong(hWndShow, GWL_EXSTYLE);
    if(dwExStyle & RTL_MIRRORED_WINDOW)
    {
        // if mirrored RTL Reading means LTR !!
        SetWindowBits(hWndShow, GWL_EXSTYLE, WS_EX_RTLREADING, WS_EX_RTLREADING);
    }
    /* Initialize hWndShow list/combo box */

    for (i=0;i<pcpd->NumberOfFonts;i++) {
        int ShowX, ShowY;

        if (!bLB == !TM_IS_TT_FONT(pcpd->FontInfo[i].Family)) {
            continue;
        }

        if (fDbcsCharSet) {
            if (! IS_ANY_DBCS_CHARSET(pcpd->FontInfo[i].tmCharSet)) {
                continue;
            }
        }
        else {
            if (IS_ANY_DBCS_CHARSET(pcpd->FontInfo[i].tmCharSet)) {
                continue;
            }
        }

        if (!bLB) {
            if (lstrcmp(pcpd->FontInfo[i].FaceName, ptszTTFace) != 0 &&
                lstrcmp(pcpd->FontInfo[i].FaceName, ptszAltTTFace) != 0) {
                /*
                 * A TrueType font, but not the one we're interested in,
                 * so don't add it to the list of point sizes.
                 */
                continue;
            }
            if (pcpd->gbBold != IS_BOLD(pcpd->FontInfo[i].Weight)) {
                continue;
            }
        }

        if (pcpd->FontInfo[i].SizeWant.X > 0) {
            ShowX = pcpd->FontInfo[i].SizeWant.X;
        } else {
            ShowX = pcpd->FontInfo[i].Size.X;
        }
        if (pcpd->FontInfo[i].SizeWant.Y > 0) {
            ShowY = pcpd->FontInfo[i].SizeWant.Y;
        } else {
            ShowY = pcpd->FontInfo[i].Size.Y;
        }
        /*
         * Add the size description string to the end of the right list
         */
        if (TM_IS_TT_FONT(pcpd->FontInfo[i].Family)) {
            // point size
            StringCchPrintf(tszText, ARRAYSIZE(tszText), TEXT("%2d"), pcpd->FontInfo[i].SizeWant.Y);    // ok to truncate - for display only
        } else {
            // pixel size
            if ((LastShowX == ShowX) && (LastShowY == ShowY)) {
                nSameSize++;
            } else {
                LastShowX = ShowX;
                LastShowY = ShowY;
                nSameSize = 0;
            }

            /*
             * The number nSameSize is appended to the string to distinguish
             * between Raster fonts of the same size.  It is not intended to
             * be visible and exists off the edge of the list
             */

            if(((dwExStyle & WS_EX_RIGHT) && !(dwExStyle & RTL_MIRRORED_WINDOW))
                || (!(dwExStyle & WS_EX_RIGHT) && (dwExStyle & RTL_MIRRORED_WINDOW))) {
                // flip  it so that the hidden part be at the far left
                StringCchPrintf(tszText, ARRAYSIZE(tszText), TEXT("#%d                %2d x %2d"),
                         nSameSize, ShowX, ShowY);  // ok to truncate - for display only
            } else {
                StringCchPrintf(tszText, ARRAYSIZE(tszText), TEXT("%2d x %2d                #%d"),
                         ShowX, ShowY, nSameSize);  // ok to truncate - for display only
            }
        }
        lListIndex = (LONG) lcbFINDSTRINGEXACT(hWndShow, bLB, tszText);
        if (lListIndex == LB_ERR) {
            lListIndex = (LONG) lcbADDSTRING(hWndShow, bLB, tszText);
        }
        lcbSETITEMDATA(hWndShow, bLB, (DWORD)lListIndex, i);
    }

    /*
     * Get the FontIndex from the currently selected item.
     * (i will be LB_ERR if no currently selected item).
     */
    lListIndex = (LONG) lcbGETCURSEL(hWndShow, bLB);
    i = (int) lcbGETITEMDATA(hWndShow, bLB, lListIndex);

    return i;
}


/** ConsoleDrawItemFontList
 *
 *  Answer the WM_DRAWITEM message sent from the font list box or
 *  facename list box.
 *
 *  Entry:
 *      lpdis     -> DRAWITEMSTRUCT describing object to be drawn
 *
 *  Returns:
 *      None.
 *
 *      The object is drawn.
 */
VOID WINAPI
ConsoleDrawItemFontList(CONSOLEPROP_DATA * pcpd, const LPDRAWITEMSTRUCT lpdis)
{
    HDC     hDC, hdcMem;
    DWORD   rgbBack, rgbText, rgbFill;
    TCHAR   tszFace[LF_FACESIZE];
    HBITMAP hOld;
    int     dy;
    HBRUSH  hbrFill;
    HWND    hWndItem;
    BOOL    bLB;
    int     dxttbmp;

    if ((int)lpdis->itemID < 0)
        return;

    hDC = lpdis->hDC;

    if (lpdis->itemAction & ODA_FOCUS) {
        if (lpdis->itemState & ODS_SELECTED) {
            DrawFocusRect(hDC, &lpdis->rcItem);
        }
    } else {
        UINT cch;

        if (lpdis->itemState & ODS_SELECTED) {
            rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
            rgbBack = SetBkColor(hDC, rgbFill = GetSysColor(COLOR_HIGHLIGHT));
        } else {
            rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
            rgbBack = SetBkColor(hDC, rgbFill = GetSysColor(COLOR_WINDOW));
        }
        // draw selection background
        hbrFill = CreateSolidBrush(rgbFill);
        if (hbrFill) {
            FillRect(hDC, &lpdis->rcItem, hbrFill);
            DeleteObject(hbrFill);
        }

        // get the string
        if (IsWindow(hWndItem = lpdis->hwndItem) == FALSE) {
            return;
        }
        cch = (UINT)SendMessage(hWndItem, LB_GETTEXTLEN, lpdis->itemID, 0);
        if (cch < ARRAYSIZE(tszFace))
        {
            SendMessage(hWndItem, LB_GETTEXT, lpdis->itemID, (LPARAM)tszFace);
        }
        else
        {
            tszFace[0] = TEXT('\0');
        }
        bLB = (BOOL) SendMessage(hWndItem, LB_GETITEMDATA, lpdis->itemID, 0L);
        dxttbmp = bLB ? 0 : g_bmTT.bmWidth;


        // draw the text
        TabbedTextOut(hDC, lpdis->rcItem.left + dxttbmp,
                      lpdis->rcItem.top, tszFace,
                      lstrlen(tszFace), 0, NULL, dxttbmp);

        // and the TT bitmap if needed
        if (!bLB) {
            hdcMem = CreateCompatibleDC(hDC);
            if (hdcMem) {
                hOld = SelectObject(hdcMem, g_hbmTT);

                dy = ((lpdis->rcItem.bottom - lpdis->rcItem.top) - g_bmTT.bmHeight) / 2;

                BitBlt(hDC, lpdis->rcItem.left, lpdis->rcItem.top + dy,
                       dxttbmp, g_dyFacelistItem, hdcMem,
                       0, 0, SRCINVERT);

                if (hOld)
                    SelectObject(hdcMem, hOld);
                DeleteDC(hdcMem);
            }
        }

        SetTextColor(hDC, rgbText);
        SetBkColor(hDC, rgbBack);

        if (lpdis->itemState & ODS_FOCUS) {
            DrawFocusRect(hDC, &lpdis->rcItem);
        }
    }
}


UINT
GetPointSizeInRange(
   HWND hDlg,
   INT Min,
   INT Max)
/*++

Routine Description:

   Get a size from the Point Size ComboBox edit field

Return Value:

   Point Size - of the edit field limited by Min/Max size
   0 - if the field is empty or invalid

--*/

{
    TCHAR szBuf[90];
    int nTmp = 0;
    BOOL bOK;

    if (GetDlgItemText(hDlg, IDC_CNSL_POINTSLIST, szBuf, NELEM(szBuf))) {
        nTmp = GetDlgItemInt(hDlg, IDC_CNSL_POINTSLIST, &bOK, TRUE);
        if (bOK && nTmp >= Min && nTmp <= Max) {
            return nTmp;
        }
    }

    return 0;
}


/* ----- Preview routines ----- */

LRESULT
_FontPreviewWndProc(
    HWND hWnd,
    UINT wMessage,
    WPARAM wParam,
    LPARAM lParam
    )

/*  FontPreviewWndProc
 *      Handles the font preview window
 */

{
    PAINTSTRUCT ps;
    RECT rect;
    HBRUSH hbrClient;
    HBRUSH hbrOld;
    COLORREF rgbText;
    COLORREF rgbBk;

    CONSOLEPROP_DATA * pcpd = (CONSOLEPROP_DATA *)GetWindowLongPtr( hWnd, GWLP_USERDATA );

    switch (wMessage) {
    case WM_CREATE:
        pcpd = (CONSOLEPROP_DATA *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr( hWnd, GWLP_USERDATA, (LPARAM)pcpd );
        break;

    case WM_PAINT:
        BeginPaint(hWnd, &ps);

        /* Draw the font sample */
        rgbText = GetNearestColor(ps.hdc, ScreenTextColor(pcpd));
        rgbBk = GetNearestColor(ps.hdc, ScreenBkColor(pcpd));
        SelectObject(ps.hdc, pcpd->FontInfo[pcpd->CurrentFontIndex].hFont);
        SetTextColor(ps.hdc, rgbText);
        SetBkColor(ps.hdc, rgbBk);
        GetClientRect(hWnd, &rect);
        InflateRect(&rect, -2, -2);
        hbrClient = CreateSolidBrush(rgbBk);
        if (hbrClient)
            hbrOld = SelectObject(ps.hdc, hbrClient);
        PatBlt(ps.hdc, rect.left, rect.top,
                rect.right - rect.left, rect.bottom - rect.top,
                PATCOPY);
        DrawText(ps.hdc, g_szPreviewText, -1, &rect, 0);
        if (hbrClient)
        {
            SelectObject(ps.hdc, hbrOld);
            DeleteObject(hbrClient);
        }

        EndPaint(hWnd, &ps);
        break;

    default:
        return DefWindowProc(hWnd, wMessage, wParam, lParam);
    }
    return 0L;
}



/*
 * SelectCurrentSize - Select the right line of the Size listbox/combobox.
 *   bLB       : Size controls is a listbox (TRUE for RasterFonts)
 *   FontIndex : Index into FontInfo[] cache
 *               If < 0 then choose a good font.
 * Returns
 *   FontIndex : Index into FontInfo[] cache
 */
int
SelectCurrentSize(CONSOLEPROP_DATA * pcpd, HWND hDlg, BOOL bLB, int FontIndex)
{
    int iCB;
    HWND hWndList;


    hWndList = GetDlgItem(hDlg, bLB ? IDC_CNSL_PIXELSLIST : IDC_CNSL_POINTSLIST);
    iCB = (int) lcbGETCOUNT(hWndList, bLB);

    if (FontIndex >= 0) {
        /*
         * look for FontIndex
         */
        while (iCB > 0) {
            iCB--;
            if (lcbGETITEMDATA(hWndList, bLB, iCB) == FontIndex) {
                lcbSETCURSEL(hWndList, bLB, iCB);
                break;
            }
        }
    } else {
        /*
         * look for a reasonable default size: looking backwards, find
         * the first one same height or smaller.
         */
        DWORD Size;
        Size = pcpd->FontLong;
        if (IsFarEastCP(pcpd->uOEMCP) & bLB
            && (pcpd->FontInfo[pcpd->CurrentFontIndex].tmCharSet != LOBYTE(LOWORD(Size)))
           )
        {
            TCHAR AltFaceName[LF_FACESIZE];
            COORD AltFontSize;
            BYTE  AltFontFamily;
            ULONG AltFontIndex = 0;

            MakeAltRasterFont(pcpd, pcpd->lpFEConsole->uCodePage, &AltFontSize, &AltFontFamily, &AltFontIndex, AltFaceName, ARRAYSIZE(AltFaceName));

            while(iCB > 0) {
                iCB--;
                if (lcbGETITEMDATA(hWndList, bLB, iCB) == (int)AltFontIndex) {
                    lcbSETCURSEL(hWndList, bLB, iCB);
                    break;
                }
            }
        }
        else
        {
            while (iCB > 0) {
                iCB--;
                FontIndex = (ULONG) lcbGETITEMDATA(hWndList, bLB, iCB);
                if (pcpd->FontInfo[FontIndex].Size.Y <= HIWORD(Size)) {
                    lcbSETCURSEL(hWndList, bLB, iCB);
                    break;
                }
            }
        }
    }
    return FontIndex;
}


BOOL
SelectCurrentFont(CONSOLEPROP_DATA * pcpd, HWND hDlg, int FontIndex)
{
    BOOL bLB;


    bLB = !TM_IS_TT_FONT(pcpd->FontInfo[FontIndex].Family);

    SendDlgItemMessage(hDlg, IDC_CNSL_FACENAME, LB_SELECTSTRING, (DWORD)-1,
            bLB ? (LPARAM)tszRasterFonts : (LPARAM)(pcpd->FontInfo[FontIndex].FaceName));

    SelectCurrentSize(pcpd, hDlg, bLB, FontIndex);
    return bLB;
}


BOOL
ConsolePreviewInit(
    CONSOLEPROP_DATA * pcpd,
    HWND hDlg,
    BOOL* pfRaster
    )

/*  PreviewInit
 *      Prepares the preview code, sizing the window and the dialog to
 *      make an attractive preview.
 *  *pfRaster is TRUE if Raster Fonts, FALSE if TT Font
 *  Returns FALSE on critical failure, TRUE otherwise
 */

{
    HDC hDC;
    TEXTMETRIC tm;
    RECT rectLabel;
    RECT rectGroup;
    int nFont;
    SHORT xChar;
    SHORT yChar;


    /* Get the system char size */
    hDC = GetDC(hDlg);
    if (!hDC)
    {
        // Out of memory; just close the dialog - better than crashing: Prefix 98162
        return FALSE;
    }

    GetTextMetrics(hDC, &tm);
    ReleaseDC(hDlg, hDC);
    xChar = (SHORT) (tm.tmAveCharWidth);
    yChar = (SHORT) (tm.tmHeight + tm.tmExternalLeading);

    /* Compute the size of the font preview */
    GetWindowRect(GetDlgItem(hDlg, IDC_CNSL_GROUP), &rectGroup);
    MapWindowRect(HWND_DESKTOP, hDlg, &rectGroup);
    rectGroup.bottom -= rectGroup.top;
    GetWindowRect(GetDlgItem(hDlg, IDC_CNSL_STATIC2), &rectLabel);
    MapWindowRect(HWND_DESKTOP, hDlg, &rectLabel);


    /* Create the font preview */
    CreateWindowEx(0L, TEXT("WOACnslFontPreview"), NULL,
        WS_CHILD | WS_VISIBLE,
        rectGroup.left + xChar, rectGroup.top + 3 * yChar / 2,
        rectLabel.left - rectGroup.left - 2 * xChar,
        rectGroup.bottom -  2 * yChar,
        hDlg, (HMENU)IDC_CNSL_FONTWINDOW, g_hinst, (LPVOID)pcpd);

    /*
     * Set the current font
     */
    nFont = FindCreateFont(pcpd,
                           pcpd->lpConsole->uFontFamily,
                           pcpd->lpFaceName,
                           pcpd->lpConsole->dwFontSize,
                           pcpd->lpConsole->uFontWeight);

    pcpd->CurrentFontIndex = nFont;

    *pfRaster = SelectCurrentFont(pcpd, hDlg, nFont);
    return TRUE;
}


BOOL
ConsolePreviewUpdate(
    CONSOLEPROP_DATA * pcpd,
    HWND hDlg,
    BOOL bLB
    )

/*++

    Does the preview of the selected font.

--*/

{
    FONT_INFO *lpFont;
    int FontIndex;
    LONG lIndex;
    HWND hWnd;
    TCHAR tszText[60];
    TCHAR tszFace[LF_FACESIZE + CCH_SELECTEDFONT];
    HWND hWndList;


    hWndList = GetDlgItem(hDlg, bLB ? IDC_CNSL_PIXELSLIST : IDC_CNSL_POINTSLIST);

    /* When we select a font, we do the font preview by setting it into
     *  the appropriate list box
     */
    lIndex = (LONG) lcbGETCURSEL(hWndList, bLB);
    if ((lIndex < 0) && !bLB) {
        COORD NewSize;
        UINT cch;

        lIndex = (LONG) SendDlgItemMessage(hDlg, IDC_CNSL_FACENAME, LB_GETCURSEL, 0, 0L);

        cch = (UINT)SendDlgItemMessage(hDlg, IDC_CNSL_FACENAME, LB_GETTEXTLEN, lIndex, 0);
        if (cch < ARRAYSIZE(tszFace))
        {
            SendDlgItemMessage(hDlg, IDC_CNSL_FACENAME, LB_GETTEXT, lIndex, (LPARAM)tszFace);
        }
        else
        {
            tszFace[0] = TEXT('\0');
        }
        NewSize.X = 0;
        NewSize.Y = (SHORT) GetPointSizeInRange(hDlg, MIN_PIXEL_HEIGHT, MAX_PIXEL_HEIGHT);

        if (NewSize.Y == 0) {
            TCHAR tszBuf[60];
            /*
             * Use tszText, tszBuf to put up an error msg for bad point size
             */
            pcpd->gbPointSizeError = TRUE;
            GetWindowText(hDlg, tszBuf, NELEM(tszBuf));
            ShellMessageBox(HINST_THISDLL, hDlg, MAKEINTRESOURCE(IDS_CNSL_FONTSIZE),
                                tszBuf, MB_OK|MB_ICONINFORMATION,
                                MIN_PIXEL_HEIGHT, MAX_PIXEL_HEIGHT);
            SetFocus(hWndList);
            pcpd->gbPointSizeError = FALSE;
            return FALSE;
        }
        FontIndex = FindCreateFont(pcpd,
                                   FF_MODERN|TMPF_VECTOR|TMPF_TRUETYPE,
                                   tszFace, NewSize, 0);
    } else {
        FontIndex = (int) lcbGETITEMDATA(hWndList, bLB, lIndex);
    }

    if (FontIndex < 0) {
        FontIndex = pcpd->DefaultFontIndex;
    }

    /*
     * If we've selected a new font, tell the property sheet we've changed
     */
    if (pcpd->CurrentFontIndex != (ULONG)FontIndex) {
        pcpd->CurrentFontIndex = FontIndex;
    }

    lpFont = &pcpd->FontInfo[FontIndex];

    /* Display the new font */

    StringCchCopy(tszFace, ARRAYSIZE(tszFace), tszSelectedFont);    // ok to truncate - for display only
    StringCchCat(tszFace, ARRAYSIZE(tszFace), lpFont->FaceName);    // ok to truncate - for display only
    SetDlgItemText(hDlg, IDC_CNSL_GROUP, tszFace);

    /* Put the font size in the static boxes */
    StringCchPrintf(tszText, ARRAYSIZE(tszText), TEXT("%u"), lpFont->Size.X);   // ok to truncate - for display only
    hWnd = GetDlgItem(hDlg, IDC_CNSL_FONTWIDTH);
    SetWindowText(hWnd, tszText);
    InvalidateRect(hWnd, NULL, TRUE);
    StringCchPrintf(tszText, ARRAYSIZE(tszText), TEXT("%u"), lpFont->Size.Y);   // ok to truncate - for display only
    hWnd = GetDlgItem(hDlg, IDC_CNSL_FONTHEIGHT);
    SetWindowText(hWnd, tszText);
    InvalidateRect(hWnd, NULL, TRUE);

    /* Force the preview windows to repaint */
    hWnd = GetDlgItem(hDlg, IDC_CNSL_PREVIEWWINDOW);
    SendMessage(hWnd, CM_PREVIEW_UPDATE, 0, 0);
    hWnd = GetDlgItem(hDlg, IDC_CNSL_FONTWINDOW);
    InvalidateRect(hWnd, NULL, TRUE);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\lnkcon.c ===
//
// lnkcon.c       link console property pages implementation
//
//---------------------------------------------------------------------------

#include "shellprv.h"
#pragma hdrstop
#include "lnkcon.h"


LRESULT PreviewWndProc( HWND hWnd, UINT wMessage, WPARAM wParam, LPARAM lParam );

BOOL_PTR CALLBACK _FontDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam );
LRESULT _FontPreviewWndProc( HWND hWnd, UINT wMessage, WPARAM wParam, LPARAM lParam );

extern TCHAR g_szPreviewText[];

// Context-sensitive help ids

const static DWORD rgdwHelpColor[] = {
    IDC_CNSL_COLOR_SCREEN_TEXT,       IDH_CONSOLE_COLOR_SCR_TEXT,
    IDC_CNSL_COLOR_SCREEN_BKGND,      IDH_CONSOLE_COLOR_SCR_BACK,
    IDC_CNSL_COLOR_POPUP_TEXT,        IDH_CONSOLE_COLOR_POPUP_TEXT,
    IDC_CNSL_COLOR_POPUP_BKGND,       IDH_CONSOLE_COLOR_POPUP_BACK,
    IDC_CNSL_COLOR_RED_LBL,           IDH_CONSOLE_COLOR_RED,
    IDC_CNSL_COLOR_RED,               IDH_CONSOLE_COLOR_RED,
    IDC_CNSL_COLOR_GREEN_LBL,         IDH_CONSOLE_COLOR_RED,
    IDC_CNSL_COLOR_GREEN,             IDH_CONSOLE_COLOR_RED,
    IDC_CNSL_COLOR_BLUE_LBL,          IDH_CONSOLE_COLOR_RED,
    IDC_CNSL_COLOR_BLUE,              IDH_CONSOLE_COLOR_RED,
    IDC_CNSL_COLOR_SCREEN_COLORS,     IDH_CONSOLE_COLOR_SCR_COLORS,
    IDC_CNSL_COLOR_SCREEN_COLORS_LBL, IDH_CONSOLE_COLOR_SCR_COLORS,
    IDC_CNSL_COLOR_POPUP_COLORS,      IDH_CONSOLE_COLOR_WIN_COLORS,
    IDC_CNSL_COLOR_POPUP_COLORS_LBL,  IDH_CONSOLE_COLOR_WIN_COLORS,
    IDC_CNSL_COLOR_1,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_2,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_3,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_4,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_5,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_6,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_7,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_8,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_9,                 IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_10,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_11,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_12,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_13,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_14,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_15,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_COLOR_16,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDC_CNSL_GROUP0,                  -1,
    IDC_CNSL_GROUP1,                  -1,
    IDC_CNSL_GROUP2,                  -1,
    0, 0
};


const static DWORD rgdwHelpSettings[] = {
    IDC_CNSL_HISTORY_NUM_LBL,  IDH_CONSOLE_OPTIONS_BUFF_NUM,
    IDC_CNSL_HISTORY_NUM,      IDH_CONSOLE_OPTIONS_BUFF_NUM,
    IDC_CNSL_HISTORY_SIZE_LBL, IDH_CONSOLE_OPTIONS_BUFF_SIZE,
    IDC_CNSL_HISTORY_SIZE,     IDH_CONSOLE_OPTIONS_BUFF_SIZE,
    IDC_CNSL_CURSOR_SMALL,     IDH_CONSOLE_OPTIONS_CURSOR,
    IDC_CNSL_CURSOR_LARGE,     IDH_CONSOLE_OPTIONS_CURSOR,
    IDC_CNSL_CURSOR_MEDIUM,    IDH_CONSOLE_OPTIONS_CURSOR,
    IDC_CNSL_HISTORY_NODUP,    IDH_CONSOLE_OPTIONS_DISCARD_DUPS,
    IDC_CNSL_INSERT,           IDH_CONSOLE_OPTIONS_INSERT,
    IDC_CNSL_QUICKEDIT,        IDH_CONSOLE_OPTIONS_QUICK_EDIT,
    IDC_CNSL_LANGUAGELIST,     IDH_CONSOLE_OPTIONS_LANGUAGE,
    IDC_CNSL_FULLSCREEN,       IDH_DOS_SCREEN_USAGE_FULL,
    IDC_CNSL_WINDOWED,         IDH_DOS_SCREEN_USAGE_WINDOW,
    IDC_CNSL_GROUP0,           -1,
    IDC_CNSL_GROUP1,           -1,
    IDC_CNSL_GROUP2,           -1,
    0, 0
};

const static DWORD rgdwHelpSize[] = {
    IDC_CNSL_SCRBUF_WIDTH_LBL,   IDH_CONSOLE_SIZE_BUFF_WIDTH,
    IDC_CNSL_SCRBUF_WIDTH,       IDH_CONSOLE_SIZE_BUFF_WIDTH,
    IDC_CNSL_SCRBUF_HEIGHT_LBL,  IDH_CONSOLE_SIZE_BUFF_HEIGHT,
    IDC_CNSL_SCRBUF_HEIGHT,      IDH_CONSOLE_SIZE_BUFF_HEIGHT,
    IDC_CNSL_WINDOW_WIDTH_LBL,   IDH_CONSOLE_SIZE_WIN_WIDTH,
    IDC_CNSL_WINDOW_WIDTH,       IDH_CONSOLE_SIZE_WIN_WIDTH,
    IDC_CNSL_WINDOW_HEIGHT_LBL,  IDH_CONSOLE_SIZE_WIN_HEIGHT,
    IDC_CNSL_WINDOW_HEIGHT,      IDH_CONSOLE_SIZE_WIN_HEIGHT,
    IDC_CNSL_WINDOW_POSX_LBL,    IDH_CONSOLE_SIZE_POS_LEFT,
    IDC_CNSL_WINDOW_POSX,        IDH_CONSOLE_SIZE_POS_LEFT,
    IDC_CNSL_WINDOW_POSY_LBL,    IDH_CONSOLE_SIZE_POS_TOP,
    IDC_CNSL_WINDOW_POSY,        IDH_CONSOLE_SIZE_POS_TOP,
    IDC_CNSL_AUTO_POSITION,      IDH_CONSOLE_SIZE_LET_SYS,
    IDC_CNSL_PREVIEWLABEL,       IDH_DOS_FONT_WINDOW_PREVIEW,
    IDC_CNSL_PREVIEWWINDOW,      IDH_DOS_FONT_WINDOW_PREVIEW,
    IDC_CNSL_GROUP0,             -1,
    IDC_CNSL_GROUP1,             -1,
    IDC_CNSL_GROUP2,             -1,
    0, 0
};





#ifdef ADVANCED_PAGE
VOID
_AddEnvVariable(
    HWND hwndLV,
    INT iItem,
    LPTSTR pszVar
    )
{
    TCHAR szTemp[ 1024 ];
    LV_ITEM lvi;
    LPTSTR p;

    for( p = szTemp; *pszVar!=TEXT('='); *p++ = *pszVar++ );
    *p = TEXT('\0');
    pszVar++;

    lvi.mask = LVIF_TEXT;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    lvi.pszText = szTemp;
    SendMessage( hwndLV, LVM_SETITEM, 0, (LPARAM)&lvi );

    for( p=szTemp; *pszVar!=TEXT('\0'); *p++ = *pszVar++ );
    *p = TEXT('\0');
    lvi.mask = LVIF_TEXT;
    lvi.iItem = iItem;
    lvi.iSubItem = 1;
    lvi.pszText = szTemp;
    SendMessage( hwndLV, LVM_SETITEM, 0, (LPARAM)&lvi );

}


BOOL_PTR
CALLBACK
_AdvancedDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the settings dialog box.

--*/

{
    UINT Item;
    HWND hWnd;
    RECT r;
    LV_COLUMN lvc;
    HWND hwndLV;
    LPTSTR pszEnv, pszSave;
    LV_ITEM lvi;
    INT i;

    LINKDATA *pld = (LINKDATA *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg) {
    case WM_INITDIALOG:
        pld = (LINKDATA *)((PROPSHEETPAGE *)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pld);

        // Initialize Columns in listview
        hwndLV = GetDlgItem( hDlg, IDC_CNSL_ADVANCED_LISTVIEW );
        GetClientRect( hwndLV, &r );
        lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvc.fmt = LVCFMT_LEFT;
        lvc.cx = (((r.right - r.left) - GetSystemMetrics(SM_CXVSCROLL)) * 7) / 20;
        lvc.pszText = TEXT("Variable Name");
        ListView_InsertColumn( hwndLV, 0, &lvc );
        lvc.cx = (((r.right - r.left) - GetSystemMetrics(SM_CXVSCROLL)) * 13) / 20;
        lvc.pszText = TEXT("Value");
        ListView_InsertColumn( hwndLV, 1, &lvc );


        ZeroMemory( &lvi, sizeof(lvi) );
        pszSave = pszEnv = GetEnvironmentStrings();
        while (pszEnv && *pszEnv)
        {
            i = SendMessage( hwndLV, LVM_INSERTITEM, 0, (LPARAM)&lvi );
            
            _AddEnvVariable( hwndLV, i, pszEnv );
            
            for( ; *pszEnv; pszEnv++ )
            {
                // do nothing
            }
            pszEnv++;
        }

        FreeEnvironmentStrings( pszSave );
        return TRUE;

    case WM_DESTROY:
        EndDialog( hDlg, TRUE );
        break;

    case WM_COMMAND:
        Item = LOWORD(wParam);

        switch (Item)
        {


        default:
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_APPLY:
            /*
             * Write out the state values and exit.
             */
            if (FAILED(SaveLink(pld)))
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            break;

        case PSN_KILLACTIVE:
            /*
             * Fake the dialog proc into thinking the edit control just
             * lost focus so it'll update properly
             */
            if (Item = GetDlgCtrlID(GetFocus())) {
                SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
            }
            return TRUE;
        }
        break;


    default:
        break;
    }
    return FALSE;
}
#endif // ADVANCED_PAGE

LRESULT
ColorControlProc(
    HWND hColor,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Window proc for the color buttons

--*/

{
    PAINTSTRUCT ps;
    int ColorId;
    RECT rColor;
    RECT rTemp;
    HBRUSH hbr;
    HDC hdc;
    HWND hWnd;
    HWND hDlg;
    COLORREF rgbBrush;

    CONSOLEPROP_DATA * pcpd = (CONSOLEPROP_DATA *)GetWindowLongPtr( hColor, 0 );

    ColorId = GetWindowLong(hColor, GWL_ID);
    hDlg = GetParent(hColor);

    switch (wMsg) {

    case CM_COLOR_INIT:
        SetWindowLongPtr( hColor, 0, lParam );
        break;

    case WM_GETDLGCODE:
        return DLGC_WANTARROWS | DLGC_WANTTAB;
        break;

    case WM_SETFOCUS:
        if (pcpd->ColorArray[pcpd->Index] != (BYTE)(ColorId - IDC_CNSL_COLOR_1)) {
            hWnd = GetDlgItem(hDlg, pcpd->ColorArray[pcpd->Index]+IDC_CNSL_COLOR_1);
            SetFocus(hWnd);
        }
        // Fall through
    case WM_KILLFOCUS:
        hdc = GetDC(hDlg);
        hWnd = GetDlgItem(hDlg, IDC_CNSL_COLOR_1);
        GetWindowRect(hWnd, &rColor);
        hWnd = GetDlgItem(hDlg, IDC_CNSL_COLOR_16);
        GetWindowRect(hWnd, &rTemp);
        rColor.right = rTemp.right;
        ScreenToClient(hDlg, (LPPOINT)&rColor.left);
        ScreenToClient(hDlg, (LPPOINT)&rColor.right);
        InflateRect(&rColor, 2, 2);
        DrawFocusRect(hdc, &rColor);
        ReleaseDC(hDlg, hdc);
        break;

    case WM_KEYDOWN:
        switch (wParam) {
        case VK_UP:
        case VK_LEFT:
            if (ColorId > IDC_CNSL_COLOR_1) {
                SendMessage(hDlg, CM_SETCOLOR,
                            ColorId - 1 - IDC_CNSL_COLOR_1, (LPARAM)hColor);
            }
            break;
        case VK_DOWN:
        case VK_RIGHT:
            if (ColorId < IDC_CNSL_COLOR_16) {
                SendMessage(hDlg, CM_SETCOLOR,
                            ColorId + 1 - IDC_CNSL_COLOR_1, (LPARAM)hColor);
            }
            break;
        case VK_TAB:
            hWnd = GetDlgItem(hDlg, IDC_CNSL_COLOR_1);
            hWnd = GetNextDlgTabItem(hDlg, hWnd, GetKeyState(VK_SHIFT) < 0);
            SetFocus(hWnd);
            break;
        default:
            return DefWindowProc(hColor, wMsg, wParam, lParam);
        }
        break;

    case WM_RBUTTONDOWN:
    case WM_LBUTTONDOWN:
        SendMessage(hDlg, CM_SETCOLOR,
                    ColorId - IDC_CNSL_COLOR_1, (LPARAM)hColor);
        break;

    case WM_PAINT:
        BeginPaint(hColor, &ps);
        GetClientRect(hColor, &rColor);
        rgbBrush = GetNearestColor(ps.hdc, pcpd->lpConsole->ColorTable[ColorId-IDC_CNSL_COLOR_1]);
        if ((hbr = CreateSolidBrush(rgbBrush)) != NULL) {
            //
            // are we the selected color for the current object?
            //
            if (pcpd->ColorArray[pcpd->Index] == (BYTE)(ColorId - IDC_CNSL_COLOR_1)) {

                //
                // put current values in dialog box
                //
                SendDlgItemMessage(hDlg, IDC_CNSL_COLOR_REDSCROLL,   UDM_SETPOS, 0, MAKELONG( GetRValue(AttrToRGB(pcpd->ColorArray[pcpd->Index])),0));
                SendDlgItemMessage(hDlg, IDC_CNSL_COLOR_GREENSCROLL, UDM_SETPOS, 0, MAKELONG( GetGValue(AttrToRGB(pcpd->ColorArray[pcpd->Index])),0));
                SendDlgItemMessage(hDlg, IDC_CNSL_COLOR_BLUESCROLL,  UDM_SETPOS, 0, MAKELONG( GetBValue(AttrToRGB(pcpd->ColorArray[pcpd->Index])),0));

                //
                // highlight the selected color
                //
                FrameRect(ps.hdc, &rColor, GetStockObject(BLACK_BRUSH));
                InflateRect(&rColor, -1, -1);
                FrameRect(ps.hdc, &rColor, GetStockObject(BLACK_BRUSH));
            }
            InflateRect(&rColor, -1, -1);
            FillRect(ps.hdc, &rColor, hbr);
            DeleteObject(hbr);
        }
        EndPaint(hColor, &ps);
        break;

    default:
        return DefWindowProc(hColor, wMsg, wParam, lParam);
        break;
    }
    return TRUE;
}

LRESULT
ColorTextProc(
    HWND hWnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Window proc for the color preview windows

--*/

{
    PAINTSTRUCT ps;
    int ColorId;
    RECT rect;
    HBRUSH hbr;
    HFONT hfT;

    CONSOLEPROP_DATA * pcpd = (CONSOLEPROP_DATA *)GetWindowLongPtr( hWnd, 0 );

    ColorId = GetWindowLong(hWnd, GWL_ID);
    switch (wMsg) {
    case CM_COLOR_INIT:
        SetWindowLongPtr( hWnd, 0, lParam );
        break;
    case WM_PAINT:
        BeginPaint(hWnd, &ps);
        GetClientRect(hWnd, &rect);
        InflateRect(&rect, -2, -2);

        if (ColorId == IDC_CNSL_COLOR_SCREEN_COLORS) {
            SetTextColor(ps.hdc, ScreenTextColor(pcpd));
            SetBkColor(ps.hdc, ScreenBkColor(pcpd));
            hbr = CreateSolidBrush( ScreenBkColor(pcpd) );
        } else {
            SetTextColor(ps.hdc, PopupTextColor(pcpd));
            SetBkColor(ps.hdc, PopupBkColor(pcpd));
            hbr = CreateSolidBrush( PopupBkColor(pcpd) );
        }

        /* Draw the text sample */

        if (hbr)
        {
            FillRect(ps.hdc, &rect, hbr);
            DeleteObject(hbr);
        }

        hfT = SelectObject(ps.hdc, pcpd->FontInfo[pcpd->CurrentFontIndex].hFont);
        DrawText(ps.hdc, g_szPreviewText, -1, &rect, 0);
        SelectObject(ps.hdc, hfT);

        EndPaint(hWnd, &ps);
        break;
    default:
        return DefWindowProc(hWnd, wMsg, wParam, lParam);
        break;
    }
    return TRUE;
}

BOOL_PTR
WINAPI
_ColorDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the color selection dialog box.

--*/

{
    UINT Value;
    UINT Red;
    UINT Green;
    UINT Blue;
    UINT Item;
    HWND hWnd;
    HWND hWndOld;
    BOOL bOK;

    LINKDATA *pld = (LINKDATA *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg) {
    case WM_INITDIALOG:
        pld = (LINKDATA *)((PROPSHEETPAGE *)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pld);
        pld->cpd.bColorInit = FALSE;
        pld->cpd.ColorArray[IDC_CNSL_COLOR_SCREEN_TEXT - IDC_CNSL_COLOR_SCREEN_TEXT] =
                LOBYTE(pld->cpd.lpConsole->wFillAttribute) & 0x0F;
        pld->cpd.ColorArray[IDC_CNSL_COLOR_SCREEN_BKGND - IDC_CNSL_COLOR_SCREEN_TEXT] =
                LOBYTE(pld->cpd.lpConsole->wFillAttribute >> 4);
        pld->cpd.ColorArray[IDC_CNSL_COLOR_POPUP_TEXT - IDC_CNSL_COLOR_SCREEN_TEXT] =
                LOBYTE(pld->cpd.lpConsole->wPopupFillAttribute) & 0x0F;
        pld->cpd.ColorArray[IDC_CNSL_COLOR_POPUP_BKGND - IDC_CNSL_COLOR_SCREEN_TEXT] =
                LOBYTE(pld->cpd.lpConsole->wPopupFillAttribute >> 4);
        CheckRadioButton(hDlg,IDC_CNSL_COLOR_SCREEN_TEXT,IDC_CNSL_COLOR_POPUP_BKGND,IDC_CNSL_COLOR_SCREEN_BKGND);
        pld->cpd.Index = IDC_CNSL_COLOR_SCREEN_BKGND - IDC_CNSL_COLOR_SCREEN_TEXT;

        // initialize color controls
        for (Item=IDC_CNSL_COLOR_1; Item<=IDC_CNSL_COLOR_16; Item++)
            SendDlgItemMessage(hDlg, Item,  CM_COLOR_INIT, 0, (LPARAM)&pld->cpd );

        // initialize text preview controls
        SendDlgItemMessage(hDlg, IDC_CNSL_COLOR_SCREEN_COLORS, CM_COLOR_INIT, 0, (LPARAM)&pld->cpd );
        SendDlgItemMessage(hDlg, IDC_CNSL_COLOR_POPUP_COLORS,  CM_COLOR_INIT, 0, (LPARAM)&pld->cpd );

        // Set ranges & position for updown controls
        SendDlgItemMessage( hDlg, IDC_CNSL_COLOR_REDSCROLL,   UDM_SETRANGE, 0, (LPARAM)MAKELONG( 255, 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_COLOR_GREENSCROLL, UDM_SETRANGE, 0, (LPARAM)MAKELONG( 255, 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_COLOR_BLUESCROLL,  UDM_SETRANGE, 0, (LPARAM)MAKELONG( 255, 0 ) );
#define pcpd (&pld->cpd)
        SendDlgItemMessage( hDlg, IDC_CNSL_COLOR_REDSCROLL,   UDM_SETPOS, 0,
            (LPARAM)MAKELONG(GetRValue(AttrToRGB(pld->cpd.ColorArray[pld->cpd.Index])), 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_COLOR_GREENSCROLL, UDM_SETPOS, 0,
            (LPARAM)MAKELONG(GetGValue(AttrToRGB(pld->cpd.ColorArray[pld->cpd.Index])), 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_COLOR_BLUESCROLL,  UDM_SETPOS, 0,
            (LPARAM)MAKELONG(GetBValue(AttrToRGB(pld->cpd.ColorArray[pld->cpd.Index])), 0 ) );
#undef pcpd
        pld->cpd.bColorInit = TRUE;
        return TRUE;

    //
    // handle help messages
    //


    case WM_HELP:               /* F1 or title-bar help button */
        WinHelp( (HWND) ((LPHELPINFO) lParam)->hItemHandle,
                 NULL,
                 HELP_WM_HELP,
                 (ULONG_PTR) (LPVOID) &rgdwHelpColor[0]
                );
        break;

    case WM_CONTEXTMENU:        /* right mouse click */
        WinHelp( (HWND) wParam,
                 NULL,
                 HELP_CONTEXTMENU,
                 (ULONG_PTR) (LPVOID) &rgdwHelpColor[0]
                );
        break;


    case WM_COMMAND:
        Item = LOWORD(wParam);

        switch (Item)
        {

        case IDC_CNSL_COLOR_SCREEN_TEXT:
        case IDC_CNSL_COLOR_SCREEN_BKGND:
        case IDC_CNSL_COLOR_POPUP_TEXT:
        case IDC_CNSL_COLOR_POPUP_BKGND:
            hWndOld = GetDlgItem(hDlg, pld->cpd.ColorArray[pld->cpd.Index]+IDC_CNSL_COLOR_1);

            pld->cpd.Index = Item - IDC_CNSL_COLOR_SCREEN_TEXT;
            CheckRadioButton(hDlg,IDC_CNSL_COLOR_SCREEN_TEXT,IDC_CNSL_COLOR_POPUP_BKGND,Item);

            // repaint new color
            hWnd = GetDlgItem(hDlg, pld->cpd.ColorArray[pld->cpd.Index]+IDC_CNSL_COLOR_1);
            InvalidateRect(hWnd, NULL, TRUE);

            // repaint old color
            if (hWndOld != hWnd)
            {
                InvalidateRect(hWndOld, NULL, TRUE);
            }

            return TRUE;

        case IDC_CNSL_COLOR_RED:
        case IDC_CNSL_COLOR_GREEN:
        case IDC_CNSL_COLOR_BLUE:
            switch (HIWORD(wParam))
            {

            case EN_UPDATE:
                Value = GetDlgItemInt(hDlg, Item, &bOK, TRUE);
                if (bOK)
                {
                    if (Value > 255) {
                        Value = 255;
                        SetDlgItemInt( hDlg, Item, Value, TRUE );
                    }
                    if ((int)Value < 0) {
                        Value = 0;
                        SetDlgItemInt( hDlg, Item, Value, TRUE );
                    }

                }
                if (pld)
                    pld->cpd.bConDirty = TRUE;
                PropSheet_Changed( GetParent( hDlg ), hDlg );
                break;

            case EN_KILLFOCUS:

                if (!pld)
                    return FALSE;

                //
                // Update the state info structure
                //

#define pcpd (&pld->cpd)
                Value = GetDlgItemInt(hDlg, Item, &bOK, TRUE);
                if (bOK)
                {
                    if (Value > 255) {
                        Value = 255;
                        SetDlgItemInt( hDlg, Item, Value, TRUE );
                    }
                    if ((int)Value < 0) {
                        Value = 0;
                        SetDlgItemInt( hDlg, Item, Value, TRUE );
                    }
                    if (Item == IDC_CNSL_COLOR_RED) {
                        Red = Value;
                    } else {
                        Red = GetRValue(AttrToRGB(pld->cpd.ColorArray[pld->cpd.Index]));
                    }
                    if (Item == IDC_CNSL_COLOR_GREEN) {
                        Green = Value;
                    } else {
                        Green = GetGValue(AttrToRGB(pld->cpd.ColorArray[pld->cpd.Index]));
                    }
                    if (Item == IDC_CNSL_COLOR_BLUE) {
                        Blue = Value;
                    } else {
                        Blue = GetBValue(AttrToRGB(pld->cpd.ColorArray[pld->cpd.Index]));
                    }
                    pld->cpd.lpConsole->ColorTable[pld->cpd.ColorArray[pld->cpd.Index]] =
                                    RGB(Red, Green, Blue);
                }
#undef pcpd

                //
                // Update the preview windows with the new value
                //

                hWnd = GetDlgItem(hDlg, IDC_CNSL_COLOR_SCREEN_COLORS);
                InvalidateRect(hWnd, NULL, FALSE);
                hWnd = GetDlgItem(hDlg, IDC_CNSL_COLOR_POPUP_COLORS);
                InvalidateRect(hWnd, NULL, FALSE);
                hWnd = GetDlgItem(hDlg, pld->cpd.ColorArray[pld->cpd.Index]+IDC_CNSL_COLOR_1);
                InvalidateRect(hWnd, NULL, FALSE);
                break;
            }
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_APPLY:
            /*
             * Write out the state values and exit.
             */
            if (FAILED(SaveLink(pld)))
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            break;

        }
        break;

    case WM_VSCROLL:
        // minus 1 because edit control precedes the updown control in the .rc file
        Item = GetDlgCtrlID( (HWND)lParam ) - 1;
        switch (LOWORD(wParam)) {
        case SB_ENDSCROLL:
            SendDlgItemMessage(hDlg, Item, EM_SETSEL, 0, (DWORD)-1);
            break;
        default:
            /*
             * Get the new value for the control
             */
            Value = GetDlgItemInt(hDlg, Item, &bOK, TRUE);
            SendDlgItemMessage(hDlg, Item, EM_SETSEL, 0, (DWORD)-1);
            hWnd = GetDlgItem(hDlg, Item);
            SetFocus(hWnd);

            /*
             * Fake the dialog proc into thinking the edit control just
             * lost focus so it'll update properly
             */
            SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );

            break;
        }
        return TRUE;

    case CM_SETCOLOR:
        switch( pld->cpd.Index + IDC_CNSL_COLOR_SCREEN_TEXT )
        {
        case IDC_CNSL_COLOR_SCREEN_TEXT:
            pld->cpd.lpConsole->wFillAttribute = (WORD)
                        ((pld->cpd.lpConsole->wFillAttribute & 0xF0) |
                        (wParam & 0x0F));
            break;
        case IDC_CNSL_COLOR_SCREEN_BKGND:
            pld->cpd.lpConsole->wFillAttribute = (WORD)
                        ((pld->cpd.lpConsole->wFillAttribute & 0x0F) |
                        (wParam << 4));
            break;
        case IDC_CNSL_COLOR_POPUP_TEXT:
            pld->cpd.lpConsole->wPopupFillAttribute = (WORD)
                        ((pld->cpd.lpConsole->wPopupFillAttribute & 0xF0) |
                        (wParam & 0x0F));
            break;
        case IDC_CNSL_COLOR_POPUP_BKGND:
            pld->cpd.lpConsole->wPopupFillAttribute = (WORD)
                        ((pld->cpd.lpConsole->wPopupFillAttribute & 0x0F) |
                        (wParam << 4));
            break;
        }

        hWndOld = GetDlgItem(hDlg, pld->cpd.ColorArray[pld->cpd.Index]+IDC_CNSL_COLOR_1);

        pld->cpd.ColorArray[pld->cpd.Index] = (BYTE)wParam;
        pld->cpd.bConDirty = TRUE;
        PropSheet_Changed( GetParent( hDlg ), hDlg );

        // Force the preview window to repaint

        if (pld->cpd.Index < (IDC_CNSL_COLOR_POPUP_TEXT - IDC_CNSL_COLOR_SCREEN_TEXT)) {
            hWnd = GetDlgItem(hDlg, IDC_CNSL_COLOR_SCREEN_COLORS);
        } else {
            hWnd = GetDlgItem(hDlg, IDC_CNSL_COLOR_POPUP_COLORS);
        }
        InvalidateRect(hWnd, NULL, TRUE);

        // repaint new color
        hWnd = GetDlgItem(hDlg, pld->cpd.ColorArray[pld->cpd.Index]+IDC_CNSL_COLOR_1);
        InvalidateRect(hWnd, NULL, TRUE);
        SetFocus(hWnd);

        // repaint old color
        if (hWndOld != hWnd) {
            InvalidateRect(hWndOld, NULL, TRUE);
        }
        return TRUE;

    default:
        break;
    }
    return FALSE;
}



BOOL_PTR
CALLBACK
_ConsoleSettingsDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the settings dialog box.

--*/

{
    UINT Item;
    SYSTEM_INFO SystemInfo;

    LINKDATA *pld = (LINKDATA *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg) {
    case WM_INITDIALOG:
        pld = (LINKDATA *)((PROPSHEETPAGE *)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pld);
        GetSystemInfo(&SystemInfo);
        if (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
            if (pld->cpd.lpConsole->bFullScreen)
                CheckRadioButton(hDlg,IDC_CNSL_WINDOWED,IDC_CNSL_FULLSCREEN,IDC_CNSL_FULLSCREEN);
            else
                CheckRadioButton(hDlg,IDC_CNSL_WINDOWED,IDC_CNSL_FULLSCREEN,IDC_CNSL_WINDOWED);
        } else {
            ShowWindow(GetDlgItem(hDlg, IDC_CNSL_WINDOWED), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_CNSL_FULLSCREEN), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_CNSL_GROUP2), SW_HIDE);
        }

        CheckDlgButton(hDlg, IDC_CNSL_HISTORY_NODUP, pld->cpd.lpConsole->bHistoryNoDup);
        CheckDlgButton(hDlg, IDC_CNSL_QUICKEDIT, pld->cpd.lpConsole->bQuickEdit);
        CheckDlgButton(hDlg, IDC_CNSL_INSERT, pld->cpd.lpConsole->bInsertMode);

        // initialize cursor radio buttons

        if (pld->cpd.lpConsole->uCursorSize <= 25)
        {
            Item = IDC_CNSL_CURSOR_SMALL;
        }
        else if (pld->cpd.lpConsole->uCursorSize <= 50)
        {
            Item = IDC_CNSL_CURSOR_MEDIUM;
        }
        else
        {
            Item = IDC_CNSL_CURSOR_LARGE;
        }
        CheckRadioButton(hDlg, IDC_CNSL_CURSOR_SMALL, IDC_CNSL_CURSOR_LARGE, Item);

        // initialize updown controls

        SendDlgItemMessage( hDlg, IDC_CNSL_HISTORY_SIZESCROLL,  UDM_SETRANGE, 0, (LPARAM)MAKELONG( 999, 1 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_HISTORY_NUMSCROLL,   UDM_SETRANGE, 0, (LPARAM)MAKELONG( 999, 1 ) );

        //
        // put current values in dialog box
        //
        SendDlgItemMessage( hDlg, IDC_CNSL_HISTORY_SIZESCROLL,  UDM_SETPOS, 0, (LPARAM)MAKELONG( pld->cpd.lpConsole->uHistoryBufferSize, 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_HISTORY_NUMSCROLL,   UDM_SETPOS, 0, (LPARAM)MAKELONG( pld->cpd.lpConsole->uNumberOfHistoryBuffers, 0 ) );

        if (IsFarEastCP(pld->cpd.uOEMCP))
            LanguageListCreate(hDlg, pld->cpd.lpFEConsole->uCodePage);
        else
        {
            ShowWindow(GetDlgItem(hDlg, IDC_CNSL_GROUP3), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_CNSL_LANGUAGELIST), SW_HIDE);
        }
        return TRUE;

    case WM_DESTROY:
        EndDialog( hDlg, TRUE );
        break;

    //
    // handle help messages
    //
    case WM_HELP:               /* F1 or title-bar help button */
        WinHelp( (HWND) ((LPHELPINFO) lParam)->hItemHandle,
                 NULL,
                 HELP_WM_HELP,
                 (ULONG_PTR) (LPVOID) &rgdwHelpSettings[0]
                );
        break;

    case WM_CONTEXTMENU:        /* right mouse click */
        WinHelp( (HWND) wParam,
                 NULL,
                 HELP_CONTEXTMENU,
                 (ULONG_PTR) (LPVOID) &rgdwHelpSettings[0]
                );
        break;


    case WM_COMMAND:
        Item = LOWORD(wParam);

        switch (Item)
        {

        case IDC_CNSL_HISTORY_SIZE:
            if (pld && (HIWORD(wParam)==EN_UPDATE))
            {
                pld->cpd.lpConsole->uHistoryBufferSize =
                    GetDlgItemInt( hDlg, Item, NULL, FALSE );
                pld->cpd.bConDirty = TRUE;
                PropSheet_Changed( GetParent( hDlg ), hDlg );
            }
            break;

        case IDC_CNSL_HISTORY_NUM:
            if (pld && (HIWORD(wParam)==EN_UPDATE))
            {
                pld->cpd.lpConsole->uNumberOfHistoryBuffers =
                    GetDlgItemInt( hDlg, Item, NULL, FALSE );
                pld->cpd.bConDirty = TRUE;
                PropSheet_Changed( GetParent( hDlg ), hDlg );
            }
            break;

#ifdef i386
        case IDC_CNSL_WINDOWED:
        case IDC_CNSL_FULLSCREEN:
            CheckRadioButton(hDlg, IDC_CNSL_WINDOWED, IDC_CNSL_FULLSCREEN, Item);
            pld->cpd.lpConsole->bFullScreen = (Item == IDC_CNSL_FULLSCREEN);
            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );
            return TRUE;
#endif
        case IDC_CNSL_LANGUAGELIST:
            switch (HIWORD(wParam)) {
            case CBN_KILLFOCUS: {
                HWND hWndLanguageCombo;
                LONG lListIndex;
                UINT  Value;

                hWndLanguageCombo = GetDlgItem(hDlg, IDC_CNSL_LANGUAGELIST);
                lListIndex = (LONG) SendMessage(hWndLanguageCombo, CB_GETCURSEL, 0, 0L);
                Value = (UINT) SendMessage(hWndLanguageCombo, CB_GETITEMDATA, lListIndex, 0L);
                if (Value != (UINT)-1) {
                    pld->cpd.fChangeCodePage = (Value != pld->cpd.lpFEConsole->uCodePage);
                    pld->cpd.lpFEConsole->uCodePage = Value;
                    PropSheet_Changed( GetParent( hDlg ), hDlg );
                }
                break;
            }

            default:
                break;
            }
            return TRUE;

        case IDC_CNSL_CURSOR_SMALL:
            pld->cpd.lpConsole->uCursorSize = 25;
            goto SetCursorSize;
        case IDC_CNSL_CURSOR_MEDIUM:
            pld->cpd.lpConsole->uCursorSize = 50;
            goto SetCursorSize;
        case IDC_CNSL_CURSOR_LARGE:
            pld->cpd.lpConsole->uCursorSize = 100;
SetCursorSize:
            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );
            CheckRadioButton(hDlg, IDC_CNSL_CURSOR_SMALL, IDC_CNSL_CURSOR_LARGE, Item);
            return TRUE;

        case IDC_CNSL_HISTORY_NODUP:
            pld->cpd.lpConsole->bHistoryNoDup = IsDlgButtonChecked( hDlg, Item );
            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );
            return TRUE;

        case IDC_CNSL_QUICKEDIT:
            pld->cpd.lpConsole->bQuickEdit = IsDlgButtonChecked( hDlg, Item );
            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );
            return TRUE;

        case IDC_CNSL_INSERT:
            pld->cpd.lpConsole->bInsertMode = IsDlgButtonChecked( hDlg, Item );
            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );
            return TRUE;

        default:
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_APPLY:
            /*
             * Write out the state values and exit.
             */
            if (FAILED(SaveLink(pld)))
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            break;

        case PSN_KILLACTIVE:
            /*
             * Fake the dialog proc into thinking the edit control just
             * lost focus so it'll update properly
             */
            if (0 != (Item = GetDlgCtrlID(GetFocus()))) {
                SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
            }
            return TRUE;
        }
        break;


    default:
        break;
    }
    return FALSE;
}

BOOL
CheckBufferSize(
    HWND hDlg,
    UINT Item,
    LINKDATA *pld,
    INT i
    )
/*++

    Checks to make sure the buffer size is not smaller than the window size

    Returns: TRUE if preview window should be updated
             FALSE if not

--*/
{
    BOOL fRet = FALSE;

    if (!pld)
     return fRet;

    switch (Item)
    {

    case IDC_CNSL_SCRBUF_WIDTHSCROLL:
    case IDC_CNSL_SCRBUF_WIDTH:
        if (i >= 1)
        {
            pld->cpd.lpConsole->dwScreenBufferSize.X = (SHORT) i;
            if (pld->cpd.lpConsole->dwWindowSize.X > i)
            {
                pld->cpd.lpConsole->dwWindowSize.X = (SHORT) i;
                SetDlgItemInt( hDlg,
                               IDC_CNSL_WINDOW_WIDTH,
                               pld->cpd.lpConsole->dwWindowSize.X,
                               TRUE
                              );

                fRet = TRUE;
            }

        }
        break;

    case IDC_CNSL_SCRBUF_HEIGHTSCROLL:
    case IDC_CNSL_SCRBUF_HEIGHT:
        if (i >= 1)
        {
            pld->cpd.lpConsole->dwScreenBufferSize.Y = (SHORT) i;
            if (pld->cpd.lpConsole->dwWindowSize.Y > i)
            {
                pld->cpd.lpConsole->dwWindowSize.Y = (SHORT) i;
                SetDlgItemInt( hDlg,
                               IDC_CNSL_WINDOW_HEIGHT,
                               pld->cpd.lpConsole->dwWindowSize.Y,
                               TRUE
                              );
                fRet = TRUE;
            }
        }
        break;

    case IDC_CNSL_WINDOW_WIDTHSCROLL:
    case IDC_CNSL_WINDOW_WIDTH:
        if (i >= 1)
        {
            pld->cpd.lpConsole->dwWindowSize.X = (SHORT) i;
            if (pld->cpd.lpConsole->dwScreenBufferSize.X < i)
            {
                pld->cpd.lpConsole->dwScreenBufferSize.X = (SHORT) i;
                SetDlgItemInt( hDlg,
                               IDC_CNSL_SCRBUF_WIDTH,
                               pld->cpd.lpConsole->dwScreenBufferSize.X,
                               TRUE
                              );
                fRet = TRUE;
            }

        }
        break;

    case IDC_CNSL_WINDOW_HEIGHTSCROLL:
    case IDC_CNSL_WINDOW_HEIGHT:
        if (i >= 1)
        {
            pld->cpd.lpConsole->dwWindowSize.Y = (SHORT) i;
            if (pld->cpd.lpConsole->dwScreenBufferSize.Y < i)
            {
                pld->cpd.lpConsole->dwScreenBufferSize.Y = (SHORT) i;
                SetDlgItemInt( hDlg,
                               IDC_CNSL_SCRBUF_HEIGHT,
                               pld->cpd.lpConsole->dwScreenBufferSize.Y,
                               TRUE
                              );
                fRet = TRUE;
            }
        }

    }

    return fRet;

}

BOOL
IsValidSetting(
    HWND hDlg,
    UINT Item,
    LINKDATA *pld,
    INT i
    )
/*++

    Checks to make sure the proposed new value is valid for the console

    Returns: TRUE if it is valid
             FALSE if not

--*/
{

    BOOL fRet = TRUE;

    if (!pld)
        return FALSE;

    if (i>9999)
        i = -1;

    switch (Item)
    {

    case IDC_CNSL_WINDOW_HEIGHT:
        if (i <= 0)
        {
            SetDlgItemInt( hDlg,
                           Item,
                           pld->cpd.lpConsole->dwWindowSize.Y,
                           TRUE
                          );
            fRet = FALSE;
        }
        else
        {
            pld->cpd.lpConsole->dwWindowSize.Y = (SHORT) i;
        }
        break;

    case IDC_CNSL_WINDOW_WIDTH:
        if (i <= 0)
        {
            SetDlgItemInt( hDlg,
                           Item,
                           pld->cpd.lpConsole->dwWindowSize.X,
                           TRUE
                          );
            fRet = FALSE;
        }
        else
        {
            pld->cpd.lpConsole->dwWindowSize.X = (SHORT) i;
        }
        break;

    case IDC_CNSL_SCRBUF_WIDTH:
        if (i <= 0)
        {
            SetDlgItemInt( hDlg,
                           Item,
                           pld->cpd.lpConsole->dwScreenBufferSize.X,
                           TRUE
                          );
            fRet = FALSE;
        }
        else
        {
            pld->cpd.lpConsole->dwScreenBufferSize.X = (SHORT) i;
        }
        break;

    case IDC_CNSL_SCRBUF_HEIGHT:
        if (i <= 0)
        {
            SetDlgItemInt( hDlg,
                           Item,
                           pld->cpd.lpConsole->dwScreenBufferSize.Y,
                           TRUE
                          );
            fRet = FALSE;
        }
        else
        {
            pld->cpd.lpConsole->dwScreenBufferSize.Y = (SHORT) i;
        }
        break;
    }

    if (i <= 0)
    {
        SendDlgItemMessage( hDlg,
                            Item,
                            EM_SETSEL,
                            (WPARAM)(INT)4,
                            (WPARAM)(INT)4
                           );
    }

    return fRet;
}

BOOL_PTR
CALLBACK
_ScreenSizeDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the screen size dialog box.

--*/

{
    UINT Value;
    UINT Item;
    HWND hWnd;
    LONG xScreen;
    LONG yScreen;
    LONG cxScreen;
    LONG cyScreen;
    LONG cxFrame;
    LONG cyFrame;

    LINKDATA *pld = (LINKDATA *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg) {

    case WM_INITDIALOG:
        pld = (LINKDATA *)((PROPSHEETPAGE *)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pld);
        SendDlgItemMessage(hDlg, IDC_CNSL_PREVIEWWINDOW, CM_PREVIEW_INIT, 0, (LPARAM)&pld->cpd );
        SendDlgItemMessage(hDlg, IDC_CNSL_PREVIEWWINDOW, CM_PREVIEW_UPDATE, 0, 0 );

        // Get some system parameters

        xScreen  = GetSystemMetrics(SM_XVIRTUALSCREEN);
        yScreen  = GetSystemMetrics(SM_YVIRTUALSCREEN);
        cxScreen = GetSystemMetrics(SM_CXVIRTUALSCREEN);
        cyScreen = GetSystemMetrics(SM_CYVIRTUALSCREEN);
        cxFrame  = GetSystemMetrics(SM_CXFRAME);
        cyFrame  = GetSystemMetrics(SM_CYFRAME);

        // initialize updown controls

        SendDlgItemMessage( hDlg, IDC_CNSL_SCRBUF_WIDTHSCROLL,  UDM_SETRANGE, 0, (LPARAM)MAKELONG( MAX_SCRBUF_WIDTH, 1 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_SCRBUF_HEIGHTSCROLL, UDM_SETRANGE, 0, (LPARAM)MAKELONG( MAX_SCRBUF_HEIGHT, 1 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_WINDOW_WIDTHSCROLL,  UDM_SETRANGE, 0, (LPARAM)MAKELONG( 9999, 1 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_WINDOW_HEIGHTSCROLL, UDM_SETRANGE, 0, (LPARAM)MAKELONG( 9999, 1 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_WINDOW_POSXSCROLL,   UDM_SETRANGE, 0, (LPARAM)MAKELONG( xScreen + cxScreen - cxFrame, xScreen - cxFrame ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_WINDOW_POSYSCROLL,   UDM_SETRANGE, 0, (LPARAM)MAKELONG( yScreen + cyScreen - cyFrame, yScreen - cyFrame ) );

        //
        // put current values in dialog box
        //

        SendDlgItemMessage( hDlg, IDC_CNSL_SCRBUF_WIDTHSCROLL,  UDM_SETPOS, 0, (LPARAM)MAKELONG( pld->cpd.lpConsole->dwScreenBufferSize.X, 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_SCRBUF_HEIGHTSCROLL, UDM_SETPOS, 0, (LPARAM)MAKELONG( pld->cpd.lpConsole->dwScreenBufferSize.Y, 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_WINDOW_WIDTHSCROLL,  UDM_SETPOS, 0, (LPARAM)MAKELONG( pld->cpd.lpConsole->dwWindowSize.X, 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_WINDOW_HEIGHTSCROLL, UDM_SETPOS, 0, (LPARAM)MAKELONG( pld->cpd.lpConsole->dwWindowSize.Y, 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_WINDOW_POSXSCROLL,   UDM_SETPOS, 0, (LPARAM)MAKELONG( pld->cpd.lpConsole->dwWindowOrigin.X, 0 ) );
        SendDlgItemMessage( hDlg, IDC_CNSL_WINDOW_POSYSCROLL,   UDM_SETPOS, 0, (LPARAM)MAKELONG( pld->cpd.lpConsole->dwWindowOrigin.Y, 0 ) );

        CheckDlgButton(hDlg, IDC_CNSL_AUTO_POSITION, pld->cpd.lpConsole->bAutoPosition);
        SendMessage(hDlg, WM_COMMAND, IDC_CNSL_AUTO_POSITION, 0);

        return TRUE;

    case WM_DESTROY:
        EndDialog( hDlg, TRUE );
        break;

    //
    // handle help messages
    //
    case WM_HELP:               /* F1 or title-bar help button */
        WinHelp( (HWND) ((LPHELPINFO) lParam)->hItemHandle,
                 NULL,
                 HELP_WM_HELP,
                 (ULONG_PTR) (LPVOID) &rgdwHelpSize[0]
                );
        break;

    case WM_CONTEXTMENU:        /* right mouse click */
        WinHelp( (HWND) wParam,
                 NULL,
                 HELP_CONTEXTMENU,
                 (ULONG_PTR) (LPVOID) &rgdwHelpSize[0]
                );
        break;


    case WM_COMMAND:
        Item = LOWORD(wParam);

        if (Item==IDC_CNSL_AUTO_POSITION)
        {
            pld->cpd.lpConsole->bAutoPosition = IsDlgButtonChecked( hDlg, Item );
            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );
            Value = IsDlgButtonChecked(hDlg, IDC_CNSL_AUTO_POSITION);
            for (Item = IDC_CNSL_WINDOW_POSX; Item < IDC_CNSL_AUTO_POSITION; Item++) {
                hWnd = GetDlgItem(hDlg, Item);
                EnableWindow(hWnd, (Value == FALSE));
            }
        }

        //
        // Make sure that we don't have a buffer size smaller than a window size
        //
        if (pld && (HIWORD(wParam)==EN_KILLFOCUS))
        {
            INT i;

            i = GetDlgItemInt( hDlg, Item, NULL, FALSE );
            if (CheckBufferSize( hDlg, Item, pld, i ))
                goto UpdatePrevWindow;

        }

        //
        // Verify that what is typed is a valid quantity...
        //
        if (pld && (HIWORD(wParam)==EN_UPDATE))
        {
            INT i;

            i = GetDlgItemInt( hDlg, Item, NULL, FALSE );
            IsValidSetting( hDlg, Item, pld, i );

            switch( Item )
            {

            case IDC_CNSL_WINDOW_POSX:
                pld->cpd.lpConsole->dwWindowOrigin.X = (SHORT)
                    GetDlgItemInt( hDlg, Item, NULL, TRUE );
                break;

            case IDC_CNSL_WINDOW_POSY:
                pld->cpd.lpConsole->dwWindowOrigin.Y = (SHORT)
                    GetDlgItemInt( hDlg, Item, NULL, TRUE );
                break;

            }

UpdatePrevWindow:

            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );
            SendDlgItemMessage(hDlg, IDC_CNSL_PREVIEWWINDOW, CM_PREVIEW_UPDATE, 0, 0 );

        }

        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case UDN_DELTAPOS:
        {
            NM_UPDOWN * lpud = (NM_UPDOWN *)lParam;
            INT i;

            i = lpud->iPos + lpud->iDelta;

            // Check for bad ranges
            if ((i > 9999) || (i < 1))
                return TRUE;

            // check restrictions and alter values accordingly.  (Buffer size
            // can never be smaller than window size!)
            CheckBufferSize( hDlg, (UINT)wParam, pld, i);

            // highlight the changed entry
            SendDlgItemMessage( hDlg,
                                (UINT)wParam,
                                EM_SETSEL,
                                (WPARAM)(INT)4,
                                (WPARAM)(INT)4
                               );

            // Update the preview window
            pld->cpd.bConDirty = TRUE;
            PropSheet_Changed( GetParent( hDlg ), hDlg );
            SendDlgItemMessage(hDlg, IDC_CNSL_PREVIEWWINDOW, CM_PREVIEW_UPDATE, 0, 0 );
        }
        break;

        case PSN_APPLY:
            /*
             * Write out the state values and exit.
             */
            if (FAILED(SaveLink(pld)))
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            break;

//        case PSN_HELP:
//            //WinHelp(hDlg, szHelpFileName, HELP_CONTEXT, DID_SCRBUFSIZE);
//            return TRUE;

        case PSN_KILLACTIVE:
            /*
             * Fake the dialog proc into thinking the edit control just
             * lost focus so it'll update properly
             */
            if (0 != (Item = GetDlgCtrlID(GetFocus()))) {
                SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
            }
            return TRUE;
        }
        break;

    default:
        break;
    }
    return FALSE;
}

void *_CopyDataBlock(IShellLink *psl, DWORD dwSig)
{
    void *pv = NULL;
    IShellLinkDataList *psld;
    if (SUCCEEDED(psl->lpVtbl->QueryInterface(psl, &IID_IShellLinkDataList, (void **)&psld)))
    {
        psld->lpVtbl->CopyDataBlock(psld, dwSig, &pv);
        psld->lpVtbl->Release(psld);
    }
    return (void *)pv;
}

void _RemoveDataBlock(IShellLink *psl, DWORD dwSig)
{
    IShellLinkDataList *psld;
    if (SUCCEEDED(psl->lpVtbl->QueryInterface(psl, &IID_IShellLinkDataList, (void **)&psld)))
    {
        psld->lpVtbl->RemoveDataBlock(psld, dwSig);
        psld->lpVtbl->Release(psld);
    }
}

void _AddDataBlock(IShellLink *psl, void *pv)
{
    IShellLinkDataList *psld;
    if (SUCCEEDED(psl->lpVtbl->QueryInterface(psl, &IID_IShellLinkDataList, (void **)&psld)))
    {
        psld->lpVtbl->AddDataBlock(psld, pv);
        psld->lpVtbl->Release(psld);
    }
}


STDAPI_(void) LinkConsolePagesSave( LINKDATA *pld )
{
    // First, remove the console settings section if it exists
    _RemoveDataBlock(pld->cpd.psl, NT_CONSOLE_PROPS_SIG);
    _RemoveDataBlock(pld->cpd.psl, NT_FE_CONSOLE_PROPS_SIG);

#ifndef UNICODE
    // if we're the ANSI shell, we need to convert FACENAME
    // over to UNICODE before saving...
    {
        WCHAR wszFaceName[LF_FACESIZE];

        MultiByteToWideChar( CP_ACP, 0,
                         pld->cpd.lpFaceName, LF_FACESIZE,
                         wszFaceName, LF_FACESIZE
                        );
        hmemcpy(pld->cpd.lpConsole->FaceName, wszFaceName, LF_FACESIZE*SIZEOF(WCHAR));
    }

#endif
    //
    // Now, add back the new console settings
    _AddDataBlock(pld->cpd.psl, pld->cpd.lpConsole);

    //
    // Now, update registry settings for this title...
    SetRegistryValues( &pld->cpd );

    if (IsFarEastCP(pld->cpd.uOEMCP))
    {
        // Same for FarEast console settings
        //
        _AddDataBlock(pld->cpd.psl, pld->cpd.lpFEConsole);

        SetFERegistryValues( &pld->cpd );
    }
    // And, mark the console data as current
    pld->cpd.bConDirty = FALSE;
}

#define PEMAGIC         ((WORD)'P'+((WORD)'E'<<8))

STDAPI_(void) AddLinkConsolePages(LINKDATA *pld, IShellLink * psl, LPCTSTR pszFile, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    HPROPSHEETPAGE hpage;
    PROPSHEETPAGE psp;
    HRESULT hres;
    TCHAR szTarget[ MAX_PATH ];
    TCHAR szBuffer[ MAX_PATH ];
    WNDCLASS wc;
    IPersistFile *ppf;
    LPNT_FE_CONSOLE_PROPS lpFEConsole;
    LPNT_CONSOLE_PROPS lpConsole;

    // do this here so we don't slow down the loading
    // of other pages

    if (SUCCEEDED(psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf)))
    {
        WCHAR wszPath[ MAX_PATH ];

        SHTCharToUnicode(pszFile, wszPath, ARRAYSIZE(wszPath));
        hres = ppf->lpVtbl->Load(ppf, wszPath, 0);
        ppf->lpVtbl->Release(ppf);
    }

    // Get the target of the link
    hres = psl->lpVtbl->GetPath(psl, szBuffer, ARRAYSIZE(szBuffer), NULL, 0);
    pld->cpd.psl = psl;

    if (FAILED(hres) || hres == S_FALSE)
        goto Exit;

    // Remove args first, to:
    // (1) shorten our string, avoiding ExpandEnvironmentStrings overflowing the buffer
    // (2) increase liklihood that PathRemoveArgs won't get confused by spaces in "Program Files" etc
    PathRemoveArgs(szTarget);

    // expand the target
    if (!SHExpandEnvironmentStrings(szBuffer, szTarget, ARRAYSIZE(szTarget)))
        goto Exit;

    // Check what kind of app target is LOWORD==PEMAGIC, HIWORD==0
    if (GetExeType( szTarget )!=PEMAGIC)
        goto Exit;

    // It's a WIN32 console mode app, let's put up our property sheet

    wc.lpszClassName = TEXT("WOACnslWinPreview");
    wc.hInstance     = HINST_THISDLL;
    wc.lpfnWndProc   = PreviewWndProc;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon         = NULL;
    wc.lpszMenuName  = NULL;
    wc.hbrBackground = (HBRUSH) (COLOR_BACKGROUND + 1);
    wc.style         = 0L;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 2 * sizeof(PVOID);   // (two pointers)
    if (!RegisterClass(&wc))
        if (GetLastError()!=ERROR_CLASS_ALREADY_EXISTS)
            goto Exit;


    wc.lpszClassName = TEXT("WOACnslFontPreview");
    wc.hInstance     = HINST_THISDLL;
    wc.lpfnWndProc   = _FontPreviewWndProc;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon         = NULL;
    wc.lpszMenuName  = NULL;
    wc.hbrBackground = GetStockObject(BLACK_BRUSH);
    wc.style         = 0L;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PVOID);       // (one pointer)
    if (!RegisterClass(&wc))
        if (GetLastError()!=ERROR_CLASS_ALREADY_EXISTS)
            goto Exit;

    wc.lpszClassName = TEXT("cpColor");
    wc.hInstance     = HINST_THISDLL;
    wc.lpfnWndProc   = ColorControlProc;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon         = NULL;
    wc.lpszMenuName  = NULL;
    wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    wc.style         = 0L;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PVOID);       // (one pointer)
    if (!RegisterClass(&wc))
        if (GetLastError()!=ERROR_CLASS_ALREADY_EXISTS)
            goto Exit;

    wc.lpszClassName = TEXT("cpShowColor");
    wc.hInstance     = HINST_THISDLL;
    wc.lpfnWndProc   = ColorTextProc;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon         = NULL;
    wc.lpszMenuName  = NULL;
    wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    wc.style         = 0L;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PVOID);       // (one pointer)
    if (!RegisterClass(&wc))
        if (GetLastError()!=ERROR_CLASS_ALREADY_EXISTS)
            goto Exit;

    // Needs TTFontList for all platform.
    if (!NT_SUCCESS( InitializeDbcsMisc(&pld->cpd) ))
        goto Exit;

    GetTitleFromLinkName( (LPTSTR)pszFile, (LPTSTR)pld->cpd.ConsoleTitle, ARRAYSIZE(pld->cpd.ConsoleTitle));

    // Check if Far East settings exist...
    
    lpFEConsole =(LPNT_FE_CONSOLE_PROPS)_CopyDataBlock(psl, NT_FE_CONSOLE_PROPS_SIG);
    if (lpFEConsole && lpFEConsole->cbSize != SIZEOF(NT_FE_CONSOLE_PROPS))
    {
        LocalFree(lpFEConsole);
        lpFEConsole = NULL;
    }

    if (lpFEConsole)
    {
        pld->cpd.lpFEConsole = lpFEConsole;
    }
    else
    {
        pld->cpd.lpFEConsole = (LPNT_FE_CONSOLE_PROPS)LocalAlloc( LPTR, SIZEOF(NT_FE_CONSOLE_PROPS) );
        if (pld->cpd.lpFEConsole) 
        {
            // Initialize Far East Console settings
            pld->cpd.lpFEConsole->cbSize = SIZEOF( NT_FE_CONSOLE_PROPS );
            pld->cpd.lpFEConsole->dwSignature = NT_FE_CONSOLE_PROPS_SIG;
            if (IsFarEastCP(pld->cpd.uOEMCP))
            {
                InitFERegistryValues( &pld->cpd );
                GetFERegistryValues( &pld->cpd );
            }
        }
    }

    if (!pld->cpd.lpFEConsole)
        goto Exit;
    
    // Get standard settings from link if they exist...
    lpConsole = (LPNT_CONSOLE_PROPS)_CopyDataBlock(psl, NT_CONSOLE_PROPS_SIG);
    if (lpConsole != NULL && lpConsole->cbSize != SIZEOF(NT_CONSOLE_PROPS))
    {
        LocalFree(lpConsole);
        lpConsole = NULL;
    }

    if (lpConsole)
    {
        pld->cpd.lpConsole = lpConsole;
    }
    else
    {
        pld->cpd.lpConsole = (LPNT_CONSOLE_PROPS)LocalAlloc(LPTR, SIZEOF(NT_CONSOLE_PROPS) );
        if (pld->cpd.lpConsole)
        {
            // Initialize console settings
            pld->cpd.lpConsole->cbSize = SIZEOF( NT_CONSOLE_PROPS );
            pld->cpd.lpConsole->dwSignature = NT_CONSOLE_PROPS_SIG;
            InitRegistryValues( &pld->cpd );
            GetRegistryValues( &pld->cpd );
        }
        else
        {
            // if the above alloc failes, we fault dereferencing lpConsole...
            ASSERT(FALSE);
        }

    }
#ifndef UNICODE
    else
    {
        // we read the properties off of disk -- so need to convert the
        // UNICODE string to ANSI

        WCHAR wszFaceName[LF_FACESIZE];

        hmemcpy(wszFaceName,pld->cpd.lpConsole->FaceName,LF_FACESIZE*SIZEOF(WCHAR));

        WideCharToMultiByte( CP_ACP, 0,
                             wszFaceName, LF_FACESIZE,
                             pld->cpd.szFaceName, LF_FACESIZE,
                             NULL, NULL
                            );
    }
#endif

    if (!pld->cpd.lpConsole)
        goto Exit;

    // set facename pointer to correct place
#ifdef UNICODE
    pld->cpd.lpFaceName = (LPTSTR)pld->cpd.lpConsole->FaceName;
#else
    pld->cpd.lpFaceName = (LPTSTR)pld->cpd.szFaceName;
#endif

    //
    // Initialize the font cache and current font index
    //

    if (STATUS_SUCCESS != InitializeFonts( &pld->cpd ))
    {
        goto Exit;
    }
    pld->cpd.CurrentFontIndex = FindCreateFont( &pld->cpd,
                                                pld->cpd.lpConsole->uFontFamily,
                                                pld->cpd.lpFaceName,
                                                pld->cpd.lpConsole->dwFontSize,
                                                pld->cpd.lpConsole->uFontWeight);

    // Mark the console data as current
    pld->cpd.bConDirty = FALSE;

    // add console settings property sheet
    psp.dwSize      = SIZEOF( psp );
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = HINST_THISDLL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_CONSOLE_SETTINGS);
    psp.pfnDlgProc  = _ConsoleSettingsDlgProc;
    psp.lParam      = (LPARAM)pld;

    hpage = CreatePropertySheetPage( &psp );
    if (hpage)
    {
        if (!pfnAddPage(hpage, lParam))
        {
            DestroyPropertySheetPage(hpage);
            goto Exit;
        }
    }
    else
    {
        if (pld->cpd.lpConsole)
        {
            LocalFree( pld->cpd.lpConsole );
            pld->cpd.lpConsole = NULL;
        }
        if (pld->cpd.lpFEConsole)
        {
            LocalFree( pld->cpd.lpFEConsole );
            pld->cpd.lpFEConsole = NULL;
        }
        goto Exit;
    }

    // add font selection property sheet
    psp.dwSize      = SIZEOF( psp );
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = HINST_THISDLL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_CONSOLE_FONTDLG);
    psp.pfnDlgProc  = _FontDlgProc;
    psp.lParam      = (LPARAM)pld;

    hpage = CreatePropertySheetPage( &psp );
    if (hpage)
    {
        if (!pfnAddPage(hpage, lParam))
        {
            DestroyPropertySheetPage(hpage);
            goto Exit;
        }
    }
    else
    {
        if (pld->cpd.lpConsole)
        {
            LocalFree( pld->cpd.lpConsole );
            pld->cpd.lpConsole = NULL;
        }
        if (pld->cpd.lpFEConsole)
        {
            LocalFree( pld->cpd.lpFEConsole );
            pld->cpd.lpFEConsole = NULL;
        }
        goto Exit;
    }

    // add console size propery sheet
    psp.dwSize      = SIZEOF( psp );
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = HINST_THISDLL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_CONSOLE_SCRBUFSIZE);
    psp.pfnDlgProc  = _ScreenSizeDlgProc;
    psp.lParam      = (LPARAM)pld;

    hpage = CreatePropertySheetPage( &psp );
    if (hpage)
    {
        if (!pfnAddPage(hpage, lParam))
        {
            DestroyPropertySheetPage(hpage);
            goto Exit;
        }
    }
    else
    {
        if (pld->cpd.lpConsole)
        {
            LocalFree( pld->cpd.lpConsole );
            pld->cpd.lpConsole = NULL;
        }
        goto Exit;
    }

    // add console color propery sheet
    psp.dwSize      = SIZEOF( psp );
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = HINST_THISDLL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_CONSOLE_COLOR);
    psp.pfnDlgProc  = _ColorDlgProc;
    psp.lParam      = (LPARAM)pld;

    hpage = CreatePropertySheetPage( &psp );
    if (hpage)
    {
        if (!pfnAddPage(hpage, lParam))
        {
            DestroyPropertySheetPage(hpage);
            goto Exit;
        }
    }
    else
    {
        if (pld->cpd.lpConsole)
        {
            LocalFree( pld->cpd.lpConsole );
            pld->cpd.lpConsole = NULL;
        }
        if (pld->cpd.lpFEConsole)
        {
            LocalFree( pld->cpd.lpFEConsole );
            pld->cpd.lpFEConsole = NULL;
        }
        goto Exit;
    }

#ifdef ADVANCED_PAGE
    // add "advanced" settings propery sheet
    psp.dwSize      = SIZEOF( psp );
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = HINST_THISDLL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_CONSOLE_ADVANCED);
    psp.pfnDlgProc  = _AdvancedDlgProc;
    psp.lParam      = (LPARAM)pld;

    hpage = CreatePropertySheetPage( &psp );
    if (hpage)
    {
        if (!pfnAddPage(hpage, lParam))
        {
            DestroyPropertySheetPage(hpage);
            goto Exit;
        }
    }
    else
    {
        if (pld->cpd.lpConsole)
        {
            LocalFree( pld->cpd.lpConsole );
            pld->cpd.lpConsole = NULL;
        }
        if (pld->cpd.lpFEConsole)
        {
            LocalFree( pld->cpd.lpFEConsole );
            pld->cpd.lpFEConsole = NULL;
        }
        goto Exit;
    }
#endif


Exit:
    ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\lnkmisc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    misc.c

Abstract:

        This file implements the NT console server font routines.

Author:

    Therese Stowell (thereses) 22-Jan-1991

Revision History:

--*/

#include "shellprv.h"
#pragma hdrstop

#include "lnkcon.h"

#define CONSOLE_REGISTRY_STRING       (TEXT("Console"))
#define CONSOLE_REGISTRY_FONTSIZE     (TEXT("FontSize"))
#define CONSOLE_REGISTRY_FONTFAMILY   (TEXT("FontFamily"))
#define CONSOLE_REGISTRY_BUFFERSIZE   (TEXT("ScreenBufferSize"))
#define CONSOLE_REGISTRY_CURSORSIZE   (TEXT("CursorSize"))
#define CONSOLE_REGISTRY_WINDOWSIZE   (TEXT("WindowSize"))
#define CONSOLE_REGISTRY_WINDOWPOS    (TEXT("WindowPosition"))
#define CONSOLE_REGISTRY_FILLATTR     (TEXT("ScreenColors"))
#define CONSOLE_REGISTRY_POPUPATTR    (TEXT("PopupColors"))
#define CONSOLE_REGISTRY_FULLSCR      (TEXT("FullScreen"))
#define CONSOLE_REGISTRY_QUICKEDIT    (TEXT("QuickEdit"))
#define CONSOLE_REGISTRY_FACENAME     (TEXT("FaceName"))
#define CONSOLE_REGISTRY_FONTWEIGHT   (TEXT("FontWeight"))
#define CONSOLE_REGISTRY_INSERTMODE   (TEXT("InsertMode"))
#define CONSOLE_REGISTRY_HISTORYSIZE  (TEXT("HistoryBufferSize"))
#define CONSOLE_REGISTRY_HISTORYBUFS  (TEXT("NumberOfHistoryBuffers"))
#define CONSOLE_REGISTRY_HISTORYNODUP (TEXT("HistoryNoDup"))
#define CONSOLE_REGISTRY_COLORTABLE   (TEXT("ColorTable%02u"))
#define CONSOLE_REGISTRY_CODEPAGE     (TEXT("CodePage"))


/*
 * Initial default fonts and face names
 */

/*
 * TTPoints -- Initial font pixel heights for TT fonts
 */
SHORT TTPoints[] = {
    5, 6, 7, 8, 10, 12, 14, 16, 18, 20, 24, 28, 36, 72
};
/*
 * TTPointsDbcs -- Initial font pixel heights for TT fonts of DBCS.
 */
SHORT TTPointsDbcs[] = {
    6, 8, 10, 12, 14, 16, 18, 20, 24, 28, 36, 72
};


typedef struct _FONTENUMDATA {
    CONSOLEPROP_DATA *pcpd;
    HDC hDC;
    BOOL bFindFaces;
    ULONG ulFE;
    PSHORT pTTPoints;
    UINT nTTPoints;
    UINT uDefCP;
} FONTENUMDATA, *PFONTENUMDATA;


FACENODE *
AddFaceNode(FACENODE * *ppStart, LPTSTR ptsz) {
    FACENODE * pNew;
    FACENODE * *ppTmp;
    UINT cch;
    int cb;
    HRESULT hr;

    /*
     * Is it already here?
     */
    for (ppTmp = ppStart; *ppTmp; ppTmp = &((*ppTmp)->pNext)) {
        if (lstrcmp(((*ppTmp)->atch), ptsz) == 0) {
            // already there !
            return *ppTmp;
        }
    }

    cch = lstrlen(ptsz) + 1;
    cb = cch * sizeof(TCHAR);
    pNew = (FACENODE *)LocalAlloc(LPTR ,sizeof(FACENODE) + cb);
    if (pNew == NULL) {
        return NULL;
    }

    pNew->pNext = NULL;
    pNew->dwFlag = 0;

    hr = StringCchCopy(pNew->atch, cch, ptsz);
    if (FAILED(hr))
    {
        LocalFree(pNew);        // return as failure to allocate
        pNew = NULL;
    }

    *ppTmp = pNew;
    return pNew;
}


VOID
DestroyFaceNodes( CONSOLEPROP_DATA *pcpd ) {
    FACENODE * pNext;
    FACENODE * pTmp;

    pTmp = pcpd->gpFaceNames;
    while (pTmp != NULL) {
        pNext = pTmp->pNext;
        LocalFree(pTmp);
        pTmp = pNext;
    }
    pcpd->gpFaceNames = NULL;
}


int
AddFont(
    CONSOLEPROP_DATA *pcpd,
    ENUMLOGFONT *pelf,
    NEWTEXTMETRIC *pntm,
    int nFontType,
    HDC hDC,
    FACENODE * pFN
    )

/*++

    Add the font desribed by the LOGFONT structure to the font table if
    it's not already there.

--*/

{
    HFONT hFont;
    TEXTMETRIC tm;
    LONG nFont;
    COORD SizeToShow;
    COORD SizeActual;
    COORD SizeWant;
    BYTE tmFamily;
    SIZE Size;
    LPTSTR ptszFace = pelf->elfLogFont.lfFaceName;

    /* get font info */
    SizeWant.Y = (SHORT)pelf->elfLogFont.lfHeight;
    SizeWant.X = (SHORT)pelf->elfLogFont.lfWidth;
CreateBoldFont:
    hFont = CreateFontIndirect(&pelf->elfLogFont);
    ASSERT(hFont);
    if (!hFont) {
        return FE_SKIPFONT;  // same font in other sizes may still be suitable
    }

    //
    // for reasons unbeknownst to me, removing this code causes GDI
    // to yack, claiming that the font is owned by another process.
    //

    SelectObject(hDC, hFont);
    GetTextMetrics(hDC, &tm);

    GetTextExtentPoint32(hDC, TEXT("0"), 1, &Size);
    SizeActual.X = (SHORT)Size.cx;
    SizeActual.Y = (SHORT)(tm.tmHeight + tm.tmExternalLeading);
    tmFamily = tm.tmPitchAndFamily;
    if (TM_IS_TT_FONT(tmFamily) && (SizeWant.Y >= 0)) {
        SizeToShow = SizeWant;
        if (SizeWant.X == 0) {
            // Asking for zero width height gets a default aspect-ratio width
            // It's better to show that width rather than 0.
            SizeToShow.X = SizeActual.X;
        }
    } else {
        SizeToShow = SizeActual;
    }

    // there's a GDI bug - this assert fails occasionally
    //ASSERT (tm.tmMaxCharWidth == pntm->tmMaxCharWidth);

    /*
     * NOW, determine whether this font entry has already been cached
     * LATER : it may be possible to do this before creating the font, if
     * we can trust the dimensions & other info from pntm.
     * Sort by size:
     *  1) By pixelheight (negative Y values)
     *  2) By height (as shown)
     *  3) By width (as shown)
     */
    for (nFont = 0; nFont < (LONG)pcpd->NumberOfFonts; ++nFont) {
        COORD SizeShown;

        if (pcpd->FontInfo[nFont].hFont == NULL) {
            continue;
        }

        if (pcpd->FontInfo[nFont].SizeWant.X > 0) {
            SizeShown.X = pcpd->FontInfo[nFont].SizeWant.X;
        } else {
            SizeShown.X = pcpd->FontInfo[nFont].Size.X;
        }

        if (pcpd->FontInfo[nFont].SizeWant.Y > 0) {
            // This is a font specified by cell height.
            SizeShown.Y = pcpd->FontInfo[nFont].SizeWant.Y;
        } else {
            SizeShown.Y = pcpd->FontInfo[nFont].Size.Y;
            if (pcpd->FontInfo[nFont].SizeWant.Y < 0) {
                // This is a TT font specified by character height.
                if (SizeWant.Y < 0 && SizeWant.Y > pcpd->FontInfo[nFont].SizeWant.Y) {
                    // Requested pixelheight is smaller than this one.
                    break;
                }
            }
        }


        if (SIZE_EQUAL(SizeShown, SizeToShow) &&
                pcpd->FontInfo[nFont].Family == tmFamily &&
                pcpd->FontInfo[nFont].Weight == tm.tmWeight &&
                lstrcmp(pcpd->FontInfo[nFont].FaceName, ptszFace) == 0) {
            /*
             * Already have this font
             */
            DeleteObject(hFont);
            return FE_FONTOK;
        }


        if ((SizeToShow.Y < SizeShown.Y) ||
                (SizeToShow.Y == SizeShown.Y && SizeToShow.X < SizeShown.X)) {
            /*
             * This new font is smaller than nFont
             */
            break;
        }
    }

    /*
     * If we have to grow our font table, do it
     */
    if (pcpd->NumberOfFonts == pcpd->FontInfoLength) {
        FONT_INFO *Temp;

        pcpd->FontInfoLength += FONT_INCREMENT;
        Temp = (FONT_INFO *)LocalReAlloc(pcpd->FontInfo,
                                       sizeof(FONT_INFO) * pcpd->FontInfoLength, LMEM_MOVEABLE|LMEM_ZEROINIT);
        ASSERT(Temp);
        if (Temp == NULL) {
            pcpd->FontInfoLength -= FONT_INCREMENT;
            return FE_ABANDONFONT;  // no point enumerating more - no memory!
        }
        pcpd->FontInfo = Temp;
    }

    /*
     * The font we are adding should be inserted into the list,
     * if it is smaller than the last one.
     */
    if (nFont < (LONG)pcpd->NumberOfFonts) {
        MoveMemory( &pcpd->FontInfo[nFont+1],
                    &pcpd->FontInfo[nFont],
                    sizeof(FONT_INFO) * (pcpd->NumberOfFonts - nFont)
                   );
    }

    /*
     * Store the font info
     */
    pcpd->FontInfo[nFont].hFont = hFont;
    pcpd->FontInfo[nFont].Family = tmFamily;
    pcpd->FontInfo[nFont].Size = SizeActual;
    if (TM_IS_TT_FONT(tmFamily)) {
        pcpd->FontInfo[nFont].SizeWant = SizeWant;
    } else {
        pcpd->FontInfo[nFont].SizeWant.X = 0;
        pcpd->FontInfo[nFont].SizeWant.Y = 0;
    }
    pcpd->FontInfo[nFont].Weight = tm.tmWeight;
    pcpd->FontInfo[nFont].FaceName = pFN->atch;
    pcpd->FontInfo[nFont].tmCharSet = tm.tmCharSet;

    ++pcpd->NumberOfFonts;

    /*
     * If this is a true type font, create a bold version too.
     */
    if (nFontType == TRUETYPE_FONTTYPE && !IS_BOLD(pcpd->FontInfo[nFont].Weight)) {
          pelf->elfLogFont.lfWeight = FW_BOLD;
          goto CreateBoldFont;
    }

    return FE_FONTOK;  // and continue enumeration
}


NTSTATUS
InitializeFonts( CONSOLEPROP_DATA *pcpd )
{
    return EnumerateFonts( pcpd, EF_DEFFACE);  // Just the Default font
}

STDAPI_(void) DestroyFonts( CONSOLEPROP_DATA *pcpd )
{
    ULONG FontIndex;

    if (pcpd->FontInfo != NULL) {
        for (FontIndex = 0; FontIndex < pcpd->NumberOfFonts; FontIndex++) {
            DeleteObject(pcpd->FontInfo[FontIndex].hFont);
        }
        LocalFree(pcpd->FontInfo);
        pcpd->FontInfo = NULL;
        pcpd->NumberOfFonts = 0;
    }

    DestroyFaceNodes( pcpd );
}


/*
 * Returns bit combination
 *  FE_ABANDONFONT  - do not continue enumerating this font
 *  FE_SKIPFONT     - skip this font but keep enumerating
 *  FE_FONTOK       - font was created and added to cache or already there
 */
int
FontEnum(
    ENUMLOGFONT *pelf,
    NEWTEXTMETRIC *pntm,
    int nFontType,
    PFONTENUMDATA pfed
    )

/*++

    Is called exactly once by GDI for each font in the system.  This
    routine is used to store the FONT_INFO structure.

--*/

{
    UINT i;
    LPTSTR ptszFace = pelf->elfLogFont.lfFaceName;
    FACENODE * pFN;

    BOOL      bNegAC;

#ifdef DEBUG
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);

    // NTMW_STRUCTURE is different on 5.0+ platforms and the flag for 5.0+
    // platforms now lives in NEWTEXTMETRIC structure.
    AssertMsg(osvi.dwMajorVersion > 4, TEXT("We now only support running on Win2k or Millennium and later so we should never hit this."));
#endif

    bNegAC = !(pntm->ntmFlags & NTM_NONNEGATIVE_AC);

    //
    // reject variable width and italic fonts, also tt fonts with neg ac
    //

    if
    (
      !(pelf->elfLogFont.lfPitchAndFamily & FIXED_PITCH) ||
      (pelf->elfLogFont.lfItalic)                        ||
      bNegAC
    )
    {
        if (!IsAvailableTTFont(pfed->pcpd,ptszFace))
            return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
    }

    /*
     * reject TT fonts for whoom family is not modern, that is do not use
     * FF_DONTCARE    // may be surprised unpleasantly
     * FF_DECORATIVE  // likely to be symbol fonts
     * FF_SCRIPT      // cursive, inappropriate for console
     * FF_SWISS OR FF_ROMAN // variable pitch
     */

    if ((nFontType == TRUETYPE_FONTTYPE) &&
            ((pelf->elfLogFont.lfPitchAndFamily & 0xf0) != FF_MODERN)) {
        return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
    }

    /*
     * reject non-TT fonts that aren't OEM
     */
    if ((nFontType != TRUETYPE_FONTTYPE) &&
         (!IsFarEastCP(pfed->uDefCP) || !IS_ANY_DBCS_CHARSET(pelf->elfLogFont.lfCharSet)) &&
         (pelf->elfLogFont.lfCharSet != OEM_CHARSET)) {
        return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
    }

    /*
     * reject non-TT vertical/non-Terminal Font for FE
     */
    if (IsFarEastCP(pfed->uDefCP))
    {
        if ((nFontType != TRUETYPE_FONTTYPE) &&
            ((ptszFace[0] == TEXT('@')) ||
             (lstrcmp(ptszFace, TEXT("Terminal")) != 0)))
        {
            return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
        }
    }

    /*
     * reject Far East TT fonts that aren't Far East charset.
     */
    if (IsAvailableTTFont(pfed->pcpd, ptszFace) &&
        !IS_ANY_DBCS_CHARSET(pelf->elfLogFont.lfCharSet) &&
        !IsAvailableTTFontCP(pfed->pcpd, ptszFace,0)
       ) {
        return FE_SKIPFONT;    // should be enumerate next charset.
    }

    /*
     * Add or find the facename
     */
    pFN = AddFaceNode(&pfed->pcpd->gpFaceNames, ptszFace);
    if (pFN == NULL) {
        return FE_ABANDONFONT;
    }

    if (pfed->bFindFaces) {
        DWORD dwFontType = 0;
        if (nFontType == TRUETYPE_FONTTYPE) {
            dwFontType = EF_TTFONT;
        } else if (nFontType == RASTER_FONTTYPE) {
            dwFontType = EF_OEMFONT;
        }
        pFN->dwFlag |= dwFontType | EF_NEW;
        
        if (IS_ANY_DBCS_CHARSET(pelf->elfLogFont.lfCharSet))
            pFN->dwFlag |= EF_DBCSFONT;
            
        return FE_SKIPFONT;
    }


    if (IS_BOLD(pelf->elfLogFont.lfWeight)) {
        // return FE_SKIPFONT;
    }

    /*
     * Add the font to the table. If this is a true type font, add the
     * sizes from the array. Otherwise, just add the size we got.
     */
    if (nFontType & TRUETYPE_FONTTYPE) {
        for (i = 0; i < pfed->nTTPoints; i++) {
            pelf->elfLogFont.lfHeight = pfed->pTTPoints[i];
            pelf->elfLogFont.lfWidth  = 0;
            pelf->elfLogFont.lfWeight = 400;
            pfed->ulFE |= AddFont(pfed->pcpd, pelf, pntm, nFontType, pfed->hDC, pFN);
            if (pfed->ulFE & FE_ABANDONFONT) {
                return FE_ABANDONFONT;
            }
        }
    } else {
            pfed->ulFE |= AddFont(pfed->pcpd, pelf, pntm, nFontType, pfed->hDC, pFN);
            if (pfed->ulFE & FE_ABANDONFONT) {
                return FE_ABANDONFONT;
            }
    }

    return FE_FONTOK;  // and continue enumeration
}

BOOL
DoFontEnum(
    CONSOLEPROP_DATA *pcpd,
    HDC hDC,
    LPTSTR ptszFace,
    PSHORT pTTPoints,
    UINT nTTPoints)
{
    BOOL bDeleteDC = FALSE;
    FONTENUMDATA fed;
    LOGFONT LogFont;
    HRESULT hr = S_OK;

    if (hDC == NULL) {
        hDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
        bDeleteDC = TRUE;
    }

    fed.pcpd = pcpd;
    fed.hDC = hDC;
    fed.bFindFaces = (ptszFace == NULL);
    fed.ulFE = 0;
    fed.pTTPoints = pTTPoints;
    fed.nTTPoints = nTTPoints;
    fed.uDefCP = pcpd->uOEMCP;
    RtlZeroMemory(&LogFont, sizeof(LOGFONT));
    LogFont.lfCharSet = DEFAULT_CHARSET;
    if (ptszFace)
    {
        hr = StringCchCopy(LogFont.lfFaceName, ARRAYSIZE(LogFont.lfFaceName), ptszFace);
    }

    if (SUCCEEDED(hr))
    {
        /*
         * EnumFontFamiliesEx function enumerates one font in every face in every character set.
         */
        EnumFontFamiliesEx(hDC, &LogFont, (FONTENUMPROC)FontEnum, (LPARAM)&fed, 0);
    }

    if (bDeleteDC) {
        DeleteDC(hDC);
    }
    return (fed.ulFE & FE_FONTOK) != 0;
}


VOID
RemoveFace(CONSOLEPROP_DATA *pcpd, LPTSTR ptszFace)
{
    DWORD i;
    int nToRemove = 0;

    //
    // Delete & Remove fonts with Face Name == ptszFace
    //
    for (i = 0; i < pcpd->NumberOfFonts; i++) {
        if (lstrcmp(pcpd->FontInfo[i].FaceName, ptszFace) == 0) {
            BOOL bDeleted = DeleteObject(pcpd->FontInfo[i].hFont);
            pcpd->FontInfo[i].hFont = NULL;
            nToRemove++;
        } else if (nToRemove > 0) {
            /*
             * Shuffle from FontInfo[i] down nToRemove slots.
             */
            MoveMemory( &pcpd->FontInfo[i - nToRemove],
                        &pcpd->FontInfo[i],
                        sizeof(FONT_INFO)*(pcpd->NumberOfFonts - i)
                       );
            pcpd->NumberOfFonts -= nToRemove;
            i -= nToRemove;
            nToRemove = 0;
        }
    }
    pcpd->NumberOfFonts -= nToRemove;
}


NTSTATUS
EnumerateFonts(
    CONSOLEPROP_DATA *pcpd,
    DWORD Flags)
{
    TEXTMETRIC tm;
    HDC hDC;
    FACENODE * pFN;
    ULONG ulOldEnumFilter;
    BOOL  bEnumOEMFace = TRUE;
    DWORD FontIndex;
    DWORD dwFontType = 0;


    dwFontType = (EF_TTFONT|EF_OEMFONT|EF_DEFFACE) & Flags;

    if (pcpd->FontInfo == NULL) {
        //
        // allocate memory for the font array
        //
        pcpd->NumberOfFonts = 0;

        pcpd->FontInfo = (FONT_INFO *)LocalAlloc(LPTR, sizeof(FONT_INFO) * INITIAL_FONTS);
        if (pcpd->FontInfo == NULL)
            return STATUS_NO_MEMORY;
        pcpd->FontInfoLength = INITIAL_FONTS;
    }

    hDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);

    // Before enumeration, turn off font enumeration filters.
    ulOldEnumFilter = SetFontEnumeration(FE_FILTER_NONE);

    if (Flags & EF_DEFFACE) {
        SelectObject(hDC, GetStockObject(OEM_FIXED_FONT));
        GetTextFace(hDC, LF_FACESIZE, pcpd->DefaultFaceName);

        // Make sure we are going to enumerate the OEM face.
        pFN = AddFaceNode(&pcpd->gpFaceNames, pcpd->DefaultFaceName);
        if (NULL == pFN)
        {
            LocalFree(pcpd->FontInfo);
            pcpd->FontInfo       = NULL;
            pcpd->FontInfoLength = 0;
            pcpd->NumberOfFonts  = 0;
            SetFontEnumeration(ulOldEnumFilter);
            DeleteDC(hDC);
            return STATUS_NO_MEMORY;
        }

        pFN->dwFlag |= EF_DEFFACE | EF_OEMFONT;
        GetTextMetrics(hDC, &tm);
        pcpd->DefaultFontSize.X = (SHORT)(tm.tmMaxCharWidth);
        pcpd->DefaultFontSize.Y = (SHORT)(tm.tmHeight+tm.tmExternalLeading);
        pcpd->DefaultFontFamily = tm.tmPitchAndFamily;
        
        if (IS_ANY_DBCS_CHARSET(tm.tmCharSet))
            pcpd->DefaultFontSize.X /= 2;
    }

    if (pcpd->gbEnumerateFaces) {
        /*
         * Set the EF_OLD bit and clear the EF_NEW bit
         * for all previously available faces
         */
        for (pFN = pcpd->gpFaceNames; pFN; pFN = pFN->pNext) {
            pFN->dwFlag |= EF_OLD;
            pFN->dwFlag &= ~EF_NEW;
        }

        //
        // Use DoFontEnum to get the names of all the suitable Faces
        // All facenames found will be put in gpFaceNames with
        // the EF_NEW bit set.
        //
        DoFontEnum(pcpd, hDC, NULL, TTPoints, 1);
        pcpd->gbEnumerateFaces = FALSE;
    }

    // Use DoFontEnum to get all fonts from the system.  Our FontEnum
    // proc puts just the ones we want into an array
    //
    for (pFN = pcpd->gpFaceNames; pFN; pFN = pFN->pNext) {

        if ((pFN->dwFlag & (EF_OLD|EF_NEW)) == EF_OLD) {
            // The face is no longer available
            RemoveFace(pcpd, pFN->atch);
            pFN->dwFlag &= ~EF_ENUMERATED;
            continue;
        }
        if ((pFN->dwFlag & dwFontType) == 0) {
            // not the kind of face we want
            continue;
        }
        if (pFN->dwFlag & EF_ENUMERATED) {
            // we already enumerated this face
            continue;
        }

        if (pFN->dwFlag & EF_TTFONT) {
            if (IsFarEastCP(pcpd->uOEMCP) && !IsAvailableTTFontCP(pcpd, pFN->atch, 0))
                DoFontEnum(pcpd, hDC, pFN->atch, TTPointsDbcs, NELEM(TTPointsDbcs));
            else
                DoFontEnum(pcpd, hDC, pFN->atch, TTPoints, NELEM(TTPoints));
        } else {
            DoFontEnum(pcpd, hDC, pFN->atch, NULL, 0);

            // If we find that the face just enumerated is the same as OEM,
            // reset flag so we don't try to enumerate it again.

            if (lstrcmpi(pFN->atch, pcpd->DefaultFaceName) == 0)
            {
                bEnumOEMFace = FALSE;
            }
        }
        pFN->dwFlag |= EF_ENUMERATED;
    }


    // After enumerating fonts, restore the font enumeration filter.
    SetFontEnumeration(ulOldEnumFilter);

    DeleteDC(hDC);

    for (FontIndex = 0; FontIndex < pcpd->NumberOfFonts; FontIndex++) {
        if (pcpd->FontInfo[FontIndex].Size.X == pcpd->DefaultFontSize.X &&
            pcpd->FontInfo[FontIndex].Size.Y == pcpd->DefaultFontSize.Y &&
            pcpd->FontInfo[FontIndex].Family == pcpd->DefaultFontFamily) {
            break;
        }
    }
    ASSERT(FontIndex < pcpd->NumberOfFonts);
    if (FontIndex < pcpd->NumberOfFonts) {
        pcpd->DefaultFontIndex = FontIndex;
    } else {
        pcpd->DefaultFontIndex = 0;
    }

    return STATUS_SUCCESS;
}

/*
 * Get the font index for a new font
 * If necessary, attempt to create the font.
 * Always return a valid FontIndex (even if not correct)
 * Family:   Find/Create a font with of this Family
 *           0    - don't care
 * ptszFace: Find/Create a font with this face name.
 *           NULL or TEXT("")  - use DefaultFaceName
 * Size:     Must match SizeWant or actual Size.
 */
int
FindCreateFont(
    CONSOLEPROP_DATA *pcpd,
    DWORD Family,
    LPTSTR ptszFace,
    COORD Size,
    LONG Weight)
{
#define NOT_CREATED_NOR_FOUND -1
#define CREATED_BUT_NOT_FOUND -2

    int i;
    int FontIndex = NOT_CREATED_NOR_FOUND;
    BOOL bFontOK;
    TCHAR AltFaceName[LF_FACESIZE];
    COORD AltFontSize;
    BYTE  AltFontFamily;
    ULONG AltFontIndex = 0;
    LPTSTR ptszAltFace = NULL;
    UINT  uCurrentCP = pcpd->lpFEConsole->uCodePage;
    UINT  uDefaultCP = pcpd->uOEMCP;
    
    BYTE CharSet = CodePageToCharSet(uCurrentCP);

    if (!IsFarEastCP(uDefaultCP) || IS_ANY_DBCS_CHARSET(CharSet))
    {
        if (ptszFace == NULL || *ptszFace == TEXT('\0')) {
            ptszFace = pcpd->DefaultFaceName;
        }
        if (Size.Y == 0) {
            Size = pcpd->DefaultFontSize;
        }
    }
    else 
    {
        MakeAltRasterFont(pcpd, uCurrentCP, &AltFontSize, &AltFontFamily, &AltFontIndex, AltFaceName, ARRAYSIZE(AltFaceName));

        if (ptszFace == NULL || *ptszFace == L'\0') {
            ptszFace = AltFaceName;
        }
        if (Size.Y == 0) {
            Size.X = AltFontSize.X;
            Size.Y = AltFontSize.Y;
        }
    }

    if (IsAvailableTTFont(pcpd, ptszFace)) {
        ptszAltFace = GetAltFaceName(pcpd, ptszFace);
    }
    else {
        ptszAltFace = ptszFace;
    }

    /*
     * Try to find the exact font
     */
TryFindExactFont:
    for (i=0; i < (int)pcpd->NumberOfFonts; i++) {
        /*
         * If looking for a particular Family, skip non-matches
         */
        if ((Family != 0) &&
                ((BYTE)Family != pcpd->FontInfo[i].Family)) {
            continue;
        }

        /*
         * Skip non-matching sizes
         */
        if ((!SIZE_EQUAL(pcpd->FontInfo[i].SizeWant, Size) &&
             !SIZE_EQUAL(pcpd->FontInfo[i].Size, Size))) {
            continue;
        }

        /*
         * Skip non-matching weights
         */
        if ((Weight != 0) && (Weight != pcpd->FontInfo[i].Weight)) {
            continue;
        }

        /*
         * Skip fonts that have unmatched charset
         */
        if (!TM_IS_TT_FONT(pcpd->FontInfo[i].Family) &&
                pcpd->FontInfo[i].tmCharSet != CharSet) {
            continue;
        }
        
        /*
         * Size (and maybe Family) match.
         *  If we don't care about the name, or if it matches, use this font.
         *  Else if name doesn't match and it is a raster font, consider it.
         */
        if ((ptszFace == NULL) || (ptszFace[0] == TEXT('\0')) ||
                (lstrcmp(pcpd->FontInfo[i].FaceName, ptszFace) == 0) ||
                (lstrcmp(pcpd->FontInfo[i].FaceName, ptszAltFace) == 0) ) {
            FontIndex = i;
            goto FoundFont;
        } else if (!TM_IS_TT_FONT(pcpd->FontInfo[i].Family)) {
            FontIndex = i;
        }
    }

    if (FontIndex == NOT_CREATED_NOR_FOUND) {
        /*
         * Didn't find the exact font, so try to create it
         */
        ULONG ulOldEnumFilter;
        ulOldEnumFilter = SetFontEnumeration(FE_FILTER_NONE);
        if (Size.Y < 0) {
            Size.Y = -Size.Y;
        }
        bFontOK = DoFontEnum(pcpd, NULL, ptszFace, &Size.Y, 1);
        SetFontEnumeration(ulOldEnumFilter);
        if (bFontOK) {
            FontIndex = CREATED_BUT_NOT_FOUND;
            goto TryFindExactFont;
        } else {
        }
    } else if (FontIndex >= 0) {
        // a close Raster Font fit - only the name doesn't match.
        goto FoundFont;
    }

    /*
     * Failed to find exact match, even after enumeration, so now try
     * to find a font of same family and same size or bigger
     */
    for (i=0; i < (int)pcpd->NumberOfFonts; i++) {
    
        if ((Family != 0) &&
                ((BYTE)Family != pcpd->FontInfo[i].Family)) {
            continue;
        }

        if (!TM_IS_TT_FONT(pcpd->FontInfo[i].Family) &&
            pcpd->FontInfo[i].tmCharSet != CharSet) {
            continue;
        }

        if (pcpd->FontInfo[i].Size.Y >= Size.Y &&
                pcpd->FontInfo[i].Size.X >= Size.X) {
            // Same family, size >= desired.
            FontIndex = i;
            break;
        }
    }

    if (FontIndex < 0) {
        if (uCurrentCP == uDefaultCP) 
        {
            FontIndex = pcpd->DefaultFontIndex;
        }
        else 
        {
            FontIndex = AltFontIndex;
        }
    }

FoundFont:
    return FontIndex;

#undef NOT_CREATED_NOR_FOUND
#undef CREATED_BUT_NOT_FOUND
}


LPTSTR
TranslateConsoleTitle(
    LPTSTR ConsoleTitle
    )
/*++

    this routine translates path characters into '_' characters because
    the NT registry apis do not allow the creation of keys with
    names that contain path characters.  it allocates a buffer that
    must be freed.

--*/
{
    int ConsoleTitleLength, i;
    LPTSTR TranslatedTitle;

    ConsoleTitleLength = lstrlen(ConsoleTitle) + 1;
    TranslatedTitle = LocalAlloc(LPTR,
                                ConsoleTitleLength * sizeof(TCHAR));
    if (TranslatedTitle == NULL) {
        return NULL;
    }
    for (i = 0; i < ConsoleTitleLength; i++) {
        if (ConsoleTitle[i] == TEXT('\\')) {
            TranslatedTitle[i] = TEXT('_');
        } else {
            TranslatedTitle[i] = ConsoleTitle[i];
        }
    }
    return TranslatedTitle;
}



void
InitRegistryValues( CONSOLEPROP_DATA *pcpd )

/*++

Routine Description:

    This routine allocates a state info structure and fill it in with
    default values.  It then tries to load the default settings for
    console from the registry.

Arguments:

    none

Return Value:

    pStateInfo - pointer to structure to receive information

--*/

{
    TCHAR chSave;


    pcpd->lpConsole->wFillAttribute = 0x07;            // white on black
    pcpd->lpConsole->wPopupFillAttribute = 0xf5;      // purple on white
    pcpd->lpConsole->bInsertMode = FALSE;
    pcpd->lpConsole->bQuickEdit = FALSE;
    pcpd->lpConsole->bFullScreen = FALSE;
    pcpd->lpConsole->dwScreenBufferSize.X = 80;
    pcpd->lpConsole->dwScreenBufferSize.Y = 25;
    pcpd->lpConsole->dwWindowSize.X = 80;
    pcpd->lpConsole->dwWindowSize.Y = 25;
    pcpd->lpConsole->dwWindowOrigin.X = 0;
    pcpd->lpConsole->dwWindowOrigin.Y = 0;
    pcpd->lpConsole->bAutoPosition = TRUE;
    pcpd->lpConsole->dwFontSize.X = 0;
    pcpd->lpConsole->dwFontSize.Y = 0;
    pcpd->lpConsole->uFontFamily = 0;
    pcpd->lpConsole->uFontWeight = 0;
#ifdef UNICODE
    FillMemory( pcpd->lpConsole->FaceName, sizeof(pcpd->lpConsole->FaceName), 0 );
    pcpd->lpFaceName = (LPTSTR)pcpd->lpConsole->FaceName;
#else
    FillMemory( pcpd->szFaceName, sizeof(pcpd->szFaceName), 0 );
    pcpd->lpFaceName = pcpd->szFaceName;
#endif
    pcpd->lpConsole->uCursorSize = 25;
    pcpd->lpConsole->uHistoryBufferSize = 25;
    pcpd->lpConsole->uNumberOfHistoryBuffers = 4;
    pcpd->lpConsole->bHistoryNoDup = 0;
    pcpd->lpConsole->ColorTable[ 0] = RGB(0,   0,   0   );
    pcpd->lpConsole->ColorTable[ 1] = RGB(0,   0,   0x80);
    pcpd->lpConsole->ColorTable[ 2] = RGB(0,   0x80,0   );
    pcpd->lpConsole->ColorTable[ 3] = RGB(0,   0x80,0x80);
    pcpd->lpConsole->ColorTable[ 4] = RGB(0x80,0,   0   );
    pcpd->lpConsole->ColorTable[ 5] = RGB(0x80,0,   0x80);
    pcpd->lpConsole->ColorTable[ 6] = RGB(0x80,0x80,0   );
    pcpd->lpConsole->ColorTable[ 7] = RGB(0xC0,0xC0,0xC0);
    pcpd->lpConsole->ColorTable[ 8] = RGB(0x80,0x80,0x80);
    pcpd->lpConsole->ColorTable[ 9] = RGB(0,   0,   0xFF);
    pcpd->lpConsole->ColorTable[10] = RGB(0,   0xFF,0   );
    pcpd->lpConsole->ColorTable[11] = RGB(0,   0xFF,0xFF);
    pcpd->lpConsole->ColorTable[12] = RGB(0xFF,0,   0   );
    pcpd->lpConsole->ColorTable[13] = RGB(0xFF,0,   0xFF);
    pcpd->lpConsole->ColorTable[14] = RGB(0xFF,0xFF,0   );
    pcpd->lpConsole->ColorTable[15] = RGB(0xFF,0xFF,0xFF);
    pcpd->lpFEConsole->uCodePage    = pcpd->uOEMCP;
    
    // make console title NULL so we load the default settings for the console
    chSave = pcpd->ConsoleTitle[0];
    pcpd->ConsoleTitle[0] = TEXT('\0');
    GetRegistryValues( pcpd );

    // restore the console title
    pcpd->ConsoleTitle[0] = chSave;

}


VOID
GetTitleFromLinkName(
    LPTSTR szLinkName,
    LPTSTR szTitle,
    UINT cchTitle
    )
{
    LPTSTR pLnk, pDot;
    LPTSTR pPath = szLinkName;
    HRESULT hr;

    // Error checking
    if (!szTitle)
        return;

    if (!szLinkName)
    {
        szTitle[0] = TEXT('\0');
        return;
    }


    // find filename at end of fully qualified link name and point pLnk to it
    for (pLnk = pPath; *pPath; pPath++)
    {
        if ( (pPath[0] == TEXT('\\') || pPath[0] == TEXT(':')) &&
              pPath[1] &&
             (pPath[1] != TEXT('\\'))
            )
            pLnk = pPath + 1;
    }

    // find extension (.lnk)
    pPath = pLnk;
    for (pDot = NULL; *pPath; pPath++)
    {
        switch (*pPath) {
        case TEXT('.'):
            pDot = pPath;       // remember the last dot
            break;
        case TEXT('\\'):
        case TEXT(' '):              // extensions can't have spaces
            pDot = NULL;        // forget last dot, it was in a directory
            break;
        }
    }

    // if we found the extension, pDot points to it, if not, pDot
    // is NULL.

    if (pDot)
    {
        hr = StringCchCopyN(szTitle, cchTitle, pLnk, pDot - pLnk);
    }
    else
    {
        hr = StringCchCopy(szTitle, cchTitle, pLnk);
    }
    if (FAILED(hr))
    {
        szTitle[0] = TEXT('\0');
    }
}



VOID
GetRegistryValues(
    CONSOLEPROP_DATA *pcpd
    )

/*++

Routine Description:

    This routine reads in values from the registry and places them
    in the supplied structure.

Arguments:

    pStateInfo - optional pointer to structure to receive information

Return Value:

    current page number

--*/

{
    HKEY hConsoleKey;
    HKEY hTitleKey;
    LPTSTR TranslatedTitle;
    DWORD dwValue, dwSize;
    DWORD dwRet = 0;
    DWORD i;
    WCHAR awchBuffer[LF_FACESIZE];

    //
    // Open the console registry key
    //
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER, CONSOLE_REGISTRY_STRING,
                                      0, KEY_QUERY_VALUE, &hConsoleKey))
    {
        return;
    }

    //
    // If there is no structure to fill out, just bail out
    //

    if ((!pcpd) || (!pcpd->lpConsole))
        goto CloseKey;

    //
    // Open the console title subkey, if there is one
    //

    if (pcpd->ConsoleTitle[0] != TEXT('\0'))
    {
        TranslatedTitle = TranslateConsoleTitle(pcpd->ConsoleTitle);
        if (TranslatedTitle == NULL)
            goto GetDefaultConsole;
        dwValue = RegOpenKeyEx( hConsoleKey, TranslatedTitle,
                                0, KEY_QUERY_VALUE,
                                &hTitleKey);
        LocalFree(TranslatedTitle);
        if (dwValue!=ERROR_SUCCESS)
            goto GetDefaultConsole;
    } else {

GetDefaultConsole:
        hTitleKey = hConsoleKey;
    }

    //
    // Initial screen fill
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_FILLATTR,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->wFillAttribute = (WORD)dwValue;
    }

    //
    // Initial popup fill
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_POPUPATTR,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->wPopupFillAttribute = (WORD)dwValue;
    }

    //
    // Initial color table
    //

    for (i = 0; i < 16; i++)
    {
        StringCchPrintf(awchBuffer, ARRAYSIZE(awchBuffer), CONSOLE_REGISTRY_COLORTABLE, i); // ok to truncate - read will just fail
        dwSize = sizeof(dwValue);
        if (SHQueryValueEx( hTitleKey,
                             (LPTSTR)awchBuffer,
                             NULL,
                             NULL,
                             (LPBYTE)&dwValue,
                             &dwSize
                            ) == ERROR_SUCCESS)
        {
            pcpd->lpConsole->ColorTable[i] = dwValue;
        }
    }

    //
    // Initial insert mode
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_INSERTMODE,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->bInsertMode = !!dwValue;
    }

    //
    // Initial quick edit mode
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_QUICKEDIT,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->bQuickEdit = !!dwValue;
    }

#ifdef i386
    //
    // Initial full screen mode
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_FULLSCR,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->bFullScreen = !!dwValue;
    }
#endif

    //
    // Initial code page
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_CODEPAGE,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpFEConsole->uCodePage = (UINT)dwValue;
    }
    
    //
    // Initial screen buffer size
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_BUFFERSIZE,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->dwScreenBufferSize.X = LOWORD(dwValue);
        pcpd->lpConsole->dwScreenBufferSize.Y = HIWORD(dwValue);
    }

    //
    // Initial window size
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_WINDOWSIZE,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->dwWindowSize.X = LOWORD(dwValue);
        pcpd->lpConsole->dwWindowSize.Y = HIWORD(dwValue);
    }

    //
    // Initial window position
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_WINDOWPOS,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->dwWindowOrigin.X = (SHORT)LOWORD(dwValue);
        pcpd->lpConsole->dwWindowOrigin.Y = (SHORT)HIWORD(dwValue);
        pcpd->lpConsole->bAutoPosition = FALSE;
    }

    //
    // Initial font size
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_FONTSIZE,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->dwFontSize.X = LOWORD(dwValue);
        pcpd->lpConsole->dwFontSize.Y = HIWORD(dwValue);
    }

    //
    // Initial font family
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_FONTFAMILY,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->uFontFamily = dwValue;
    }

    //
    // Initial font weight
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_FONTWEIGHT,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->uFontWeight = dwValue;
    }

    //
    // Initial font face name
    //

    dwSize = sizeof(awchBuffer);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_FACENAME,
                         NULL,
                         NULL,
                         (LPBYTE)awchBuffer,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        CopyMemory((LPBYTE)pcpd->lpFaceName, (LPBYTE)awchBuffer, LF_FACESIZE*sizeof(TCHAR));
        pcpd->lpFaceName[ARRAYSIZE(pcpd->lpFaceName)-1] = TEXT('\0');
    }

    //
    // Initial cursor size
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_CURSORSIZE,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->uCursorSize = dwValue;
    }

    //
    // Initial history buffer size
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_HISTORYSIZE,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->uHistoryBufferSize = dwValue;
    }

    //
    // Initial number of history buffers
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_HISTORYBUFS,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->uNumberOfHistoryBuffers = dwValue;
    }

    //
    // Initial history duplication mode
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_HISTORYNODUP,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpConsole->bHistoryNoDup = dwValue;
    }

    //
    // Close the registry keys
    //

    if (hTitleKey != hConsoleKey) {
        RegCloseKey(hTitleKey);
    }

CloseKey:
    RegCloseKey(hConsoleKey);
}


VOID
SetRegistryValues(
    CONSOLEPROP_DATA *pcpd
    )

/*++

Routine Description:

    This routine writes values to the registry from the supplied
    structure.

Arguments:

    pStateInfo - optional pointer to structure containing information
    dwPage     - current page number

Return Value:

    none

--*/

{
    HKEY hConsoleKey;
    HKEY hTitleKey;
    LPTSTR TranslatedTitle;
    DWORD dwValue;
    DWORD i;
    WCHAR awchBuffer[LF_FACESIZE];

    //
    // Open the console registry key
    //
    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER, CONSOLE_REGISTRY_STRING,
                                        0, NULL, 0, KEY_SET_VALUE, NULL,
                                        &hConsoleKey, NULL))
    {
        return;
    }

    //
    // If we only want to save the current page, bail out
    //

    if (pcpd == NULL)
    {
        goto CloseKey;
    }

    //
    // Open the console title subkey, if there is one
    //

    if (pcpd->ConsoleTitle[0] != TEXT('\0'))
    {
        TranslatedTitle = TranslateConsoleTitle(pcpd->ConsoleTitle);
        if (TranslatedTitle == NULL)
        {
            RegCloseKey(hConsoleKey);
            return;
        }
        dwValue = RegCreateKeyEx( hConsoleKey, TranslatedTitle,
                                  0, NULL, 0, KEY_SET_VALUE, NULL,
                                  &hTitleKey, NULL);
        LocalFree(TranslatedTitle);
        if (dwValue!=ERROR_SUCCESS)
        {
            RegCloseKey(hConsoleKey);
            return;
        }
    } else {
        hTitleKey = hConsoleKey;
    }

    //
    // Save screen and popup colors and color table
    //

    dwValue = pcpd->lpConsole->wFillAttribute;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_FILLATTR,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
    dwValue = pcpd->lpConsole->wPopupFillAttribute;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_POPUPATTR,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
    for (i = 0; i < 16; i++)
    {
        dwValue = pcpd->lpConsole->ColorTable[i];
        StringCchPrintf(awchBuffer, ARRAYSIZE(awchBuffer), CONSOLE_REGISTRY_COLORTABLE, i);    // truncation will never happen
        RegSetValueEx( hTitleKey,
                       (LPTSTR)awchBuffer,
                       0,
                       REG_DWORD,
                       (LPBYTE)&dwValue,
                       sizeof(dwValue)
                      );
    }

    //
    // Save insert, quickedit, and fullscreen mode settings
    //

    dwValue = pcpd->lpConsole->bInsertMode;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_INSERTMODE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
    dwValue = pcpd->lpConsole->bQuickEdit;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_QUICKEDIT,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
#ifdef i386
    dwValue = pcpd->lpConsole->bFullScreen;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_FULLSCR,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
#endif

    //
    // Save screen buffer size
    //

    dwValue = MAKELONG(pcpd->lpConsole->dwScreenBufferSize.X,
                       pcpd->lpConsole->dwScreenBufferSize.Y);
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_BUFFERSIZE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );

    //
    // Save window size
    //

    dwValue = MAKELONG(pcpd->lpConsole->dwWindowSize.X,
                       pcpd->lpConsole->dwWindowSize.Y);
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_WINDOWSIZE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );

    //
    // Save window position
    //

    if (pcpd->lpConsole->bAutoPosition) {
        RegDeleteKey(hTitleKey, CONSOLE_REGISTRY_WINDOWPOS);
    } else {
        dwValue = MAKELONG(pcpd->lpConsole->dwWindowOrigin.X,
                           pcpd->lpConsole->dwWindowOrigin.Y);
        RegSetValueEx( hTitleKey,
                       CONSOLE_REGISTRY_WINDOWPOS,
                       0,
                       REG_DWORD,
                       (LPBYTE)&dwValue,
                       sizeof(dwValue)
                      );
    }

    //
    // Save font size, family, weight, and face name
    //

    dwValue = MAKELONG(pcpd->lpConsole->dwFontSize.X,
                       pcpd->lpConsole->dwFontSize.Y);
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_FONTSIZE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
    dwValue = pcpd->lpConsole->uFontFamily;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_FONTFAMILY,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
    dwValue = pcpd->lpConsole->uFontWeight;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_FONTWEIGHT,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_FACENAME,
                   0,
                   REG_SZ,
                   (LPBYTE)pcpd->lpFaceName,
                   (lstrlen(pcpd->lpFaceName) + 1) * sizeof(TCHAR)
                 );

    //
    // Save cursor size
    //

    dwValue = pcpd->lpConsole->uCursorSize;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_CURSORSIZE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );

    //
    // Save history buffer size and number
    //

    dwValue = pcpd->lpConsole->uHistoryBufferSize;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_HISTORYSIZE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
    dwValue = pcpd->lpConsole->uNumberOfHistoryBuffers;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_HISTORYBUFS,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );
    dwValue = pcpd->lpConsole->bHistoryNoDup;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_HISTORYNODUP,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );

    //
    // Close the registry keys
    //

    if (hTitleKey != hConsoleKey) {
        RegCloseKey(hTitleKey);
    }

CloseKey:
    RegCloseKey(hConsoleKey);
}

void
InitFERegistryValues( CONSOLEPROP_DATA *pcpd )

/*++

Routine Description:

    This routine allocates a state info structure and fill it in with
    default values.  It then tries to load the default settings for
    console from the registry.

Arguments:

    none

Return Value:

    pStateInfo - pointer to structure to receive information

--*/

{
    /*
     * In this case: console reads a property of US version.
     * It doesn't have code page information.
     * Console should sets some code page as default.
     * However, I don't know right value. 437 is temporary value.
     */
    pcpd->lpFEConsole->uCodePage = 437;

    GetFERegistryValues( pcpd );
}


VOID
GetFERegistryValues(
    CONSOLEPROP_DATA *pcpd
    )

/*++

Routine Description:

    This routine reads in values from the registry and places them
    in the supplied structure.

Arguments:

    pStateInfo - optional pointer to structure to receive information

Return Value:

    current page number

--*/

{
    HKEY hConsoleKey;
    HKEY hTitleKey;
    LPTSTR TranslatedTitle;
    DWORD dwValue, dwSize;
    DWORD dwRet = 0;

    //
    // Open the console registry key
    //

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER, CONSOLE_REGISTRY_STRING,
                                      0, KEY_QUERY_VALUE, &hConsoleKey))
    {
        return;
    }

    //
    // If there is no structure to fill out, just bail out
    //

    if ((!pcpd) || (!pcpd->lpFEConsole))
        goto CloseKey;

    //
    // Open the console title subkey, if there is one
    //

    if (pcpd->ConsoleTitle[0] != TEXT('\0'))
    {
        TranslatedTitle = TranslateConsoleTitle(pcpd->ConsoleTitle);
        if (TranslatedTitle == NULL)
            goto CloseKey;
        dwValue = RegOpenKeyEx( hConsoleKey, TranslatedTitle,
                                0, KEY_QUERY_VALUE,
                                &hTitleKey);
        LocalFree(TranslatedTitle);
        if (dwValue!=ERROR_SUCCESS)
            goto CloseKey;
    } else {
            goto CloseKey;
    }

    //
    // Initial code page
    //

    dwSize = sizeof(dwValue);
    if (SHQueryValueEx( hTitleKey,
                         CONSOLE_REGISTRY_CODEPAGE,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize
                        ) == ERROR_SUCCESS)
    {
        pcpd->lpFEConsole->uCodePage = (UINT)dwValue;
    }

    //
    // Close the registry keys
    //

    if (hTitleKey != hConsoleKey) {
        RegCloseKey(hTitleKey);
    }

CloseKey:
    RegCloseKey(hConsoleKey);

}


VOID
SetFERegistryValues(
    CONSOLEPROP_DATA *pcpd
    )

/*++

Routine Description:

    This routine writes values to the registry from the supplied
    structure.

Arguments:

    pStateInfo - optional pointer to structure containing information
    dwPage     - current page number

Return Value:

    none

--*/

{
    HKEY hConsoleKey;
    HKEY hTitleKey;
    LPTSTR TranslatedTitle;
    DWORD dwValue;

    //
    // Open the console registry key
    //

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER, CONSOLE_REGISTRY_STRING,
                                        0, NULL, 0, KEY_SET_VALUE, NULL,
                                        &hConsoleKey, NULL))
    {
        return;
    }

    //
    // If we only want to save the current page, bail out
    //

    if (pcpd == NULL)
    {
        goto CloseKey;
    }

    //
    // Open the console title subkey, if there is one
    //

    if (pcpd->ConsoleTitle[0] != TEXT('\0'))
    {
        TranslatedTitle = TranslateConsoleTitle(pcpd->ConsoleTitle);
        if (TranslatedTitle == NULL)
        {
            RegCloseKey(hConsoleKey);
            return;
        }
        dwValue = RegCreateKeyEx( hConsoleKey, TranslatedTitle,
                                  0, NULL, 0, KEY_SET_VALUE, NULL,
                                  &hTitleKey, NULL);
        LocalFree(TranslatedTitle);
        if (dwValue!=ERROR_SUCCESS)
        {
            goto CloseKey;
        }
    } else {
        hTitleKey = hConsoleKey;
    }

    // scotthsu
    dwValue = pcpd->lpFEConsole->uCodePage;
    RegSetValueEx( hTitleKey,
                   CONSOLE_REGISTRY_CODEPAGE,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(dwValue)
                  );

    //
    // Close the registry keys
    //

    if (hTitleKey != hConsoleKey) {
        RegCloseKey(hTitleKey);
    }

CloseKey:
    RegCloseKey(hConsoleKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\lstrfns.h ===
#define OFFSET(x) ((PSTR)(LOWORD((DWORD)(x))))

extern LPWSTR StrChrW(LPCWSTR lpStart, WCHAR wMatch);
extern LPSTR StrChrA(LPCSTR lpStart, CHAR wMatch);
extern LPWSTR StrRChrW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch);
extern LPSTR StrRChrA(LPCSTR lptart, LPCSTR lpEnd, CHAR wMatch);
extern LPWSTR StrChrIW(LPCWSTR lpStart, WCHAR wMatch);
extern LPSTR StrChrIA(LPCSTR lptart, CHAR wMatch);
extern LPWSTR StrRChrIW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch);
extern LPSTR StrRChrIA(LPCSTR lptart, LPCSTR lpEnd, CHAR wMatch);
extern INT StrCpyNW(LPWSTR lpDest, LPWSTR lpSource, INT nBufSize);
extern INT StrCpyNA(LPSTR lpest, LPSTR lpSource, INT nBufSize);
extern INT StrNCpyW(LPWSTR lpDest, LPWSTR lpSource, INT nChar);
extern INT StrNCpyA(LPSTR lpest, LPSTR lpSource, INT nChar);
extern LPWSTR StrStrW(LPWSTR lpFirst, LPWSTR lpSrch);
extern LPSTR StrStrA(LPSTR lpirst, LPSTR lpSrch);
extern LPWSTR StrRStrW(LPWSTR lpSource, LPWSTR lpLast, LPWSTR lpSrch);
extern LPSTR StrRStrA(LPSTR lpource, LPSTR lpLast, LPSTR lpSrch);
extern LPWSTR StrStrIW(LPWSTR lpFirst, LPWSTR lpSrch);
extern LPSTR StrStrIA(LPSTR lpirst, LPSTR lpSrch);
extern LPWSTR StrRStrIW(LPWSTR lpSource, LPWSTR lpLast, LPWSTR lpSrch);
extern LPSTR StrRStrIA(LPSTR lpSource, LPSTR lpLast, LPSTR lpSrch);

extern BOOL IntlStrEqWorkerW(BOOL fCaseSens, LPCWSTR lpWStr1, LPCWSTR lpWStr2, INT nChar);
extern BOOL IntlStrEqWorkerA(BOOL fCaseSens, LPCSTR lptr1, LPCSTR lpWStr2, INT nChar);

#ifndef UNICODE
#define StrChr StrChrA
#define StrRChr StrRChrA
#define StrChrI StrChrIA
#define StrRChrI StrRChrIA
#define StrCpyN StrCpyNA
#define StrNCpy StrNCpyA
#define StrStr StrStrA
#define StrRStr StrRStrA
#define StrStrI StrStrIA
#define StrRStrI StrRStrIA
#define IntlStrEqN(lpStr1, lpStr2, nChar)   IntlStrEqWorkerA(  TRUE, lpStr1, lpStr2, nChar)
#define IntlStrEqNI(lpStr1, lpStr2, nChar)  IntlStrEqWorkerA( FALSE, lpStr1, lpStr2, nChar)
#else
#define StrChr StrChrW
#define StrRChr StrRChrW
#define StrChrI StrChrIW
#define StrRChrI StrRChrIW
#define StrCpyN StrCpyNW
#define StrNCpy StrNCpyW
#define StrStr StrStrW
#define StrRStr StrRStrW
#define StrStrI StrStrIW
#define StrRStrI StrRStrIW
#define IntlStrEqN(lpStr1, lpStr2, nChar)   IntlStrEqWorkerW(  TRUE, lpStr1, lpStr2, nChar)
#define IntlStrEqNI(lpStr1, lpStr2, nChar)  IntlStrEqWorkerW( FALSE, lpStr1, lpStr2, nChar)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\lnkprev.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    preview.c

Abstract:

    This module contains the code for console preview window

Author:

    Therese Stowell (thereses) Feb-3-1992 (swiped from Win3.1)

Revision History:

--*/

#include "shellprv.h"
#pragma hdrstop

#include "lnkcon.h"

/* ----- Equates ----- */

LONG CnslAspectScale( LONG n1, LONG n2, LONG m );
void CnslAspectPoint( CONSOLEPROP_DATA * pcpd, RECT* rectPreview, POINT* pt);


VOID
UpdatePreviewRect( CONSOLEPROP_DATA * pcpd )

/*++

    Update the global window size and dimensions

--*/

{
    POINT MinSize;
    POINT MaxSize;
    POINT WindowSize;
    FONT_INFO *lpFont;
    HMONITOR hMonitor;
    MONITORINFO mi;

    /*
     * Get the font pointer
     */
    lpFont = &pcpd->FontInfo[pcpd->CurrentFontIndex];

    /*
     * Get the window size
     */
    MinSize.x = (GetSystemMetrics(SM_CXMIN)-pcpd->NonClientSize.x) / lpFont->Size.X;
    MinSize.y = (GetSystemMetrics(SM_CYMIN)-pcpd->NonClientSize.y) / lpFont->Size.Y;
    MaxSize.x = GetSystemMetrics(SM_CXFULLSCREEN) / lpFont->Size.X;
    MaxSize.y = GetSystemMetrics(SM_CYFULLSCREEN) / lpFont->Size.Y;
    WindowSize.x = max(MinSize.x, min(MaxSize.x, pcpd->lpConsole->dwWindowSize.X));
    WindowSize.y = max(MinSize.y, min(MaxSize.y, pcpd->lpConsole->dwWindowSize.Y));

    /*
     * Get the window rectangle, making sure it's at least twice the
     * size of the non-client area.
     */
    pcpd->WindowRect.left = pcpd->lpConsole->dwWindowOrigin.X;
    pcpd->WindowRect.top = pcpd->lpConsole->dwWindowOrigin.Y;
    pcpd->WindowRect.right = WindowSize.x * lpFont->Size.X + pcpd->NonClientSize.x;
    if (pcpd->WindowRect.right < pcpd->NonClientSize.x * 2) {
        pcpd->WindowRect.right = pcpd->NonClientSize.x * 2;
    }
    pcpd->WindowRect.right += pcpd->WindowRect.left;
    pcpd->WindowRect.bottom = WindowSize.y * lpFont->Size.Y + pcpd->NonClientSize.y;
    if (pcpd->WindowRect.bottom < pcpd->NonClientSize.y * 2) {
        pcpd->WindowRect.bottom = pcpd->NonClientSize.y * 2;
    }
    pcpd->WindowRect.bottom += pcpd->WindowRect.top;

    /*
     * Get information about the monitor we're on
     */
    hMonitor = MonitorFromRect(&pcpd->WindowRect, MONITOR_DEFAULTTONEAREST);
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMonitor, &mi);
    pcpd->xScreen = mi.rcWork.right - mi.rcWork.left;
    pcpd->yScreen = mi.rcWork.bottom - mi.rcWork.top;

    /*
     * Convert window rectangle to monitor relative coordinates
     */
    pcpd->WindowRect.right  -= pcpd->WindowRect.left;
    pcpd->WindowRect.left   -= mi.rcWork.left;
    pcpd->WindowRect.bottom -= pcpd->WindowRect.top;
    pcpd->WindowRect.top    -= mi.rcWork.top;

    /*
     * Update the display flags
     */
    if (WindowSize.x < pcpd->lpConsole->dwScreenBufferSize.X) {
        pcpd->PreviewFlags |= PREVIEW_HSCROLL;
    } else {
        pcpd->PreviewFlags &= ~PREVIEW_HSCROLL;
    }
    if (WindowSize.y < pcpd->lpConsole->dwScreenBufferSize.Y) {
        pcpd->PreviewFlags |= PREVIEW_VSCROLL;
    } else {
        pcpd->PreviewFlags &= ~PREVIEW_VSCROLL;
    }
}


VOID
InvalidatePreviewRect(HWND hWnd, CONSOLEPROP_DATA * pcpd)

/*++

    Invalidate the area covered by the preview "window"

--*/

{
    RECT rectWin;
    RECT rectPreview;


    /*
     * Get the size of the preview "screen"
     */
    GetClientRect(hWnd, &rectPreview);

    /*
     * Get the dimensions of the preview "window" and scale it to the
     * preview "screen"
     */
    rectWin.left   = pcpd->WindowRect.left;
    rectWin.top    = pcpd->WindowRect.top;
    rectWin.right  = pcpd->WindowRect.left + pcpd->WindowRect.right;
    rectWin.bottom = pcpd->WindowRect.top + pcpd->WindowRect.bottom;
    CnslAspectPoint( pcpd, &rectPreview, (POINT*)&rectWin.left);
    CnslAspectPoint( pcpd, &rectPreview, (POINT*)&rectWin.right);

    /*
     * Invalidate the area covered by the preview "window"
     */
    InvalidateRect(hWnd, &rectWin, FALSE);
}


VOID
PreviewPaint(
    PAINTSTRUCT* pPS,
    HWND hWnd,
    CONSOLEPROP_DATA * pcpd
    )

/*++

    Paints the font preview.  This is called inside the paint message
    handler for the preview window

--*/

{
    RECT rectWin;
    RECT rectPreview;
    HBRUSH hbrFrame;
    HBRUSH hbrTitle;
    HBRUSH hbrOld;
    HBRUSH hbrClient;
    HBRUSH hbrBorder;
    HBRUSH hbrButton;
    HBRUSH hbrScroll;
    HBRUSH hbrDesktop;
    POINT ptButton;
    POINT ptScroll;
    HDC hDC;
    HBITMAP hBitmap;
    HBITMAP hBitmapOld;
    COLORREF rgbClient;


    /*
     * Get the size of the preview "screen"
     */
    GetClientRect(hWnd, &rectPreview);

    /*
     * Get the dimensions of the preview "window" and scale it to the
     * preview "screen"
     */
    rectWin = pcpd->WindowRect;
    CnslAspectPoint( pcpd, &rectPreview, (POINT*)&rectWin.left);
    CnslAspectPoint( pcpd, &rectPreview, (POINT*)&rectWin.right);

    /*
     * Compute the dimensions of some other window components
     */
    ptButton.x = GetSystemMetrics(SM_CXSIZE);
    ptButton.y = GetSystemMetrics(SM_CYSIZE);
    CnslAspectPoint( pcpd, &rectPreview, &ptButton);
    ptButton.y *= 2;       /* Double the computed size for "looks" */
    ptScroll.x = GetSystemMetrics(SM_CXVSCROLL);
    ptScroll.y = GetSystemMetrics(SM_CYHSCROLL);
    CnslAspectPoint( pcpd, &rectPreview, &ptScroll);

    /*
     * Create the memory device context
     */
    hDC = CreateCompatibleDC(pPS->hdc);
    hBitmap = CreateCompatibleBitmap(pPS->hdc,
                                     rectPreview.right,
                                     rectPreview.bottom);
    hBitmapOld = SelectObject(hDC, hBitmap);

    /*
     * Create the brushes
     */
    hbrBorder  = CreateSolidBrush(GetSysColor(COLOR_ACTIVEBORDER));
    hbrTitle   = CreateSolidBrush(GetSysColor(COLOR_ACTIVECAPTION));
    hbrFrame   = CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME));
    hbrButton  = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
    hbrScroll  = CreateSolidBrush(GetSysColor(COLOR_SCROLLBAR));
    hbrDesktop = CreateSolidBrush(GetSysColor(COLOR_BACKGROUND));
    rgbClient  = GetNearestColor(hDC, ScreenBkColor(pcpd));
    hbrClient  = CreateSolidBrush(rgbClient);

    /*
     * Erase the clipping area
     */
    FillRect(hDC, &(pPS->rcPaint), hbrDesktop);

    /*
     * Fill in the whole window with the client brush
     */
    hbrOld = SelectObject(hDC, hbrClient);
    PatBlt(hDC, rectWin.left, rectWin.top,
           rectWin.right - 1, rectWin.bottom - 1, PATCOPY);

    /*
     * Fill in the caption bar
     */
    SelectObject(hDC, hbrTitle);
    PatBlt(hDC, rectWin.left + 3, rectWin.top + 3,
           rectWin.right - 7, ptButton.y - 2, PATCOPY);

    /*
     * Draw the "buttons"
     */
    SelectObject(hDC, hbrButton);
    PatBlt(hDC, rectWin.left + 3, rectWin.top + 3,
           ptButton.x, ptButton.y - 2, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4 - ptButton.x,
           rectWin.top + 3,
           ptButton.x, ptButton.y - 2, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4 - 2 * ptButton.x - 1,
           rectWin.top + 3,
           ptButton.x, ptButton.y - 2, PATCOPY);
    SelectObject(hDC, hbrFrame);
    PatBlt(hDC, rectWin.left + 3 + ptButton.x, rectWin.top + 3,
           1, ptButton.y - 2, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4 - ptButton.x - 1,
           rectWin.top + 3,
           1, ptButton.y - 2, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4 - 2 * ptButton.x - 2,
           rectWin.top + 3,
           1, ptButton.y - 2, PATCOPY);

    /*
     * Draw the scrollbars
     */
    SelectObject(hDC, hbrScroll);
    if (pcpd->PreviewFlags & PREVIEW_HSCROLL) {
        PatBlt(hDC, rectWin.left + 3,
               rectWin.top + rectWin.bottom - 4 - ptScroll.y,
               rectWin.right - 7, ptScroll.y, PATCOPY);
    }
    if (pcpd->PreviewFlags & PREVIEW_VSCROLL) {
        PatBlt(hDC, rectWin.left + rectWin.right - 4 - ptScroll.x,
               rectWin.top + 1 + ptButton.y + 1,
               ptScroll.x, rectWin.bottom - 6 - ptButton.y, PATCOPY);
        if (pcpd->PreviewFlags & PREVIEW_HSCROLL) {
            SelectObject(hDC, hbrFrame);
            PatBlt(hDC, rectWin.left + rectWin.right - 5 - ptScroll.x,
                   rectWin.top + rectWin.bottom - 4 - ptScroll.y,
                   1, ptScroll.y, PATCOPY);
            PatBlt(hDC, rectWin.left + rectWin.right - 4 - ptScroll.x,
                   rectWin.top + rectWin.bottom - 5 - ptScroll.y,
                   ptScroll.x, 1, PATCOPY);
        }
    }

    /*
     * Draw the interior window frame and caption frame
     */
    SelectObject(hDC, hbrFrame);
    PatBlt(hDC, rectWin.left + 2, rectWin.top + 2,
           1, rectWin.bottom - 5, PATCOPY);
    PatBlt(hDC, rectWin.left + 2, rectWin.top + 2,
           rectWin.right - 5, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + 2, rectWin.top + rectWin.bottom - 4,
           rectWin.right - 5, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4, rectWin.top + 2,
           1, rectWin.bottom - 5, PATCOPY);
    PatBlt(hDC, rectWin.left + 2, rectWin.top + 1 + ptButton.y,
           rectWin.right - 5, 1, PATCOPY);

    /*
     * Draw the border
     */
    SelectObject(hDC, hbrBorder);
    PatBlt(hDC, rectWin.left + 1, rectWin.top + 1,
           1, rectWin.bottom - 3, PATCOPY);
    PatBlt(hDC, rectWin.left + 1, rectWin.top + 1,
           rectWin.right - 3, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + 1, rectWin.top + rectWin.bottom - 3,
           rectWin.right - 3, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 3, rectWin.top + 1,
           1, rectWin.bottom - 3, PATCOPY);

    /*
     * Draw the exterior window frame
     */
    SelectObject(hDC, hbrFrame);
    PatBlt(hDC, rectWin.left, rectWin.top,
           1, rectWin.bottom - 1, PATCOPY);
    PatBlt(hDC, rectWin.left, rectWin.top,
           rectWin.right - 1, 1, PATCOPY);
    PatBlt(hDC, rectWin.left, rectWin.top + rectWin.bottom - 2,
           rectWin.right - 1, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 2, rectWin.top,
           1, rectWin.bottom - 1, PATCOPY);

    /*
     * Copy the memory device context to the screen device context
     */
    BitBlt(pPS->hdc, 0, 0, rectPreview.right, rectPreview.bottom,
           hDC, 0, 0, SRCCOPY);

    /*
     * Clean up everything
     */
    SelectObject(hDC, hbrOld);
    SelectObject(hDC, hBitmapOld);
    DeleteObject(hbrBorder);
    DeleteObject(hbrFrame);
    DeleteObject(hbrTitle);
    DeleteObject(hbrClient);
    DeleteObject(hbrButton);
    DeleteObject(hbrScroll);
    DeleteObject(hbrDesktop);
    DeleteObject(hBitmap);
    DeleteDC(hDC);
}


#define LPCS_INDEX 0
#define PCPD_INDEX sizeof(PVOID)

LRESULT
PreviewWndProc(
    HWND hWnd,
    UINT wMessage,
    WPARAM wParam,
    LPARAM lParam
    )

/*
 * PreviewWndProc
 *      Handles the preview window
 */

{
    PAINTSTRUCT ps;
    LPCREATESTRUCT lpcs;
    RECT rcWindow;
    CONSOLEPROP_DATA * pcpd;
    int cx;
    int cy;


    switch (wMessage) {
    case WM_CREATE:
        lpcs = (LPCREATESTRUCT)LocalAlloc( LPTR, SIZEOF( CREATESTRUCT ) );
        if (lpcs)
        {
            CopyMemory( (PVOID)lpcs, (PVOID)lParam, SIZEOF( CREATESTRUCT ) );
            SetWindowLongPtr( hWnd, LPCS_INDEX, (LONG_PTR)lpcs );
        }
        else
            return 0;
        break;

    case CM_PREVIEW_INIT:

        pcpd = (CONSOLEPROP_DATA *)lParam;
        SetWindowLongPtr( hWnd, PCPD_INDEX, (LONG_PTR)pcpd );

        /*
         * Figure out space used by non-client area
         */
        SetRect(&rcWindow, 0, 0, 50, 50);
        AdjustWindowRect(&rcWindow, WS_OVERLAPPEDWINDOW, FALSE);
        pcpd->NonClientSize.x = rcWindow.right - rcWindow.left - 50;
        pcpd->NonClientSize.y = rcWindow.bottom - rcWindow.top - 50;

        /*
         * Compute the size of the preview "window"
         */
        UpdatePreviewRect( pcpd );

        /*
         * Scale the window so it has the same aspect ratio as the screen
         */
        lpcs = (LPCREATESTRUCT)GetWindowLongPtr( hWnd, LPCS_INDEX );
        cx = lpcs->cx;
        cy = CnslAspectScale( pcpd->yScreen, pcpd->xScreen, cx);
        if (cy > lpcs->cy) {
            cy = lpcs->cy;
            cx = CnslAspectScale(pcpd->xScreen, pcpd->yScreen, cy);
        }
        MoveWindow(hWnd, lpcs->x, lpcs->y, cx, cy, TRUE);
        break;

    case WM_PAINT:
        pcpd = (CONSOLEPROP_DATA *)GetWindowLongPtr( hWnd, PCPD_INDEX );
        BeginPaint(hWnd, &ps);
        if (pcpd)
            PreviewPaint(&ps, hWnd, pcpd);
        EndPaint(hWnd, &ps);
        break;

    case CM_PREVIEW_UPDATE:
        pcpd = (CONSOLEPROP_DATA *)GetWindowLongPtr( hWnd, PCPD_INDEX );
        if (pcpd)
        {
            InvalidatePreviewRect(hWnd, pcpd);
            UpdatePreviewRect( pcpd );

            /*
             * Make sure the preview "screen" has the correct aspect ratio
             */
            GetWindowRect(hWnd, &rcWindow);
            cx = rcWindow.right - rcWindow.left;
            cy = CnslAspectScale(pcpd->yScreen, pcpd->xScreen, cx);
            if (cy != rcWindow.bottom - rcWindow.top) {
                SetWindowPos(hWnd, NULL, 0, 0, cx, cy, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
            }
        
            InvalidatePreviewRect(hWnd, pcpd);
        }
        break;

    case WM_DESTROY:
        lpcs = (LPCREATESTRUCT)GetWindowLongPtr( hWnd, LPCS_INDEX );
        if (lpcs)
            LocalFree( lpcs );
        break;

    default:
        return DefWindowProc(hWnd, wMessage, wParam, lParam);
    }
    return 0L;
}


/*  CnslAspectScale
 *      Performs the following calculation in LONG arithmetic to avoid
 *      overflow:
 *          return = n1 * m / n2
 *      This can be used to make an aspect ration calculation where n1/n2
 *      is the aspect ratio and m is a known value.  The return value will
 *      be the value that corresponds to m with the correct apsect ratio.
 */

LONG
CnslAspectScale(
    LONG n1,
    LONG n2,
    LONG m)
{
    LONG Temp;

    Temp = n1 * m + (n2 >> 1);
    return Temp / n2;
}

/*  CnslAspectPoint
 *      Scales a point to be preview-sized instead of screen-sized.
 */

void
CnslAspectPoint(
    CONSOLEPROP_DATA * pcpd,
    RECT* rectPreview,
    POINT* pt
    )
{
    pt->x = CnslAspectScale(rectPreview->right, pcpd->xScreen, pt->x);
    pt->y = CnslAspectScale(rectPreview->bottom, pcpd->yScreen, pt->y);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\lvutil.c ===
#include "shellprv.h"
#pragma  hdrstop

// convert screen coords to listview view coordinates

// convert listview client window coords into listview view coordinates

void LVUtil_ClientToLV(HWND hwndLV, LPPOINT ppt)
{
    POINT ptOrigin;

    if (!ListView_GetOrigin(hwndLV, &ptOrigin))
        return;

    ppt->x += ptOrigin.x;
    ppt->y += ptOrigin.y;
}

void LVUtil_ScreenToLV(HWND hwndLV, LPPOINT ppt)
{
    ScreenToClient(hwndLV, ppt);

    LVUtil_ClientToLV(hwndLV, ppt);
}

// convert listview client window coords into listview view coordinates

void LVUtil_LVToClient(HWND hwndLV, LPPOINT ppt)
{
    POINT ptOrigin;

    if (!ListView_GetOrigin(hwndLV, &ptOrigin))
        return;

    ppt->x -= ptOrigin.x;
    ppt->y -= ptOrigin.y;
}

//
// Parameters:
//  hwndLV      -- Specifies the listview window
//  nItem       -- Specifies the item to be altered
//  uState      -- Specifies the new state of the item
//  uMask       -- Specifies the state mask
//
void LVUtil_DragSetItemState(HWND hwndLV, int nItem, UINT uState, UINT uMask)
{
    // check the state to see if it is already as we want to avoid
    // flashing while dragging

    if (ListView_GetItemState(hwndLV, nItem, uMask) != (uState & uMask))
    {
        DAD_ShowDragImage(FALSE);
        ListView_SetItemState(hwndLV, nItem, uState, uMask);
        UpdateWindow(hwndLV);   // REVIEW, needed?
        DAD_ShowDragImage(TRUE);
    }
}

void LVUtil_DragSelectItem(HWND hwndLV, int nItem)
{
    int nTemp;

    for (nTemp = ListView_GetItemCount(hwndLV) - 1; nTemp >= 0; --nTemp)
    {
        LVUtil_DragSetItemState(hwndLV, nTemp, nTemp == nItem ? LVIS_DROPHILITED : 0, LVIS_DROPHILITED);
    }
}

//
// Note that it returns NULL, if iItem is -1.
//
LPARAM LVUtil_GetLParam(HWND hwndLV, int i)
{
    LV_ITEM item;

    item.mask = LVIF_PARAM;
    item.iItem = i;
    item.iSubItem = 0;
    item.lParam = 0;
    if (i != -1)
    {
        ListView_GetItem(hwndLV, &item);
    }

    return item.lParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\lvutil.h ===
// Drag the selected items in a ListView.  Other than hwndLV (the ListView
// window), the parameters are the same as those for ShellDragObjects.
//
STDAPI_(void) LVUtil_ScreenToLV(HWND hwndLV, POINT *ppt);
STDAPI_(void) LVUtil_ClientToLV(HWND hwndLV, POINT *ppt);
STDAPI_(void) LVUtil_LVToClient(HWND hwndLV, POINT *ppt);
STDAPI_(void) LVUtil_DragSelectItem(HWND hwndLV, int nItem);
STDAPI_(LPARAM) LVUtil_GetLParam(HWND hwndLV, int i);

STDAPI_(BOOL) DAD_SetDragImageFromWindow(HWND hwnd, POINT* ppt, IDataObject* pDataObject);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\lstrfns.c ===
#define UNICODE 1

#include "shellprv.h"
#pragma  hdrstop

/*
 * StrEndN - Find the end of a string, but no more than n bytes
 * Assumes   lpStart points to start of null terminated string
 *           nBufSize is the maximum length
 * returns ptr to just after the last byte to be included
 */
LPWSTR StrEndNW(LPCWSTR lpStart, int nBufSize)
{
    LPCWSTR lpEnd;

    for (lpEnd = lpStart + nBufSize; *lpStart && lpStart < lpEnd; lpStart = CharNext(lpStart))
    {
        /* just getting to the end of the string */
        continue;
    }

    if (lpStart > lpEnd)
    {
      /* We can only get here if the last wchar before lpEnd was a lead byte
       */
      lpStart -= 2;
    }

    return((LPWSTR)lpStart);
}

LPSTR StrEndNA(LPCSTR lpStart, int nBufSize)
{
    LPCSTR lpEnd;

    for (lpEnd = lpStart + nBufSize; *lpStart && lpStart < lpEnd; lpStart = CharNextA(lpStart))
    {
        /* just getting to the end of the string */
        continue;
    }

    if (lpStart > lpEnd)
    {
        // We can only get here if the last byte before lpEnd was a lead byte
        lpStart -= 2;
    }

    return (LPSTR)lpStart;
}


/*
 * StrCpyN      - Copy up to N chars, don't end in LeadByte char
 *
 * Assumes   lpDest points to buffer of nBufSize bytes (including NULL)
 *           lpSource points to string to be copied.
 * returns   Number of bytes copied, NOT including NULL
 */
int Shell32_StrCpyNW(LPWSTR lpDest, LPWSTR lpSource, int nBufSize)
{
    LPWSTR lpEnd;
    WCHAR cHold;

    if (nBufSize < 0)
        return(nBufSize);

    lpEnd = StrEndNW(lpSource, nBufSize);
    cHold = *lpEnd;
    *lpEnd = WCHAR_NULL;
    lstrcpy(lpDest, lpSource);
    *lpEnd = cHold;

    return (int)(lpEnd - lpSource);
}

int Shell32_StrCpyNA(LPSTR lpDest, LPSTR lpSource, int nBufSize)
{
    LPSTR lpEnd;
    CHAR cHold;

    if (nBufSize < 0)
        return(nBufSize);

    lpEnd = StrEndNA(lpSource, nBufSize);
    cHold = *lpEnd;
    *lpEnd = '\0';
    lstrcpyA(lpDest, lpSource);
    *lpEnd = cHold;
    
    return (int)(lpEnd - lpSource);
}


/*
 * StrNCmp      - Compare n characters
 *
 * returns   See lstrcmp return values.
 */
int StrNCmpW(LPWSTR lpStr1, LPWSTR lpStr2, int nChar)
{
    WCHAR cHold1, cHold2;
    int i;
    LPWSTR lpsz1 = lpStr1, lpsz2 = lpStr2;

    for (i = 0; i < nChar; i++)
    {
        /* If we hit the end of either string before the given number
        * of bytes, just return the comparison
        */
        if (!*lpsz1 || !*lpsz2)
            return(wcscmp(lpStr1, lpStr2));

        lpsz1 = CharNextW(lpsz1);
        lpsz2 = CharNextW(lpsz2);
    }

    cHold1 = *lpsz1;
    cHold2 = *lpsz2;
    *lpsz1 = *lpsz2 = WCHAR_NULL;
    i = wcscmp(lpStr1, lpStr2);
    *lpsz1 = cHold1;
    *lpsz2 = cHold2;

    return(i);
}

int StrNCmpA(LPSTR lpStr1, LPSTR lpStr2, int nChar)
{
    CHAR cHold1, cHold2;
    int i;
    LPSTR lpsz1 = lpStr1, lpsz2 = lpStr2;

    for (i = 0; i < nChar; i++)
    {
        /* If we hit the end of either string before the given number
        * of bytes, just return the comparison
        */
        if (!*lpsz1 || !*lpsz2)
            return(lstrcmpA(lpStr1, lpStr2));

        lpsz1 = CharNextA(lpsz1);
        lpsz2 = CharNextA(lpsz2);
    }

    cHold1 = *lpsz1;
    cHold2 = *lpsz2;
    *lpsz1 = *lpsz2 = '\0';
    i = lstrcmpA(lpStr1, lpStr2);
    *lpsz1 = cHold1;
    *lpsz2 = cHold2;

    return i;
}


/*
 * StrNCmpI     - Compare n characters, case insensitive
 *
 * returns   See lstrcmpi return values.
 */
int StrNCmpIW(LPWSTR lpStr1, LPWSTR lpStr2, int nChar)
{
    WCHAR cHold1, cHold2;
    int i;
    LPWSTR lpsz1 = lpStr1, lpsz2 = lpStr2;

    for (i = 0; i < nChar; i++)
    {
        /* If we hit the end of either string before the given number
        * of bytes, just return the comparison
        */
        if (!*lpsz1 || !*lpsz2)
            return(lstrcmpi(lpStr1, lpStr2));

        lpsz1 = CharNext(lpsz1);
        lpsz2 = CharNext(lpsz2);
    }

    cHold1 = *lpsz1;
    cHold2 = *lpsz2;
    *lpsz1 = *lpsz2 = WCHAR_NULL;
    i = _wcsicmp(lpStr1, lpStr2);
    *lpsz1 = cHold1;
    *lpsz2 = cHold2;

    return i;
}

int StrNCmpIA(LPSTR lpStr1, LPSTR lpStr2, int nChar)
{
    CHAR cHold1, cHold2;
    int i;
    LPSTR lpsz1 = lpStr1, lpsz2 = lpStr2;

    for (i = 0; i < nChar; i++)
    {
        /* If we hit the end of either string before the given number
        * of bytes, just return the comparison
        */
        if (!*lpsz1 || !*lpsz2)
            return(lstrcmpiA(lpStr1, lpStr2));

        lpsz1 = CharNextA(lpsz1);
        lpsz2 = CharNextA(lpsz2);
    }

    cHold1 = *lpsz1;
    cHold2 = *lpsz2;
    *lpsz1 = *lpsz2 = '\0';
    i = lstrcmpiA(lpStr1, lpStr2);
    *lpsz1 = cHold1;
    *lpsz2 = cHold2;

    return i;
}


/*
 * StrNCpy      - Copy n characters
 *
 * returns   Actual number of characters copied
 */
int StrNCpyW(LPWSTR lpDest, LPWSTR lpSource, int nChar)
{
    WCHAR cHold;
    int i;
    LPWSTR lpch = lpSource;

    if (nChar < 0)
        return(nChar);

    for (i = 0; i < nChar; i++)
    {
        if (!*lpch)
            break;

        lpch = CharNext(lpch);
    }

    cHold = *lpch;
    *lpch = WCHAR_NULL;
    wcscpy(lpDest, lpSource);
    *lpch = cHold;

    return i;
}

int StrNCpyA(LPSTR lpDest, LPSTR lpSource,int nChar)
{
    CHAR cHold;
    int i;
    LPSTR lpch = lpSource;

    if (nChar < 0)
        return(nChar);

    for (i = 0; i < nChar; i++)
    {
        if (!*lpch)
            break;

        lpch = CharNextA(lpch);
    }

    cHold = *lpch;
    *lpch = '\0';
    lstrcpyA(lpDest, lpSource);
    *lpch = cHold;
    
    return i;
}


/*
 * StrRStr      - Search for last occurrence of a substring
 *
 * Assumes   lpSource points to the null terminated source string
 *           lpLast points to where to search from in the source string
 *           lpLast is not included in the search
 *           lpSrch points to string to search for
 * returns   last occurrence of string if successful; NULL otherwise
 */
LPWSTR StrRStrW(LPWSTR lpSource, LPWSTR lpLast, LPWSTR lpSrch)
{
    int iLen;

    iLen = lstrlen(lpSrch);

    if (!lpLast)
    {
        lpLast = lpSource + lstrlen(lpSource);
    }

    do
    {
        /* Return NULL if we hit the exact beginning of the string
        */
        if (lpLast == lpSource)
            return(NULL);

        --lpLast;

        /* Break if we hit the beginning of the string
        */
        if (!lpLast)
            break;

        /* Break if we found the string, and its first byte is not a tail byte
        */
        if (!StrCmpNW(lpLast, lpSrch, iLen) && (lpLast==StrEndNW(lpSource, (int)(lpLast-lpSource))))
            break;
    }
    while (1);

    return lpLast;
}

LPSTR StrRStrA(LPSTR lpSource, LPSTR lpLast, LPSTR lpSrch)
{
    int iLen;

    iLen = lstrlenA(lpSrch);

    if (!lpLast)
    {
        lpLast = lpSource + lstrlenA(lpSource);
    }

    do
    {
        /* Return NULL if we hit the exact beginning of the string
        */
        if (lpLast == lpSource)
            return(NULL);

        --lpLast;

        /* Break if we hit the beginning of the string
        */
        if (!lpLast)
            break;

        /* Break if we found the string, and its first byte is not a tail byte
        */
        if (!StrCmpNA(lpLast, lpSrch, iLen) &&(lpLast==StrEndNA(lpSource, (int)(lpLast-lpSource))))
        {
            break;
        }
    }
    while (1);

    return lpLast;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\lowdisk.cpp ===
#include "shellprv.h"
#include "util.h"
#include "ids.h"
#include "bitbuck.h"
#include "mtpt.h"

// states for state machine, values are relavant as we compare them
// durring transitions to see if UI should be triggered or not

typedef enum
{
    STATE_1MB = 0,          // the "disk is completely filled" case
    STATE_50MB = 1,         // < 50MB case
    STATE_80MB = 2,         // < 80MB case
    STATE_200MB = 3,        // < 200MB case, only do this one on > 2.25GB drives
    STATE_ALLGOOD = 4,      // > 200MB, everything is fine
    STATE_UNKNOWN = 5,
} LOWDISK_STATE;

#define BYTES_PER_MB		((ULONGLONG)0x100000)

typedef struct 
{
    LOWDISK_STATE lds;
    ULONG dwMinMB;              // range (min) that defines this state
    ULONG dwMaxMB;              // range (max) that defines this state
    DWORD dwCleanupFlags;       // DISKCLEANUP_
    DWORD dwShowTime;           // in sec
    DWORD dwIntervalTime;       // in sec
    UINT  cRetry;
    DWORD niif;
} STATE_DATA;

#define HOURS (60 * 60)
#define MINS  (60)

const STATE_DATA c_state_data[] = 
{
    {STATE_1MB,     0,     1,   DISKCLEANUP_VERYLOWDISK, 30, 5 * MINS,  -1, NIIF_ERROR},
    {STATE_50MB,    1,    50,   DISKCLEANUP_VERYLOWDISK, 30, 5 * MINS,  -1, NIIF_WARNING},
    {STATE_80MB,   50,    80,   DISKCLEANUP_LOWDISK,     30, 4 * HOURS,  1, NIIF_WARNING},
    {STATE_200MB,  80,   200,   DISKCLEANUP_LOWDISK,     30, 0 * HOURS,  0, NIIF_INFO},
};

void SRNotify(LPCWSTR pszDrive, DWORD dwFreeSpaceInMB, BOOL bImproving)
{
    typedef void (* PFNSRNOTIFYFREESPACE)(LPCWSTR, DWORD, BOOL);
    
    static HMODULE s_hmodSR = NULL;
    if (NULL == s_hmodSR)
        s_hmodSR = LoadLibrary(TEXT("srclient.dll"));

    if (s_hmodSR)
    {
	    PFNSRNOTIFYFREESPACE pfnNotifyFreeSpace = (PFNSRNOTIFYFREESPACE)GetProcAddress(s_hmodSR, "SRNotify");
        if (pfnNotifyFreeSpace)
            pfnNotifyFreeSpace(pszDrive, dwFreeSpaceInMB, bImproving);
    }
}

class CLowDiskSpaceUI : IQueryContinue
{
public:
    CLowDiskSpaceUI(int iDrive);
    void CheckDiskSpace();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IQueryContinue
    STDMETHODIMP QueryContinue();    // S_OK -> Continue, other 

private:
    ~CLowDiskSpaceUI();
    BOOL _EnterExclusive();
    void _LeaveExclusive();
    void _DoNotificationUI();
    void _DoStateMachine();

    const STATE_DATA *_StateData(LOWDISK_STATE lds);
    LOWDISK_STATE _StateFromFreeSpace(ULARGE_INTEGER ulTotal, ULARGE_INTEGER ulFree);
    LOWDISK_STATE _GetCurrentState(BOOL bInStateMachine);

    static DWORD CALLBACK s_ThreadProc(void *pv);

    LONG _cRef;
    TCHAR _szRoot[5];
    HANDLE _hMutex;
    LOWDISK_STATE _ldsCurrent;
    BOOL _bShowUI;
    BOOL _bSysVolume;
    DWORD _dwLastFreeMB;
};

CLowDiskSpaceUI::CLowDiskSpaceUI(int iDrive) : _cRef(1), _ldsCurrent(STATE_UNKNOWN)
{
    ASSERT(_bShowUI == FALSE);
    ASSERT(_bSysVolume == FALSE);

    PathBuildRoot(_szRoot, iDrive);

    TCHAR szWinDir[MAX_PATH];
    if (GetWindowsDirectory(szWinDir, ARRAYSIZE(szWinDir)))
    {
        _bSysVolume = szWinDir[0] == _szRoot[0];
    }
}

CLowDiskSpaceUI::~CLowDiskSpaceUI()
{
    if (_hMutex)
        CloseHandle(_hMutex);
}

HRESULT CLowDiskSpaceUI::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CLowDiskSpaceUI, IQueryContinue),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CLowDiskSpaceUI::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CLowDiskSpaceUI::Release()
{
    ASSERT(0 != _cRef);
    ULONG cRef = InterlockedDecrement(&_cRef);
    if (0 == cRef)
    {
        delete this;
    }
    return cRef;
}

HRESULT CLowDiskSpaceUI::QueryContinue()
{
    LOWDISK_STATE ldsOld = _ldsCurrent;
    return ldsOld == _GetCurrentState(TRUE) ? S_OK : S_FALSE;
}

const STATE_DATA *CLowDiskSpaceUI::_StateData(LOWDISK_STATE lds)
{
    for (int i = 0; i < ARRAYSIZE(c_state_data); i++)
    {
        if (c_state_data[i].lds == lds)
            return &c_state_data[i];
    }
    return NULL;
}

LOWDISK_STATE CLowDiskSpaceUI::_StateFromFreeSpace(ULARGE_INTEGER ulTotal, ULARGE_INTEGER ulFree)
{
    ULONGLONG ulTotalMB = (ulTotal.QuadPart / BYTES_PER_MB);
    ULONGLONG ulFreeMB = (ulFree.QuadPart / BYTES_PER_MB);

    _dwLastFreeMB = (DWORD)ulFreeMB;

    for (int i = 0; i < ARRAYSIZE(c_state_data); i++)
    {
        // total needs to be 8 times the max of this range for us to consider it
        if ((ulTotalMB / 8) > c_state_data[i].dwMaxMB)
        {
            if ((c_state_data[i].lds == _ldsCurrent) ?
                ((ulFreeMB >= c_state_data[i].dwMinMB) && (ulFreeMB <= (c_state_data[i].dwMaxMB + 3))) :
                ((ulFreeMB >= c_state_data[i].dwMinMB) && (ulFreeMB <=  c_state_data[i].dwMaxMB)))
            {
                // only report 200MB state on drives >= 2.25GB
                if ((c_state_data[i].lds != STATE_200MB) || (ulTotal.QuadPart >= (2250 * BYTES_PER_MB)))
                    return c_state_data[i].lds;
            }
        }
    }
    return STATE_ALLGOOD;
}

LOWDISK_STATE CLowDiskSpaceUI::_GetCurrentState(BOOL bInStateMachine)
{
    LOWDISK_STATE ldsNew = STATE_ALLGOOD;   // assume this in case of failure

    ULARGE_INTEGER ulTotal, ulFree;
    if (SHGetDiskFreeSpaceEx(_szRoot, NULL, &ulTotal, &ulFree))
    {
        ldsNew = _StateFromFreeSpace(ulTotal, ulFree);
    }

    if (bInStateMachine)
    {
        if (_ldsCurrent != ldsNew)
        {
            // state change

            // if things are getting worse need to show UI (if we are in the state machine)
            _bShowUI = (ldsNew < _ldsCurrent);

            SRNotify(_szRoot, _dwLastFreeMB, ldsNew > _ldsCurrent);  // call system restore 
        }
        _ldsCurrent = ldsNew;
    }
    return ldsNew;
}

// creates the notification icon in the tray and shows a balloon with it
// this is a modal call, when it returns either the UI has timed out or the
// user has clicked on the notification UI.

void CLowDiskSpaceUI::_DoNotificationUI()
{
    // assume this will be a one shot UI, but this can get reset via our callback
    _bShowUI = FALSE;

    const STATE_DATA *psd = _StateData(_ldsCurrent);
    if (psd && (_bSysVolume || (psd->lds <= STATE_80MB)))
    {
        IUserNotification *pun;
        HRESULT hr = CoCreateInstance(CLSID_UserNotification, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IUserNotification, &pun));
        if (SUCCEEDED(hr))
        {
            SHFILEINFO sfi = {0};
            SHGetFileInfo(_szRoot, FILE_ATTRIBUTE_DIRECTORY, &sfi, sizeof(sfi),
                SHGFI_USEFILEATTRIBUTES | SHGFI_DISPLAYNAME |
                SHGFI_ICON | SHGFI_SMALLICON | SHGFI_ADDOVERLAYS);

            TCHAR szTitle[64], szMsg[256], szTemplate[256];

            UINT niif = _bSysVolume ? psd->niif : NIIF_INFO;

            LoadString(HINST_THISDLL, IDS_DISK_FULL_TITLE, szTitle, ARRAYSIZE(szTitle));
            LoadString(HINST_THISDLL, NIIF_INFO == niif ? IDS_DISK_FULL_TEXT : IDS_DISK_FULL_TEXT_SERIOUS, 
                szTemplate, ARRAYSIZE(szTemplate));

            StringCchPrintf(szMsg, ARRAYSIZE(szMsg), szTemplate, sfi.szDisplayName);
            pun->SetIconInfo(sfi.hIcon, szTitle);
            pun->SetBalloonRetry(psd->dwShowTime * 1000, psd->dwIntervalTime * 1000, psd->cRetry);
            // pun->SetBalloonInfo(szTitle, L"<a href=\"notepad.exe\"> Click here for notepad</a>", niif);
            pun->SetBalloonInfo(szTitle, szMsg, niif);

            hr = pun->Show(SAFECAST(this, IQueryContinue *), 1 * 1000); // 1 sec poll for callback


            if (sfi.hIcon)
                DestroyIcon(sfi.hIcon);

            if (S_OK == hr)
            {
                // S_OK -> user click on icon or balloon
                LaunchDiskCleanup(NULL, DRIVEID(_szRoot), (_bSysVolume ? psd->dwCleanupFlags : 0) | DISKCLEANUP_MODAL);
            }

            pun->Release();
        }
    }
}

void CLowDiskSpaceUI::_DoStateMachine()
{
    do
    {
        if (_bShowUI)
        {
            _DoNotificationUI();
        }
        else
        {
            SHProcessMessagesUntilEvent(NULL, NULL, 5 * 1000);  // 5 seconds
        }
    }
    while (STATE_ALLGOOD != _GetCurrentState(TRUE));
}

BOOL CLowDiskSpaceUI::_EnterExclusive()
{
    if (NULL == _hMutex)
    {
        TCHAR szEvent[32];

        StringCchPrintf(szEvent, ARRAYSIZE(szEvent), TEXT("LowDiskOn%C"), _szRoot[0]);  // ok to truncate
        _hMutex = CreateMutex(SHGetAllAccessSA(), FALSE, szEvent);
    }
    return _hMutex && WAIT_OBJECT_0 == WaitForSingleObject(_hMutex, 0);    // zero timeout
}

void CLowDiskSpaceUI::_LeaveExclusive()
{
    ASSERT(_hMutex);
    ReleaseMutex(_hMutex);
}

DWORD CALLBACK CLowDiskSpaceUI::s_ThreadProc(void *pv)
{
    CLowDiskSpaceUI *pldsui = (CLowDiskSpaceUI *)pv;
    if (pldsui->_EnterExclusive())
    {
        pldsui->_DoStateMachine();
        pldsui->_LeaveExclusive();
    }
    pldsui->Release();
    return 0;
}

void CLowDiskSpaceUI::CheckDiskSpace()
{
    if (STATE_ALLGOOD != _GetCurrentState(FALSE))
    {
        AddRef();
        if (!SHCreateThread(s_ThreadProc, this, CTF_COINIT, NULL))
        {
            Release();
        }
    }
}

STDAPI CheckDiskSpace()
{
    // the only caller of this is in explorer\tray.cpp
    // it checks against SHRestricted(REST_NOLOWDISKSPACECHECKS) on that side.
    for (int i = 0; i < 26; i++)
    {
        CMountPoint* pmp = CMountPoint::GetMountPoint(i);
        if (pmp)
        {
            if (pmp->IsFixedDisk() && !pmp->IsRemovableDevice())
            {
                CLowDiskSpaceUI *pldsui = new CLowDiskSpaceUI(i);
                if (pldsui)
                {
                    pldsui->CheckDiskSpace();
                    pldsui->Release();
                }
            }
            pmp->Release();
        }
    }
    return S_OK;
}

STDAPI_(BOOL) GetDiskCleanupPath(LPTSTR pszBuf, UINT cchSize)
{
    if (pszBuf)
       *pszBuf = 0;

    DWORD cbLen = CbFromCch(cchSize);
    return SUCCEEDED(SKGetValue(SHELLKEY_HKLM_EXPLORER, TEXT("MyComputer\\cleanuppath"), NULL, NULL, pszBuf, &cbLen));
}

STDAPI_(void) LaunchDiskCleanup(HWND hwnd, int iDrive, UINT uFlags)
{
    TCHAR szPathTemplate[MAX_PATH];

    if (GetDiskCleanupPath(szPathTemplate, ARRAYSIZE(szPathTemplate)))
    {
        TCHAR szPath[MAX_PATH], szArgs[MAX_PATH];
        HRESULT hr;
        BOOL fExec = FALSE;

        hr = StringCchPrintf(szPath, ARRAYSIZE(szPath), szPathTemplate, TEXT('A') + iDrive);
        if (SUCCEEDED(hr))
        {
            if (uFlags & DISKCLEANUP_LOWDISK)
            {
                hr = StringCchCat(szPath, ARRAYSIZE(szPath), TEXT(" /LOWDISK"));
            }
            else if (uFlags & DISKCLEANUP_VERYLOWDISK)
            {
                hr = StringCchCat(szPath, ARRAYSIZE(szPath), TEXT(" /VERYLOWDISK"));
            }

            if (SUCCEEDED(hr))
            {
                hr = PathSeperateArgs(szPath, szArgs, ARRAYSIZE(szArgs), NULL);
                if (SUCCEEDED(hr))
                {
                    SHELLEXECUTEINFO ei =
                    {
                        sizeof(ei),
                        SEE_MASK_FLAG_NO_UI | SEE_MASK_NOCLOSEPROCESS,
                        NULL, NULL, szPath, szArgs, NULL, SW_SHOWNORMAL, NULL
                    };

                    if (ShellExecuteEx(&ei))
                    {
                        fExec = TRUE;

                        if (ei.hProcess)
                        {
                            if (DISKCLEANUP_MODAL & uFlags)
                                SHProcessMessagesUntilEvent(NULL, ei.hProcess, INFINITE);
                            CloseHandle(ei.hProcess);
                        }
                    }
                }
            }
        }

        if (!fExec)
        {
            ShellMessageBox(HINST_THISDLL, NULL,
                        MAKEINTRESOURCE(IDS_NO_CLEANMGR_APP),
                        NULL, MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);
        }
    }
}


// public export
STDAPI_(void) SHHandleDiskFull(HWND hwnd, int idDrive)
{
    // legacy, no one calls this
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\makefile.inc ===
..\shell32.rc : $(PROJECT_ROOT)\lib\$(O)\shldisp.tlb $(SELFREGNAME) $(O)\cpview.ui $(O)\folder.ui

!include $(CCSHELL_DIR)\makefile.inc

$(O)\cpview.ui : $(O)\cpview.uipp
    cleaninf -w $(O)\cpview.uipp $(O)\cpview.ui

$(O)\cpview.uipp : ..\cpview.uix
    $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $@

$(O)\folder.ui : $(O)\folder.uipp
    cleaninf -w $(O)\folder.uipp $(O)\folder.ui

$(O)\folder.uipp : ..\folder.uix
    $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mergfldr.h ===
#ifndef _mergfldr_h_
#define _mergfldr_h_

#include "sfstorage.h"
#include "clsobj.h"

class CMergedFolder;
class CMergedFldrDropTarget;
class CMergedFldrContextMenu;
class CMergedFldrNamespace;
class CMergedFldrItem;
class CMergedFldrEnum;
class CMergedCategorizer;
class CMergedFolderViewCB;

class CMergedFolder : public CSFStorage,
                      public IAugmentedShellFolder3,
                      public IShellService,
                      public ITranslateShellChangeNotify,
                      public IPersistFolder2,
                      public IPersistPropertyBag,
                      public IShellIconOverlay,
                      public ICompositeFolder,
                      public IItemNameLimits
{
public:
    // IUnknown
    STDMETHOD (QueryInterface)(REFIID, void **);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    
    // IShellFolder
    STDMETHOD(ParseDisplayName)(HWND hwnd, LPBC pbc, LPOLESTR pszName, ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHOD(EnumObjects)(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHOD(BindToObject)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut);
    STDMETHOD(BindToStorage)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj);
    STDMETHOD(CompareIDs)(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHOD(CreateViewObject)(HWND hwndOwner, REFIID riid, void **ppvOut);
    STDMETHOD(GetAttributesOf)(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut);
    STDMETHOD(GetUIObjectOf)(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppvOut);
    STDMETHOD(GetDisplayNameOf)(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHOD(SetNameOf)(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST * ppidlOut);

    // IShellFolder2
    // stub implementation to indicate we support CompareIDs() for identity
    STDMETHOD(GetDefaultSearchGUID)(LPGUID) 
        { return E_NOTIMPL; }
    STDMETHOD(EnumSearches)(LPENUMEXTRASEARCH *pe) 
        { *pe = NULL; return E_NOTIMPL; }
    STDMETHOD(GetDefaultColumn)(DWORD dwRes, ULONG *pSort, ULONG *pDisplay) 
        { return E_NOTIMPL; };
    
    STDMETHOD(GetDefaultColumnState)(UINT iColumn, DWORD *pbState);
    STDMETHOD(GetDetailsEx)(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHOD(GetDetailsOf)(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHOD(MapColumnToSCID)(UINT iCol, SHCOLUMNID *pscid);

    // IAugmentedShellFolder
    STDMETHOD(AddNameSpace)(const GUID * pguidObject, IShellFolder * psf, LPCITEMIDLIST pidl, DWORD dwFlags);
    STDMETHOD(GetNameSpaceID)(LPCITEMIDLIST pidl, GUID * pguidOut);
    STDMETHOD(QueryNameSpace)(DWORD dwID, GUID * pguidOut, IShellFolder ** ppsf);
    STDMETHOD(EnumNameSpace)(DWORD cNameSpaces, DWORD * pdwID);

    // IAugmentedShellFolder2
    STDMETHOD(UnWrapIDList)(LPCITEMIDLIST pidlWrap, LONG cPidls, IShellFolder** apsf, LPITEMIDLIST* apidlFolder, LPITEMIDLIST* apidlItems, LONG* pcFetched);

    // IAugmentedShellFolder3
    STDMETHOD(QueryNameSpace2)(DWORD dwID, QUERYNAMESPACEINFO *pqnsi);

    // IShellService
    STDMETHOD(SetOwner)(IUnknown * punkOwner);

    // ITranslateShellChangeNotify
    STDMETHOD(TranslateIDs)(LONG *plEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST *ppidlOut1, LPITEMIDLIST *ppidlOut2,
                            LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, LPITEMIDLIST *ppidlOut2Event2);
    STDMETHOD(IsChildID)(LPCITEMIDLIST pidlKid, BOOL fImmediate);
    STDMETHOD(IsEqualID)(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHOD(Register)(HWND hwnd, UINT uMsg, long lEvents);
    STDMETHOD(Unregister)(void);

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pclsid) 
        { *pclsid = _clsid; return S_OK; };

    // IPersistFolder
    STDMETHOD(Initialize)(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHOD(GetCurFolder)(LPITEMIDLIST *ppidl);

    // IPersistPropertyBag
    STDMETHOD(InitNew)()
        { return E_NOTIMPL; };
    STDMETHOD(Load)(IPropertyBag* ppb, IErrorLog *pErrLog);
    STDMETHOD(Save)(IPropertyBag *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
        { return E_NOTIMPL; };

    // IShellIconOverlay
    STDMETHOD(GetOverlayIndex)(LPCITEMIDLIST pidl, int *pIndex);
    STDMETHOD(GetOverlayIconIndex)(LPCITEMIDLIST pidl, int *pIndex);

    // ICompositeFolder
    STDMETHOD(InitComposite)(WORD wSignature, REFCLSID refclsid, CFINITF cfiFlags, ULONG celt, const COMPFOLDERINIT *rgCFs);
    STDMETHOD(BindToParent)(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPITEMIDLIST *ppidlLast);

    // IItemNameLimits
    STDMETHOD(GetValidCharacters)(LPWSTR *ppwszValidChars, LPWSTR *ppwszInvalidChars)
        { return E_NOTIMPL; }
    STDMETHOD(GetMaxLength)(LPCWSTR pszName, int *piMaxNameLen)
        { return E_NOTIMPL; }

protected:
    CMergedFolder(CMergedFolder*pmfParent, REFCLSID clsid);
    virtual ~CMergedFolder();
    friend HRESULT CMergedFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
    friend HRESULT CCompositeFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
    virtual HRESULT _CreateWithCLSID(CLSID clsid, CMergedFolder **ppmf);
    virtual BOOL _ShouldSuspend(REFGUID rguid);

private:

    // CSFStorage
    STDMETHOD(_DeleteItemByIDList)(LPCITEMIDLIST pidl);
    STDMETHOD(_StgCreate)(LPCITEMIDLIST pidl, DWORD grfMode, REFIID riid, void **ppv);

    CMergedFldrNamespace* _Namespace(int iNamespace);
    HRESULT _Namespace(int i, CMergedFldrNamespace **ppns);
    HRESULT _NamespaceForItem(LPCITEMIDLIST pidlWrap, ULONG dwAttribMask, ULONG dwAttrib, IShellFolder** ppsf, LPITEMIDLIST *ppidl, CMergedFldrNamespace **ppns, BOOL fExact = FALSE);
    HRESULT _OldTranslateIDs(LONG *plEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST *ppidlOut1, LPITEMIDLIST *ppidlOut2,
                             LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, LPITEMIDLIST *ppidlOut2Event2);
    HRESULT _NewTranslateIDs(LONG *plEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST *ppidlOut1, LPITEMIDLIST *ppidlOut2,
                             LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, LPITEMIDLIST *ppidlOut2Event2);
    HRESULT _GetOverlayInfo(LPCITEMIDLIST pidl, int * pIndex, DWORD dwFlags);

    BOOL _NamespaceMatches(ULONG dwAttribMask, ULONG dwAttrib, LPCGUID pguid, CMergedFldrNamespace *pns);
    HRESULT _FindNamespace(ULONG dwAttribMask, ULONG dwAttrib, LPCGUID pguid, CMergedFldrNamespace **ppv, BOOL fFallback = FALSE);
    BOOL    _ShouldMergeNamespaces(int iNS1, int iNS2);
    BOOL    _ShouldMergeNamespaces(CMergedFldrNamespace *pns1, CMergedFldrNamespace *pns2);
    CMergedFolder*_Parent() { return _pmfParent; }
    HRESULT _GetPidl(int* piPos, DWORD grfEnumFlags, LPITEMIDLIST *ppidl);
    HRESULT _GetFolder2(LPCITEMIDLIST pidlWrap, LPITEMIDLIST *ppidlItem, IShellFolder2 **ppsf);
    HRESULT _New(LPCITEMIDLIST pidlWrap, CMergedFolder **ppmf);

    HRESULT _IsWrap(LPCITEMIDLIST pidlTest);
    HRESULT _CreateWrap(LPCITEMIDLIST pidlSrc, UINT nSrcID, LPITEMIDLIST *ppidlWrap);
    HRESULT _WrapAddIDList(LPCITEMIDLIST pidlSrc, UINT nSrcID, IN OUT LPITEMIDLIST *ppidlWrap);
    ULONG _GetSourceCount(IN LPCITEMIDLIST pidl);
    BOOL _ContainsSrcID(LPCITEMIDLIST pidlWrap, UINT uSrcID);
    HRESULT _WrapRemoveIDList(LPITEMIDLIST pidlWrap, UINT nSrcID, LPITEMIDLIST *ppidl);
    HRESULT _WrapRemoveIDListAbs(LPITEMIDLIST pidlWrapAbs, UINT nSrcID, LPITEMIDLIST *ppidlAbs);
    HRESULT _GetSubPidl(LPCITEMIDLIST pidlWrap, int i, UINT* pnSrcID, LPITEMIDLIST *ppidl, CMergedFldrNamespace **ppns);
    HRESULT _ForceParseDisplayName(LPCITEMIDLIST pidlAbsNamespace, LPTSTR pszDisplayName, BOOL fForce, BOOL *pfOthersInwrap, LPITEMIDLIST *ppidl);
    HRESULT _AbsPidlToAbsWrap(CMergedFldrNamespace *pns, LPCITEMIDLIST pidl, BOOL fForce, BOOL *pfOthersInwrap, LPITEMIDLIST *ppidl);
    HRESULT _AddComposite(const COMPFOLDERINIT *pcfi);
    void _SetSimple(LPITEMIDLIST *ppidl);
    BOOL _IsSimple(LPCITEMIDLIST pidl);

    HRESULT _FixStrRetOffset(LPCITEMIDLIST pidl, STRRET *psr);
    BOOL _IsFolder(LPCITEMIDLIST pidl);
    HRESULT _CreateOtherNameSpace(IShellFolder **ppsf);
    HRESULT _CompareSingleLevelIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    static int CALLBACK _SearchByName(void *p1, void *p2, LPARAM lParam);
    static void *_Merge(UINT uMsg, void * pv1, void * pv2, LPARAM lParam);
    static int _CompareArbitraryPidls(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    static int _Compare(void *pv1, void *pv2, LPARAM lParam);

    HRESULT _SearchForPidl(int iNamespace, CMergedFldrNamespace *pns, LPCITEMIDLIST pidl, BOOL fFolder, int* piIndex, CMergedFldrItem** ppmfi);
    HRESULT _GetTargetUIObjectOf(IShellFolder *psf, HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, REFIID riid, UINT *prgf, void **ppv);
    HRESULT _GetContextMenu(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, REFIID riid, void **ppv);

    int _NamespaceCount() const;
    void _FreeNamespaces();

    int _AcquireObjects();
    void _FreeObjects();
    int _ObjectCount() const;
    CMergedFldrItem *_GetObject(int i);
    
    BOOL _IsFolderEvent(LONG lEvent);
    LPITEMIDLIST _ILCombineBase(LPCITEMIDLIST pidlContainingBase, LPCITEMIDLIST pidlRel);

    static int _DestroyObjectsProc(void *pv, void *pvData);
    static int _SetOwnerProc(void *, void *);
    static int _SetNotifyProc(void *, void *);
    static int _DestroyNamespacesProc(void *pv, void *pvData);

    BOOL _IsChildIDInternal(LPCITEMIDLIST pidl, BOOL fImmediate, int* iShellFolder);
    
    void _GetKeyForProperty(LPWSTR pszName, LPWSTR pszValue, LPWSTR pszBuffer, INT cchBuffer);
    HRESULT _AddNameSpaceFromPropertyBag(IPropertyBag *ppb, LPWSTR pszName);
    HRESULT _SimpleAddNamespace(CMergedFldrNamespace *pns);
    BOOL _IsOurColumn(UINT iColumn);
    HRESULT _GetWhichFolderColumn(LPCITEMIDLIST pidl, LPTSTR pszBuffer, INT cchBuffer);
    HRESULT _GetDestinationStorage(DWORD grfMode, IStorage **ppstg);
    void _AddAllOtherNamespaces(LPITEMIDLIST *ppidl);

public:
    LPITEMIDLIST      _pidl;                  // CMergedFolder is a base class for several IShellFolders, and their IShellFolderViewCBs need access to this

private:
    CLSID             _clsid;                 // our identity
    LONG              _cRef;                  // reference count.
    HDPA              _hdpaNamespaces;        // source _Namespace collection
    HDPA              _hdpaObjects;           // array of (CMergedFldrItem *)
    CMergedFolder    *_pmfParent;             // parent folder (if any)
    UINT              _iColumnOffset;         // offset to my column set (-1 if unknown)
    DWORD             _dwDropEffect;          // default drop effect for this folder
    BOOL              _fInShellView;          // true if we're in the view.  used in TranslateIDs.
    BOOL              _fDontMerge;            // true means don't merge the items in the view (but still navigate like we're merged).
    BOOL              _fPartialMerge;         // true if only some namespaces should be merged
    BOOL              _fCDBurn;               // true means we're the cdburn case.
    IStorage         *_pstg;                  // hold onto the storage for the first namespace (default for IStorage operations).
    BOOL              _fAcquiring;            // correct for architecture problem where state is kept in the folder about the enumeration

    friend CMergedFldrEnum;
    friend CMergedFldrDropTarget;
    friend CMergedFldrContextMenu;
    friend CMergedCategorizer;
    friend CMergedFolderViewCB;
};


class CMergedFolderViewCB : public CBaseShellFolderViewCB
{
public:
    CMergedFolderViewCB(CMergedFolder *pmf);

    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    virtual ~CMergedFolderViewCB();

    CMergedFolder *_pmf;

private:
    HRESULT _OnGetWebViewTemplate(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvi);
    HRESULT _OnFSNotify(DWORD pv, LPCITEMIDLIST *ppidl, LPARAM lp);
    HRESULT _RefreshObjectsWithSameName(IShellFolderView *psfv, LPITEMIDLIST pidl);
};



#endif // _mergfldr_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\malloc.c ===
#include "shellprv.h"
#pragma  hdrstop

extern const IMallocVtbl c_CShellMallocVtbl;

const IMalloc c_mem = { &c_CShellMallocVtbl };

STDMETHODIMP CShellMalloc_QueryInterface(IMalloc *pmem, REFIID riid, LPVOID * ppvObj)
{
    ASSERT(pmem == &c_mem);
    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IMalloc))
    {
        *ppvObj = pmem;
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CShellMalloc_AddRefRelease(IMalloc *pmem)
{
    ASSERT(pmem == &c_mem);
    return 1; // static object
}

STDMETHODIMP_(void *) CShellMalloc_Alloc(IMalloc *pmem, SIZE_T cb)
{
    ASSERT(pmem == &c_mem);
    return (void*)LocalAlloc(LPTR, cb);
}

//
//  IMalloc::Realloc is slightly different from LocalRealloc.
//
//  IMalloc::Realloc(NULL, 0) = return NULL
//  IMalloc::Realloc(pv, 0) = IMalloc::Free(pv)
//  IMalloc::Realloc(NULL, cb) = IMalloc::Alloc(cb)
//  IMalloc::Realloc(pv, cb) = LocalRealloc()
//
STDMETHODIMP_(void *) CShellMalloc_Realloc(IMalloc *pmem, void *pv, SIZE_T cb)
{
    ASSERT(pmem == &c_mem);

    if (cb == 0)
    {
        if (pv) LocalFree(pv);
        return NULL;
    }
    else if (pv == NULL)
    {
        return LocalAlloc(LPTR, cb);
    }
    else
        return LocalReAlloc(pv, cb, LMEM_MOVEABLE|LMEM_ZEROINIT);
}

//
//  IMalloc::Free is slightly different from LocalFree.
//
//  IMalloc::Free(NULL) - nop
//  IMalloc::Free(pv)   - LocalFree()
//
STDMETHODIMP_(void) CShellMalloc_Free(IMalloc *pmem, void *pv)
{
    ASSERT(pmem == &c_mem);
    if (pv) LocalFree(pv);
}

STDMETHODIMP_(SIZE_T) CShellMalloc_GetSize(IMalloc *pmem, void *pv)
{
    ASSERT(pmem == &c_mem);
    return LocalSize(pv);
}

STDMETHODIMP_(int) CShellMalloc_DidAlloc(IMalloc *pmem, void *pv)
{
    ASSERT(pmem == &c_mem);
    return -1;  // don't know
}

STDMETHODIMP_(void) CShellMalloc_HeapMinimize(IMalloc *pmem)
{
    ASSERT(pmem == &c_mem);
}

const IMallocVtbl c_CShellMallocVtbl = {
    CShellMalloc_QueryInterface, CShellMalloc_AddRefRelease, CShellMalloc_AddRefRelease,
    CShellMalloc_Alloc,
    CShellMalloc_Realloc,
    CShellMalloc_Free,
    CShellMalloc_GetSize,
    CShellMalloc_DidAlloc,
    CShellMalloc_HeapMinimize,
};


typedef HRESULT (STDAPICALLTYPE * LPFNCOGETMALLOC)(DWORD dwMemContext, IMalloc **ppmem);

IMalloc *g_pmemTask = NULL;     // No default task allocator.

#ifdef DEBUG
extern void WINAPI DbgRegisterMallocSpy();
#endif

// on DEBUG builds, mostly for NT, we force using OLE's task allocator at all times.
// for retail we only use OLE if ole32 is already loaded in this process.
//
// this is because OLE's DEBUG allocator will complain if we pass it LocalAlloc()ed
// memory. this can happen if we start up without OLE loaded, then delay load it.
// retail OLE uses LocalAlloc() so we can use our own allocator and switch
// on the fly with no complains from OLE in retail. a common case here would be
// using the file dialogs with notepad

void _GetTaskAllocator(IMalloc **ppmem)
{
    if (g_pmemTask == NULL)
    {
#ifndef DEBUG
        if (GetModuleHandle(TEXT("OLE32.DLL"))) // retail
#endif
        {
            CoGetMalloc(MEMCTX_TASK, &g_pmemTask);
        }

        if (g_pmemTask == NULL)
        {
            // use the shell task allocator (which is LocalAlloc).
            g_pmemTask = (IMalloc *)&c_mem; // const -> non const
        }
    }
    else
    {
        // handing out cached version, add ref it first
        g_pmemTask->lpVtbl->AddRef(g_pmemTask);
    }

    *ppmem = g_pmemTask;
}

//
// To be exported
//
STDAPI SHGetMalloc(IMalloc **ppmem)
{
    _GetTaskAllocator(ppmem);
    return NOERROR;
}

// BOGUS, NT redefines these to HeapAlloc variants...
#ifdef Alloc
#undef Alloc
#undef Free
#undef GetSize
#endif

__inline void FAST_GetTaskAllocator()
{
    IMalloc *pmem;
    if (g_pmemTask == NULL) {
        // perf: avoid calling unless really need to
        _GetTaskAllocator(&pmem);
        ASSERT(g_pmemTask != NULL);
        ASSERT(g_pmemTask == pmem);
    }
    // else n.b. no AddRef!  but we have a refcnt of >=1, and we never Release
    // so who cares...
    return;
}

STDAPI_(void *) SHAlloc(SIZE_T cb)
{
    FAST_GetTaskAllocator();
    return g_pmemTask->lpVtbl->Alloc(g_pmemTask, cb);
}

STDAPI_(void *) SHRealloc(LPVOID pv, SIZE_T cbNew)
{
    IMalloc *pmem;
    _GetTaskAllocator(&pmem);
    return pmem->lpVtbl->Realloc(pmem, pv, cbNew);
}

STDAPI_(void) SHFree(LPVOID pv)
{
    FAST_GetTaskAllocator();
    g_pmemTask->lpVtbl->Free(g_pmemTask, pv);
}

STDAPI_(SIZE_T) SHGetSize(LPVOID pv)
{
    IMalloc *pmem;
    _GetTaskAllocator(&pmem);
    return (SIZE_T) pmem->lpVtbl->GetSize(pmem, pv);
}

#ifdef DEBUG
void TaskMem_MakeInvalid(void)
{
    static IMalloc c_memDummy = { &c_CShellMallocVtbl };
    //
    // so we can catch calls to the allocator after PROCESS_DETATCH
    // which should be illegal because OLE32.DLL can be unloaded before our
    // DLL (unload order is not deterministic) we switch the allocator
    // to this dummy one that will cause our asserts to trip.
    //
    // note, runnin the dummy alllocator is actually fine as it will free
    // memory with LocalAlloc(), which is what the OLE alocator uses in all
    // cases except debug. and besides, our process is about to go away and
    // all process memory will be freed anyway!
    //
    g_pmemTask = &c_memDummy;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mixctnt.h ===
#ifndef MIXCTNT_H
#define MIXCTNT_H

BOOL _AddAutoplayPrompt(PCWSTR pszDriveOrDeviceID);
void _RemoveFromAutoplayPromptHDPA(LPCWSTR pszAltDeviceID);

void _SetAutoplayPromptHWND(LPCWSTR pszAltDeviceID, HWND hwnd);
BOOL _GetAutoplayPromptHWND(LPCWSTR pszAltDeviceID, HWND* phwnd);

EXTERN_C CRITICAL_SECTION g_csAutoplayPrompt;
extern HDPA g_hdpaAutoplayPrompt;

#endif //MIXCTNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mixctnt.cpp ===
#include "shellprv.h"

#include "mixctnt.h"
#include "clsobj.h"
#include "apprmdlg.h"
#include "hwcmmn.h"
#include "ids.h"
#include "shpriv.h"
#include "mtptl.h"
#include "filetbl.h"

class CDeviceEventHandler : public IHWEventHandler
{
public:
    CDeviceEventHandler();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IHWEventHandler
    STDMETHODIMP Initialize(LPCWSTR pszParams);
    STDMETHODIMP HandleEvent(LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID, LPCWSTR pszEventType);
    STDMETHODIMP HandleEventWithContent(LPCWSTR pszDeviceID,
        LPCWSTR pszAltDeviceID, LPCWSTR pszEventType,
        LPCWSTR pszContentTypeHandler, IDataObject* pdtobj);

private:
    ~CDeviceEventHandler();

    LONG _cRef;
    LPWSTR _pszParams;
};

CDeviceEventHandler::CDeviceEventHandler() : _cRef(1)
{
    DllAddRef();
}

CDeviceEventHandler::~CDeviceEventHandler()
{
    CoTaskMemFree(_pszParams)
    DllRelease();
}

STDAPI CDeviceEventHandler_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppv = NULL;
    
    // aggregation checking is handled in class factory
    CDeviceEventHandler* pHWMixedContent = new CDeviceEventHandler();
    if (pHWMixedContent)
    {
        hr = pHWMixedContent->QueryInterface(riid, ppv);
        pHWMixedContent->Release();
    }

    return hr;
}

// IUnknown
STDMETHODIMP CDeviceEventHandler::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CDeviceEventHandler, IHWEventHandler),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CDeviceEventHandler::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDeviceEventHandler::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IHWEventHandler
STDMETHODIMP CDeviceEventHandler::Initialize(LPCWSTR pszParams)
{
    return SHStrDup(pszParams, &_pszParams);
}

DWORD WINAPI _PromptThreadProc(void* pv)
{
    CBaseContentDlg* pdlg = (CBaseContentDlg*)pv;

    if (IDOK == pdlg->DoModal(pdlg->_hinst, MAKEINTRESOURCE(pdlg->_iResource), pdlg->_hwndParent))
    {
        // Try to Autoplay this type handler
        IHWDevice* phwd;
        if (SUCCEEDED(_GetHWDevice(pdlg->_pszDeviceID, &phwd)))
        {
            phwd->AutoplayHandler(TEXT("DeviceArrival"), pdlg->_szHandler);
            phwd->Release();
        }
    }

    _RemoveFromAutoplayPromptHDPA(pdlg->_pszDeviceID);

    pdlg->Release();

    return 0;
}

HRESULT _Prompt(LPCWSTR pszDeviceID, LPCWSTR pszEventType, BOOL fCheckAlwaysDoThis)
{
    HRESULT hr;

    BOOL fShowDlg = _AddAutoplayPrompt(pszDeviceID);

    if (fShowDlg)
    {
        BOOL fDialogShown = FALSE;
        CBaseContentDlg* pdlg = new CNoContentDlg();

        if (pdlg)
        {
            pdlg->_szContentTypeHandler[0] = 0;
            pdlg->_hinst = g_hinst;
            pdlg->_iResource = DLG_APNOCONTENT;
            pdlg->_hwndParent = NULL;

            hr = pdlg->Init(pszDeviceID, NULL, 0, fCheckAlwaysDoThis);
            if (SUCCEEDED(hr))
            {
                if (SHCreateThread(_PromptThreadProc, pdlg, CTF_COINIT, NULL))
                {
                    fDialogShown = TRUE;
                }
                else
                {   
                    pdlg->Release();
                }
            }
            else
            {
                pdlg->Release();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (!fDialogShown)
        {
            _RemoveFromAutoplayPromptHDPA(pszDeviceID);
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

STDMETHODIMP CDeviceEventHandler::HandleEvent(LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID, LPCWSTR pszEventType)
{
    HRESULT hr = E_NOTIMPL;

    if (!lstrcmp(_pszParams, TEXT("PromptEachTimeNoContent")))
    {
        hr = _Prompt(pszDeviceID, pszEventType, FALSE);
    }
    else
    {
        // The '*' means to check the AlwaysDoThis checkbox!
        if (!lstrcmp(_pszParams, TEXT("PromptEachTimeNoContent*")))
        {
            hr = _Prompt(pszDeviceID, pszEventType, TRUE);
        }
    }

    return hr;
}

STDMETHODIMP CDeviceEventHandler::HandleEventWithContent(LPCWSTR pszDeviceID,
        LPCWSTR pszAltDeviceID, LPCWSTR pszEventType,
        LPCWSTR pszContentTypeHandler, IDataObject* pdtobj)
{
    return E_FAIL;
}


class CDeviceAutoPlayNotification : IQueryContinue
{
public:
    CDeviceAutoPlayNotification();
    void CreateNotificationThread();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IQueryContinue
    STDMETHODIMP QueryContinue();    // S_OK -> Continue, other 

    HRESULT Init(LPCTSTR pszDevice, LPCWSTR pszEventType, CCrossThreadFlag* pDeviceGoneFlag);

private:
    ~CDeviceAutoPlayNotification();

    void _DoNotificationUI();

    static DWORD CALLBACK s_ThreadProc(void *pv);

    LONG                _cRef;
    LPTSTR              _pszDevice;
    LPTSTR              _pszEventType;
    CCrossThreadFlag*   _pDeviceGoneFlag;
    BOOL                _fPoppedUpDlg;
};

CDeviceAutoPlayNotification::CDeviceAutoPlayNotification() : _cRef(1)
{}

HRESULT CDeviceAutoPlayNotification::Init(LPCTSTR pszDevice, LPCWSTR pszEventType,
    CCrossThreadFlag* pDeviceGoneFlag)
{
    HRESULT hr = S_OK;

    _pszDevice = StrDup(pszDevice);
    _pszEventType = StrDup(pszEventType);

    pDeviceGoneFlag->AddRef();
    _pDeviceGoneFlag = pDeviceGoneFlag;

    if (!_pszDevice || !_pszEventType)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

CDeviceAutoPlayNotification::~CDeviceAutoPlayNotification()
{
    LocalFree(_pszDevice);
    LocalFree(_pszEventType);

    if (_pDeviceGoneFlag)
    {
        _pDeviceGoneFlag->Release();
    }
}

HRESULT CDeviceAutoPlayNotification::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDeviceAutoPlayNotification, IQueryContinue),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CDeviceAutoPlayNotification::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDeviceAutoPlayNotification::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CDeviceAutoPlayNotification::QueryContinue()
{
    HRESULT hr;

    if (_fPoppedUpDlg || _pDeviceGoneFlag->IsSignaled())
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

void CDeviceAutoPlayNotification::_DoNotificationUI()
{
    DWORD dwTimeOut = 30;

#ifdef DEBUG
    dwTimeOut = 60;
#endif

    IUserNotification *pun;
    HRESULT hr = CoCreateInstance(CLSID_UserNotification, NULL, CLSCTX_ALL, IID_PPV_ARG(IUserNotification, &pun));
    if (SUCCEEDED(hr))
    {
        IHWDeviceCustomProperties* pdcp;
        if (SUCCEEDED(GetDeviceProperties(_pszDevice, &pdcp)))
        {
            HICON hicon = NULL;

            WORD_BLOB* pblob;
            if (SUCCEEDED(pdcp->GetMultiStringProperty(TEXT("Icons"), TRUE, &pblob)))
            {
                TCHAR szLocation[MAX_PATH + 10];
                if (SUCCEEDED(StringCchCopy(szLocation, ARRAYSIZE(szLocation), pblob->asData)))
                {
                    int iIcon = PathParseIconLocation(szLocation);
                    ExtractIconEx(szLocation, iIcon, NULL, &hicon, 1);
                }
                CoTaskMemFree(pblob);
            }

            LPWSTR psz;
            if (SUCCEEDED(pdcp->GetStringProperty(TEXT("Label"), &psz)))
            {
                TCHAR szName[128];
                SHLoadIndirectString(psz, szName, ARRAYSIZE(szName), NULL);
                pun->SetIconInfo(hicon, szName);
                CoTaskMemFree(psz);
            }

            pdcp->Release();

            if (hicon)
                DestroyIcon(hicon);
        }

        pun->SetBalloonRetry(dwTimeOut * 1000, 0, 0);  // show for 30 sec, then go away

        hr = pun->Show(SAFECAST(this, IQueryContinue *), 1 * 1000); // 1 sec poll for callback

        pun->Release();

        if (S_OK == hr)
        {
            _Prompt(_pszDevice, _pszEventType, FALSE);
            _fPoppedUpDlg = TRUE;
        }
    }
}

DWORD CALLBACK CDeviceAutoPlayNotification::s_ThreadProc(void *pv)
{
    CDeviceAutoPlayNotification *pldsui = (CDeviceAutoPlayNotification *)pv;

    pldsui->_DoNotificationUI();
    pldsui->Release();

    return 0;
}

void CDeviceAutoPlayNotification::CreateNotificationThread()
{
    AddRef();

    if (!SHCreateThread(s_ThreadProc, this, CTF_COINIT, NULL))
    {
        Release();
    }
}

HRESULT DoDeviceNotification(LPCTSTR pszDevice, LPCTSTR pszEventType, CCrossThreadFlag* pDeviceGoneFlag)
{
    HRESULT hr;
    CDeviceAutoPlayNotification *pldsui = new CDeviceAutoPlayNotification();

    if (pldsui)
    {
        hr = pldsui->Init(pszDevice, pszEventType, pDeviceGoneFlag);

        if (SUCCEEDED(hr))
        {
            pldsui->CreateNotificationThread();
        }

        pldsui->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

template <typename TCALLBACKFCT, typename TCALLBACKARG, typename TCALLBACKRET>
BOOL _FindAutoplayStructAndExecuteCB(LPCWSTR pszDriveOrDeviceID, TCALLBACKFCT fct, TCALLBACKARG arg, TCALLBACKRET* pRet)
{
    BOOL fRet = FALSE;

    EnterCriticalSection(&g_csAutoplayPrompt);

    if (g_hdpaAutoplayPrompt)
    {
        int n = DPA_GetPtrCount(g_hdpaAutoplayPrompt);

        for (int i = 0; i < n; ++i)
        {
            AUTOPLAYPROMPT* pap = (AUTOPLAYPROMPT*)DPA_GetPtr(g_hdpaAutoplayPrompt, i);

            if (!lstrcmpi(pap->szDriveOrDeviceID, pszDriveOrDeviceID))
            {
                fRet = TRUE;

                *pRet = fct(pap, arg);

                break;
            }
        }    
    }

    LeaveCriticalSection(&g_csAutoplayPrompt);

    return fRet;
}

BOOL _AddAutoplayPromptEntry(LPCWSTR pszDriveOrDeviceID, BOOL fDlgWillBeShown)
{
    BOOL fFoundEntry = FALSE;
    BOOL fWasRunning = FALSE;
    EnterCriticalSection(&g_csAutoplayPrompt);

    if (g_hdpaAutoplayPrompt)
    {
        int n = DPA_GetPtrCount(g_hdpaAutoplayPrompt);

        for (int i = 0; i < n; ++i)
        {
            AUTOPLAYPROMPT* pap = (AUTOPLAYPROMPT*)DPA_GetPtr(g_hdpaAutoplayPrompt, i);

            if (!lstrcmpi(pap->szDriveOrDeviceID, pszDriveOrDeviceID))
            {
                fWasRunning = pap->fDlgWillBeShown;
                fFoundEntry = TRUE;

                if (!pap->fDlgWillBeShown)
                {
                    pap->fDlgWillBeShown = fDlgWillBeShown;
                }

                TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: Found entry for %s - (dlg = %d -> %d)",
                    pszDriveOrDeviceID, fWasRunning, pap->fDlgWillBeShown);

                break;
            }
        }    
    }

    if (!fFoundEntry)
    {
        if (!g_hdpaAutoplayPrompt)
        {
            g_hdpaAutoplayPrompt = DPA_Create(3);
        }

        if (g_hdpaAutoplayPrompt)
        {
            AUTOPLAYPROMPT* pap;

            if (SUCCEEDED(SHLocalAlloc(sizeof(AUTOPLAYPROMPT), &pap)))
            {
                StringCchCopy(pap->szDriveOrDeviceID, ARRAYSIZE(pap->szDriveOrDeviceID),
                    pszDriveOrDeviceID);

                pap->fDlgWillBeShown = fDlgWillBeShown;

                TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: Adding entry for %s - (dlg = %d)",
                    pszDriveOrDeviceID, fDlgWillBeShown);

                if (-1 == DPA_AppendPtr(g_hdpaAutoplayPrompt, (void*)pap))
                {
                    LocalFree((HLOCAL)pap);
                }
                else
                {
                    TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: Total # of entry: %d",
                        DPA_GetPtrCount(g_hdpaAutoplayPrompt));
                }
            }
        }
    }

    LeaveCriticalSection(&g_csAutoplayPrompt);

    return !fWasRunning;
}

BOOL _AddAutoplayPrompt(LPCWSTR pszDriveOrDeviceID)
{
    return _AddAutoplayPromptEntry(pszDriveOrDeviceID, TRUE);
}

void _RemoveFromAutoplayPromptHDPA(LPCWSTR pszAltDeviceID)
{
    EnterCriticalSection(&g_csAutoplayPrompt);

    if (g_hdpaAutoplayPrompt)
    {
        int n = DPA_GetPtrCount(g_hdpaAutoplayPrompt);

        for (int i = 0; i < n; ++i)
        {
            AUTOPLAYPROMPT* pap = (AUTOPLAYPROMPT*)DPA_GetPtr(g_hdpaAutoplayPrompt, i);

            if (!lstrcmpi(pap->szDriveOrDeviceID, pszAltDeviceID))
            {
                TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: Removing %s",
                    pap->szDriveOrDeviceID);

                if (pap->pDeviceGoneFlag)
                {
                    pap->pDeviceGoneFlag->Release();
                }

                LocalFree((HLOCAL)pap);

                DPA_DeletePtr(g_hdpaAutoplayPrompt, i);

                TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: Total # of entry: %d",
                    DPA_GetPtrCount(g_hdpaAutoplayPrompt));

                break;
            }
        }            
    }

    LeaveCriticalSection(&g_csAutoplayPrompt);
}

// Set/Get HWND
typedef BOOL (*PFNSETAAUTOPLAYPROMPTHWNDCB)(AUTOPLAYPROMPT* pap, HWND hwnd);

BOOL _SetAutoplayPromptHWNDCB(AUTOPLAYPROMPT* pap, HWND hwnd)
{
    pap->hwndDlg = hwnd;

    TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: SetHWND for %s - (dlg = %d)",
        pap->szDriveOrDeviceID, pap->fDlgWillBeShown);

    return TRUE;
}

void _SetAutoplayPromptHWND(LPCWSTR pszAltDeviceID, HWND hwnd)
{
    BOOL fRet;

    _FindAutoplayStructAndExecuteCB<PFNSETAAUTOPLAYPROMPTHWNDCB, HWND, BOOL>
        (pszAltDeviceID, _SetAutoplayPromptHWNDCB, hwnd, &fRet);
}

typedef BOOL (*PFNGETAAUTOPLAYPROMPTHWNDCB)(AUTOPLAYPROMPT* pap, HWND* phwnd);

BOOL _GetAutoplayPromptHWNDCB(AUTOPLAYPROMPT* pap, HWND* phwnd)
{
    *phwnd = pap->hwndDlg;

    TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: GetHWND for %s - (dlg = %d)",
        pap->szDriveOrDeviceID, pap->fDlgWillBeShown);

    return TRUE;
}

BOOL _GetAutoplayPromptHWND(LPCWSTR pszAltDeviceID, HWND* phwnd)
{
    BOOL fRet;

    return _FindAutoplayStructAndExecuteCB<PFNGETAAUTOPLAYPROMPTHWNDCB, HWND*, BOOL>
        (pszAltDeviceID, _GetAutoplayPromptHWNDCB, phwnd, &fRet);
}

// Set/Get DeviceGoneFlag
typedef BOOL (*PFNSETDEVICEGONEFLAGCB)(AUTOPLAYPROMPT* pap, CCrossThreadFlag* pDeviceGoneFlag);

BOOL _SetDeviceGoneFlagCB(AUTOPLAYPROMPT* pap, CCrossThreadFlag* pDeviceGoneFlag)
{
    pap->pDeviceGoneFlag = pDeviceGoneFlag;

    TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: SetDeviceGoneFlag for %s - (dlg = %d)",
        pap->szDriveOrDeviceID, pap->fDlgWillBeShown);

    return TRUE;
}

void AttachGoneFlagForDevice(LPCWSTR pszAltDeviceID, CCrossThreadFlag* pDeviceGoneFlag)
{
    BOOL fRet;

    if (!_FindAutoplayStructAndExecuteCB<PFNSETDEVICEGONEFLAGCB, CCrossThreadFlag*, BOOL>
        (pszAltDeviceID, _SetDeviceGoneFlagCB, pDeviceGoneFlag, &fRet))
    {
        _AddAutoplayPromptEntry(pszAltDeviceID, FALSE);

        if (_FindAutoplayStructAndExecuteCB<PFNSETDEVICEGONEFLAGCB, CCrossThreadFlag*, BOOL>
                (pszAltDeviceID, _SetDeviceGoneFlagCB, pDeviceGoneFlag, &fRet))
        {
            if (fRet)
            {
                pDeviceGoneFlag->AddRef();
            }
        }
    }
}

typedef BOOL (*PFNGETDEVICEGONEFLAGCB)(AUTOPLAYPROMPT* pap, CCrossThreadFlag** ppDeviceGoneFlag);

BOOL _GetDeviceGoneFlagCB(AUTOPLAYPROMPT* pap, CCrossThreadFlag** ppDeviceGoneFlag)
{
    *ppDeviceGoneFlag = pap->pDeviceGoneFlag;

    TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: GetDeviceGoneFlag for %s - (dlg = %d)",
        pap->szDriveOrDeviceID, pap->fDlgWillBeShown);

    return !!(*ppDeviceGoneFlag);
}

BOOL GetGoneFlagForDevice(LPCWSTR pszAltDeviceID, CCrossThreadFlag** ppDeviceGoneFlag)
{
    BOOL fRet;

    if (_FindAutoplayStructAndExecuteCB<PFNGETDEVICEGONEFLAGCB, CCrossThreadFlag**, BOOL>
        (pszAltDeviceID, _GetDeviceGoneFlagCB, ppDeviceGoneFlag, &fRet))
    {
        (*ppDeviceGoneFlag)->AddRef();
    }
    else
    {
        TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: GetDeviceGoneFlag for %s -> Did not find!",
            pszAltDeviceID);

        fRet = FALSE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mergfldr.cpp ===
#include "shellprv.h"
#pragma  hdrstop
#include "clsobj.h"

#include "ids.h"
#include <cowsite.h>
#include "datautil.h"
#include "idhidden.h"
#include "prop.h"
#include "stgutil.h"
#include "sfstorage.h"
#include "util.h"
#include "fstreex.h"
#include "basefvcb.h"
#include "category.h"
#include "mergfldr.h"
#include "filefldr.h"
#include "idldata.h"
#include "defcm.h"

#define TF_AUGM 0x10000000


// pidl wrapper contains a TAG word for validation and then
// the count for the number of packaged pidl object.
//
// each pidl has a hidden payload which is the name space
// index that it originated from. 

#pragma pack(1)
typedef struct 
{
    USHORT      cb;         // pidl wrap length 
    USHORT      dwFlags;    // flags
    ULONG       ulTag;      // signature
    ULONG       ulVersion ; // AugMergeISF pidl version
    ULONG       cSrcs;      // Number of source _Namespace objects backing this composite pidl
} AUGM_IDWRAP;
typedef UNALIGNED AUGM_IDWRAP *PAUGM_IDWRAP;

typedef struct  
{
    HIDDENITEMID hid;
    UINT    uSrcID;         // src _Namespace
} AUGM_NAMESPACE;
typedef UNALIGNED AUGM_NAMESPACE *PAUGM_NAMESPACE;
#pragma pack()

#define AUGM_NS_CURRENTVERSION  0
#define AUGM_WRAPVERSION_1_0    MAKELONG(1, 0)
#define AUGM_WRAPVERSION_2_0    MAKELONG(2, 0)

#define AUGM_WRAPCURRENTVERSION AUGM_WRAPVERSION_2_0

#define AUGM_WRAPTAG            MAKELONG(MAKEWORD('A','u'), MAKEWORD('g','M'))
#define CB_IDLIST_TERMINATOR    sizeof(USHORT)

// dwFlags field flags
#define AUGMF_ISSIMPLE          0x0001


// helpers.

HRESULT CMergedFldrContextMenu_CreateInstance(HWND hwnd, CMergedFolder *pmf, UINT cidl, LPCITEMIDLIST *apidl, IContextMenu *pcmCommon, IContextMenu *pcmUser, IContextMenu **ppcm);
HRESULT CMergedFldrEnum_CreateInstance(CMergedFolder*pmf, DWORD grfFlags, IEnumIDList **ppenum);
HRESULT CMergedFldrDropTarget_CreateInstance(CMergedFolder*pmf, HWND hwnd, IDropTarget **ppdt);
HRESULT CMergedFolderViewCB_CreateInstance(CMergedFolder *pmf, IShellFolderViewCB **ppsfvcb);

// Helper function that spans all objects
BOOL AffectAllUsers(HWND hwnd)
{
    BOOL bRet = FALSE;  // default to NO
    if (hwnd)
    {
        TCHAR szMessage[255];
        TCHAR szTitle[20];

        if (LoadString(HINST_THISDLL, IDS_ALLUSER_WARNING, szMessage, ARRAYSIZE(szMessage)) > 0 &&
            LoadString(HINST_THISDLL, IDS_WARNING, szTitle, ARRAYSIZE(szTitle)) > 0)
        {
            bRet = (IDYES == MessageBox(hwnd, szMessage, szTitle, MB_YESNO | MB_ICONINFORMATION));
        }
    }
    else
        bRet = TRUE;    // NULL hwnd implies NO UI, say "yes"
    return bRet;
}



//  CMergedFoldersource _Namespace descriptor.
//
//  Objects of class CMergedFldrNamespace are created by CMergedFolderin 
//  the AddNameSpace() method impl, and are maintained in the collection
//  CMergedFolder::_hdpaNamespaces.
//

class CMergedFldrNamespace
{
public:
    CMergedFldrNamespace();
    ~CMergedFldrNamespace();

    IShellFolder* Folder() const
        { return _psf; }
    REFGUID GetGUID() const
        { return _guid; }
    ULONG FolderAttrib() const  
        { return _dwAttrib; }
    LPCITEMIDLIST GetIDList() const 
        { return _pidl; }
    HRESULT GetLocation(LPWSTR pszBuffer, INT cchBuffer)
        { StrCpyN(pszBuffer, _szLocation, cchBuffer); return S_OK; };
    LPCWSTR GetDropFolder()
        { return _szDrop; };
    ULONG FixItemAttributes(ULONG attrib)
        { return (attrib & _dwItemAttribMask) | _dwItemAttrib; }
    DWORD GetDropEffect(void) const
        { return _dwDropEffect; }
    int GetDefaultOverlayIndex() const
        { return _iDefaultOverlayIndex; }
    int GetConflictOverlayIndex() const
        { return _iConflictOverlayIndex; }
    int GetNamespaceOverlayIndex(LPCITEMIDLIST pidl);
    
    HRESULT SetNamespace(const GUID * pguidUIObject, IShellFolder* psf, LPCITEMIDLIST pidl, ULONG dwAttrib);
    HRESULT SetDropFolder(LPCWSTR pszDrop);
    HRESULT RegisterNotify(HWND, UINT, ULONG);
    HRESULT UnregisterNotify();
    BOOL SetOwner(IUnknown *punk);
    
protected:
    ULONG _RegisterNotify(HWND hwnd, UINT nMsg, LPCITEMIDLIST pidl, DWORD dwEvents, UINT uFlags, BOOL fRecursive);
    void _ReleaseNamespace();

    IShellFolder* _psf;             // IShellFolder interface pointer
    GUID _guid;                     // optional GUID for specialized UI handling
    LPITEMIDLIST _pidl;             // optional pidl
    ULONG  _dwAttrib;               // optional flags
    UINT _uChangeReg;               // Shell change notify registration ID.

    WCHAR _szLocation[MAX_PATH];    // Location to use for object
    WCHAR _szDrop[MAX_PATH];        // folder that gets the forced drop effect
    DWORD _dwItemAttrib;            // OR mask for the attributes
    DWORD _dwItemAttribMask;        // AND mask for the attributes
    DWORD _dwDropEffect;            // default drop effect for this folder
    int   _iDefaultOverlayIndex;    // overlay icon index for default
    int   _iConflictOverlayIndex;   // overlay icon index if the name exists in another namespace
};

CMergedFldrNamespace::CMergedFldrNamespace() :
    _dwItemAttribMask(-1)
{
}

inline CMergedFldrNamespace::~CMergedFldrNamespace()
{ 
    UnregisterNotify();
    _ReleaseNamespace();
}

HRESULT CMergedFldrNamespace::SetNamespace(const GUID * pguidUIObject, IShellFolder* psf, LPCITEMIDLIST pidl, ULONG dwAttrib)
{
    _ReleaseNamespace();

    // store the IShellFolder object if we have one
    if (psf)
    {
        _psf = psf;
        _psf->AddRef();
    }
    else if (pidl)
    {
        SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidl, &_psf));
    }

    // get the IDLIST that this namespace represnets
    if (pidl)
    {
        _pidl = ILClone(pidl);      // we have a PIDL passed to us.
    }
    else
    {
        _pidl = NULL;
        IPersistFolder3 *ppf3;
        if (SUCCEEDED(_psf->QueryInterface(IID_PPV_ARG(IPersistFolder3, &ppf3))))
        {
            PERSIST_FOLDER_TARGET_INFO pfti;
            if (SUCCEEDED(ppf3->GetFolderTargetInfo(&pfti)))
            {
                _pidl = pfti.pidlTargetFolder;
            }
            ppf3->Release();
        }

        // if it doesnt have IPersistFolder3 or if there's no target folder then
        // fall back to IPersistFolder2
        if (!_pidl)
        {
            SHGetIDListFromUnk(psf, &_pidl);
        }
    }

    if (!_psf || !_pidl)
        return E_FAIL;

    // now fill out the information about the namespace, including getting the display
    // information from the registry

    _guid = pguidUIObject ? *pguidUIObject : GUID_NULL;
    _dwAttrib = dwAttrib;

    _szLocation[0] = TEXT('\0');
    _dwItemAttrib = 0;                  // item attribute become a NOP
    _dwItemAttribMask = (DWORD)-1;
    _dwDropEffect = 0;                  // default behaviour
    _iDefaultOverlayIndex = -1;
    _iConflictOverlayIndex = -1;

    // format a key to the property bag stored in the registry, then create the
    // property bag which we then query against.

    TCHAR szKey[MAX_PATH], szGUID[GUIDSTR_MAX+1];
    SHStringFromGUID(_guid, szGUID, ARRAYSIZE(szGUID));
    wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("CLSID\\%s\\MergedFolder"), szGUID);

    IPropertyBag *ppb;
    if (SUCCEEDED(SHCreatePropertyBagOnRegKey(HKEY_CLASSES_ROOT, szKey, STGM_READ, IID_PPV_ARG(IPropertyBag, &ppb))))
    {
        TCHAR szLocalized[100];
        if (SUCCEEDED(SHPropertyBag_ReadStr(ppb, L"Location", szLocalized, ARRAYSIZE(szLocalized))))
        {
            SHLoadIndirectString(szLocalized, _szLocation, ARRAYSIZE(_szLocation), NULL);
        }

        SHPropertyBag_ReadDWORD(ppb, L"Attributes", &_dwItemAttrib);
        SHPropertyBag_ReadDWORD(ppb, L"AttributeMask", &_dwItemAttribMask);
        SHPropertyBag_ReadDWORD(ppb, L"DropEffect", &_dwDropEffect);

        TCHAR szIconLocation[MAX_PATH];
        szIconLocation[0] = 0;
        SHPropertyBag_ReadStr(ppb, L"DefaultOverlayIcon", szIconLocation, ARRAYSIZE(szIconLocation));
        _iDefaultOverlayIndex = SHGetIconOverlayIndex(szIconLocation, PathParseIconLocation(szIconLocation));

        szIconLocation[0] = 0;
        SHPropertyBag_ReadStr(ppb, L"ConflictOverlayIcon", szIconLocation, ARRAYSIZE(szIconLocation));
        _iConflictOverlayIndex = SHGetIconOverlayIndex(szIconLocation, PathParseIconLocation(szIconLocation));

        ppb->Release();
    }

    if (!SHGetPathFromIDList(_pidl, _szDrop))
    {
        _szDrop[0] = 0;
    }

    return S_OK;
}

HRESULT CMergedFldrNamespace::SetDropFolder(LPCWSTR pszDrop)
{
    StrCpyN(_szDrop, pszDrop, ARRAYSIZE(_szDrop));
    return S_OK;
}

void CMergedFldrNamespace::_ReleaseNamespace()
{
    ATOMICRELEASE(_psf); 
    ILFree(_pidl);
    _pidl = NULL;
    _guid = GUID_NULL;
    _dwAttrib = 0L;
}

ULONG CMergedFldrNamespace::_RegisterNotify(HWND hwnd, UINT nMsg, LPCITEMIDLIST pidl, DWORD dwEvents, UINT uFlags, BOOL fRecursive)
{
    SHChangeNotifyEntry fsne = { 0 };
    fsne.fRecursive = fRecursive;
    fsne.pidl = pidl;
    return SHChangeNotifyRegister(hwnd, uFlags | SHCNRF_NewDelivery, dwEvents, nMsg, 1, &fsne);
}


//  Register change notification for the _Namespace
HRESULT CMergedFldrNamespace::RegisterNotify(HWND hwnd, UINT uMsg, ULONG lEvents)
{
    if (0 == _uChangeReg)
    {
        _uChangeReg = _RegisterNotify(hwnd, uMsg, _pidl, lEvents,
                                       SHCNRF_ShellLevel | SHCNRF_InterruptLevel | SHCNRF_RecursiveInterrupt,
                                       TRUE);
    }

    return 0 != _uChangeReg ? S_OK : E_FAIL;
}

// Unregister change notification for the _Namespace
HRESULT CMergedFldrNamespace::UnregisterNotify()
{
    if (_uChangeReg)
    {
        ::SHChangeNotifyDeregister(_uChangeReg);
        _uChangeReg = 0;
    }
    return S_OK;
}

inline BOOL CMergedFldrNamespace::SetOwner(IUnknown *punkOwner)
{
    if (!_psf)
        return FALSE;

    IUnknown_SetOwner(_psf, punkOwner);
    return TRUE;
}

int CMergedFldrNamespace::GetNamespaceOverlayIndex(LPCITEMIDLIST pidl)
{
    int iIndex = -1;
    if (_psf)
    {
        IShellIconOverlay *psio;
        if (SUCCEEDED(_psf->QueryInterface(IID_PPV_ARG(IShellIconOverlay, &psio))))
        {
            psio->GetOverlayIndex(pidl, &iIndex);
            psio->Release();
        }
    }
    return iIndex;
}

// object which takes ownership of the IDLIST and handles wrapping and returning information from it.

class CMergedFldrItem
{
public:
    ~CMergedFldrItem();
    BOOL Init(IShellFolder* psf, LPITEMIDLIST pidl, int iNamespace);
    BOOL Init(CMergedFldrItem *pmfi);

    BOOL SetDisplayName(LPTSTR pszDispName)
            { return Str_SetPtr(&_pszDisplayName, pszDispName); }
    ULONG GetFolderAttrib()
            { return _rgfAttrib; }
    LPTSTR GetDisplayName()
            { return _pszDisplayName; }
    LPITEMIDLIST GetIDList()
            { return _pidlWrap; }
    int GetNamespaceID()
            { return _iNamespace; }

private:
    ULONG _rgfAttrib;
    LPTSTR _pszDisplayName;
    LPITEMIDLIST _pidlWrap;
    int    _iNamespace;

    friend CMergedFolder;
};

CMergedFldrItem::~CMergedFldrItem()
{   
    Str_SetPtr(&_pszDisplayName, NULL);
    ILFree(_pidlWrap);
}

BOOL CMergedFldrItem::Init(CMergedFldrItem *pmfi)
{
    _iNamespace = pmfi->_iNamespace;
    _pidlWrap = ILClone(pmfi->GetIDList());
    BOOL fRet = (_pidlWrap != NULL);
    if (fRet)
    {
        fRet = SetDisplayName(pmfi->GetDisplayName());
        _rgfAttrib = pmfi->GetFolderAttrib();
    }

    return fRet;
}

BOOL CMergedFldrItem::Init(IShellFolder* psf, LPITEMIDLIST pidl, int iNamespace)
{
    BOOL fRet = FALSE;

    _pidlWrap = pidl;                               // evil, hold an alias
    _rgfAttrib = SFGAO_FOLDER | SFGAO_HIDDEN;
    _iNamespace = iNamespace;

    if (SUCCEEDED(psf->GetAttributesOf(1, (LPCITEMIDLIST*)&pidl, &_rgfAttrib)))
    {
        TCHAR szDisplayName[MAX_PATH];
        if (SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szDisplayName, ARRAYSIZE(szDisplayName))))
        {
            fRet = SetDisplayName(szDisplayName);
        }
    }
    return fRet;
}


// shell folder object.
CMergedFolder::CMergedFolder(CMergedFolder *pmfParent, REFCLSID clsid) : 
        _clsid(clsid),
        _cRef(1), 
        _pmfParent(pmfParent),
        _iColumnOffset(-1)
{
    ASSERT(_hdpaNamespaces == NULL);
    if (_pmfParent)
    {
        _pmfParent->AddRef();
        _fDontMerge = _pmfParent->_fDontMerge;
        _fCDBurn = _pmfParent->_fCDBurn;
        _fInShellView = _pmfParent->_fInShellView;
        _dwDropEffect = _pmfParent->_dwDropEffect;
    }
    else
    {
        _fDontMerge = IsEqualCLSID(_clsid, CLSID_CompositeFolder);
        _fCDBurn = IsEqualCLSID(_clsid, CLSID_CDBurnFolder);
    }

    DllAddRef();
}

CMergedFolder::~CMergedFolder()
{
    SetOwner(NULL);
    ILFree(_pidl);
    _FreeNamespaces();
    _FreeObjects();
    ATOMICRELEASE(_pmfParent);
    ATOMICRELEASE(_pstg);
    DllRelease();
}

// CMergedFolderglobal CreateInstance method for da class factory
HRESULT CMergedFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    // aggregation checking is handled in class factory
    HRESULT hr = E_OUTOFMEMORY;
    CMergedFolder* pmf = new CMergedFolder(NULL, CLSID_MergedFolder);
    if (pmf)
    {
        hr = pmf->QueryInterface(riid, ppv);
        pmf->Release();
    }
    return hr;
}

HRESULT CCompositeFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    // aggregation checking is handled in class factory
    HRESULT hr = E_OUTOFMEMORY;
    CMergedFolder* pmf = new CMergedFolder(NULL, CLSID_CompositeFolder);
    if (pmf)
    {
        hr = pmf->QueryInterface(riid, ppv);
        pmf->Release();
    }
    return hr;
}

#ifdef TESTING_COMPOSITEFOLDER
COMPFOLDERINIT s_rgcfiTripleD[] = {
    {CFITYPE_CSIDL, CSIDL_DRIVES, L"Drives"},
    {CFITYPE_PIDL, (int)&c_idlDesktop, L"Desktop"},
    {CFITYPE_PATH, (int)L"::{450d8fba-ad25-11d0-98a8-0800361b1103}", L"MyDocs"}
};

STDAPI CTripleD_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    ICompositeFolder *pcf;
    HRESULT hr = CCompositeFolder_CreateInstance(punkOuter, IID_PPV_ARG(ICompositeFolder, &pcf));

    if (SUCCEEDED(hr))
    {
        hr = pcf->InitComposite(0x8877, CLSID_TripleD, CFINITF_FLAT, ARRAYSIZE(s_rgcfiTripleD), s_rgcfiTripleD);

        if (SUCCEEDED(hr))
        {
            hr = pcf->QueryInterface(riid, ppv);
        }
        pcf->Release();
    }

    return hr;
}
#endif //TESTING_COMPOSITEFOLDER


STDMETHODIMP CMergedFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CMergedFolder, IShellFolder, IAugmentedShellFolder),
        QITABENT     (CMergedFolder, IAugmentedShellFolder),
        QITABENT     (CMergedFolder, IAugmentedShellFolder2),
        QITABENT     (CMergedFolder, IAugmentedShellFolder3),
        QITABENT     (CMergedFolder, IShellFolder2),
        QITABENT     (CMergedFolder, IShellService),
        QITABENT     (CMergedFolder, ITranslateShellChangeNotify),
        QITABENT     (CMergedFolder, IStorage),
        QITABENT     (CMergedFolder, IShellIconOverlay),
        QITABENTMULTI(CMergedFolder, IPersist, IPersistFolder2),
        QITABENTMULTI(CMergedFolder, IPersistFolder, IPersistFolder2),
        QITABENT     (CMergedFolder, IPersistFolder2),
        QITABENT     (CMergedFolder, IPersistPropertyBag),
        QITABENT     (CMergedFolder, ICompositeFolder),
        QITABENT     (CMergedFolder, IItemNameLimits),
        { 0 },
    };
    if (IsEqualIID(CLSID_MergedFolder, riid))
    {
        *ppv = this;
        AddRef();
        return S_OK;
    }
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CMergedFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CMergedFolder::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


// get the count from the enumerated items.
int CMergedFolder::_ObjectCount() const
{
    return _hdpaObjects ? DPA_GetPtrCount(_hdpaObjects) : 0;
}

CMergedFldrItem *CMergedFolder::_GetObject(int i)
{
    return _hdpaObjects ? (CMergedFldrItem *)DPA_GetPtr(_hdpaObjects, i) : NULL;
}

int CMergedFolder::_NamespaceCount() const 
{
    return _hdpaNamespaces ? DPA_GetPtrCount(_hdpaNamespaces) : 0;
}


//  Retrieves a pointer to a source _Namespace descriptor associated with 
//  the specified lookup index.

HRESULT CMergedFolder::_Namespace(int iIndex, CMergedFldrNamespace **ppns)
{
    *ppns = NULL;
    if ((iIndex >= 0) && (iIndex < _NamespaceCount()))
        *ppns = _Namespace(iIndex);
    return *ppns ? S_OK : E_INVALIDARG;
}


// given an index for the name space return it.
CMergedFldrNamespace* CMergedFolder::_Namespace(int iNamespace)
{
    if (!_hdpaNamespaces)
        return NULL;

    return (CMergedFldrNamespace*)DPA_GetPtr(_hdpaNamespaces, iNamespace);
}

// Determine whether pidls from the two namespaces should be merged
// The NULL namespace is a wildcard that always merges (if merging is permitted at all)
BOOL CMergedFolder::_ShouldMergeNamespaces(CMergedFldrNamespace *pns1, CMergedFldrNamespace *pns2)
{
    // Early-out:  Identical namespaces can be merged (even if merging
    //             is globally disabled)
    if (pns1 == pns2)
    {
        return TRUE;
    }

    // Early-out:  Merging globally disabled
    if (_fDontMerge)
    {
        return FALSE;
    }

    // Early-out:  Merging globally enabled
    if (!_fPartialMerge)
    {
        return TRUE;
    }

    if (!pns1 || !pns2)
    {
        return TRUE;                // wildcard
    }

    if (!(pns1->FolderAttrib() & ASFF_MERGESAMEGUID))
    {
        // this namespace will merge with anybody!
        return TRUE;
    }

    // Source namespace will merge only with namespaces of the same GUID
    // See if destination namespace has the same GUID
    return IsEqualGUID(pns1->GetGUID(), pns2->GetGUID());
}

// Determine whether pidls from the two namespaces should be merged
// NAmespace -1 is a wildcard that always merges (if merging is permitted at all)
BOOL CMergedFolder::_ShouldMergeNamespaces(int iNS1, int iNS2)
{
    // Early-out:  Merging globally disabled
    if (_fDontMerge)
    {
        return FALSE;
    }

    // Early-out:  Merging globally enabled
    if (!_fPartialMerge)
    {
        return TRUE;
    }

    if (iNS1 < 0 || iNS2 < 0)
    {
        return TRUE;                // wildcard
    }

    return _ShouldMergeNamespaces(_Namespace(iNS1), _Namespace(iNS2));
}


// check to see if the IDLIST we are given is a wrapped one.
HRESULT CMergedFolder::_IsWrap(LPCITEMIDLIST pidl)
{
    HRESULT hr = E_INVALIDARG;
    if (pidl)
    {
        ASSERT(IS_VALID_PIDL(pidl));
        PAUGM_IDWRAP pWrap = (PAUGM_IDWRAP)pidl;

        if ((pWrap->cb >= sizeof(AUGM_IDWRAP)) &&
            (pWrap->ulTag == AUGM_WRAPTAG) &&
            (pWrap->ulVersion == AUGM_WRAPVERSION_2_0))
        {
            hr = S_OK;
        }
        else if (ILFindHiddenID(pidl, IDLHID_PARENTFOLDER))
        {
            hr = S_OK;
        }
    }
    return hr;
}


//  STRRET_OFFSET has no meaning in context of the pidl wrapper.
//  We can either calculate the offset into the wrapper, or allocate
//  a wide char for the name.  For expedience, we'll allocate the name.

HRESULT CMergedFolder::_FixStrRetOffset(LPCITEMIDLIST pidl, STRRET *psr)
{
    HRESULT hr = S_OK;

    if (psr->uType == STRRET_OFFSET)
    {
        UINT cch = lstrlenA(STRRET_OFFPTR(pidl, psr));
        LPWSTR pwszName = (LPWSTR)SHAlloc((cch + 1) * sizeof(WCHAR));
        if (pwszName)
        {
            SHAnsiToUnicode(STRRET_OFFPTR(pidl, psr), pwszName, cch + 1);
            pwszName[cch] = 0;
            psr->pOleStr = pwszName;
            psr->uType   = STRRET_WSTR;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}


// is the object a folder?
BOOL CMergedFolder::_IsFolder(LPCITEMIDLIST pidl)
{
    ULONG rgf = SFGAO_FOLDER | SFGAO_STREAM;
    return SUCCEEDED(GetAttributesOf(1, &pidl, &rgf)) && (SFGAO_FOLDER == (rgf & (SFGAO_FOLDER | SFGAO_STREAM)));
}


// the number of source _Namespace pidls in the wrap.
ULONG CMergedFolder::_GetSourceCount(LPCITEMIDLIST pidl)
{
    if (SUCCEEDED(_IsWrap(pidl)))
    {
        if (ILFindHiddenID(pidl, IDLHID_PARENTFOLDER))
        {
            return 1;
        }
        else
        {
            PAUGM_IDWRAP pWrap = (PAUGM_IDWRAP)pidl;
            return pWrap->cSrcs;    
        }
    }
    return 0;
}

// Creates an IDLIST for CMergedFolder that wraps a single source pidl.
HRESULT CMergedFolder::_CreateWrap(LPCITEMIDLIST pidlSrc, UINT nSrcID, LPITEMIDLIST *ppidlWrap)
{
    *ppidlWrap = NULL;              // incase of failure

    LPITEMIDLIST pidlSrcWithID;
    HRESULT hr = SHILClone(pidlSrc, &pidlSrcWithID);
    if (SUCCEEDED(hr))
    {
        hr = E_OUTOFMEMORY;
        if (!ILFindHiddenID(pidlSrcWithID, IDLHID_PARENTFOLDER))
        {
            AUGM_NAMESPACE ans = { {sizeof(ans), AUGM_NS_CURRENTVERSION, IDLHID_PARENTFOLDER} , nSrcID };
            pidlSrcWithID = ILAppendHiddenID((LPITEMIDLIST)pidlSrcWithID, &ans.hid);
        }

        if (pidlSrcWithID)
        {
            UINT cbAlloc = sizeof(AUGM_IDWRAP) + CB_IDLIST_TERMINATOR +      // header for our IDLIST
                           pidlSrcWithID->mkid.cb + CB_IDLIST_TERMINATOR;   // wrapped IDLIST

            AUGM_IDWRAP *pWrap = (AUGM_IDWRAP *)_ILCreate(cbAlloc);
            if (pWrap)
            {
                // fill out wrapped header
                pWrap->cb = (USHORT)(cbAlloc - CB_IDLIST_TERMINATOR);
                pWrap->dwFlags = 0;
                pWrap->ulTag = AUGM_WRAPTAG;
                pWrap->ulVersion = AUGM_WRAPVERSION_2_0;
                pWrap->cSrcs = 1;
        
                // copy the IDLIST with the hidden data into the wrapping object
                LPITEMIDLIST pidl = (LPITEMIDLIST)((BYTE *)pWrap + sizeof(AUGM_IDWRAP));
                memcpy(pidl, pidlSrcWithID, pidlSrcWithID->mkid.cb);
                *ppidlWrap = (LPITEMIDLIST)pWrap;
                hr = S_OK;
            }

            ILFree(pidlSrcWithID);
        }
    }

    return hr;
}

// does the wrapped IDLIST we are passed contain the given source ID?
BOOL CMergedFolder::_ContainsSrcID(LPCITEMIDLIST pidl, UINT uSrcID)
{
    UINT uID;
    for (UINT nSrc = 0; SUCCEEDED(_GetSubPidl(pidl, nSrc, &uID, NULL, NULL)); nSrc++)
    {        
        if (uID == uSrcID)
            return TRUE;
    }        
    return FALSE;
}

// returns new pidl in *ppidl free of nSrcID
HRESULT CMergedFolder::_WrapRemoveIDList(LPITEMIDLIST pidlWrap, UINT nSrcID, LPITEMIDLIST *ppidl)
{
    ASSERT(IS_VALID_WRITE_PTR(ppidl, LPITEMIDLIST));
    
    *ppidl = NULL;

    HRESULT hr = _IsWrap(pidlWrap);
    if (SUCCEEDED(hr))
    {
        UINT uID;
        LPITEMIDLIST pidl;
        for (UINT i = 0; SUCCEEDED(hr) && SUCCEEDED(_GetSubPidl(pidlWrap, i, &uID, &pidl, NULL)); i++)
        {
            if (uID != nSrcID)
                hr = _WrapAddIDList(pidl, uID, ppidl);
            ILFree(pidl);
        }
    }

    return hr;
}

HRESULT CMergedFolder::_WrapRemoveIDListAbs(LPITEMIDLIST pidlWrapAbs, UINT nSrcID, LPITEMIDLIST *ppidlAbs)
{
    ASSERT(ppidlAbs);

    HRESULT hr = E_OUTOFMEMORY;
    *ppidlAbs = ILCloneParent(pidlWrapAbs);
    if (*ppidlAbs)
    {
        LPITEMIDLIST pidlLast;
        hr = _WrapRemoveIDList(ILFindLastID(pidlWrapAbs), nSrcID, &pidlLast);
        if (SUCCEEDED(hr))
        {
            // shilappend frees pidlLast
            hr = SHILAppend(pidlLast, ppidlAbs);
        }
    }
    return hr;
}


// Adds a source pidl to *ppidlWrap (IN/OUT param!)
HRESULT CMergedFolder::_WrapAddIDList(LPCITEMIDLIST pidlSrc, UINT nSrcID, LPITEMIDLIST* ppidlWrap)
{
    HRESULT hr;

    if (!*ppidlWrap)
    {
        // called as a create, rather than append       
        hr = _CreateWrap(pidlSrc, nSrcID, ppidlWrap);   
    }
    else
    {
        // check to see if we already have the ID in this IDLIST we are wrapping onto.        
        LPITEMIDLIST pidlSrcWithID;
        hr = SHILClone(pidlSrc, &pidlSrcWithID);
        if (SUCCEEDED(hr))
        {
            hr = E_OUTOFMEMORY;
            if (!ILFindHiddenID(pidlSrcWithID, IDLHID_PARENTFOLDER))
            {
                AUGM_NAMESPACE ans = { {sizeof(ans), AUGM_NS_CURRENTVERSION, IDLHID_PARENTFOLDER} , nSrcID };
                pidlSrcWithID = ILAppendHiddenID((LPITEMIDLIST)pidlSrcWithID, &ans.hid);
            }

            // ok, we have an IDLIST that we can use to append to this object.
            if (pidlSrcWithID)
            {
                BOOL fOtherSrcIDsExist = TRUE;
                // check to see if this ID already exists within the wrap idlist.
                if (*ppidlWrap && _ContainsSrcID(*ppidlWrap, nSrcID))
                {
                    LPITEMIDLIST pidlFree = *ppidlWrap;
                    if (SUCCEEDED(_WrapRemoveIDList(pidlFree, nSrcID, ppidlWrap)))
                    {
                        ILFree(pidlFree);
                    }
                    fOtherSrcIDsExist = (*ppidlWrap != NULL);
                }

                if (fOtherSrcIDsExist)
                {
                    // now compute the new size of the IDLIST.  (*ppidlWrap has been updated);
                    PAUGM_IDWRAP pWrap = (PAUGM_IDWRAP)*ppidlWrap;

                    SHORT cbOld = pWrap->cb;
                    SHORT cbNew = cbOld + (pidlSrcWithID->mkid.cb + CB_IDLIST_TERMINATOR);            // extra terminator is appended.
           
                    pWrap = (PAUGM_IDWRAP)SHRealloc(pWrap, cbNew + CB_IDLIST_TERMINATOR);

                    if (pWrap)
                    {
                        // copy the new idlist and its hidden payload (ensure we are terminated)
                        memcpy(((BYTE*)pWrap)+ cbOld, pidlSrcWithID, cbNew-cbOld);
                        *((UNALIGNED SHORT*)(((BYTE*)pWrap)+ cbNew)) = 0;    

                        pWrap->cb += cbNew-cbOld;
                        pWrap->cSrcs++;
                        hr = S_OK;
                    }
                    *ppidlWrap = (LPITEMIDLIST)pWrap;
                }
                else
                {
                    hr = _CreateWrap(pidlSrc, nSrcID, ppidlWrap);
                }
                ILFree(pidlSrcWithID);
            }
        }
    }

    return hr;
}


// used to itterate through the sub pidls in the wrapped pidl
// all out params optional
//
// out:
//      *ppidl  alias into pidlWrap (nested pidl)

HRESULT CMergedFolder::_GetSubPidl(LPCITEMIDLIST pidlWrap, int i, UINT *pnSrcID, LPITEMIDLIST *ppidl, CMergedFldrNamespace **ppns)
{
    if (pnSrcID)
        *pnSrcID = -1;

    if (ppidl)
        *ppidl = NULL;

    if (ppns)
        *ppns = NULL;
 
    HRESULT hr = _IsWrap(pidlWrap);
    if (SUCCEEDED(hr))
    {
        if ((UINT)i < _GetSourceCount(pidlWrap))
        {
            PAUGM_NAMESPACE pans = (PAUGM_NAMESPACE)ILFindHiddenID(pidlWrap, IDLHID_PARENTFOLDER);
            if (!pans)
            {
                PAUGM_IDWRAP pWrap = (PAUGM_IDWRAP)pidlWrap;
                LPITEMIDLIST pidlSrc = (LPITEMIDLIST)(((BYTE *)pWrap) + sizeof(AUGM_IDWRAP));

                while (i--)
                {
                    // advance to next item
                    SHORT cb = pidlSrc->mkid.cb;
                    pidlSrc = (LPITEMIDLIST)(((BYTE *)pidlSrc) + cb + CB_IDLIST_TERMINATOR);
                }

                if (pnSrcID || ppns)
                {
                    PAUGM_NAMESPACE pans = (PAUGM_NAMESPACE)ILFindHiddenID(pidlSrc, IDLHID_PARENTFOLDER);
                    ASSERTMSG((pans != NULL), "Failed to find hidden _Namespace in pidlWrap");
            
                    if (pans && pnSrcID)
                        *pnSrcID = pans->uSrcID;

                    if (pans && ppns)
                        hr = _Namespace(pans->uSrcID, ppns);
                }

                if (SUCCEEDED(hr) && ppidl)
                {
                    hr = SHILClone(pidlSrc, ppidl);
                }
            }
            else
            {
                if (pnSrcID)
                    *pnSrcID = pans->uSrcID;

                if (ppns)
                    hr = _Namespace(pans->uSrcID, ppns);

                if (SUCCEEDED(hr) && ppidl)
                {
                    hr = SHILClone(pidlWrap, ppidl);
                }
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    if (SUCCEEDED(hr) && ppidl)
    {
        // we need to strip away the hidden id that marks this guy as merged.
        // this is because the pidl we're returning is supposed to be a child of one of our
        // namespaces we're merging, so it should know absolutely nothing about being merged.
        // these guys used to slip through and cause problems.
        ILRemoveHiddenID(*ppidl, IDLHID_PARENTFOLDER);
    }

    ASSERT(!ppidl || (ILFindLastID(*ppidl) == *ppidl));

    return hr;
}

// function to compare two opaque pidls.
// this is helpful since in the non-merged case, there's some difficulty
// getting defview to contain items with the same name.  we need a way to
// compare two pidls to say "yes defview, these pidls are actually different!"
// note that the actual order doesn't matter, as long as the comparison
// is consistent (since this is used in sorting functions).
int CMergedFolder::_CompareArbitraryPidls(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    UINT iRet;
    UINT cbItem1 = ILGetSize(pidl1);
    UINT cbItem2 = ILGetSize(pidl2);
    if (cbItem1 != cbItem2)
    {
        iRet = (cbItem1 < cbItem2) ? 1 : -1;
    }
    else
    {
        iRet = memcmp(pidl1, pidl2, cbItem1);
        ASSERTMSG(iRet != 0, "no two pidls from the enumerators should be EXACTLY alike!");
    }
    return iRet;
}

int CMergedFolder::_Compare(void *pv1, void *pv2, LPARAM lParam)
{
    int iRet = -1;
    CMergedFldrItem* pmfiEnum1 = (CMergedFldrItem*)pv1;
    CMergedFldrItem* pmfiEnum2 = (CMergedFldrItem*)pv2;
    if (pmfiEnum1 && pmfiEnum2)
    {
        // Are these two items of different types?
        if (BOOLIFY(pmfiEnum1->GetFolderAttrib() & SFGAO_FOLDER) ^ BOOLIFY(pmfiEnum2->GetFolderAttrib() & SFGAO_FOLDER))
        {
            // Yes. Then Folders sort before items.
            iRet = BOOLIFY(pmfiEnum1->GetFolderAttrib() & SFGAO_FOLDER) ? 1 : -1;
        }
        else    // They are of the same type. Then compare by name
        {
            iRet = lstrcmpi(pmfiEnum1->GetDisplayName(), pmfiEnum2->GetDisplayName());
            if (iRet == 0)
            {
                CMergedFolder *pmf = (CMergedFolder *) lParam;
                if (!pmf->_ShouldMergeNamespaces(pmfiEnum1->GetNamespaceID(), pmfiEnum2->GetNamespaceID()))
                {
                    // these items cannot be merged,
                    // force iRet to be nonzero.  the only reason why this comparison
                    // has to be well-defined is so we can pass our ASSERTs that the
                    // list is sorted using this comparison function.
                    iRet = _CompareArbitraryPidls(pmfiEnum1->GetIDList(), pmfiEnum2->GetIDList());
                }
            }
        }
    }
    return iRet;
}


void *CMergedFolder::_Merge(UINT uMsg, void *pv1, void *pv2, LPARAM lParam)
{
    CMergedFolder*pmf = (CMergedFolder*)lParam;
    void * pvRet = pv1;
    
    switch (uMsg)
    {
    case DPAMM_MERGE:
        {
            UINT nSrcID;
            LPITEMIDLIST pidl;
            CMergedFldrItem* pitemSrc  = (CMergedFldrItem*)pv2;
            if (SUCCEEDED(pmf->_GetSubPidl(pitemSrc->GetIDList(), 0, &nSrcID, &pidl, NULL)))
            {
                // add pidl from src to dest
                CMergedFldrItem* pitemDest = (CMergedFldrItem*)pv1;
                pmf->_WrapAddIDList(pidl, nSrcID, &pitemDest->_pidlWrap);
                ILFree(pidl);
            }
        }
        break;

    case DPAMM_INSERT:
        {
            CMergedFldrItem* pmfiNew = new CMergedFldrItem;
            if (pmfiNew)
            {
                CMergedFldrItem* pmfiSrc = (CMergedFldrItem*)pv1;
                if (!pmfiNew->Init(pmfiSrc))
                {
                    delete pmfiNew;
                    pmfiNew = NULL;
                }
            }
            pvRet = pmfiNew;
        }
        break;

    default:
        ASSERT(0);
    }
    return pvRet;
}


typedef struct
{
    LPTSTR pszDisplayName;
    BOOL   fFolder;
    CMergedFolder *self;
    int    iNamespace;
} SEARCH_FOR_PIDL;

int CALLBACK CMergedFolder::_SearchByName(void *p1, void *p2, LPARAM lParam)
{
    SEARCH_FOR_PIDL* psfp = (SEARCH_FOR_PIDL*)p1;
    CMergedFldrItem* pmfiEnum  = (CMergedFldrItem*)p2;

    // Are they of different types?
    if (BOOLIFY(pmfiEnum->GetFolderAttrib() & SFGAO_FOLDER) ^ psfp->fFolder)
    {
        // Yes. 
        return psfp->fFolder ? 1 : -1;
    }

    // They are of the same type. Then compare by name
    int iRc = StrCmpI(psfp->pszDisplayName, pmfiEnum->GetDisplayName());
    if (iRc)
        return iRc;

    // They are the same name. But if they're not allowed to merge, then
    // they're really different.
    if (!psfp->self->_ShouldMergeNamespaces(pmfiEnum->GetNamespaceID(), psfp->iNamespace))
    {
        // Sort by namespace ID
        return psfp->iNamespace - pmfiEnum->GetNamespaceID();
    }

    // I guess they're really equal
    return 0;
}


// IPersistFolder::Initialize()
STDMETHODIMP CMergedFolder::Initialize(LPCITEMIDLIST pidl)
{
    return Pidl_Set(&_pidl, pidl) ? S_OK : E_OUTOFMEMORY;
}

// IPersistFolder2::GetCurFolder()
STDMETHODIMP CMergedFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    if (_pidl)
        return SHILClone(_pidl, ppidl);
    else
    {
        *ppidl = NULL;
        return S_FALSE;
    }
}


// IPersistPropertyBag

void CMergedFolder::_GetKeyForProperty(LPWSTR pszName, LPWSTR pszValue, LPWSTR pszBuffer, INT cchBuffer)
{
    StrCpyNW(pszBuffer, L"MergedFolder\\", cchBuffer);
    StrCatBuffW(pszBuffer, pszName, cchBuffer);
    StrCatBuffW(pszBuffer, pszValue, cchBuffer);
}

HRESULT CMergedFolder::_AddNameSpaceFromPropertyBag(IPropertyBag *ppb, LPWSTR pszName)
{
    WCHAR szKey[MAX_PATH];

    // get the path of the folder
    WCHAR szPath[MAX_PATH];
    LPITEMIDLIST pidl = NULL;

    _GetKeyForProperty(pszName, L"Path", szKey, ARRAYSIZE(szKey));
    HRESULT hr = SHPropertyBag_ReadStr(ppb, szKey, szPath, ARRAYSIZE(szPath));
    if (SUCCEEDED(hr))
    {
        // we picked a path from the property bag, so lets convert
        // that to an IDLIST so we can do something with it.

        hr = SHILCreateFromPath(szPath, &pidl, NULL);
    }
    else
    {
        // attempt to determine the CSIDL for the folder we are going
        // to show, if that works then convert it to an IDLIST
        // so that we can pass it to AddNamespace.

        _GetKeyForProperty(pszName, L"CSIDL", szKey, ARRAYSIZE(szKey));

        int csidl;
        hr = SHPropertyBag_ReadDWORD(ppb, szKey, (DWORD*)&csidl);
        if (SUCCEEDED(hr))
        {
            hr = SHGetSpecialFolderLocation(NULL, csidl, &pidl);
        }
    }

    if (SUCCEEDED(hr) && pidl)
    {
        // we succeeded in getting a location for the folder we
        // are going to add, so lets pick up the rest of the
        // information on that object.

        GUID guid;
        GUID *pguid = NULL;
        _GetKeyForProperty(pszName, L"GUID", szKey, ARRAYSIZE(szKey));
        pguid = SUCCEEDED(SHPropertyBag_ReadGUID(ppb, szKey, &guid)) ? &guid:NULL;

        DWORD dwFlags = 0;
        _GetKeyForProperty(pszName, L"Flags", szKey, ARRAYSIZE(szKey));
        SHPropertyBag_ReadDWORD(ppb, szKey, &dwFlags);

        hr = AddNameSpace(pguid, NULL, pidl, dwFlags);
    }

    ILFree(pidl);
    return hr;
}


HRESULT CMergedFolder::Load(IPropertyBag* ppb, IErrorLog *pErrLog)
{
    SHPropertyBag_ReadGUID(ppb, L"MergedFolder\\CLSID", &_clsid);            // get the folders CLSID
    SHPropertyBag_ReadDWORD(ppb, L"MergedFolder\\DropEffect", &_dwDropEffect);
    _fInShellView = SHPropertyBag_ReadBOOLDefRet(ppb, L"MergedFolder\\ShellView", FALSE);

    WCHAR sz[MAX_PATH];
    if (SUCCEEDED(SHPropertyBag_ReadStr(ppb, L"MergedFolder\\Folders", sz, ARRAYSIZE(sz))))
    {
        LPWSTR pszName = sz;
        while (pszName && *pszName)
        {
            LPWSTR pszNext = StrChrW(pszName, L',');
            if (pszNext)
            {
                *pszNext = 0;
                pszNext++;
            }
            
            _AddNameSpaceFromPropertyBag(ppb, pszName);
            pszName = pszNext;
        }
    }

    return S_OK;
}


// IShellFolder

STDMETHODIMP CMergedFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
{
    *ppenumIDList = NULL;

    HRESULT hr = E_FAIL;
    if (_hdpaNamespaces)
    {
        _FreeObjects();
        hr = CMergedFldrEnum_CreateInstance(this, grfFlags, ppenumIDList);
    }

    if (SUCCEEDED(hr) && _fInShellView)
    {
        Register(NULL, 0, 0);
    }
    return hr;
}

HRESULT CMergedFolder::_CreateWithCLSID(CLSID clsid, CMergedFolder **ppmf)
{
    *ppmf = new CMergedFolder(this, clsid);
    return *ppmf ? S_OK : E_OUTOFMEMORY;
}

BOOL CMergedFolder::_ShouldSuspend(REFGUID rguid)
{
    return FALSE;
}

// create a new CMergedFolder from the first element in pidlWrap
// this is our private init method, IPersistFolder::Initialize() is how we
// get inited at our junction point.
HRESULT CMergedFolder::_New(LPCITEMIDLIST pidlWrap, CMergedFolder **ppmf)
{
    ASSERT(ppmf);
    *ppmf = NULL;

    HRESULT hr = E_OUTOFMEMORY; // assume the worst

    // just want the first element in pidlWrap
    LPITEMIDLIST pidlFirst = ILCloneFirst(pidlWrap);
    if (pidlFirst)
    {
        if (_IsFolder(pidlFirst))
        {
            hr = _CreateWithCLSID(_clsid, ppmf);
            if (SUCCEEDED(hr) && _pidl)
            {
                hr = SHILCombine(_pidl, pidlFirst, &(*ppmf)->_pidl);
                if (FAILED(hr))
                {
                    (*ppmf)->Release();
                    *ppmf = NULL;
                }
            }
        }
        else
        {
            hr = E_NOINTERFACE;
        }
        ILFree(pidlFirst);
    }
    return hr;
}

void CMergedFolder::_AddAllOtherNamespaces(LPITEMIDLIST *ppidl)
{
    TCHAR szName[MAX_PATH];
    if (SUCCEEDED(DisplayNameOf(static_cast<CSFStorage *>(this), *ppidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName))))
    {
        CMergedFldrNamespace *pns;
        for (int n = 0; pns = _Namespace(n); n++)
        {
            if (FAILED(_GetSubPidl(*ppidl, n, NULL, NULL, NULL)))
            {
                IBindCtx *pbc;
                WIN32_FIND_DATA wfd = {0};
                wfd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
                if (SUCCEEDED(SHCreateFileSysBindCtx(&wfd, &pbc)))
                {
                    LPITEMIDLIST pidlNamespace;
                    if (SUCCEEDED(pns->Folder()->ParseDisplayName(NULL, pbc, szName, NULL, &pidlNamespace, NULL)))
                    {
                        _WrapAddIDList(pidlNamespace, n, ppidl);
                        ILFree(pidlNamespace);
                    }
                    pbc->Release();
                }
            }
        }
    }
}

STDMETHODIMP CMergedFolder::BindToObject(LPCITEMIDLIST pidlWrap, LPBC pbc, REFIID riid, void **ppv)
{
    ASSERT(IS_VALID_PIDL(pidlWrap));

    *ppv = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    LPITEMIDLIST pidlRewrappedFirst;
    if (_fDontMerge)
    {
        // this doesn't contain a wrap consisting of all namespaces but only one instead
        LPITEMIDLIST pidlWrapFirst = ILCloneFirst(pidlWrap);
        if (pidlWrapFirst)
        {
            TCHAR szName[MAX_PATH];
            hr = DisplayNameOf(reinterpret_cast<IShellFolder *>(this), pidlWrapFirst, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
            if (SUCCEEDED(hr))
            {
                // we want to round-trip the name so the non-merged pidl gets remerged
                // during a bind (so you dont get just one namespace from here on down)
                hr = ParseDisplayName(NULL, NULL, szName, NULL, &pidlRewrappedFirst, NULL);
            }
            ILFree(pidlWrapFirst);
        }
    }
    else
    {
        pidlRewrappedFirst = ILCloneFirst(pidlWrap);
        if (pidlRewrappedFirst)
        {
            hr = S_OK;
            if (_fCDBurn && _IsFolder(pidlRewrappedFirst))
            {
                // in the cdburn case we need to fake up the other namespaces in the pidl we're about to bind to.
                // this is so when we navigate into a subfolder that only exists on the CD and not the staging area,
                // if a file is later added to the staging area it'll still be merged in.
                _AddAllOtherNamespaces(&pidlRewrappedFirst);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        // just in case
        ASSERT(SUCCEEDED(_IsWrap(pidlRewrappedFirst)));

        LPCITEMIDLIST pidlNext = _ILNext(pidlWrap);

        CMergedFolder *pmf;
        hr = _New(pidlRewrappedFirst, &pmf);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlSrc;
            CMergedFldrNamespace *pns;
            for (UINT i = 0; SUCCEEDED(_GetSubPidl(pidlRewrappedFirst, i, NULL, &pidlSrc, &pns)); i++)
            {
                hr = E_OUTOFMEMORY;
                ASSERT(ILFindLastID(pidlSrc) == pidlSrc);
                LPITEMIDLIST pidlSrcFirst = ILCloneFirst(pidlSrc);
                if (pidlSrcFirst)
                {
                    IShellFolder *psf;
                    if (SUCCEEDED(pns->Folder()->BindToObject(pidlSrcFirst, pbc, IID_PPV_ARG(IShellFolder, &psf))))
                    {
                        LPITEMIDLIST pidlAbs = ILCombine(pns->GetIDList(), pidlSrcFirst);
                        if (pidlAbs)
                        {
                            CMergedFldrNamespace *pnsNew = new CMergedFldrNamespace();
                            if (pnsNew)
                            {
                                hr = pnsNew->SetNamespace(&(pns->GetGUID()), psf, pidlAbs, pns->FolderAttrib());
                                if (SUCCEEDED(hr))
                                {
                                    // propagate the drop folder down to the child.
                                    hr = pnsNew->SetDropFolder(pns->GetDropFolder());
                                    if (SUCCEEDED(hr))
                                    {
                                        hr = pmf->_SimpleAddNamespace(pnsNew);
                                        if (SUCCEEDED(hr))
                                        {
                                            // success, _SimpleAddNamespace took ownership
                                            pnsNew = NULL;
                                        }
                                    }
                                }
                                if (pnsNew)
                                    delete pnsNew;
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                            ILFree(pidlAbs);
                        }
                        psf->Release();
                    }
                    ILFree(pidlSrcFirst);
                }
                ILFree(pidlSrc);
            }

            // it's possible to go through the loop without adding any namespaces.
            // usually it's when BindToObject above fails -- this can happen if somebody
            // puts a junction point in the merged folder (like a zip file).  in that case
            // we're in trouble.

            if (ILIsEmpty(pidlNext))
                hr = pmf->QueryInterface(riid, ppv);
            else
                hr = pmf->BindToObject(pidlNext, pbc, riid, ppv);
            pmf->Release();
        }

        if (FAILED(hr) && ILIsEmpty(pidlNext))
        {
            // maybe it's an interface that we don't support ourselves (IStream?).
            // we cant merge interfaces that we don't know about so lets just
            // assume we'll pick the interface up from the default namespace in
            // the wrapped pidl.
            LPITEMIDLIST pidlSrc;
            CMergedFldrNamespace *pns;
            hr = _NamespaceForItem(pidlRewrappedFirst, ASFF_DEFNAMESPACE_BINDSTG, ASFF_DEFNAMESPACE_BINDSTG, NULL, &pidlSrc, &pns);
            if (SUCCEEDED(hr))
            {
                hr = pns->Folder()->BindToObject(pidlSrc, pbc, riid, ppv);
                ILFree(pidlSrc);
            }
        }
        ILFree(pidlRewrappedFirst);
    }

    if (SUCCEEDED(hr) && _fInShellView)
    {
        Register(NULL, 0, 0);
    }

    return hr;
}

STDMETHODIMP CMergedFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

HRESULT CMergedFolder::_CompareSingleLevelIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    IShellFolder *psf1;
    LPITEMIDLIST pidlItem1;
    CMergedFldrNamespace *pns1;
    HRESULT hr = _NamespaceForItem(pidl1, ASFF_DEFNAMESPACE_DISPLAYNAME, ASFF_DEFNAMESPACE_DISPLAYNAME, &psf1, &pidlItem1, &pns1);
    if (SUCCEEDED(hr))
    {
        IShellFolder *psf2;
        LPITEMIDLIST pidlItem2;
        CMergedFldrNamespace *pns2;
        hr = _NamespaceForItem(pidl2, ASFF_DEFNAMESPACE_DISPLAYNAME, ASFF_DEFNAMESPACE_DISPLAYNAME, &psf2, &pidlItem2, &pns2);
        if (SUCCEEDED(hr))
        {
            //  Same _Namespace? Just forward the request.
            if (psf1 == psf2)
            {
                hr = psf1->CompareIDs(lParam, pidlItem1, pidlItem2);
            }
            else if ((pns1->FolderAttrib() & ASFF_SORTDOWN) ^ (pns2->FolderAttrib() & ASFF_SORTDOWN))
            {
                // One namespace marked ASFF_SORTDOWN and one not?  The SORTDOWN one
                // comes second.
                hr = ResultFromShort((pns1->FolderAttrib() & ASFF_SORTDOWN) ? 1 : -1);
            }
            else
            {
                if (!_IsSimple(pidl1) && !_IsSimple(pidl2))
                {
                    //  Comparison heuristics:
                    //  (1) folders take precedence over nonfolders, (2) alphanum comparison
                    int iFolder1 = SHGetAttributes(psf1, pidlItem1, SFGAO_FOLDER) ? 1 : 0;
                    int iFolder2 = SHGetAttributes(psf2, pidlItem2, SFGAO_FOLDER) ? 1 : 0;
                    hr = ResultFromShort(iFolder2 - iFolder1);
                }
                else
                {
                    // if a pidl is simple, compare based on name only.
                    hr = ResultFromShort(0);
                }

                if (ResultFromShort(0) == hr)
                {
                    TCHAR szName1[MAX_PATH], szName2[MAX_PATH];
                    if (SUCCEEDED(DisplayNameOf(psf1, pidlItem1, SHGDN_INFOLDER, szName1, ARRAYSIZE(szName1))) &&
                        SUCCEEDED(DisplayNameOf(psf2, pidlItem2, SHGDN_INFOLDER, szName2, ARRAYSIZE(szName2))))
                    {
                        int iRet = StrCmp(szName1, szName2); // Comparisons are by name with items of the same type.
                        if ((iRet == 0) &&
                            SUCCEEDED(DisplayNameOf(psf1, pidlItem1, SHGDN_FORPARSING | SHGDN_INFOLDER, szName1, ARRAYSIZE(szName1))) &&
                            SUCCEEDED(DisplayNameOf(psf2, pidlItem2, SHGDN_FORPARSING | SHGDN_INFOLDER, szName2, ARRAYSIZE(szName2))))
                        {
                            iRet = lstrcmp(szName1, szName2); // minimal behavior change for xpsp1: fall back to parsing name if theres still a tie.
                            if ((iRet == 0) && !_ShouldMergeNamespaces(pns1, pns2))
                            {
                                ASSERTMSG(!_fInShellView, "we shouldn't be in this code path for the start menu");
                                // different namespaces must compare differently in the non-merged case.
                                iRet = _CompareArbitraryPidls(pidlItem1, pidlItem2);
                            }
                        }
                        hr = ResultFromShort(iRet);
                    }
                }
            }
            ILFree(pidlItem2);
        }
        ILFree(pidlItem1);
    }
    return hr;
}

STDMETHODIMP CMergedFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // just in case
    //ASSERT(!pidl1 || SUCCEEDED(_IsWrap(pidl1)));
    //ASSERT(!pidl2 || SUCCEEDED(_IsWrap(pidl2)));

    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlFirst1 = pidl1 ? ILCloneFirst(pidl1) : NULL;
    LPITEMIDLIST pidlFirst2 = pidl2 ? ILCloneFirst(pidl2) : NULL;
    if (pidlFirst1 && pidlFirst2)
    {
        hr = _CompareSingleLevelIDs(lParam, pidlFirst1, pidlFirst2);
    }
    ILFree(pidlFirst1);
    ILFree(pidlFirst2);

    // if there was an exact match then lets compare the trailing elements of the IDLIST
    // if there are some (by binding down) etc.

    if (ResultFromShort(0) == hr)
    {
        IShellFolder *psf;
        hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = ILCompareRelIDs(psf, pidl1, pidl2, lParam);
            psf->Release();
        }
    }

    if (!_IsSimple(pidl1) && !_IsSimple(pidl2))
    {
        // if we're still the same, compare the number
        // of namespaces in the pidl.
        int nCount1, nCount2;
        if (ResultFromShort(0) == hr)
        {
            nCount1 = pidl1 ? _GetSourceCount(pidl1) : 0;
            nCount2 = pidl2 ? _GetSourceCount(pidl2) : 0;
            hr = ResultFromShort(nCount1 - nCount2);
        }

        // next compare the namespaces themselves.
        // basically we're only concerned with the two-namespace case, so if both pidls have
        // elements from 0 or 2 namespaces theyre equal; we're worried about when one pidl has
        // 1 sub-pidl in namespace 0 and the other one has 1 sub-pidl in namespace 1.
        // we dont worry about 3+ namespaces and those permutations.
        if ((ResultFromShort(0) == hr) && (nCount1 == 1) && (nCount2 == 1))
        {
            GUID guid1 = GUID_NULL, guid2 = GUID_NULL;

            GetNameSpaceID(pidl1, &guid1);
            GetNameSpaceID(pidl2, &guid2);

            hr = ResultFromShort(memcmp(&guid1, &guid2, sizeof(GUID)));
        }
    }

    return hr;
}

STDMETHODIMP CMergedFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr;
    if (IsEqualIID(riid, IID_IDropTarget))
    {
        hr = CMergedFldrDropTarget_CreateInstance(this, hwnd, (IDropTarget**)ppv);
    }
    else if (IsEqualIID(riid, IID_IShellView))
    {
        IShellFolderViewCB *psfvcb;
        hr = CMergedFolderViewCB_CreateInstance(this, &psfvcb);
        if (SUCCEEDED(hr))
        {
            SFV_CREATE csfv = {0};
            csfv.cbSize = sizeof(csfv);
            csfv.pshf = SAFECAST(this, IAugmentedShellFolder2*);
            csfv.psfvcb = psfvcb;
            hr = SHCreateShellFolderView(&csfv, (IShellView **)ppv);

            psfvcb->Release();
        }
    }
    else if (_fInShellView && IsEqualIID(riid, IID_ICategoryProvider))
    {
        IShellFolder *psf;
        hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            BEGIN_CATEGORY_LIST(s_Categories)
            CATEGORY_ENTRY_SCIDMAP(SCID_WHICHFOLDER, CLSID_MergedCategorizer)
            END_CATEGORY_LIST()

            hr = CCategoryProvider_Create(&CLSID_MergedCategorizer, &SCID_WHICHFOLDER, NULL, s_Categories, psf, riid, ppv);
            psf->Release();
        }
    }
    else if (_fInShellView && IsEqualIID(riid, IID_IContextMenu))
    {
        // this is pretty much what filefldr does to create its background
        // context menu.  we don't want to let one of our namespaces take over for the background
        // context menu because then the context menu will think it's in an unmerged namespace.

        // for example the new menu would then work with the storage of the child namespace
        // and couldn't select the new item after its done since it has an unmerged pidl
        // and the view has a merged one.
        IShellFolder *psfToPass;
        hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfToPass));
        if (SUCCEEDED(hr))
        {
            HKEY hkNoFiles = NULL;
            RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("Directory\\Background"), 0, KEY_READ, &hkNoFiles);
            // initialize with our merged pidl.
            IContextMenuCB *pcmcb = new CDefBackgroundMenuCB(_pidl);
            if (pcmcb) 
            {
                hr = CDefFolderMenu_Create2Ex(_pidl, hwnd, 0, NULL, psfToPass, pcmcb, 
                                              1, &hkNoFiles, (IContextMenu **)ppv);
                pcmcb->Release();
            }
            if (hkNoFiles)                          // CDefFolderMenu_Create can handle NULL ok
                RegCloseKey(hkNoFiles);
            psfToPass->Release();
        }
    }
    else
    {
        CMergedFldrNamespace *pns;
        hr = _FindNamespace(ASFF_DEFNAMESPACE_VIEWOBJ, ASFF_DEFNAMESPACE_VIEWOBJ, NULL, &pns);
        if (SUCCEEDED(hr))
        {
            hr = pns->Folder()->CreateViewObject(hwnd, riid, ppv);
        }
    }
    return hr;
}

STDMETHODIMP CMergedFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut)
{
    // attribs of the namespace root.
    // scope this to the sub-namespaces?
    if (!cidl || !apidl)
    {
        *rgfInOut &= SFGAO_FOLDER | SFGAO_FILESYSTEM | 
                     SFGAO_LINK | SFGAO_DROPTARGET |
                     SFGAO_CANRENAME | SFGAO_CANDELETE |
                     SFGAO_CANLINK | SFGAO_CANCOPY | 
                     SFGAO_CANMOVE | SFGAO_HASSUBFOLDER;
        return S_OK;
    }

    HRESULT hr = S_OK;
    for (UINT i = 0; SUCCEEDED(hr) && (i < cidl); i++)
    {
        ULONG ulAttribs = *rgfInOut;

        IShellFolder* psf;
        LPITEMIDLIST pidlItem;
        CMergedFldrNamespace *pns;
        hr = _NamespaceForItem(apidl[0], ASFF_DEFNAMESPACE_ATTRIB, ASFF_DEFNAMESPACE_ATTRIB, &psf, &pidlItem, &pns);
        if (SUCCEEDED(hr))
        {
            ulAttribs |= SFGAO_FOLDER;
            hr = psf->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlItem, &ulAttribs);
            if (SUCCEEDED(hr))
            {
                ulAttribs = pns->FixItemAttributes(ulAttribs);
                if (_fInShellView || !(*rgfInOut & SFGAO_FOLDER))
                {
                    ulAttribs &= ~SFGAO_CANLINK;  // avoid people creating links to our pidls
                }

                if (*rgfInOut & (SFGAO_CANCOPY | SFGAO_CANMOVE | SFGAO_CANLINK))
            	{
                    // allow per-type guys to do what they want.
                    IQueryAssociations *pqa;
                    DWORD dwDefEffect = DROPEFFECT_NONE;
                    if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST*)&pidlItem, IID_X_PPV_ARG(IQueryAssociations, NULL, &pqa))))
                    {
                        DWORD cb = sizeof(dwDefEffect);
                        pqa->GetData(0, ASSOCDATA_VALUE, L"DefaultDropEffect", &dwDefEffect, &cb);
                        pqa->Release();
                    }
                    ulAttribs |= dwDefEffect & (SFGAO_CANCOPY | SFGAO_CANMOVE | SFGAO_CANLINK);
                }
            }
            ILFree(pidlItem);
        }

        // keep only the attributes common to all pidls.
        *rgfInOut &= ulAttribs;
    }
    return hr;
}

STDMETHODIMP CMergedFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, REFIID riid, UINT *prgf, void **ppv)
{
    *ppv = NULL;

    HRESULT hr = E_NOTIMPL;
    if (IsEqualGUID(riid, IID_IContextMenu))
    {
        hr = _GetContextMenu(hwnd, cidl, apidl, riid, ppv);
    }
    else if (IsEqualGUID(riid, IID_IDropTarget) && _IsFolder(apidl[0]))
    {
        IShellFolder *psf;
        hr = BindToObject(apidl[0], NULL, IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->CreateViewObject(hwnd, riid, ppv);
            psf->Release();
        }
    }
    else if ((IsEqualIID(riid, IID_IExtractImage) || 
              IsEqualIID(riid, IID_IExtractLogo)) && _IsFolder(apidl[0]))
    {
        IShellFolder *psfThis;
        hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfThis));
        if (SUCCEEDED(hr))
        {
            hr = CFolderExtractImage_Create(psfThis, apidl[0], riid, ppv);
            psfThis->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IDataObject) && _pidl)
    {
        hr = SHCreateFileDataObject(_pidl, cidl, apidl, NULL, (IDataObject **)ppv);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        // Forward to default _Namespace for UI object
        LPITEMIDLIST *apidlItems = new LPITEMIDLIST[cidl];
        if (apidlItems)
        {
            hr = E_FAIL;       // assume failure

            UINT cidlItems = 0;
            IShellFolder *psf, *psfKeep; // not ref counted
            LPITEMIDLIST pidlItem;
            for (UINT i = 0; i < cidl; i++)
            {
                if (SUCCEEDED(_NamespaceForItem(apidl[i], ASFF_DEFNAMESPACE_UIOBJ, ASFF_DEFNAMESPACE_UIOBJ, &psf, &pidlItem, NULL)))
                {
                    // only keep the ones that match the default namespace for UI object
                    // if they dont match, too bad.
                    apidlItems[cidlItems++] = pidlItem;
                    psfKeep = psf;
                }
            }

            if (cidlItems)
            {
                hr = psfKeep->GetUIObjectOf(hwnd, cidlItems, (LPCITEMIDLIST *)apidlItems, riid, NULL, ppv);
            }
            for (UINT j = 0; j < cidlItems; j++)
            {
                ILFree(apidlItems[j]);
            }
            delete [] apidlItems;
        }
    }
    return hr;
}


// in:
//      pidl optional, NULL means get default
// out:
//      *ppidl if pidl is != NULL

HRESULT CMergedFolder::_GetFolder2(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlInner, IShellFolder2 **ppsf)
{
    if (ppidlInner)
        *ppidlInner = NULL;

    HRESULT hr;
    if (NULL == pidl)
    {
        CMergedFldrNamespace *pns;
        hr = _FindNamespace(ASFF_DEFNAMESPACE_DISPLAYNAME, ASFF_DEFNAMESPACE_DISPLAYNAME, NULL, &pns);
        if (FAILED(hr))
        {
            pns = _Namespace(0);
            hr = pns ? S_OK : E_FAIL;
        }

        if (SUCCEEDED(hr))
            hr = pns->Folder()->QueryInterface(IID_PPV_ARG(IShellFolder2, ppsf));
    }
    else
    {
        IShellFolder* psf;
        hr = _NamespaceForItem(pidl, ASFF_DEFNAMESPACE_DISPLAYNAME, ASFF_DEFNAMESPACE_DISPLAYNAME, &psf, ppidlInner, NULL);
        if (SUCCEEDED(hr))
        {
            hr = psf->QueryInterface(IID_PPV_ARG(IShellFolder2, ppsf));
            if (FAILED(hr) && ppidlInner)
            {
                ILFree(*ppidlInner);
            }
        }
    }
    return hr;
}


// extended column information, these are appended after the set from the merged folder.

#define COLID_WHICHFOLDER  0x00    // column index for the merged folder location

static struct
{
    const SHCOLUMNID *pscid;
    UINT iTitle;
    UINT cchCol;
    UINT iFmt;
}
_columns[] =
{
    {&SCID_WHICHFOLDER, IDS_WHICHFOLDER_COL, 20, LVCFMT_LEFT},
};


// column handler helpers

BOOL CMergedFolder::_IsOurColumn(UINT iCol)
{
    return ((_iColumnOffset != -1) && ((iCol >= _iColumnOffset) && ((iCol - _iColumnOffset) < ARRAYSIZE(_columns))));
}

HRESULT CMergedFolder::_GetWhichFolderColumn(LPCITEMIDLIST pidl, LPWSTR pszBuffer, INT cchBuffer)
{
    CMergedFldrNamespace *pns;
    HRESULT hr = _NamespaceForItem(pidl, ASFF_DEFNAMESPACE_ATTRIB, ASFF_DEFNAMESPACE_ATTRIB, NULL, NULL, &pns);
    if (SUCCEEDED(hr))
    {
        hr = pns->GetLocation(pszBuffer, cchBuffer);
    }
    return hr;
}

STDMETHODIMP CMergedFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails)
{
    // do we have a column offset, or is this within the range of our the ISFs columns
    HRESULT hr = E_FAIL;
    if (!_IsOurColumn(iColumn))
    {
        IShellFolder2 *psf2;
        LPITEMIDLIST pidlItem;

        // get the column value from the folder.
        hr = _GetFolder2(pidl, &pidlItem, &psf2);
        if (SUCCEEDED(hr))
        {
            hr = psf2->GetDetailsOf(pidlItem, iColumn, pDetails);
            psf2->Release();
            ILFree(pidlItem);
        }

        // we failed and we don't know the column offset to handle
        if (FAILED(hr) && (_iColumnOffset == -1))
            _iColumnOffset = iColumn;
    }
    
    if (FAILED(hr) && _IsOurColumn(iColumn))
    {
        iColumn -= _iColumnOffset;

        pDetails->str.uType = STRRET_CSTR;          // we are returning strings
        pDetails->str.cStr[0] = 0;

        WCHAR szTemp[MAX_PATH];
        if (!pidl)
        {
            pDetails->fmt = _columns[iColumn].iFmt;
            pDetails->cxChar = _columns[iColumn].cchCol;
            LoadString(HINST_THISDLL, _columns[iColumn].iTitle, szTemp, ARRAYSIZE(szTemp));
            hr = StringToStrRet(szTemp, &(pDetails->str));
        }
        else if (SUCCEEDED(_IsWrap(pidl)))
        {
            if (iColumn == COLID_WHICHFOLDER)
            {
                hr = _GetWhichFolderColumn(pidl, szTemp, ARRAYSIZE(szTemp));
                if (SUCCEEDED(hr))
                    hr = StringToStrRet(szTemp, &(pDetails->str));
            }
        }
    }
    return hr;
}

STDMETHODIMP CMergedFolder::GetDefaultColumnState(UINT iColumn, DWORD *pbState)
{ 
    IShellFolder2 *psf2;
    HRESULT hr = _GetFolder2(NULL, NULL, &psf2);
    if (SUCCEEDED(hr))
    {
        hr = psf2->GetDefaultColumnState(iColumn, pbState);
        psf2->Release();
    }
    return hr;
}

STDMETHODIMP CMergedFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{ 
    HRESULT hr;

    if (IsEqualSCID(*pscid, SCID_WHICHFOLDER))
    {
        WCHAR szTemp[MAX_PATH];
        hr = _GetWhichFolderColumn(pidl, szTemp, ARRAYSIZE(szTemp));
        if (SUCCEEDED(hr))
            hr = InitVariantFromStr(pv, szTemp);
    }
    else
    {
        IShellFolder2 *psf2;
        LPITEMIDLIST pidlItem;
        hr = _GetFolder2(pidl, &pidlItem, &psf2);
        if (SUCCEEDED(hr))
        {
            hr = psf2->GetDetailsEx(pidlItem, pscid, pv);
            psf2->Release();
            ILFree(pidlItem);
        }
    }
    return hr;
}

STDMETHODIMP CMergedFolder::MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid)
{ 
    HRESULT hr = S_OK;

    // one of our columns?

    if (_IsOurColumn(iCol))
    {
        iCol -= _iColumnOffset;
        *pscid = *_columns[iCol].pscid;
    }
    else
    {
        IShellFolder2 *psf2;
        hr = _GetFolder2(NULL, NULL, &psf2);
        if (SUCCEEDED(hr))
        {
            hr = psf2->MapColumnToSCID(iCol, pscid);
            psf2->Release();
        }
    }
    return hr;
}


//  Forward to default _Namespace for display name
STDMETHODIMP CMergedFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD grfFlags, STRRET *psr)
{
    IShellFolder* psf;
    LPITEMIDLIST pidlItem;
    HRESULT hr = _NamespaceForItem(pidl, ASFF_DEFNAMESPACE_DISPLAYNAME, ASFF_DEFNAMESPACE_DISPLAYNAME, &psf, &pidlItem, NULL);
    if (SUCCEEDED(hr))
    {
        ASSERT(ILFindLastID(pidlItem) == pidlItem);
        hr = psf->GetDisplayNameOf(pidlItem, grfFlags, psr);
        if (SUCCEEDED(hr))
        {
            hr = _FixStrRetOffset(pidlItem, psr);
#ifdef DEBUG
            // If the trace flags are set, and this is not comming from an internal query,
            // Then append the location where this name came from
            if (!((SHGDN_FORPARSING | SHGDN_FOREDITING) & grfFlags) &&
                (g_qwTraceFlags & TF_AUGM))
            {
                LPWSTR pwszOldName;
                hr = StrRetToStrW(psr, pidlItem, &pwszOldName);
                if (SUCCEEDED(hr))
                {
                    UINT cch = lstrlenW(pwszOldName) + 50;
                    psr->uType = STRRET_WSTR;
                    psr->pOleStr = (LPWSTR)SHAlloc(cch * sizeof(WCHAR));
                    if (psr->pOleStr)
                    {
                        UINT cchAdded = wnsprintfW(psr->pOleStr, cch, L"%s ", pwszOldName);
                        cch -= cchAdded;
                        LPWSTR pwsz = psr->pOleStr + cchAdded;

                        ULONG nSrc = _GetSourceCount(pidl);
                        UINT uSrc;
                        // Cut off after 10 to avoid buffer overflow
                        for (uSrc = 0; uSrc < nSrc && uSrc < 10; uSrc++)
                        {
                            UINT uID;
                            if (SUCCEEDED(_GetSubPidl(pidl, uSrc, &uID, NULL, NULL)))
                            {
                                cchAdded = wnsprintfW(pwsz, cch, L"%c%d", uSrc ? '+' : '(', uID);
                                cch -= cchAdded;
                                pwsz += cchAdded;
                            }
                        }
                        pwsz += wnsprintfW(pwsz, cch, L")");
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    SHFree(pwszOldName);
                }
            }
#endif
        }
        ILFree(pidlItem);
    }
    else
    {
        if (IsSelf(1, &pidl) && 
            ((grfFlags & (SHGDN_FORADDRESSBAR | SHGDN_INFOLDER | SHGDN_FORPARSING)) == SHGDN_FORPARSING))
        {
            IShellFolder2 *psf2;
            hr = _GetFolder2(NULL, NULL, &psf2);
            if (SUCCEEDED(hr))
            {
                hr = psf2->GetDisplayNameOf(NULL, grfFlags, psr);
                psf2->Release();
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
}

// CFSFolder helper
HRESULT _NextSegment(LPCWSTR *ppszIn, LPTSTR pszSegment, UINT cchSegment, BOOL bValidate);

void CMergedFolder::_SetSimple(LPITEMIDLIST *ppidl)
{
    PAUGM_IDWRAP pWrap = (PAUGM_IDWRAP)*ppidl;
    if ((pWrap->cb >= sizeof(AUGM_IDWRAP)) &&
        (pWrap->ulTag == AUGM_WRAPTAG) &&
        (pWrap->ulVersion == AUGM_WRAPVERSION_2_0))
    {
        pWrap->dwFlags |= AUGMF_ISSIMPLE;
    }
}

BOOL CMergedFolder::_IsSimple(LPCITEMIDLIST pidl)
{
    BOOL fSimple = FALSE;
    PAUGM_IDWRAP pWrap = (PAUGM_IDWRAP)pidl;
    if ((pWrap->cb >= sizeof(AUGM_IDWRAP)) &&
        (pWrap->ulTag == AUGM_WRAPTAG) &&
        (pWrap->ulVersion == AUGM_WRAPVERSION_2_0))
    {
        fSimple = (pWrap->dwFlags & AUGMF_ISSIMPLE);
    }
    return fSimple;
}

STDMETHODIMP CMergedFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pwszName, 
                                             ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttrib)
{
    *ppidl = NULL;

    TCHAR szName[MAX_PATH];
    // ISSUE: this relies on the fact that the path that's getting parsed is FS (with backslashes).
    // alternatively this could be rearchitected so that the namespaces would be delegate folders
    // and we could do the merge when we handle their pidl allocation.
    HRESULT hr = _NextSegment((LPCWSTR *) &pwszName, szName, ARRAYSIZE(szName), TRUE);
    if (SUCCEEDED(hr))
    {
        // let all name spaces try to parse, append them into the pidl as these are found
        CMergedFldrNamespace *pns;
        HRESULT hrParse = S_OK;
        for (int i = 0; SUCCEEDED(hr) && (pns = _Namespace(i)); i++)
        {
            LPITEMIDLIST pidl;
            hrParse = pns->Folder()->ParseDisplayName(hwnd, pbc, szName, NULL, &pidl, NULL);
            if (SUCCEEDED(hrParse))
            {
                // let each name space parse, accumulate results
                // into *ppidl across multiple folders
                hr = _WrapAddIDList(pidl, i, ppidl);

                ILFree(pidl);
            }
        }

        if (!*ppidl)
        {
            if (SUCCEEDED(hr))
            {
                hr = hrParse;
            }
            ASSERT(FAILED(hr));
        }
        else
        {
            if (S_OK == SHIsFileSysBindCtx(pbc, NULL))
            {
                _SetSimple(ppidl);
            }
            ASSERT(ILFindLastID(*ppidl) == *ppidl);
        }

        if (SUCCEEDED(hr) && pwszName)
        {
            IShellFolder *psf;
            hr = BindToObject(*ppidl, pbc, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlNext;
                hr = psf->ParseDisplayName(hwnd, pbc, pwszName, NULL, &pidlNext, pdwAttrib);
                if (SUCCEEDED(hr))
                {
                    // shilappend frees pidlNext
                    hr = SHILAppend(pidlNext, ppidl);
                }
                psf->Release();
            }

            if (FAILED(hr))
            {
                Pidl_Set(ppidl, NULL);
            }
        }
        
        if (SUCCEEDED(hr) && pdwAttrib && *pdwAttrib)
        {
            GetAttributesOf(1, (LPCITEMIDLIST *)ppidl, pdwAttrib);
        }
    }
    ASSERT(SUCCEEDED(hr) ? (*ppidl != NULL) : (*ppidl == NULL));
    return hr;
}

STDMETHODIMP CMergedFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidlWrap, 
                                      LPCOLESTR pwszName, DWORD uFlags, LPITEMIDLIST *ppidlOut)
{
    if (ppidlOut)
        *ppidlOut = NULL;

    HRESULT hr = E_FAIL;
    IShellFolder* psf; // not ref counted
    LPITEMIDLIST pidlItem;

    if (!_fInShellView)
    {
        hr = _NamespaceForItem(pidlWrap, ASFF_COMMON, 0, &psf, &pidlItem, NULL, TRUE);
        if (FAILED(hr))
        {
            hr = _NamespaceForItem(pidlWrap, ASFF_COMMON, ASFF_COMMON, &psf, &pidlItem, NULL, TRUE);
            if (SUCCEEDED(hr))
            {
                hr = AffectAllUsers(hwnd) ? S_OK : E_FAIL;
                if (FAILED(hr))
                {
                    ILFree(pidlItem);
                }
            }
        }
    }
    else
    {
        hr = _NamespaceForItem(pidlWrap, ASFF_DEFNAMESPACE_DISPLAYNAME, ASFF_DEFNAMESPACE_DISPLAYNAME, &psf, &pidlItem, NULL);
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(ILFindLastID(pidlItem) == pidlItem);
        hr = psf->SetNameOf(hwnd, pidlItem, pwszName, uFlags, NULL);
        ILFree(pidlItem);
    }

    if (SUCCEEDED(hr) && ppidlOut)
    {   
        WCHAR szName[MAX_PATH];
        hr = DisplayNameOf(SAFECAST(this, IAugmentedShellFolder2*), pidlWrap, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
        if (SUCCEEDED(hr))
            hr = ParseDisplayName(NULL, NULL, szName, NULL, ppidlOut, NULL);
    }
    return hr;
}


// IAugmentedShellFolder::AddNameSpace
// Adds a source _Namespace to the Merge shell folder object
STDMETHODIMP CMergedFolder::AddNameSpace(const GUID *pguidObject, IShellFolder *psf, LPCITEMIDLIST pidl, DWORD dwFlags)
{
    //  Check for duplicate via full display name
    CMergedFldrNamespace *pns;
    for (int i = 0; pns = _Namespace(i); i++)
    {
        if (pidl && ILIsEqual(pns->GetIDList(), pidl))
        {
            // If Found, then reassign attributes and return
            return pns->SetNamespace(pguidObject, psf, pidl, dwFlags);
        }
    }

    HRESULT hr;
    pns = new CMergedFldrNamespace();
    if (pns) 
    {
        hr = pns->SetNamespace(pguidObject, psf, pidl, dwFlags);
        if (SUCCEEDED(hr))
        {
            hr = _SimpleAddNamespace(pns);
            if (SUCCEEDED(hr))
            {
                pns = NULL; // success, don't free below
            }
        }
        if (pns)
            delete pns;
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

HRESULT CMergedFolder::_SimpleAddNamespace(CMergedFldrNamespace *pns)
{
    if (NULL == _hdpaNamespaces)
        _hdpaNamespaces = DPA_Create(2);

    HRESULT hr = E_OUTOFMEMORY;
    if (_hdpaNamespaces && (DPA_AppendPtr(_hdpaNamespaces, pns) != -1))
    {
        // If there is any conditional merging going on, then remember it
        if (pns->FolderAttrib() & ASFF_MERGESAMEGUID)
        {
            _fPartialMerge = TRUE;
        }
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CMergedFolder::GetNameSpaceID(LPCITEMIDLIST pidl, GUID * pguidOut)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(IS_VALID_PIDL(pidl));
    ASSERT(IS_VALID_WRITE_PTR(pguidOut, GUID));

    if (pidl && pguidOut)
    {
        CMergedFldrNamespace *pns;
        hr = _GetSubPidl(pidl, 0, NULL, NULL, &pns);
        if (SUCCEEDED(hr))
        {
            *pguidOut = pns->GetGUID();
        }
    }

    return hr;
}


//  Retrieves data for the _Namespace identified by dwID.
STDMETHODIMP CMergedFolder::QueryNameSpace(ULONG iIndex, GUID *pguidOut, IShellFolder **ppsf)
{
    CMergedFldrNamespace *pns;
    HRESULT hr = _Namespace(iIndex, &pns);
    if (SUCCEEDED(hr))
    {
        if (pguidOut)  
            *pguidOut = pns->GetGUID();

        if (ppsf)
        {      
            *ppsf = pns->Folder();
            if (*ppsf)
                (*ppsf)->AddRef();
        }
    }
    return hr;
}

#define ASFQNSI_SUPPORTED (ASFQNSI_FLAGS | ASFQNSI_FOLDER | ASFQNSI_GUID | ASFQNSI_PIDL)

STDMETHODIMP CMergedFolder::QueryNameSpace2(ULONG iIndex, QUERYNAMESPACEINFO *pqnsi)
{
    if (pqnsi->cbSize != sizeof(QUERYNAMESPACEINFO) ||
        (pqnsi->dwMask & ~ASFQNSI_SUPPORTED))
    {
        return E_INVALIDARG;
    }


    CMergedFldrNamespace *pns;
    HRESULT hr = _Namespace(iIndex, &pns);
    if (SUCCEEDED(hr))
    {
        // Do PIDL first since it's the only one that can fail
        // so we don't have to do cleanup
        if (pqnsi->dwMask & ASFQNSI_PIDL)
        {
            hr = SHILClone(pns->GetIDList(), &pqnsi->pidl);
            if (FAILED(hr))
                return hr;
        }

        if (pqnsi->dwMask & ASFQNSI_FLAGS)
            pqnsi->dwFlags = pns->FolderAttrib();

        if (pqnsi->dwMask & ASFQNSI_FOLDER)
        {
            pqnsi->psf = pns->Folder();
            if (pqnsi->psf)
                pqnsi->psf->AddRef();
        }

        if (pqnsi->dwMask & ASFQNSI_GUID)
            pqnsi->guidObject = pns->GetGUID();
    }
    return hr;
}



STDMETHODIMP CMergedFolder::EnumNameSpace(DWORD uNameSpace, DWORD *pdwID)
{
    if (uNameSpace == (DWORD)-1)
    {
        return ResultFromShort(_NamespaceCount());
    }

    if (uNameSpace < (UINT)_NamespaceCount())
    {
        // Our namespace IDs are just ordinals
        *pdwID = uNameSpace;
        return S_OK;
    }

    return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
}

// IAugmentedShellFolder2 methods
STDMETHODIMP CMergedFolder::UnWrapIDList(LPCITEMIDLIST pidlWrap, LONG cPidls, 
                                         IShellFolder** apsf, LPITEMIDLIST* apidlFolder, 
                                         LPITEMIDLIST* apidlItems, LONG* pcFetched)
{
    if (cPidls <= 0)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    
    //  Enumerate pidls in wrap
    LPITEMIDLIST pidlItem;
    CMergedFldrNamespace *pns;
    LONG cFetched;
    for (cFetched = 0; SUCCEEDED(hr) && (cFetched < cPidls) && SUCCEEDED(_GetSubPidl(pidlWrap, cFetched, NULL, &pidlItem, &pns)); cFetched++)
    {
        if (apsf)
        {
            apsf[cFetched] = pns->Folder();
            if (apsf[cFetched])
                apsf[cFetched]->AddRef();
        }
        if (apidlFolder)
        {
            hr = SHILClone(pns->GetIDList(), &apidlFolder[cFetched]);
        }
        if (apidlItems)
        {
            apidlItems[cFetched] = NULL;
            if (SUCCEEDED(hr))
            {
                hr = SHILClone(pidlItem, &apidlItems[cFetched]);
            }
        }
        ILFree(pidlItem);
    }

    if (SUCCEEDED(hr))
    {
        if (pcFetched)
        {
            *pcFetched = cFetched;
        }
    
        hr = (cFetched == cPidls) ? S_OK : S_FALSE;
    }
    else
    {
        // clean up items we've already allocated; since the caller won't free if we
        // return failure
        for (LONG i = 0; i < cFetched; i++)
        {
            if (apsf)
                ATOMICRELEASE(apsf[i]);
            if (apidlFolder)
                ILFree(apidlFolder[i]);
            if (apidlItems)
                ILFree(apidlItems[i]);
        }
    }

    return hr;
}


STDMETHODIMP CMergedFolder::SetOwner(IUnknown* punkOwner)
{
    DPA_EnumCallback(_hdpaNamespaces, _SetOwnerProc, punkOwner);
    return S_OK;
}


int CMergedFolder::_SetOwnerProc(void *pv, void *pvParam)
{
    CMergedFldrNamespace *pns = (CMergedFldrNamespace*) pv;
    return pns->SetOwner((IUnknown*)pvParam);
}


//  ITranslateShellChangeNotify methods

// old translate style only
LPITEMIDLIST CMergedFolder::_ILCombineBase(LPCITEMIDLIST pidlContainingBase, LPCITEMIDLIST pidlRel)
{
    // This routine differs from ILCombine in that it takes the First pidl's base, and
    // cats on the last id of the second pidl. We need this so Wrapped pidls
    // end up with the same base, and we get a valid full pidl.
    LPITEMIDLIST pidlRet = NULL;
    LPITEMIDLIST pidlBase = ILClone(pidlContainingBase);
    if (pidlBase)
    {
        ILRemoveLastID(pidlBase);
        pidlRet = ILCombine(pidlBase, pidlRel);
        ILFree(pidlBase);
    }

    return pidlRet;
}

BOOL CMergedFolder::_IsFolderEvent(LONG lEvent)
{
    return lEvent == SHCNE_MKDIR || lEvent == SHCNE_RMDIR || lEvent == SHCNE_RENAMEFOLDER;
}

BOOL GetRealPidlFromSimple(LPCITEMIDLIST pidlSimple, LPITEMIDLIST* ppidlReal)
{
    // Similar to SHGetRealIDL in Function, but SHGetRealIDL does SHGDN_FORPARSING | INFOLDER.
    // I need the parsing name. I can't rev SHGetRealIDL very easily, so here's this one!
    TCHAR szFullName[MAX_PATH];
    if (SUCCEEDED(SHGetNameAndFlags(pidlSimple, SHGDN_FORPARSING, szFullName, SIZECHARS(szFullName), NULL)))
    {
        *ppidlReal = ILCreateFromPath(szFullName);
    }

    if (*ppidlReal == NULL) // Unable to create? Then use the simple pidl. This is because it does not exist any more
    {                       // For say, a Delete Notify
        *ppidlReal = ILClone(pidlSimple);
    }

    return *ppidlReal != NULL;
}

// the new way we have of translating ids is better than the old way since it handles
// multi-level translation.
// the problem is that the old way is used extensively by the start menu, so the
// start menu will need to be rewritten to use the new way.  when that happens,
// then the old method can be ripped out.
STDMETHODIMP CMergedFolder::TranslateIDs(
    LONG *plEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, 
    LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
    LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, 
    LPITEMIDLIST *ppidlOut2Event2)
{
    if (_fInShellView)
    {
        return _NewTranslateIDs(plEvent, pidl1, pidl2, ppidlOut1, ppidlOut2, plEvent2, ppidlOut1Event2, ppidlOut2Event2);
    }
    else
    {
        return _OldTranslateIDs(plEvent, pidl1, pidl2, ppidlOut1, ppidlOut2, plEvent2, ppidlOut1Event2, ppidlOut2Event2);
    }
}


// old version.
HRESULT CMergedFolder::_OldTranslateIDs(
    LONG *plEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, 
    LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
    LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, 
    LPITEMIDLIST *ppidlOut2Event2)
{
    HRESULT hr = E_FAIL;

    if (!plEvent)
        return E_FAIL;

    switch (*plEvent)
    {
        case SHCNE_EXTENDED_EVENT:
        case SHCNE_ASSOCCHANGED:
        case SHCNE_UPDATEIMAGE:
            return S_OK;

        case SHCNE_UPDATEDIR:
            _FreeObjects();
            return S_OK;
    }

    ASSERT(ppidlOut1);
    ASSERT(ppidlOut2);
    LONG lEvent = *plEvent;

    *plEvent2 = (LONG)-1;
    *ppidlOut1Event2 = NULL;
    *ppidlOut2Event2 = NULL;
    
    *ppidlOut1 = (LPITEMIDLIST)pidl1;
    *ppidlOut2 = (LPITEMIDLIST)pidl2;

    // If they are already wrapped, don't wrap twice.
    if (SUCCEEDED(_IsWrap(ILFindLastID(pidl1))) ||
        SUCCEEDED(_IsWrap(ILFindLastID(pidl2))))
    {
        // We don't want to wrap twice.
        return E_FAIL;
    }

    if (!_hdpaNamespaces)
        return E_FAIL;

    if (!_hdpaObjects)
        return E_FAIL;

    CMergedFldrItem* pmfi;

    int iIndex;
    int iShellFolder1 = -1;
    int iShellFolder2 = -1;
    IShellFolder* psf1 = NULL;
    IShellFolder* psf2 = NULL;
    LPITEMIDLIST pidlReal1 = NULL;
    LPITEMIDLIST pidlReal2 = NULL;
    LPITEMIDLIST pidlRealRel1 = NULL;
    LPITEMIDLIST pidlRealRel2 = NULL;
    CMergedFldrNamespace * pns1 = NULL;
    CMergedFldrNamespace * pns2 = NULL;

    BOOL fFolder = _IsFolderEvent(*plEvent);

    // Get the information about these Simple pidls: Are they our Children? If so, what _Namespace?
    BOOL fChild1 = _IsChildIDInternal(pidl1, TRUE, &iShellFolder1);
    BOOL fChild2 = _IsChildIDInternal(pidl2, TRUE, &iShellFolder2);

    // Is either a child?
    if (!(fChild1 || fChild2))
        return hr;

    // Ok, pidl1 is a child, can we get the Real pidl from the simple one?
    if (pidl1 && !GetRealPidlFromSimple(pidl1, &pidlReal1))
        goto Cleanup;

    // Ok, pidl2 is a child, can we get the Real pidl from the simple one?
    if (pidl2 && !GetRealPidlFromSimple(pidl2, &pidlReal2))
        goto Cleanup;

    // These are for code clarity later on. We deal with Relative pidls from here until the very end,
    // when we combine the base of the in pidls with the outgoing wrapped pidls.
    if (pidlReal1)
        pidlRealRel1 = ILFindLastID(pidlReal1);

    if (pidlReal2)
        pidlRealRel2 = ILFindLastID(pidlReal2);

    // Is Pidl1 in our _Namespaces?
    if (iShellFolder1 != -1)
    {
        // Yes, lets get the non-refcounted shell folder that know's about this pidl.
        pns1 = _Namespace(iShellFolder1);
        psf1 = pns1->Folder();  // Non ref counted.
    }

    // Is Pidl2 in our _Namespaces?
    if (iShellFolder2 != -1)
    {
        // Yes, lets get the non-refcounted shell folder that know's about this pidl.
        pns2 = _Namespace(iShellFolder2);
        psf2 = pns2->Folder();  // Non ref counted.
    }

    hr = S_OK;

    switch(*plEvent)
    {
    case SHCNE_UPDATEITEM:
    case 0: // Just look up the pidls and return.
        {
            DWORD rgfAttrib = SFGAO_FOLDER;
            if (iShellFolder1 != -1)
            {
                psf1->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlRealRel1, &rgfAttrib);
                if (S_OK == _SearchForPidl(iShellFolder1, pns1, pidlRealRel1, BOOLIFY(rgfAttrib & SFGAO_FOLDER), &iIndex, &pmfi))
                {
                    *ppidlOut1 = _ILCombineBase(pidlReal1, pmfi->GetIDList());
                    if (!*ppidlOut1)
                        hr = E_OUTOFMEMORY;
                }
            }

            rgfAttrib = SFGAO_FOLDER;
            if (iShellFolder2 != -1 && SUCCEEDED(hr))
            {
                psf2->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlRealRel2, &rgfAttrib);
                if (S_OK == _SearchForPidl(iShellFolder2, pns2, pidlRealRel2, BOOLIFY(rgfAttrib & SFGAO_FOLDER), &iIndex, &pmfi))
                {
                    *ppidlOut2 = _ILCombineBase(pidlReal2, pmfi->GetIDList());
                    if (!*ppidlOut2)
                        hr = E_OUTOFMEMORY;
                }
            }
        }
        break;

    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        {
            TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s", fFolder?  TEXT("SHCNE_MKDIR") : TEXT("SHCNE_CREATE")); 

            // Is there a thing of this name already?
            if (S_OK == _SearchForPidl(iShellFolder1, pns1, pidlRealRel1, fFolder, &iIndex, &pmfi))
            {
                TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s needs to be merged. Converting to Rename", pmfi->GetDisplayName());

                // Yes; Then we need to merge this new pidl into the wrapped pidl, and change this
                // to a rename, passing the Old wrapped pidl as the first arg, and the new wrapped pidl
                // as the second arg. I have to be careful about the freeing:
                // Free *ppidlOut1
                // Clone pmfi->pidlWrap -> *ppidlOut1.
                // Add pidl1 to pmfi->_pidlWrap.
                // Clone new pmfi->_pidlWrap -> *ppidlOut2.  ASSERT(*ppidlOut2 == NULL)

                *ppidlOut1 = _ILCombineBase(pidl1, pmfi->GetIDList());
                if (*ppidlOut1)
                {
                    _WrapAddIDList(pidlRealRel1, iShellFolder1, &pmfi->_pidlWrap); 
                    *ppidlOut2 = _ILCombineBase(pidl1, pmfi->GetIDList());

                    if (!*ppidlOut2)
                        TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Failure. Was unable to create new pidl2");

                    *plEvent = fFolder? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;
                }
                else
                {
                    TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Failure. Was unable to create new pidl1");
                }
            }
            else
            {
                CMergedFldrItem* pmfiEnum = new CMergedFldrItem;
                if (pmfiEnum)
                {
                    LPITEMIDLIST pidlWrap;
                    if (SUCCEEDED(_CreateWrap(pidlRealRel1, (UINT)iShellFolder1, &pidlWrap)) &&
                        pmfiEnum->Init(SAFECAST(this, IAugmentedShellFolder2*), pidlWrap, iShellFolder1))
                    {
                        SEARCH_FOR_PIDL sfp;
                        sfp.pszDisplayName = pmfiEnum->GetDisplayName();
                        sfp.fFolder = fFolder;
                        sfp.self = this;
                        sfp.iNamespace = -1;

                        int iInsertIndex = DPA_Search(_hdpaObjects, &sfp, 0,
                                _SearchByName, NULL, DPAS_SORTED | DPAS_INSERTAFTER);

                        TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: Creating new unmerged %s at %d", pmfiEnum->GetDisplayName(), iInsertIndex);

                        if (iInsertIndex < 0)
                            iInsertIndex = DA_LAST;

                        if (DPA_InsertPtr(_hdpaObjects, iInsertIndex, pmfiEnum) == -1)
                        {
                            TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Was unable to add %s for some reason. Bailing", 
                                pmfiEnum->GetDisplayName());
                            delete pmfiEnum;
                        }
                        else
                        {
                            *ppidlOut1 = _ILCombineBase(pidl1, pmfiEnum->GetIDList());
                        }
                    }
                    else
                        delete pmfiEnum;
                }
            }

        }
        break;

    case SHCNE_DELETE:
    case SHCNE_RMDIR:
        {
            TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s", fFolder? 
                TEXT("SHCNE_RMDIR") : TEXT("SHCNE_DELETE")); 
            int iDeleteIndex;
            // Is there a folder of this name already?
            if (S_OK == _SearchForPidl(iShellFolder1, pns1, pidlRealRel1,
                fFolder, &iDeleteIndex, &pmfi))
            {
                TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: Found %s checking merge state.", pmfi->GetDisplayName()); 
                // Yes; Then we need to unmerge this pidl from the wrapped pidl, and change this
                // to a rename, passing the Old wrapped pidl as the first arg, and the new wrapped pidl
                // as the second arg. I have to be careful about the freeing:
                // Free *ppidlOut1
                // Clone pmfi->GetIDList() -> *ppidlOut1.
                // Remove pidl1 from pmfi->_GetIDList()
                // Convert to rename, pass new wrapped as second arg. 

                if (_GetSourceCount(pmfi->GetIDList())  > 1)
                {
                    TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s is Merged. Removing pidl, convert to rename", pmfi->GetDisplayName()); 
                    *ppidlOut1 = _ILCombineBase(pidl1, pmfi->GetIDList());
                    if (*ppidlOut1)
                    {
                        LPITEMIDLIST pidlFree = pmfi->GetIDList();
                        if (SUCCEEDED(_WrapRemoveIDList(pidlFree, iShellFolder1, &pmfi->_pidlWrap)))
                        {
                            ILFree(pidlFree);
                        }

                        *ppidlOut2 = _ILCombineBase(pidl1, pmfi->GetIDList());
                        if (!*ppidlOut2)
                            TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Failure. Was unable to create new pidl2");

                        *plEvent = fFolder? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;
                    }
                    else
                    {
                        TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Failure. Was unable to create new pidl1");
                    }
                }
                else
                {
                    TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s is not Merged. deleteing", pmfi->GetDisplayName()); 
                    pmfi = (CMergedFldrItem*)DPA_DeletePtr(_hdpaObjects, iDeleteIndex);
                    if (EVAL(pmfi))
                    {
                        *ppidlOut1 = _ILCombineBase(pidl1, pmfi->GetIDList());
                        delete pmfi;
                    }
                    else
                    {
                        TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Failure. Was unable to get %d from DPA", iDeleteIndex);
                    }
                }
            }
        }
        break;

    case SHCNE_RENAMEITEM:
    case SHCNE_RENAMEFOLDER:
        {
            // REARCHITECT: (lamadio): When renaming an item in the menu, this code will split it into
            // a Delete and a Create. We need to detect this situation and convert it to 1 rename. This
            // will solve the problem of the lost order during a rename....
            BOOL fEvent1Set = FALSE;
            BOOL fFirstPidlInNamespace = FALSE;
            TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s", fFolder? 
                TEXT("SHCNE_RENAMEFOLDER") : TEXT("SHCNE_RENAMEITEM")); 

            // Is this item being renamed FROM the Folder?
            if (iShellFolder1 != -1)
            {
                // Is this pidl a child of the Folder?
                if (S_OK == _SearchForPidl(iShellFolder1, pns1, pidlRealRel1,
                    fFolder, &iIndex, &pmfi))  // Is it found?
                {
                    TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: Old pidl %s is in the Folder", pmfi->GetDisplayName()); 
                    // Yes.
                    // Then we need to see if the item that it's being renamed from was Merged

                    // Need this for reentrancy
                    if (_ContainsSrcID(pmfi->GetIDList(), iShellFolder1))
                    {
                        // Was it merged?
                        if (_GetSourceCount(pmfi->GetIDList()) > 1)    // Case 3)
                        {
                            // Yes; Then we need to unmerge that item.
                            *ppidlOut1 = _ILCombineBase(pidl1, pmfi->GetIDList());
                            if (*ppidlOut1)
                            {
                                LPITEMIDLIST pidlFree = pmfi->GetIDList();
                                if (SUCCEEDED(_WrapRemoveIDList(pidlFree, iShellFolder1, &pmfi->_pidlWrap)))
                                {
                                    ILFree(pidlFree);
                                }

                                *ppidlOut2 = _ILCombineBase(pidl1, pmfi->GetIDList());
                                if (!*ppidlOut2)
                                    TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Failure. Was unable to create new pidl2");

                                // This We need to "Rename" the old wrapped pidl, to this new one
                                // that does not contain the old item.
                                fEvent1Set = TRUE;
                            }
                            else
                            {
                                TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Failure. Was unable to create new pidl1");
                            }
                        }
                        else
                        {
                            TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s is not merged. Nuking item Convert to Delete for event 1.", 
                                pmfi->GetDisplayName()); 
                            // No, This was not a wrapped pidl. Then, convert to a delete:
                            pmfi = (CMergedFldrItem*)DPA_DeletePtr(_hdpaObjects, iIndex);

                            if (EVAL(pmfi))
                            {
                                // If we're renaming from this folder, into this folder, Then the first event stays a rename.
                                if (iShellFolder2 == -1)
                                {
                                    fEvent1Set = TRUE;
                                    *plEvent = fFolder? SHCNE_RMDIR : SHCNE_DELETE;
                                }
                                else
                                {
                                    fFirstPidlInNamespace = TRUE;
                                }
                                *ppidlOut1 = _ILCombineBase(pidl1, pmfi->GetIDList());
                                delete pmfi;
                            }
                            else
                            {
                                TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Failure. Was unable to find Item at %d", iIndex);
                            }

                        }
                    }
                    else
                    {
                        TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: Skipping this because we already processed it."
                            "Dragging To Desktop?");
                        hr = E_FAIL;
                    }
                }
                else
                {
                    // we were told to rename something that is supposed to exist in the first
                    // namespace, but we couldn't find it.
                    // we dont want to have the caller fire off some more events because of this,
                    // so we fail.
                    hr = E_FAIL;
                }
            }

            // Is this item is being rename INTO the Start Menu?
            if (iShellFolder2 != -1)
            {
                TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: New pidl is in the Folder"); 
                LPITEMIDLIST* ppidlNewWrapped1 = ppidlOut1;
                LPITEMIDLIST* ppidlNewWrapped2 = ppidlOut2;
                LONG* plNewEvent = plEvent;

                if (fEvent1Set)
                {
                    plNewEvent = plEvent2;
                    ppidlNewWrapped1 = ppidlOut1Event2;
                    ppidlNewWrapped2 = ppidlOut2Event2;
                }

                if (S_OK == _SearchForPidl(iShellFolder2, pns2, pidlRealRel2,
                    fFolder, &iIndex, &pmfi))
                {
                    // If we're renaming from this folder, into this folder, Check to see if the destination has a
                    // conflict. If there is a confict (This case), then convert first event to a remove, 
                    // and the second event to the rename.
                    if (fFirstPidlInNamespace)
                    {
                        fEvent1Set = TRUE;
                        *plEvent = fFolder? SHCNE_RMDIR : SHCNE_DELETE;
                        plNewEvent = plEvent2;
                        ppidlNewWrapped1 = ppidlOut1Event2;
                        ppidlNewWrapped2 = ppidlOut2Event2;
                    }
                    
                    TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s is in Folder", pmfi->GetDisplayName());
                    TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: Adding pidl to %s. Convert to Rename for event %s", 
                        pmfi->GetDisplayName(), fEvent1Set? TEXT("2") : TEXT("1"));

                    // Then the destination needs to be merged.
                    *ppidlNewWrapped1 = _ILCombineBase(pidl2, pmfi->GetIDList());
                    if (*ppidlNewWrapped1)
                    {
                        TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: Successfully created out pidl1");

                        _WrapAddIDList(pidlRealRel2, iShellFolder2, &pmfi->_pidlWrap); 
                        *ppidlNewWrapped2 = _ILCombineBase(pidl2, pmfi->GetIDList());

                        *plNewEvent = fFolder? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;
                    }
                }
                else
                {
                    CMergedFldrItem* pmfiEnum = new CMergedFldrItem;
                    if (pmfiEnum)
                    {
                        LPITEMIDLIST pidlWrap;
                        if (SUCCEEDED(_CreateWrap(pidlRealRel2, (UINT)iShellFolder2, &pidlWrap)) &&
                            pmfiEnum->Init(SAFECAST(this, IAugmentedShellFolder2*), pidlWrap, iShellFolder2))
                        {
                            SEARCH_FOR_PIDL sfp;
                            sfp.pszDisplayName = pmfiEnum->GetDisplayName();
                            sfp.fFolder = BOOLIFY(pmfiEnum->GetFolderAttrib() & SFGAO_FOLDER);
                            sfp.self = this;
                            sfp.iNamespace = -1;

                            int iInsertIndex = DPA_Search(_hdpaObjects, &sfp, 0,
                                                           _SearchByName, NULL, 
                                                           DPAS_SORTED | DPAS_INSERTAFTER);

                            TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: %s is a new item. Converting to Create", pmfiEnum->GetDisplayName());

                            if (iInsertIndex < 0)
                                iInsertIndex = DA_LAST;

                            if (DPA_InsertPtr(_hdpaObjects, iInsertIndex, pmfiEnum) == -1)
                            {
                                TraceMsg(TF_ERROR, "CMergedFolder::TranslateIDs: Was unable to add %s for some reason. Bailing", 
                                                    pmfiEnum->GetDisplayName());
                                delete pmfiEnum;
                            }
                            else
                            {
                                TraceMsg(TF_AUGM, "CMergedFolder::TranslateIDs: Creating new item %s at %d for event %s", 
                                                  pmfiEnum->GetDisplayName(), iInsertIndex,  fEvent1Set? TEXT("2") : TEXT("1"));

                                // If we're renaming from this folder, into this folder, Then the first event stays
                                // a rename.
                                if (!fFirstPidlInNamespace)
                                {
                                    *plNewEvent = fFolder ? SHCNE_MKDIR : SHCNE_CREATE;
                                    *ppidlNewWrapped1 = _ILCombineBase(pidl2, pidlWrap);
                                    *ppidlNewWrapped2 = NULL;
                                }
                                else
                                    *ppidlOut2 = _ILCombineBase(pidl2, pidlWrap);
                            }
                        }
                        else
                            delete pmfiEnum;
                    }
                }
            }
        }
        break;

    default:
        break;
    }

Cleanup:
    ILFree(pidlReal1);
    ILFree(pidlReal2);

    return hr;
}


// parsedisplayname with some extras.
// this is used to process change notifies.  the change notify can be fired AFTER the
// item has been moved/deleted/whatever, but we still have to be able to correctly process that
// pidl.  so here pidlAbsNamespace identifies the absolute pidl of the item being changenotified.
// if we're parsing a name within that namespace, force the parsedisplayname with STGM_CREATE to
// make sure we get the pidl (because it may have been moved or deleted by now) if fForce==TRUE.
HRESULT CMergedFolder::_ForceParseDisplayName(LPCITEMIDLIST pidlAbsNamespace, LPTSTR pszDisplayName, BOOL fForce, BOOL *pfOthersInWrap, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;
    *pfOthersInWrap = FALSE;

    HRESULT hr = S_OK;

    // set up a bindctx: will have STGM_CREATE if fForce is passed, NULL otherwise
    IBindCtx *pbc;
    if (fForce)
    {
        hr = BindCtx_CreateWithMode(STGM_CREATE, &pbc);
    }
    else
    {
        pbc = NULL;
    }

    if (SUCCEEDED(hr))
    {
        CMergedFldrNamespace *pnsWrap = NULL;
        CMergedFldrNamespace *pnsLoop;
        for (int i = 0; SUCCEEDED(hr) && (pnsLoop = _Namespace(i)); i++)
        {
            HRESULT hrLoop = E_FAIL;  // not propagated since ParseDisplayName can fail and that's okay
            
            LPITEMIDLIST pidlNamespace;
            // so if the namespace pnsLoop is a parent to the pidl, we know it
            // came from there so use the bindctx to force creation if necessary
            if (ILIsParent(pnsLoop->GetIDList(), pidlAbsNamespace, FALSE))
            {
                hrLoop = pnsLoop->Folder()->ParseDisplayName(NULL, pbc, pszDisplayName, NULL, &pidlNamespace, NULL);
            }
            else if (_ShouldMergeNamespaces(pnsWrap, pnsLoop))
            {
                pnsWrap = pnsLoop;
                // only if we're merging, tack on other namespace's pidls.
                hrLoop = pnsLoop->Folder()->ParseDisplayName(NULL, NULL, pszDisplayName, NULL, &pidlNamespace, NULL);
            }

            if (SUCCEEDED(hrLoop))
            {
                if (*ppidl)
                {
                    *pfOthersInWrap = TRUE;
                }
                hr = _WrapAddIDList(pidlNamespace, i, ppidl);
    
                ILFree(pidlNamespace);
            }
        }

        // it could be NULL
        if (pbc)
        {
            pbc->Release();
        }
    }
    return hr;
}


// this takes an absolute pidl in the given namespace and converts it to a merged pidl.
// if the item does not actually exist in the namespace, it forces creation if fForce==TRUE (so if
// a changenotify comes in on that namespace it will process it normally, even if the
// underlying item has been moved or deleted).
HRESULT CMergedFolder::_AbsPidlToAbsWrap(CMergedFldrNamespace *pns, LPCITEMIDLIST pidl, BOOL fForce, BOOL *pfOthersInWrap, LPITEMIDLIST *ppidl)
{
    LPCITEMIDLIST pidlRel = ILFindChild(pns->GetIDList(), pidl);
    HRESULT hr = SHILClone(_pidl, ppidl);
    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc;
        hr = SHCreateSkipBindCtx(NULL, &pbc); // skip all other binding
        if (SUCCEEDED(hr))
        {
            CMergedFolder *pmfMerged = this;
            pmfMerged->AddRef();

            IShellFolder *psfNamespace = pns->Folder();
            psfNamespace->AddRef();

            HRESULT hrLoop = S_OK;
            while (SUCCEEDED(hr) && SUCCEEDED(hrLoop) && !ILIsEmpty(pidlRel))
            {
                hr = E_OUTOFMEMORY;
                LPITEMIDLIST pidlRelFirst = ILCloneFirst(pidlRel);
                if (pidlRelFirst)
                {
                    TCHAR szRelPath[MAX_PATH];
                    hr = DisplayNameOf(psfNamespace, pidlRelFirst, SHGDN_FORPARSING | SHGDN_INFOLDER, szRelPath, ARRAYSIZE(szRelPath));

                    if (SUCCEEDED(hr))
                    {
                        LPITEMIDLIST pidlNextPart;
                        hr = pmfMerged->_ForceParseDisplayName(pidl, szRelPath, fForce, pfOthersInWrap, &pidlNextPart);
                        if (SUCCEEDED(hr))
                        {
                            // shilappend frees pidlnextpart
                            hr = SHILAppend(pidlNextPart, ppidl);
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        // advance and clean up
                        IShellFolder *psfFree = psfNamespace;
                        psfNamespace = NULL;
                        hrLoop = psfFree->BindToObject(pidlRelFirst, pbc, IID_PPV_ARG(IShellFolder, &psfNamespace));
                        psfFree->Release();

                        if (SUCCEEDED(hrLoop))
                        {
                            CMergedFolder *pmfFree = pmfMerged;
                            pmfMerged = NULL;
                            hrLoop = pmfFree->BindToObject(ILFindLastID(*ppidl), pbc, CLSID_MergedFolder, (void **) &pmfMerged);
                            pmfFree->Release();
                        }

                        pidlRel = ILGetNext(pidlRel);
                    }

                    ILFree(pidlRelFirst);
                }
            }

            if (pmfMerged)
                pmfMerged->Release();
            if (psfNamespace)
                psfNamespace->Release();

            pbc->Release();
        }
    }
    return hr;
}


// new translateids.
// when the start menu works a little better this whole interface can be revised.
HRESULT CMergedFolder::_NewTranslateIDs(
    LONG *plEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, 
    LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
    LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, 
    LPITEMIDLIST *ppidlOut2Event2)
{
    if (!plEvent || !ppidlOut1 || !ppidlOut2)
        return E_INVALIDARG;

    // If they are already wrapped, don't wrap twice.
    if (SUCCEEDED(_IsWrap(ILFindLastID(pidl1))) ||
        SUCCEEDED(_IsWrap(ILFindLastID(pidl2))))
    {
        // We don't want to wrap twice.
        return E_INVALIDARG;
    }

    if (!_hdpaNamespaces)
        return E_FAIL;

    HRESULT hr = E_FAIL;

    switch (*plEvent)
    {
        case SHCNE_EXTENDED_EVENT:
        case SHCNE_ASSOCCHANGED:
        case SHCNE_UPDATEIMAGE:
            return S_OK;
    }

    LONG lEvent = *plEvent;

    *plEvent2 = (LONG)-1;
    *ppidlOut1Event2 = NULL;
    *ppidlOut2Event2 = NULL;
    
    *ppidlOut1 = (LPITEMIDLIST)pidl1;
    *ppidlOut2 = (LPITEMIDLIST)pidl2;

    CMergedFldrNamespace *pns1, *pns2;
    int iShellFolder1, iShellFolder2;
    BOOL fPidl1IsChild, fPidl2IsChild;
    // Get the information about these Simple pidls: Are they our Children? If so, what _Namespace?
    fPidl1IsChild = _IsChildIDInternal(pidl1, FALSE, &iShellFolder1);
    if (fPidl1IsChild)
    {
        pns1 = _Namespace(iShellFolder1);
    }
    fPidl2IsChild = _IsChildIDInternal(pidl2, FALSE, &iShellFolder2);
    if (fPidl2IsChild)
    {
        pns2 = _Namespace(iShellFolder2);
    }

    // and is either a child?
    if (fPidl1IsChild || fPidl2IsChild)
    {
        hr = S_OK;

        BOOL fOthersInNamespace1, fOthersInNamespace2;

        BOOL fFolderEvent = FALSE;
        switch (*plEvent)
        {
        case SHCNE_MKDIR:
            fFolderEvent = TRUE;
        case SHCNE_CREATE:
            if (fPidl1IsChild)
            {
                hr = _AbsPidlToAbsWrap(pns1, pidl1, FALSE, &fOthersInNamespace1, ppidlOut1);
                if (SUCCEEDED(hr) && fOthersInNamespace1 && !_fDontMerge)
                {
                    // whoops, it was already here and this create should become a rename
                    // since we're just merging in with the existing pidl.
                    *plEvent = fFolderEvent ? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;

                    // this new wrapped one is what it's renamed TO so bump it to ppidlOut2.
                    *ppidlOut2 = *ppidlOut1;
                    // strip it to get what it used to be.
                    hr = _WrapRemoveIDListAbs(*ppidlOut2, iShellFolder1, ppidlOut1);
                }
            }
            break;

        case SHCNE_RMDIR:
            fFolderEvent = TRUE;
        case SHCNE_DELETE:
            if (fPidl1IsChild)
            {
                hr = _AbsPidlToAbsWrap(pns1, pidl1, TRUE, &fOthersInNamespace1, ppidlOut1);
                if (SUCCEEDED(hr) && fOthersInNamespace1 && !_fDontMerge)
                {
                    // whoops, there are still more parts to it and it should become a rename
                    // since we're just unmerging from the existing pidl.
                    *plEvent = fFolderEvent ? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;

                    // strip it to get the "deleted" version
                    hr = _WrapRemoveIDListAbs(*ppidlOut1, iShellFolder1, ppidlOut2);
                }
            }
            break;

        case SHCNE_RENAMEFOLDER:
            fFolderEvent = TRUE;
        case SHCNE_RENAMEITEM:
            if (fPidl1IsChild)
            {
                // this is just like a delete.
                *plEvent = fFolderEvent ? SHCNE_RMDIR : SHCNE_DELETE;
                hr = _AbsPidlToAbsWrap(pns1, pidl1, TRUE, &fOthersInNamespace1, ppidlOut1);
                if (SUCCEEDED(hr) && fOthersInNamespace1 && !_fDontMerge)
                {
                    // whoops, there are still more parts to it and it should become a rename
                    // since we're just unmerging from the existing pidl.
                    *plEvent = fFolderEvent ? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;

                    // strip it to get the "deleted" version
                    hr = _WrapRemoveIDListAbs(*ppidlOut1, iShellFolder1, ppidlOut2);
                }

                // set ourselves up so that if fPidl2IsChild, it will write into the second event.
                plEvent = plEvent2;
                ppidlOut1 = ppidlOut1Event2;
                ppidlOut2 = ppidlOut2Event2;
            }

            if (fPidl2IsChild)
            {
                // this is just like a create.
                *plEvent = fFolderEvent ? SHCNE_MKDIR : SHCNE_CREATE;
                hr = _AbsPidlToAbsWrap(pns2, pidl2, FALSE, &fOthersInNamespace2, ppidlOut1);
                if (SUCCEEDED(hr) && fOthersInNamespace2 && !_fDontMerge)
                {
                    // whoops, it was already here and this create should become a rename
                    // since we're just merging in with the existing pidl.
                    *plEvent = fFolderEvent ? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;

                    // this new wrapped one is what it's renamed TO so bump it to ppidlOut2.
                    *ppidlOut2 = *ppidlOut1;
                    // strip it to get what it used to be.
                    hr = _WrapRemoveIDListAbs(*ppidlOut2, iShellFolder2, ppidlOut1);
                }
            }
            break;

        case SHCNE_UPDATEDIR:
        case SHCNE_UPDATEITEM:
        case SHCNE_MEDIAINSERTED:
        case SHCNE_MEDIAREMOVED:
            hr = _AbsPidlToAbsWrap(pns1, pidl1, FALSE, &fOthersInNamespace1, ppidlOut1);
            break;

        default:
            break;
        }
    }

    return hr;
}

STDMETHODIMP CMergedFolder::IsChildID(LPCITEMIDLIST pidlKid, BOOL fImmediate)
{
    return _IsChildIDInternal(pidlKid, fImmediate, NULL) ? S_OK : S_FALSE;
}


STDMETHODIMP CMergedFolder::IsEqualID(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // This used to return E_NOTIMPL. I'm kinda overloading the interface to mean:
    // is this equal tp any of your _Namespaces.
    HRESULT hr = S_FALSE;

    CMergedFldrNamespace *pns;
    for (int i = 0; (hr == S_FALSE) && (pns = _Namespace(i)); i++)
    {
        if (pidl1)
        {
            if (ILIsEqual(pns->GetIDList(), pidl1))
                hr = S_OK;
        }
        else if (pidl2) // If you pass a pidl2 it means: Is pidl2 a parent of one of my _Namespaces?
        {
            if (ILIsParent(pidl2, pns->GetIDList(), FALSE))
                hr = S_OK;
        }
    }
    return hr;
}


typedef struct
{
    HWND hwnd;
    UINT uMsg;
    LONG lEvents;
} REGISTERNOTIFYINFO;

int CMergedFolder::_SetNotifyProc(void *pv, void *pvParam)
{
    CMergedFldrNamespace *pns = (CMergedFldrNamespace*)pv;
    if (pvParam)
    {
        REGISTERNOTIFYINFO *prni = (REGISTERNOTIFYINFO*)pvParam;
        pns->RegisterNotify(prni->hwnd, prni->uMsg, prni->lEvents);
    }
    else
    {
        pns->UnregisterNotify();
    }
    return 1;
}

STDMETHODIMP CMergedFolder::Register(HWND hwnd, UINT uMsg, long lEvents)
{
    if (_fInShellView)
    {
        // only register the alias if we have no parent folder
        // the merged folder at the junction point can take care of the registration
        // for everybody.
        if (_pidl && !_pmfParent)
        {
            CMergedFldrNamespace *pns;
            for (int i = 0; pns = _Namespace(i); i++)
            {
                if (!ILIsEqual(pns->GetIDList(), _pidl))
                {
                    SHChangeNotifyRegisterAlias(pns->GetIDList(), _pidl);
                }
            }
        }
    }
    else if (_hdpaNamespaces)
    {
        REGISTERNOTIFYINFO rni = {hwnd, uMsg, lEvents};
        DPA_EnumCallback(_hdpaNamespaces, _SetNotifyProc, &rni);
    }
    return S_OK;
}

STDMETHODIMP CMergedFolder::Unregister()
{
    if (_hdpaNamespaces)
    {
        DPA_EnumCallback(_hdpaNamespaces, _SetNotifyProc, NULL);
    }
    return S_OK;
}


BOOL CMergedFolder::_IsChildIDInternal(LPCITEMIDLIST pidlKid, BOOL fImmediate, int* piShellFolder)
{
    // This is basically the same Method as the interface method, but returns the shell folder
    // that it came from.
    BOOL fChild = FALSE;

    //At this point we should have a translated pidl
    if (SUCCEEDED(_IsWrap(pidlKid)))
    {
        LPCITEMIDLIST pidlRelKid = ILFindLastID(pidlKid);
        if (pidlRelKid)
        {
            CMergedFldrNamespace *pns;
            for (int i = 0; !fChild && (pns = _Namespace(i)); i++)
            {
                if (ILIsParent(pns->GetIDList(), pidlKid, fImmediate) &&
                    !ILIsEqual(pns->GetIDList(), pidlKid))
                {
                    fChild = TRUE;
                    if (piShellFolder)
                        *piShellFolder = i;
                }
            }
        }
    }
    else if (pidlKid)
    {
        CMergedFldrNamespace *pns;
        for (int i = 0; !fChild && (pns = _Namespace(i)); i++)
        {
            if (ILIsParent(pns->GetIDList(), pidlKid, fImmediate))
            {
                fChild = TRUE;
                if (piShellFolder)
                    *piShellFolder = i;
            }
        }
    }

    return fChild;
}


HRESULT CMergedFolder::_SearchForPidl(int iNamespace, CMergedFldrNamespace *pns, LPCITEMIDLIST pidl, BOOL fFolder, int* piIndex, CMergedFldrItem** ppmfi)
{
    int iIndex = -1;
    *ppmfi = NULL;

    TCHAR szDisplayName[MAX_PATH];
    if (SUCCEEDED(DisplayNameOf(pns->Folder(), pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szDisplayName, ARRAYSIZE(szDisplayName))))
    {
        SEARCH_FOR_PIDL sfp;
        sfp.pszDisplayName = szDisplayName;
        sfp.fFolder = fFolder;
        sfp.self = this;
        if (_fPartialMerge)
        {
            sfp.iNamespace = iNamespace;
        }
        else
        {
            sfp.iNamespace = -1;
        }

        iIndex = DPA_Search(_hdpaObjects, &sfp, 0, _SearchByName, NULL, DPAS_SORTED);

        if (iIndex >= 0)
        {
            *ppmfi = _GetObject(iIndex);
        }
    }

    if (piIndex)
        *piIndex = iIndex;

    if (*ppmfi)
        return S_OK;

    return S_FALSE;
}

HRESULT CMergedFolder::_GetTargetUIObjectOf(IShellFolder *psf, HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, REFIID riid, UINT *prgf, void **ppv)
{
    *ppv = NULL;

    IPersistFolder3 *ppf3;
    HRESULT hr = psf->QueryInterface(IID_PPV_ARG(IPersistFolder3, &ppf3));
    if (SUCCEEDED(hr))
    {
        PERSIST_FOLDER_TARGET_INFO pfti;
        hr = ppf3->GetFolderTargetInfo(&pfti);
        if (SUCCEEDED(hr) && pfti.pidlTargetFolder)
        {
            IShellFolder *psfTarget;
            hr = SHBindToObjectEx(NULL, pfti.pidlTargetFolder, NULL, IID_PPV_ARG(IShellFolder, &psfTarget));
            if (SUCCEEDED(hr))
            {
                DWORD dwAttrib = SFGAO_VALIDATE;
                hr = psfTarget->GetAttributesOf(cidl, apidl, &dwAttrib);
                if (SUCCEEDED(hr))
                {
                    hr = psfTarget->GetUIObjectOf(hwnd, cidl, apidl, riid, prgf, ppv);
                }
                psfTarget->Release();
            }
            ILFree(pfti.pidlTargetFolder);
        }
        else
        {
            hr = E_FAIL;
        }
        ppf3->Release();
    }

    if (FAILED(hr))
    {
        DWORD dwAttrib = SFGAO_VALIDATE;
        hr = psf->GetAttributesOf(cidl, apidl, &dwAttrib);
        if (SUCCEEDED(hr))
        {
            hr = psf->GetUIObjectOf(hwnd, cidl, apidl, riid, prgf, ppv);
        }
    }
    return hr;
}

HRESULT CMergedFolder::_GetContextMenu(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    UINT iNumCommon = 0;
    LPITEMIDLIST *apidlCommon = new LPITEMIDLIST[cidl];
    if (apidlCommon)
    {
        UINT iNumUser = 0;
        LPITEMIDLIST *apidlUser = new LPITEMIDLIST[cidl];
        if (apidlUser)
        {
            IShellFolder *psf, *psfCommon, *psfUser;  // not ref counted
            LPITEMIDLIST pidl;
            for (UINT i = 0; i < cidl; i++)
            {
                if (SUCCEEDED(_NamespaceForItem(apidl[i], ASFF_COMMON, ASFF_COMMON, &psf, &pidl, NULL, TRUE)))
                {
                    apidlCommon[iNumCommon++] = pidl;
                    psfCommon = psf;
                }
                if (SUCCEEDED(_NamespaceForItem(apidl[i], ASFF_COMMON, 0, &psf, &pidl, NULL, TRUE)))
                {
                    apidlUser[iNumUser++] = pidl;
                    psfUser = psf;
                }
            }

            IContextMenu *pcmCommon = NULL;
            if (iNumCommon)
            {
                _GetTargetUIObjectOf(psfCommon, hwnd, iNumCommon, (LPCITEMIDLIST *)apidlCommon, IID_X_PPV_ARG(IContextMenu, NULL, &pcmCommon));
            }

            IContextMenu *pcmUser = NULL;
            if (iNumUser)
            {
                _GetTargetUIObjectOf(psfUser, hwnd, iNumUser, (LPCITEMIDLIST *)apidlUser, IID_X_PPV_ARG(IContextMenu, NULL, &pcmUser));
            }

            BOOL fMerge = _fInShellView || (cidl == 1) && _IsFolder(apidl[0]);
            if (fMerge && (pcmCommon || pcmUser))
            {
                hr = CMergedFldrContextMenu_CreateInstance(hwnd, this, cidl, apidl, pcmCommon, pcmUser, (IContextMenu**)ppv);
            }
            else if (pcmUser)
            {
                hr = pcmUser->QueryInterface(riid, ppv);
            }
            else if (pcmCommon)
            {
                hr = pcmCommon->QueryInterface(riid, ppv);
            }
            else
            {
                hr = E_FAIL;
            }

            for (i = 0; i < iNumCommon; i++)
            {
                ILFree(apidlCommon[i]);
            }
            for (i = 0; i < iNumUser; i++)
            {
                ILFree(apidlUser[i]);
            }

            ATOMICRELEASE(pcmCommon);
            ATOMICRELEASE(pcmUser);
            delete [] apidlUser;
        }
        delete [] apidlCommon;
    }

    return hr;
}


// out:
//      *ppsf       unreffed psf, don't call ->Release()!
//      *ppidlItem  clone of pidl in pidlWrap (nested pidl)

HRESULT CMergedFolder::_NamespaceForItem(LPCITEMIDLIST pidlWrap, ULONG dwAttribMask, ULONG dwAttrib, 
                                         IShellFolder **ppsf, LPITEMIDLIST *ppidlItem, CMergedFldrNamespace **ppns, BOOL fExact)
{
    if (ppsf)
        *ppsf = NULL;
    if (ppns)
        *ppns = NULL;

    // first try to get the prefered name space based
    HRESULT hr = E_UNEXPECTED;  // assume failure from here
    CMergedFldrNamespace *pns;
    LPITEMIDLIST pidl;
    for (UINT i = 0; SUCCEEDED(_GetSubPidl(pidlWrap, i, NULL, &pidl, &pns)); i++)
    {
        if ((dwAttribMask & dwAttrib) == (dwAttribMask & pns->FolderAttrib()))
        {
            hr = S_OK; // don't free, we're going to hand this one back.
            break;
        }
        ILFree(pidl);
    }

    // not found, fall back to the first name space in the wrapped pidl
    if (!fExact && FAILED(hr))
    {
        hr = _GetSubPidl(pidlWrap, 0, NULL, &pidl, &pns);
    }

    // it succeeded, so lets pass out the information that the caller wanted    
    if (SUCCEEDED(hr))
    {
        if (ppsf)
            *ppsf = pns->Folder();
        if (ppns)
            *ppns = pns;
        if (ppidlItem)
        {
            // transfer ownership
            *ppidlItem = pidl;
        }
        else
        {
            ILFree(pidl);
        }
    }

    return hr;
}

BOOL CMergedFolder::_NamespaceMatches(ULONG dwAttribMask, ULONG dwAttrib, LPCGUID pguid, CMergedFldrNamespace *pns)
{
    BOOL fRet = FALSE;

    dwAttrib &= dwAttribMask;

    if (dwAttrib == (dwAttribMask & pns->FolderAttrib()))
    {
        // If ASFF_MERGESAMEGUID is set, then the GUID must also match
        if (!(dwAttrib & ASFF_MERGESAMEGUID) ||
            IsEqualGUID(*pguid, pns->GetGUID()))
        {
            fRet = TRUE;
        }
    }
    return fRet;
}

// find a name space based on its attributes
// dwAttribMask is a mask of the bits to test
// dwAttrib is the value of the bits in the mask, tested for equality
// pguid is the GUID to match if dwAttrib includes ASFF_MERGESAMEGUID
//
// pnSrcID is optional out param
HRESULT CMergedFolder::_FindNamespace(ULONG dwAttribMask, ULONG dwAttrib, LPCGUID pguid,
                                      CMergedFldrNamespace **ppns, BOOL fFallback)
{
    *ppns = NULL;

    CMergedFldrNamespace *pns;
    int i;

    // first look for a matching namespace.
    for (i = 0; !*ppns && (pns = _Namespace(i)); i++)
    {
        if (!_ShouldSuspend(pns->GetGUID()) && _NamespaceMatches(dwAttribMask, dwAttrib, pguid, pns))
        {
            *ppns = pns;
        }
    }

    if (fFallback && !*ppns)
    {
        // if the matching namespace got scoped out, fall back to another.
        for (i = 0; !*ppns && (pns = _Namespace(i)); i++)
        {
            if (!_ShouldSuspend(pns->GetGUID()))
            {
                *ppns = pns;
            }
        }
    }

    return *ppns ? S_OK : E_FAIL;
}

int CMergedFolder::_AcquireObjects()
{
    _fAcquiring = TRUE;

    HDPA hdpa2 = NULL;

    ASSERT(_hdpaObjects == NULL);

    CMergedFldrNamespace *pns;
    for (int i = 0; pns = _Namespace(i); i++)
    {
        if (_ShouldSuspend(pns->GetGUID()))
        {
            continue;
        }

        HDPA *phdpa = (i == 0) ? &_hdpaObjects : &hdpa2;

        IEnumIDList *peid;
        if (S_OK == pns->Folder()->EnumObjects(NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS | SHCONTF_INCLUDEHIDDEN, &peid))
        {
            if (!*phdpa)
                *phdpa = DPA_Create(4);

            if (*phdpa)
            {
                LPITEMIDLIST pidl;
                ULONG cEnum;
                
                while (S_OK == peid->Next(1, &pidl, &cEnum))
                {
                    CMergedFldrItem* pmfiEnum = new CMergedFldrItem;
                    if (pmfiEnum)
                    {
                        // This is ok, the memory just gets 
                        LPITEMIDLIST pidlWrap;
                        if (SUCCEEDED(_CreateWrap(pidl, i, &pidlWrap)) &&
                                pmfiEnum->Init(SAFECAST(this, IAugmentedShellFolder2*), pidlWrap, i))
                        {
                            if (DPA_AppendPtr(*phdpa, pmfiEnum) != -1)
                                pmfiEnum = NULL;   // don't free below
                        }

                        if (pmfiEnum)
                            delete pmfiEnum;
                    }
                    ILFree(pidl);
                }
            }
            peid->Release();
        }

        // if we have only hdpa2 but not _hdpaObjects, do a switcheroo.
        if (hdpa2 && !_hdpaObjects)
        {
            _hdpaObjects = hdpa2;
            hdpa2 = NULL;
        }

        // now that we have both hdpa's (or one) let's merge them.
        if (_hdpaObjects && hdpa2)
        {
            DPA_Merge(_hdpaObjects, hdpa2, DPAM_UNION, _Compare, _Merge, (LPARAM)this);
            DPA_DestroyCallback(hdpa2, _DestroyObjectsProc, NULL);
            hdpa2 = NULL;
        }
        else if (_hdpaObjects)
        {
            DPA_Sort(_hdpaObjects, _Compare, (LPARAM)this);
        }
    }

    _fAcquiring = FALSE;
    return _ObjectCount();
}

int CMergedFolder::_DestroyObjectsProc(void *pv, void *pvData)
{
    CMergedFldrItem* pmfiEnum = (CMergedFldrItem*)pv;
    if (pmfiEnum)
        delete pmfiEnum;
    return TRUE;
}

void CMergedFolder::_FreeObjects()
{
    if (!_fAcquiring && _hdpaObjects)
    {
        DPA_DestroyCallback(_hdpaObjects, _DestroyObjectsProc, NULL);
        _hdpaObjects = NULL;
    }
}

int CMergedFolder::_DestroyNamespacesProc(void *pv, void *pvData)
{
    CMergedFldrNamespace* p = (CMergedFldrNamespace*)pv;
    if (p)
        delete p;
    return TRUE;
}

void CMergedFolder::_FreeNamespaces()
{
    if (_hdpaNamespaces)
    {
        DPA_DestroyCallback(_hdpaNamespaces, _DestroyNamespacesProc, NULL);
        _hdpaNamespaces = NULL;
    }
}

HRESULT CMergedFolder::_GetPidl(int* piPos, DWORD grfEnumFlags, LPITEMIDLIST* ppidl)
{
    *ppidl = NULL;

    if (_hdpaObjects == NULL)
        _AcquireObjects();

    if (_hdpaObjects == NULL)
        return E_OUTOFMEMORY;

    BOOL fWantFolders    = 0 != (grfEnumFlags & SHCONTF_FOLDERS),
         fWantNonFolders = 0 != (grfEnumFlags & SHCONTF_NONFOLDERS),
         fWantHidden     = 0 != (grfEnumFlags & SHCONTF_INCLUDEHIDDEN),
         fWantAll        = 0 != (grfEnumFlags & SHCONTF_STORAGE);

    HRESULT hr = S_FALSE;
    while (*piPos < _ObjectCount())
    {
        CMergedFldrItem* pmfiEnum = _GetObject(*piPos);
        if (pmfiEnum)
        {
            BOOL fFolder = 0 != (pmfiEnum->GetFolderAttrib() & SFGAO_FOLDER),
                 fHidden = 0 != (pmfiEnum->GetFolderAttrib() & SFGAO_HIDDEN);
             
            if (fWantAll ||
                (!fHidden || fWantHidden) && 
                ((fFolder && fWantFolders) || (!fFolder && fWantNonFolders)))
            {
                // Copy out the pidl
                hr = SHILClone(pmfiEnum->GetIDList(), ppidl);
                break;
            }
            else
            {
                (*piPos)++;
            }
        }
    }

    return hr;
}

HRESULT CMergedFolder::_GetOverlayInfo(LPCITEMIDLIST pidl, int *pIndex, DWORD dwFlags)
{
    int iOverlayIndex = -1;
    HRESULT hr = S_OK;

    CMergedFldrNamespace *pns;
    if (_fCDBurn)
    {
        hr = E_OUTOFMEMORY;
        LPITEMIDLIST pidlInNamespace;
        if (SUCCEEDED(_GetSubPidl(pidl, 0, NULL, &pidlInNamespace, &pns)))
        {
            ASSERTMSG(!_fDontMerge || _GetSourceCount(pidl) == 1, "item for overlay should have exactly one wrapped pidl if not merged");

            LPITEMIDLIST pidlFirst = ILCloneFirst(pidl);
            if (pidlFirst)
            {
                if (_GetSourceCount(pidlFirst) > 1)
                {
                    // an overlay to indicate overwrite
                    iOverlayIndex = pns->GetConflictOverlayIndex();
                }
                if (iOverlayIndex == -1)
                {
                    // overlay to indicate staged
                    iOverlayIndex = pns->GetDefaultOverlayIndex();
                }
                if (iOverlayIndex == -1)
                {
                    // use the one provided by the namespace
                    iOverlayIndex = pns->GetNamespaceOverlayIndex(pidlInNamespace);
                }
                ILFree(pidlFirst);
            }
            ILFree(pidlInNamespace);
        }
    }

    ASSERT(pIndex);
    *pIndex = (dwFlags == SIOM_OVERLAYINDEX) ? iOverlayIndex : INDEXTOOVERLAYMASK(iOverlayIndex);

    return hr;
}

HRESULT CMergedFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    return (*pIndex == OI_ASYNC) ? E_PENDING : _GetOverlayInfo(pidl, pIndex, SIOM_OVERLAYINDEX);
}

HRESULT CMergedFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIconIndex)
{
    return _GetOverlayInfo(pidl, pIconIndex, SIOM_ICONINDEX);
}

STDMETHODIMP CMergedFolder::BindToParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPITEMIDLIST *ppidlLast)
{
    // tybeam: nobody seems to call this any more.
    // if this is ever needed tell me to add it back.
    return E_NOTIMPL;
}

HRESULT CMergedFolder::_AddComposite(const COMPFOLDERINIT *pcfi)
{
    HRESULT hr = E_FAIL;

    LPITEMIDLIST pidl = NULL;
    switch (pcfi->uType)
    {
    case CFITYPE_CSIDL:
        SHGetSpecialFolderLocation(NULL, pcfi->csidl, &pidl);
        break;

    case CFITYPE_PIDL:
        pidl = ILClone(pcfi->pidl);
        break;

    case CFITYPE_PATH:
        pidl = ILCreateFromPath(pcfi->pszPath);
        break;

    default:
        ASSERT(FALSE);
    }

    if (pidl)
    {
        hr = AddNameSpace(NULL, NULL, pidl, ASFF_DEFNAMESPACE_ALL);
        ILFree(pidl);
    }

    return hr;
}

STDMETHODIMP CMergedFolder::InitComposite(WORD wSignature, REFCLSID refclsid, CFINITF cfiFlags, ULONG celt, const COMPFOLDERINIT *rgCFs)
{
    HRESULT hr = S_OK;

    _clsid = refclsid;

    ASSERTMSG(cfiFlags == CFINITF_FLAT, "merged folder doesn't support listing namespaces as children any more");
    if (cfiFlags != CFINITF_FLAT)
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        for (ULONG i = 0; SUCCEEDED(hr) && (i < celt); i++)
        {
            hr = _AddComposite(rgCFs + i);
        }
    }
    return hr;
}

STDMETHODIMP CMergedFolder::_DeleteItemByIDList(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlSrc;
    CMergedFldrNamespace *pns;
    HRESULT hr = _NamespaceForItem(pidl, ASFF_DEFNAMESPACE_BINDSTG, ASFF_DEFNAMESPACE_BINDSTG, NULL, &pidlSrc, &pns, FALSE);
    if (SUCCEEDED(hr))
    {
        IStorage *pstg;
        hr = pns->Folder()->QueryInterface(IID_PPV_ARG(IStorage, &pstg));
        if (SUCCEEDED(hr))
        {
            TCHAR szName[MAX_PATH];
            hr = DisplayNameOf(pns->Folder(), pidlSrc, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
            if (SUCCEEDED(hr))
            {
                hr = pstg->DestroyElement(szName);
            }
            pstg->Release();
        }
        ILFree(pidlSrc);
    }
    return hr;
}

HRESULT CMergedFolder::_GetDestinationStorage(DWORD grfMode, IStorage **ppstg)
{
    CMergedFldrNamespace *pns;
    HRESULT hr = _FindNamespace(ASFF_DEFNAMESPACE_BINDSTG, ASFF_DEFNAMESPACE_BINDSTG, NULL, &pns, TRUE);
    if (SUCCEEDED(hr))
    {
        IShellFolder *psf;
        LPCITEMIDLIST pidlLast;
        hr = SHBindToIDListParent(pns->GetIDList(), IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
        if (SUCCEEDED(hr))
        {
            // SHGetAttributes doesn't help for SFGAO_VALIDATE
            DWORD dwAttrib = SFGAO_VALIDATE;
            hr = psf->GetAttributesOf(1, &pidlLast, &dwAttrib);
            psf->Release();
        }
    }

    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc;
        hr = BindCtx_CreateWithMode(grfMode, &pbc);
        if (SUCCEEDED(hr))
        {
            hr = SHBindToObjectEx(NULL, pns->GetIDList(), pbc, IID_PPV_ARG(IStorage, ppstg));
            pbc->Release();
        }
    }
    else if (_pmfParent)
    {
        // the current pidl doesnt have the storage target namespace, so create it using our parent.
        IStorage *pstgParent;
        hr = _pmfParent->_GetDestinationStorage(grfMode, &pstgParent);
        if (SUCCEEDED(hr))
        {
            TCHAR szName[MAX_PATH];
            hr = DisplayNameOf((IShellFolder*)(void*)_pmfParent, ILFindLastID(_pidl), SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
            if (SUCCEEDED(hr))
            {
                hr = pstgParent->CreateStorage(szName, STGM_READWRITE, 0, 0, ppstg);
            }
            pstgParent->Release();
        }
    }
    return hr;
}

STDMETHODIMP CMergedFolder::_StgCreate(LPCITEMIDLIST pidl, DWORD grfMode, REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;
    // first we need to ensure that the folder exists.
    if (_pstg == NULL)
    {
        hr = _GetDestinationStorage(grfMode, &_pstg);
    }

    if (SUCCEEDED(hr))
    {
        TCHAR szName[MAX_PATH];
        hr = DisplayNameOf((IShellFolder*)(void*)this, pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
        if (SUCCEEDED(hr))
        {
            if (IsEqualIID(riid, IID_IStorage))
            {
                hr = _pstg->CreateStorage(szName, grfMode, 0, 0, (IStorage **) ppv);
            }
            else if (IsEqualIID(riid, IID_IStream))
            {
                hr = _pstg->CreateStream(szName, grfMode, 0, 0, (IStream **) ppv);
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
    }
    return hr;
}

// enumerator object

class CMergedFldrEnum : public IEnumIDList
{
public:
    // IUnknown
    STDMETHOD (QueryInterface) (REFIID, void **);
    STDMETHOD_(ULONG,AddRef)  ();
    STDMETHOD_(ULONG,Release) ();

    // IEnumIDList
    STDMETHODIMP Next(ULONG, LPITEMIDLIST*, ULONG*);
    STDMETHODIMP Skip(ULONG);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList**);

    CMergedFldrEnum(CMergedFolder*pmf, DWORD grfEnumFlags, int iPos = 0);

private:
    ~CMergedFldrEnum();

    LONG _cRef;
    CMergedFolder*_pmf;
    DWORD _grfEnumFlags;
    int _iPos;
};

CMergedFldrEnum::CMergedFldrEnum(CMergedFolder *pfm, DWORD grfEnumFlags, int iPos) : 
        _cRef(1), _iPos(iPos), _pmf(pfm), _grfEnumFlags(grfEnumFlags)
{ 
    _pmf->AddRef();
}

CMergedFldrEnum::~CMergedFldrEnum()
{
    _pmf->Release();
}

STDMETHODIMP CMergedFldrEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = { 
        QITABENT(CMergedFldrEnum, IEnumIDList), 
        { 0 } 
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CMergedFldrEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CMergedFldrEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IEnumIDList

STDMETHODIMP CMergedFldrEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    int iStart = _iPos;
    int cFetched = 0;
    HRESULT hr = S_OK;

    if (!(celt > 0 && rgelt) || (NULL == pceltFetched && celt > 1))
        return E_INVALIDARG;
    
    *rgelt = 0;

    while (hr == S_OK && (_iPos - iStart) < (int)celt)
    {
        LPITEMIDLIST pidl;
        hr = _pmf->_GetPidl(&_iPos, _grfEnumFlags, &pidl);
        if (hr == S_OK)
        {
            rgelt[cFetched] = pidl;
            cFetched++;
        }
        _iPos++;
    }
    
    if (pceltFetched)
        *pceltFetched = cFetched;
    
    return celt == (ULONG)cFetched ? S_OK : S_FALSE;
}

STDMETHODIMP CMergedFldrEnum::Skip(ULONG celt)
{
    _iPos += celt;
    return S_OK;
}

STDMETHODIMP CMergedFldrEnum::Reset()
{
    _iPos = 0;
    return S_OK;
}

STDMETHODIMP CMergedFldrEnum::Clone(IEnumIDList **ppenum)
{
    *ppenum = new CMergedFldrEnum(_pmf, _grfEnumFlags, _iPos);
    return *ppenum ? S_OK : E_OUTOFMEMORY;
}

HRESULT CMergedFldrEnum_CreateInstance(CMergedFolder*pmf, DWORD grfFlags, IEnumIDList **ppenum)
{
    CMergedFldrEnum *penum = new CMergedFldrEnum(pmf, grfFlags);
    if (!penum)
        return E_OUTOFMEMORY;

    HRESULT hr = penum->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
    penum->Release();
    return hr;
}


// Drop Target handler

class CMergedFldrDropTarget : public IDropTarget,
                              public IObjectWithSite
{
public:
    // IUnknown
    STDMETHOD (QueryInterface) (REFIID, void **);
    STDMETHOD_(ULONG,AddRef)  ();
    STDMETHOD_(ULONG,Release) ();

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown *punkSite);
    STDMETHODIMP GetSite(REFIID riid, void **ppvSite);

    CMergedFldrDropTarget(CMergedFolder*pmf, HWND hwnd);

private:
    ~CMergedFldrDropTarget();
    HRESULT _CreateOtherNameSpace(IShellFolder **ppsf);
    HRESULT _FindTargetNamespace(CMergedFldrNamespace *pnsToMatch, CMergedFldrNamespace **ppns, CMergedFldrNamespace **ppnsMatched);
    HRESULT _CreateFolder(IShellFolder *psf, LPCWSTR pszName, REFIID riid, void **ppv);
    LPITEMIDLIST _FolderIDListFromData(IDataObject *pdtobj);
    BOOL _IsCommonIDList(LPCITEMIDLIST pidlItem);
    HRESULT _SetDropEffectFolders();
    void _DestroyDropEffectFolders();

    LONG _cRef;
    CMergedFolder *_pmf;
    IDropTarget *_pdt;
    IDataObject *_pdo;
    HWND _hwnd;
    BOOL _fSrcIsCommon;          // is _pdt a common programs folder (or its child)
    LPITEMIDLIST _pidlSrcFolder;         // where the source comes from
    DWORD _grfKeyState;
    DWORD _dwDragEnterEffect;
};


CMergedFldrDropTarget::CMergedFldrDropTarget(CMergedFolder*pfm, HWND hwnd) : 
        _cRef(1), 
        _pmf(pfm), 
        _hwnd(hwnd)
{ 
    _pmf->AddRef();
}

CMergedFldrDropTarget::~CMergedFldrDropTarget()
{
    _pmf->Release();
    ASSERT(!_pdt);
    ASSERT(!_pdo);
}

STDMETHODIMP CMergedFldrDropTarget::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    { 
        QITABENT(CMergedFldrDropTarget, IDropTarget),
        QITABENT(CMergedFldrDropTarget, IObjectWithSite),
        { 0 }
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CMergedFldrDropTarget::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CMergedFldrDropTarget::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


// is this pidl in the "All Users" part of the name space
BOOL CMergedFldrDropTarget::_IsCommonIDList(LPCITEMIDLIST pidlItem)
{
    BOOL bRet = FALSE;
    LPITEMIDLIST pidlCommon;
    
    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_STARTMENU, &pidlCommon)))
    {
        bRet = ILIsParent(pidlCommon, pidlItem, FALSE);
        ILFree(pidlCommon);
    }
    if (!bRet &&
        SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_PROGRAMS, &pidlCommon)))
    {
        bRet = ILIsParent(pidlCommon, pidlItem, FALSE);
        ILFree(pidlCommon);
    }
    if (!bRet &&
        SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_DESKTOPDIRECTORY, &pidlCommon)))
    {
        bRet = ILIsParent(pidlCommon, pidlItem, FALSE);
        ILFree(pidlCommon);
    }

    return bRet;
}

LPITEMIDLIST CMergedFldrDropTarget::_FolderIDListFromData(IDataObject *pdtobj)
{
    LPITEMIDLIST pidlFolder = NULL;
    STGMEDIUM medium = {0};
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        pidlFolder = ILClone(HIDA_GetPIDLFolder(pida));
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return pidlFolder;
}

HRESULT CMergedFldrDropTarget::_CreateFolder(IShellFolder *psf, LPCWSTR pszName, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IStorage *pstg;
    HRESULT hr = psf->QueryInterface(IID_PPV_ARG(IStorage, &pstg));
    if (SUCCEEDED(hr))
    {
        DWORD grfMode = STGM_READWRITE;
        IStorage *pstgNew;
        hr = pstg->OpenStorage(pszName, NULL, grfMode, 0, 0, &pstgNew);
        if (FAILED(hr))
        {
            // try create if it's not there
            hr = pstg->CreateStorage(pszName, grfMode, 0, 0, &pstgNew);
        }
        if (SUCCEEDED(hr))
        {
            hr = pstgNew->QueryInterface(riid, ppv);
            pstgNew->Release();
        }
        pstg->Release();
    }
    return hr;
}

HRESULT CMergedFldrDropTarget::_FindTargetNamespace(CMergedFldrNamespace *pnsToMatch, CMergedFldrNamespace **ppnsDstRoot, CMergedFldrNamespace **ppnsMatched)
{
    *ppnsDstRoot = NULL;
    *ppnsMatched = NULL;

    // if the source of the drag drop is in one of our name spaces
    // we prefer that as the target name space
    for (CMergedFolder*pmf = this->_pmf; pmf && (NULL == *ppnsDstRoot); pmf = pmf->_Parent())
    {
        pmf->_FindNamespace(pnsToMatch->FolderAttrib(), pnsToMatch->FolderAttrib(), &pnsToMatch->GetGUID(), ppnsMatched);

        CMergedFldrNamespace *pns;
        for (int i = 0; (pns = pmf->_Namespace(i)) && (NULL == *ppnsDstRoot); i++)
        {
            if (pmf->_ShouldMergeNamespaces(*ppnsMatched, pns) &&
                ILFindChild(pns->GetIDList(), _pidlSrcFolder))
            {
                *ppnsDstRoot = pns;     // if the source is in one of our name spaces
            }
        }
        ASSERT(NULL != *ppnsMatched);   // pnsToMatch must exist above us

        // If merging is disabled, then we don't want parent namespaces
        // to infect us.
        if (pmf->_fDontMerge)
        {
            break;
        }
    }

    if (NULL == *ppnsDstRoot)
    {
        // if the source was not found, find the target name space based on
        // 1) if the source data is an "All Users" item find the first common _Namespace
        if (_fSrcIsCommon)
        {
            for (pmf = this->_pmf; pmf && (NULL == *ppnsDstRoot); pmf = pmf->_Parent())
            {
                pmf->_FindNamespace(pnsToMatch->FolderAttrib(), pnsToMatch->FolderAttrib(), &pnsToMatch->GetGUID(), ppnsMatched);
                pmf->_FindNamespace(ASFF_COMMON, ASFF_COMMON, NULL, ppnsDstRoot);
            }
        }

        // 2) find the first NON common name space for this guy
        for (pmf = this->_pmf; pmf && (NULL == *ppnsDstRoot); pmf = pmf->_Parent())
        {
            pmf->_FindNamespace(pnsToMatch->FolderAttrib(), pnsToMatch->FolderAttrib(), &pnsToMatch->GetGUID(), ppnsMatched);
            pmf->_FindNamespace(ASFF_COMMON, 0, NULL, ppnsDstRoot);    // search for non common items
        }
    }

    if (NULL == *ppnsMatched && NULL != *ppnsDstRoot)
    {
        delete *ppnsDstRoot;
        *ppnsDstRoot = NULL;
    }

    return *ppnsDstRoot ? S_OK : E_FAIL;
}

HRESULT CMergedFldrDropTarget::_CreateOtherNameSpace(IShellFolder **ppsf)
{
    *ppsf = NULL;

    HRESULT hr = E_FAIL;
    if (_pidlSrcFolder && 
            (!_fSrcIsCommon || AffectAllUsers(_hwnd)))
    {
        CMergedFldrNamespace *pnsDstRoot; // name space we want to create this new item in
        CMergedFldrNamespace *pnsSrc;
        CMergedFldrNamespace *pnsStart = this->_pmf->_Namespace(0);

        if (pnsStart)
        {
            hr = _FindTargetNamespace(pnsStart, &pnsDstRoot, &pnsSrc);
            if (SUCCEEDED(hr))
            {
                LPCITEMIDLIST pidlChild = ILFindChild(pnsSrc->GetIDList(), pnsStart->GetIDList());
                ASSERT(pidlChild && !ILIsEmpty(pidlChild));  // pnsSrc is a parent of pnsStart

                IShellFolder *psfDst = pnsDstRoot->Folder();
                psfDst->AddRef();

                IShellFolder *psfSrc = pnsSrc->Folder();
                psfSrc->AddRef();

                for (LPCITEMIDLIST pidl = pidlChild; !ILIsEmpty(pidl) && SUCCEEDED(hr); pidl = _ILNext(pidl))
                {
                    LPITEMIDLIST pidlFirst = ILCloneFirst(pidl);
                    if (pidlFirst)
                    {
                        WCHAR szName[MAX_PATH];
                        hr = DisplayNameOf(psfSrc, pidlFirst, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
                        if (SUCCEEDED(hr))
                        {
                            IShellFolder *psfNew;
                            hr = _CreateFolder(psfDst, szName, IID_PPV_ARG(IShellFolder, &psfNew));
                            if (SUCCEEDED(hr))
                            {
                                psfDst->Release();
                                psfDst = psfNew;
                            }
                            else
                            {
                                break;
                            }
                        }

                        // now advance to the next folder in the source name space
                        IShellFolder *psfNew;
                        hr = psfSrc->BindToObject(pidlFirst, NULL, IID_PPV_ARG(IShellFolder, &psfNew));
                        if (SUCCEEDED(hr))
                        {
                            psfSrc->Release();
                            psfSrc = psfNew;
                        }
                        else
                        {
                            break;
                        }

                        ILFree(pidlFirst);
                    }
                    else
                        hr = E_FAIL;
                }
                psfSrc->Release();

                if (SUCCEEDED(hr))
                    *ppsf = psfDst; // copy out our ref
                else
                    psfDst->Release();
            }
        }
    }
    return hr;
}

HRESULT CMergedFldrDropTarget::_SetDropEffectFolders()
{
    INT i, cFolders = 0;

    // Compute the number of folders which have special drop effects
    for (i = 0; i < _pmf->_NamespaceCount(); i++)
    {
        if (_pmf->_Namespace(i)->GetDropEffect() != 0)
            cFolders++;
    }

    // If the number is > 0 then lets add to the IDataObject the clipboard format
    // which defines this information.
    HRESULT hr = S_OK;
    if ((cFolders > 0) || (_pmf->_dwDropEffect != 0))
    {
        DWORD cb = sizeof(DROPEFFECTFOLDERLIST) + sizeof(DROPEFFECTFOLDER) * (cFolders - 1);
        DROPEFFECTFOLDERLIST *pdefl = (DROPEFFECTFOLDERLIST*)LocalAlloc(LPTR, cb);
        if (pdefl)
        {
            pdefl->cFolders = cFolders;
            pdefl->dwDefaultDropEffect = _pmf->_dwDropEffect;           // default effect for the folders.

            // fill the array backwards with the folders we have and their desired effects
            for (i = 0, cFolders--; cFolders >= 0; i++)
            {
                DWORD dwDropEffect = _pmf->_Namespace(i)->GetDropEffect();
                if (dwDropEffect != 0)
                {
                    pdefl->aFolders[cFolders].dwDropEffect = dwDropEffect;
                    StrCpyN(pdefl->aFolders[cFolders].wszPath, _pmf->_Namespace(i)->GetDropFolder(), ARRAYSIZE(pdefl->aFolders[cFolders].wszPath));
                    cFolders--;
                }
            }

            ASSERTMSG(g_cfDropEffectFolderList != 0, "Clipboard format for CFSTR_DROPEFFECTFOLDERS not registered");
            hr = DataObj_SetBlob(_pdo, g_cfDropEffectFolderList, pdefl, cb);
            LocalFree(pdefl);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

// nuke the modified drop effects
void CMergedFldrDropTarget::_DestroyDropEffectFolders()
{
    // there are no DROPEFFECTFOLDERs so subtract off the [1] array
    DWORD cb = sizeof(DROPEFFECTFOLDERLIST) - sizeof(DROPEFFECTFOLDER);
    DROPEFFECTFOLDERLIST *pdefl = (DROPEFFECTFOLDERLIST*)LocalAlloc(LPTR, cb);
    if (pdefl)
    {
        pdefl->cFolders = 0;
        pdefl->dwDefaultDropEffect = DROPEFFECT_NONE;  // means do default handling

        ASSERTMSG(g_cfDropEffectFolderList != 0, "Clipboard format for CFSTR_DROPEFFECTFOLDERS not registered");
        DataObj_SetBlob(_pdo, g_cfDropEffectFolderList, pdefl, cb);
        LocalFree(pdefl);
    }
}

HRESULT CMergedFldrDropTarget::SetSite(IUnknown *punkSite)
{
    IUnknown_SetSite(_pdt, punkSite);
    return S_OK;
}

HRESULT CMergedFldrDropTarget::GetSite(REFIID riid, void **ppvSite)
{
    return IUnknown_GetSite(_pdt, riid, ppvSite);
}

HRESULT CMergedFldrDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    ASSERT(!_fSrcIsCommon);
    ASSERT(_pdt == NULL);
    ASSERT(_pidlSrcFolder == NULL);
    ASSERT(_pdo == NULL);
    
    IUnknown_Set((IUnknown**)&_pdo, pdtobj);
    _SetDropEffectFolders();

    _pidlSrcFolder = _FolderIDListFromData(pdtobj);
    if (_pidlSrcFolder)
        _fSrcIsCommon = _IsCommonIDList(_pidlSrcFolder);

    HRESULT hr;
    CMergedFldrNamespace *pns;
    if (_fSrcIsCommon)
    {
        // if the item is comming from an "All Users" folder we want to target 
        // the common folder. if that does not exist yet then we continue on 
        // with a NULL _pdt and create that name space when the drop happens
        hr = _pmf->_FindNamespace(ASFF_COMMON, ASFF_COMMON, NULL, &pns);
    }
    else
    {
        // not "All Users" item, get the default name space (if there is one)
        hr = _pmf->_FindNamespace(ASFF_DEFNAMESPACE_VIEWOBJ, ASFF_DEFNAMESPACE_VIEWOBJ, NULL, &pns);
    }

    if (SUCCEEDED(hr) || _pmf->_fCDBurn)
    {
        if (_pmf->_fCDBurn)
        {
            IShellExtInit *psei;
            hr = CoCreateInstance(CLSID_CDBurn, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellExtInit, &psei));
            if (SUCCEEDED(hr))
            {
                hr = psei->Initialize(_pmf->_pidl, NULL, NULL);
                if (SUCCEEDED(hr))
                {
                    hr = psei->QueryInterface(IID_PPV_ARG(IDropTarget, &_pdt));
                }
                psei->Release();
            }
        }
        else
        {
            hr = pns->Folder()->CreateViewObject(_hwnd, IID_PPV_ARG(IDropTarget, &_pdt));
        }

        if (SUCCEEDED(hr))
        {
            _pdt->DragEnter(pdtobj, grfKeyState, pt, pdwEffect);
        }
    }

    _grfKeyState = grfKeyState;
    _dwDragEnterEffect = *pdwEffect;

    return S_OK;
}

HRESULT CMergedFldrDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    _grfKeyState = grfKeyState;
    return _pdt ? _pdt->DragOver(grfKeyState, pt, pdwEffect) : S_OK;
}

HRESULT CMergedFldrDropTarget::DragLeave(void)
{
    if (_pdt)
    {
        _pdt->DragLeave();
        IUnknown_SetSite(_pdt, NULL);
        IUnknown_Set((IUnknown **)&_pdt, NULL);
    }
    if (_pdo)
    {
        _DestroyDropEffectFolders();
        IUnknown_Set((IUnknown**)&_pdo, NULL);
    }

    _fSrcIsCommon = 0;
    ILFree(_pidlSrcFolder); // accepts NULL
    _pidlSrcFolder = NULL;
    return S_OK;
}

HRESULT CMergedFldrDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = S_OK;

    if (!_pdt)
    {
        // we came here because we don't have _pdt which means that
        // there is only one folder in our _Namespace and that's not
        // the one we have to drop on. so we need to create it now

        IShellFolder *psf;
        hr = _CreateOtherNameSpace(&psf);
        if (SUCCEEDED(hr))
        {
            hr = psf->CreateViewObject(_hwnd, IID_PPV_ARG(IDropTarget, &_pdt));
            if (SUCCEEDED(hr))
                _pdt->DragEnter(pdtobj, _grfKeyState, pt, &_dwDragEnterEffect);
            psf->Release();
        }
    }

    if (_pdt)
    {
        hr = _pdt->Drop(pdtobj, grfKeyState, pt, pdwEffect);
        DragLeave();
    }
    return S_OK;
}

HRESULT CMergedFldrDropTarget_CreateInstance(CMergedFolder*pmf, HWND hwndOwner, IDropTarget **ppdt)
{
    CMergedFldrDropTarget *pdt = new CMergedFldrDropTarget(pmf, hwndOwner);
    if (!pdt)
        return E_OUTOFMEMORY;

    HRESULT hr = pdt->QueryInterface(IID_PPV_ARG(IDropTarget, ppdt));
    pdt->Release();
    return hr;
}


// context menu handling.

class CMergedFldrContextMenu : public IContextMenu3,
                               public IObjectWithSite
{
public:
    // IUnknown
    STDMETHOD (QueryInterface)(REFIID, void**);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT* pwReserved, LPSTR pszName, UINT cchMax);

    // IContextMenu2    
    STDMETHODIMP HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IContextMenu3
    STDMETHODIMP HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown *punkSite);
    STDMETHODIMP GetSite(REFIID riid, void **ppvSite);

    CMergedFldrContextMenu(HWND hwnd, IContextMenu *pcmCommon, IContextMenu *pcmUser);

private:
    ~CMergedFldrContextMenu();

    HRESULT _Initialize(CMergedFolder *pmf, UINT cidl, LPCITEMIDLIST *apidl);
    BOOL _IsMergedCommand(LPCMINVOKECOMMANDINFO pici);
    HRESULT _InvokeCanonical(IContextMenu *pcm, LPCMINVOKECOMMANDINFO pici);
    HRESULT _InvokeMergedCommand(LPCMINVOKECOMMANDINFO pici);
    IContextMenu* _DefaultMenu();

    LONG            _cRef;
    IContextMenu *  _pcmCommon;
    IContextMenu *  _pcmUser;
    UINT            _cidl;
    LPITEMIDLIST   *_apidl;
    CMergedFolder  *_pmfParent;
    UINT            _idFirst;
    HWND            _hwnd;

    friend HRESULT CMergedFldrContextMenu_CreateInstance(HWND hwnd, CMergedFolder *pmf, UINT cidl, LPCITEMIDLIST *apidl, IContextMenu *pcmCommon, IContextMenu *pcmUser, IContextMenu **ppcm);
};

CMergedFldrContextMenu::CMergedFldrContextMenu(HWND hwnd, IContextMenu *pcmCommon, IContextMenu *pcmUser)
{
    ASSERT(pcmCommon || pcmUser);   // need at least one of these

    _cRef = 1;
    _hwnd = hwnd;

    IUnknown_Set((IUnknown **)&_pcmCommon, pcmCommon);
    IUnknown_Set((IUnknown **)&_pcmUser, pcmUser);
}

CMergedFldrContextMenu::~CMergedFldrContextMenu()
{
    ATOMICRELEASE(_pcmCommon);
    ATOMICRELEASE(_pcmUser);
    ATOMICRELEASE(_pmfParent);

    for (UINT i = 0; i < _cidl; i++)
    {
        ILFree(_apidl[i]);
    }
}

IContextMenu* CMergedFldrContextMenu::_DefaultMenu()
{
    ASSERT(_pcmUser || _pcmCommon);   // need at least one of these; this is pretty much guaranteed since we're given them
                                      // at constructor time.
    return _pcmUser ? _pcmUser : _pcmCommon;
}

HRESULT CMergedFldrContextMenu::_Initialize(CMergedFolder *pmf, UINT cidl, LPCITEMIDLIST *apidl)
{
    _pmfParent = pmf;
    if (_pmfParent)
    {
        _pmfParent->AddRef();
    }

    HRESULT hr = E_OUTOFMEMORY;
    LPITEMIDLIST *apidlNew = new LPITEMIDLIST[cidl];
    if (apidlNew)
    {
        hr = S_OK;
        for (UINT i = 0; SUCCEEDED(hr) && i < cidl; i++)
        {
            hr = SHILClone(apidl[i], &(apidlNew[i]));
        }

        if (SUCCEEDED(hr))
        {
            _apidl = apidlNew;
            _cidl = cidl;
        }
        else
        {
            for (i = 0; i < cidl; i++)
            {
                ILFree(apidlNew[i]);
            }
            delete [] apidlNew;
        }
    }
    return hr;
}

STDMETHODIMP CMergedFldrContextMenu::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CMergedFldrContextMenu, IContextMenu,  IContextMenu3),
        QITABENTMULTI(CMergedFldrContextMenu, IContextMenu2, IContextMenu3),
        QITABENT(CMergedFldrContextMenu, IContextMenu3),
        QITABENT(CMergedFldrContextMenu, IObjectWithSite),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CMergedFldrContextMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CMergedFldrContextMenu::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CMergedFldrContextMenu::SetSite(IUnknown *punkSite)
{
    // setsite/getsite will always be matched because _pcmUser and _pcmCommon never change
    // after the constructor is called.
    IUnknown_SetSite(_DefaultMenu(), punkSite);
    return S_OK;
}

HRESULT CMergedFldrContextMenu::GetSite(REFIID riid, void **ppvSite)
{
    return IUnknown_GetSite(_DefaultMenu(), riid, ppvSite);
}

HRESULT CMergedFldrContextMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HRESULT hr;
    
    if (_pmfParent->_fInShellView)
    {
        hr = _DefaultMenu()->QueryContextMenu(hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);
    }
    else
    {
        if (hmenu)
        {
            HMENU hmContext = SHLoadMenuPopup(HINST_THISDLL, MENU_SM_CONTEXTMENU);
            if (hmContext)
            {
                int i;

                if (!_pcmCommon || !_pcmUser)
                {
                    DeleteMenu(hmContext, SMIDM_OPENCOMMON, MF_BYCOMMAND);
                    DeleteMenu(hmContext, SMIDM_EXPLORECOMMON, MF_BYCOMMAND);
                }

                _idFirst = idCmdFirst;
                i = Shell_MergeMenus(hmenu, hmContext, -1, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
                DestroyMenu(hmContext);

                // Make it look "Shell Like"
                SetMenuDefaultItem(hmenu, 0, MF_BYPOSITION);

                hr = ResultFromShort(i);
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_INVALIDARG;
    }
    
    return hr;
}

BOOL CMergedFldrContextMenu::_IsMergedCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = S_OK;
    WCHAR szVerb[32];
    if (!IS_INTRESOURCE(pici->lpVerb))
    {
        lstrcpyn(szVerb, (LPCWSTR)pici->lpVerb, ARRAYSIZE(szVerb));
    }
    else
    {
        hr = _DefaultMenu()->GetCommandString((UINT_PTR)pici->lpVerb, GCS_VERBW, NULL, (LPSTR)szVerb, ARRAYSIZE(szVerb));
    }

    BOOL fRet = FALSE;
    if (SUCCEEDED(hr))
    {
        if ((lstrcmpi(szVerb, c_szOpen) == 0) ||
            (lstrcmpi(szVerb, c_szExplore) == 0))
        {
            fRet = TRUE;
        }
    }
    return fRet;
}

HRESULT CMergedFldrContextMenu::_InvokeMergedCommand(LPCMINVOKECOMMANDINFO pici)
{
    // this code is mostly to navigate into folders from the shell view.
    // the reason why we have to do this manually is because the context menus for
    // the different namespaces have dataobjects which refer only to one namespace.
    // when the navigate happens, that means we get passed bogus non-merged pidls
    // into our BindToObject which screws things up.
    ASSERT(_pmfParent->_fInShellView);

    BOOL fHasFolders = FALSE;
    BOOL fHasNonFolders = FALSE;
    for (UINT i = 0; i < _cidl; i++)
    {
        if (_pmfParent->_IsFolder(_apidl[i]))
        {
            fHasFolders = TRUE;
        }
        else
        {
            fHasNonFolders = TRUE;
        }
    }

    HRESULT hr;
    if (fHasFolders && _IsMergedCommand(pici))
    {
        if (!fHasNonFolders)
        {
            // reinit the defcm with a new dataobject
            IShellExtInit *psei;
            hr = _DefaultMenu()->QueryInterface(IID_PPV_ARG(IShellExtInit, &psei));
            if (SUCCEEDED(hr))
            {
                IDataObject *pdo;
                hr = SHCreateFileDataObject(_pmfParent->_pidl, _cidl, (LPCITEMIDLIST *)_apidl, NULL, &pdo);
                if (SUCCEEDED(hr))
                {
                    hr = psei->Initialize(_pmfParent->_pidl, pdo, NULL);
                    if (SUCCEEDED(hr))
                    {
                        hr = _DefaultMenu()->InvokeCommand(pici);
                    }
                    pdo->Release();
                }
                psei->Release();
            }
        }
        else
        {
            // to open both folders and items simultaneously means we'd have to
            // get a new context menu for just the items.
            // we can do this if this scenario comes up.
            hr = E_FAIL;
        }
    }
    else
    {
        hr = _DefaultMenu()->InvokeCommand(pici);
    }

    return hr;
}

const ICIVERBTOIDMAP c_sIDVerbMap[] = 
{
    { L"delete",     "delete",     SMIDM_DELETE,     SMIDM_DELETE,     },
    { L"rename",     "rename",     SMIDM_RENAME,     SMIDM_RENAME,     },
    { L"properties", "properties", SMIDM_PROPERTIES, SMIDM_PROPERTIES, },
};

HRESULT CMergedFldrContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = E_FAIL;
    CMINVOKECOMMANDINFOEX ici = {0};

    memcpy(&ici, pici, min(sizeof(ici), pici->cbSize));
    ici.cbSize = sizeof(ici);

    if (_pmfParent->_fInShellView)
    {
        hr = _InvokeMergedCommand((LPCMINVOKECOMMANDINFO)&ici);
    }
    else
    {
        UINT id;
        hr = SHMapICIVerbToCmdID((LPCMINVOKECOMMANDINFO)&ici, c_sIDVerbMap, ARRAYSIZE(c_sIDVerbMap), &id);
        if (SUCCEEDED(hr))
        {
            // The below sets an ansi verb only, make sure no lpVerbW is used
            ici.fMask &= (~CMIC_MASK_UNICODE);

            switch (id)
            {
            case SMIDM_OPEN:
            case SMIDM_EXPLORE:
            case SMIDM_OPENCOMMON:
            case SMIDM_EXPLORECOMMON:
                {
                    ASSERT(!_pmfParent->_fInShellView);

                    IContextMenu * pcm;
                    if (id == SMIDM_OPEN || id == SMIDM_EXPLORE)
                    {
                        pcm = _DefaultMenu();
                    }
                    else
                    {
                        pcm = _pcmCommon;
                    }

                    hr = SHInvokeCommandOnContextMenu(ici.hwnd, NULL, pcm, ici.fMask,
                            (id == SMIDM_EXPLORE || id == SMIDM_EXPLORECOMMON) ? "explore" : "open");
                }
                break;
            
            case SMIDM_PROPERTIES:
                hr = SHInvokeCommandOnContextMenu(ici.hwnd, NULL, _DefaultMenu(), ici.fMask, "properties");
                break;
            
            case SMIDM_DELETE:
                ici.lpVerb = "delete";
                if (_pcmUser)
                {
                    hr = SHInvokeCommandOnContextMenu(ici.hwnd, NULL, _pcmUser, ici.fMask, "delete");
                }
                else
                {
                    ASSERT(_pcmCommon);

                    ici.fMask |= CMIC_MASK_FLAG_NO_UI;
                    if (AffectAllUsers(_hwnd))
                        hr = SHInvokeCommandOnContextMenu(ici.hwnd, NULL, _pcmCommon, ici.fMask, "delete");   
                    else
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                }   
            
                break;
            
            case SMIDM_RENAME:
                ASSERT(0);
                hr = E_NOTIMPL; // sftbar picks this off
                break;

            default:
                ASSERTMSG(FALSE, "shouldn't have unknown command");
                hr = E_INVALIDARG;
            }
        }
    }
    
    return hr;
}

HRESULT CMergedFldrContextMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT* pwReserved, LPSTR pszName, UINT cchMax)
{
    HRESULT hr = E_NOTIMPL;

    switch (uType)
    {
    case GCS_VERBA:
    case GCS_VERBW:
        hr = SHMapCmdIDToVerb(idCmd, c_sIDVerbMap, ARRAYSIZE(c_sIDVerbMap), pszName, cchMax, GCS_VERBW == uType);
    }

    if (FAILED(hr))
    {
        hr = _DefaultMenu()->GetCommandString(idCmd, uType, pwReserved, pszName, cchMax);
    }

    return hr;
}

HRESULT CMergedFldrContextMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;
    if (_pmfParent->_fInShellView)
    {
        IContextMenu2 *pcm2;
        hr = _DefaultMenu()->QueryInterface(IID_PPV_ARG(IContextMenu2, &pcm2));
        if (SUCCEEDED(hr))
        {
            hr = pcm2->HandleMenuMsg(uMsg, wParam, lParam);
            pcm2->Release();
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }
    return hr;
}

HRESULT CMergedFldrContextMenu::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    HRESULT hr;
    if (_pmfParent->_fInShellView)
    {
        IContextMenu3 *pcm3;
        hr = _DefaultMenu()->QueryInterface(IID_PPV_ARG(IContextMenu3, &pcm3));
        if (SUCCEEDED(hr))
        {
            hr = pcm3->HandleMenuMsg2(uMsg, wParam, lParam, plResult);
            pcm3->Release();
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }
    return hr;
}

HRESULT CMergedFldrContextMenu_CreateInstance(HWND hwnd, CMergedFolder *pmf, UINT cidl, LPCITEMIDLIST *apidl, IContextMenu *pcmCommon, IContextMenu *pcmUser, IContextMenu **ppcm)
{
    HRESULT hr = E_OUTOFMEMORY;
    CMergedFldrContextMenu* pcm = new CMergedFldrContextMenu(hwnd, pcmCommon, pcmUser);
    if (pcm)
    {
        hr = pcm->_Initialize(pmf, cidl, apidl);
        if (SUCCEEDED(hr))
        {
            hr = pcm->QueryInterface(IID_PPV_ARG(IContextMenu, ppcm));
        }
        pcm->Release();
    }
    return hr;
}

class CMergedCategorizer : public ICategorizer,
                           public IShellExtInit
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICategorizer
    STDMETHODIMP GetDescription(LPWSTR pszDesc, UINT cch);
    STDMETHODIMP GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds);
    STDMETHODIMP GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci);
    STDMETHODIMP CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2);

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID);

    CMergedCategorizer();
private:
    ~CMergedCategorizer();
    long _cRef;
    CMergedFolder *_pmf;
};

//  Type Categorizer

STDAPI CMergedCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CMergedCategorizer *pmc = new CMergedCategorizer();
    if (pmc)
    {
        hr = pmc->QueryInterface(riid, ppv);
        pmc->Release();
    }
    return hr;
}

CMergedCategorizer::CMergedCategorizer() : 
    _cRef(1)
{
}

CMergedCategorizer::~CMergedCategorizer()
{
    ATOMICRELEASE(_pmf);
}

HRESULT CMergedCategorizer::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CMergedCategorizer, ICategorizer),
        QITABENT(CMergedCategorizer, IShellExtInit),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CMergedCategorizer::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CMergedCategorizer::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CMergedCategorizer::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID)
{
    ATOMICRELEASE(_pmf);
    return SHBindToObjectEx(NULL, pidlFolder, NULL, CLSID_MergedFolder, (void**)&_pmf);
}

HRESULT CMergedCategorizer::GetDescription(LPWSTR pszDesc, UINT cch)
{
    LoadString(HINST_THISDLL, IDS_WHICHFOLDER_COL, pszDesc, cch);
    return S_OK;
}

HRESULT CMergedCategorizer::GetCategory(UINT cidl, LPCITEMIDLIST *apidl, DWORD *rgCategoryIds)
{
    HRESULT hr = E_ACCESSDENIED;

    if (_pmf)
    {
        for (UINT i = 0; i < cidl; i++)
        {
            rgCategoryIds[i] = -1;
            CMergedFldrNamespace *pns;
            UINT uSrcID;
            for (UINT j = 0; SUCCEEDED(_pmf->_GetSubPidl(apidl[i], j, &uSrcID, NULL, &pns)); j++)
            {
                if (_pmf->_ShouldSuspend(pns->GetGUID()))
                {
                    continue;
                }
                rgCategoryIds[i] = uSrcID;
                if (ASFF_DEFNAMESPACE_ATTRIB & pns->FolderAttrib())
                {
                    // if we have more than one, keep the one from the defnamespace for attrib.
                    break;
                }
            }
        }

        hr = S_OK;
    }

    return hr;
}

HRESULT CMergedCategorizer::GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci)
{
    CMergedFldrNamespace *pns;
    HRESULT hr = _pmf->_Namespace(dwCategoryId, &pns);
    if (SUCCEEDED(hr))
    {
        hr = pns->GetLocation(pci->wszName, ARRAYSIZE(pci->wszName));
    }
    return hr;
}

HRESULT CMergedCategorizer::CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2)
{
    if (dwCategoryId1 == dwCategoryId2)
        return ResultFromShort(0);
    else if (dwCategoryId1 > dwCategoryId2)
        return ResultFromShort(-1);
    else
        return ResultFromShort(1);
}


#define NORMALEVENTS (SHCNE_RENAMEITEM | SHCNE_RENAMEFOLDER | SHCNE_CREATE | SHCNE_DELETE | SHCNE_UPDATEDIR | SHCNE_UPDATEITEM | SHCNE_MKDIR | SHCNE_RMDIR)
#define CDBURNEVENTS (SHCNE_MEDIAREMOVED | SHCNE_MEDIAINSERTED)
CMergedFolderViewCB::CMergedFolderViewCB(CMergedFolder *pmf) :
    CBaseShellFolderViewCB(pmf->_pidl, (pmf->_fCDBurn) ? CDBURNEVENTS|NORMALEVENTS : NORMALEVENTS),
    _pmf(pmf)
{
    _pmf->AddRef();
}

CMergedFolderViewCB::~CMergedFolderViewCB()
{
    _pmf->Release();
}

HRESULT CMergedFolderViewCB::_RefreshObjectsWithSameName(IShellFolderView *psfv, LPITEMIDLIST pidl)
{
    TCHAR szName[MAX_PATH];
    HRESULT hr = DisplayNameOf(SAFECAST(_pmf, IShellFolder2 *), pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
    if (SUCCEEDED(hr))
    {
        CMergedFldrNamespace *pns;
        for (int i = 0; SUCCEEDED(hr) && (pns = _pmf->_Namespace(i)); i++)
        {
            LPITEMIDLIST pidlItem;
            if (SUCCEEDED(pns->Folder()->ParseDisplayName(NULL, NULL, szName, NULL, &pidlItem, NULL)))
            {
                LPITEMIDLIST pidlItemWrap;
                hr = _pmf->_CreateWrap(pidlItem, i, &pidlItemWrap);
                if (SUCCEEDED(hr))
                {
                    UINT uItem;
                    hr = psfv->UpdateObject(pidlItemWrap, pidlItemWrap, &uItem);
                    ILFree(pidlItemWrap);
                }
                ILFree(pidlItem);
            }
        }
    }
    return hr;
}

HRESULT CMergedFolderViewCB::_OnFSNotify(DWORD pv, LPCITEMIDLIST *ppidl, LPARAM lp)
{
    // bail out early if we're merging.
    // S_OK indicates to defview to do what it usually does
    if (!_pmf->_fDontMerge)
        return S_OK;

    IShellFolderView *psfv;
    HRESULT hr = IUnknown_GetSite(SAFECAST(this, IShellFolderViewCB*), IID_PPV_ARG(IShellFolderView, &psfv));
    if (SUCCEEDED(hr))
    {
        LONG lEvent = (LONG) lp;
        LPITEMIDLIST pidl1 = ppidl[0] ? ILFindChild(_pidl, ppidl[0]) : NULL;
        LPITEMIDLIST pidl2 = ppidl[1] ? ILFindChild(_pidl, ppidl[1]) : NULL;

        UINT uItem;
        switch (lEvent)
        {
            case SHCNE_RENAMEFOLDER:
            case SHCNE_RENAMEITEM:
                // we need to handle the in/out for the view
                if (pidl1 && pidl2)
                {
                    if (SUCCEEDED(psfv->UpdateObject(pidl1, pidl2, &uItem)))
                        hr = S_FALSE;
                    _RefreshObjectsWithSameName(psfv, pidl1);
                    _RefreshObjectsWithSameName(psfv, pidl2);
                }
                else if (pidl1)
                {
                    if (SUCCEEDED(psfv->RemoveObject(pidl1, &uItem)))
                        hr = S_FALSE;
                    _RefreshObjectsWithSameName(psfv, pidl1);
                }
                else if (pidl2)
                {
                    if (SUCCEEDED(psfv->AddObject(pidl2, &uItem)))
                        hr = S_FALSE;
                    _RefreshObjectsWithSameName(psfv, pidl2);
                }
                break;

            case SHCNE_CREATE:
            case SHCNE_MKDIR:
                ASSERTMSG(pidl1 != NULL, "incoming notify should be child of _pidl because thats what we were listening for");
                if (SUCCEEDED(psfv->AddObject(pidl1, &uItem)))
                    hr = S_FALSE;
                _RefreshObjectsWithSameName(psfv, pidl1);
                break;

            case SHCNE_DELETE:
            case SHCNE_RMDIR: 
                ASSERTMSG(pidl1 != NULL, "incoming notify should be child of _pidl because thats what we were listening for");
                if (SUCCEEDED(psfv->RemoveObject(pidl1, &uItem)))
                    hr = S_FALSE;
                _RefreshObjectsWithSameName(psfv, pidl1);
                break;

            default:
                break;
        }

        psfv->Release();
    }
    return hr;
}

STDMETHODIMP CMergedFolderViewCB::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(0, SFVM_FSNOTIFY, _OnFSNotify);

    default:
        return E_NOTIMPL;
    }
    return S_OK;
}

HRESULT CMergedFolderViewCB_CreateInstance(CMergedFolder *pmf, IShellFolderViewCB **ppsfvcb)
{
    HRESULT hr = E_OUTOFMEMORY;
    CMergedFolderViewCB *pcmfvcb = new CMergedFolderViewCB(pmf);
    if (pcmfvcb)
    {
        hr = pcmfvcb->QueryInterface(IID_PPV_ARG(IShellFolderViewCB, ppsfvcb));
        pcmfvcb->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mkhelp.cpp ===
#include "shellprv.h"
//#include "mkhelp.h"
#include "urlmon.h"
#include "ids.h"

class CBSCLocalCopyHelper :   public IBindStatusCallback,
                            public IAuthenticate
{
public:
    CBSCLocalCopyHelper(IBindCtx *pbc, BOOL fWebfolders);

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef () ;
    STDMETHODIMP_(ULONG) Release ();

    // *** IAuthenticate ***
    virtual STDMETHODIMP Authenticate(
        HWND *phwnd,
        LPWSTR *pszUsername,
        LPWSTR *pszPassword);

    // *** IBindStatusCallback ***
    virtual STDMETHODIMP OnStartBinding(
        /* [in] */ DWORD grfBSCOption,
        /* [in] */ IBinding *pib);

    virtual STDMETHODIMP GetPriority(
        /* [out] */ LONG *pnPriority);

    virtual STDMETHODIMP OnLowResource(
        /* [in] */ DWORD reserved);

    virtual STDMETHODIMP OnProgress(
        /* [in] */ ULONG ulProgress,
        /* [in] */ ULONG ulProgressMax,
        /* [in] */ ULONG ulStatusCode,
        /* [in] */ LPCWSTR szStatusText);

    virtual STDMETHODIMP OnStopBinding(
        /* [in] */ HRESULT hresult,
        /* [in] */ LPCWSTR szError);

    virtual STDMETHODIMP GetBindInfo(
        /* [out] */ DWORD *grfBINDINFOF,
        /* [unique][out][in] */ BINDINFO *pbindinfo);

    virtual STDMETHODIMP OnDataAvailable(
        /* [in] */ DWORD grfBSCF,
        /* [in] */ DWORD dwSize,
        /* [in] */ FORMATETC *pformatetc,
        /* [in] */ STGMEDIUM *pstgmed);

    virtual STDMETHODIMP OnObjectAvailable(
        /* [in] */ REFIID riid,
        /* [iid_is][in] */ IUnknown *punk);


protected:
    ~CBSCLocalCopyHelper();

    long _cRef;
    IBinding *_pib;

    IProgressDialog *_pdlg;
    HWND _hwnd;

    BOOL _fRosebudMagic;
};

CBSCLocalCopyHelper::CBSCLocalCopyHelper(IBindCtx *pbc, BOOL fWebfolders) 
    : _cRef(1) , _fRosebudMagic(fWebfolders)
{
    //  we should use the pbc to 
    //  get our simpler uiprogress
    //  interface.  but for now
    //  we will do nothing
}

CBSCLocalCopyHelper::~CBSCLocalCopyHelper()
{
    ATOMICRELEASE(_pib);
    ATOMICRELEASE(_pdlg);

    //  NOTE dont need to release _ppstm because we dont own it
}

STDMETHODIMP CBSCLocalCopyHelper::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CBSCLocalCopyHelper, IBindStatusCallback),
        QITABENT(CBSCLocalCopyHelper, IAuthenticate),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CBSCLocalCopyHelper::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CBSCLocalCopyHelper::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CBSCLocalCopyHelper::Authenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword)
{
    if (ppszUsername)
        *ppszUsername = NULL;
    if (ppszPassword)
        *ppszPassword = NULL;
        
    *phwnd = GetLastActivePopup(_hwnd);

    return *phwnd ? S_OK : E_FAIL;
}

STDMETHODIMP CBSCLocalCopyHelper::OnStartBinding(DWORD dwReserved,IBinding *pib)
{
    ATOMICRELEASE(_pib);
    if (pib)
    {
        pib->AddRef();
        _pib = pib;
    }

    if (_pdlg)
    {
        WCHAR sz[MAX_PATH];
        //  we are starting out here
        _pdlg->Timer(PDTIMER_RESET, NULL);
        _pdlg->SetProgress(0, 0);
        LoadStringW(HINST_THISDLL, IDS_ACCESSINGMONIKER, sz, ARRAYSIZE(sz));
        _pdlg->SetLine(1, sz, FALSE, NULL);
    }
    
    return S_OK;
}

STDMETHODIMP CBSCLocalCopyHelper::GetPriority(LONG *pnPriority)
{
    if (pnPriority)
    {
        //  we are a blocking UI thread
        *pnPriority = THREAD_PRIORITY_ABOVE_NORMAL;
    }
    return S_OK;
}

STDMETHODIMP CBSCLocalCopyHelper::OnLowResource(DWORD reserved)
{
    return S_OK;
}

STDMETHODIMP CBSCLocalCopyHelper::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR pszStatusText)
{
    HRESULT hr = S_OK;
    //  handle UI udpates
    if (_pdlg)
    {
        if (_pdlg->HasUserCancelled())
        {
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
        
        if (ulProgressMax)
        {
            _pdlg->SetProgress(ulProgress, ulProgressMax);
        }

        if (pszStatusText)
            _pdlg->SetLine(1, pszStatusText, FALSE, NULL);
    }
    
    return hr;
}

STDMETHODIMP CBSCLocalCopyHelper::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    //  handle something
    ATOMICRELEASE(_pib);
    return S_OK;
}

STDMETHODIMP CBSCLocalCopyHelper::GetBindInfo(DWORD *grfBINDINFOF, BINDINFO *pbindinfo)
{
    if (_fRosebudMagic && pbindinfo)
    {
        //  this is the magic number that says its ok for URLMON to use DAV/rosebud/webfolders.
        //  we dont need this during download and in fact if we 
        //  set it, we may not be able to retrieve the resource.
        //  we coudl do some kind of check on the moniker to verify the clsid
        //  comes from URLMON.  right now this is how office handles 
        //  all of its requests so we do too.
        pbindinfo->dwOptions = 1;
    }

    if (grfBINDINFOF)
    {
        *grfBINDINFOF = BINDF_GETFROMCACHE_IF_NET_FAIL | BINDF_GETNEWESTVERSION;
    }

    return S_OK;
}

STDMETHODIMP CBSCLocalCopyHelper::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
{
    return S_OK;
}

STDMETHODIMP CBSCLocalCopyHelper::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    return E_UNEXPECTED;
}

HRESULT _CreateUrlmonBindCtx(IBindCtx *pbcIn, BOOL fWebfolders, IBindCtx **ppbc, IBindStatusCallback **ppbsc)
{
    IBindCtx *pbc;
    HRESULT hr = CreateBindCtx(0, &pbc);
    *ppbc = NULL;
    *ppbsc = NULL;

    if (SUCCEEDED(hr))
    {
        IBindStatusCallback *pbsc = (IBindStatusCallback *) new CBSCLocalCopyHelper(pbcIn, fWebfolders);
        if (pbsc)
        {
            //  maybe we should attach it to the existing 
            //  pbc, but for now we will create a new one.
            hr = RegisterBindStatusCallback(pbc, pbsc, NULL, 0);

            if (SUCCEEDED(hr))
            {
                BIND_OPTS bo = {0};
                bo.cbStruct = SIZEOF(bo);
                bo.grfMode = BindCtx_GetMode(pbcIn, STGM_READ);

                //
                //  on webfolders, (and possibly other URLMON
                //  monikers), if you are attempting to create a 
                //  writable stream you also need to pass STGM_CREATE
                //  even if the file you are writing to already exists.
                //
                if (bo.grfMode & (STGM_WRITE | STGM_READWRITE))
                    bo.grfMode |= STGM_CREATE;
                
                hr = pbc->SetBindOptions(&bo);
            }
        }
        else
            hr = E_OUTOFMEMORY;


        if (SUCCEEDED(hr))
        {
            *ppbc = pbc;
            *ppbsc = pbsc;
        }
        else
        {
            pbc->Release();
            if (pbsc)
                pbsc->Release();
        }
    }

    return hr;
}

static const GUID CLSID_WEBFOLDERS = // {BDEADF00-C265-11D0-BCED-00A0C90AB50F}
    { 0xBDEADF00, 0xC265, 0x11D0, { 0xBC, 0xED, 0x00, 0xA0, 0xC9, 0x0A, 0xB5, 0x0F} };

BOOL _IsWebfolders(IShellItem *psi)
{
    BOOL fRet = FALSE;
    IShellItem *psiParent;
    HRESULT hr = psi->GetParent(&psiParent);

    if (SUCCEEDED(hr))
    {
        IShellFolder *psf;
        SFGAOF flags = SFGAO_LINK;
        if (SUCCEEDED(psiParent->GetAttributes(flags, &flags))
        && (flags & SFGAO_LINK))
        {
            //  this is a folder shortcut that needs derefing
            IShellItem *psiTarget;
            hr = psiParent->BindToHandler(NULL, BHID_LinkTargetItem, IID_PPV_ARG(IShellItem, &psiTarget));

            if (SUCCEEDED(hr))
            {
                //  switcheroo
                psiParent->Release();
                psiParent = psiTarget;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = psiParent->BindToHandler(NULL, BHID_SFObject, IID_PPV_ARG(IShellFolder, &psf));

            if (SUCCEEDED(hr))
            {
                CLSID clsid;
                if (SUCCEEDED(IUnknown_GetClassID(psf, &clsid)))
                    fRet = IsEqualGUID(clsid, CLSID_WEBFOLDERS);

                psf->Release();
            }
        }
        
        psiParent->Release();
    }

    return fRet;
}

HRESULT _CreateStorageHelper(IShellItem *psi, IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv)
{
    IMoniker *pmk;
    HRESULT hr = psi->BindToHandler(pbc, BHID_SFObject, IID_PPV_ARG(IMoniker, &pmk));

    if (SUCCEEDED(hr))
    {
        IBindCtx *pbcMk;
        IBindStatusCallback *pbsc;
        hr = _CreateUrlmonBindCtx(pbc, _IsWebfolders(psi), &pbcMk, &pbsc);
        if (SUCCEEDED(hr))
        {
            hr = pmk->BindToStorage(pbcMk, NULL, riid, ppv);
            // urlmon + ftp url can cause this.  remove when 3140245 is fixed
            if (SUCCEEDED(hr) && NULL == *ppv)
                hr = E_FAIL;

            RevokeBindStatusCallback(pbcMk, pbsc);
                
            pbcMk->Release();
            pbsc->Release();
        }
    }

    return hr;
}

EXTERN_C WINSHELLAPI HRESULT STDAPICALLTYPE SHCopyMonikerToTemp(IMoniker *pmk, LPCWSTR pszIn, LPWSTR pszOut, int cchOut)
{
    //  REMOVE this as soon as ComDlg32 is updated
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mountvol.cpp ===
//   Implements Mounted Volume

#include "shellprv.h"
#include "clsobj.h"

EXTERN_C CLIPFORMAT g_cfMountedVolume = 0;

class CMountedVolume : public IMountedVolume, IDataObject
{
public:
    //IUnknown methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    //IDataObject methods
    STDMETHODIMP GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium);
    STDMETHODIMP GetDataHere(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium);
    STDMETHODIMP QueryGetData(LPFORMATETC pformatetcIn);
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC pformatetc, LPFORMATETC pformatetcOut);
    STDMETHODIMP SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppenumFormatEtc);
    STDMETHODIMP DAdvise(FORMATETC *pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD *pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *ppenumAdvise);

    // IMountedVolume methods
    STDMETHODIMP Initialize(LPCWSTR pcszMountPoint);
protected:
    CMountedVolume();
    ~CMountedVolume();

    friend HRESULT CMountedVolume_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv);

private:
    LONG _cRef;
    TCHAR _szMountPoint[MAX_PATH];
};

//constructor/destructor and related functions

CMountedVolume::CMountedVolume() :
    _cRef(1)
{
    _szMountPoint[0] = 0;
    DllAddRef();
}

CMountedVolume::~CMountedVolume()
{
    DllRelease();
}

STDAPI CMountedVolume_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppv = NULL;
    
    if (!g_cfMountedVolume)
        g_cfMountedVolume = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_MOUNTEDVOLUME);

    // aggregation checking is handled in class factory
    CMountedVolume* pMountedVolume = new CMountedVolume();
    if (pMountedVolume)
    {
        hr = pMountedVolume->QueryInterface(riid, ppv);
        pMountedVolume->Release();
    }

    return hr;
}

//IUnknown handling

STDMETHODIMP CMountedVolume::QueryInterface(REFIID riid,void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CMountedVolume, IDataObject),
        QITABENT(CMountedVolume, IMountedVolume),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CMountedVolume::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CMountedVolume::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

#define GETDATA_BUFSIZE MAX_PATH

//IDataObject handling
STDMETHODIMP CMountedVolume::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
    HRESULT hr = E_FAIL;

    //make sure IMountedVolume::Initialize was called
    if (TEXT('\0') != _szMountPoint[0])
    {
        pmedium->hGlobal = NULL;
        pmedium->pUnkForRelease = NULL;
        pmedium->tymed = TYMED_HGLOBAL;

        if ((g_cfMountedVolume == pformatetcIn->cfFormat) && (TYMED_HGLOBAL & pformatetcIn->tymed))
        {
            pmedium->hGlobal = GlobalAlloc(GPTR, (GETDATA_BUFSIZE + 1) * SIZEOF(TCHAR) + SIZEOF(DROPFILES));

            if (pmedium->hGlobal)
            {
                LPDROPFILES pdf = (LPDROPFILES)pmedium->hGlobal;
                LPTSTR pszMountPoint = (LPTSTR)(pdf + 1);
                pdf->pFiles = SIZEOF(DROPFILES);
                ASSERT(pdf->pt.x==0);
                ASSERT(pdf->pt.y==0);
                ASSERT(pdf->fNC==FALSE);
                ASSERT(pdf->fWide==FALSE);
        #ifdef UNICODE
                pdf->fWide = TRUE;
        #endif
                //do the copy
                hr = StringCchCopy(pszMountPoint, GETDATA_BUFSIZE, _szMountPoint);
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }
    else
        ASSERTMSG(0, "IMountedVolume::Initialize was NOT called prior to IMountedVolume::GetData");

    return hr;
}

STDMETHODIMP CMountedVolume::QueryGetData(LPFORMATETC pformatetcIn)
{
    HRESULT hr = S_FALSE;

    if ((g_cfMountedVolume == pformatetcIn->cfFormat) && (TYMED_HGLOBAL & pformatetcIn->tymed))
        hr = S_OK;

    return hr;
}

STDMETHODIMP CMountedVolume::SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMountedVolume::GetDataHere(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium )
{
    return E_NOTIMPL;
}

STDMETHODIMP CMountedVolume::GetCanonicalFormatEtc(LPFORMATETC pformatetc, LPFORMATETC pformatetcOut)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMountedVolume::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppenumFormatEtc)
{
    return S_FALSE;
}

STDMETHODIMP CMountedVolume::DAdvise(FORMATETC *pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD *pdwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP CMountedVolume::DUnadvise(DWORD dwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP CMountedVolume::EnumDAdvise(LPENUMSTATDATA *ppenumAdvise)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

// IMountedVolume methods
STDMETHODIMP CMountedVolume::Initialize(LPCWSTR pcszMountPoint)
{
    HRESULT hr;

    if (SUCCEEDED(StringCchCopy(_szMountPoint, ARRAYSIZE(_szMountPoint), pcszMountPoint)) &&
        PathAddBackslash(_szMountPoint))
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mtpt.h ===
#ifndef _MTPT_H
#define _MTPT_H

#include "regsprtb.h"
#include "hwcmmn.h"
#include "dpa.h"

#include <dbt.h>

#define REGSTR_MTPT_ROOTKEY2 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MountPoints2")

/////////////////////////////////////////////////////////////////////////////
// Assumptions
/////////////////////////////////////////////////////////////////////////////
// 1- Floppies (3.5" and 5.25") are always FAT
// 2- FAT does not support compression
// 3- DRIVE_CDROM == CDFS or UDF for File system
// 4- CDFS or UDF does not support compression
//
/////////////////////////////////////////////////////////////////////////////

#define DT_FIXEDDISK                     0x00000001
#define DT_FLOPPY35                      0x00000004
#define DT_FLOPPY525                     0x00000008
#define DT_CDROM                         0x00000020
#define DT_CDR                           0x00000040
#define DT_CDRW                          0x00000080
#define DT_DVDROM                        0x00000100
#define DT_DVDRAM                        0x00000200
#define DT_DVDR                          0x00000400
#define DT_DVDRW                         0x00000800
#define DT_REMOVABLEDISK                 0x00001000
#define DT_REMOTE                        0x00002000

#define DT_ANYTYPE                       0x0000FFFF

#define DT_ANYFLOPPYDRIVES               (   DT_FLOPPY35 | \
                                                        DT_FLOPPY525 )

#define DT_ANYCDDRIVES                   (   DT_CDROM | \
                                                        DT_CDR | \
                                                        DT_CDRW | \
                                                        DT_DVDROM | \
                                                        DT_DVDRAM | \
                                                        DT_DVDR | \
                                                        DT_DVDRW )

#define DT_ANYDVDDRIVES                  (   DT_DVDROM | \
                                                        DT_DVDRAM | \
                                                        DT_DVDR | \
                                                        DT_DVDRW )

#define DT_ANYWRITABLECDDRIVES           (   DT_CDR | \
                                                        DT_CDRW )

#define DT_ANYWRITABLEDVDDRIVES          (   DT_DVDR | \
                                                        DT_DVDRW )

#define DT_ANYREMOVABLEMEDIADRIVES       (   DT_ANYCDDRIVES | \
                                                        DT_ANYFLOPPYDRIVES | \
                                                        DT_REMOVABLEDISK )

#define DT_ANYLOCALDRIVES                (   DT_ANYREMOVABLEMEDIADRIVES | \
                                                        DT_FIXEDDISK )

#define AUTORUNFLAG_MEDIAARRIVAL            0x00000001
#define AUTORUNFLAG_MTPTARRIVAL             0x00000002
#define AUTORUNFLAG_MENUINVOKED             0x00000004

// put in shell32\shellprv.h
#define TF_MOUNTPOINT       0x08000000

#define MAX_DISPLAYNAME         MAX_PATH
#define MAX_MTPTCOMMENT         MAX_PATH

#define OFFSET_GUIDWITHINVOLUMEGUID     (sizeof("\\\\?\\Volume") - 1)

class CMountPoint;
class CMtPtLocal;
class CMtPtRemote;

class CCriticalSection : CRITICAL_SECTION
{
public:
    BOOL Init()
    {
        // need to use InitializeCriticalSectionAndSpinCount since we are called during process attach
        if (InitializeCriticalSectionAndSpinCount(this, 0))
        {
            _fInited = TRUE;
        }

#ifdef DEBUG
        _dwThreadIDThatShouldNotTryToEnter = 0;
        _fFakeEntered = FALSE;
#endif
        return _fInited;
    }

    void Enter()
    {
#ifdef DEBUG
        if (_dwThreadIDThatShouldNotTryToEnter)
        {
            ASSERT(_dwThreadIDThatShouldNotTryToEnter != GetCurrentThreadId());
        }
#endif

        if (!_fShuttingDown)
        {
            if (_fInited)
            {
                EnterCriticalSection(this);
            }
        }
    }

    void Leave()
    {
        if (!_fShuttingDown)
        {
            if (_fInited)
            {
                LeaveCriticalSection(this);
            }
        }
    }

    void Delete()
    {
        if (_fInited)
        {
            _fInited = FALSE;
            DeleteCriticalSection(this);
        }
    }

    BOOL IsInitialized()
    {
        return _fInited;
    }

    BOOL _fInited;
    BOOL _fShuttingDown;
#ifdef DEBUG
    BOOL IsInside()
    {
        ASSERT(_fInited);

        return _fFakeEntered || (OwningThread == UlongToHandle(GetCurrentThreadId()));
    }

    void FakeEnter()
    {
        ASSERT(_fInited);
        // See the comment in CMountPoint::_InitLocalDriveHelper where we use this fct.
        // Basically the cirtiical section should already be entered.  This will not
        // verify that it's entered by the thread that launched us, but it will verify
        // that at least one thread entered it.
        ASSERT(OwningThread);
        
        _fFakeEntered = TRUE;
    }

    void FakeLeave()
    {
        ASSERT(_fInited);
        ASSERT(OwningThread);
        
        _fFakeEntered = FALSE;
    }

    void SetThreadIDToCheckForEntrance(DWORD dwThreadID)
    {
        _dwThreadIDThatShouldNotTryToEnter = dwThreadID;
    }

    DWORD _dwThreadIDThatShouldNotTryToEnter;
    BOOL  _fFakeEntered;
#endif
};

typedef enum
{
    APS_RESET       = 0,
    APS_DID_SNIFF   = 0x0001,
//    APS_
} APSTATEF;

typedef enum
{
    CTI_PIX = 0,
    CTI_MUSIC,
    CTI_VIDEO,
    CTI_MIXCONTENT,
    _CTI_TOTAL_COUNT_
} CONTENTTYPE_INDEX;

class CAutoPlayParams
{
public:
    CAutoPlayParams(LPCWSTR pszDrive, CMountPoint* pMtPt, DWORD dwAutorunFlags);
    ~CAutoPlayParams() { ATOMICRELEASE(_pdo); }

    PCWSTR Drive() { return _pszDrive; }
    CMountPoint *MountPoint() { return _pmtpt; }
    CMtPtLocal *MountPointLocal() { return _pmtptl; }
    DWORD DriveType() { return _dwDriveType; }
    HRESULT DataObject(IDataObject **ppdo) 
    { 
        HRESULT hr = _InitObjects(NULL);
        *ppdo = _pdo; 
        if (SUCCEEDED(hr)) 
            _pdo->AddRef();
        return hr;
    }

    BOOL IsContentTypePresent(DWORD dwContentType);
    DWORD ContentType();
    void ForceSniff();

protected:  // methods
    BOOL _ShouldSniffDrive(BOOL fCheckHandlerDefaults);
    void _TrySniff();
    HRESULT _Sniff(DWORD *pdwFound);
    HRESULT _AddWalkToDataObject(INamespaceWalk* pnsw);
    HRESULT _InitObjects(IShellFolder **ppsf);
    
protected:  //  members
    DWORD _state; // APSTATEF
    DWORD _dwDriveType;
    DWORD _dwContentType;
    DWORD _dwAutorunFlags;
    PCWSTR _pszDrive;
    CMountPoint *_pmtpt;
    CMtPtLocal* _pmtptl;
    IDataObject *_pdo;

public:
    BOOL _fCheckAlwaysDoThisCheckBox;
};

#define AUTORUN_CONDITION_FCT(a) static BOOL (a)(HWND hwndForeground, CAutoPlayParams *papp);

class CMountPoint : public CRegSupport
{
///////////////////////////////////////////////////////////////////////////////
// Management (mtptmgmt.cpp)
///////////////////////////////////////////////////////////////////////////////
public:
    static CMountPoint* GetMountPoint(LPCTSTR pszMountPoint,
        BOOL fCreateNew = TRUE);
    static CMountPoint* GetSimulatedMountPointFromVolumeGuid(
        LPCTSTR pszVolumeGuid );
    static CMountPoint* GetMountPoint(int iDrive, BOOL fCreateNew = TRUE,
        BOOL fOKToHitNet = TRUE);

    static DWORD GetDrivesMask();

    static void HandleMountPointNetEvent(LPCWSTR pszDrive, BOOL fArrival);
    static DWORD WINAPI HandleMountPointLocalEventThreadProc(void* pv);
    static void HandleMountPointLocalEvent(LPCWSTR pszDrive, BOOL fArrival,
        BOOL fMediaEvent);
    static void OnNetShareArrival(LPCWSTR pszDrive);
    static void OnNetShareRemoval(LPCWSTR pszDrive);
    static void OnMediaArrival(LPCWSTR pszDrive);
    static void OnMountPointArrival(LPCWSTR pszDrive);
    static void OnMediaRemoval(LPCWSTR pszDrive);
    static void OnMountPointRemoval(LPCWSTR pszDrive);

    static void FinalCleanUp();
    static BOOL Initialize();

    static void NotifyUnavailableNetDriveGone(LPCWSTR pszMountPoint);
    static void NotifyReconnectedNetDrive(LPCWSTR pszMountPoint);

///////////////////////////////////////////////////////////////////////////////
// Public methods
///////////////////////////////////////////////////////////////////////////////
public:
    HRESULT GetDisplayName(LPTSTR pszName, DWORD cchName);
    HRESULT GetComment(LPTSTR pszComment, DWORD cchComment);
    virtual HRESULT GetLabel(LPTSTR pszLabel, DWORD cchLabel) = 0;
    virtual HRESULT GetLabelNoFancy(LPTSTR pszLabel, DWORD cchLabel) = 0;
    virtual HRESULT SetLabel(HWND hwnd, LPCTSTR pszLabel) = 0;
    virtual HRESULT SetDriveLabel(HWND hwnd, LPCTSTR pszLabel)
    { return SetLabel(hwnd, pszLabel); }

    virtual HRESULT GetRemotePath(LPWSTR pszPath, DWORD cchPath) = 0;
    BOOL GetFileSystemName(LPTSTR pszFileSysName, DWORD cchFileSysName);
    virtual void GetTypeString(LPTSTR pszType, DWORD cchType) = 0;
    DWORD GetAttributes();
    DWORD GetClusterSize();
    virtual int GetDriveFlags() = 0;
    int GetVolumeFlags();

    virtual UINT GetIcon(LPTSTR pszModule, DWORD cchModule) = 0;
    virtual HRESULT GetAssocSystemElement(IAssociationElement **ppae) = 0;
    virtual DWORD GetShellDescriptionID() = 0;

    virtual HKEY GetRegKey() = 0;

    BOOL IsStrictRemovable();
    BOOL IsFixedDisk();
    BOOL IsRemote();
    BOOL IsCDROM();
    BOOL IsAudioCD();
    BOOL IsAudioCDNoData();
    BOOL IsDVD();
    BOOL IsDVDRAMMedia();

    BOOL IsFormattable();
    BOOL IsNTFS();
    BOOL IsCompressible();
    BOOL IsCompressed();
    BOOL IsSupportingSparseFile();
    BOOL IsContentIndexed();
    BOOL IsSlow();
    BOOL IsFloppy();
    BOOL IsRemovableDevice();

    // Don't call this on net drive for nothing
    virtual BOOL IsMounted() { return TRUE; }
    virtual BOOL IsFormatted() = 0;

    virtual BOOL IsAutoRunDrive() { return FALSE; }
    virtual BOOL IsEjectable() { return FALSE; }
    virtual BOOL HasMedia() { return TRUE; }

    void SetAutorunStatus(BYTE* rgb, DWORD cbSize);

    // Returns E_FAIL if not applicable
    // Returns S_FALSE if cannot determine capabilities for drive
    virtual HRESULT GetCDInfo(DWORD* pdwDriveCapabilities, DWORD* pdwMediaCapabilities)
    { return E_FAIL; }

    // remote only
    virtual BOOL IsUnavailableNetDrive() { return FALSE; }
    virtual BOOL IsDisconnectedNetDrive() { return FALSE; }
    // local only
    virtual HRESULT Eject(HWND hwnd) { return E_FAIL; }

    virtual HRESULT ChangeNotifyRegisterAlias(void) = 0;
    virtual void StoreIconForUpdateImage(int iImage) { }

    static void HandleWMDeviceChange(ULONG_PTR code, DEV_BROADCAST_HDR *pbh);
    static void GetTypeString(int iDrive, LPTSTR pszType, DWORD cchType);

    static void DoAutorunPrompt(WPARAM iDrive);
    static void DoAutorun(LPCWSTR pszDrive, DWORD dwAutorunFlags);
    static void _DoAutorunHelper(CAutoPlayParams *papp);
    static HRESULT _Sniff(LPCWSTR pszDeviceIDVolume, LPCWSTR pszDrive, DWORD *pdwFound);

    static void WantAutorunUI(LPCWSTR pszDrive);
    static BOOL _AppAllowsAutoRun(HWND hwndApp, CMountPoint* pmtpt);
    static HRESULT _QueryRunningObject(CMountPoint* pmtpt, DWORD dwAutorunContentType, BOOL* pfAllow);

    AUTORUN_CONDITION_FCT(_acShiftKeyDown);
    AUTORUN_CONDITION_FCT(_acCurrentDesktopIsActiveConsole);
    AUTORUN_CONDITION_FCT(_acDriveIsMountedOnDriveLetter);
    AUTORUN_CONDITION_FCT(_acDriveIsRestricted);
    AUTORUN_CONDITION_FCT(_acHasAutorunCommand);
    AUTORUN_CONDITION_FCT(_acHasUseAutoPLAY);
    AUTORUN_CONDITION_FCT(_acForegroundAppAllowsAutorun);
    AUTORUN_CONDITION_FCT(_acQueryCancelAutoplayAllowsAutorun);
    AUTORUN_CONDITION_FCT(_acUserHasSelectedApplication);
    AUTORUN_CONDITION_FCT(_acShellIsForegroundApp);
    AUTORUN_CONDITION_FCT(_acOSIsServer);
    AUTORUN_CONDITION_FCT(_acIsDockedLaptop);
    AUTORUN_CONDITION_FCT(_acDriveIsFormatted);
    AUTORUN_CONDITION_FCT(_acShellExecuteDriveAutorunINF);
    AUTORUN_CONDITION_FCT(_acAlwaysReturnsTRUE);
    AUTORUN_CONDITION_FCT(_acPromptUser);
    AUTORUN_CONDITION_FCT(_acIsMixedContent);
    AUTORUN_CONDITION_FCT(_acExecuteAutoplayDefault);
    AUTORUN_CONDITION_FCT(_acWasjustDocked);
    AUTORUN_CONDITION_FCT(_acShouldSniff);
    AUTORUN_CONDITION_FCT(_acAddAutoplayVerb);
    AUTORUN_CONDITION_FCT(_acDirectXAppRunningFullScreen);

    static BOOL _ExecuteHelper(LPCWSTR pszHandler, LPCWSTR pszContentTypeHandler, 
        CAutoPlayParams *papp, DWORD dwMtPtContentType);

    static UINT GetSuperPlainDriveIcon(LPCWSTR pszDrive, UINT uDriveType);

    static BOOL _CanRegister();

    // returns DT_* defined above
    virtual DWORD _GetMTPTDriveType() = 0;
    // returns CT_* defined above
    virtual DWORD _GetMTPTContentType() = 0;

///////////////////////////////////////////////////////////////////////////////
// 
///////////////////////////////////////////////////////////////////////////////
protected:
    virtual BOOL _IsFloppy() { return FALSE; }
    virtual BOOL _IsFloppy35() { return FALSE; }
    virtual BOOL _IsFloppy525() { return FALSE; }
    virtual BOOL _IsCDROM() { return FALSE; }
    virtual BOOL _IsStrictRemovable() { return FALSE; }
    virtual BOOL _IsAutorun() = 0;
    virtual BOOL _IsFormattable()  { return FALSE; }
    virtual BOOL _IsAudioCD() { return FALSE; }
    virtual BOOL _IsAudioCDNoData() { return FALSE; }
    virtual BOOL _IsDVD() { return FALSE; }
    virtual BOOL _IsFixedDisk() { return FALSE; }
    virtual BOOL _IsDVDRAMMedia() { return FALSE; }
    virtual BOOL _IsRemovableDevice() { return FALSE; }
    BOOL _IsAutoRunDrive();

    BOOL _ProcessAutoRunFile();
    HRESULT _CopyInvokeVerbKey(LPCWSTR pszProgID, LPCWSTR pszVerb);
    HRESULT _AddAutoplayVerb();

    static BOOL _IsDriveLetter(LPCWSTR pszDrive);

    // Helpers
    void _QualifyCommandToDrive(LPTSTR pszCommand, DWORD cchCommand);

    virtual BOOL _NeedToRefresh() { return FALSE; }

public:
    // Should be accessed only by CMtPt_... fcts
    BOOL _IsLFN();
    BOOL _IsSecure();
    virtual BOOL _IsSlow() { return FALSE; }

private:

///////////////////////////////////////////////////////////////////////////////
// 
///////////////////////////////////////////////////////////////////////////////
protected:
    virtual BOOL _IsAudioDisc() { return FALSE; }
    virtual BOOL _IsRemote() { return FALSE; }

    BOOL _GetLegacyRegLabel(LPTSTR pszLabel, DWORD cchLabel);

    void _UpdateCommentFromDesktopINI();
    void _InitLegacyRegIconAndLabel(BOOL fUseAutorunIcon, BOOL fUseAutorunLabel);

    virtual BOOL _IsMountedOnDriveLetter() = 0;

///////////////////////////////////////////////////////////////////////////////
// Management (mtptmgmt.cpp)
///////////////////////////////////////////////////////////////////////////////
public:
    //      Drive Letter (DL)
    static CMountPoint* _GetMountPointDL(int iDrive, BOOL fCreateNew);

    //      Mounted On Folder (MOF)
    static CMtPtLocal* _GetStoredMtPtMOF(LPTSTR pszPathWithBackslash);
    static BOOL _StoreMtPtMOF(CMtPtLocal* pMtPt);
    static CMtPtLocal* _GetStoredMtPtMOFFromHDPA(LPTSTR pszPathWithBackslash);

protected:
    //      Helpers
    static BOOL _IsNetDriveLazyLoadNetDLLs(int iDrive);
    static HRESULT _InitLocalDrives();
    static HRESULT _InitNetDrives();
    static HRESULT _InitNetDrivesHelper(DWORD dwScope);
    static HRESULT _ReInitNetDrives();

    static HRESULT _EnumVolumes(IHardwareDevices* pihwdevs);
    static HRESULT _EnumMountPoints(IHardwareDevices* pihwdevs);

    static HRESULT _DeleteVolumeInfo();
    static HRESULT _DeleteLocalMtPts();
    static HRESULT _GetMountPointsForVolume(LPCWSTR pszDeviceIDVolume,
        HDPA hdpaMtPts);
    static HRESULT _MediaArrivalRemovalHelper(LPCWSTR pszDeviceIDVolume,
        BOOL fArrived);

    static HRESULT _RemoveLocalMountPoint(LPCWSTR pszMountPoint);
    static HRESULT _RemoveNetMountPoint(LPCWSTR pszMountPoint);

    static BOOL _LocalDriveIsCoveredByNetDrive(LPCWSTR pszDriveLetter);

    static BOOL _CheckLocalMtPtsMOF(LPCWSTR pszMountPoint);

public:
    static BOOL _StripToClosestMountPoint(LPCTSTR pszSource, LPTSTR pszDest,
        DWORD cchDest);

public:
    static HRESULT _InitLocalDriveHelper();

///////////////////////////////////////////////////////////////////////////////
// Miscellaneous helpers
///////////////////////////////////////////////////////////////////////////////
protected:
    virtual LPCTSTR _GetNameForFctCall();

    virtual BOOL _GetFileAttributes(DWORD* pdwAttrib) = 0;
    virtual BOOL _GetFileSystemName(LPTSTR pszFileSysName, DWORD cchFileSysName) = 0;
    virtual BOOL _GetGVILabelOrMixedCaseFromReg(LPTSTR pszLabel, DWORD cchLabel) = 0;
    virtual BOOL _GetGVILabel(LPTSTR pszLabel, DWORD cchLabel) = 0;
    virtual BOOL _GetSerialNumber(DWORD* pdwSerialNumber) = 0;
    virtual BOOL _GetFileSystemFlags(DWORD* pdwFlags) = 0;
    virtual int _GetGVIDriveFlags() = 0;
    virtual int _GetDriveType() = 0;
    virtual DWORD _GetAutorunContentType() = 0;

    TCHAR _GetNameFirstCharUCase();
    LPTSTR _GetNameFirstXChar(LPTSTR pszBuffer, int c);
    LPCTSTR _GetName();
    LPCTSTR _GetNameDebug();

    BOOL _GetLabelFromReg(LPWSTR psz, DWORD cch);
    BOOL _GetLabelFromDesktopINI(LPWSTR psz, DWORD cch);

    CMountPoint();

public:
    ULONG AddRef();
    ULONG Release();

///////////////////////////////////////////////////////////////////////////////
// 
///////////////////////////////////////////////////////////////////////////////
    static HRESULT _VolumeAddedOrUpdated(BOOL fAdded,
        VOLUMEINFO2* pvolinfo2);
    static HRESULT _VolumeRemoved(LPCWSTR pszDeviceIDVolume);
    static HRESULT _VolumeMountingEvent(LPCWSTR pszDeviceIDVolume,
        DWORD dwEvent);
    static HRESULT _MountPointAdded(LPCWSTR pszMountPoint,
        LPCWSTR pszDeviceIDVolume);
    static HRESULT _MountPointRemoved(LPCWSTR pszMountPoint);

    static HRESULT RegisterForHardwareNotifications();
    static HRESULT HandleDeviceQueryRemove();
    static DWORD WINAPI _RegisterThreadProc(void* pv);
    static void CALLBACK _EventAPCProc(ULONG_PTR ulpParam);
    static DWORD CALLBACK _EventProc(void* pv);

///////////////////////////////////////////////////////////////////////////////
// Data
///////////////////////////////////////////////////////////////////////////////
protected:
    // Only mtpt, volume, drive real data shared by derived objs
    WCHAR                           _szName[MAX_PATH];
    LPWSTR                          _pszLegacyRegIcon;
    LPWSTR                          _pszLegacyRegLabel;

    BOOL                            _fAutorunFileProcessed;

    // Static, non-mtpt related stuff
    LONG                            _cRef;
    static CCriticalSection         _csLocalMtPtHDPA;
    static CCriticalSection         _csDL;
    
    static HDPA                     _hdpaMountPoints;
    static HDPA                     _hdpaVolumes;
    static HDPA                     _hdpaShares;

    static DWORD                    _dwAdviseToken;
    
    // optimization we have an array for the volumes mounted on drive letters
    static CMtPtLocal*              _rgMtPtDriveLetterLocal[];
    static CMtPtRemote*             _rgMtPtDriveLetterNet[];
    
    static BOOL                     _fNetDrivesInited;
    static BOOL                     _fLocalDrivesInited;
    static BOOL                     _fNoVolLocalDrivesInited;
    static DWORD                    _dwTickCountTriedAndFailed;

    // Constructor/destructor of _hwdevcb will NOT get called
    static BOOL                     _fShuttingDown;

    // Watch out!  No constructor nor destructor called on the next members
    static CRegSupport              _rsMtPtsLocalDL;
    static CRegSupport              _rsMtPtsLocalMOF;
    static CRegSupport              _rsMtPtsRemote;

    static DWORD                    _dwRemoteDriveAutorun;
    static HANDLE                   _hThreadSCN;

    static DWORD                    _dwRememberedNetDrivesMask;

public:
    static BOOL                     _fCanRegisterWithShellService;
};

STDAPI MountPoint_RegisterChangeNotifyAlias(int iDrive);

BOOL _Shell32LoadedInDesktop();

struct TWODWORDS
{
    DWORD dwLeft;
    DWORD dwRight;
};

DWORD _DoDWORDMapping(DWORD dwLeft, const TWODWORDS* rgtwodword, DWORD ctwodword, BOOL fORed);

class PNPNOTIFENTRY : public CRefCounted
{
public:
    HDEVNOTIFY  hdevnotify;
    BOOL        fStopSniffing;
    HANDLE      hThread;
};

// everything is only the things we care about
#define DRIVEHAS_EVERYTHING (CT_AUTOPLAYMUSIC | CT_AUTOPLAYPIX | CT_AUTOPLAYMOVIE)

class CSniffDrive : public INamespaceWalkCB
{
public:
    CSniffDrive();
    ~CSniffDrive();
    
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef()
    {
        // stack created
        return 3;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        // stack created
        return 2;
    }

    // INamespaceWalkCB
    STDMETHODIMP FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP InitializeProgressDialog(LPWSTR *ppszTitle, LPWSTR *ppszCancel);

    DWORD Found() {return _dwFound;}

    // CSniffDrive
    static HRESULT Init(HANDLE hThreadSCN);
    static HRESULT InitNotifyWindow(HWND hwnd);
    static HRESULT CleanUp();
    static HRESULT HandleNotif(HDEVNOTIFY hdevnotify);
    static void CALLBACK _RegisterForNotifsHelper(ULONG_PTR ul);
    static void CALLBACK _UnregisterForNotifsHelper(ULONG_PTR ul);

    HRESULT RegisterForNotifs(LPCWSTR pszDeviceIDVolume);
    HRESULT UnregisterForNotifs();

private:  // methods
    BOOL _FoundEverything();
        
private:  // members
    DWORD                       _dwFound;
    PNPNOTIFENTRY*              _pne;

public:
    static HANDLE               _hThreadSCN;
    static CDPA<PNPNOTIFENTRY>  _dpaNotifs;
    static HWND                 _hwndNotify;
};

#endif //_MTPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mtpt2.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "mtpt.h"
#include "ids.h"
#include "shitemid.h"
#include "filetbl.h"

#include "shpriv.h"
#include "hwcmmn.h"

#include "apithk.h"

#include <ntddcdrm.h>

///////////////////////////////////////////////////////////////////////////////
// Public methods
///////////////////////////////////////////////////////////////////////////////
// get the friendly name for a given drive thing
// for example:
//      Floppy (A:)
//      Volume Name (D:)
//      User on 'Pyrex' (V:)
//      Dist on Strike\sys\public (Netware case)
HRESULT CMountPoint::GetDisplayName(LPTSTR pszName, DWORD cchName)
{
    HRESULT hres = E_FAIL;
    TCHAR szDriveLabel[MAX_DISPLAYNAME];
    static BOOL s_fAllDriveLetterFirst = -1;
    static BOOL s_fRemoteDriveLetterFirst = -1;
    static BOOL s_fNoDriveLetter = -1;

    ASSERT(cchName > 0);
    *pszName = 0; // handle failure case

    // for s_fDriveLetterFirst, see bug 250899, that's a long story.
    if (-1 == s_fRemoteDriveLetterFirst)
    {
        DWORD dw;
        DWORD cb = sizeof(dw);

        s_fRemoteDriveLetterFirst = FALSE;
        s_fAllDriveLetterFirst = FALSE;
        s_fNoDriveLetter = FALSE;

        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE,
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), 
            TEXT("ShowDriveLettersFirst"), NULL, &dw, &cb))
        {
            if (1 == dw)
            {
                s_fRemoteDriveLetterFirst = TRUE;
            }
            else
            {
                if (2 == dw)
                {
                    s_fNoDriveLetter = TRUE;
                }
                else
                {
                    if (4 == dw)
                    {
                        s_fAllDriveLetterFirst = TRUE;
                    }
                }
            }
        }
    }

    hres = GetLabel(szDriveLabel, ARRAYSIZE(szDriveLabel));

    if (SUCCEEDED(hres))
    {
        if (s_fNoDriveLetter)
        {
            hres = StringCchCopy(pszName, cchName, szDriveLabel);
        }
        else
        {
            BOOL fDriveLetterFirst = ((_IsRemote()) && s_fRemoteDriveLetterFirst) ||
                                        s_fAllDriveLetterFirst;

            // To return something like: "My Drive (c:)", we need a drive letter.
            // Fortunately for us this fct is only called for a drive mounted on a
            // letter (from drive implementation of IShellFolder), for volumes mounted
            // on folders, the folder impl  is called rather than the drive one.
            LPTSTR psz = ShellConstructMessageString(HINST_THISDLL, 
                        MAKEINTRESOURCE(fDriveLetterFirst ? IDS_VOL_FORMAT_LETTER_1ST : IDS_VOL_FORMAT),
                        szDriveLabel, _GetNameFirstCharUCase());
            if (psz)
            {
                hres = StringCchCopy(pszName, cchName, psz);
                LocalFree(psz);
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }
        }
    }

    return hres;
}

// { DRIVE_ISCOMPRESSIBLE | DRIVE_COMPRESSED | DRIVE_LFN | DRIVE_SECURITY }
int CMountPoint::GetVolumeFlags()
{
    int iFlags = _GetGVIDriveFlags();

    // Try to avoid getting the attributes
    if (iFlags & DRIVE_ISCOMPRESSIBLE)
    {
        DWORD dwAttrib = -1;

        if (_GetFileAttributes(&dwAttrib))
        {
            if (dwAttrib & FILE_ATTRIBUTE_COMPRESSED)
            {
                iFlags |= DRIVE_COMPRESSED;
            }
        }
    }

    return iFlags;
}

DWORD CMountPoint::GetClusterSize()
{
    DWORD dwSecPerClus, dwBytesPerSec, dwClusters, dwTemp;

    // assume this, avoid div by zero
    DWORD dwRet = 512;

    if (GetDiskFreeSpace(_GetNameForFctCall(), &dwSecPerClus, &dwBytesPerSec, &dwTemp, &dwClusters))
    {
        dwRet = dwSecPerClus * dwBytesPerSec;
    }
    
    return dwRet;   
}

//static
void CMountPoint::GetTypeString(int iDrive, LPTSTR pszType, DWORD cchType)
{
    *pszType = 0;

    CMountPoint* pmtpt = GetMountPoint(iDrive);
    if (pmtpt)
    {
        pmtpt->GetTypeString(pszType, cchType);

        pmtpt->Release();
    }
}

// static
UINT CMountPoint::GetSuperPlainDriveIcon(LPCWSTR pszDrive, UINT uDriveType)
{
    int iIcon;

    switch (uDriveType)
    {
        case DRIVE_REMOVABLE:
        {
            iIcon = II_DRIVEREMOVE;

            if (pszDrive)
            {
                if ((TEXT('a') == *pszDrive) || (TEXT('A') == *pszDrive))
                {
                    iIcon = II_DRIVE35;
                }
                else
                {
                    if ((TEXT('b') == *pszDrive) || (TEXT('B') == *pszDrive))
                    {
                        iIcon = II_DRIVE35;
                    }
                }
            }

            break;
        }
        case DRIVE_FIXED:
        {
            iIcon = II_DRIVEFIXED;
            break;
        }
        case DRIVE_REMOTE:
        {
            iIcon = II_DRIVENET;
            break;
        }
        case DRIVE_CDROM:
        {
            iIcon = II_DRIVECD;
            break;
        }
        case DRIVE_RAMDISK:
        {
            iIcon = II_DRIVERAM;
            break;
        }
        case DRIVE_UNKNOWN:
        case DRIVE_NO_ROOT_DIR:
        default:
        {
            iIcon = -IDI_DRIVEUNKNOWN;
            break;
        }
    }

    return iIcon;
}

///////////////////////////////////////////////////////////////////////////////
// Call Backs
///////////////////////////////////////////////////////////////////////////////
void CMountPoint::_UpdateCommentFromDesktopINI()
{
    WCHAR szCommentFromDesktopINI[MAX_MTPTCOMMENT];

    GetShellClassInfoInfoTip(_GetName(), szCommentFromDesktopINI, ARRAYSIZE(szCommentFromDesktopINI));

    RSSetTextValue(NULL, TEXT("_CommentFromDesktopINI"),
        szCommentFromDesktopINI, REG_OPTION_NON_VOLATILE);
}

///////////////////////////////////////////////////////////////////////////////
// Default Icon/Label
///////////////////////////////////////////////////////////////////////////////

#define REG_TEMPLATE_ICON    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\DriveIcons\\%c\\DefaultIcon")
#define REG_TEMPLATE2_ICON   TEXT("Applications\\Explorer.exe\\Drives\\%c\\DefaultIcon")
#define REG_TEMPLATE_LABEL   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\DriveIcons\\%c\\DefaultLabel")
#define REG_TEMPLATE2_LABEL  TEXT("Applications\\Explorer.exe\\Drives\\%c\\DefaultLabel")

void CMountPoint::_InitLegacyRegIconAndLabel(BOOL fUseAutorunIcon,
    BOOL fUseAutorunLabel)
{
    // No Autorun icon, load the legacy reg icon if any
    if (!fUseAutorunIcon && _IsMountedOnDriveLetter())
    {
        WCHAR szSubKey[MAX_PATH];
        ASSERT(ARRAYSIZE(szSubKey) >= ARRAYSIZE(REG_TEMPLATE_ICON) &&
               ARRAYSIZE(szSubKey) >= ARRAYSIZE(REG_TEMPLATE2_ICON) &&
               ARRAYSIZE(szSubKey) >= ARRAYSIZE(REG_TEMPLATE_LABEL) &&
               ARRAYSIZE(szSubKey) >= ARRAYSIZE(REG_TEMPLATE2_LABEL)); // make sure printfs won't fail
        WCHAR szIconLocation[MAX_PATH + 12];

        StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey),
                        REG_TEMPLATE_ICON, _GetNameFirstCharUCase());

        szIconLocation[0] = 0;

        if (!RegGetValueString(HKEY_LOCAL_MACHINE, szSubKey, NULL, szIconLocation,
            ARRAYSIZE(szIconLocation) * sizeof(TCHAR)))
        {
            // Let's try second location
            StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey),
                            REG_TEMPLATE2_ICON, _GetNameFirstCharUCase());

            RegGetValueString(HKEY_CLASSES_ROOT, szSubKey, NULL, szIconLocation,
                ARRAYSIZE(szIconLocation) * sizeof(TCHAR));
        }

        if (szIconLocation[0])
        {
            AssertMsg(!_pszLegacyRegIcon, TEXT("_InitLegacyRegIconAndLabel: called twice"));
            _pszLegacyRegIcon = StrDup(szIconLocation);
        }
    }

    if (!fUseAutorunLabel && _IsMountedOnDriveLetter())
    {
        WCHAR szSubKey[MAX_PATH];
        WCHAR szLabel[MAX_LABEL];

        StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey),
                        REG_TEMPLATE_LABEL, _GetNameFirstCharUCase());

        szLabel[0] = 0;

        if (!RegGetValueString(HKEY_LOCAL_MACHINE, szSubKey, NULL, szLabel,
            ARRAYSIZE(szLabel) * sizeof(TCHAR)))
        {
            // Let's try second location
            StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey),
                            REG_TEMPLATE2_LABEL, _GetNameFirstCharUCase());

            RegGetValueString(HKEY_CLASSES_ROOT, szSubKey, NULL, szLabel,
                ARRAYSIZE(szLabel) * sizeof(TCHAR));
        }

        if (szLabel[0])
        {
            AssertMsg(!_pszLegacyRegLabel, TEXT("_InitLegacyRegIconAndLabel: called twice"));
            _pszLegacyRegLabel = StrDup(szLabel);
        }
    }
}

BOOL CMountPoint::_GetLegacyRegLabel(LPTSTR pszLabel, DWORD cchLabel)
{
    BOOL fRet;
    if (_pszLegacyRegLabel &&
        SUCCEEDED(StringCchCopy(pszLabel, cchLabel, _pszLegacyRegLabel)))
    {
        fRet = TRUE;
    }
    else
    {
        *pszLabel = 0;
        fRet = FALSE;
    }

    return fRet;
}

LPCTSTR CMountPoint::_GetNameForFctCall()
{
    return _szName;
}

// the first character in the name, and convert it to upper case
// the first character is generally the drive letter
TCHAR CMountPoint::_GetNameFirstCharUCase()
{
    return (TCHAR) CharUpper((LPTSTR) _szName[0]);
}

LPTSTR CMountPoint::_GetNameFirstXChar(LPTSTR pszBuffer, int c)
{
    StringCchCopy(pszBuffer, c, _szName);

    return pszBuffer;
}

LPCTSTR CMountPoint::_GetNameDebug()
{
    return _szName;
}

LPCTSTR CMountPoint::_GetName()
{
    return _szName;
}

///////////////////////////////////////////////////////////////////////////////
// Misc
///////////////////////////////////////////////////////////////////////////////

//
// External API for use by non-CPP modules.
//
HRESULT MountPoint_RegisterChangeNotifyAlias(int iDrive)
{    
    HRESULT hr = E_FAIL;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(iDrive);
    if (pMtPt)
    {
        pMtPt->ChangeNotifyRegisterAlias();
        pMtPt->Release();
        hr = NOERROR;
    }
    return hr;
}    

HRESULT CMountPoint::GetComment(LPTSTR pszComment, DWORD cchComment)
{
    RSGetTextValue(NULL, TEXT("_CommentFromDesktopINI"), pszComment, &cchComment);
    return *pszComment ? S_OK : E_FAIL;
}

BOOL CMountPoint::GetFileSystemName(LPTSTR pszFileSysName, DWORD cchFileSysName)
{
    return _GetFileSystemName(pszFileSysName, cchFileSysName);
}

BOOL CMountPoint::_GetLabelFromReg(LPWSTR psz, DWORD cch)
{
    *psz = 0;

    return (RSGetTextValue(NULL, TEXT("_LabelFromReg"), psz, &cch) && *psz);
}

BOOL CMountPoint::_GetLabelFromDesktopINI(LPWSTR psz, DWORD cch)
{
    *psz = 0;

    return (RSGetTextValue(NULL, TEXT("_LabelFromDesktopINI"), psz, &cch) && *psz);
}

DWORD CMountPoint::GetAttributes()
{
    DWORD dwAttrib;

    _GetFileAttributes(&dwAttrib);
    
    return dwAttrib;
}

CMountPoint::CMountPoint() : _cRef(1)
{
}

ULONG CMountPoint::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CMountPoint::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mtptarun2.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "ids.h"
#include "mtptl.h"
#include "hwcmmn.h"
#include "datautil.h"

// for now
#include "mixctnt.h"

#include "filetbl.h"
#include "apprmdlg.h"

#include "views.h"

#include <ddraw.h>

CDPA<PNPNOTIFENTRY>     CSniffDrive::_dpaNotifs = NULL;
HANDLE                  CSniffDrive::_hThreadSCN = NULL;
HWND                    CSniffDrive::_hwndNotify = NULL;


//
//  if a drive has a AutoRun.inf file and AutoRun is not restricted in
//  the registry.  copy the AutoRun info into a key in the registry.
//
//  HKEY_CLASSES_ROOT\AutoRun\0   (0=A,1=B,...)
//
//  the key is a standard ProgID key, has DefaultIcon, shell, shellex, ...
//
//  the autorun file looks like this....
//
//  [AutoRun]
//      key = value
//      key = value
//      key = value
//
//  examples:
//
//    [AutoRun]
//      DefaultIcon = foo.exe,1
//      shell=myverb
//      shell\myverb = &MyVerb
//      shell\myverb\command = myexe.exe
//
//      will give the drive a icon from 'foo.exe'
//      add a verb called myverb (with name "&My Verb")
//      and make myverb default.
//
//    [AutoRun]
//      shell\myverb = &MyVerb
//      shell\myverb\command = myexe.exe
//
//      add a verb called myverb (with name "&My Verb")
//      verb will not be default.
//
//  any thing they add will be copied over, they can add wacky things
//  like CLSID's or shellx\ContextMenuHandlers and it will work.
//
//  or they can just copy over data the app will look at later.
//
//  the following special cases will be supported....
//
//    [AutoRun]
//      Open = command.exe /params
//      Icon = iconfile, iconnumber
//
//  will be treated like:
//
//    [AutoRun]
//      DefaultIcon = iconfile, iconnumber
//      shell = AutoRun
//      shell\AutoRun = Auto&Play
//      shell\AutoRun\command = command.exe /params
//
//
// This function tries to take care of the case that a command was registered
// in the autrun file of a cdrom.  If the command is relative than see if the
// command exists on the CDROM
void CMountPoint::_QualifyCommandToDrive(LPTSTR pszCommand, DWORD cchCommand)
{
    // for now we assume that we'll call this only for CD mounted on a drive letter
    // (by oppoition to a folder)

    if (_IsMountedOnDriveLetter())
    {
        TCHAR szImage[MAX_PATH];

        StringCchCopy(szImage, ARRAYSIZE(szImage), pszCommand);

        PathRemoveArgs(szImage);
        PathUnquoteSpaces(szImage);

        if (PathIsRelative(szImage))
        {
            TCHAR szFinal[MAX_PATH];
            LPTSTR pszTmp = szImage;

            StringCchCopy(szFinal, ARRAYSIZE(szFinal), _GetName());

            // do simple check for command, check for "..\abc" or "../abc"
            while ((TEXT('.') == *pszTmp) && (TEXT('.') == *(pszTmp + 1)) &&
                ((TEXT('\\') == *(pszTmp + 2)) || (TEXT('/') == *(pszTmp + 2))))
            {
                pszTmp += 3;
            }

            StringCchCat(szFinal, ARRAYSIZE(szFinal), pszTmp);

            // we first check if it exists on the CD
            DWORD dwAttrib = GetFileAttributes(szFinal);

            if (0xFFFFFFFF == dwAttrib)
            {
                // It's not on the CD, try appending ".exe"

                StringCchCat(szFinal, ARRAYSIZE(szFinal), TEXT(".exe"));

                dwAttrib = GetFileAttributes(szFinal);
            }

            if (0xFFFFFFFF != dwAttrib)
            {
                // Yes, it's on the CD
                PathQuoteSpaces(szFinal);

                LPTSTR pszArgs = PathGetArgs(pszCommand);
                if (pszArgs && *pszArgs)
                {
                    StringCchCat(szFinal, ARRAYSIZE(szFinal), pszArgs - 1);
                }

                StringCchCopy(pszCommand, cchCommand, szFinal);
            }
            else
            {
                // No, not on the CD
            }
        } 
    }
}

// This one does not hit the drive
BOOL CMountPoint::_IsAutoRunDrive()
{
    BOOL fRet = TRUE;

    // Add support for now drive letter
    if (_IsMountedOnDriveLetter())
    {
        int iDrive = DRIVEID(_GetName());    

        // Restrict auto-run's to particular drives.
        if (SHRestricted(REST_NODRIVEAUTORUN) & (1 << iDrive))
        {
            fRet = FALSE;
        }
    }

    if (fRet)
    {
        UINT uDriveType = _GetDriveType();

        // Restrict auto-run's to particular types of drives.
        if (SHRestricted(REST_NODRIVETYPEAUTORUN) & (1 << (uDriveType & DRIVE_TYPE)))
        {
            fRet = FALSE;
        }
        else
        {
            if (DRIVE_UNKNOWN == (uDriveType & DRIVE_TYPE))
            {
                fRet = FALSE;
            }
        }

        if (fRet && _IsFloppy())
        {
            fRet = FALSE;
        }
    }

    return fRet;
}

HRESULT CMountPoint::_AddAutoplayVerb()
{
    HRESULT hr = E_FAIL;

    if (RSSetTextValue(TEXT("shell\\Autoplay\\DropTarget"), TEXT("CLSID"),
        TEXT("{f26a669a-bcbb-4e37-abf9-7325da15f931}"), REG_OPTION_NON_VOLATILE))
    {
        // IDS_MENUAUTORUN -> 8504
        if (RSSetTextValue(TEXT("shell\\Autoplay"), TEXT("MUIVerb"),
            TEXT("@shell32.dll,-8504"), REG_OPTION_NON_VOLATILE))
        {
            if (RSSetTextValue(TEXT("shell"), NULL, TEXT("None"), REG_OPTION_NON_VOLATILE))
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}

HRESULT CMountPoint::_CopyInvokeVerbKey(LPCWSTR pszProgID, LPCWSTR pszVerb)
{
    ASSERT(pszProgID);
    ASSERT(pszVerb);
    WCHAR szKey[MAX_PATH];

    HRESULT hr = E_FAIL;

    hr = StringCchPrintf(szKey, ARRAYSIZE(szKey), TEXT("shell\\%s"), pszVerb);

    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;

        HKEY hkeyNew = RSDuplicateSubKey(szKey, TRUE, FALSE);

        if (hkeyNew)
        {
            hr = StringCchPrintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\shell\\%s"), pszProgID, pszVerb);

            if (SUCCEEDED(hr))
            {
                hr = E_FAIL;

                if (ERROR_SUCCESS == SHCopyKey(HKEY_CLASSES_ROOT, szKey, hkeyNew, 0))
                {
                    if (RSSetTextValue(TEXT("shell"), NULL, pszVerb, REG_OPTION_NON_VOLATILE))
                    {
                        hr = S_OK;
                    }
                }
            }

            RegCloseKey(hkeyNew);
        }
    }

    return hr;
}

BOOL CMountPoint::_ProcessAutoRunFile()
{
    BOOL fRet = TRUE;

    if (!_fAutorunFileProcessed)
    {
        BOOL fProcessFile = FALSE;

        if (_IsCDROM())
        {
            CMtPtLocal* pmtptlocal = (CMtPtLocal*)this;

            // not CDs with no media, or no autorun.inf files
            if (pmtptlocal->_IsMediaPresent())
            {
                if (!pmtptlocal->_CanUseVolume())
                {
                    fProcessFile = TRUE;
                }
                else
                {
                    if ((HWDMC_HASAUTORUNINF & pmtptlocal->_pvol->dwMediaCap) &&
                        !(HWDMC_HASUSEAUTOPLAY & pmtptlocal->_pvol->dwMediaCap))
                    {
                        fProcessFile = TRUE;
                    }
                }
            }
        }
        else
        {
            if (_IsRemote())
            {
                fProcessFile = TRUE;
            }
            else
            {
                if (_IsFixedDisk())
                {
                    fProcessFile = TRUE;
                }
            }
        }

        if (fProcessFile)
        {
            LPCTSTR pszSection;
            TCHAR szInfFile[MAX_PATH];
            TCHAR szKeys[512];
            TCHAR szValue[MAX_PATH];
            TCHAR szIcon[MAX_PATH + 12]; // MAX_PATH + room for ",1000000000" (for icon index part)
            LPTSTR pszKey;
            int iDrive = 0;

            RSDeleteSubKey(TEXT("Shell"));

            if (_IsMountedOnDriveLetter())
            {
                iDrive = DRIVEID(_GetName());
            }

            // build abs path to AutoRun.inf
            StringCchCopy(szInfFile, ARRAYSIZE(szInfFile), _GetName());
            StringCchCat(szInfFile, ARRAYSIZE(szInfFile), TEXT("AutoRun.inf"));

#if defined(_X86_)
    pszSection = TEXT("AutoRun.x86");
#elif defined(_IA64_)
    pszSection = TEXT("AutoRun.Ia64");
#elif defined(_AMD64_)
    pszSection = TEXT("AutoRun.Amd64");
#endif
            //
            // make sure a file exists before calling GetPrivateProfileString
            // because for some media this check might take a long long time
            // and we dont want to have kernel wait wiht the Win16Lock
            //
            UINT err = SetErrorMode(SEM_FAILCRITICALERRORS);

            if (!PathFileExistsAndAttributes(szInfFile, NULL))
            {
                SetErrorMode(err);
                _fAutorunFileProcessed = TRUE;

                return FALSE;
            }

            //
            // get all the keys in the [AutoRun] section
            //

            // Flush the INI cache, or this may fail during a Device broadcast
            WritePrivateProfileString(NULL, NULL, NULL, szInfFile);

        #if defined(_X86_)
            pszSection = TEXT("AutoRun.x86");
        #elif defined(_IA64_)
            pszSection = TEXT("AutoRun.Ia64");
        #endif

            int i = GetPrivateProfileString(pszSection, NULL, c_szNULL, szKeys, ARRAYSIZE(szKeys), szInfFile);

            // if we fail to find a platform-specific AutoRun section, fall
            // back to looking for the naked "AutoRun" section.
            if (0 == i)
            {
                pszSection = TEXT("AutoRun");
                i = GetPrivateProfileString(pszSection, NULL, c_szNULL, szKeys, ARRAYSIZE(szKeys), szInfFile);
            }

            SetErrorMode(err);

            if (i >= 4)
            {
                //
                // make sure the external strings are what we think.
                //
                ASSERT(lstrcmpi(c_szOpen,TEXT("open")) == 0);
                ASSERT(lstrcmpi(c_szShell, TEXT("shell")) == 0);

                //  now walk all the keys in the .inf file and copy them to the registry.

                for (pszKey = szKeys; *pszKey; pszKey += lstrlen(pszKey) + 1)
                {
                    GetPrivateProfileString(pszSection, pszKey,
                        c_szNULL, szValue, ARRAYSIZE(szValue), szInfFile);

                    //
                    //  special case open =
                    //
                    if (lstrcmpi(pszKey, c_szOpen) == 0)
                    {
                        if (_IsMountedOnDriveLetter())
                        {
                            RSSetTextValue(c_szShell, NULL, TEXT("AutoRun"));

                            _QualifyCommandToDrive(szValue, ARRAYSIZE(szValue));
                            RSSetTextValue(TEXT("shell\\AutoRun\\command"), NULL, szValue);

                            LoadString(HINST_THISDLL, IDS_MENUAUTORUN, szValue, ARRAYSIZE(szValue));
                            RSSetTextValue(TEXT("shell\\AutoRun"), NULL, szValue);
                        }
                    }
                    //
                    //  special case ShellExecute
                    //
                    else if (lstrcmpi(pszKey, TEXT("ShellExecute")) == 0)
                    {
                        if (_IsMountedOnDriveLetter())
                        {
                            TCHAR szPath[MAX_PATH * 2];

                            if (ExpandEnvironmentStrings(
                                TEXT("%windir%\\system32\\RunDLL32.EXE Shell32.DLL,ShellExec_RunDLL "),
                                szPath, ARRAYSIZE(szPath)))
                            {
                                StringCchCat(szPath, ARRAYSIZE(szPath), szValue);

                                RSSetTextValue(c_szShell, NULL, TEXT("AutoRun"));

                                RSSetTextValue(TEXT("shell\\AutoRun\\command"), NULL, szPath);

                                LoadString(HINST_THISDLL, IDS_MENUAUTORUN, szValue, ARRAYSIZE(szValue));
                                RSSetTextValue(TEXT("shell\\AutoRun"), NULL, szValue);
                            }
                        }
                    }
                    //
                    //  special case icon =
                    //  make sure the icon file has a full path...
                    //
                    else if (lstrcmpi(pszKey, TEXT("Icon")) == 0)
                    {
                        StringCchCopy(szIcon, ARRAYSIZE(szIcon), _GetName());
                        StringCchCat(szIcon, ARRAYSIZE(szIcon), szValue);

                        RSSetTextValue(TEXT("_Autorun\\DefaultIcon"), NULL, szIcon);
                    }
                    //
                    //  special case label =
                    //  make sure the label file has a full path...
                    //
                    else if (lstrcmpi(pszKey, TEXT("Label")) == 0)
                    {
                        RSSetTextValue(TEXT("_Autorun\\DefaultLabel"), NULL, szValue);
                    }
                    //
                    //  special case shell = open
                    //  We have an autorun file but this puts open as the default verb
                    //  so we force it to be Autorun
                    //
                    else if (!lstrcmpi(pszKey, TEXT("shell")) && !lstrcmpi(szValue, TEXT("open")))
                    {
                        if (_IsMountedOnDriveLetter())
                        {
                            RSSetTextValue(pszKey, NULL, TEXT("Autorun"));
                        }
                    }
                    //
                    //  it is just a key/value pair copy it over.
                    //
                    else
                    {
                        if (_IsMountedOnDriveLetter())
                        {
                            if (lstrcmpi(PathFindFileName(pszKey), c_szCommand) == 0)
                            {
                                _QualifyCommandToDrive(szValue, ARRAYSIZE(szValue));
                            }

                            RSSetTextValue(pszKey, NULL, szValue);
                        }
                    }
                }
            }
            else
            {
                fRet = FALSE;
            }
        }

        _fAutorunFileProcessed = TRUE;
    }

    return fRet;
}

// sends the "QueryCancelAutoPlay" msg to the window to see if it wants
// to cancel the autoplay. useful for dialogs that are prompting for disk
// inserts or cases where the app wants to capture the event and not let
// other apps be run

// static
BOOL CMountPoint::_AppAllowsAutoRun(HWND hwndApp, CMountPoint* pmtpt)
{
    ULONG_PTR dwCancel = 0;

    DWORD dwType = pmtpt->_GetAutorunContentType();
    WCHAR cDrive = pmtpt->_GetNameFirstCharUCase();

    int iDrive = cDrive - TEXT('A');

    SendMessageTimeout(hwndApp, QueryCancelAutoPlayMsg(), iDrive, dwType, SMTO_NORMAL | SMTO_ABORTIFHUNG,
        1000, &dwCancel);

    return (dwCancel == 0);
}

STDAPI SHCreateQueryCancelAutoPlayMoniker(IMoniker** ppmoniker)
{
    return CreateClassMoniker(CLSID_QueryCancelAutoPlay, ppmoniker);
}

struct QUERRYRUNNINGOBJECTSTRUCT
{
    WCHAR szMountPoint[MAX_PATH];
    DWORD dwContentType;
    WCHAR szLabel[MAX_LABEL];
    DWORD dwSerialNumber;
};

DWORD WINAPI _QueryRunningObjectThreadProc(void* pv)
{
    QUERRYRUNNINGOBJECTSTRUCT* pqro = (QUERRYRUNNINGOBJECTSTRUCT*)pv;

    HRESULT hrRet = S_OK;
    HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        IRunningObjectTable* prot;

        hr = GetRunningObjectTable(0, &prot);

        if (SUCCEEDED(hr))
        {
            IMoniker* pmoniker;
            IBindCtx* pbindctx;

            hr = CreateBindCtx(0, &pbindctx);

            if (SUCCEEDED(hr))
            {
                BIND_OPTS2 bindopts;

                ZeroMemory(&bindopts, sizeof(bindopts));

                bindopts.cbStruct = sizeof(bindopts);
                bindopts.dwClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD;

                hr = pbindctx->SetBindOptions(&bindopts);

                if (SUCCEEDED(hr))
                {
                    HKEY hkey;

                    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoplayHandlers\\CancelAutoplay\\CLSID"),
                        0, MAXIMUM_ALLOWED, &hkey))
                    {
                        DWORD dwIndex = 0;
                        WCHAR szCLSID[39] = TEXT("{");
                        DWORD cchCLSID = ARRAYSIZE(szCLSID) - 1;

                        while ((S_FALSE != hrRet) &&
                            (ERROR_SUCCESS == RegEnumValue(hkey, dwIndex, &(szCLSID[1]),
                            &cchCLSID, 0, 0, 0, 0)))
                        {
                            CLSID clsid;

                            szCLSID[37] = TEXT('}');
                            szCLSID[38] = 0;

                            hr = CLSIDFromString(szCLSID, &clsid);

                            if (SUCCEEDED(hr))
                            {
                                IMoniker* pmoniker;

                                // Create the moniker that we'll put in the ROT
                                hr = CreateClassMoniker(clsid, &pmoniker);

                                if (SUCCEEDED(hr))
                                {
                                    IUnknown* punk;

                                    hr = prot->GetObject(pmoniker, &punk);

                                    if (SUCCEEDED(hr) && (S_FALSE != hr))
                                    {
                                        IQueryCancelAutoPlay* pqca;
                                        hr = punk->QueryInterface(IID_PPV_ARG(IQueryCancelAutoPlay, &pqca));

                                        if (SUCCEEDED(hr))
                                        {
                                            hrRet = pqca->AllowAutoPlay(pqro->szMountPoint, pqro->dwContentType,
                                                pqro->szLabel, pqro->dwSerialNumber);

                                            pqca->Release();
                                        }

                                        punk->Release();
                                    }

                                    pmoniker->Release();
                                }
                            }

                            ++dwIndex;
                            cchCLSID = ARRAYSIZE(szCLSID) - 1;
                        }

                        RegCloseKey(hkey);
                    }
                }

                pbindctx->Release();
            }

            if (S_FALSE != hrRet)
            {
                // This case is to support WMP and CD burning.  We did not get to replace
                // their cancel logic before shipping.
                hr = SHCreateQueryCancelAutoPlayMoniker(&pmoniker);

                if (SUCCEEDED(hr))
                {
                    IUnknown* punk;

                    hr = prot->GetObject(pmoniker, &punk);

                    if (SUCCEEDED(hr) && (S_FALSE != hr))
                    {
                        IQueryCancelAutoPlay* pqca;
                        hr = punk->QueryInterface(IID_PPV_ARG(IQueryCancelAutoPlay, &pqca));

                        if (SUCCEEDED(hr))
                        {
                            hrRet = pqca->AllowAutoPlay(pqro->szMountPoint, pqro->dwContentType,
                                pqro->szLabel, pqro->dwSerialNumber);

                            pqca->Release();
                        }

                        punk->Release();
                    }

                    pmoniker->Release();
                }
            }

            prot->Release();
        }

        CoUninitialize();
    }

    LocalFree((HLOCAL)pqro);

    return (DWORD)hrRet;
}

// static
HRESULT CMountPoint::_QueryRunningObject(CMountPoint* pmtpt, DWORD dwAutorunContentType, BOOL* pfAllow)
{
    *pfAllow = TRUE;

    QUERRYRUNNINGOBJECTSTRUCT *pqro;
    HRESULT hr = SHLocalAlloc(sizeof(*pqro), &pqro);
    if (SUCCEEDED(hr))
    {
        WCHAR szLabel[MAX_LABEL];

        if (!(ARCONTENT_BLANKCD & dwAutorunContentType) &&
            !(ARCONTENT_BLANKDVD & dwAutorunContentType))
        {
            if (pmtpt->_GetGVILabel(szLabel, ARRAYSIZE(szLabel)))
            {
                StringCchCopy(pqro->szLabel, ARRAYSIZE(pqro->szLabel), szLabel);

                pmtpt->_GetSerialNumber(&(pqro->dwSerialNumber));
            }
        }

        hr = StringCchCopy(pqro->szMountPoint, ARRAYSIZE(pqro->szMountPoint), pmtpt->_GetName());
        
        if (SUCCEEDED(hr))
        {
            pqro->dwContentType = dwAutorunContentType;

            HANDLE hThread = CreateThread(NULL, 0, _QueryRunningObjectThreadProc, 
                pqro, 0, NULL);

            if (hThread)
            {
                // thread now owns these guys, NULL them out to avoid dbl free
                pqro = NULL;    // don't free this below

                hr = S_FALSE;
            
                // Wait 3 sec to see if wants to process it.  If not, it's
                // fair play for us.
                DWORD dwWait = WaitForSingleObject(hThread, 3000);

                if (WAIT_OBJECT_0 == dwWait)
                {
                    // Return within time and did not failed
                    DWORD dwExitCode;

                    if (GetExitCodeThread(hThread, &dwExitCode))
                    {
                        HRESULT hrHandlesEvent = (HRESULT)dwExitCode;
    
                        // Will return S_FALSE if they do NOT allow AutoRun
                        if (SUCCEEDED(hrHandlesEvent) && (S_FALSE == hrHandlesEvent))
                        {
                            *pfAllow = FALSE;
                        }

                        hr = S_OK;
                    }
                }
                CloseHandle(hThread);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        LocalFree((HLOCAL)pqro);    // may be NULL
    }

    return hr;
}

CAutoPlayParams::CAutoPlayParams(LPCWSTR pszDrive, CMountPoint* pMtPt, DWORD dwAutorunFlags)
    :   _pszDrive(pszDrive), 
        _pmtpt(pMtPt), 
        _dwAutorunFlags(dwAutorunFlags),
        _state(APS_RESET),
        _pdo(NULL),
        _fCheckAlwaysDoThisCheckBox(FALSE)
{
    _dwDriveType = pMtPt->_GetMTPTDriveType();
    _dwContentType = pMtPt->_GetMTPTContentType();

    if (DT_ANYLOCALDRIVES & _dwDriveType)
        _pmtptl = (CMtPtLocal*)pMtPt;
    else
        _pmtptl = NULL;

    //  maybe assert on these?
}

BOOL CAutoPlayParams::_ShouldSniffDrive(BOOL fCheckHandlerDefaults)
{
    BOOL fSniff = FALSE;

    if (_pmtptl)
    {
        if (CT_AUTORUNINF & _dwContentType)
        {
            if (_pmtptl->_CanUseVolume())
            {
                if (_pmtptl->_pvol->dwMediaCap & HWDMC_HASUSEAUTOPLAY)
                {
                    fSniff = TRUE;
                }
            }
        }
        else
        {
            fSniff = TRUE;
        }

        if (fSniff)
        {
            fSniff = FALSE;
            
            if (!((CT_CDAUDIO | CT_DVDMOVIE) & _dwContentType))
            {
                if (_pmtptl->_CanUseVolume())
                {
                    if (!(HWDVF_STATE_HASAUTOPLAYHANDLER & _pmtptl->_pvol->dwVolumeFlags) &&
                        !(HWDVF_STATE_DONOTSNIFFCONTENT & _pmtptl->_pvol->dwVolumeFlags))
                    {
                        if (AUTORUNFLAG_MENUINVOKED & _dwAutorunFlags)
                        {
                            fSniff = TRUE;
                        }
                        else if (DT_FIXEDDISK & _dwDriveType)
                        {
                            if (HWDDC_REMOVABLEDEVICE & _pmtptl->_pvol->dwDriveCapability)
                            {
                                fSniff = TRUE;
                            }
                        }
                        else
                        {
                            if (AUTORUNFLAG_MEDIAARRIVAL & _dwAutorunFlags)
                            {
                                fSniff = TRUE;
                            }
                            else
                            {
                                if (AUTORUNFLAG_MTPTARRIVAL & _dwAutorunFlags)
                                {
                                    if (HWDDC_REMOVABLEDEVICE & _pmtptl->_pvol->dwDriveCapability)
                                    {
                                        fSniff = TRUE;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if (fSniff && fCheckHandlerDefaults)
    {
        // Let's make sure the user did not pick "Take no action" for all Autoplay
        // content types, it would be useless to sniff.
        BOOL fAllTakeNoAction = TRUE;

        DWORD rgdwContentType[] =
        {
            CT_AUTOPLAYMUSIC,
            CT_AUTOPLAYPIX,
            CT_AUTOPLAYMOVIE,
            CT_AUTOPLAYMUSIC | CT_AUTOPLAYPIX | CT_AUTOPLAYMOVIE, // Mix content
        };

        for (DWORD dw = 0; fAllTakeNoAction && (dw < ARRAYSIZE(rgdwContentType)); ++dw)
        {
            WCHAR szContentTypeHandler[MAX_CONTENTTYPEHANDLER];

            DWORD dwMtPtContentType = rgdwContentType[dw];

            HRESULT hr = _GetContentTypeHandler(dwMtPtContentType, szContentTypeHandler, ARRAYSIZE(szContentTypeHandler));
            if (SUCCEEDED(hr))
            {
                IAutoplayHandler* piah;

                hr = _GetAutoplayHandler(Drive(), TEXT("ContentArrival"), szContentTypeHandler, &piah);

                if (SUCCEEDED(hr))
                {
                    LPWSTR pszHandlerDefault;

                    hr = piah->GetDefaultHandler(&pszHandlerDefault);

                    if (SUCCEEDED(hr))
                    {
                        if (HANDLERDEFAULT_MORERECENTHANDLERSINSTALLED &
                            HANDLERDEFAULT_GETFLAGS(hr))
                        {
                            fAllTakeNoAction = FALSE;
                        }
                        else
                        {
                            if (lstrcmpi(pszHandlerDefault, TEXT("MSTakeNoAction")))
                            {
                                fAllTakeNoAction = FALSE;
                            }
                        }

                        CoTaskMemFree(pszHandlerDefault);
                    }

                    piah->Release();
                }
            }
        }

        if (fAllTakeNoAction)
        {
            fSniff = FALSE;
        }
    }

    return fSniff;
}

DWORD CAutoPlayParams::ContentType() 
{ 
    return _dwContentType;
}

HRESULT CAutoPlayParams::_InitObjects(IShellFolder **ppsf)
{
    HRESULT hr;
    if (!_pdo || ppsf)
    {
        LPITEMIDLIST pidlFolder;
        hr = SHParseDisplayName(_pszDrive, NULL, &pidlFolder, 0, NULL);
        if (SUCCEEDED(hr))
        {
            hr = SHGetUIObjectOf(pidlFolder, NULL, IID_PPV_ARG(IDataObject, &_pdo));

            ILFree(pidlFolder);
        }
    }
    else
    {
        hr = S_OK;
    }

    if (SUCCEEDED(hr) && ppsf)
    {
        //  we need to avoid hitting the burn folder
        //  so we skip junctions for the sniff
        IBindCtx * pbc;
        hr = SHCreateSkipBindCtx(NULL, &pbc);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlFolder;
            hr = SHParseDisplayName(_pszDrive, pbc, &pidlFolder, 0, NULL);
            if (SUCCEEDED(hr))
            {
                hr = SHBindToObjectEx(NULL, pidlFolder, pbc, IID_PPV_ARG(IShellFolder, ppsf));
                ILFree(pidlFolder);
            }
            pbc->Release();
        }
    }        
    return hr;
}

HRESULT CAutoPlayParams::_AddWalkToDataObject(INamespaceWalk* pnsw)
{
    UINT cidl;
    LPITEMIDLIST *apidl;
    HRESULT hr = pnsw->GetIDArrayResult(&cidl, &apidl);
    if (SUCCEEDED(hr))
    {
        //  we need to add this back in
        if (cidl)
        {
            //  ragged array
            HIDA hida = HIDA_Create(&c_idlDesktop, cidl, (LPCITEMIDLIST *)apidl);
            if (hida)
            {
                IDLData_InitializeClipboardFormats(); // init our registerd formats
                //  should we free hida on FAILED?
                DataObj_SetGlobal(_pdo, g_cfAutoPlayHIDA, hida);
            }
        }
        FreeIDListArray(apidl, cidl);
    }
    return hr;
}

HRESULT CAutoPlayParams::_Sniff(DWORD *pdwFound)
{
    //  we found nothing
    HRESULT hr = S_FALSE;
    *pdwFound = 0;

    if (_pmtptl->_CanUseVolume())
    {
        //  setup the IDataObject and IShellFolder for the walk
        IShellFolder *psf;
        HRESULT hr = _InitObjects(&psf);
        if (SUCCEEDED(hr))
        {
            INamespaceWalk* pnsw;
            hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw));

            if (SUCCEEDED(hr))
            {
                CSniffDrive sniff;

                hr = sniff.RegisterForNotifs(_pmtptl->_pvol->pszDeviceIDVolume);

                if (SUCCEEDED(hr))
                {
                    // We don't care about the return value.  WE don't want to stop Autorun for as much.
                    // If sniffing fail we go on with what we have.
                    if (SUCCEEDED(pnsw->Walk(psf, NSWF_IGNORE_AUTOPLAY_HIDA | NSWF_DONT_TRAVERSE_LINKS | NSWF_SHOW_PROGRESS, 4, &sniff)))
                    {
                        //  we keep everything we found
                        _AddWalkToDataObject(pnsw);
                    }

                    sniff.UnregisterForNotifs();

                    *pdwFound = sniff.Found();
                }

                pnsw->Release();
            }
            psf->Release();
        }
    }

    return hr;
}

// BEGIN: Fcts for matrix below
//
BOOL CMountPoint::_acShiftKeyDown(HWND , CAutoPlayParams *)
{
    return (GetAsyncKeyState(VK_SHIFT) < 0);
}

BOOL _IsDirectXExclusiveMode()
{
    BOOL fRet = FALSE;

    // This code determines whether a DirectDraw 7 process (game) is running and
    // whether it's exclusively holding the video to the machine in full screen mode.

    // The code is probably to be considered untrusted and hence is wrapped in a
    // __try / __except block. It could AV and therefore bring down shell
    // with it. Not very good. If the code does raise an exception the release
    // call is skipped. Tough. Don't trust the release method either.

    IDirectDraw7 *pIDirectDraw7 = NULL;

    HRESULT hr = CoCreateInstance(CLSID_DirectDraw7, NULL, CLSCTX_INPROC_SERVER,
        IID_IDirectDraw7, (void**)&pIDirectDraw7);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIDirectDraw7);

        __try
        {
            hr = IDirectDraw7_Initialize(pIDirectDraw7, NULL);

            if (DD_OK == hr)
            {
                fRet = (IDirectDraw7_TestCooperativeLevel(pIDirectDraw7) ==
                    DDERR_EXCLUSIVEMODEALREADYSET);
            }

            IDirectDraw7_Release(pIDirectDraw7);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }

    return fRet;
}

// From a mail regarding the DirectX fct below:
//
// You can definitely count on the following:
//
// (1) If shadow cursors are on, there is definitely not an exclusive mode app running.
// (2) If hot tracking is on, there is definitely not an exclusive mode app running.
// (3) If message boxes for SEM_NOGPFAULTERRORBOX, SEM_FAILCRITICALERRORS, or
//     SEM_NOOPENFILEERRORBOX have not been disabled via SetErrorMode, then there
//     is definitely not an exclusive mode app running.
//
// Note: we cannot use (3) since this is per-process.

BOOL CMountPoint::_acDirectXAppRunningFullScreen(HWND hwndForeground, CAutoPlayParams *)
{
    BOOL fRet = FALSE;
    BOOL fSPI;

    if (SystemParametersInfo(SPI_GETCURSORSHADOW, 0, &fSPI, 0) && !fSPI)
    {
        if (SystemParametersInfo(SPI_GETHOTTRACKING, 0, &fSPI, 0) && !fSPI)
        {
            // There's a chance that a DirectX app is running full screen.  Let's do the
            // expensive DirectX calls that will tell us for sure.
            fRet = _IsDirectXExclusiveMode();
        }
    }

    return fRet;
}

BOOL CMountPoint::_acCurrentDesktopIsActiveConsole(HWND , CAutoPlayParams *)
{
    BOOL fRetValue = FALSE;  // block auto-run/auto-play if we can't determine our state.

    if (0 == GetSystemMetrics(SM_REMOTESESSION))
    {
        //
        //  We are not remoted. See if we are the active console session.
        //

        BOOL b;
        DWORD dwProcessSession;

        b = ProcessIdToSessionId(GetCurrentProcessId(), &dwProcessSession);
        if (b)
        {
            DWORD dwConsoleSession = WTSGetActiveConsoleSessionId( );

            if ( dwProcessSession == dwConsoleSession )
            {        
                //
                //  See if the screen saver is running.
                //

                BOOL b;
                BOOL fScreenSaver;

                b = SystemParametersInfo( SPI_GETSCREENSAVERRUNNING, 0, &fScreenSaver, 0 );
                if (b)
                {
                    if (!fScreenSaver)
                    {
                        //
                        //  We made it here, we must be the active console session without a
                        //  screen saver.
                        //

                        HDESK hDesk = OpenInputDesktop( 0, FALSE, DESKTOP_CREATEWINDOW );
                        if ( NULL != hDesk )
                        {
                            //
                            //  We have access to the current desktop which should indicate that
                            //  WinLogon isn't.
                            //
                            CloseDesktop( hDesk );

                            fRetValue = TRUE;
                        }
                        // else "WinLogon" has the "desktop"... don't allow auto-run/auto-play.
                    }
                    // else a screen saver is running... don't allow auto-run/auto-play.
                }
                // else we are in an undeterminate state... don't allow auto-run/auto-play.
            }
            //  else we aren't the console... don't allow auto-run/auto-play
        }
        // else we are in an undeterminate state... don't allow auto-run/auto-play.
    }
    //  else we are remoted... don't allow auto-run/auto-play.

    return fRetValue;
}

BOOL CMountPoint::_acDriveIsMountedOnDriveLetter(HWND , CAutoPlayParams *papp)
{
    return _IsDriveLetter(papp->Drive());
}

BOOL CMountPoint::_acDriveIsRestricted(HWND , CAutoPlayParams *papp)
{
    BOOL fIsRestricted = (SHRestricted(REST_NODRIVES) & (1 << DRIVEID(papp->Drive())));

    if (!fIsRestricted)
    {
        fIsRestricted = !(papp->MountPoint()->_IsAutoRunDrive());
    }

    return fIsRestricted;
}

BOOL CMountPoint::_acHasAutorunCommand(HWND , CAutoPlayParams *papp)
{
    BOOL fRet = FALSE;

    if ((papp->IsContentTypePresent(CT_AUTORUNINF)) &&
        (DT_ANYLOCALDRIVES & papp->DriveType()))
    {
        CMtPtLocal* pmtptl = (CMtPtLocal*)papp->MountPoint();

        if (pmtptl->_CanUseVolume())
        {
            if (pmtptl->_pvol->dwMediaCap & HWDMC_HASAUTORUNCOMMAND)
            {
                fRet = TRUE;
            }
        }
        else
        {
            fRet = papp->MountPoint()->_IsAutorun();
        }
    }
    else
    {
        fRet = papp->IsContentTypePresent(CT_AUTORUNINF);
    }

    return fRet;
}

BOOL CMountPoint::_acHasUseAutoPLAY(HWND , CAutoPlayParams *papp)
{
    BOOL fRet = FALSE;

    if (papp->IsContentTypePresent(CT_AUTORUNINF) &&
        (DT_ANYLOCALDRIVES & papp->DriveType()))
    {
        CMtPtLocal* pmtptl = (CMtPtLocal*)papp->MountPoint();

        if (pmtptl->_CanUseVolume())
        {
            if (pmtptl->_pvol->dwMediaCap & HWDMC_HASUSEAUTOPLAY)
            {
                fRet = TRUE;
            }
        }
        else
        {
            // If we're here, most likely the ShellService is not running, so we won't be able to
            // Autoplay anyway.
            fRet = FALSE;
        }
    }
    else
    {
        // not supported for remote drives
    }

    return fRet;
}

BOOL CMountPoint::_acForegroundAppAllowsAutorun(HWND hwndForeground, CAutoPlayParams *papp)
{
    return _AppAllowsAutoRun(hwndForeground, papp->MountPoint());
}

static const TWODWORDS allcontentsVSarcontenttypemappings[] =
{
    { CT_AUTORUNINF      , ARCONTENT_AUTORUNINF },
    { CT_CDAUDIO         , ARCONTENT_AUDIOCD },
    { CT_DVDMOVIE        , ARCONTENT_DVDMOVIE },
    { CT_UNKNOWNCONTENT  , ARCONTENT_UNKNOWNCONTENT },
    { CT_BLANKCDR        , ARCONTENT_BLANKCD },
    { CT_BLANKCDRW       , ARCONTENT_BLANKCD },
    { CT_BLANKDVDR       , ARCONTENT_BLANKDVD },
    { CT_BLANKDVDRW      , ARCONTENT_BLANKDVD },
    { CT_AUTOPLAYMUSIC   , ARCONTENT_AUTOPLAYMUSIC },
    { CT_AUTOPLAYPIX     , ARCONTENT_AUTOPLAYPIX },
    { CT_AUTOPLAYMOVIE   , ARCONTENT_AUTOPLAYVIDEO },
};

BOOL CMountPoint::_acQueryCancelAutoplayAllowsAutorun(HWND , CAutoPlayParams *papp)
{
    BOOL fAllow = TRUE;

    DWORD dwAutorunContentType = _DoDWORDMapping(papp->ContentType(),
        allcontentsVSarcontenttypemappings, ARRAYSIZE(allcontentsVSarcontenttypemappings),
        TRUE);

    _QueryRunningObject(papp->MountPoint(), dwAutorunContentType, &fAllow);

    return fAllow;
}

BOOL CMountPoint::_acUserHasSelectedApplication(HWND hwndForeground, CAutoPlayParams *papp)
{
    BOOL fRet = FALSE;
    WCHAR szContentTypeHandler[MAX_CONTENTTYPEHANDLER];

    DWORD dwMtPtContentType = papp->ContentType() & ~CT_UNKNOWNCONTENT;
    HRESULT hr = _GetContentTypeHandler(dwMtPtContentType, szContentTypeHandler, ARRAYSIZE(szContentTypeHandler));
    if (SUCCEEDED(hr))
    {
        IAutoplayHandler* piah;

        hr = _GetAutoplayHandler(papp->Drive(), TEXT("ContentArrival"), szContentTypeHandler, &piah);

        if (SUCCEEDED(hr))
        {
            LPWSTR pszHandlerDefault;

            hr = piah->GetDefaultHandler(&pszHandlerDefault);

            if (SUCCEEDED(hr))
            {
                if (HANDLERDEFAULT_MORERECENTHANDLERSINSTALLED &
                    HANDLERDEFAULT_GETFLAGS(hr))
                {
                    fRet = FALSE;
                }
                else
                {
                    if (HANDLERDEFAULT_USERCHOSENDEFAULT &
                        HANDLERDEFAULT_GETFLAGS(hr))
                    {
                        fRet = lstrcmpi(pszHandlerDefault, TEXT("MSPromptEachTime"));
                    }
                    else
                    {
                        fRet = FALSE;
                    }
                }

                if (!fRet)
                {
                    if (((HANDLERDEFAULT_USERCHOSENDEFAULT &
                        HANDLERDEFAULT_GETFLAGS(hr)) ||
                        (HANDLERDEFAULT_EVENTHANDLERDEFAULT &
                        HANDLERDEFAULT_GETFLAGS(hr))) &&
                        !(HANDLERDEFAULT_DEFAULTSAREDIFFERENT &
                        HANDLERDEFAULT_GETFLAGS(hr)))
                    {
                        papp->_fCheckAlwaysDoThisCheckBox = TRUE;
                    }
                }

                CoTaskMemFree(pszHandlerDefault);
            }

            piah->Release();
        }
    }

    return fRet;
}

BOOL CMountPoint::_acShellIsForegroundApp(HWND hwndForeground, CAutoPlayParams *papp)
{
    BOOL fRet = FALSE;
    WCHAR szModule[MAX_PATH];

    if (GetWindowModuleFileName(hwndForeground, szModule, ARRAYSIZE(szModule)))
    {
        if (!lstrcmpi(PathFindFileName(szModule), TEXT("explorer.exe")))
        {
            fRet = TRUE;
        }
    }

    return fRet;
}

BOOL CMountPoint::_acOSIsServer(HWND , CAutoPlayParams *papp)
{
    return IsOS(OS_ANYSERVER);
}

BOOL CMountPoint::_acIsDockedLaptop(HWND hwndForeground, CAutoPlayParams *papp)
{
    return (GMID_DOCKED & SHGetMachineInfo(GMI_DOCKSTATE));
}

BOOL CMountPoint::_acDriveIsFormatted(HWND hwndForeground, CAutoPlayParams *papp)
{
    return papp->MountPoint()->IsFormatted();
}

BOOL CMountPoint::_acShellExecuteDriveAutorunINF(HWND hwndForeground, CAutoPlayParams *papp)
{
    SHELLEXECUTEINFO ei = {
        sizeof(ei),                 // size
        SEE_MASK_INVOKEIDLIST | SEE_MASK_FLAG_NO_UI,      // flags
        NULL,
        NULL,                       // verb
        papp->Drive(),              // file
        papp->Drive(),              // params
        papp->Drive(),              // directory
        SW_NORMAL,                  // show.
        NULL,                       // hinstance
        NULL,                       // IDLIST
        NULL,                       // class name
        NULL,                       // class key
        0,                          // hot key
        NULL,                       // icon
        NULL,                       // hProcess
    };

    return ShellExecuteEx(&ei);
}


HRESULT _InvokeAutoRunProgid(HKEY hkProgid, LPCWSTR pszVerb, IDataObject *pdo)
{
    IShellExtInit *psei;
    HRESULT hr = CoCreateInstance(CLSID_ShellFileDefExt, NULL, CLSCTX_INPROC, IID_PPV_ARG(IShellExtInit, &psei));

    if (SUCCEEDED(hr))
    {
        hr = psei->Initialize(NULL, pdo, hkProgid);
        if (SUCCEEDED(hr))
        {
            IContextMenu *pcm;
            hr = psei->QueryInterface(IID_PPV_ARG(IContextMenu, &pcm));
            if (SUCCEEDED(hr))
            {
                CHAR szVerb[64];

                //  maybe hwnd
                //  maybe punkSite
                //  maybe ICI flags
                SHUnicodeToAnsi(pszVerb, szVerb, ARRAYSIZE(szVerb));
    
                hr = SHInvokeCommandOnContextMenu(NULL, NULL, pcm, 0, szVerb);

                pcm->Release();
            }
        }

        psei->Release();
    }
    return hr;
}

HRESULT _GetProgidAndVerb(DWORD dwContentType, PCWSTR pszHandler, PWSTR pszInvokeProgID,
    DWORD cchInvokeProgID, PWSTR pszInvokeVerb, DWORD cchInvokeVerb)
{
    HRESULT hr;
    if (0 == StrCmpI(pszHandler, TEXT("AutoplayLegacyHandler")) && (dwContentType & (CT_CDAUDIO | CT_DVDMOVIE)))
    {
        HKEY hkey;
        BOOL fGotDefault = FALSE;

        if (dwContentType & CT_CDAUDIO)
        {
            hr = StringCchCopy(pszInvokeProgID, cchInvokeProgID, TEXT("AudioCD"));
        }
        else
        {
            ASSERT(dwContentType & CT_DVDMOVIE);
            hr = StringCchCopy(pszInvokeProgID, cchInvokeProgID, TEXT("DVD"));
        }

        if (SUCCEEDED(hr))
        {
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, pszInvokeProgID, 0, MAXIMUM_ALLOWED,
                &hkey))
            {
                HKEY hkey2;

                if (ERROR_SUCCESS == RegOpenKeyEx(hkey, TEXT("shell"), 0, MAXIMUM_ALLOWED,
                    &hkey2))
                {
                    DWORD cbInvokeVerb = cchInvokeVerb * sizeof(WCHAR);

                    if (ERROR_SUCCESS == RegQueryValueEx(hkey2, NULL, NULL, NULL, (PBYTE)pszInvokeVerb,
                        &cbInvokeVerb))
                    {
                        if (cbInvokeVerb && *pszInvokeVerb)
                        {                        
                            if (cbInvokeVerb != (cchInvokeVerb * sizeof(WCHAR)))
                            {
                                fGotDefault = TRUE;
                            }
                        }
                    }

                    RegCloseKey(hkey2);
                }

                RegCloseKey(hkey);
            }

            if (!fGotDefault)
            {
                hr = StringCchCopy(pszInvokeVerb, cchInvokeVerb, TEXT("play"));
            }
        }
    }
    else
    {
        hr = _GetHandlerInvokeProgIDAndVerb(pszHandler, pszInvokeProgID,
                    cchInvokeProgID, pszInvokeVerb, cchInvokeVerb);
    }
    return hr;
}

BOOL CMountPoint::_ExecuteHelper(LPCWSTR pszHandler, LPCWSTR pszContentTypeHandler,
    CAutoPlayParams *papp, DWORD dwMtPtContentType)
{
    HRESULT hr;

    if (lstrcmpi(pszHandler, TEXT("MSTakeNoAction")))
    {
        WCHAR szInvokeProgID[260];
        WCHAR szInvokeVerb[CCH_KEYMAX];

        hr = _GetProgidAndVerb(dwMtPtContentType, pszHandler, szInvokeProgID,
            ARRAYSIZE(szInvokeProgID), szInvokeVerb, ARRAYSIZE(szInvokeVerb));

        if (SUCCEEDED(hr))
        {
            HKEY hkey;
            if (dwMtPtContentType & (CT_CDAUDIO | CT_DVDMOVIE))
            {
                hr = papp->MountPoint()->_CopyInvokeVerbKey(szInvokeProgID, szInvokeVerb);

                if (SUCCEEDED(hr))
                {
                    hkey = papp->MountPoint()->RSDuplicateRootKey();

                    if (hkey)
                    {
                        papp->MountPoint()->RSSetTextValue(TEXT("shell"), NULL, szInvokeVerb,
                            REG_OPTION_NON_VOLATILE);
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
            }
            else
            {
                hr = ResultFromWin32(RegOpenKeyExW(HKEY_CLASSES_ROOT, szInvokeProgID, 0, MAXIMUM_ALLOWED, &hkey));
            }

            if (SUCCEEDED(hr))
            {
                IDataObject* pdo;
                hr = papp->DataObject(&pdo);
                if (SUCCEEDED(hr))
                {
                    hr = _InvokeAutoRunProgid(hkey, szInvokeVerb, pdo);
                    pdo->Release();
                }

                RegCloseKey(hkey);
            }
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return SUCCEEDED(hr);
}

BOOL CMountPoint::_acExecuteAutoplayDefault(HWND hwndForeground, CAutoPlayParams *papp)
{
    BOOL fRet = FALSE;

    if (DT_ANYLOCALDRIVES & papp->DriveType())
    {
        WCHAR szContentTypeHandler[MAX_CONTENTTYPEHANDLER];

        DWORD dwMtPtContentType = papp->ContentType() & ~CT_UNKNOWNCONTENT;

        HRESULT hr = _GetContentTypeHandler(dwMtPtContentType, szContentTypeHandler, ARRAYSIZE(szContentTypeHandler));

        if (SUCCEEDED(hr))
        {
            IAutoplayHandler* piah;

            hr = _GetAutoplayHandler(papp->Drive(), TEXT("ContentArrival"), szContentTypeHandler, &piah);

            if (SUCCEEDED(hr))
            {
                LPWSTR pszHandlerDefault;

                hr = piah->GetDefaultHandler(&pszHandlerDefault);

                if (SUCCEEDED(hr))
                {
                    // No need to check for (S_HANDLERS_MORE_RECENT_THAN_USER_SELECTION == hr) here
                    // It should have been caught by _acUserHasSelectedApplication
                    fRet = _ExecuteHelper(pszHandlerDefault, szContentTypeHandler, papp, dwMtPtContentType);
                }

                CoTaskMemFree(pszHandlerDefault);
            }

            piah->Release();
        }
    }

    return fRet;
}

BOOL CMountPoint::_acWasjustDocked(HWND hwndForeground, CAutoPlayParams *papp)
{
    BOOL fRet = FALSE;

    if (DT_ANYLOCALDRIVES & papp->DriveType())
    {
        CMtPtLocal* pmtptl = (CMtPtLocal*)papp->MountPoint();

        if (pmtptl->_CanUseVolume())
        {
            if (pmtptl->_pvol->dwVolumeFlags & HWDVF_STATE_JUSTDOCKED)
            {
                fRet = TRUE;
            }
        }
    }

    return fRet;
}

CRITICAL_SECTION g_csAutoplayPrompt = {0};
HDPA g_hdpaAutoplayPrompt = NULL;

BOOL CMountPoint::_acPromptUser(HWND hwndForeground, CAutoPlayParams *papp)
{
    BOOL fRet = FALSE;
    BOOL fShowDlg = TRUE;

    if (papp->Drive())
    {
        fShowDlg = _AddAutoplayPrompt(papp->Drive());
    }

    if (fShowDlg)
    {
        CBaseContentDlg* pdlg;

        papp->ForceSniff();

        DWORD dwMtPtContentType = papp->ContentType() & ~CT_UNKNOWNCONTENT;

        if (dwMtPtContentType)
        {
            if (_acIsMixedContent(hwndForeground, papp))
            {
                pdlg = new CMixedContentDlg();

                dwMtPtContentType &= CT_ANYAUTOPLAYCONTENT;

                if (pdlg)
                {
                    pdlg->_iResource = DLG_APMIXEDCONTENT;
                }
            }
            else
            {
                pdlg = new CHWContentPromptDlg();

                if (pdlg)
                {
                    pdlg->_iResource = DLG_APPROMPTUSER;
                }
            }
        }

        if (pdlg)
        {
            // Better be a local drive
            if (DT_ANYLOCALDRIVES & papp->DriveType())
            {
                CMtPtLocal* pmtptl = (CMtPtLocal*)papp->MountPoint();

                if (pmtptl->_CanUseVolume())
                {
                    HRESULT hr = pdlg->Init(pmtptl->_pvol->pszDeviceIDVolume, papp->Drive(), dwMtPtContentType,
                        papp->_fCheckAlwaysDoThisCheckBox);

                    pdlg->_hinst = g_hinst;
                    pdlg->_hwndParent = NULL;

                    if (SUCCEEDED(hr))
                    {
                        INT_PTR iRet = pdlg->DoModal(pdlg->_hinst, MAKEINTRESOURCE(pdlg->_iResource),
                            pdlg->_hwndParent);

                        if (IDOK == iRet)
                        {
                            fRet = _ExecuteHelper(pdlg->_szHandler, pdlg->_szContentTypeHandler,
                                papp, dwMtPtContentType);
                        }
                    }
                }
            }

            pdlg->Release();
        }

        if (papp->Drive())
        {
            _RemoveFromAutoplayPromptHDPA(papp->Drive());
        }
    }
    
    return fRet;
}

BOOL CMountPoint::_acIsMixedContent(HWND hwndForeground, CAutoPlayParams *papp)
{
    BOOL fRet;

    if (papp->IsContentTypePresent(CT_ANYAUTOPLAYCONTENT))
    {
        fRet = IsMixedContent(papp->ContentType());
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

BOOL CMountPoint::_acAlwaysReturnsTRUE(HWND hwndForeground, CAutoPlayParams *papp)
{
    return TRUE;
}

BOOL CMountPoint::_acShouldSniff(HWND hwndForeground, CAutoPlayParams *papp)
{
    BOOL fRet = TRUE;
    CMtPtLocal* pmtptl = papp->MountPointLocal();
    if (pmtptl)
    {
        if (pmtptl->_CanUseVolume())
        {
            fRet = !(HWDVF_STATE_DONOTSNIFFCONTENT & pmtptl->_pvol->dwVolumeFlags);
        }
    }

    return fRet;
}

BOOL CMountPoint::_acAddAutoplayVerb(HWND hwndForeground, CAutoPlayParams *papp)
{
    CMtPtLocal* pmtptl = papp->MountPointLocal();

    if (pmtptl)
    {
        if (pmtptl->_CanUseVolume())
        {
            // We don't care about the return value
            pmtptl->_AddAutoplayVerb();
        }
    }

    return TRUE;
}

//
// END: Fcts for matrix below

#define SKIPDEPENDENTS_ONFALSE                      0x00000001  // Skips dependents
#define SKIPDEPENDENTS_ONTRUE                       0x00000002  // Skips dependents
#define CANCEL_AUTOPLAY_ONFALSE                     0x00000004
#define CANCEL_AUTOPLAY_ONTRUE                      0x00000008
#define NOTAPPLICABLE_ONANY                         0x00000010

#define LEVEL_EXECUTE                               0x10000000
#define LEVEL_SKIP                                  0x20000000
#define LEVEL_SPECIALMASK                           0x30000000
#define LEVEL_REALLEVELMASK                         0x0FFFFFFF

typedef BOOL (AUTORUNFCT)(HWND hwndForeground, CAutoPlayParams *papp);

// fct is called with pszDrive, papp->MountPoint(), hwndForeground, drive type and content type
struct AUTORUNCONDITION
{
    DWORD               dwNestingLevel;
    DWORD               dwMtPtDriveType;
    DWORD               dwMtPtContentType;
    DWORD               dwReturnValueHandling;
    AUTORUNFCT*         fct;
#ifdef DEBUG
    LPCWSTR             pszDebug;
#endif
};

// For this table to be more readable, add the content of \\stephstm\public\usertype.dat to
// %ProgramFiles%\Microsoft Visual Studio\Common\MSDev98\Bin\usertype.dat
// then restart MSDev

// AR_ENTRY -> AUTORUN_ENTRY
#ifdef DEBUG
#define AR_ENTRY(a, b, c, d, e) { (a), (b), (c), (d), CMountPoint::e, TEXT(#a) TEXT(":") TEXT(#b) TEXT(":") TEXT(#c) TEXT(":") TEXT(#d) TEXT(":") TEXT(#e) }
#else
#define AR_ENTRY(a, b, c, d, e) { (a), (b), (c), (d), CMountPoint::e }
#endif

// DT_* -> DriveType
// CT_* -> ContentType

static const AUTORUNCONDITION _rgAutorun[] =
{
    // We don't autorun if the drive is not mounted on a drive letter
    AR_ENTRY(0, DT_ANYTYPE, CT_ANYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acDriveIsMountedOnDriveLetter),
    // We don't autorun if this is a restricted drive
    AR_ENTRY(0, DT_ANYTYPE & ~DT_REMOTE, CT_ANYCONTENT, CANCEL_AUTOPLAY_ONTRUE, _acDriveIsRestricted),
        // Add the Autoplay Verb
        AR_ENTRY(1, DT_ANYTYPE & ~DT_REMOTE, CT_ANYCONTENT & ~CT_AUTORUNINF, SKIPDEPENDENTS_ONFALSE, _acAddAutoplayVerb),
    // We don't autorun if the Shift key is down
    AR_ENTRY(0, DT_ANYTYPE, CT_ANYCONTENT, CANCEL_AUTOPLAY_ONTRUE, _acShiftKeyDown),
    // We don't autorun if a laptop was just docked.  All devices in the craddle come as nhew devices.
    AR_ENTRY(0, DT_ANYTYPE & ~DT_REMOTE, CT_ANYCONTENT, CANCEL_AUTOPLAY_ONTRUE, _acWasjustDocked),
    // We don't autorun if the Current Desktop is not the active console desktop
    AR_ENTRY(0, DT_ANYTYPE, CT_ANYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acCurrentDesktopIsActiveConsole),
    // We don't autorun if the Current Desktop is not the active console desktop
    AR_ENTRY(0, DT_ANYTYPE, CT_ANYCONTENT, CANCEL_AUTOPLAY_ONTRUE, _acDirectXAppRunningFullScreen),
        // Remote drive always Autorun (mostly opening folder)
        AR_ENTRY(1, DT_REMOTE, CT_ANYCONTENT, SKIPDEPENDENTS_ONFALSE, _acForegroundAppAllowsAutorun),
        AR_ENTRY(1, DT_REMOTE, CT_ANYCONTENT, SKIPDEPENDENTS_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
            AR_ENTRY(2 | LEVEL_EXECUTE, DT_REMOTE, CT_ANYCONTENT, NOTAPPLICABLE_ONANY, _acShellExecuteDriveAutorunINF),
        // Autorun.inf
        AR_ENTRY(1, DT_ANYTYPE & ~DT_REMOVABLEDISK, CT_AUTORUNINF, SKIPDEPENDENTS_ONFALSE, _acHasAutorunCommand),
            AR_ENTRY(2, DT_ANYTYPE & ~DT_REMOVABLEDISK, CT_AUTORUNINF, SKIPDEPENDENTS_ONTRUE, _acHasUseAutoPLAY),
                AR_ENTRY(3, DT_ANYTYPE & ~DT_REMOVABLEDISK, CT_AUTORUNINF, CANCEL_AUTOPLAY_ONFALSE, _acForegroundAppAllowsAutorun),
                AR_ENTRY(3, DT_ANYTYPE & ~DT_REMOVABLEDISK, CT_AUTORUNINF, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
                    AR_ENTRY(4 | LEVEL_EXECUTE, DT_ANYCDDRIVES, CT_AUTORUNINF, NOTAPPLICABLE_ONANY, _acShellExecuteDriveAutorunINF),
        // CD Audio
        AR_ENTRY(1, DT_ANYCDDRIVES, CT_CDAUDIO, CANCEL_AUTOPLAY_ONFALSE, _acForegroundAppAllowsAutorun),
        AR_ENTRY(1, DT_ANYCDDRIVES, CT_CDAUDIO, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
            AR_ENTRY(2, DT_ANYCDDRIVES, CT_CDAUDIO, SKIPDEPENDENTS_ONFALSE, _acUserHasSelectedApplication),
                AR_ENTRY(3 | LEVEL_EXECUTE, DT_ANYCDDRIVES, CT_CDAUDIO, NOTAPPLICABLE_ONANY, _acExecuteAutoplayDefault),
        AR_ENTRY(LEVEL_EXECUTE | 1, DT_ANYCDDRIVES, CT_CDAUDIO, NOTAPPLICABLE_ONANY, _acPromptUser),
        // DVD Movie
        AR_ENTRY(1, DT_ANYCDDRIVES, CT_DVDMOVIE, CANCEL_AUTOPLAY_ONFALSE, _acForegroundAppAllowsAutorun),
        AR_ENTRY(1, DT_ANYCDDRIVES, CT_DVDMOVIE, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
            AR_ENTRY(2, DT_ANYCDDRIVES, CT_DVDMOVIE, SKIPDEPENDENTS_ONFALSE, _acUserHasSelectedApplication),
                AR_ENTRY(3 | LEVEL_EXECUTE, DT_ANYCDDRIVES, CT_DVDMOVIE, NOTAPPLICABLE_ONANY, _acExecuteAutoplayDefault),
        AR_ENTRY(LEVEL_EXECUTE | 1, DT_ANYCDDRIVES, CT_DVDMOVIE, NOTAPPLICABLE_ONANY, _acPromptUser),
        // Writable CDs
        AR_ENTRY(1, DT_ANYCDDRIVES, CT_BLANKCDWRITABLE, CANCEL_AUTOPLAY_ONFALSE, _acForegroundAppAllowsAutorun),
        AR_ENTRY(1, DT_ANYCDDRIVES, CT_BLANKCDWRITABLE, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
            AR_ENTRY(2, DT_ANYCDDRIVES, CT_BLANKCDWRITABLE, SKIPDEPENDENTS_ONFALSE, _acUserHasSelectedApplication),
                AR_ENTRY(3 | LEVEL_EXECUTE, DT_ANYCDDRIVES, CT_BLANKCDWRITABLE, NOTAPPLICABLE_ONANY, _acExecuteAutoplayDefault),
        AR_ENTRY(LEVEL_EXECUTE | 1, DT_ANYCDDRIVES, CT_BLANKCDWRITABLE, NOTAPPLICABLE_ONANY, _acPromptUser),
        // Writable DVDs
        AR_ENTRY(LEVEL_SKIP | 1, DT_ANYCDDRIVES, CT_BLANKCDWRITABLE, CANCEL_AUTOPLAY_ONFALSE, _acForegroundAppAllowsAutorun),
        AR_ENTRY(LEVEL_SKIP | 1, DT_ANYCDDRIVES, CT_BLANKCDWRITABLE, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
            AR_ENTRY(LEVEL_SKIP | 2, DT_ANYCDDRIVES, CT_BLANKCDWRITABLE, SKIPDEPENDENTS_ONFALSE, _acUserHasSelectedApplication),
                AR_ENTRY(LEVEL_SKIP | 3 | LEVEL_EXECUTE, DT_ANYDVDDRIVES, CT_BLANKDVDWRITABLE, NOTAPPLICABLE_ONANY, _acExecuteAutoplayDefault),
        AR_ENTRY(LEVEL_SKIP | LEVEL_EXECUTE | 1, DT_ANYDVDDRIVES, CT_BLANKDVDWRITABLE, NOTAPPLICABLE_ONANY, _acPromptUser),
        // Mixed content
        AR_ENTRY(1, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, SKIPDEPENDENTS_ONFALSE, _acIsMixedContent),
            AR_ENTRY(2, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, SKIPDEPENDENTS_ONTRUE, _acUserHasSelectedApplication),
                AR_ENTRY(3, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
                    AR_ENTRY(4 | LEVEL_EXECUTE, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, NOTAPPLICABLE_ONANY, _acPromptUser),
            AR_ENTRY(LEVEL_EXECUTE | 2, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, NOTAPPLICABLE_ONANY, _acExecuteAutoplayDefault),
        // Single Autoplay content
        AR_ENTRY(1, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
            AR_ENTRY(2, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, SKIPDEPENDENTS_ONTRUE, _acUserHasSelectedApplication),
                AR_ENTRY(3 | LEVEL_EXECUTE, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, NOTAPPLICABLE_ONANY, _acPromptUser),
            AR_ENTRY(LEVEL_EXECUTE | 2, DT_ANYTYPE & ~DT_REMOTE, CT_ANYAUTOPLAYCONTENT, NOTAPPLICABLE_ONANY, _acExecuteAutoplayDefault),
        // Unknown content
        AR_ENTRY(1, DT_ANYREMOVABLEMEDIADRIVES, CT_UNKNOWNCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acForegroundAppAllowsAutorun),
        AR_ENTRY(1, DT_ANYREMOVABLEMEDIADRIVES, CT_UNKNOWNCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
            // If we should not sniff, we should not open a folder either
            AR_ENTRY(2, DT_ANYREMOVABLEMEDIADRIVES, CT_UNKNOWNCONTENT, SKIPDEPENDENTS_ONFALSE, _acShouldSniff),
                AR_ENTRY(3 | LEVEL_EXECUTE, DT_ANYREMOVABLEMEDIADRIVES, CT_UNKNOWNCONTENT, NOTAPPLICABLE_ONANY, _acShellExecuteDriveAutorunINF),
            // Weird CDs have autorun.inf but no autorun command
            AR_ENTRY(2, DT_ANYREMOVABLEMEDIADRIVES, CT_AUTORUNINF, SKIPDEPENDENTS_ONTRUE, _acHasAutorunCommand),
                AR_ENTRY(3 | LEVEL_EXECUTE, DT_ANYREMOVABLEMEDIADRIVES, CT_AUTORUNINF, NOTAPPLICABLE_ONANY, _acShellExecuteDriveAutorunINF),
        // Former ShellOpen, basically we ShellExecute whatever drives except CD drives if the shell is in the foreground
        AR_ENTRY(1, ~DT_ANYCDDRIVES, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, SKIPDEPENDENTS_ONFALSE, _acShellIsForegroundApp),
            AR_ENTRY(2, ~DT_ANYCDDRIVES, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONTRUE, _acAlwaysReturnsTRUE),
                // Additonnal restrictions on Fixed disk drive
                AR_ENTRY(3, DT_FIXEDDISK, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acDriveIsFormatted),
                    AR_ENTRY(4, DT_FIXEDDISK, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONTRUE, _acOSIsServer),
                        AR_ENTRY(5, DT_FIXEDDISK, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONTRUE, _acIsDockedLaptop),
                            AR_ENTRY(6, DT_FIXEDDISK, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acForegroundAppAllowsAutorun),
                            AR_ENTRY(6, DT_FIXEDDISK, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
                                AR_ENTRY(7 | LEVEL_EXECUTE, DT_ANYTYPE, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, NOTAPPLICABLE_ONANY, _acShellExecuteDriveAutorunINF),
                // Non Fixed Disk drives
                AR_ENTRY(3, ~DT_FIXEDDISK, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acForegroundAppAllowsAutorun),
                AR_ENTRY(3, ~DT_FIXEDDISK, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, CANCEL_AUTOPLAY_ONFALSE, _acQueryCancelAutoplayAllowsAutorun),
                    AR_ENTRY(4 | LEVEL_EXECUTE, ~DT_FIXEDDISK, CT_ANYCONTENT & ~CT_ANYAUTOPLAYCONTENT, NOTAPPLICABLE_ONANY, _acShellExecuteDriveAutorunINF),
};

// This array will be dumped in the registry under the Volume GUID of the
// drive in a value named _AutorunStatus
//
// Each byte represents an entry in the above table.  Following is the
// meaning of each byte:
//
// 01: Condition was TRUE
// 00: Condition was FALSE
// CF: ContentType condition was failed
// DF: DriveType condition was failed
// 5F: Condition was skipped (5 looks like an 'S' :)
// EE: Condition was executed
// FF: Never got there

// Use a struct to avoid alignement issues
#pragma pack(push, 4)
struct AUTORUNSTATUS
{
    BYTE _rgbAutorunStatus[ARRAYSIZE(_rgAutorun)];
    DWORD dwDriveType;
    DWORD dwContentType;
};
#pragma pack(pop)

static AUTORUNSTATUS s_autorunstatus;

// static
void CMountPoint::DoAutorun(LPCWSTR pszDrive, DWORD dwAutorunFlags)
{
    CMountPoint* pmtpt = GetMountPoint(pszDrive);

    FillMemory(s_autorunstatus._rgbAutorunStatus, sizeof(s_autorunstatus._rgbAutorunStatus), -1);

    if (pmtpt)
    {
        CAutoPlayParams app(pszDrive, pmtpt, dwAutorunFlags);
        if (AUTORUNFLAG_MENUINVOKED & dwAutorunFlags)
        {
            _acPromptUser(GetForegroundWindow(), &app);
        }
        else
        {
            _DoAutorunHelper(&app);
        }

        pmtpt->Release();
    }
}

void CAutoPlayParams::_TrySniff()
{
    if (!(APS_DID_SNIFF & _state))
    {
        if (_ShouldSniffDrive(TRUE))
        {
            DWORD dwFound;

            if (SUCCEEDED(_Sniff(&dwFound)))
            {
                _dwContentType |= dwFound;
            }
        }

        _state |= APS_DID_SNIFF;
    }
}

BOOL CAutoPlayParams::IsContentTypePresent(DWORD dwContentType)
{
    BOOL fRet;

    if (CT_ANYCONTENT == dwContentType)
    {
        fRet = TRUE;
    }
    else
    {
        // We special case this because we do not want to sniff at this point
        if ((CT_ANYCONTENT & ~CT_AUTORUNINF) == dwContentType)
        {
            if (CT_AUTORUNINF == _dwContentType)
            {
                fRet = FALSE;
            }
            else
            {
                // Anything else is good
                fRet = TRUE;
            }
        }
        else
        {
            if (CT_ANYAUTOPLAYCONTENT & dwContentType)
            {
                _TrySniff();
            }

            fRet = !!(dwContentType & _dwContentType);
        }
    }

    return fRet;
}

void CAutoPlayParams::ForceSniff()
{
    if (AUTORUNFLAG_MENUINVOKED & _dwAutorunFlags)
    {
        _TrySniff();
    }
}

// static
void CMountPoint::_DoAutorunHelper(CAutoPlayParams *papp)
{
    DWORD dwMaxLevelToProcess = 0;
    BOOL fStop = FALSE;

    HWND hwndForeground = GetForegroundWindow();

    for (DWORD dwStep = 0; !fStop && (dwStep < ARRAYSIZE(_rgAutorun)); ++dwStep)
    {
        if (!(_rgAutorun[dwStep].dwNestingLevel & LEVEL_SKIP))
        {
            if ((_rgAutorun[dwStep].dwNestingLevel & LEVEL_REALLEVELMASK) <= dwMaxLevelToProcess)
            {
                BOOL fConditionResult = FALSE;
                // We do not want to Cancel the whole Autoplay operation if we do not get a
                // match for a drive type or content type.  We do the Cancel Autoplay only
                // if the condition was evaluated.
                BOOL fConditionEvaluated = FALSE;

                if (_rgAutorun[dwStep].dwMtPtDriveType & papp->DriveType())
                {
                    if (papp->IsContentTypePresent(_rgAutorun[dwStep].dwMtPtContentType))
                    {
                        if (!(_rgAutorun[dwStep].dwNestingLevel & LEVEL_EXECUTE))
                        {
                            fConditionResult = ((_rgAutorun[dwStep].fct)(hwndForeground, papp));

                            s_autorunstatus._rgbAutorunStatus[dwStep] = fConditionResult ? 1 : 0;

                            fConditionEvaluated = TRUE;
                        }
                        else
                        {
                            // LEVEL_EXECUTE
#ifdef DEBUG
                            TraceMsg(TF_MOUNTPOINT, "AUTORUN[%d]: EXECUTING -> %s", dwStep, _rgAutorun[dwStep].pszDebug);
#endif

                            _rgAutorun[dwStep].fct(hwndForeground, papp);

                            // 2 execute
                            s_autorunstatus._rgbAutorunStatus[dwStep] = 0xEE;

                            // We're done
                            fStop = TRUE;
                        }
                    }
                    else
                    {
#ifdef DEBUG
                        TraceMsg(TF_MOUNTPOINT, "AUTORUN[%d]: NO MATCH on CONTENTTYPE, %s ", dwStep, _rgAutorun[dwStep].pszDebug);
#endif
                        s_autorunstatus._rgbAutorunStatus[dwStep] = 0xCF;
                    }
                }
                else
                {
#ifdef DEBUG
                    TraceMsg(TF_MOUNTPOINT, "AUTORUN[%d]: NO MATCH on DRIVETYPE, %s ", dwStep, _rgAutorun[dwStep].pszDebug);
#endif
                    s_autorunstatus._rgbAutorunStatus[dwStep] = 0xDF;
                }

                if (!fStop)
                {
                    if (fConditionResult)
                    {
#ifdef DEBUG
                        TraceMsg(TF_MOUNTPOINT, "AUTORUN[%d]: TRUE -> %s", dwStep, _rgAutorun[dwStep].pszDebug);
#endif
                        switch (_rgAutorun[dwStep].dwReturnValueHandling)
                        {
                            case SKIPDEPENDENTS_ONTRUE:
                                dwMaxLevelToProcess = _rgAutorun[dwStep].dwNestingLevel & LEVEL_REALLEVELMASK;
                                break;

                            case CANCEL_AUTOPLAY_ONTRUE:
                                if (fConditionEvaluated)
                                {
                                    fStop = TRUE;
                                }

                                break;

                            default:
                                dwMaxLevelToProcess = (_rgAutorun[dwStep].dwNestingLevel & LEVEL_REALLEVELMASK) + 1;
                                break;

                            case NOTAPPLICABLE_ONANY:
                                break;
                        }
                    }
                    else
                    {
#ifdef DEBUG
                        TraceMsg(TF_MOUNTPOINT, "AUTORUN[%d]: FALSE -> %s", dwStep, _rgAutorun[dwStep].pszDebug);
#endif
                        switch (_rgAutorun[dwStep].dwReturnValueHandling)
                        {
                            case SKIPDEPENDENTS_ONFALSE:
                                dwMaxLevelToProcess = _rgAutorun[dwStep].dwNestingLevel & LEVEL_REALLEVELMASK;
                                break;

                            case CANCEL_AUTOPLAY_ONFALSE:
                                if (fConditionEvaluated)
                                {
                                    fStop = TRUE;
                                }

                                break;

                            default:
                                dwMaxLevelToProcess = (_rgAutorun[dwStep].dwNestingLevel & LEVEL_REALLEVELMASK) + 1;
                                break;

                            case NOTAPPLICABLE_ONANY:
                                break;
                        }                                
                    }
                }
            }
            else
            {
#ifdef DEBUG
                TraceMsg(TF_MOUNTPOINT, "AUTORUN[%d]: SKIPPING , %s ", dwStep, _rgAutorun[dwStep].pszDebug);
#endif
                s_autorunstatus._rgbAutorunStatus[dwStep] = 0x5F;
            }
        }
        else
        {
#ifdef DEBUG
            TraceMsg(TF_MOUNTPOINT, "AUTORUN[%d]: LVL-SKIP , %s ", dwStep, _rgAutorun[dwStep].pszDebug);
#endif
            s_autorunstatus._rgbAutorunStatus[dwStep] = 0x5F;
        }
    }

    s_autorunstatus.dwDriveType = papp->DriveType();
    s_autorunstatus.dwContentType = papp->ContentType();

    papp->MountPoint()->SetAutorunStatus((BYTE*)&s_autorunstatus, sizeof(s_autorunstatus));
}

DWORD _DoDWORDMapping(DWORD dwLeft, const TWODWORDS* rgtwodword, DWORD ctwodword, BOOL fORed)
{
    DWORD dwRight = 0;

    for (DWORD dw = 0; dw < ctwodword; ++dw)
    {
        if (fORed)
        {
            if (dwLeft & rgtwodword[dw].dwLeft)
            {
                dwRight |= rgtwodword[dw].dwRight;
            }
        }
        else
        {
            if (dwLeft == rgtwodword[dw].dwLeft)
            {
                dwRight = rgtwodword[dw].dwRight;
                break;
            }
        }
    }

    return dwRight;
}

STDMETHODIMP CSniffDrive::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CSniffDrive, INamespaceWalkCB),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP CSniffDrive::FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    // include everything
    HRESULT hr = S_OK;

    if (!_pne || !_pne->fStopSniffing)
    {
        // if we found everything we dont need to worry about sniffing
        // now we are just populating the dataobject
        if (!_FoundEverything())
        {
            PERCEIVED gen = GetPerceivedType(psf, pidl);

            if (GEN_IMAGE == gen)
            {
                _dwFound |= CT_AUTOPLAYPIX;
            }
            else if (GEN_AUDIO == gen)
            {
                _dwFound |= CT_AUTOPLAYMUSIC;
            }
            else if (GEN_VIDEO == gen)
            {
                _dwFound |= CT_AUTOPLAYMOVIE;
            }
            else            
            {
                _dwFound |= CT_UNKNOWNCONTENT;
            }

            hr = S_OK;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    //  we never want the results on the sniff
    return hr;
}

STDMETHODIMP CSniffDrive::EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return S_OK;
}

STDMETHODIMP CSniffDrive::LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return S_OK;
}

STDMETHODIMP CSniffDrive::InitializeProgressDialog(LPWSTR *ppszTitle, LPWSTR *ppszCancel)
{
    *ppszCancel = NULL; // use default

    TCHAR szMsg[256];
    
    LoadString(g_hinst, IDS_AP_SNIFFPROGRESSDIALOG, szMsg, ARRAYSIZE(szMsg));
    
    return SHStrDup(szMsg, ppszTitle);
}

// static
HRESULT CSniffDrive::Init(HANDLE hThreadSCN)
{
    HRESULT hr;

    if (DuplicateHandle(GetCurrentProcess(), hThreadSCN, GetCurrentProcess(),
        &_hThreadSCN, THREAD_ALL_ACCESS, FALSE, 0))
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return S_OK;
}

// static
HRESULT CSniffDrive::CleanUp()
{
    if (_dpaNotifs)
    {
        // We should not need to delete the items, they should all be removed.  Even
        // if they're, we should leave them there since something will probably try
        // to access them.
        _dpaNotifs.Destroy();
        _dpaNotifs = NULL;
    }

    if (_hThreadSCN)
    {
        CloseHandle(_hThreadSCN);
        _hThreadSCN = NULL;
    }

    return S_OK;
}

// static
HRESULT CSniffDrive::InitNotifyWindow(HWND hwnd)
{
    _hwndNotify = hwnd;

    return S_OK;
}

HRESULT CSniffDrive::RegisterForNotifs(LPCWSTR pszDeviceIDVolume)
{
    HRESULT hr;

    _pne = new PNPNOTIFENTRY();

    if (_pne)
    {
        HANDLE hDevice = CreateFile(pszDeviceIDVolume, FILE_READ_ATTRIBUTES,
           FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

        if (INVALID_HANDLE_VALUE != hDevice)
        {
            DEV_BROADCAST_HANDLE dbhNotifFilter = {0};

            // Assume failure
            hr = E_FAIL;

            dbhNotifFilter.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
            dbhNotifFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;
            dbhNotifFilter.dbch_handle = hDevice;

            _pne->hdevnotify = RegisterDeviceNotification(_hwndNotify, &dbhNotifFilter,
                DEVICE_NOTIFY_WINDOW_HANDLE);

            if (_pne->hdevnotify)
            {
                _pne->AddRef();

                if (QueueUserAPC(CSniffDrive::_RegisterForNotifsHelper, _hThreadSCN, (ULONG_PTR)_pne))
                {
                    hr = S_OK;
                }
                else
                {
                    _pne->Release();
                }
            }

            CloseHandle(hDevice);
        }
        else
        {
            hr = E_FAIL;
        }

        if (FAILED(hr))
        {
            // Something must have gone wrong
            _pne->Release();
            _pne = NULL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CSniffDrive::UnregisterForNotifs()
{
    UnregisterDeviceNotification(_pne->hdevnotify);
    
    QueueUserAPC(CSniffDrive::_UnregisterForNotifsHelper, _hThreadSCN, (ULONG_PTR)_pne);

    _pne->Release();
    _pne = NULL;

    return S_OK;
}

// static
void CALLBACK CSniffDrive::_RegisterForNotifsHelper(ULONG_PTR ul)
{
    PNPNOTIFENTRY* pne = (PNPNOTIFENTRY*)ul;

    if (!_dpaNotifs)
    {
        _dpaNotifs.Create(1);
    }

    if (_dpaNotifs)
    {
        // We do not check the return value.  We cannot free it, since the thread that
        // queued this APC to us, expect this chunk of mem to be there until it calls
        // UnregisterNotify.  We'll leak it.  Hopefully, this won't happen often.
        _dpaNotifs.AppendPtr(pne);
    }
}

// static
void CALLBACK CSniffDrive::_UnregisterForNotifsHelper(ULONG_PTR ul)
{
    PNPNOTIFENTRY* pne = (PNPNOTIFENTRY*)ul;

    if (_dpaNotifs)
    {
        int cItem = _dpaNotifs.GetPtrCount();

        for (int i = 0; i < cItem; ++i)
        {
            PNPNOTIFENTRY* pneTmp = _dpaNotifs.GetPtr(i);
        
            if (pneTmp->hdevnotify == pne->hdevnotify)
            {
                CloseHandle(pne->hThread);

                _dpaNotifs.DeletePtr(i);

                pne->Release();

                break;
            }
        }
    }
}

// static
HRESULT CSniffDrive::HandleNotif(HDEVNOTIFY hdevnotify)
{
    int cItem = _dpaNotifs ? _dpaNotifs.GetPtrCount() : 0;

    for (int i = 0; i < cItem; ++i)
    {
        PNPNOTIFENTRY* pneTmp = _dpaNotifs.GetPtr(i);
        
        if (pneTmp->hdevnotify == hdevnotify)
        {
            pneTmp->fStopSniffing = TRUE;

            // We don't check the return value.  The worst that will happen is that this
            // fails and we'll return too early and PnP will prompt the user to reboot.
            // Wait 2 minutes
            WaitForSingleObjectEx(pneTmp->hThread, 2 * 60 * 1000, FALSE);
        
            break;
        }
    }
    
    return S_OK;
}

BOOL CSniffDrive::_FoundEverything()
{
    return (_dwFound & DRIVEHAS_EVERYTHING) == DRIVEHAS_EVERYTHING;
}

CSniffDrive::CSniffDrive() : _dwFound(0)
{}

CSniffDrive::~CSniffDrive()
{}

void CMountPoint::SetAutorunStatus(BYTE* rgb, DWORD cbSize)
{
    RSSetBinaryValue(NULL, TEXT("_AutorunStatus"), rgb, cbSize);
}

class CAutoPlayVerb : public IDropTarget
{
public:
    CAutoPlayVerb() : _cRef(1) {}

    //  IUnknown refcounting
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void)
    {
       return ++_cRef;
    }

    STDMETHODIMP_(ULONG) Release(void)
    {
        if (--_cRef > 0)
            return _cRef;

        delete this;
        return 0;    
    }

    // IDropTarget ***
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

protected:
    LONG _cRef;
};

HRESULT CAutoPlayVerb::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAutoPlayVerb, IDropTarget),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

// IDropTarget::DragEnter
HRESULT CAutoPlayVerb::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    return S_OK;;
}

// IDropTarget::DragOver
HRESULT CAutoPlayVerb::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    return S_OK;;
}

// IDropTarget::DragLeave
HRESULT CAutoPlayVerb::DragLeave(void)
{
    return S_OK;
}

STDAPI CAutoPlayVerb_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppv = NULL;
    
    // aggregation checking is handled in class factory
    CAutoPlayVerb* p = new CAutoPlayVerb();
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}

STDAPI SHChangeNotifyAutoplayDrive(PCWSTR pszDrive);

// IDropTarget::DragDrop
HRESULT CAutoPlayVerb::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    //  start the AutoPlayDialog
    WCHAR szDrive[4];
    HRESULT hr = PathFromDataObject(pdtobj, szDrive, ARRAYSIZE(szDrive));
    if (SUCCEEDED(hr))
    {
        hr = SHChangeNotifyAutoplayDrive(szDrive);
    }
    return hr;
}

DWORD CALLBACK _AutorunPromptProc(void *pv)
{
    WCHAR szDrive[4];
    CMountPoint::DoAutorun(PathBuildRoot(szDrive, PtrToInt(pv)), AUTORUNFLAG_MENUINVOKED);
    return 0;
}

void CMountPoint::DoAutorunPrompt(WPARAM iDrive)
{
    SHCreateThread(_AutorunPromptProc, (void *)iDrive, CTF_COINIT | CTF_REF_COUNTED, NULL);
}

STDAPI_(void) Activate_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
    DWORD dwProcessID;
    HWND hwnd = GetShellWindow();

    GetWindowThreadProcessId(hwnd, &dwProcessID);

    AllowSetForegroundWindow(dwProcessID);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mtptis2.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "mtpt.h"

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
BOOL CMountPoint::IsCDROM()
{
    return _IsCDROM();
}

BOOL CMountPoint::IsFixedDisk()
{
    return _IsFixedDisk();
}

BOOL CMountPoint::IsStrictRemovable()
{
    return _IsStrictRemovable();
}

BOOL CMountPoint::IsRemote()
{
    return _IsRemote();
}

BOOL CMountPoint::IsFloppy()
{
    return _IsFloppy();
}

BOOL CMountPoint::IsDVD()
{
    return _IsDVD();
}

BOOL CMountPoint::IsAudioCD()
{
    return _IsAudioCD();
}

BOOL CMountPoint::IsAudioCDNoData()
{
    return _IsAudioCDNoData();
}

BOOL CMountPoint::IsDVDRAMMedia()
{
    return _IsDVDRAMMedia();
}

BOOL CMountPoint::IsFormattable()
{
    return _IsFormattable();
}

BOOL CMountPoint::IsCompressible()
{
    return ((DRIVE_ISCOMPRESSIBLE & _GetGVIDriveFlags()) ? TRUE : FALSE);
}

BOOL CMountPoint::IsRemovableDevice()
{
    return _IsRemovableDevice();
}

BOOL CMountPoint::IsCompressed()
{
    BOOL fRet = FALSE;

    if (!_IsFloppy35() && !_IsFloppy525() && !_IsCDROM())
    {
        DWORD dwAttrib;

        TraceMsg(TF_MOUNTPOINT, "CMountPoint::IsCompressed: for '%s'", _GetName());

        if (_GetFileAttributes(&dwAttrib))
        {
            if (dwAttrib & FILE_ATTRIBUTE_COMPRESSED)
            {
                fRet = TRUE;
            }
        }
    }

    return (fRet ? TRUE : FALSE);
}

BOOL CMountPoint::IsSupportingSparseFile()
{
    BOOL fRet = FALSE;
    DWORD dwFlags;
    
    if (_GetFileSystemFlags(&dwFlags))
    {
        fRet = (FILE_SUPPORTS_SPARSE_FILES & dwFlags) ? TRUE : FALSE;
    }

    return fRet;
}

BOOL CMountPoint::IsContentIndexed()
{
    BOOL fRet = FALSE;
    DWORD dwAttrib;

    TraceMsg(TF_MOUNTPOINT, "CMountPoint::IsContentIndexed: for '%s'", _GetName());

    if (_GetFileAttributes(&dwAttrib))
    {
        fRet = !(FILE_ATTRIBUTE_NOT_CONTENT_INDEXED & dwAttrib);
    }

    return (fRet ? TRUE : FALSE);
}

BOOL CMountPoint::IsNTFS()
{
    BOOL fRet = FALSE;
    WCHAR szFileSysName[MAX_FILESYSNAME];

    if (_GetFileSystemName(szFileSysName, ARRAYSIZE(szFileSysName)))
    {
        fRet = BOOLFROMPTR(StrStr(TEXT("NTFS"), szFileSysName));
    }

    return fRet;
}

BOOL CMountPoint::_IsLFN()
{
    int iFlags = GetVolumeFlags();

    return !!(iFlags & DRIVE_LFN);
}

BOOL CMountPoint::_IsSecure()
{
    int iFlags = GetVolumeFlags();

    return !!(iFlags & DRIVE_SECURITY);
}

/////////////////////////////////////////////////////////////////////////////
// static IsXXX fct
/////////////////////////////////////////////////////////////////////////////
STDAPI_(BOOL) CMtPt_IsSlow(int iDrive)
{
    BOOL fRet = FALSE;
    CMountPoint* pmtpt = CMountPoint::GetMountPoint(iDrive, FALSE);

    if (pmtpt)
    {
        fRet = pmtpt->_IsSlow();

        pmtpt->Release();
    }

    return fRet;
}

STDAPI_(BOOL) CMtPt_IsLFN(int iDrive)
{
    BOOL fRet = FALSE;
    CMountPoint* pmtpt = CMountPoint::GetMountPoint(iDrive, FALSE);

    if (pmtpt)
    {
        fRet = pmtpt->_IsLFN();

        pmtpt->Release();
    }

    return fRet;
}

STDAPI_(BOOL) CMtPt_IsSecure(int iDrive)
{
    BOOL fRet = FALSE;
    CMountPoint* pmtpt = CMountPoint::GetMountPoint(iDrive, FALSE);

    if (pmtpt)
    {
        fRet = pmtpt->_IsSecure();

        pmtpt->Release();
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\msgbox.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "uemapp.h"

#define MAXRCSTRING 514

// Major hack follows to get this to work with the DEBUG alloc/free -- on NT
// Local and Global heap functions evaluate to the same heap.  The problem
// here is that LocalFree gets mapped to DebugLocalFree, but when we
// call FormatMessage, the buffer is not allocated through DebugLocalAlloc,
// so it dies.
//
#ifdef DEBUG
#undef LocalFree
#define LocalFree GlobalFree
#endif

// this will check to see if lpcstr is a resource id or not.  if it
// is, it will return a LPSTR containing the loaded resource.
// the caller must LocalFree this lpstr.  if pszText IS a string, it
// will return pszText
//
// returns:
//      pszText if it is already a string
//      or
//      LocalAlloced() memory to be freed with LocalFree
//      if pszRet != pszText free pszRet

LPTSTR WINAPI ResourceCStrToStr(HINSTANCE hInst, LPCTSTR pszText)
{
    TCHAR szTemp[MAXRCSTRING];
    LPTSTR pszRet = NULL;

    if (!IS_INTRESOURCE(pszText))
        return (LPTSTR)pszText;

    if (LOWORD((DWORD_PTR)pszText) && LoadString(hInst, LOWORD((DWORD_PTR)pszText), szTemp, ARRAYSIZE(szTemp)))
    {
        size_t cch = lstrlen(szTemp) + 1;
        pszRet = LocalAlloc(LPTR, cch * SIZEOF(TCHAR));
        if (pszRet)
            StringCchCopy(pszRet, cch, szTemp);
    }
    return pszRet;
}

LPSTR ResourceCStrToStrA(HINSTANCE hInst, LPCSTR pszText)
{
    CHAR szTemp[MAXRCSTRING];
    LPSTR pszRet = NULL;

    if (!IS_INTRESOURCE(pszText))
        return (LPSTR)pszText;

    if (LOWORD((DWORD_PTR)pszText) && LoadStringA(hInst, LOWORD((DWORD_PTR)pszText), szTemp, ARRAYSIZE(szTemp)))
    {
        size_t cch = (lstrlenA(szTemp) + 1);
        pszRet = LocalAlloc(LPTR, cch * SIZEOF(CHAR));
        if (pszRet)
            StringCchCopyA(pszRet, cch, szTemp);
    }
    return pszRet;
}

LPTSTR _ConstructMessageString(HINSTANCE hInst, LPCTSTR pszMsg, va_list *ArgList)
{
    LPTSTR pszRet;
    LPTSTR pszRes = ResourceCStrToStr(hInst, pszMsg);
    if (!pszRes)
    {
        DebugMsg(DM_ERROR, TEXT("_ConstructMessageString: Failed to load string template"));
        return NULL;
    }

    if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                       pszRes, 0, 0, (LPTSTR)&pszRet, 0, ArgList))
    {
        DebugMsg(DM_ERROR, TEXT("_ConstructMessageString: FormatMessage failed %d"),GetLastError());
        DebugMsg(DM_ERROR, TEXT("                         pszRes = %s"), pszRes );
        DebugMsg(DM_ERROR, !IS_INTRESOURCE(pszMsg) ? 
        TEXT("                         pszMsg = %s") : 
        TEXT("                         pszMsg = 0x%x"), pszMsg );
        pszRet = NULL;
    }

    if (pszRes != pszMsg)
        LocalFree(pszRes);

    return pszRet;      // free with LocalFree()
}

LPSTR _ConstructMessageStringA(HINSTANCE hInst, LPCSTR pszMsg, va_list *ArgList)
{
    LPSTR pszRet;
    LPSTR pszRes = ResourceCStrToStrA(hInst, pszMsg);
    if (!pszRes)
    {
        DebugMsg(DM_ERROR, TEXT("_ConstructMessageString: Failed to load string template"));
        return NULL;
    }

    if (!FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                       pszRes, 0, 0, (LPSTR)&pszRet, 0, ArgList))
    {
        DebugMsg(DM_ERROR, TEXT("_ConstructMessageString: FormatMessage failed %d"),GetLastError());
        DebugMsg(DM_ERROR, TEXT("                         pszRes = %S"), pszRes );

        DebugMsg(DM_ERROR, !IS_INTRESOURCE(pszMsg) ? 
        TEXT("                         pszMsg = %s") : 
        TEXT("                         pszMsg = 0x%x"), pszMsg );
        pszRet = NULL;
    }

    if (pszRes != pszMsg)
        LocalFree(pszRes);

    return pszRet;      // free with LocalFree()
}

// NOTE: ShellMessageBoxW has been re-implemented in shlwapi, so shell32 redirects that api there
// Shlwapi doesn't need an A version (because it's in shell32), so we're leaving this code here...
// 
int WINCAPI ShellMessageBoxA(HINSTANCE hInst, HWND hWnd, LPCSTR pszMsg, LPCSTR pszTitle, UINT fuStyle, ...)
{
    LPSTR pszText;
    int result;
    CHAR szBuffer[80];
    va_list ArgList;

    // BUG 95214
#ifdef DEBUG
    IUnknown* punk = NULL;
    if (SUCCEEDED(SHGetThreadRef(&punk)) && punk)
    {
        ASSERTMSG(hWnd != NULL, "shell32\\msgbox.c : ShellMessageBoxA - Caller should either be not under a browser or should have a parent hwnd");
        punk->lpVtbl->Release(punk);
    }
#endif

    if (!IS_INTRESOURCE(pszTitle))
    {
        // do nothing
    }
    else if (LoadStringA(hInst, LOWORD((DWORD_PTR)pszTitle), szBuffer, ARRAYSIZE(szBuffer)))
    {
        // Allow this to be a resource ID or NULL to specifiy the parent's title
        pszTitle = szBuffer;
    }
    else if (hWnd)
    {
        // Grab the title of the parent
        GetWindowTextA(hWnd, szBuffer, ARRAYSIZE(szBuffer));

        //
        //  we would rather not use the "Desktop" as our title,
        //  but sometimes that is the window that is used, and we dont
        //  have a better title.  callers should review to make sure that
        //  they want "Desktop" as the title to the dialog in 
        //  the case that the hwnd passed in is the desktop window.
        //
        if (!lstrcmpA(szBuffer, "Program Manager")) 
        {
            LoadStringA(HINST_THISDLL, IDS_DESKTOP, szBuffer, ARRAYSIZE(szBuffer));
            pszTitle = szBuffer;
            DebugMsg(TF_WARNING, TEXT("No caption for SHMsgBox() on desktop"));
        } 
        else
            pszTitle = szBuffer;
    }
    else
    {
        pszTitle = "";
    }

    va_start(ArgList, fuStyle);
    pszText = _ConstructMessageStringA(hInst, pszMsg, &ArgList);
    va_end(ArgList);

    if (pszText)
    {
        result = MessageBoxA(hWnd, pszText, pszTitle, fuStyle | MB_SETFOREGROUND);
        LocalFree(pszText);
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("smb: Not enough memory to put up dialog."));
        result = -1;    // memory failure
    }

    return result;
}


//
// returns:
//      pointer to formatted string, free this with SHFree() (not Free())
//

LPTSTR WINCAPI ShellConstructMessageString(HINSTANCE hInst, LPCTSTR pszMsg, ...)
{
    LPTSTR pszRet;
    va_list ArgList;

    va_start(ArgList, pszMsg);

    pszRet = _ConstructMessageString(hInst, pszMsg, &ArgList);

    va_end(ArgList);

    return pszRet;      // free with SHFree()
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mtptl.h ===
#include "mtpt.h"

class CVolume;

class CMtPtLocal : public CMountPoint
{
///////////////////////////////////////////////////////////////////////////////
// Public methods
///////////////////////////////////////////////////////////////////////////////
public:
    CMtPtLocal();
    ~CMtPtLocal();

    HRESULT GetMountPointName(LPWSTR pszMountPoint, DWORD cchMountPoint);
    HRESULT Eject(HWND hwnd);

    BOOL IsEjectable();
    BOOL HasMedia();

    BOOL IsFormatted();
    BOOL IsMounted();

    HRESULT GetCDInfo(DWORD* pdwDriveCapabilities, DWORD* pdwMediaCapabilities);

    HRESULT GetLabel(LPTSTR pszLabel, DWORD cchLabel);
    HRESULT GetLabelNoFancy(LPTSTR pszLabel, DWORD cchLabel);
    HRESULT SetLabel(HWND hwnd, LPCTSTR pszLabel);
    HRESULT SetDriveLabel(HWND hwnd, LPCTSTR pszLabel);
    HRESULT ChangeNotifyRegisterAlias(void)
        { /* no-op */ return NOERROR; }

    int GetDriveFlags();
    HRESULT GetRemotePath(LPWSTR pszPath, DWORD cchPath) { return E_NOTIMPL; }
    void GetTypeString(LPTSTR pszType, DWORD cchType);

    void StoreIconForUpdateImage(int iImage);

    UINT GetIcon(LPTSTR pszModule, DWORD cchModule);
    HRESULT GetAssocSystemElement(IAssociationElement **ppae);
    DWORD GetShellDescriptionID();

    HKEY GetRegKey();

    static BOOL IsVolume(LPCWSTR pszDeviceID);

///////////////////////////////////////////////////////////////////////////////
// Miscellaneous helpers
///////////////////////////////////////////////////////////////////////////////
public: // should be used in mtptmgmt2.cpp only
    BOOL _IsMiniMtPt();
    BOOL _NeedToRefresh();

public: // should be used in mtptarun2.cpp only (when used outside of CMtPtLocal)
    BOOL _IsMediaPresent();
    BOOL _CanUseVolume();

private:
    HRESULT _InitWithVolume(LPCWSTR pszMtPt, CVolume* pvol);
    HRESULT _Init(LPCWSTR pszMtPt);

    LPCTSTR _GetNameForFctCall();

    BOOL _IsFloppy();
    BOOL _IsFloppy35();
    BOOL _IsFloppy525();
    BOOL _IsCDROM();
    // real removable, excludes floppies
    BOOL _IsStrictRemovable();
    BOOL _IsFixedDisk();

    BOOL _IsFormattable();
    BOOL _IsAudioCD();
    BOOL _IsAudioCDNoData();
    BOOL _IsDVD();
    BOOL _IsRemovableDevice();

    BOOL _IsAutorun();
    BOOL _IsDVDDisc();
    BOOL _IsDVDRAMMedia();
    BOOL _IsAudioDisc();

    BOOL _ForceCheckMediaPresent();
    BOOL _IsFormatted();
    BOOL _IsReadOnly();

    // returns DT_* defined above
    DWORD _GetMTPTDriveType();
    // returns CT_* defined above
    DWORD _GetMTPTContentType();

    BOOL _GetFileAttributes(DWORD* pdwAttrib);
    BOOL _GetFileSystemName(LPTSTR pszFileSysName, DWORD cchFileSysName);
    BOOL _GetGVILabelOrMixedCaseFromReg(LPTSTR pszLabel, DWORD cchLabel);
    BOOL _GetGVILabel(LPTSTR pszLabel, DWORD cchLabel);
    BOOL _GetSerialNumber(DWORD* pdwSerialNumber);
    BOOL _GetFileSystemFlags(DWORD* pdwFlags);
    int _GetGVIDriveFlags();
    int _GetDriveType();
    DWORD _GetAutorunContentType();

    HRESULT _Eject(HWND hwnd, LPTSTR pszMountPointNameForError);

    BOOL _HasAutorunLabel();
    BOOL _HasAutorunIcon();
    UINT _GetAutorunIcon(LPTSTR pszModule, DWORD cchModule);
    void _GetAutorunLabel(LPWSTR pszLabel, DWORD cchLabel);
    void _InitLegacyRegIconAndLabelHelper();
    void _InitAutorunInfo();

    BOOL _IsMountedOnDriveLetter();

    HANDLE _GetHandleWithAccessAndShareMode(DWORD dwDesiredAccess, DWORD dwShareMode);
    HANDLE _GetHandleReadRead();

    UINT _GetCDROMIcon();
    BOOL _GetCDROMName(LPWSTR pszName, DWORD cchName);

    DWORD _GetRegVolumeGen();

public:
    static BOOL Initialize();
    static void FinalCleanUp();

    static HRESULT _GetAndRemoveVolumeAndItsMtPts(LPCWSTR pszDeviceIDVolume,
        CVolume** ppvol, HDPA hdpaMtPts);
    static CVolume* _GetVolumeByID(LPCWSTR pszDeviceIDVolume);
    static CVolume* _GetVolumeByMtPt(LPCWSTR pszMountPoint);
    static HRESULT _CreateMtPtLocalWithVolume(LPCWSTR pszMountPoint, CVolume* pvol);
    static HRESULT _CreateMtPtLocal(LPCWSTR pszMountPoint);
    static HRESULT _CreateMtPtLocalFromVolumeGuid(LPCWSTR pszVolumeGuid, CMountPoint ** ppmtpt );
    static HRESULT _CreateVolume(VOLUMEINFO* pvolinfo, CVolume** ppvolNew);

    static HRESULT _CreateVolumeFromReg(LPCWSTR pszDeviceIDVolume, CVolume** ppvolNew);
    static HRESULT _CreateVolumeFromRegHelper(LPCWSTR pszGUID, CVolume** ppvolNew);
    static HRESULT _CreateVolumeFromVOLUMEINFO2(VOLUMEINFO2* pvolinfo2, CVolume** ppvolNew);

    static CVolume* _GetAndRemoveVolumeByID(LPCWSTR pszDeviceIDVolume);

    static HRESULT _UpdateVolumeRegInfo(VOLUMEINFO* pvolinfo);
    static HRESULT _UpdateVolumeRegInfo2(VOLUMEINFO2* pvolinfo2);
///////////////////////////////////////////////////////////////////////////////
// Data
///////////////////////////////////////////////////////////////////////////////
public: // should be used in mtptarun2.cpp only (when used outside of CMtPtLocal)
    CVolume*                _pvol;

    // should be used in mtptevnt.cpp only (when used outside of CMtPtLocal)

    // Watch out!  No constructor nor destructor called on the next member
    static CRegSupport      _rsVolumes;

private:
    BOOL                    _fMountedOnDriveLetter;
    BOOL                    _fVolumePoint;

    WCHAR                   _szNameNoVolume[2];

#ifdef DEBUG
private:
    static DWORD            _cMtPtLocal;
#endif
};

class CVolume
{
public:
    DWORD       dwGeneration;
    DWORD       dwState;
    LPWSTR      pszDeviceIDVolume; // \\?\STORAGE#Volume#...{...GUID...}
    LPWSTR      pszVolumeGUID;     // \\?\Volume{...GUID...}
    DWORD       dwVolumeFlags;               // see HWDVF_... flags
    DWORD       dwDriveType;                 // see HWDT_... flags
    DWORD       dwDriveCapability;          // see HWDDC_... flags
    LPWSTR      pszLabel;          // 
    LPWSTR      pszFileSystem;     // 
    DWORD       dwFileSystemFlags;           // 
    DWORD       dwMaxFileNameLen;            // 
    DWORD       dwRootAttributes;            // 
    DWORD       dwSerialNumber;              // 
    DWORD       dwDriveState;                // see HWDDS_...
    DWORD       dwMediaState;                // see HWDMS_...
    DWORD       dwMediaCap;

    int         iShellImageForUpdateImage;
    LPWSTR      pszAutorunIconLocation;
    LPWSTR      pszAutorunLabel;
    LPWSTR      pszKeyName;

    LPWSTR      pszIconFromService;
    LPWSTR      pszNoMediaIconFromService;
    LPWSTR      pszLabelFromService;

public:
    ULONG AddRef()
    { return InterlockedIncrement(&_cRef); }

    ULONG Release()
    {
        ASSERT( 0 != _cRef );
        ULONG cRef = InterlockedDecrement(&_cRef);
        if ( 0 == cRef )
        {
            delete this;
        }
        return cRef;
    }

private:
    LONG            _cRef;

public:
    CVolume() : _cRef(1)
    {
#ifdef DEBUG
        ++_cVolume;
#endif
    }
    ~CVolume()
    {
        if (pszDeviceIDVolume)
        {
            LocalFree(pszDeviceIDVolume);
        }
        if (pszVolumeGUID)
        {
            LocalFree(pszVolumeGUID);
        }
        if (pszLabel)
        {
            LocalFree(pszLabel);
        }
        if (pszFileSystem)
        {
            LocalFree(pszFileSystem);
        }
        if (pszAutorunIconLocation)
        {
            LocalFree(pszAutorunIconLocation);
        }
        if (pszAutorunLabel)
        {
            LocalFree(pszAutorunLabel);
        }
        if (pszIconFromService)
        {
            LocalFree(pszIconFromService);
        }
		if (pszNoMediaIconFromService)
        {
            LocalFree(pszNoMediaIconFromService);
        }
        if (pszLabelFromService)
        {
            LocalFree(pszLabelFromService);
        }
#ifdef DEBUG
        --_cVolume;
#endif
    }
#ifdef DEBUG
private:
    static DWORD                _cVolume;
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mtptevnt.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "mtpt.h"
#include "mtptl.h"
#include "mtptr.h"

#include "hwcmmn.h"
#include "cdburn.h"

#include "mixctnt.h"
#include "regsuprt.h"

// Misc comments:

// (1) Do a DoAutorun for all new drives except network ones.  These will be
//     generated externally... 

// static
void CMountPoint::WantAutorunUI(LPCWSTR pszDrive)
{
    int iDrive = DRIVEID(pszDrive);

    CMountPoint::_dwRemoteDriveAutorun |= (1 << iDrive);    
}

BOOL _Shell32LoadedInDesktop()
{
    static BOOL fLoadedInExplorer = -1;

    if (-1 == fLoadedInExplorer)
    {
        fLoadedInExplorer = BOOLFROMPTR(GetModuleHandle(TEXT("EXPLORER.EXE")));
    }

    return fLoadedInExplorer;
}

// static
void CMountPoint::OnNetShareArrival(LPCWSTR pszDrive)
{
    _csDL.Enter();

    if (!_fNetDrivesInited)
    {
        _InitNetDrives();
    }

    _csDL.Leave();

    if (_fNetDrivesInited)
    {
        WCHAR szDriveNoSlash[] = TEXT("A:");
        WCHAR szRemoteName[MAX_PATH];
        DWORD cchRemoteName = ARRAYSIZE(szRemoteName);
        HRESULT hr;
        int iDrive = DRIVEID(pszDrive);

        szDriveNoSlash[0] = *pszDrive;

        DWORD dw = WNetGetConnection(szDriveNoSlash, szRemoteName, &cchRemoteName);

        if (NO_ERROR == dw)
        {
            hr = CMtPtRemote::_CreateMtPtRemote(pszDrive, szRemoteName,
                TRUE);
        }
        else
        {
            DWORD dwGLD = GetLogicalDrives();

            if (dwGLD & (1 << iDrive))
            {
                // This must be a weird System mapped drive
                // which WNet... fcts don't like
                hr = CMtPtRemote::_CreateMtPtRemoteWithoutShareName(pszDrive);
            }
            else
            {
                hr = E_FAIL;
            }
        }

        if (SUCCEEDED(hr))
        {
            SHChangeNotify(SHCNE_DRIVEADD, SHCNF_PATH, pszDrive, NULL);

            if (CMountPoint::_dwRemoteDriveAutorun & (1 << iDrive))
            {
                DoAutorun(pszDrive, AUTORUNFLAG_MTPTARRIVAL);

                CMountPoint::_dwRemoteDriveAutorun &= ~(1 << iDrive);
            }
        }
    }
}

// static
void CMountPoint::OnNetShareRemoval(LPCWSTR pszDrive)
{
    _csDL.Enter();

    if (!_fNetDrivesInited)
    {
        _InitNetDrives();
    }

    _csDL.Leave();

    if (_fNetDrivesInited)
    {
        _RemoveNetMountPoint(pszDrive);

        SHChangeNotify(SHCNE_DRIVEREMOVED, SHCNF_PATH, pszDrive, NULL);

        // There's a possibility that this net drive was covering a local drive
        // with the same drive letter

        CMountPoint* pmtpt = CMountPoint::GetMountPoint(pszDrive);

        if (pmtpt)
        {
            if (CMountPoint::_IsDriveLetter(pszDrive))
            {
                CDBurn_OnDeviceChange(TRUE, pszDrive);
            }
     
            SHChangeNotify(SHCNE_DRIVEADD, SHCNF_PATH, pszDrive, NULL);

            pmtpt->Release();
        }
    }
}

// static
void CMountPoint::OnMediaArrival(LPCWSTR pszDrive)
{
    // Check if this local drive letter is not "covered" by a net
    // drive letter
    if (!_LocalDriveIsCoveredByNetDrive(pszDrive))
    {
        BOOL fDriveLetter = CMountPoint::_IsDriveLetter(pszDrive);

        if (fDriveLetter)
        {
            CDBurn_OnMediaChange(TRUE, pszDrive);
        }

        SHChangeNotify(SHCNE_MEDIAINSERTED, SHCNF_PATH, pszDrive, NULL);

        // for now do it only for drive letter mounted stuff 
        if (fDriveLetter)
        {
            // Send one of these for all media arrival events
            DoAutorun(pszDrive, AUTORUNFLAG_MEDIAARRIVAL);
        }

        // for the non net case force these through right away to make those
        // cd-rom autorun things come up faster
        SHChangeNotify(0, SHCNF_FLUSH | SHCNF_FLUSHNOWAIT, NULL, NULL);
    }
}

// static
void CMountPoint::OnMountPointArrival(LPCWSTR pszDrive)
{
    // Check if this local drive letter is not "covered" by a net
    // drive letter
    _csDL.Enter();

    if (!_IsDriveLetter(pszDrive))
    {
        _rsMtPtsLocalMOF.RSSetTextValue(NULL, pszDrive, TEXT(""));        
    }

    _csDL.Leave();

    if (!_LocalDriveIsCoveredByNetDrive(pszDrive))
    {
        BOOL fDriveLetter = CMountPoint::_IsDriveLetter(pszDrive);
        LONG lEvent;

        if (fDriveLetter)
        {
            CDBurn_OnDeviceChange(TRUE, pszDrive);
            lEvent = SHCNE_DRIVEADD;
        }
        else
        {
            lEvent = SHCNE_UPDATEITEM;
        }

        SHChangeNotify(lEvent, SHCNF_PATH, pszDrive, NULL);

        if (fDriveLetter)
        {
            // If the DBTF_MEDIA is not set, do not send this notification for CDROM
            // or Removable as they may have come from a new device and not have any
            // media in them.  Also, when inserting a floppy drive (not media) in a
            // laptop, this would pop up a window.
            CMountPoint* pmtpt = CMountPoint::GetMountPoint(pszDrive);

            if (pmtpt)
            {
                if (pmtpt->_IsRemote() || pmtpt->_IsFixedDisk() ||
                    (pmtpt->_IsRemovableDevice() && !pmtpt->_IsFloppy()))
                {
                    DoAutorun(pszDrive, AUTORUNFLAG_MTPTARRIVAL);
                }

                pmtpt->Release();
            }
        }

        // for the non net case force these through right away to make those
        // cd-rom autorun things come up faster
        SHChangeNotify(0, SHCNF_FLUSH | SHCNF_FLUSHNOWAIT, NULL, NULL);
    }
}

void _CloseAutoplayPrompt(LPCWSTR pszDriveOrDeviceID)
{
    HWND hwnd;

    if (_GetAutoplayPromptHWND(pszDriveOrDeviceID, &hwnd))
    {
        _RemoveFromAutoplayPromptHDPA(pszDriveOrDeviceID);

        EndDialog(hwnd, IDCANCEL);
    }
}

// static
void CMountPoint::OnMediaRemoval(LPCWSTR pszDrive)
{
    // Check if this local drive letter is not "covered" by a net
    // drive letter
    if (!_LocalDriveIsCoveredByNetDrive(pszDrive))
    {
        if (CMountPoint::_IsDriveLetter(pszDrive))
        {
            CDBurn_OnMediaChange(FALSE, pszDrive);
        }

        SHChangeNotify(SHCNE_MEDIAREMOVED, SHCNF_PATH, pszDrive, NULL);

        _CloseAutoplayPrompt(pszDrive);
    }
}

// static
void CMountPoint::OnMountPointRemoval(LPCWSTR pszDrive)
{
    // Check if this local drive letter is not "covered" by a net
    // drive letter
    _csDL.Enter();

    if (!_IsDriveLetter(pszDrive))
    {
        _rsMtPtsLocalMOF.RSSetTextValue(NULL, pszDrive, TEXT(""));        
    }

    _csDL.Leave();

    if (!_LocalDriveIsCoveredByNetDrive(pszDrive))
    {
        LONG lEvent;

        if (CMountPoint::_IsDriveLetter(pszDrive))
        {
            CDBurn_OnDeviceChange(FALSE, pszDrive);
            lEvent = SHCNE_DRIVEREMOVED;
        }
        else
        {
            lEvent = SHCNE_UPDATEITEM;
        }

        SHChangeNotify(lEvent, SHCNF_PATH, pszDrive, NULL);

        _CloseAutoplayPrompt(pszDrive);
    }
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// static
HRESULT CMountPoint::_MediaArrivalRemovalHelper(LPCWSTR pszDeviceIDVolume,
    BOOL fArrived)
{
    ASSERT(!_csDL.IsInside());

    HRESULT hr;
    HDPA hdpaPaths = DPA_Create(4);

    if (hdpaPaths)
    {
        hr = _GetMountPointsForVolume(pszDeviceIDVolume, hdpaPaths);

        if (SUCCEEDED(hr))
        {
            int n = DPA_GetPtrCount(hdpaPaths);

            for (int i = n - 1; i >= 0; --i)
            {
                LPCWSTR pszMtPt = (LPCWSTR)DPA_GetPtr(hdpaPaths, i);

                // We don't want to call OnMediaXxxal within the critical
                // sections
                ASSERT(!_csDL.IsInside());

                if (fArrived)
                {
                    CMountPoint::OnMediaArrival(pszMtPt);
                }
                else
                {
                    CMountPoint::OnMediaRemoval(pszMtPt);
                }

                LocalFree((HLOCAL)pszMtPt);
                DPA_DeletePtr(hdpaPaths, i);
            }
        }

        DPA_Destroy(hdpaPaths);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// static
HRESULT CMountPoint::_VolumeAddedOrUpdated(BOOL fAdded,
    VOLUMEINFO2* pvolinfo2)
{
    HRESULT hr = S_FALSE;
    HDPA hdpaMtPtsOld = NULL;
    CVolume* pvolOld = NULL;
    CVolume* pvolNew = NULL;
    BOOL fMediaPresenceChanged = FALSE;
    BOOL fMediaArrived;

    _csDL.Enter();

    if (!fAdded)
    {
        // Updated
        // That's a volume that some code might have a ptr to.  We need to drop
        // it from the list and create a new one.

        hdpaMtPtsOld = DPA_Create(3);

        if (hdpaMtPtsOld)
        {
            hr = CMtPtLocal::_GetAndRemoveVolumeAndItsMtPts(
                pvolinfo2->szDeviceIDVolume, &pvolOld, hdpaMtPtsOld);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Common to Add and Update
    if (SUCCEEDED(hr))
    {
        CMtPtLocal::_UpdateVolumeRegInfo2(pvolinfo2);

        hr = CMtPtLocal::_CreateVolumeFromVOLUMEINFO2(pvolinfo2, &pvolNew);
    }

    if (SUCCEEDED(hr))
    {
        if (!fAdded)
        {
            BOOL fLabelChanged;

            if (pvolOld && lstrcmp(pvolOld->pszLabel, pvolNew->pszLabel))
            {
                fLabelChanged = TRUE;
            }
            else
            {
                fLabelChanged = FALSE;
            }

            if (hdpaMtPtsOld)
            {
                // Create new MtPts from old ones
                int n = DPA_GetPtrCount(hdpaMtPtsOld);

                for (int i = 0; i < n; ++i)
                {
                    CMtPtLocal* pmtptl = (CMtPtLocal*)DPA_GetPtr(hdpaMtPtsOld, i);

                    if (pmtptl)
                    {
                        WCHAR szMountPoint[MAX_PATH];

                        HRESULT hrTmp = pmtptl->GetMountPointName(szMountPoint,
                            ARRAYSIZE(szMountPoint));

                        if (SUCCEEDED(hrTmp))
                        {
                            CMtPtLocal::_CreateMtPtLocalWithVolume(szMountPoint, pvolNew);
                            // for now don't care about return value

                            if (fLabelChanged)
                            {
                                SHChangeNotify(SHCNE_RENAMEFOLDER, SHCNF_PATH,
                                    szMountPoint, szMountPoint);
                            }

                            if (pvolOld && (pvolOld->dwMediaState != pvolNew->dwMediaState))
                            {
                                fMediaPresenceChanged = TRUE;
                                fMediaArrived = !!(HWDMS_PRESENT & pvolNew->dwMediaState);
                            }
                        }

                        // Get rid of old mtptl
                        pmtptl->Release();
                    }
                }

                if (pvolOld)
                {
                    SHChangeNotify(SHCNE_UPDATEIMAGE, SHCNF_DWORD,
                        IntToPtr(pvolOld->iShellImageForUpdateImage), NULL);
                }
                
                DPA_Destroy(hdpaMtPtsOld);
            }

            if (pvolOld)
            {
                pvolOld->Release();
            }
        }

        pvolNew->Release();
    }

    _csDL.Leave();

    // Outside of the crit sect.
    if (fMediaPresenceChanged)
    {
        _MediaArrivalRemovalHelper(pvolinfo2->szDeviceIDVolume, fMediaArrived);
    }

    return hr;
}

// In theory, we should do the same as for VolumeUpdated, i.e. remove the volume
// from the DPA and all the mtpts, so that code which already has a pointer to it,
// will not see a change.  But the change we need to do is so tiny, that it would
// be overkill.  We're just going to flip a bit.

// static
HRESULT CMountPoint::_VolumeMountingEvent(LPCWSTR pszDeviceIDVolume, DWORD dwEvent)
{
    _csDL.Enter();

    CVolume* pvol = CMtPtLocal::_GetVolumeByID(pszDeviceIDVolume);

    _csDL.Leave();

    if (pvol)
    {
        if (SHHARDWAREEVENT_VOLUMEDISMOUNTED == dwEvent)
        {
            pvol->dwVolumeFlags |= HWDVF_STATE_DISMOUNTED;

            _csDL.Enter();

            // We need to set the label to nothing, so that when the volume
            // is mounted back, we compare the old and new label, find them to
            // be different and send an SHChangeNotify.
            if (pvol->pszLabel)
            {
                LPWSTR psz = StrDup(TEXT(""));

                if (psz)
                {
                    LocalFree(pvol->pszLabel);

                    // pvol->pszLabel is expected to not be NULL
                    pvol->pszLabel = psz;
                }
            }

            _csDL.Leave();

            _MediaArrivalRemovalHelper(pszDeviceIDVolume, FALSE);
        }
        else
        {
            ASSERT(SHHARDWAREEVENT_VOLUMEMOUNTED == dwEvent);

            pvol->dwVolumeFlags &= ~HWDVF_STATE_DISMOUNTED;
        }

        pvol->Release();
    }

    return S_OK;
}
 
// static
HRESULT CMountPoint::_VolumeRemoved(
    LPCWSTR pszDeviceIDVolume)
{
    CVolume* pvol = CMtPtLocal::_GetAndRemoveVolumeByID(pszDeviceIDVolume);

    if (pvol)
    {
        CMtPtLocal::_rsVolumes.RSDeleteSubKey(pvol->pszVolumeGUID +
            OFFSET_GUIDWITHINVOLUMEGUID);
        
        // Final release
        pvol->Release();
    }

    return S_OK;
}

HRESULT CMountPoint::_MountPointAdded(
    LPCWSTR pszMountPoint,     // "c:\", or "d:\MountFolder\"
    LPCWSTR pszDeviceIDVolume)// \\?\STORAGE#Volume#...{...GUID...}
{
    HRESULT hrCreateMtPt;
    BOOL fCallOnMountPointArrival = TRUE;

    _csDL.Enter();

    CVolume* pvol = CMtPtLocal::_GetVolumeByID(pszDeviceIDVolume);

    CMtPtLocal* pMtPtLocal = CMountPoint::_rgMtPtDriveLetterLocal[DRIVEID(pszMountPoint)];

    if (pMtPtLocal && pMtPtLocal->_IsMiniMtPt())
    {
        // The WM_DEVICECHANGE message beated us, do not do the notif
        fCallOnMountPointArrival = FALSE;
    }

    if (pvol)
    {
        hrCreateMtPt = CMtPtLocal::_CreateMtPtLocalWithVolume(pszMountPoint, pvol);
    }

    _csDL.Leave();

    if (pvol)
    {
        if (SUCCEEDED(hrCreateMtPt) && fCallOnMountPointArrival)
        {
            CMountPoint::OnMountPointArrival(pszMountPoint);
        }

        pvol->Release();
    }
    else
    {
        hrCreateMtPt = E_FAIL;
    }

    return hrCreateMtPt;
}

HRESULT CMountPoint::_MountPointRemoved(
    LPCWSTR pszMountPoint)
{
    HRESULT hr;
    BOOL fCallOnMountPointRemoval = TRUE;

    _csDL.Enter();

    if (CMountPoint::_IsDriveLetter(pszMountPoint))
    {
        CMtPtLocal* pmtptl = CMountPoint::_rgMtPtDriveLetterLocal[DRIVEID(pszMountPoint)];
    
        if (!pmtptl || pmtptl->_IsMiniMtPt())
        {
            // The WM_DEVICECHANGE message beated us, do not do the notif
            fCallOnMountPointRemoval = FALSE;
        }
    }

    hr = CMountPoint::_RemoveLocalMountPoint(pszMountPoint);

    _csDL.Leave();

    if (SUCCEEDED(hr) && fCallOnMountPointRemoval)
    {
        CMountPoint::OnMountPointRemoval(pszMountPoint);
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//static
void CMountPoint::HandleMountPointNetEvent(LPCWSTR pszDrive, BOOL fArrival)
{
    // These we need to send even if Shell Service is running
    if (fArrival)
    {
        CMountPoint::OnNetShareArrival(pszDrive);
    }
    else
    {
        CMountPoint::OnNetShareRemoval(pszDrive);
    }
}

struct HANDLEMOUNTPOINTLOCALEVENTSTRUCT
{
    WCHAR szDrive[4]; // can only be drive letter
    BOOL fMediaEvent;
};

// static
DWORD WINAPI CMountPoint::HandleMountPointLocalEventThreadProc(void* pv)
{
    HANDLEMOUNTPOINTLOCALEVENTSTRUCT* phmle =
        (HANDLEMOUNTPOINTLOCALEVENTSTRUCT*)pv;

    Sleep(3000);

    if (phmle->fMediaEvent)
    {
        // Nothing to do, we're not doing anything fancy in safe boot
        // mode, so no cache to reset, icons no change...

        // This is common to both Shell Service and non-Shell Service
        // notification, so do anything non Shell Service notif sepcific
        // above
        BOOL fIsMiniMtPt = FALSE;

        _csDL.Enter();

        CMtPtLocal* pMtPtLocal =
            CMountPoint::_rgMtPtDriveLetterLocal[DRIVEID(phmle->szDrive)];

        if (pMtPtLocal)
        {
            fIsMiniMtPt = pMtPtLocal->_IsMiniMtPt();
        }

        _csDL.Leave();

        if (fIsMiniMtPt)
        {
            HRESULT hr = SHCoInitialize();

            if (SUCCEEDED(hr))
            {
                CMountPoint::OnMediaArrival(phmle->szDrive);
            }

            SHCoUninitialize(hr);
        }
    }
    else
    {
        _csDL.Enter();

        CMtPtLocal* pMtPtLocal =
            CMountPoint::_rgMtPtDriveLetterLocal[DRIVEID(phmle->szDrive)];

        if (!pMtPtLocal)
        {
            // New local drive
            CMtPtLocal::_CreateMtPtLocal(phmle->szDrive);
        }

        _csDL.Leave();

        // Can check if pMtMtLocal is NULL or not, but cannot use it
        // might already have been freed.
        if (!pMtPtLocal)
        {
            HRESULT hr = SHCoInitialize();

            if (SUCCEEDED(hr))
            {
                // See comment above (This is common...)
                CMountPoint::OnMountPointArrival(phmle->szDrive);
            }

            SHCoUninitialize(hr);
        }
    }

    LocalFree((HLOCAL)phmle);

    return 0;
}

// fMedia: TRUE  -> Media
//         FALSE -> Drive
//static
void CMountPoint::HandleMountPointLocalEvent(LPCWSTR pszDrive, BOOL fArrival,
    BOOL fMediaEvent)
{
    if (fArrival)
    {
        // We might be racing with the shell service notification.
        HANDLEMOUNTPOINTLOCALEVENTSTRUCT* phmle = (HANDLEMOUNTPOINTLOCALEVENTSTRUCT*)LocalAlloc(LPTR,
            sizeof(HANDLEMOUNTPOINTLOCALEVENTSTRUCT));

        if (phmle)
        {
            HRESULT hr = StringCchCopy(phmle->szDrive, ARRAYSIZE(phmle->szDrive), pszDrive);
            phmle->fMediaEvent = fMediaEvent;                

            if (FAILED(hr) || !SHQueueUserWorkItem(HandleMountPointLocalEventThreadProc, phmle,
                0, (DWORD_PTR)0, (DWORD_PTR*)NULL, NULL, 0))
            {
                LocalFree((HLOCAL)phmle);
            }
        }
    }
    else
    {
        if (fMediaEvent)
        {
            // Nothing to do, we're not doing anything fancy in safe boot
            // mode, so no cache to reset, icons no change...

            // See comment above (This is common...)
            CMountPoint::OnMediaRemoval(pszDrive);
        }
        else
        {
            int iDrive = DRIVEID(pszDrive);
            BOOL fCallOnMountPointRemoval = TRUE;

            _csDL.Enter();

            if (_rgMtPtDriveLetterLocal[iDrive])
            {
                _rgMtPtDriveLetterLocal[iDrive]->Release();
                _rgMtPtDriveLetterLocal[iDrive] = NULL;
            }
            else
            {
                fCallOnMountPointRemoval = FALSE;
            }
        
            _csDL.Leave();

            // Can check if pMtMtLocal is NULL or not, but cannot use it
            // might already have been freed.
            if (fCallOnMountPointRemoval)
            {
                // See comment above (This is common...)
                CMountPoint::OnMountPointRemoval(pszDrive);
            }
        }
    }
}

//static
void CMountPoint::HandleWMDeviceChange(ULONG_PTR code, DEV_BROADCAST_HDR* pbh)
{
    if (DBT_DEVTYP_VOLUME == pbh->dbch_devicetype)
    {
        if ((DBT_DEVICEREMOVECOMPLETE == code) ||
            (DBT_DEVICEARRIVAL == code))
        {
            DEV_BROADCAST_VOLUME* pbv = (DEV_BROADCAST_VOLUME*)pbh;
            BOOL fIsNetEvent = !!(pbv->dbcv_flags & DBTF_NET);
            BOOL fIsMediaEvent = !!(pbv->dbcv_flags & DBTF_MEDIA);

            for (int iDrive = 0; iDrive < 26; ++iDrive)
            {
                if ((1 << iDrive) & pbv->dbcv_unitmask)
                {
                    TCHAR szPath[4];

                    if (DBT_DEVICEARRIVAL == code)
                    {
                        // Subst drive have the netevent flag on: bad.
                        PathBuildRoot(szPath, iDrive);

                        // Check if this is the arrival of a subst drive
                        if (DRIVE_REMOTE != GetDriveType(szPath))
                        {
                            // Yep.
                            fIsNetEvent = FALSE;
                        }
                        else
                        {
                            fIsNetEvent = TRUE;
                        }
                    }
                    else
                    {
                        _csDL.Enter();

                        CMtPtLocal* pMtPtLocal =
                            CMountPoint::_rgMtPtDriveLetterLocal[iDrive];
                        
                        if (pMtPtLocal)
                        {
                            fIsNetEvent = FALSE;
                        }

                        _csDL.Leave();
                    }

                    if (fIsNetEvent)
                    {
                        HandleMountPointNetEvent(PathBuildRoot(szPath, iDrive),
                            DBT_DEVICEARRIVAL == code);
                    }
                    else
                    {
                        HandleMountPointLocalEvent(PathBuildRoot(szPath, iDrive),
                            DBT_DEVICEARRIVAL == code, fIsMediaEvent);
                    }
                }
            }
        }
    }
}

// static
void CMountPoint::NotifyUnavailableNetDriveGone(LPCWSTR pszMountPoint)
{
    CMountPoint::_RemoveNetMountPoint(pszMountPoint);
}

// static
void CMountPoint::NotifyReconnectedNetDrive(LPCWSTR pszMountPoint)
{
    CMtPtRemote::_NotifyReconnectedNetDrive(pszMountPoint);
}

// static
DWORD CALLBACK CMountPoint::_EventProc(void* pv)
{
    SHHARDWAREEVENT* pshhe = (SHHARDWAREEVENT*)pv;
    BOOL fLocalDrivesInited;

    _csDL.Enter();

    fLocalDrivesInited = _fLocalDrivesInited;

    _csDL.Leave();

    // If the Local Drives info was not initialized there's nothing to update.
    if (fLocalDrivesInited)
    {
        switch (pshhe->dwEvent)
        {
            case SHHARDWAREEVENT_VOLUMEARRIVED:
            case SHHARDWAREEVENT_VOLUMEUPDATED:
            {
                VOLUMEINFO2* pvolinfo2 = (VOLUMEINFO2*)pshhe->rgbPayLoad;

                CMountPoint::_VolumeAddedOrUpdated(
                    (SHHARDWAREEVENT_VOLUMEARRIVED == pshhe->dwEvent), pvolinfo2);
                break;
            }
            case SHHARDWAREEVENT_VOLUMEREMOVED:
            {
                LPCWSTR pszDeviceIDVolume = (LPCWSTR)pshhe->rgbPayLoad;

                CMountPoint::_VolumeRemoved(pszDeviceIDVolume);
                break;
            }
            case SHHARDWAREEVENT_MOUNTPOINTARRIVED:
            {
                MTPTADDED* pmtptadded = (MTPTADDED*)pshhe->rgbPayLoad;

                CMountPoint::_MountPointAdded(pmtptadded->szMountPoint,
                    pmtptadded->szDeviceIDVolume);
                break;
            }
            case SHHARDWAREEVENT_MOUNTPOINTREMOVED:
            {
                LPCWSTR pszMountPoint = (LPCWSTR)pshhe->rgbPayLoad;

                CMountPoint::_MountPointRemoved(pszMountPoint);
                break;
            }
            case SHHARDWAREEVENT_VOLUMEDISMOUNTED:
            case SHHARDWAREEVENT_VOLUMEMOUNTED:
            {
                LPCWSTR pszDeviceIDVolume = (LPCWSTR)pshhe->rgbPayLoad;

                CMountPoint::_VolumeMountingEvent(pszDeviceIDVolume, pshhe->dwEvent);
                break;
            }
        }
    }

    switch (pshhe->dwEvent)
    {
        case SHHARDWAREEVENT_DEVICEARRIVED:
        case SHHARDWAREEVENT_DEVICEUPDATED:
        case SHHARDWAREEVENT_DEVICEREMOVED:
        {
            HWDEVICEINFO* phwdevinfo = (HWDEVICEINFO*)pshhe->rgbPayLoad;

            if (SHHARDWAREEVENT_DEVICEARRIVED == pshhe->dwEvent)
            {
                if (HWDDF_HASDEVICEHANDLER & phwdevinfo->dwDeviceFlags)
                {
                    CCrossThreadFlag* pDeviceGoneFlag = new CCrossThreadFlag();

                    if (pDeviceGoneFlag)
                    {
                        if (pDeviceGoneFlag->Init())
                        {
                            AttachGoneFlagForDevice(phwdevinfo->szDeviceIntfID, pDeviceGoneFlag);

                            DoDeviceNotification(phwdevinfo->szDeviceIntfID, TEXT("DeviceArrival"),
                                pDeviceGoneFlag);
                        }

                        pDeviceGoneFlag->Release();
                    }
                }
            }
            else
            {
                if (SHHARDWAREEVENT_DEVICEREMOVED == pshhe->dwEvent)
                {
                    CCrossThreadFlag* pDeviceGoneFlag;

                    if (GetGoneFlagForDevice(phwdevinfo->szDeviceIntfID, &pDeviceGoneFlag))
                    {
                        pDeviceGoneFlag->Signal();
                        pDeviceGoneFlag->Release();
                    }

                    _CloseAutoplayPrompt(phwdevinfo->szDeviceIntfID);
                }
            }
            
            LPITEMIDLIST pidl;
            if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidl)))
            {
                //  wait for WIA to do its stuff
                Sleep(5000);

                SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, pidl, NULL);
                ILFree(pidl);
            }
            break;
        }

        default:
            // That's no good
            break;
    }
    
    VirtualFree(pv, 0, MEM_RELEASE);

    return 0;
}

// static
void CALLBACK CMountPoint::_EventAPCProc(ULONG_PTR ulpParam)
{
    if (!SHCreateThread(CMountPoint::_EventProc, (void*)ulpParam, CTF_COINIT | CTF_REF_COUNTED, NULL))
    {
        VirtualFree((void*)ulpParam, 0, MEM_RELEASE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mtptris.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "mtptr.h"

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
BOOL CMtPtRemote::_IsRemote()
{
    return TRUE;
}

BOOL CMtPtRemote::_IsSlow()
{
    BOOL fRet = FALSE;
    DWORD dwSpeed = _GetPathSpeed();
    
    if ((0 != dwSpeed) && (dwSpeed <= SPEED_SLOW))
    {
        fRet = TRUE;
    }

    TraceMsg(TF_MOUNTPOINT, "static CMountPoint::_IsSlow: for '%s'", _GetNameDebug());

    return fRet;
}

BOOL CMtPtRemote::_IsAutorun()
{
    return _pshare->fAutorun;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mtptl2.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "shitemid.h"
#include "ids.h"
#include <ntddcdrm.h>
#include "shpriv.h"
#include "hwcmmn.h"
#include "mtptl.h"
#include "cdburn.h"

#ifdef DEBUG
DWORD CMtPtLocal::_cMtPtLocal = 0;
DWORD CVolume::_cVolume = 0;
#endif

const static WCHAR g_szCrossProcessCacheVolumeKey[] = TEXT("CPC\\Volume");
CRegSupport CMtPtLocal::_rsVolumes;

HRESULT CMtPtLocal::SetLabel(HWND hwnd, LPCTSTR pszLabel)
{
    HRESULT hr = E_FAIL;
    
    TraceMsg(TF_MOUNTPOINT, "CMtPtLocal::SetLabel: for '%s'", _GetNameDebug());
    
    if (SetVolumeLabel(_GetNameForFctCall(), pszLabel))
    {
        TraceMsg(TF_MOUNTPOINT, "   'SetVolumeLabel' succeeded");
        
        if ( !_fVolumePoint )
        {
            RSSetTextValue(NULL, TEXT("_LabelFromReg"), pszLabel, 
                REG_OPTION_NON_VOLATILE);
        }
        
        if (!_CanUseVolume())
        {
            // we notify for only the current drive (no folder mounted drive)
            SHChangeNotify(SHCNE_RENAMEFOLDER, SHCNF_PATH, _GetName(),
                _GetName());
        }
        hr = S_OK;
    }
    else
    {
        DWORD dwErr = GetLastError();
        
        switch (dwErr)
        {
        case ERROR_SUCCESS:
            break;
            
        case ERROR_ACCESS_DENIED:
            
            hr = S_FALSE;	// don't have permission, shouldn't put them back into editing mode
            
            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE( IDS_ACCESSDENIED ),
                MAKEINTRESOURCE( IDS_TITLE_VOLUMELABELBAD ),
                MB_OK | MB_ICONSTOP | MB_SETFOREGROUND);
            break;
            
        case ERROR_WRITE_PROTECT:
            hr = S_FALSE; // can't write, shouldn't put them back into editing mode
            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE( IDS_WRITEPROTECTED ),
                MAKEINTRESOURCE( IDS_TITLE_VOLUMELABELBAD ),
                MB_OK | MB_ICONSTOP | MB_SETFOREGROUND);
            break;
            
        case ERROR_LABEL_TOO_LONG:
            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE( IDS_ERR_VOLUMELABELBAD ),
                MAKEINTRESOURCE( IDS_TITLE_VOLUMELABELBAD ),
                MB_OK | MB_ICONSTOP | MB_SETFOREGROUND);
            break;
            
        case ERROR_UNRECOGNIZED_VOLUME:
            hr = S_FALSE; // can't write, shouldn't put them back into editing mode
            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE( IDS_ERR_VOLUMEUNFORMATTED ),
                MAKEINTRESOURCE( IDS_TITLE_VOLUMELABELBAD ),
                MB_OK | MB_ICONSTOP | MB_SETFOREGROUND);
            break;
            
        default:
            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE( IDS_BADLABEL ),
                MAKEINTRESOURCE( IDS_TITLE_VOLUMELABELBAD ),
                MB_OK | MB_ICONSTOP | MB_SETFOREGROUND);
            break;
        }
        
        TraceMsg(TF_MOUNTPOINT, "   'SetVolumeLabel' failed");
    }
    
    return hr;
}

HRESULT CMtPtLocal::SetDriveLabel(HWND hwnd, LPCTSTR pszLabel)
{
    HRESULT hr = E_FAIL;

    if ((_IsFloppy() || !_IsMediaPresent()) && _IsMountedOnDriveLetter())
    {
        // we rename the drive not the media
        TCHAR szSubKey[MAX_PATH];

        hr = StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey),
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\DriveIcons\\%c\\DefaultLabel"),
            _GetNameFirstCharUCase());

        if (SUCCEEDED(hr))
        {
            hr = RegSetValueString(HKEY_LOCAL_MACHINE, szSubKey, NULL, pszLabel) ? S_OK : E_FAIL;

            if (SUCCEEDED(hr))
            {
                LocalFree(_pszLegacyRegLabel);  // may be NULL
                _pszLegacyRegLabel = *pszLabel ? StrDup(pszLabel) : NULL;   // empty string resets
                SHChangeNotify(SHCNE_RENAMEFOLDER, SHCNF_PATH, _GetName(), _GetName());
            }
        }
    }
    else
    {
        hr = SetLabel(hwnd, pszLabel);
    }

    return hr;
}

HRESULT CMtPtLocal::GetLabelNoFancy(LPTSTR pszLabel, DWORD cchLabel)
{
    HRESULT hr = S_OK;

    if (!_GetGVILabelOrMixedCaseFromReg(pszLabel, cchLabel))
    {
        *pszLabel = 0;
        // Propagate failure code out for caller
        hr = E_FAIL;
    }

    return hr;
}

BOOL _ShowUglyDriveNames()
{
    static BOOL s_fShowUglyDriveNames = (BOOL)42;   // Preload some value to say lets calculate...

    if (s_fShowUglyDriveNames == (BOOL)42)
    {
        int iACP;
        TCHAR szTemp[MAX_PATH];     // Nice large buffer
        if (GetLocaleInfo(GetUserDefaultLCID(), LOCALE_IDEFAULTANSICODEPAGE, szTemp, ARRAYSIZE(szTemp)))
        {
            iACP = StrToInt(szTemp);
            // per Samer Arafeh, show ugly name for 1256 (Arabic ACP)
            if (iACP == 1252 || iACP == 1254 || iACP == 1255 || iACP == 1257 || iACP == 1258)
                goto TryLoadString;
            else
                s_fShowUglyDriveNames = TRUE;
        }
        else
        {
        TryLoadString:
            // All indications are that we can use pretty drive names.
            // Double-check that the localizers didn't corrupt the chars.
            LoadString(HINST_THISDLL, IDS_DRIVES_UGLY_TEST, szTemp, ARRAYSIZE(szTemp));

            // If the characters did not come through properly set ugly mode...
            s_fShowUglyDriveNames = (szTemp[0] != 0x00BC || szTemp[1] != 0x00BD);
        }
    }
    return s_fShowUglyDriveNames;
}

BOOL CMtPtLocal::_HasAutorunLabel()
{
    BOOL fRet = FALSE;

    if (_CanUseVolume())
    {
        fRet = BOOLFROMPTR(_pvol->pszAutorunLabel) &&
            *(_pvol->pszAutorunLabel);
    }

    return fRet;
}

BOOL CMtPtLocal::_HasAutorunIcon()
{
    BOOL fRet = FALSE;

    if (_CanUseVolume())
    {
        fRet = BOOLFROMPTR(_pvol->pszAutorunIconLocation) &&
            *(_pvol->pszAutorunIconLocation);
    }

    return fRet;
}

void CMtPtLocal::_GetAutorunLabel(LPWSTR pszLabel, DWORD cchLabel)
{
    ASSERT(_CanUseVolume());
    StringCchCopy(pszLabel, cchLabel, _pvol->pszAutorunLabel);
}

HRESULT CMtPtLocal::GetLabel(LPTSTR pszLabel, DWORD cchLabel)
{
    HRESULT hr = S_OK;
    BOOL fFoundIt = FALSE;

    // Autorun first
    // Fancy icon (Autoplay) second 
    // True label from drive for non-removable
    // Legacy drive icons third
    // Regular last

    if (_HasAutorunLabel())
    {
        _GetAutorunLabel(pszLabel, cchLabel);
        fFoundIt = TRUE;
    }

    if (!fFoundIt)
    {
        if (!_IsFloppy())
        {
            if (!_GetGVILabelOrMixedCaseFromReg(pszLabel, cchLabel))
            {
                *pszLabel = 0;
            }
            else
            {
                if (*pszLabel)
                {
                    fFoundIt = TRUE;
                }
            }
        }
    }

    if (!fFoundIt)
    {
        fFoundIt = _GetLegacyRegLabel(pszLabel, cchLabel);
    }

    if (!fFoundIt)
    {
        if (!_IsFloppy())
        {
            if (_CanUseVolume())
            {
                if (_pvol->pszLabelFromService)
                {
                    if (SUCCEEDED(SHLoadIndirectString(_pvol->pszLabelFromService, pszLabel,
                        cchLabel, NULL)))
                    {
                        fFoundIt = TRUE;
                    }
                    else
                    {
                        *pszLabel = 0;
                    }
                }
            }
        }
    }

    if (!fFoundIt)
    {
        if (_CanUseVolume() && (HWDTS_CDROM == _pvol->dwDriveType))
        {
            fFoundIt = _GetCDROMName(pszLabel, cchLabel);
        }
    }

    if (!fFoundIt)
    {
        if (_IsFloppy())
        {
            // For some weird reason we have wo sets of "ugly" name for floppies,
            // the other is in GetTypeString
            UINT id;

            if (_IsFloppy35())
            {
                id = _ShowUglyDriveNames() ? IDS_35_FLOPPY_DRIVE_UGLY : IDS_35_FLOPPY_DRIVE;
            }
            else
            {
                id = _ShowUglyDriveNames() ? IDS_525_FLOPPY_DRIVE_UGLY : IDS_525_FLOPPY_DRIVE;
            }

            LoadString(HINST_THISDLL, id, pszLabel, cchLabel);
        }
        else
        {
            // Cook up a default name
            GetTypeString(pszLabel, cchLabel);
        }
    }

    return hr;
}

HRESULT CMtPtLocal::Eject(HWND hwnd)
{
    TCHAR szNameForError[MAX_DISPLAYNAME];

    GetDisplayName(szNameForError, ARRAYSIZE(szNameForError));

    return _Eject(hwnd, szNameForError);
}

BOOL CMtPtLocal::HasMedia()
{
    return _IsMediaPresent();
}

BOOL CMtPtLocal::IsFormatted()
{
    return _IsFormatted();
}

BOOL CMtPtLocal::IsMounted()
{
    BOOL fRet;

    if (_pvol)
    {
        if (_pvol->dwVolumeFlags & HWDVF_STATE_DISMOUNTED)
        {
            fRet = FALSE;
        }
        else
        {
            fRet = TRUE;
        }
    }
    else
    {
        // Assume true.  Code that will call this will do so mainly to go
        // around the caching done in _pvol.
        fRet = TRUE;
    }

    return fRet;
}

BOOL CMtPtLocal::IsEjectable()
{
    BOOL fIsEjectable = FALSE;

    if (_IsCDROM())
    {
        fIsEjectable = TRUE;
    }
    else
    {
        // Floppies are not Software ejectable
        if (_IsStrictRemovable())
        {
            fIsEjectable = TRUE;
        }
        else
        {
            if (_IsFloppy())
            {
                if (_CanUseVolume() && (HWDDC_FLOPPYSOFTEJECT & _pvol->dwDriveCapability))
                {
                    if (_IsMediaPresent())
                    {
                        fIsEjectable = TRUE;
                    }
                }
            }
        }
    }

    if (fIsEjectable)
    {
        if (_CanUseVolume())
        {
            if (HWDDC_NOSOFTEJECT & _pvol->dwDriveCapability)
            {
                fIsEjectable = FALSE;
            }
        }
    }

    return fIsEjectable;
}

HRESULT CMtPtLocal::GetCDInfo(DWORD* pdwDriveCapabilities, DWORD* pdwMediaCapabilities)
{
    HRESULT hr;

    *pdwDriveCapabilities = 0;
    *pdwMediaCapabilities = 0;

    if (_IsCDROM())
    {
        if (_CanUseVolume())
        {
            if (HWDDC_CAPABILITY_SUPPORTDETECTION & _pvol->dwDriveCapability)
            {
                *pdwDriveCapabilities = (_pvol->dwDriveCapability & HWDDC_CDTYPEMASK);

                if (HWDMC_WRITECAPABILITY_SUPPORTDETECTION & _pvol->dwMediaCap)
                {
                    *pdwMediaCapabilities = (_pvol->dwMediaCap & HWDMC_CDTYPEMASK);
                }

                hr = S_OK;
            }
            else
            {
                // in the case where we really dont know, see if the IMAPI info cached in the
                // registry has what we want.
                hr = CDBurn_GetCDInfo(_pvol->pszVolumeGUID, pdwDriveCapabilities, pdwMediaCapabilities);
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

// Put all these together
BOOL CMtPtLocal::_IsDVDDisc()
{
    BOOL fRet = FALSE;

    if (_CanUseVolume())
    {
        if (HWDMC_HASDVDMOVIE & _pvol->dwMediaCap)
        {
            fRet = TRUE;
        }
    }
    // else In safe boot we don't care about Audio Disc

    return fRet;
}

BOOL CMtPtLocal::_IsRemovableDevice()
{
    BOOL fRet = FALSE;

    if (_CanUseVolume())
    {
        if (HWDDC_REMOVABLEDEVICE & _pvol->dwDriveCapability)
        {
            fRet = TRUE;
        }        
    }

    return fRet;
}

// We keep the functionality we had before: a drive is Autorun only if it has
// a Autorun.inf in the root when inserted.  If it acquires one after, too bad.
BOOL CMtPtLocal::_IsAutorun()
{
    BOOL fRet = FALSE;

    if (_CanUseVolume())
    {
        if ((HWDMC_HASAUTORUNINF & _pvol->dwMediaCap) &&
            (HWDMC_HASAUTORUNCOMMAND & _pvol->dwMediaCap) &&
            !(HWDMC_HASUSEAUTOPLAY & _pvol->dwMediaCap))
        {
            fRet = TRUE;
        }
    }
    else
    {
        WCHAR szAutorun[MAX_PATH];
        DWORD dwErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

        if (SUCCEEDED(StringCchCopy(szAutorun, ARRAYSIZE(szAutorun), _GetNameForFctCall())))
        {
            if (SUCCEEDED(StringCchCat(szAutorun, ARRAYSIZE(szAutorun), TEXT("autorun.inf"))))
            {
                if (-1 != GetFileAttributes(szAutorun))
                {
                    fRet = TRUE;
                }
            }
        }

        SetErrorMode(dwErrMode);
    }

    return fRet;
}

// try to rename it
BOOL CMtPtLocal::_IsAudioDisc()
{
    BOOL fRet = FALSE;

    if (_CanUseVolume())
    {
        if (HWDMC_HASAUDIOTRACKS & _pvol->dwMediaCap)
        {
            fRet = TRUE;
        }
    }
    // else In safe boot we don't care about Audio Disc

    return fRet;
}

LPCTSTR CMtPtLocal::_GetNameForFctCall()
{
    LPCTSTR psz;

    if (_CanUseVolume())
    {
        psz = _pvol->pszVolumeGUID;
    }
    else
    {
        psz = _szName;
    }

    return psz;
}

HRESULT CMtPtLocal::_Eject(HWND hwnd, LPTSTR pszMountPointNameForError)
{
    HRESULT hr = E_FAIL;

#ifndef _WIN64
    // NTRAID#NTBUG9-093957-2000/09/08-StephStm  Code temporarily disabled for Win64
    // MCI is not 64bit ready.  It crashes.
    // We do this check to see if the CD will accept an IOCTL to eject it.
    // Old CD drives do not.  On W2K ssince the IOCTL was not implemented they use
    // to all say 'no'.  I assumne that on ia64 machine they will have recent CD
    // drives.  I call the IOCTL for them.  It works now, and it's certainly better
    // than the crash we get using MCI, worst come to worst it will silently fail.
    if (IsEjectable())
    {
#endif //_WIN64
        // it is a protect mode drive that we can tell directly...
        if (_IsCDROM())
        {
            HANDLE h = _GetHandleReadRead();

            if (INVALID_HANDLE_VALUE != h)
            {
                DWORD dwReturned;

                DeviceIoControl(h, IOCTL_DISK_EJECT_MEDIA, NULL, 0, NULL, 0,
                    &dwReturned, NULL);

                CloseHandle(h);
            }
            
            hr = S_OK;
        }
        else
        {
            // For removable drives, we want to do all the calls on a single
            // handle, thus we can't do lots of calls to DeviceIoControl.
            // Instead, use the helper routines to do our work...
            
            // Don't bring up any error message if the user already chose to abort.
            BOOL fAborted = FALSE;
            BOOL fFailed = TRUE;

            HANDLE h = _GetHandleWithAccessAndShareMode(GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE);

            if (INVALID_HANDLE_VALUE != h)
            {
                DWORD dwReturned;
_RETRY_LOCK_VOLUME_:

                // Now try to lock the drive...
                //
                // In theory, if no filesystem was mounted, the IOCtl command could go
                // to the device, which would fail with ERROR_INVALID_FUNCTION.  If that
                // occured, we would still want to proceed, since the device might still
                // be able to handle the IOCTL_DISK_EJECT_MEDIA command below.
                //
                if (!DeviceIoControl(h, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0,
                    &dwReturned, NULL) && (GetLastError() != ERROR_INVALID_FUNCTION))
                {
                    // So we can't lock the drive, bring up a message box to see if user
                    // wants to
                    //  1. Abort.
                    //  2. Retry to lock the drive.
                    //  3. Dismount anyway.

                    WCHAR szLabelForMessage[MAX_LABEL];

                    szLabelForMessage[0] = 0;

                    if (_CanUseVolume() && (_pvol->pszLabelFromService))
                    {
                        StringCchCopy(szLabelForMessage, ARRAYSIZE(szLabelForMessage), _pvol->pszLabelFromService);
                    }

                    if (!(szLabelForMessage[0]))
                    {
                        GetTypeString(szLabelForMessage, ARRAYSIZE(szLabelForMessage));

                        LPTSTR psz = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_VOL_FORMAT),
                                    szLabelForMessage, _GetNameFirstCharUCase());

                        if (psz)
                        {
                            StringCchCopy(szLabelForMessage, ARRAYSIZE(szLabelForMessage), psz);
                            LocalFree(psz);
                        }
                        else
                        {
                            StringCchCopy(szLabelForMessage, ARRAYSIZE(szLabelForMessage), pszMountPointNameForError);
                        }
                    }

                    int iRet = ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE( IDS_UNMOUNT_TEXT ),
                        pszMountPointNameForError, MB_CANCELTRYCONTINUE | MB_ICONWARNING | MB_SETFOREGROUND,
                        szLabelForMessage);
        
                    switch (iRet)
                    {
                        case IDCANCEL:
                            // we did not fail, we aborted the format
                            fFailed = FALSE;
                            fAborted = TRUE;
                            break;

                        case IDCONTINUE:
                            // send FSCTL_DISMOUNT_VOLUME
                            if (!DeviceIoControl(h, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0, &dwReturned, NULL))
                            {
                                TraceMsg(TF_WARNING, "FSCTL_DISMOUNT_VOLUME failed with error %d.", GetLastError());
                                fFailed = TRUE;
                                break;
                            }
                            // We sucessfully dismounted the volume, so the h we have is not valid anymore. We
                            // therefore close it and start the process all over again, hoping to lock the volume before
                            // anyone re-opens a handle to it
                            //
                            // (fall through)
                        case IDTRYAGAIN:
                            goto _RETRY_LOCK_VOLUME_;
                    }
                }
                else
                {
                    ASSERT(!fAborted);  // should not have aborted if we got this far...
                    fFailed = FALSE;
                }


                if (!fFailed && !fAborted)
                {
                    PREVENT_MEDIA_REMOVAL pmr;

                    pmr.PreventMediaRemoval = FALSE;

                    // tell the drive to allow removal, then eject
                    if (!DeviceIoControl(h, IOCTL_STORAGE_MEDIA_REMOVAL, &pmr, sizeof(pmr), NULL, 0, &dwReturned, NULL) ||
                        !DeviceIoControl(h, IOCTL_STORAGE_EJECT_MEDIA, NULL, 0, NULL, 0, &dwReturned, NULL))
                    {
                        ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE( IDS_EJECT_TEXT ),
                                MAKEINTRESOURCE( IDS_EJECT_TITLE ),
                                MB_OK | MB_ICONSTOP | MB_SETFOREGROUND, pszMountPointNameForError);
                    }
                    else
                    {
                        hr = S_OK;
                    }
                }

                CloseHandle(h);
            }

            if (fFailed)
            {
                ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE( IDS_UNMOUNT_TEXT ),
                        MAKEINTRESOURCE( IDS_UNMOUNT_TITLE ),
                        MB_OK | MB_ICONSTOP | MB_SETFOREGROUND, pszMountPointNameForError);
            }
        }
#ifndef _WIN64
    }
    else
    {
        // Is this needed anymore?

        // See comment above for why this is ifdef'ed out on Win64
        // (stephstm) only works for drive mounted on letter
        TCHAR szMCI[128];

        hr = StringCchPrintf(szMCI, ARRAYSIZE(szMCI), TEXT("Open %c: type cdaudio alias foo shareable"),
            _GetNameFirstCharUCase());

        if (SUCCEEDED(hr))
        {
            if (mciSendString(szMCI, NULL, 0, 0L) == MMSYSERR_NOERROR)
            {
                mciSendString(TEXT("set foo door open"), NULL, 0, 0L);
                mciSendString(TEXT("close foo"), NULL, 0, 0L);
                hr = S_OK;
            }
        }
    }
#endif //_WIN64

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  New  //////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
BOOL CMtPtLocal::_GetFileAttributes(DWORD* pdwAttrib)
{
    BOOL fRet = FALSE;
    BOOL fDoRead = FALSE;
    *pdwAttrib = -1;

    if (_CanUseVolume() && !_IsFloppy())
    {
        if (_IsMediaPresent() && _IsFormatted())
        {
            if (_IsReadOnly())
            {
                // The file attrib we received at the begginning should be
                // valid, do not touch the drive for nothing
                *pdwAttrib = _pvol->dwRootAttributes;
                fRet = TRUE;
            }
            else
            {
                fDoRead = TRUE;
            }
        }
    }
    else
    {
        fDoRead = TRUE;
    }

    if (fDoRead)
    {
        DWORD dw = GetFileAttributes(_GetNameForFctCall());

        if (-1 != dw)
        {
            *pdwAttrib = dw;
            fRet = TRUE;
        }
    }

    return fRet;
}

// { DRIVE_ISCOMPRESSIBLE | DRIVE_LFN | DRIVE_SECURITY }
int CMtPtLocal::_GetGVIDriveFlags()
{
    int iFlags = 0;
    DWORD dwFileSystemFlags = 0;
    DWORD dwMaxFileNameLen = 13;

    if (_CanUseVolume() && (_pvol->dwVolumeFlags & HWDVF_STATE_SUPPORTNOTIFICATION))
    {
        if (_IsMediaPresent() && _IsFormatted())
        {
            // No check for _IsReadOnly, we'll be notified if there's a format
            dwFileSystemFlags = _pvol->dwFileSystemFlags;
            dwMaxFileNameLen = _pvol->dwMaxFileNameLen;
        }
    }
    else
    {
        if (!GetVolumeInformation(_GetNameForFctCall(), NULL, 0, NULL,
            &dwMaxFileNameLen, &dwFileSystemFlags, NULL, NULL))
        {
            // Just make sure
            dwMaxFileNameLen = 13;
        }
    }

    // The file attrib we received at the begginning should be
    // valid, do not touch the drive for nothing
    if (dwFileSystemFlags & FS_FILE_COMPRESSION)
    {
        iFlags |= DRIVE_ISCOMPRESSIBLE;
    }

    // Volume supports long filename (greater than 8.3)?
    if (dwMaxFileNameLen > 12)
    {
        iFlags |= DRIVE_LFN;
    }

    // Volume supports security?
    if (dwFileSystemFlags & FS_PERSISTENT_ACLS)
    {
        iFlags |= DRIVE_SECURITY;
    }

    return iFlags;
}

BOOL CMtPtLocal::_GetGVILabel(LPTSTR pszLabel, DWORD cchLabel)
{
    BOOL fRet = FALSE;

    *pszLabel = 0;

    if (_CanUseVolume() && (_pvol->dwVolumeFlags & HWDVF_STATE_SUPPORTNOTIFICATION))
    {
        if (_IsMediaPresent() && _IsFormatted())
        {
            // No check for _IsReadOnly, we'll be notified if there's a change
            // of label
            fRet = SUCCEEDED(StringCchCopy(pszLabel, cchLabel, _pvol->pszLabel));
        }
    }
    else
    {
        fRet = GetVolumeInformation(_GetNameForFctCall(), pszLabel, cchLabel,
            NULL, NULL, NULL, NULL, NULL);
    }

    return fRet;
}

BOOL CMtPtLocal::_GetSerialNumber(DWORD* pdwSerialNumber)
{
    BOOL fRet = FALSE;

    if (_CanUseVolume() && (_pvol->dwVolumeFlags & HWDVF_STATE_SUPPORTNOTIFICATION))
    {
        if (_IsMediaPresent() && _IsFormatted())
        {
            *pdwSerialNumber = _pvol->dwSerialNumber;
            fRet = TRUE;
        }
    }
    else
    {
        fRet = GetVolumeInformation(_GetNameForFctCall(), NULL, 0,
            pdwSerialNumber, NULL, NULL, NULL, NULL);
    }

    return fRet;
}

BOOL CMtPtLocal::_GetGVILabelOrMixedCaseFromReg(LPTSTR pszLabel, DWORD cchLabel)
{
    BOOL fRet = FALSE;

    *pszLabel = 0;

    fRet = _GetGVILabel(pszLabel, cchLabel);

    if (fRet)
    {
        WCHAR szLabelFromReg[MAX_LABEL];

        // Do we already have a label from the registry for this volume?
        // (the user may have renamed this drive)
        if (_GetLabelFromReg(szLabelFromReg, ARRAYSIZE(szLabelFromReg)) &&
            szLabelFromReg[0])
        {
            // Yes
            // Do they match (only diff in case)
            if (lstrcmpi(szLabelFromReg, pszLabel) == 0)
            {
                // Yes
                StringCchCopy(pszLabel, cchLabel, szLabelFromReg);
            }
        }
    }

    return fRet;
}

BOOL CMtPtLocal::_GetFileSystemFlags(DWORD* pdwFlags)
{
    BOOL fRet = FALSE;
    DWORD dwFileSystemFlags = 0;

    *pdwFlags = 0;

    if (_CanUseVolume() && (_pvol->dwVolumeFlags & HWDVF_STATE_SUPPORTNOTIFICATION))
    {
        if (_IsMediaPresent() && _IsFormatted())
        {
            // No check for _IsReadOnly, we'll be notified if there's a
            // format oper.
            *pdwFlags = _pvol->dwFileSystemFlags;
            fRet = TRUE;
        }
    }
    else
    {
        if (GetVolumeInformation(_GetNameForFctCall(), NULL, 0, NULL,
            NULL, pdwFlags, NULL, NULL))
        {
            fRet = TRUE;
        }
    }

    return fRet;
}

BOOL CMtPtLocal::_GetFileSystemName(LPTSTR pszFileSysName, DWORD cchFileSysName)
{
    BOOL fRet = FALSE;

    *pszFileSysName = 0;

    if (_CanUseVolume() && (_pvol->dwVolumeFlags & HWDVF_STATE_SUPPORTNOTIFICATION))
    {
        if (_IsMediaPresent() && _IsFormatted())
        {
            fRet = SUCCEEDED(StringCchCopy(pszFileSysName, cchFileSysName,
                _pvol->pszFileSystem));
        }
    }
    else
    {
        if (GetVolumeInformation(_GetNameForFctCall(),
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 NULL,
                                 pszFileSysName,
                                 cchFileSysName))
        {
            fRet = TRUE;            
        }
    }

    return fRet;
}

struct CDROMICONS
{
    DWORD   dwCap;
    UINT    iIcon;
    UINT    iName;
};
  
// Go from most wonderful caps to less wonderful (according to stepshtm)
// Keep in order, it is verrrrry important
const CDROMICONS rgMediaPresent[] =
{
    // Specfic content 
    { HWDMC_HASDVDMOVIE, -IDI_AP_VIDEO, 0}, // we display the DVD media icon,
                                          // since it will most likely be
                                          // replaced by an icon from the DVD itself
    { HWDMC_HASAUDIOTRACKS | HWDMC_HASDATATRACKS, -IDI_MEDIACDAUDIOPLUS, 0}, 
    { HWDMC_HASAUDIOTRACKS, -IDI_CDAUDIO, 0 },
    { HWDMC_HASAUTORUNINF, -IDI_DRIVECD, 0 },
    // Specific media
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDMC_DVDRAM, -IDI_MEDIADVDRAM, 0 },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDMC_DVDRECORDABLE, -IDI_MEDIADVDR, 0 },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDMC_DVDREWRITABLE, -IDI_MEDIADVDRW, 0 },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDMC_DVDROM, -IDI_MEDIADVDROM, 0 },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDMC_CDREWRITABLE, -IDI_MEDIACDRW, 0 },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDMC_CDRECORDABLE, -IDI_MEDIACDR, 0 },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDMC_CDROM, -IDI_MEDIACDROM, 0 },
};

// Keep in order, it is verrrrry important
const CDROMICONS rgNoMedia[] =
{
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_DVDRAM, -IDI_DRIVECD, IDS_DRIVES_DVDRAM },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_DVDRECORDABLE, -IDI_DRIVECD, IDS_DRIVES_DVDR },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_DVDREWRITABLE, -IDI_DRIVECD, IDS_DRIVES_DVDRW },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_DVDROM | HWDDC_CDREWRITABLE, -IDI_DRIVECD, IDS_DRIVES_DVDCDRW },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_DVDROM | HWDDC_CDRECORDABLE, -IDI_DRIVECD, IDS_DRIVES_DVDCDR },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_DVDROM, -IDI_DVDDRIVE, IDS_DRIVES_DVD },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_CDREWRITABLE, -IDI_DRIVECD, IDS_DRIVES_CDRW },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_CDRECORDABLE, -IDI_DRIVECD, IDS_DRIVES_CDR },
    { HWDMC_WRITECAPABILITY_SUPPORTDETECTION | HWDDC_CDROM, -IDI_DRIVECD, IDS_DRIVES_CDROM },
};

UINT _GetCDROMIconFromArray(DWORD dwCap, const CDROMICONS* prgcdromicons,
    DWORD ccdromicons)
{
    UINT iIcon = 0;

    for (DWORD dw = 0; dw < ccdromicons; ++dw)
    {
        if ((prgcdromicons[dw].dwCap & dwCap) == prgcdromicons[dw].dwCap)
        {
            iIcon = prgcdromicons[dw].iIcon;
            break;
        }
    }

    return iIcon;
}

UINT _GetCDROMNameFromArray(DWORD dwCap)
{
    UINT iName = 0;

    for (DWORD dw = 0; dw < ARRAYSIZE(rgNoMedia); ++dw)
    {
        if ((rgNoMedia[dw].dwCap & dwCap) == rgNoMedia[dw].dwCap)
        {
            iName = rgNoMedia[dw].iName;
            break;
        }
    }

    return iName;
}

UINT CMtPtLocal::_GetCDROMIcon()
{
    int iIcon;

    if (_IsMediaPresent())
    {
        ASSERT(_CanUseVolume());

        iIcon = _GetCDROMIconFromArray(_pvol->dwMediaCap, rgMediaPresent,
            ARRAYSIZE(rgMediaPresent));

        if (!iIcon)
        {
            iIcon = -IDI_DRIVECD;
        }
    }
    else
    {
        ASSERT(_CanUseVolume());

        iIcon = _GetCDROMIconFromArray(_pvol->dwDriveCapability, rgNoMedia,
            ARRAYSIZE(rgNoMedia));

        if (!iIcon)
        {
            // No media generic CD icon
            iIcon = -IDI_DRIVECD;
        }
    }

    return iIcon;
}

BOOL CMtPtLocal::_GetCDROMName(LPWSTR pszName, DWORD cchName)
{
    BOOL fRet = FALSE;
    *pszName = 0;

    if (!_IsMediaPresent())
    {
        ASSERT(_CanUseVolume());
        UINT iName = _GetCDROMNameFromArray(_pvol->dwDriveCapability);

        if (iName)
        {
            fRet = LoadString(HINST_THISDLL, iName, pszName, cchName);
        }
    }

    return fRet;
}

UINT CMtPtLocal::_GetAutorunIcon(LPTSTR pszModule, DWORD cchModule)
{
    int iIcon = -1;

    ASSERT(_CanUseVolume());

    if (_pvol->pszAutorunIconLocation)
    {
        if (SUCCEEDED(StringCchCopy(pszModule, cchModule, _GetName())))
        {
            if (SUCCEEDED(StringCchCat(pszModule, cchModule, _pvol->pszAutorunIconLocation)))
            {
                iIcon = PathParseIconLocation(pszModule);
            }
        }
    }

    return iIcon;
}

UINT CMtPtLocal::GetIcon(LPTSTR pszModule, DWORD cchModule)
{
    UINT iIcon = -IDI_DRIVEUNKNOWN;

    *pszModule = 0;

    if (_CanUseVolume())
    {
        // Autorun first
        // Fancy icon (Autoplay) second 
        // Legacy drive icons last

        if (_HasAutorunIcon())
        {
            iIcon = _GetAutorunIcon(pszModule, cchModule);
        }
        
        if (-IDI_DRIVEUNKNOWN == iIcon)
        {
            // Try fancy icon
            if (!_IsFloppy())
            {
                if (_IsMediaPresent())
                {
                    if (_pvol->pszIconFromService)
                    {
                        if (FAILED(StringCchCopy(pszModule, cchModule, _pvol->pszIconFromService)))
                        {
                            *pszModule = 0;
                        }
                    }
                }
                else
                {
                    if (_pvol->pszNoMediaIconFromService)
                    {
                        if (FAILED(StringCchCopy(pszModule, cchModule, _pvol->pszNoMediaIconFromService)))
                        {
                            *pszModule = 0;
                        }
                    }
                    else
                    {
                        if (_pvol->pszIconFromService)
                        {
                            if (FAILED(StringCchCopy(pszModule, cchModule, _pvol->pszIconFromService)))
                            {
                                *pszModule = 0;
                            }
                        }
                    }
                }

                if (*pszModule)
                {
                    iIcon = PathParseIconLocation(pszModule);
                }
            }

            if (-IDI_DRIVEUNKNOWN == iIcon)
            {
                if (_pszLegacyRegIcon)
                {
                    if (*_pszLegacyRegIcon)
                    {
                        if (SUCCEEDED(StringCchCopy(pszModule, cchModule, _pszLegacyRegIcon)))
                        {
                            iIcon = PathParseIconLocation(pszModule);
                        }
                    }
                    else
                    {
                        *pszModule = 0;
                    }
                }
                else
                {
                    if (_CanUseVolume() && (HWDTS_CDROM == _pvol->dwDriveType))
                    {
                        iIcon = _GetCDROMIcon();
                        *pszModule = 0;
                    }
                }
            }

            if (-IDI_DRIVEUNKNOWN == iIcon)
            {
                switch (_pvol->dwDriveType)
                {
                    case HWDTS_FLOPPY35:
                    {
                        iIcon = II_DRIVE35;
                        break;
                    }
                    case HWDTS_FIXEDDISK:
                    {
                        iIcon = II_DRIVEFIXED;
                        break;
                    }
                    case HWDTS_CDROM:
                    {
                        iIcon = II_DRIVECD;
                        break;
                    }
                    case HWDTS_REMOVABLEDISK:
                    {
                        iIcon = II_DRIVEREMOVE;
                        break;
                    }
                    case HWDTS_FLOPPY525:
                    {
                        iIcon = II_DRIVE525;
                        break;
                    }
                    default:
                    {
                        iIcon = -IDI_DRIVEUNKNOWN;
                        break;
                    }
                }
            }
        }
    }
    else
    {
        iIcon = CMountPoint::GetSuperPlainDriveIcon(_szName, GetDriveType(_GetName()));
    }

    if (*pszModule)
        TraceMsg(TF_MOUNTPOINT, "CMtPtLocal::GetIcon: for '%s', chose '%s', '%d'", _GetNameDebug(), pszModule, iIcon);
    else
        TraceMsg(TF_MOUNTPOINT, "CMtPtLocal::GetIcon: for '%s', chose '%d'", _GetNameDebug(), iIcon);

    return iIcon;
}

HRESULT CMtPtLocal::GetAssocSystemElement(IAssociationElement **ppae)
{
    PCWSTR psz = NULL;
    if (_IsFixedDisk())
        psz = L"Drive.Fixed";
    else if (_IsFloppy())
        psz = L"Drive.Floppy";
    else if (_IsCDROM())
        psz = L"Drive.CDROM";
    else if (_IsStrictRemovable())
        psz = L"Drive.Removable";
        
    if (psz)
        return AssocElemCreateForClass(&CLSID_AssocSystemElement, psz, ppae);

    return E_FAIL;
}

int CMtPtLocal::GetDriveFlags()
{
    UINT uDriveFlags = 0;

    // Is this a CD/DVD of some sort?
    if (_IsCDROM()) 
    {
        // Yes
        LPCTSTR pszSubKey = NULL;
        if (_IsAudioDisc())
        {
            uDriveFlags |= DRIVE_AUDIOCD;
            pszSubKey = TEXT("AudioCD\\shell");
        }
        else if (_IsDVDDisc())
        {
            uDriveFlags |= DRIVE_DVD;
            pszSubKey = TEXT("DVD\\shell");
        }

        // Set the AutoOpen stuff, if applicable
        if (pszSubKey)
        {
            TCHAR ach[80];
            DWORD cb = sizeof(ach);
            ach[0] = 0;

            // get the default verb for Audio CD/DVD
            if (ERROR_SUCCESS == SHRegGetValue(HKEY_CLASSES_ROOT, pszSubKey, NULL, SRRF_RT_REG_SZ, NULL, ach, &cb))
            {
                // we should only set AUTOOPEN if there is a default verb on Audio CD/DVD
                if (ach[0])
                    uDriveFlags |= DRIVE_AUTOOPEN;
            }
        }
    }
    else
    {
        // No, by default every drive type is ShellOpen, except CD-ROMs
        uDriveFlags |= DRIVE_SHELLOPEN;
    }

    if (_IsAutorun())
    {
        uDriveFlags |= DRIVE_AUTORUN;

        //FEATURE should we set AUTOOPEN based on a flag in the AutoRun.inf???
        uDriveFlags |= DRIVE_AUTOOPEN;
    }

    return uDriveFlags;
}

void CMtPtLocal::GetTypeString(LPTSTR pszType, DWORD cchType)
{
    int iID;

    *pszType = 0;

    if (_CanUseVolume())
    {
        switch (_pvol->dwDriveType)
        {
            case HWDTS_FLOPPY35:
                if (_ShowUglyDriveNames())
                {
                    iID = IDS_DRIVES_DRIVE35_UGLY;
                }
                else
                {
                    iID = IDS_DRIVES_DRIVE35;
                }
                break;
            case HWDTS_FLOPPY525:
                if (_ShowUglyDriveNames())
                {
                    iID = IDS_DRIVES_DRIVE525_UGLY;
                }
                else
                {
                    iID = IDS_DRIVES_DRIVE525;
                }
                break;

            case HWDTS_REMOVABLEDISK:
                iID = IDS_DRIVES_REMOVABLE;
                break;
            case HWDTS_FIXEDDISK:
                iID = IDS_DRIVES_FIXED;
                break;
            case HWDTS_CDROM:
                iID = IDS_DRIVES_CDROM;
                break;
        }
    }
    else
    {
        UINT uDriveType = GetDriveType(_GetNameForFctCall());

        switch (uDriveType)
        {
            case DRIVE_REMOVABLE:
                iID = IDS_DRIVES_REMOVABLE;
                break;
            case DRIVE_REMOTE:
                iID = IDS_DRIVES_NETDRIVE;
                break;
            case DRIVE_CDROM:
                iID = IDS_DRIVES_CDROM;
                break;
            case DRIVE_RAMDISK:
                iID = IDS_DRIVES_RAMDISK;
                break;
            case DRIVE_FIXED:
            default:
                iID = IDS_DRIVES_FIXED;
                break;
        }
    }

    LoadString(HINST_THISDLL, iID, pszType, cchType);
}

DWORD CMtPtLocal::GetShellDescriptionID()
{
    DWORD dwShellDescrID;

    if (_CanUseVolume())
    {
        switch (_pvol->dwDriveType)
        {
            case HWDTS_FLOPPY35:
                dwShellDescrID = SHDID_COMPUTER_DRIVE35;
                break;
            case HWDTS_FLOPPY525:
                dwShellDescrID = SHDID_COMPUTER_DRIVE525;
                break;
            case HWDTS_REMOVABLEDISK:
                dwShellDescrID = SHDID_COMPUTER_REMOVABLE;
                break;
            case HWDTS_FIXEDDISK:
                dwShellDescrID = SHDID_COMPUTER_FIXED;
                break;
            case HWDTS_CDROM:
                dwShellDescrID = SHDID_COMPUTER_CDROM;
                break;
            default:
                dwShellDescrID = SHDID_COMPUTER_OTHER;
                break;
        }
    }
    else
    {
        UINT uDriveType = GetDriveType(_GetNameForFctCall());

        switch (uDriveType)
        {
            case DRIVE_REMOVABLE:
                dwShellDescrID = SHDID_COMPUTER_REMOVABLE;
                break;

            case DRIVE_CDROM:
                dwShellDescrID = SHDID_COMPUTER_CDROM;
                break;

            case DRIVE_FIXED:
                dwShellDescrID = SHDID_COMPUTER_FIXED;
                break;

            case DRIVE_RAMDISK:
                dwShellDescrID = SHDID_COMPUTER_RAMDISK;
                break;

            case DRIVE_NO_ROOT_DIR:
            case DRIVE_UNKNOWN:
            default:
                dwShellDescrID = SHDID_COMPUTER_OTHER;
                break;
        }
    }

    return dwShellDescrID;
}

///////////////////////////////////////////////////////////////////////////////
// DeviceIoControl stuff
///////////////////////////////////////////////////////////////////////////////
HANDLE CMtPtLocal::_GetHandleWithAccessAndShareMode(DWORD dwDesiredAccess, DWORD dwShareMode)
{
    HANDLE handle = INVALID_HANDLE_VALUE;
    WCHAR szVolumeGUIDWOSlash[50];
    DWORD dwFileAttributes = 0;

    if (_CanUseVolume())
    {
        StringCchCopy(szVolumeGUIDWOSlash, ARRAYSIZE(szVolumeGUIDWOSlash),
            _pvol->pszVolumeGUID);

        PathRemoveBackslash(szVolumeGUIDWOSlash);
    }
    else
    {
        // Go for VolumeGUID first
        if (GetVolumeNameForVolumeMountPoint(_GetName(), szVolumeGUIDWOSlash,
            ARRAYSIZE(szVolumeGUIDWOSlash)))
        {
            PathRemoveBackslash(szVolumeGUIDWOSlash);
        }
        else
        {
            // Probably a floppy, which cannot be mounted on a folder
            StringCchCopy(szVolumeGUIDWOSlash, ARRAYSIZE(szVolumeGUIDWOSlash),
                TEXT("\\\\.\\A:"));
            szVolumeGUIDWOSlash[4] = _GetNameFirstCharUCase();
        }
    }

    return CreateFile(szVolumeGUIDWOSlash, dwDesiredAccess, dwShareMode, NULL, OPEN_EXISTING, dwFileAttributes, NULL);
}

// On NT, when use GENERIC_READ (as opposed to 0) in the CreateFile call, we
// get a handle to the filesystem (CDFS), not the device itself.  But we can't
// change DriveIOCTL to do this, since that causes the floppy disks to spin
// up, and we don't want to do that.
HANDLE CMtPtLocal::_GetHandleReadRead()
{
    return _GetHandleWithAccessAndShareMode(GENERIC_READ, FILE_SHARE_READ);
}

BOOL CMtPtLocal::_CanUseVolume()
{
    // This is used in ASSERTs, do not add code that would introduce a side
    // effect in debug only (stephstm)

    // For Dismounted volumes, we want the code to take the alternate code
    // path.  The volume, when ready to be re-mounted, will be remounted
    // until some code tries to access it.  So using the alternate code path
    // will try to remount it, if it's ready it will get remounted, the Shell
    // Service will get an event, and we'll remove the DISMOUNTED bit.
    return (_pvol && !(_pvol->dwVolumeFlags & HWDVF_STATE_ACCESSDENIED) &&
        !(_pvol->dwVolumeFlags & HWDVF_STATE_DISMOUNTED));
}

HRESULT CMtPtLocal::_InitWithVolume(LPCWSTR pszMtPt, CVolume* pvol)
{
    HRESULT hr = StringCchCopy(_szName, ARRAYSIZE(_szName), pszMtPt);

    if (SUCCEEDED(hr))
    {
        pvol->AddRef();
        _pvol = pvol;

        PathAddBackslash(_szName);

        _fMountedOnDriveLetter = _IsDriveLetter(pszMtPt);

        RSInitRoot(HKEY_CURRENT_USER, REGSTR_MTPT_ROOTKEY2, _pvol->pszKeyName,
            REG_OPTION_NON_VOLATILE);

        RSSetTextValue(NULL, TEXT("BaseClass"), TEXT("Drive"));

        _InitAutorunInfo();

        if (_CanUseVolume())
        {
            if (HWDMC_HASDESKTOPINI & _pvol->dwMediaCap)
            {
                // we need to listen to change notify to know when this guys will change
                _UpdateCommentFromDesktopINI();
            }
        }

        _InitLegacyRegIconAndLabelHelper();
    }
    
    return hr;
}

// These can only be mounted on drive letter
HRESULT CMtPtLocal::_Init(LPCWSTR pszMtPt)
{
    HRESULT hr;
    ASSERT(_IsDriveLetter(pszMtPt));

    if (GetLogicalDrives() & (1 << DRIVEID(pszMtPt)))
    {
        _fMountedOnDriveLetter = TRUE;

        hr = StringCchCopy(_szName, ARRAYSIZE(_szName), pszMtPt);

        if (SUCCEEDED(hr))
        {
            PathAddBackslash(_szName);

            _GetNameFirstXChar(_szNameNoVolume, ARRAYSIZE(_szNameNoVolume));

            RSInitRoot(HKEY_CURRENT_USER, REGSTR_MTPT_ROOTKEY2, _szNameNoVolume,
                REG_OPTION_NON_VOLATILE);

            RSSetTextValue(NULL, TEXT("BaseClass"), TEXT("Drive"));

            _InitAutorunInfo();
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

void CMtPtLocal::_InitLegacyRegIconAndLabelHelper()
{
    CMountPoint::_InitLegacyRegIconAndLabel(_HasAutorunIcon(),
        _HasAutorunLabel());
}

void CMtPtLocal::StoreIconForUpdateImage(int iImage)
{
    if (_CanUseVolume())
    {
        _pvol->iShellImageForUpdateImage = iImage;
    }
}

void CMtPtLocal::_InitAutorunInfo()
{
    if (_Shell32LoadedInDesktop())
    {
        BOOL fAutorun = FALSE;

        if (!_CanUseVolume())
        {
            if (_IsAutorun())
            {
                fAutorun = TRUE;
            }
        }

        if (!fAutorun && !_fVolumePoint)
        {
            // Make sure to delete the shell key
            RSDeleteSubKey(TEXT("Shell"));
        }
    }
}

// Equivalent of GetDriveType API
int CMtPtLocal::_GetDriveType()
{
    int iDriveType = DRIVE_NO_ROOT_DIR;

    if (_CanUseVolume())
    {
        switch (_pvol->dwDriveType)
        {
            case HWDTS_FLOPPY35:
            case HWDTS_FLOPPY525:
            case HWDTS_REMOVABLEDISK:
                iDriveType = DRIVE_REMOVABLE;
                break;
            case HWDTS_FIXEDDISK:
                iDriveType = DRIVE_FIXED;
                break;
            case HWDTS_CDROM:
                iDriveType = DRIVE_CDROM;
                break;
        }
    }
    else
    {
        iDriveType = GetDriveType(_GetNameForFctCall());
    }

    return iDriveType;
}

#define VALID_VOLUME_PREFIX TEXT("\\\\?\\Volume")

// static
HRESULT CMtPtLocal::_CreateVolume(VOLUMEINFO* pvolinfo, CVolume** ppvolNew)
{
    ASSERT(_csDL.IsInside());
    HRESULT hr;

    if (!StrCmpN(pvolinfo->pszVolumeGUID, VALID_VOLUME_PREFIX, ARRAYSIZE(VALID_VOLUME_PREFIX) - 1))
    {
        CVolume* pvol = new CVolume();

        *ppvolNew = NULL;

        if (pvol)
        {
            // The next four strings shouyld always be set to something
            pvol->pszDeviceIDVolume = StrDup(pvolinfo->pszDeviceIDVolume);
            pvol->pszVolumeGUID = StrDup(pvolinfo->pszVolumeGUID);
            pvol->pszLabel = StrDup(pvolinfo->pszLabel);
            pvol->pszFileSystem = StrDup(pvolinfo->pszFileSystem);

            // The following five strings are optional
            if (pvolinfo->pszAutorunIconLocation)
            {
                pvol->pszAutorunIconLocation = StrDup(pvolinfo->pszAutorunIconLocation);
            }

            if (pvolinfo->pszAutorunLabel)
            {
                pvol->pszAutorunLabel = StrDup(pvolinfo->pszAutorunLabel);
            }

            if (pvolinfo->pszIconLocationFromService)
            {
                pvol->pszIconFromService = StrDup(pvolinfo->pszIconLocationFromService);
            }

            if (pvolinfo->pszNoMediaIconLocationFromService)
            {
                pvol->pszNoMediaIconFromService = StrDup(pvolinfo->pszNoMediaIconLocationFromService);
            }

            if (pvolinfo->pszLabelFromService)
            {
                pvol->pszLabelFromService = StrDup(pvolinfo->pszLabelFromService);
            }
        
            if (pvol->pszDeviceIDVolume && pvol->pszVolumeGUID && pvol->pszLabel &&
                pvol->pszFileSystem)
            {
                pvol->dwState = pvolinfo->dwState;
                pvol->dwVolumeFlags = pvolinfo->dwVolumeFlags;
                pvol->dwDriveType = pvolinfo->dwDriveType;
                pvol->dwDriveCapability = pvolinfo->dwDriveCapability;
                pvol->dwFileSystemFlags = pvolinfo->dwFileSystemFlags;
                pvol->dwMaxFileNameLen = pvolinfo->dwMaxFileNameLen;
                pvol->dwRootAttributes = pvolinfo->dwRootAttributes;
                pvol->dwSerialNumber = pvolinfo->dwSerialNumber;
                pvol->dwDriveState = pvolinfo->dwDriveState;
                pvol->dwMediaState = pvolinfo->dwMediaState;
                pvol->dwMediaCap = pvolinfo->dwMediaCap;

                if (_hdpaVolumes && (-1 != DPA_AppendPtr(_hdpaVolumes, pvol)))
                {
                    pvol->pszKeyName = pvol->pszVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID;

                    pvol->AddRef();
                    *ppvolNew = pvol;
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if (FAILED(hr))
            {
                delete pvol;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

// this helper function will hit the drive to see if media is present.
// should only be used for drives that don't support the HWDVF_STATE_SUPPORTNOTIFICATION
BOOL CMtPtLocal::_ForceCheckMediaPresent()
{
    BOOL bRet = FALSE;  // assume no media present

    HANDLE hDevice = _GetHandleWithAccessAndShareMode(GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE);

    if (hDevice != INVALID_HANDLE_VALUE)
    {
        DWORD dwDummy;

        // call the ioctl to verify media presence
        if (DeviceIoControl(hDevice,
                            IOCTL_STORAGE_CHECK_VERIFY,
                            NULL,
                            0,
                            NULL,
                            0,
                            &dwDummy,
                            NULL))
        {
            bRet = TRUE;
        }

        CloseHandle(hDevice);
    }

    return bRet;
}

BOOL CMtPtLocal::_IsMediaPresent()
{
    BOOL bRet;

    if (!_CanUseVolume() || !(_pvol->dwVolumeFlags & HWDVF_STATE_SUPPORTNOTIFICATION))
    {
        // if the drive dosen't support notification, we need to ping it now
        bRet = _ForceCheckMediaPresent();
    }
    else
    {
        bRet = (HWDMS_PRESENT & _pvol->dwMediaState);
    }

    return bRet;
}

BOOL CMtPtLocal::_IsFormatted()
{
    BOOL bRet = FALSE;

    if (!_CanUseVolume() || !(_pvol->dwVolumeFlags & HWDVF_STATE_SUPPORTNOTIFICATION))
    {
        // if the drive dosen't support notification, we need to ping it now
        bRet = GetVolumeInformation(_GetNameForFctCall(),
                                    NULL,
                                    0,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);
    }
    else
    {
        bRet = (_IsMediaPresent() && (HWDMS_FORMATTED & _pvol->dwMediaState));
    }

    return bRet;
}

BOOL CMtPtLocal::_IsReadOnly()
{
    ASSERT(_CanUseVolume());
    ASSERT(_IsMediaPresent()); // does not make sense otherwise
    BOOL fRet = FALSE;

    if (_IsCDROM() &&
            (
                (HWDMC_WRITECAPABILITY_SUPPORTDETECTION & _pvol->dwMediaState) &&
                (
                    (HWDMC_CDROM & _pvol->dwMediaCap) ||
                    (HWDMC_DVDROM & _pvol->dwMediaCap)
                )
            )
        )
    {
        fRet = TRUE;
    }
    else
    {
        // We could optimize by checking if the floppy is write protected.  But
        // it might not be worth it.
        fRet = FALSE;
    }

    return fRet;
}

BOOL CMtPtLocal::_IsMountedOnDriveLetter()
{
    return _fMountedOnDriveLetter;
}

CMtPtLocal::CMtPtLocal()
{
#ifdef DEBUG
    ++_cMtPtLocal;
#endif
}

CMtPtLocal::~CMtPtLocal()
{
    if (_pvol)
    {
        _pvol->Release();
    }

#ifdef DEBUG
    --_cMtPtLocal;
#endif
}

// static
HRESULT CMtPtLocal::_CreateMtPtLocal(LPCWSTR pszMountPoint)
{
    ASSERT(_csDL.IsInside());
    HRESULT hr;
    CMtPtLocal* pmtptl = new CMtPtLocal();

    if (pmtptl)
    {
        int iDrive = DRIVEID(pszMountPoint);

        if (_rgMtPtDriveLetterLocal[iDrive])
        {
            _rgMtPtDriveLetterLocal[iDrive]->Release();
            _rgMtPtDriveLetterLocal[iDrive] = NULL;
        }

        hr = pmtptl->_Init(pszMountPoint);

        if (SUCCEEDED(hr))
        {
            // Yes
            _rgMtPtDriveLetterLocal[iDrive] = pmtptl;
        }
        else
        {
            delete pmtptl;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

HRESULT CMtPtLocal::GetMountPointName(LPWSTR pszMountPoint, DWORD cchMountPoint)
{
    return StringCchCopy(pszMountPoint, cchMountPoint, _GetName());
}

// static
HRESULT CMtPtLocal::_CreateMtPtLocalWithVolume(LPCWSTR pszMountPoint,
    CVolume* pvol)
{
    ASSERT(_csDL.IsInside());
    HRESULT hr;
    CMtPtLocal* pmtptlNew = new CMtPtLocal();

    if (pmtptlNew)
    {
        // Is it a drive letter only?
        if (_IsDriveLetter(pszMountPoint))
        {
            // Yes
            int iDrive = DRIVEID(pszMountPoint);

            if (_rgMtPtDriveLetterLocal[iDrive])
            {
                _rgMtPtDriveLetterLocal[iDrive]->Release();
                _rgMtPtDriveLetterLocal[iDrive] = NULL;
            }
        }
        else
        {
            _RemoveLocalMountPoint(pszMountPoint);
        }

        hr = pmtptlNew->_InitWithVolume(pszMountPoint, pvol);

        if (SUCCEEDED(hr))
        {
            // Is it a drive letter only?
            if (_IsDriveLetter(pszMountPoint))
            {
                // Yes
                int iDrive = DRIVEID(pszMountPoint);

                _rgMtPtDriveLetterLocal[iDrive] = pmtptlNew;
            }
            else
            {
                hr = _StoreMtPtMOF(pmtptlNew);
            }
        }

        if (FAILED(hr))
        {
            delete pmtptlNew;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

// static
HRESULT CMtPtLocal::_CreateMtPtLocalFromVolumeGuid(LPCWSTR pszVolumeGuid, CMountPoint ** ppmtpt )
{
    ASSERT(_csDL.IsInside());
    HRESULT hr;
    CMtPtLocal* pmtptlNew = new CMtPtLocal();

    Assert(NULL != ppmtpt);
    *ppmtpt = (CMountPoint*)pmtptlNew;

    if (pmtptlNew)
    {
        ASSERT(NULL == pmtptlNew->_pvol);

        hr = StringCchCopy(pmtptlNew->_szName, ARRAYSIZE(pmtptlNew->_szName), pszVolumeGuid);

        if (SUCCEEDED(hr))
        {
            pmtptlNew->RSInitRoot(HKEY_CURRENT_USER, REGSTR_MTPT_ROOTKEY2, pmtptlNew->_szName,
                REG_OPTION_NON_VOLATILE);

            PathAddBackslash(pmtptlNew->_szName);

            pmtptlNew->_fMountedOnDriveLetter = FALSE;
            pmtptlNew->_fVolumePoint = TRUE;
            pmtptlNew->_InitAutorunInfo();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

// static
CVolume* CMtPtLocal::_GetVolumeByMtPt(LPCWSTR pszMountPoint)
{
    ASSERT(_csDL.IsInside());
    CVolume* pvol = NULL;
    WCHAR szVolumeGUID[50];

    if (_fLocalDrivesInited)
    {
        if (GetVolumeNameForVolumeMountPoint(pszMountPoint, szVolumeGUID,
            ARRAYSIZE(szVolumeGUID)))
        {
            DWORD c = DPA_GetPtrCount(_hdpaVolumes);

            for (DWORD dw = 0; dw < c; ++dw)
            {
                pvol = (CVolume*)DPA_GetPtr(_hdpaVolumes, dw);

                if (pvol)
                {
                    if (!lstrcmpi(pvol->pszVolumeGUID, szVolumeGUID))
                    {
                        pvol->AddRef();
                        break;
                    }
                    else
                    {
                        pvol = NULL;
                    }
                }
            }
        }
    }

    return pvol;
}

// static
CVolume* CMtPtLocal::_GetVolumeByID(LPCWSTR pszDeviceIDVolume)
{
    ASSERT(_csDL.IsInside());
    CVolume* pvol = NULL;

    if (_hdpaVolumes)
    {
        DWORD c = DPA_GetPtrCount(_hdpaVolumes);

        for (DWORD dw = 0; dw < c; ++dw)
        {
            pvol = (CVolume*)DPA_GetPtr(_hdpaVolumes, dw);

            if (pvol)
            {
                if (!lstrcmpi(pvol->pszDeviceIDVolume, pszDeviceIDVolume))
                {
                    pvol->AddRef();
                    break;
                }
                else
                {
                    pvol = NULL;
                }
            }
        }
    }

    return pvol;
}

// static
CVolume* CMtPtLocal::_GetAndRemoveVolumeByID(LPCWSTR pszDeviceIDVolume)
{
    CVolume* pvol = NULL;

    _csDL.Enter();

    if (_hdpaVolumes)
    {
        DWORD c = DPA_GetPtrCount(_hdpaVolumes);

        for (int i = c - 1; i >= 0; --i)
        {
            pvol = (CVolume*)DPA_GetPtr(_hdpaVolumes, i);

            if (pvol)
            {
                if (!lstrcmpi(pvol->pszDeviceIDVolume, pszDeviceIDVolume))
                {
                    // Do not AddRef
                    DPA_DeletePtr(_hdpaVolumes, i);
                    break;
                }
                else
                {
                    pvol = NULL;
                }
            }
        }
    }

    _csDL.Leave();

    return pvol;
}

// static
HRESULT CMtPtLocal::_GetAndRemoveVolumeAndItsMtPts(LPCWSTR pszDeviceIDVolume,
    CVolume** ppvol, HDPA hdpaMtPts)
{
    _csDL.Enter();

    CVolume* pvol = _GetAndRemoveVolumeByID(pszDeviceIDVolume);

    if (pvol)
    {
        for (DWORD dw = 0; dw < 26; ++dw)
        {
            CMtPtLocal* pmtptl = (CMtPtLocal*)_rgMtPtDriveLetterLocal[dw];

            if (pmtptl && pmtptl->_pvol)
            {
                if (pmtptl->_pvol == pvol)
                {
                    _rgMtPtDriveLetterLocal[dw] = 0;

                    DPA_AppendPtr(hdpaMtPts, pmtptl);
                    break;
                }
            }
        }

        _csLocalMtPtHDPA.Enter();

        if (_hdpaMountPoints)
        {
            DWORD c = DPA_GetPtrCount(_hdpaMountPoints);

            for (int i = c - 1; i >= 0; --i)
            {
                CMtPtLocal* pmtptl = (CMtPtLocal*)DPA_GetPtr(_hdpaMountPoints, i);

                if (pmtptl && pmtptl->_pvol)
                {
                    if (pmtptl->_pvol == pvol)
                    {
                        DPA_DeletePtr(_hdpaMountPoints, i);

                        DPA_AppendPtr(hdpaMtPts, pmtptl);
                    }
                }
            }
        }

        _csLocalMtPtHDPA.Leave();
    }

    *ppvol = pvol;

    _csDL.Leave();

    return S_OK;
}

BOOL CMtPtLocal::_IsMiniMtPt()
{
    return !_CanUseVolume();
}

HKEY CMtPtLocal::GetRegKey()
{
    TraceMsg(TF_MOUNTPOINT, "CMtPtLocal::GetRegKey: for '%s'", _GetNameDebug());

    if (_IsAutoRunDrive())
    {
        _ProcessAutoRunFile();
    }

    return RSDuplicateRootKey();
}

DWORD CMtPtLocal::_GetRegVolumeGen()
{
    ASSERT(_CanUseVolume());
    DWORD dwGen;

    if (!_rsVolumes.RSGetDWORDValue(_pvol->pszVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID, TEXT("Generation"), &dwGen))
    {
        dwGen = 0;
    }

    return dwGen;
}

BOOL CMtPtLocal::_NeedToRefresh()
{
    ASSERT(_csDL.IsInside());
    ASSERT(!_Shell32LoadedInDesktop());
    BOOL fNeedToRefresh = FALSE;

    if (_CanUseVolume())
    {
        DWORD dwRegVolumeGeneration = _GetRegVolumeGen();

        if (dwRegVolumeGeneration != _pvol->dwGeneration)
        {
            // Remove it so that new mtpts do not get it.
            CVolume* pvolnew;
            CVolume* pvol = _GetAndRemoveVolumeByID(_pvol->pszDeviceIDVolume);

            if (pvol)
            {
                // Release our cache ref count
                pvol->Release();
            }

            // Replace the volume
            if (SUCCEEDED(CMtPtLocal::_CreateVolumeFromReg(_pvol->pszDeviceIDVolume,
                &pvolnew)))
            {
                pvolnew->Release();
            }

            fNeedToRefresh = TRUE;
        }
    }

    return fNeedToRefresh;
}

// static 
HRESULT CMtPtLocal::_CreateVolumeFromVOLUMEINFO2(VOLUMEINFO2* pvolinfo2, CVolume** ppvolNew)
{
    VOLUMEINFO volinfo = {0};

    volinfo.pszDeviceIDVolume = pvolinfo2->szDeviceIDVolume;
    volinfo.pszVolumeGUID = pvolinfo2->szVolumeGUID;
    volinfo.pszLabel = pvolinfo2->szLabel;
    volinfo.pszFileSystem = pvolinfo2->szFileSystem;

    volinfo.dwState = pvolinfo2->dwState;
    volinfo.dwVolumeFlags = pvolinfo2->dwVolumeFlags;
    volinfo.dwDriveType = pvolinfo2->dwDriveType;
    volinfo.dwDriveCapability = pvolinfo2->dwDriveCapability;
    volinfo.dwFileSystemFlags = pvolinfo2->dwFileSystemFlags;
    volinfo.dwMaxFileNameLen = pvolinfo2->dwMaxFileNameLen;
    volinfo.dwRootAttributes = pvolinfo2->dwRootAttributes;
    volinfo.dwSerialNumber = pvolinfo2->dwSerialNumber;
    volinfo.dwDriveState = pvolinfo2->dwDriveState;
    volinfo.dwMediaState = pvolinfo2->dwMediaState;
    volinfo.dwMediaCap = pvolinfo2->dwMediaCap;

    if (-1 != pvolinfo2->oAutorunIconLocation)
    {
        volinfo.pszAutorunIconLocation = pvolinfo2->szOptionalStrings +
            pvolinfo2->oAutorunIconLocation;
    }
    if (-1 != pvolinfo2->oAutorunLabel)
    {
        volinfo.pszAutorunLabel = pvolinfo2->szOptionalStrings +
            pvolinfo2->oAutorunLabel;
    }
    if (-1 != pvolinfo2->oIconLocationFromService)
    {
        volinfo.pszIconLocationFromService = pvolinfo2->szOptionalStrings +
            pvolinfo2->oIconLocationFromService;
    }
    if (-1 != pvolinfo2->oNoMediaIconLocationFromService)
    {
        volinfo.pszNoMediaIconLocationFromService = pvolinfo2->szOptionalStrings +
            pvolinfo2->oNoMediaIconLocationFromService;
    }
    if (-1 != pvolinfo2->oLabelFromService)
    {
        volinfo.pszLabelFromService = pvolinfo2->szOptionalStrings +
            pvolinfo2->oLabelFromService;
    }

    return _CreateVolume(&volinfo, ppvolNew);
}

// static 
HRESULT CMtPtLocal::_CreateVolumeFromRegHelper(LPCWSTR pszGUID, CVolume** ppvolNew)
{
    ASSERT(!_Shell32LoadedInDesktop());
    ASSERT(_csDL.IsInside());
    HRESULT hr;
    
    DWORD cbSize = MAX_VOLUMEINFO2;
    PBYTE pb = (PBYTE)LocalAlloc(LPTR, cbSize);

    if (pb)
    {
        if (_rsVolumes.RSGetBinaryValue(pszGUID, TEXT("Data"), pb, &cbSize))
        {
            DWORD dwGen;

            if (_rsVolumes.RSGetDWORDValue(pszGUID, TEXT("Generation"), &dwGen))
            {
                VOLUMEINFO2* pvolinfo2 = (VOLUMEINFO2*)pb;

                hr = _CreateVolumeFromVOLUMEINFO2(pvolinfo2, ppvolNew);

                if (SUCCEEDED(hr))
                {
                    (*ppvolNew)->dwGeneration = dwGen;
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_FAIL;
        }

        LocalFree(pb);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// static 
HRESULT CMtPtLocal::_CreateVolumeFromReg(LPCWSTR pszDeviceIDVolume, CVolume** ppvolNew)
{
    ASSERT(!_Shell32LoadedInDesktop());
    ASSERT(_csDL.IsInside());
    HRESULT hr;
    
    WCHAR szDeviceIDWithSlash[MAX_PATH];
    WCHAR szVolumeGUID[50];

    hr = StringCchCopy(szDeviceIDWithSlash, ARRAYSIZE(szDeviceIDWithSlash),
        pszDeviceIDVolume);

    if (SUCCEEDED(hr))
    {
        if (PathAddBackslash(szDeviceIDWithSlash))
        {
            if (GetVolumeNameForVolumeMountPoint(szDeviceIDWithSlash,
                szVolumeGUID, ARRAYSIZE(szVolumeGUID)))
            {
                LPWSTR pszGUID = &(szVolumeGUID[OFFSET_GUIDWITHINVOLUMEGUID]);

                hr = _CreateVolumeFromRegHelper(pszGUID, ppvolNew);
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

// static
HRESULT CMtPtLocal::_UpdateVolumeRegInfo(VOLUMEINFO* pvolinfo)
{
    ASSERT(_Shell32LoadedInDesktop());
    ASSERT(_csDL.IsInside());

    HRESULT hr;
    DWORD cbSize = MAX_VOLUMEINFO2;
    PBYTE pb = (PBYTE)LocalAlloc(LPTR, cbSize);

    if (pb)
    {
        DWORD dwGen;
        VOLUMEINFO2* pvolinfo2 = (VOLUMEINFO2*)pb;

        // Get the Generation
        if (!_rsVolumes.RSGetDWORDValue(
            pvolinfo->pszVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID, TEXT("Generation"),
            &dwGen))
        {
            dwGen = 0;
        }

        ++dwGen;
        
        ASSERT(pvolinfo->pszDeviceIDVolume);
        ASSERT(pvolinfo->pszVolumeGUID);
        ASSERT(pvolinfo->pszLabel);
        ASSERT(pvolinfo->pszFileSystem);

        hr = StringCchCopy(pvolinfo2->szDeviceIDVolume, ARRAYSIZE(pvolinfo2->szDeviceIDVolume),
            pvolinfo->pszDeviceIDVolume);

        if (SUCCEEDED(hr))
        {
            hr = StringCchCopy(pvolinfo2->szVolumeGUID, ARRAYSIZE(pvolinfo2->szVolumeGUID),
                pvolinfo->pszVolumeGUID);
        }

        if (SUCCEEDED(hr))
        {
            StringCchCopy(pvolinfo2->szLabel, ARRAYSIZE(pvolinfo2->szLabel),
                pvolinfo->pszLabel);
            StringCchCopy(pvolinfo2->szFileSystem, ARRAYSIZE(pvolinfo2->szFileSystem),
                pvolinfo->pszFileSystem);

            pvolinfo2->dwState = pvolinfo->dwState;
            pvolinfo2->dwVolumeFlags = pvolinfo->dwVolumeFlags;
            pvolinfo2->dwDriveType = pvolinfo->dwDriveType;
            pvolinfo2->dwDriveCapability = pvolinfo->dwDriveCapability;
            pvolinfo2->dwFileSystemFlags = pvolinfo->dwFileSystemFlags;
            pvolinfo2->dwMaxFileNameLen = pvolinfo->dwMaxFileNameLen;
            pvolinfo2->dwRootAttributes = pvolinfo->dwRootAttributes;
            pvolinfo2->dwSerialNumber = pvolinfo->dwSerialNumber;
            pvolinfo2->dwDriveState = pvolinfo->dwDriveState;
            pvolinfo2->dwMediaState = pvolinfo->dwMediaState;
            pvolinfo2->dwMediaCap = pvolinfo->dwMediaCap;

            pvolinfo2->oAutorunIconLocation = -1;
            pvolinfo2->oAutorunLabel = -1;
            pvolinfo2->oIconLocationFromService = -1;
            pvolinfo2->oNoMediaIconLocationFromService = -1;
            pvolinfo2->oLabelFromService = -1;

            LPWSTR pszNext = pvolinfo2->szOptionalStrings;
            size_t cchLeft = (cbSize - sizeof(*pvolinfo2) + 
                sizeof(pvolinfo2->szOptionalStrings)) / sizeof(WCHAR);
            size_t cchLeftBeginWith = cchLeft;
            
             // The following five strings are optional
            if (pvolinfo->pszAutorunIconLocation)
            {
                pvolinfo2->oAutorunIconLocation = (DWORD)(cchLeftBeginWith - cchLeft);

                hr = StringCchCopyEx(pszNext, cchLeft, pvolinfo->pszAutorunIconLocation, &pszNext, &cchLeft, 0);
                
                ++pszNext;
                --cchLeft;
            }

            if (SUCCEEDED(hr) && pvolinfo->pszAutorunLabel)
            {
                pvolinfo2->oAutorunLabel = (DWORD)(cchLeftBeginWith - cchLeft);

                hr = StringCchCopyEx(pszNext, cchLeft, pvolinfo->pszAutorunLabel, &pszNext, &cchLeft, 0);
                
                ++pszNext;
                --cchLeft;
            }

            if (SUCCEEDED(hr) && pvolinfo->pszIconLocationFromService)
            {
                pvolinfo2->oIconLocationFromService = (DWORD)(cchLeftBeginWith - cchLeft);
                
                hr = StringCchCopyEx(pszNext, cchLeft, pvolinfo->pszIconLocationFromService, &pszNext, &cchLeft, 0);
                
                ++pszNext;
                --cchLeft;
            }

            if (SUCCEEDED(hr) && pvolinfo->pszNoMediaIconLocationFromService)
            {
                pvolinfo2->oNoMediaIconLocationFromService = (DWORD)(cchLeftBeginWith - cchLeft);
                
                hr = StringCchCopyEx(pszNext, cchLeft, pvolinfo->pszNoMediaIconLocationFromService, &pszNext, &cchLeft, 0);
                
                ++pszNext;
                --cchLeft;
            }

            if (SUCCEEDED(hr) && pvolinfo->pszLabelFromService)
            {
                pvolinfo2->oLabelFromService = (DWORD)(cchLeftBeginWith - cchLeft);

                hr = StringCchCopyEx(pszNext, cchLeft, pvolinfo->pszLabelFromService, &pszNext, &cchLeft, 0);

                // Remove one for the null terminator
                --cchLeft;
            }

            if (SUCCEEDED(hr))
            {
                if (_rsVolumes.RSSetBinaryValue(pvolinfo->pszVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID,
                    TEXT("Data"), pb, cbSize - (cchLeft * sizeof(WCHAR)), REG_OPTION_VOLATILE))
                {
                    if (_rsVolumes.RSSetDWORDValue(pvolinfo->pszVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID,
                        TEXT("Generation"), dwGen))
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }

            if (FAILED(hr))
            {
                _rsVolumes.RSDeleteSubKey(pvolinfo->pszVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID);
            }
        }

        LocalFree(pb);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// static
HRESULT CMtPtLocal::_UpdateVolumeRegInfo2(VOLUMEINFO2* pvolinfo2)
{
    ASSERT(_Shell32LoadedInDesktop());
    ASSERT(_csDL.IsInside());

    HRESULT hr;
    DWORD dwGen;

    // Get the Generation
    if (!_rsVolumes.RSGetDWORDValue(
        pvolinfo2->szVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID, TEXT("Generation"),
        &dwGen))
    {
        dwGen = 0;
    }

    ++dwGen;

    if (_rsVolumes.RSSetBinaryValue(pvolinfo2->szVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID,
        TEXT("Data"), (PBYTE)pvolinfo2, pvolinfo2->cbSize, REG_OPTION_VOLATILE))
    {
        if (_rsVolumes.RSSetDWORDValue(pvolinfo2->szVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID,
            TEXT("Generation"), dwGen))
        {
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    if (FAILED(hr))
    {
        _rsVolumes.RSDeleteSubKey(pvolinfo2->szVolumeGUID + OFFSET_GUIDWITHINVOLUMEGUID);
    }

    return hr;
}

//static
BOOL CMtPtLocal::Initialize()
{
    _rsVolumes.RSInitRoot(HKEY_CURRENT_USER, REGSTR_MTPT_ROOTKEY2,
        g_szCrossProcessCacheVolumeKey, REG_OPTION_VOLATILE);

	return TRUE;
}

void CMtPtLocal::FinalCleanUp()
{
    if (_Shell32LoadedInDesktop())
    {
        _rsVolumes.RSDeleteKey();
    }
}

static const TWODWORDS arcontenttypemappings[] =
{
    { HWDMC_HASAUTORUNINF, ARCONTENT_AUTORUNINF },
    { HWDMC_HASAUDIOTRACKS, ARCONTENT_AUDIOCD },
    { HWDMC_HASDVDMOVIE, ARCONTENT_DVDMOVIE },
};

static const TWODWORDS arblankmediamappings[] =
{
    { HWDMC_CDRECORDABLE, ARCONTENT_BLANKCD },
    { HWDMC_CDREWRITABLE, ARCONTENT_BLANKCD },
    { HWDMC_DVDRECORDABLE, ARCONTENT_BLANKDVD },
    { HWDMC_DVDREWRITABLE, ARCONTENT_BLANKDVD },
};

DWORD CMtPtLocal::_GetAutorunContentType()
{
    DWORD dwRet = 0;
    
    if (_CanUseVolume())
    {
        dwRet = _DoDWORDMapping(_pvol->dwMediaCap, arcontenttypemappings,
            ARRAYSIZE(arcontenttypemappings), TRUE);

        if (_pvol->dwMediaState & HWDMS_FORMATTED)
        {
            dwRet |= ARCONTENT_UNKNOWNCONTENT;
        }
        else
        {
            ASSERT(!dwRet);

            DWORD dwDriveCapabilities;
            DWORD dwMediaCapabilities;

            if (_IsCDROM())
            {
                if (SUCCEEDED(CDBurn_GetCDInfo(_pvol->pszVolumeGUID, &dwDriveCapabilities, &dwMediaCapabilities)))
                {
                    dwRet = _DoDWORDMapping(dwMediaCapabilities, arblankmediamappings,
                        ARRAYSIZE(arblankmediamappings), TRUE);
                }
            }
        }
    }
    else
    {
        // If there's no _pvol, we care only about autorun.inf
        if (_IsAutorun())
        {
            dwRet = ARCONTENT_AUTORUNINF;
        }

        if (_IsFormatted())
        {
            dwRet |= ARCONTENT_UNKNOWNCONTENT;
        }
    }
    
    return dwRet;
}

// static
BOOL CMtPtLocal::IsVolume(LPCWSTR pszDeviceID)
{
    BOOL fRet = FALSE;

    _csDL.Enter();

    CVolume* pvol = _GetVolumeByID(pszDeviceID);

    if (pvol)
    {
        fRet = TRUE;
        pvol->Release();
    }

    _csDL.Leave();
    
    return fRet;
}

static const TWODWORDS drivetypemappings[] =
{
    { HWDTS_FLOPPY35     , DT_FLOPPY35 },
    { HWDTS_FLOPPY525    , DT_FLOPPY525 },
    { HWDTS_REMOVABLEDISK, DT_REMOVABLEDISK },
    { HWDTS_FIXEDDISK    , DT_FIXEDDISK },
    { HWDTS_CDROM        , DT_CDROM },
};

static const TWODWORDS drivetypemappingusingGDT[] =
{
    { DRIVE_REMOVABLE    , DT_REMOVABLEDISK },
    { DRIVE_FIXED        , DT_FIXEDDISK },
    { DRIVE_RAMDISK      , DT_FIXEDDISK },
    { DRIVE_CDROM        , DT_CDROM },
};

static const TWODWORDS cdtypemappings[] =
{
    { HWDDC_CDROM        , DT_CDROM },
    { HWDDC_CDRECORDABLE , DT_CDR },
    { HWDDC_CDREWRITABLE , DT_CDRW },
    { HWDDC_DVDROM       , DT_DVDROM },
    { HWDDC_DVDRECORDABLE, DT_DVDR },
    { HWDDC_DVDREWRITABLE, DT_DVDRW },
    { HWDDC_DVDRAM       , DT_DVDRAM },
};

DWORD CMtPtLocal::_GetMTPTDriveType()
{
    DWORD dwRet = 0;
    
    if (_CanUseVolume())
    {
        dwRet = _DoDWORDMapping(_pvol->dwDriveType, drivetypemappings,
            ARRAYSIZE(drivetypemappings), TRUE);

        if (DT_CDROM == dwRet)
        {
            DWORD dwDriveCapabilities;
            DWORD dwMediaCapabilities;

            if (SUCCEEDED(CDBurn_GetCDInfo(_pvol->pszVolumeGUID, &dwDriveCapabilities, &dwMediaCapabilities)))
            {
                dwRet |= _DoDWORDMapping(dwDriveCapabilities, cdtypemappings,
                    ARRAYSIZE(cdtypemappings), TRUE);
            }
        }
    }
    else
    {
        dwRet = _DoDWORDMapping(GetDriveType(_GetNameForFctCall()), drivetypemappingusingGDT,
            ARRAYSIZE(drivetypemappingusingGDT), FALSE);
    }

    return dwRet;
}

/* TBD
        CT_UNKNOWNCONTENT              0x00000008

        CT_AUTOPLAYMUSIC               0x00000100
        CT_AUTOPLAYPIX                 0x00000200
        CT_AUTOPLAYMOVIE               0x00000400*/
static const TWODWORDS contenttypemappings[] =
{
    { HWDMC_HASAUTORUNINF, CT_AUTORUNINF },
    { HWDMC_HASAUDIOTRACKS, CT_CDAUDIO },
    { HWDMC_HASDVDMOVIE, CT_DVDMOVIE },
};

static const TWODWORDS blankmediamappings[] =
{
    { HWDMC_CDRECORDABLE, CT_BLANKCDR },
    { HWDMC_CDREWRITABLE, CT_BLANKCDRW },
    { HWDMC_DVDRECORDABLE, CT_BLANKDVDR },
    { HWDMC_DVDREWRITABLE, CT_BLANKDVDRW },
};

DWORD CMtPtLocal::_GetMTPTContentType()
{
    DWORD dwRet = 0;
    
    if (_CanUseVolume())
    {
        dwRet = _DoDWORDMapping(_pvol->dwMediaCap, contenttypemappings,
            ARRAYSIZE(contenttypemappings), TRUE);

        if (!(_pvol->dwMediaState & HWDMS_FORMATTED))
        {
            ASSERT(!dwRet);

            DWORD dwDriveCapabilities;
            DWORD dwMediaCapabilities;

            if (_IsCDROM())
            {
                if (SUCCEEDED(CDBurn_GetCDInfo(_pvol->pszVolumeGUID, &dwDriveCapabilities, &dwMediaCapabilities)))
                {
                    dwRet = _DoDWORDMapping(dwMediaCapabilities, blankmediamappings,
                        ARRAYSIZE(blankmediamappings), TRUE);
                }
            }
        }
        else
        {
            dwRet |= CT_UNKNOWNCONTENT;
        }
    }
    else
    {
        // If there's no _pvol, we care only about autorun.inf
        if (_IsAutorun())
        {
            dwRet = CT_AUTORUNINF;
        }

        if (_IsFormatted())
        {
            dwRet |= CT_UNKNOWNCONTENT;
        }
    }
    
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mtptlis.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "mtptl.h"

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
// Lies in Safe boot mode about floppies
BOOL CMtPtLocal::_IsStrictRemovable()
{
    BOOL fRet;

    if (_CanUseVolume())
    {
        fRet = _pvol->dwDriveType & HWDTS_REMOVABLEDISK;
    }
    else
    {
        fRet = FALSE;

        if (GetDriveType(_GetNameForFctCall()) == DRIVE_REMOVABLE)
        {
            WCHAR ch = _GetNameFirstCharUCase();

            if ((TEXT('A') != ch) && (TEXT('B') != ch))
            {
                fRet = TRUE;
            }
        }
    }

    return fRet;
}

BOOL CMtPtLocal::_IsFixedDisk()
{
    BOOL fRet;

    if (_CanUseVolume())
    {
        fRet = _pvol->dwDriveType & HWDTS_FIXEDDISK;
    }
    else
    {
        fRet = (GetDriveType(_GetNameForFctCall()) == DRIVE_FIXED);
    }

    return fRet;
}

BOOL CMtPtLocal::_IsFloppy()
{
    BOOL fRet;

    if (_CanUseVolume())
    {
        fRet = _pvol->dwDriveType & (HWDTS_FLOPPY35 | HWDTS_FLOPPY525);
    }
    else
    {
        fRet = FALSE;

        if (GetDriveType(_GetNameForFctCall()) == DRIVE_REMOVABLE)
        {
            WCHAR ch = _GetNameFirstCharUCase();

            if ((TEXT('A') == ch) || (TEXT('B') == ch))
            {
                fRet = TRUE;
            }
        }
    }

    return fRet;
}

// Lies in Safe boot mode about floppies
BOOL CMtPtLocal::_IsFloppy35()
{
    BOOL fRet;

    if (_CanUseVolume())
    {
        fRet = _pvol->dwDriveType & HWDTS_FLOPPY35;
    }
    else
    {
        fRet = FALSE;

        if (GetDriveType(_GetNameForFctCall()) == DRIVE_REMOVABLE)
        {
            WCHAR ch = _GetNameFirstCharUCase();

            if (TEXT('A') == ch)
            {
                fRet = TRUE;
            }
        }
    }

    return fRet;
}

// Lies in Safe boot mode about floppies
BOOL CMtPtLocal::_IsFloppy525()
{
    BOOL fRet;

    if (_CanUseVolume())
    {
        fRet = _pvol->dwDriveType & HWDTS_FLOPPY525;
    }
    else
    {
        fRet = FALSE;

        if (GetDriveType(_GetNameForFctCall()) == DRIVE_REMOVABLE)
        {
            WCHAR ch = _GetNameFirstCharUCase();

            if (TEXT('B') == ch)
            {
                fRet = TRUE;
            }
        }
    }

    return fRet;
}

BOOL CMtPtLocal::_IsCDROM()
{
    BOOL fRet;

    if (_CanUseVolume())
    {
        fRet = _pvol->dwDriveType & HWDTS_CDROM;
    }
    else
    {
        fRet = (GetDriveType(_GetNameForFctCall()) == DRIVE_CDROM);
    }

    return fRet;
}

BOOL CMtPtLocal::_IsAudioCD()
{
    BOOL fRet;

    if (_CanUseVolume())
    {
        fRet = _pvol->dwMediaCap & HWDMC_HASAUDIOTRACKS;
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

BOOL CMtPtLocal::_IsAudioCDNoData()
{
    return _IsAudioCD() && !(_pvol->dwMediaCap & HWDMC_HASDATATRACKS);
}

BOOL CMtPtLocal::_IsDVDRAMMedia()
{
    BOOL fRetVal = FALSE;

    if (_CanUseVolume())
    {
        fRetVal = ((HWDDC_CAPABILITY_SUPPORTDETECTION & _pvol->dwDriveCapability) &&
                   (HWDMC_WRITECAPABILITY_SUPPORTDETECTION & _pvol->dwMediaCap) &&
                   (_pvol->dwMediaCap & HWDMC_DVDRAM) && 
                   (_pvol->dwDriveCapability & HWDDC_DVDRAM));
    }

    return fRetVal;
}

BOOL CMtPtLocal::_IsFormattable()
{
    return (_IsStrictRemovable() || _IsFixedDisk() || _IsFloppy() || _IsDVDRAMMedia());
}

/*BOOL CMtPtLocal::_IsDVDMedia()
{
    BOOL fRet;

    if (_CanUseVolume())
    {
        if (HWDMC_WRITECAPABILITY_SUPPORTDETECTION & _pvol->dwMediaCap)
        {
            fRet = !!(_pvol->dwMediaCap &
                (HWDMC_DVDROM | HWDMC_DVDRECORDABLE | HWDMC_DVDRAM));
        }
        else
        {
            fRet = FALSE;
        }
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}*/

BOOL CMtPtLocal::_IsDVD()
{
    return _IsDVDDisc();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mtptr2.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "shitemid.h"
#include "ids.h"
#include "hwcmmn.h"

#include "mtptr.h"

#ifdef DEBUG
DWORD CMtPtRemote::_cMtPtRemote = 0;
DWORD CShare::_cShare = 0;
#endif

///////////////////////////////////////////////////////////////////////////////
// Public methods
///////////////////////////////////////////////////////////////////////////////
HRESULT CMtPtRemote::SetLabel(HWND hwnd, LPCTSTR pszLabel)
{
    TraceMsg(TF_MOUNTPOINT, "CMtPtRemote::SetLabel: for '%s'", _GetNameDebug());

    RSSetTextValue(NULL, TEXT("_LabelFromReg"), pszLabel,
        REG_OPTION_NON_VOLATILE);

    // we notify for only the current drive (no folder mounted drive)
    SHChangeNotify(SHCNE_RENAMEFOLDER, SHCNF_PATH, _GetName(), _GetName());

    return S_OK;
}

BOOL CMtPtRemote::IsDisconnectedNetDrive()
{
    return !_IsConnected();
}

// Expensive, do not call for nothing
BOOL CMtPtRemote::IsFormatted()
{
    return (0xFFFFFFFF != GetFileAttributes(_GetNameForFctCall()));
}

HRESULT CMtPtRemote::_GetDefaultUNCDisplayName(LPTSTR pszLabel, DWORD cchLabel)
{
    HRESULT hr = E_FAIL;
    LPTSTR pszShare, pszT;
    TCHAR szTempUNCPath[MAX_PATH];

    pszLabel[0] = TEXT('\0');

    if (!_pshare->fFake)
    {
        // Why would it not be a UNC name?
        if (PathIsUNC(_GetUNCName()))
        {
            // Now we need to handle 3 cases.
            // The normal case: \\pyrex\user
            // The Netware setting root: \\strike\sys\public\dist
            // The Netware CD?            \\stike\sys \public\dist
            StringCchCopy(szTempUNCPath, ARRAYSIZE(szTempUNCPath), _GetUNCName());
            pszT = StrChr(szTempUNCPath, TEXT(' '));
            while (pszT)
            {
                pszT++;
                if (*pszT == TEXT('\\'))
                {
                    // The netware case of \\strike\sys \public\dist
                    *--pszT = 0;
                    break;
                }
                pszT = StrChr(pszT, TEXT(' '));
            }

            pszShare = StrRChr(szTempUNCPath, NULL, TEXT('\\'));
            if (pszShare)
            {
                *pszShare++ = 0;
                PathMakePretty(pszShare);

                // pszServer should always start at char 2.
                if (szTempUNCPath[2])
                {
                    LPTSTR pszServer, pszSlash;

                    pszServer = &szTempUNCPath[2];
                    for (pszT = pszServer; pszT != NULL; pszT = pszSlash)
                    {
                        pszSlash = StrChr(pszT, TEXT('\\'));
                        if (pszSlash)
                            *pszSlash = 0;

                        PathMakePretty(pszT);
                        if (pszSlash)
                            *pszSlash++ = TEXT('\\');
                    }

                    TCHAR szDisplay[MAX_PATH];
                    hr = SHGetComputerDisplayName(pszServer, 0x0, szDisplay, ARRAYSIZE(szDisplay));
                    if (FAILED(hr))
                    {
                        *szDisplay = 0;
                    }

                    if (SUCCEEDED(hr))
                    {
                        LPTSTR pszLabel2 = ShellConstructMessageString(HINST_THISDLL,
                                MAKEINTRESOURCE(IDS_UNC_FORMAT), pszShare, szDisplay);

                        if (pszLabel2)
                        {
                            StringCchCopy(pszLabel, cchLabel, pszLabel2);
                            LocalFree(pszLabel2);
                        }
                        else
                        {
                            *pszLabel = TEXT('\0');
                        }
                    }
                }
            }
        }
    }

    return hr;
}

int CMtPtRemote::GetDriveFlags()
{
    // By default every drive type is ShellOpen, except CD-ROMs
    UINT uDriveFlags = DRIVE_SHELLOPEN;

    if (_IsAutorun())
    {
        uDriveFlags |= DRIVE_AUTORUN;

        //FEATURE should we set AUTOOPEN based on a flag in the AutoRun.inf???
        uDriveFlags |= DRIVE_AUTOOPEN;
    }

    if (_IsConnected())
    {
        if ((0 != _dwSpeed) && (_dwSpeed <= SPEED_SLOW))
        {
            uDriveFlags |= DRIVE_SLOW;
        }
    }

    return TRUE;
}

void CMtPtRemote::_CalcPathSpeed()
{
    _dwSpeed = 0;

    NETCONNECTINFOSTRUCT nci = {0};
    NETRESOURCE nr = {0};
    TCHAR szPath[3];

    nci.cbStructure = sizeof(nci);

    // we are passing in a local drive and MPR does not like us to pass a
    // local name as Z:\ but only wants Z:
    _GetNameFirstXChar(szPath, 2 + 1);
    
    nr.lpLocalName = szPath;

    // dwSpeed is returned by MultinetGetConnectionPerformance
    MultinetGetConnectionPerformance(&nr, &nci);

    _dwSpeed = nci.dwSpeed;
}

// Imported from fsnotify.c
STDAPI_(void) SHChangeNotifyRegisterAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias);
//
// If a mount point is for a remote path (UNC), it needs to respond
// to shell changes identified by both UNC and local drive path (L:\).
// This function performs this registration.
//
HRESULT CMtPtRemote::ChangeNotifyRegisterAlias(void)
{
    HRESULT hr = E_FAIL;

    // Don't wake up sleeping net connections
    if (_IsConnected() && !(_pshare->fFake))
    {
        LPITEMIDLIST pidlLocal = SHSimpleIDListFromPath(_GetName());
        if (NULL != pidlLocal)
        {
            LPITEMIDLIST pidlUNC = SHSimpleIDListFromPath(_GetUNCName());
            if (NULL != pidlUNC)
            {
                SHChangeNotifyRegisterAlias(pidlUNC, pidlLocal);
                ILFree(pidlUNC);
                hr = NOERROR;
            }
            ILFree(pidlLocal);
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  Temp  /////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void _UpdateGFAAndGVIInfoHelper(LPCWSTR pszDrive, CShare* pshare)
{
    pshare->dwGetFileAttributes = GetFileAttributes(pszDrive);

    if (-1 != pshare->dwGetFileAttributes)
    {
        pshare->fGVIRetValue = GetVolumeInformation(pszDrive,
            pshare->szLabel, ARRAYSIZE(pshare->szLabel),
            &(pshare->dwSerialNumber), &(pshare->dwMaxFileNameLen),
            &(pshare->dwFileSystemFlags), pshare->szFileSysName,
            ARRAYSIZE(pshare->szFileSysName));
    }
}

struct GFAGVICALL
{
    HANDLE hEventBegun;
    HANDLE hEventFinish;
    WCHAR szDrive[4];
    CShare* pshare;
};

void _FreeGFAGVICALL(GFAGVICALL* pgfagvicall)
{
    if (pgfagvicall->hEventBegun)
    {
        CloseHandle(pgfagvicall->hEventBegun);
    }

    if (pgfagvicall->hEventFinish)
    {
        CloseHandle(pgfagvicall->hEventFinish);
    }

    if (pgfagvicall->pshare)
    {
        pgfagvicall->pshare->Release();
    }

    if (pgfagvicall)
    {
        LocalFree(pgfagvicall);
    }
}

DWORD WINAPI _UpdateGFAAndGVIInfoCB(LPVOID pv)
{
    GFAGVICALL* pgfagvicall = (GFAGVICALL*)pv;

    SetEvent(pgfagvicall->hEventBegun);

    _UpdateGFAAndGVIInfoHelper(pgfagvicall->szDrive, pgfagvicall->pshare);

    SetEvent(pgfagvicall->hEventFinish);

    _FreeGFAGVICALL(pgfagvicall);

    return 0;
}

GFAGVICALL* CMtPtRemote::_PrepareThreadParam(HANDLE* phEventBegun,
    HANDLE* phEventFinish)
{
    BOOL fSucceeded = FALSE;
    *phEventBegun = NULL;
    *phEventFinish = NULL;

    GFAGVICALL* pgfagvicall = (GFAGVICALL*)LocalAlloc(LPTR,
        sizeof(GFAGVICALL));

    if (pgfagvicall)
    {
        pgfagvicall->hEventBegun = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (pgfagvicall->hEventBegun)
        {
            HANDLE hCurrentProcess = GetCurrentProcess();

            if (DuplicateHandle(hCurrentProcess, pgfagvicall->hEventBegun,
                hCurrentProcess, phEventBegun, 0, FALSE,
                DUPLICATE_SAME_ACCESS))
            {
                pgfagvicall->hEventFinish = CreateEvent(NULL, FALSE, FALSE, NULL);

                if (pgfagvicall->hEventFinish)
                {
                    if (DuplicateHandle(hCurrentProcess,
                        pgfagvicall->hEventFinish, hCurrentProcess,
                        phEventFinish, 0, FALSE, DUPLICATE_SAME_ACCESS))
                    {
                        _pshare->AddRef();
                        pgfagvicall->pshare = _pshare;

                        fSucceeded = SUCCEEDED(StringCchCopy(pgfagvicall->szDrive,
                            ARRAYSIZE(pgfagvicall->szDrive), _GetName()));
                    }
                }
            }
        }
    }

    if (!fSucceeded)
    {
        if (*phEventBegun)
        {
            CloseHandle(*phEventBegun);
        }

        if (pgfagvicall)
        {
            _FreeGFAGVICALL(pgfagvicall);
            pgfagvicall = NULL;
        }
    }

    return pgfagvicall;
}

// Expiration: 35 secs (what we shipped W2K with)
BOOL CMtPtRemote::_HaveGFAAndGVIExpired(DWORD dwNow)
{
    BOOL fExpired = FALSE;

    // Check also for the wrapping case first.
    if ((_pshare->dwGFAGVILastCall > dwNow) ||
        ((dwNow - _pshare->dwGFAGVILastCall) > 35 * 1000))
    {
        fExpired = TRUE;
    }
    else
    {
        fExpired = FALSE;
    }

    return fExpired;
}

// We launch a thread so that we won't be jammed on this for more than 10 sec.
// If the thread times out, we use the cache value but do not reset the cache
// values.  They're better than nothing.  We do reset the cache last tick count
// so that we do not send another thread to jam here before at least 35 sec.

// Return TRUE or FALSE to tell us if timed out or not.  For GFA and GVI
// success/failure check (-1 != dwGetFileAttributes) && (_fGVIRetValue)
BOOL CMtPtRemote::_UpdateGFAAndGVIInfo()
{
    BOOL fRet = TRUE;
    DWORD dwNow = GetTickCount();

    if (_HaveGFAAndGVIExpired(dwNow))
    {
        _pshare->dwGFAGVILastCall = dwNow;

        BOOL fGoSync = TRUE;
        HANDLE hEventBegun;
        HANDLE hEventFinish;

        GFAGVICALL* pgfagvicall = _PrepareThreadParam(&hEventBegun,
            &hEventFinish);

        if (pgfagvicall)
        {
            if (SHQueueUserWorkItem(_UpdateGFAAndGVIInfoCB, pgfagvicall,
                0, (DWORD_PTR)0, (DWORD_PTR*)NULL, NULL, 0))
            {
                DWORD dw = WaitForSingleObject(hEventFinish, 10 * 1000);

                if (WAIT_TIMEOUT == dw)
                {
                    // we timed out!
                    fRet = FALSE;

                    if (WAIT_OBJECT_0 != WaitForSingleObject(
                        hEventBegun, 0))
                    {
                        // since the thread started, we know that
                        // this call is _really_ slow!
                        fGoSync = FALSE;
                    }
                    else
                    {
                        // our work item was never queued, so we
                        // fall through to the fGoSync case below
                    }
                }
            }
            else
            {
                _FreeGFAGVICALL(pgfagvicall);
            }

            CloseHandle(hEventBegun);
            CloseHandle(hEventFinish);
        }
        
        if (fGoSync)
        {
            // we should come here if we failed to create our workitem
            // or our workitem was never queued
            _UpdateGFAAndGVIInfoHelper(_GetName(), _pshare);
            fRet = TRUE;
        }
    }

    return fRet;
}

BOOL CMtPtRemote::_GetFileAttributes(DWORD* pdwAttrib)
{
    if (_UpdateGFAAndGVIInfo())
    {
        *pdwAttrib = _pshare->dwGetFileAttributes;
    }
    else
    {
        *pdwAttrib = -1;
    }

    return (-1 != *pdwAttrib);
}

// { DRIVE_ISCOMPRESSIBLE | DRIVE_LFN | DRIVE_SECURITY }
int CMtPtRemote::_GetGVIDriveFlags()
{
    int iFlags = 0;

    if (_UpdateGFAAndGVIInfo())
    {
        if (_pshare->fGVIRetValue)
        {
            // The file attrib we received at the begginning should be
            // valid, do not touch the drive for nothing
            if (_pshare->dwFileSystemFlags & FS_FILE_COMPRESSION)
            {
                iFlags |= DRIVE_ISCOMPRESSIBLE;
            }

            // Volume supports long filename (greater than 8.3)?
            if (_pshare->dwMaxFileNameLen > 12)
            {
                iFlags |= DRIVE_LFN;
            }

            // Volume supports security?
            if (_pshare->dwFileSystemFlags & FS_PERSISTENT_ACLS)
            {
                iFlags |= DRIVE_SECURITY;
            }
        }
    }

    return iFlags;
}

BOOL CMtPtRemote::_GetSerialNumber(DWORD* pdwSerialNumber)
{
    BOOL fRet = FALSE;

    if (_UpdateGFAAndGVIInfo())
    {
        if (_pshare->fGVIRetValue)
        {
            *pdwSerialNumber = _pshare->dwSerialNumber;
            fRet = TRUE;
        }
    }

    // No reg stuff

    return fRet;
}

BOOL CMtPtRemote::_GetGVILabel(LPTSTR pszLabel, DWORD cchLabel)
{
    BOOL fRet = FALSE;

    *pszLabel = 0;

    if (_UpdateGFAAndGVIInfo())
    {
        if (_pshare->fGVIRetValue)
        {
            fRet = SUCCEEDED(StringCchCopy(pszLabel, cchLabel, _pshare->szLabel));
        }
    }

    // No reg stuff

    return fRet;
}

BOOL CMtPtRemote::_GetGVILabelOrMixedCaseFromReg(LPTSTR pszLabel, DWORD cchLabel)
{
    return _GetGVILabel(pszLabel, cchLabel);
}

BOOL CMtPtRemote::_GetFileSystemFlags(DWORD* pdwFlags)
{
    BOOL fRet = FALSE;
    
    *pdwFlags = 0;

    if (_UpdateGFAAndGVIInfo())
    {
        if (_pshare->fGVIRetValue)
        {
            *pdwFlags = _pshare->dwFileSystemFlags;
            fRet = TRUE;
        }
    }

    return fRet;
}

BOOL CMtPtRemote::_GetFileSystemName(LPTSTR pszFileSysName, DWORD cchFileSysName)
{
    BOOL fRet = FALSE;

    *pszFileSysName = 0;

    if (_UpdateGFAAndGVIInfo())
    {
        if (_pshare->fGVIRetValue)
        {
            fRet = SUCCEEDED(StringCchCopy(pszFileSysName, cchFileSysName, _pshare->szFileSysName));
        }
    }

    return fRet;
}

DWORD CMtPtRemote::GetShellDescriptionID()
{
    return SHDID_COMPUTER_NETDRIVE;
}
///////////////////////////////////////////////////////////////////////////////
//  New  //////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
UINT CMtPtRemote::_GetAutorunIcon(LPTSTR pszModule, DWORD cchModule)
{
    int iIcon = -1;

    if (RSGetTextValue(TEXT("_Autorun\\DefaultIcon"), NULL, pszModule,
        &cchModule))
    {
        iIcon = PathParseIconLocation(pszModule);
    }
    
    return iIcon;
}

UINT CMtPtRemote::GetIcon(LPTSTR pszModule, DWORD cchModule)
{
    BOOL fFoundIt = FALSE;
    UINT iIcon = II_DRIVENET;

    *pszModule = 0;

    // Autorun first
    // Fancy icon (Autoplay) second 
    // Legacy drive icons last

    if (_IsAutorun())
    {
        iIcon = _GetAutorunIcon(pszModule, cchModule);

        if (-1 != iIcon)
        {
            fFoundIt = TRUE;
        }
    }
    
    if (!fFoundIt)
    {
        if (_pszLegacyRegIcon)
        {
            if (RSGetTextValue(TEXT("DefaultIcon"), NULL, pszModule,
                &cchModule))
            {
                iIcon = PathParseIconLocation(pszModule);
            }
            else
            {
                *pszModule = 0;
            }
        }
        else
        {
            if (_IsUnavailableNetDrive())
            {
                iIcon = II_DRIVENETDISABLED;
            }
        }
    }
    
    if (*pszModule)
        TraceMsg(TF_MOUNTPOINT, "CMtPtRemote::GetIcon: for '%s', chose '%s', '%d'", _GetNameDebug(), pszModule, iIcon);
    else
        TraceMsg(TF_MOUNTPOINT, "CMtPtRemote::GetIcon: for '%s', chose '%d'", _GetNameDebug(), iIcon);

    return iIcon;
}

void CMtPtRemote::GetTypeString(LPTSTR pszType, DWORD cchType)
{
    int iID;

    *pszType = 0;

    if (_IsConnected())
    {
        iID = IDS_DRIVES_NETDRIVE;
    }
    else
    {
        iID = IDS_DRIVES_NETUNAVAIL;
    }

    LoadString(HINST_THISDLL, iID, pszType, cchType);
}

HRESULT CMtPtRemote::GetLabelNoFancy(LPTSTR pszLabel, DWORD cchLabel)
{
    HRESULT hr;

    if (_UpdateGFAAndGVIInfo())
    {
        hr = StringCchCopy(pszLabel, cchLabel, _pshare->szLabel);
    }
    else
    {
        *pszLabel = 0;
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CMtPtRemote::GetLabel(LPTSTR pszLabel, DWORD cchLabel)
{
    HRESULT hres = E_FAIL;

    ASSERT(pszLabel);

    *pszLabel = 0;
        
    // Do we already have a label from the registry for this volume?
    // (the user may have renamed this drive)

    if (!_GetLabelFromReg(pszLabel, cchLabel))
    {
        // No

        // Do we have a name from the server?
        if (!_GetLabelFromDesktopINI(pszLabel, cchLabel))
        {
            // No
            // We should build up the display name ourselves
            hres = _GetDefaultUNCDisplayName(pszLabel, cchLabel);

            if (SUCCEEDED(hres) && *pszLabel)
            {
                hres = S_OK;
            }
        }
        else
        {
            hres = S_OK;
        }
    }
    else
    {
        hres = S_OK;
    }

    if (FAILED(hres))
    {
        GetTypeString(pszLabel, cchLabel);
        hres = S_OK;
    }

    return hres;
}

HRESULT CMtPtRemote::GetRemotePath(LPWSTR pszPath, DWORD cchPath)
{
    HRESULT hr = E_FAIL;

    *pszPath = 0;
    if (!_pshare->fFake && _pshare->pszRemoteName[0])
    {
        hr = StringCchCopy(pszPath, cchPath, _pshare->pszRemoteName);
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// Connection status
///////////////////////////////////////////////////////////////////////////////
// We cannot cache the connection status.  This is already cached at the redirector level.
// When calling the WNetGetConnection fcts you get what's cache there, no check is actually
// done on the network to see if this information is accurate (OK/Disconnected/Unavailable).
// The information is updated only when the share is actually accessed (e.g: GetFileAttributes)
// 
// So we need to always do the calls (fortunately non-expensive) so that we get the most
// up to date info.  Otherwise the following was occuring: A user double click a map drive
// from the Explorer's Listview, WNetConnection gets called and we get the OK cached value 
// from the redirector.  Some other code actually try to access the share, and the redirector 
// realize that the share is not there and set its cache to Disconnected.  We are queried
// again for the state of the connection to update the icon, if we cached this info we
// return OK, if we ask for it (0.1 sec after the first call to WNetGetConnection) we get
// Disconnected. (stephstm 06/02/99)

void CMtPtRemote::_UpdateWNetGCStatus()
{
    TCHAR szRemoteName[MAX_PATH];
    DWORD cchRemoteName = ARRAYSIZE(szRemoteName);
    TCHAR szPath[3];

    // WNetConnection does not take a trailing slash
    _dwWNetGCStatus = WNetGetConnection(
        _GetNameFirstXChar(szPath, 2 + 1), szRemoteName, &cchRemoteName);
}

BOOL CMtPtRemote::IsUnavailableNetDrive()
{
    return _IsUnavailableNetDrive();
}

BOOL CMtPtRemote::_IsUnavailableNetDrive()
{
    BOOL fUnavail = TRUE;
    BOOL fPrevUnavail = _IsUnavailableNetDriveFromStateVar();

    _UpdateWNetGCStatus();

    fUnavail = (ERROR_CONNECTION_UNAVAIL == _dwWNetGCStatus);

    if (fPrevUnavail != fUnavail)
    {
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, _GetName(), NULL);
    }

    return fUnavail;
}

BOOL CMtPtRemote::_IsUnavailableNetDriveFromStateVar()
{
    return (ERROR_CONNECTION_UNAVAIL == _dwWNetGCStatus);
}

BOOL CMtPtRemote::_IsConnected()
{
    BOOL fConnected = TRUE;

    _UpdateWNetGCStatus();

    // This whole if/else statement is the same thing as
    // _IsConnectedFromStateVar() except that we will avoid calling
    // WNetGetConnection3 if possible (optimization)

    if (NO_ERROR != _dwWNetGCStatus)
    {
        fConnected = FALSE;
    }
    else
    {
        DWORD dwSize = sizeof(_wngcs);
        TCHAR szPath[3]; 

        _dwWNetGC3Status = WNetGetConnection3(
            _GetNameFirstXChar(szPath, 2 + 1), NULL,
            WNGC_INFOLEVEL_DISCONNECTED, &_wngcs, &dwSize);

        // Did we succeeded the call to WNetGetConnection 3 and it returned
        // disconnected?
        if (WN_SUCCESS == _dwWNetGC3Status)
        {
            if (WNGC_DISCONNECTED == _wngcs.dwState)
            {
                // Yes
                fConnected = FALSE;
            }
        }
        else
        {
            fConnected = FALSE;
        }
    }

    return fConnected;
}

BOOL CMtPtRemote::_IsMountedOnDriveLetter()
{
    return TRUE;
}

void CMtPtRemote::_UpdateLabelFromDesktopINI()
{
    WCHAR szLabelFromDesktopINI[MAX_MTPTCOMMENT];

    if (!GetShellClassInfo(_GetName(), TEXT("NetShareDisplayName"),
        szLabelFromDesktopINI, ARRAYSIZE(szLabelFromDesktopINI)))
    {
         szLabelFromDesktopINI[0] = 0;
    }

    RSSetTextValue(NULL, TEXT("_LabelFromDesktopINI"),
        szLabelFromDesktopINI, REG_OPTION_NON_VOLATILE);
}

void CMtPtRemote::_UpdateAutorunInfo()
{
    _pshare->fAutorun = FALSE;

    if (_IsAutoRunDrive())
    {
        if (_ProcessAutoRunFile())
        {
            _pshare->fAutorun = TRUE;
        }
    }

    if (!_pshare->fAutorun)
    {
        // Make sure to delete the shell key
        RSDeleteSubKey(TEXT("Shell"));
    }
}

CMtPtRemote::CMtPtRemote()
{
#ifdef DEBUG
    ++_cMtPtRemote;
#endif
}

CMtPtRemote::~CMtPtRemote()
{
    if (_pshare)
    {
        _pshare->Release();
    }

#ifdef DEBUG
    --_cMtPtRemote;
#endif
}

HRESULT CMtPtRemote::_InitWithoutShareName(LPCWSTR pszName)
{
    // Let's make a name
    GUID guid;
    HRESULT hr = CoCreateGuid(&guid);

    if (SUCCEEDED(hr))
    {
        WCHAR szGUID[sizeof("{00000010-0000-0010-8000-00AA006D2EA4}")];

        if (StringFromGUID2(guid, szGUID, ARRAYSIZE(szGUID)))
        {
            hr = _Init(pszName, szGUID, TRUE);

            if (SUCCEEDED(hr))
            {
                _pshare->fFake = TRUE;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

HRESULT CMtPtRemote::_Init(LPCWSTR pszName, LPCWSTR pszShareName,
    BOOL fUnavailable)
{
    HRESULT hr;

    _pshare = _GetOrCreateShareFromID(pszShareName);

    if (_pshare)
    {
        if (fUnavailable)
        {
            _dwWNetGCStatus = ERROR_CONNECTION_UNAVAIL;
        }

        hr = StringCchCopy(_szName, ARRAYSIZE(_szName), pszName);

        if (SUCCEEDED(hr))
        {
            PathAddBackslash(_szName);

            // Remote drives uses the Share key for all their stuff.  They do not have
            // anything interesting specific to the drive letter
            RSInitRoot(HKEY_CURRENT_USER, REGSTR_MTPT_ROOTKEY2, _pshare->pszKeyName,
                REG_OPTION_NON_VOLATILE);

            RSSetTextValue(NULL, TEXT("BaseClass"), TEXT("Drive"));

            // Access the drive on first connection of the share
            _InitOnlyOnceStuff();

            _InitLegacyRegIconAndLabel(FALSE, FALSE);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

LPCTSTR CMtPtRemote::_GetUNCName()
{
    return _pshare->pszRemoteName;
}

void CMtPtRemote::_InitOnlyOnceStuff()
{
    if (!RSValueExist(NULL, TEXT("_CommentFromDesktopINI")))
    {
        // Comment
        _UpdateCommentFromDesktopINI();

        // Label
        _UpdateLabelFromDesktopINI();

        // Autorun
        _UpdateAutorunInfo();
    }
}

int CMtPtRemote::_GetDriveType()
{
    return DRIVE_REMOTE;
}

HRESULT CMtPtRemote::GetAssocSystemElement(IAssociationElement **ppae)
{
    return AssocElemCreateForClass(&CLSID_AssocSystemElement, L"Drive.Network", ppae);
}

DWORD CMtPtRemote::_GetPathSpeed()
{
    if (!_dwSpeed)
    {
        _CalcPathSpeed();
    }

    return _dwSpeed;
}

// static
HRESULT CMtPtRemote::_DeleteAllMtPtsAndShares()
{
    _csDL.Enter();

    for (DWORD dw = 0; dw <26; ++dw)
    {
        CMtPtRemote* pmtptr = CMountPoint::_rgMtPtDriveLetterNet[dw];

        if (pmtptr)
        {
            pmtptr->Release();
            CMountPoint::_rgMtPtDriveLetterNet[dw] = 0;
        }
    }

    if (_hdpaShares)
    {
        DPA_Destroy(_hdpaShares);
        _hdpaShares = NULL;
    }

    _csDL.Leave();

    return S_OK;
}

// static
HRESULT CMtPtRemote::_CreateMtPtRemoteWithoutShareName(LPCWSTR pszMountPoint)
{
    HRESULT hr;
    CMtPtRemote* pmtptr = new CMtPtRemote();

    if (pmtptr)
    {
        hr = pmtptr->_InitWithoutShareName(pszMountPoint);

        if (SUCCEEDED(hr))
        {
            _csDL.Enter();

            CMountPoint::_rgMtPtDriveLetterNet[DRIVEID(pszMountPoint)] =
                pmtptr;

            _csDL.Leave();
        }
        else
        {
            delete pmtptr;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// static
HRESULT CMtPtRemote::_CreateMtPtRemote(LPCWSTR pszMountPoint,
    LPCWSTR pszShareName, BOOL fUnavailable)
{
    HRESULT hr;
    CMtPtRemote* pmtptr = new CMtPtRemote();

    if (pmtptr)
    {
        hr = pmtptr->_Init(pszMountPoint, pszShareName, fUnavailable);

        if (SUCCEEDED(hr))
        {
            _csDL.Enter();

            CMountPoint::_rgMtPtDriveLetterNet[DRIVEID(pszMountPoint)] =
                pmtptr;

            _csDL.Leave();
        }
        else
        {
            delete pmtptr;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// static
CShare* CMtPtRemote::_GetOrCreateShareFromID(LPCWSTR pszShareName)
{
    CShare* pshare = NULL;

    _csDL.Enter();

    DWORD c = DPA_GetPtrCount(_hdpaShares);

    for (DWORD dw = 0; dw < c; ++dw)
    {
        pshare = (CShare*)DPA_GetPtr(_hdpaShares, dw);

        if (pshare)
        {
            if (!lstrcmpi(pshare->pszRemoteName, pszShareName))
            {
                pshare->AddRef();
                break;
            }
            else
            {
                pshare = NULL;
            }
        }
    }    

    if (!pshare)
    {
        BOOL fSuccess = FALSE;

        pshare = new CShare();

        if (pshare)
        {
            pshare->pszRemoteName = StrDup(pszShareName);

            if (pshare->pszRemoteName)
            {
                pshare->pszKeyName = StrDup(pszShareName);

                if (pshare->pszKeyName)
                {
                    LPWSTR psz = pshare->pszKeyName;

                    while (*psz)
                    {
                        if (TEXT('\\') == *psz)
                        {
                            *psz = TEXT('#');
                        }

                        ++psz;
                    }

                    if (-1 != DPA_AppendPtr(_hdpaShares, pshare))
                    {
                        fSuccess = TRUE;
                    }
                }
            }
        }

        if (!fSuccess)
        {
            if (pshare)
            {
                if (pshare->pszKeyName)
                {
                    LocalFree(pshare->pszKeyName);
                }

                if (pshare->pszRemoteName)
                {
                    LocalFree(pshare->pszRemoteName);
                }

                delete pshare;
                pshare = NULL;
            }
        }
    }

    _csDL.Leave();

    return pshare;
}


HKEY CMtPtRemote::GetRegKey()
{
    TraceMsg(TF_MOUNTPOINT, "CMtPtRemote::GetRegKey: for '%s'", _GetNameDebug());

    return RSDuplicateRootKey();
}

// static
void CMtPtRemote::_NotifyReconnectedNetDrive(LPCWSTR pszMountPoint)
{
    _csDL.Enter();

    CMtPtRemote* pmtptr = CMountPoint::_rgMtPtDriveLetterNet[
        DRIVEID(pszMountPoint)];

    if (pmtptr)
    {
        pmtptr->_pshare->dwGFAGVILastCall = GetTickCount() - 35001;
    }

    // ChangeNotify???

    _csDL.Leave();
}

// static
HRESULT CMtPtRemote::_RemoveShareFromHDPA(CShare* pshare)
{
    _csDL.Enter();

    if (_hdpaShares)
    {
        DWORD c = DPA_GetPtrCount(_hdpaShares);

        for (DWORD dw = 0; dw < c; ++dw)
        {
            CShare* pshare2 = (CShare*)DPA_GetPtr(_hdpaShares, dw);

            if (pshare2 && (pshare2 == pshare))
            {
                DPA_DeletePtr(_hdpaShares, dw);
                break;
            }
        }
    }

    _csDL.Leave();

    return S_OK;
}

DWORD CMtPtRemote::_GetAutorunContentType()
{
    return _GetMTPTContentType();
}

DWORD CMtPtRemote::_GetMTPTDriveType()
{
    return DT_REMOTE;
}

DWORD CMtPtRemote::_GetMTPTContentType()
{
    DWORD dwRet = CT_UNKNOWNCONTENT;

    if (_IsAutorun())
    {
        dwRet |= CT_AUTORUNINF;
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mtptmgmt2.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "mtpt.h"
#include "mtptl.h"
#include "mtptr.h"
#include "hwcmmn.h"
#include "clsobj.h"

#include <cfgmgr32.h>

HDPA CMountPoint::_hdpaMountPoints = NULL;
HDPA CMountPoint::_hdpaVolumes = NULL;
HDPA CMountPoint::_hdpaShares = NULL;
CMtPtLocal* CMountPoint::_rgMtPtDriveLetterLocal[26] = {0};
CMtPtRemote* CMountPoint::_rgMtPtDriveLetterNet[26] = {0};

CCriticalSection CMountPoint::_csLocalMtPtHDPA;
CCriticalSection CMountPoint::_csDL;

BOOL CMountPoint::_fShuttingDown = FALSE;

BOOL CMountPoint::_fNetDrivesInited = FALSE;
BOOL CMountPoint::_fLocalDrivesInited = FALSE;
BOOL CMountPoint::_fNoVolLocalDrivesInited = FALSE;
DWORD CMountPoint::_dwTickCountTriedAndFailed = 0;

DWORD CMountPoint::_dwAdviseToken = -1;

BOOL CMountPoint::_fCanRegisterWithShellService = FALSE;

CRegSupport CMountPoint::_rsMtPtsLocalDL;
CRegSupport CMountPoint::_rsMtPtsLocalMOF;
CRegSupport CMountPoint::_rsMtPtsRemote;

DWORD CMountPoint::_dwRemoteDriveAutorun = 0;

static WCHAR g_szCrossProcessCacheMtPtsLocalDLKey[] = TEXT("CPC\\LocalDL");
static WCHAR g_szCrossProcessCacheMtPtsRemoteKey[] = TEXT("CPC\\Remote");
static WCHAR g_szCrossProcessCacheMtPtsLocalMOFKey[] = TEXT("CPC\\LocalMOF");

HANDLE CMountPoint::_hThreadSCN = NULL;

DWORD CMountPoint::_dwRememberedNetDrivesMask = 0;

///////////////////////////////////////////////////////////////////////////////
// Public
///////////////////////////////////////////////////////////////////////////////
//static
CMountPoint* CMountPoint::GetMountPoint(int iDrive, BOOL fCreateNew,
    BOOL fOKToHitNet)
{
    CMountPoint* pMtPt = NULL;

    if (iDrive >= 0 && iDrive < 26)
    {
        _csDL.Enter();

        if (!_fShuttingDown)
        {
            pMtPt = _GetMountPointDL(iDrive, fCreateNew);
        }

        _csDL.Leave();
    }
    else
    {
        TraceMsg(TF_MOUNTPOINT,
            "CMountPoint::GetMountPoint: Requested invalid mtpt '%d'",
            iDrive);
    }

    return pMtPt;
}

//static
CMountPoint* CMountPoint::GetMountPoint(LPCTSTR pszName, BOOL fCreateNew)
{
    CMountPoint* pMtPt = NULL;

    // Sometimes we receive an empty string (go figure)
    // Check '\' for UNC and \\?\VolumeGUID which we do not support
    // (they're not mountpoints)
    if (pszName && *pszName && (TEXT('\\') != *pszName))
    {
        if (InRange(*pszName , TEXT('a'), TEXT('z')) ||
            InRange(*pszName , TEXT('A'), TEXT('Z')))
        {
            _csDL.Enter();

            if (!_fShuttingDown)
            {
                if (!_IsDriveLetter(pszName))
                {
                    BOOL fNetDrive = _IsNetDriveLazyLoadNetDLLs(DRIVEID(pszName));

                    if (!fNetDrive)
                    {
                        TCHAR szClosestMtPt[MAX_PATH];

                        if (_StripToClosestMountPoint(pszName, szClosestMtPt,
                            ARRAYSIZE(szClosestMtPt)))
                        {
                            if (!_IsDriveLetter(szClosestMtPt))
                            {
                                pMtPt = _GetStoredMtPtMOF(szClosestMtPt);
                            }
                            else
                            {
                                pMtPt = _GetMountPointDL(DRIVEID(pszName), fCreateNew);
                            }
                        }
                    }
                    else
                    {
                        // Net drives can only be mounted on drive letter
                        pMtPt = _GetMountPointDL(DRIVEID(pszName), fCreateNew);
                    }
                }
                else
                {
                    pMtPt = _GetMountPointDL(DRIVEID(pszName), fCreateNew);
                }
            }

            _csDL.Leave();
        }
        else
        {
            TraceMsg(TF_MOUNTPOINT,
                "CMountPoint::GetMountPoint: Requested invalid mtpt '%s'",
                pszName);
        }
    }
    else
    {
        TraceMsg(TF_MOUNTPOINT, "CMountPoint::GetMountPoint: Requested invalid mtpt '%s'",
            pszName);
    }

    return pMtPt;
}

//static
CMountPoint* CMountPoint::GetSimulatedMountPointFromVolumeGuid(LPCTSTR pszVolumeGuid)
{
    CMountPoint* pMtPt = NULL;

    static const TCHAR szWackWackVolume[] = TEXT("\\\\?\\Volume");

    // Check for "\\?\Volume"
    if (pszVolumeGuid && 0 == lstrncmp( pszVolumeGuid, szWackWackVolume, ARRAYSIZE(szWackWackVolume) - sizeof("") ) )
    {
        _csDL.Enter();

        CMtPtLocal::_CreateMtPtLocalFromVolumeGuid( pszVolumeGuid, &pMtPt );
        if ( !pMtPt )
        {
            TraceMsg(TF_MOUNTPOINT, "CMountPoint::GetMountPoint: Out of memory" );
        }

        _csDL.Leave();
    }
    else
    {
        TraceMsg(TF_MOUNTPOINT, "CMountPoint::GetSimulatedMountPointFromVolumeGuid: Request is not a volume guid '%ws'",
            pszVolumeGuid);
    }

    return pMtPt;
}


// static
BOOL CMountPoint::_LocalDriveIsCoveredByNetDrive(LPCWSTR pszDriveLetter)
{
    BOOL fCovered = FALSE;

    CMountPoint* pmtpt = GetMountPoint(DRIVEID(pszDriveLetter), FALSE, FALSE);

    if (pmtpt)
    {
        if (pmtpt->_IsRemote())
        {
            fCovered = TRUE;
        }

        pmtpt->Release();
    }

    return fCovered;
}
///////////////////////////////////////////////////////////////////////////////
// Private
///////////////////////////////////////////////////////////////////////////////

// pszSource must be a path including a trailing backslash
// if returns TRUE, then pszDest contains the path to the closest MountPoint

//static
BOOL CMountPoint::_StripToClosestMountPoint(LPCTSTR pszSource, LPTSTR pszDest,
    DWORD cchDest)
{
    BOOL fFound = GetVolumePathName(pszSource, pszDest, cchDest);
    if (fFound)
    {
        PathAddBackslash(pszDest);
    }
    return fFound;
}

///////////////////////////////////////////////////////////////////////////////
// Drive letter: DL
///////////////////////////////////////////////////////////////////////////////
//static
CMountPoint* CMountPoint::_GetMountPointDL(int iDrive, BOOL fCreateNew)
{
    ASSERT(_csDL.IsInside());
    CMountPoint* pmtpt = NULL;

    // Determine if it's a net drive
    BOOL fNetDrive = _IsNetDriveLazyLoadNetDLLs(iDrive);

    if (fNetDrive)
    {
        if (!_fNetDrivesInited)
        {
            _InitNetDrives();
        }

        pmtpt = _rgMtPtDriveLetterNet[iDrive];
    }
    else
    {
        if (!_fLocalDrivesInited)
        {
            _InitLocalDrives();
        }

        pmtpt = _rgMtPtDriveLetterLocal[iDrive];

        if (!_Shell32LoadedInDesktop())
        {
            DWORD dwAllDrives = GetLogicalDrives();
            
            if (pmtpt)
            {
                // make sure it still exist
                if (!(dwAllDrives & (1 << iDrive)))
                {
                    // its' gone!
                    _rgMtPtDriveLetterLocal[iDrive]->Release();
                    _rgMtPtDriveLetterLocal[iDrive] = NULL;
                    pmtpt = NULL;
                }

                if (pmtpt && (pmtpt->_NeedToRefresh()))
                {
                    CVolume* pvol;
                    HRESULT hr;
                    WCHAR szMountPoint[4];

                    _rgMtPtDriveLetterLocal[iDrive]->Release();
                    _rgMtPtDriveLetterLocal[iDrive] = NULL;

                    PathBuildRoot(szMountPoint, iDrive);

                    pvol = CMtPtLocal::_GetVolumeByMtPt(szMountPoint);

                    if (pvol)
                    {
                        hr = CMtPtLocal::_CreateMtPtLocalWithVolume(szMountPoint,
                            pvol);

                        pvol->Release();
                    }
                    else
                    {
                        hr = CMtPtLocal::_CreateMtPtLocal(szMountPoint);
                    }

                    if (SUCCEEDED(hr))
                    {    
                        pmtpt = _rgMtPtDriveLetterLocal[iDrive];
                    }
                    else
                    {
                        pmtpt = NULL;
                    }
                }
            }
            else
            {
                // maybe it arrived after we enumerated
                if (dwAllDrives & (1 << iDrive))
                {
                    WCHAR szMtPt[4];
                    // Is it a non-net drive?
                    UINT uDriveType = GetDriveType(PathBuildRoot(szMtPt, iDrive));

                    if ((DRIVE_FIXED == uDriveType) || (DRIVE_CDROM == uDriveType) || 
                        (DRIVE_REMOVABLE == uDriveType) || (DRIVE_RAMDISK == uDriveType))
                    {
                        // indeed
                        CVolume* pvolNew;

                        HRESULT hrTmp = CMtPtLocal::_CreateVolumeFromReg(szMtPt, &pvolNew);

                        if (SUCCEEDED(hrTmp))
                        {
                            CMtPtLocal::_CreateMtPtLocalWithVolume(szMtPt, pvolNew);

                            pvolNew->Release();
                        }
                        else
                        {
                            CMtPtLocal::_CreateMtPtLocal(szMtPt);
                        }

                        pmtpt = _rgMtPtDriveLetterNet[iDrive];
                    }
                }
            }
        }
    }

    if (pmtpt)
    {
        pmtpt->AddRef();
    }

    return pmtpt;
}

///////////////////////////////////////////////////////////////////////////////
// Mounted On Folder: MOF
///////////////////////////////////////////////////////////////////////////////
//static
CMtPtLocal* CMountPoint::_GetStoredMtPtMOFFromHDPA(LPTSTR pszPathWithBackslash)
{
    CMtPtLocal* pmtptl = NULL;

    if (_hdpaMountPoints)
    {
        int n = DPA_GetPtrCount(_hdpaMountPoints);

        for (int i = 0; i < n; ++i)
        {
            pmtptl = (CMtPtLocal*)DPA_GetPtr(_hdpaMountPoints, i);

            if (pmtptl)
            {
                if (!lstrcmpi(pmtptl->_GetName(), pszPathWithBackslash))
                {
                    break;
                }
                else
                {
                    pmtptl = NULL;
                }
            }
        }
    }

    return pmtptl;
}

//static
CMtPtLocal* CMountPoint::_GetStoredMtPtMOF(LPTSTR pszPathWithBackslash)
{
    ASSERT(_csDL.IsInside());

    _csLocalMtPtHDPA.Enter();

    if (!_fLocalDrivesInited)
    {
        _InitLocalDrives();
    }

    CMtPtLocal* pmtptl = _GetStoredMtPtMOFFromHDPA(pszPathWithBackslash);

    if (!_Shell32LoadedInDesktop())
    {
        BOOL fExist = _CheckLocalMtPtsMOF(pszPathWithBackslash);

        if (pmtptl)
        {
            if (fExist)
            {
                if (pmtptl->_NeedToRefresh())
                {
                    CVolume* pvol = CMtPtLocal::_GetVolumeByMtPt(pszPathWithBackslash);

                    pmtptl = NULL;

                    if (pvol)
                    {
                        HRESULT hr = CMtPtLocal::_CreateMtPtLocalWithVolume(
                            pszPathWithBackslash, pvol);

                        if (SUCCEEDED(hr))
                        {
                            pmtptl = _GetStoredMtPtMOFFromHDPA(pszPathWithBackslash);
                        }

                        pvol->Release();
                    }
                    else
                    {
                        // if we can't get a volume, we don't care about drive mounted on folder
                    }
                }
            }
            else
            {
                // its' gone!
                _RemoveLocalMountPoint(pszPathWithBackslash);
                pmtptl = NULL;
            }
        }
        else
        {
            // maybe it arrived after we enumerated
            if (fExist)
            {
                CVolume* pvolNew;

                HRESULT hrTmp = CMtPtLocal::_CreateVolumeFromReg(pszPathWithBackslash,
                    &pvolNew);

                if (SUCCEEDED(hrTmp))
                {
                    hrTmp = CMtPtLocal::_CreateMtPtLocalWithVolume(pszPathWithBackslash, pvolNew);

                    if (SUCCEEDED(hrTmp))
                    {
                        pmtptl = _GetStoredMtPtMOFFromHDPA(pszPathWithBackslash);
                    }

                    pvolNew->Release();
                }
                else
                {
                    // if we can't get a volume, we don't care about drive mounted on folder
                }
            }
        }
    }

    if (pmtptl)
    {
        pmtptl->AddRef();
    }

    _csLocalMtPtHDPA.Leave();

    return pmtptl;
}

//static
BOOL CMountPoint::_StoreMtPtMOF(CMtPtLocal* pmtptl)
{
    HRESULT hr;

    _csLocalMtPtHDPA.Enter();

    if (!_hdpaMountPoints && !_fShuttingDown)
    {
        _hdpaMountPoints = DPA_Create(2);
    }

    if (_hdpaMountPoints)
    {
        if (-1 == DPA_AppendPtr(_hdpaMountPoints, pmtptl))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    _csLocalMtPtHDPA.Leave();

    return hr;
}

//static
BOOL CMountPoint::_IsDriveLetter(LPCTSTR pszName)
{
    // Is this a drive mounted on a drive letter only (e.g. 'a:' or 'a:\')?
    return (!pszName[2] || !pszName[3]);
}

///////////////////////////////////////////////////////////////////////////////
// 
///////////////////////////////////////////////////////////////////////////////

//static
HRESULT CMountPoint::_InitNetDrivesHelper(DWORD dwScope)
{
    HRESULT hr = S_FALSE;
    HANDLE hEnum;
    DWORD dwErr = WNetOpenEnum(dwScope, RESOURCETYPE_DISK, 0, NULL, &hEnum);

    if (WN_SUCCESS == dwErr)
    {
        DWORD cbBuf = 4096 * 4; // Recommended size from docs
        PBYTE pbBuf = (PBYTE)LocalAlloc(LPTR, cbBuf);

        if (pbBuf)
        {
            // return as many entries as possible
            DWORD dwEntries = (DWORD)-1;

            dwErr = WNetEnumResource(hEnum, &dwEntries, pbBuf, &cbBuf);

            if (dwErr == ERROR_MORE_DATA)
            {
                if (pbBuf)
                {
                    LocalFree(pbBuf);
                }

                // cbBuf contains required size
                pbBuf = (PBYTE)LocalAlloc(LPTR, cbBuf);
                if (pbBuf)
                {
                    dwErr = WNetEnumResource(hEnum, &dwEntries, pbBuf, &cbBuf);
                }
                else
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                }
            }

            if (dwErr == WN_SUCCESS)
            {
                UINT i;
                NETRESOURCE* pnr = (NETRESOURCE*)pbBuf;
    
                for (i = 0; SUCCEEDED(hr) && (i < dwEntries); ++i)
                {
                    // Is it mapped or just net used
                    if (pnr->lpLocalName)
                    {
                        // Remembered drives and connected drives list overlaps
                        if (!_rgMtPtDriveLetterNet[DRIVEID(pnr->lpLocalName)])
                        {
                            hr = CMtPtRemote::_CreateMtPtRemote(pnr->lpLocalName,
                                                                pnr->lpRemoteName,
                                                                (dwScope == RESOURCE_CONNECTED));

                            if (RESOURCE_REMEMBERED == dwScope)
                            {
                                _dwRememberedNetDrivesMask |= (1 << DRIVEID(pnr->lpLocalName));
                            }
                        }
                    }

                    pnr++;
                }
            }
    
            if (pbBuf)
            {
                LocalFree(pbBuf);
            }
        }

        WNetCloseEnum(hEnum);
    }

    return hr;
}

//static
HRESULT CMountPoint::_ReInitNetDrives()
{
    ASSERT(_csDL.IsInside());

    CMtPtRemote::_DeleteAllMtPtsAndShares();

    _fNetDrivesInited = FALSE;

    CMountPoint::_InitNetDrives();

    return S_OK;
}

//static
HRESULT CMountPoint::_InitNetDrives()
{
    ASSERT(_csDL.IsInside());
    HRESULT hr;

    if (!_fNetDrivesInited)
    {
        if (!_fShuttingDown)
        {
            if (!_hdpaShares)
            {
                _hdpaShares = DPA_Create(3);
            }
        }

        if (_hdpaShares)
        {
            hr = _InitNetDrivesHelper(RESOURCE_CONNECTED);

            if (SUCCEEDED(hr))
            {
                hr = _InitNetDrivesHelper(RESOURCE_REMEMBERED);
            }

            if (SUCCEEDED(hr))
            {
                DWORD dwLogicalDrives = GetLogicalDrives();

                for (DWORD dw = 0; dw < 26; ++dw)
                {
                    if (dwLogicalDrives & (1 << dw))
                    {
                        if (!(_rgMtPtDriveLetterNet[dw]))
                        {
                            WCHAR szDrive[4];

                            PathBuildRoot(szDrive, dw);

                            if (DRIVE_REMOTE == GetDriveType(szDrive))
                            {
                                // This must be a weird System mapped drive
                                // which is not enumerated by the per-user
                                // WNetEnumResource...
                                hr = CMtPtRemote::_CreateMtPtRemoteWithoutShareName(szDrive);
                            }
                        }
                    }
                }

                _fNetDrivesInited = TRUE;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    if (_Shell32LoadedInDesktop())
    {
        DWORD dwRemoteDrives = 0;

        for (DWORD dw = 0; dw < 26; ++dw)
        {
            if (_rgMtPtDriveLetterNet[dw])
            {
                dwRemoteDrives |= (1 << dw);
            }
        }
    }

    return hr;
}

inline void _CoTaskMemFree(void* pv)
{
    if (pv)
    {
        CoTaskMemFree(pv);
    }
}

const GUID guidVolumeClass =
    {0x53f5630d, 0xb6bf, 0x11d0,
    {0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b}};

//static
HRESULT CMountPoint::_EnumVolumes(IHardwareDevices* pihwdevs)
{
    ASSERT(_csDL.IsInside());
    HRESULT hr;

    if (_Shell32LoadedInDesktop())
    {
        // Synchro
        IHardwareDevicesVolumesEnum* penum;

        hr = pihwdevs->EnumVolumes(HWDEV_GETCUSTOMPROPERTIES, &penum);

        ASSERTMSG(NULL != _hdpaVolumes, "_hdpaVolumes should not be NULL at this point, some code found its way here without calling InitLocalDrives");

        if (SUCCEEDED(hr))
        {
            do
            {
                VOLUMEINFO volinfo;

                hr = penum->Next(&volinfo);

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    CVolume* pvolNew;

                    if (SUCCEEDED(CMtPtLocal::_CreateVolume(&volinfo, &pvolNew)))
                    {
                        CMtPtLocal::_UpdateVolumeRegInfo(&volinfo);

                        pvolNew->Release();
                    }

                    CoTaskMemFree(volinfo.pszDeviceIDVolume);
                    CoTaskMemFree(volinfo.pszVolumeGUID);
                    CoTaskMemFree(volinfo.pszLabel);
                    CoTaskMemFree(volinfo.pszFileSystem);
                    CoTaskMemFree(volinfo.pszAutorunIconLocation);
                    CoTaskMemFree(volinfo.pszAutorunLabel);
                    CoTaskMemFree(volinfo.pszIconLocationFromService);
                    CoTaskMemFree(volinfo.pszNoMediaIconLocationFromService);
                    CoTaskMemFree(volinfo.pszLabelFromService);
                }
            }
            while (SUCCEEDED(hr) && (S_FALSE != hr));

            penum->Release();
        }
    }
    else
    {
        ULONG ulSize;
        ULONG ulFlags = CM_GET_DEVICE_INTERFACE_LIST_PRESENT;

        CONFIGRET cr = CM_Get_Device_Interface_List_Size_Ex(&ulSize,
            (GUID*)&guidVolumeClass, NULL, ulFlags, NULL);

        if ((CR_SUCCESS == cr) && (ulSize > 1))
        {
            LPWSTR pszVolumes = (LPWSTR)LocalAlloc(LPTR, ulSize * sizeof(WCHAR));

            if (pszVolumes)
            {
                cr = CM_Get_Device_Interface_List_Ex((GUID*)&guidVolumeClass,
                    NULL, pszVolumes, ulSize, ulFlags, NULL);

                if (CR_SUCCESS == cr)
                {
                    for (LPWSTR psz = pszVolumes; *psz; psz += lstrlen(psz) + 1)
                    {
                        CVolume* pvolNew;

                        HRESULT hrTmp = CMtPtLocal::_CreateVolumeFromReg(psz,
                            &pvolNew);

                        if (SUCCEEDED(hrTmp))
                        {
                            pvolNew->Release();
                        }
                    }

                    hr = S_OK;
                }
                else
                {
                    hr = S_FALSE;
                }

                LocalFree(pszVolumes);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

//static
HRESULT CMountPoint::_EnumMountPoints(IHardwareDevices* pihwdevs)
{
    ASSERT(_csDL.IsInside());
    HRESULT hr;

    if (_Shell32LoadedInDesktop())
    {
        IHardwareDevicesMountPointsEnum* penum;

        hr = pihwdevs->EnumMountPoints(&penum);

        if (SUCCEEDED(hr))
        {
            LPWSTR pszMountPoint;
            LPWSTR pszDeviceIDVolume;

            while (SUCCEEDED(hr = penum->Next(&pszMountPoint, &pszDeviceIDVolume)) &&
                   (S_FALSE != hr))
            {
                CVolume* pvol = CMtPtLocal::_GetVolumeByID(pszDeviceIDVolume);

                if (pvol)
                {
                    CMtPtLocal::_CreateMtPtLocalWithVolume(pszMountPoint, pvol);

                    pvol->Release();
                }

                if (!_IsDriveLetter(pszMountPoint))
                {
                    _rsMtPtsLocalMOF.RSSetTextValue(NULL, pszMountPoint, TEXT(""));
                }

                CoTaskMemFree(pszMountPoint);
                CoTaskMemFree(pszDeviceIDVolume);
            }

            penum->Release();
        }
    }
    else
    {
        hr = S_OK;

        if (_hdpaVolumes)
        {
            DWORD c = DPA_GetPtrCount(_hdpaVolumes);

            for (int i = c - 1; i >= 0; --i)
            {
                CVolume* pvol = (CVolume*)DPA_GetPtr(_hdpaVolumes, i);

                if (pvol)
                {
                    DWORD cch;

                    if (GetVolumePathNamesForVolumeName(pvol->pszVolumeGUID,
                        NULL, 0, &cch))
                    {
                        // no mountpoint, we're done                        
                    }
                    else
                    {
                        // Expected, even wanted...
                        if (ERROR_MORE_DATA == GetLastError())
                        {
                            LPWSTR pszMtPts = (LPWSTR)LocalAlloc(LPTR,
                                cch * sizeof(WCHAR));

                            if (pszMtPts)
                            {
                                if (GetVolumePathNamesForVolumeName(
                                    pvol->pszVolumeGUID, pszMtPts, cch, &cch))
                                {
                                    for (LPWSTR psz = pszMtPts; *psz;
                                        psz += lstrlen(psz) + 1)
                                    {
                                        CMtPtLocal::_CreateMtPtLocalWithVolume(
                                            psz, pvol);
                                    }
                                }

                                LocalFree(pszMtPts);
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        else
                        {
                            hr = S_FALSE; 
                        }
                    }
                }
            }
        }
    }

    // We don't care about the prev hr.  I'll clean this up when moving the
    // volume information from the Shell Service.  (stephstm, 2001/03/13)

    DWORD dwLogicalDrives = GetLogicalDrives();
    DWORD dwLocalDrives = 0;

    for (DWORD dw = 0; dw < 26; ++dw)
    {
        if (dwLogicalDrives & (1 << dw))
        {
            if (_rgMtPtDriveLetterLocal[dw])
            {
                dwLocalDrives |= (1 << dw);
            }
            else
            {
                WCHAR szDrive[4];

                PathBuildRoot(szDrive, dw);

                if (DRIVE_REMOTE != GetDriveType(szDrive))
                {
                    // This is a "subst" drive or something like this.
                    // It only appears in the per-user drive map, not the
                    // per-machine.  Let's create a mountpoint for it.
                    CMtPtLocal::_CreateMtPtLocal(szDrive);

                    dwLocalDrives |= (1 << dw);
                }
            }
        }
    }

    return hr;
}

//static
HRESULT CMountPoint::_DeleteVolumeInfo()
{
    ASSERT(_csDL.IsInside());

    if (_hdpaVolumes)
    {
        DWORD c = DPA_GetPtrCount(_hdpaVolumes);

        for (int i = c - 1; i >= 0; --i)
        {
            CVolume* pvol = (CVolume*)DPA_GetPtr(_hdpaVolumes, i);

            if (pvol)
            {
                pvol->Release();
            }

            DPA_DeletePtr(_hdpaVolumes, i);
        }

        DPA_Destroy(_hdpaVolumes);
        _hdpaVolumes = NULL;
    }

    return S_OK;
}

//static
HRESULT CMountPoint::_DeleteLocalMtPts()
{
    ASSERT(_csDL.IsInside());
    for (DWORD dw = 0; dw < 26; ++dw)
    {
        CMtPtLocal* pmtptl = (CMtPtLocal*)_rgMtPtDriveLetterLocal[dw];

        if (pmtptl)
        {
            pmtptl->Release();

            _rgMtPtDriveLetterLocal[dw] = 0;
        }
    }

    _csLocalMtPtHDPA.Enter();

    if (_hdpaMountPoints)
    {
        int n = DPA_GetPtrCount(_hdpaMountPoints);

        for (int i = n - 1; i >= 0; --i)
        {
            CMtPtLocal* pmtptl = (CMtPtLocal*)DPA_GetPtr(_hdpaMountPoints, i);

            if (pmtptl)
            {
                pmtptl->Release();

                DPA_DeletePtr(_hdpaMountPoints, i);
            }
        }

        DPA_Destroy(_hdpaMountPoints);
    }

    _csLocalMtPtHDPA.Leave();

    return S_OK;
}

// static
HRESULT CMountPoint::_GetMountPointsForVolume(LPCWSTR pszDeviceIDVolume,
    HDPA hdpaMtPts)
{
    ASSERT(!_csDL.IsInside());

    _csDL.Enter();

    for (DWORD dw = 0; dw < 26; ++dw)
    {
        CMtPtLocal* pmtptl = (CMtPtLocal*)_rgMtPtDriveLetterLocal[dw];

        if (pmtptl && pmtptl->_pvol)
        {
            if (!lstrcmpi(pmtptl->_pvol->pszDeviceIDVolume, pszDeviceIDVolume))
            {
                LPCWSTR pszMtPt = StrDup(pmtptl->_szName);

                if (pszMtPt)
                {
                    if (-1 == DPA_AppendPtr(hdpaMtPts, (void*)pszMtPt))
                    {
                        LocalFree((HLOCAL)pszMtPt);
                    }
                }

                // Volumes can be mounted on only one drive letter
                break;
            }
        }
    }

    _csDL.Leave();

    _csLocalMtPtHDPA.Enter();

    if (_hdpaMountPoints)
    {
        int n = DPA_GetPtrCount(_hdpaMountPoints);

        for (int i = n - 1; i >= 0; --i)
        {
            CMtPtLocal* pmtptl = (CMtPtLocal*)DPA_GetPtr(_hdpaMountPoints, i);

            if (pmtptl && pmtptl->_pvol)
            {
                if (!lstrcmpi(pmtptl->_pvol->pszDeviceIDVolume, pszDeviceIDVolume))
                {
                    LPCWSTR pszMtPt = StrDup(pmtptl->_szName);

                    if (pszMtPt)
                    {
                        if (-1 == DPA_AppendPtr(hdpaMtPts, (void*)pszMtPt))
                        {
                            LocalFree((HLOCAL)pszMtPt);
                        }
                    }
                }
            }
        }
    }

    _csLocalMtPtHDPA.Leave();

    return S_OK;
}

// static
HRESULT CMountPoint::_InitLocalDriveHelper()
{
#ifdef DEBUG
    // We should not try to enter the Drive Letter critical section on this thread.
    // We've already entered it on the thread that launched us, and
    // we should still be in there.  The thread that launched us is waiting for
    // this thread to finish before going on.  Trying to re-enter this critical
    // section from this thread will deadlock.
    DWORD dwThreadID = GetCurrentThreadId();
    _csDL.SetThreadIDToCheckForEntrance(dwThreadID);

    _csDL.FakeEnter();
#endif

    IHardwareDevices* pihwdevs;

    HRESULT hr;
    BOOL fLoadedInDesktop = _Shell32LoadedInDesktop();
    
    if (fLoadedInDesktop)
    {
        hr = _GetHardwareDevices(&pihwdevs);
    }
    else
    {
        hr = S_FALSE;
    }

    if (SUCCEEDED(hr))
    {
        if (!_hdpaVolumes && !_fShuttingDown)
        {
            _hdpaVolumes = DPA_Create(3);
        }

        if (_hdpaVolumes)
        {
            if (SUCCEEDED(hr))
            {
                hr = _EnumVolumes(pihwdevs);

                if (SUCCEEDED(hr))
                {
                    hr = _EnumMountPoints(pihwdevs);

                    if (SUCCEEDED(hr))
                    {
                        _fLocalDrivesInited = TRUE;
                    }
                    else
                    {
                        _DeleteVolumeInfo();
                    }
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (fLoadedInDesktop)
        {
            pihwdevs->Release();
        }
    }

#ifdef DEBUG
    _csDL.FakeLeave();

    _csDL.SetThreadIDToCheckForEntrance(0);
#endif

    return hr;
}

DWORD WINAPI _FirstHardwareEnumThreadProc(void* pv)
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);

    if (SUCCEEDED(hr))
    {
        hr = CMountPoint::_InitLocalDriveHelper();

        CoUninitialize();
    }

    return (DWORD)hr;
}

//static
BOOL CMountPoint::_CanRegister()
{
    if (!CMountPoint::_fCanRegisterWithShellService)
    {
        HANDLE hCanRegister = OpenEvent(SYNCHRONIZE, FALSE, TEXT("_fCanRegisterWithShellService"));

        if (hCanRegister)
        {
            CloseHandle(hCanRegister);
        }
        else
        {
            CMountPoint::_fCanRegisterWithShellService = TRUE;
        }
    }

    return CMountPoint::_fCanRegisterWithShellService;
}

//static
HRESULT CMountPoint::_InitLocalDrives()
{
    ASSERT(_csDL.IsInside());

    HRESULT hr = E_FAIL;
    BOOL fTryFullInit = FALSE;

    if (CMountPoint::_CanRegister())
    {
        if (!_dwTickCountTriedAndFailed)
        {
            // We didn't try full init yet
            fTryFullInit = TRUE;
        }
        else
        {
            // We already tried and failed doing a full init.  Try again only if
            // it's been more than 5 seconds.
            if ((GetTickCount() - _dwTickCountTriedAndFailed) >
                (5 * 1000))
            {
                fTryFullInit = TRUE;
            }
        }

        if (fTryFullInit)
        {
            if (_Shell32LoadedInDesktop())
            {
                HANDLE hThread = CreateThread(NULL, 0, _FirstHardwareEnumThreadProc, NULL, 0, NULL);

                if (hThread)
                {
                    DWORD dwWait = WaitForSingleObject(hThread, INFINITE);

                    if (WAIT_FAILED != dwWait)
                    {
                        DWORD dwExitCode;

                        if (GetExitCodeThread(hThread, &dwExitCode))
                        {
                            hr = (HRESULT)dwExitCode;
                        }
                    }

                    CloseHandle(hThread);
                }

                if (SUCCEEDED(hr))
                {
                    _dwTickCountTriedAndFailed = 0;
                }
                else
                {
                    _dwTickCountTriedAndFailed = GetTickCount();
                }
            }
            else
            {
                hr = _InitLocalDriveHelper();

                _dwTickCountTriedAndFailed = 0;
            }
        }
    }
   
    if (FAILED(hr))
    {
        if (!_fNoVolLocalDrivesInited)
        {
            DWORD dwLogicalDrives = GetLogicalDrives();

            for (DWORD dw = 0; dw < 26; ++dw)
            {
                if (dwLogicalDrives & (1 << dw))
                {
                    WCHAR szDrive[4];
                    int iDriveType = GetDriveType(PathBuildRoot(szDrive, dw));

                    if ((DRIVE_REMOTE != iDriveType) && (DRIVE_UNKNOWN != iDriveType) &&
                        (DRIVE_NO_ROOT_DIR != iDriveType))
                    {
                        hr = CMtPtLocal::_CreateMtPtLocal(szDrive);
                    }
                }
            }

            _fNoVolLocalDrivesInited = TRUE;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

//static
DWORD CMountPoint::GetDrivesMask()
{
    HRESULT hr = S_FALSE;
    DWORD dwMask = 0;

    _csDL.Enter();

    if (!_fNetDrivesInited)
    {
        hr = _InitNetDrives();
    }

    if (!_fLocalDrivesInited)
    {
        hr = _InitLocalDrives();
    }

    if (SUCCEEDED(hr))
    {
        if (_Shell32LoadedInDesktop())
        {
            for (DWORD dw = 0; dw < 26; ++dw)
            {
                if (_rgMtPtDriveLetterLocal[dw] || _rgMtPtDriveLetterNet[dw])
                {
                    dwMask |= (1 << dw);
                }
            }
        }
        else
        {
            dwMask = GetLogicalDrives() | _dwRememberedNetDrivesMask;
        }
    }

    _csDL.Leave();

    return dwMask;
}

//static
BOOL CMountPoint::Initialize()
{
    BOOL bRet = TRUE;

    if (!_csLocalMtPtHDPA.Init() ||
        !_csDL.Init())
    {
        bRet = FALSE;
    }

    _rsMtPtsLocalDL.RSInitRoot(HKEY_CURRENT_USER, REGSTR_MTPT_ROOTKEY2,
        g_szCrossProcessCacheMtPtsLocalDLKey, REG_OPTION_VOLATILE);

    _rsMtPtsRemote.RSInitRoot(HKEY_CURRENT_USER, REGSTR_MTPT_ROOTKEY2,
        g_szCrossProcessCacheMtPtsRemoteKey, REG_OPTION_VOLATILE);

    _rsMtPtsLocalMOF.RSInitRoot(HKEY_CURRENT_USER, REGSTR_MTPT_ROOTKEY2,
        g_szCrossProcessCacheMtPtsLocalMOFKey, REG_OPTION_VOLATILE);

    return bRet;
}
///////////////////////////////////////////////////////////////////////////////
// For C caller
///////////////////////////////////////////////////////////////////////////////
STDAPI_(void) CMtPt_FinalCleanUp()
{
    CMountPoint::FinalCleanUp();
    CMtPtLocal::FinalCleanUp();
}

STDAPI_(BOOL) CMtPt_Initialize()
{
    BOOL bRet = TRUE;

    if (!CMountPoint::Initialize()  ||
        !CMtPtLocal::Initialize())
    {
        bRet = FALSE;
    }

    return bRet;
}

//static
void CMountPoint::FinalCleanUp()
{
    if (_csDL.IsInitialized() && _csLocalMtPtHDPA.IsInitialized())
    {
        _csDL.Enter();

        _fShuttingDown = TRUE;

        _csLocalMtPtHDPA.Enter();

        _DeleteLocalMtPts();
        _DeleteVolumeInfo();
        CMtPtRemote::_DeleteAllMtPtsAndShares();
        _fNetDrivesInited = FALSE;

        _csLocalMtPtHDPA._fShuttingDown = TRUE;
        _csDL._fShuttingDown = TRUE;

        _csLocalMtPtHDPA.Leave();
        _csDL.Leave();

        _csLocalMtPtHDPA.Delete();
        _csDL.Delete();

        CSniffDrive::CleanUp();

        if (_hThreadSCN)
        {
            CloseHandle(_hThreadSCN);
            _hThreadSCN = NULL;
        }
    }

    if (_Shell32LoadedInDesktop())
    {
        _rsMtPtsLocalDL.RSDeleteKey();
        _rsMtPtsLocalMOF.RSDeleteKey();
        _rsMtPtsRemote.RSDeleteKey();
    }
}

//static
BOOL CMountPoint::_IsNetDriveLazyLoadNetDLLs(int iDrive)
{
    ASSERT(_csDL.IsInside());
    BOOL fNetDrive = FALSE;

    if (!_fNetDrivesInited)
    {
        HRESULT hr = S_FALSE;
        WCHAR szPath[4];

        // Try to avoid loading the net dlls
        UINT uDriveType = GetDriveType(PathBuildRoot(szPath, iDrive));

        if (DRIVE_NO_ROOT_DIR == uDriveType)
        {
            // This happens for Remembered drives
            hr = _InitNetDrives();

            if (SUCCEEDED(hr))
            {
                fNetDrive = BOOLFROMPTR(_rgMtPtDriveLetterNet[iDrive]);
            }
        }
        else
        {
            if (DRIVE_REMOTE == uDriveType)
            {
                fNetDrive = TRUE;
            }
        }
    }
    else
    {
        fNetDrive = BOOLFROMPTR(_rgMtPtDriveLetterNet[iDrive]);

        if (!_Shell32LoadedInDesktop())
        {
            DWORD dwAllDrives = GetLogicalDrives() | _dwRememberedNetDrivesMask;

            if (fNetDrive)
            {
                // make sure it still exist
                if (!(dwAllDrives & (1 << iDrive)))
                {
                    // its' gone!
                    fNetDrive = FALSE;
                }
                else
                {
                    WCHAR szPath[4];

                    // There's still a drive there, make sure it's not a local one
                    if (!(_dwRememberedNetDrivesMask & (1 << iDrive)) &&
                        !(GetDriveType(PathBuildRoot(szPath, iDrive)) == DRIVE_REMOTE))
                    {
                        fNetDrive = FALSE;
                    }
                }

                if (!fNetDrive && (_rgMtPtDriveLetterNet[iDrive]))
                {
                    _rgMtPtDriveLetterNet[iDrive]->Release();
                    _rgMtPtDriveLetterNet[iDrive] = NULL;
                }
            }
            else
            {
                // maybe it arrived after we enumerated
                if (dwAllDrives & (1 << iDrive))
                {
                    WCHAR szPath[4];

                    // Is it a remote drive?
                    if ((_dwRememberedNetDrivesMask & (1 << iDrive)) ||
                        (GetDriveType(PathBuildRoot(szPath, iDrive)) == DRIVE_REMOTE))
                    {
                        // indeed
                        _ReInitNetDrives();

                        fNetDrive = TRUE;
                    }
                }
            }
        }
    }

    return fNetDrive;
}

// static
HRESULT CMountPoint::_RemoveLocalMountPoint(LPCWSTR pszMountPoint)
{
    if (_IsDriveLetter(pszMountPoint))
    {
        _csDL.Enter();
        int iDrive = DRIVEID(pszMountPoint);

        CMtPtLocal* pmtptl = (CMtPtLocal*)_rgMtPtDriveLetterLocal[iDrive];

        if (pmtptl)
        {
            _rgMtPtDriveLetterLocal[iDrive] = 0;

            pmtptl->Release();
        }

        _csDL.Leave();
    }
    else
    {
        _csLocalMtPtHDPA.Enter();

        if (_hdpaMountPoints)
        {
            DWORD c = DPA_GetPtrCount(_hdpaMountPoints);

            for (int i = c - 1; i >= 0; --i)
            {
                CMtPtLocal* pmtptl = (CMtPtLocal*)DPA_GetPtr(_hdpaMountPoints, i);

                if (pmtptl)
                {
                    if (!lstrcmpi(pmtptl->_szName, pszMountPoint))
                    {
                        DPA_DeletePtr(_hdpaMountPoints, i);

                        pmtptl->Release();

                        break;
                    }
                }
            }
        }

        if (_Shell32LoadedInDesktop())
        {
            _rsMtPtsLocalMOF.RSDeleteValue(NULL, pszMountPoint);
        }

        _csLocalMtPtHDPA.Leave();
    }

    return S_OK;
}

// static
HRESULT CMountPoint::_RemoveNetMountPoint(LPCWSTR pszMountPoint)
{
    _csDL.Enter();

    int iDrive = DRIVEID(pszMountPoint);

    if (_rgMtPtDriveLetterNet[iDrive])
    {
        _rgMtPtDriveLetterNet[iDrive]->Release();
        _rgMtPtDriveLetterNet[iDrive] = 0;
    }

    _csDL.Leave();

    return S_OK;
}

// static
BOOL CMountPoint::_CheckLocalMtPtsMOF(LPCWSTR pszMountPoint)
{
    ASSERT(!_Shell32LoadedInDesktop());

    return _rsMtPtsLocalMOF.RSValueExist(NULL, pszMountPoint);
}

//
// This needs to be called from the thread that will be used for APCs callbacks
// (stephstm: 2001/03/31)

// static
DWORD WINAPI CMountPoint::_RegisterThreadProc(void* pv)
{
    ASSERT(_Shell32LoadedInDesktop());
    HANDLE hThread = (HANDLE)pv;
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);

    if (SUCCEEDED(hr))
    {
        IHardwareDevices* pihwdevs;

        hr = _GetHardwareDevices(&pihwdevs);

        if (SUCCEEDED(hr))
        {
            hr = pihwdevs->Advise(GetCurrentProcessId(), (ULONG_PTR)hThread,
                (ULONG_PTR)CMountPoint::_EventAPCProc, &_dwAdviseToken);

            pihwdevs->Release();
        }

        CoUninitialize();
    }

    return (DWORD)hr;
}

// static
HRESULT CMountPoint::RegisterForHardwareNotifications()
{
    HRESULT hr;

    if (_Shell32LoadedInDesktop() && (-1 == _dwAdviseToken))
    {
        HANDLE hPseudoProcess = GetCurrentProcess();
        // See comment above!
        HANDLE hPseudoThread = GetCurrentThread();

        hr = E_FAIL;

        if (DuplicateHandle(hPseudoProcess, hPseudoThread, hPseudoProcess,
            &_hThreadSCN, DUPLICATE_SAME_ACCESS, FALSE, 0))
        {
            HANDLE hThread = CreateThread(NULL, 0, _RegisterThreadProc, (void*)_hThreadSCN, 0, NULL);

            CSniffDrive::Init(_hThreadSCN);

            if (hThread)
            {
                DWORD dwWait = WaitForSingleObject(hThread, INFINITE);

                if (WAIT_FAILED != dwWait)
                {
                    DWORD dwExitCode;

                    if (GetExitCodeThread(hThread, &dwExitCode))
                    {
                        hr = (HRESULT)dwExitCode;
                    }
                }

                CloseHandle(hThread);
            }
            else
            {
                // We want to keep the handle around we'll uise it for something else.
            }
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mtptr.h ===
#include "mtpt.h"

class CShare;

class CMtPtRemote : public CMountPoint
{
///////////////////////////////////////////////////////////////////////////////
// Public methods
///////////////////////////////////////////////////////////////////////////////
public:
    CMtPtRemote();
    ~CMtPtRemote();

    // virtual override
    BOOL IsUnavailableNetDrive();
    BOOL IsDisconnectedNetDrive();

    BOOL IsFormatted();

    HRESULT GetLabel(LPTSTR pszLabel, DWORD cchLabel);
    HRESULT GetLabelNoFancy(LPTSTR pszLabel, DWORD cchLabel);
    HRESULT SetLabel(HWND hwnd, LPCTSTR pszLabel);
    HRESULT ChangeNotifyRegisterAlias(void);

    HRESULT GetRemotePath(LPWSTR pszPath, DWORD cchPath);

    UINT GetIcon(LPTSTR pszModule, DWORD cchModule);
    HRESULT GetAssocSystemElement(IAssociationElement **ppae);
    DWORD GetShellDescriptionID();

    int GetDriveFlags();
    void GetTypeString(LPTSTR pszType, DWORD cchType);

    HKEY GetRegKey();

    static void _NotifyReconnectedNetDrive(LPCWSTR pszMountPoint);

///////////////////////////////////////////////////////////////////////////////
// Miscellaneous helpers
///////////////////////////////////////////////////////////////////////////////
private:
    HRESULT _Init(LPCWSTR pszName, LPCWSTR pszShareName, BOOL fUnavailable);
    HRESULT _InitWithoutShareName(LPCWSTR pszName);

    HRESULT _GetDefaultUNCDisplayName(LPTSTR pszLabel, DWORD cchLabel);

    LPCTSTR _GetUNCName();
    BOOL _IsConnected();
    BOOL _IsUnavailableNetDrive();
    BOOL _IsUnavailableNetDriveFromStateVar();

    BOOL _IsRemote();

    BOOL _IsSlow();
    BOOL _IsAutorun();

    // returns DT_* defined above
    DWORD _GetMTPTDriveType();
    // returns CT_* defined above
    DWORD _GetMTPTContentType();

    DWORD _GetPathSpeed();
    void _CalcPathSpeed();

    BOOL _GetFileAttributes(DWORD* pdwAttrib);
    BOOL _GetFileSystemName(LPTSTR pszFileSysName, DWORD cchFileSysName);
    BOOL _GetGVILabelOrMixedCaseFromReg(LPTSTR pszLabel, DWORD cchLabel);
    BOOL _GetGVILabel(LPTSTR pszLabel, DWORD cchLabel);
    BOOL _GetSerialNumber(DWORD* pdwSerialNumber);
    BOOL _GetFileSystemFlags(DWORD* pdwFlags);
    int _GetGVIDriveFlags();
    int _GetDriveType();
    DWORD _GetAutorunContentType();
    UINT _GetAutorunIcon(LPTSTR pszModule, DWORD cchModule);

    struct GFAGVICALL* _PrepareThreadParam(HANDLE* phEventBegun,
        HANDLE* phEventFinish);
    BOOL _HaveGFAAndGVIExpired(DWORD dwNow);
    BOOL _UpdateGFAAndGVIInfo();
    void _UpdateWNetGCStatus();

    BOOL _IsMountedOnDriveLetter();

    void _InitOnlyOnceStuff();
    void _UpdateLabelFromDesktopINI();
    void _UpdateAutorunInfo();

public:
    static HRESULT _CreateMtPtRemote(LPCWSTR pszMountPoint,
        LPCWSTR pszShareName, BOOL fUnavailable);
    static HRESULT _CreateMtPtRemoteWithoutShareName(LPCWSTR pszMountPoint);

    static CShare* _GetOrCreateShareFromID(LPCWSTR pszShareName);

    static HRESULT _DeleteAllMtPtsAndShares();

    static HRESULT _RemoveShareFromHDPA(CShare* pshare);

///////////////////////////////////////////////////////////////////////////////
// Data
///////////////////////////////////////////////////////////////////////////////
private:
    class CShare*               _pshare;

    DWORD                       _dwWNetGCStatus;
    DWORD                       _dwWNetGC3Status;
    WNGC_CONNECTION_STATE       _wngcs;

    DWORD                       _dwSpeed;

#ifdef DEBUG
private:
    static DWORD                _cMtPtRemote;
#endif
};

class CShare
{
public:
    DWORD                   dwGetFileAttributes;
                  
    WCHAR                   szLabel[MAX_LABEL];
    DWORD                   dwSerialNumber;
    DWORD                   dwMaxFileNameLen;
    DWORD                   dwFileSystemFlags;
    WCHAR                   szFileSysName[MAX_FILESYSNAME];

    BOOL                    fGVIRetValue;
    DWORD                   dwGFAGVILastCall;

    BOOL                    fConnected;

    LPWSTR                  pszRemoteName;
    LPWSTR                  pszKeyName;

    BOOL                    fAutorun;

    BOOL                    fFake;

public:
    ULONG AddRef()
    { return InterlockedIncrement(&_cRef); }

    ULONG Release()
    {
        ASSERT( 0 != _cRef );
        ULONG cRef = InterlockedDecrement(&_cRef);
        if ( 0 == cRef )
        {
            delete this;
        }
        return cRef;
    }

private:
    LONG            _cRef;

public:
    CShare() : _cRef(1)
    {
#ifdef DEBUG
        ++_cShare;
#endif
    }
    ~CShare()
    {
        CMtPtRemote::_RemoveShareFromHDPA(this);

        if (pszRemoteName)
        {
            LocalFree(pszRemoteName);
        }
        if (pszKeyName)
        {
            LocalFree(pszKeyName);
        }
#ifdef DEBUG
        --_cShare;
#endif
    }
#ifdef DEBUG
private:
    static DWORD                _cShare;
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mxctdlg.h ===
#ifndef MXCTDLG_H
#define MXCTDLG_H

#include "hwprompt.h"

#define MAX_DEVICENAME      50

class CMixedContentDlg : public CHWPromptDlg
{
public:
    CMixedContentDlg();

protected:
    virtual ~CMixedContentDlg();
    HRESULT _FillListView();
    HRESULT _InitStatics();
    HRESULT _InitSelections();

private:
    LPWSTR              _rgpszContentTypeFN[5];
    DWORD               _cContentTypeFN;
};

#endif //MXCTDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\nametrans.cpp ===
#include "shellprv.h"
#include "ids.h"
#pragma hdrstop

#include "isproc.h"

// eventually expand this to do rename UI, right now it just picks a default name
// in the destination namespace

HRESULT QIThroughShellItem(IShellItem *psi, REFIID riid, void **ppv)
{
    // todo: put this into shellitem
    *ppv = NULL;

    IShellFolder *psf;
    HRESULT hr = psi->BindToHandler(NULL, BHID_SFObject, IID_PPV_ARG(IShellFolder, &psf));
    if (SUCCEEDED(hr))
    {
        hr = psf->QueryInterface(riid, ppv);
        psf->Release();
    }
    return hr;
}

BOOL IsValidChar(WCHAR chTest, LPWSTR pszValid, LPWSTR pszInvalid)
{
    return (!pszValid || StrChr(pszValid, chTest)) &&
           (!pszInvalid || !StrChr(pszInvalid, chTest));
}

const WCHAR c_rgSubstitutes[] = { '_', ' ', '~' };
WCHAR GetValidSubstitute(LPWSTR pszValid, LPWSTR pszInvalid)
{
    for (int i = 0; i < ARRAYSIZE(c_rgSubstitutes); i++)
    {
        if (IsValidChar(c_rgSubstitutes[i], pszValid, pszInvalid))
        {
            return c_rgSubstitutes[i];
        }
    }
    return 0;
}

HRESULT CheckCharsAndReplaceIfNecessary(IItemNameLimits *pinl, LPWSTR psz)
{
    // returns S_OK if no chars replaced, S_FALSE otherwise
    HRESULT hr = S_OK;
    LPWSTR pszValid, pszInvalid;
    if (SUCCEEDED(pinl->GetValidCharacters(&pszValid, &pszInvalid)))
    {
        WCHAR chSubs = GetValidSubstitute(pszValid, pszInvalid);

        int iSrc = 0, iDest = 0;
        while (psz[iSrc] != 0)
        {
            if (IsValidChar(psz[iSrc], pszValid, pszInvalid))
            {
                // use the char itself if it's valid
                psz[iDest] = psz[iSrc];
                iDest++;
            }
            else
            {
                // mark that we replaced a char
                hr = S_FALSE;
                if (chSubs)
                {
                    // use a substitute if available
                    psz[iDest] = chSubs;
                    iDest++;
                }
                // else no valid char, just skip it
            }
            iSrc++;
        }
        psz[iDest] = 0;

        if (pszValid)
            CoTaskMemFree(pszValid);
        if (pszInvalid)
            CoTaskMemFree(pszInvalid);
    }
    return hr;
}

HRESULT BreakOutString(LPCWSTR psz, LPWSTR *ppszFilespec, LPWSTR *ppszExt)
{
    // todo: detect the (2) in "New Text Document (2).txt" and reduce the filespec
    // accordingly to prevent "(1) (1)" etc. in multiple copies

    *ppszFilespec = NULL;
    *ppszExt = NULL;

    LPWSTR pszExt = PathFindExtension(psz);
    // make an empty string if necessary.  this makes our logic simpler later instead of having to
    // handle the special case all the time.
    HRESULT hr = SHStrDup(pszExt ? pszExt : L"", ppszExt);
    if (SUCCEEDED(hr))
    {
        int iLenExt = lstrlen(*ppszExt);
        int cchBufFilespec = lstrlen(psz) - iLenExt + 1;
        *ppszFilespec = (LPWSTR)CoTaskMemAlloc(cchBufFilespec * sizeof(WCHAR));
        if (*ppszFilespec)
        {
            StrCpyN(*ppszFilespec, psz, cchBufFilespec);
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (FAILED(hr) && *ppszExt)
    {
        CoTaskMemFree(*ppszExt);
        *ppszExt = NULL;
    }
    ASSERT((SUCCEEDED(hr) && *ppszFilespec && *ppszExt) || (FAILED(hr) && !*ppszFilespec && !*ppszExt));
    return hr;
}

BOOL ItemExists(LPCWSTR pszName, IShellItem *psiDest)
{
    BOOL fRet = FALSE;

    IBindCtx *pbc;
    HRESULT hr = BindCtx_CreateWithMode(STGX_MODE_READ, &pbc);
    if (SUCCEEDED(hr))
    {
        ITransferDest *pitd;
        hr = psiDest->BindToHandler(pbc, BHID_SFObject, IID_PPV_ARG(ITransferDest, &pitd));
        if (FAILED(hr))
        {
            hr = CreateStg2StgExWrapper(psiDest, NULL, &pitd);
        }
        if (SUCCEEDED(hr))
        {
            DWORD dwDummy;
            IUnknown *punk;
            hr = pitd->OpenElement(pszName, STGX_MODE_READ, &dwDummy, IID_PPV_ARG(IUnknown, &punk));
            if (SUCCEEDED(hr))
            {
                fRet = TRUE;
                punk->Release();
            }
            pitd->Release();
        }
        pbc->Release();
    }
    return fRet;
}

HRESULT BuildName(LPCWSTR pszFilespec, LPCWSTR pszExt, int iOrd, int iMaxLen, LPWSTR *ppszName)
{
    // some things are hardcoded here like the " (%d)" stuff.  this limitation is equivalent to
    // PathYetAnotherMakeUniqueName so we're okay.

    WCHAR szOrd[10];
    if (iOrd)
    {
        StringCchPrintf(szOrd, ARRAYSIZE(szOrd), L" (%d)", iOrd);
    }
    else
    {
        szOrd[0] = 0;
    }

    int iLenFilespecToUse = lstrlen(pszFilespec);
    int iLenOrdToUse = lstrlen(szOrd);
    int iLenExtToUse = lstrlen(pszExt);
    int iLenTotal = iLenFilespecToUse + iLenOrdToUse + iLenExtToUse;
    HRESULT hr = S_OK;
    if (iLenTotal > iMaxLen)
    {
        // first reduce the filespec since its less important than the extension
        iLenFilespecToUse = max(1, iLenFilespecToUse - (iLenTotal - iMaxLen));
        iLenTotal = iLenFilespecToUse + iLenOrdToUse + iLenExtToUse;
        if (iLenTotal > iMaxLen)
        {
            // next zap the extension.
            iLenExtToUse = max(0, iLenExtToUse - (iLenTotal - iMaxLen));
            iLenTotal = iLenFilespecToUse + iLenOrdToUse + iLenExtToUse;
            if (iLenTotal > iMaxLen)
            {
                // now it's game over.
                iLenOrdToUse = max(0, iLenOrdToUse - (iLenTotal - iMaxLen));
                iLenTotal = iLenFilespecToUse + iLenOrdToUse + iLenExtToUse;
                if (iLenTotal > iMaxLen)
                {
                    hr = E_FAIL;
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        int cchBuf = iLenTotal + 1;
        *ppszName = (LPWSTR)CoTaskMemAlloc(cchBuf * sizeof(WCHAR));
        if (*ppszName)
        {
            StrCpyN(*ppszName, pszFilespec, iLenFilespecToUse + 1);
            StrCpyN(*ppszName + iLenFilespecToUse, szOrd, iLenOrdToUse + 1);
            StrCpyN(*ppszName + iLenFilespecToUse + iLenOrdToUse, pszExt, iLenExtToUse + 1);
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

HRESULT FindUniqueName(LPCWSTR pszFilespec, LPCWSTR pszExt, int iMaxLen, IShellItem *psiDest, LPWSTR *ppszName)
{
    *ppszName = NULL;

    HRESULT hr = E_FAIL;
    BOOL fFound = FALSE;
    for (int i = 0; !fFound && (i < 1000); i++)
    {
        LPWSTR pszBuf;
        if (SUCCEEDED(BuildName(pszFilespec, pszExt, i, iMaxLen, &pszBuf)))
        {
            if (!ItemExists(pszBuf, psiDest))
            {
                fFound = TRUE;
                hr = S_OK;
                *ppszName = pszBuf;
            }
            else
            {
                CoTaskMemFree(pszBuf);
            }
        }
    }

    ASSERT((SUCCEEDED(hr) && *ppszName) || (FAILED(hr) && !*ppszName));
    return hr;
}

HRESULT AutoCreateName(IShellItem *psiDest, IShellItem *psi, LPWSTR *ppszName)
{
    *ppszName = NULL;

    LPWSTR pszOrigName;
    HRESULT hr = psi->GetDisplayName(SIGDN_PARENTRELATIVEFORADDRESSBAR, &pszOrigName);
    if (SUCCEEDED(hr))
    {
        IItemNameLimits *pinl;
        if (SUCCEEDED(QIThroughShellItem(psiDest, IID_PPV_ARG(IItemNameLimits, &pinl))))
        {
            int iMaxLen;
            if (FAILED(pinl->GetMaxLength(pszOrigName, &iMaxLen)))
            {
                // assume this for now in case of failure
                iMaxLen = MAX_PATH;
            }

            if (S_OK != CheckCharsAndReplaceIfNecessary(pinl, pszOrigName) ||
                lstrlen(pszOrigName) > iMaxLen)
            {
                // only if it started as an illegal name do we retry and provide uniqueness.
                // (if its legal then leave it as non-unique so callers can do their confirm overwrite code).
                LPWSTR pszFilespec, pszExt;
                hr = BreakOutString(pszOrigName, &pszFilespec, &pszExt);
                if (SUCCEEDED(hr))
                {
                    hr = FindUniqueName(pszFilespec, pszExt, iMaxLen, psiDest, ppszName);
                    CoTaskMemFree(pszFilespec);
                    CoTaskMemFree(pszExt);
                }
            }
            else
            {
                // the name is okay so let it go through
                hr = S_OK;
                *ppszName = pszOrigName;
                pszOrigName = NULL;
            }
            pinl->Release();
        }
        else
        {
            // if the destination namespace doesn't have an IItemNameLimits then assume the
            // name is all good.  we're not going to probe or anything so this is the best
            // we can do.
            hr = S_OK;
            *ppszName = pszOrigName;
            pszOrigName = NULL;
        }
        if (pszOrigName)
        {
            CoTaskMemFree(pszOrigName);
        }
    }

    if (FAILED(hr) && *ppszName)
    {
        CoTaskMemFree(*ppszName);
        *ppszName = NULL;
    }

    ASSERT((SUCCEEDED(hr) && *ppszName) || (FAILED(hr) && !*ppszName));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mydocsfldr.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include <shguidp.h>    // CLSID_MyDocuments, CLSID_ShellFSFolder
#include <shellp.h>     // SHCoCreateInstance
#include <shlguidp.h>   // IID_IResolveShellLink
#include "util.h"
#include "ids.h"

enum CALLING_APP_TYPE 
{
    APP_IS_UNKNOWN = 0,
    APP_IS_NORMAL,
    APP_IS_OFFICE
};

class CMyDocsFolderLinkResolver : public IResolveShellLink
{
private:
    LONG _cRef;
public:
    CMyDocsFolderLinkResolver() : _cRef(1) { DllAddRef(); };
    ~CMyDocsFolderLinkResolver() { DllRelease(); };

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IResolveShellLink
    STDMETHOD(ResolveShellLink)(IUnknown* punk, HWND hwnd, DWORD fFlags);
};

STDMETHODIMP CMyDocsFolderLinkResolver::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CMyDocsFolderLinkResolver, IResolveShellLink),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_ (ULONG) CMyDocsFolderLinkResolver::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_ (ULONG) CMyDocsFolderLinkResolver::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CMyDocsFolderLinkResolver::ResolveShellLink(IUnknown* punk, HWND hwnd, DWORD fFlags)
{
    // No action needed to resolve a link to the mydocs folder:
    return S_OK;
}


// shell folder implementation for icon on the desktop. the purpouse of this object is
//      1) to give access to MyDocs high up in the name space 
//         this makes it easier for end users to get to MyDocs
//      2) allow for end user custimization of the real MyDocs folder
//         through the provided property page on this icon

// NOTE: this object agregates the file system folder so we get away with a minimal set of interfaces
// on this object. the real file system folder does stuff like IPersistFolder2 for us

class CMyDocsFolder : public IPersistFolder,
                      public IShellFolder2,
                      public IShellIconOverlay
{
public:
    CMyDocsFolder();
    HRESULT Init();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IShellFolder
    STDMETHOD(ParseDisplayName)(HWND hwnd, LPBC pbc, LPOLESTR pDisplayName,
                                ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes);
    STDMETHOD(EnumObjects)(HWND hwnd, DWORD grfFlags, IEnumIDList **ppEnumIDList);
    STDMETHOD(BindToObject)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHOD(BindToStorage)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHOD(CompareIDs)(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHOD(CreateViewObject)(HWND hwnd, REFIID riid, void **ppv);
    STDMETHOD(GetAttributesOf)(UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfInOut);
    STDMETHOD(GetUIObjectOf)(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppv);
    STDMETHOD(GetDisplayNameOf)(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName);
    STDMETHOD(SetNameOf)(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST* ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(LPGUID lpGuid);
    STDMETHODIMP EnumSearches(LPENUMEXTRASEARCH *ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid);

    // IPersist, IPersistFreeThreadedObject
    STDMETHOD(GetClassID)(CLSID *pClassID);

    // IPersistFolder
    STDMETHOD(Initialize)(LPCITEMIDLIST pidl);

    // IPersistFolder2, IPersistFolder3, etc are all implemented by 
    // the folder we agregate

    // IShellIconOverlay
    STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex);
    STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIconIndex);

private:
    ~CMyDocsFolder();


    HRESULT _GetFolder();
    HRESULT _GetFolder2();
    HRESULT _GetShellIconOverlay();

    void _FreeFolder();

    HRESULT _PathFromIDList(LPCITEMIDLIST pidl, LPTSTR pszPath);

    HRESULT _GetFolderOverlayInfo(int *pIndex, BOOL fIconIndex);


    LONG                 _cRef;

    IUnknown *           _punk;         // points to IUnknown for shell folder in use...
    IShellFolder *       _psf;          // points to shell folder in use...
    IShellFolder2 *      _psf2;         // points to shell folder in use...
    IShellIconOverlay*   _psio;         // points to shell folder in use...
    LPITEMIDLIST         _pidl;         // copy of pidl passed to us in Initialize()
    CALLING_APP_TYPE     _host;

    HRESULT RealInitialize(LPCITEMIDLIST pidlRoot, LPCITEMIDLIST pidlBindTo, LPTSTR pRootPath);
    CALLING_APP_TYPE _WhoIsCalling();
};

STDAPI CMyDocsFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CMyDocsFolder *pmydocs = new CMyDocsFolder();
    if (pmydocs)
    {
        hr = pmydocs->Init();
        if (SUCCEEDED(hr))
            hr = pmydocs->QueryInterface(riid, ppv);
        pmydocs->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

CMyDocsFolder::CMyDocsFolder() : _cRef(1), _host(APP_IS_UNKNOWN),
    _psf(NULL), _psf2(NULL), _psio(NULL), _punk(NULL), _pidl(NULL)
{
    DllAddRef();
}

CMyDocsFolder::~CMyDocsFolder()
{
    _cRef = 1000;  // deal with agregation re-enter

    _FreeFolder();

    ILFree(_pidl);

    DllRelease();
}

HRESULT CMyDocsFolder::Init()
{
    // agregate a file system folder object early so we can
    // delegate QI() to him that we don't implement
    HRESULT hr = SHCoCreateInstance(NULL, &CLSID_ShellFSFolder, SAFECAST(this, IShellFolder *), IID_PPV_ARG(IUnknown, &_punk));
    if (SUCCEEDED(hr))
    {
        IPersistFolder3 *ppf3;
        hr = SHQueryInnerInterface(SAFECAST(this, IShellFolder *), _punk, IID_PPV_ARG(IPersistFolder3, &ppf3));
        if (SUCCEEDED(hr))
        {
            PERSIST_FOLDER_TARGET_INFO pfti = {0};
    
            pfti.dwAttributes = FILE_ATTRIBUTE_DIRECTORY;
            pfti.csidl = CSIDL_PERSONAL | CSIDL_FLAG_PFTI_TRACKTARGET;

            hr = SHGetFolderLocation(NULL, CSIDL_PERSONAL, NULL, 0, &_pidl);
            if (SUCCEEDED(hr))
            {
                hr = ppf3->InitializeEx(NULL, _pidl, &pfti);
            }
            SHReleaseInnerInterface(SAFECAST(this, IShellFolder *), (IUnknown **)&ppf3);
        }
    }
    return hr;
}

STDMETHODIMP CMyDocsFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CMyDocsFolder, IShellFolder, IShellFolder2),
        QITABENT(CMyDocsFolder, IShellFolder2),
        QITABENTMULTI(CMyDocsFolder, IPersist, IPersistFolder),
        QITABENT(CMyDocsFolder, IPersistFolder),
        QITABENT(CMyDocsFolder, IShellIconOverlay),
        // QITABENTMULTI2(CMyDocsFolder, IID_IPersistFreeThreadedObject, IPersist),           // IID_IPersistFreeThreadedObject
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);
    if (FAILED(hr) && _punk)
        hr = _punk->QueryInterface(riid, ppv); // agregated guy
    return hr;
}

STDMETHODIMP_ (ULONG) CMyDocsFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_ (ULONG) CMyDocsFolder::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// Determine who is calling us so that we can do app specific
// compatibility hacks when needed
CALLING_APP_TYPE CMyDocsFolder::_WhoIsCalling()
{
    // Check to see if we have the value already...
    if (_host == APP_IS_UNKNOWN)
    {
        if (SHGetAppCompatFlags (ACF_APPISOFFICE) & ACF_APPISOFFICE)
            _host = APP_IS_OFFICE;
        else 
            _host = APP_IS_NORMAL;
    }
    return _host;
}

// IPersist methods
STDMETHODIMP CMyDocsFolder::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_MyDocuments;
    return S_OK;
}

HRESULT _BindToIDListParent(LPCITEMIDLIST pidl, LPBC pbc, IShellFolder **ppsf, LPITEMIDLIST *ppidlLast)
{
    HRESULT hr;
    LPITEMIDLIST pidlParent = ILCloneParent(pidl);
    if (pidlParent)
    {
        hr = SHBindToObjectEx(NULL, pidlParent, pbc, IID_PPV_ARG(IShellFolder, ppsf));
        ILFree(pidlParent);
    }
    else
        hr = E_OUTOFMEMORY;
    if (ppidlLast)
        *ppidlLast = ILFindLastID(pidl);
    return hr;
}

HRESULT _ConfirmMyDocsPath(HWND hwnd)
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = SHGetFolderPath(hwnd, CSIDL_PERSONAL | CSIDL_FLAG_CREATE, NULL, SHGFP_TYPE_CURRENT, szPath);
    if (S_OK != hr)
    {
        TCHAR szTitle[MAX_PATH];

        // above failed, get unverified path
        SHGetFolderPath(NULL, CSIDL_PERSONAL | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPath);

        LPCTSTR pszMsg = PathIsNetworkPath(szPath) ? MAKEINTRESOURCE(IDS_CANT_FIND_MYDOCS_NET) :
                                                     MAKEINTRESOURCE(IDS_CANT_FIND_MYDOCS);

        PathCompactPath(NULL, szPath, 400);

        GetMyDocumentsDisplayName(szTitle, ARRAYSIZE(szTitle));

        ShellMessageBox(g_hinst, hwnd, pszMsg, szTitle,
                        MB_OK | MB_ICONSTOP, szPath, szTitle);

        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // user saw the message
    } 
    else if (hr == S_FALSE)
        hr = E_FAIL;
    return hr;
}

// like SHGetPathFromIDList() except this uses the bind context to make sure
// we don't get into loops since there can be cases where there are multiple 
// instances of this folder that can cause binding loops.

HRESULT CMyDocsFolder::_PathFromIDList(LPCITEMIDLIST pidl, LPTSTR pszPath)
{
    *pszPath = 0;

    LPBC pbc;
    HRESULT hr = CreateBindCtx(NULL, &pbc);
    if (SUCCEEDED(hr))
    {
        // this bind context skips extension taged with our CLSID
        hr = pbc->RegisterObjectParam(STR_SKIP_BINDING_CLSID, SAFECAST(this, IShellFolder *));
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlLast;
            IShellFolder *psf;
            hr = _BindToIDListParent(pidl, pbc, &psf, &pidlLast);
            if (SUCCEEDED(hr))
            {
                hr = DisplayNameOf(psf, pidlLast, SHGDN_FORPARSING, pszPath, MAX_PATH);
                psf->Release();
            }
        }
        pbc->Release();
    }
    return hr;
}

void CMyDocsFolder::_FreeFolder()
{
    if (_punk)
    {
        SHReleaseInnerInterface(SAFECAST(this, IShellFolder *), (IUnknown **)&_psf);
        SHReleaseInnerInterface(SAFECAST(this, IShellFolder *), (IUnknown **)&_psf2);
        SHReleaseInnerInterface(SAFECAST(this, IShellFolder *), (IUnknown **)&_psio);
        _punk->Release();
        _punk = NULL;
    }
}

// verify that _psf (agregated file system folder) has been inited

HRESULT CMyDocsFolder::_GetFolder()
{
    HRESULT hr;

    if (_psf)
    {
        hr = S_OK;
    }
    else
    {
        hr = SHQueryInnerInterface(SAFECAST(this, IShellFolder *), _punk, IID_PPV_ARG(IShellFolder, &_psf));
    }
    return hr;
}

HRESULT CMyDocsFolder::_GetFolder2()
{
    HRESULT hr;
    if (_psf2)
        hr = S_OK;
    else
    {
        hr = _GetFolder();
        if (SUCCEEDED(hr))
            hr = SHQueryInnerInterface(SAFECAST(this, IShellFolder *), _punk, IID_PPV_ARG(IShellFolder2, &_psf2));
    }
    return hr;
}

HRESULT CMyDocsFolder::_GetShellIconOverlay()
{
    HRESULT hr;
    if (_psio)
    {
        hr = S_OK;
    }
    else
    {
        hr = _GetFolder();
        if (SUCCEEDED(hr))
        {
            hr = SHQueryInnerInterface(SAFECAST(this, IShellFolder *), _punk, IID_PPV_ARG(IShellIconOverlay, &_psio));
        }
    }
    return hr;
}

// returns:
//      S_OK    -- goodness
//      S_FALSE freed the pidl, set to empty
//      E_OUTOFMEMORY

HRESULT _SetIDList(LPITEMIDLIST* ppidl, LPCITEMIDLIST pidl)
{
    if (*ppidl) 
    {
        ILFree(*ppidl);
        *ppidl = NULL;
    }

    return pidl ? SHILClone(pidl, ppidl) : S_FALSE;
}

BOOL IsMyDocsIDList(LPCITEMIDLIST pidl)
{
    BOOL bIsMyDocs = FALSE;
    if (pidl && !ILIsEmpty(pidl) && ILIsEmpty(_ILNext(pidl)))
    {
        LPITEMIDLIST pidlMyDocs;
        if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_PERSONAL, NULL, 0, &pidlMyDocs)))
        {
            bIsMyDocs = ILIsEqual(pidl, pidlMyDocs);
            ILFree(pidlMyDocs);
        }
    }
    return bIsMyDocs;
}


// Scans a desktop.ini file for sections to see if all of them are empty...

BOOL IsDesktopIniEmpty(LPCTSTR pIniFile)
{
    TCHAR szSections[1024];  // for section names
    if (GetPrivateProfileSectionNames(szSections, ARRAYSIZE(szSections), pIniFile))
    {
        for (LPTSTR pTmp = szSections; *pTmp; pTmp += lstrlen(pTmp) + 1)
        {
            TCHAR szSection[1024];   // for section key names and values
            GetPrivateProfileSection(pTmp, szSection, ARRAYSIZE(szSection), pIniFile);
            if (szSection[0])
            {
                return FALSE;
            }
        }
    }
    return TRUE;
}

// Remove our entries from the desktop.ini file in this directory, and
// then test the desktop.ini to see if it's empty.  If it is, delete it
// and remove the system/readonly bit from the directory...

void MyDocsUnmakeSystemFolder(LPCTSTR pPath)
{
    TCHAR szIniFile[MAX_PATH];

    if (PathCombine(szIniFile, pPath, c_szDesktopIni))
    {
        // Remove CLSID2
        WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("CLSID2"), NULL, szIniFile);

        // Remove InfoTip
        WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("InfoTip"), NULL, szIniFile);

        // Remove Icon
        WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("IconFile"), NULL, szIniFile);

        DWORD dwAttrb = GetFileAttributes(szIniFile);
        if (dwAttrb != 0xFFFFFFFF)
        {
            if (IsDesktopIniEmpty(szIniFile))
            {
                dwAttrb &= ~(FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN);
                SetFileAttributes(szIniFile, dwAttrb);
                DeleteFile(szIniFile);
            }
            PathUnmakeSystemFolder(pPath);
        }
    }
}


// IPersistFolder
HRESULT CMyDocsFolder::Initialize(LPCITEMIDLIST pidl)
{
    HRESULT hr;
    if (IsMyDocsIDList(pidl))
    {
        hr = _SetIDList(&_pidl, pidl);
    }
    else
    {
        TCHAR szPathInit[MAX_PATH], szMyDocs[MAX_PATH];

        // we are being inited by some folder other than the one on the
        // desktop (from the old mydocs desktop.ini). if this the current users
        // MyDocs we will untag it now so we don't get called on this anymore

        SHGetFolderPath(NULL, CSIDL_PERSONAL | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szMyDocs);

        if (SUCCEEDED(_PathFromIDList(pidl, szPathInit)) &&
            lstrcmpi(szPathInit, szMyDocs) == 0)
        {
            MyDocsUnmakeSystemFolder(szMyDocs);
        }
        hr = E_FAIL;    // don't init on the file system folder anymore
    }
    return hr;
}

STDMETHODIMP CMyDocsFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pDisplayName, 
                                             ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG *pdwAttributes)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->ParseDisplayName(hwnd, pbc, pDisplayName, pchEaten, ppidl, pdwAttributes);
    return hr;
}

STDMETHODIMP CMyDocsFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppEnumIdList)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->EnumObjects(hwnd, grfFlags, ppEnumIdList);
    return hr;
}

STDMETHODIMP CMyDocsFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->BindToObject(pidl, pbc, riid, ppv);
    return hr;
}

STDMETHODIMP CMyDocsFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->BindToStorage(pidl, pbc, riid, ppv);
    return hr;
}

STDMETHODIMP CMyDocsFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->CompareIDs(lParam, pidl1, pidl2);
    return hr;
}

/*
void UpdateSendToFile()
{
    IPersistFile *ppf;
    if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_MyDocsDropTarget, NULL, IID_PPV_ARG(IPersistFile, &ppf))))
    {
        ppf->Load(NULL, 0); // hack, get this guy to update his icon
        ppf->Release();
    }
}
*/

STDMETHODIMP CMyDocsFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr;
    if (riid == IID_IResolveShellLink)
    {
        // No work needed to resolve a link to the mydocs folder, because it is a virtual
        // folder whose location is always tracked by the shell, so return our implementation
        // of IResolveShellLink - which does nothing when Resolve() is called
        CMyDocsFolderLinkResolver* pslr = new CMyDocsFolderLinkResolver;
        if (pslr)
        {
            hr = pslr->QueryInterface(riid, ppv);
            pslr->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (riid == IID_IShellLinkA || 
             riid == IID_IShellLinkW)
    {
        LPITEMIDLIST pidl;
        hr = SHGetFolderLocation(NULL, CSIDL_PERSONAL | CSIDL_FLAG_NO_ALIAS, NULL, 0, &pidl);
        if (SUCCEEDED(hr))
        {
            IShellLink *psl;
            hr = SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, IID_PPV_ARG(IShellLink, &psl));
            if (SUCCEEDED(hr))
            {
                hr = psl->SetIDList(pidl);
                if (SUCCEEDED(hr))
                {
                    hr = psl->QueryInterface(riid, ppv);
                }
                psl->Release();
            }
            ILFree(pidl);
        }
    }
    else
    {
        hr = _GetFolder();
        if (SUCCEEDED(hr))
        {
            if (hwnd && (IID_IShellView == riid))
                hr = _ConfirmMyDocsPath(hwnd);

            if (SUCCEEDED(hr))
                hr = _psf->CreateViewObject(hwnd, riid, ppv);
        }
    }

    return hr;
}

DWORD _GetRealMyDocsAttributes(DWORD dwAttributes)
{
    DWORD dwRet = SFGAO_HASPROPSHEET;   // default to this in the falure case
                                        // so you can redirect mydocs via the property page
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetFolderLocation(NULL, CSIDL_PERSONAL | CSIDL_FLAG_NO_ALIAS, NULL, 0, &pidl);
    if (SUCCEEDED(hr))
    {
        IShellFolder *psf;
        LPITEMIDLIST pidlLast;
        hr = _BindToIDListParent(pidl, NULL, &psf, &pidlLast);
        if (SUCCEEDED(hr))
        {
            dwRet = SHGetAttributes(psf, pidlLast, dwAttributes);
            psf->Release();
        }
        ILFree(pidl);
    }
    return dwRet;
}

#define MYDOCS_CLSID TEXT("{450d8fba-ad25-11d0-98a8-0800361b1103}") // CLSID_MyDocuments

DWORD MyDocsGetAttributes()
{
    DWORD dwAttributes = SFGAO_CANLINK |            // 00000004
                         SFGAO_CANRENAME |          // 00000010
                         SFGAO_CANDELETE |          // 00000020
                         SFGAO_HASPROPSHEET |       // 00000040
                         SFGAO_DROPTARGET |         // 00000100
                         SFGAO_FILESYSANCESTOR |    // 10000000
                         SFGAO_FOLDER |             // 20000000
                         SFGAO_FILESYSTEM |         // 40000000
                         SFGAO_HASSUBFOLDER |       // 80000000
                         SFGAO_STORAGEANCESTOR |
                         SFGAO_STORAGE;             
                         // SFGAO_NONENUMERATED     // 00100000
                         //                         // F0400174
    HKEY hkey;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID\\") MYDOCS_CLSID TEXT("\\ShellFolder"), 0, KEY_QUERY_VALUE, &hkey))
    {
        DWORD dwSize = sizeof(dwAttributes);
        RegQueryValueEx(hkey, TEXT("Attributes"), NULL, NULL, (BYTE *)&dwAttributes, &dwSize);
        RegCloseKey(hkey);
    }
    return dwAttributes;
}

// these are the attributes from the real mydocs folder that we want to merge
// in with the desktop icons attributes

#define SFGAO_ATTRIBS_MERGE    (SFGAO_SHARE | SFGAO_HASPROPSHEET)

STDMETHODIMP CMyDocsFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* rgfInOut)
{
    HRESULT hr;
    if (IsSelf(cidl, apidl))
    {
        DWORD dwRequested = *rgfInOut;

        *rgfInOut = MyDocsGetAttributes();
        
        if (dwRequested & SFGAO_ATTRIBS_MERGE)
            *rgfInOut |= _GetRealMyDocsAttributes(SFGAO_ATTRIBS_MERGE);

        // RegItem "CallForAttributes" gets us here...
        switch(_WhoIsCalling())
        {
        case APP_IS_OFFICE:
            *rgfInOut &= ~(SFGAO_FILESYSANCESTOR | SFGAO_CANMONIKER | 
                           SFGAO_HASPROPSHEET | SFGAO_NONENUMERATED);
            break;
        }
        
        if (SHRestricted(REST_MYDOCSNOPROP))
        {
            (*rgfInOut) &= ~SFGAO_HASPROPSHEET;
        }

        hr = S_OK;
    }
    else
    {
        hr = _GetFolder();
        if (SUCCEEDED(hr))
            hr = _psf->GetAttributesOf(cidl, apidl, rgfInOut);
    }

    return hr;
}

STDMETHODIMP CMyDocsFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *aidl, 
                                          REFIID riid, UINT *pRes, void **ppv)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->GetUIObjectOf(hwnd, cidl, aidl, riid, pRes, ppv);
    return hr;
}

STDMETHODIMP CMyDocsFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName)
{
    HRESULT hr;
    if (IsSelf(1, &pidl))
    {
        TCHAR szMyDocsPath[MAX_PATH];
        hr = SHGetFolderPath(NULL, CSIDL_PERSONAL | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szMyDocsPath);
        if (SUCCEEDED(hr))
        {
            // RegItems "WantsFORPARSING" gets us here. allows us to control our parsing name
            LPTSTR psz = ((uFlags & SHGDN_INFOLDER) ? PathFindFileName(szMyDocsPath) : szMyDocsPath);
            hr = StringToStrRet(psz, pName);
        }
    }
    else
    {
        hr = _GetFolder();
        if (SUCCEEDED(hr))
            hr = _psf->GetDisplayNameOf(pidl, uFlags, pName);
    }
    return hr;
}

STDMETHODIMP CMyDocsFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pName, DWORD uFlags, LPITEMIDLIST *ppidlOut)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->SetNameOf(hwnd, pidl, pName, uFlags, ppidlOut);
    return hr;
}

STDMETHODIMP CMyDocsFolder::GetDefaultSearchGUID(LPGUID lpGuid)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->GetDefaultSearchGUID(lpGuid);
    return hr;
}

STDMETHODIMP CMyDocsFolder::EnumSearches(LPENUMEXTRASEARCH *ppenum)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->EnumSearches(ppenum);
    return hr;
}

STDMETHODIMP CMyDocsFolder::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->GetDefaultColumn(dwRes, pSort, pDisplay);
    return hr;
}

STDMETHODIMP CMyDocsFolder::GetDefaultColumnState(UINT iColumn, DWORD *pbState)
{    
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->GetDefaultColumnState(iColumn, pbState);
    return hr;
}

STDMETHODIMP CMyDocsFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->GetDetailsEx(pidl, pscid, pv);
    return hr;
}

STDMETHODIMP CMyDocsFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, LPSHELLDETAILS pDetail)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->GetDetailsOf(pidl, iColumn, pDetail);
    return hr;
}

STDMETHODIMP CMyDocsFolder::MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->MapColumnToSCID(iCol, pscid);
    return hr;
}

HRESULT CMyDocsFolder::_GetFolderOverlayInfo(int *pIndex, BOOL fIconIndex)
{
    HRESULT hr;

    if (pIndex)
    {
        LPITEMIDLIST pidl;
        hr = SHGetFolderLocation(NULL, CSIDL_PERSONAL | CSIDL_FLAG_NO_ALIAS, NULL, 0, &pidl);
        if (SUCCEEDED(hr))
        {
            IShellFolder *psf;
            LPITEMIDLIST pidlLast;
            hr = _BindToIDListParent(pidl, NULL, &psf, &pidlLast);
            if (SUCCEEDED(hr))
            {
                IShellIconOverlay* psio;
                hr = psf->QueryInterface(IID_PPV_ARG(IShellIconOverlay, &psio));
                if (SUCCEEDED(hr))
                {
                    if (fIconIndex)
                        hr = psio->GetOverlayIconIndex(pidlLast, pIndex);
                    else
                        hr = psio->GetOverlayIndex(pidlLast, pIndex);

                    psio->Release();
                }

                psf->Release();
            }

            ILFree(pidl);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CMyDocsFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    HRESULT hr = E_FAIL;

    if (IsSelf(1, &pidl))
    {
        if (pIndex && *pIndex == OI_ASYNC)
            hr = E_PENDING;
        else
            hr = _GetFolderOverlayInfo(pIndex, FALSE);
    }
    else
    {
        // forward to aggregated dude
        if (SUCCEEDED(_GetShellIconOverlay()))
        {
            hr = _psio->GetOverlayIndex(pidl, pIndex);
        }
    }

    return hr;
}

STDMETHODIMP CMyDocsFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIconIndex)
{
    HRESULT hr = E_FAIL;

    if (IsSelf(1, &pidl))
    {
        hr = _GetFolderOverlayInfo(pIconIndex, TRUE);
    }
    else if (SUCCEEDED(_GetShellIconOverlay()))
    {
        // forward to aggregated dude
        hr = _psio->GetOverlayIconIndex(pidl, pIconIndex);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\mulprsht.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "propsht.h"
#include <winbase.h>
#include <shellids.h>
#include "util.h"       // for GetFileDescription
#include "prshtcpp.h"   // for progress dlg and recursive apply
#include "shlexec.h"    // for SIDKEYNAME
#include "datautil.h"
#include <efsui.h>      // for EfsDetail
#include "ascstr.h"     // for IAssocStore
#include "strsafe.h"
// drivesx.c
STDAPI_(DWORD) PathGetClusterSize(LPCTSTR pszPath);
STDAPI_(DWORD) DrivesPropertiesThreadProc(void *pv);

// version.c
STDAPI_(void) AddVersionPage(LPCTSTR pszFilePath, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);

// link.c
STDAPI_(BOOL) AddLinkPage(LPCTSTR pszFile, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

const DWORD aFileGeneralHelpIds[] = {
        IDD_LINE_1,             NO_HELP,
        IDD_LINE_2,             NO_HELP,
        IDD_LINE_3,             NO_HELP,
        IDD_ITEMICON,           IDH_FPROP_GEN_ICON,
        IDD_NAMEEDIT,           IDH_FPROP_GEN_NAME,
        IDC_CHANGEFILETYPE,     IDH_FPROP_GEN_CHANGE,
        IDD_FILETYPE_TXT,       IDH_FPROP_GEN_TYPE,
        IDD_FILETYPE,           IDH_FPROP_GEN_TYPE,
        IDD_OPENSWITH_TXT,      IDH_FPROP_GEN_OPENSWITH,
        IDD_OPENSWITH,          IDH_FPROP_GEN_OPENSWITH,
        IDD_LOCATION_TXT,       IDH_FPROP_GEN_LOCATION,
        IDD_LOCATION,           IDH_FPROP_GEN_LOCATION,
        IDD_FILESIZE_TXT,       IDH_FPROP_GEN_SIZE,
        IDD_FILESIZE,           IDH_FPROP_GEN_SIZE,
        IDD_FILESIZE_COMPRESSED,     IDH_FPROP_GEN_COMPRESSED_SIZE,
        IDD_FILESIZE_COMPRESSED_TXT, IDH_FPROP_GEN_COMPRESSED_SIZE,
        IDD_CONTAINS_TXT,       IDH_FPROP_FOLDER_CONTAINS,
        IDD_CONTAINS,           IDH_FPROP_FOLDER_CONTAINS,
        IDD_CREATED_TXT,        IDH_FPROP_GEN_DATE_CREATED,
        IDD_CREATED,            IDH_FPROP_GEN_DATE_CREATED,
        IDD_LASTMODIFIED_TXT,   IDH_FPROP_GEN_LASTCHANGE,
        IDD_LASTMODIFIED,       IDH_FPROP_GEN_LASTCHANGE,
        IDD_LASTACCESSED_TXT,   IDH_FPROP_GEN_LASTACCESS,
        IDD_LASTACCESSED,       IDH_FPROP_GEN_LASTACCESS,
        IDD_ATTR_GROUPBOX,      IDH_COMM_GROUPBOX,
        IDD_READONLY,           IDH_FPROP_GEN_READONLY,
        IDD_HIDDEN,             IDH_FPROP_GEN_HIDDEN,
        IDD_ARCHIVE,            IDH_FPROP_GEN_ARCHIVE,
        IDC_ADVANCED,           IDH_FPROP_GEN_ADVANCED,
        IDC_DRV_PROPERTIES,     IDH_FPROP_GEN_MOUNTEDPROP,
        IDD_FILETYPE_TARGET,    IDH_FPROP_GEN_MOUNTEDTARGET,
        IDC_DRV_TARGET,         IDH_FPROP_GEN_MOUNTEDTARGET,
        0, 0
};

const DWORD aFolderGeneralHelpIds[] = {
        IDD_LINE_1,             NO_HELP,
        IDD_LINE_2,             NO_HELP,
        IDD_LINE_3,             NO_HELP,
        IDD_ITEMICON,           IDH_FPROP_GEN_ICON,
        IDD_NAMEEDIT,           IDH_FPROP_GEN_NAME,
        IDC_CHANGEFILETYPE,     IDH_FPROP_GEN_CHANGE,
        IDD_FILETYPE_TXT,       IDH_FPROP_GEN_TYPE,
        IDD_FILETYPE,           IDH_FPROP_GEN_TYPE,
        IDD_OPENSWITH_TXT,      IDH_FPROP_GEN_OPENSWITH,
        IDD_OPENSWITH,          IDH_FPROP_GEN_OPENSWITH,
        IDD_LOCATION_TXT,       IDH_FPROP_GEN_LOCATION,
        IDD_LOCATION,           IDH_FPROP_GEN_LOCATION,
        IDD_FILESIZE_TXT,       IDH_FPROP_GEN_SIZE,
        IDD_FILESIZE,           IDH_FPROP_GEN_SIZE,
        IDD_FILESIZE_COMPRESSED,     IDH_FPROP_GEN_COMPRESSED_SIZE,
        IDD_FILESIZE_COMPRESSED_TXT, IDH_FPROP_GEN_COMPRESSED_SIZE,
        IDD_CONTAINS_TXT,       IDH_FPROP_FOLDER_CONTAINS,
        IDD_CONTAINS,           IDH_FPROP_FOLDER_CONTAINS,
        IDD_CREATED_TXT,        IDH_FPROP_GEN_DATE_CREATED,
        IDD_CREATED,            IDH_FPROP_GEN_DATE_CREATED,
        IDD_LASTMODIFIED_TXT,   IDH_FPROP_GEN_LASTCHANGE,
        IDD_LASTMODIFIED,       IDH_FPROP_GEN_LASTCHANGE,
        IDD_LASTACCESSED_TXT,   IDH_FPROP_GEN_LASTACCESS,
        IDD_LASTACCESSED,       IDH_FPROP_GEN_LASTACCESS,
        IDD_ATTR_GROUPBOX,      IDH_COMM_GROUPBOX,
        IDD_READONLY,           IDH_FPROP_GEN_FOLDER_READONLY,
        IDD_HIDDEN,             IDH_FPROP_GEN_HIDDEN,
        IDD_ARCHIVE,            IDH_FPROP_GEN_ARCHIVE,
        IDC_ADVANCED,           IDH_FPROP_GEN_ADVANCED,
        IDC_DRV_PROPERTIES,     IDH_FPROP_GEN_MOUNTEDPROP,
        IDD_FILETYPE_TARGET,    IDH_FPROP_GEN_MOUNTEDTARGET,
        IDC_DRV_TARGET,         IDH_FPROP_GEN_MOUNTEDTARGET,
        0, 0
};

const DWORD aMultiPropHelpIds[] = {
        IDD_LINE_1,             NO_HELP,
        IDD_LINE_2,             NO_HELP,
        IDD_ITEMICON,           IDH_FPROP_GEN_ICON,
        IDD_CONTAINS,           IDH_MULTPROP_NAME,
        IDD_FILETYPE_TXT,       IDH_FPROP_GEN_TYPE,
        IDD_FILETYPE,           IDH_FPROP_GEN_TYPE,
        IDD_LOCATION_TXT,       IDH_FPROP_GEN_LOCATION,
        IDD_LOCATION,           IDH_FPROP_GEN_LOCATION,
        IDD_FILESIZE_TXT,       IDH_FPROP_GEN_SIZE,
        IDD_FILESIZE,           IDH_FPROP_GEN_SIZE,
        IDD_FILESIZE_COMPRESSED,     IDH_FPROP_GEN_COMPRESSED_SIZE,
        IDD_FILESIZE_COMPRESSED_TXT, IDH_FPROP_GEN_COMPRESSED_SIZE,
        IDD_ATTR_GROUPBOX,      IDH_COMM_GROUPBOX,
        IDD_READONLY,           IDH_FPROP_GEN_READONLY,
        IDD_HIDDEN,             IDH_FPROP_GEN_HIDDEN,
        IDD_ARCHIVE,            IDH_FPROP_GEN_ARCHIVE,
        IDC_ADVANCED,           IDH_FPROP_GEN_ADVANCED,
        0, 0
};

const DWORD aAdvancedHelpIds[] = {
        IDD_ITEMICON,           NO_HELP,
        IDC_MANAGEFILES_TXT,    NO_HELP,
        IDD_MANAGEFOLDERS_TXT,  NO_HELP,
        IDD_ARCHIVE,            IDH_FPROP_GEN_ARCHIVE,
        IDD_INDEX,              IDH_FPROP_GEN_INDEX,
        IDD_COMPRESS,           IDH_FPROP_GEN_COMPRESSED,
        IDD_ENCRYPT,            IDH_FPROP_GEN_ENCRYPT,
        IDC_ADVANCED,           IDH_FPROP_ENCRYPT_DETAILS,
        0, 0
};

FOLDERCONTENTSINFO* Create_FolderContentsInfo()
{
    FOLDERCONTENTSINFO *pfci = (FOLDERCONTENTSINFO*)LocalAlloc(LPTR, sizeof(*pfci));
    if (pfci)
    {
        pfci->_cRef = 1;
    }
    return pfci;
}

void Free_FolderContentsInfoMembers(FOLDERCONTENTSINFO* pfci)
{
    if (pfci->hida)
    {
        GlobalFree(pfci->hida);
        pfci->hida = NULL;
    }
}

LONG AddRef_FolderContentsInfo(FOLDERCONTENTSINFO* pfci)
{
    ASSERTMSG(pfci != NULL, "AddRef_FolderContentsInfo: caller passed a null pfci");
    if (pfci)
    {
        return InterlockedIncrement(&pfci->_cRef);
    }
    return 0;
}

LONG Release_FolderContentsInfo(FOLDERCONTENTSINFO* pfci)
{
    if (pfci)
    {
        ASSERT( 0 != pfci->_cRef );
        LONG cRef = InterlockedDecrement(&pfci->_cRef);
        if ( 0 == cRef )
        {
            Free_FolderContentsInfoMembers(pfci);
            LocalFree(pfci);
        }
        return cRef;
    }
    return 0;
}


void UpdateSizeCount(FILEPROPSHEETPAGE * pfpsp)
{
    TCHAR szNum[32], szNum1[64];
    LPTSTR pszFmt = ShellConstructMessageString(HINST_THISDLL,
         MAKEINTRESOURCE(pfpsp->pfci->cbSize ? IDS_SIZEANDBYTES : IDS_SIZE),
         ShortSizeFormat64(pfpsp->pfci->cbSize, szNum, ARRAYSIZE(szNum)),
         AddCommas64(pfpsp->pfci->cbSize, szNum1, ARRAYSIZE(szNum1)));
    if (pszFmt)
    {
        SetDlgItemText(pfpsp->hDlg, IDD_FILESIZE, pszFmt);
        LocalFree(pszFmt);
    }

    pszFmt = ShellConstructMessageString(HINST_THISDLL,
         MAKEINTRESOURCE(pfpsp->pfci->cbActualSize ? IDS_SIZEANDBYTES : IDS_SIZE),
         ShortSizeFormat64(pfpsp->pfci->cbActualSize, szNum, ARRAYSIZE(szNum)),
         AddCommas64(pfpsp->pfci->cbActualSize, szNum1, ARRAYSIZE(szNum1)));

    if (pszFmt)
    {
        SetDlgItemText(pfpsp->hDlg, IDD_FILESIZE_COMPRESSED, pszFmt);
        LocalFree(pszFmt);
    }

    pszFmt = ShellConstructMessageString(HINST_THISDLL,
         MAKEINTRESOURCE(IDS_NUMFILES),
         AddCommas(pfpsp->pfci->cFiles, szNum, ARRAYSIZE(szNum)),
         AddCommas(pfpsp->pfci->cFolders, szNum1, ARRAYSIZE(szNum1)));
    if (pszFmt && !pfpsp->fMountedDrive)
    {
        SetDlgItemText(pfpsp->hDlg, IDD_CONTAINS, pszFmt);
        LocalFree(pszFmt);
    }
}


STDAPI_(BOOL) HIDA_FillFindData(HIDA hida, UINT iItem, LPTSTR pszPath, WIN32_FIND_DATA *pfd, BOOL fReturnCompressedSize)
{
    BOOL fRet = FALSE;      // assume error
    *pszPath = 0;           // assume error

    LPITEMIDLIST pidl = HIDA_ILClone(hida, iItem);
    if (pidl)
    {
        if (SHGetPathFromIDList(pidl, pszPath))
        {
            if (pfd)
            {
                HANDLE h = FindFirstFile(pszPath, pfd);
                if (h == INVALID_HANDLE_VALUE)
                {
                    // error, zero the bits
                    ZeroMemory(pfd, sizeof(*pfd));
                }
                else
                {
                    FindClose(h);
                    // if the user wants the compressed file size, and compression is supported, then go get it
                    if (fReturnCompressedSize && (pfd->dwFileAttributes & (FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_SPARSE_FILE)))
                    {
                        pfd->nFileSizeLow = SHGetCompressedFileSize(pszPath, &pfd->nFileSizeHigh);
                    }
                }
            }
            fRet = TRUE;
        }
        ILFree(pidl);
    }
    return fRet;
}


DWORD CALLBACK SizeThreadProc(void *pv)
{
    FOLDERCONTENTSINFO* pfci = (FOLDERCONTENTSINFO*)pv;

    pfci->cbSize  = 0;
    pfci->cbActualSize = 0;
    pfci->cFiles = 0;
    pfci->cFolders = 0;

    if (pfci->bContinue && pfci->hDlg)
    {
        // update the dialog every 1/4 second
        SetTimer(pfci->hDlg, IDT_SIZE, 250, NULL);
    }

    TCHAR szPath[MAX_PATH];
    for (UINT iItem = 0; HIDA_FillFindData(pfci->hida, iItem, szPath, &pfci->fd, FALSE) && pfci->bContinue; iItem++)
    {
        if (pfci->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            FolderSize(szPath, pfci);

            if (pfci->fMultipleFiles)
            {
                // for multiple file/folder properties, count myself
                pfci->cFolders++;
            }
        }
        else
        {   // file selected
            ULARGE_INTEGER ulSize, ulSizeOnDisk;
            DWORD dwClusterSize = PathGetClusterSize(szPath);

            // if compression is supported, we check to see if the file is sparse or compressed
            if (pfci->fIsCompressionAvailable && (pfci->fd.dwFileAttributes & (FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_SPARSE_FILE)))
            {
                ulSizeOnDisk.LowPart = SHGetCompressedFileSize(szPath, &ulSizeOnDisk.HighPart);
            }
            else
            {
                // not compressed or sparse, so just round to the cluster size
                ulSizeOnDisk.LowPart = pfci->fd.nFileSizeLow;
                ulSizeOnDisk.HighPart = pfci->fd.nFileSizeHigh;
                ulSizeOnDisk.QuadPart = ROUND_TO_CLUSTER(ulSizeOnDisk.QuadPart, dwClusterSize);
            }

            // add the size in
            ulSize.LowPart = pfci->fd.nFileSizeLow;
            ulSize.HighPart = pfci->fd.nFileSizeHigh;
            pfci->cbSize += ulSize.QuadPart;

            // add the size on disk in
            pfci->cbActualSize += ulSizeOnDisk.QuadPart;

            // increment the # of files
            pfci->cFiles++;
        }

        // set this so the progress bar knows how much total work there is to do

        // ISSUE RAID BUG - 120446 - Need to Guard access to pfci->ulTotalNumberOfBytes.QuadParts
        pfci->ulTotalNumberOfBytes.QuadPart = pfci->cbActualSize;
    }  // end of For Loop.


    if (pfci->bContinue && pfci->hDlg)
    {
        KillTimer(pfci->hDlg, IDT_SIZE);
        // make sure that there is a WM_TIMER message in the queue so we will get the "final" results
        PostMessage(pfci->hDlg, WM_TIMER, (WPARAM)IDT_SIZE, (LPARAM)NULL);
    }

    pfci->fIsSizeThreadAlive = FALSE;
    Release_FolderContentsInfo(pfci);
    return 0;
}

DWORD CALLBACK SizeThread_AddRefCallBack(void *pv)
{
    FOLDERCONTENTSINFO* pfci = (FOLDERCONTENTSINFO *)pv;
    AddRef_FolderContentsInfo(pfci);
    pfci->fIsSizeThreadAlive = TRUE;
    return 0;
}

void CreateSizeThread(FILEPROPSHEETPAGE * pfpsp)
{
    if (pfpsp->pfci->bContinue)
    {
        if (!pfpsp->pfci->fIsSizeThreadAlive)
        {
            SHCreateThread(SizeThreadProc, pfpsp->pfci, CTF_COINIT, SizeThread_AddRefCallBack);
        }
        else
        {
            // previous size thread still running, so bail
        }
    }
}

void KillSizeThread(FILEPROPSHEETPAGE * pfpsp)
{
    // signal the thread to stop
    pfpsp->pfci->bContinue = FALSE;
}


DWORD GetVolumeFlags(LPCTSTR pszPath, OUT OPTIONAL LPTSTR pszFileSys, int cchFileSys)
{
    TCHAR szRoot[MAX_PATH + 1];
    DWORD dwVolumeFlags = 0;

    /* Is this mounted point, e.g. c:\ or c:\hostfolder\ */
    if (!PathGetMountPointFromPath(pszPath, szRoot, ARRAYSIZE(szRoot)))
    {
        //no
        StringCchCopy(szRoot, ARRAYSIZE(szRoot), pszPath); // OK to truncate since we strip to root...
        PathStripToRoot(szRoot);
    }
    
    // GetVolumeInformation requires a trailing backslash.  Append one
    if (PathAddBackslash(szRoot))
    {
        if (pszFileSys)
            *pszFileSys = 0 ;

        if (!GetVolumeInformation(szRoot, NULL, 0, NULL, NULL, &dwVolumeFlags, pszFileSys, cchFileSys))
        {
            dwVolumeFlags = 0; 
        }
    }
    
    return dwVolumeFlags;
}


//
// This function sets the initial file attributes based on the dwFlagsAND / dwFlagsOR
// for the multiple file case
//
void SetInitialFileAttribs(FILEPROPSHEETPAGE* pfpsp, DWORD dwFlagsAND, DWORD dwFlagsOR)
{
    DWORD dwTriState = dwFlagsAND ^ dwFlagsOR; // this dword now has all the bits that are in the BST_INDETERMINATE state
#ifdef DEBUG
    // the pfpsp struct should have been zero inited, make sure that our ATTRIBUTESTATE
    // structs are zero inited
    ATTRIBUTESTATE asTemp = {0};
    ASSERT(memcmp(&pfpsp->asInitial, &asTemp, sizeof(pfpsp->asInitial)) == 0);
#endif // DEBUG

    // set the inital state based on the flags
    if (dwTriState & FILE_ATTRIBUTE_READONLY)
    {
        pfpsp->asInitial.fReadOnly = BST_INDETERMINATE;
    }
    else if (dwFlagsAND & FILE_ATTRIBUTE_READONLY)
    {
        pfpsp->asInitial.fReadOnly = BST_CHECKED;
    }

    if (dwTriState & FILE_ATTRIBUTE_HIDDEN)
    {
        pfpsp->asInitial.fHidden = BST_INDETERMINATE;
    }
    else if (dwFlagsAND & FILE_ATTRIBUTE_HIDDEN)
    {
        pfpsp->asInitial.fHidden = BST_CHECKED;
    }

    if (dwTriState & FILE_ATTRIBUTE_ARCHIVE)
    {
        pfpsp->asInitial.fArchive = BST_INDETERMINATE;
    }
    else if (dwFlagsAND & FILE_ATTRIBUTE_ARCHIVE)
    {
        pfpsp->asInitial.fArchive = BST_CHECKED;
    }

    if (dwTriState & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED)
    {
        pfpsp->asInitial.fIndex = BST_INDETERMINATE;
    }
    else if (!(dwFlagsAND & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED))
    {
        pfpsp->asInitial.fIndex = BST_CHECKED;
    }

    if (dwTriState & FILE_ATTRIBUTE_COMPRESSED)
    {
        pfpsp->asInitial.fCompress = BST_INDETERMINATE;
    }
    else if (dwFlagsAND & FILE_ATTRIBUTE_COMPRESSED)
    {
        pfpsp->asInitial.fCompress = BST_CHECKED;
    }

    if (dwTriState & FILE_ATTRIBUTE_ENCRYPTED)
    {
        pfpsp->asInitial.fEncrypt = BST_INDETERMINATE;
    }
    else if (dwFlagsAND & FILE_ATTRIBUTE_ENCRYPTED)
    {
        pfpsp->asInitial.fEncrypt = BST_CHECKED;
    }
}


//
// Updates the size fields for single and multiple file property sheets.
//
// NOTE: if you have the the WIN32_FIND_DATA already, then pass it for perf
//
STDAPI_(void) UpdateSizeField(FILEPROPSHEETPAGE* pfpsp, WIN32_FIND_DATA* pfd)
{
    WIN32_FIND_DATA wfd;

    if (pfpsp->pfci->fMultipleFiles)
    {
        // multiple selection case
        // create the size and # of files thread
        CreateSizeThread(pfpsp);
    }
    else
    {
        // if the caller didn't pass pfd, then go get the WIN32_FIND_DATA now
        if (!pfd)
        {
            HANDLE hFind = FindFirstFile(pfpsp->szPath, &wfd);

            if (hFind == INVALID_HANDLE_VALUE)
            {
                // if this failed we should clear out all the values as to not show garbage on the screen.
                ZeroMemory(&wfd, sizeof(wfd));
            }
            else
            {
                FindClose(hFind);
            }

            pfd = &wfd;
        }

        if (pfpsp->fMountedDrive)
        {
            // mounted drive case
            SetDateTimeText(pfpsp->hDlg, IDD_CREATED, &pfd->ftCreationTime);
        }
        else if (pfpsp->fIsDirectory)
        {
            // single folder case, in the UI we call this "Modified"
            // but since NTFS updates ftModified when the contents of the
            // folder changes (FAT does not) we use ftCreationTime as the
            // stable end user notiion of "Modified"
            SetDateTimeText(pfpsp->hDlg, IDD_CREATED, &pfd->ftCreationTime);

            // create the size and # of files thread
            CreateSizeThread(pfpsp);
        }
        else
        {
            TCHAR szNum1[MAX_COMMA_AS_K_SIZE];
            TCHAR szNum2[MAX_COMMA_NUMBER_SIZE];
            ULARGE_INTEGER ulSize = { pfd->nFileSizeLow, pfd->nFileSizeHigh };
            DWORD dwClusterSize = PathGetClusterSize(pfpsp->szPath);

            // fill in the "Size:" field
            LPTSTR pszFmt = ShellConstructMessageString(HINST_THISDLL,
                                                 MAKEINTRESOURCE(ulSize.QuadPart ? IDS_SIZEANDBYTES : IDS_SIZE),
                                                 ShortSizeFormat64(ulSize.QuadPart, szNum1, ARRAYSIZE(szNum1)),
                                                 AddCommas64(ulSize.QuadPart, szNum2, ARRAYSIZE(szNum2)));
            if (pszFmt)
            {
                SetDlgItemText(pfpsp->hDlg, IDD_FILESIZE, pszFmt);
                LocalFree(pszFmt);
            }

            //
            // fill in the "Size on disk:" field
            //
            if (pfd->dwFileAttributes & (FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_SPARSE_FILE))
            {
                // the file is compressed or sparse, so for "size on disk" use the compressed size
                ulSize.LowPart = SHGetCompressedFileSize(pfpsp->szPath, &ulSize.HighPart);
            }
            else
            {
                // the file isint comrpessed so just round to the cluster size for the "size on disk"
                ulSize.LowPart = pfd->nFileSizeLow;
                ulSize.HighPart = pfd->nFileSizeHigh;
                ulSize.QuadPart = ROUND_TO_CLUSTER(ulSize.QuadPart, dwClusterSize);
            }

            pszFmt = ShellConstructMessageString(HINST_THISDLL,
                                                 MAKEINTRESOURCE(ulSize.QuadPart ? IDS_SIZEANDBYTES : IDS_SIZE),
                                                 ShortSizeFormat64(ulSize.QuadPart, szNum1, ARRAYSIZE(szNum1)),
                                                 AddCommas64(ulSize.QuadPart, szNum2, ARRAYSIZE(szNum2)));
            if (pszFmt && !pfpsp->fMountedDrive)
            {
                SetDlgItemText(pfpsp->hDlg, IDD_FILESIZE_COMPRESSED, pszFmt);
                LocalFree(pszFmt);
            }

            //
            // we always touch the file in the process of getting its info, so the
            // ftLastAccessTime is always TODAY, which makes this field pretty useless...

            // date and time
            SetDateTimeText(pfpsp->hDlg, IDD_CREATED,      &pfd->ftCreationTime);
            SetDateTimeText(pfpsp->hDlg, IDD_LASTMODIFIED, &pfd->ftLastWriteTime);
            {
                // FAT implementation doesn't support last accessed time (gets the date right, but not the time),
                // so we won't display it
                DWORD dwFlags = FDTF_LONGDATE | FDTF_RELATIVE;

                if (NULL == StrStrI(pfpsp->szFileSys, TEXT("FAT")))
                    dwFlags |= FDTF_LONGTIME;   // for non FAT file systems

                SetDateTimeTextEx(pfpsp->hDlg, IDD_LASTACCESSED, &pfd->ftLastAccessTime, dwFlags);
            }
        }
    }
}


//
// Descriptions:
//   This function fills fields of the multiple object property sheet.
//
BOOL InitMultiplePrsht(FILEPROPSHEETPAGE* pfpsp)
{
    SHFILEINFO sfi;
    TCHAR szBuffer[MAX_PATH+1];
    BOOL fMultipleType = FALSE;
    BOOL fSameLocation = TRUE;
    DWORD dwFlagsOR = 0;                // start all clear
    DWORD dwFlagsAND = (DWORD)-1;       // start all set
    DWORD dwVolumeFlagsAND = (DWORD)-1; // start all set

    TCHAR szType[MAX_PATH];
    TCHAR szDirPath[MAX_PATH];
    szDirPath[0] = 0;
    szType[0] = 0;

    // For all the selected files compare their types and get their attribs
    for (int iItem = 0; HIDA_FillFindData(pfpsp->pfci->hida, iItem, szBuffer, NULL, FALSE); iItem++)
    {
        DWORD dwFileAttributes = GetFileAttributes(szBuffer);

        dwFlagsAND &= dwFileAttributes;
        dwFlagsOR  |= dwFileAttributes;

        // process types only if we haven't already found that there are several types
        if (!fMultipleType)
        {
            SHGetFileInfo((LPTSTR)IDA_GetIDListPtr((LPIDA)GlobalLock(pfpsp->pfci->hida), iItem), 0,
                &sfi, sizeof(sfi), SHGFI_PIDL|SHGFI_TYPENAME);

            if (szType[0] == 0)
                StrCpyN(szType, sfi.szTypeName, ARRAYSIZE(szType));
            else
                
                fMultipleType = lstrcmp(szType, sfi.szTypeName) != 0;
        }

        dwVolumeFlagsAND &= GetVolumeFlags(szBuffer, pfpsp->szFileSys, ARRAYSIZE(pfpsp->szFileSys));
        // check to see if the files are in the same location
        if (fSameLocation)
        {
            PathRemoveFileSpec(szBuffer);

            if (szDirPath[0] == 0)
                StrCpyN(szDirPath, szBuffer, ARRAYSIZE(szDirPath));
            else
                fSameLocation = (lstrcmpi(szDirPath, szBuffer) == 0);
        }
    }

    if ((dwVolumeFlagsAND & FS_FILE_ENCRYPTION) && !SHRestricted(REST_NOENCRYPTION))
    {
        // all the files are on volumes that support encryption (eg NTFS)
        pfpsp->fIsEncryptionAvailable = TRUE;
    }

    if (dwVolumeFlagsAND & FS_FILE_COMPRESSION)
    {
        pfpsp->pfci->fIsCompressionAvailable = TRUE;
    }

    //
    // HACK (reinerf) - we dont have a FS_SUPPORTS_INDEXING so we
    // use the FILE_SUPPORTS_SPARSE_FILES flag, because native index support
    // appeared first on NTFS5 volumes, at the same time sparse file support
    // was implemented.
    //
    if (dwVolumeFlagsAND & FILE_SUPPORTS_SPARSE_FILES)
    {
        // yup, we are on NTFS5 or greater
        pfpsp->fIsIndexAvailable = TRUE;
    }

    // if any of the files was a directory, then we set this flag
    if (dwFlagsOR & FILE_ATTRIBUTE_DIRECTORY)
    {
        pfpsp->fIsDirectory = TRUE;
    }

    // setup all the flags based on what we found out
    SetInitialFileAttribs(pfpsp, dwFlagsAND, dwFlagsOR);

    // set the current attributes to the same as the initial
    pfpsp->asCurrent = pfpsp->asInitial;

    //
    // now setup all the controls on the dialog based on the attribs
    // that we have
    //

    // check for multiple file types
    if (fMultipleType)
    {
        LoadString(HINST_THISDLL, IDS_MULTIPLETYPES, szBuffer, ARRAYSIZE(szBuffer));
    }
    else
    {
        LoadString(HINST_THISDLL, IDS_ALLOFTYPE, szBuffer, ARRAYSIZE(szBuffer));
        StringCchCat(szBuffer, ARRAYSIZE(szBuffer), szType);
    }
    SetDlgItemText(pfpsp->hDlg, IDD_FILETYPE, szBuffer);

    if (fSameLocation)
    {
        LoadString(HINST_THISDLL, IDS_ALLIN, szBuffer, ARRAYSIZE(szBuffer));
        StringCchCat(szBuffer, ARRAYSIZE(szBuffer), szDirPath);
        StrCpyN(pfpsp->szPath, szDirPath, ARRAYSIZE(pfpsp->szPath));
    }
    else
    {
        LoadString(HINST_THISDLL, IDS_VARFOLDERS, szBuffer, ARRAYSIZE(szBuffer));
    }

    //Keep Functionality same as NT4 by avoiding PathCompactPath. 
    SetDlgItemTextWithToolTip(pfpsp->hDlg, IDD_LOCATION, szBuffer, &pfpsp->hwndTip);

    //
    // check the ReadOnly and Hidden checkboxes, they always appear on the general tab
    //
    if (pfpsp->asInitial.fReadOnly == BST_INDETERMINATE)
    {
        SendDlgItemMessage(pfpsp->hDlg, IDD_READONLY, BM_SETSTYLE, BS_AUTO3STATE, 0);
    }
    CheckDlgButton(pfpsp->hDlg, IDD_READONLY, pfpsp->asCurrent.fReadOnly);

    if (pfpsp->asInitial.fHidden == BST_INDETERMINATE)
    {
        SendDlgItemMessage(pfpsp->hDlg, IDD_HIDDEN, BM_SETSTYLE, BS_AUTO3STATE, 0);
    }
    CheckDlgButton(pfpsp->hDlg, IDD_HIDDEN, pfpsp->asCurrent.fHidden);

    // to avoid people making SYSTEM files HIDDEN (SYSTEM HIDDEN files are
    // never show to the user) we don't let people make SYSTEM files HIDDEN
    if (dwFlagsOR & FILE_ATTRIBUTE_SYSTEM)
        EnableWindow(GetDlgItem(pfpsp->hDlg, IDD_HIDDEN), FALSE);

    // Archive is only on the general tab for FAT, otherwise it is under the "Advanced attributes"
    // and FAT volumes dont have the "Advanced attributes" button.
    if (pfpsp->pfci->fIsCompressionAvailable || pfpsp->fIsEncryptionAvailable)
    {
        // if compression is available, then we must be on NTFS
        DestroyWindow(GetDlgItem(pfpsp->hDlg, IDD_ARCHIVE));
    }
    else
    {
        // we are on FAT/FAT32, so get rid of the "Advanced attributes" button, and set the inital Archive state
        DestroyWindow(GetDlgItem(pfpsp->hDlg, IDC_ADVANCED));

        if (pfpsp->asInitial.fArchive == BST_INDETERMINATE)
        {
            SendDlgItemMessage(pfpsp->hDlg, IDD_ARCHIVE, BM_SETSTYLE, BS_AUTO3STATE, 0);
        }
        CheckDlgButton(pfpsp->hDlg, IDD_ARCHIVE, pfpsp->asCurrent.fArchive);
    }

    UpdateSizeField(pfpsp, NULL);

    return TRUE;
}

void Free_DlgDependentFilePropSheetPage(FILEPROPSHEETPAGE* pfpsp)
{
    // this frees the members that are dependent on pfpsp->hDlg still
    // being valid

    if (pfpsp)
    {
        ASSERT(IsWindow(pfpsp->hDlg));  // our window had better still be valid!

        ReplaceDlgIcon(pfpsp->hDlg, IDD_ITEMICON, NULL);

        if (pfpsp->pfci && !pfpsp->pfci->fMultipleFiles)
        {
            // single-file specific members
            if (!pfpsp->fIsDirectory)
            {
                // cleanup the typeicon for non-folders
                ReplaceDlgIcon(pfpsp->hDlg, IDD_TYPEICON, NULL);
            }
        }
    }
}

void Free_DlgIndepFilePropSheetPage(FILEPROPSHEETPAGE *pfpsp)
{
    if (pfpsp)
    {
        IAssocStore* pas = (IAssocStore *)pfpsp->pAssocStore;
        if (pas)
        {
            delete pas;
            pfpsp->pAssocStore = NULL;
        }

        Release_FolderContentsInfo(pfpsp->pfci);
        pfpsp->pfci = NULL;

        ILFree(pfpsp->pidl);
        pfpsp->pidl = NULL;

        ILFree(pfpsp->pidlTarget);
        pfpsp->pidlTarget = NULL;
    }
}

//
// Descriptions:
//   Callback for the property sheet code
//
UINT CALLBACK FilePrshtCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    if (uMsg == PSPCB_RELEASE)
    {
        FILEPROPSHEETPAGE * pfpsp = (FILEPROPSHEETPAGE *)ppsp;

        // Careful!  pfpsp can be NULL in low memory situations
        if (pfpsp)
        {
            KillSizeThread(pfpsp);
            Free_DlgIndepFilePropSheetPage(pfpsp);
        }
    }

    return 1;
}

//
// DESCRIPTION:
//
//   Opens the file for compression.  It handles the case where a READONLY
//   file is trying to be compressed or uncompressed.  Since read only files
//   cannot be opened for WRITE_DATA, it temporarily resets the file to NOT
//   be READONLY in order to open the file, and then sets it back once the
//   file has been compressed.
//
//   Taken from WinFile module wffile.c without change.  Originally from
//   G. Kimura's compact.c. Now taken from shcompui without change.
//
// ARGUMENTS:
//
//   phFile
//      Address of file handle variable for handle of open file if
//      successful.
//
//   szFile
//      Name string of file to be opened.
//
// RETURNS:
//
//    TRUE  = File successfully opened.  Handle in *phFile.
//    FALSE = File couldn't be opened. *phFile == INVALID_HANDLE_VALUE
//
///////////////////////////////////////////////////////////////////////////////
BOOL OpenFileForCompress(HANDLE *phFile, LPCTSTR szFile)
{
    //
    //  Try to open the file - READ_DATA | WRITE_DATA.
    //
    if ((*phFile = CreateFile(szFile,
                               FILE_READ_DATA | FILE_WRITE_DATA,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
                               NULL)) != INVALID_HANDLE_VALUE)
    {
        //
        //  Successfully opened the file.
        //
        return TRUE;
    }

    if (GetLastError() != ERROR_ACCESS_DENIED)
    {
        return FALSE;
    }

    //
    //  Try to open the file - READ_ATTRIBUTES | WRITE_ATTRIBUTES.
    //
    HANDLE hAttr = CreateFile(szFile,
                              FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL);
    
    if (hAttr == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    //
    //  See if the READONLY attribute is set.
    //
    BY_HANDLE_FILE_INFORMATION fi;
    if ((!GetFileInformationByHandle(hAttr, &fi)) ||
         (!(fi.dwFileAttributes & FILE_ATTRIBUTE_READONLY)))
    {
        //
        //  If the file could not be open for some reason other than that
        //  the readonly attribute was set, then fail.
        //
        CloseHandle(hAttr);
        return FALSE;
    }

    //
    //  Turn OFF the READONLY attribute.
    //
    fi.dwFileAttributes &= ~FILE_ATTRIBUTE_READONLY;
    if (!SetFileAttributes(szFile, fi.dwFileAttributes))
    {
        CloseHandle(hAttr);
        return FALSE;
    }

    //
    //  Try again to open the file - READ_DATA | WRITE_DATA.
    //
    *phFile = CreateFile(szFile,
                          FILE_READ_DATA | FILE_WRITE_DATA,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL);

    //
    //  Close the file handle opened for READ_ATTRIBUTE | WRITE_ATTRIBUTE.
    //
    CloseHandle(hAttr);

    //
    //  Make sure the open succeeded.  If it still couldn't be opened with
    //  the readonly attribute turned off, then fail.
    //
    if (*phFile == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    //
    //  Turn the READONLY attribute back ON.
    //
    fi.dwFileAttributes |= FILE_ATTRIBUTE_READONLY;
    if (!SetFileAttributes(szFile, fi.dwFileAttributes))
    {
        CloseHandle(*phFile);
        *phFile = INVALID_HANDLE_VALUE;
        return FALSE;
    }

    //
    //  Return success.  A valid file handle is in *phFile.
    //
    return TRUE;
}


// One half second (500 ms = 0.5s)
#define ENCRYPT_RETRY_PERIOD       500
// Retry 4 times (at least 2s)
#define ENCRYPT_MAX_RETRIES         4

//
//  This function encrypts/decrypts a file. If the readonly bit is set, the
//  function will clear it and encrypt/decrypt and then set the RO bit back
//  We will also remove/replace the system bit for known encryptable system
//  files
//
//  szPath      a string that has the full path to the file
//  fCompress   TRUE  - compress the file
//              FALSE - decompress the file
//
//
//  return:     TRUE  - the file was sucessfully encryped/decryped
//              FALSE - the file could not be encryped/decryped
//
STDAPI_(BOOL) SHEncryptFile(LPCTSTR pszPath, BOOL fEncrypt)
{
    BOOL bRet = fEncrypt ? EncryptFile(pszPath) : DecryptFile(pszPath, 0);

    if (!bRet)
    {
        DWORD dwLastError = GetLastError();
        DWORD dwAttribs = GetFileAttributes(pszPath);

        // Check to see if the attributes are blocking the encryption and we can change them
        if (dwAttribs & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY))
        {
            BOOL fStripAttribs = TRUE;
            if (dwAttribs & FILE_ATTRIBUTE_SYSTEM)
            {
                fStripAttribs = FALSE;

                // We can only strip attributes if it is a know encryptable system file
                WCHAR szStream[MAX_PATH];
                if (SUCCEEDED(StringCchCopy(szStream, ARRAYSIZE(szStream), pszPath)) &&
                    SUCCEEDED(StringCchCat(szStream, ARRAYSIZE(szStream), TEXT(":encryptable"))))
                {
                    HANDLE hStream = CreateFile(szStream, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
                    if (hStream != INVALID_HANDLE_VALUE)
                    {
                        CloseHandle(hStream);
                        fStripAttribs = TRUE;
                    }
                }
            }

            if (fStripAttribs)
            {
                if (SetFileAttributes(pszPath, dwAttribs & ~FILE_ATTRIBUTE_READONLY & ~FILE_ATTRIBUTE_SYSTEM))
                {
                    int i = 0;
                    bRet = fEncrypt ? EncryptFile(pszPath) : DecryptFile(pszPath, 0);
                    while (!bRet && i < ENCRYPT_MAX_RETRIES)
                    {
                        i++;
                        Sleep(ENCRYPT_RETRY_PERIOD);
                        bRet = fEncrypt ? EncryptFile(pszPath) : DecryptFile(pszPath, 0);
                    }
                    SetFileAttributes(pszPath, dwAttribs);
                }
            }
        }

        // If we failed after all this, make sure we return the right error code
        if (!bRet)
        {
            ASSERT(dwLastError != ERROR_SUCCESS);
            SetLastError(dwLastError);
        }
    }

    return bRet;
}

//
//  This function compresses/uncompresses a file.
//
//  szPath      a string that has the full path to the file
//  fCompress   TRUE  - compress the file
//              FALSE - decompress the file
//
//
//  return:     TRUE  - the file was sucessfully compressed/uncompressed
//              FALSE - the file could not be compressed/uncompressed
//
BOOL CompressFile(LPCTSTR pzsPath, BOOL fCompress)
{
    DWORD dwAttribs = GetFileAttributes(pzsPath);

    if (dwAttribs & FILE_ATTRIBUTE_ENCRYPTED)
    {
        // We will fail to compress/decompress the file if is encryped. We don't want
        // to bother the user w/ error messages in this case (since encryption "takes
        // presidence" over compression), so we just return success.
        return TRUE;
    }

    HANDLE hFile;
    if (OpenFileForCompress(&hFile, pzsPath))
    {
        USHORT uState = fCompress ? COMPRESSION_FORMAT_DEFAULT : COMPRESSION_FORMAT_NONE;
        ULONG Length;
        BOOL bRet = DeviceIoControl(hFile,
                               FSCTL_SET_COMPRESSION,
                               &uState,
                               sizeof(USHORT),
                               NULL,
                               0,
                               &Length,
                               FALSE);
        CloseHandle(hFile);
        return bRet;
    }
    else
    {
        // couldnt get a file handle
        return FALSE;
    }
}

BOOL IsValidFileName(LPCTSTR pszFileName)
{
    if (!pszFileName || !pszFileName[0])
    {
        return FALSE;
    }

    LPCTSTR psz = pszFileName;
    do
    {
        // we are only passed the file name, so its ok to use PIVC_LFN_NAME
        if (!PathIsValidChar(*psz, PIVC_LFN_NAME))
        {
            // found a non-legal character
            return FALSE;
        }

        psz = CharNext(psz);
    }
    while (*psz);

    // didn't find any illegal characters
    return TRUE;
}


// renames the file, or checks to see if it could be renamed if fCommit == FALSE
BOOL ApplyRename(FILEPROPSHEETPAGE* pfpsp, BOOL fCommit)
{
    ASSERT(pfpsp->fRename);

    TCHAR szNewName[MAX_PATH];
    Edit_GetText(GetDlgItem(pfpsp->hDlg, IDD_NAMEEDIT), szNewName, ARRAYSIZE(szNewName));

    if (StrCmpC(pfpsp->szInitialName, szNewName) != 0)
    {
        // the name could be changed from C:\foo.txt to C:\FOO.txt, this is
        // technically the same name to PathFileExists, but we should allow it
        // anyway
        BOOL fCaseChange = (lstrcmpi(pfpsp->szInitialName, szNewName) == 0);

        // get the dir where the file lives
        TCHAR szDir[MAX_PATH];
        if (FAILED(StringCchCopy(szDir, ARRAYSIZE(szDir), pfpsp->szPath)))
            return FALSE;
        PathRemoveFileSpec(szDir);

        // find out the old name with the extension (we cant use pfpsp->szInitialName here,
        // because it might not have had the extension depending on the users view|options settings)
        LPCTSTR pszOldName = PathFindFileName(pfpsp->szPath);

        if (!pfpsp->fShowExtension)
        {
            // the extension is hidden, so add it to the new path the user typed
            LPCTSTR pszExt = PathFindExtension(pfpsp->szPath);
            if (*pszExt)
            {
                // Note that we can't call PathAddExtension, because it removes the existing extension.
                if (FAILED(StringCchCat(szNewName, ARRAYSIZE(szNewName), pszExt)))
                    return FALSE;
            }
        }

        // is this a test or is it the real thing? (test needed so we can put up error UI before we get
        // the PSN_LASTCHANCEAPPLY)
        if (fCommit)
        {
            if (SHRenameFileEx(pfpsp->hDlg, NULL, szDir, pszOldName, szNewName) == ERROR_SUCCESS)
            {
                SHChangeNotify(SHCNE_RENAMEITEM, SHCNF_FLUSH | SHCNF_PATH, pszOldName, szNewName);
            }
            else
            {
                return FALSE;   // dont need error ui because SHRenameFile takes care of that for us.
            }
        }
        else
        {
            TCHAR szNewPath[MAX_PATH];
            PathCombine(szNewPath, szDir, szNewName);

            if (!IsValidFileName(szNewName) || (PathFileExists(szNewPath) && !fCaseChange))
            {
                LRESULT lRet = SHRenameFileEx(pfpsp->hDlg, NULL, szDir, pszOldName, szNewName);

                if (lRet == ERROR_SUCCESS)
                {
                    // Whoops, I guess we really CAN rename the file (this case can happen if the user
                    // tries to add a whole bunch of .'s to the end of a folder name).

                    // Rename it back so we can succeed when we call this fn. again with fCommit = TRUE;
                    lRet = SHRenameFileEx(NULL, NULL, szDir, szNewName, pszOldName);
                    ASSERT(lRet == ERROR_SUCCESS);

                    return TRUE;
                }

                // SHRenameFileEx put up the error UI for us, so just return false.
                return FALSE;
            }
        }
        // we dont bother doing anything if the rename succeeded since we only do renames
        // if the dialog is about to close (user hit "ok")
    }
    return TRUE;
}


//
// this is the dlg proc for Attribute Errors
//
//   returns
//
//      IDCANCEL                - user clicked abort
//      IDRETRY                 - user clicked retry
//      IDIGNORE                - user clicked ignore
//      IDIGNOREALL             - user clikced ignore all
//
BOOL_PTR CALLBACK FailedApplyAttribDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            ATTRIBUTEERROR* pae = (ATTRIBUTEERROR*)lParam;

            TCHAR szPath[MAX_PATH];
            StrCpyN(szPath, pae->pszPath, ARRAYSIZE(szPath));

            // Modify very long path names so that they fit into the message box.
            // get the size of the text boxes
            RECT rc;
            GetWindowRect(GetDlgItem(hDlg, IDD_NAME), &rc);
            PathCompactPath(NULL, szPath, rc.right - rc.left);

            SetDlgItemText(hDlg, IDD_NAME, szPath);

            // Default message if FormatMessage doesn't recognize dwLastError
            TCHAR szTemplate[MAX_PATH];
            LoadString(HINST_THISDLL, IDS_UNKNOWNERROR, szTemplate, ARRAYSIZE(szTemplate));
            TCHAR szErrorMsg[MAX_PATH];
            StringCchPrintf(szErrorMsg, ARRAYSIZE(szErrorMsg), szTemplate, pae->dwLastError);

            // Try the system error message
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 
                                NULL, pae->dwLastError, 0, szErrorMsg, ARRAYSIZE(szErrorMsg), NULL);

            SetDlgItemText(hDlg, IDD_ERROR_TXT, szErrorMsg);
            EnableWindow(hDlg, TRUE);
            break;
        }

        case WM_COMMAND:
        {
            UINT uCtrlID = GET_WM_COMMAND_ID(wParam, lParam);
            switch (uCtrlID)
            {
                case IDIGNOREALL:   // = 10  (this comes from shell32.rc, the rest come from winuser.h)
                case IDCANCEL:      // = 2
                case IDRETRY:       // = 4
                case IDIGNORE:      // = 5
                    EndDialog(hDlg, uCtrlID);
                    return TRUE;
                    break;

                default:
                    return FALSE;
            }
            break;
        }
        default :
            return FALSE;
    }
    return FALSE;
}


//
// This function displays the "and error has occured [abort] [retry] [ignore] [ignore all]" message
// If the user hits abort, then we return FALSE so that our caller knows to abort the operation
//
//  returns the id of the button pressed (one of: IDIGNOREALL, IDIGNORE, IDCANCEL, IDRETRY)
//
int FailedApplyAttribsErrorDlg(HWND hWndParent, ATTRIBUTEERROR* pae)
{
    //  Put up the error message box - ABORT, RETRY, IGNORE, IGNORE ALL.
    int iRet = (int)DialogBoxParam(HINST_THISDLL,
                          MAKEINTRESOURCE(DLG_ATTRIBS_ERROR),
                          hWndParent,
                          FailedApplyAttribDlgProc,
                          (LPARAM)pae);
    //
    // if the user hits the ESC key or the little X thingy, then
    // iRet = 0, so we set iRet = IDCANCEL
    //
    if (!iRet)
    {
        iRet = IDCANCEL;
    }

    return iRet;
}

//
// we check to see if this is a known bad file that we skip applying attribs to
//
BOOL IsBadAttributeFile(LPCTSTR pszFile, FILEPROPSHEETPAGE* pfpsp)
{
    const static LPTSTR s_rgszBadFiles[] = {
        {TEXT("pagefile.sys")},
        {TEXT("hiberfil.sys")},
        {TEXT("ntldr")},
        {TEXT("ntdetect.com")},
        {TEXT("explorer.exe")},
        {TEXT("System Volume Information")},
        {TEXT("cmldr")},
        {TEXT("desktop.ini")},
        {TEXT("ntuser.dat")},
        {TEXT("ntuser.dat.log")},
        {TEXT("ntuser.pol")},
        {TEXT("usrclass.dat")},
        {TEXT("usrclass.dat.log")}};

    LPTSTR pszFileName = PathFindFileName(pszFile);
    for (int i = 0; i < ARRAYSIZE(s_rgszBadFiles); i++)
    {
        if (lstrcmpi(s_rgszBadFiles[i], pszFileName) == 0)
        {
            // this file matched on of the "bad" files that we dont apply attributes to
            return TRUE;
        }
    }

    // ok to muck with this file
    return FALSE;
}

// This is the encryption warning callback dlg proc

BOOL_PTR CALLBACK EncryptionWarningDlgProc(HWND hDlgWarning, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            LPCTSTR pszPath = (LPCTSTR)lParam;

            SetWindowPtr(hDlgWarning, DWLP_USER, (void*) pszPath);

            // set the initial state of the radio buttons
            CheckDlgButton(hDlgWarning, IDC_ENCRYPT_PARENTFOLDER, TRUE);
            break;
        }

        case WM_COMMAND:
        {
            if ((LOWORD(wParam) == IDOK) && (IsDlgButtonChecked(hDlgWarning, IDC_ENCRYPT_PARENTFOLDER) == BST_CHECKED))
            {
                LPTSTR pszPath = (LPTSTR) GetWindowPtr(hDlgWarning, DWLP_USER);

                if (pszPath)
                {
                    LPITEMIDLIST pidl = ILCreateFromPath(pszPath);

                    if (pidl)
                    {
                        SHChangeNotifySuspendResume(TRUE, pidl, TRUE, 0);
                    }

RetryEncryptParentFolder:
                    if (!SHEncryptFile(pszPath, TRUE))
                    {
                        ATTRIBUTEERROR ae = {pszPath, GetLastError()};

                        if (FailedApplyAttribsErrorDlg(hDlgWarning, &ae) == IDRETRY)
                        {
                            goto RetryEncryptParentFolder;
                        }
                    }

                    if (pidl)
                    {
                        SHChangeNotifySuspendResume(FALSE, pidl, TRUE, 0);
                        ILFree(pidl);
                    }
                }
            }
            break;
        }
    }

    // we want the MessageBoxCheckExDlgProc have a crack at everything as well,
    // so return false here
    return FALSE;
}

//
// This function warns the user that they are encrypting a file that is not in and encrypted
// folder. Most editors (MS word included), do a "safe-save" where they rename the file being
// edited, and then save the new modified version out, and then delete the old original. This
// causes an encrypted document that is NOT in an encrypted folder to become decrypted so we
// warn the user here.
//
// returns:
//          TRUE  - the user hit "ok" (either compress just the file, or the parent folder as well)
//          FALSE - the user hit "cancel"
//
int WarnUserAboutDecryptedParentFolder(LPCTSTR pszPath, HWND hWndParent)
{
    // check for the root case (no parent), or the directory case
    if (PathIsRoot(pszPath) || PathIsDirectory(pszPath))
        return TRUE;

    int iRet = IDOK; // assume everything is okidokey

    // first check to see if the parent folder is encrypted
    TCHAR szParentFolder[MAX_PATH];
    StringCchCopy(szParentFolder, ARRAYSIZE(szParentFolder), pszPath);
    PathRemoveFileSpec(szParentFolder);

    DWORD dwAttribs = GetFileAttributes(szParentFolder);
    if ((dwAttribs != (DWORD)-1) && !(dwAttribs & FILE_ATTRIBUTE_ENCRYPTED) && !PathIsRoot(szParentFolder))
    {
        // the parent folder is NOT encrypted and the parent folder isin't the root, so warn the user
        iRet = SHMessageBoxCheckEx(hWndParent, HINST_THISDLL, MAKEINTRESOURCE(DLG_ENCRYPTWARNING), EncryptionWarningDlgProc,
                                  (void *)szParentFolder, IDOK, TEXT("EncryptionWarning"));
    }

    return (iRet == IDOK);
}

//
// Sets attributes of a file based on the info in pfpsp
//
//  szFilename  -  the name of the file to compress
//
//  pfpsp       -  the filepropsheetpage info
//
//  hwndParent  -  Parent hwnd in case we need to put up some ui
//
//  pbSomethingChanged - pointer to a bool that says whether or not something actually was
//                       changed during the operation.
//                       TRUE  - we applied at leaset one attribute
//                       FALSE - we didnt change anything (either an error or all the attribs already matched)
//
//  return value: TRUE  - the operation was sucessful
//                FALSE - there was an error and the user hit cancel to abort the operation
//
//
// NOTE:    the caller of this function must take care of generating the SHChangeNotifies so that
//          we dont end up blindly sending them for every file in a dir (the caller will send
//          one for just that dir). That is why we have the pbSomethingChanged variable.
//
STDAPI_(BOOL) ApplyFileAttributes(LPCTSTR pszPath, FILEPROPSHEETPAGE* pfpsp, HWND hwndParent, BOOL* pbSomethingChanged)
{
    DWORD dwLastError = ERROR_SUCCESS;
    BOOL bCallSetFileAttributes = FALSE;
    LPITEMIDLIST pidl = NULL;
 
    // assume nothing changed to start with
    *pbSomethingChanged = 0;
    
    if ((pfpsp->fRecursive || pfpsp->pfci->fMultipleFiles) && IsBadAttributeFile(pszPath, pfpsp))
    {
        // we are doing a recursive operation or a multiple file operation, so we skip files
        // that we dont want to to mess with because they will ususally give error dialogs
        if (pfpsp->pProgressDlg)
        {
            // since we are skipping this file, we subtract its size from both
            // ulTotal and ulCompleted. This will make sure the progress bar isint
            // messed up by files like pagefile.sys who are huge but get "compressed"
            // in milliseconds.
            ULARGE_INTEGER ulTemp;

            ulTemp.LowPart = pfpsp->fd.nFileSizeLow;
            ulTemp.HighPart = pfpsp->fd.nFileSizeHigh;

            // guard against underflow
            if (pfpsp->ulNumberOfBytesDone.QuadPart < ulTemp.QuadPart)
            {
                pfpsp->ulNumberOfBytesDone.QuadPart = 0;
            }
            else
            {
                pfpsp->ulNumberOfBytesDone.QuadPart -= ulTemp.QuadPart;
            }

            pfpsp->pfci->ulTotalNumberOfBytes.QuadPart -= ulTemp.QuadPart;

            UpdateProgressBar(pfpsp);
        }

        // return telling the user everying is okidokey
        return TRUE;
    }

RetryApplyAttribs:
    DWORD dwInitialAttributes = GetFileAttributes(pszPath);

    if (dwInitialAttributes == -1)
    {
        // we were unable to get the file attribues, doh!
        dwLastError = GetLastError();
        goto RaiseErrorMsg;
    }

    if (pfpsp->pProgressDlg)
    {
        // update the progress dialog file name
        SetProgressDlgPath(pfpsp, pszPath, TRUE);
    }

    //
    // we only allow attribs that SetFileAttributes can handle
    //
    DWORD dwNewAttributes = (dwInitialAttributes & (FILE_ATTRIBUTE_READONLY               | 
                                                    FILE_ATTRIBUTE_HIDDEN                 | 
                                                    FILE_ATTRIBUTE_ARCHIVE                |
                                                    FILE_ATTRIBUTE_OFFLINE                |
                                                    FILE_ATTRIBUTE_SYSTEM                 |
                                                    FILE_ATTRIBUTE_TEMPORARY              |
                                                    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED));

    BOOL bIsSuperHidden = IS_SYSTEM_HIDDEN(dwInitialAttributes);

    if (pfpsp->asInitial.fReadOnly != pfpsp->asCurrent.fReadOnly)
    {
        // don't allow changing of folders read only bit, since this is a trigger
        // for shell special folder stuff like thumbnails, etc.
        if (!(dwInitialAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            if (pfpsp->asCurrent.fReadOnly)
            {
                dwNewAttributes |= FILE_ATTRIBUTE_READONLY;
            }
            else
            {
                dwNewAttributes &= ~FILE_ATTRIBUTE_READONLY;
            }

            bCallSetFileAttributes = TRUE;
        }
    }

    //
    // don't allow setting of hidden on system files, as this will make them disappear for good.
    //
    if (pfpsp->asInitial.fHidden != pfpsp->asCurrent.fHidden && !(dwNewAttributes & FILE_ATTRIBUTE_SYSTEM))
    {
        if (pfpsp->asCurrent.fHidden)
        {
            dwNewAttributes |= FILE_ATTRIBUTE_HIDDEN;
        }
        else
        {
            dwNewAttributes &= ~FILE_ATTRIBUTE_HIDDEN;
        }
            
        bCallSetFileAttributes = TRUE;
    }

    if (pfpsp->asInitial.fArchive != pfpsp->asCurrent.fArchive)
    {
        if (pfpsp->asCurrent.fArchive)
        {
            dwNewAttributes |= FILE_ATTRIBUTE_ARCHIVE;
        }
        else
        {
            dwNewAttributes &= ~FILE_ATTRIBUTE_ARCHIVE;
        }
        
        bCallSetFileAttributes = TRUE;
    }

    if (pfpsp->asInitial.fIndex != pfpsp->asCurrent.fIndex)
    {
        if (pfpsp->asCurrent.fIndex)
        {
            dwNewAttributes &= ~FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
        }
        else
        {
            dwNewAttributes |= FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
        }
        
        bCallSetFileAttributes = TRUE;
    }

    // did something change that we need to call SetFileAttributes for?
    if (bCallSetFileAttributes)
    {
        if (SetFileAttributes(pszPath, dwNewAttributes))
        {
            // success! set fSomethingChanged so we know to send out
            // a changenotify
            *pbSomethingChanged = TRUE;
        }
        else
        {
            // get the last error value now so we know why it failed
            dwLastError = GetLastError();
            goto RaiseErrorMsg;
        }
    }

    // We need to be careful about the order we compress/encrypt in since these
    // operations are mutually exclusive.
    // We therefore do the uncompressing/decrypting first
    if ((pfpsp->asInitial.fCompress != pfpsp->asCurrent.fCompress) &&
        (pfpsp->asCurrent.fCompress == BST_UNCHECKED))
    {
        if (!CompressFile(pszPath, FALSE))
        {
            // get the last error value now so we know why it failed
            dwLastError = GetLastError();
            goto RaiseErrorMsg;
        }
        else
        {
            // success
            *pbSomethingChanged = TRUE;
        }
    }

    if ((pfpsp->asInitial.fEncrypt != pfpsp->asCurrent.fEncrypt) &&
        (pfpsp->asCurrent.fEncrypt == BST_UNCHECKED))
    {
        BOOL fSucceeded = SHEncryptFile(pszPath, FALSE); // try to decrypt the file

        if (!fSucceeded)
        {
            // get the last error value now so we know why it failed
            dwLastError = GetLastError();

            if (ERROR_SHARING_VIOLATION == dwLastError)
            {
                // Encrypt/Decrypt needs exclusive access to the file, this is a problem if we
                // initiate encrypt for a folder from Explorer, then most probably the folder will
                // be opened.  We don't do "SHChangeNotifySuspendResume" right away for perf reasons,
                // we wait for it to fail and then we try again. (stephstm)

                ASSERT(pidl == NULL);
                pidl = ILCreateFromPath(pszPath);

                if (pidl)
                {
                    SHChangeNotifySuspendResume(TRUE, pidl, TRUE, 0);
                }

                // retry to decrypt after the suspend
                fSucceeded = SHEncryptFile(pszPath, FALSE);

                if (!fSucceeded)
                {
                    // get the last error value now so we know why it failed
                    dwLastError = GetLastError();
                }
            }
        }

        if (fSucceeded)
        {
            // success
            *pbSomethingChanged = TRUE;
            dwLastError = ERROR_SUCCESS;
        }
        else
        {
            ASSERT(dwLastError != ERROR_SUCCESS);
            goto RaiseErrorMsg;
        }
    }

    // now check for encrypt/compress
    if ((pfpsp->asInitial.fCompress != pfpsp->asCurrent.fCompress) &&
        (pfpsp->asCurrent.fCompress == BST_CHECKED))
    {
        if (!CompressFile(pszPath, TRUE))
        {
            // get the last error value now so we know why it failed
            dwLastError = GetLastError();
            goto RaiseErrorMsg;
        }
        else
        {
            // success
            *pbSomethingChanged = TRUE;
        }
    }

    if ((pfpsp->asInitial.fEncrypt != pfpsp->asCurrent.fEncrypt) &&
        (pfpsp->asCurrent.fEncrypt == BST_CHECKED))
    {
        // only prompt for encrypting the parent folder on non-recursive operations
        if (!pfpsp->fRecursive && !WarnUserAboutDecryptedParentFolder(pszPath, hwndParent))
        {
            // user cancled the operation
            return FALSE;
        }

        BOOL fSucceeded = SHEncryptFile(pszPath, TRUE); // try to encrypt the file

        if (!fSucceeded)
        {
            // get the last error value now so we know why it failed
            dwLastError = GetLastError();

            if (ERROR_SHARING_VIOLATION == dwLastError)
            {
                // Encrypt/Decrypt needs exclusive access to the file, this is a problem if we
                // initiate encrypt for a folder from Explorer, then most probably the folder will
                // be opened.  We don't do "SHChangeNotifySuspendResume" right away for perf reasons,
                // we wait for it to fail and then we try again. (stephstm)

                ASSERT(pidl == NULL);
                pidl = ILCreateFromPath(pszPath);

                if (pidl)
                {
                    SHChangeNotifySuspendResume(TRUE, pidl, TRUE, 0);
                }

                // retry to encrypt after the suspend
                fSucceeded = SHEncryptFile(pszPath, TRUE);

                if (!fSucceeded)
                {
                    // get the last error value now so we know why it failed
                    dwLastError = GetLastError();
                }
            }
        }

        if (fSucceeded)
        {
            // success
            *pbSomethingChanged = TRUE;
            dwLastError = ERROR_SUCCESS;
        }
        else
        {
            ASSERT(dwLastError != ERROR_SUCCESS);
            goto RaiseErrorMsg;
        }
    }

RaiseErrorMsg:

    if (pidl)
    {
        SHChangeNotifySuspendResume(FALSE, pidl, TRUE, 0);
        ILFree(pidl);
        pidl = NULL;
    }

    // if we are ignoring all errors or we dont have an hwnd to use as a parent,
    // then dont show any error msgs.
    if (pfpsp->fIgnoreAllErrors || !hwndParent)
    {
        dwLastError = ERROR_SUCCESS;
    }

    // If kernel threw up an error dialog (such as "the disk is write proctected")
    // and the user hit "abort" then return false to avoid a second error dialog
    if (dwLastError == ERROR_REQUEST_ABORTED)
    {
        return FALSE;
    }

    // put up the error dlg if necessary, but not for super hidden files
    if (dwLastError != ERROR_SUCCESS)
    {
        // !PathIsRoot is required, since the root path (eg c:\) is superhidden by default even after formatting a drive,
        // why the filesystem thinks that the root should be +s +r after a format is a mystery to me...
        if (bIsSuperHidden && !ShowSuperHidden() && !PathIsRoot(pszPath))
        {
            dwLastError = ERROR_SUCCESS;
        }
        else
        {
            ATTRIBUTEERROR ae;

            ae.pszPath = pszPath;
            ae.dwLastError = dwLastError;

            int iRet = FailedApplyAttribsErrorDlg(hwndParent, &ae);

            switch (iRet)
            {
                case IDRETRY:
                    // we clear out dwError and try again
                    dwLastError = ERROR_SUCCESS;
                    goto RetryApplyAttribs;
                    break;

                case IDIGNOREALL:
                    pfpsp->fIgnoreAllErrors = TRUE;
                    dwLastError = ERROR_SUCCESS;
                    break;

                case IDIGNORE:
                    dwLastError = ERROR_SUCCESS;
                    break;

                case IDCANCEL:
                default:
                    break;
            }
        }
    }

    // update the progress bar
    if (pfpsp->pProgressDlg)
    {
        ULARGE_INTEGER ulTemp;

        // it is the callers responsibility to make sure that pfpsp->fd is filled with
        // the proper information for the file we are applying attributes to.
        ulTemp.LowPart = pfpsp->fd.nFileSizeLow;
        ulTemp.HighPart = pfpsp->fd.nFileSizeHigh;

        pfpsp->ulNumberOfBytesDone.QuadPart += ulTemp.QuadPart;

        UpdateProgressBar(pfpsp);
    }

    return (dwLastError == ERROR_SUCCESS) ? TRUE : FALSE;
}

//
//  Set the text of a dialog item and attach a tooltip if necessary.
//
STDAPI_(void) SetDlgItemTextWithToolTip(HWND hDlg, UINT id, LPCTSTR pszText, HWND *phwnd)
{
    HWND hwnd = GetDlgItem(hDlg, id);
    if (hwnd)
    {
        SetWindowText(hwnd, pszText);
        RECT rc;
        HDC hDC;
        if (GetClientRect(hwnd, &rc) && (hDC = GetDC(hDlg)) != NULL)
        {
            HFONT hFont = GetWindowFont(hwnd);
            if (hFont)
            {
                // set the dlg font into the DC so we can calc the size
                hFont = (HFONT)SelectObject(hDC, hFont);

                SIZE size = {0};
                GetTextExtentPoint32(hDC, pszText, lstrlen(pszText), &size);
                // restore the prev. hFont
                SelectObject(hDC, hFont);

                if (size.cx > rc.right)
                {
                    // our text size is bigger than the dlg width, so its clipped
                    if (*phwnd == NULL)
                    {
                        *phwnd = CreateWindow(TOOLTIPS_CLASS,
                                              c_szNULL,
                                              WS_POPUP | TTS_NOPREFIX,
                                              CW_USEDEFAULT,
                                              CW_USEDEFAULT,
                                              CW_USEDEFAULT,
                                              CW_USEDEFAULT,
                                              hDlg,
                                              NULL,
                                              HINST_THISDLL,
                                              NULL);
                    }

                    if (*phwnd)
                    {
                        TOOLINFO ti;

                        ti.cbSize = sizeof(ti);
                        ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
                        ti.hwnd = hDlg;
                        ti.uId = (UINT_PTR)hwnd;
                        ti.lpszText = (LPTSTR)pszText;  // const -> non const
                        ti.hinst = HINST_THISDLL;
                        SendMessage(*phwnd, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
                    }
                }
            }
            ReleaseDC(hDlg, hDC);
        }
    }
}


void UpdateTriStateCheckboxes(FILEPROPSHEETPAGE* pfpsp)
{
    // we turn off tristate after applying attibs for those things that were tri-state
    // initially but are not anymore since we sucessfully applied the attributes

    if (pfpsp->hDlg)
    {
        if (pfpsp->asInitial.fReadOnly == BST_INDETERMINATE && pfpsp->asCurrent.fReadOnly != BST_INDETERMINATE)
        {
            SendDlgItemMessage(pfpsp->hDlg, IDD_READONLY, BM_SETSTYLE, BS_AUTOCHECKBOX, 0);
        }

        if (pfpsp->asInitial.fHidden == BST_INDETERMINATE && pfpsp->asCurrent.fHidden != BST_INDETERMINATE)
        {
            SendDlgItemMessage(pfpsp->hDlg, IDD_HIDDEN, BM_SETSTYLE, BS_AUTOCHECKBOX, 0);
        }

        // Archive is only on the general tab for files on FAT/FAT32 volumes
        if (!pfpsp->pfci->fIsCompressionAvailable && pfpsp->asInitial.fArchive == BST_INDETERMINATE && pfpsp->asCurrent.fArchive != BST_INDETERMINATE)
        {
            SendDlgItemMessage(pfpsp->hDlg, IDD_ARCHIVE, BM_SETSTYLE, BS_AUTOCHECKBOX, 0);
        }
    }
}

//
// This applies the attributes to the selected files (multiple file case)
//
// return value:
//      TRUE    We sucessfully applied all the attributes
//      FALSE   The user hit cancel, and we stoped
//
STDAPI_(BOOL) ApplyMultipleFileAttributes(FILEPROPSHEETPAGE* pfpsp)
{
    BOOL bRet = FALSE;

    // create the progress dialog.  This may fail if out of memory.  If it does fail, we will
    // abort the operation because it will also probably fail if out of memory.
    if (CreateAttributeProgressDlg(pfpsp))
    {
        BOOL bSomethingChanged = FALSE;

        bRet = TRUE;

        // make sure that HIDA_FillFindDatat returns the compressed size, else our progress est will be way off
        TCHAR szPath[MAX_PATH];
        for (int iItem = 0; HIDA_FillFindData(pfpsp->pfci->hida, iItem, szPath, &pfpsp->fd, TRUE); iItem++)
        {
            if (HasUserCanceledAttributeProgressDlg(pfpsp))
            {
                // the user hit cancel on the progress dlg, so stop
                bRet = FALSE;
                break;
            }

            if (pfpsp->fRecursive && (pfpsp->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                // apply attribs to the subfolders
                bRet = ApplyRecursiveFolderAttribs(szPath, pfpsp);

                // send out a notification for the whole dir, regardless if the user hit cancel since
                // something could have changed
                SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH, szPath, NULL);
            }
            else
            {
                HWND hwndParent = NULL;

                // if we have a progress hwnd, try to use it as our parent. This will fail
                // if the progress dialog isn't being displayed yet.
                IUnknown_GetWindow((IUnknown*)pfpsp->pProgressDlg, &hwndParent);

                if (!hwndParent)
                {
                    // the progress dlg isint here yet, so use the property page hwnd
                    hwndParent = GetParent(pfpsp->hDlg);
                }

                // apply the attribs to this item only
                bRet = ApplyFileAttributes(szPath, pfpsp, hwndParent, &bSomethingChanged);

                if (bSomethingChanged)
                {
                    // something changed, so send out a notification for that file
                    SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, szPath, NULL);
                    DeleteFileThumbnail(szPath);
                }
            }
        }

        // destroy the progress dialog
        DestroyAttributeProgressDlg(pfpsp);

        if (bRet)
        {
            // since we just sucessfully applied attribs, reset any tri-state checkboxes as necessary
            UpdateTriStateCheckboxes(pfpsp);

            // the user did NOT hit cancel, so update the prop sheet to reflect the new attribs
            pfpsp->asInitial = pfpsp->asCurrent;
        }

        // flush any change-notifications we generated
        SHChangeNotifyHandleEvents();
    }

    return bRet;
}


STDAPI_(BOOL) ApplySingleFileAttributes(FILEPROPSHEETPAGE* pfpsp)
{
    BOOL bRet = TRUE;
    BOOL bSomethingChanged = FALSE;

    if (!pfpsp->fRecursive)
    {
        bRet = ApplyFileAttributes(pfpsp->szPath, pfpsp, GetParent(pfpsp->hDlg), &bSomethingChanged);

        if (bSomethingChanged)
        {
            // something changed, so generate a notification for the item
            SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, pfpsp->szPath, NULL);
            DeleteFileThumbnail(pfpsp->szPath);
        }
    }
    else
    {
        // We only should be doing a recursive operation if we have a directory!
        ASSERT(pfpsp->fIsDirectory);

        // create the progress dialog.  This may fail if out of memory.  If it does fail, we will
        // abort the operation because it will also probably fail if out of memory.
        if (CreateAttributeProgressDlg(pfpsp))
        {
            // apply attribs to this folder & sub files/folders
            bRet = ApplyRecursiveFolderAttribs(pfpsp->szPath, pfpsp);

            // HACKHACK: send out a notification for the item so that defview will refresh properly
            SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, pfpsp->szPath, NULL);

            // send out a notification for the whole dir, regardless of the return value since
            // something could have changed even if the user hit cancel
            SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH, pfpsp->szPath, NULL);

            DestroyAttributeProgressDlg(pfpsp);
        }
        else
        {
            bRet = FALSE;
        }
    }

    if (bRet)
    {
        // since we just sucessfully applied attribs, reset any tri-state checkboxes as necessary
        UpdateTriStateCheckboxes(pfpsp);

        // the user did NOT hit cancel, so update the prop sheet to reflect the new attribs
        pfpsp->asInitial = pfpsp->asCurrent;

        // (reinerf) need to update the size fields (eg file was just compressed)
    }

    // handle any events we may have generated
    SHChangeNotifyHandleEvents();

    return bRet;
}

//
// this function sets the string that tells the user what attributes they are about to
// apply
//
BOOL SetAttributePromptText(HWND hDlgRecurse, FILEPROPSHEETPAGE* pfpsp)
{
    TCHAR szAttribsToApply[MAX_PATH];
    TCHAR szTemp[MAX_PATH];

    szAttribsToApply[0] = 0;

    if (pfpsp->asInitial.fReadOnly != pfpsp->asCurrent.fReadOnly)
    {
        if (pfpsp->asCurrent.fReadOnly)
            EVAL(LoadString(HINST_THISDLL, IDS_READONLY, szTemp, ARRAYSIZE(szTemp)));
        else
            EVAL(LoadString(HINST_THISDLL, IDS_NOTREADONLY, szTemp, ARRAYSIZE(szTemp)));

        StringCchCat(szAttribsToApply, ARRAYSIZE(szAttribsToApply), szTemp);
    }

    if (pfpsp->asInitial.fHidden != pfpsp->asCurrent.fHidden)
    {
        if (pfpsp->asCurrent.fHidden)
            EVAL(LoadString(HINST_THISDLL, IDS_HIDE, szTemp, ARRAYSIZE(szTemp)));
        else
            EVAL(LoadString(HINST_THISDLL, IDS_UNHIDE, szTemp, ARRAYSIZE(szTemp)));

        StringCchCat(szAttribsToApply, ARRAYSIZE(szAttribsToApply), szTemp);
    }

    if (pfpsp->asInitial.fArchive != pfpsp->asCurrent.fArchive)
    {
        if (pfpsp->asCurrent.fArchive)
            EVAL(LoadString(HINST_THISDLL, IDS_ARCHIVE, szTemp, ARRAYSIZE(szTemp)));
        else
            EVAL(LoadString(HINST_THISDLL, IDS_UNARCHIVE, szTemp, ARRAYSIZE(szTemp)));

        StringCchCat(szAttribsToApply, ARRAYSIZE(szAttribsToApply), szTemp);
    }

    if (pfpsp->asInitial.fIndex != pfpsp->asCurrent.fIndex)
    {
        if (pfpsp->asCurrent.fIndex)
            EVAL(LoadString(HINST_THISDLL, IDS_INDEX, szTemp, ARRAYSIZE(szTemp)));
        else
            EVAL(LoadString(HINST_THISDLL, IDS_DISABLEINDEX, szTemp, ARRAYSIZE(szTemp)));

        StringCchCat(szAttribsToApply, ARRAYSIZE(szAttribsToApply), szTemp);
    }

    if (pfpsp->asInitial.fCompress != pfpsp->asCurrent.fCompress)
    {
        if (pfpsp->asCurrent.fCompress)
            EVAL(LoadString(HINST_THISDLL, IDS_COMPRESS, szTemp, ARRAYSIZE(szTemp)));
        else
            EVAL(LoadString(HINST_THISDLL, IDS_UNCOMPRESS, szTemp, ARRAYSIZE(szTemp)));

        StringCchCat(szAttribsToApply, ARRAYSIZE(szAttribsToApply), szTemp);
    }

    if (pfpsp->asInitial.fEncrypt != pfpsp->asCurrent.fEncrypt)
    {
        if (pfpsp->asCurrent.fEncrypt)
            EVAL(LoadString(HINST_THISDLL, IDS_ENCRYPT, szTemp, ARRAYSIZE(szTemp)));
        else
            EVAL(LoadString(HINST_THISDLL, IDS_DECRYPT, szTemp, ARRAYSIZE(szTemp)));

        StringCchCat(szAttribsToApply, ARRAYSIZE(szAttribsToApply), szTemp);
    }

    if (!*szAttribsToApply)
    {
        // nothing changed bail
        return FALSE;
    }

    // remove the trailing ", "
    int iLength = lstrlen(szAttribsToApply);
    ASSERT(iLength >= 3);
    StringCchCopy(&szAttribsToApply[iLength - 2], ARRAYSIZE(szAttribsToApply) - iLength + 2, TEXT("\0"));

    SetDlgItemText(hDlgRecurse, IDD_ATTRIBSTOAPPLY, szAttribsToApply);
    return TRUE;
}


//
// This dlg proc is for the prompt to ask the user if they want to have their changes apply
// to only the directories, or all files/folders within the directories.
//
BOOL_PTR CALLBACK RecursivePromptDlgProc(HWND hDlgRecurse, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    FILEPROPSHEETPAGE* pfpsp = (FILEPROPSHEETPAGE *)GetWindowLongPtr(hDlgRecurse, DWLP_USER);

    switch (uMessage)
    {
        case WM_INITDIALOG:
        {
            SetWindowLongPtr(hDlgRecurse, DWLP_USER, lParam);
            pfpsp = (FILEPROPSHEETPAGE *)lParam;

            // set the initial state of the radio button
            CheckDlgButton(hDlgRecurse, IDD_RECURSIVE, TRUE);

            // set the IDD_ATTRIBSTOAPPLY based on what attribs we are applying
            if (!SetAttributePromptText(hDlgRecurse, pfpsp))
            {
                // we should not get here because we check for the no attribs
                // to apply earlier
                ASSERT(FALSE);

                EndDialog(hDlgRecurse, TRUE);
            }

            // load either "this folder" or "the selected items"
            TCHAR szFolderText[MAX_PATH];
            LoadString(HINST_THISDLL, pfpsp->pfci->fMultipleFiles ? IDS_THESELECTEDITEMS : IDS_THISFOLDER, szFolderText, ARRAYSIZE(szFolderText));

            // set the IDD_RECURSIVE_TXT text to have "this folder" or "the selected items"
            TCHAR szFormatString[MAX_PATH];
            GetDlgItemText(hDlgRecurse, IDD_RECURSIVE_TXT, szFormatString, ARRAYSIZE(szFormatString));
            TCHAR szDlgText[MAX_PATH];
            StringCchPrintf(szDlgText, ARRAYSIZE(szDlgText), szFormatString, szFolderText);
            SetDlgItemText(hDlgRecurse, IDD_RECURSIVE_TXT, szDlgText);

            // set the IDD_NOTRECURSIVE raido button text to have "this folder" or "the selected items"
            GetDlgItemText(hDlgRecurse, IDD_NOTRECURSIVE, szFormatString, ARRAYSIZE(szFormatString));
            StringCchPrintf(szDlgText, ARRAYSIZE(szDlgText), szFormatString, szFolderText);
            SetDlgItemText(hDlgRecurse, IDD_NOTRECURSIVE, szDlgText);

            // set the IDD_RECURSIVE raido button text to have "this folder" or "the selected items"
            GetDlgItemText(hDlgRecurse, IDD_RECURSIVE, szFormatString, ARRAYSIZE(szFormatString));
            StringCchPrintf(szDlgText, ARRAYSIZE(szDlgText), szFormatString, szFolderText);
            SetDlgItemText(hDlgRecurse, IDD_RECURSIVE, szDlgText);

            return TRUE;
        }

        case WM_COMMAND:
        {
            UINT uCtrlID = GET_WM_COMMAND_ID(wParam, lParam);
            switch (uCtrlID)
            {
                case IDOK:
                    pfpsp->fRecursive = (IsDlgButtonChecked(hDlgRecurse, IDD_RECURSIVE) == BST_CHECKED);
                    // fall through

                case IDCANCEL:
                    EndDialog(hDlgRecurse, (uCtrlID == IDCANCEL) ? FALSE : TRUE);
                    break;
            }
        }

        default:
            return FALSE;
    }
}


//
// This wndproc handles the "Advanced Attributes..." button on the general tab for
//
// return - FALSE:  the user hit cancle
//          TRUE:   the user hit ok
//
BOOL_PTR CALLBACK AdvancedFileAttribsDlgProc(HWND hDlgAttribs, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    FILEPROPSHEETPAGE* pfpsp = (FILEPROPSHEETPAGE *)GetWindowLongPtr(hDlgAttribs, DWLP_USER);

    switch (uMessage)
    {
        case WM_INITDIALOG:
        {
            SetWindowLongPtr(hDlgAttribs, DWLP_USER, lParam);
            pfpsp = (FILEPROPSHEETPAGE *)lParam;

            // set the initial state of the checkboxes

            if (pfpsp->asInitial.fArchive == BST_INDETERMINATE)
            {
                SendDlgItemMessage(hDlgAttribs, IDD_ARCHIVE, BM_SETSTYLE, BS_AUTO3STATE, 0);
            }
            CheckDlgButton(hDlgAttribs, IDD_ARCHIVE, pfpsp->asCurrent.fArchive);

            if (pfpsp->asInitial.fIndex == BST_INDETERMINATE)
            {
                SendDlgItemMessage(hDlgAttribs, IDD_INDEX, BM_SETSTYLE, BS_AUTO3STATE, 0);
            }
            CheckDlgButton(hDlgAttribs, IDD_INDEX, pfpsp->asCurrent.fIndex);

            if (pfpsp->asInitial.fCompress == BST_INDETERMINATE)
            {
                SendDlgItemMessage(hDlgAttribs, IDD_COMPRESS, BM_SETSTYLE, BS_AUTO3STATE, 0);
            }
            CheckDlgButton(hDlgAttribs, IDD_COMPRESS, pfpsp->asCurrent.fCompress);

            if (pfpsp->asInitial.fEncrypt == BST_INDETERMINATE)
            {
                SendDlgItemMessage(hDlgAttribs, IDD_ENCRYPT, BM_SETSTYLE, BS_AUTO3STATE, 0);
            }
            CheckDlgButton(hDlgAttribs, IDD_ENCRYPT, pfpsp->asCurrent.fEncrypt);

            // assert that compression and encryption are mutually exclusive
            ASSERT(!((pfpsp->asCurrent.fCompress == BST_CHECKED) && (pfpsp->asCurrent.fEncrypt == BST_CHECKED)));

            // gray any checkboxs that are not supported by this filesystem
            EnableWindow(GetDlgItem(hDlgAttribs, IDD_INDEX), pfpsp->fIsIndexAvailable);
            EnableWindow(GetDlgItem(hDlgAttribs, IDD_COMPRESS), pfpsp->pfci->fIsCompressionAvailable);
            EnableWindow(GetDlgItem(hDlgAttribs, IDD_ENCRYPT), pfpsp->fIsEncryptionAvailable);

            if (pfpsp->fIsEncryptionAvailable   &&
                pfpsp->asInitial.fEncrypt       &&
                !pfpsp->fIsDirectory            &&
                !pfpsp->pfci->fMultipleFiles)
            {
                // we only support the Advanced button for the single file case
                EnableWindow(GetDlgItem(hDlgAttribs, IDC_ADVANCED), TRUE);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlgAttribs, IDC_ADVANCED), FALSE);
            }

            // load either "this folder" or "the selected items"
            TCHAR szFolderText[MAX_PATH];
            LoadString(HINST_THISDLL, pfpsp->pfci->fMultipleFiles ? IDS_THESELECTEDITEMS : IDS_THISFOLDER, szFolderText, ARRAYSIZE(szFolderText));

            // set the IDC_MANAGEFILES_TXT text to have "this folder" or "the selected items"
            TCHAR szFormatString[MAX_PATH];
            GetDlgItemText(hDlgAttribs, IDC_MANAGEFILES_TXT, szFormatString, ARRAYSIZE(szFormatString));
            TCHAR szDlgText[MAX_PATH];
            StringCchPrintf(szDlgText, ARRAYSIZE(szDlgText), szFormatString, szFolderText);
            SetDlgItemText(hDlgAttribs, IDC_MANAGEFILES_TXT, szDlgText);
            return TRUE;
        }

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPTSTR)aAdvancedHelpIds);
            break;

        case WM_CONTEXTMENU:
            if ((int)SendMessage(hDlgAttribs, WM_NCHITTEST, 0, lParam) != HTCLIENT)
            {
                // not in our client area, so don't process it
                return FALSE;
            }
            WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aAdvancedHelpIds);
            break;

        case WM_COMMAND:
        {
            UINT uCtrlID = GET_WM_COMMAND_ID(wParam, lParam);

            switch (uCtrlID) 
            {
            case IDD_COMPRESS:
                // encrypt and compress are mutually exclusive
                if (IsDlgButtonChecked(hDlgAttribs, IDD_COMPRESS) == BST_CHECKED)
                {
                    // the user checked compress so uncheck the encrypt checkbox
                    CheckDlgButton(hDlgAttribs, IDD_ENCRYPT, BST_UNCHECKED);
                }
                break;

            case IDD_ENCRYPT:
                // encrypt and compress are mutually exclusive
                if (IsDlgButtonChecked(hDlgAttribs, IDD_ENCRYPT) == BST_CHECKED)
                {
                    // the user checked encrypt, so uncheck the compression checkbox
                    CheckDlgButton(hDlgAttribs, IDD_COMPRESS, BST_UNCHECKED);

                    if (!pfpsp->fIsDirectory         &&
                        !pfpsp->pfci->fMultipleFiles &&
                        pfpsp->asInitial.fEncrypt)
                    {
                        EnableWindow(GetDlgItem(hDlgAttribs, IDC_ADVANCED), TRUE);
                    }
                }
                else
                {
                    EnableWindow(GetDlgItem(hDlgAttribs, IDC_ADVANCED), FALSE);
                }
                break;

            case IDC_ADVANCED:
                ASSERT(pfpsp->fIsEncryptionAvailable && pfpsp->asInitial.fEncrypt && !pfpsp->pfci->fMultipleFiles);
                // bring up the EfsDetail dialog
                EfsDetail(hDlgAttribs, pfpsp->szPath);
                break;

            case IDOK:
                pfpsp->asCurrent.fArchive = IsDlgButtonChecked(hDlgAttribs, IDD_ARCHIVE);
                if (pfpsp->asCurrent.fArchive == BST_INDETERMINATE)
                {
                    // if its indeterminate, it better had been indeterminate to start with
                    ASSERT(pfpsp->asInitial.fArchive == BST_INDETERMINATE);
                }

                pfpsp->asCurrent.fIndex = IsDlgButtonChecked(hDlgAttribs, IDD_INDEX);
                if (pfpsp->asCurrent.fIndex == BST_INDETERMINATE)
                {
                    // if its indeterminate, it better had been indeterminate to start with
                    ASSERT(pfpsp->asInitial.fIndex == BST_INDETERMINATE);
                }

                pfpsp->asCurrent.fCompress = IsDlgButtonChecked(hDlgAttribs, IDD_COMPRESS);
                if (pfpsp->asCurrent.fCompress == BST_INDETERMINATE)
                {
                    // if its indeterminate, it better had been indeterminate to start with
                    ASSERT(pfpsp->asInitial.fCompress == BST_INDETERMINATE);
                }

                pfpsp->asCurrent.fEncrypt = IsDlgButtonChecked(hDlgAttribs, IDD_ENCRYPT);
                if (pfpsp->asCurrent.fEncrypt == BST_INDETERMINATE)
                {
                    // if its indeterminate, it better had been indeterminate to start with
                    ASSERT(pfpsp->asInitial.fEncrypt == BST_INDETERMINATE);
                }
                // fall through...

            case IDCANCEL:
                ReplaceDlgIcon(hDlgAttribs, IDD_ITEMICON, NULL);
            
                EndDialog(hDlgAttribs, (uCtrlID == IDCANCEL) ? FALSE : TRUE);
                break;
            }
        }

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Descriptions:
//   This is the dialog procedure for multiple object property sheet.
//
BOOL_PTR CALLBACK MultiplePrshtDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    FILEPROPSHEETPAGE * pfpsp = (FILEPROPSHEETPAGE *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMessage)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pfpsp = (FILEPROPSHEETPAGE *)lParam;
        pfpsp->hDlg = hDlg;
        pfpsp->pfci->hDlg = hDlg;

        InitMultiplePrsht(pfpsp);
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(void *)aMultiPropHelpIds);
        break;

    case WM_CONTEXTMENU:
        if ((int)SendMessage(hDlg, WM_NCHITTEST, 0, lParam) != HTCLIENT)
        {
            // not in our client area, so don't process it
            return FALSE;
        }
        WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aMultiPropHelpIds);
        break;

    case WM_TIMER:
        UpdateSizeCount(pfpsp);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDD_READONLY:
        case IDD_HIDDEN:
        case IDD_ARCHIVE:
            break;

        case IDC_ADVANCED:
            // the dialog box returns fase if the user hit cancel, and true if they hit ok,
            // so if they cancelled, return immediately and don't send the PSM_CHANGED message
            // because nothing actually changed
            if (!DialogBoxParam(HINST_THISDLL,
                                MAKEINTRESOURCE(pfpsp->fIsDirectory ? DLG_FOLDERATTRIBS : DLG_FILEATTRIBS),
                                hDlg,
                                AdvancedFileAttribsDlgProc,
                                (LPARAM)pfpsp))
            {
                // the user has cancled
                return TRUE;
            }
            break;

        default:
            return TRUE;
        }

        // check to see if we need to enable the Apply button
        if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
        {
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
        }
        break;

    case WM_DESTROY:
        Free_DlgDependentFilePropSheetPage(pfpsp);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
            case PSN_APPLY:
            {
                //
                // Get the final state of the checkboxes
                //

                pfpsp->asCurrent.fReadOnly = IsDlgButtonChecked(hDlg, IDD_READONLY);
                if (pfpsp->asCurrent.fReadOnly == BST_INDETERMINATE)
                {
                    // if its indeterminate, it better had been indeterminate to start with
                    ASSERT(pfpsp->asInitial.fReadOnly == BST_INDETERMINATE);
                }

                pfpsp->asCurrent.fHidden = IsDlgButtonChecked(hDlg, IDD_HIDDEN);
                if (pfpsp->asCurrent.fHidden == BST_INDETERMINATE)
                {
                    // if its indeterminate, it better had been indeterminate to start with
                    ASSERT(pfpsp->asInitial.fHidden == BST_INDETERMINATE);
                }

                if (!pfpsp->pfci->fIsCompressionAvailable)
                {
                    // at least one of the files is on FAT, so the Archive checkbox is on the general page
                    pfpsp->asCurrent.fArchive = IsDlgButtonChecked(hDlg, IDD_ARCHIVE);
                    if (pfpsp->asCurrent.fArchive == BST_INDETERMINATE)
                    {
                        // if its indeterminate, it better had been indeterminate to start with
                        ASSERT(pfpsp->asInitial.fArchive == BST_INDETERMINATE);
                    }
                }

                BOOL bRet = TRUE;

                // check to see if the user actually changed something, if they didnt, then
                // we dont have to apply anything
                if (memcmp(&pfpsp->asInitial, &pfpsp->asCurrent, sizeof(pfpsp->asInitial)) != 0)
                {
                    HWND hwndParent = GetParent(hDlg);

                    // NOTE: We dont check to see if all the dirs are empty, that would be too expensive.
                    // We only do that in the single file case.
                    if (pfpsp->fIsDirectory)
                    {
                        // check to see if the user wants to apply the attribs recursively or not
                        bRet = (int)DialogBoxParam(HINST_THISDLL,
                                              MAKEINTRESOURCE(DLG_ATTRIBS_RECURSIVE),
                                              hDlg,
                                              RecursivePromptDlgProc,
                                              (LPARAM)pfpsp);
                    }

                    if (hwndParent)
                    {
                        // disable our window since we pump messages on this thread while
                        // displaying the progress UI and we don't want the user to hit "Apply"
                        // a second time and get re-entered
                        EnableWindow(hwndParent, FALSE);
                    }

                    if (bRet)
                    {
                        bRet = ApplyMultipleFileAttributes(pfpsp);
                    }

                    if (hwndParent)
                    {
                        EnableWindow(hwndParent, TRUE);
                    }

                    if (!bRet)
                    {
                        // the user hit cancel, so we return true to prevent the property sheet form closeing
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }
                    else
                    {
                        // update the size / last accessed time
                        UpdateSizeField(pfpsp, NULL);
                    }
                }
                break;
            }
            // fall through

            default:
                return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

// in:
//      hdlg
//      id      text control id
//      pftUTC  UTC time time to be set
//
STDAPI_(void) SetDateTimeText(HWND hdlg, int id, const FILETIME *pftUTC)
{
    SetDateTimeTextEx(hdlg, id, pftUTC, FDTF_LONGDATE | FDTF_LONGTIME | FDTF_RELATIVE) ;
}

STDAPI_(void) SetDateTimeTextEx(HWND hdlg, int id, const FILETIME *pftUTC, DWORD dwFlags)
{
    if (!IsNullTime(pftUTC))
    {
        LCID locale = GetUserDefaultLCID();

        if ((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC) ||
            (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW))
        {
            HWND hWnd = GetDlgItem(hdlg, id);
            DWORD dwExStyle = GetWindowLong(hdlg, GWL_EXSTYLE);
            if ((BOOLIFY(dwExStyle & WS_EX_RTLREADING)) != (BOOLIFY(dwExStyle & RTL_MIRRORED_WINDOW)))
                dwFlags |= FDTF_RTLDATE;
            else
                dwFlags |= FDTF_LTRDATE;
        }

        TCHAR szBuf[64];
        SHFormatDateTime(pftUTC, &dwFlags, szBuf, ARRAYSIZE(szBuf));
        SetDlgItemText(hdlg, id, szBuf);
    }
}


// Set the friendly display name into control uId.
BOOL SetPidlToWindow(HWND hwnd, UINT uId, LPITEMIDLIST pidl)
{
    BOOL fRes = FALSE;
    LPCITEMIDLIST pidlItem;
    IShellFolder* psf;
    if (SUCCEEDED(SHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlItem)))
    {
        TCHAR szPath[MAX_PATH];

        // SHGDN_FORADDRESSBAR | SHGDN_FORPARSING because we want:
        // c:\winnt\.... and http://weird, but not ::{GUID} or Folder.{GUID}
        if (SUCCEEDED(DisplayNameOf(psf, pidlItem, SHGDN_FORADDRESSBAR | SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath))))
        {
            SetDlgItemText(hwnd, uId, szPath);
            fRes = TRUE;
        }
        psf->Release();
    }

    return fRes;
}

//
// Descriptions:
//   This function fills fields of the "general" dialog box (a page of
//  a property sheet) with attributes of the associated file.
//
BOOL InitSingleFilePrsht(FILEPROPSHEETPAGE * pfpsp)
{
    SHFILEINFO sfi = {0};
    TCHAR szBuffer[MAX_PATH];

    // get info about the file.
    SHGetFileInfo((LPTSTR)pfpsp->pidl, pfpsp->fd.dwFileAttributes, &sfi, sizeof(sfi),
        SHGFI_ICON | SHGFI_LARGEICON |
        SHGFI_DISPLAYNAME | SHGFI_PIDL |
        SHGFI_TYPENAME | SHGFI_ADDOVERLAYS);

    // .ani cursor hack!
    if (lstrcmpi(PathFindExtension(pfpsp->szPath), TEXT(".ani")) == 0)
    {
        HICON hIcon = (HICON)LoadImage(NULL, pfpsp->szPath, IMAGE_ICON, 0, 0, LR_LOADFROMFILE);
        if (hIcon)
        {
            if (sfi.hIcon)
                DestroyIcon(sfi.hIcon);

            sfi.hIcon = hIcon;
        }
    }

    // icon
    ReplaceDlgIcon(pfpsp->hDlg, IDD_ITEMICON, sfi.hIcon);

    // set the initial rename state
    pfpsp->fRename = FALSE;

    // set the file type
    if (pfpsp->fMountedDrive)
    {
        //Borrow szVolumeGUID
        TCHAR szVolumeGUID[MAX_PATH];
        LoadString(HINST_THISDLL, IDS_MOUNTEDVOLUME, szVolumeGUID, ARRAYSIZE(szVolumeGUID));

        SetDlgItemText(pfpsp->hDlg, IDD_FILETYPE, szVolumeGUID);

        //use szVolumeLabel temporarily
        TCHAR szVolumeLabel[MAX_PATH + 1];
        StringCchCopy(szVolumeLabel, ARRAYSIZE(szVolumeLabel), pfpsp->szPath); //pfpsp->szPath is at most MAX_PATH
        PathAddBackslash(szVolumeLabel);
        GetVolumeNameForVolumeMountPoint(szVolumeLabel, szVolumeGUID, ARRAYSIZE(szVolumeGUID));

        if (!GetVolumeInformation(szVolumeGUID, szVolumeLabel, ARRAYSIZE(szVolumeLabel),
            NULL, NULL, NULL, pfpsp->szFileSys, ARRAYSIZE(pfpsp->szFileSys)))
        {
            EnableWindow(GetDlgItem(pfpsp->hDlg, IDC_DRV_PROPERTIES), FALSE);
            *szVolumeLabel = 0;
        }

        if (!(*szVolumeLabel))
            LoadString(HINST_THISDLL, IDS_UNLABELEDVOLUME, szVolumeLabel, ARRAYSIZE(szVolumeLabel));

        SetDlgItemText(pfpsp->hDlg, IDC_DRV_TARGET, szVolumeLabel);
    }
    else
    {
        SetDlgItemText(pfpsp->hDlg, IDD_FILETYPE, sfi.szTypeName);
    }


    // save off the initial short filename, and set the "Name" edit box
    StringCchCopy(pfpsp->szInitialName, ARRAYSIZE(pfpsp->szInitialName), sfi.szDisplayName );
    SetDlgItemText(pfpsp->hDlg, IDD_NAMEEDIT, sfi.szDisplayName);

    // use a strcmp to see if we are showing the extension
    if (lstrcmpi(sfi.szDisplayName, PathFindFileName(pfpsp->szPath)) == 0)
    {
        // since the strings are the same, we must be showing the extension
        pfpsp->fShowExtension = TRUE;
    }

    UINT cchMax;
    GetCCHMaxFromPath(pfpsp->szPath, &cchMax, pfpsp->fShowExtension);
    Edit_LimitText(GetDlgItem(pfpsp->hDlg, IDD_NAMEEDIT), cchMax);

    // apply the limit input code for the item
    if (pfpsp->pidl)
    {
        IShellFolder *psf;
        if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pfpsp->pidl, &psf))))
        {
            SHLimitInputEdit(GetDlgItem(pfpsp->hDlg, IDD_NAMEEDIT), psf);
            psf->Release();
        }
    }

    // Are we a folder shortcut?
    if (pfpsp->fFolderShortcut)
    {
        // Yes; Then we need to populate folder shortcut specific controls.
        if (pfpsp->pidl)
        {
            IShellLink *psl;
            if (SUCCEEDED(SHGetUIObjectFromFullPIDL(pfpsp->pidl, NULL, IID_PPV_ARG(IShellLink, &psl))))
            {
                // Populate the Target
                if (SUCCEEDED(psl->GetIDList(&pfpsp->pidlTarget)))
                {
                    if (SetPidlToWindow(pfpsp->hDlg, IDD_TARGET, pfpsp->pidlTarget))
                    {
                        pfpsp->fValidateEdit = FALSE;     // Set this to false because we already have a pidl
                        // and don't need to validate.
                    }
                }

                // And description
                TCHAR sz[INFOTIPSIZE];
                if (SUCCEEDED(psl->GetDescription(sz, ARRAYSIZE(sz))))
                {
                    SetDlgItemText(pfpsp->hDlg, IDD_COMMENT, sz);
                }

                psl->Release();
            }
        }

        SetDateTimeText(pfpsp->hDlg, IDD_CREATED, &pfpsp->fd.ftCreationTime);
    }
    else
    {
        // set the initial attributes
        SetInitialFileAttribs(pfpsp, pfpsp->fd.dwFileAttributes, pfpsp->fd.dwFileAttributes);
        
        // special case for folders, we don't apply the read only bit to folders
        // and to indicate that in the UI we make the inital state of the check
        // box tri-state. this allows the read only bit to be applied to files in
        // this folder, but not the folders themselves.
        if (pfpsp->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            pfpsp->asInitial.fReadOnly = BST_INDETERMINATE;
            SendDlgItemMessage(pfpsp->hDlg, IDD_READONLY, BM_SETSTYLE, BS_AUTO3STATE, 0);
        }

        // set the current attributes to the same as the initial
        pfpsp->asCurrent = pfpsp->asInitial;

        CheckDlgButton(pfpsp->hDlg, IDD_READONLY, pfpsp->asInitial.fReadOnly);
        CheckDlgButton(pfpsp->hDlg, IDD_HIDDEN, pfpsp->asInitial.fHidden);

        // Disable renaming the file if requested
        if (pfpsp->fDisableRename)
        {
            EnableWindow(GetDlgItem(pfpsp->hDlg, IDD_NAMEEDIT), FALSE);
        }

        if (pfpsp->fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)
        {
            // to avoid people making SYSTEM files HIDDEN (superhidden files are
            // not show to the user by default) we don't let people make SYSTEM files HIDDEN
            EnableWindow(GetDlgItem(pfpsp->hDlg, IDD_HIDDEN), FALSE);
        }

        // Archive is only on the general tab for FAT, otherwise it is under the "Advanced attributes"
        // and FAT volumes dont have the "Advanced attributes" button.
        if (pfpsp->pfci->fIsCompressionAvailable || pfpsp->fIsEncryptionAvailable)
        {
            // if compression/encryption is available, then we must be on NTFS
            DestroyWindow(GetDlgItem(pfpsp->hDlg, IDD_ARCHIVE));
        }
        else
        {
            // we are on FAT/FAT32, so get rid of the "Advanced attributes" button, and set the inital Archive state
            DestroyWindow(GetDlgItem(pfpsp->hDlg, IDC_ADVANCED));
            CheckDlgButton(pfpsp->hDlg, IDD_ARCHIVE, pfpsp->asInitial.fArchive);
        }

        UpdateSizeField(pfpsp, &pfpsp->fd);

        if (!(pfpsp->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            // Check to see if the target file is a lnk, because if it is a lnk then
            // we need to display the type information for the target, not the lnk itself.
            if (PathIsShortcut(pfpsp->szPath, pfpsp->fd.dwFileAttributes))
            {
                pfpsp->fIsLink = TRUE;
            }
            if (!(GetFileAttributes(pfpsp->szPath) & FILE_ATTRIBUTE_OFFLINE))
            {
                 UpdateOpensWithInfo(pfpsp);
            }
            else
            {
                 EnableWindow(GetDlgItem(pfpsp->hDlg, IDC_FT_PROP_CHANGEOPENSWITH), FALSE);
            }
        }

        // get the full path to the folder that contains this file.
        StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), pfpsp->szPath);
        PathRemoveFileSpec(szBuffer);

        // Keep Functionality same as NT4 by avoiding PathCompactPath.
        SetDlgItemTextWithToolTip(pfpsp->hDlg, IDD_LOCATION, szBuffer, &pfpsp->hwndTip);
    }
    return TRUE;
}

STDAPI_(BOOL) ShowMountedVolumeProperties(LPCTSTR pszMountedVolume, HWND hwndParent)
{
    IMountedVolume* pMountedVolume;
    HRESULT hr = SHCoCreateInstance(NULL, &CLSID_MountedVolume, NULL, IID_PPV_ARG(IMountedVolume, &pMountedVolume));
    if (SUCCEEDED(hr))
    {
        TCHAR szPathSlash[MAX_PATH + 1];
        hr = StringCchCopy(szPathSlash, ARRAYSIZE(szPathSlash), pszMountedVolume);
        if (SUCCEEDED(hr))
        {
            hr = PathAddBackslash(szPathSlash) ? S_OK : E_FAIL;
            if (SUCCEEDED(hr))
            {
                hr = pMountedVolume->Initialize(szPathSlash);
                if (SUCCEEDED(hr))
                {
                    IDataObject* pDataObj;
                    hr = pMountedVolume->QueryInterface(IID_PPV_ARG(IDataObject, &pDataObj));
                    if (SUCCEEDED(hr))
                    {
                        PROPSTUFF *pps = (PROPSTUFF *)LocalAlloc(LPTR, sizeof(*pps));
                        if (pps)
                        {
                            pps->lpStartAddress = DrivesPropertiesThreadProc;
                            pps->pdtobj = pDataObj;

                            EnableWindow(hwndParent, FALSE);

                            DrivesPropertiesThreadProc(pps);

                            EnableWindow(hwndParent, TRUE);

                            LocalFree(pps);
                        }

                        pDataObj->Release();
                    }
                }
            }
        }
        pMountedVolume->Release();
    }

    return SUCCEEDED(hr);
}

#ifdef FOLDERSHORTCUT_EDITABLETARGET
BOOL SetFolderShortcutInfo(HWND hDlg, FILEPROPSHEETPAGE* pfpsp)
{
    ASSERT(pfpsp->pidl);

    BOOL fSuccess = FALSE;

    IShellLink* psl;
    if (SUCCEEDED(SHGetUIObjectFromFullPIDL(pfpsp->pidl, NULL, IID_PPV_ARG(IShellLink, &psl))))
    {
        TCHAR sz[INFOTIPSIZE];
        Edit_GetText(GetDlgItem(pfpsp->hDlg, IDD_COMMENT), sz, ARRAYSIZE(sz));

        psl->SetDescription(sz);

        if (pfpsp->fValidateEdit)
        {
            IShellFolder* psf;
            if (SUCCEEDED(SHGetDesktopFolder(&psf)))
            {
                TCHAR szPath[MAX_PATH];
                Edit_GetText(GetDlgItem(pfpsp->hDlg, IDD_TARGET), sz, ARRAYSIZE(sz));

                if (PathCanonicalize(szPath, sz))
                {
                    LPITEMIDLIST pidlDest;
                    DWORD dwAttrib = SFGAO_FOLDER | SFGAO_VALIDATE;
                    ULONG chEat = 0;
                    if (SUCCEEDED(psf->ParseDisplayName(NULL, NULL, szPath, &chEat, &pidlDest, &dwAttrib)))
                    {
                        if ((dwAttrib & SFGAO_FOLDER) == SFGAO_FOLDER)
                        {
                            ILFree(pfpsp->pidlTarget);
                            pfpsp->pidlTarget = pidlDest;
                            fSuccess = TRUE;
                        }
                        else
                        {
                            ILFree(pidlDest);
                        }
                    }
                }
                psf->Release();
            }
        }
        else
        {
            fSuccess = TRUE;
        }

        if (fSuccess)
        {
            psl->SetIDList(pfpsp->pidlTarget);

            IPersistFile* ppf;
            if (SUCCEEDED(psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf))))
            {
                fSuccess = (S_OK == ppf->Save(pfpsp->szPath, TRUE));
                SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, pfpsp->szPath, NULL);
                ppf->Release();
            }
        }

        psl->Release();
    }

    return fSuccess;
}
#endif

//
// Descriptions:
//   This is the dialog procedure for the "general" page of a property sheet.
//
BOOL_PTR CALLBACK SingleFilePrshtDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    FILEPROPSHEETPAGE* pfpsp = (FILEPROPSHEETPAGE *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMessage)
    {
    case WM_INITDIALOG:
        // REVIEW, we should store more state info here, for example
        // the hIcon being displayed and the FILEINFO pointer, not just
        // the file name ptr
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pfpsp = (FILEPROPSHEETPAGE *)lParam;
        pfpsp->hDlg = hDlg;
        pfpsp->pfci->hDlg = hDlg;

        InitSingleFilePrsht(pfpsp);

        // We set this to signal that we are done processing the WM_INITDIALOG.
        // This is needed because we set the text of the "Name" edit box and unless
        // he knows that this is being set for the first time, he thinks that someone is doing a rename.
        pfpsp->fWMInitFinshed = TRUE;
        break;

    case WM_TIMER:
        if (!pfpsp->fMountedDrive)
            UpdateSizeCount(pfpsp);
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(void *)(pfpsp->fIsDirectory ? aFolderGeneralHelpIds : aFileGeneralHelpIds));
        break;

    case WM_CONTEXTMENU:
        if ((int)SendMessage(hDlg, WM_NCHITTEST, 0, lParam) != HTCLIENT)
        {
            // not in our client area, so don't process it
            return FALSE;
        }
        WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)(pfpsp->fIsDirectory ? aFolderGeneralHelpIds : aFileGeneralHelpIds));
        break;


    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDD_READONLY:
        case IDD_HIDDEN:
        case IDD_ARCHIVE:
            break;

#ifdef FOLDERSHORTCUT_EDITABLETARGET
        case IDD_TARGET:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
            {
                // someone typed in the target, enable apply button
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);

                // Do a verification on apply.
                pfpsp->fValidateEdit = TRUE;
            }
            break;

        case IDD_COMMENT:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
            {
                // Set the apply.
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
            }
            break;
#endif
        case IDD_NAMEEDIT:
            // we need to check the pfpsp->fWMInitFinshed to make sure that we are done processing the WM_INITDIALOG,
            // because during init we set the initial IDD_NAMEEDIT text which generates a EN_CHANGE message.
            if ((GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE) && !pfpsp->fRename && pfpsp->fWMInitFinshed)
            {
                pfpsp->fRename = TRUE;
                //
                // disable "Apply" even though the edit field has changed (reinerf)
                //
                // We only allow "ok" or "cancel" after the name has changed to be sure we
                // don't rename the file out from under other property sheet extensions that
                // cache the original name away
                PropSheet_DisableApply(GetParent(pfpsp->hDlg));
            }
            break;

        case IDC_CHANGEFILETYPE:
            {
                // Bring up the "Open With" dialog
                OPENASINFO oai;

                if (pfpsp->fIsLink && pfpsp->szLinkTarget[0])
                {
                    // if we have a link we want to re-associate the link target, NOT .lnk files!
                    oai.pcszFile = pfpsp->szLinkTarget;
                }
                else
                {
#ifdef DEBUG
                    LPTSTR pszExt = PathFindExtension(pfpsp->szPath);

                    // reality check...
                    ASSERT((lstrcmpi(pszExt, TEXT(".exe")) != 0) &&
                           (lstrcmpi(pszExt, TEXT(".lnk")) != 0));
#endif // DEBUG
                    oai.pcszFile = pfpsp->szPath;
                }

                oai.pcszClass = NULL;
                oai.dwInFlags = (OAIF_REGISTER_EXT | OAIF_FORCE_REGISTRATION); // we want the association to be made

                if (SUCCEEDED(OpenAsDialog(GetParent(hDlg), &oai)))
                {
                    // we changed the association so update the "Opens with:" text. Clear out szLinkTarget to force
                    // the update to happen
                    pfpsp->szLinkTarget[0] = 0;
                    UpdateOpensWithInfo(pfpsp);
                }
            }
            break;

        case IDC_ADVANCED:
            // the dialog box returns fase if the user hit cancel, and true if they hit ok,
            // so if they cancelled, return immediately and don't send the PSM_CHANGED message
            // because nothing actually changed
            if (!DialogBoxParam(HINST_THISDLL,
                                MAKEINTRESOURCE(pfpsp->fIsDirectory ? DLG_FOLDERATTRIBS : DLG_FILEATTRIBS),
                                hDlg,
                                AdvancedFileAttribsDlgProc,
                                (LPARAM)pfpsp))
            {
                // the user has canceled
                return TRUE;
            }
            break;

        case IDC_DRV_PROPERTIES:
            ASSERT(pfpsp->fMountedDrive);
            ShowMountedVolumeProperties(pfpsp->szPath, hDlg);
            break;

#ifdef FOLDERSHORTCUT_EDITABLETARGET
        case IDD_BROWSE:
            {
                // Display the BrowseForFolder dialog.

                // FEATURE(lamadio): Implement a filter to filter things we can create folder
                // shortcuts to. Not enough time for this rev 6.5.99

                TCHAR szTitle[MAX_PATH];
                LoadString(HINST_THISDLL, IDS_BROWSEFORFS, szTitle, ARRAYSIZE(szTitle));
                TCHAR szAltPath[MAX_PATH];

                BROWSEINFO bi = {0};
                bi.hwndOwner    = hDlg;
                bi.pidlRoot     = NULL;
                bi.pszDisplayName = szAltPath;
                bi.lpszTitle    = szTitle;
                bi.ulFlags      =  BIF_USENEWUI | BIF_EDITBOX;
                LPITEMIDLIST pidlFull = SHBrowseForFolder(&bi);
                if (pidlFull)
                {
                    ILFree(pfpsp->pidlTarget);
                    pfpsp->pidlTarget = pidlFull;

                    if (SetPidlToWindow(hDlg, IDD_TARGET, pfpsp->pidlTarget))
                    {
                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                        pfpsp->fValidateEdit = FALSE;
                    }
                }
            }
            break;
#endif

        default:
            return TRUE;
        }

        // check to see if we need to enable the Apply button
        if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
        {
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
        }
        break;

    case WM_DESTROY:
        Free_DlgDependentFilePropSheetPage(pfpsp);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
            case PSN_APPLY:
                // check to see if we could apply the name change.  Note that this
                // does not actually apply the change until PSN_LASTCHANCEAPPLY
                pfpsp->fCanRename = TRUE;
                if (pfpsp->fRename && !ApplyRename(pfpsp, FALSE))
                {
                    // can't change the name so don't let the dialog close
                    pfpsp->fCanRename = FALSE;
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    return TRUE;
                }

                if (pfpsp->fFolderShortcut)
                {
#ifdef FOLDERSHORTCUT_EDITABLETARGET
                    if (!SetFolderShortcutInfo(hDlg, pfpsp))
                    {
                        // Display that we could not create because blah, blah, blah
                        ShellMessageBox(HINST_THISDLL,
                                        hDlg,
                                        MAKEINTRESOURCE(IDS_FOLDERSHORTCUT_ERR),
                                        MAKEINTRESOURCE(IDS_FOLDERSHORTCUT_ERR_TITLE),
                                        MB_OK | MB_ICONSTOP);

                        // Reset the Folder info.
                        SetPidlToWindow(hDlg, IDD_TARGET, pfpsp->pidlTarget);

                        // Don't close the dialog.
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }
#endif
                }
                else
                {
                    UINT uReadonlyState = IsDlgButtonChecked(hDlg, IDD_READONLY);
                    switch (uReadonlyState)
                    {
                    case BST_CHECKED:
                        pfpsp->asCurrent.fReadOnly = TRUE;
                        break;

                    case BST_UNCHECKED:
                        pfpsp->asCurrent.fReadOnly = FALSE;
                        break;

                    case BST_INDETERMINATE:
                        // read-only checkbox is initaially set to BST_INDETERMINATE for folders
                        ASSERT(pfpsp->fIsDirectory);
                        ASSERT(pfpsp->asInitial.fReadOnly == BST_INDETERMINATE);
                        pfpsp->asCurrent.fReadOnly = BST_INDETERMINATE;
                        break;
                    }

                    pfpsp->asCurrent.fHidden = (IsDlgButtonChecked(hDlg, IDD_HIDDEN) == BST_CHECKED);

                    // Archive is on the general page for FAT volumes
                    if (!pfpsp->pfci->fIsCompressionAvailable)
                    {
                        pfpsp->asCurrent.fArchive = (IsDlgButtonChecked(hDlg, IDD_ARCHIVE) == BST_CHECKED);
                    }

                    // check to see if the user actually changed something, if they didnt, then
                    // we dont have to apply anything
                    if (memcmp(&pfpsp->asInitial, &pfpsp->asCurrent, sizeof(pfpsp->asInitial)) != 0)
                    {
                        HWND hwndParent = GetParent(hDlg);
                        BOOL bRet = TRUE;

                        // Check to see if the user wants to apply the attribs recursively or not. If the
                        // directory is empty, dont bother to ask, since there is nothing to recurse into
                        if (pfpsp->fIsDirectory && !PathIsDirectoryEmpty(pfpsp->szPath))
                        {
                            bRet = (int)DialogBoxParam(HINST_THISDLL,
                                                       MAKEINTRESOURCE(DLG_ATTRIBS_RECURSIVE),
                                                       hDlg,
                                                       RecursivePromptDlgProc,
                                                       (LPARAM)pfpsp);
                        }

                        if (hwndParent)
                        {
                            // disable our window since we pump messages on this thread while
                            // displaying the progress UI and we don't want the user to hit "Apply"
                            // a second time and get re-entered
                            EnableWindow(hwndParent, FALSE);
                        }

                        if (bRet)
                        {
                            bRet = ApplySingleFileAttributes(pfpsp);
                        }
                        
                        if (hwndParent)
                        {
                            EnableWindow(hwndParent, TRUE);
                        }

                        if (!bRet)
                        {
                            // the user hit cancel, so we return true to prevent the property sheet from closing
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                            return TRUE;
                        }
                        else
                        {
                            // update the size / last accessed time
                            UpdateSizeField(pfpsp, NULL);
                        }
                    }
                }
                break;

            case PSN_SETACTIVE:
                if (pfpsp->fIsLink)
                {
                    // If this is a link, each time we get set active we need to check to see
                    // if the user applied changes on the link tab that would affect the
                    // "Opens With:" info.
                    UpdateOpensWithInfo(pfpsp);
                }
                break;

            case PSN_QUERYINITIALFOCUS:
                // Special hack:  We do not want initial focus on the "Rename" or "Change" controls, since
                // if the user hit something by accident they would start renaming/modifying the assoc. So
                // we set the focus to the "Read-only" control since it is present on all dialogs that use
                // this wndproc (file, folder, and mounted drive)
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)GetDlgItem(hDlg, IDD_READONLY));
                return TRUE;

            case PSN_LASTCHANCEAPPLY:
                //
                // HACKHACK (reinerf)
                //
                // I hacked PSN_LASTCHANCEAPPLY into the prsht code so we can get a notification after
                // every other app has applied, then we can go and do the rename.
                //
                // strangely, PSN_LASTCHANCEAPPLY is called even if PSN_APPY returns TRUE.
                //
                // we can now safely rename the file, since all the other tabs have
                // applied their stuff.
                if (pfpsp->fRename && pfpsp->fCanRename)
                {
                    // dont bother to check the return value since this is the last-chance,
                    // so the dialog is ending shortly after this
                    ApplyRename(pfpsp, TRUE);
                }
                break;

            default:
                return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}



//
// This function consists of code  that does some
// Initialization for the file property sheet dialog.

STDAPI InitCommonPrsht(FILEPROPSHEETPAGE * pfpsp)
{
    pfpsp->psp.dwSize      = sizeof(FILEPROPSHEETPAGE);        // extra data
    pfpsp->psp.dwFlags     = PSP_USECALLBACK;
    pfpsp->psp.hInstance   = HINST_THISDLL;
    pfpsp->psp.pfnCallback = NULL; //FilePrshtCallback;
    pfpsp->pfci->bContinue   = TRUE;

    // Do basic init for file system props
    if (HIDA_GetCount(pfpsp->pfci->hida) == 1)       // single file?
    {
        // get most of the data we will need (the date/time stuff is not filled in)
        if (HIDA_FillFindData(pfpsp->pfci->hida, 0, pfpsp->szPath, &(pfpsp->pfci->fd), FALSE))
        {
            pfpsp->fd = pfpsp->pfci->fd;
            pfpsp->pidl = HIDA_ILClone(pfpsp->pfci->hida, 0);
            if (pfpsp->pidl)
            {
                //  disable renaming here.
                DWORD dwAttrs = SFGAO_CANRENAME;
                if (SUCCEEDED(SHGetNameAndFlags(pfpsp->pidl, 0, NULL, 0, &dwAttrs)) && !(dwAttrs & SFGAO_CANRENAME))
                {
                    pfpsp->fDisableRename = TRUE;
                }
            }

            if (pfpsp->pfci->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                pfpsp->fIsDirectory = TRUE;
                // check for HostFolder folder mounting a volume)
                //GetVolumeNameFromMountPoint Succeeds then the give path is a mount point


                //Make sure the path ends with a backslash. otherwise the following api wont work
                TCHAR szPathSlash[MAX_PATH + 1];
                StringCchCopy(szPathSlash, ARRAYSIZE(szPathSlash), pfpsp->szPath);
                PathAddBackslash(szPathSlash);

                // Is this a mounted volume at this folder?
                // this fct will return FALSE if not on NT5 and higher
                TCHAR szVolumeName[MAX_PATH];
                if (GetVolumeNameForVolumeMountPoint(szPathSlash, szVolumeName, ARRAYSIZE(szVolumeName)))
                {
                    // Yes; show the Mounted Drive Propertysheet instead of normal
                    // folder property sheet
                    // fpsp.fMountedDrive also means NT5 or higher, because this fct will fail otherwise
                    pfpsp->fMountedDrive = TRUE;
                }

                // check to see if it's a folder shortcut
                if (!(pfpsp->fMountedDrive))
                {
                    // Folder and a shortcut? Must be a folder shortcut!
                    if (PathIsShortcut(pfpsp->szPath, pfpsp->pfci->fd.dwFileAttributes))
                    {
                        pfpsp->fFolderShortcut = TRUE;
                    }
                }
            }

            {
                DWORD dwVolumeFlags = GetVolumeFlags(pfpsp->szPath,
                                                     pfpsp->szFileSys,
                                                     ARRAYSIZE(pfpsp->szFileSys));

                // test for file-based compression.
                if (dwVolumeFlags & FS_FILE_COMPRESSION)
                {
                    // filesystem supports compression
                    pfpsp->pfci->fIsCompressionAvailable = TRUE;
                }

                // test for file-based encryption.
                if ((dwVolumeFlags & FS_FILE_ENCRYPTION) && !SHRestricted(REST_NOENCRYPTION))
                {
                    // filesystem supports encryption
                    pfpsp->fIsEncryptionAvailable = TRUE;
                }

                //
                // HACKHACK (reinerf) - we dont have a FS_SUPPORTS_INDEXING so we
                // use the FILE_SUPPORTS_SPARSE_FILES flag, because native index support
                // appeared first on NTFS5 volumes, at the same time sparse file support
                // was implemented.
                //
                if (dwVolumeFlags & FILE_SUPPORTS_SPARSE_FILES)
                {
                    // yup, we are on NTFS5 or greater
                    pfpsp->fIsIndexAvailable = TRUE;
                }

                // check to see if we have a .exe and we need to prompt for user logon
                pfpsp->fIsExe = PathIsBinaryExe(pfpsp->szPath);
            }
        }
    }
    else
    {
        // we have multiple files
        pfpsp->pfci->fMultipleFiles = TRUE;
    }

    return S_OK;
}


//
// Descriptions:
//   This function creates a property sheet object for the "general" page
//  which shows file system attributes.
//
// Arguments:
//  hDrop           -- specifies the file(s)
//  pfnAddPage      -- Specifies the callback function.
//  lParam          -- Specifies the lParam to be passed to the callback.
//
// Returns:
//  TRUE if it added any pages
//
// History:
//  12-31-92 SatoNa Created
//
STDAPI FileSystem_AddPages(IDataObject *pdtobj, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    FILEPROPSHEETPAGE fpsp = {0};
    HRESULT hr = S_OK;

    fpsp.pfci = Create_FolderContentsInfo();
    if (fpsp.pfci)
    {
        hr = DataObj_CopyHIDA(pdtobj, &fpsp.pfci->hida);
        if (SUCCEEDED(hr))
        {
            hr = InitCommonPrsht(&fpsp);
            if (SUCCEEDED(hr))
            {
                fpsp.psp.pfnCallback = FilePrshtCallback;

                UINT uRes;
                if (!fpsp.pfci->fMultipleFiles)
                {
                    fpsp.psp.pfnDlgProc = SingleFilePrshtDlgProc;
                    if (fpsp.fIsDirectory)
                    {
                        if (fpsp.fMountedDrive)
                        {
                            uRes = DLG_MOUNTEDDRV_GENERAL;
                        }
                        else if (fpsp.fFolderShortcut)
                        {
                            uRes = DLG_FOLDERSHORTCUTPROP;
                        }
                        else
                        {
                            uRes = DLG_FOLDERPROP;
                        }
                    }
                    else
                    {
                        //Files
                        uRes = DLG_FILEPROP;
                    }
                }
                else
                {
                    // Multiple Files / Folders.
                    fpsp.psp.pfnDlgProc  = MultiplePrshtDlgProc;
                    uRes = DLG_FILEMULTPROP;
                }
                fpsp.psp.pszTemplate = MAKEINTRESOURCE(uRes);
            }
        }

        if (SUCCEEDED(hr))
        {
            HPROPSHEETPAGE hpage = CreatePropertySheetPage(&fpsp.psp);
            if (hpage)
            {
                if (pfnAddPage(hpage, lParam))
                {
                    hr = S_OK;
                    if (!fpsp.pfci->fMultipleFiles)
                    {
                        if (AddLinkPage(fpsp.szPath, pfnAddPage, lParam))
                        {
                            // set second page default!
                            hr = ResultFromShort(2);
                        }
                        AddVersionPage(fpsp.szPath, pfnAddPage, lParam);
                    }
                }
                else
                {
                    DestroyPropertySheetPage(hpage);
                }
            }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {
        Free_DlgIndepFilePropSheetPage(&fpsp);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\netfind.cpp ===
#include "shellprv.h"
#pragma  hdrstop
#include "shellids.h" // new help ids are stored here
#include "findfilter.h"
#include "netview.h"
#include "prop.h"
#include "ids.h"

STDAPI CNetwork_EnumSearches(IShellFolder2 *psf2, IEnumExtraSearch **ppenum);

class CNetFindEnum;

class CNetFindFilter : public IFindFilter
{
    friend CNetFindEnum;

public:
    CNetFindFilter();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IFindFilter
    STDMETHODIMP GetStatusMessageIndex(UINT uContext, UINT *puMsgIndex);
    STDMETHODIMP GetFolderMergeMenuIndex(UINT *puBGMainMergeMenu, UINT *puBGPopupMergeMenu);
    STDMETHODIMP FFilterChanged();
    STDMETHODIMP GenerateTitle(LPTSTR *ppszTile, BOOL fFileName);
    STDMETHODIMP PrepareToEnumObjects(HWND hwnd, DWORD * pdwFlags);
    STDMETHODIMP ClearSearchCriteria();
    STDMETHODIMP EnumObjects(IShellFolder *psf, LPCITEMIDLIST pidlStart, DWORD grfFlags, int iColSort, 
                              LPTSTR pszProgressText, IRowsetWatchNotify *prwn, IFindEnum **ppfindenum);
    STDMETHODIMP GetColumnsFolder(IShellFolder2 **ppsf);
    STDMETHODIMP_(BOOL) MatchFilter(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP SaveCriteria(IStream * pstm, WORD fCharType);   
    STDMETHODIMP RestoreCriteria(IStream * pstm, int cCriteria, WORD fCharType);
    STDMETHODIMP DeclareFSNotifyInterest(HWND hwndDlg, UINT uMsg);
    STDMETHODIMP GetColSaveStream(WPARAM wParam, IStream **ppstm);
    STDMETHODIMP GenerateQueryRestrictions(LPWSTR *ppwszQuery, DWORD *pdwGQRFlags);
    STDMETHODIMP ReleaseQuery();
    STDMETHODIMP UpdateField(LPCWSTR pszField, VARIANT vValue);
    STDMETHODIMP ResetFieldsToDefaults();
    STDMETHODIMP GetItemContextMenu(HWND hwndOwner, IFindFolder* pff, IContextMenu** ppcm);
    STDMETHODIMP GetDefaultSearchGUID(IShellFolder2 *psf2, LPGUID lpGuid);
    STDMETHODIMP EnumSearches(IShellFolder2 *psf2, LPENUMEXTRASEARCH *ppenum);
    STDMETHODIMP GetSearchFolderClassId(LPGUID lpGuid);
    STDMETHODIMP GetNextConstraint(VARIANT_BOOL fReset, BSTR *pName, VARIANT *pValue, VARIANT_BOOL *pfFound);
    STDMETHODIMP GetQueryLanguageDialect(ULONG * pulDialect);
    STDMETHODIMP GetWarningFlags(DWORD *pdwWarningFlags) { return E_NOTIMPL; }

protected:

    LPTSTR _pszCompName;   // the one we do compares with
    TCHAR _szUserInputCompName[MAX_PATH];  // User input

private:
    ~CNetFindFilter();
    LONG _cRef;

    LPITEMIDLIST _pidlStart;      // Where to start the search from.

    // Data associated with the file name.
};

CNetFindFilter::CNetFindFilter() : _cRef(1)
{
}

CNetFindFilter::~CNetFindFilter()
{
    ILFree(_pidlStart);
    Str_SetPtr(&_pszCompName, NULL);
}


STDMETHODIMP CNetFindFilter::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CNetFindFilter, IFindFilter),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CNetFindFilter::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CNetFindFilter::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CNetFindFilter::GetStatusMessageIndex(UINT uContext, UINT *puMsgIndex)
{
    // Currently context is not used
    *puMsgIndex = IDS_COMPUTERSFOUND;
    return S_OK;
}

STDMETHODIMP CNetFindFilter::GetFolderMergeMenuIndex(UINT *puBGMainMergeMenu, UINT *puBGPopupMergeMenu)
{
    *puBGPopupMergeMenu = 0;
    return S_OK;
}

STDMETHODIMP CNetFindFilter::GetItemContextMenu(HWND hwndOwner, IFindFolder* pff, IContextMenu **ppcm)
{
    return CFindItem_Create(hwndOwner, pff, ppcm);
}

STDMETHODIMP CNetFindFilter::GetDefaultSearchGUID(IShellFolder2 *psf2, GUID *pGuid)
{
    *pGuid = SRCID_SFindComputer;
    return S_OK;
}

STDMETHODIMP CNetFindFilter::EnumSearches(IShellFolder2 *psf2, IEnumExtraSearch **ppenum)
{
    return CNetwork_EnumSearches(psf2, ppenum);
}

STDMETHODIMP CNetFindFilter::GetSearchFolderClassId(LPGUID lpGuid)
{
    *lpGuid = CLSID_ComputerFindFolder;
    return S_OK;
}

STDMETHODIMP CNetFindFilter::GetNextConstraint(VARIANT_BOOL fReset, BSTR *pName, VARIANT *pValue, VARIANT_BOOL *pfFound)
{
    *pName = NULL;
    *pfFound = FALSE;
    VariantClear(pValue);                            
    return E_NOTIMPL;
}

STDMETHODIMP CNetFindFilter::GetQueryLanguageDialect(ULONG * pulDialect)
{
    if (pulDialect)
        *pulDialect = 0;
    return E_NOTIMPL;
}

STDMETHODIMP CNetFindFilter::FFilterChanged()
{
    // Currently not saving so who cares?
    return S_FALSE;
}

STDMETHODIMP CNetFindFilter::GenerateTitle(LPTSTR *ppszTitle, BOOL fFileName)
{
    // Now lets construct the message from the resource
    *ppszTitle = ShellConstructMessageString(HINST_THISDLL,
            MAKEINTRESOURCE(IDS_FIND_TITLE_COMPUTER), fFileName ? TEXT(" #") : TEXT(":"));

    return *ppszTitle ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CNetFindFilter::ClearSearchCriteria()
{
    return S_OK;
}


STDAPI CreateDefaultComputerFindFilter(IFindFilter **ppff)
{
    *ppff = new CNetFindFilter;
    return *ppff ? S_OK : E_OUTOFMEMORY;
}


class CNetFindEnum : public IFindEnum
{
public:
    CNetFindEnum(CNetFindFilter *pnff, IShellFolder *psf, LPTSTR pszDisplayText, DWORD grfFlags, LPITEMIDLIST pidlStart);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IFindEnum
    STDMETHODIMP Next(LPITEMIDLIST *ppidl, int *pcObjectSearched, int *pcFoldersSearched, BOOL *pfContinue, int *pState);
    STDMETHODIMP Skip(int celt) { return E_NOTIMPL; }
    STDMETHODIMP Reset() { return E_NOTIMPL; }
    STDMETHODIMP StopSearch() { return E_NOTIMPL; }
    STDMETHODIMP_(BOOL) FQueryIsAsync();
    STDMETHODIMP GetAsyncCount(DBCOUNTITEM *pdwTotalAsync, int *pnPercentComplete, BOOL *pfQueryDone);
    STDMETHODIMP GetItemIDList(UINT iItem, LPITEMIDLIST *ppidl);
    STDMETHODIMP GetItemID(UINT iItem, DWORD *puWorkID);
    STDMETHODIMP SortOnColumn(UINT iCol, BOOL fAscending);

private:
    ~CNetFindEnum();
    HRESULT _FindCompByUNCName(LPITEMIDLIST *ppidl, int *piState);

    LONG _cRef;
    IFindFolder  *_pff;                 // find folder

    // Stuff to use in the search
    DWORD _grfFlags;                    // Flags that control things like recursion

    // filter info...
    LPTSTR _pszDisplayText;             // Place to write feadback text into
    CNetFindFilter *_pnetf;             // Pointer to the net filter...

    // enumeration state

    IShellFolder *_psfEnum;             // Pointer to shell folder for the object.
    IEnumIDList  *_penum;               // Enumerator in use.
    LPITEMIDLIST  _pidlFolder;                // The idlist of the currently processing
    LPITEMIDLIST  _pidlStart;           // Pointer to the starting point.
    int           _iFolder;             // Which folder are we adding items for?
    BOOL          _fFindUNC;            // Find UNC special case
    int           _iPassCnt;            // Used to control when to reiterat...
};


CNetFindEnum::CNetFindEnum(CNetFindFilter *pnff, IShellFolder *psf, LPTSTR pszDisplayText, DWORD grfFlags, LPITEMIDLIST pidlStart) :
    _cRef(1), _pnetf(pnff), _pszDisplayText(pszDisplayText), _grfFlags(grfFlags), _iFolder(-1)
{
    ASSERT(0 == _iPassCnt);

    _pnetf->AddRef();

    psf->QueryInterface(IID_PPV_ARG(IFindFolder, &_pff));
    ASSERT(_pff);

    if (pidlStart)
        SHILClone(pidlStart, &_pidlStart);
    else
        SHGetDomainWorkgroupIDList(&_pidlStart);

    // special case to force us to search for specific UNC
    _fFindUNC = _pnetf->_pszCompName && (_pnetf->_pszCompName[0] == TEXT('\\'));
}

CNetFindEnum::~CNetFindEnum()
{
    // Release any open enumerator and open IShell folder we may have.
    if (_psfEnum)
        _psfEnum->Release();
    if (_penum)
        _penum->Release();

    _pff->Release();
    _pnetf->Release();

    ILFree(_pidlStart);
    ILFree(_pidlFolder);
}

STDMETHODIMP CNetFindEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
//        QITABENT(CNetFindEnum, IFindEnum),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CNetFindEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CNetFindEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CNetFindFilter::EnumObjects(IShellFolder *psf, LPCITEMIDLIST pidlStart, 
                                    DWORD grfFlags, int iColSort, LPTSTR pszDisplayText, 
                                    IRowsetWatchNotify *prsn, IFindEnum **ppfindenum)
{
    // We need to construct the iterator
    *ppfindenum = new CNetFindEnum(this, psf, pszDisplayText, grfFlags, _pidlStart);
    return *ppfindenum ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CNetFindFilter::PrepareToEnumObjects(HWND hwnd, DWORD *pdwFlags)
{
    *pdwFlags = 0;

    // Also lets convert the Computer name  pattern into the strings
    // will do the compares against.
    if ((_szUserInputCompName[0] == TEXT('\\')) &&
        (_szUserInputCompName[1] == TEXT('\\')))
    {
        Str_SetPtr(&_pszCompName, _szUserInputCompName);
    }
    else
    {
        SetupWildCardingOnFileSpec(_szUserInputCompName, &_pszCompName);
    }

    return S_OK;
}

STDMETHODIMP CNetFindFilter::GetColumnsFolder(IShellFolder2 **ppsf)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetDomainWorkgroupIDList(&pidl);
    if (SUCCEEDED(hr))
    {
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder2, pidl, ppsf));
        ILFree(pidl);
    }
    else
        *ppsf = NULL;
    return hr;
}

STDMETHODIMP_(BOOL) CNetFindFilter::MatchFilter(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    if (this->_pszCompName && this->_pszCompName[0])
    {
        // Although for now not much...
        TCHAR szPath[MAX_PATH];

        return SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_NORMAL, szPath, ARRAYSIZE(szPath))) &&
               PathMatchSpec(szPath, _pszCompName);
    }

    return TRUE;    // emtpy search, return TRUE (yes)
}

STDMETHODIMP CNetFindFilter::SaveCriteria(IStream *pstm, WORD fCharType)
{
    return S_OK;
}

STDMETHODIMP CNetFindFilter::RestoreCriteria(IStream *pstm, int cCriteria, WORD fCharType)
{
    return S_OK;
}

STDMETHODIMP CNetFindFilter::GetColSaveStream(WPARAM wparam, IStream **ppstm)
{
    *ppstm = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CNetFindFilter::GenerateQueryRestrictions(LPWSTR *ppszQuery, DWORD *pdwFlags)
{
    if (ppszQuery)
        *ppszQuery = NULL;
    *pdwFlags = 0;
    return E_NOTIMPL;
}

STDMETHODIMP CNetFindFilter::ReleaseQuery()
{
    return S_OK;
}

HRESULT CNetFindFilter::UpdateField(LPCWSTR pszField, VARIANT vValue)
{
    HRESULT hr = E_FAIL;

    if (0 == StrCmpIW(pszField, L"LookIn"))
    {
        hr = S_OK;  // ignored
    }
    else if (0 == StrCmpIW(pszField, L"SearchFor"))
    {
        // Careful!  VariantToStr returns a pointer, not an HRESULT
        if (VariantToStr(&vValue, _szUserInputCompName, ARRAYSIZE(_szUserInputCompName)))
        {
            hr = S_OK;
        }
    }

    return hr;
}

HRESULT CNetFindFilter::ResetFieldsToDefaults()
{
    _szUserInputCompName[0] = 0;
    return S_OK;
}

STDMETHODIMP CNetFindFilter::DeclareFSNotifyInterest(HWND hwndDlg, UINT uMsg)
{
    SHChangeNotifyEntry fsne;

    fsne.fRecursive = TRUE;
    fsne.pidl = _pidlStart;
    if (fsne.pidl) 
    {
        SHChangeNotifyRegister(hwndDlg, SHCNRF_NewDelivery | SHCNRF_ShellLevel, SHCNE_DISKEVENTS, uMsg, 1, &fsne);
    }

    return S_OK;
}

// chop off all of an UNC path except the \\server portion

void _StripToServer(LPTSTR pszUNC)
{
    for (pszUNC += 2; *pszUNC; pszUNC = CharNext(pszUNC))
    {
        if (*pszUNC == TEXT('\\'))
        {
            // found something after server name, so get rid of it
            *pszUNC = 0;
            break;
        }
    }
}

// Helper function to the next function to help process find computer
// on returning computers by UNC names...

HRESULT CNetFindEnum::_FindCompByUNCName(LPITEMIDLIST *ppidl, int *piState)
{
    *piState = GNF_DONE;    // assume we are done

    // Two cases, There is a UNC name entered.  If so we need to process
    // this by extracting everythign off after the server name...
    if (_pnetf->_pszCompName && _pnetf->_pszCompName[0])
    {
        if (PathIsUNC(_pnetf->_pszCompName))
        {
            _StripToServer(_pnetf->_pszCompName);
        }
        else
        {
            // no unc name, but lets try to convert to unc name
            TCHAR szTemp[MAX_PATH];
            szTemp[0] = TEXT('\\');
            szTemp[1] = TEXT('\\');
            szTemp[2] = 0;

            StrCatBuff(szTemp, _pnetf->_szUserInputCompName, ARRAYSIZE(szTemp)); 
            _StripToServer(szTemp);

            Str_SetPtr(&_pnetf->_pszCompName, szTemp);
        }
    }

    if (_pnetf->_pszCompName && _pnetf->_pszCompName[0])
    {
        // see if we can parse this guy... if so we have a match
        LPITEMIDLIST pidl;
        if (SUCCEEDED(SHParseDisplayName(_pnetf->_pszCompName, NULL, &pidl, 0, NULL)))
        {
            LPITEMIDLIST pidlFolder;
            LPCITEMIDLIST pidlChild;
            if (SUCCEEDED(SplitIDList(pidl, &pidlFolder, &pidlChild)))
            {
                if (SUCCEEDED(_pff->AddFolder(pidlFolder, FALSE, &_iFolder)))
                {
                    if (SUCCEEDED(_pff->AddDataToIDList(pidlChild, _iFolder, pidlFolder, DFDF_NONE, 0, 0, 0, ppidl)))
                        *piState = GNF_MATCH;
                }
                ILFree(pidlFolder);
            }
            ILFree(pidl);
        }
    }
    return S_OK;
}

STDMETHODIMP CNetFindEnum::Next(LPITEMIDLIST *ppidl, int *pcObjectSearched, 
                                int *pcFoldersSearched, BOOL *pfContinue, int *piState)
{
    HRESULT hr;
    // Special case to find UNC Names quickly
    if (_fFindUNC)
    {
        // If not the first time through return that we are done!
        if (_iPassCnt)
        {
            *piState = GNF_DONE;
            return S_OK;
        }

        _iPassCnt = 1;

        hr = _FindCompByUNCName(ppidl, piState);
    }
    else
    {
        BOOL fContinue = TRUE;

        do
        {
            if (_penum)
            {
                LPITEMIDLIST pidl;
                if (S_OK == _penum->Next(1, &pidl, NULL))
                {
                    // Now see if this is someone we might want to return.
                    // Our Match function take esither find data or idlist...
                    // for networks we work off of the idlist,
                    fContinue = FALSE;  // We can exit the loop;
                    (*pcObjectSearched)++;
                
                    if (_pnetf->MatchFilter(_psfEnum, pidl))
                    {
                        *piState = GNF_MATCH;

                        // see if we have to add this folder to our list.
                        if (-1 == _iFolder)
                            _pff->AddFolder(_pidlFolder, FALSE, &_iFolder);

                        if (SUCCEEDED(_pff->AddDataToIDList(pidl, _iFolder, _pidlFolder, DFDF_NONE, 0, 0, 0, ppidl)))
                        {
                            if ((_iPassCnt == 1) && _pnetf->_pszCompName && _pnetf->_pszCompName[0])
                            {
                                // See if this is an exact match of the name
                                // we are looking for.  If it is we set pass=2
                                // as to not add the item twice.
                                TCHAR szName[MAX_PATH];

                                if (SUCCEEDED(DisplayNameOf(_psfEnum, pidl, SHGDN_NORMAL, szName, ARRAYSIZE(szName))) &&
                                    (0 == lstrcmpi(szName, _pnetf->_szUserInputCompName)))
                                {
                                    _iPassCnt = 2;
                                }
                            }
                            ILFree(pidl);
                            pidl = NULL;
                            break;
                        }
                    }
                    else
                    {
                        *piState = GNF_NOMATCH;
                    }
                    ILFree(pidl);
                }
                else
                {
                    ATOMICRELEASE(_penum);      // release and zero
                    ATOMICRELEASE(_psfEnum);
                }
            }

            if (!_penum)
            {
                switch (_iPassCnt)
                {
                case 1:
                    // We went through all of the items see if there is
                    // an exact match...
                    _iPassCnt = 2;

                    return _FindCompByUNCName(ppidl, piState);

                case 2:
                    // We looped through everything so return done!
                    *piState = GNF_DONE;
                    return S_OK;

                case 0:
                    // This is the main pass through here...
                    // Need to clone the idlist
                    hr = SHILClone(_pidlStart, &_pidlFolder);
                    if (SUCCEEDED(hr))
                    {
                        _iPassCnt = 1;

                        // We will do the first on in our own thread.
                        if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, _pidlFolder, &_psfEnum))))
                        {
                            if (S_OK != _psfEnum->EnumObjects(NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &_penum))
                            {
                                // Failed to get iterator so release folder.
                                ATOMICRELEASE(_psfEnum);
                                ASSERT(NULL == _penum);
                            }
                        }
                        break;
                    }
                    else
                    {
                       *piState = GNF_ERROR;
                       return hr;
                    }
                }

                (*pcFoldersSearched)++;

                // update progress text
                SHGetNameAndFlags(_pidlFolder, SHGDN_NORMAL, _pszDisplayText, MAX_PATH, NULL);
            }
        } while (fContinue && *pfContinue);

        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP_(BOOL) CNetFindEnum::FQueryIsAsync()
{
    return FALSE;
}

STDMETHODIMP CNetFindEnum::GetAsyncCount(DBCOUNTITEM *pdwTotalAsync, int *pnPercentComplete, BOOL *pfQueryDone)
{
    return E_NOTIMPL;
}

STDMETHODIMP CNetFindEnum::GetItemIDList(UINT iItem, LPITEMIDLIST *ppidl)
{
    return E_NOTIMPL;
}

STDMETHODIMP CNetFindEnum::GetItemID(UINT iItem, DWORD *puWorkID)
{
    *puWorkID = (UINT)-1;
    return E_NOTIMPL;
}

STDMETHODIMP CNetFindEnum::SortOnColumn(UINT iCOl, BOOL fAscending)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\netapi.cpp ===
#include "shellprv.h"
#include "netview.h"
#include "mtpt.h"
#include "ids.h"

#pragma  hdrstop

// from mtptarun.cpp
STDAPI_(void) CMtPt_SetWantUI(int iDrive);

//
// Converts an offset to a string to a string pointer.
//

LPCTSTR _Offset2Ptr(LPTSTR pszBase, UINT_PTR offset, UINT * pcb)
{
    LPTSTR pszRet;
    if (offset == 0) 
    {
        pszRet = NULL;
        *pcb = 0;
    } 
    else 
    {
        pszRet = (LPTSTR)((LPBYTE)pszBase + offset);
        *pcb = (lstrlen(pszRet) + 1) * sizeof(TCHAR);
    }
    return pszRet;
}


//
// exported networking APIs from shell32
//

STDAPI_(UINT) SHGetNetResource(HNRES hnres, UINT iItem, LPNETRESOURCE pnresOut, UINT cbMax)
{
    UINT iRet = 0;        // assume error
    LPNRESARRAY panr = (LPNRESARRAY)GlobalLock(hnres);
    if (panr)
    {
        if (iItem==(UINT)-1)
        {
            iRet = panr->cItems;
        }
        else if (iItem < panr->cItems)
        {
            UINT cbProvider, cbRemoteName;
            LPCTSTR pszProvider = _Offset2Ptr((LPTSTR)panr, (UINT_PTR)panr->nr[iItem].lpProvider, &cbProvider);
            LPCTSTR pszRemoteName = _Offset2Ptr((LPTSTR)panr, (UINT_PTR)panr->nr[iItem].lpRemoteName, &cbRemoteName);
            iRet = sizeof(NETRESOURCE) + cbProvider + cbRemoteName;
            if (iRet <= cbMax)
            {
                DWORD cch;
                LPTSTR psz = (LPTSTR)(pnresOut + 1);
                *pnresOut = panr->nr[iItem];
                if (pnresOut->lpProvider)
                {
                    cch = cbProvider / sizeof(TCHAR); // Includes NULL terminator

                    pnresOut->lpProvider = psz;
                    StrCpyN(psz, pszProvider, cch);
                    psz += cch;
                }
                if (pnresOut->lpRemoteName)
                {
                    cch = cbRemoteName / sizeof(TCHAR); // Includes NULL terminator
                    pnresOut->lpRemoteName = psz;
                    StrCpyN(psz, pszRemoteName, cch);
                }
            }
            else
            {
                iRet = 0; // FAIL if not enough space in the buffer!
            }
        }
        GlobalUnlock(hnres);
    }
    return iRet;
}


STDAPI_(DWORD) SHNetConnectionDialog(HWND hwnd, LPTSTR pszRemoteName, DWORD dwType)
{
    CONNECTDLGSTRUCT cds = {0};
    NETRESOURCE nr = {0};

    cds.cbStructure = sizeof(cds);  /* size of this structure in bytes */
    cds.hwndOwner = hwnd;           /* owner window for the dialog */
    cds.lpConnRes = &nr;            /* Requested Resource info    */
    cds.dwFlags = CONNDLG_USE_MRU;  /* flags (see below) */

    nr.dwType = dwType;

    if (pszRemoteName)
    {
        nr.lpRemoteName = pszRemoteName;
        cds.dwFlags = CONNDLG_RO_PATH;
    }
    DWORD mnr = WNetConnectionDialog1(&cds);
    if (mnr == WN_SUCCESS && dwType != RESOURCETYPE_PRINT && cds.dwDevNum != 0)
    {
        TCHAR szPath[4];

        CMountPoint::WantAutorunUI(PathBuildRoot(szPath, cds.dwDevNum - 1 /* 1-based! */));
    }
    return mnr;
}

typedef struct
{
    HWND    hwnd;
    TCHAR   szRemoteName[MAX_PATH];
    DWORD   dwType;
} SHNETCONNECT;

DWORD CALLBACK _NetConnectThreadProc(void *pv)
{
    SHNETCONNECT *pshnc = (SHNETCONNECT *)pv;
    HWND hwndDestroy = NULL;

    if (!pshnc->hwnd)
    {
        RECT rc;
        LPPOINT ppt;
        DWORD pid;

        // Wild multimon guess - Since we don't have a parent window,
        // we will arbitrarily position ourselves in the same location as
        // the foreground window, if the foreground window belongs to our
        // process.
        HWND hwnd = GetForegroundWindow();

        if (hwnd                                    && 
            GetWindowThreadProcessId(hwnd, &pid)    &&
            (pid == GetCurrentProcessId())          && 
            GetWindowRect(hwnd, &rc))
        {
            // Don't use the upper left corner exactly; slide down by
            // some fudge factor.  We definitely want to get past the
            // caption.
            rc.top += GetSystemMetrics(SM_CYCAPTION) * 4;
            rc.left += GetSystemMetrics(SM_CXVSCROLL) * 4;
            ppt = (LPPOINT)&rc;
        }
        else
        {
            ppt = NULL;
        }

        // Create a stub window so the wizard can establish an Alt+Tab icon
        hwndDestroy = _CreateStubWindow(ppt, NULL);
        pshnc->hwnd = hwndDestroy;
    }

    SHNetConnectionDialog(pshnc->hwnd, pshnc->szRemoteName[0] ? pshnc->szRemoteName : NULL, pshnc->dwType);

    if (hwndDestroy)
        DestroyWindow(hwndDestroy);

    LocalFree(pshnc);

    SHChangeNotifyHandleEvents();
    return 0;
}


STDAPI SHStartNetConnectionDialog(HWND hwnd, LPCTSTR pszRemoteName OPTIONAL, DWORD dwType)
{
    SHNETCONNECT *pshnc = (SHNETCONNECT *)LocalAlloc(LPTR, sizeof(SHNETCONNECT));
    if (pshnc)
    {
        pshnc->hwnd = hwnd;
        pshnc->dwType = dwType;
        if (pszRemoteName)
            StrCpyN(pshnc->szRemoteName, pszRemoteName, ARRAYSIZE(pshnc->szRemoteName));

        if (!SHCreateThread(_NetConnectThreadProc, pshnc, CTF_PROCESS_REF | CTF_COINIT, NULL))
        {
            LocalFree((HLOCAL)pshnc);
        } 
    }
    return S_OK;    // whole thing is async, value here is meaningless
}


#ifdef UNICODE

STDAPI SHStartNetConnectionDialogA(HWND hwnd, LPCSTR pszRemoteName, DWORD dwType)
{
    WCHAR wsz[MAX_PATH];

    if (pszRemoteName)
    {
        SHAnsiToUnicode(pszRemoteName, wsz, SIZECHARS(wsz));
        pszRemoteName = (LPCSTR)wsz;
    }
    return SHStartNetConnectionDialog(hwnd, (LPCTSTR)pszRemoteName, dwType);
}

#else

STDAPI SHStartNetConnectionDialogW(HWND hwnd, LPCWSTR pszRemoteName, DWORD dwType)
{
    char sz[MAX_PATH];

    if (pszRemoteName)
    {
        SHUnicodeToAnsi(pszRemoteName, sz, SIZECHARS(sz));
        pszRemoteName = (LPCWSTR)sz;
    }

    return SHStartNetConnectionDialog(hwnd, (LPCTSTR)pszRemoteName, dwType);
}

#endif


// These are wrappers around the same WNet APIs, but play with the parameters
// to make it easier to call.  They accept full paths rather than just drive letters.
//
DWORD APIENTRY SHWNetDisconnectDialog1 (LPDISCDLGSTRUCT lpConnDlgStruct)
{
    TCHAR szLocalName[3];

    if (lpConnDlgStruct && lpConnDlgStruct->lpLocalName && lstrlen(lpConnDlgStruct->lpLocalName) > 2)
    {
        // Kludge allert, don't pass c:\ to API, instead only pass C:
        szLocalName[0] = lpConnDlgStruct->lpLocalName[0];
        szLocalName[1] = TEXT(':');
        szLocalName[2] = 0;
        lpConnDlgStruct->lpLocalName = szLocalName;
    }

    return WNetDisconnectDialog1 (lpConnDlgStruct);
}


DWORD APIENTRY SHWNetGetConnection (LPCTSTR lpLocalName, LPTSTR lpRemoteName, LPDWORD lpnLength)
{
    TCHAR szLocalName[3];

    if (lpLocalName && lstrlen(lpLocalName) > 2)
    {
        // Kludge allert, don't pass c:\ to API, instead only pass C:
        szLocalName[0] = lpLocalName[0];
        szLocalName[1] = TEXT(':');
        szLocalName[2] = 0;
        lpLocalName = szLocalName;
    }

    return WNetGetConnection (lpLocalName, lpRemoteName, lpnLength);
}


// exported for netfind.cpp to use

STDAPI SHGetDomainWorkgroupIDList(LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;

    IShellFolder *psfDesktop;
    HRESULT hr = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hr))
    {
        TCHAR szName[MAX_PATH];

        StrCpyN(szName, TEXT("\\\\"), ARRAYSIZE(szName));

        if (RegGetValueString(HKEY_LOCAL_MACHINE, 
                TEXT("SYSTEM\\CurrentControlSet\\Control\\ComputerName\\ComputerName"),
                TEXT("ComputerName"), szName + 2, sizeof(szName) - 2 * sizeof(TCHAR)))
        {
            WCHAR wszName[MAX_PATH];

            SHTCharToUnicode(szName, wszName, ARRAYSIZE(wszName));

            hr = psfDesktop->ParseDisplayName(NULL, NULL, wszName, NULL, ppidl, NULL);
            if (SUCCEEDED(hr))
                ILRemoveLastID(*ppidl);
        }
        else
            hr = E_FAIL;

        psfDesktop->Release();
    }
    return hr;
}


// SHGetComputerDisplayName - formats and returns the computer name for display.

#define REGSTR_PATH_COMPUTERDESCCACHE  REGSTR_PATH_EXPLORER TEXT("\\ComputerDescriptions")

STDAPI_(void) SHCacheComputerDescription(LPCTSTR pszMachineName, LPCTSTR pszDescription)
{
    if (pszDescription)
    {
        DWORD cb = (lstrlen(pszDescription) + 1) * sizeof(*pszDescription);
        SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_COMPUTERDESCCACHE, SkipServerSlashes(pszMachineName), REG_SZ, pszDescription, cb);
    }
}

STDAPI _GetComputerDescription(LPCTSTR pszMachineName, LPTSTR pszDescription, DWORD cchDescription)
{
    SERVER_INFO_101 *psv101 = NULL;
    HRESULT hr = ResultFromWin32(NetServerGetInfo((LPWSTR)pszMachineName, 101, (BYTE**)&psv101));
    if (SUCCEEDED(hr))
    {
        if (psv101->sv101_comment && psv101->sv101_comment[0])
        {
            StrCpyN(pszDescription, psv101->sv101_comment, cchDescription);
        }
        else
        {
            hr = E_FAIL;
        }
        NetApiBufferFree(psv101);
    }
    return hr;
}

HRESULT _GetCachedComputerDescription(LPCTSTR pszMachineName, LPTSTR pszDescription, int cchDescription)
{
    ULONG cb = cchDescription*sizeof(*pszDescription);
    return ResultFromWin32(SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_COMPUTERDESCCACHE, SkipServerSlashes(pszMachineName), NULL, pszDescription, &cb));
}

STDAPI SHGetComputerDisplayNameW(LPCWSTR pszMachineName, DWORD dwFlags, LPWSTR pszDisplay, DWORD cchDisplay)
{
    HRESULT hr = E_FAIL;

    // map the NULL machine name to the local computer name - so we can cache correctly.

    WCHAR szMachineName[CNLEN + 1];
    if (!pszMachineName)
    {
        DWORD cchMachine = ARRAYSIZE(szMachineName);
        if (GetComputerName(szMachineName, &cchMachine))
        {
            pszMachineName = szMachineName;
            dwFlags |= SGCDNF_NOCACHEDENTRY;
        }
    }

    // we must have a machine name, so we can perform the look up.

    if (pszMachineName)
    {
        WCHAR szDescription[256];

        // can we read the name from teh cache, if not/or the user says they don't want
        // the cached name then lets hit the wire and read it.

        if (!(dwFlags & SGCDNF_NOCACHEDENTRY))
            hr = _GetCachedComputerDescription(pszMachineName, szDescription, ARRAYSIZE(szDescription));

        if (FAILED(hr))
        {
            hr = _GetComputerDescription(pszMachineName, szDescription, ARRAYSIZE(szDescription));
            if (FAILED(hr))
            {
                *szDescription = _TEXT('\0');
            }
            if (!(dwFlags & SGCDNF_NOCACHEDENTRY))
            {
                SHCacheComputerDescription(pszMachineName, szDescription);  // write through to cache
            }
        }

        // we have a name, so lets format it, if they request description only / or we failed
        // above lets just return raw string.  otherwise we build a new machine name based
        // on the remote name and the description we fetched.

        if (SUCCEEDED(hr) && *szDescription)
        {
            if (dwFlags & SGCDNF_DESCRIPTIONONLY)
            {
                StrCpyN(pszDisplay, szDescription, cchDisplay);
                hr = S_OK;
            }
            else
            {
                hr = SHBuildDisplayMachineName(pszMachineName, szDescription, pszDisplay, cchDisplay);
            }
        }
        else if (!(dwFlags & SGCDNF_DESCRIPTIONONLY))
        {
            StrCpyN(pszDisplay, SkipServerSlashes(pszMachineName), cchDisplay);
            hr = S_OK;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\netcrawl.cpp ===
#include "shellprv.h"
#include "commctrl.h"
#include "comctrlp.h"
#pragma hdrstop

#include "netview.h"
#include "msprintx.h"
#include "setupapi.h"
#include "ras.h"
#include "ids.h"


// a COM object to enumerate shares and printers in the shell, its acts
// as a monitor for all that is going on.

class CWorkgroupCrawler : public INetCrawler, IPersistPropertyBag
{
public:
    CWorkgroupCrawler();
    ~CWorkgroupCrawler();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // INetCrawler
    STDMETHOD(Update)(DWORD dwFlags);

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pclsid)
        { *pclsid = CLSID_WorkgroupNetCrawler; return S_OK; }

    // IPersistPropertyBag
    STDMETHOD(InitNew)()
        { return S_OK; }
    STDMETHOD(Load)(IPropertyBag *ppb, IErrorLog *pel)
        { IUnknown_Set((IUnknown**)&_ppb, ppb); return S_OK; }
    STDMETHOD(Save)(IPropertyBag *ppb, BOOL fClearDirty, BOOL fSaveAll)
        { return S_OK; }

private:
    HRESULT _GetMRUs();
    void _AgeOutShares(BOOL fDeleteAll);
    HRESULT _CreateShortcutToShare(LPCTSTR pszRemoteName);
    HRESULT _InstallPrinter(LPCTSTR pszRemoteName);
    BOOL _KeepGoing(int *pcMachines, int *pcShares, int *pcPrinters);
    void _EnumResources(LPNETRESOURCE pnr, int *pcMachines, HDPA hdaShares, HDPA hdaPrinters);
    HANDLE _AddPrinterConnectionNoUI(LPCWSTR pszRemoteName, BOOL *pfInstalled);

    static int CALLBACK _DiscardCB(void *pvItem, void *pv);
    static int CALLBACK _InstallSharesCB(void *pvItem, void *pv);
    static int CALLBACK _InstallPrinterCB(void *pvItem, void *pv);

    LONG _cRef;                 // reference count for the object
    HANDLE _hPrinters;          // MRU for printers 
    HKEY _hShares;              // registry key for the printer shares
    HINSTANCE _hPrintUI;        // instance handle for printui.dll    
    IPropertyBag *_ppb;         // property bag object for state
};


// constants for the MRU's and buffers

#define WORKGROUP_PATH \
            REGSTR_PATH_EXPLORER TEXT("\\WorkgroupCrawler")

#define PRINTER_SUBKEY     \
            (WORKGROUP_PATH TEXT("\\Printers"))
   
#define SHARE_SUBKEY     \
            (WORKGROUP_PATH TEXT("\\Shares"))

#define LAST_VISITED    TEXT("DateLastVisited")
#define SHORTCUT_NAME   TEXT("Filename")

#define MAX_MACHINES    32
#define MAX_PRINTERS    10
#define MAX_SHARES      10

#define CB_WNET_BUFFER  (8*1024)

typedef HANDLE (* ADDPRINTCONNECTIONNOUI)(LPCWSTR, BOOL *);


// construction and IUnknown

CWorkgroupCrawler::CWorkgroupCrawler() :
    _cRef(1)
{
}

CWorkgroupCrawler::~CWorkgroupCrawler()
{
    if (_hPrinters)
        FreeMRUList(_hPrinters);

    if (_hShares)
        RegCloseKey(_hShares);

    if (_hPrintUI)
        FreeLibrary(_hPrintUI);

    if (_ppb)
        _ppb->Release();
}

STDMETHODIMP CWorkgroupCrawler::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CWorkgroupCrawler, INetCrawler),           // IID_INetCrawler
        QITABENT(CWorkgroupCrawler, IPersist),              // IID_IPersist
        QITABENT(CWorkgroupCrawler, IPersistPropertyBag),   // IID_IPersistPropertyBag
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CWorkgroupCrawler::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CWorkgroupCrawler::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDAPI CWorkgroupCrawler_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv)
{
    CWorkgroupCrawler *pwgc = new CWorkgroupCrawler();            
    if (!pwgc)
        return E_OUTOFMEMORY;

    HRESULT hr = pwgc->QueryInterface(riid, ppv);
    pwgc->Release();
    return hr;
}


// lets open the keys for the objects we are about to install

HRESULT CWorkgroupCrawler::_GetMRUs()
{
    // get the printers MRU if we need to allocate one

    if (!_hPrinters)
    {
        MRUINFO mi = { 0 };
        mi.cbSize = sizeof(mi);
        mi.hKey = HKEY_CURRENT_USER;
        mi.uMax = (MAX_PRINTERS * MAX_MACHINES);
        mi.lpszSubKey = PRINTER_SUBKEY;

        _hPrinters = CreateMRUList(&mi);
        if (!_hPrinters)
            return E_OUTOFMEMORY;    
    }

    if (!_hShares) 
    {
        DWORD dwres = RegCreateKeyEx(HKEY_CURRENT_USER, SHARE_SUBKEY, 
                                     0, 
                                     TEXT(""), 
                                     0, 
                                     MAXIMUM_ALLOWED, 
                                     NULL, 
                                     &_hShares, 
                                     NULL);
        if (WN_SUCCESS != dwres)
        {
            return E_FAIL;
        }
    }

    return S_OK;                // success
}

                                            
// lets create a folder shortcut to the object

HRESULT CWorkgroupCrawler::_CreateShortcutToShare(LPCTSTR pszRemoteName)
{
    HRESULT hr = S_OK;
    TCHAR szTemp[MAX_PATH];
    BOOL fCreateLink = FALSE;
    HKEY hk = NULL;

    // the share information is stored in the registry as follows:
    //
    //  Shares
    //      Remote Name
    //          value: shortcut name
    //          value: last seen
    //
    // as we add each share we update the information stored in this list in 
    // the registry.  for each entry we have the shortcut name (so we can remove it)
    // and the time and date we last visited the share.

    // determine if we need to recreate the object?

    StrCpyN(szTemp, pszRemoteName+2, ARRAYSIZE(szTemp));  
    LPTSTR pszTemp = StrChr(szTemp, TEXT('\\'));
    if (pszTemp)
    {
        *pszTemp = TEXT('/');               // convert the \\...\... to .../...

        DWORD dwres = RegOpenKeyEx(_hShares, szTemp, 0, MAXIMUM_ALLOWED, &hk);
        if (WN_SUCCESS != dwres)
        {
            fCreateLink = TRUE;
            dwres = RegCreateKeyEx(_hShares, szTemp, 0, TEXT(""), 0, MAXIMUM_ALLOWED, NULL, &hk, NULL);
        }

        if (WN_SUCCESS == dwres)
        {
            // if we haven't already seen the link (eg. the key didn't exist in the registry
            // then lets create it now.

            if (fCreateLink)
            {
                // NOTE: we must use SHCoCreateInstance() here because we are being called from a thread
                //       that intentionally did not initialize COM (see comment in Update())

                IShellLink *psl;
                hr = SHCoCreateInstance(NULL, &CLSID_FolderShortcut, NULL, IID_PPV_ARG(IShellLink, &psl));
                if (SUCCEEDED(hr))
                {
                    psl->SetPath(pszRemoteName);                 // sotore the remote name, its kinda important

                    // get a description for the link, this comes either from the desktop.ini or the
                    // is a pretty version of teh remote name.

                    if (GetShellClassInfo(pszRemoteName, TEXT("InfoTip"), szTemp, ARRAYSIZE(szTemp)))
                    {
                        psl->SetDescription(szTemp);
                    }
                    else
                    {
                        StrCpyN(szTemp, pszRemoteName, ARRAYSIZE(szTemp));
                        PathMakePretty(szTemp);
                        psl->SetDescription(szTemp);
                    }

                    // some links (shared documents) can specify a shortcut name, if this is specified
                    // then use it, otherwise get a filename from the nethood folder (eg. foo on bah).
                    //
                    // we musst also record the name we save the shortcut as, this used when we
                    // age out the links from the hood folder.

                    if (!GetShellClassInfo(pszRemoteName, TEXT("NetShareDisplayName"), szTemp, ARRAYSIZE(szTemp)))
                    {
                        LPITEMIDLIST pidl;
                        hr = SHILCreateFromPath(pszRemoteName, &pidl, NULL);
                        if (SUCCEEDED(hr))
                        {
                            hr = SHGetNameAndFlags(pidl, SHGDN_NORMAL, szTemp, ARRAYSIZE(szTemp), NULL); 
                            ILFree(pidl);
                        }
                    }
                    else
                    {
                        hr = S_OK;
                    }

// should we find a unique name (daviddv)

                    if (SUCCEEDED(hr))
                    {
                        if (NO_ERROR == SHSetValue(hk, NULL, SHORTCUT_NAME, REG_SZ, szTemp, lstrlen(szTemp)*sizeof(TCHAR)))
                        {
                            hr = SaveShortcutInFolder(CSIDL_NETHOOD, szTemp, psl);
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                    }

                    psl->Release();
                }
            }

            // lets update the time we last saw the link into the registry - this is used for the clean up
            // pass we will perform.

            if (SUCCEEDED(hr))
            {
                FILETIME ft;
                GetSystemTimeAsFileTime(&ft);

                dwres = SHSetValue(hk, NULL, LAST_VISITED, REG_BINARY, (void*)&ft, sizeof(ft));
                hr = (NO_ERROR != dwres) ? E_FAIL:S_OK;
            }
        }

        if (hk)
            RegCloseKey(hk);
    }
    else
    {
        hr = E_UNEXPECTED;
    }
    
    return hr;
}


// walk the list of shares stored in the registry to determine which ones should be
// removed from the file system and the list.  all files older than 7 days need to
// be removed.

#define FILETIME_SECOND_OFFSET (LONGLONG)((1 * 10 * 1000 * (LONGLONG)1000))

void CWorkgroupCrawler::_AgeOutShares(BOOL fDeleteAll)
{
    FILETIME ft;
    ULARGE_INTEGER ulTime;
    DWORD index = 0;
    TCHAR szFilesToDelete[1024];
    int cchFilesToDelete = 0;

    GetSystemTimeAsFileTime(&ft);
    ulTime = *((ULARGE_INTEGER*)&ft);
    ulTime.QuadPart -= FILETIME_SECOND_OFFSET*((60*60*24)*2);

    SHQueryInfoKey(_hShares, &index, NULL, NULL, NULL);           // retrieve the count of the keys

    while (((LONG)(--index)) >= 0)
    {
        TCHAR szKey[MAX_PATH];
        DWORD cb = ARRAYSIZE(szKey);
        BOOL fRemoveKey = FALSE;

        if (WN_SUCCESS == SHEnumKeyEx(_hShares, index, szKey, &cb)) 
        {
            // we enumerated a key name, so lets open it so we can look around inside.

            HKEY hk;
            if (WN_SUCCESS == RegOpenKeyEx(_hShares, szKey, 0, MAXIMUM_ALLOWED, &hk))
            {
                ULARGE_INTEGER ulLastSeen;

                // when did we last crawl to this object, if it was less than the time we
                // have for our threshold, then we go through the process of cleaning up the
                // object.

                cb = sizeof(ulLastSeen);
                if (ERROR_SUCCESS == SHGetValue(hk, NULL, LAST_VISITED, NULL, (void*)&ulLastSeen, &cb))
                {
                    if (fDeleteAll || (ulLastSeen.QuadPart <= ulTime.QuadPart))
                    {
                        TCHAR szName[MAX_PATH];
                        cb = ARRAYSIZE(szName)*sizeof(TCHAR);
                        if (ERROR_SUCCESS == SHGetValue(hk, NULL, SHORTCUT_NAME, NULL, &szName, &cb))
                        {
                            TCHAR szPath[MAX_PATH];

                            // compose the path to the object we want to delete.  if the buffer
                            // is full (eg. this item would over run the size) then flush the
                            // buffer.

                            SHGetFolderPath(NULL, CSIDL_NETHOOD|CSIDL_FLAG_CREATE, NULL, 0, szPath);
                            PathAppend(szPath, szName);

                            if ((lstrlen(szPath)+cchFilesToDelete) >= ARRAYSIZE(szFilesToDelete))
                            {
                                SHFILEOPSTRUCT shfo = { NULL, FO_DELETE, szFilesToDelete, NULL, 
                                                        FOF_SILENT|FOF_NOCONFIRMATION|FOF_NOERRORUI, FALSE, NULL, NULL };

                                szFilesToDelete[cchFilesToDelete] = 0;            // double terminate
                                SHFileOperation(&shfo); 

                                cchFilesToDelete = 0;
                            }

                            // add this name to the buffer

                            StrCpyN(&szFilesToDelete[cchFilesToDelete], szPath, ARRAYSIZE(szFilesToDelete)-cchFilesToDelete);
                            cchFilesToDelete += lstrlen(szPath)+1;
                        }

                        fRemoveKey = TRUE;
                    }
                }

                RegCloseKey(hk);

                // we can only close the key once it has been closed

                if (fRemoveKey)
                    SHDeleteKey(_hShares, szKey);
            }                
        }
    }

    // are there any trailing files in the buffer?  if so then lets nuke them also

    if (cchFilesToDelete)
    {
        SHFILEOPSTRUCT shfo = { NULL, FO_DELETE, szFilesToDelete, NULL, 
                                FOF_SILENT|FOF_NOCONFIRMATION|FOF_NOERRORUI, FALSE, NULL, NULL };

        szFilesToDelete[cchFilesToDelete] = 0;            // double terminate
        SHFileOperation(&shfo); 
    }
}


// silently install printers we have discovered.   we have the remote name of the
// printer share, so we then call printui to perform the printer installation
// which it does without UI (hopefully).   

HANDLE CWorkgroupCrawler::_AddPrinterConnectionNoUI(LPCWSTR pszRemoteName, BOOL *pfInstalled)
{
    HANDLE hResult = NULL;

    if (!_hPrintUI)
        _hPrintUI = LoadLibrary(TEXT("printui.dll"));

    if (_hPrintUI)
    {
        ADDPRINTCONNECTIONNOUI apc = (ADDPRINTCONNECTIONNOUI)GetProcAddress(_hPrintUI, (LPCSTR)200);
        if (apc)
        {
            hResult = apc(pszRemoteName, pfInstalled);
        }
    }

    return hResult;
}

HRESULT CWorkgroupCrawler::_InstallPrinter(LPCTSTR pszRemoteName)
{
    if (-1 == FindMRUString(_hPrinters, pszRemoteName, NULL))
    {
        BOOL fInstalled;
        HANDLE hPrinter = _AddPrinterConnectionNoUI(pszRemoteName, &fInstalled);    
        if (hPrinter)
        {
            ClosePrinter(hPrinter);
            hPrinter = NULL;
        }
    }
    AddMRUString(_hPrinters, pszRemoteName);         // promote back to the top of the list
    return S_OK;
}


// check the counters, if we have max'd out then lets stop enumerating

BOOL CWorkgroupCrawler::_KeepGoing(int *pcMachines, int *pcShares, int *pcPrinters)
{
    if (pcMachines && (*pcMachines > MAX_MACHINES))
        return FALSE;
    if (pcShares && (*pcShares > MAX_SHARES))
        return FALSE;
    if (pcPrinters && (*pcPrinters > MAX_PRINTERS))
        return FALSE;

    return TRUE;
}

void CWorkgroupCrawler::_EnumResources(LPNETRESOURCE pnr, int *pcMachines, HDPA hdaShares, HDPA hdaPrinters)
{
    HANDLE hEnum = NULL;
    int cPrinters = 0;
    int cShares = 0;
    DWORD dwScope = RESOURCE_GLOBALNET;
    
    // if no net resource structure passed then lets enumerate the workgroup
    // (this is used for debugging)

    NETRESOURCE nr = { 0 };
    if (!pnr)
    {
        pnr = &nr;
        dwScope = RESOURCE_CONTEXT;
        nr.dwType = RESOURCETYPE_ANY;
        nr.dwUsage = RESOURCEUSAGE_CONTAINER;
    }

    // open the enumerator

    DWORD dwres = WNetOpenEnum(dwScope, RESOURCETYPE_ANY, 0, pnr, &hEnum);
    if (NO_ERROR == dwres)
    {
        NETRESOURCE *pnrBuffer = (NETRESOURCE*)SHAlloc(CB_WNET_BUFFER);        // avoid putting the buffer on the stack
        if (pnrBuffer)
        {
            while ((WN_SUCCESS == dwres) || (dwres == ERROR_MORE_DATA) && _KeepGoing(pcMachines, &cShares, &cPrinters))
            {
                DWORD cbEnumBuffer= CB_WNET_BUFFER;
                DWORD dwCount = -1;

                // enumerate the resources for this enum context and then lets
                // determine the objects which we should see.
            
                dwres = WNetEnumResource(hEnum, &dwCount, pnrBuffer, &cbEnumBuffer);
                if ((WN_SUCCESS == dwres) || (dwres == ERROR_MORE_DATA))
                {
                    DWORD index;
                    for (index = 0 ; (index != dwCount) && _KeepGoing(pcMachines, &cShares, &cPrinters) ; index++)
                    {    
                        LPNETRESOURCE pnr = &pnrBuffer[index];
                        LPTSTR pszRemoteName = pnr->lpRemoteName;

                        switch (pnr->dwDisplayType)
                        {
                            case RESOURCEDISPLAYTYPE_ROOT:      // ignore the entire network object
                            default:
                                break;

                            case RESOURCEDISPLAYTYPE_NETWORK:
                            {
                                // ensure that we only crawl the local network providers (eg. Windows Networking)
                                // crawling DAV, TSCLIENT etc can cause all sorts of random pop ups.                                    
                            
                                DWORD dwType, cbProviderType = sizeof(dwType);
                                if (WN_SUCCESS == WNetGetProviderType(pnr->lpProvider, &dwType))
                                {
                                    if (dwType == WNNC_NET_LANMAN)
                                    {
                                        _EnumResources(pnr, pcMachines, hdaShares, hdaPrinters);
                                    }
                                }
                                break;
                            }                                
                               
                            
                            case RESOURCEDISPLAYTYPE_DOMAIN:
                                _EnumResources(pnr, pcMachines, hdaShares, hdaPrinters);
                                break;
                        
                            case RESOURCEDISPLAYTYPE_SERVER:       
                            {
                                *pcMachines += 1;               // another machine found

                                if (!PathIsSlow(pszRemoteName, -1))
                                {
                                    SHCacheComputerDescription(pszRemoteName, pnr->lpComment);
                                    _EnumResources(pnr, pcMachines, hdaShares, hdaPrinters);
                                }

                                break;
                            }
                        
                            case RESOURCEDISPLAYTYPE_SHARE:                            
                            {
                                HDPA hdpa = NULL;
                                switch (pnr->dwType)
                                {
                                    case RESOURCETYPE_PRINT:
                                        cPrinters++;
                                        hdpa = hdaPrinters;
                                        break;

                                    case RESOURCETYPE_DISK:
                                        cShares++;
                                        hdpa = hdaShares;
                                        break;

                                    default:
                                        break;
                                }

                                if (hdpa)
                                {
                                    LPTSTR pszName = StrDup(pszRemoteName);
                                    if (pszName)
                                    {
                                        if (-1 == DPA_AppendPtr(hdpa, pszName))
                                        {
                                            LocalFree(pszName);
                                        }
                                    }
                                }
                                break;
                            }
                        }
                    } 
                }
            }            
            SHFree(pnrBuffer);
        }    

        WNetCloseEnum(hEnum);        
    }
}


// handle the clean up of the DPA's, either we are installing or 
// we are releasing objects.

int CALLBACK CWorkgroupCrawler::_DiscardCB(void *pvItem, void *pv)
{
    LPTSTR pszRemoteName = (LPTSTR)pvItem;
    LocalFree(pszRemoteName);
    return 1;
}

int CALLBACK CWorkgroupCrawler::_InstallPrinterCB(void *pvItem, void *pv)
{
    CWorkgroupCrawler* pnc = (CWorkgroupCrawler*)pv;
    if (pnc)
    {
        LPTSTR pszRemoteName = (LPTSTR)pvItem;
        pnc->_InstallPrinter(pszRemoteName);
    }
    return _DiscardCB(pvItem, pv);
}

int CALLBACK CWorkgroupCrawler::_InstallSharesCB(void *pvItem, void *pv)
{
    CWorkgroupCrawler* pnc = (CWorkgroupCrawler*)pv;
    if (pnc)
    {
        LPTSTR pszRemoteName = (LPTSTR)pvItem;
        pnc->_CreateShortcutToShare(pszRemoteName);
    }
    return _DiscardCB(pvItem, pv);
}

HRESULT CWorkgroupCrawler::Update(DWORD dwFlags)
{
    // don't crawl if we are logged in on a TS client, this will discover the shares and
    // printers local to the terminal server machine, rather than the ones local to the
    // users login domain - badness.

    if (SHGetMachineInfo(GMI_TSCLIENT))
        return S_OK;

    // by default we will only crawl if there isn't a RAS connection, therefore lets
    // check the status using RasEnumConnections.
    
    RASCONN rc = { 0 };
    DWORD cbConnections = sizeof(rc);
    DWORD cConnections = 0;

    rc.dwSize = sizeof(rc);
    if (!RasEnumConnections(&rc, &cbConnections, &cConnections) && cConnections)
        return S_OK;   

    // check to see if we are in a domain or not, if we are then we shouldn't crawl.  however
    // we do a provide a "WorkgroupOnly" policy which overrides this behaviour.  setting
    // this causes us to skip the check, and perform a CONTEXT ENUM below...

    BOOL fWorkgroupOnly = (_ppb ? SHPropertyBag_ReadBOOLDefRet(_ppb, L"WorkgroupOnly", FALSE):FALSE);
    if (IsOS(OS_DOMAINMEMBER) && !fWorkgroupOnly)
        return S_OK;   

    // populate the DPAs with shares and printer objects we find on the network, to
    // do this enumeration lets fake up a NETRESOURCE structure for entire network

    int cMachines = 0;
    HDPA hdaShares = DPA_Create(MAX_SHARES);
    HDPA hdaPrinters = DPA_Create(MAX_PRINTERS);

    if (hdaShares && hdaPrinters)
    {
        NETRESOURCE nr = { 0 };
        nr.dwDisplayType = RESOURCEDISPLAYTYPE_ROOT;
        nr.dwType = RESOURCETYPE_ANY;
        nr.dwUsage = RESOURCEUSAGE_CONTAINER;

        _EnumResources(fWorkgroupOnly ? NULL:&nr, &cMachines, hdaShares, hdaPrinters);
    }

    // now attempt to make connections to the shares and printers.  to do this
    // we need to look at the number of machines we have visited, if its less
    // than our threshold then we can install.

    if (SUCCEEDED(_GetMRUs()) && (cMachines < MAX_MACHINES))
    {
        DPA_DestroyCallback(hdaShares, _InstallSharesCB, this);
        DPA_DestroyCallback(hdaPrinters, _InstallPrinterCB, this);
        _AgeOutShares(FALSE);
    }
    else
    {
        DPA_DestroyCallback(hdaShares, _DiscardCB, this);
        DPA_DestroyCallback(hdaPrinters, _DiscardCB, this);
    }

    return S_OK;
}



// this is the main crawler object, from this we create the protocol specific
// crawlers which handle enumerating the resources for the various network types.

#define CRAWLER_SUBKEY     \
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\NetworkCrawler\\Objects")

class CNetCrawler : public INetCrawler
{
public:
    CNetCrawler();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // INetCrawler
    STDMETHOD(Update)(DWORD dwFlags);

private:
    static DWORD CALLBACK s_DoCrawl(void* pv);
    DWORD _DoCrawl();

    LONG _cRef;    
    LONG _cUpdateLock;              // > 0 then we are already spinning

    DWORD _dwFlags;                 // flags from update - passed to each of the crawler sub-objects
};

CNetCrawler* g_pnc = NULL;          // there is a single instance of this object


// construction / IUnknown

CNetCrawler::CNetCrawler() :
    _cRef(1)
{
}

STDMETHODIMP CNetCrawler::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CNetCrawler, INetCrawler),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CNetCrawler::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CNetCrawler::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        ENTERCRITICAL;
        g_pnc = NULL;
        LEAVECRITICAL;
    
        delete this;
    }
    return cRef;
}


// there is a single instance of the object, therefore in a critical section
// lets check to see if the global exists, if so then QI it, otherwise
// create a new one and QI that instead.

STDAPI CNetCrawler_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    ENTERCRITICAL;
    if (g_pnc)
    {
        hr = g_pnc->QueryInterface(riid, ppv);
    }
    else
    {
        g_pnc = new CNetCrawler();            
        if (g_pnc)
        {
            hr = g_pnc->QueryInterface(riid, ppv);
            g_pnc->Release();
        }
    }
    LEAVECRITICAL;
    return hr;
}


// this object has a execution count to inidicate if we are already crawling.  
// only if the count is 0 when the ::Update method is called, will create a thread
// which inturn will create each of the crawler objects and allow them to
// do their enumeration.

DWORD CALLBACK CNetCrawler::s_DoCrawl(void* pv)
{
    CNetCrawler *pnc = (CNetCrawler*)pv;
    return pnc->_DoCrawl();
}

DWORD CNetCrawler::_DoCrawl()
{
    // enumrate all the keys under the crawler sub-key, from that we can then
    // create the individual crawler objects.

    HKEY hk;
    DWORD dwres = RegOpenKeyEx(HKEY_LOCAL_MACHINE, CRAWLER_SUBKEY, 0, KEY_READ, &hk);
    if (WN_SUCCESS == dwres)
    {
        DWORD index = 0;
        SHQueryInfoKey(hk, &index, NULL, NULL, NULL);           // retrieve the count of the keys

        while (((LONG)(--index)) >= 0)
        {
            TCHAR szKey[MAX_PATH];
            DWORD cb = ARRAYSIZE(szKey);
            if (WN_SUCCESS == SHEnumKeyEx(hk, index, szKey, &cb)) 
            {
                // given the keyname, create a property bag so we can access
                
                IPropertyBag *ppb;
                HRESULT hr = SHCreatePropertyBagOnRegKey(hk, szKey, STGM_READ, IID_PPV_ARG(IPropertyBag, &ppb));
                if (SUCCEEDED(hr))
                {
                    // we have a property bag mapped to the registry for the items we need
                    // to read back, so lets get the CLSID and create a crawler from it.

                    CLSID clsid;
                    hr = SHPropertyBag_ReadGUID(ppb, L"CLSID", &clsid);
                    if (SUCCEEDED(hr))
                    {
                        INetCrawler *pnc;
                        hr = SHCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(INetCrawler, &pnc));
                        if (SUCCEEDED(hr))
                        {
                            // if the crawler supports IPersistPropertyBag then lets allow it
                            // to slurp its settings into from the registry.
                            SHLoadFromPropertyBag(pnc, ppb);

                            // allow it to update and load.
    
                            pnc->Update(_dwFlags);          // we don't care about the failure
                            pnc->Release();
                        }
                    }
                    ppb->Release();
                }
            }
        }

        RegCloseKey(hk);
    }

    ASSERT( 0 != _cUpdateLock );
    InterlockedDecrement(&_cUpdateLock);           // release the lock that signifies that we're updating:
    Release();                                       
    return 0;
}

STDMETHODIMP CNetCrawler::Update(DWORD dwFlags)
{
    // we either have policy defined to disable the crawler, or the
    // users has selected that they don't want to be able to auto discover
    // the world. 
    
    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_NONETCRAWLING, FALSE);
    if (ss.fNoNetCrawling || SHRestricted(REST_NONETCRAWL))
    {
        return S_OK;
    }

    // increase the lock, if its >0 then we should not bother crawling again
    // as we already have it covered, therefore decrease the lock counter.
    //
    // if the lock is ==0 then create the thread which will do the crawling
    // and inturn create the objects.

    HRESULT hr = S_OK;
    if (InterlockedIncrement(&_cUpdateLock) == 1)
    {
        _dwFlags = dwFlags; // store the flags for use later

        AddRef();
        if (!SHCreateThread(s_DoCrawl, (void*)this, CTF_COINIT, NULL))
        {
            Release();
            hr = E_FAIL;
        }
    }
    else
    {
        ASSERT( 0 != _cUpdateLock );
        InterlockedDecrement(&_cUpdateLock);
    }
    return hr;
}



// helper function that will invoke the net crawler to perform a async refresh,
// to ensure that we don't block we will create a thread which inturn will CoCreate
// the net crawler and then call its refresh method.

DWORD _RefreshCrawlerThreadProc(void *pv)
{
    INetCrawler *pnc;
    if (SUCCEEDED(CoCreateInstance(CLSID_NetCrawler, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(INetCrawler, &pnc))))
    {
        pnc->Update(SNCF_REFRESHLIST);
        pnc->Release();
    }
    return 0;
}
                
STDAPI_(void) RefreshNetCrawler()
{
    SHCreateThread(_RefreshCrawlerThreadProc, NULL, CTF_COINIT, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\netfldr.cpp ===
#include "shellprv.h"
#include "caggunk.h"
#include "views.h"
#include "ids.h"
#include "shitemid.h"
#include "fstreex.h"
#include "clsobj.h"
#include "datautil.h"
#include "winnetp.h"    // RESOURCE_SHAREABLE
#include "prop.h"
#include "infotip.h"
#include "basefvcb.h"
#include "netview.h"
#include "printer.h"
#include "fsdata.h"
#include "idldrop.h"
#include "enumidlist.h"
#include "util.h"
#include <webvw.h>


#define WNNC_NET_LARGEST WNNC_NET_SYMFONET


HRESULT CNetRootDropTarget_CreateInstance(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt);

class CNetData : public CFSIDLData
{
public:
    CNetData(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[]): CFSIDLData(pidlFolder, cidl, apidl, NULL) { };

    // IDataObject methods overwrite
    STDMETHODIMP GetData(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
    STDMETHODIMP QueryGetData(FORMATETC *pFmtEtc);

protected:
    STDMETHODIMP GetHDrop(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
};


// {22BEB58B-0794-11d2-A4AA-00C04F8EEB3E}
const GUID CLSID_CNetFldr = { 0x22beb58b, 0x794, 0x11d2, 0xa4, 0xaa, 0x0, 0xc0, 0x4f, 0x8e, 0xeb, 0x3e };

// idlist.c
STDAPI_(void) StrRetFormat(STRRET *pStrRet, LPCITEMIDLIST pidlRel, LPCTSTR pszTemplate, LPCTSTR pszAppend);

// in stdenum.cpp
STDAPI_(void *) CStandardEnum_CreateInstance(REFIID riid, BOOL bInterfaces, int cElement, int cbElement, void *rgElements,
                 void (WINAPI * pfnCopyElement)(void *, const void *, DWORD));

// is a \\server\printer object
BOOL _IsPrintShare(LPCIDNETRESOURCE pidn)
{
    return NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_SHARE && 
           NET_GetType(pidn) == RESOURCETYPE_PRINT;
}


// column information

enum
{
    ICOL_NAME = 0,
    ICOL_COMMENT,
    ICOL_COMPUTERNAME,
    ICOL_NETWORKLOCATION
};

const COLUMN_INFO s_net_cols[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_NAME,             30, IDS_NAME_COL),
    DEFINE_COL_STR_ENTRY(SCID_Comment,          30, IDS_EXCOL_COMMENT),
    DEFINE_COL_STR_ENTRY(SCID_COMPUTERNAME,     30, IDS_EXCOL_COMPUTER),
    DEFINE_COL_STR_ENTRY(SCID_NETWORKLOCATION,  30, IDS_NETWORKLOCATION),
};

#define MAX_ICOL_NETFOLDER          (ICOL_COMMENT+1)
#define MAX_ICOL_NETROOT            (ICOL_NETWORKLOCATION+1)

STDAPI CNetwork_DFMCallBackBG(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

class CNetFolderViewCB;
class CNetFolderEnum;

class CNetFolder : public CAggregatedUnknown, 
                   public IShellFolder2, 
                   public IPersistFolder3,
                   public IShellIconOverlay
{
    friend CNetFolderViewCB;
    friend CNetFolderEnum;

public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj)
                { return CAggregatedUnknown::QueryInterface(riid, ppvObj); };
    STDMETHODIMP_(ULONG) AddRef(void) 
                { return CAggregatedUnknown::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void) 
                { return CAggregatedUnknown::Release(); };

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList ** ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(HWND hwndOwner, REFIID riid, void **ppv);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST* apidl,
                               REFIID riid, UINT* prgfInOut, void **ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST* ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pGuid);
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD* pbState)
        { return _GetDefaultColumnState(MAX_ICOL_NETFOLDER, iColumn, pbState); }
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS* pDetails)
        { return _GetDetailsOf(MAX_ICOL_NETFOLDER, pidl, iColumn, pDetails); }
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID* pscid)
        { return _MapColumnToSCID(MAX_ICOL_NETFOLDER, iColumn, pscid); }

    // IPersist
    STDMETHODIMP GetClassID(CLSID* pClassID);
    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);
    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST* ppidl);
    // IPersistFolder3
    STDMETHOD(InitializeEx)(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *ppfai);
    STDMETHOD(GetFolderTargetInfo)(PERSIST_FOLDER_TARGET_INFO *ppfai);

    // *** IShellIconOverlay methods***
    STDMETHOD(GetOverlayIndex)(LPCITEMIDLIST pidl, int * pIndex);
    STDMETHOD(GetOverlayIconIndex)(LPCITEMIDLIST pidl, int * pIconIndex);

protected:
    CNetFolder(IUnknown* punkOuter);
    ~CNetFolder();

    virtual HRESULT v_GetFileFolder(IShellFolder2 **ppsfFiles) 
                { *ppsfFiles = NULL; return E_NOTIMPL; };

    // used by the CAggregatedUnknown stuff
    HRESULT v_InternalQueryInterface(REFIID riid, void **ppvObj);

    HRESULT _OpenKeys(LPCIDNETRESOURCE pidn, HKEY ahkeys[]);
    LPCTSTR _GetProvider(LPCIDNETRESOURCE pidn, IBindCtx *pbc, LPTSTR pszProvider, UINT cchProvider);
    DWORD _OpenEnum(HWND hwnd, DWORD grfFlags, LPNETRESOURCE pnr, HANDLE *phEnum);

    static HRESULT _CreateNetIDList(LPIDNETRESOURCE pidnIn, 
                                    LPCTSTR pszName, LPCTSTR pszProvider, LPCTSTR pszComment,
                                    LPITEMIDLIST *ppidl);

    static HRESULT _NetResToIDList(NETRESOURCE *pnr, 
                                   BOOL fKeepNullRemoteName, 
                                   BOOL fKeepProviderName, 
                                   BOOL fKeepComment, 
                                   LPITEMIDLIST *ppidl);

    static HRESULT _CreateEntireNetwork(LPITEMIDLIST *ppidl);

    static HRESULT _CreateEntireNetworkFullIDList(LPITEMIDLIST *ppidl);

    LPTSTR _GetNameForParsing(LPCWSTR pwszName, LPTSTR pszBuffer, INT cchBuffer, LPTSTR *ppszRegItem);
    HRESULT _ParseRest(LPBC pbc, LPCWSTR pszRest, LPITEMIDLIST* ppidl, DWORD* pdwAttributes);
    HRESULT _AddUnknownIDList(DWORD dwDisplayType, LPITEMIDLIST *ppidl);
    HRESULT _ParseSimple(LPBC pbc, LPWSTR pszName, LPITEMIDLIST* ppidl, DWORD* pdwAttributes);
    HRESULT _NetResToIDLists(NETRESOURCE *pnr, DWORD dwbuf, LPITEMIDLIST *ppidl);

    HRESULT _ParseNetName(HWND hwnd, LPBC pbc, LPCWSTR pwszName, ULONG* pchEaten, 
                              LPITEMIDLIST* ppidl, DWORD* pdwAttributes);
    LONG _GetFilePIDLType(LPCITEMIDLIST pidl);
    BOOL _MakeStripToLikeKinds(UINT *pcidl, LPCITEMIDLIST **papidl, BOOL fNetObjects);
    HRESULT _GetDefaultColumnState(UINT cColumns, UINT iColumn, DWORD* pdwState);
    HRESULT _GetDetailsOf(UINT cColumns, LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    HRESULT _MapColumnToSCID(UINT cColumns, UINT iColumn, SHCOLUMNID* pscid);

    LPFNDFMCALLBACK _GetCallbackType(LPCIDNETRESOURCE pidn)
                        { return _IsPrintShare(pidn) ? &PrinterDFMCallBack : &DFMCallBack; };

    static HRESULT CALLBACK _AttributesCallbackRoot(IShellFolder2* psf, LPCITEMIDLIST pidl, ULONG* prgfInOut);

    LPITEMIDLIST _pidl;
    LPITEMIDLIST _pidlTarget; // pidl of where the folder is in the namespace
    LPCIDNETRESOURCE _pidnForProvider; // optional provider for this container...
    LPTSTR _pszResName;      // optional resource name of this container
    UINT _uDisplayType;      // display type of the folder
    IShellFolder2* _psfFiles;
    IUnknown* _punkReg;
    
private:
    HRESULT _CreateInstance(LPCITEMIDLIST pidlAbs, LPCITEMIDLIST pidlTarget,
                                           UINT uDisplayType,                                            
                                           LPCIDNETRESOURCE pidnForProvider, LPCTSTR pszResName, 
                                           REFIID riid, void **ppv);
    friend HRESULT CNetwork_DFMCallBackBG(IShellFolder *psf, HWND hwnd,
                                          IDataObject *pdtobj, UINT uMsg, 
                                          WPARAM wParam, LPARAM lParam);
    static DWORD CALLBACK _PropertiesThreadProc(void *pv);
    static HRESULT DFMCallBack(IShellFolder* psf, HWND hwnd,
                               IDataObject* pdtobj, UINT uMsg, 
                               WPARAM wParam, LPARAM lParam);
    static HRESULT PrinterDFMCallBack(IShellFolder* psf, HWND hwnd,
                                      IDataObject* pdtobj, UINT uMsg, 
                                      WPARAM wParam, LPARAM lParam);
    static HRESULT CALLBACK _AttributesCallback(IShellFolder2* psf, LPCITEMIDLIST pidl, ULONG* prgfInOut);

    BOOL _GetPathForShare(LPCIDNETRESOURCE pidn, LPTSTR pszPath, int cchPath);
    HRESULT _GetPathForItem(LPCIDNETRESOURCE pidn, LPTSTR pszPath, int cchPath);
    HRESULT _CreateFolderForItem(LPBC pbc, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlTarget, LPCIDNETRESOURCE pidnForProvider, REFIID riid, void **ppv);
    HRESULT _GetFormatName(LPCIDNETRESOURCE pidn, STRRET* pStrRet);
    HRESULT _GetIconOverlayInfo(LPCIDNETRESOURCE pidn, int *pIndex, DWORD dwFlags);
    HKEY _OpenProviderTypeKey(LPCIDNETRESOURCE pidn);
    HKEY _OpenProviderKey(LPCIDNETRESOURCE pidn);
    static void WINAPI _CopyEnumElement(void* pDest, const void* pSource, DWORD dwSize);
    HRESULT _GetNetResource(LPCIDNETRESOURCE pidn, NETRESOURCEW* pnr, int cb);
};  


class CNetRootFolder : public CNetFolder
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj)
                { return CNetFolder::QueryInterface(riid, ppvObj); };
    STDMETHODIMP_(ULONG) AddRef(void)
                { return CNetFolder::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void)
                { return CNetFolder::Release(); };

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList ** ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj)
        { return CNetFolder::BindToStorage(pidl, pbc, riid, ppvObj); };
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(HWND hwndOwner, REFIID riid, void **ppv);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST* apidl,
                               REFIID riid, UINT* prgfInOut, void **ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST* ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pGuid)
        { return CNetFolder::GetDefaultSearchGUID(pGuid); };
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum)
        { return CNetFolder::EnumSearches(ppenum); };
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay)
        { return CNetFolder::GetDefaultColumn(dwRes, pSort, pDisplay); };
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD* pbState)
        { return _GetDefaultColumnState(MAX_ICOL_NETROOT, iColumn, pbState); }       // +1 for <= check
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv)
        { return CNetFolder::GetDetailsEx(pidl, pscid, pv); };
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS* pDetails)
        { return _GetDetailsOf(MAX_ICOL_NETROOT, pidl, iColumn, pDetails); };
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID* pscid)
        { return _MapColumnToSCID(MAX_ICOL_NETROOT, iColumn, pscid); }

    // IPersist
    STDMETHODIMP GetClassID(CLSID* pClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST* ppidl) { return CNetFolder::GetCurFolder(ppidl); };

    // IPersistFolder3
    STDMETHOD(InitializeEx)(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *ppfai)
        { return CNetFolder::InitializeEx(pbc, pidlRoot, ppfai); };
    STDMETHOD(GetFolderTargetInfo)(PERSIST_FOLDER_TARGET_INFO *ppfai)
        { return CNetFolder::GetFolderTargetInfo(ppfai); };

protected:
    CNetRootFolder(IUnknown* punkOuter) : CNetFolder(punkOuter) { };
    ~CNetRootFolder() { ASSERT(NULL != _spThis); _spThis = NULL; };

    BOOL v_HandleDelete(PLONG pcRef);
    HRESULT v_GetFileFolder(IShellFolder2 **ppsfFiles);

private:
    HRESULT _TryParseEntireNet(HWND hwnd, LPBC pbc, WCHAR *pwszName, LPITEMIDLIST *ppidl, DWORD *pdwAttributes);

    friend HRESULT CNetwork_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
    static CNetRootFolder* _spThis;
};  

class CNetFolderViewCB : public CBaseShellFolderViewCB
{
public:
    CNetFolderViewCB(CNetFolder *pFolder);

    // IShellFolderViewCB
    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    ~CNetFolderViewCB();
    HRESULT OnINVOKECOMMAND(DWORD pv, UINT wP);
    HRESULT OnGETHELPTEXT(DWORD pv, UINT wPl, UINT wPh, LPTSTR lP);
    HRESULT OnREFRESH(DWORD pv, BOOL fPreRefresh);
    HRESULT OnDELAYWINDOWCREATE(DWORD pv, HWND hwnd);
    HRESULT OnGETCOLSAVESTREAM(DWORD pv, WPARAM wP, IStream **pps);
    HRESULT OnDEFITEMCOUNT(DWORD pv, UINT *pnItems);
    HRESULT OnGetZone(DWORD pv, DWORD * pdwZone);
    HRESULT OnEnumeratedItems(DWORD pv, UINT celt, LPCITEMIDLIST *rgpidl);
    HRESULT OnDefViewMode(DWORD pv, FOLDERVIEWMODE* pvm);
    HRESULT OnGetDeferredViewSettings(DWORD pv, SFVM_DEFERRED_VIEW_SETTINGS* pSettings);

    BOOL _EntireNetworkAvailable();

    CNetFolder *_pFolder;
    UINT _cItems;

    // Web View implementation
    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData);
    HRESULT OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks);
public:
    static HRESULT _CanShowHNW(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);    
    static HRESULT _CanViewComputersNearMe(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanSearchActiveDirectory(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);

    static HRESULT _DoRunDll32(LPTSTR pszParameters); // helper to do a ShellExecute of RunDll32.

    static HRESULT _OnViewNetConnections(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnAddNetworkPlace(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
        { return _DoRunDll32(TEXT("netplwiz.dll,AddNetPlaceRunDll")); }
    static HRESULT _OnHomeNetworkWizard(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
        { return _DoRunDll32(TEXT("hnetwiz.dll,HomeNetWizardRunDll")); }
    static HRESULT _OnViewComputersNearMe(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnSearchActiveDirectory(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
        { return _DoRunDll32(TEXT("dsquery.dll,OpenQueryWindow")); }
    static HRESULT _HasPreviousVersions(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _OnPreviousVersions(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
};

#define NETFLDR_EVENTS \
            SHCNE_RENAMEITEM | SHCNE_RENAMEFOLDER | \
            SHCNE_CREATE | SHCNE_DELETE | SHCNE_UPDATEDIR | SHCNE_UPDATEITEM | \
            SHCNE_MKDIR | SHCNE_RMDIR

CNetFolderViewCB::CNetFolderViewCB(CNetFolder *pFolder) : 
    CBaseShellFolderViewCB(pFolder->_pidl, NETFLDR_EVENTS), _pFolder(pFolder)
{
    _pFolder->AddRef();
}

CNetFolderViewCB::~CNetFolderViewCB()
{
    _pFolder->Release();
}

HRESULT CNetFolderViewCB::OnINVOKECOMMAND(DWORD pv, UINT wP)
{
    return CNetwork_DFMCallBackBG(_pFolder, _hwndMain, NULL, DFM_INVOKECOMMAND, wP, 0);
}

HRESULT CNetFolderViewCB::OnGETHELPTEXT(DWORD pv, UINT wPl, UINT wPh, LPTSTR lP)
{
    return CNetwork_DFMCallBackBG(_pFolder, _hwndMain, NULL, DFM_GETHELPTEXTW, MAKEWPARAM(wPl, wPh), (LPARAM)lP);
}

HRESULT CNetFolderViewCB::OnREFRESH(DWORD pv, BOOL fPreRefresh)
{
    if (fPreRefresh)
    {
        RefreshNetCrawler();
    }
    return S_OK;
}

HRESULT CNetFolderViewCB::OnDELAYWINDOWCREATE(DWORD pv, HWND hwnd)
{
    // only do delay window processing in the net root.

    if (RESOURCEDISPLAYTYPE_GENERIC == _pFolder->_uDisplayType) // MyNetPlaces
    {
        RefreshNetCrawler();
    }

    return S_OK;
}

HRESULT CNetFolderViewCB::OnGETCOLSAVESTREAM(DWORD pv, WPARAM wP, IStream **pps)
{
    LPCTSTR pszValName;

    switch (_pFolder->_uDisplayType) 
    {
    case RESOURCEDISPLAYTYPE_DOMAIN:
        pszValName = TEXT("NetDomainColsX");
        break;

    case RESOURCEDISPLAYTYPE_SERVER:
        pszValName = TEXT("NetServerColsX");
        break;

    default:
        return E_FAIL;
    }

    *pps = OpenRegStream(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER, pszValName, (DWORD) wP);
    return *pps ? S_OK : E_FAIL;
}

// HRESULT CNetFolderViewCB::OnGetZone(DWORD pv, DWORD * pdwZone);

HRESULT CNetFolderViewCB::OnEnumeratedItems(DWORD pv, UINT celt, LPCITEMIDLIST *rgpidl)
{
    _cItems = celt;
    return S_OK;
}

HRESULT CNetFolderViewCB::OnDefViewMode(DWORD pv, FOLDERVIEWMODE* pvm)
{
    if (IsOS(OS_SERVERADMINUI))
        *pvm = FVM_DETAILS;    // Server Admin always gets DETAILS
    else if (_cItems < DEFVIEW_FVM_MANY_CUTOFF)
        *pvm = FVM_TILE;
    else
        *pvm = FVM_ICON; // used to pick icon only for My Net Places ((_pFolder->_uDisplayType == RESOURCEDISPLAYTYPE_GENERIC))

    return S_OK;
}

HRESULT CNetFolderViewCB::OnGetDeferredViewSettings(DWORD pv, SFVM_DEFERRED_VIEW_SETTINGS* pSettings)
{
    OnDefViewMode(pv, &pSettings->fvm);

    // if this is the root folder then lets sort accordingly
    if (_pFolder->_uDisplayType == RESOURCEDISPLAYTYPE_GENERIC)
    {
        pSettings->fGroupView = TRUE;
        pSettings->uSortCol = ICOL_NETWORKLOCATION;
        pSettings->iSortDirection = 1;
    }
   
    return S_OK;
}

HRESULT CNetFolderViewCB::OnGetZone(DWORD pv, DWORD * pdwZone)
{
    if (pdwZone)
        *pdwZone = URLZONE_INTRANET; // default is "Local Intranet"
    return S_OK;    
}


HRESULT CNetFolderViewCB::OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));
    pData->dwLayout = SFVMWVL_NORMAL;
    return S_OK;
}

// HNW is shown on X86 pro or personal workgroup only
HRESULT CNetFolderViewCB::_CanShowHNW(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
#ifdef _WIN64
    *puisState = UIS_DISABLED;
    return S_OK;
#else
    if (IsOS(OS_ANYSERVER))
        *puisState = UIS_DISABLED;  // Server-type OS
    else
        *puisState = !IsOS(OS_DOMAINMEMBER) ? UIS_ENABLED : UIS_DISABLED;
    return S_OK;
#endif
}

HRESULT CNetFolderViewCB::_CanViewComputersNearMe(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    if (!SHRestricted(REST_NOCOMPUTERSNEARME))
        *puisState = !IsOS(OS_DOMAINMEMBER) ? UIS_ENABLED : UIS_DISABLED;
    else
        *puisState = UIS_DISABLED;
    return S_OK;
}

HRESULT CNetFolderViewCB::_CanSearchActiveDirectory(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    if (IsOS(OS_DOMAINMEMBER) && (GetEnvironmentVariable(TEXT("USERDNSDOMAIN"), NULL, 0) > 0))
        *puisState = UIS_ENABLED;
    else
        *puisState = UIS_DISABLED;

    return S_OK;
}

HRESULT CNetFolderViewCB::_OnViewNetConnections(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetFolderLocation(NULL, CSIDL_CONNECTIONS, NULL, 0, &pidl); 
    if (SUCCEEDED(hr))
    {
        hr = ((CNetFolderViewCB*)(void*)pv)->_BrowseObject(pidl);
        ILFree(pidl);
    }
    return hr;
}

HRESULT CNetFolderViewCB::_DoRunDll32(LPTSTR pszParameters)
{
    SHELLEXECUTEINFO sei = {0};
    sei.cbSize = sizeof(sei);
    sei.lpFile = TEXT("rundll32.exe");
    sei.lpParameters = pszParameters;
    sei.nShow = SW_SHOWNORMAL;
    
    return ShellExecuteEx(&sei) ? S_OK : E_FAIL;
}

HRESULT CNetFolderViewCB::_OnViewComputersNearMe(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetFolderLocation(NULL, CSIDL_COMPUTERSNEARME, NULL, 0, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = ((CNetFolderViewCB*)(void*)pv)->_BrowseObject(pidl);
        ILFree(pidl);
    }
    return hr;
}

HRESULT CNetFolderViewCB::_HasPreviousVersions(IUnknown* /*pv*/, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    HRESULT hr = S_OK;

    *puisState = UIS_HIDDEN;

    if (NULL != psiItemArray)
    {
#ifdef DEBUG
        // Sanity check.
        DWORD dwNumItems;
        ASSERT(S_OK == psiItemArray->GetCount(&dwNumItems));
        ASSERT(1 == dwNumItems);
#endif
        BOOL bHavePV = FALSE;

        // This returns E_PENDING if the answer is unknown
        // and fOkToBeSlow is FALSE
        hr = HavePreviousVersionsAt(psiItemArray, 0, fOkToBeSlow, &bHavePV);
        if (S_OK == hr && bHavePV)
        {
            *puisState = UIS_ENABLED;
        }
    }
    return hr;
}

HRESULT CNetFolderViewCB::_OnPreviousVersions(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    ShowPreviousVersionsAt(psiItemArray, 0, ((CNetFolderViewCB*)(void*)pv)->_hwndMain);
    return S_OK;
}

const WVTASKITEM c_MyNetPlacesTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_MYNETPLACES, IDS_HEADER_MYNETPLACES_TT);
const WVTASKITEM c_MyNetPlacesTaskList[] =
{
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_ADDNETWORKPLACE,    IDS_TASK_ADDNETWORKPLACE_TT,    IDI_TASK_ADDNETWORKPLACE,    NULL, CNetFolderViewCB::_OnAddNetworkPlace),
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_VIEWNETCONNECTIONS, IDS_TASK_VIEWNETCONNECTIONS_TT, IDI_TASK_VIEWNETCONNECTIONS, NULL, CNetFolderViewCB::_OnViewNetConnections),
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_HOMENETWORKWIZARD,  IDS_TASK_HOMENETWORKWIZARD_TT,  IDI_TASK_HOMENETWORKWIZARD,  CNetFolderViewCB::_CanShowHNW, CNetFolderViewCB::_OnHomeNetworkWizard),
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_COMPUTERSNEARME,    IDS_TASK_COMPUTERSNEARME_TT,    IDI_GROUP,                   CNetFolderViewCB::_CanViewComputersNearMe, CNetFolderViewCB::_OnViewComputersNearMe),
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_SEARCHDS,           IDS_TASK_SEARCHDS_TT,           IDI_TASK_SEARCHDS,           CNetFolderViewCB::_CanSearchActiveDirectory, CNetFolderViewCB::_OnSearchActiveDirectory),
    WVTI_ENTRY_TITLE(UICID_PreviousVersions, L"shell32.dll", IDS_TASK_SHADOW, IDS_TASK_SHADOW, 0, IDS_TASK_SHADOW_TT, IDI_TASK_SHADOW,   CNetFolderViewCB::_HasPreviousVersions, CNetFolderViewCB::_OnPreviousVersions),
};

BOOL CNetFolderViewCB::_EntireNetworkAvailable()
{
    BOOL fRet = FALSE;

    // Only enable if we're in a Domain
    if (IsOS(OS_DOMAINMEMBER) && !SHRestricted(REST_NOENTIRENETWORK))
    {
        LPITEMIDLIST pidl;
        if (SUCCEEDED(CNetFolder::_CreateEntireNetworkFullIDList(&pidl)))
        {
            // ... and we're not already in the "Entire Network" folder.
            if (!ILIsEqual(_pidl, pidl))
            {
                fRet = TRUE;
            }
            ILFree(pidl);
        }
    }

    return fRet;
}

HRESULT CNetFolderViewCB::OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));

    Create_IUIElement(&c_MyNetPlacesTaskHeader, &(pData->pFolderTaskHeader));

    LPCTSTR rgCsidls[] = { MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_PERSONAL), MAKEINTRESOURCE(CSIDL_COMMON_DOCUMENTS), MAKEINTRESOURCE(CSIDL_PRINTERS) };
    
    if (_EntireNetworkAvailable())
    {
        LPITEMIDLIST pidlEntireNetwork = NULL;
        CNetFolder::_CreateEntireNetworkFullIDList(&pidlEntireNetwork);
        CreateIEnumIDListOnCSIDLs2(_pidl, pidlEntireNetwork, rgCsidls, ARRAYSIZE(rgCsidls), &(pData->penumOtherPlaces));
        ILFree(pidlEntireNetwork);
    }
    else
    {
        CreateIEnumIDListOnCSIDLs(_pidl, rgCsidls, ARRAYSIZE(rgCsidls), &(pData->penumOtherPlaces));
    }

    return S_OK;
}

HRESULT CNetFolderViewCB::OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
{
    ZeroMemory(pTasks, sizeof(*pTasks));

    Create_IEnumUICommand((IUnknown*)(void*)this, c_MyNetPlacesTaskList, ARRAYSIZE(c_MyNetPlacesTaskList), &pTasks->penumFolderTasks);

    return S_OK;
}

STDMETHODIMP CNetFolderViewCB::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_INVOKECOMMAND, OnINVOKECOMMAND);
    HANDLE_MSG(0, SFVM_GETHELPTEXT, OnGETHELPTEXT);
    HANDLE_MSG(0, SFVM_DELAYWINDOWCREATE, OnDELAYWINDOWCREATE);
    HANDLE_MSG(0, SFVM_GETCOLSAVESTREAM, OnGETCOLSAVESTREAM);
    HANDLE_MSG(0, SFVM_GETZONE, OnGetZone);
    HANDLE_MSG(0, SFVM_ENUMERATEDITEMS, OnEnumeratedItems);
    HANDLE_MSG(0, SFVM_DEFVIEWMODE, OnDefViewMode);
    HANDLE_MSG(0, SFVM_GETDEFERREDVIEWSETTINGS, OnGetDeferredViewSettings);
    HANDLE_MSG(0, SFVM_REFRESH, OnREFRESH);
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, OnGetWebViewContent);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTASKS, OnGetWebViewTasks);

    default:
        return E_FAIL;
    }

    return S_OK;
}


// Replace all the space characters in the provider name with '_'.
void ReplaceSpacesWithUnderscore(LPTSTR psz)
{
    while (psz = StrChr(psz, TEXT(' ')))
    {
        *psz = TEXT('_');
        psz++;              // DBCS safe
    }
}

// Define a collate order for the hood object types
#define _HOOD_COL_RON    0
#define _HOOD_COL_REMOTE 1
#define _HOOD_COL_FILE   2
#define _HOOD_COL_NET    3

const static ICONMAP c_aicmpNet[] = {
    { SHID_NET_NETWORK     , II_NETWORK      },
    { SHID_NET_DOMAIN      , II_GROUP        },
    { SHID_NET_SERVER      , II_SERVER       },
    { SHID_NET_SHARE       , (UINT)EIRESID(IDI_SERVERSHARE)  },
    { SHID_NET_DIRECTORY   , II_FOLDER       },
    { SHID_NET_PRINTER     , II_PRINTER      },
    { SHID_NET_RESTOFNET   , II_WORLD        },
    { SHID_NET_SHAREADMIN  , II_DRIVEFIXED   },
    { SHID_NET_TREE        , II_TREE         },
    { SHID_NET_NDSCONTAINER, (UINT)EIRESID(IDI_NDSCONTAINER) },
};

enum
{
    NKID_PROVIDERTYPE = 0,
    NKID_PROVIDER,
    NKID_NETCLASS,
    NKID_NETWORK,
    NKID_DIRECTORY,
    NKID_FOLDER
};

#define NKID_COUNT 6


// This is one-entry cache for remote junctions resolution
TCHAR g_szLastAttemptedJunctionName[MAX_PATH] = {0};
TCHAR g_szLastResolvedJunctionName[MAX_PATH] = {0};

REGITEMSINFO g_riiNetRoot =
{
    REGSTR_PATH_EXPLORER TEXT("\\NetworkNeighborhood\\NameSpace"),
    NULL,
    TEXT(':'),
    SHID_NET_REGITEM,
    1,
    SFGAO_CANLINK,
    0,
    NULL,
    RIISA_ORIGINAL,
    NULL,
    0,
    0,
};

CNetRootFolder* CNetRootFolder::_spThis = NULL;

HRESULT CNetFolder::_CreateInstance(LPCITEMIDLIST pidlAbs, LPCITEMIDLIST pidlTarget, UINT uDisplayType, 
                                LPCIDNETRESOURCE pidnForProvider, LPCTSTR pszResName, 
                                REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppv = NULL;

    if (!ILIsEmpty(pidlAbs))
    {
        CNetFolder* pNetF = new CNetFolder(NULL);
        if (NULL != pNetF)
        {
            pNetF->_uDisplayType = uDisplayType;

            if (pidnForProvider)
            {
                //Make sure that the pidnProvider has provider information.
                ASSERT(NET_FHasProvider(pidnForProvider))

                //We are interested only in the provider informarion which is contained in the first entry.
                //Its enough if we clone only the first item in the pidl.
                pNetF->_pidnForProvider = (LPCIDNETRESOURCE)ILCloneFirst((LPCITEMIDLIST)pidnForProvider);                
            }

            if (pszResName && *pszResName)
                pNetF->_pszResName = StrDup(pszResName);
           
            pNetF->_pidl = ILClone(pidlAbs);
            pNetF->_pidlTarget = ILClone(pidlTarget);

            if (pNetF->_pidl && (!pidlTarget || (pidlTarget && pNetF->_pidlTarget)))
            {
                if (uDisplayType == RESOURCEDISPLAYTYPE_SERVER)
                {
                    // This is a remote computer. See if there are any remote
                    // computer registry items. If so, aggregate with the registry
                    // class.

                    REGITEMSINFO riiComputer =
                    {
                        REGSTR_PATH_EXPLORER TEXT("\\RemoteComputer\\NameSpace"),
                        NULL,
                        TEXT(':'),
                        SHID_NET_REMOTEREGITEM,
                        -1,
                        SFGAO_FOLDER | SFGAO_CANLINK,
                        0,      // no required reg items
                        NULL,
                        RIISA_ORIGINAL,
                        pszResName,
                        0,
                        0,
                    };

                    CRegFolder_CreateInstance(&riiComputer,
                                              (IUnknown*) (IShellFolder*) pNetF,
                                              IID_PPV_ARG(IUnknown, &pNetF->_punkReg));
                }
                else if (uDisplayType == RESOURCEDISPLAYTYPE_ROOT)
                {
                    //
                    // this is the entire net icon, so lets create an instance of the regitem folder
                    // so we can merge in the items from there.
                    //

                    REGITEMSINFO riiEntireNet =
                    {
                        REGSTR_PATH_EXPLORER TEXT("\\NetworkNeighborhood\\EntireNetwork\\NameSpace"),
                        NULL,
                        TEXT(':'),
                        SHID_NET_REGITEM,
                        -1,
                        SFGAO_CANLINK,
                        0,      // no required reg items
                        NULL,
                        RIISA_ORIGINAL,
                        NULL,
                        0,
                        0,
                    };

                    CRegFolder_CreateInstance(&riiEntireNet,
                                              (IUnknown*) (IShellFolder*) pNetF,
                                              IID_PPV_ARG(IUnknown, &pNetF->_punkReg));
                }
                else
                {
                    ASSERT(hr == E_OUTOFMEMORY);
                }
                hr = pNetF->QueryInterface(riid, ppv);
            }
            pNetF->Release();
        }
        else
        {
            ASSERT(hr == E_OUTOFMEMORY);
        }
    }
    else
    {
        ASSERT(0);
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CNetwork_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;
    *ppv = NULL;

    // Must enter critical section to avoid racing against v_HandleDelete
    ENTERCRITICAL;

    if (NULL != CNetRootFolder::_spThis)
    {
        hr = CNetRootFolder::_spThis->QueryInterface(riid, ppv);
    }
    else
    {
        CNetRootFolder* pNetRootF = new CNetRootFolder(punkOuter);
        if (pNetRootF)
        {
            // Initialize it ourselves to ensure that the cached value
            // is the correct one.
            hr = pNetRootF->Initialize((LPCITEMIDLIST)&c_idlNet);
            if (SUCCEEDED(hr))
            {
                pNetRootF->_uDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
                ASSERT(NULL == pNetRootF->_punkReg);

                if (SHRestricted(REST_NOSETFOLDERS))
                    g_riiNetRoot.iReqItems = 0;

                // create the regitems object, he has the NetRoot object as his outer guy.

                hr = CRegFolder_CreateInstance(&g_riiNetRoot,
                                                 SAFECAST(pNetRootF, IShellFolder2*),
                                                 IID_PPV_ARG(IUnknown, &pNetRootF->_punkReg));

                // NOTE: not using SHInterlockedCompareExchange() because we have the critsec
                CNetRootFolder::_spThis = pNetRootF;
                hr = pNetRootF->QueryInterface(riid, ppv);
            }

            // Release the self-reference, but keep the the _spThis pointer intact
            // (it will be reset to NULL in the destructor)
            pNetRootF->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    LEAVECRITICAL;

    return hr;
}


CNetFolder::CNetFolder(IUnknown* punkOuter) : 
    CAggregatedUnknown (punkOuter)
{
    // Assert that we're still using a zero-init flag inside the new operator
    ASSERT(NULL == _pidl);
    ASSERT(NULL == _pidlTarget);
    ASSERT(NULL == _pidnForProvider);
    ASSERT(NULL == _pszResName);
    ASSERT(0 == _uDisplayType);
    ASSERT(NULL == _psfFiles);
    ASSERT(NULL == _punkReg);

    DllAddRef();
}


CNetFolder::~CNetFolder()
{
    ILFree(_pidl);
    ILFree(_pidlTarget);
    ILFree((LPITEMIDLIST)_pidnForProvider);
    
    if (NULL != _pszResName)
    {
        LocalFree(_pszResName);
    }

    if (_psfFiles)
    {
        _psfFiles->Release();
    }

    SHReleaseInnerInterface(SAFECAST(this, IShellFolder *), &_punkReg);
    DllRelease();
}

CNetFolder *FolderToNetFolder(IUnknown *punk)
{
    CNetFolder * pThis = NULL;
    return punk && SUCCEEDED(punk->QueryInterface(CLSID_CNetFldr, (void **)&pThis)) ? pThis : NULL;
}

HRESULT CNetFolder::v_InternalQueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CNetFolder, IShellFolder2),                                    // IID_IShellFolder2
        QITABENTMULTI(CNetFolder, IShellFolder, IShellFolder2),                 // IID_IShellFolder
        QITABENT(CNetFolder, IPersistFolder3),                              // IID_IPersistFolder3
        QITABENT(CNetFolder, IShellIconOverlay),                            // IID_IShellIconOverlay
        QITABENTMULTI(CNetFolder, IPersistFolder2, IPersistFolder3),        // IID_IPersistFolder2
        QITABENTMULTI(CNetFolder, IPersistFolder, IPersistFolder3),         // IID_IPersistFolder
        QITABENTMULTI(CNetFolder, IPersist, IPersistFolder3),               // IID_IPersist
        QITABENTMULTI2(CNetFolder, IID_IPersistFreeThreadedObject, IPersist),   // IID_IPersistFreeThreadedObject
        { 0 },
    };

    if (IsEqualIID(riid, CLSID_CNetFldr))
    {
        *ppv = this;        // get class pointer (unrefed!)
        return S_OK;
    }

    HRESULT hr;
    if (_punkReg && RegGetsFirstShot(riid))
    {
        hr = _punkReg->QueryInterface(riid, ppv);
    }
    else
    {
        hr = QISearch(this, qit, riid, ppv);
        if ((E_NOINTERFACE == hr) && _punkReg)
        {
            hr = _punkReg->QueryInterface(riid, ppv);
        }
    }
    return hr;
}


BOOL CNetRootFolder::v_HandleDelete(PLONG pcRef)
{
    ASSERT(NULL != pcRef);

    ENTERCRITICAL;

    // Once inside the critical section things are slightly more stable.
    // CNetwork_CreateInstance won't be able to rescue the cached reference
    // (and bump the refcount from 0 to 1).  And we don't have to worry
    // about somebody Release()ing us down to zero a second time, since
    // no new references can show up.
    //
    // HOWEVER!  All those scary things could've happened WHILE WE WERE
    // WAITING TO ENTER THE CRITICAL SECTION.
    //
    // While we were waiting, somebody could've called CNetwork_CreateInstance,
    // which bumps the reference count back up.  So don't destroy ourselves
    // if our object got "rescued".
    //
    // What's more, while we were waiting, that somebody could've then
    // Release()d us back down to zero, causing us to be called on that
    // other thread, notice that the refcount is indeed zero, and destroy
    // the object, all on that other thread.  So if we are not the cached
    // instance, then don't destroy ourselves since that other thread did
    // it already.
    //
    // And even more, somebody might call CNetwork_CreateInstance again
    // and create a brand new object, which might COINCIDENTALLY happen
    // to have the same address as the old object we are trying to destroy
    // here.  But in that case, it's okay to destroy the new object because
    // it is indeed the case that the object's reference count is zero and
    // deserves to be destroyed.

    if (this == _spThis && 0 == *pcRef)
    {
        *pcRef = 1000; // protect against cached pointers bumping us up then down
        delete this;
    }
    LEAVECRITICAL;
    // return TRUE to indicate that we've implemented this function
    // (regardless of whether or not this object was actually deleted)
    return TRUE;
}


STDMETHODIMP CNetFolder::ParseDisplayName(HWND hwnd, LPBC pbc, WCHAR* pszName, ULONG* pchEaten,
                                          LPITEMIDLIST* ppidl, DWORD* pdwAttributes)
{
    return E_NOTIMPL;
}


// new for Win2K, this enables enuming the hidden admin shares
#ifndef RESOURCE_SHAREABLE
#define RESOURCE_SHAREABLE      0x00000006
#endif

//
//  in:
//      hwnd        NULL indicates no UI.
//      grfFlags     IShellFolder::EnumObjects() SHCONTF_ flags
//      pnr          in/out params
//
//
DWORD CNetFolder::_OpenEnum(HWND hwnd, DWORD grfFlags, LPNETRESOURCE pnr, HANDLE *phEnum)
{
    DWORD dwType = (grfFlags & SHCONTF_NETPRINTERSRCH) ? RESOURCETYPE_PRINT : RESOURCETYPE_ANY;
    DWORD dwScope = pnr ? RESOURCE_GLOBALNET : RESOURCE_CONTEXT;

    if ((_uDisplayType == RESOURCEDISPLAYTYPE_SERVER) &&
        (grfFlags & SHCONTF_SHAREABLE))
    {
        dwScope = RESOURCE_SHAREABLE;   // hidden admin shares for this server
    }

    DWORD err = WNetOpenEnum(dwScope, dwType, RESOURCEUSAGE_ALL, pnr, phEnum);
    if ((err != WN_SUCCESS) && hwnd)
    {
        // If it failed because you are not authenticated yet,
        // we need to let the user loggin to this network resource.
        //
        // REVIEW: Ask LenS to review this code.
        if (err == WN_NOT_AUTHENTICATED || 
            err == ERROR_LOGON_FAILURE || 
            err == WN_BAD_PASSWORD || 
            err == WN_ACCESS_DENIED)
        {
            // Retry with password dialog box.
            err = WNetAddConnection3(hwnd, pnr, NULL, NULL, CONNECT_TEMPORARY | CONNECT_INTERACTIVE);
            if (err == WN_SUCCESS)
            {
                err = WNetOpenEnum(dwScope, dwType, RESOURCEUSAGE_ALL, pnr, phEnum);
            }                
        }

        UINT idTemplate = pnr && pnr->lpRemoteName ? IDS_ENUMERR_NETTEMPLATE2 : IDS_ENUMERR_NETTEMPLATE1;   
        SHEnumErrorMessageBox(hwnd, idTemplate, err, pnr ? pnr->lpRemoteName : NULL, TRUE, MB_OK | MB_ICONHAND);
    }
    return err;
}

// find the share part of a UNC
//  \\server\share
//  return pointer to "share" or pointer to empty string if none

LPCTSTR PathFindShareName(LPCTSTR pszUNC)
{
    LPCTSTR psz = SkipServerSlashes(pszUNC);
    if (*psz)
    {
        psz = StrChr(psz + 1, TEXT('\\'));
        if (psz)
            psz++;
        else
            psz = TEXT("");
    }
    return psz;
}

// Flags for the dwRemote field
#define RMF_CONTEXT         0x00000001  // Entire network is being enumerated
#define RMF_SHOWREMOTE      0x00000002  // Return Remote Services for next enumeration
#define RMF_STOP_ENUM       0x00000004  // Stop enumeration
#define RMF_GETLINKENUM     0x00000008  // Hoodlinks enum needs to be fetched
#define RMF_SHOWLINKS       0x00000010  // Hoodlinks need to be shown
#define RMF_FAKENETROOT     0x00000020  // Don't enumerate the workgroup items

#define RMF_ENTIRENETSHOWN  0x40000000  // Entire network object shown
#define RMF_REMOTESHOWN     0x80000000  // Return Remote Services for next enumeration


class CNetFolderEnum : public CEnumIDListBase
{
public:
    // IEnumIDList
    STDMETHOD(Next)(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    
private:
    CNetFolderEnum(CNetFolder *pnf, DWORD grfFlags, DWORD dwRemote, HANDLE hEnum);
    ~CNetFolderEnum();
    friend HRESULT Create_NetFolderEnum(CNetFolder* pnsf, DWORD grfFlags, DWORD dwRemote, HANDLE hEnum, IEnumIDList** ppenum);
    
    CNetFolder *_pnsf;     // CNetFolder object we're enumerating
    HANDLE _hEnum;
    DWORD _grfFlags;
    LONG _cItems;   // Count of items in buffer
    LONG _iItem;    // Current index of the item in the buffer
    DWORD _dwRemote;
    union {
        NETRESOURCE _anr[0];
        BYTE _szBuffer[8192];
    };
    IEnumIDList *_peunk;  // used for enumerating file system items (links)
};

CNetFolderEnum::CNetFolderEnum(CNetFolder *pnsf, DWORD grfFlags, DWORD dwRemote, HANDLE hEnum) : CEnumIDListBase()
{
    _pnsf = pnsf;
    _pnsf->AddRef();

    _grfFlags = grfFlags;
    _dwRemote = dwRemote;

    _hEnum = hEnum;
}

HRESULT Create_NetFolderEnum(CNetFolder* pnf, DWORD grfFlags, DWORD dwRemote, HANDLE hEnum, IEnumIDList** ppenum)
{
    HRESULT hr;
    CNetFolderEnum* p= new CNetFolderEnum(pnf, grfFlags, dwRemote, hEnum);
    if (p)
    {
        hr = p->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
        p->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppenum = NULL;
    }
    return hr;
}

CNetFolderEnum::~CNetFolderEnum()
{
    _pnsf->Release();              // release the "this" ptr we have

    if (_peunk)
        _peunk->Release();

    if (_hEnum)
        WNetCloseEnum(_hEnum);
}

STDMETHODIMP CNetFolderEnum::Next(ULONG celt, LPITEMIDLIST *ppidl, ULONG *pceltFetched)
{
    HRESULT hr;

    *ppidl = NULL;
    if (pceltFetched)
        *pceltFetched = 0;

    // Time to stop enumeration?
    if (_dwRemote & RMF_STOP_ENUM)
        return S_FALSE;       // Yes

    // should we try and get the links enumerator?
    if (_dwRemote & RMF_GETLINKENUM)
    {
        IShellFolder2* psfNetHood;                                                                                             
        if (SUCCEEDED(_pnsf->v_GetFileFolder(&psfNetHood)))
            psfNetHood->EnumObjects(NULL, _grfFlags, &_peunk);

        if (_peunk)
            _dwRemote |= RMF_SHOWLINKS;

        _dwRemote &= ~RMF_GETLINKENUM;
    }

    // should we be showing the links?
    if (_dwRemote & RMF_SHOWLINKS)
    {
        if (_peunk)
        {
            ULONG celtFetched;
            LPITEMIDLIST pidl;

            hr = _peunk->Next(1, &pidl, &celtFetched);
            if (hr == S_OK && celtFetched == 1)
            {
                *ppidl = pidl;
                if (pceltFetched)
                    *pceltFetched = celtFetched;
                return S_OK;       // Added link
            }
        }

        _dwRemote &= ~RMF_SHOWLINKS; // Done enumerating links
    }

    hr = S_OK;

    // Do we add the remote folder?
    // (Note: as a hack to ensure that the remote folder is added
    // to the 'hood despite what MPR says, RMF_SHOWREMOTE can be
    // set without RMF_CONTEXT set.)
    if ((_dwRemote & RMF_SHOWREMOTE) && !(_dwRemote & RMF_REMOTESHOWN))
    {
        // Yes
        // Only try to put the remote entry in once.
        _dwRemote |= RMF_REMOTESHOWN;

        // Is this not the Context container?
        // (See note above as to why we are asking this question.)
        if (!(_dwRemote & RMF_CONTEXT)) 
        {
            // Yes; stop after the next time
            _dwRemote |= RMF_STOP_ENUM;
        }

        // We have fallen thru because the remote services is not
        // installed.

        // Is this not the Context container AND the remote folder
        // is not installed?
        if (!(_dwRemote & RMF_CONTEXT)) 
        {
            // Yes; nothing else to enumerate
            return S_FALSE;
        }
    }

    if (_dwRemote & RMF_FAKENETROOT)
    {
        if ((!(_dwRemote & RMF_ENTIRENETSHOWN)) &&            
            (S_FALSE != SHShouldShowWizards(_punkSite)))
        {                           
            _pnsf->_CreateEntireNetwork(ppidl);         // fake entire net
            _dwRemote |= RMF_ENTIRENETSHOWN;
        }
        else
        {
            return S_FALSE;         // no more to enumerate
        }
    }
    else
    {
        while (TRUE)
        {
            ULONG err = WN_SUCCESS;
            LPNETRESOURCE pnr;

            if (_iItem >= _cItems)
            {
                DWORD dwSize = sizeof(_szBuffer);

                _cItems = -1;           // its signed
                _iItem = 0;

                err = WNetEnumResource(_hEnum, (DWORD*)&_cItems, _szBuffer, &dwSize);
                DebugMsg(DM_TRACE, TEXT("Net EnumCallback: err=%d Count=%d"), err, _cItems);
            }

            pnr = &_anr[_iItem++];

            // Note: the <= below is correct as we already incremented the index...
            if (err == WN_SUCCESS && (_iItem <= _cItems))
            {
                // decide if the thing is a folder or not
                ULONG grfFlagsItem = ((pnr->dwUsage & RESOURCEUSAGE_CONTAINER) || 
                                      (pnr->dwType == RESOURCETYPE_DISK) ||
                                      (pnr->dwType == RESOURCETYPE_ANY)) ?
                                        SHCONTF_FOLDERS : SHCONTF_NONFOLDERS;

                // If this is the context enumeration, we want to insert the
                // Remote Services after the first container.
                //
                // Remember that we need to return the Remote Services in the next iteration.

                if ((pnr->dwUsage & RESOURCEUSAGE_CONTAINER) && 
                     (_dwRemote & RMF_CONTEXT))
                {
                    _dwRemote |= RMF_SHOWREMOTE;
                }

                if ((_pnsf->_uDisplayType == RESOURCEDISPLAYTYPE_SERVER) &&
                    (_grfFlags & SHCONTF_SHAREABLE))
                {
                    // filter out ADMIN$ and IPC$, based on str len
                    if (lstrlen(PathFindShareName(pnr->lpRemoteName)) > 2)
                    {
                        grfFlagsItem = 0;
                    }
                }

                // if this is a network object, work out if we should hide or note, so
                // convert the provider to its type number and open the key under:
                //
                // HKEY_CLASSES_ROOT\Network\Type\<type string>

                if ((pnr->dwDisplayType == RESOURCEDISPLAYTYPE_NETWORK) && 
                          !(_grfFlags & SHCONTF_INCLUDEHIDDEN))
                {
                    DWORD dwType;
                    if (WNetGetProviderType(pnr->lpProvider, &dwType) == WN_SUCCESS)
                    {
                        TCHAR szRegValue[MAX_PATH];
                        wnsprintf(szRegValue, ARRAYSIZE(szRegValue), TEXT("Network\\Type\\%d"), HIWORD(dwType));

                        BOOL fHide = FALSE;
                        DWORD cb = sizeof(fHide);
                        if ((ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, szRegValue, TEXT("HideProvider"), NULL, &fHide, &cb)) && fHide)
                        {
                            grfFlagsItem = 0;
                        }
                    }
                }

                // Check if we found requested type of net resource.
                if (_grfFlags & grfFlagsItem)
                {
                    if (SUCCEEDED(_pnsf->_NetResToIDList(pnr, FALSE, TRUE, (_grfFlags & SHCONTF_NONFOLDERS), ppidl)))
                    {
                        break;
                    }
                }
            }
            else if (err == WN_NO_MORE_ENTRIES) 
            {
                hr = S_FALSE; // no more element
                break;
            }
            else 
            {
                DebugMsg(DM_ERROR, TEXT("sh ER - WNetEnumResource failed (%lx)"), err);
                hr = E_FAIL;
                break;
            }
        }
    }

    if (pceltFetched)
        *pceltFetched = (S_OK == hr) ? 1 : 0;
    
    return hr;
}


STDMETHODIMP CNetFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList** ppenum)
{
    NETRESOURCE nr = {0};
    TCHAR szProvider[MAX_PATH];

    nr.lpProvider = (LPTSTR) _GetProvider(NULL, NULL, szProvider, ARRAYSIZE(szProvider));

    if (_uDisplayType != RESOURCEDISPLAYTYPE_ROOT &&
        _uDisplayType != RESOURCEDISPLAYTYPE_NETWORK)
    {
        nr.lpRemoteName = _pszResName;
    }

    HRESULT hr;
    HANDLE hEnum;
    DWORD err = _OpenEnum(hwnd, grfFlags, &nr,  &hEnum);
    if (err == WN_SUCCESS)
    {
        hr = Create_NetFolderEnum(this, grfFlags, 0, hEnum, ppenum);

        if (FAILED(hr))
        {
            WNetCloseEnum(hEnum);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(err);
    }

    return hr;
}


LPCIDNETRESOURCE NET_IsValidID(LPCITEMIDLIST pidl)
{
    if (pidl && !ILIsEmpty(pidl) && ((pidl->mkid.abID[0] & SHID_GROUPMASK) == SHID_NET))
        return (LPCIDNETRESOURCE)pidl;
    return NULL;
}

STDMETHODIMP CNetFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr;
    LPCIDNETRESOURCE pidn;

    *ppv = NULL;

    pidn = NET_IsValidID(pidl);
    if (pidn)
    {
        IShellFolder *psfJunction;
        LPITEMIDLIST pidlInit = NULL;
        LPITEMIDLIST pidlTarget = NULL;
        LPCITEMIDLIST pidlRight = _ILNext(pidl);
        BOOL fRightIsEmpty = ILIsEmpty(pidlRight);
        LPCIDNETRESOURCE pidnProvider = NET_FHasProvider(pidn) ? pidn :_pidnForProvider;

        hr = S_OK;

        // lets get the IDLISTs we are going to use to initialize the shell folder
        // if we are doing a single level bind then then ILCombine otherwise
        // be more careful.

        pidlInit = ILCombineParentAndFirst(_pidl, pidl, pidlRight);
        if (_pidlTarget)
            pidlTarget = ILCombineParentAndFirst(_pidlTarget, pidl, pidlRight);

        if (!pidlInit || (!pidlTarget && _pidlTarget))
           hr = E_OUTOFMEMORY;

        // now create the folder object we are using, and either return that    
        // object to the caller, or continue the binding down.

        if (SUCCEEDED(hr))
        {
            hr = _CreateFolderForItem(pbc, pidlInit, pidlTarget, pidnProvider, 
                                        fRightIsEmpty ? riid : IID_IShellFolder, 
                                        fRightIsEmpty ? ppv : (void **)&psfJunction);

            if (!fRightIsEmpty && SUCCEEDED(hr))
            {
                hr = psfJunction->BindToObject(pidlRight, pbc, riid, ppv);
                psfJunction->Release();
            }        
        }

        ILFree(pidlInit);
        ILFree(pidlTarget);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CNetFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

STDMETHODIMP CNetFolder::CompareIDs(LPARAM iCol, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = E_INVALIDARG;
    LPCIDNETRESOURCE pidn1 = NET_IsValidID(pidl1);
    LPCIDNETRESOURCE pidn2 = NET_IsValidID(pidl2);

    if (pidn1 && pidn2)
    {
        TCHAR szBuff1[MAX_PATH], szBuff2[MAX_PATH];

        switch (iCol & SHCIDS_COLUMNMASK)
        {
            case ICOL_COMMENT:
            {
                hr = ResultFromShort(StrCmpLogicalRestricted(NET_CopyComment(pidn1, szBuff1, ARRAYSIZE(szBuff1)), 
                                                    NET_CopyComment(pidn2, szBuff2, ARRAYSIZE(szBuff2))));

                if (hr != 0)
                    return hr;

                // drop down into the name comparison
            }

            case ICOL_NAME:
            {
                // Compare by name.  This is the one case where we need to handle
                // simple ids in either place.  We will try to resync the items
                // if we find a case of this before do the compares.
                // Check for relative IDs.  In particular if one item is at
                // a server and the other is at RestOfNet then try to resync
                // the two
                //

                if (NET_IsFake(pidn1) || NET_IsFake(pidn2))
                {
                    // if either pidn1 or pidn2 is fake then we assume they are identical,
                    // this allows us to compare a simple net ID to a real net ID.  we
                    // assume that if this fails later then the world will be happy

                    hr = 0;
                }
                else
                {
                    // otherwise lets look at the names and provider strings accordingly

                    NET_CopyResName(pidn1, szBuff1, ARRAYSIZE(szBuff1));
                    NET_CopyResName(pidn2, szBuff2, ARRAYSIZE(szBuff2));
                    hr = ResultFromShort(StrCmpLogicalRestricted(szBuff1, szBuff2));

                    // If they're still identical, compare provider names.

                    if ((hr == 0) && (iCol & SHCIDS_ALLFIELDS))
                    {
                        LPCTSTR pszProv1 = _GetProvider(pidn1, NULL, szBuff1, ARRAYSIZE(szBuff1));
                        LPCTSTR pszProv2 = _GetProvider(pidn2, NULL, szBuff2, ARRAYSIZE(szBuff2));

                        if (pszProv1 && pszProv2)
                            hr = ResultFromShort(lstrcmp(pszProv1, pszProv2));
                        else
                        {
                            if (pszProv1 || pszProv2)
                                hr = ResultFromShort(pszProv1 ? 1 : -1);
                            else
                                hr = ResultFromShort(0);
                        }
                    }
                }

                // If they identical, compare the rest of IDs.

                if (hr == 0)
                    hr = ILCompareRelIDs((IShellFolder*)this, (LPCITEMIDLIST)pidn1, (LPCITEMIDLIST)pidn2, iCol);
            }
        }
    }

    return hr;
}

STDMETHODIMP CNetFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IShellView))
    {
        SFV_CREATE sSFV;

        sSFV.cbSize   = sizeof(sSFV);
        sSFV.psvOuter = NULL;
        sSFV.psfvcb = new CNetFolderViewCB(this);    // failure is OK, we just get generic support

        QueryInterface(IID_PPV_ARG(IShellFolder, &sSFV.pshf));   // in case we are agregated

        hr = SHCreateShellFolderView(&sSFV, (IShellView**) ppv);

        if (sSFV.pshf)
            sSFV.pshf->Release();

        if (sSFV.psfvcb)
            sSFV.psfvcb->Release();
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        IShellFolder* psfOuter;
        hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfOuter));
        if (SUCCEEDED(hr))
        {
            hr = CDefFolderMenu_Create(_pidl, hwnd, 0, NULL, psfOuter, 
                CNetwork_DFMCallBackBG, NULL, NULL, (IContextMenu**) ppv);
            psfOuter->Release();
        }
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return hr;
}

typedef HRESULT (CALLBACK *PFNGAOCALLBACK)(IShellFolder2 *psf, LPCITEMIDLIST pidl, ULONG* prgfInOut);

STDAPI GetAttributesCallback(IShellFolder2 *psf, UINT cidl, LPCITEMIDLIST* apidl, ULONG *prgfInOut, PFNGAOCALLBACK pfnGAOCallback)
{
    HRESULT hr = S_OK;
    ULONG rgfOut = 0;

    for (UINT i = 0; i < cidl; i++)
    {
        ULONG rgfT = *prgfInOut;
        hr = pfnGAOCallback(psf, apidl[i], &rgfT);
        if (FAILED(hr))
        {
            rgfOut = 0;
            break;
        }
        rgfOut |= rgfT;
    }

    *prgfInOut &= rgfOut;
    return hr;
}
    
STDMETHODIMP CNetFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* prgfInOut)
{
    HRESULT hr;
    if (IsSelf(cidl, apidl))
    {
        *prgfInOut &= (SFGAO_CANLINK | SFGAO_HASPROPSHEET | SFGAO_HASSUBFOLDER |
                       SFGAO_FOLDER | SFGAO_FILESYSANCESTOR);
        hr = S_OK;
    }
    else
    {
        hr = GetAttributesCallback(SAFECAST(this, IShellFolder2*), cidl, apidl, prgfInOut, _AttributesCallback);
    }

    return hr;
}

STDMETHODIMP CNetFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, STRRET* pStrRet)
{
    HRESULT hr;
    LPCIDNETRESOURCE pidn = NET_IsValidID(pidl);
    if (pidn)
    {
        TCHAR szPath[MAX_PATH];
        LPCITEMIDLIST pidlNext = _ILNext(pidl);

        if (dwFlags & SHGDN_FORPARSING)
        {
            if ((dwFlags & SHGDN_INFOLDER) ||
                ((dwFlags & SHGDN_FORADDRESSBAR) && (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_ROOT))) // the non-infolder name for the root is not good for the address bar
            {
                NET_CopyResName(pidn, szPath, ARRAYSIZE(szPath));
                if (ILIsEmpty(pidlNext))
                {
                    // we just need the last part of the display name (IN FOLDER)
                    LPTSTR pszT = StrRChr(szPath, NULL, TEXT('\\'));

                    if (!pszT)
                        pszT = szPath;
                    else
                        pszT++; // move past '\'
                    hr = StringToStrRet(pszT, pStrRet);
                }
                else
                {
                    hr = ILGetRelDisplayName((IShellFolder*) this, pStrRet, pidl, szPath, MAKEINTRESOURCE(IDS_DSPTEMPLATE_WITH_BACKSLASH), dwFlags);
                }
            }
            else
            {
                LPCITEMIDLIST pidlRight = _ILNext(pidl);

                if (ILIsEmpty(pidlRight))
                {
                    hr = _GetPathForItem(pidn, szPath, ARRAYSIZE(szPath));
                    if (SUCCEEDED(hr))
                    {
                        hr = StringToStrRet(szPath, pStrRet);
                    }
                }
                else
                {
                    IShellFolder *psfJunction;
                    //Get the pidn which has network provider information.
                    LPCIDNETRESOURCE pidnProvider = NET_FHasProvider(pidn) ? pidn :_pidnForProvider;
                    LPITEMIDLIST pidlInit, pidlTarget = NULL;

                    pidlInit = ILCombineParentAndFirst(_pidl, pidl, pidlRight);                    
                    if (_pidlTarget)
                        pidlTarget = ILCombineParentAndFirst(_pidlTarget, pidl, pidlRight);
    
                    if (!pidlInit || (_pidlTarget && !pidlTarget))
                        return E_OUTOFMEMORY;

                    hr = _CreateFolderForItem(NULL, pidlInit, pidlTarget, pidnProvider, IID_PPV_ARG(IShellFolder, &psfJunction));
                    if (SUCCEEDED(hr))
                    {
                        hr = psfJunction->GetDisplayNameOf(pidlRight, dwFlags, pStrRet);
                        psfJunction->Release();
                    }

                    ILFree(pidlInit);
                    ILFree(pidlTarget);
                }
            }
        }
        else
        {
            hr = _GetFormatName(pidn, pStrRet);
            if (SUCCEEDED(hr) && !(dwFlags & SHGDN_INFOLDER) && (NET_GetFlags(pidn) & SHID_JUNCTION))
            {
                TCHAR szServer[MAX_PATH];
                hr = SHGetNameAndFlags(_pidlTarget ? _pidlTarget:_pidl, SHGDN_FORPARSING, szServer, ARRAYSIZE(szServer), NULL);
                if (SUCCEEDED(hr))
                {                
                    TCHAR szDisplay[MAX_PATH];
                    hr = SHGetComputerDisplayName(szServer, 0x0, szDisplay, ARRAYSIZE(szDisplay));
                    if (SUCCEEDED(hr))
                    {
                        StrRetFormat(pStrRet, pidl, MAKEINTRESOURCE(IDS_DSPTEMPLATE_WITH_ON), szDisplay);
                    }
                }
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}


STDMETHODIMP CNetFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD dwRes, LPITEMIDLIST* ppidl)
{
    if (ppidl)
    { 
        *ppidl = NULL;
    }
    return E_NOTIMPL;   // not supported
}

STDMETHODIMP CNetFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST* apidl,
                                       REFIID riid, UINT* prgfInOut, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    LPCIDNETRESOURCE pidn = cidl ? NET_IsValidID(apidl[0]) : NULL;

    *ppv = NULL;

    if ((IsEqualIID(riid, IID_IExtractIconA) || IsEqualIID(riid, IID_IExtractIconW)) && pidn)
    {
        UINT iIndex;

        if (_IsPrintShare(pidn))
            iIndex = (UINT)EIRESID(IDI_PRINTER_NET);
        else if (NET_IsRemoteFld(pidn))
            iIndex = II_RNA;
        else
            iIndex = SILGetIconIndex(apidl[0], c_aicmpNet, ARRAYSIZE(c_aicmpNet));

        hr = SHCreateDefExtIcon(NULL, iIndex, iIndex, GIL_PERCLASS, II_FOLDER, riid, ppv);
    }
    else if (IsEqualIID(riid, IID_IContextMenu) && pidn)
    {
        HKEY ahkeys[NKID_COUNT];

        hr = _OpenKeys(pidn, ahkeys);
        if (SUCCEEDED(hr))
        {
            IShellFolder* psfOuter;
            hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfOuter));
            if (SUCCEEDED(hr))
            {
                hr = CDefFolderMenu_Create2(_pidl, hwnd, cidl, apidl, 
                                            psfOuter, _GetCallbackType(pidn), 
                                            ARRAYSIZE(ahkeys), ahkeys, (IContextMenu**) ppv);
                psfOuter->Release();
            }

            SHRegCloseKeys(ahkeys, ARRAYSIZE(ahkeys));
        }
    }
    else if (cidl && IsEqualIID(riid, IID_IDataObject))
    {
        // Point & Print printer installation assumes that the
        // netresources from CNetData_GetData and the
        // pidls from CIDLData_GetData are in the same order.
        // Keep it this way.

        CNetData *pnd = new CNetData(_pidl, cidl, apidl);
        if (pnd)
        {
            hr = pnd->QueryInterface(riid, ppv);
            pnd->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else if (pidn && IsEqualIID(riid, IID_IDropTarget))
    {
        // special support because this is an item (not a folder)
        if (_IsPrintShare(pidn))
        {
            LPITEMIDLIST pidl;
            hr = SHILCombine(_pidl, apidl[0], &pidl);
            if (SUCCEEDED(hr))
            {
                hr = CPrinterDropTarget_CreateInstance(hwnd, pidl, (IDropTarget**)ppv);
                ILFree(pidl);
            }
        }
        else
        {
            IShellFolder *psf;

            hr = BindToObject(apidl[0], NULL, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                hr = psf->CreateViewObject(hwnd, riid, ppv);
                psf->Release();
            }
        }
    }
    else if (pidn && IsEqualIID(riid, IID_IQueryInfo))
    {
        if (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_ROOT)
        {
            hr = CreateInfoTipFromText(MAKEINTRESOURCE(IDS_RESTOFNETTIP), riid, ppv);
        }
        else
        {
            // Someday maybe have infotips for other things too
        }
    }

    return hr;
}


STDMETHODIMP CNetFolder::GetDefaultSearchGUID(LPGUID pguid)
{
    *pguid = SRCID_SFindComputer;
    return S_OK;
}


void WINAPI CNetFolder::_CopyEnumElement(void* pDest, const void* pSource, DWORD dwSize)
{
    if (pDest && pSource)
        memcpy(pDest, pSource, dwSize);
}

STDMETHODIMP CNetFolder::EnumSearches(IEnumExtraSearch** ppenum)
{
    HRESULT hr = E_NOTIMPL;
    
    *ppenum = NULL;
    
    // if the restriction is set then this item should be enumerated from the registry
    // so we fail, else enumerate it
    // only enumerate if we actually have a network to search against
    if (!SHRestricted(REST_HASFINDCOMPUTERS) &&
        (GetSystemMetrics(SM_NETWORK) & RNC_NETWORKS))
    {
        EXTRASEARCH *pxs = (EXTRASEARCH *)LocalAlloc(LPTR, sizeof(EXTRASEARCH));
        if (pxs)
        {
            pxs->guidSearch = SRCID_SFindComputer;
            if (LoadStringW(g_hinst, IDS_FC_NAME, pxs->wszFriendlyName, ARRAYSIZE(pxs->wszFriendlyName)))
            {      
                *ppenum = (IEnumExtraSearch*)CStandardEnum_CreateInstance(IID_IEnumExtraSearch, FALSE,
                            1, sizeof(EXTRASEARCH), pxs, _CopyEnumElement);
                if (*ppenum == NULL)
                {
                    LocalFree(pxs);
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    hr = S_OK;
                }                    
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }            
    }

    return hr;
}


STDMETHODIMP CNetFolder::GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay)
{
    return E_NOTIMPL;
}

HRESULT CNetFolder::_GetDefaultColumnState(UINT cColumns, UINT iColumn, DWORD* pdwState)
{
    *pdwState = 0;
    
    HRESULT hr = S_OK;
    if (iColumn < cColumns)
    {
        *pdwState = s_net_cols[iColumn].csFlags;
        if (iColumn >= 1)
        {
            *pdwState |= SHCOLSTATE_SLOW;   // comment is slow for net root
        }            
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

STDMETHODIMP CNetFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv)
{
    HRESULT hr = E_NOTIMPL;
    LPCIDNETRESOURCE pidn = NET_IsValidID(pidl);
    if (pidn)
    {
        if (IsEqualSCID(*pscid, SCID_NETRESOURCE))
        {
            // Office calls SHGetDataFromIDList() with a large buffer to hold all
            // of the strings in the NETRESOURCE structure, so we need to make sure
            // that our variant can hold enough data to pass back to it:
            BYTE rgBuffer[sizeof(NETRESOURCEW) + (4 * MAX_PATH * sizeof(WCHAR))];
            hr = _GetNetResource(pidn, (NETRESOURCEW*) rgBuffer, sizeof(rgBuffer));
            if (SUCCEEDED(hr))
            {
                hr = InitVariantFromBuffer(pv, rgBuffer, sizeof(rgBuffer));
                if (SUCCEEDED(hr))
                {
                    // Fixup pointers in structure to point within the variant
                    // instead of our stack variable (rgBuffer):
                    ASSERT(pv->vt == (VT_ARRAY | VT_UI1));
                    NETRESOURCEW* pnrw = (NETRESOURCEW*) pv->parray->pvData;
                    if (pnrw->lpLocalName)
                    {
                        pnrw->lpLocalName = (LPWSTR) ((BYTE*) pnrw +
                                                      ((BYTE*) pnrw->lpLocalName - rgBuffer));
                    }
                    if (pnrw->lpRemoteName)
                    {
                        pnrw->lpRemoteName = (LPWSTR) ((BYTE*) pnrw +
                                                       ((BYTE*) pnrw->lpRemoteName - rgBuffer));
                    }
                    if (pnrw->lpComment)
                    {
                        pnrw->lpComment = (LPWSTR) ((BYTE*) pnrw +
                                                    ((BYTE*) pnrw->lpComment - rgBuffer));
                    }
                    if (pnrw->lpProvider)
                    {
                        pnrw->lpProvider = (LPWSTR) ((BYTE*) pnrw +
                                                     ((BYTE*) pnrw->lpProvider - rgBuffer));
                    }
                }
            }
        }
        else if (IsEqualSCID(*pscid, SCID_DESCRIPTIONID))
        {
            SHDESCRIPTIONID did;

            switch(SIL_GetType(pidl) & SHID_TYPEMASK)
            {
                case SHID_NET_DOMAIN:
                    did.dwDescriptionId = SHDID_NET_DOMAIN;
                    break;

                case SHID_NET_SERVER:
                    did.dwDescriptionId = SHDID_NET_SERVER;
                    break;

                case SHID_NET_SHARE:
                    did.dwDescriptionId = SHDID_NET_SHARE;
                    break;

                case SHID_NET_RESTOFNET:
                    did.dwDescriptionId = SHDID_NET_RESTOFNET;
                    break;

                default:
                    did.dwDescriptionId = SHDID_NET_OTHER;
                    break;
            }

            did.clsid = CLSID_NULL;
            hr = InitVariantFromBuffer(pv, &did, sizeof(did));
        }
        else if (IsEqualSCID(*pscid, SCID_Comment))
        {
            TCHAR szTemp[MAX_PATH];
            hr = InitVariantFromStr(pv, NET_CopyComment(pidn, szTemp, ARRAYSIZE(szTemp)));
        }
        else if (IsEqualSCID(*pscid, SCID_NAME))
        {
            TCHAR szTemp[MAX_PATH];
            hr = InitVariantFromStr(pv, NET_CopyResName(pidn, szTemp, ARRAYSIZE(szTemp)));
        }
    }
    else
    {
        IShellFolder2* psfFiles;
        hr = v_GetFileFolder(&psfFiles);
        if (SUCCEEDED(hr))
        {
            hr = psfFiles->GetDetailsEx(pidl, pscid, pv);            
        }            
    }

    return hr;
}

HRESULT CNetFolder::_GetDetailsOf(UINT cColumns, LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails)
{
    HRESULT hr = S_OK;

    pDetails->str.uType = STRRET_CSTR;
    pDetails->str.cStr[0] = 0;

    if (NULL == pidl)
    {
        hr = GetDetailsOfInfo(s_net_cols, cColumns, iColumn, pDetails);
    }
    else
    {
        SHCOLUMNID scid;
        hr = MapColumnToSCID(iColumn, &scid);
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            hr = GetDetailsEx(pidl, &scid, &var);
            if (SUCCEEDED(hr))
            {
                TCHAR szTemp[MAX_PATH];
                hr = SHFormatForDisplay(scid.fmtid,
                                        scid.pid,
                                        (PROPVARIANT*)&var,
                                        PUIFFDF_DEFAULT,
                                        szTemp,
                                        ARRAYSIZE(szTemp));
                if (SUCCEEDED(hr))
                {
                    hr = StringToStrRet(szTemp, &pDetails->str);
                }

                VariantClear(&var);
            }
        }
    }

    return hr;
}


HRESULT CNetFolder::_MapColumnToSCID(UINT cColumns, UINT iColumn, SHCOLUMNID* pscid)
{
    return MapColumnToSCIDImpl(s_net_cols, cColumns, iColumn, pscid);
}


// IPersist methods

STDMETHODIMP CNetFolder::GetClassID(CLSID* pCLSID)
{
    switch (_uDisplayType) 
    {
        case RESOURCEDISPLAYTYPE_ROOT:
            *pCLSID = CLSID_NetworkRoot;
            break;

        case RESOURCEDISPLAYTYPE_SERVER:
            *pCLSID = CLSID_NetworkServer;
            break;

        case RESOURCEDISPLAYTYPE_DOMAIN:
            *pCLSID = CLSID_NetworkDomain;
            break;

        case RESOURCEDISPLAYTYPE_SHARE:
            *pCLSID = CLSID_NetworkShare;
            break;

        default:
            *pCLSID = CLSID_NULL;
            break;
    }
    
    return S_OK;
}


// IPersistFolder method

STDMETHODIMP CNetFolder::Initialize(LPCITEMIDLIST pidl)
{
    ILFree(_pidl);
    ILFree(_pidlTarget);
    _pidl = _pidlTarget = NULL;

    return SHILClone(pidl, &_pidl);
}


// IPersistFolder2 method

STDMETHODIMP CNetFolder::GetCurFolder(LPITEMIDLIST* ppidl)
{
    return GetCurFolderImpl(_pidl, ppidl);
}


// IPersistFolder3 methods

STDMETHODIMP CNetFolder::InitializeEx(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *pfti)
{
    ILFree(_pidl);
    ILFree(_pidlTarget);
    _pidl = _pidlTarget = NULL;

    HRESULT hr = SHILClone(pidlRoot, &_pidl);
    if (SUCCEEDED(hr) && pfti && pfti->pidlTargetFolder)
    {
        hr = SHILClone(pfti->pidlTargetFolder, &_pidlTarget);
    }

    return hr;
}

STDMETHODIMP CNetFolder::GetFolderTargetInfo(PERSIST_FOLDER_TARGET_INFO *pfti)
{
    HRESULT hr = S_OK;

    ZeroMemory(pfti, sizeof(*pfti));

    if (_pidlTarget)
        hr = SHILClone(_pidlTarget, &pfti->pidlTargetFolder);
    
    pfti->dwAttributes = FILE_ATTRIBUTE_DIRECTORY; // maybe add system?
    pfti->csidl = -1;

    return hr;
}


// IShellIconOverlay

HRESULT CNetFolder::_GetIconOverlayInfo(LPCIDNETRESOURCE pidn, int *pIndex, DWORD dwFlags)
{
    //
    // For netshare objects we want to get the icon overlay.
    // If the share is "pinned" to be available offline it will
    // have the "Offline Files" overlay.
    //

    HRESULT hr = E_FAIL;
    if (RESOURCEDISPLAYTYPE_SHARE == NET_GetDisplayType(pidn))
    {
        TCHAR szPath[MAX_PATH];
        hr = _GetPathForItem(pidn, szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            IShellIconOverlayManager *psiom;
            hr = GetIconOverlayManager(&psiom);
            if (SUCCEEDED(hr))
            {
                WCHAR szPathW[MAX_PATH];
                SHTCharToUnicode(szPath, szPathW, ARRAYSIZE(szPathW));
                hr = psiom->GetFileOverlayInfo(szPathW, 0, pIndex, dwFlags);
                psiom->Release();
            }
        }
    }
    return hr;
}


STDMETHODIMP CNetFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    HRESULT hr = E_FAIL;
    LPCIDNETRESOURCE pidn = NET_IsValidID(pidl);
    if (NULL != pidn)
    {
        hr = _GetIconOverlayInfo(pidn, pIndex, SIOM_OVERLAYINDEX);
    }
    return hr;
}


STDMETHODIMP CNetFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    HRESULT hr = E_FAIL;
    LPCIDNETRESOURCE pidn = NET_IsValidID(pidl);
    if (NULL != pidn)
    {
        hr = _GetIconOverlayInfo(pidn, pIndex, SIOM_ICONINDEX);
    }
    return hr;
}



//
// Helper function to allow external callers to query information from a
// network pidl...
//
// NOTE NOTE - This function returns a NETRESOURCE structure whose string
// pointers are not valid.  On Win95 they were pointers back into the pidl's
// strings (even though the strings were copied into the supplied pv buffer.)
// Now we make the pointers really point into the buffer.
//
HRESULT CNetFolder::_GetNetResource(LPCIDNETRESOURCE pidn, NETRESOURCEW* pnr, int cb)
{
    TCHAR szStrings[3][MAX_PATH];
    LPWSTR psz, lpsz[3] = {NULL, NULL, NULL};
    int i, cchT;

    if (cb < sizeof(*pnr))
        return DISP_E_BUFFERTOOSMALL;

    ZeroMemory(pnr, cb);

    NET_CopyResName(pidn, szStrings[0], ARRAYSIZE(szStrings[0]));
    NET_CopyComment(pidn, szStrings[1], ARRAYSIZE(szStrings[1]));
    _GetProvider(pidn, NULL, szStrings[2], ARRAYSIZE(szStrings[2]));

    // Fill in some of the stuff first.
    // pnr->dwScope = 0;
    pnr->dwType = NET_GetType(pidn);
    pnr->dwDisplayType = NET_GetDisplayType(pidn);
    pnr->dwUsage = NET_GetUsage(pidn);
    // pnr->lpLocalName = NULL;

    // Now lets copy the strings into the buffer and make the pointers
    // relative to the buffer...
    psz = (LPWSTR)(pnr + 1);
    cb -= sizeof(*pnr);

    for (i = 0; i < ARRAYSIZE(szStrings); i++)
    {
        if (*szStrings[i])
        {
            cchT = (lstrlen(szStrings[i]) + 1) * sizeof(TCHAR);
            if (cchT <= cb)
            {
                SHTCharToUnicode(szStrings[i], psz, cb/sizeof(TCHAR));
                lpsz[i] = psz;
                psz += cchT;
                cb -= cchT * sizeof(TCHAR);
            }
            else
            {
                // A hint that the structure is ok, but the strings are missing
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
            }
        }
    }

    pnr->lpRemoteName = lpsz[0];
    pnr->lpComment    = lpsz[1];
    pnr->lpProvider   = lpsz[2];

    return S_OK;
}

//
// This function opens a reg. database key based on the "network provider".
//
// Returns:        hkey
//
// The caller is responsibe to close the key by calling RegCloseKey().
//
HKEY CNetFolder::_OpenProviderKey(LPCIDNETRESOURCE pidn)
{
    TCHAR szProvider[MAX_PATH];
    if (_GetProvider(pidn, NULL, szProvider, ARRAYSIZE(szProvider)))
    {
        HKEY hkeyProgID = NULL;
        ReplaceSpacesWithUnderscore(szProvider);
        RegOpenKeyEx(HKEY_CLASSES_ROOT, szProvider, 0, KEY_READ, &hkeyProgID);
        return hkeyProgID;
    }
    return NULL;
}

//
// This function opens a reg. database key based on the network provider type.
// The type is a number that is not localized, as opposed to the provider name
// which may be localized.
//
// Arguments:
//  pidlAbs -- Absolute IDList to a network resource object.
//
// Returns:        hkey
//
// Notes:
//  The caller is responsible to close the key by calling RegCloseKey().
//

HKEY CNetFolder::_OpenProviderTypeKey(LPCIDNETRESOURCE pidn)
{
    HKEY hkeyProgID = NULL;
    TCHAR szProvider[MAX_PATH];

    if (_GetProvider(pidn, NULL, szProvider, ARRAYSIZE(szProvider)))
    {
        // Now that we've got the provider name, get the provider id.
        DWORD dwType;
        if (WNetGetProviderType(szProvider, &dwType) == WN_SUCCESS)
        {
            // convert nis.wNetType to a string, and then open the key
            // HKEY_CLASSES_ROOT\Network\Type\<type string>

            TCHAR szRegValue[MAX_PATH];
            wnsprintf(szRegValue, ARRAYSIZE(szRegValue), TEXT("Network\\Type\\%d"), HIWORD(dwType));
            RegOpenKeyEx(HKEY_CLASSES_ROOT, szRegValue, 0, KEY_READ, &hkeyProgID);
        }
    }

    return hkeyProgID;
}

HRESULT CNetFolder::_OpenKeys(LPCIDNETRESOURCE pidn, HKEY ahkeys[NKID_COUNT])
{
    // See if there is a key specific to the type of Network object...
    COMPILETIME_ASSERT(6 == NKID_COUNT);
    ahkeys[0] = ahkeys[1] = ahkeys[2] = ahkeys[3] = ahkeys[4] = ahkeys[5] = NULL;
    ahkeys[NKID_PROVIDERTYPE] = _OpenProviderTypeKey(pidn);
    ahkeys[NKID_PROVIDER] = _OpenProviderKey(pidn);

    if (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_SHARE)
        RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("NetShare"), 0, KEY_READ, &ahkeys[NKID_NETCLASS]);
    else if (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_SERVER)
        RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("NetServer"), 0, KEY_READ, &ahkeys[NKID_NETCLASS]);

    RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("Network"), 0, KEY_READ, &ahkeys[NKID_NETWORK]);

    // make sure it is not a printer before adding "Folder" or "directory"

    if (!_IsPrintShare(pidn))
    {
        // Shares should also support directory stuff...
        if (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_SHARE)
            RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("Directory"), 0, KEY_READ, &ahkeys[NKID_DIRECTORY]);

        RegOpenKeyEx(HKEY_CLASSES_ROOT, c_szFolderClass, 0, KEY_READ, &ahkeys[NKID_FOLDER]);
    }

    return S_OK;
}

#define WNFMT_PLATFORM  WNFMT_ABBREVIATED | WNFMT_INENUM

//
//  This function retrieves the formatted (display) name of the specified network object.
//
HRESULT CNetFolder::_GetFormatName(LPCIDNETRESOURCE pidn, STRRET* pStrRet)
{
    HRESULT hr = E_FAIL;
    TCHAR szName[MAX_PATH];

    NET_CopyResName(pidn, szName, ARRAYSIZE(szName));
    
    if (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_SERVER)
    {
        TCHAR szMachineName[MAX_PATH];
        TCHAR szComment[MAX_PATH];

        NET_CopyResName(pidn, szMachineName, ARRAYSIZE(szMachineName));
        NET_CopyComment(pidn, szComment, ARRAYSIZE(szComment));

        hr = SHBuildDisplayMachineName(szMachineName, szComment, szName, ARRAYSIZE(szName));
    }

    if (FAILED(hr) && 
        (NET_GetDisplayType(pidn) != RESOURCEDISPLAYTYPE_ROOT) && 
        (NET_GetDisplayType(pidn) != RESOURCEDISPLAYTYPE_NETWORK))
    {
        TCHAR szDisplayName[MAX_PATH], szProvider[MAX_PATH];
        DWORD dwSize = ARRAYSIZE(szDisplayName);

        LPCTSTR pszProvider = _GetProvider(pidn, NULL, szProvider, ARRAYSIZE(szProvider));
        if (pszProvider)
        {   
            DWORD dwRes = WNetFormatNetworkName(pszProvider, szName, szDisplayName, &dwSize, WNFMT_PLATFORM, 8 + 1 + 3);
            if (dwRes == WN_SUCCESS)           
            { 
                StrCpyN(szName, szDisplayName, ARRAYSIZE(szName));
            }                
        }
    }

    return StringToStrRet(szName, pStrRet);
}


//
// resolve non-UNC share names (novell) to UNC style names
//
// returns:
//      TRUE    translated the name
//      FALSE   didn't translate (maybe error case)
//
// WARNING: If we use too much stack space then we will cause
//          faults by over flowing the stack.  Millennium #94818
BOOL CNetFolder::_GetPathForShare(LPCIDNETRESOURCE pidn, LPTSTR pszPath, int cchPath)
{
    BOOL fRet = FALSE;

    *pszPath = TEXT('\0');

    LPTSTR pszAccessName = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * MAX_PATH * 3); // *3 remote, provider and path
    if (pszAccessName)
    {
        LPTSTR pszRemoteName = pszAccessName + MAX_PATH;
        LPTSTR pszProviderName = pszRemoteName + MAX_PATH;

        NET_CopyResName(pidn, pszRemoteName, MAX_PATH);
        if (NULL != _pszResName)
        {
            //
            // Combine the folder name with the share name
            // to create a UNC path.
            //
            // Borrow the pszProviderName buffer for a bit.
            //
            PathCombine(pszProviderName, _pszResName, pszRemoteName);

            //
            // To be safe: UNC prefix implies that name is available using FS access
            // Theoretically it also should be routed to MPR, but it is late to do this
            //
            if (PathIsUNC(pszProviderName))
            {
                StrCpyN(pszPath, pszProviderName, cchPath);
                fRet = FALSE;
            }
            else
            {
                pszProviderName[0] = TEXT('\0');
            }
        }

        if (!*pszPath)
        {
            // Check cache
            ENTERCRITICAL;
            if (lstrcmpi(g_szLastAttemptedJunctionName, pszRemoteName) == 0)
            {
                // cache hit
                StrCpy(pszPath, g_szLastResolvedJunctionName);
                fRet = TRUE;
            }
            LEAVECRITICAL;
        }

        if (!*pszPath)
        {
            NETRESOURCE nr = {0};
            DWORD err, dwRedir, dwResult;
            DWORD cchAccessName;

            nr.lpRemoteName = pszRemoteName;
            nr.lpProvider = (LPTSTR) _GetProvider(pidn, NULL, pszProviderName, MAX_PATH);
            nr.dwType = NET_GetType(pidn);
            nr.dwUsage = NET_GetUsage(pidn);
            nr.dwDisplayType = NET_GetDisplayType(pidn);

            dwRedir = CONNECT_TEMPORARY;

            // Prepare access name buffer and net resource request buffer
            //
            cchAccessName = MAX_PATH;
            pszAccessName[0] = 0;

            err = WNetUseConnection(NULL, &nr, NULL, NULL, dwRedir, pszAccessName, &cchAccessName, &dwResult);
            if ((WN_SUCCESS != err) || !pszAccessName[0])
            {
                // perf idea: might be good to cache the last failed junction bind
                // and early out on the next attempt.  One slight problem this
                // might encounter: what if we cache a failure, the user changes
                // state to fix the problem, but we hit our failure cache...
                //
                StrCpyN(pszPath, pszRemoteName, cchPath);
                fRet = FALSE;
            }
            else
            {
                // Get the return name
                StrCpyN(pszPath, pszAccessName, cchPath);
                fRet = TRUE;

                // Update success cache entry
                ENTERCRITICAL;

                StrCpyN(g_szLastAttemptedJunctionName, pszRemoteName, ARRAYSIZE(g_szLastAttemptedJunctionName));
                StrCpyN(g_szLastResolvedJunctionName, pszAccessName, ARRAYSIZE(g_szLastResolvedJunctionName));

                LEAVECRITICAL;
            }
        }

        LocalFree(pszAccessName);
    }
    return fRet;
}

// in:
//      pidn    may be multi-level net resource pidl like
//              [entire net] [provider] [server] [share] [... file sys]
//           or [server] [share] [... file sys]

HRESULT CNetFolder::_GetPathForItem(LPCIDNETRESOURCE pidn, LPTSTR pszPath, int cchPath)
{
    *pszPath = 0;

    // loop down
    for (; !ILIsEmpty((LPCITEMIDLIST)pidn) ; pidn = (LPCIDNETRESOURCE)_ILNext((LPCITEMIDLIST)pidn))
    {
        if (NET_GetFlags(pidn) & SHID_JUNCTION)     // \\server\share or strike/sys
        {
            _GetPathForShare(pidn, pszPath, cchPath);
            break;  // below this we don't know about any of the PIDLs
        }
        else
        {
            // if this is entire network then return the canonical name for
            // this object.

            if (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_ROOT)
                StrCpyN(pszPath, TEXT("EntireNetwork"), cchPath);
            else
                NET_CopyResName(pidn, pszPath, cchPath);
        }
    }
    return *pszPath ? S_OK : E_NOTIMPL;
}


// in:
//  pidl
//
// takes the last items and create a folder for it, assuming the first section is the 
// used to initialze.  the riid and ppv are used to return an object.
//

HRESULT CNetFolder::_CreateFolderForItem(LPBC pbc, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlTarget, LPCIDNETRESOURCE pidnForProvider, REFIID riid, void **ppv)
{
    LPCITEMIDLIST pidlLast = ILFindLastID(pidl);
    LPCIDNETRESOURCE pidn = NET_IsValidID(pidlLast);

    if (!pidn)
        return E_INVALIDARG;

    HRESULT hr;
    if (NET_IsRemoteFld(pidn))
    {
        // note: I think this is dead functionality. it was used in NT4 but we can't find
        // the impl of this CLSID_Remote anymore...
        IPersistFolder * ppf;
        hr = SHCoCreateInstance(NULL, &CLSID_Remote, NULL, IID_PPV_ARG(IPersistFolder, &ppf));
        if (SUCCEEDED(hr))
        {
            hr= ppf->Initialize(pidl);
            if (SUCCEEDED(hr))
                hr = ppf->QueryInterface(riid, ppv);
            ppf->Release();
        }
    }
    else if (NET_GetFlags(pidn) & SHID_JUNCTION)     // \\server\share or strike/sys
    {
        PERSIST_FOLDER_TARGET_INFO * ppfti = (PERSIST_FOLDER_TARGET_INFO *) LocalAlloc(LPTR, sizeof(PERSIST_FOLDER_TARGET_INFO));
        if (ppfti)
        {
            ppfti->pidlTargetFolder = (LPITEMIDLIST)pidlTarget;    
            ppfti->csidl = -1;
            ppfti->dwAttributes = FILE_ATTRIBUTE_DIRECTORY; // maybe add system?

            _GetPathForItem(pidn, ppfti->szTargetParsingName, ARRAYSIZE(ppfti->szTargetParsingName));

            hr = CFSFolder_CreateFolder(NULL, pbc, pidl, ppfti, riid, ppv);
            LocalFree(ppfti);
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        TCHAR szPath[MAX_PATH];
        NET_CopyResName(pidn, szPath, ARRAYSIZE(szPath));

        hr = _CreateInstance(pidl, pidlTarget, NET_GetDisplayType(pidn), pidnForProvider, szPath, riid, ppv);
    }
    return hr;
}


// get the provider for an item or the folder itself. since some items don't have the
// provider stored we fall back to the folder to get the provider in that case
//
//  in:
//      pidn    item to get provider for. if NULL get provider for the folder
//      pbc     IBindCtx to get provider for.  if NULL get provider from pidn or folder.
//
// returns:
//      NULL        no provider in the item or the folder
//      non NULL    address of passed in buffer

LPCTSTR CNetFolder::_GetProvider(LPCIDNETRESOURCE pidn, IBindCtx *pbc, LPTSTR pszProvider, UINT cchProvider)
{
    // attempt to get the provider from the property bag
    IPropertyBag *ppb;
    if (pbc && SUCCEEDED(pbc->GetObjectParam(STR_PARSE_NETFOLDER_INFO, (IUnknown**)&ppb)))
    {
        HRESULT hr = SHPropertyBag_ReadStr(ppb, STR_PARSE_NETFOLDER_PROVIDERNAME, pszProvider, cchProvider);
        ppb->Release();
        if (SUCCEEDED(hr) && *pszProvider)
        {
            return pszProvider;
        }
    }

    // from the IDLIST
    if (pidn && NET_CopyProviderName(pidn, pszProvider, cchProvider))
        return pszProvider;

    // from our state
    if (_pidnForProvider)
    {
        NET_CopyProviderName(_pidnForProvider, pszProvider, cchProvider);
        return pszProvider;
    }

    *pszProvider = 0;
    return NULL;
}


const NETPROVIDERS c_rgProviderMap[] = 
{
    { TEXT("Microsoft Network"), HIWORD(WNNC_NET_LANMAN) },
    { TEXT("NetWare"),           HIWORD(WNNC_NET_NETWARE) }
};


// construct a net idlist either copying the existing data from a pidl or 
// from a NETRESOURCE structure

HRESULT CNetFolder::_CreateNetIDList(LPIDNETRESOURCE pidnIn, 
                                     LPCTSTR pszName, LPCTSTR pszProvider, LPCTSTR pszComment, 
                                     LPITEMIDLIST *ppidl)
{
    LPBYTE pb;
    UINT cbmkid = sizeof(IDNETRESOURCE) - sizeof(CHAR);
    UINT cchName, cchProvider, cchComment, cbProviderType = 0;
    LPIDNETRESOURCE pidn;
    WORD wNetType = 0;
    BOOL fUnicode = FALSE;
    UINT cchAnsiName, cchAnsiProvider, cchAnsiComment;
    CHAR szAnsiName[MAX_PATH], szAnsiProvider[MAX_PATH], szAnsiComment[MAX_PATH];

    ASSERT(ppidl != NULL);
    *ppidl = NULL;

    if (!pszName)
        pszName = c_szNULL;     // For now put in an empty string...

    if (pszProvider)
        cbProviderType += sizeof(WORD);
    
    // Win9x shipped with one set of provider name which are 
    // different on NT.  Therefore lets convert the NT one to
    // something that Win9x can understand.

    if (pszProvider)
    {
        cbProviderType = sizeof(WORD);
        DWORD dwType, dwRes = WNetGetProviderType(pszProvider, &dwType);
        if (dwRes == WN_SUCCESS)
        {
            wNetType = HIWORD(dwType);
            for (int i = 0; i < ARRAYSIZE(c_rgProviderMap); i++)
            {
                if (c_rgProviderMap[i].wNetType == wNetType)
                {
                    pszProvider = c_rgProviderMap[i].lpName;
                    break;
                }
            }
        }
    }

    // compute the string lengths ready to build an IDLIST

    cchName = lstrlen(pszName)+1;
    cchProvider = pszProvider ? lstrlen(pszProvider)+1 : 0;
    cchComment = pszComment ? lstrlen(pszComment)+1 : 0;

    cchAnsiName = 0;
    cchAnsiProvider = 0;
    cchAnsiComment = 0;

    fUnicode  = !DoesStringRoundTrip(pszName, szAnsiName, ARRAYSIZE(szAnsiProvider));
    cchAnsiName = lstrlenA(szAnsiName)+1;

    if (pszProvider)
    {
        fUnicode |= !DoesStringRoundTrip(pszProvider, szAnsiProvider, ARRAYSIZE(szAnsiProvider));
        cchAnsiProvider = lstrlenA(szAnsiProvider)+1;
    }

    if (pszComment)
    {
        fUnicode |= !DoesStringRoundTrip(pszComment, szAnsiComment, ARRAYSIZE(szAnsiComment));
        cchAnsiComment = lstrlenA(szAnsiComment)+1;
    }

    // allocate and fill the IDLIST header

    cbmkid += cbProviderType+cchAnsiName + cchAnsiProvider + cchAnsiComment;

    if (fUnicode)
        cbmkid += (sizeof(WCHAR)*(cchName+cchProvider+cchComment));

    pidn = (LPIDNETRESOURCE)_ILCreate(cbmkid + sizeof(USHORT));
    if (!pidn)
        return E_OUTOFMEMORY;

    pidn->cb = (WORD)cbmkid;
    pidn->bFlags = pidnIn->bFlags;
    pidn->uType = pidnIn->uType;
    pidn->uUsage = pidnIn->uUsage;

    if (pszProvider)
        pidn->uUsage |= NET_HASPROVIDER;

    if (pszComment)
        pidn->uUsage |= NET_HASCOMMENT;

    pb = (LPBYTE) pidn->szNetResName;

    //
    // write the ANSI strings into the IDLIST
    //

    StrCpyA((PSTR)pb, szAnsiName);                           // buffer allocated above based on cch
    pb += cchAnsiName;

    if (pszProvider)
    {
        StrCpyA((PSTR) pb, szAnsiProvider);                  // buffer allocated above based on cch
        pb += cchAnsiProvider;
    }

    if (pszComment)
    {
        StrCpyA((PSTR) pb, szAnsiComment);                   // buffer allocated above based on cch
        pb += cchAnsiComment;
    }

    // if we are going to be UNICODE then lets write those strings also.
    // Note that we must use unaligned string copies since the is no
    // promse that the ANSI strings will have an even number of characters
    // in them.
    if (fUnicode)
    {
        pidn->uUsage |= NET_UNICODE;
      
        ualstrcpyW((UNALIGNED WCHAR *)pb, pszName);              // buffer allocated above based on cch
        pb += cchName*sizeof(WCHAR);

        if (pszProvider)
        {
            ualstrcpyW((UNALIGNED WCHAR *)pb, pszProvider);     // buffer allocated above based on cch
            pb += cchProvider*sizeof(WCHAR);
        }

        if (pszComment)
        {
            ualstrcpyW((UNALIGNED WCHAR *)pb, pszComment);      // buffer allocated above based on cch
            pb += cchComment*sizeof(WCHAR);
        }
    }

    //
    // and the trailing provider type
    //

    if (cbProviderType)
    {
        // Store the provider type
        pb = (LPBYTE)pidn + pidn->cb - sizeof(WORD);
        *((UNALIGNED WORD *)pb) = wNetType;
    }

    *ppidl = (LPITEMIDLIST)pidn;
    return S_OK;
}


// wrapper for converting a NETRESOURCE into an IDLIST via _CreateNetPidl

HRESULT CNetFolder::_NetResToIDList(NETRESOURCE *pnr, 
                                    BOOL fKeepNullRemoteName, 
                                    BOOL fKeepProviderName, 
                                    BOOL fKeepComment, 
                                    LPITEMIDLIST *ppidl)
{
    NETRESOURCE nr = *pnr;
    LPITEMIDLIST pidl;
    LPTSTR pszName, pszProvider, pszComment;
    IDNETRESOURCE idn;
    LPTSTR psz;

    if (ppidl)
        *ppidl = NULL;

    switch (pnr->dwDisplayType) 
    {
    case RESOURCEDISPLAYTYPE_NETWORK:
        pszName = pnr->lpProvider;
        break;

    case RESOURCEDISPLAYTYPE_ROOT:
        pszName =pnr->lpComment;
        break;

    default:
        {
            pszName = pnr->lpRemoteName;

            if (!fKeepNullRemoteName && (!pszName || !*pszName))
                return E_FAIL;

            if (pszName && *pszName)
            {
                psz = (LPTSTR)SkipServerSlashes(pnr->lpRemoteName);
                if ( *psz )
                    PathMakePretty(psz);
            }
        }
        break;
    }

    pszProvider = fKeepProviderName ? nr.lpProvider:NULL;
    pszComment = fKeepComment ? nr.lpComment:NULL;
       
    idn.bFlags = (BYTE)(SHID_NET | (pnr->dwDisplayType & 0x0f));
    idn.uType  = (BYTE)(pnr->dwType & 0x0f);
    idn.uUsage = (BYTE)(pnr->dwUsage & 0x0f);

    // Is the current resource a share of some kind and not a container
    if ((pnr->dwDisplayType == RESOURCEDISPLAYTYPE_SHARE || pnr->dwDisplayType == RESOURCEDISPLAYTYPE_SHAREADMIN) &&
        !(pnr->dwUsage & RESOURCEUSAGE_CONTAINER))
    {
        // If so, remember to delegate children of this folder to FSFolder
        idn.bFlags |= (BYTE)SHID_JUNCTION;    // \\server\share type thing
    }

    HRESULT hr = _CreateNetIDList(&idn, pszName, pszProvider, pszComment, &pidl);
    if (SUCCEEDED(hr))
    {
        if (ppidl)
            *ppidl = pidl;
    }

    return hr;
}

HRESULT CNetFolder::_CreateEntireNetwork(LPITEMIDLIST *ppidl)
{
    TCHAR szPath[MAX_PATH];
    NETRESOURCE nr = {0};

    // We need to add the Rest of network entry.  This is psuedo
    // bogus, as we should either always do it ourself or have
    // MPR always do it, but here it goes...
    LoadString(HINST_THISDLL, IDS_RESTOFNET, szPath, ARRAYSIZE(szPath));
    nr.dwDisplayType = RESOURCEDISPLAYTYPE_ROOT;
    nr.dwType = RESOURCETYPE_ANY;
    nr.dwUsage = RESOURCEUSAGE_CONTAINER;
    nr.lpComment = szPath;

    return _NetResToIDList(&nr, FALSE, FALSE, FALSE, ppidl);
}

HRESULT CNetFolder::_CreateEntireNetworkFullIDList(LPITEMIDLIST *ppidl)
{
    // CLSID_NetworkPlaces\EntireNetwork
    return SHILCreateFromPath(TEXT("::{208D2C60-3AEA-1069-A2D7-08002B30309D}\\EntireNetwork"), ppidl, NULL);
}

//
// To be called back from within CDefFolderMenu
//
STDAPI CNetwork_DFMCallBackBG(IShellFolder *psf, HWND hwnd,
                              IDataObject *pdtobj, UINT uMsg, 
                              WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    CNetFolder *pThis = FolderToNetFolder(psf);

    if (NULL == pThis)
        return E_UNEXPECTED;

    switch(uMsg)
    {
    case DFM_MERGECONTEXTMENU_BOTTOM:
        if (!(wParam & (CMF_VERBSONLY | CMF_DVFILE)))
        {
            CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_PROPERTIES_BG, 0, (LPQCMINFO)lParam);
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam)
        {
        case FSIDM_PROPERTIESBG:
            hr = SHPropertiesForPidl(hwnd, pThis->_pidl, (LPCTSTR)lParam);
            break;

        default:
            // This is one of view menu items, use the default code.
            hr = S_FALSE;
            break;
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}


//
// To be called back from within CDefFolderMenu
//
STDAPI CNetFolder::DFMCallBack(IShellFolder* psf, HWND hwnd,
                                  IDataObject* pdtobj, UINT uMsg, 
                                  WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch(uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        if (pdtobj)
        {
            STGMEDIUM medium;
            LPIDA pida;
            LPQCMINFO pqcm = (LPQCMINFO)lParam;
            UINT idCmdBase = pqcm->idCmdFirst; // must be called before merge
            CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_NETWORK_ITEM, 0, pqcm);

            pida = DataObj_GetHIDA(pdtobj, &medium);
            if (pida)
            {
                if (pida->cidl > 0)
                {
                    LPIDNETRESOURCE pidn = (LPIDNETRESOURCE)IDA_GetIDListPtr(pida, 0);

                    // Only enable "connect" command if the first one is a share.
                    if (pidn)
                    {
                        ULONG rgf = 0;
                        if(NET_GetFlags(pidn) & SHID_JUNCTION &&
                            !SHRestricted(REST_NONETCONNECTDISCONNECT))
                        {
                            EnableMenuItem(pqcm->hmenu, idCmdBase + FSIDM_CONNECT,
                                MF_CHECKED | MF_BYCOMMAND);
                        }
                    }
                }
                HIDA_ReleaseStgMedium(pida, &medium);
            }
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));
        break;

    case DFM_INVOKECOMMAND:
        switch(wParam)
        {
        case DFM_CMD_PROPERTIES:
            hr = SHLaunchPropSheet(_PropertiesThreadProc, pdtobj, (LPCTSTR)lParam, psf, NULL);
            break;

        case DFM_CMD_LINK:
            {
                hr = S_FALSE; // do the default shortcut stuff
                CNetFolder *pThis = FolderToNetFolder(psf);
                if (pThis)
                {
                    // net hood special case.  in this case we want to create the shortuct
                    // in the net hood, not offer to put this on the desktop
                    IShellFolder2* psfFiles;
                    if (SUCCEEDED(pThis->v_GetFileFolder(&psfFiles)))
                    {
                        CFSFolder_CreateLinks(hwnd, psfFiles, pdtobj, (LPCTSTR)lParam, CMIC_MASK_FLAG_NO_UI);
                        hr = S_OK;    // we created the links
                    }
                }
            }
            break;

        case FSIDM_CONNECT:
            if (pdtobj)
            {
                STGMEDIUM medium;
                LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
                if (pida)
                {
                    for (UINT i = 0; i < pida->cidl; i++)
                    {
                        LPIDNETRESOURCE pidn = (LPIDNETRESOURCE)IDA_GetIDListPtr(pida, i);

                        // Only execute "connect" on shares.
                        if (NET_GetFlags(pidn) & SHID_JUNCTION)
                        {
                            TCHAR szName[MAX_PATH];
                            LPTSTR pszName = NET_CopyResName(pidn, szName, ARRAYSIZE(szName));
                            DWORD err = SHStartNetConnectionDialog(hwnd, pszName, RESOURCETYPE_DISK);
                            DebugMsg(DM_TRACE, TEXT("CNet FSIDM_CONNECT (%s, %x)"), szName, err);

                            // events will get generated automatically
                        }
                    }
                    HIDA_ReleaseStgMedium(pida, &medium);
                }
            }
            break;

        default:
            // This is one of view menu items, use the default code.
            hr = S_FALSE;
            break;
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }
    return hr;
}

STDAPI CNetFolder::PrinterDFMCallBack(IShellFolder* psf, HWND hwnd,
                                      IDataObject* pdtobj, UINT uMsg, 
                                      WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch(uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        //
        //  Returning S_FALSE indicates no need to get verbs from
        // extensions.
        //
        hr = S_FALSE;
        break;

    // if anyone hooks our context menu, we want to be on top (Open)
    case DFM_MERGECONTEXTMENU_TOP:
        if (pdtobj)
        {
            LPQCMINFO pqcm = (LPQCMINFO)lParam;

            // insert verbs
            CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_NETWORK_PRINTER, 0, pqcm);
            SetMenuDefaultItem(pqcm->hmenu, 0, MF_BYPOSITION);
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam)
        {
        case DFM_CMD_PROPERTIES:
            hr = SHLaunchPropSheet(_PropertiesThreadProc, pdtobj, (LPCTSTR)lParam, psf, NULL);
            break;

        case DFM_CMD_LINK:
            // do the default create shortcut crap
            return S_FALSE;

        case FSIDM_OPENPRN:
        case FSIDM_NETPRN_INSTALL:
        {
            STGMEDIUM medium;
            LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
            if (pida)
            {
                UINT action;

                // set up the operation we are going to perform
                switch (wParam) 
                {
                case FSIDM_OPENPRN:
                    action = PRINTACTION_OPENNETPRN;
                    break;
                case FSIDM_NETPRN_INSTALL:
                    action = PRINTACTION_NETINSTALL;
                    break;
                default: // FSIDM_CONNECT_PRN
                    action = (UINT)-1;
                    break;
                }

                for (UINT i = 0; i < pida->cidl; i++)
                {
                    LPIDNETRESOURCE pidn = (LPIDNETRESOURCE)IDA_GetIDListPtr(pida, i);

                    // Only execute command for a net print share
                    if (_IsPrintShare(pidn))
                    {
                        TCHAR szName[MAX_PATH];
                        NET_CopyResName(pidn,szName,ARRAYSIZE(szName));

                        SHInvokePrinterCommand(hwnd, action, szName, NULL, FALSE);
                    }
                } // for (i...
                HIDA_ReleaseStgMedium(pida, &medium);
            } // if (medium.hGlobal)
            break;
        } // case ID_NETWORK_PRINTER_INSTALL, FSIDM_CONNECT_PRN

        default:
            hr = E_FAIL;
            break;

        } // switch(wparam)
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }
    return hr;
}


//
// REVIEW: Almost identical code in fstreex.c
//
DWORD CALLBACK CNetFolder::_PropertiesThreadProc(void *pv)
{
    PROPSTUFF* pps = (PROPSTUFF *)pv;
    ULONG_PTR dwCookie = 0;
    ActivateActCtx(NULL, &dwCookie);
    CNetFolder *pThis = FolderToNetFolder(pps->psf);
    if (pThis)
    {
        STGMEDIUM medium;
        LPIDA pida = DataObj_GetHIDA(pps->pdtobj, &medium);
        if (pida)
        {
            // Yes, do context menu.
            HKEY ahkeys[NKID_COUNT];
            LPCIDNETRESOURCE pnid = (LPCIDNETRESOURCE)IDA_GetIDListPtr(pida, 0);
            if (pnid)
            {
                HRESULT hr = pThis->_OpenKeys(pnid, ahkeys);
                if (SUCCEEDED(hr))
                {
                    LPTSTR pszCaption = SHGetCaption(medium.hGlobal);
                    SHOpenPropSheet(pszCaption, ahkeys, ARRAYSIZE(ahkeys),
                                    &CLSID_ShellNetDefExt,
                                    pps->pdtobj, NULL, pps->pStartPage);
                    if (pszCaption)
                        SHFree(pszCaption);

                    SHRegCloseKeys(ahkeys, ARRAYSIZE(ahkeys));
                }
            }

            HIDA_ReleaseStgMedium(pida, &medium);
        }
    }
    return S_OK;
}

STDAPI CNetFolder::_AttributesCallback(IShellFolder2* psf, LPCITEMIDLIST pidl, ULONG* prgfInOut)
{
    LPCIDNETRESOURCE pidn = (LPCIDNETRESOURCE)pidl;
    ULONG rgfOut = SFGAO_CANLINK | SFGAO_HASPROPSHEET | SFGAO_HASSUBFOLDER |
                   SFGAO_FOLDER | SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR;

    if (NET_GetFlags(pidn) & SHID_JUNCTION)
    {
        if ((NET_GetType(pidn) == RESOURCETYPE_DISK) || 
            (NET_GetType(pidn) == RESOURCETYPE_ANY))
            rgfOut |= SFGAO_FILESYSTEM | SFGAO_DROPTARGET | SFGAO_CANCOPY | SFGAO_CANMOVE | SFGAO_STORAGE;
        else
            rgfOut &= ~(SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR);
    }

    if (_IsPrintShare(pidn))
    {
        rgfOut |= SFGAO_DROPTARGET; // for drag and drop printing
        rgfOut &= ~(SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR | SFGAO_FILESYSTEM | SFGAO_FOLDER | SFGAO_HASSUBFOLDER);
    }

    if (NET_IsRemoteFld(pidn))
    {
        rgfOut &= ~(SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR | SFGAO_FILESYSTEM);
    }

    *prgfInOut = rgfOut;
    return S_OK;

}

// This is only used by the CNetRootFolder subclass, but because we can only QI for
// CLSID_NetFldr, and we can't access protected members of any CNetFolder instance 
// from a member function of CNetRootFolder, we'll make it belong to CNetFolder

HRESULT CALLBACK CNetFolder::_AttributesCallbackRoot(IShellFolder2* psf, LPCITEMIDLIST pidl, ULONG* prgfInOut)
{
    HRESULT hr;
    CNetFolder* pNetF = FolderToNetFolder(psf);
    if (pNetF)
    {
        if (NET_IsValidID(pidl))
        {
            hr = pNetF->CNetFolder::GetAttributesOf(1, &pidl, prgfInOut);
        }
        else 
        {
            IShellFolder2* psfFiles;
            hr = pNetF->v_GetFileFolder(&psfFiles);
            if (SUCCEEDED(hr))
                hr = psfFiles->GetAttributesOf(1, &pidl, prgfInOut);
        }
    }
    else
        hr = E_FAIL;
    return hr;
}

// this is called by netfind.c

STDAPI CNetwork_EnumSearches(IShellFolder2* psf2, IEnumExtraSearch **ppenum)
{
    *ppenum = NULL;

    CNetFolder* pNetF = FolderToNetFolder(psf2);
    return pNetF ? pNetF->EnumSearches(ppenum) : E_INVALIDARG;
}


// given the resulting ppidl and a pszRest continue to parse through and add in the remainder
// of the file system path.

HRESULT CNetFolder::_ParseRest(LPBC pbc, LPCWSTR pszRest, LPITEMIDLIST* ppidl, DWORD* pdwAttributes)
{
    HRESULT hr = S_OK;

    // skip leading \ if there is one present
    if (pszRest && pszRest[0] == L'\\')
        pszRest++;

    if (pszRest && pszRest[0])
    {
        // need to QI to get the agregated case
        IShellFolder* psfBind;
        hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfBind));
        if (SUCCEEDED(hr))
        {
            // pass down to pick off stuff below including regitems and file names
            IShellFolder* psfSub;
            hr = psfBind->BindToObject(*ppidl, NULL, IID_PPV_ARG(IShellFolder, &psfSub));
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlSubDir;
                hr = psfSub->ParseDisplayName(NULL, pbc, (LPWSTR)pszRest, NULL, &pidlSubDir, pdwAttributes);
                if (SUCCEEDED(hr))
                {
                    hr = SHILAppend(pidlSubDir, ppidl);
                }
                psfSub->Release();
            }
            psfBind->Release();
        }
    }
    else
    {
        if (pdwAttributes)
        {
            LPCITEMIDLIST apidlLast[1] = { ILFindLastID(*ppidl) };
            hr = GetAttributesOf(1, apidlLast, pdwAttributes);
        }
    }

    return hr;
}


// generate an IDLIST from the NETRESOURCESTRUCTURE we have by
// walking up its parents trying to determine where we
// are in the namespace

BOOL _GetParentResource(NETRESOURCE *pnr, DWORD *pdwbuf)
{
    if ((pnr->dwDisplayType == RESOURCEDISPLAYTYPE_ROOT) || 
           (WN_SUCCESS != WNetGetResourceParent(pnr, pnr, pdwbuf)))
    {
        return FALSE;
    }

    return TRUE;
}

HRESULT CNetFolder::_NetResToIDLists(NETRESOURCE *pnr, DWORD dwbuf, LPITEMIDLIST *ppidl)
{
    HRESULT hr = S_OK;

    do
    {
        LPITEMIDLIST pidlT;
        hr = _NetResToIDList(pnr, TRUE, TRUE, TRUE, &pidlT);
        if (SUCCEEDED(hr))
        {
            hr = SHILPrepend(pidlT, ppidl); // NOTE: SHILPrepend frees on failure
        }
    }
    while (SUCCEEDED(hr) && _GetParentResource(pnr, &dwbuf));

    return hr;
}


// get the parsable network name from the object

LPTSTR CNetFolder::_GetNameForParsing(LPCWSTR pwszName, LPTSTR pszBuffer, INT cchBuffer, LPTSTR *ppszRegItem)
{
    LPTSTR pszRegItem = NULL;
    INT cSlashes = 0;

    *ppszRegItem = NULL;
 
    SHUnicodeToTChar(pwszName, pszBuffer, cchBuffer);    

    // remove the trailing \ if there is one, NTLanMan barfs if we pass a string containing it

    INT cchPath = lstrlen(pszBuffer)-1;
    if (cchPath > 2)
    {
        // We don't need to call CharPrev if cchPath <= 2.
        // Calling CharPrev is expensive.
        LPTSTR lpTmp = CharPrev(pszBuffer, pszBuffer + cchPath + 1);
        if (*lpTmp == TEXT('\\'))
            *lpTmp = TEXT('\0');
    }

    // lets walk the name, look for \:: squence to signify the start of a regitem name,
    // and if the number of slashes is > 2 then we should bail
    
    LPTSTR pszUNC = pszBuffer+2;    
    while (pszUNC && *pszUNC && (cSlashes < 2))
    {
        if ((pszUNC[0] == TEXT('\\')) && 
                (pszUNC[1] == TEXT(':')) && (pszUNC[2] == TEXT(':')))
        {
            *ppszRegItem = pszUNC;
            break;
        }

        pszUNC = StrChr(pszUNC+1, TEXT('\\'));
        cSlashes++;
    }

    return pszUNC;
}


HRESULT CNetFolder::_ParseNetName(HWND hwnd, LPBC pbc, 
                                  LPCWSTR pwszName, ULONG* pchEaten,
                                  LPITEMIDLIST *ppidl, DWORD *pdwAttrib)
{
    HRESULT hr;
    struct _NRTEMP 
    {
        NETRESOURCE nr;
        TCHAR szBuffer[1024];
    } nrOut = { 0 };
    TCHAR szPath[MAX_PATH];
    DWORD dwres, dwbuf = sizeof(nrOut.szBuffer);
    LPTSTR pszServerShare = NULL;
    LPTSTR pszRestOfName = NULL;
    LPTSTR pszFakeRestOfName = NULL;
    LPTSTR pszRegItem = NULL;

    // validate the name before we start cracking it...

    pszFakeRestOfName = _GetNameForParsing(pwszName, szPath, ARRAYSIZE(szPath), &pszRegItem);

    NETRESOURCE nr = { 0 };
    nr.lpRemoteName = szPath;
    nr.dwType = RESOURCETYPE_ANY;

    TCHAR szProviderTemp[256];
    nr.lpProvider = (LPTSTR)_GetProvider(NULL, pbc, szProviderTemp, ARRAYSIZE(szProviderTemp));

    dwres = WNetGetResourceInformation(&nr, &nrOut.nr, &dwbuf, &pszRestOfName);    
    if (WN_SUCCESS != dwres)
    {
        TCHAR cT;
        LPTSTR pszTemp;

        // truncate the string at the \\server\share to try and parse the name,
        // note at this point if MPR resolves the alias on a Novel server this could
        // get very confusing (eg. \\strike\foo\bah may resolve to \\string\bla,
        // yet our concept of what pszRestOfName will be wrong!
    
        if (pszFakeRestOfName)
        {
            cT = *pszFakeRestOfName;
            *pszFakeRestOfName = TEXT('\0');
        }

        dwres = WNetGetResourceInformation(&nr, &nrOut.nr, &dwbuf, &pszTemp);    
        if (dwres != WN_SUCCESS)
        {
            // we failed to get  a net connection using the truncated string,
            // so lets try and use a new connect (eg. prompt for creds)

// NOTE: shouldn't we only be doing this if its an access denied type error?

            dwres = WNetUseConnection(hwnd, &nr, NULL, NULL, hwnd ? CONNECT_INTERACTIVE:0, NULL, NULL, NULL);
            if (dwres == WN_SUCCESS)
            {
                dwres = WNetGetResourceInformation(&nr, &nrOut, &dwbuf, &pszTemp);
            }
        }

        if (pszFakeRestOfName)
            *pszFakeRestOfName = cT;

        pszRestOfName = pszFakeRestOfName;
    }

    if (WN_SUCCESS == dwres)
    {
        WCHAR wszRestOfName[MAX_PATH] = { 0 };

        if (pszRestOfName)
            SHTCharToUnicode(pszRestOfName, wszRestOfName, ARRAYSIZE(wszRestOfName));

        // assume we are truncating at the regitem and parsing through

        if (pszRegItem)
            pszRestOfName = pszRegItem;

        // attempt to convert the NETRESOURCE to a string to IDLISTS by walking the
        // parents, then add in Entire Network

        hr = _NetResToIDLists(&nrOut.nr, dwbuf, ppidl);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlT;
            hr = _CreateEntireNetwork(&pidlT);
            if (SUCCEEDED(hr))
            {
                hr = SHILPrepend(pidlT, ppidl); // NOTE: SHILPrepend frees on failure
            }
        }

        // if we have a local string then lets continue to parse it by binding to 
        // its parent folder, otherwise we just want to return the attributes

        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(DisplayNameOf(this, *ppidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath))))
            {
                NPTRegisterNameToPidlTranslation(szPath, *ppidl); // no _ILNext b/c this is relative to the Net Places folder
            }
            hr = _ParseRest(pbc, wszRestOfName, ppidl, pdwAttrib);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(dwres);
    }

    return hr;
}


//
// simple name parsing for the network paths.  this makes big assumptions about the
// \\server\share format we are given, and the type of IDLISTs to return.
//

HRESULT CNetFolder::_AddUnknownIDList(DWORD dwDisplayType, LPITEMIDLIST *ppidl)
{
    NETRESOURCE nr = { 0 };

    nr.dwScope = RESOURCE_GLOBALNET;
    nr.dwDisplayType = dwDisplayType;
    nr.dwUsage = RESOURCEUSAGE_CONTAINER;
    nr.lpRemoteName = TEXT("\0");               // null name means fake item

    LPITEMIDLIST pidlT;
    HRESULT hr = _NetResToIDList(&nr, TRUE, FALSE, FALSE, &pidlT);
    if (SUCCEEDED(hr))
    {
        hr = SHILAppend(pidlT, ppidl);
        if (FAILED(hr))
            ILFree(pidlT);
    }

    return hr;
}

HRESULT CNetFolder::_ParseSimple(LPBC pbc, LPWSTR pszName, LPITEMIDLIST* ppidl, DWORD* pdwAttributes)
{
    HRESULT hr = S_OK;
    NETRESOURCE nr = {0};
    LPWSTR pszSlash;
    LPITEMIDLIST pidlT;

    *ppidl = NULL;

    // create the entire network IDLIST, provider and domain elements

    hr = _CreateEntireNetwork(ppidl);

    if (SUCCEEDED(hr))
        hr = _AddUnknownIDList(RESOURCEDISPLAYTYPE_NETWORK, ppidl);

    if (SUCCEEDED(hr))
        hr = _AddUnknownIDList(RESOURCEDISPLAYTYPE_DOMAIN, ppidl);

    // create the server IDLIST

    if (SUCCEEDED(hr))
    {
        pszSlash = StrChrW(pszName+2, L'\\');

        if (pszSlash)
            *pszSlash = L'\0';

        nr.dwScope = RESOURCE_GLOBALNET;
        nr.dwDisplayType = RESOURCEDISPLAYTYPE_SERVER;
        nr.dwType = RESOURCETYPE_DISK;
        nr.dwUsage = RESOURCEUSAGE_CONTAINER;
        nr.lpRemoteName = pszName;

        hr = _NetResToIDList(&nr, FALSE, FALSE, FALSE, &pidlT);
        if (SUCCEEDED(hr))
            hr = SHILAppend(pidlT, ppidl);

        if (pszSlash)
            *pszSlash = L'\\';

        // if we have a trailing \ then lets add in the share part of the IDLIST

        if (SUCCEEDED(hr) && pszSlash)
        {
            pszSlash = StrChrW(pszSlash+1, L'\\');
            if (pszSlash)
                *pszSlash = L'\0';

            nr.dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
            nr.dwUsage = RESOURCEUSAGE_CONNECTABLE;
            nr.lpRemoteName = pszName;

            hr = _NetResToIDList(&nr, FALSE, FALSE, FALSE, &pidlT);
            if (SUCCEEDED(hr))
                hr = SHILAppend(pidlT, ppidl);

            if (pszSlash)
                *pszSlash = L'\\';
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = _ParseRest(pbc, pszSlash, ppidl, pdwAttributes);
    }
    
    return hr;
}


// try parsing out the EntireNet or localised version.  if we find that object then try and
// parse through that to the regitems or other objects which live below.   this inturn
// will cause an instance of CNetFolder to be created to generate the other parsing names.
//
// returns:
//      S_FALSE         - not rest of net, try something else
//      S_OK            - was rest of net, use this
//      FAILED(hr)    - error result, return

HRESULT CNetRootFolder::_TryParseEntireNet(HWND hwnd, LPBC pbc, WCHAR *pwszName, LPITEMIDLIST *ppidl, DWORD *pdwAttributes)
{
    HRESULT hr = S_FALSE; // skip, not rest of net
 
    *ppidl = NULL;

    if (!PathIsUNCW(pwszName))
    {
        const WCHAR szEntireNetwork[] = L"EntireNetwork";
        WCHAR szRestOfNet[128];
        INT cchRestOfNet = LoadStringW(HINST_THISDLL, IDS_RESTOFNET, szRestOfNet, ARRAYSIZE(szRestOfNet));
       
        BOOL fRestOfNet = !StrCmpNIW(szRestOfNet, pwszName, cchRestOfNet);
        if (!fRestOfNet && !StrCmpNIW(szEntireNetwork, pwszName, ARRAYSIZE(szEntireNetwork)-1)) 
        {
            fRestOfNet = TRUE;
            cchRestOfNet = ARRAYSIZE(szEntireNetwork)-1;
        }
        
        if (fRestOfNet)
        {
            hr = _CreateEntireNetwork(ppidl);
            if (SUCCEEDED(hr))
            {
                if (pdwAttributes)
                {
                    GetAttributesOf(1, (LPCITEMIDLIST *)ppidl, pdwAttributes);
                }
                hr = S_OK;
            }

            // 
            // if we find extra stuff after the name then lets bind and continue the parsing
            // from there on.  this is needed so the we can access regitems burried inside
            // entire net.
            //
            // eg:  EntireNetwork\\::{clsid}
            //

            if (SUCCEEDED(hr) && 
                    (pwszName[cchRestOfNet] == L'\\') && pwszName[cchRestOfNet+1])
            {
                IShellFolder *psfRestOfNet;
                hr = BindToObject(*ppidl, NULL, IID_PPV_ARG(IShellFolder, &psfRestOfNet));
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidl;
                    hr = psfRestOfNet->ParseDisplayName(hwnd, pbc, pwszName+cchRestOfNet+1, NULL, &pidl, pdwAttributes);
                    if  (SUCCEEDED(hr))
                    {
                        hr = SHILAppend(pidl, ppidl);                        
                    }
                    psfRestOfNet->Release();
                }
            }
        }
    }

    return hr;
}


// CNetRootFolder::ParseDisplayname
//  - swtich based on the file system context to see if we need to do a simple parse or not,
//  - check for "EntireNet" and delegate parsing as required.

STDMETHODIMP CNetRootFolder::ParseDisplayName(HWND hwnd, LPBC pbc, WCHAR* pszName, ULONG* pchEaten, LPITEMIDLIST* ppidl, DWORD* pdwAttributes)
{
    if (!ppidl)
        return E_INVALIDARG;

    *ppidl = NULL;

    if (!pszName)
        return E_INVALIDARG;

    HRESULT hr = _TryParseEntireNet(hwnd, pbc, pszName, ppidl, pdwAttributes);
    if (hr == S_FALSE)
    {
        if (PathIsUNCW(pszName))
        {
            LPCITEMIDLIST pidlMapped;
            LPTSTR pszRest = NPTMapNameToPidl(pszName, &pidlMapped);
            if (pidlMapped)
            {
                hr = SHILClone(pidlMapped, ppidl);
                if (SUCCEEDED(hr))
                {
                    hr = _ParseRest(pbc, pszRest, ppidl, pdwAttributes);
                }
            }
            else
            {
                if (S_OK == SHIsFileSysBindCtx(pbc, NULL))
                {
                    hr = _ParseSimple(pbc, pszName, ppidl, pdwAttributes);
                }
                else
                {
                    hr = _ParseNetName(hwnd, pbc, pszName, pchEaten, ppidl, pdwAttributes);
                }
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_NET_NAME);
        }

        if ((HRESULT_FROM_WIN32(ERROR_BAD_NET_NAME) == hr))
        {
            IShellFolder2 *psfFiles;
            if (SUCCEEDED(v_GetFileFolder(&psfFiles)))
            {
                hr = psfFiles->ParseDisplayName(hwnd, pbc, pszName, pchEaten, ppidl, pdwAttributes);
            }
        }
    }

    if (FAILED(hr))
    {
        ILFree(*ppidl);
        *ppidl = NULL;
    }
    
    return hr;
}



STDMETHODIMP CNetRootFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList** ppenum)
{
    DWORD dwRemote = RMF_GETLINKENUM;
    HANDLE hEnum = NULL;

    // Do we enumerate the workgroup?
    if (!SHRestricted(REST_ENUMWORKGROUP))
    {
        // Don't enumerate the workgroup, if the restriction says so
        dwRemote |= RMF_FAKENETROOT;

        // Check the WNet policy to see if we should be showing the
        // entire net object.  If not, mark it as shown so that the
        // enumerator doesn't return it.
        if (SHRestricted(REST_NOENTIRENETWORK))
            dwRemote |= RMF_ENTIRENETSHOWN;
    }

    // if we are not faking the net root then lets call _OpenEnum, otherwise lets ignore

    if (!(dwRemote & RMF_FAKENETROOT))
    {
        DWORD err = _OpenEnum(hwnd, grfFlags, NULL, &hEnum);

        // Always add the remote folder to the 'hood
        if (WN_SUCCESS != err)
        {
            // Yes; still show remote anyway (only)
            dwRemote |= RMF_SHOWREMOTE;
        }
        else
        {
            // No; allow everything to be enumerated in the 'hood.
            dwRemote |= RMF_CONTEXT;
        }
    }

    HRESULT hr = Create_NetFolderEnum(this, grfFlags, dwRemote, hEnum, ppenum);

    if (FAILED(hr) && hEnum)
    {
        WNetCloseEnum(hEnum);
    }

    return hr;
}

STDMETHODIMP CNetRootFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr;
    if (NET_IsValidID(pidl))
        hr = CNetFolder::BindToObject(pidl, pbc, riid, ppv);
    else
    {
        IShellFolder2* psfFiles;
        hr = v_GetFileFolder(&psfFiles);
        if (SUCCEEDED(hr))
        {
            hr = psfFiles->BindToObject(pidl, pbc, riid, ppv);
        }            
    }
    return hr;
}

STDMETHODIMP CNetRootFolder::CompareIDs(LPARAM iCol, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = E_INVALIDARG;

    // First obtain the collate type of the pidls and their respective
    // collate order.

    LONG iColateType1 = _GetFilePIDLType(pidl1);
    LONG iColateType2 = _GetFilePIDLType(pidl2);

    if (iColateType1 == iColateType2) 
    {
        // pidls are of same type.
        if (iColateType1 == _HOOD_COL_FILE)  // two file system pidls
        {
            IShellFolder2* psfFiles;
            if (SUCCEEDED(v_GetFileFolder(&psfFiles)))
            {
                if (0 == (iCol & SHCIDS_COLUMNMASK))
                {
                    // special case this for perf, this is the name compare
                    hr = psfFiles->CompareIDs(iCol, pidl1, pidl2);
                }
                else
                {
                    SHCOLUMNID scid;
                    MapColumnToSCID((UINT)iCol & SHCIDS_COLUMNMASK, &scid);
                    int iRet = CompareBySCID(psfFiles, &scid, pidl1, pidl2);
                    hr = ResultFromShort(iRet);
                }
            }
        }
        else 
        {
            // pidls same and are not of type file,
            // so both must be a type understood
            // by the CNetwork class - pass on to compare.

            hr = CNetFolder::CompareIDs(iCol, pidl1, pidl2);
        }
    }
    else 
    {
        // ensure that entire network ends up at the head of the list

        LPCIDNETRESOURCE pidn1 = NET_IsValidID(pidl1);
        LPCIDNETRESOURCE pidn2 = NET_IsValidID(pidl2);

        if ((pidn1 && (NET_GetDisplayType(pidn1) == RESOURCEDISPLAYTYPE_ROOT)) ||
             (pidn2 && (NET_GetDisplayType(pidn2) == RESOURCEDISPLAYTYPE_ROOT)))
        {
            if (iColateType1 == _HOOD_COL_FILE)
                return ResultFromShort(1);
            else
                return ResultFromShort(-1);
        }

        // pidls are not of same type, so have already been correctly
        // collated (consequently, sorting is first by type and
        // then by subfield).

        hr = ResultFromShort(((iColateType2 - iColateType1) > 0) ? 1 : -1);
    }
    return hr;
}

STDMETHODIMP CNetRootFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    ASSERT(ILIsEqual(_pidl, (LPCITEMIDLIST)&c_idlNet));

    if (IsEqualIID(riid, IID_IDropTarget))
    {
        return CNetRootDropTarget_CreateInstance(hwnd, _pidl, (IDropTarget**) ppv);
    }
    return CNetFolder::CreateViewObject(hwnd, riid, ppv);
}

STDMETHODIMP CNetRootFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG* prgfInOut)
{
    HRESULT hr;

    if (IsSelf(cidl, apidl))
    {
        // The user can rename links in the hood.
        hr = CNetFolder::GetAttributesOf(cidl, apidl, prgfInOut);
        *prgfInOut |= SFGAO_CANRENAME;
    }
    else
    {
        hr = GetAttributesCallback(SAFECAST(this, IShellFolder2*), cidl, apidl, prgfInOut, _AttributesCallbackRoot);
    }
    return hr;
}

STDMETHODIMP CNetRootFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, STRRET* pStrRet)
{
    HRESULT hr;
    if (NET_IsValidID(pidl) || IsSelf(1, &pidl))
    {
        hr = CNetFolder::GetDisplayNameOf(pidl, dwFlags, pStrRet);
    }
    else
    {
        IShellFolder2* psfFiles;
        hr = v_GetFileFolder(&psfFiles);
        if (SUCCEEDED(hr))
        {
            hr = psfFiles->GetDisplayNameOf(pidl, dwFlags, pStrRet);
        }            
    }
    return hr;
}

STDMETHODIMP CNetRootFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName,
                                       DWORD dwRes, LPITEMIDLIST* ppidl)
{
    HRESULT hr;
    if (NET_IsValidID(pidl))
    {
        hr = CNetFolder::SetNameOf(hwnd, pidl, lpszName, dwRes, ppidl);
    }
    else
    {
        IShellFolder2* psfFiles;
        hr = v_GetFileFolder(&psfFiles);
        if (SUCCEEDED(hr))
        {
            hr = psfFiles->SetNameOf(hwnd, pidl, lpszName, dwRes, ppidl);
        }            
    }
    return hr;
}

STDMETHODIMP CNetRootFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST* apidl,
                                           REFIID riid, UINT* prgfInOut, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    LPCIDNETRESOURCE pidn = cidl ? NET_IsValidID(apidl[0]) : NULL;
    BOOL fStriped = FALSE;

    *ppv = NULL;

    if (pidn)
    {
        fStriped = _MakeStripToLikeKinds(&cidl, &apidl, TRUE);

        if (IsEqualIID(riid, IID_IContextMenu))
        {
            HKEY ahkeys[NKID_COUNT];

            hr = _OpenKeys(pidn, ahkeys);
            if (SUCCEEDED(hr))
            {
                IShellFolder* psfOuter;
                hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfOuter));
                if (SUCCEEDED(hr))
                {
                    hr = CDefFolderMenu_Create2(_pidl, hwnd, cidl, apidl, 
                                                  psfOuter, _GetCallbackType(pidn),
                                                  ARRAYSIZE(ahkeys), ahkeys, (IContextMenu**) ppv);
                    psfOuter->Release();
                }
                SHRegCloseKeys(ahkeys, ARRAYSIZE(ahkeys));
            }
        }
        else
        {
            hr = CNetFolder::GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
        }            
    }
    else
    {
        fStriped = _MakeStripToLikeKinds(&cidl, &apidl, FALSE);

        IShellFolder2* psfFiles;
        hr = v_GetFileFolder(&psfFiles);
        if (SUCCEEDED(hr))
        {
            hr = psfFiles->GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
        }            
    }

    if (fStriped)
        LocalFree((HLOCAL)apidl);
        
    return hr;
}

STDMETHODIMP CNetRootFolder::GetClassID(CLSID* pCLSID)
{
    *pCLSID = CLSID_NetworkPlaces;
    return S_OK;
}

STDMETHODIMP CNetRootFolder::Initialize(LPCITEMIDLIST pidl)
{
    ASSERT(ILIsEqual(pidl, (LPCITEMIDLIST)&c_idlNet));
    ASSERT(AssertIsIDListInNameSpace(pidl, &CLSID_NetworkPlaces) && ILIsEmpty(_ILNext(pidl)));
    // Only allow the Net root on the desktop

    // Don't initialize more than once; we are a singleton object.
    // This is theoretically redundant with the InterlockedCompareExchange
    // below, but redundant reinitialization is by far the common case
    // so we'll optimize it.
    if (_pidl)
        return S_OK;

    LPITEMIDLIST pidlNew;
    HRESULT hr = SHILClone(pidl, &pidlNew);
    if (SUCCEEDED(hr))
    {
        if (SHInterlockedCompareExchange((void**)&_pidl, pidlNew, 0))
        {
            // Some other thread raced with us, throw away our copy
            ILFree(pidlNew);
        }
    }
    return hr;
}

LONG CNetFolder::_GetFilePIDLType(LPCITEMIDLIST pidl)
{
    if (NET_IsValidID(pidl)) 
    {
        if (NET_IsRemoteFld((LPIDNETRESOURCE)pidl)) 
        {
            return _HOOD_COL_REMOTE;
        }
        if (NET_GetDisplayType((LPIDNETRESOURCE)pidl) == RESOURCEDISPLAYTYPE_ROOT) 
        {
            return _HOOD_COL_RON;
        }
        return _HOOD_COL_NET;
    }
    return _HOOD_COL_FILE;
}


BOOL CNetFolder::_MakeStripToLikeKinds(UINT *pcidl, LPCITEMIDLIST **papidl, BOOL fNetObjects)
{
    BOOL bRet = FALSE;
    LPITEMIDLIST *apidl = (LPITEMIDLIST*)*papidl;
    int cidl = *pcidl;

    for (int i = 0; i < cidl; i++)
    {
        if ((NET_IsValidID(apidl[i]) != NULL) != fNetObjects)
        {
            LPCITEMIDLIST *apidlHomo = (LPCITEMIDLIST *)LocalAlloc(LPTR, sizeof(*apidlHomo) * cidl);
            if (!apidlHomo)
                return FALSE;

            int cpidlHomo = 0;
            for (i = 0; i < cidl; i++)
            {
                if ((NET_IsValidID(apidl[i]) != NULL) == fNetObjects)
                {
                    apidlHomo[cpidlHomo++] = apidl[i];
                }                    
            }

            // Setup to use the stripped version of the pidl array...
            *pcidl = cpidlHomo;
            *papidl = apidlHomo;
            bRet = TRUE;
        }
    }
    return bRet;
}

HRESULT CNetRootFolder::v_GetFileFolder(IShellFolder2 **psf)
{
    HRESULT hr = SHCacheTrackingFolder((LPCITEMIDLIST)&c_idlNet, CSIDL_NETHOOD, &_psfFiles);
    *psf = _psfFiles;
    return hr;
}


//
// pmedium and pformatetcIn == NULL if we are handling QueryGetData
//
HRESULT CNetData::GetHDrop(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
    HRESULT hr = E_INVALIDARG;        // assume error
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(this, &medium);
    if (pida)
    {
        // Get the first one to see the type.
        LPCIDNETRESOURCE pidn = (LPCIDNETRESOURCE)IDA_GetIDListPtr(pida, 0);

        if (NULL == pidn)
            hr = E_FAIL;
            
        if (pidn && (NET_GetFlags(pidn) & SHID_JUNCTION) && 
            (NET_GetType(pidn) == RESOURCETYPE_DISK))
        {
            // Get HDrop only if we are handling IDataObject::GetData (pmedium != NULL)
            if (pmedium) 
            {
                // We have non-null FORMATETC and STGMEDIUM - get the HDrop
                hr = CFSIDLData::GetHDrop(pformatetcIn, pmedium);
            }
            else
            {
                hr = S_OK;  // We were handling QueryGetData
            }
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return hr;
}

LPTSTR NET_GetProviderFromRes(LPCIDNETRESOURCE pidn, LPTSTR pszBuff, UINT cchBuff);

// By the way...Win95 shipped with the below provider
// names.  Since the name can be changed and be localized,
// we have to try and map these correctly for net pidl
// interop.

//
// get the network resource name from an item. this is not a file system path!
//
// example:
//      server      \\server or strike/sys
//      share       \\server\share or strike/sys
//      printer     \\server\printer
//      provider    "provider name"
//      entire net  "Entire Network"
//
// in:
//   pidn       the item
//   cchBuff    size of buffer in chars.
//
// out:
//   pszBuff    return buffer
//
// returns:
//   address of the input buffer (pszBuff)
//
LPTSTR NET_CopyResName(LPCIDNETRESOURCE pidn, LPTSTR pszBuff, UINT cchBuff)
{
    if (NET_IsUnicode(pidn))
    {
        LPBYTE pb = (LPBYTE)pidn->szNetResName;
        pb += lstrlenA((LPSTR)pb) + 1;      // Skip over ansi net name
        if (NET_FHasProvider(pidn))
            pb += lstrlenA((LPSTR)pb) + 1;  // Skip over ansi provider
        if (NET_FHasComment(pidn))
            pb += lstrlenA((LPSTR)pb) + 1;  // Skip over comment
        ualstrcpyn(pszBuff, (LPNWSTR)pb, cchBuff);
    }
    else
    {
        SHAnsiToTChar(pidn->szNetResName, pszBuff, cchBuff);
    }
    return pszBuff;
}

//
// get the provider name from an item. some items do not have providers stored
// in them. for example the "*" indicates where the provider is stored in the
// two different forms of network pidls.
//      [entire net] [provider *] [server] [share] [... file system]
//      [server *] [share] [... file system]
// in:
//   pidn       item (single item PIDL) to try to get the provider name from
//   cchBuff    size in chars.
// out:
//   pszBuff    output
//
LPTSTR NET_CopyProviderName(LPCIDNETRESOURCE pidn, LPTSTR pszBuff, UINT cchBuff)
{
    *pszBuff = 0;

    if (!NET_FHasProvider(pidn))
        return NULL;

    // try the wNetType at the end of the pidl

    const BYTE *pb = (LPBYTE)pidn + pidn->cb - sizeof(WORD);
    DWORD dwNetType = *((UNALIGNED WORD *)pb) << 16;

    if (dwNetType && (dwNetType <= WNNC_NET_LARGEST) &&
        (WNetGetProviderName(dwNetType, pszBuff, (ULONG*)&cchBuff) == WN_SUCCESS))
    {
        return pszBuff;
    }

    // Try the old way...

    pb = (LPBYTE)pidn->szNetResName + lstrlenA(pidn->szNetResName) + 1;      // Skip over ansi net name

    if (NET_IsUnicode(pidn))
    {
        pb += lstrlenA((LPSTR)pb) + 1;      // Skip over ansi provider
        if (NET_FHasComment(pidn))
            pb += lstrlenA((LPSTR)pb) + 1;  // Skip over comment
        pb += (ualstrlen((LPNWSTR)pb) + 1) * sizeof(WCHAR); // skip over unicode net name
        ualstrcpyn(pszBuff, (LPNWSTR)pb, cchBuff);
    }
    else
    {
        SHAnsiToTChar((LPSTR)pb, pszBuff, cchBuff);
    }

    // Map from Win95 net provider name if possible...
    for (int i = 0; i < ARRAYSIZE(c_rgProviderMap); i++)
    {
        if (lstrcmp(pszBuff, c_rgProviderMap[i].lpName) == 0)
        {
            DWORD dwNetType = c_rgProviderMap[i].wNetType << 16;
            if (dwNetType && (dwNetType <= WNNC_NET_LARGEST))
            {
                *pszBuff = 0;
                WNetGetProviderName(dwNetType, pszBuff, (LPDWORD)&cchBuff);
            }
            break;
        }
    }
    return pszBuff;
}

//
// get the comment if there is one from the net item
//
LPTSTR NET_CopyComment(LPCIDNETRESOURCE pidn, LPTSTR pszBuff, UINT cchBuff)
{
    *pszBuff = 0;

    LPCSTR pszT = pidn->szNetResName + lstrlenA(pidn->szNetResName) + 1;
    if (NET_FHasComment(pidn))
    {
        if (NET_FHasProvider(pidn))
            pszT += lstrlenA(pszT) + 1;
        if (NET_IsUnicode(pidn))
        {
            pszT += lstrlenA(pszT) + 1;      // Skip Ansi comment

            LPNCWSTR pszW = (LPNCWSTR)pszT;  // We're at the unicode portion of the pidl
            pszW += ualstrlen(pszW) + 1;     // Skip Unicode Name
            if (NET_FHasProvider(pidn))
                pszW += ualstrlen(pszW) + 1; // Skip Unicode Provider
            ualstrcpyn(pszBuff, pszW, cchBuff);
        }
        else
        {
            SHAnsiToUnicode(pszT, pszBuff, cchBuff);
        }
    }
    return pszBuff;
}

//  pidlRemainder will be filled in (only in the TRUE return case) with a
//  pointer to the part of the IDL (if any) past the remote regitem.
//  This value may be used, for example, to differentiate between a remote
//  printer folder and a printer under a remote printer folder

BOOL NET_IsRemoteRegItem(LPCITEMIDLIST pidl, REFCLSID rclsid, LPCITEMIDLIST* ppidlRemainder)
{
    BOOL bRet = FALSE;
    // in "My Network Places"
    if (pidl && IsIDListInNameSpace(pidl, &CLSID_NetworkPlaces))
    {
        LPCITEMIDLIST pidlStart = pidl; // save this

        // Now, search for a server item. HACKHACK: this assume everything from
        // the NetHood to the server item is a shell pidl with a bFlags field!!

        for (pidl = _ILNext(pidl); !ILIsEmpty(pidl); pidl = _ILNext(pidl))
        {
            if ((SIL_GetType(pidl) & SHID_TYPEMASK) == SHID_NET_SERVER)
            {
                LPITEMIDLIST pidlToTest;

                // Found a server. Is the thing after it a remote registry item?
                pidl = _ILNext(pidl);

                *ppidlRemainder = _ILNext(pidl);

                pidlToTest = ILCloneUpTo(pidlStart, *ppidlRemainder);
                if (pidlToTest)
                {
                    CLSID clsid;
                    bRet = SUCCEEDED(GetCLSIDFromIDList(pidlToTest, &clsid)) && IsEqualCLSID(rclsid, clsid);
                    ILFree(pidlToTest);
                }
                break;  // done
            }
        }
    }
    return bRet;
}




//
// Get the provider name from an absolute IDLIST.
// Parameters:
//  pidlAbs -- Specifies the Absolute IDList to the file system object
//
LPTSTR NET_GetProviderFromIDList(LPCITEMIDLIST pidlAbs, LPTSTR pszBuff, UINT cchBuff)
{
    return NET_GetProviderFromRes((LPCIDNETRESOURCE)_ILNext(pidlAbs), pszBuff, cchBuff);
}

//
// Get the provider name from a relative IDLIST.
// in:
//  pidn    potentially multi level item to try to get the resource from
//
LPTSTR NET_GetProviderFromRes(LPCIDNETRESOURCE pidn, LPTSTR pszBuffer, UINT cchBuffer)
{
    // If this guy is the REST of network item, we increment to the
    // next IDLIST - If at root return NULL
    if (pidn->cb == 0)
        return NULL;

    //
    // If the IDLIST starts with a ROOT_REGITEM, then skip to the
    // next item in the list...
    if (pidn->bFlags == SHID_ROOT_REGITEM)
    {
        pidn = (LPIDNETRESOURCE)_ILNext((LPITEMIDLIST)pidn);
        if (pidn->cb == 0)
            return NULL;
    }

    // If the IDLIST includes Entire Network, the provider will be
    // part of the next component.
    if (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_ROOT)
    {
        pidn = (LPIDNETRESOURCE)_ILNext((LPITEMIDLIST)pidn);
        if (pidn->cb == 0)
            return NULL;
    }

    // If the next component after the 'hood or Entire Network is
    // a network object, its name is the provider name, else the
    // provider name comes after the remote name.
    if (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_NETWORK)
    {
        // Simply return the name field back for the item.
        return NET_CopyResName(pidn, pszBuffer, cchBuffer);
    }
    else
    {
        // Nope one of the items in the neighborhood view was selected
        // The Provider name is stored after ther resource name
        return NET_CopyProviderName(pidn, pszBuffer, cchBuffer);
    }
}

#define PTROFFSET(pBase, p)     ((int) ((LPBYTE)(p) - (LPBYTE)(pBase)))


//
// fill in pmedium with a NRESARRAY
//
// pmedium == NULL if we are handling QueryGetData
//
STDAPI CNetData_GetNetResource(IDataObject *pdtobj, STGMEDIUM *pmedium)
{
    HRESULT hr = E_OUTOFMEMORY;
    LPITEMIDLIST pidl;
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);

    ASSERT(pida && pida->cidl);

    // First, get the provider name from the first one (assuming they are common).
    pidl = IDA_ILClone(pida, 0);
    if (pidl)
    {
        TCHAR szProvider[MAX_PATH];
        LPCTSTR pszProvider = NET_GetProviderFromIDList(pidl, szProvider, ARRAYSIZE(szProvider));
        if (pmedium)
        {
            TCHAR szName[MAX_PATH];
            UINT cbHeader = sizeof(NRESARRAY) + (sizeof(NETRESOURCE) * (pida->cidl - 1));
            UINT cbRequired, iItem;

            // Calculate required size
            cbRequired = cbHeader;
            if (pszProvider)
                cbRequired += (lstrlen(pszProvider) + 1) * sizeof(TCHAR);

            for (iItem = 0; iItem < pida->cidl; iItem++)
            {
                LPCIDNETRESOURCE pidn = (LPCIDNETRESOURCE)IDA_GetIDListPtr(pida, iItem);
                NET_CopyResName(pidn, szName, ARRAYSIZE(szName));
                cbRequired += (lstrlen(szName) + 1) * sizeof(TCHAR);
            }

            //
            // Indicate that the caller should release hmem.
            //
            pmedium->pUnkForRelease = NULL;
            pmedium->tymed = TYMED_HGLOBAL;
            pmedium->hGlobal = GlobalAlloc(GPTR, cbRequired);
            if (pmedium->hGlobal)
            {
                LPNRESARRAY panr = (LPNRESARRAY)pmedium->hGlobal;
                LPTSTR pszT = (LPTSTR)((LPBYTE)panr + cbHeader);
                LPTSTR pszEnd = (LPTSTR)((LPBYTE)panr + cbRequired);
                UINT offProvider = 0;

                panr->cItems = pida->cidl;

                // Copy the provider name. This is not necessary,
                // if we are dragging providers.
                if (pszProvider)
                {
                    StrCpy(pszT, pszProvider);                         // buffer compute above on cch
                    offProvider = PTROFFSET(panr, pszT);
                    pszT += lstrlen(pszT) + 1;
                }

                //
                // For each item, fill each NETRESOURCE and append resource
                // name at the end. Note that we should put offsets in
                // lpProvider and lpRemoteName.
                //
                for (iItem = 0; iItem < pida->cidl; iItem++)
                {
                    LPNETRESOURCE pnr = &panr->nr[iItem];
                    LPCIDNETRESOURCE pidn = (LPCIDNETRESOURCE)IDA_GetIDListPtr(pida, iItem);

                    ASSERT(pnr->dwScope == 0);
                    ASSERT(pnr->lpLocalName==NULL);
                    ASSERT(pnr->lpComment==NULL);

                    pnr->dwType = NET_GetType(pidn);
                    pnr->dwDisplayType = NET_GetDisplayType(pidn);
                    pnr->dwUsage = NET_GetUsage(pidn);
                    NET_CopyResName(pidn, pszT, (UINT)(pszEnd-pszT));   // buffer compute above on cch

                    if (pnr->dwDisplayType == RESOURCEDISPLAYTYPE_ROOT)
                    {
                        pnr->lpProvider = NULL;
                        pnr->lpRemoteName = NULL;
                    }
                    else if (pnr->dwDisplayType == RESOURCEDISPLAYTYPE_NETWORK)
                    {
                        *((UINT *) &pnr->lpProvider) = PTROFFSET(panr, pszT);
                        ASSERT(pnr->lpRemoteName == NULL);
                    }
                    else
                    {
                        *((UINT *) &pnr->lpProvider) = offProvider;
                        *((UINT *) &pnr->lpRemoteName) = PTROFFSET(panr, pszT);
                    }
                    pszT += lstrlen(pszT) + 1;
                }

                ASSERT(pszEnd == pszT);
                hr = S_OK;
            }
        }
        else
        {
            hr = S_OK;    // handing QueryGetData, yes, we have it
        }
        ILFree(pidl);
    }

    HIDA_ReleaseStgMedium(pida, &medium);

    return hr;
}


// fill in pmedium with an HGLOBAL version of a NRESARRAY

STDAPI CNetData_GetNetResourceForFS(IDataObject *pdtobj, STGMEDIUM *pmedium)
{
    HRESULT hr = E_OUTOFMEMORY;
    LPITEMIDLIST pidlAbs;
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);

    ASSERT(pida && medium.hGlobal);     // we created this...

    //
    // NOTES: Even though we may have multiple FS objects in this HIDA,
    //  we know that they share the root. Therefore, getting the pidl for
    //  the first item is always sufficient.
    //

    pidlAbs = IDA_ILClone(pida, 0);
    if (pidlAbs)
    {
        LPITEMIDLIST pidl;

        ASSERT(AssertIsIDListInNameSpace(pidlAbs, &CLSID_NetworkPlaces));

        //
        // Look for the JUNCTION point (starting from the second ID)
        //
        for (pidl = _ILNext(pidlAbs); !ILIsEmpty(pidl); pidl = _ILNext(pidl))
        {
            LPIDNETRESOURCE pidn = (LPIDNETRESOURCE)pidl;
            if (NET_GetFlags(pidn) & SHID_JUNCTION)
            {
                //
                // We found the JUNCTION point (which is s share).
                // Return the HNRES to it.
                //
                TCHAR szProvider[MAX_PATH];
                TCHAR szRemote[MAX_PATH];
                UINT cbRequired;
                LPCTSTR pszProvider = NET_GetProviderFromIDList(pidlAbs, szProvider, ARRAYSIZE(szProvider));
                LPCTSTR pszRemoteName = NET_CopyResName(pidn, szRemote, ARRAYSIZE(szRemote));
                UINT   cbProvider = lstrlen(pszProvider) * sizeof(TCHAR) + sizeof(TCHAR);

                //
                // This should not be a provider node.
                // This should not be the last ID in pidlAbs.
                //
                ASSERT(pszProvider != pszRemoteName);
                ASSERT(!ILIsEmpty(_ILNext(pidl)));

                cbRequired = sizeof(NRESARRAY) + cbProvider + lstrlen(pszRemoteName) * sizeof(TCHAR) + sizeof(TCHAR);

                pmedium->pUnkForRelease = NULL;
                pmedium->tymed = TYMED_HGLOBAL;
                pmedium->hGlobal = GlobalAlloc(GPTR, cbRequired);
                if (pmedium->hGlobal)
                {
                    LPNRESARRAY panr = (LPNRESARRAY)pmedium->hGlobal;
                    LPNETRESOURCE pnr = &panr->nr[0];
                    LPTSTR pszT = (LPTSTR)(panr + 1);

                    ASSERT(pnr->dwScope == 0);
                    ASSERT(pnr->lpLocalName == NULL);
                    ASSERT(pnr->lpComment == NULL);

                    panr->cItems = 1;

                    pnr->dwType = NET_GetType(pidn);
                    pnr->dwDisplayType = NET_GetDisplayType(pidn);
                    pnr->dwUsage = NET_GetUsage(pidn);

                    *((UINT *) &pnr->lpProvider) = sizeof(NRESARRAY);
                    StrCpy(pszT, pszProvider);                         // buffer compute above on cch
                    ASSERT(PTROFFSET(panr, pszT) == sizeof(NRESARRAY));
                    pszT += cbProvider / sizeof(TCHAR);

                    *((UINT *) &pnr->lpRemoteName) = sizeof(NRESARRAY) + cbProvider;
                    ASSERT(PTROFFSET(panr, pszT) == (int)sizeof(NRESARRAY) + (int)cbProvider);
                    StrCpy(pszT, pszRemoteName);                       // buffer compute above on cch

                    ASSERT(((LPBYTE)panr) + cbRequired == (LPBYTE)pszT + (lstrlen(pszT) + 1) * sizeof(TCHAR));
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                break;
            }
        }
        ASSERT(!ILIsEmpty(pidl));   // We should have found the junction point.
        ILFree(pidlAbs);
    }
    HIDA_ReleaseStgMedium(pida, &medium);
    return hr;
}

STDMETHODIMP CNetData::QueryGetData(FORMATETC *pformatetc)
{
    if (pformatetc->tymed & TYMED_HGLOBAL)
    {
        if (pformatetc->cfFormat == g_cfNetResource)
            return CNetData_GetNetResource(this, NULL);

        if (pformatetc->cfFormat == CF_HDROP)
            return GetHDrop(NULL, NULL);
    }

    return CFSIDLData::QueryGetData(pformatetc);
}

STDMETHODIMP CNetData::GetData(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    if (pformatetc->tymed & TYMED_HGLOBAL)
    {
        if (pformatetc->cfFormat == g_cfNetResource)
            return CNetData_GetNetResource(this, pmedium);

        if (pformatetc->cfFormat == CF_HDROP)
            return GetHDrop(pformatetc, pmedium);
    }

    return CFSIDLData::GetData(pformatetc, pmedium);
}

BOOL GetPathFromDataObject(IDataObject *pdtobj, DWORD dwData, LPTSTR pszFileName)
{
    BOOL bRet = FALSE;
    BOOL fUnicode = FALSE;
    HRESULT hr;

    if (dwData & (DTID_FDESCW | DTID_FDESCA))
    {
        FORMATETC fmteW = {g_cfFileGroupDescriptorW, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM medium = {0};

        hr = pdtobj->GetData(&fmteW, &medium);

        if (SUCCEEDED(hr))
        {
            fUnicode = TRUE;
        }
        else
        {
            FORMATETC fmteA = {g_cfFileGroupDescriptorA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
            hr = pdtobj->GetData(&fmteA, &medium);
        }

        if (SUCCEEDED(hr))
        {
            if (fUnicode)
            {
                FILEGROUPDESCRIPTORW *pfgdW = (FILEGROUPDESCRIPTORW *)GlobalLock(medium.hGlobal);
                if (pfgdW)
                {
                    if (pfgdW->cItems == 1)
                    {
                        SHUnicodeToTChar(pfgdW->fgd[0].cFileName, pszFileName, MAX_PATH);
                    }
                    bRet = TRUE;
                    GlobalUnlock(medium.hGlobal);
                }
            }
            else
            {
                FILEGROUPDESCRIPTORA *pfgdA = (FILEGROUPDESCRIPTORA*)GlobalLock(medium.hGlobal);
                if (pfgdA)
                {
                    if (pfgdA->cItems == 1)
                    {
                        SHAnsiToTChar(pfgdA->fgd[0].cFileName, pszFileName, MAX_PATH);
                    }
                    bRet = TRUE;
                    GlobalUnlock(medium.hGlobal);
                }
            }
            ReleaseStgMedium(&medium);
        }
    }

    return bRet;
}

class CNetRootDropTarget : public CIDLDropTarget
{
    friend HRESULT CNetRootDropTarget_CreateInstance(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt);
public:
    CNetRootDropTarget(HWND hwnd) : CIDLDropTarget(hwnd) { };

    // IDropTarget methods overwirte
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

private:
    ~CNetRootDropTarget();
    IDropTarget *_pdtgHood;              // file system drop target
};

CNetRootDropTarget::~CNetRootDropTarget()
{
    if (_pdtgHood)
        _pdtgHood->Release();
}

STDMETHODIMP CNetRootDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    CIDLDropTarget::DragEnter(pdtobj, grfKeyState, pt, pdwEffect);

    if ((m_dwData & (DTID_NETRES | DTID_HIDA)) == (DTID_NETRES | DTID_HIDA))
    {
        // NETRESOURCE (DTID_NETRES) allow link
        *pdwEffect &= DROPEFFECT_LINK;
    }
    else if (((m_dwData & (DTID_FDESCW | DTID_CONTENTS)) == (DTID_FDESCW | DTID_CONTENTS)) ||
             ((m_dwData & (DTID_FDESCA | DTID_CONTENTS)) == (DTID_FDESCA | DTID_CONTENTS)) )
    {
        // dragging an URL from the web browser gives a FILECONTENTS version
        // of a .URL file. accept that here for Internet Shortcut (.url)
        TCHAR szFileName[MAX_PATH];
        if (GetPathFromDataObject(pdtobj, m_dwData, szFileName) &&
            (0 == lstrcmpi(PathFindExtension(szFileName), TEXT(".url"))))
        {
            *pdwEffect &= DROPEFFECT_LINK;
        }
        else
        {
            *pdwEffect = DROPEFFECT_NONE;
        }
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
    }

    m_dwEffectLastReturned = *pdwEffect;
    return S_OK;
}

STDMETHODIMP CNetRootDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect &= DROPEFFECT_LINK;

    HRESULT hr = CIDLDropTarget::DragDropMenu(DROPEFFECT_LINK, pdtobj,
                            pt, pdwEffect, NULL, NULL, POPUP_NONDEFAULTDD, grfKeyState);
    if (*pdwEffect)
    {
        if (!_pdtgHood)
        {
            LPITEMIDLIST pidl = SHCloneSpecialIDList(NULL, CSIDL_NETHOOD, FALSE);
            if (pidl)
            {
                IShellFolder *psf;
                if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidl, &psf))))
                {
                    psf->CreateViewObject(_GetWindow(), IID_PPV_ARG(IDropTarget, &_pdtgHood));
                    psf->Release();
                }
                ILFree(pidl);
            }
        }
        
        if (_pdtgHood)
        {
            // force link through the dwEffect and keyboard
            *pdwEffect &= DROPEFFECT_LINK;
            grfKeyState = MK_LBUTTON | MK_CONTROL | MK_SHIFT | MK_FAKEDROP;
            hr = SHSimulateDrop(_pdtgHood, pdtobj, grfKeyState, NULL, pdwEffect);
        }
        else 
            *pdwEffect = 0;
    }

    CIDLDropTarget::DragLeave();
    return hr;
}

HRESULT CNetRootDropTarget_CreateInstance(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt)
{
    *ppdropt = NULL;

    CNetRootDropTarget *pnrdt = new CNetRootDropTarget(hwnd);
    if (!pnrdt)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pnrdt->_Init(pidl);
    if (SUCCEEDED(hr))
    {
        hr = pnrdt->QueryInterface(IID_PPV_ARG(IDropTarget, ppdropt));
    }            
    pnrdt->Release();
    return hr;
}

// This part is psuedo bogus.  Basically we have problems at times doing a
// translation from things like \\pyrex\user to the appropriate PIDL,
// especially if you want to avoid the overhead of hitting the network and
// also problems of knowing if the server is in the "HOOD"
//
// We must maintain the mapping table in UNICODE internally, because
// IShellFolder::ParseDisplayName uses UNICODE, and we don't want to have
// to deal with lstrlen(dbcs) != lstrlen(sbcs) problems.
//

typedef struct _NPT_ITEM
{
    struct _NPT_ITEM *pnptNext;     // Pointer to next item;
    LPCITEMIDLIST   pidl;           // The pidl
    USHORT          cchName;        // size of the name in characters.
    WCHAR           szName[1];      // The name to translate from
} NPT_ITEM;

// Each process will maintain their own list.
NPT_ITEM *g_pnptHead = NULL;

//
//  Function to register translations from Path to IDList translations.
//
void NPTRegisterNameToPidlTranslation(LPCTSTR pszPath, LPCITEMIDLIST pidl)
{
    NPT_ITEM *pnpt;
    int cItemsRemoved = 0;
    WCHAR szPath[MAX_PATH];

    // We currently are only interested in UNC Roots
    // If the table becomes large we can reduce this to only servers...

    if (!PathIsUNC(pszPath))
        return;     // Not interested.

    //
    // If this item is not a root we need to count how many items to remove
    //
    SHTCharToUnicode(pszPath, szPath, ARRAYSIZE(szPath));
    while (!PathIsUNCServerShare(szPath))
    {
        cItemsRemoved++;
        if (!PathRemoveFileSpecW(szPath))
            return;     // Did not get back to a valid root
    }

    ENTERCRITICAL;

    // We don't want to add duplicates
    for (pnpt = g_pnptHead; pnpt != NULL ; pnpt = pnpt->pnptNext)
    {
        if (StrCmpIW(szPath, pnpt->szName) == 0)
            break;
    }

    if (pnpt == NULL)
    {
        UINT cch = lstrlenW(szPath);
        pnpt = (NPT_ITEM *)LocalAlloc(LPTR, sizeof(NPT_ITEM) + cch * sizeof(WCHAR));
        if (pnpt)
        {
            pnpt->pidl = ILClone(pidl);
            if (pnpt->pidl)
            {
                while (cItemsRemoved--)
                {
                    ILRemoveLastID((LPITEMIDLIST)pnpt->pidl);
                }
                pnpt->pnptNext = g_pnptHead;
                g_pnptHead = pnpt;
                pnpt->cchName = (USHORT)cch;
                StrCpyNW(pnpt->szName, szPath, cch + 1);
            }
            else
            {
                LocalFree((HLOCAL)pnpt);
            }
        }
    }
    LEAVECRITICAL;
}

// The main function to attemp to map a portion of the name into an idlist
// Right now limit it to UNC roots
//
LPWSTR NPTMapNameToPidl(LPCWSTR pszPath, LPCITEMIDLIST *ppidl)
{
    NPT_ITEM *pnpt;

    *ppidl = NULL;

    ENTERCRITICAL;

    // See if we can find the item in the list.
    for (pnpt = g_pnptHead; pnpt != NULL ; pnpt = pnpt->pnptNext)
    {
        if (IntlStrEqNIW(pszPath, pnpt->szName, pnpt->cchName) &&
            ((pszPath[pnpt->cchName] == TEXT('\\')) || (pszPath[pnpt->cchName] == TEXT('\0'))))
        {             
            break;
        }
    }
    LEAVECRITICAL;

    // See if we found a match
    if (pnpt == NULL)
        return NULL;

    // Found a match
    *ppidl = pnpt->pidl;
    return (LPWSTR)pszPath + pnpt->cchName;     // points to slash
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\netview.h ===
#include "lm.h"

#pragma pack(1)
typedef struct _IDNETRESOURCE   // idn
{
    WORD    cb;
    BYTE    bFlags;         // Display type in low nibble
    BYTE    uType;
    BYTE    uUsage;         // Usage in low nibble, More Flags in high nibble
    CHAR    szNetResName[1];
    // char szProvider[*] - If NET_HASPROVIDER bit is set
    // char szComment[*]  - If NET_HASCOMMENT bit is set.
    // WCHAR szNetResNameWide[*] - If NET_UNICODE bit it set.
    // WCHAR szProviderWide[*]   - If NET_UNICODE and NET_HASPROVIDER
    // WCHAR szCommentWide[*]    - If NET_UNICODE and NET_HASCOMMENT
} IDNETRESOURCE, *LPIDNETRESOURCE;
typedef const IDNETRESOURCE *LPCIDNETRESOURCE;
#pragma pack()

//===========================================================================
// CNetwork: Some private macro - but probably needed in .cpp file.
//===========================================================================
#define NET_DISPLAYNAMEOFFSET           ((UINT)((LPIDNETRESOURCE)0)->szNetResName)
#define NET_GetFlags(pidnRel)           ((pidnRel)->bFlags)
#define NET_GetDisplayType(pidnRel)     ((pidnRel)->bFlags & 0x0f)
#define NET_GetType(pidnRel)            ((pidnRel)->uType)
#define NET_GetUsage(pidnRel)           ((pidnRel)->uUsage & 0x0f)
#define NET_IsReg(pidnRel)              ((pidnRel)->bFlags == SHID_NET_REGITEM)
#define NET_IsJunction(pidnRel)         ((pidnRel)->bFlags & SHID_JUNCTION)
#define NET_IsRootReg(pidnRel)          ((pidnRel)->bFlags == SHID_NET_ROOTREGITEM)
#define NET_IsFake(pidnRel)             ((pidnRel)->szNetResName[0] == '\0')

// Define some Flags that are on high nibble of uUsage byte
#define NET_HASPROVIDER                 0x80    // Has own copy of provider
#define NET_HASCOMMENT                  0x40    // Has comment field in pidl
#define NET_REMOTEFLD                   0x20    // Is remote folder
#define NET_UNICODE                     0x10    // Has unicode names
#define NET_FHasComment(pidnRel)        ((pidnRel)->uUsage & NET_HASCOMMENT)
#define NET_FHasProvider(pidnRel)       ((pidnRel)->uUsage & NET_HASPROVIDER)
#define NET_IsRemoteFld(pidnRel)        ((pidnRel)->uUsage & NET_REMOTEFLD)
#define NET_IsUnicode(pidnRel)          ((pidnRel)->uUsage & NET_UNICODE)

STDAPI_(BOOL) NET_IsRemoteRegItem(LPCITEMIDLIST pidl, REFCLSID rclsid, LPCITEMIDLIST* ppidlRemainder);

// These are exported form netviewx.c they are wrappers around the same WNet
// APIs, but play with the parameters to make it easier to call.  They accept
// full paths rather than just drive letters.

STDAPI_(DWORD) SHWNetDisconnectDialog1 (LPDISCDLGSTRUCT lpConnDlgStruct);
STDAPI_(DWORD) SHWNetGetConnection (LPCTSTR lpLocalName, LPTSTR lpRemoteName, LPDWORD lpnLength);
STDAPI SHGetDomainWorkgroupIDList(LPITEMIDLIST *ppidl);
STDAPI_(void) SHCacheComputerDescription(LPCTSTR pszMachineName, LPCTSTR pszDescription);

typedef struct
{
    LPCTSTR lpName;
    WORD    wNetType;
} NETPROVIDERS;

EXTERN_C const NETPROVIDERS c_rgProviderMap[];
EXTERN_C const int c_cProviders;

STDAPI_(LPTSTR) NET_CopyResName(LPCIDNETRESOURCE pidn, LPTSTR pszBuff, UINT cchBuff);
STDAPI_(LPTSTR) NET_CopyComment(LPCIDNETRESOURCE pidn, LPTSTR pszBuff, UINT cchBuff);
STDAPI_(LPTSTR) NET_CopyProviderName(LPCIDNETRESOURCE pidn, LPTSTR pszBuff, UINT cchBuff);

// netcrawl.cpp
STDAPI_(void) RefreshNetCrawler();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ole2def.c ===
// stubs for OLE routines that we used to delay load or implement ourselves

#include "shellprv.h"
#pragma  hdrstop

STDAPI SHFlushClipboard(void)
{
    return OleFlushClipboard();
}

// we should not use these anymore, just call the OLE32 versions

STDAPI SHRegisterDragDrop(HWND hwnd, IDropTarget *pDropTarget)
{
    return RegisterDragDrop(hwnd, pDropTarget);
}

STDAPI SHRevokeDragDrop(HWND hwnd)
{
    return RevokeDragDrop(hwnd);
}

STDAPI_(void) SHFreeUnusedLibraries()
{
    CoFreeUnusedLibraries();
}

STDAPI SHLoadOLE(LPARAM lParam)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\nothunk.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    nothunk.c

Abstract:

    Code to handle routines which are being thunked down to 16 bits or
    exported from the Windows 95 kernel.  On NT these do nothing.

--*/


#include "shellprv.h"
#pragma  hdrstop

LRESULT WINAPI CallCPLEntry16(
    HINSTANCE hinst,
    FARPROC16 lpfnEntry,
    HWND hwndCPL,
    UINT msg,
    LPARAM lParam1,
    LPARAM lParam2
) {
    return 0L;
}

void RunDll_CallEntry16(
    RUNDLLPROC pfn,
    HWND hwndStub,
    HINSTANCE hinst,
    LPSTR pszParam,
    int nCmdShow)
{
    return;
}

void SHGlobalDefect(DWORD lpVoid)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ole2dup.h ===
#include <shellp.h>

// undoced OLE32 export (so we have to have this thunk)
STDAPI SHStgOpenStorageOnHandle(HANDLE h, DWORD grfMode, void *res1, void *res2, REFIID riid, void **ppv);

STDAPI SHCoCreateInstance(LPCTSTR pszCLSID, const CLSID *pclsid, IUnknown* pUnkOuter, REFIID riid, void **ppv);
STDAPI SHExtCoCreateInstance(LPCTSTR pszCLSID, const CLSID *pclsid, IUnknown* pUnkOuter, REFIID riid, void **ppv);
STDAPI SHExtCoCreateInstance2(LPCTSTR pszCLSID, const CLSID *pclsid, IUnknown *punkOuter, DWORD dwClsCtx, REFIID riid, void **ppv);
STDAPI SHCLSIDFromString(LPCTSTR lpsz, LPCLSID pclsid);
STDAPI_(HINSTANCE) SHPinDllOfCLSIDStr(LPCTSTR pszCLSID);

#define CH_GUIDFIRST TEXT('{') // '}'
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\nswalk.cpp ===
#include "shellprv.h"
#include "dpa.h"
#include "datautil.h"

typedef enum
{
    NSWALK_DONTWALK,
    NSWALK_FOLDER,
    NSWALK_ITEM,
    NSWALK_LINK
} NSWALK_ELEMENT_TYPE;

class CNamespaceWalk : public INamespaceWalk
{
public:
    CNamespaceWalk();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // INamespaceWalk
    STDMETHODIMP Walk(IUnknown *punkToWalk, DWORD dwFlags, int cDepth, INamespaceWalkCB *pnswcb);
    STDMETHODIMP GetIDArrayResult(UINT *pcItems, LPITEMIDLIST **pppidl);

private:
    ~CNamespaceWalk();

    static int CALLBACK _FreeItems(LPITEMIDLIST pidl, IShellFolder *psf);
    static int CALLBACK _CompareItems(LPITEMIDLIST p1, LPITEMIDLIST p2, IShellFolder *psf);
    HRESULT _EnsureDPA();
    HRESULT _AddItem(IShellFolder *psf, LPCITEMIDLIST pidl);
    HRESULT _AppendFull(LPCITEMIDLIST pidlFull);
    HRESULT _EnumFolder(IShellFolder *psf, LPCITEMIDLIST pidlFirst, CDPA<UNALIGNED ITEMIDLIST> *pdpaItems);
    HRESULT _GetShortcutTarget(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget);
    BOOL _IsFolderTarget(IShellFolder *psf, LPCITEMIDLIST pidl);
    HRESULT _WalkView(IFolderView *pfv);
    HRESULT _WalkFolder(IShellFolder *psf, LPCITEMIDLIST pidlFirst, int cDepth);
    HRESULT _WalkDataObject(IDataObject *pdtobj);
    HRESULT _WalkParentAndItem(IParentAndItem *ppai);
    HRESULT _WalkIDList(IShellFolder *psfRoot, LPCITEMIDLIST pidl, int cDepth, int cFolderDepthDelta);
    HRESULT _WalkFolderItem(IShellFolder *psf, LPCITEMIDLIST pidl, int cDepth);
    HRESULT _WalkShortcut(IShellFolder *psf, LPCITEMIDLIST pidl, int cDepth, int cFolderDepthDelta);

    NSWALK_ELEMENT_TYPE _GetType(IShellFolder *psf, LPCITEMIDLIST pidl);
    BOOL _OneImpliesAll(IShellFolder *psf, LPCITEMIDLIST pidl);

    HRESULT _ProgressDialogQueryCancel();
    void _ProgressDialogBegin();
    void _ProgressDialogUpdate(LPCWSTR pszText);
    void _ProgressDialogEnd();

    LONG _cRef;
    DWORD _dwFlags;
    int _cDepthMax;
    INamespaceWalkCB *_pnswcb;
    IActionProgressDialog *_papd;
    IActionProgress *_pap;
#ifdef DEBUG
    TCHAR _szLastFolder[MAX_PATH];   // to track what we failed on
#endif
    CDPA<UNALIGNED ITEMIDLIST> _dpaItems;
};


STDAPI CNamespaceWalk_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    CNamespaceWalk *pnsw = new CNamespaceWalk();
    if (!pnsw)
        return E_OUTOFMEMORY;

    HRESULT hr = pnsw->QueryInterface(riid, ppv);
    pnsw->Release();
    return hr;
}

CNamespaceWalk::CNamespaceWalk() : _cRef(1)
{
    _papd = NULL;
    _pap = NULL;
}

CNamespaceWalk::~CNamespaceWalk()
{
    ASSERT(!_papd);
    ASSERT(!_pap);

    if ((HDPA)_dpaItems)
        _dpaItems.DestroyCallbackEx(_FreeItems, (IShellFolder *)NULL);
}

STDMETHODIMP_(ULONG) CNamespaceWalk::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CNamespaceWalk::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CNamespaceWalk::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CNamespaceWalk, INamespaceWalk),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

int CALLBACK CNamespaceWalk::_FreeItems(LPITEMIDLIST pidl, IShellFolder *psf)
{
    ILFree(pidl);
    return 1;
}

HRESULT CNamespaceWalk::_EnsureDPA()
{
    return (HDPA)_dpaItems ? S_OK : (_dpaItems.Create(10) ? S_OK : E_OUTOFMEMORY);
}

// consumes pidl in all cases (success and failure)

HRESULT CNamespaceWalk::_AppendFull(LPCITEMIDLIST pidlFull)
{
    HRESULT hr = _ProgressDialogQueryCancel(); // ERROR_CANCELLED -> cancelled

    if (SUCCEEDED(hr))
    {
        if (NSWF_DONT_ACCUMULATE_RESULT & _dwFlags)
        {
            hr = S_OK;
        }
        else
        {
            hr = _EnsureDPA();
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlClone;
                hr = SHILClone(pidlFull, &pidlClone);
                if (SUCCEEDED(hr) && (-1 == _dpaItems.AppendPtr(pidlClone)))
                {
                    hr = E_OUTOFMEMORY;
                    ILFree(pidlClone);
                }
            }
        }
    }

    return hr;
}

HRESULT CNamespaceWalk::_AddItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidlFull = NULL;
    
    if (!(NSWF_DONT_ACCUMULATE_RESULT & _dwFlags))
    {
        hr = SUCCEEDED(SHFullIDListFromFolderAndItem(psf, pidl, &pidlFull)) ? S_OK : S_FALSE;//couldn't get the pidl?  Just skip the item
    }

    if (S_OK == hr)
    {
        hr = _pnswcb ? _pnswcb->FoundItem(psf, pidl) : S_OK;
        if (S_OK == hr)
        {
            hr = _AppendFull(pidlFull);
        }
        ILFree(pidlFull);
    }
    return SUCCEEDED(hr) ? S_OK : hr;   // filter out S_FALSE success cases
}

int CALLBACK CNamespaceWalk::_CompareItems(LPITEMIDLIST p1, LPITEMIDLIST p2, IShellFolder *psf)
{
    HRESULT hr = psf->CompareIDs(0, p1, p2);
    return (short)HRESULT_CODE(hr);
}

HRESULT CNamespaceWalk::_EnumFolder(IShellFolder *psf, LPCITEMIDLIST pidlFirst, CDPA<UNALIGNED ITEMIDLIST> *pdpaItems)
{
    CDPA<UNALIGNED ITEMIDLIST> dpaItems;
    HRESULT hr = dpaItems.Create(16) ? S_OK : E_OUTOFMEMORY;
    if (SUCCEEDED(hr))
    {
        IEnumIDList *penum;
        if (S_OK == psf->EnumObjects(NULL, SHCONTF_NONFOLDERS | SHCONTF_FOLDERS, &penum))
        {
            LPITEMIDLIST pidl;
            ULONG c;
            while (SUCCEEDED(hr) && (S_OK == penum->Next(1, &pidl, &c)))
            {
                if (-1 == dpaItems.AppendPtr(pidl))
                {
                    ILFree(pidl);
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    hr = _ProgressDialogQueryCancel();
                }
            }
            penum->Release();
        }

        if (SUCCEEDED(hr))
        {
            dpaItems.SortEx(_CompareItems, psf);

            if (pidlFirst && !(NSWF_FLAG_VIEWORDER & _dwFlags))
            {
                // rotate the items array so pidlFirst is first in the list
                // cast for bogus SearchEx decl
                int iMid = dpaItems.SearchEx((LPITEMIDLIST)pidlFirst, 0, _CompareItems, psf, DPAS_SORTED);
                if (-1 != iMid)
                {
                    int cItems = dpaItems.GetPtrCount();
                    CDPA<UNALIGNED ITEMIDLIST> dpaTemp;
                    if (dpaTemp.Create(cItems))
                    {
                        for (int i = 0; i < cItems; i++)
                        {
                            dpaTemp.SetPtr(i, dpaItems.GetPtr(iMid++));
                            if (iMid >= cItems)
                                iMid = 0;
                        }

                        for (int i = 0; i < cItems; i++)
                        {
                            dpaItems.SetPtr(i, dpaTemp.GetPtr(i));
                        }
                        dpaTemp.Destroy();    // don't free the pidls, just the array
                    }
                }
                else
                {
                    // pidlFirst not found in the enum, it might be hidden or filters
                    // out some way, but make sure this always ends up in the dpa in this case
                    LPITEMIDLIST pidlClone = ILClone(pidlFirst);
                    if (pidlClone)
                    {
                        dpaItems.InsertPtr(0, pidlClone);
                    }
                }
            }
        }
    }

    if (FAILED(hr))
    {
        dpaItems.DestroyCallbackEx(_FreeItems, psf);
        dpaItems = NULL;
    }

    *pdpaItems = dpaItems;
    return hr;
}

NSWALK_ELEMENT_TYPE CNamespaceWalk::_GetType(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    NSWALK_ELEMENT_TYPE nwet = NSWALK_DONTWALK;

    DWORD dwAttribs = SHGetAttributes(psf, pidl, SFGAO_FOLDER | SFGAO_STREAM | SFGAO_FILESYSTEM | SFGAO_LINK);
    if ((dwAttribs & SFGAO_FOLDER) && (!(dwAttribs & SFGAO_STREAM) || (NSWF_TRAVERSE_STREAM_JUNCTIONS & _dwFlags)))
    {
        nwet = NSWALK_FOLDER;
    }
    else if ((dwAttribs & SFGAO_LINK) && !(NSWF_DONT_TRAVERSE_LINKS & _dwFlags))
    {
        nwet = NSWALK_LINK;
    }
    else if ((dwAttribs & SFGAO_FILESYSTEM) || !(NSWF_FILESYSTEM_ONLY & _dwFlags))
    {
        nwet = NSWALK_ITEM;
    }
    return nwet;
}

HRESULT CNamespaceWalk::_WalkIDList(IShellFolder *psfRoot, LPCITEMIDLIST pidl, int cDepth, int cFolderDepthDelta)
{
    IShellFolder *psf;
    LPCITEMIDLIST pidlLast;
    HRESULT hr = SHBindToFolderIDListParent(psfRoot, pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
    if (SUCCEEDED(hr))
    {
        switch (_GetType(psf, pidlLast))
        {
        case NSWALK_FOLDER:
            hr = _WalkFolderItem(psf, pidlLast, cDepth + cFolderDepthDelta);
            break;

        case NSWALK_LINK:
            hr = _WalkShortcut(psf, pidlLast, cDepth, cFolderDepthDelta);
            break;

        case NSWALK_ITEM:
            hr = _AddItem(psf, pidlLast);
            break;
        }
        psf->Release();
    }
    return hr;
}

HRESULT CNamespaceWalk::_WalkShortcut(IShellFolder *psf, LPCITEMIDLIST pidl, int cDepth, int cFolderDepthDelta)
{
    HRESULT hr = S_OK;
    
    // If an error occured trying to resolve a shortcut then we simply skip
    // this shortcut and continue

    LPITEMIDLIST pidlTarget;
    if (SUCCEEDED(_GetShortcutTarget(psf, pidl, &pidlTarget)))
    {
        hr = _WalkIDList(NULL, pidlTarget, cDepth, cFolderDepthDelta);
        ILFree(pidlTarget);
    }

    return hr;
}

HRESULT CNamespaceWalk::_GetShortcutTarget(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget)
{
    *ppidlTarget = NULL;

    IShellLink *psl;
    if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST *)&pidl, IID_PPV_ARG_NULL(IShellLink, &psl))))
    {
        if (S_OK == psl->Resolve(NULL, SLR_UPDATE | SLR_NO_UI))
        {
            psl->GetIDList(ppidlTarget);
        }
        psl->Release();
    }

    return *ppidlTarget ? S_OK : E_FAIL;
}

HRESULT CNamespaceWalk::_WalkFolder(IShellFolder *psf, LPCITEMIDLIST pidlFirst, int cDepth)
{
    if (cDepth > _cDepthMax)
        return S_OK;     // done

    CDPA<UNALIGNED ITEMIDLIST> dpaItems;
    HRESULT hr = _EnumFolder(psf, pidlFirst, &dpaItems);
    if (SUCCEEDED(hr))
    {
        UINT cFolders = 0;
        // breadth first traversal, so do the items (non folders) first
        // (this includes shortcuts and those can point to folders)

        for (int i = 0; (S_OK == hr) && (i < dpaItems.GetPtrCount()); i++)
        {
            switch (_GetType(psf, dpaItems.GetPtr(i)))
            {
            case NSWALK_FOLDER:
                cFolders++;
                break;

            case NSWALK_LINK:
                hr = _WalkShortcut(psf, dpaItems.GetPtr(i), cDepth, 1);
                break;

            case NSWALK_ITEM:
                hr = _AddItem(psf, dpaItems.GetPtr(i));
                break;
            }
        }

        // no go deep into the folders

        if (cFolders)
        {
            for (int i = 0; (S_OK == hr) && (i < dpaItems.GetPtrCount()); i++)
            {
                if (NSWALK_FOLDER == _GetType(psf, dpaItems.GetPtr(i)))
                {
                    hr = _WalkFolderItem(psf, dpaItems.GetPtr(i), cDepth + 1);
                }
            }
        }
        dpaItems.DestroyCallbackEx(_FreeItems, psf);
    }
    return hr;
}

HRESULT CNamespaceWalk::_WalkFolderItem(IShellFolder *psf, LPCITEMIDLIST pidl, int cDepth)
{
    IShellFolder *psfNew;
    HRESULT hr = psf->BindToObject(pidl, NULL, IID_PPV_ARG(IShellFolder, &psfNew));
    if (SUCCEEDED(hr))
    {
#ifdef DEBUG
        DisplayNameOf(psf, pidl, SHGDN_FORPARSING, _szLastFolder, ARRAYSIZE(_szLastFolder));
#endif
        hr = _pnswcb ? _pnswcb->EnterFolder(psf, pidl) : S_OK;
        if (S_OK == hr)
        {
            // Update progress dialog;  note we only update the progress dialog
            // with the folder names we're currently traversing.  Updating on a
            // per filename basis just caused far too much flicker, looked bad.
            if (NSWF_SHOW_PROGRESS & _dwFlags)
            {
                WCHAR sz[MAX_PATH];
                if (SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_NORMAL, sz, ARRAYSIZE(sz))))
                    _ProgressDialogUpdate(sz);

                hr = _ProgressDialogQueryCancel(); // ERROR_CANCELLED -> cancelled
            }

            if (SUCCEEDED(hr))
            {
                hr = _WalkFolder(psfNew, NULL, cDepth);
                if (_pnswcb)
                    _pnswcb->LeaveFolder(psf, pidl);             // ignore result
            }
        }
        hr = SUCCEEDED(hr) ? S_OK : hr; // filter out S_FALSE success cases
        psfNew->Release();
    }
    return hr;
}

BOOL CNamespaceWalk::_IsFolderTarget(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    BOOL bIsFolder = FALSE;

    LPITEMIDLIST pidlTarget;
    if (SUCCEEDED(_GetShortcutTarget(psf, pidl, &pidlTarget)))
    {
        bIsFolder = SHGetAttributes(NULL, pidlTarget, SFGAO_FOLDER);
        ILFree(pidlTarget);
    }
    return bIsFolder;
}

// NSWF_ONE_IMPLIES_ALL applies only when the "one" is not a folder
// and if it is a shortcut if the target of the shortcut is a file

BOOL CNamespaceWalk::_OneImpliesAll(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    BOOL bOneImpliesAll = FALSE;

    if (NSWF_ONE_IMPLIES_ALL & _dwFlags)
    {
        switch (_GetType(psf, pidl))
        {
        case NSWALK_LINK:
            if (!_IsFolderTarget(psf, pidl))
            {
                bOneImpliesAll = TRUE;  // shortcut to non folder, one-implies-all applies
            }
            break;

        case NSWALK_ITEM:
            bOneImpliesAll = TRUE;      // non folder
            break;
        }
    }
    return bOneImpliesAll;
}

// walk an IShellFolderView implementation. this is usually defview (only such impl now)
// the depth beings at level 0 here

HRESULT CNamespaceWalk::_WalkView(IFolderView *pfv)
{
    IShellFolder2 *psf;
    HRESULT hr = pfv->GetFolder(IID_PPV_ARG(IShellFolder2, &psf));
    if (SUCCEEDED(hr))
    {
        int uSelectedCount;
        hr = pfv->ItemCount(SVGIO_SELECTION, &uSelectedCount);
        if (SUCCEEDED(hr))
        {
            // folders explictly selected in the view are level 0
            // folders implictly selected are level 1
            UINT cFolderStartDepth = 0; // assume all folders explictly selected

            IEnumIDList *penum;
            // prop the NSWF_ flags to the IFolderView SVGIO_ flags
            UINT uFlags = (NSWF_FLAG_VIEWORDER & _dwFlags) ? SVGIO_FLAG_VIEWORDER : 0;

            if (uSelectedCount > 1)
            {
                hr = pfv->Items(SVGIO_SELECTION | uFlags, IID_PPV_ARG(IEnumIDList, &penum));
            }
            else if (uSelectedCount == 1)
            {
                hr = pfv->Items(SVGIO_SELECTION, IID_PPV_ARG(IEnumIDList, &penum));
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidl;
                    ULONG c;
                    if (S_OK == penum->Next(1, &pidl, &c))
                    {
                        if (_OneImpliesAll(psf, pidl))
                        {
                            // this implies pidl is not a folder so folders are implictly selected
                            // consider them depth 1
                            cFolderStartDepth = 1;  

                            // one implies all -> release the "one" and grab "all"
                            penum->Release();   
                            hr = pfv->Items(SVGIO_ALLVIEW, IID_PPV_ARG(IEnumIDList, &penum));
                        }
                        else
                        {
                            // folder selected, keep this enumerator for below loop
                            penum->Reset();
                        }
                        ILFree(pidl);
                    }
                }
            }
            else if (uSelectedCount == 0)
            {
                // folders implictly selected, consider them depth 1
                cFolderStartDepth = 1;  

                // get "all" or the selection. in the selection case we know that will be empty
                // given uSelectedCount == 0
                uFlags |= ((NSWF_NONE_IMPLIES_ALL & _dwFlags) ? SVGIO_ALLVIEW : SVGIO_SELECTION);
                hr = pfv->Items(uFlags, IID_PPV_ARG(IEnumIDList, &penum));
            }

            if (SUCCEEDED(hr))
            {
                UINT cFolders = 0;
                LPITEMIDLIST pidl;
                ULONG c;

                while ((S_OK == hr) && (S_OK == penum->Next(1, &pidl, &c)))
                {
                    switch (_GetType(psf, pidl))
                    {
                    case NSWALK_FOLDER:
                        cFolders++;
                        break;

                    case NSWALK_LINK:
                        hr = _WalkShortcut(psf, pidl, 0, cFolderStartDepth);
                        break;

                    case NSWALK_ITEM:
                        hr = _AddItem(psf, pidl);
                        break;
                    }
                    ILFree(pidl);
                }

                if (cFolders)
                {
                    penum->Reset();
                    ULONG c;
                    while ((S_OK == hr) && (S_OK == penum->Next(1, &pidl, &c)))
                    {
                        if (NSWALK_FOLDER == _GetType(psf, pidl))
                        {
                            hr = _WalkFolderItem(psf, pidl, cFolderStartDepth); 
                        }
                        ILFree(pidl);
                    }
                }
                penum->Release();
            }
        }
        psf->Release();
    }
    return hr;
}

HRESULT _GetHIDA(IDataObject *pdtobj, BOOL fIgnoreAutoPlay, STGMEDIUM *pmed, LPIDA *ppida)
{
    HRESULT hr = E_FAIL;
    if (!fIgnoreAutoPlay)
    {
        IDLData_InitializeClipboardFormats(); // init our registerd formats
        *ppida = DataObj_GetHIDAEx(pdtobj, g_cfAutoPlayHIDA, pmed);
        hr = *ppida ? S_FALSE : E_FAIL;
    }
    
    if (FAILED(hr))
    {   
        *ppida = DataObj_GetHIDA(pdtobj, pmed);
        hr = *ppida ? S_OK : E_FAIL;
    }
    return hr;
}

HRESULT CNamespaceWalk::_WalkDataObject(IDataObject *pdtobj)
{
    STGMEDIUM medium = {0};
    LPIDA pida;
    HRESULT hr = _GetHIDA(pdtobj, NSWF_IGNORE_AUTOPLAY_HIDA & _dwFlags, &medium, &pida);
    if (SUCCEEDED(hr))
    {
        //  if we picked up the autoplay hida, then we dont want 
        //  to do a full traversal
        if (hr == S_FALSE)
            _cDepthMax = 0;
        
        IShellFolder *psfRoot;
        hr = SHBindToObjectEx(NULL, HIDA_GetPIDLFolder(pida), NULL, IID_PPV_ARG(IShellFolder, &psfRoot));
        if (SUCCEEDED(hr))
        {
            BOOL cFolders = 0;

            // pass 1, non folders and shortcuts
            for (UINT i = 0; (S_OK == hr) && (i < pida->cidl); i++)
            {
                IShellFolder *psf;
                LPCITEMIDLIST pidlLast;
                hr = SHBindToFolderIDListParent(psfRoot, IDA_GetIDListPtr(pida, i), IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
                if (SUCCEEDED(hr))
                {
                    if ((pida->cidl == 1) && _OneImpliesAll(psf, pidlLast))
                    {
                        // when doing one implies all ignore the view order
                        // flag as that should only apply to explictly selected items
                        _dwFlags &= ~NSWF_FLAG_VIEWORDER;

                        hr = _WalkFolder(psf, pidlLast, 0);
                    }
                    else
                    {
                        switch (_GetType(psf, pidlLast))
                        {
                        case NSWALK_FOLDER:
                            cFolders++;
                            break;

                        case NSWALK_LINK:
                            hr = _WalkShortcut(psf, pidlLast, 0, 0);
                            break;

                        case NSWALK_ITEM:
                            hr = _AddItem(psf, pidlLast);
                            break;
                        }
                    }
                    psf->Release();
                }
            }

            if (cFolders)
            {
                // pass 2, recurse into folders
                for (UINT i = 0; (S_OK == hr) && (i < pida->cidl); i++)
                {
                    IShellFolder *psf;
                    LPCITEMIDLIST pidlLast;
                    hr = SHBindToFolderIDListParent(psfRoot, IDA_GetIDListPtr(pida, i), IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
                    if (SUCCEEDED(hr))
                    {
                        if (NSWALK_FOLDER == _GetType(psf, pidlLast))
                        {
                            if (ILIsEmpty(pidlLast))
                            {
                                // in case of desktop folder we just walk the folder
                                // because empty pidl is not its child, and there can
                                // only be one desktop in the data object so always level 0
                                hr = _WalkFolder(psf, NULL, 0);
                            }
                            else
                            {
                                // all folders that are explictly selected are level 0
                                // in the walk. if the folder is in the data object then it is selected
                                hr = _WalkFolderItem(psf, pidlLast, 0);
                            }
                        }
                        psf->Release();
                    }
                }
            }

            psfRoot->Release();
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    else
    {
        // we have to use CF_HDROP instead of HIDA because this
        // data object comes from AutoPlay and that only supports CF_HDROP
        FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        hr = pdtobj->GetData(&fmte, &medium);
        if (SUCCEEDED(hr))
        {
            TCHAR szPath[MAX_PATH];
            for (int i = 0; SUCCEEDED(hr) && DragQueryFile((HDROP)medium.hGlobal, i, szPath, ARRAYSIZE(szPath)); i++)
            {
                LPITEMIDLIST pidl;
                hr = SHParseDisplayName(szPath, NULL, &pidl, 0, NULL);
                if (SUCCEEDED(hr))
                {
                    // note, no filter being applied here!
                    hr = _AppendFull(pidl);
                    ILFree(pidl);
                }
            }
            ReleaseStgMedium(&medium);
        }
    }
    return hr;
}

HRESULT CNamespaceWalk::_WalkParentAndItem(IParentAndItem *ppai)
{
    LPITEMIDLIST pidlChild;
    IShellFolder *psf;
    HRESULT hr = ppai->GetParentAndItem(NULL, &psf, &pidlChild);
    if (SUCCEEDED(hr))
    {
        if (_OneImpliesAll(psf, pidlChild))
        {
            // a non folder item, this is level 0 of walk
            hr = _WalkFolder(psf, pidlChild, 0);
        }
        else
        {
            // folder or non folder, this is level 0 of walk
            // and level 0 if the item is a folder
            hr = _WalkIDList(psf, pidlChild, 0, 0);
        }

        psf->Release();
        ILFree(pidlChild);
    }
    return hr;
}

// punkToWalk can be a...
//      site that gives access to IFolderView (defview)
//      IShellFolder
//      IDataObject
//      IParentAndItem (CLSID_ShellItem usually)

STDMETHODIMP CNamespaceWalk::Walk(IUnknown *punkToWalk, DWORD dwFlags, int cDepth, INamespaceWalkCB *pnswcb)
{
    _dwFlags = dwFlags;
    _cDepthMax = cDepth;

    if (pnswcb)
        pnswcb->QueryInterface(IID_PPV_ARG(INamespaceWalkCB, &_pnswcb));

    _ProgressDialogBegin();

    IFolderView *pfv;
    HRESULT hr = IUnknown_QueryService(punkToWalk, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv));
    if (SUCCEEDED(hr))
    {
        hr = _WalkView(pfv);
        pfv->Release();
    }
    else
    {
        IShellFolder *psf;
        hr = punkToWalk->QueryInterface(IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = _WalkFolder(psf, NULL, 0);
            psf->Release();
        }
        else
        {
            IDataObject *pdtobj;
            hr = punkToWalk->QueryInterface(IID_PPV_ARG(IDataObject, &pdtobj));
            if (SUCCEEDED(hr))
            {
                hr = _WalkDataObject(pdtobj);
                pdtobj->Release();
            }
            else
            {
                // IShellItem case, get to the things to walk via IParentAndItem
                IParentAndItem *ppai;
                hr = punkToWalk->QueryInterface(IID_PPV_ARG(IParentAndItem, &ppai));
                if (SUCCEEDED(hr))
                {
                    hr = _WalkParentAndItem(ppai);
                    ppai->Release();
                }
            }
        }
    }

    _ProgressDialogEnd();

    if (_pnswcb)
        _pnswcb->Release();

    return hr;
}

// caller should use FreeIDListArray() (inline helper in the .h file) to free this array

STDMETHODIMP CNamespaceWalk::GetIDArrayResult(UINT *pcItems, LPITEMIDLIST **pppidl)
{
    HRESULT hr;
    *pppidl = NULL;
    *pcItems = (HDPA)_dpaItems ? _dpaItems.GetPtrCount() : 0;
    if (*pcItems)
    {
        ULONG cb = *pcItems * sizeof(*pppidl);
        *pppidl = (LPITEMIDLIST *)CoTaskMemAlloc(cb);
        if (*pppidl)
        {
            memcpy(*pppidl, _dpaItems.GetPtrPtr(), cb);  // transfer ownership of pidls here
            _dpaItems.Destroy();    // don't free the pidls, just the array
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            *pcItems = 0;
        }
    }
    else
    {
        hr = S_FALSE;
    }
    return hr;
}

void CNamespaceWalk::_ProgressDialogBegin()
{
    ASSERT(!_papd);                         // Why are we initializing more than once???
    ASSERT(!_pap);                          // Why are we initializing more than once???
    if (_dwFlags & NSWF_SHOW_PROGRESS)
    {
        if (!_papd)
        {
            HRESULT hr = CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActionProgressDialog, &_papd));
            if (SUCCEEDED(hr))
            {
                LPWSTR pszTitle = NULL, pszCancel = NULL;

                // Retrieve dialog text from callback.
                hr = _pnswcb ? _pnswcb->InitializeProgressDialog(&pszTitle, &pszCancel) : S_OK;
                if (SUCCEEDED(hr))
                {
                    hr = _papd->Initialize(SPINITF_MODAL, pszTitle, pszCancel);
                    if (SUCCEEDED(hr))
                    {
                        hr = _papd->QueryInterface(IID_PPV_ARG(IActionProgress, &_pap));
                        if (SUCCEEDED(hr))
                        {
                            hr = _pap->Begin(SPACTION_SEARCHING_FILES, SPBEGINF_MARQUEEPROGRESS);
                            if (FAILED(hr))
                            {
                                ATOMICRELEASE(_pap);    // Cleanup if necessary.
                            }
                        }
                    }
                }
                CoTaskMemFree(pszTitle);
                CoTaskMemFree(pszCancel);

                // Cleanup if necessary.
                if (FAILED(hr))
                {
                    ATOMICRELEASE(_papd);
                }
            }
        }
    }
}

void CNamespaceWalk::_ProgressDialogUpdate(LPCWSTR pszText)
{
    if (_pap)
        _pap->UpdateText(SPTEXT_ACTIONDETAIL, pszText, TRUE);
}

// Note:
//  Returns S_OK if we should continue our walk.
//  Returns ERROR_CANCELLED if we should abort our walk due to user "Cancel".
//
HRESULT CNamespaceWalk::_ProgressDialogQueryCancel()
{
    HRESULT hr = S_OK;  // assume we keep going

    // Check progress dialog to see if user cancelled walk.
    if (_pap)
    {
        BOOL bCancelled;
        hr = _pap->QueryCancel(&bCancelled);
        if (SUCCEEDED(hr) && bCancelled)
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }
    return hr;
}

void CNamespaceWalk::_ProgressDialogEnd()
{
    if (_pap)
    {
        _pap->End();
        ATOMICRELEASE(_pap);
    }

    if (_papd)
    {
        _papd->Stop();
        ATOMICRELEASE(_papd);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ole2dup2.c ===
#include "shellprv.h"
#pragma  hdrstop

STDAPI_(BOOL) StrRetToStrN(LPTSTR pszOut, UINT cchOut, STRRET *pStrRet, LPCITEMIDLIST pidl)
{
    return SUCCEEDED(StrRetToBuf(pStrRet, pidl, pszOut, cchOut));
}

STDAPI_(int) OleStrToStrN(LPTSTR pszOut, int cchOut, LPCWSTR pwsz, int cchWideChar)
{
    int cchOutput;

    if (cchOut > cchWideChar && -1 != cchWideChar)
        cchOut = cchWideChar;

    cchOutput = cchOut;

    while (cchOut)
    {
        if ((*pszOut++ = *pwsz++) == 0)
            return cchOutput - cchOut + 1;
        cchOut--;
    }

    if (-1 == cchWideChar)
        pszOut--;              // Make room for the null 

    *pszOut = 0;
    return cchOutput;
}


STDAPI_(int) StrToOleStrN(LPWSTR pwszOut, int cchOut, LPCTSTR psz, int cchIn)
{
    int cchOutput;

    if (cchOut > cchIn)
        cchOut = cchIn;

    cchOutput = cchOut;

    while (--cchOut)
    {
        if ((*pwszOut++ = *psz++) == 0)
            return cchOutput - cchOut + 1;
    }

    *pwszOut = 0;
    return cchOutput;
}

// bogus export, too scared to remove it
STDAPI_(int) StrToOleStr(LPWSTR pwszOut, LPCTSTR psz)
{
    return SHTCharToUnicode(psz, pwszOut, MAX_PATH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\newres.h ===
/**
**      Header for the New version of RC.EXE. This contains the structures
**      for new format of BITMAP files.
**/

/*  The width of the name field in the Data for the group resources */
#ifndef RC_INVOKED       // RC can't handle #pragmas
#pragma pack(2)

typedef struct tagBITMAPHEADER
  {
    DWORD   Size;
    WORD    Width;
    WORD    Height;
    WORD    Planes;
    WORD    BitCount;
  } BITMAPHEADER;

// WHY WASN'T THIS DEFINED TO BE SAME AS RESOURCE FORMAT?
// Image File header
typedef struct tagIMAGEFILEHEADER
{
    BYTE    cx;
    BYTE    cy;
    BYTE    nColors;
    BYTE    iUnused;
    WORD    xHotSpot;
    WORD    yHotSpot;
    DWORD   cbDIB;
    DWORD   offsetDIB;
} IMAGEFILEHEADER;

// File header
#define FT_ICON     1
#define FT_CURSOR   2

typedef struct tagICONFILEHEADER
{
        WORD iReserved;
        WORD iResourceType;
        WORD cresIcons;
        IMAGEFILEHEADER imh[1];
} ICONFILEHEADER;

typedef struct tagNEWHEADER {
    WORD    Reserved;
    WORD    ResType;
    WORD    ResCount;
} NEWHEADER, *LPNEWHEADER;

typedef struct tagICONDIR
{
        BYTE  Width;            /* 16, 32, 64 */
        BYTE  Height;           /* 16, 32, 64 */
        BYTE  ColorCount;       /* 2, 8, 16 */
        BYTE  reserved;
} ICONDIR;

// Format of resource directory (array of resources)

typedef struct tagRESDIR
{
        ICONDIR Icon;
        WORD    Planes;
        WORD    BitCount;
        DWORD   BytesInRes;
        WORD    idIcon;
} RESDIR, *LPRESDIR;

typedef struct tagRESDIRDISK
{
        struct  tagICONDIR  Icon;

        WORD   Reserved[2];
        DWORD  BytesInRes;
        DWORD  Offset;
} RESDIRDISK, *LPRESDIRDISK;

#pragma pack()
#endif // !RC_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ole2dup.c ===
#include "shellprv.h"
#pragma  hdrstop

// this makes sure the DLL for the given clsid stays in memory
// this is needed because we violate COM rules and hold apparment objects
// across the lifetime of appartment threads. these objects really need
// to be free threaded (we have always treated them as such)

STDAPI_(HINSTANCE) SHPinDllOfCLSIDStr(LPCTSTR pszCLSID)
{
    CLSID clsid;

    SHCLSIDFromString(pszCLSID, &clsid);
    return SHPinDllOfCLSID(&clsid);
}

// translate string form of CLSID into binary form

STDAPI SHCLSIDFromString(LPCTSTR psz, CLSID *pclsid)
{
    *pclsid = CLSID_NULL;
    if (psz == NULL) 
        return NOERROR;
    return GUIDFromString(psz, pclsid) ? NOERROR : CO_E_CLASSSTRING;
}

BOOL _IsShellDll(LPCTSTR pszDllPath)
{
    LPCTSTR pszDllName = PathFindFileName(pszDllPath);
    return lstrcmpi(pszDllName, TEXT("shell32.dll")) == 0;
}

HKEY g_hklmApprovedExt = (HKEY)-1;    // not tested yet

// On NT, we must check to ensure that this CLSID exists in
// the list of approved CLSIDs that can be used in-process.
// If not, we fail the creation with ERROR_ACCESS_DENIED.
// We explicitly allow anything serviced by this DLL

BOOL _IsShellExtApproved(LPCTSTR pszClass, LPCTSTR pszDllPath)
{
    BOOL fIsApproved = TRUE;

    ASSERT(!_IsShellDll(pszDllPath));

#ifdef FULL_DEBUG
    if (TRUE)
#else
    if (SHRestricted(REST_ENFORCESHELLEXTSECURITY))
#endif
    {
        if (g_hklmApprovedExt == (HKEY)-1)
        {
            g_hklmApprovedExt = NULL;
            RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"), 0, KEY_READ, &g_hklmApprovedExt);
        }

        if (g_hklmApprovedExt)
        {
            fIsApproved = SHQueryValueEx(g_hklmApprovedExt, pszClass, 0, NULL, NULL, NULL) == ERROR_SUCCESS;
            if (!fIsApproved)
            {
                HKEY hk;
                if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"), 0, KEY_READ, &hk) == ERROR_SUCCESS)
                {
                    fIsApproved = SHQueryValueEx(hk, pszClass, 0, NULL, NULL, NULL) == ERROR_SUCCESS;
                    RegCloseKey(hk);
                }
            }
        }
    }

#ifdef FULL_DEBUG
    if (!SHRestricted(REST_ENFORCESHELLEXTSECURITY) && !fIsApproved)
    {
        TraceMsg(TF_WARNING, "%s not approved; fortunately, shell security is disabled", pszClass);
        fIsApproved = TRUE;
    }
#endif
    return fIsApproved;
}

STDAPI_(BOOL) IsGuimodeSetupRunning()
{
    DWORD dwSystemSetupInProgress;
    DWORD dwMiniSetupInProgress;
    DWORD dwType;
    DWORD dwSize;
    
    dwSize = sizeof(dwSystemSetupInProgress);
    if ((SHGetValueW(HKEY_LOCAL_MACHINE, L"SYSTEM\\Setup", L"SystemSetupInProgress", &dwType, (LPVOID)&dwSystemSetupInProgress, &dwSize) == ERROR_SUCCESS) &&
        (dwType == REG_DWORD) &&
        (dwSystemSetupInProgress != 0))
    {

        // starting w/ whistler on a syspreped machine the SystemSetupInProgress will be set EVEN AFTER guimode setup
        // has finished (needed for OOBE on the boot after guimode finishes). So, to distinguish the "first-boot" case
        // from the "guimode-setup" case we check the MiniSetupInProgress value as well.

        dwSize = sizeof(dwMiniSetupInProgress);
        if ((SHGetValueW(HKEY_LOCAL_MACHINE, L"SYSTEM\\Setup", L"MiniSetupInProgress", &dwType, (LPVOID)&dwMiniSetupInProgress, &dwSize) != ERROR_SUCCESS) ||
            (dwType != REG_DWORD) ||
            (dwMiniSetupInProgress == 0))
        {
            return TRUE;
        }
    }

    return FALSE;
}

typedef HRESULT (__stdcall *PFNDLLGETCLASSOBJECT)(REFCLSID rclsid, REFIID riid, void **ppv);

HRESULT _CreateFromDllGetClassObject(PFNDLLGETCLASSOBJECT pfn, const CLSID *pclsid, IUnknown *punkOuter, REFIID riid, void **ppv)
{
    IClassFactory *pcf;
    HRESULT hr = pfn(pclsid, &IID_IClassFactory, &pcf);
    if (SUCCEEDED(hr))
    {
        hr = pcf->lpVtbl->CreateInstance(pcf, punkOuter, riid, ppv);
#ifdef DEBUG
        if (SUCCEEDED(hr))
        {
            // confirm that OLE can create this object to
            // make sure our objects are really CoCreateable
            IUnknown *punk;
            HRESULT hrTemp = CoCreateInstance(pclsid, punkOuter, CLSCTX_INPROC_SERVER, riid, &punk);
            if (SUCCEEDED(hrTemp))
                punk->lpVtbl->Release(punk);
            else
            {
                if (hrTemp == CO_E_NOTINITIALIZED)
                {
                    // shell32.dll works without com being inited
                    TraceMsg(TF_WARNING, "shell32 or friend object used without COM being initalized");
                }
// the RIPMSG below was hitting too often in out-of-memory cases where lame class factories return E_FAIL, E_NOTIMPL, and a bunch of
// other meaningless error codes. I have therefore relegaed this ripmsg to FULL_DEBUG only status.
#ifdef FULL_DEBUG
                else if ((hrTemp != E_OUTOFMEMORY) &&   // stress can hit the E_OUTOFMEMORY case
                         (hrTemp != E_NOINTERFACE) &&   // stress can hit the E_NOINTERFACE case
                         (hrTemp != HRESULT_FROM_WIN32(ERROR_COMMITMENT_LIMIT)) &&      // stress can hit the ERROR_COMMITMENT_LIMIT case
                         (hrTemp != HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES)) &&   // stress can hit the ERROR_NO_SYSTEM_RESOURCES case
                         !IsGuimodeSetupRunning())      // and we don't want to fire the assert during guimode (shell32 might not be registered yet)
                {
                    // others failures are bad
                    RIPMSG(FALSE, "CoCreate failed with %x", hrTemp);
                }
#endif // FULL_DEBUG
            }
        }
#endif
        pcf->lpVtbl->Release(pcf);
    }
    return hr;
}


HRESULT _CreateFromShell(const CLSID *pclsid, IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return _CreateFromDllGetClassObject(DllGetClassObject, pclsid, punkOuter, riid, ppv);
}

HRESULT _CreateFromDll(LPCTSTR pszDllPath, const CLSID *pclsid, IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HMODULE hmod = LoadLibraryEx(pszDllPath,NULL,LOAD_WITH_ALTERED_SEARCH_PATH);
    if (hmod)
    {
        HRESULT hr;
        PFNDLLGETCLASSOBJECT pfn = (PFNDLLGETCLASSOBJECT)GetProcAddress(hmod, "DllGetClassObject");
        if (pfn)
            hr = _CreateFromDllGetClassObject(pfn, pclsid, punkOuter, riid, ppv);
        else
            hr = E_FAIL;

        if (FAILED(hr))
            FreeLibrary(hmod);
        return hr;
    }
    return HRESULT_FROM_WIN32(GetLastError());
}

STDAPI SHGetInProcServerForClass(const CLSID *pclsid, LPTSTR pszDllPath, LPTSTR pszClass, DWORD cchClass, BOOL *pbLoadWithoutCOM)
{
    TCHAR szKeyToOpen[GUIDSTR_MAX + 128], szInProcServer[GUIDSTR_MAX];
    HKEY hkeyInProcServer;
    DWORD dwSize = MAX_PATH * sizeof(TCHAR);  // convert to count of bytes
    DWORD dwError;

    SHStringFromGUID(pclsid, szInProcServer, ARRAYSIZE(szInProcServer));

    StrCpyN(pszClass, szInProcServer, cchClass);

    *pszDllPath = 0;

    StrCpyN(szKeyToOpen, TEXT("CLSID\\"), ARRAYSIZE(szKeyToOpen));
    StrCatBuff(szKeyToOpen, szInProcServer, ARRAYSIZE(szKeyToOpen));
    StrCatBuff(szKeyToOpen, TEXT("\\InProcServer32"), ARRAYSIZE(szKeyToOpen));

    dwError = RegOpenKeyEx(HKEY_CLASSES_ROOT, szKeyToOpen, 0, KEY_QUERY_VALUE, &hkeyInProcServer);
    if (dwError == ERROR_SUCCESS)
    {
        SHQueryValueEx(hkeyInProcServer, NULL, 0, NULL, (BYTE *)pszDllPath, &dwSize);

        *pbLoadWithoutCOM = SHQueryValueEx(hkeyInProcServer, TEXT("LoadWithoutCOM"), NULL, NULL, NULL, NULL) == ERROR_SUCCESS;
        RegCloseKey(hkeyInProcServer);
    }

    //
    //  Return a more accurate error code so we don't
    //  fire a bogus assertion.
    //
    if (*pszDllPath)
    {
        return S_OK;
    }
    else
    {
        // If error was "key not found", then the class is not registered.
        // If no error, then class is not registered properly (e.g., null
        // string for InProcServer32).
        if (dwError == ERROR_FILE_NOT_FOUND || dwError == ERROR_SUCCESS)
        {
            return REGDB_E_CLASSNOTREG;
        }
        else
        {
            // Any other error is worth reporting as-is (out of memory,
            // access denied, etc.)
            return HRESULT_FROM_WIN32(dwError);
        }
    }
}

STDAPI _SHCoCreateInstance(const CLSID * pclsid, IUnknown *punkOuter, DWORD dwCoCreateFlags, 
                           BOOL bMustBeApproved, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    TCHAR szClass[GUIDSTR_MAX + 64], szDllPath[MAX_PATH];
    BOOL bLoadWithoutCOM = FALSE;
    *ppv = NULL;
    *szDllPath = 0;

    // save us some registry accesses and try the shell first
    // but only if its INPROC
    if (dwCoCreateFlags & CLSCTX_INPROC_SERVER)
        hr = _CreateFromShell(pclsid, punkOuter, riid, ppv);

#ifdef DEBUG
    if (SUCCEEDED(hr))
    {
        HRESULT hrRegistered = THR(SHGetInProcServerForClass(pclsid, szDllPath, szClass, ARRAYSIZE(szClass), &bLoadWithoutCOM));

        //
        // check to see if we're the explorer process before complaining (to
        // avoid ripping during setup before all objects have been registered)
        //
        if (IsProcessAnExplorer() && !IsGuimodeSetupRunning() && hrRegistered == REGDB_E_CLASSNOTREG)
        {
            ASSERTMSG(FAILED(hr), "object not registered (add to selfreg.inx) pclsid = %x", pclsid);
        }
    }
#endif

    if (FAILED(hr))
    {
        BOOL fNeedsInProc = ((dwCoCreateFlags & CLSCTX_ALL) == CLSCTX_INPROC_SERVER);
        hr = fNeedsInProc ? THR(SHGetInProcServerForClass(pclsid, szDllPath, szClass, ARRAYSIZE(szClass), &bLoadWithoutCOM)) : S_FALSE;
        if (SUCCEEDED(hr))
        {
            if (hr == S_OK && _IsShellDll(szDllPath))
            {
                // Object likely moved out of the shell DLL.
                hr = CLASS_E_CLASSNOTAVAILABLE;
            }
            else if (bMustBeApproved &&
                     SHStringFromGUID(pclsid, szClass, ARRAYSIZE(szClass)) &&
                     !_IsShellExtApproved(szClass, szDllPath))
            {
                TraceMsg(TF_ERROR, "SHCoCreateInstance() %s needs to be registered under HKLM or HKCU"
                    ",Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved", szClass);
                hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            }
            else
            {
                hr = THR(SHCoCreateInstanceAC(pclsid, punkOuter, dwCoCreateFlags, riid, ppv));

                if (FAILED(hr) && fNeedsInProc && bLoadWithoutCOM)
                {
                    if ((hr == REGDB_E_IIDNOTREG) || (hr == CO_E_NOTINITIALIZED))
                    {
                        hr = THR(_CreateFromDll(szDllPath, pclsid, punkOuter, riid, ppv));
                    }
                }

                // only RIP if this is not a secondary explorer process since secondary explorers dont init com or ole since
                // they are going to delegate to an existing process and we don't want to have to load ole for perf in that case.
                if (!IsSecondaryExplorerProcess())
                {
                    RIPMSG((hr != CO_E_NOTINITIALIZED), "COM not inited for dll %s", szDllPath);
                }

                //  sometimes we need to permanently pin these objects.
                if (SUCCEEDED(hr) && fNeedsInProc && (OBJCOMPATF_PINDLL & SHGetObjectCompatFlags(NULL, pclsid)))
                {
                    SHPinDllOfCLSID(pclsid);
                }
            }
        }
    }

#ifdef DEBUG
    if (FAILED(hr) && (hr != E_NOINTERFACE))    // E_NOINTERFACE means riid not accepted
    {
        ULONGLONG dwTF = IsFlagSet(g_dwBreakFlags, BF_COCREATEINSTANCE) ? TF_ALWAYS : TF_WARNING;
        TraceMsg(dwTF, "CoCreateInstance: failed (%s,%x)", szClass, hr);
    }
#endif
    return hr;
}

STDAPI SHCoCreateInstance(LPCTSTR pszCLSID, const CLSID * pclsid, IUnknown *punkOuter, REFIID riid, void **ppv)
{
    CLSID clsid;
    if (pszCLSID)
    {
        SHCLSIDFromString(pszCLSID, &clsid);
        pclsid = &clsid;
    }
    return _SHCoCreateInstance(pclsid, punkOuter, CLSCTX_INPROC_SERVER, FALSE, riid, ppv);
}

//
// create a shell extension object, ensures that object is in the approved list
//
STDAPI SHExtCoCreateInstance2(LPCTSTR pszCLSID, const CLSID *pclsid, IUnknown *punkOuter, DWORD dwClsCtx, REFIID riid, void **ppv)
{
    CLSID clsid;
    
    if (pszCLSID)
    {
        SHCLSIDFromString(pszCLSID, &clsid);
        pclsid = &clsid;
    }

    return _SHCoCreateInstance(pclsid, punkOuter, dwClsCtx, TRUE, riid, ppv);
}

STDAPI SHExtCoCreateInstance(LPCTSTR pszCLSID, const CLSID *pclsid, IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return SHExtCoCreateInstance2(pszCLSID, pclsid, punkOuter, CLSCTX_NO_CODE_DOWNLOAD | CLSCTX_INPROC_SERVER, riid, ppv);
}

STDAPI_(BOOL) SHIsBadInterfacePtr(const void *pv, UINT cbVtbl)
{
    IUnknown const * punk = pv;
    return IsBadReadPtr(punk, sizeof(punk->lpVtbl)) || 
           IsBadReadPtr(punk->lpVtbl, cbVtbl) || 
           IsBadCodePtr((FARPROC)punk->lpVtbl->Release);
}

// private API that loads COM inproc objects out of band of COM. this 
// should be used very carefully, only in special legacy cases where 
// we knowingly need to break COM rules. right now this is only for AVIFile
// as it depended on the Win95 behavior of SHCoCreateInstance() loading objects
// without COM being inited and without them being marshalled

STDAPI SHCreateInstance(REFCLSID clsid, REFIID riid, void **ppv)
{
    TCHAR szClass[GUIDSTR_MAX + 64], szDllPath[MAX_PATH];
    BOOL bLoadWithoutCOM;

    HRESULT hr = SHGetInProcServerForClass(clsid, szDllPath, szClass, ARRAYSIZE(szClass), &bLoadWithoutCOM);
    if (SUCCEEDED(hr))
    {
        hr = THR(_CreateFromDll(szDllPath, clsid, NULL, riid, ppv));
    }
    else
    {
        *ppv = NULL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ovrlayid.h ===
// Shell Icon Overlay Identifiers 

#ifndef _OVERLAYID_H_
#define _OVERLAYID_H_

#define REGSTR_ICONOVERLAYID     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellIconOverlayIdentifiers")
#define REGSTR_ICONOVERLAYCLSID  TEXT("CLSID\\%s")

STDAPI CFSIconOverlayIdentifier_SlowFile_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppvOut);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\openwith.cpp ===
#include "shellprv.h"
#include "ids.h"
#include <shlwapi.h>
#include "openwith.h"
#include "uemapp.h"
#include "mtpt.h"
#include "fassoc.h"
#include "filetbl.h"
#include "datautil.h"
#include <dpa.h>
#include "defcm.h"

#define TF_OPENWITHMENU 0x00000000

#define SZOPENWITHLIST                  TEXT("OpenWithList")
#define REGSTR_PATH_EXPLORER_FILEEXTS   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts")
#define OPEN_WITH_LIST_MAX_ITEMS        10

//
//  OpenWithListOpen() 
//  allocates and initializes the state for the openwithlist 
//
HRESULT OpenWithListOpen(IN LPCTSTR pszExt, HANDLE *phmru)
{
    *phmru = 0;
    if (pszExt && *pszExt) 
    {
        TCHAR szSubKey[MAX_PATH];
        //  Build up the subkey string.
        wnsprintf(szSubKey, SIZECHARS(szSubKey), TEXT("%s\\%s\\%s"), REGSTR_PATH_EXPLORER_FILEEXTS, pszExt, SZOPENWITHLIST);
        MRUINFO mi = {sizeof(mi), OPEN_WITH_LIST_MAX_ITEMS, 0, HKEY_CURRENT_USER, szSubKey, NULL};
        *phmru = CreateMRUList(&mi);

    }

    return *phmru ? S_OK : E_OUTOFMEMORY;
}

HRESULT _AddItem(HANDLE hmru, LPCTSTR pszName)
{
    HRESULT hr = S_OK;
    if (hmru)
    {
        int cItems = EnumMRUList(hmru, -1, NULL, 0);

        //  just trim us down to make room...
        while (cItems >= OPEN_WITH_LIST_MAX_ITEMS)
            DelMRUString(hmru, --cItems);
            
        if (0 > AddMRUString(hmru, pszName))
            hr = E_UNEXPECTED;

    }
    
    return hr;
}

void _DeleteItem(HANDLE hmru, LPCTSTR pszName)
{
    int iItem = FindMRUString(hmru, pszName, NULL);
    if (0 <= iItem) 
    {
        DelMRUString(hmru, iItem);
    } 
}

void _AddProgidForExt(LPCWSTR pszExt);

STDAPI OpenWithListRegister(DWORD dwFlags, LPCTSTR pszExt, LPCTSTR pszVerb, HKEY hkProgid)
{
    //
    //  ----> Peruser entries are stored here
    //  HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts
    //     \.Ext
    //         Application = "foo.exe"
    //         \OpenWithList
    //             MRUList = "ab"
    //             a = "App.exe"
    //             b = "foo.exe"
    //
    //  ----> for permanent entries are stored un HKCR
    //  HKCR
    //     \.Ext
    //         \OpenWithList
    //             \app.exe
    //
    //  ----> and applications or the system can write app association here
    //     \Applications
    //         \APP.EXE
    //             \shell...
    //         \foo.exe
    //             \shell...
    //
    //
    HANDLE hmru;
    HRESULT hr = OpenWithListOpen(pszExt, &hmru);
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];
        hr = AssocQueryStringByKey(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, hkProgid, pszVerb, szPath, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szPath)));
        if (SUCCEEDED(hr))
        {
            LPCTSTR pszExe = PathFindFileName(szPath);

            if (IsPathInOpenWithKillList(pszExe))
                hr = E_ACCESSDENIED;
            else
                hr = AssocMakeApplicationByKey(ASSOCMAKEF_VERIFY, hkProgid, pszVerb);
        
            if (SUCCEEDED(hr))
            {
                TraceMsg(TF_OPENWITHMENU, "[%X] OpenWithListRegister() adding %s",hmru, pszExe);
                hr = _AddItem(hmru, pszExe);
            }

            if (FAILED(hr)) 
                _DeleteItem(hmru, pszExe);

        }

        FreeMRUList(hmru);
    }

    _AddProgidForExt(pszExt);

    return hr;
}

STDAPI_(void) OpenWithListSoftRegisterProcess(DWORD dwFlags, LPCTSTR pszExt, LPCTSTR pszProcess)
{
    HANDLE hmru;
    if (SUCCEEDED(OpenWithListOpen(pszExt, &hmru)))
    {
        TCHAR szApp[MAX_PATH];  
        if (!pszProcess)
        {
           if (GetModuleFileName(NULL, szApp, SIZECHARS(szApp)))
               pszProcess = szApp;
        }

        if (pszProcess && !IsPathInOpenWithKillList(pszProcess))
            _AddItem(hmru, PathFindFileName(pszProcess));

        FreeMRUList(hmru);
    }
}

class COpenWithArray : public CDPA<CAppInfo>
{
public:
    ~COpenWithArray();
    HRESULT FillArray(PCWSTR pszExt);

private:
    static int CALLBACK _DeleteAppInfo(CAppInfo *pai, void *pv)
        { if (pai) delete pai; return 1; }

};

COpenWithArray::~COpenWithArray()
{
    if ((HDPA)this)
        DestroyCallback(_DeleteAppInfo, NULL);
}

HRESULT COpenWithArray::FillArray(PCWSTR pszExt)
{
    IEnumAssocHandlers *penum;
    HRESULT hr = SHAssocEnumHandlers(pszExt, &penum);
    if (SUCCEEDED(hr))
    {
        IAssocHandler *pah;
        while (S_OK == penum->Next(1, &pah, NULL))
        {
            // we only want the best
            if (S_OK == pah->IsRecommended())
            {
                CAppInfo *pai = new CAppInfo(pah);
                if (pai)
                {
                    if (pai->Init())
                    {
                        // Trim duplicate items before we add them for other programs
                        int i = 0;
                        for (; i < GetPtrCount(); i++)
                        {
                            if (0 == lstrcmpi(pai->Name(), GetPtr(i)->Name()))
                            {
                                //  its a match
                                break;
                            }
                        }

                        //  if we dont add this to the dpa
                        //  then we need to clean it up
                        if (i == GetPtrCount() && -1 != AppendPtr(pai))
                            pai = NULL;
                    }

                    if (pai)
                        delete pai;
                }
            }
            pah->Release();
        }
        penum->Release();
    }

    return hr;
}

class COpenWithMenu : public IContextMenu3, IShellExtInit
{
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    
    // IContextMenu
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax);
    
    // IContextMenu2
    STDMETHOD(HandleMenuMsg)(UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    // IContextMenu3
    STDMETHOD(HandleMenuMsg2)(UINT uMsg, WPARAM wParam, LPARAM lParam,LRESULT *lResult);
    
    // IShellExtInit
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);
    
    
    friend HRESULT COpenWithMenu_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppvOut);
    
protected:  // methods
    COpenWithMenu();
    ~COpenWithMenu();
    //Handle Menu messages submitted to HandleMenuMsg
    void DrawItem(DRAWITEMSTRUCT *lpdi);
    LRESULT MeasureItem(MEASUREITEMSTRUCT *lpmi);
    BOOL InitMenuPopup(HMENU hMenu);
    
    //Internal Helpers
    HRESULT _GetHelpText(UINT_PTR idCmd, LPSTR pszName, UINT cchMax, BOOL fUnicode);
    HRESULT _MatchMenuItem(TCHAR ch, LRESULT* plRes);

protected:  // members
    LONG                _cRef;
    HMENU               _hMenu;
    BOOL                _fMenuNeedsInit;
    UINT                _idCmdFirst;
    COpenWithArray      _owa;
    int                 _nItems;
    UINT                _uFlags;
    IDataObject        *_pdtobj;
    TCHAR               _szPath[MAX_PATH];
    
};


COpenWithMenu::COpenWithMenu() : _cRef(1)
{
    TraceMsg(TF_OPENWITHMENU, "ctor COpenWithMenu %x", this);
}

COpenWithMenu::~COpenWithMenu()
{
    TraceMsg(TF_OPENWITHMENU, "dtor COpenWithMenu %x", this);

    if (_pdtobj)
        _pdtobj->Release();

    if (_hMenu)
    {
        ASSERT(_nItems);
        DestroyMenu(_hMenu);
    }
}

STDAPI COpenWithMenu_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppvOut)
{
    *ppvOut = NULL;                     

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    COpenWithMenu * powm = new COpenWithMenu();
    if (!powm)
        return E_OUTOFMEMORY;
    
    HRESULT hr = powm->QueryInterface(riid, ppvOut);
    powm->Release();
    return hr;
}

HRESULT COpenWithMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(COpenWithMenu, IContextMenu, IContextMenu3),
        QITABENTMULTI(COpenWithMenu, IContextMenu2, IContextMenu3),
        QITABENT(COpenWithMenu, IContextMenu3),
        QITABENT(COpenWithMenu, IShellExtInit),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG COpenWithMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG COpenWithMenu::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

/*
    Purpose:
        Add Open/Edit/Default verb to extension app list
*/
HRESULT AddVerbItems(LPCTSTR pszExt)
{
    IQueryAssociations *pqa;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));
    
    if (SUCCEEDED(hr))
    {
        hr = pqa->Init(0, pszExt, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            HKEY hkeyClass;
            hr = pqa->GetKey(0, ASSOCKEY_SHELLEXECCLASS, NULL, &hkeyClass);
            if (SUCCEEDED(hr))
            {
                OpenWithListRegister(0, pszExt, NULL, hkeyClass);
                RegCloseKey(hkeyClass);
            }

            //  we add in the editor too
            if (SUCCEEDED(pqa->GetKey(0, ASSOCKEY_SHELLEXECCLASS, L"Edit", &hkeyClass)))
            {
                OpenWithListRegister(0, pszExt, NULL, hkeyClass);
                RegCloseKey(hkeyClass);
            }
                
            hr = S_OK;
        }
        pqa->Release();
    }
    return hr;
}

//
//  Our context menu IDs are assigned like this
//
//  idCmdFirst = Open With Custom Program (either on main menu or on popup)
//  idCmdFirst+1 through idCmdFirst+_nItems = Open With program in OpenWithList

#define OWMENU_BROWSE       0
#define OWMENU_APPFIRST     1


HRESULT COpenWithMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    MENUITEMINFO mii;
    LPTSTR pszExt;
    TCHAR szOpenWithMenu[80];
    
    _idCmdFirst = idCmdFirst;
    _uFlags = uFlags;
    
    if (SUCCEEDED(PathFromDataObject(_pdtobj, _szPath, ARRAYSIZE(_szPath))))
    {
        // No openwith context menu for executables.
        if (PathIsExe(_szPath))
            return S_OK;

        pszExt = PathFindExtension(_szPath);
        if (pszExt && *pszExt)
        {
            // Add Open/Edit/Default verb to extension app list
            if (SUCCEEDED(AddVerbItems(pszExt)))
            {
                // Do this only if AddVerbItems succeeded; otherwise,
                // we would create an empty MRU for a nonexisting class,
                // causing the class to spring into existence and cause
                // the "Open With" dialog to think we are overriding
                // rather than creating new.
                // get extension app list
                
                if (_owa.Create(4) && SUCCEEDED(_owa.FillArray(pszExt)))
                {
                    _nItems = _owa.GetPtrCount();
                    if (1 == _nItems)
                    {
                        // For known file type(there is at least one verb under its progid), 
                        // if there is only one item in its openwithlist, don't show open with sub menu
                        _nItems = 0;
                    }
                }
            }
        }
    }

    LoadString(g_hinst, (_nItems ? IDS_OPENWITH : IDS_OPENWITHNEW), szOpenWithMenu, ARRAYSIZE(szOpenWithMenu));

    if (_nItems)
    {
        //  we need to create a submenu
        //  with all of our goodies
        _hMenu = CreatePopupMenu();
        if (_hMenu)
        {
            _fMenuNeedsInit = TRUE;
            
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_ID|MIIM_TYPE|MIIM_DATA;
            mii.wID = idCmdFirst+OWMENU_APPFIRST;
            mii.fType = MFT_STRING;
            mii.dwTypeData = szOpenWithMenu;
            mii.dwItemData = 0;
        
            InsertMenuItem(_hMenu,0,TRUE,&mii);
        
            mii.fMask = MIIM_ID|MIIM_SUBMENU|MIIM_TYPE;
            mii.fType = MFT_STRING;
            mii.wID = idCmdFirst+OWMENU_BROWSE;
            mii.hSubMenu = _hMenu;
            mii.dwTypeData = szOpenWithMenu;
        
            InsertMenuItem(hmenu,indexMenu,TRUE,&mii);
        }
    }
    else
    {
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID|MIIM_TYPE|MIIM_DATA;
        mii.fType = MFT_STRING;
        mii.wID = idCmdFirst+OWMENU_BROWSE;
        mii.dwTypeData = szOpenWithMenu;
        mii.dwItemData = 0;
        
        InsertMenuItem(hmenu,indexMenu,TRUE,&mii);

    }
    return ResultFromShort(_nItems + 1);

}

HRESULT COpenWithMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = E_OUTOFMEMORY;
    CMINVOKECOMMANDINFOEX ici;
    void * pvFree;

    //  maybe these two routines should be collapsed into one?
    if ((IS_INTRESOURCE(pici->lpVerb) || 0 == lstrcmpiA(pici->lpVerb, "openas"))
    && SUCCEEDED(ICI2ICIX(pici, &ici, &pvFree)))
    {
        BOOL fOpenAs = TRUE;
        if (pici->lpVerb && IS_INTRESOURCE(pici->lpVerb))
        {
            int i = LOWORD(pici->lpVerb) - OWMENU_APPFIRST;
            if (i < _owa.GetPtrCount())
            {
                hr = _owa.GetPtr(i)->Handler()->Invoke(&ici, _szPath);
                fOpenAs = FALSE;
            }
        }

        if (fOpenAs)
        {
            SHELLEXECUTEINFO ei = {0};
            hr = ICIX2SEI(&ici, &ei);
            if (SUCCEEDED(hr))
            {
                // use the "Unknown" key so we get the openwith prompt
                ei.lpFile = _szPath;
                //  dont do the zone check before the user picks the app.
                //  wait until they actually try to invoke the file.
                ei.fMask |= SEE_MASK_NOZONECHECKS;
                RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("Unknown"), 0, MAXIMUM_ALLOWED, &ei.hkeyClass);
                if (!(_uFlags & CMF_DEFAULTONLY))
                {
                    // defview sets CFM_DEFAULTONLY when the user is double-clicking. We check it
                    // here since we want do NOT want to query the class store if the user explicitly
                    // right-clicked on the menu and choo   se openwith.

                    // pop up open with dialog without querying class store
                    ei.fMask |= SEE_MASK_NOQUERYCLASSSTORE;
                }

                if (ei.hkeyClass)
                {
                    ei.fMask |= SEE_MASK_CLASSKEY;

                    if (ShellExecuteEx(&ei)) 
                    {
                        hr = S_OK;
                        if (UEMIsLoaded())
                        {
                            // note that we already got a UIBL_DOTASSOC (from
                            // OpenAs_RunDLL or whatever it is that 'Unknown'
                            // runs).  so the Uassist analysis app will have to
                            // subtract it off
                            UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_RUNASSOC, UIBL_DOTNOASSOC);
                        }
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                    RegCloseKey(ei.hkeyClass);
                 }
                 else
                    hr = E_FAIL;
             }
        }

        LocalFree(pvFree);  // accepts NULL
    }        

    return hr;
}

HRESULT COpenWithMenu::_GetHelpText(UINT_PTR idCmd, LPSTR pszName, UINT cchMax, BOOL fUnicode)
{
    UINT ids;
    LPCTSTR pszFriendly = NULL;

    if (idCmd == OWMENU_BROWSE)
    {
        ids = IDS_OPENWITHHELP;
        pszFriendly = TEXT("");
    }
    else if ((idCmd-OWMENU_APPFIRST) < (UINT_PTR)_owa.GetPtrCount())
    {
        ids = IDS_OPENWITHAPPHELP;
        pszFriendly = _owa.GetPtr(idCmd-OWMENU_APPFIRST)->UIName();
    }

    if (!pszFriendly)
        return E_FAIL;

    if (fUnicode)
    {
        WCHAR wszFormat[80];
        LoadStringW(HINST_THISDLL, ids, wszFormat, ARRAYSIZE(wszFormat));
        wnsprintfW((LPWSTR)pszName, cchMax, wszFormat, pszFriendly);
    }
    else
    {
        CHAR szFormat[80];
        LoadStringA(HINST_THISDLL, ids, szFormat, ARRAYSIZE(szFormat));
        wnsprintfA(pszName, cchMax, szFormat, pszFriendly);
    }

    return S_OK;
}

const ICIVERBTOIDMAP c_sIDVerbMap[] = 
{
    { L"openas", "openas", OWMENU_BROWSE, OWMENU_BROWSE, },
};

HRESULT COpenWithMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax)
{
    switch (uType)
    {
        case GCS_VERBA:
        case GCS_VERBW:
            return SHMapCmdIDToVerb(idCmd, c_sIDVerbMap, ARRAYSIZE(c_sIDVerbMap), pszName, cchMax, GCS_VERBW == uType);

        case GCS_HELPTEXTA:
        case GCS_HELPTEXTW:
            return _GetHelpText(idCmd, pszName, cchMax, uType == GCS_HELPTEXTW);

    }

    return E_NOTIMPL;
}

HRESULT COpenWithMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg,wParam,lParam,NULL);
}

// Defined in fsmenu.cpp
BOOL _MenuCharMatch(LPCTSTR lpsz, TCHAR ch, BOOL fIgnoreAmpersand);

HRESULT COpenWithMenu::_MatchMenuItem(TCHAR ch, LRESULT* plRes)
{
    if (plRes == NULL)
        return S_FALSE;

    int iLastSelectedItem = -1;
    int iNextMatch = -1;
    BOOL fMoreThanOneMatch = FALSE;
    int c = GetMenuItemCount(_hMenu);

    // Pass 1: Locate the Selected Item
    for (int i = 0; i < c; i++) 
    {
        MENUITEMINFO mii = {0};
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_STATE;
        if (GetMenuItemInfo(_hMenu, i, MF_BYPOSITION, &mii))
        {
            if (mii.fState & MFS_HILITE)
            {
                iLastSelectedItem = i;
                break;
            }
        }
    }

    // Pass 2: Starting from the selected item, locate the first item with the matching name.
    for (int i = iLastSelectedItem + 1; i < c; i++) 
    {
        if (i < _owa.GetPtrCount()
        && _MenuCharMatch(_owa.GetPtr(i)->UIName(), ch, FALSE))
        {
            if (iNextMatch != -1)
            {
                fMoreThanOneMatch = TRUE;
                break;                      // We found all the info we need
            }
            else
            {
                iNextMatch = i;
            }
        }
    }

    // Pass 3: If we did not find a match, or if there was only one match
    // Search from the first item, to the Selected Item
    if (iNextMatch == -1 || fMoreThanOneMatch == FALSE)
    {
        for (int i = 0; i <= iLastSelectedItem; i++) 
        {
            if (i < _owa.GetPtrCount()
            && _MenuCharMatch(_owa.GetPtr(i)->UIName(), ch, FALSE))
            {
                if (iNextMatch != -1)
                {
                    fMoreThanOneMatch = TRUE;
                    break;
                }
                else
                {
                    iNextMatch = i;
                }
            }
        }
    }

    if (iNextMatch != -1)
    {
        *plRes = MAKELONG(iNextMatch, fMoreThanOneMatch? MNC_SELECT : MNC_EXECUTE);
    }
    else
    {
        *plRes = MAKELONG(0, MNC_IGNORE);
    }

    return S_OK;
}


HRESULT COpenWithMenu::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam,LRESULT *plResult)
{
    LRESULT lResult = 0;
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case WM_INITMENUPOPUP:
        InitMenuPopup(_hMenu);
        break;

    case WM_DRAWITEM:
        DrawItem((DRAWITEMSTRUCT *)lParam);
        break;
        
    case WM_MEASUREITEM:
        lResult = MeasureItem((MEASUREITEMSTRUCT *)lParam);    
        break;

    case WM_MENUCHAR:
        hr = _MatchMenuItem((TCHAR)LOWORD(wParam), &lResult);
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    if (plResult)
        *plResult = lResult;

    return hr;
}

HRESULT COpenWithMenu::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);
    return S_OK;
}

#define CXIMAGEGAP 6
#define SRCSTENCIL              0x00B8074AL

void COpenWithMenu::DrawItem(DRAWITEMSTRUCT *lpdi)
{
    CAppInfo *pai = _owa.GetPtr(lpdi->itemData);
    DrawMenuItem(lpdi,  pai->UIName(), pai->IconIndex());
}

LRESULT COpenWithMenu::MeasureItem(MEASUREITEMSTRUCT *pmi)
{
    CAppInfo *pai = _owa.GetPtr(pmi->itemData);
    return MeasureMenuItem(pmi, pai->UIName());
}
 
BOOL COpenWithMenu::InitMenuPopup(HMENU hmenu)
{
    TraceMsg(TF_OPENWITHMENU, "COpenWithMenu::InitMenuPopup");

    if (_fMenuNeedsInit)
    {
        TCHAR szMenuText[80];
        MENUITEMINFO mii;
        // remove the place holder.
        DeleteMenu(hmenu,0,MF_BYPOSITION);

        // add app's in mru list to context menu
        for (int i = 0; i < _owa.GetPtrCount(); i++)
        {
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_ID|MIIM_TYPE|MIIM_DATA;
            mii.wID = _idCmdFirst + OWMENU_APPFIRST + i;
            mii.fType = MFT_OWNERDRAW;
            mii.dwItemData = i;

            InsertMenuItem(hmenu,GetMenuItemCount(hmenu),TRUE,&mii);
        }

        // add seperator
        AppendMenu(hmenu,MF_SEPARATOR,0,NULL); 

        // add "Choose Program..."
        LoadString(g_hinst, IDS_OPENWITHBROWSE, szMenuText, ARRAYSIZE(szMenuText));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID|MIIM_TYPE|MIIM_DATA;
        mii.wID = _idCmdFirst + OWMENU_BROWSE;
        mii.fType = MFT_STRING;
        mii.dwTypeData = szMenuText;
        mii.dwItemData = 0;

        InsertMenuItem(hmenu,GetMenuItemCount(hmenu),TRUE,&mii);
        _fMenuNeedsInit = FALSE;
        return TRUE;
    }
    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ovrlaymn.h ===
// Shell Icon Overlay Manager

#ifndef _OVERLAYMN_H_
#define _OVERLAYMN_H_

// HACK: This is defined in image.c, and it should be in one of the header files
#define MAX_OVERLAY_IMAGES  NUM_OVERLAY_IMAGES

#define REGSTR_ICONOVERLAYID     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellIconOverlayIdentifiers")
#define REGSTR_ICONOVERLAYCLSID  TEXT("CLSID\\%s")

STDAPI CFSIconOverlayManager_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppvOut);

STDAPI_(BOOL) IconOverlayManagerInit();
STDAPI_(void) IconOverlayManagerTerminate();

extern IShellIconOverlayManager * g_psiom;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\openwith.h ===
/*
 * openwith.h -- Open With context menu handler
 */

#ifndef _OPENWITH_H_
#define _OPENWITH_H_

//
// Prototypes for all modules
//
    
STDAPI COpenWithMenu_CreateInstance(IUnknown* pUnkOuter, REFIID riid, OUT LPVOID *  ppvOut);

#endif  // _OPENWITH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\os.c ===
#include "shellprv.h"
#pragma  hdrstop

#include <ntimage.h>    
#include <ntrtl.h>

static DWORD s_dwThreadIDSuspendNotify = 0;

STDAPI_(BOOL) SuspendSHNotify()
{
    DWORD dwID = GetCurrentThreadId();
    DWORD dwOldID = InterlockedCompareExchange(&s_dwThreadIDSuspendNotify, dwID, 0);
    return (dwOldID == 0);
}

STDAPI_(BOOL) ResumeSHNotify()
{
    DWORD dwID = GetCurrentThreadId();
    DWORD dwOldID = InterlockedCompareExchange(&s_dwThreadIDSuspendNotify, 0, dwID);
    return (dwOldID == dwID);
}

STDAPI_(BOOL) SHMoveFile(LPCTSTR pszExisting, LPCTSTR pszNew, LONG lEvent)
{
    BOOL res;

    // CreateDirectory fails if the directory name being created does
    // not have room for an 8.3 name to be tagged onto the end of it,
    // i.e., lstrlen(new_directory_name)+12 must be less or equal to MAX_PATH.
    // However, NT does not impose this restriction on MoveFile -- which the
    // shell sometimes uses to manipulate directory names.  So, in order to
    // maintain consistency, we now check the length of the name before we
    // move the directory...

    if (IsDirPathTooLongForCreateDir(pszNew) &&
        (GetFileAttributes(pszExisting) & FILE_ATTRIBUTE_DIRECTORY))
    {
        SetLastError(ERROR_FILENAME_EXCED_RANGE);
        res = FALSE;
    }
    else
    {
        res = MoveFile(pszExisting, pszNew);
        if (FALSE == res)
        {
            // If we couldn't move the file, see if it had the readonly or system attributes.
            // If so, clear them, move the file, and set them back on the destination

            DWORD dwAttributes = GetFileAttributes(pszExisting);
            if (-1 != dwAttributes && (dwAttributes & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
            {
                if (SetFileAttributes(pszExisting, dwAttributes  & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
                {
                    res = MoveFile(pszExisting, pszNew);
                    if (res)
                    {
                        SetFileAttributes(pszNew, dwAttributes);
                    }
                    else
                    {
                        SetFileAttributes(pszExisting, dwAttributes); // if move failed, return attributes.
                    }
                }
            }
        }
    }

    if (res && s_dwThreadIDSuspendNotify != GetCurrentThreadId())
    {
        SHChangeNotify(lEvent, SHCNF_PATH, pszExisting, pszNew);
    }

    return res;
}

STDAPI_(BOOL) Win32MoveFile(LPCTSTR pszExisting, LPCTSTR pszNew, BOOL fDir)
{
    return SHMoveFile(pszExisting, pszNew, fDir ? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM);
}

STDAPI_(BOOL) Win32DeleteFilePidl(LPCTSTR pszFileName, LPCITEMIDLIST pidlFile)
{
    BOOL res = DeleteFile(pszFileName);
    if (FALSE == res)
    {
        // If we couldn't delete the file, see if it has the readonly or
        // system bits set.  If so, clear them and try again

        DWORD dwAttributes = GetFileAttributes(pszFileName);
        if (-1 != dwAttributes && (dwAttributes & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
        {
            if (SetFileAttributes(pszFileName, dwAttributes  & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
            {
                res = DeleteFile(pszFileName);
            }
        }
    }

    if (res && s_dwThreadIDSuspendNotify != GetCurrentThreadId())
    {
        if (pidlFile)
        {
            SHChangeNotify(SHCNE_DELETE, SHCNF_IDLIST, pidlFile, NULL);
        }
        else
        {
            SHChangeNotify(SHCNE_DELETE, SHCNF_PATH, pszFileName, NULL);
        }
    }

    return res;
}

STDAPI_(BOOL) Win32DeleteFile(LPCTSTR pszFileName)
{
    return Win32DeleteFilePidl(pszFileName, NULL);
}

STDAPI_(BOOL) Win32CreateDirectory(LPCTSTR pszPath, LPSECURITY_ATTRIBUTES lpsa)
{
    BOOL res = CreateDirectory(pszPath, lpsa);

    if (res && s_dwThreadIDSuspendNotify != GetCurrentThreadId())
    {
        SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, pszPath, NULL);
    }

    return res;
}

//
// Some filesystems (like NTFS, perchance) actually pay attention to
// the readonly bit on folders.  So, in order to pretend we're sort of
// FAT and dumb, we clear the attribute before trying to delete the
// directory.
//
STDAPI_(BOOL) Win32RemoveDirectory(LPCTSTR pszDir)
{
    BOOL res = RemoveDirectory(pszDir);

    if (FALSE == res) 
    {
        DWORD dwAttr = GetFileAttributes(pszDir);
        if ((-1 != dwAttr) && (dwAttr & FILE_ATTRIBUTE_READONLY))
        {
            dwAttr &= ~FILE_ATTRIBUTE_READONLY;
            SetFileAttributes(pszDir, dwAttr);
            res = RemoveDirectory(pszDir);
        }
    }
    
    if (res && s_dwThreadIDSuspendNotify != GetCurrentThreadId())
    {
        SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, pszDir, NULL);
    }

    return res;
}

STDAPI_(HANDLE) Win32CreateFile(LPCTSTR pszFileName, DWORD dwAttrib)
{
    HANDLE hFile = CreateFile(pszFileName,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              CREATE_ALWAYS,
                              dwAttrib & FILE_ATTRIBUTE_VALID_FLAGS,
                              NULL);
    if ((INVALID_HANDLE_VALUE != hFile) && (s_dwThreadIDSuspendNotify != GetCurrentThreadId()))
    {
        SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, pszFileName, NULL);
    }

    return hFile;
}

STDAPI_(BOOL) CreateWriteCloseFile(HWND hwnd, LPCTSTR pszFile, void *pData, DWORD cbData)
{
    BOOL bRet;
    HANDLE hfile = Win32CreateFile(pszFile, 0);
    if (hfile != INVALID_HANDLE_VALUE)
    {
        if (cbData)
        {
            DWORD dwBytesWritten;
            WriteFile(hfile, pData, cbData, &dwBytesWritten, 0);
        }
        CloseHandle(hfile);
        bRet = TRUE;
    } 
    else 
    {
        TCHAR szPath[MAX_PATH];

        // ok to truncate (displayed in error message only)
        StringCchCopy(szPath, ARRAYSIZE(szPath), pszFile);
        PathRemoveExtension(szPath);

        SHSysErrorMessageBox(hwnd, NULL, IDS_CANNOTCREATEFILE,
                GetLastError(), PathFindFileName(szPath),
                MB_OK | MB_ICONEXCLAMATION);

        bRet = FALSE;
    }

    return bRet;
}

#undef SHGetProcessDword
STDAPI_(DWORD) SHGetProcessDword(DWORD idProcess, LONG iIndex)
{
    return 0;
}

STDAPI_(BOOL) SHSetShellWindowEx(HWND hwnd, HWND hwndChild)
{
    return SetShellWindowEx(hwnd, hwndChild);
}

#define ISEXETSAWARE_MAX_IMAGESIZE  (4 * 1024) // allocate at most a 4k block to hold the image header (eg 1 page on x86)

//
// this is a function that takes a full path to an executable and returns whether or not
// the exe has the TS_AWARE bit set in the image header
//
STDAPI_(BOOL) IsExeTSAware(LPCTSTR pszExe)
{
    BOOL bRet = FALSE;
    HANDLE hFile = CreateFile(pszExe,
                              GENERIC_READ, 
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING, 
                              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        DWORD cbImageSize = GetFileSize(hFile, NULL);
        LPBYTE pBuffer;
        
        if (cbImageSize > ISEXETSAWARE_MAX_IMAGESIZE)
        {
            // 4k should be enough to get the image header for everything...
            cbImageSize = ISEXETSAWARE_MAX_IMAGESIZE;
        }

        pBuffer = LocalAlloc(LPTR, cbImageSize);

        if (pBuffer)
        {
            HANDLE hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY | SEC_IMAGE, 0, cbImageSize, NULL);

            if (hMap)
            {
                // map the first 4k of the file in
                LPBYTE pFileMapping = (LPBYTE)MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, cbImageSize);

                if (pFileMapping) 
                {
                    _try
                    {
                        memcpy(pBuffer, pFileMapping, cbImageSize);
                    }
                    _except(UnhandledExceptionFilter(GetExceptionInformation()))
                    {
                        // We hit an exception while copying! doh!
                        LocalFree(pBuffer);
                        pBuffer = NULL;
                    }
                    
                    UnmapViewOfFile(pFileMapping);
                }
                else
                {
                    LocalFree(pBuffer);
                    pBuffer = NULL;
                }

                CloseHandle(hMap);
            }
            else
            {
                LocalFree(pBuffer);
                pBuffer = NULL;
            }

            if (pBuffer)
            {
                PIMAGE_NT_HEADERS pImageNTHeader;

                // NOTE: this should work ok for 64-bit images too, since both the IMAGE_NT_HEADERS and the IMAGE_NT_HEADERS64
                // structs have a ->Signature and ->OptionalHeader that is identical up to the DllCharacteristics offset.
                pImageNTHeader = RtlImageNtHeader(pBuffer);

                if (pImageNTHeader)
                {
                    if (pImageNTHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE)
                    {
                        // yes, this is a TSAWARE executable!
                        bRet = TRUE;
                    }
                }

                LocalFree(pBuffer);
            }
        }

        CloseHandle(hFile);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\os.h ===
//
//  wrappers around Kernel API's that generate FS notification messages.
//
STDAPI_(BOOL) SHMoveFile(LPCTSTR pszExisting, LPCTSTR pszNew, LONG lEvent);
STDAPI_(BOOL) CreateWriteCloseFile(HWND hwnd, LPCTSTR pszFileName, void *pData, DWORD cbData);

STDAPI_(BOOL) Win32MoveFile(LPCTSTR pszExisting, LPCTSTR pszNew, BOOL fDir);
STDAPI_(BOOL) Win32CreateDirectory(LPCTSTR pszPath, LPSECURITY_ATTRIBUTES lpsa);
STDAPI_(BOOL) Win32RemoveDirectory(LPCTSTR pszDir);
STDAPI_(BOOL) Win32DeleteFile(LPCTSTR pszFileName);
STDAPI_(BOOL) Win32DeleteFilePidl(LPCTSTR pszFileName, LPCITEMIDLIST pidlFile);
STDAPI_(HANDLE) Win32CreateFile(LPCTSTR pszFileName, DWORD dwAttrib);


STDAPI_(BOOL) SuspendSHNotify();
STDAPI_(BOOL) ResumeSHNotify();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\pchcpp.h ===
#define NO_INCLUDE_UNION

#include "shellprv.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ovrlaymn.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: overlayMN.cpp
//
// This file contains the implementation of CFSIconOverlayManager, a COM object
// that manages the IShellIconOverlayIdentifiers list.
// It aslo managess the Sytem Image List OverlayIndexes, since we have limited slots,
// exactly MAX_OVERLAY_IAMGES of them. 
// History:
//         5-2-97  by dli
//------------------------------------------------------------------------
#include "shellprv.h"
#include "ovrlaymn.h"
#include "fstreex.h"
#include "filetbl.h"
extern "C" {
#include "cstrings.h"
#include "ole2dup.h"
}


extern "C" UINT const c_SystemImageListIndexes[];
extern int g_lrFlags;

// NOTE: The value of OVERLAYINDEX_RESERVED is not the same as the overall
// size of the s_ReservedOverlays array, we need to reserved the overlay slot
// #3 for the non-existent Read-Only overaly.
// The Read Only overlay was once there in Win95, but got turned off on IE4
// however, because of the of the original overlay designs,( we used to
// assign overlay 1 to share and 2 to link and 3 to readonly, and the third parties
// just copied our scheme,) we have to keep overlay #3 as a ghost. 
#define OVERLAYINDEX_RESERVED 4

typedef struct _ReservedIconOverlay
{
    int iShellResvrdImageIndex;
    int iImageIndex;
    int iOverlayIndex;
    int iPriority;
} ReservedIconOverlay;

static ReservedIconOverlay s_ReservedOverlays[] = {
    {II_SHARE, II_SHARE, 1, 10}, 
    {II_LINK, II_LINK, 2, 10},
    // Slot 3 should be reserved as a ghost slot because of the read-only overlay
    {II_SLOWFILE, II_SLOWFILE, 4, 10},
};
    
// File system Icon overlay Identifiers
typedef struct _FSIconOverlay {
    IShellIconOverlayIdentifier * psioi;  
    CLSID clsid;
    int iIconIndex;                          // Index of the Overlay Icon in szIconFile
    int iImageIndex;                         // System Image List index of the icon overlay image
    int iOverlayIndex;
    int iPriority;
    TCHAR szIconFile[MAX_PATH];              // Path of the icon overlay
} FSIconOverlay;

#define FSIconOverlay_GROW 3
#define DSA_LAST    0x7fffffff
#define MAX_OVERLAY_PRIORITY  100
class CFSIconOverlayManager : public IShellIconOverlayManager
{
public:
    CFSIconOverlayManager();
    ~CFSIconOverlayManager();
    
    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellIconOverlay Methods
    virtual STDMETHODIMP GetFileOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwFlags);
    virtual STDMETHODIMP GetReservedOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwFlags, int iReservedID);
    virtual STDMETHODIMP RefreshOverlayImages(DWORD dwFlags);
    virtual STDMETHODIMP LoadNonloadedOverlayIdentifiers(void);
    virtual STDMETHODIMP OverlayIndexFromImageIndex(int iImage, int * piIndex, BOOL fAdd);
                                             
    // *** Public Methods

    // *** Static Methods
    static HRESULT CreateInstance(IUnknown* pUnkOuter, REFIID riid, OUT LPVOID * ppvOut);

protected:
    
    // IUnknown 
    LONG _cRef;
    HDSA _hdsaIconOverlays;      // Icon Overlay Identifiers array, this list is ordered by the IOIs' priority
    HRESULT _InitializeHdsaIconOverlays(); // Initialize the Icon Overlay Identifiers array
    HRESULT _DestroyHdsaIconOverlays();
    int     _GetImageIndex(FSIconOverlay * pfsio);
    FSIconOverlay * _FindMatchingID(LPCWSTR pwszPath, DWORD dwAttrib, int iMinPriority, int * pIOverlayIndex);
    HRESULT _SetGetOverlayInfo(FSIconOverlay * pfsio, int iOverlayIndex, int * pIndex, DWORD dwFlags);
    HRESULT _InitializeReservedOverlays();
    HRESULT _LoadIconOverlayIdentifiers(HDSA hdsaOverlays, BOOL bSkipIfLoaded);

    BOOL _IsIdentifierLoaded(REFCLSID clsid);
//    int  _GetAvailableOverlayIndex(int imyhdsa);
//    HRESULT _SortIOIList();      // Sort the IOI's in the list according to their priority
}; 


HRESULT CFSIconOverlayManager::RefreshOverlayImages(DWORD dwFlags)
{
    ENTERCRITICAL;

    _InitializeReservedOverlays();

    if (dwFlags && _hdsaIconOverlays)
    {
        for (int ihdsa = 0; ihdsa < DSA_GetItemCount(_hdsaIconOverlays); ihdsa++)
        {
            FSIconOverlay * pfsio = (FSIconOverlay *)DSA_GetItemPtr(_hdsaIconOverlays, ihdsa);
            if (dwFlags & SIOM_ICONINDEX)
                pfsio->iImageIndex = -1;
            if (dwFlags & SIOM_OVERLAYINDEX)
                pfsio->iOverlayIndex = -1;
        }
    }

    LEAVECRITICAL;
    return S_OK;
}


HRESULT CFSIconOverlayManager::OverlayIndexFromImageIndex(int iImage, int * piIndex, BOOL fAdd)
{
    HRESULT hres = E_FAIL;
    *piIndex = -1;
    int i;
    for (i = 0; i < ARRAYSIZE(s_ReservedOverlays); i++)
    {
        if (s_ReservedOverlays[i].iImageIndex == iImage)
        {
            *piIndex = s_ReservedOverlays[i].iOverlayIndex;
            hres = S_OK;
            break;
        }
    }

    if (i == ARRAYSIZE(s_ReservedOverlays))
    {
        ENTERCRITICAL;

        if (_hdsaIconOverlays)
        {
            int nOverlays = DSA_GetItemCount(_hdsaIconOverlays);

            // 1. Try to find this overlay image in the list 
            int i;
            for (i = 0; i < nOverlays; i++)
            {
                FSIconOverlay * pfsio = (FSIconOverlay *)DSA_GetItemPtr(_hdsaIconOverlays, i);
                if (pfsio && pfsio->iImageIndex == iImage)
                {
                    *piIndex = pfsio->iOverlayIndex;
                    hres = S_OK;
                    break;
                }
            }

            // 2. Can't find it, let's add it (if requested)
            if (fAdd && (i == nOverlays) && (nOverlays < NUM_OVERLAY_IMAGES))
            {
                FSIconOverlay fsio = {0};
                fsio.iImageIndex = iImage;
                fsio.iOverlayIndex = nOverlays + OVERLAYINDEX_RESERVED + 1;
                if (DSA_InsertItem(_hdsaIconOverlays, DSA_LAST, &fsio) >= 0)
                {
                    hres = S_OK;
                    for (int j = 0; j < ARRAYSIZE(g_rgshil); j++)
                    {
                        if (!ImageList_SetOverlayImage(g_rgshil[j].himl, iImage, fsio.iOverlayIndex))
                        {
                            hres = E_FAIL;
                            break;
                        }
                    }

                    if (SUCCEEDED(hres))
                    {
                        *piIndex = fsio.iOverlayIndex;
                    }
                    else
                    {
                        DSA_DeleteItem(_hdsaIconOverlays, nOverlays);
                    }
                }
            }
        }
        LEAVECRITICAL;
    }
    return hres;
}


HRESULT CFSIconOverlayManager::_InitializeReservedOverlays()
{
    int i;
    TCHAR szModule[MAX_PATH];

    BOOL fInit = _IsSHILInited();
    if (!fInit)
        fInit = FileIconInit(FALSE);

    if (!fInit)
        return E_OUTOFMEMORY;

    HKEY hkeyIcons = SHGetShellKey(SHELLKEY_HKLM_EXPLORER, TEXT("Shell Icons"), FALSE);
        
    GetModuleFileName(HINST_THISDLL, szModule, ARRAYSIZE(szModule));

    for (i = 0; i < ARRAYSIZE(s_ReservedOverlays); i++)
    {
        ASSERT(s_ReservedOverlays[i].iShellResvrdImageIndex > 0);
        ASSERT(s_ReservedOverlays[i].iOverlayIndex > 0);
        ASSERT(s_ReservedOverlays[i].iOverlayIndex <= MAX_OVERLAY_IMAGES);
        
        //
        // Warning: This is used by non explorer processes on NT only
        // because their image list was initialized with only 4 icons
        //
        int iIndex = s_ReservedOverlays[i].iShellResvrdImageIndex;

        // re-acquire the image index
        s_ReservedOverlays[i].iImageIndex = LookupIconIndex(szModule, iIndex, 0);

        if (s_ReservedOverlays[i].iImageIndex == -1)
        {
            HICON rghicon[ARRAYSIZE(g_rgshil)] = {0};

            // check to see if icon is overridden in the registry
            if (hkeyIcons)
            {
                TCHAR val[12];
                TCHAR ach[MAX_PATH];
                DWORD cb = SIZEOF(ach);
                HRESULT hr;

                hr = StringCchPrintf(val, ARRAYSIZE(val), TEXT("%d"), iIndex);  // ok to truncate

                ach[0] = 0;
                SHQueryValueEx(hkeyIcons, val, NULL, NULL, (LPBYTE)ach, &cb);

                if (ach[0])
                {
                    int iIcon = PathParseIconLocation(ach);

                    for (int j = 0; j < ARRAYSIZE(rghicon); j++)
                    {
                        ExtractIcons(ach, iIcon, g_rgshil[j].size.cx, g_rgshil[j].size.cy,
                                        &rghicon[j], NULL, 1, g_lrFlags);
                    }
                }
            }

            // if we got a large icon, run with that for everyone.  otherwise fall back to loadimage.
            if (rghicon[SHIL_LARGE] == NULL)
            {
                for (int j = 0; j < ARRAYSIZE(g_rgshil); j++)
                {
                    if (rghicon[j] == NULL)
                    {
                        rghicon[j] = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(c_SystemImageListIndexes[iIndex]),
                                        IMAGE_ICON, g_rgshil[j].size.cx, g_rgshil[j].size.cy, g_lrFlags);
                    }
                }
            }

            s_ReservedOverlays[i].iImageIndex = SHAddIconsToCache(rghicon, szModule, iIndex, 0);

            _DestroyIcons(rghicon, ARRAYSIZE(rghicon));
        }
        for (int j = 0; j < ARRAYSIZE(g_rgshil); j++)
        {
            ImageList_SetOverlayImage(g_rgshil[j].himl, s_ReservedOverlays[i].iImageIndex, s_ReservedOverlays[i].iOverlayIndex);
        }
    }

    if (hkeyIcons)
        RegCloseKey(hkeyIcons);
        
    return S_OK;
}

//===========================================================================
// Initialize the IShellIconOverlayIdentifiers 
//===========================================================================
HRESULT CFSIconOverlayManager::_InitializeHdsaIconOverlays() 
{
    HRESULT hres = S_FALSE; // Already initialized.

    if (NULL == _hdsaIconOverlays)
    {
        hres = _InitializeReservedOverlays();
        if (SUCCEEDED(hres))
        {
            _hdsaIconOverlays = DSA_Create(SIZEOF(FSIconOverlay), FSIconOverlay_GROW);

            if(NULL != _hdsaIconOverlays)
            {
                hres = _LoadIconOverlayIdentifiers(_hdsaIconOverlays, FALSE);
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }
        }
    }
    return hres;
}



HRESULT CFSIconOverlayManager::LoadNonloadedOverlayIdentifiers(void)
{
    HRESULT hres;

    ENTERCRITICAL;

    if (NULL == _hdsaIconOverlays)
    {
        //
        // No overlay HDSA yet.  We should never hit this but just in case,
        // this will be valid behavior.
        //
        hres = _InitializeHdsaIconOverlays();
    }
    else
    {
        //
        // Load unloaded identifiers into existing HDSA.
        //
        hres = _LoadIconOverlayIdentifiers(_hdsaIconOverlays, TRUE);
    }

    LEAVECRITICAL;
    return hres;
}


HRESULT CFSIconOverlayManager::_LoadIconOverlayIdentifiers(HDSA hdsaOverlays, BOOL bSkipIfLoaded)
{
    ASSERT(NULL != hdsaOverlays);

    HDCA hdca = DCA_Create();
    if (!hdca)
        return E_OUTOFMEMORY;

    HRESULT hrInit = SHCoInitialize();

    // Enumerate all of the Icon Identifiers in
    DCA_AddItemsFromKey(hdca, HKEY_LOCAL_MACHINE, REGSTR_ICONOVERLAYID);
    if (DCA_GetItemCount(hdca) <= 0)
        goto EXIT;

    int idca;
    for (idca = 0; idca < DCA_GetItemCount(hdca); idca++)
    {
        const CLSID * pclsid = DCA_GetItem(hdca, idca);

        if (bSkipIfLoaded && _IsIdentifierLoaded(*pclsid))
            continue;

        FSIconOverlay fsio;
        ZeroMemory(&fsio, sizeof(fsio));
        // These came from HKLM which only administrators can write to,
        // so don't need to go through administrator approval
        if (FAILED(DCA_CreateInstance(hdca, idca, IID_PPV_ARG(IShellIconOverlayIdentifier, &fsio.psioi))))
            continue;       

        SHPinDllOfCLSID(pclsid);
        
        DWORD dwFlags = 0;
        int iIndex;
        WCHAR wszIconFile[MAX_PATH];
        // Initialize the Overlay Index to -1
        fsio.iOverlayIndex = -1;

        // Try get the overlay icon information from the Overlay Identifiers 
        if (S_OK == fsio.psioi->GetOverlayInfo(wszIconFile, ARRAYSIZE(wszIconFile), &iIndex, &dwFlags))
        {
            if (dwFlags & ISIOI_ICONFILE)
            {
                SHUnicodeToTChar(wszIconFile, fsio.szIconFile, ARRAYSIZE(fsio.szIconFile));
                fsio.iImageIndex = -1;
                if (dwFlags & ISIOI_ICONINDEX)
                    fsio.iIconIndex = iIndex;
                else
                    fsio.iIconIndex = 0;
            }

            if (FAILED(fsio.psioi->GetPriority(&fsio.iPriority)))
                fsio.iPriority = MAX_OVERLAY_PRIORITY;

            CopyMemory(&fsio.clsid, pclsid, sizeof(fsio.clsid));
            DSA_InsertItem(hdsaOverlays, DSA_LAST, &fsio);
        }
        // Now try to look in the registry for the Overlay Icons 
        else
        {
            fsio.iImageIndex = -1;
            const CLSID * pclsid = DCA_GetItem(hdca, idca);
            if (pclsid)
            {
                TCHAR szCLSID[GUIDSTR_MAX];
                TCHAR szRegKey[GUIDSTR_MAX + 40];
                HKEY hkeyIcon;
                HRESULT hr;
                SHStringFromGUID(*pclsid, szCLSID, ARRAYSIZE(szCLSID));

                hr = StringCchPrintf(szRegKey, ARRAYSIZE(szRegKey), REGSTR_ICONOVERLAYCLSID, szCLSID);
                if (SUCCEEDED(hr))
                {
                    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szRegKey, 0, KEY_QUERY_VALUE, &hkeyIcon))
                    {
                        if (ERROR_SUCCESS == SHRegGetString(hkeyIcon, NULL, c_szDefaultIcon, fsio.szIconFile, ARRAYSIZE(fsio.szIconFile))
                            && fsio.szIconFile[0])
                        {
                            fsio.iIconIndex = PathParseIconLocation(fsio.szIconFile);
                            CopyMemory(&fsio.clsid, pclsid, sizeof(fsio.clsid));
                            DSA_InsertItem(hdsaOverlays, DSA_LAST, &fsio);
                        }

                        // Unfinished !!! Code to retrieve the priority here
                        fsio.iPriority = MAX_OVERLAY_PRIORITY;
                        RegCloseKey(hkeyIcon);
                    }
                }
            }
        }

        // Stop when we have more than we can handle
        if (DSA_GetItemCount(hdsaOverlays) >= (MAX_OVERLAY_IMAGES - OVERLAYINDEX_RESERVED))
            break;
    }
    
EXIT:
    DCA_Destroy(hdca);
    SHCoUninitialize(hrInit);
    return S_OK;
}
     

BOOL CFSIconOverlayManager::_IsIdentifierLoaded(REFCLSID clsid)
{
    if (NULL != _hdsaIconOverlays)
    {
        int cEntries = DSA_GetItemCount(_hdsaIconOverlays);
        for (int i = 0; i < cEntries; i++)
        {
            FSIconOverlay *pfsio = (FSIconOverlay *)DSA_GetItemPtr(_hdsaIconOverlays, i);            
            if (pfsio->clsid == clsid)
                return TRUE;
        }
    }
    return FALSE;
}


CFSIconOverlayManager::CFSIconOverlayManager() : _cRef(1) // _hdsaIconOverlays(NULL)
{
}

HRESULT CFSIconOverlayManager::_DestroyHdsaIconOverlays()
{
    if (_hdsaIconOverlays)
    {
        DSA_Destroy(_hdsaIconOverlays);
    }
    
    return S_OK;
}

CFSIconOverlayManager::~CFSIconOverlayManager()
{
    if (_hdsaIconOverlays)
        _DestroyHdsaIconOverlays();

}

//
// CFSFolder_GetAvailableOverlayIndex:
// This function first tries to find an empty slot in all the available overlay indexes
// If none found, it goes through the _hdsaIconOverlays array elements who have lower
// priorities and grab their overlay indexes if they are using one
//
/*int CFSIconOverlayManager::_GetAvailableOverlayIndex(int imyhdsa)
{
    int ib;
    for (ib = 0; ib < MAX_OVERLAY_IMAGES; ib++)
        if (_bOverlayIndexOccupied[ib] == FALSE)
            break;

    // Add code to grab indexes here.
    return ++ib;
}*/

HRESULT CFSIconOverlayManager::QueryInterface(REFIID riid, LPVOID * ppvObj)
{ 
    // ppvObj must not be NULL
    ASSERT(ppvObj != NULL);
    
    if (IsEqualIID(riid, IID_IUnknown))
    {    
        *ppvObj = SAFECAST(this, IUnknown *);
        DebugMsg(DM_TRACE, TEXT("QI IUnknown succeeded"));
    }
    else if (IsEqualIID(riid, IID_IShellIconOverlayManager))
    {
        *ppvObj = SAFECAST(this, IShellIconOverlayManager*);
        DebugMsg(DM_TRACE, TEXT("QI IShellIconOverlayManager succeeded"));
    } 
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;  // Otherwise, don't delegate to HTMLObj!!
    }
    
    AddRef();
    return S_OK;
}


ULONG CFSIconOverlayManager::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFSIconOverlayManager::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

int CFSIconOverlayManager::_GetImageIndex(FSIconOverlay * pfsio)
{
    int iImage = LookupIconIndex(pfsio->szIconFile, pfsio->iIconIndex, GIL_FORSHELL);

    if (iImage == -1)
    {
        // we couldn't find it from the cache
        HICON rghicon[ARRAYSIZE(g_rgshil)] = {0};

        for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
        {
            SHDefExtractIcon(pfsio->szIconFile, pfsio->iIconIndex, GIL_FORSHELL, &rghicon[i],
                             NULL, g_rgshil[i].size.cx);
        }

        iImage = SHAddIconsToCache(rghicon, pfsio->szIconFile, pfsio->iIconIndex, GIL_FORSHELL);

        _DestroyIcons(rghicon, ARRAYSIZE(rghicon));
    }
    
    return iImage;
}

FSIconOverlay * CFSIconOverlayManager::_FindMatchingID(LPCWSTR pwszPath, DWORD dwAttrib, int iMinPriority, int * pIOverlayIndex)
{
    // If we got here, we must have the DSA array
    ASSERT(_hdsaIconOverlays);
    if (_hdsaIconOverlays)
    {
        int ihdsa;
        for (ihdsa = 0; ihdsa < DSA_GetItemCount(_hdsaIconOverlays); ihdsa++)
        {
            FSIconOverlay * pfsio = (FSIconOverlay *)DSA_GetItemPtr(_hdsaIconOverlays, ihdsa);
            ASSERT(pfsio);
            if (pfsio->iPriority >= iMinPriority)
                continue;
            if (pfsio->psioi && pfsio->psioi->IsMemberOf(pwszPath, dwAttrib) == S_OK)
            {
                // Overlay indexes start from 1, and let's not use the reserved ones
                ASSERT(pIOverlayIndex);
                *pIOverlayIndex = ihdsa + OVERLAYINDEX_RESERVED + 1; 
                return pfsio;
            }
        }
    }
    return NULL;
}

HRESULT CFSIconOverlayManager::_SetGetOverlayInfo(FSIconOverlay * pfsio, int iOverlayIndex, int * pIndex, DWORD dwFlags)
{
    HRESULT hres = E_FAIL;
    RIP(pIndex);
    *pIndex = -1;

    if (pfsio->iImageIndex == -1)
    {
        int iImage = _GetImageIndex(pfsio);

        // Either we couldn't get it or we couldn't put it in cache 
        if (iImage == -1)
        {
            // leave this as a zombie
            pfsio->iImageIndex = 0;
            pfsio->iOverlayIndex = 0;
        }
        else
            pfsio->iImageIndex = iImage;
    }

    // Only if we have a reasonable image index will we proceed. 
    if (pfsio->iImageIndex > 0)
    {
        if (dwFlags == SIOM_ICONINDEX)
        {
            *pIndex = pfsio->iImageIndex;
        }
        else
        {
            ASSERT(iOverlayIndex > 0);
            ASSERT(iOverlayIndex <= MAX_OVERLAY_IMAGES);
            if (pfsio->iOverlayIndex == -1)
            {
                // Now set the overlay
                ASSERT(_IsSHILInited());

                for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
                {
                    ImageList_SetOverlayImage(g_rgshil[i].himl, pfsio->iImageIndex, iOverlayIndex);
                }

                pfsio->iOverlayIndex = iOverlayIndex;
            }

            // Must be the overlayindex flag
            ASSERT(dwFlags == SIOM_OVERLAYINDEX);
            *pIndex = pfsio->iOverlayIndex;
        }
        hres = S_OK;

    }
    return hres;
}

HRESULT CFSIconOverlayManager::GetFileOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwFlags)
{
    ASSERT((dwFlags == SIOM_OVERLAYINDEX) || (dwFlags == SIOM_ICONINDEX)); // || (dwFlags == SIOM_PRIORITY));

    HRESULT hres = E_FAIL;
    int iOverlayIndex;
    *pIndex = 0;

    ENTERCRITICAL;
    if (_hdsaIconOverlays)
    {
        FSIconOverlay * pfsio = _FindMatchingID(pwszPath, dwAttrib, MAX_OVERLAY_PRIORITY, &iOverlayIndex);
        if (pfsio)
            hres = _SetGetOverlayInfo(pfsio, iOverlayIndex, pIndex, dwFlags);
    }
    LEAVECRITICAL;
    return hres;
}

HRESULT CFSIconOverlayManager::GetReservedOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwFlags, int iReservedID)
{
    ASSERT(iReservedID < OVERLAYINDEX_RESERVED);
    HRESULT hres = S_OK;

    ENTERCRITICAL;
    if (_hdsaIconOverlays && pwszPath)
    {
        int iOverlayIndex;
        FSIconOverlay * pfsio = _FindMatchingID(pwszPath, dwAttrib, s_ReservedOverlays[iReservedID].iPriority, &iOverlayIndex);
        if (pfsio)
        {
            hres = _SetGetOverlayInfo(pfsio, iOverlayIndex, pIndex, dwFlags);
            LEAVECRITICAL;
            return hres;
        }
    }
    
    if (dwFlags == SIOM_ICONINDEX)
        *pIndex =  s_ReservedOverlays[iReservedID].iImageIndex;
    else
    {
        ASSERT(dwFlags == SIOM_OVERLAYINDEX);
        *pIndex =  s_ReservedOverlays[iReservedID].iOverlayIndex;
    }
    LEAVECRITICAL;

    return hres;
}


HRESULT CFSIconOverlayManager::CreateInstance(IUnknown* pUnkOuter, REFIID riid, OUT LPVOID * ppvOut)
{
    HRESULT hr;
    
    DebugMsg(DM_TRACE, TEXT("CFSIconOverlayManager::CreateInstance()"));
    
    *ppvOut = NULL;                     // null the out param

    CFSIconOverlayManager *pcfsiom = new CFSIconOverlayManager;

    if (!pcfsiom)
        return E_OUTOFMEMORY;

    hr = pcfsiom->_InitializeHdsaIconOverlays();
    if (SUCCEEDED(hr))
        hr = pcfsiom->QueryInterface(riid, ppvOut);
    pcfsiom->Release();

    return hr;
}


STDAPI CFSIconOverlayManager_CreateInstance(IUnknown* pUnkOuter, REFIID riid, OUT LPVOID *  ppvOut)
{
    return CFSIconOverlayManager::CreateInstance(pUnkOuter, riid, ppvOut);
}

STDAPI_(int) SHGetIconOverlayIndexW(LPCWSTR pwszIconPath, int iIconIndex)
{

    TCHAR szIconPath[MAX_PATH];
    int iRet = -1;
    int iImage = -1;

    // If NULL path is passed in, see if the index matches one of our special indexes
    if (pwszIconPath == NULL)
    {
        switch (iIconIndex)
        {
            case IDO_SHGIOI_SHARE:
                iImage = s_ReservedOverlays[0].iImageIndex;
                break;
            case IDO_SHGIOI_LINK:
                iImage = s_ReservedOverlays[1].iImageIndex;
                break;
            case IDO_SHGIOI_SLOWFILE:
                iImage = s_ReservedOverlays[2].iImageIndex;
                break;
        }
    }
    else if (SHUnicodeToTChar(pwszIconPath, szIconPath, ARRAYSIZE(szIconPath)))        
            // Try to load the image into the shell icon cache            
            iImage = Shell_GetCachedImageIndex(szIconPath, iIconIndex, 0);
    
    if (iImage >= 0)
    {
        IShellIconOverlayManager *psiom;
        if (SUCCEEDED(GetIconOverlayManager(&psiom)))
        {
            int iCandidate = -1;
            if (SUCCEEDED(psiom->OverlayIndexFromImageIndex(iImage, &iCandidate, TRUE)))
            {
                iRet = iCandidate;
            }
            psiom->Release();
        }
    }
    
    return iRet;
}

STDAPI_(int) SHGetIconOverlayIndexA(LPCSTR pszIconPath, int iIconIndex)
{
    int iRet = -1;
    WCHAR wszIconPath[MAX_PATH];
    LPCWSTR pwszIconPath = NULL;
    if (pszIconPath)
    {
        wszIconPath[0] = L'\0';
        SHAnsiToUnicode(pszIconPath, wszIconPath, ARRAYSIZE(wszIconPath));
        pwszIconPath = wszIconPath;
    }
    
    return  SHGetIconOverlayIndexW(pwszIconPath, iIconIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\pchcpp.cpp ===
#include "pchcpp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\pidl.h ===
// no one should know what is in this file. this data is private to the folders
 
#ifndef _PIDL_H_
#define _PIDL_H_

#include <idhidden.h>
#include <lmcons.h> // UNLEN

// CRegFolder pidl
#pragma pack(1)
typedef struct
{
    WORD    cb;
    BYTE    bFlags;
    BYTE    bOrder;
    CLSID   clsid;
} IDREGITEM;
typedef UNALIGNED IDREGITEM *LPIDREGITEM;
typedef const UNALIGNED IDREGITEM *LPCIDREGITEM;
#pragma pack()

// CFSFolder pidl
typedef struct
{
    WORD        cb;                     // pidl size
    BYTE        bFlags;                 // SHID_FS_* bits
    DWORD       dwSize;                 // -1 implies > 4GB, hit the disk to get the real size
    WORD        dateModified;
    WORD        timeModified;
    WORD        wAttrs;                 // FILE_ATTRIBUTES_* cliped to 16bits
    CHAR        cFileName[MAX_PATH];    // this is WCHAR for names that don't round trip
    CHAR        cAltFileName[8+1+3+1];  // ANSI version of cFileName (some chars not converted)
} IDFOLDER;
typedef UNALIGNED IDFOLDER *LPIDFOLDER;
typedef const UNALIGNED IDFOLDER *LPCIDFOLDER;

// IDList factory
#pragma pack(1)
typedef struct
{
    WORD wDate;
    WORD wTime;
} DOSSTAMP;

typedef struct
{
    HIDDENITEMID hid;
    DOSSTAMP dsCreate;
    DOSSTAMP dsAccess;
    WORD offNameW;
    WORD offResourceA;   //  ascii
} IDFOLDEREX;   // IDLHID_IDFOLDEREX

typedef struct
{
    HIDDENITEMID hid;
    WCHAR szUserName[UNLEN];
} IDPERSONALIZED;   // IDLHID_PERSONALIZED

#pragma pack()

typedef UNALIGNED IDFOLDEREX *PIDFOLDEREX;
typedef const UNALIGNED IDFOLDEREX *PCIDFOLDEREX;

typedef UNALIGNED IDPERSONALIZED *PIDPERSONALIZED;
typedef const UNALIGNED IDPERSONALIZED *PCIDPERSONALIZED;

#define IDFXF_PERSONALIZED  0x0001
#define IDFXF_USELOOKASIDE  0x8000

//  rev the version when ever we change IDFOLDEREX
#define IDFX_V1    0x0003
#define IDFX_CV    IDFX_V1

// End of hidden data for IDFOLDER

#pragma pack(1)
typedef struct
{
    WORD    cb;
    BYTE    bFlags;
    CHAR    cName[4];
    ULONGLONG qwSize;  // this is a "guess" at the disk size and free space
    ULONGLONG qwFree;
    WORD    wSig;
    CLSID   clsid;
} IDDRIVE;
typedef const UNALIGNED IDDRIVE *LPCIDDRIVE;
typedef UNALIGNED IDDRIVE *LPIDDRIVE;
#pragma pack()

// wSig usage
// we dont have much space in the word, so the first byte is an ordinal representing what
// kind of pidl extension were doing
// the second byte is flags pertaining to that ordinal
#define IDDRIVE_ORDINAL_MASK            0xFF00
#define IDDRIVE_FLAGS_MASK              0x00FF

#define IDDRIVE_ORDINAL_DRIVEEXT        0x0100
#define IDDRIVE_FLAGS_DRIVEEXT_HASCLSID 0x0001

typedef struct
{
    IDDRIVE idd;
    USHORT  cbNext;
} DRIVE_IDLIST;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\pickicon.c ===
#include "shellprv.h"
#pragma  hdrstop

#define MAX_ICONS   500             // that is a lot 'o icons

#define CX_BORDER    4
#define CY_BORDER    12

typedef struct {
    LPCTSTR pszDialogTitle;           // input
    BOOL    bShowRestoreButton;       // input
    LPTSTR pszIconPath;              // input/output
    int cchIconPath;                 // input
    int iIconIndex;                 // input/output
    // private state variables
    HWND hDlg;
    BOOL fFirstPass;
    TCHAR szPathField[MAX_PATH];
    TCHAR szBuffer[MAX_PATH];
} PICKICON_DATA, *LPPICKICON_DATA;


typedef struct 
{
    int iResult;                    // icon index within the resources
    int iResId;                     // resource ID to search for!
} ICONENUMSTATE, *LPICONENUMSTATE;


// Call back function used when trying to find the correct icon to be 
// highlighted, called with the name of each resource - we compare this
// against the one specified in the structure and bail out if we get
// a match.

BOOL CALLBACK IconEnumProc( HANDLE hModule, LPCTSTR lpszType, LPTSTR lpszName, LONG_PTR lParam )
{
    LPICONENUMSTATE pState = (LPICONENUMSTATE)lParam;

    if ( (INT_PTR)lpszName == pState->iResId )
        return FALSE;                        // bail out of enum loop

    pState->iResult++;
    return TRUE;
}




// Checks if the file exists, if it doesn't it tries tagging on .exe and
// if that fails it reports an error. The given path is environment expanded.
// If it needs to put up an error box, it changes the cursor back.
// Path s assumed to be MAXITEMPATHLEN long.
// The main reason for moving this out of the DlgProc was because we're
// running out of stack space on the call to the comm dlg.

BOOL IconFileExists(LPPICKICON_DATA lppid)
{
    TCHAR szExpBuffer[ ARRAYSIZE(lppid->szBuffer) ];

    if (lppid->szBuffer[0] == 0)
        return FALSE;

    if (SHExpandEnvironmentStrings(lppid->szBuffer, szExpBuffer, ARRAYSIZE(szExpBuffer)))
    {
        PathUnquoteSpaces(lppid->szBuffer);
        PathUnquoteSpaces(szExpBuffer);

        if (PathResolve(szExpBuffer, NULL, PRF_VERIFYEXISTS | PRF_TRYPROGRAMEXTENSIONS))
            return TRUE;

        ShellMessageBox(HINST_THISDLL, lppid->hDlg, MAKEINTRESOURCE(IDS_BADPATHMSG), 0, MB_OK | MB_ICONEXCLAMATION, (LPTSTR)lppid->szPathField);
    }

    return FALSE;
}

//
// GetDefaultIconImageName:
//
void GetDefaultIconImageName(LPTSTR pszBuffer, int cchBuffer)
{
    WCHAR szModName[MAX_PATH];

    GetModuleFileName(HINST_THISDLL, szModName, ARRAYSIZE(szModName));

    if (!PathUnExpandEnvStrings(szModName, pszBuffer, cchBuffer))
    {
        StringCchCopy(pszBuffer, cchBuffer, szModName);
    }
}

void PutIconsInList(LPPICKICON_DATA lppid)
{
    HICON  *rgIcons;
    int  cIcons;
    HWND hDlg = lppid->hDlg;
    DECLAREWAITCURSOR;
    LONG err = LB_ERR;

    SendDlgItemMessage(hDlg, IDD_ICON, LB_RESETCONTENT, 0, 0L);

    GetDlgItemText(hDlg, IDD_PATH, lppid->szPathField, ARRAYSIZE(lppid->szPathField));

    StringCchCopy(lppid->szBuffer, ARRAYSIZE(lppid->szBuffer), lppid->szPathField);

    if (!IconFileExists(lppid)) {
        if (lppid->fFirstPass) {

            // Icon File doesn't exist, use progman
            lppid->fFirstPass = FALSE;  // Only do this bit once.
            GetDefaultIconImageName(lppid->szBuffer, ARRAYSIZE(lppid->szBuffer));
        } else {
            return;
        }
    }

    StringCchCopy(lppid->szPathField, ARRAYSIZE(lppid->szPathField), lppid->szBuffer);
    SetDlgItemText(hDlg, IDD_PATH, lppid->szPathField);

    SetWaitCursor();

    rgIcons = (HICON *)LocalAlloc(LPTR, MAX_ICONS*SIZEOF(HICON));

    if (rgIcons != NULL)
        cIcons = (int)ExtractIconEx(lppid->szBuffer, 0, rgIcons, NULL, MAX_ICONS);
    else
        cIcons = 0;

    ResetWaitCursor();
    if (!cIcons) {

        if (lppid->fFirstPass) {

            lppid->fFirstPass = FALSE;  // Only do this bit once.

            ShellMessageBox(HINST_THISDLL, hDlg, MAKEINTRESOURCE(IDS_NOICONSMSG1), 0, MB_OK | MB_ICONEXCLAMATION, (LPCTSTR)lppid->szBuffer);

            // No icons here - change the path do somewhere where we
            // know there are icons. Get the path to progman.
            GetDefaultIconImageName(lppid->szPathField, ARRAYSIZE(lppid->szPathField));
            SetDlgItemText(hDlg, IDD_PATH, lppid->szPathField);
            PutIconsInList(lppid);
        } else {

            ShellMessageBox(HINST_THISDLL, hDlg, MAKEINTRESOURCE(IDS_NOICONSMSG), 0, MB_OK | MB_ICONEXCLAMATION, (LPCTSTR)lppid->szBuffer);
            return;
        }
    }

    SetWaitCursor();

    SendDlgItemMessage(hDlg, IDD_ICON, WM_SETREDRAW, FALSE, 0L);

    if (rgIcons) {
        int i;
        for (i = 0; i < cIcons; i++) {
            SendDlgItemMessage(hDlg, IDD_ICON, LB_ADDSTRING, 0, (LPARAM)(UINT_PTR)rgIcons[i]);
        }
        LocalFree((HLOCAL)rgIcons);
    }

    // Cope with being given a resource ID, not an index into the icon array.  To do this
    // we must enumerate the icon names checking for a match.  If we have one then highlight
    // that, otherwise default to the first.
    //
    // A resource icon reference is indicated by being passed a -ve iIconIndex.

    if ( lppid->iIconIndex >= 0 )
    {
        err = (LONG) SendDlgItemMessage( hDlg, IDD_ICON, LB_SETCURSEL, lppid->iIconIndex, 0L);
    }
    else
    {
        HMODULE hModule = LoadLibrary(lppid->szBuffer);
        if (hModule)
        {
            ICONENUMSTATE state;

            state.iResult = 0;
            state.iResId = -(lppid->iIconIndex);

            EnumResourceNames( hModule, RT_GROUP_ICON, IconEnumProc, (LONG_PTR)&state );

            err = (LONG) SendDlgItemMessage( hDlg, IDD_ICON, LB_SETCURSEL, state.iResult, 0L );
            FreeLibrary( hModule );
        }
    }

    // Check for failure, if we did then ensure we highlight the first!

    if ( err == LB_ERR )
        SendDlgItemMessage( hDlg, IDD_ICON, LB_SETCURSEL, 0, 0L );
       
    SendDlgItemMessage(hDlg, IDD_ICON, WM_SETREDRAW, TRUE, 0L);
    InvalidateRect(GetDlgItem(hDlg, IDD_ICON), NULL, TRUE);

    ResetWaitCursor();
}


void InitPickIconDlg(HWND hDlg, LPPICKICON_DATA lppid)
{
    RECT rc;
    UINT cy;
    HWND hwndIcons;

    // init state variables

    lppid->hDlg = hDlg;
    StringCchCopy(lppid->szPathField, ARRAYSIZE(lppid->szPathField), lppid->pszIconPath);

    // this first pass stuff is so that the first time something
    // bogus happens (file not found, no icons) we give the user
    // a list of icons from progman.
    lppid->fFirstPass = TRUE;

    // Override the Dialog Title if Set. Else use the default Title defined in the Dialog resource.
    if (lppid->pszDialogTitle && (lppid->pszDialogTitle[0] != TEXT('\0')))
    {
        SetWindowText(hDlg, lppid->pszDialogTitle);
    }

    // Enable or Disable the Restore Default button.
    if (lppid->bShowRestoreButton)
        ShowWindow(GetDlgItem(lppid->hDlg, IDD_RESTORE),SW_SHOW);
    else
        ShowWindow(GetDlgItem(lppid->hDlg, IDD_RESTORE), SW_HIDE);
    

    // init the dialog controls

    SetDlgItemText(hDlg, IDD_PATH, lppid->pszIconPath);

    // Cannot max against 0 because 0 means "no limit"
    SendDlgItemMessage(hDlg, IDD_PATH, EM_LIMITTEXT, max(lppid->cchIconPath-1, 1), 0L);

    SendDlgItemMessage(hDlg, IDD_ICON, LB_SETCOLUMNWIDTH, GetSystemMetrics(SM_CXICON) + CX_BORDER, 0L);

    hwndIcons = GetDlgItem(hDlg, IDD_ICON);

    /* compute the height of the listbox based on icon dimensions */
    GetClientRect(hwndIcons, &rc);

    cy = ((GetSystemMetrics(SM_CYICON) + CY_BORDER) * 4) + 
         GetSystemMetrics(SM_CYHSCROLL) + 
         GetSystemMetrics(SM_CYEDGE) * 3;

    SetWindowPos(hwndIcons, NULL, 0, 0, rc.right, cy, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    SHAutoComplete(GetDlgItem(hDlg, IDD_PATH), 0);

    PutIconsInList(lppid);
}


// call the common browse code for this

BOOL BrowseForIconFile(LPPICKICON_DATA lppid)
{
    TCHAR szTitle[80];

    GetWindowText(lppid->hDlg, szTitle, ARRAYSIZE(szTitle));
    GetDlgItemText(lppid->hDlg, IDD_PATH, lppid->szBuffer, ARRAYSIZE(lppid->szBuffer));

    // We will never be quoted here because IconFileExists() removes quotes (of course user could type them in)
    if (lppid->szBuffer[0] != '"')
        PathQuoteSpaces(lppid->szBuffer);

    if (GetFileNameFromBrowse(lppid->hDlg, lppid->szBuffer, ARRAYSIZE(lppid->szBuffer), NULL, MAKEINTRESOURCE(IDS_ICO), MAKEINTRESOURCE(IDS_ICONSFILTER), szTitle))
    {
        PathQuoteSpaces(lppid->szBuffer);
        SetDlgItemText(lppid->hDlg, IDD_PATH, lppid->szBuffer);
        // Set default button to OK.
        SendMessage(lppid->hDlg, DM_SETDEFID, IDOK, 0);
        return TRUE;
    } else
        return FALSE;
}

// test if the name field is different from the last file we looked at

BOOL NameChange(LPPICKICON_DATA lppid)
{
    GetDlgItemText(lppid->hDlg, IDD_PATH, lppid->szBuffer, ARRAYSIZE(lppid->szBuffer));

    return lstrcmpi(lppid->szBuffer, lppid->szPathField);
}


//
// dialog procedure for picking an icon (ala progman change icon)
// uses DLG_PICKICON template
//
// in:
//      pszIconFile
//      cbIconFile
//      iIndex
//
// out:
//      pszIconFile
//      iIndex
//

BOOL_PTR CALLBACK PickIconDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    LPPICKICON_DATA lppid = (LPPICKICON_DATA)GetWindowLongPtr(hDlg, DWLP_USER);
    DWORD dwOldLayout;

        // Array for context help:

        static const DWORD aPickIconHelpIDs[] = {
                IDD_PATH,   IDH_FCAB_LINK_ICONNAME,
                IDD_ICON,   IDH_FCAB_LINK_CURRENT_ICON,
                IDD_BROWSE, IDH_BROWSE,

                0, 0
        };

    switch (wMsg) {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        InitPickIconDlg(hDlg, (LPPICKICON_DATA)lParam);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDD_BROWSE:
            if (BrowseForIconFile(lppid))
                PutIconsInList(lppid);
            break;

        case IDD_PATH:
            if (NameChange(lppid))
                SendDlgItemMessage(hDlg, IDD_ICON, LB_SETCURSEL, (WPARAM)-1, 0);
            break;

        case IDD_ICON:
            if (NameChange(lppid)) {
                PutIconsInList(lppid);
                break;
            }

            if (GET_WM_COMMAND_CMD(wParam, lParam) != LBN_DBLCLK)
                break;

            /*** FALL THRU on double click ***/

        case IDOK:

            if (NameChange(lppid)) {
                PutIconsInList(lppid);
            } else {
                int iIconIndex = (int)SendDlgItemMessage(hDlg, IDD_ICON, LB_GETCURSEL, 0, 0L);
                if (iIconIndex < 0)
                    iIconIndex = 0;
                lppid->iIconIndex = iIconIndex;
                StringCchCopy(lppid->pszIconPath, lppid->cchIconPath, lppid->szPathField);

                EndDialog(hDlg, S_OK);
            }
            break;

        case IDCANCEL:
            EndDialog(hDlg, HRESULT_FROM_WIN32(ERROR_CANCELLED));
            break;

        case IDD_RESTORE:
            EndDialog(hDlg, S_FALSE);
            break;

        default:
            return(FALSE);
        }
        break;

    // owner draw messages for icon listbox

    case WM_DRAWITEM:
        #define lpdi ((DRAWITEMSTRUCT *)lParam)

        if (lpdi->itemState & ODS_SELECTED)
            SetBkColor(lpdi->hDC, GetSysColor(COLOR_HIGHLIGHT));
        else
            SetBkColor(lpdi->hDC, GetSysColor(COLOR_WINDOW));


        /* repaint the selection state */
        ExtTextOut(lpdi->hDC, 0, 0, ETO_OPAQUE, &lpdi->rcItem, NULL, 0, NULL);

        dwOldLayout = GET_DC_LAYOUT(lpdi->hDC);

        if (g_bMirroredOS && dwOldLayout)
        {
            SET_DC_LAYOUT(lpdi->hDC, dwOldLayout | LAYOUT_PRESERVEBITMAP);
        }

        /* draw the icon */
        if ((int)lpdi->itemID >= 0)
          DrawIcon(lpdi->hDC, (lpdi->rcItem.left + lpdi->rcItem.right - GetSystemMetrics(SM_CXICON)) / 2,
                              (lpdi->rcItem.bottom + lpdi->rcItem.top - GetSystemMetrics(SM_CYICON)) / 2, (HICON)lpdi->itemData);
        if (dwOldLayout)
        {
            SET_DC_LAYOUT(lpdi->hDC, dwOldLayout);
        }                              

        // InflateRect(&lpdi->rcItem, -1, -1);

        /* if it has the focus, draw the focus */
        if (lpdi->itemState & ODS_FOCUS)
            DrawFocusRect(lpdi->hDC, &lpdi->rcItem);

        #undef lpdi
        break;

    case WM_MEASUREITEM:
        #define lpmi ((MEASUREITEMSTRUCT *)lParam)

        lpmi->itemWidth = GetSystemMetrics(SM_CXICON) + CX_BORDER;
        lpmi->itemHeight = GetSystemMetrics(SM_CYICON) + CY_BORDER;

        #undef lpmi
        break;

    case WM_DELETEITEM:
        #define lpdi ((DELETEITEMSTRUCT *)lParam)

        DestroyIcon((HICON)lpdi->itemData);

        #undef lpdi
        break;

    case WM_HELP:
        WinHelp(((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aPickIconHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR)(LPVOID)aPickIconHelpIDs);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

// puts up the pick icon dialog

STDAPI_(int) PickIconDlg(HWND hwnd, IN OUT LPTSTR pszIconPath, UINT cchIconPath, int *piIconIndex)
{
    return SUCCEEDED(PickIconDlgWithTitle(hwnd, NULL, FALSE, pszIconPath, cchIconPath, piIconIndex));
}

// puts up the pick icon dialog with a customized Title for the Dialog Window.

STDAPI PickIconDlgWithTitle(HWND hwnd, LPCTSTR pszTitle, BOOL bShowRestoreButton, IN OUT LPTSTR pszIconPath, UINT cchIconPath, int *piIconIndex)
{
    RIPMSG(pszIconPath && IS_VALID_WRITE_BUFFER(pszIconPath, TCHAR, cchIconPath), "PickIconDlgWithTitle: caller passed bad pszIconPath");
    RIPMSG(piIconIndex != NULL, "PickIconDlgWithTitle: caller passed bad piIconIndex");

    if (pszIconPath && piIconIndex)
    {
        PICKICON_DATA *pid = (PICKICON_DATA *)LocalAlloc(LPTR, sizeof(PICKICON_DATA));
        if (pid)
        {
            HRESULT res;

            pid->pszDialogTitle = pszTitle;
            pid->bShowRestoreButton = bShowRestoreButton;
            pid->pszIconPath = pszIconPath;
            pid->cchIconPath = cchIconPath;
            pid->iIconIndex = *piIconIndex;

            res = (HRESULT)DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_PICKICON), hwnd, PickIconDlgProc, (LPARAM)pid);

            *piIconIndex = pid->iIconIndex;

            LocalFree(pid);

            return res;
        }

        *piIconIndex = 0;
        *pszIconPath = 0;

        return E_OUTOFMEMORY;
    }
    return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\piffnt.c ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1991
 *  All Rights Reserved.
 *
 *
 *  PIFFNT.C
 *  User interface dialogs for GROUP_FNT
 *
 *  History:
 *  Created 04-Jan-1993 1:10pm by Jeff Parsons
 *  Changed 05-May-1993 5:10pm by Raymond Chen -- New Chicago-look preview
 *  Changed 12-Aug-1993 4:14pm by Raymond Chen -- Remove font inc and dec
 *
 *  All font dialog code taken from font*.c in vmdosapp, 01-Apr-93
 */

#include "shellprv.h"
#pragma hdrstop

#ifdef _X86_

#define REGSTR_MSDOSEMU_DISPLAYPARAMS TEXT("DisplayParams")

#define REGSTR_PATH_MSDOSEMU "Software\\Microsoft\\Windows\\CurrentVersion\\MS-DOS Emulation"

const TCHAR szWndPreviewClass[] = TEXT("WOAWinPreview");
const TCHAR szFontPreviewClass[] = TEXT("WOAFontPreview");

// The preview strings for bilingual dosbox. 
// We'll load this from our resource that will be properly
// localized. We'll give up if it fails and use above sample
// instead.

UINT cxScreen, cyScreen, dyChar, dyItem;

// Macro definitions that handle codepages 
//
#define OEMCharsetFromCP(cp) \
    ((cp)==CP_JPN? SHIFTJIS_CHARSET : ((cp)==CP_WANSUNG? HANGEUL_CHARSET : OEM_CHARSET))
/*
 * Font cache information.  Note that this cache, being in PIFMGR,
 * is now global, which will make support for per-VM font files/faces
 * more problematic, if we even decide that's an interesting feature.
 *
 */
DWORD   bpfdiStart[2] =  {  0  };    /* strage for the offset to cache */
UINT    cfdiCache[2];                   /* # used entries in fdi cache */
UINT    cfdiCacheActual[2];             /* Total # entries in fdi cache */
LPVOID lpCache = NULL;


/*
 * Owner-draw list box information.
 *
 */
HBITMAP hbmFont;                        /* Handle to "TrueType" logo */
DWORD   dwTimeCheck;
COLORREF clrChecksum;

HCURSOR hcursorWait;

#define MAXDIMENSTRING 80

/*
 * Initial font heights for TT fonts
 *
 * This is read from an INI file, so it must remain writeable.
 *
 * We don't try generating TT fonts below 12pt by default because
 * they just look crappy.  Frosting setup will put a different
 * table into place because Lucida Console looks good down to 4pt.
 *
 * On NT, Lucida Console is installed be default, though.
 *
 * The Frosting table is
 *      4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 20, 22
 */
WORD rgwInitialTtHeights[] = { 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 20, 22 };



/*
 * rgpnlPenalties -- Initialize penalty array to default values
 */
INT rgpnlPenalties[] =
        { 5000, 1000, 0, 1000, 5000, 1000, 0, 1000, 1 };


POINT ptNonAspectMin = { -1, -1 };

// Context-sensitive help ids

const static DWORD rgdwHelp[] = {
    IDC_FONTGRP,            IDH_COMM_GROUPBOX,
    IDC_RASTERFONTS,        IDH_DOS_AVAIL_FONTS,
    IDC_TTFONTS,            IDH_DOS_AVAIL_FONTS,
    IDC_BOTHFONTS,          IDH_DOS_AVAIL_FONTS,
    IDC_FONTSIZELBL,        IDH_DOS_FONT_SIZE,
    IDC_FONTSIZE,           IDH_DOS_FONT_SIZE,
    IDC_WNDPREVIEWLBL,      IDH_DOS_FONT_WINDOW_PREVIEW,
    IDC_FONTPREVIEWLBL,     IDH_DOS_FONT_FONT_PREVIEW,
    IDC_WNDPREVIEW,         IDH_DOS_FONT_WINDOW_PREVIEW,
    IDC_FONTPREVIEW,        IDH_DOS_FONT_FONT_PREVIEW,
    IDC_REALMODEDISABLE,    IDH_DOS_REALMODEPROPS,
    0, 0
};


BOOL_PTR CALLBACK DlgFntProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PFNTINFO pfi = (PFNTINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        // allocate dialog instance data
        if (NULL != (pfi = (PFNTINFO)LocalAlloc(LPTR, sizeof(FNTINFO)))) 
        {
            pfi->ppl = (PPROPLINK)((LPPROPSHEETPAGE)lParam)->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pfi);
            InitFntDlg(hDlg, pfi);
            break;
        }
        else
        {
            EndDialog(hDlg, FALSE);     // fail the dialog create
        }
        break;

    case WM_DESTROY:
        // free any allocations/resources inside the pfi first!
        if (pfi) 
        {
            if (pfi->hFontPreview)
            {
                DeleteObject(pfi->hFontPreview);
                pfi->hFontPreview = NULL;
            }
            // ok, NOW we can free the pfi
            EVAL(LocalFree(pfi) == NULL);
            SetWindowLongPtr(hDlg, DWLP_USER, 0);
        }
        break;

    HELP_CASES(rgdwHelp)                // Handle help messages

    case WM_COMMAND:
        if (LOWORD(lParam) == 0)
            break;                      // message not from a control

        switch (LOWORD(wParam))
        {
        case IDC_RASTERFONTS:
        case IDC_TTFONTS:
        case IDC_BOTHFONTS:

            /*
             * Rebuild the font list based on the user's selection of
             * which fonts to include/exclude.
             */
            pfi->fntProposed.flFnt &= ~FNT_BOTHFONTS;
            pfi->fntProposed.flFnt |= FNTFLAGSFROMID(wParam);
            CreateFontList(GetDlgItem(hDlg, IDC_FONTSIZE), TRUE, &pfi->fntProposed);
            PreviewUpdate(GetDlgItem(hDlg, IDC_FONTSIZE), pfi);

            if (HIWORD(wParam) == BN_CLICKED)
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);

            return FALSE;

        case IDC_FONTSIZE:

            if (HIWORD(wParam) == LBN_SELCHANGE)
            {
                PreviewUpdate(GetDlgItem(hDlg, IDC_FONTSIZE), pfi);
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                return TRUE;
            }
            if (HIWORD(wParam) == LBN_DBLCLK)
                ApplyFntDlg(hDlg, pfi);

            return FALSE;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) {
        case PSN_SETACTIVE:
            AdjustRealModeControls(pfi->ppl, hDlg);
            break;

        case PSN_KILLACTIVE:
            // This gives the current page a chance to validate itself
            // SetWindowLong(hDlg, DWL_MSGRESULT, ValidFntDlg(hDlg, pfi));
            break;

        case PSN_APPLY:
            // This happens on OK....
            ApplyFntDlg(hDlg, pfi);
            break;

        case PSN_RESET:
            // This happens on Cancel....
            break;
        }
        break;

    /*
     *  For WM_MEASUREITEM and WM_DRAWITEM, since there is only one
     *  owner-draw list box in the entire dialog box, we don't have
     *  to do a GetDlgItem to figure out who he is.
     */

    case WM_MEASUREITEM:
        // measure the owner draw listbox
        MeasureItemFontList((LPMEASUREITEMSTRUCT)lParam);
        break;

    case WM_DRAWITEM:
        DrawItemFontList(TRUE, (LPDRAWITEMSTRUCT)lParam);
        break;

    case WM_SYSCOLORCHANGE:
        UpdateTTBitmap();
        break;

    default:
        return FALSE;                   // return 0 when not processing
    }
    return TRUE;
}


/** InitFntDlg
 *
 *  Create the list of appropriate fonts.
 *
 *  This routine is broken out of FontDlgProc because it chew
 *  up lots of stack for the message buffer, and we don't want to
 *  eat that much stack on every entry to FontDlgProc.
 *
 *  Note that we must defer CreateFontList until WM_INITDIALOG
 *  time because it is not until then that we have a list box that
 *  we can shove the data into.
 */

void InitFntDlg(HWND hDlg, register PFNTINFO pfi)
{
    HWND hwndList;              /* The listbox of fonts */
    PPROPLINK ppl = pfi->ppl;
    WINDOWPLACEMENT wp;

    ASSERTTRUE(ppl->iSig == PROP_SIG);

    if (!PifMgr_GetProperties(ppl, MAKELP(0,GROUP_FNT),
                        &pfi->fntProposed, sizeof(pfi->fntProposed), GETPROPS_NONE)
        ||
        !PifMgr_GetProperties(ppl, MAKELP(0,GROUP_WIN),
                        &pfi->winOriginal, sizeof(pfi->winOriginal), GETPROPS_NONE)) {
        Warning(hDlg, IDS_QUERY_ERROR, MB_ICONEXCLAMATION | MB_OK);
        return;
    }

    /*
     * Set up instance variables for the window preview window.
     */
     
    /* Show preview maximized if window is maximized or restores to max'd.
     * Also if it is open restored and has no scrollbars.
     * (Determined by comparing the client window size against the cell
     * size and font size.)
     */

    pfi->fMax = FALSE;

    /*
     * Preload winOriginal with up-to-the-minute goodies, if we have
     * them.
     */

#define HasScrollbars(z) \
    (pfi->winOriginal.c##z##Cells * pfi->fntProposed.c##z##FontActual > \
     pfi->winOriginal.c##z##Client)

    if (ppl->hwndTty) {
        wp.length = sizeof(WINDOWPLACEMENT);
        VERIFYTRUE(GetWindowPlacement(ppl->hwndTty, &wp));

        // Convert/Copy to 16-bit structure
        pfi->winOriginal.wLength          = (WORD)wp.length;
        pfi->winOriginal.wShowFlags       = (WORD)wp.flags;
        pfi->winOriginal.wShowCmd         = (WORD)wp.showCmd;
        pfi->winOriginal.xMinimize        = (WORD)wp.ptMinPosition.x;
        pfi->winOriginal.yMinimize        = (WORD)wp.ptMinPosition.y;
        pfi->winOriginal.xMaximize        = (WORD)wp.ptMaxPosition.x;
        pfi->winOriginal.yMaximize        = (WORD)wp.ptMaxPosition.y;
        pfi->winOriginal.rcNormal.left    = (WORD)wp.rcNormalPosition.left;
        pfi->winOriginal.rcNormal.top     = (WORD)wp.rcNormalPosition.top;
        pfi->winOriginal.rcNormal.right   = (WORD)wp.rcNormalPosition.right;
        pfi->winOriginal.rcNormal.bottom  = (WORD)wp.rcNormalPosition.bottom;

        if (!IsIconic(ppl->hwndTty) &&
                !HasScrollbars(x) && !HasScrollbars(y)) {
            pfi->fMax = TRUE;
        }
    }

    if ((pfi->winOriginal.wShowCmd == SW_SHOWMAXIMIZED) ||
        (pfi->winOriginal.wShowFlags & WPF_RESTORETOMAXIMIZED)) {
        pfi->fMax = TRUE;
    }

    if (pfi->winOriginal.wShowCmd == SW_SHOWMAXIMIZED) {
        pfi->ptCorner.x = (LONG)pfi->winOriginal.xMaximize;
        pfi->ptCorner.y = (LONG)pfi->winOriginal.yMaximize;
    } else {
        if (pfi->winOriginal.rcNormal.left==0)
        {
            pfi->ptCorner.x = -1;
        }
        else
        {
            pfi->ptCorner.x = (LONG)pfi->winOriginal.rcNormal.left;
        }
        pfi->ptCorner.y = (LONG)pfi->winOriginal.rcNormal.top;
    }

    /*
     * First, check which fonts the user wants to see.
     *
     */
    CheckDlgButton(hDlg, IDFROMFNTFLAGS(pfi->fntProposed.flFnt), TRUE);

    hwndList = GetDlgItem(hDlg, IDC_FONTSIZE);
    // SendMessage(hwndList, WM_SETFONT, (WPARAM)GetStockObject(SYSTEM_FIXED_FONT), FALSE);

    if (CreateFontList(hwndList, TRUE, &pfi->fntProposed) == LB_ERR) {
        MemoryWarning(hDlg);
        EndDialog(hDlg, PtrToLong(BPFDI_CANCEL));    /* Get out of the dialog */
        return;
    }

    /* Initialize the preview windows */
    PreviewInit(hDlg, pfi);
    PreviewUpdate(GetDlgItem(hDlg, IDC_FONTSIZE), pfi);
}


void ApplyFntDlg(HWND hDlg, register PFNTINFO pfi)
{
    PPROPLINK ppl = pfi->ppl;

    ASSERTTRUE(ppl->iSig == PROP_SIG);

    if (!PifMgr_SetProperties(ppl, MAKELP(0,GROUP_FNT),
                        &pfi->fntProposed, sizeof(pfi->fntProposed), SETPROPS_NONE))
        Warning(hDlg, IDS_UPDATE_ERROR, MB_ICONEXCLAMATION | MB_OK);
    else
    if (ppl->hwndNotify) {
        ppl->flProp |= PROP_NOTIFY;
        PostMessage(ppl->hwndNotify, ppl->uMsgNotify, sizeof(pfi->fntProposed), (LPARAM)MAKELP(0,GROUP_FNT));
    }
}

/*
 * Retrieves the name of the font to use for true-type DOS box
 * in a window given a registry tree root.
 *
 * Entry:
 *
 * hkRoot      -> registry tree root to search
 * pszFaceSbcs -> LF_FACESIZE buffer for SBCS font
 * pszFaceDbcs -> LF_FACESIZE buffer for DBCS font (may be null)
 *
 * Exit:
 *
 * Buffers filled with new font names, or left unchanged if nothing
 * found in registry.
 *
 */

#define REGSTR_MSDOSEMU_FONT "Font"
#define REGSTR_MSDOSEMU_FONTDBCS "FontDBCS"

// assumes caller passes LF_FACESIZE buffers
void GetDosBoxTtFontsHkA(HKEY hkRoot, LPSTR pszFaceSbcs, LPSTR pszFaceDbcs)
{
    static CHAR const szMsdosemu[] = REGSTR_PATH_MSDOSEMU;
    HKEY hk;
    DWORD cb;

    if (RegOpenKeyExA(hkRoot, szMsdosemu, 0, KEY_READ, &hk) == ERROR_SUCCESS)
    {
        static CHAR const szFont[] = REGSTR_MSDOSEMU_FONT;
        cb = LF_FACESIZE;
        RegQueryValueExA(hk, szFont, 0, 0, (LPBYTE)pszFaceSbcs, &cb);

        if (pszFaceDbcs)
        {
            static CHAR const szDbcsFont[] = REGSTR_MSDOSEMU_FONTDBCS;
            cb = LF_FACESIZE;
            RegQueryValueExA(hk, szDbcsFont, 0, 0, (LPBYTE)pszFaceDbcs, &cb);
        }
        RegCloseKey(hk);
    }
}

/*
 * Retrieves the name of the font to use for true-type DOS box
 * in a window.
 *
 * This routine consults the appropriate registry keys.
 *
 * The DOS box font comes first from HKLM, to establish  a
 * machine-wide default, but can in turn be overridden by
 * HKCU for each user to override.
 *
 * Entry:
 *
 * pszFaceSbcs -> LF_FACESIZE buffer for SBCS font
 * pszFaceDbcs -> LF_FACESIZE buffer for DBCS font (may be null)
 *
 * Exit:
 *
 * Buffers filled with new font names, or left unchange if nothing
 * found in registry.
 *
 */

void CoolGetDosBoxTtFontsA(LPSTR pszFaceSbcs, LPSTR pszFaceDbcs)
{
    GetDosBoxTtFontsHkA(HKEY_LOCAL_MACHINE, pszFaceSbcs, pszFaceDbcs);
    GetDosBoxTtFontsHkA(HKEY_CURRENT_USER, pszFaceSbcs, pszFaceDbcs);
}

/** BroadcastFontChange
 *
 *  HACK! for MS PowerPoint 4.0.  These wallys, for some reason, will go
 *  off and eat up reams of CPU time if they receive a WM_FONTCHANGE
 *  message that was *posted*.  But if the message is *sent*, they do
 *  the right thing.  The puzzling thing is that they never call
 *  InSendMessage(), so how do they know?  What's more, why do they care?
 *  This was true in 3.1 also.  What's their problem?
 *
 *  The problem is that sending a broadcast risks deadlock city; see the
 *  various hacks in winoldap for places where DDE broadcasting is bypassed.
 *  In addition, since BroadcastFontChange is also called during the WEP,
 *  multi-threaded apps will deadlock if we SendMessage back to a window
 *  on a different thread in the app, because Kernel takes a process
 *  critical section during DLL unload.
 *
 *  So if PowerPig is running, we just don't tell anybody that we dorked
 *  with the fonts.
 *
 *  Returns:
 *
 *      None.
 *
 */

void BroadcastFontChange(void)
{
    if (!GetModuleHandle(szPP4)) {
        PostMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0L);
    }
}

/** LoadGlobalFontData
 *
 *  Get the name of the DOS box raster font and load it.
 *
 *  Get the name of the TT font.  (CheckDisplayParameters needs this.)
 *
 *  Check the display parameters.
 *
 *  Initialize the fdi cache.  The cache remains in GlobalLock'd
 *  memory throughout its lifetime.  This is not a problem because
 *  we are guaranteed to be in protected mode.
 *
 *  We also load things necessary for the font combo/list boxes.
 *
 *  And compute the height of the owner-draw list box item.
 *
 *  Returns:
 *
 *      TRUE on success.  In which case the FDI cache and hbmFont
 *      are ready to use.
 *
 *      FALSE on failure.  In which case there is insufficient memory
 *      to complete the operation.
 */

typedef void (WINAPI *LPFNGDBTF)(LPTSTR, LPTSTR); /* GetDosBoxTtFonts */

BOOL LoadGlobalFontData(void)
{
    HDC hDC;
    TEXTMETRIC tm;
    TCHAR szBuffer[MAXPATHNAME];

    cxScreen = GetSystemMetrics(SM_CXSCREEN);
    cyScreen = GetSystemMetrics(SM_CYSCREEN);

    /*
     * Get the system char size and save it away for later use.
     */
    hDC = GetDC(NULL);
    SelectObject(hDC, GetStockObject(SYSTEM_FONT));
    GetTextMetrics(hDC, &tm);
    ReleaseDC(NULL, hDC);

    dyChar = tm.tmHeight + tm.tmExternalLeading;
    dyItem = max(tm.tmHeight, DY_TTBITMAP);

    /*
     * Chicago's AddFontResource looks in the FONTS directory first, which
     * is great because it saves us the trouble of doing goofy disk access
     * optimizations.
     */
    GetPrivateProfileString(sz386EnhSection, szWOAFontKey,
                            c_szNULL, szBuffer, ARRAYSIZE(szBuffer), szSystemINI);
    if (szBuffer[0] && AddFontResource(szBuffer)) {
        BroadcastFontChange();
    }

    /*
     * Add DBCS native font if it is present.
     */
    GetPrivateProfileString(sz386EnhSection, szWOADBCSFontKey,
                            c_szNULL, szBuffer, ARRAYSIZE(szBuffer), szSystemINI);
    if (szBuffer[0] && AddFontResource(szBuffer)) {
        BroadcastFontChange();
    }

    /*
     * Load default TT font name(s) and TT cache section names from resource
     */
    LoadStringA(g_hinst, IDS_TTFACENAME_SBCS, szTTFaceName[0], ARRAYSIZE(szTTFaceName[0]));
    LoadString(g_hinst,IDS_TTCACHESEC_SBCS, szTTCacheSection[0], ARRAYSIZE(szTTCacheSection[0]));

    if (IsBilingualCP(g_uCodePage))
    {
        LoadStringA(g_hinst, IDS_TTFACENAME_DBCS, szTTFaceName[1], ARRAYSIZE(szTTFaceName[1]));
        LoadString(g_hinst, IDS_TTCACHESEC_DBCS, szTTCacheSection[1], ARRAYSIZE(szTTCacheSection[1]));
    }        

    CoolGetDosBoxTtFontsA(szTTFaceName[0], szTTFaceName[1]);

    CheckDisplayParameters();

    // alloc needed # of cache
    //
    lpCache = (LPVOID)LocalAlloc(LPTR,
                    FDI_TABLE_START * sizeof(FONTDIMENINFO) * (IsBilingualCP(g_uCodePage)? 2:1));
                         
    if (!lpCache)
        return FALSE;

    hcursorWait = LoadCursor(NULL, IDC_WAIT);

    UpdateTTBitmap();
    if (!hbmFont)
        goto E0;

    // set initial value of # of cache entries which depends on whether we have
    // two codepage to handle
    //
    cfdiCacheActual[0] = FDI_TABLE_START;

    if (IsBilingualCP(g_uCodePage))
    {
        cfdiCacheActual[1] = FDI_TABLE_START;
        bpfdiStart[1] += FDI_TABLE_START;
    }

    FontSelInit();

    return TRUE;

E0: 
    EVAL(LocalFree(lpCache) == NULL);

    return FALSE;
}


BOOL LoadGlobalFontEditData()
{
    WNDCLASS wc;

    // Set up the window preview class for piffnt.c

    wc.style         = 0L;
    wc.lpfnWndProc   = WndPreviewWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PFNTINFO);
    wc.hInstance     = g_hinst;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BACKGROUND + 1);
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = szWndPreviewClass;

    // Don't go through RegisterClassD because we manually unregister
    // this class ourselves.
    if (!RealRegisterClass(&wc))
        return FALSE;

    // Set up the font preview class for piffnt.c

    wc.style         = 0L;
    wc.lpfnWndProc   = FontPreviewWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PFNTINFO);
    wc.hInstance     = g_hinst;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(BLACK_BRUSH);
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = szFontPreviewClass;

    // Don't go through RegisterClassD because we manually unregister
    // this class ourselves.
    if (!RealRegisterClass(&wc))
        return FALSE;

    return TRUE;
}


void FreeGlobalFontEditData()
{
    UnregisterClass(szWndPreviewClass, g_hinst);
    UnregisterClass(szFontPreviewClass, g_hinst);
}


/*
 *  Make sure that the display parameters have not changed, including
 *  the name of the TT font(s).
 *
 *  If they have, we BLAST OUR CACHE since it is no longer any good.
 *
 *  Entry:
 *      szTTFaceName contains the name of the TrueType font to use.
 *
 *  Returns:
 *      None.
 */

void CheckDisplayParameters(void)
{
    HDC         hIC;
    HKEY        hk;
    DISPLAYPARAMETERS dpTrue, dpStored;

    hIC = CreateIC(szDisplay, 0, 0, 0);

    if (!hIC) {
        /*
         * If things are really screwy, stay conservative and assume
         * that all is well.
         */
        return;
    }

    dpTrue.dpHorzSize   = GetDeviceCaps(hIC, HORZSIZE);
    dpTrue.dpVertSize   = GetDeviceCaps(hIC, VERTSIZE);
    dpTrue.dpHorzRes    = GetDeviceCaps(hIC, HORZRES);
    dpTrue.dpVertRes    = GetDeviceCaps(hIC, VERTRES);
    dpTrue.dpLogPixelsX = GetDeviceCaps(hIC, LOGPIXELSX);
    dpTrue.dpLogPixelsY = GetDeviceCaps(hIC, LOGPIXELSY);
    dpTrue.dpAspectX    = GetDeviceCaps(hIC, ASPECTX);
    dpTrue.dpAspectY    = GetDeviceCaps(hIC, ASPECTY);
    dpTrue.dpBitsPerPixel = GetDeviceCaps(hIC, BITSPIXEL);
    DeleteDC(hIC);

    /*
     *  Since szTTFaceName is pre-initialized to "Courier New" padded
     *  with nulls, we can rely on the garbage after the end of the
     *  string always to be the same, so that a pure memory comparison
     *  will work.
     */
    MultiByteToWideChar(CP_ACP, 0, szTTFaceName[0], -1, dpTrue.szTTFace[0], ARRAYSIZE(dpTrue.szTTFace[0]));
    if (IsBilingualCP(g_uCodePage))
        MultiByteToWideChar(CP_ACP, 0, szTTFaceName[1], -1, dpTrue.szTTFace[1], ARRAYSIZE(dpTrue.szTTFace[1]));

    /*
     *  We must store the dimension information in the registry because
     *  the install program for Omar Sharif Bridge will ERASE! your
     *  SYSTEM.INI if it contains a line greater than 78 characters.
     *  (I am not making this up.  How could I?)
     */

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT(REGSTR_PATH_MSDOSEMU), 0, NULL, 0, KEY_READ | KEY_WRITE, NULL, &hk, NULL) == 0) {
        DWORD cb = sizeof(DISPLAYPARAMETERS);
        if (SHQueryValueEx(hk, REGSTR_MSDOSEMU_DISPLAYPARAMS, 0, 0, (LPVOID)&dpStored, &cb) != 0 || cb != sizeof(DISPLAYPARAMETERS) || IsBufferDifferent(&dpTrue, &dpStored, sizeof(DISPLAYPARAMETERS))) {
            /*
             * Not much we can do if the write fails, so don't check.
             */
            VERIFYTRUE(RegSetValueEx(hk, REGSTR_MSDOSEMU_DISPLAYPARAMS, 0, REG_BINARY, (LPVOID)&dpTrue, cb) == 0);

            /* Blast the font dimension cache */
            WritePrivateProfileString(szTTCacheSection[1], NULL, NULL, szSystemINI);
            if (IsBilingualCP(g_uCodePage))
                WritePrivateProfileString(szTTCacheSection[0], NULL, NULL, szSystemINI);
        }
        VERIFYTRUE(RegCloseKey(hk) == 0);
    } else {
        /*
         *  Couldn't access registry.  Oh well.
         */
    }

}

/*
 *  When the dialog box is created, we create the Window
 *  Preview child window, as well as the Font Preview window.
 *
 *  The creation is deferred until the actual dialog box creation
 *  because the size and shape of the Window Preview window depends
 *  on the current video driver.
 */

void PreviewInit(HWND hDlg, PFNTINFO pfi)
{
    HWND hwnd;
    RECT rectLabel, rcPreview;

    /*
     * Compute the size of our preview window.
     *
     *  The top is aligned with the top of IDC_WNDPREVIEWLBL,
     *          minus a top margin of 3/2 dyChar.
     *  The left edge is aligned with the left edge of IDC_WNDPREVIEWLBL.
     *  The maximum width is the width of IDC_WNDPREVIEWLBL.
     *  The bottom edge can go as far down as the bottom of the dialog,
     *          minus a bottom margin of 3/2 dyChar.
     *  And the shape of the preview window is determined by the screen
     *          dimensions.
     *
     * We make the preview window as large as possible, given these
     * constraints.
     *
     */
    GetWindowRect(GetDlgItem(hDlg, IDC_WNDPREVIEWLBL), &rectLabel);
    ScreenToClient(hDlg, (LPPOINT)&rectLabel);
    ScreenToClient(hDlg, (LPPOINT)&rectLabel.right);

    /*
     * This GetWindowRect/ScreenToClient sets rcPreview.top.
     */
    GetWindowRect(GetDlgItem(hDlg, IDC_WNDPREVIEWLBL), &rcPreview);
    ScreenToClient(hDlg, (LPPOINT)&rcPreview);

    /*
     * Compute height based on width.
     */
    rcPreview.top += 3 * dyChar / 2;
    rcPreview.left = rectLabel.left;
    rcPreview.right = rectLabel.right - rectLabel.left;
    rcPreview.bottom = AspectScale(cyScreen, cxScreen, rcPreview.right);

    /*
     * Phew.  Now we can create the preview window.
     */
    hwnd = CreateWindowEx(
        WS_EX_CLIENTEDGE,
        szWndPreviewClass, NULL,
        WS_CHILD | WS_VISIBLE,
        rcPreview.left, rcPreview.top,
        rcPreview.right, rcPreview.bottom,
        hDlg, (HMENU)IDC_WNDPREVIEW, g_hinst, NULL);

    if (hwnd)
        SetWindowLongPtr(hwnd, 0, (LONG_PTR)pfi);

    /*
     * Compute the size of the font preview.  This is easier.
     */
    GetWindowRect(GetDlgItem(hDlg, IDC_FONTPREVIEWLBL), &rectLabel);
    ScreenToClient(hDlg, (LPPOINT)&rectLabel.left);
    ScreenToClient(hDlg, (LPPOINT)&rectLabel.right);

    hwnd = CreateWindowEx(
        WS_EX_CLIENTEDGE,
        szFontPreviewClass, NULL,
        WS_CHILD | WS_VISIBLE,
        rectLabel.left,
        rectLabel.top + 3 * dyChar / 2,
        rectLabel.right - rectLabel.left,
        rcPreview.bottom,
        hDlg, (HMENU)IDC_FONTPREVIEW, g_hinst, NULL);

    if (hwnd)
        SetWindowLongPtr(hwnd, 0, (LONG_PTR)pfi);
}


/*  PreviewUpdate
 *
 *  Does the preview of the selected font.
 */

void PreviewUpdate(HWND hwndList, PFNTINFO pfi)
{
    HWND hDlg;
    BPFDI bpfdi;

    /* Delete the old font if necessary */
    if (pfi->hFontPreview)
    {
        DeleteObject(pfi->hFontPreview);
        pfi->hFontPreview = NULL;
    }

    /* When we select a font, we do the font preview by setting it
     * into the appropriate list box
     */
    bpfdi = (BPFDI)GetFont(hwndList, TRUE, pfi);
    if (IsSpecialBpfdi(bpfdi))
        return;

    /* Update our internal font structure so that preview window
     * will actually change
     */
    pfi->bpfdi = bpfdi;
    SetFont(&pfi->fntProposed, bpfdi);

    /* Make the new font */
    pfi->hFontPreview = CreateFontFromBpfdi(bpfdi, pfi);

    /* Force the preview windows to repaint */
    hDlg = GetParent(hwndList);
    InvalidateRect(GetDlgItem(hDlg, IDC_WNDPREVIEW), NULL, TRUE);
    InvalidateRect(GetDlgItem(hDlg, IDC_FONTPREVIEW), NULL, TRUE);
}


/*  WndPreviewWndProc
 *
 *  Handles the window preview window.
 */

LRESULT WndPreviewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_PAINT:
        WndPreviewPaint(GetParent(hwnd), hwnd);
        break;

    case WM_HELP:       // Handles title bar help button message
        WinHelp(hwnd, NULL, HELP_CONTEXTPOPUP, IDH_DOS_FONT_WINDOW_PREVIEW);
        break;

    case WM_RBUTTONUP:
    case WM_NCRBUTTONUP: // Equivalent of WM_CONTEXTMENU
        OnWmContextMenu((WPARAM)hwnd, &rgdwHelp[0]);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}

/*  Swiped from Control Panel / Metrics.
 *
 *  Draws the frame *and* modifies the rectangle to contain the
 *  shrunk coordinates.
 */
void _DrawFrame(HDC hdc, int clr, LPRECT lprc, int cx, int cy)
{
    HBRUSH hbr;
    RECT rcT;

    CopyRect(&rcT, lprc);
    hbr = SelectObject(hdc, GetSysColorBrush(clr));

    /* Left */
    PatBlt(hdc, rcT.left, rcT.top, cx, rcT.bottom-rcT.top, PATCOPY);
    rcT.left += cx;

    /* Top */
    PatBlt(hdc, rcT.left, rcT.top, rcT.right-rcT.left, cy, PATCOPY);
    rcT.top += cy;

    /* Right */
    rcT.right -= cx;
    PatBlt(hdc, rcT.right, rcT.top, cx, rcT.bottom-rcT.top, PATCOPY);

    /* Bottom */
    rcT.bottom -= cy;
    PatBlt(hdc, rcT.left, rcT.bottom, rcT.right-rcT.left, cy, PATCOPY);

    SelectObject(hdc, hbr);
    CopyRect(lprc, &rcT);
}


/*  WndPreviewPaint
 *
 *  Paints the window preview window.  This is called from its
 *  paint message handler.
 *
 */

void WndPreviewPaint(HWND hDlg, HWND hwnd)
{
    PPROPLINK ppl;
    PFNTINFO pfi;
    RECT rcPreview;
    RECT rcWin;
    RECT rcClient;
    RECT rcT;
    POINT ptButton;
#define cxButton    ptButton.x
#define cyButton    ptButton.y
    POINT ptCorner;
    POINT ptFrame;
#define cxFrame    ptFrame.x
#define cyFrame    ptFrame.y
    BPFDI bpfdi;
    int cxBorder, cyBorder;
    int dyToolbar;
    PAINTSTRUCT ps;
    BOOL bCenter;

    BeginPaint(hwnd, &ps);

    pfi = (PFNTINFO)GetWindowLongPtr(hwnd, 0);

    ppl = pfi->ppl;
    ASSERTTRUE(ppl->iSig == PROP_SIG);

    bpfdi = pfi->bpfdi;

    /* If we don't have a font, get out */
    if (!pfi->hFontPreview)
        return;

    /* Get the width of the preview "screen" */
    GetClientRect(hwnd, &rcPreview);

    /* Figure out how large we would be as a result of the change.
     * This isn't perfect, but it'll probably be close enough.
     * (Imperfection if we chose AUTO as the font.)
     */

    /* Assume maximized */
    rcClient.left = rcClient.top = 0;
    if (pfi->winOriginal.cxCells) {
        rcClient.right = pfi->winOriginal.cxCells * bpfdi->fdiWidthActual;
    } else {
        rcClient.right = 80 * bpfdi->fdiWidthActual;
    }

    if (pfi->winOriginal.cyCells) {
        rcClient.bottom = pfi->winOriginal.cyCells * bpfdi->fdiHeightActual;
    } else {
        PROPVID vid;

        // set default value
        rcClient.bottom = 25 * bpfdi->fdiHeightActual;

        // now see if there is a value in the pif file for size of window...
        if (PifMgr_GetProperties(ppl, MAKELP(0,GROUP_VID),
                        &vid, sizeof(vid), GETPROPS_NONE))
        {
            if (vid.cScreenLines > 0)
                rcClient.bottom = vid.cScreenLines * bpfdi->fdiHeightActual;

        }
    }
    if (!pfi->fMax && pfi->winOriginal.cxClient && pfi->winOriginal.cyClient) {
        /* Shrink down to window actual */
        if (rcClient.right > (int)pfi->winOriginal.cxClient)
            rcClient.right = (int)pfi->winOriginal.cxClient;
        if (rcClient.bottom > (int)pfi->winOriginal.cyClient)
            rcClient.bottom = (int)pfi->winOriginal.cyClient;
    }

    /* Get some more metrics */
    cxBorder = GetSystemMetrics(SM_CXBORDER);
    cyBorder = GetSystemMetrics(SM_CYBORDER);

    cxButton = GetSystemMetrics(SM_CXSIZE);
    cyButton = GetSystemMetrics(SM_CYSIZE);
//  cyButton *= 2;                      /* Double the height for "looks" */

    cxFrame = GetSystemMetrics(SM_CXFRAME);
    cyFrame = GetSystemMetrics(SM_CYFRAME);

    /* FLAG DAY!  Convert everything from desktop coordinates to
     * aspect ratio-scaled preview coordinates
     *
     * Do **not** convert cxBorder and cyBorder!
     *
     * ptCorner must not be modified in-place since its value is used at
     * the next go-round.
     *
     * After translation, cxFrame and cyFrame are adjusted so that the
     * cxBorder counts against them.  This allows for users who set
     * really wide frames, but doesn't penalize the users who have
     * narrow frames.
     */

    ptCorner = pfi->ptCorner;
    bCenter = (ptCorner.x == -1);
    AspectPoint(&rcPreview, &ptCorner);
    AspectPoint(&rcPreview, &ptFrame);
    AspectRect(&rcPreview, &rcClient);
    AspectPoint(&rcPreview, &ptButton);

    /*
     * The height of a toolbar is hard-coded at 30 pixels.
     */
    if (pfi->winOriginal.flWin & WIN_TOOLBAR) {
        dyToolbar = (int)AspectScale(rcPreview.bottom, cyScreen, 30);
    } else {
        dyToolbar = 0;
    }

    /* Make sure the buttons are nonzero in dimension */
    if (cxButton == 0) cxButton = 1;
    if (cyButton == 0) cyButton = 1;

    /*
     * Don't penalize people who have thin frames.
     */
    if (cxFrame < cxBorder) cxFrame = cxBorder;
    if (cyFrame < cyBorder) cyFrame = cyBorder;

    /*
     * Convert from client rectangle back to window rectangle.
     *
     * We must do this *AFTER* the flag day, because we need to use the
     * post-flag day cxBorder and cyBorder.
     */

    /* Put a (scaled-down) toolbar into place.  We'll expand the client
     * region to accomodate it.  (We'll subtract the toolbar off before
     * painting the client region.)
     */
    rcClient.bottom += dyToolbar;

    /* Shove the client region down to make room for the caption. */
    OffsetRect(&rcClient, 0, cyButton);

    rcWin = rcClient;
    rcWin.top = 0;
    InflateRect(&rcWin, cxFrame, cyFrame);

    /*
     * Now put it in the proper position on the (shrunk-down) desktop.
     * We cannot do this until rcWin's value is finalized.
     */
    if (bCenter)
    {
        ptCorner.x = ((rcPreview.right - rcPreview.left) -
                       (rcWin.right  - rcWin.left)
                     ) / 2;
        if (ptCorner.x < 0)
            ptCorner.x = 0;

        ptCorner.y = ((rcPreview.bottom - rcPreview.top) -
                       (rcWin.bottom  - rcWin.top)
                     ) / 5;
        if (ptCorner.y < 0)
            ptCorner.y = 0;

    }
    OffsetRect(&rcWin, ptCorner.x, ptCorner.y);
    OffsetRect(&rcClient, ptCorner.x, ptCorner.y);

    /* It's party time! */

    /* The outer border */
    DrawEdge(ps.hdc, &rcWin, BDR_RAISEDINNER, BF_RECT | BF_ADJUST);

    /* The sizing frame */
    _DrawFrame(ps.hdc, COLOR_ACTIVEBORDER,
                    &rcWin, cxFrame - cxBorder, cyFrame - cyBorder);

    /* rcWin has now shrunk to its inner edge */

    /* Move its bottom edge upwards to meet the top of the client region.
     * This turns rcWin into the caption area.
     */
    rcWin.bottom = rcClient.top;
    FillRect(ps.hdc, &rcWin, (HBRUSH)(COLOR_ACTIVECAPTION+1));

    /* Next comes the toolbar */
    rcT= rcClient;
    rcT.bottom = rcT.top + dyToolbar;
    FillRect(ps.hdc, &rcT, (HBRUSH)(COLOR_BTNFACE+1));

    /* Next, draw the client region */
    rcClient.top += dyToolbar;
    DrawEdge(ps.hdc, &rcClient, BDR_SUNKENOUTER, BF_RECT | BF_ADJUST);
    FillRect(ps.hdc, &rcClient, (HBRUSH)GetStockObject(BLACK_BRUSH));

    /*
     * Now draw the three caption buttons.
     */

    /*
     * The system menu.
     */
    rcT = rcWin;
    rcT.right = rcT.left + cxButton;
  //DrawFrameControl(ps.hdc, &rcT, DFC_SYSMENU, DFCS_SYSMENUMAIN);
    DrawFrameControl(ps.hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONCLOSE);

    /*
     * The maximize menu.
     */
    rcWin.left = rcWin.right - cxButton;
  //DrawFrameControl(ps.hdc, &rcWin, DFC_SIZE, DFCS_SIZEMAX);
    DrawFrameControl(ps.hdc, &rcWin, DFC_CAPTION, DFCS_CAPTIONMAX);

    /*
     * The minimize menu.
     */
    rcWin.left -= cxButton;
    rcWin.right -= cxButton;
  //DrawFrameControl(ps.hdc, &rcWin, DFC_SIZE, DFCS_SIZEMIN);
    DrawFrameControl(ps.hdc, &rcWin, DFC_CAPTION, DFCS_CAPTIONMIN);

    EndPaint(hwnd, &ps);
}
#undef cxButton
#undef cyButton

#undef cxFrame
#undef cyFrame

LRESULT FontPreviewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rect;
    PFNTINFO pfi;
    PAINTSTRUCT ps;

    switch (uMsg)
    {
    case WM_PAINT:
        BeginPaint(hwnd, &ps);

        pfi = (PFNTINFO)GetWindowLongPtr(hwnd, 0);

        /* Draw the font sample */
        SelectObject(ps.hdc, pfi->hFontPreview);
        SetTextColor(ps.hdc, RGB(192, 192, 192));
        SetBkColor(ps.hdc, RGB(0, 0, 0));
        GetClientRect(hwnd, &rect);
        InflateRect(&rect, -2, -2);

        {
            TCHAR szPreviewText[300];
            LoadString(g_hinst, IsBilingualCP(pfi->fntProposed.wCurrentCP) ? IDS_PREVIEWTEXT_BILNG : IDS_PREVIEWTEXT, szPreviewText, ARRAYSIZE(szPreviewText));
            // load a sample for their native codepage
            DrawText(ps.hdc, szPreviewText, -1, &rect, 0);
        }

        EndPaint(hwnd, &ps);
        break;

    case WM_HELP:       // Handles title bar help button message
        WinHelp(hwnd, NULL, HELP_CONTEXTPOPUP, IDH_DOS_FONT_FONT_PREVIEW);
        break;

    case WM_RBUTTONUP:
    case WM_NCRBUTTONUP: // Equivalent of WM_CONTEXTMENU
        OnWmContextMenu((WPARAM)hwnd, &rgdwHelp[0]);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


/*
 *  Loads the dialog control hwndList with all available font
 *  dimensions for raster fonts, and a selected collection of
 *  dimensions for TrueType fonts.
 *
 *  The reference data for each control is an index into lpfniCache.
 *
 *  The hourglass cursor is displayed during the font list build.
 *
 *  Entry:
 *      hwndList == handle to listbox or combo box to fill
 *      fListBox == TRUE if hwndList is a listbox, FALSE if a combo box
 *      lpFnt    -> PROPFNT structure
 *
 *      If HIWORD(lpFnt) is NULL, then LOWORD(lpFnt) is used as an hProps
 *      to get obtain property info for that handle.
 *
 *  Returns:
 *      >= 0 on success, indicating the current selection.
 *      In which case the FDI cache is valid and hwndList has been filled
 *      with font information, and the currently-selected font has been
 *      made the current selection.
 *
 *      LB_ERR/CB_ERR on failure.  The list box hwndList is left in an
 *      indeterminate state.
 */

int WINAPI CreateFontList(HWND hwndList, BOOL fListBox, LPPROPFNT lpFnt)
{
    DWORD   dwIndex;
    HCURSOR hcursor;
    PROPFNT fntTemp;
    int     iReturn = LB_ERR;
    TCHAR   szBuf[MAXDIMENSTRING];

    if (IS_INTRESOURCE(lpFnt))
    {
        if (!PifMgr_GetProperties(lpFnt, MAKELP(0,GROUP_FNT),
                           &fntTemp, sizeof(fntTemp), GETPROPS_NONE))
            goto Exit2;

        lpFnt = &fntTemp;
    }

    /*
     * Put up an hourglass while the font list build is taking place,
     * since it might take a long time if we have to re-rasterize
     * TrueType fonts.
     *
     * NOTE!  That we do not do a ShowCursor.  Why?
     *
     *  If the user is on a mouseless system, then he can't access his
     *  toolbar, and hence the only time this code can get called is
     *  during the creation of the font selection dialog box.  In which
     *  case, DialogBox has already done a ShowCursor for us.
     *
     */
    hcursor = SetCursor(hcursorWait);

    /*
     * Initialize the list box.
     */
    if (hwndList) {
        SendMessage(hwndList, WM_SETREDRAW, FALSE, 0L);
        SendMessage(hwndList, fListBox ? LB_RESETCONTENT : CB_RESETCONTENT, 0, 0L);
    }

    /*
     * Add the fonts.
     */
    if ((lpFnt->flFnt & FNT_RASTERFONTS) &&
        !AddRasterFontsToFontListA(hwndList, fListBox,
                                  lpFnt->achRasterFaceName, lpFnt->wCurrentCP))
        goto Exit;

    if ((lpFnt->flFnt & FNT_TTFONTS) &&
        !AddTrueTypeFontsToFontListA(hwndList, fListBox,
                                  lpFnt->achTTFaceName, lpFnt->wCurrentCP))
        goto Exit;

    /*
     * And the magical "Auto" font size.
     */

    /*
     * Beyond this point, success is assured, so at the very least,
     * DON'T return LB_ERR;  we may optionally set the return code to
     * the current selection, below, too...
     */
    iReturn = 0;

    if (hwndList) {
        /*
         * No error checking here because if anything fails, then the
         * end result will be merely that the "Auto" option either
         * (1) exists but is invisible, or (2) doesn't appear at all.
         */
        LoadString(g_hinst, IDS_AUTO, szBuf, ARRAYSIZE(szBuf));
        dwIndex = lcbInsertString(hwndList, fListBox, szBuf, 0);
        lcbSetItemDataPair(hwndList, fListBox, dwIndex, BPFDI_AUTO, 0);

        /*
         * Make yet another pass through the list to find the current
         * font and select it.  Thanks to an intentional flakiness
         * in USER, we can't do this check at the point that the
         * font is added, because the selection does not move with the
         * item when a new item is inserted above the selection.
         *
         * Bleah.
         */
        if (!MatchCurrentFont(hwndList, fListBox, lpFnt)) {
            /*
             * If no font matched the current font, and we are a list box,
             * then make the first font the current selection.
             *
             * We don't want to make any default selection if we are a
             * combo box, because that would make the user think that the
             * current font was something it wasn't.
             */
            if (fListBox) {
                /*
                 * SORTING-SENSITIVE!  This assumes that "Auto" is at the top
                 * of the list.
                 */
                lcbSetCurSel(hwndList, TRUE, 0);
                lpFnt->flFnt |= FNT_AUTOSIZE;
            }
        }
        SendMessage(hwndList, WM_SETREDRAW, TRUE, 0L);

        iReturn = lcbGetCurSel(hwndList, fListBox);
    }
Exit:
    /*
     * Reset the mouse cursor.
     */
    SetCursor(hcursor);

Exit2:
    return iReturn;
}


/** UpdateTTBitmap
 *
 *  Recompute the colors for the TrueType bitmap hbmFont.
 *
 *  Since we may receive this several times for a single WM_SYSCOLORCHANGE,
 *  we update our colors under the following conditions:
 *
 *      1. More than one second has elapsed since the previous call, or
 *      2. A crude checksum fails.
 *
 *  Entry:
 *      None.
 *
 *  Returns:
 *      hbmFont recomputed.
 */

VOID WINAPI UpdateTTBitmap(void)
{
    COLORREF clr;

    /*
     *  Note that the checksum should not be a symmetric function,
     *  because a common color alteration is to exchange or permute
     *  the colors.
     */
    clr = +  GetSysColor(COLOR_BTNTEXT)
          -  GetSysColor(COLOR_BTNSHADOW)
          + (GetSysColor(COLOR_BTNFACE) ^ 1)
          - (GetSysColor(COLOR_BTNHIGHLIGHT) ^ 2)
          ^  GetSysColor(COLOR_WINDOW);

    if (!hbmFont || clr != clrChecksum || GetTickCount() - dwTimeCheck < 1000) {
        clrChecksum = clr;
        dwTimeCheck = GetTickCount();
        if (hbmFont) DeleteObject(hbmFont);
        hbmFont = CreateMappedBitmap(g_hinst, IDB_TTBITMAP, 0, NULL, 0);
    }
}


/** DrawItemFontList
 *
 *  Answer the WM_DRAWITEM message sent from the font list box or
 *  font combo box.
 *
 *  This code was originally lifted from FONT.C in sdk\commdlg.
 *
 *  See fontutil.h for an explanation of the \1 hack.
 *
 *  Entry:
 *      fListBox    =  TRUE if the item is a list box, FALSE if a combo box
 *      lpdis       -> DRAWITEMSTRUCT describing object to be drawn
 *
 *  Returns:
 *      None.
 *
 *      The object is drawn.
 */

#define cTabsList 3

typedef struct DIFLINFO {
    LPTSTR       di_lpsz;
    PINT        di_pTabs;
} DIFLINFO, *LPDIFLINFO;

#define lpdi ((LPDIFLINFO)lp)
BOOL CALLBACK diflGrayStringProc(HDC hdc, LPARAM lp, int cch)
{
    return (BOOL)TabbedTextOut(hdc, 0, 0,
                  lpdi->di_lpsz, lstrlen(lpdi->di_lpsz),
                  cTabsList, lpdi->di_pTabs, 0);

}
#undef lpdi

VOID WINAPI DrawItemFontList(BOOL fListBox, const LPDRAWITEMSTRUCT lpdis)
{
    HDC     hDC, hdcMem;
    DWORD   rgbBack, rgbText;
    int     iColorBack;
    COLORREF clrText;
    COLORREF clrBack;
    TCHAR    szDimen[MAXDIMENSTRING];
    HBITMAP hOld;
    int     dy;
    DIFLINFO di;
    static int rgTabsList[cTabsList] = {0, 0, 0};
    static int rgTabsCombo[cTabsList] = {0, 0, 0};
#define lpsz di.di_lpsz
#define pTabs di.di_pTabs

    if ((int)lpdis->itemID < 0)
        return;

    hDC = lpdis->hDC;

    if (lpdis->itemAction & ODA_FOCUS) {
        if (lpdis->itemState & ODS_SELECTED) {
            DrawFocusRect(hDC, &lpdis->rcItem);
        }
    } else {
        if (lpdis->itemState & ODS_SELECTED) {
            clrBack = GetSysColor(iColorBack = COLOR_HIGHLIGHT);
            clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
        } else {
            clrBack = GetSysColor(iColorBack = COLOR_WINDOW);
            clrText = GetSysColor(IsWindowEnabled(lpdis->hwndItem) ?
                                        COLOR_WINDOWTEXT : COLOR_GRAYTEXT);
        }
        rgbText = SetTextColor(hDC, clrText);
        rgbBack = SetBkColor(hDC, clrBack);

        // draw selection background
        FillRect(hDC, &lpdis->rcItem, (HBRUSH)UIntToPtr((iColorBack + 1)));

        // get the string
        SendMessage(lpdis->hwndItem, fListBox ? LB_GETTEXT : CB_GETLBTEXT, lpdis->itemID, (LPARAM)(LPTSTR)szDimen);

        lpsz = szDimen;
        if (szDimen[0] == TEXT('\1'))   // hack for "Auto" string
            lpsz++;

        if (fListBox)
            pTabs = rgTabsList;
        else
            pTabs = rgTabsCombo;

        if (pTabs[0] == 0) {            /* Never seen this font before */
            /* Assumes GetTextExtent(hDC, ANSI_TIMES, 1) < 2 * dxChar */
            SIZE sSize;
            GetTextExtentPoint32(hDC, szZero, 1, &sSize); // size of '0'
            /* A negative # for tab stop right aligns the tabs... */
            pTabs[0] = -sSize.cx * 3;
            pTabs[1] = -sSize.cx * 5;
            pTabs[2] = -sSize.cx * 8;
        }

        // draw the text
        //
        // Note that the SDK dox for GrayString says that you can detect
        // whether GrayString is needed by saying
        //
        //      if (GetSysColor(COLOR_GRAYTEXT) == 0) {
        //          GrayString(...);
        //      } else {
        //          TextOut(...);
        //      }
        //
        // This is incorrect.  The correct test is the one below, which
        // also catches bad color combinations on color devices.
        //
        if (clrText == clrBack) {
            SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
            GrayString(hDC, GetStockObject(GRAY_BRUSH), diflGrayStringProc ,
                       (LPARAM)(LPVOID)&di, 0,
                        lpdis->rcItem.left + DX_TTBITMAP,
                        lpdis->rcItem.top,
                        lpdis->rcItem.right - lpdis->rcItem.left - DX_TTBITMAP,
                        lpdis->rcItem.bottom - lpdis->rcItem.top);
        } else {
            TabbedTextOut(hDC, lpdis->rcItem.left + DX_TTBITMAP, lpdis->rcItem.top, lpsz, lstrlen(lpsz), cTabsList, pTabs, DX_TTBITMAP);
        }

        // and the bitmap if needed
        if (!IsSpecialBpfdi((BPFDI)lpdis->itemData))
        {
            if (((BPFDI)(lpdis->itemData))->bTT) {
                hdcMem = CreateCompatibleDC(hDC);
                if (hdcMem) {
                    hOld = SelectObject(hdcMem, hbmFont);

                    dy = ((lpdis->rcItem.bottom - lpdis->rcItem.top) - DY_TTBITMAP) / 2;

                    BitBlt(hDC, lpdis->rcItem.left, lpdis->rcItem.top + dy,
                        DX_TTBITMAP, DY_TTBITMAP, hdcMem, 0,
                        lpdis->itemState & ODS_SELECTED ? 0 : DY_TTBITMAP, SRCCOPY);

                    if (hOld)
                        SelectObject(hdcMem, hOld);
                    DeleteDC(hdcMem);
                }
            }
        }

        SetTextColor(hDC, rgbText);
        SetBkColor(hDC, rgbBack);

        if (lpdis->itemState & ODS_FOCUS) {
            DrawFocusRect(hDC, &lpdis->rcItem);
        }
    }
}
#undef lpsz
#undef pTabs


/** MeasureItemFontList
 *
 *  Answer the WM_MEASUREITEM message sent from the font list box or
 *  font combo box. shared between the toolbar combo box code and
 *  the font preview property sheet
 *
 *  Entry:
 *      lpmi -> LPMEASUREITEMSTRUCT describing object to be measured
 *
 *  Returns:
 *      TRUE.
 *
 *      lpmi->itemHeight filled with actual item height.
 */

LONG WINAPI MeasureItemFontList(LPMEASUREITEMSTRUCT lpmi)
{
    lpmi->itemHeight = dyItem;
    return TRUE;
}


/** MatchCurrentFont
 *
 *  Locates the current font in the indicated list box and
 *  makes him the current selection.
 *
 *  If we are in auto-mode, then "Auto" is selected.
 *
 *  Entry:
 *      hwndList == handle to listbox or combo box
 *      fListBox == TRUE if hwndList is a listbox, FALSE if a combo box
 *      lpFnt    -> PROPFNT structure
 *
 *  Returns:
 *      TRUE if the current font was found and selected.
 */
BOOL WINAPI MatchCurrentFont(HWND hwndList, BOOL fListBox, LPPROPFNT lpFnt)
{
    BPFDI bpfdi;
    DWORD dwCount, dwIndex;
    BOOL  fCurFontIsTt = !!(lpFnt->flFnt & FNT_TT);

    if (lpFnt->flFnt & FNT_AUTOSIZE) {
        /*
         * SORTING-SENSITIVE!  This assumes that "Auto" is at the top
         * of the list.
         */
        lcbSetCurSel(hwndList, fListBox, 0);
        return TRUE;
    }
    dwCount = lcbGetCount(hwndList, fListBox);
    for (dwIndex = 0; dwIndex < dwCount; dwIndex++) {

        bpfdi = lcbGetBpfdi(hwndList, fListBox, dwIndex);

        if (!IsSpecialBpfdi(bpfdi)) {
            // bpfdi = (BPFDI)((DWORD)bpfdi + (DWORD)lpCache);
            if (bpfdi->fdiWidthActual  == lpFnt->cxFontActual &&
                bpfdi->fdiHeightActual == lpFnt->cyFontActual &&
                fCurFontIsTt == (bpfdi->fdiHeightReq != 0)) {

                    lcbSetCurSel(hwndList, fListBox, dwIndex);
                    return TRUE;
            }
        }
    }
    return FALSE;
}

/** AddRasterFontsToFontList
 *
 *  Enumerate the available dimensions for our OEM raster font
 *  and add them to the list or combo box.
 *
 *  Entry:
 *      hwndList        =  List box or combo box to fill with info
 *      fListBox        =  TRUE if hwndList is a listbox, FALSE if a combo box
 *      lpszRasterFaceName
 *
 *  Returns:
 *      TRUE if fonts were enumerated to completion.
 *      FALSE if enumeration failed.  (Out of memory.)
 *
 */
BOOL AddRasterFontsToFontListA(HWND hwndList, BOOL fListBox,
                                       LPCSTR lpszRasterFaceName, INT CodePage)
{
    HDC     hDC;
    BOOL    fSuccess;
    FNTENUMINFO FntEnum;

    hDC = GetDC(hwndList);
    if (!hDC) return FALSE;

    FntEnum.hwndList = hwndList;
    FntEnum.fListBox = fListBox;
    FntEnum.CodePage = CodePage;
    fSuccess = EnumFontFamiliesA(hDC,
                                lpszRasterFaceName,
                                (FONTENUMPROCA)RasterFontEnum,
                                (LPARAM)&FntEnum);
    ReleaseDC(hwndList, hDC);
    return TRUE;
}


/** RasterFontEnum
 *
 *  FONTENUMPROC for enumerating all available dimensions of the OEM
 *  raster font.
 *
 *  This routine is used to load the logical and physical font
 *  dimensions cache with information about raster fonts.
 *
 *  Entry:
 *      lpelf           \
 *      lpntm            > from EnumFonts (see SDK)
 *      nFontType       /
 *      hwndList        =  List box or combo box to fill with info
 *      fListBox        =  TRUE if hwndList is a listbox, FALSE if a combo box
 *
 *  Returns:
 *      TRUE to continue enumeration.
 *      FALSE to stop enumeration.  (Out of memory.)
 */

int CALLBACK RasterFontEnum(ENUMLOGFONTA *lpelf, NEWTEXTMETRICA *lpntm, int nFontType, LPARAM lParam)
{
#define fListBox  (((LPFNTENUMINFO)lParam)->fListBox)
#define hwndList  (((LPFNTENUMINFO)lParam)->hwndList)
#define CodePage (((LPFNTENUMINFO)lParam)->CodePage)
#define lpLogFont (&(lpelf->elfLogFont))

    /*
     * We only care about OEM fixed-pitch fonts.
     */
    if (lpLogFont->lfCharSet != OEMCharsetFromCP(CodePage)
        || (lpLogFont->lfPitchAndFamily & (TMPF_TRUETYPE | TMPF_FIXED_PITCH))
            != TMPF_FIXED_PITCH)
        return TRUE;

    return AddToFontListCache(hwndList,
                              fListBox,
                              0, 0,
                              lpLogFont->lfHeight,
                              lpLogFont->lfWidth,
                              CodePage) != BPFDI_CANCEL;
#undef lpLogFont
#undef fListBox
#undef hwndList
#undef CodePage
}

/** AddToFontListCache
 *
 *  Adds an entry to the font dimension information cache,
 *  growing the cache if necessary.
 *
 *  It also adds the entry to the indicated list box, provided
 *  the entry is not a duplicate.
 *
 *  Returns:
 *      BPFDI of the recently-added font, or BPFDI_CANCEL if out of memory.
 *
 *  Overview:
 *      (1) Grow the cache if necessary.
 *      (2) Add the information to the list/combo box.
 *      (3) Add the information to the cache.
 */
BPFDI AddToFontListCache(HWND hwndList,
                         BOOL fListBox,
                         UINT uHeightReq,
                         UINT uWidthReq,
                         UINT uHeightActual,
                         UINT uWidthActual,
                         UINT uCodePage)
{
    LPVOID  hCache;
    LONG_PTR lCacheSave;
    DWORD   dwIndex, ifdi;
    BPFDI   bpfdi;
    TCHAR   szBuf[MAXDIMENSTRING];
    int     idx;
    
    ASSERT(!((uHeightReq==0) && (uWidthReq==0) && (uHeightActual==0) && (uWidthActual==0)));
    /* Reject too-large fonts out of hand. */
    if (uHeightActual > MAX_FONT_HEIGHT) {
        return BPFDI_IGNORE;
    }

    /*
     * FIRST, determine whether this font entry has already been cached
     */

    // we maintain two set of cache entries in case we have two code page
    // to support
    // 
    idx = IsBilingualCP(uCodePage) ? 1 : 0; 
    
    for (ifdi = 0, bpfdi = (BPFDI)((DWORD_PTR)lpCache + bpfdiStart[idx]); ifdi < cfdiCache[idx]; ++ifdi, ++bpfdi)
    {
        if (bpfdi->fdiWidthReq == uWidthReq &&
            bpfdi->fdiHeightReq == uHeightReq &&
            bpfdi->fdiWidthActual == uWidthActual &&
            bpfdi->fdiHeightActual == uHeightActual)
                goto UpdateListCombo;
    }

    /*
     * Grow the cache if necessary.
     */
    if (cfdiCache[idx] >= cfdiCacheActual[idx]) {

        /*
         * save offset from beginning of cache
         */
        bpfdi = (BPFDI)((DWORD_PTR)bpfdi - (DWORD_PTR)lpCache);

        /*
         * save current lpCache value so can adjust entries in listbox
         * when we're done...
         */
        lCacheSave = (LONG_PTR)lpCache;
        hCache = LocalReAlloc(lpCache,
        (cfdiCacheActual[0] + cfdiCacheActual[1] + FDI_TABLE_INC) *
        sizeof(FONTDIMENINFO), LMEM_ZEROINIT|LMEM_MOVEABLE);
        if (!hCache)
            return BPFDI_CANCEL;
        lpCache = hCache;
        
        if (!idx && IsBilingualCP(g_uCodePage)) {
            /*
             * We need to shift 2nd cache before using expanded 1st chache
             */
            BPFDI bpfdi2;
            for (ifdi = cfdiCache[1],
                              bpfdi2 = (BPFDI)((DWORD_PTR)lpCache + bpfdiStart[1]) + ifdi - 1 + FDI_TABLE_INC ;
                                                  ifdi ; ifdi--, bpfdi2--) {
                *bpfdi2 = *(bpfdi2 - FDI_TABLE_INC);
            }
            bpfdiStart[1] += FDI_TABLE_INC;
        }
        /* restore bpfdi from saved offset */
        bpfdi = (BPFDI)((DWORD_PTR)lpCache + (DWORD_PTR)bpfdi);
        cfdiCacheActual[idx] += FDI_TABLE_INC;

        /*
         * Convert lCacheSave to an offset...
         */
        lCacheSave = (LONG_PTR)lpCache - lCacheSave;

        if (lCacheSave)
        {
            /*
             * Now, adjust each entry in the listbox to account for the new
             * relocated cache position..
             */

            dwIndex = lcbGetCount(hwndList, fListBox);
            for(ifdi = 0; ifdi < dwIndex; ifdi++)
            {
                LONG_PTR lBpfdi;

                lBpfdi = (LONG_PTR)lcbGetItemDataPair(hwndList, fListBox, ifdi);
                if (!IsSpecialBpfdi((BPFDI)lBpfdi))
                {
                    lBpfdi += lCacheSave;
                    lcbSetItemDataPair(hwndList, fListBox, ifdi, lBpfdi, ((BPFDI)lBpfdi)->bTT);
                }
            }
        }
    }

    /*
     * Now add the information to the cache.  All the casting on bpfdiCache
     * is just to inhibit a bogus compiler complaint.
     */
    bpfdi->fdiWidthReq  = uWidthReq;
    bpfdi->fdiHeightReq = uHeightReq;

    bpfdi->fdiWidthActual  = uWidthActual;
    bpfdi->fdiHeightActual = uHeightActual;

    cfdiCache[idx]++;

  UpdateListCombo:

    if (hwndList) {
        /*
         * Add the string to the list/combo box if it isn't there already.
         */
        StringCchPrintf(szBuf, ARRAYSIZE(szBuf), TEXT("\t%2d\tx\t%2d"), uWidthActual, uHeightActual);

        dwIndex = lcbFindStringExact(hwndList, fListBox, szBuf);

        if (IsDlgError(dwIndex)) {
            /*
             * Not already on the list.  Add it.
             */
            dwIndex = lcbAddString(hwndList, fListBox, szBuf);

            if (IsDlgError(dwIndex)) {
                return BPFDI_CANCEL;
            }
            lcbSetItemDataPair(hwndList, fListBox, dwIndex,
                               bpfdi, uHeightReq);
        }
    }
    return bpfdi;
}


/** AddTrueTypeFontsToFontListA
 *
 *  To avoid rasterizing all the fonts unnecessarily, we load the
 *  information from the szTTCacheSection font cache.
 *
 *  Note that the cache information is not validated!  We just
 *  assume that if the value is in the cache, it is valid.
 *
 *  Entry:
 *      hwndList        =  List box or combo box to fill with info
 *      fListBox        =  TRUE if hwndList is a listbox, FALSE if a combo box
 *      lpszTTFaceName
 *
 *  Returns:
 *      TRUE if fonts were enumerated to completion.
 *      FALSE if enumeration failed.  (Out of memory.)
 *
 *  Caveats:
 *      The ParseIniWords call assumes that the values were written
 *      by AddOneNewTrueTypeFontToFontList, who wrote them out so
 *      that a single call to ParseIniWords will read the height and
 *      width directly into a dwHeightWidth.
 *
 *      Similarly, the second ParseIniWords reads the item directly into
 *      a dwHeightWidth.
 */

BOOL AddTrueTypeFontsToFontListA(HWND hwndList, BOOL fListBox,
                                        LPSTR lpszTTFaceName, INT CodePage)
{
    LPTSTR  pszBuf;
    LPTSTR  pszBufNew;
    LPTSTR  psz;
    LPTSTR  lpszNext;
    DWORD   dwHWReq;
    DWORD   dwHWActual;
    BOOL    fSuccess;
    DWORD   cchBuf;
    DWORD   cchActual;
    int     i;
    int     idx = IsBilingualCP(CodePage) ? 1 : 0;
    
    /*
     * See if we can load everything out of the szTTCacheSection.
     *
     * There is no API to get the size of a profile string, so we
     * have to fake it by reading, reallocing, and reading again
     * until it all fits.
     *
     * The initial value of 1024 characters means that we can handle
     * up to 128 font sizes.  A comfortable number, we hope.
     */

    cchBuf = 1024;
    cchActual = 0;
    pszBufNew = (LPTSTR)LocalAlloc(LPTR, cchBuf*sizeof(TCHAR));

    while (pszBufNew) {
        pszBuf = pszBufNew;
        cchActual = GetPrivateProfileString(szTTCacheSection[idx], NULL,
                                         c_szNULL, pszBuf, cchBuf, szSystemINI);
        if (cchActual < cchBuf - 5) goto Okay;

        cchBuf += 512;
        pszBufNew = (LPTSTR)LocalReAlloc(pszBuf, cchBuf*sizeof(TCHAR), LMEM_MOVEABLE|LMEM_ZEROINIT);
    }

    /* Bleargh.  Too much stuff in the cache.  Punt it and start anew. */
    goto FreshStart;

Okay:

    fSuccess = FALSE;

    /*
     *  In the time between flushing the cache and reloading it here,
     *  a handful of fonts may have gotten added to the cache due to
     *  WinOldAp trying to realize the font it got back.  So consider the
     *  font cache decent if there are at least ten fonts in it.
     */
    if (cchActual >= 4 * 10) {

        /*
         * We found cache information.  Party away.
         */

        psz = pszBuf;
        while (*psz) {

            if (ParseIniWords(psz, (PWORD)&dwHWReq, 2, &lpszNext) != 2 ||
                GetIniWords(szTTCacheSection[idx], psz,
                            (PWORD)&dwHWActual, 2, szSystemINI) != 2) {
                /* Font cache looks bogus.  Start with a new one. */
                goto FreshStart;
            }

            if (AddToFontListCache(hwndList, fListBox,
                                   (UINT)HIWORD(dwHWReq),
                                   (UINT)LOWORD(dwHWReq),
                                   (UINT)HIWORD(dwHWActual),
                                   (UINT)LOWORD(dwHWActual),
                                   CodePage) == BPFDI_CANCEL)
                goto E0;
                
            psz = (LPTSTR)(lpszNext + 1);       /* Skip past the NUL */
        }

    }
    else
    {
FreshStart:
        /* Blast the old cache, just make sure we have a clean slate */
        WritePrivateProfileString(szTTCacheSection[idx], NULL, NULL, szSystemINI);

        /* No cache available.  Need to build one. */
        for (i = 0; i < NUMINITIALTTHEIGHTS; i++) 
        {
            if (rgwInitialTtHeights[i]) 
            {
                AddOneNewTrueTypeFontToFontListA(hwndList, fListBox,
                                                0, (UINT)rgwInitialTtHeights[i],
                                                lpszTTFaceName, CodePage);
            }
        }
    }

    fSuccess = TRUE;
E0:
    EVAL(LocalFree(pszBuf) == NULL);
    return fSuccess;
}


/*  Given height and width, synthesize a TrueType font with those
 *  dimensions and record the actual font height and width in
 *  the persistent font cache, as well as a FDI.
 *
 *  Entry:
 *      hwndList        =  List box or combo box to fill with info
 *      fListBox        =  TRUE if hwndList is a listbox, FALSE if a combo box
 *      wHeight         =  Desired font height
 *      wWidth          =  Desired font width (can be zero for "default")
 *      lpszTTFaceName
 *
 *  Returns:
 *      BPFDI of font dimension info, or BPFDI_CANCEL on failure.
 *
 *  Caveats:
 *      The wsprintf assumes that the fdiWidthReq and
 *      fdiHeightReq fields appear in the indicated order,
 *      because the values will be read into a dwHeightWidth later.
 *
 *      Similarly for the WriteIniWords.
 */

BPFDI AddOneNewTrueTypeFontToFontListA(HWND hwndList,
                                      BOOL fListBox,
                                      UINT uWidth, UINT uHeight,
                                      LPSTR lpszTTFaceName, INT CodePage)
{
    BPFDI   bpfdi;
    HDC     hDC;
    HFONT   hFont;
    SIZE    sSize;
    HFONT   hFontPrev;
    DWORD   dwHeightWidth;
    TCHAR   szBuf[MAXDIMENSTRING];

    int     idx;
    BYTE    bCharset;
    DWORD   fdwClipPrecision;

    bpfdi = BPFDI_CANCEL;

    hDC = GetDC(NULL);          /* Get a screen DC */
    if (!hDC) goto E0;
    
    // choose charset, clip precision based on codepage
    // 0xFE is a hack for japanese platform
    //
    bCharset = (CodePage == CP_JPN? 0xFE: OEMCharsetFromCP(CodePage));
    
    if (CodePage == CP_US)
        fdwClipPrecision = CLIP_DEFAULT_PRECIS|(g_uCodePage == CP_WANSUNG? CLIP_DFA_OVERRIDE: 0);
    else
        fdwClipPrecision = CLIP_DEFAULT_PRECIS;

    hFont = CreateFontA((INT)uHeight, (INT)uWidth, 0, 0, 0, 0, 0, 0,
               bCharset, OUT_TT_PRECIS,
               fdwClipPrecision, 0, FIXED_PITCH | FF_DONTCARE, lpszTTFaceName);
               
    if (!hFont) goto E1;

    hFontPrev = SelectObject(hDC, hFont);
    if (!hFontPrev) goto E2;

    if (GetTextExtentPoint32(hDC, szZero, 1, &sSize))
    {
        dwHeightWidth = (sSize.cy << 16) | (sSize.cx & 0x00FF);
    }
    else
    {
        dwHeightWidth = 0;
    }

    if (!dwHeightWidth) goto E3;

    if (IsBilingualCP(CodePage) && (HIWORD(dwHeightWidth)%2))
        goto E3;

    StringCchPrintf(szBuf, ARRAYSIZE(szBuf), TEXT("%d %d"), uWidth, uHeight);

    idx = IsBilingualCP(CodePage) ? 0 : 1;
    
    WriteIniWords(szTTCacheSection[idx], szBuf, (PWORD)&dwHeightWidth, 2, szSystemINI);

    bpfdi = AddToFontListCache(hwndList, fListBox, uHeight, uWidth,
                               (UINT)sSize.cy, (UINT)sSize.cx,
                               CodePage);

E3: SelectObject(hDC, hFontPrev);
E2: DeleteObject(hFont);
E1: ReleaseDC(0, hDC);
E0: return bpfdi;

}


/*  Returns the BPFDI corresponding to the currently selected font in
 *  the indicated list or combo box, or BPFDI_CANCEL on error.
 *
 *  Entry:
 *      hwndList == handle to listbox or combo box to fill
 *                  if NULL, then AUTO font calculation is assumed
 *      fListBox == TRUE if hwndList is a listbox, FALSE if a combo box
 *      pfi      -> FNTINFO structure
 *                  if pfi is NULL, then AUTO font calculation is ignored
 *  Returns:
 *      BPFDI of the current selection, or BPFDI_CANCEL on error.
 */
DWORD_PTR GetFont(HWND hwndList, BOOL fListBox, PFNTINFO pfi)
{
    DWORD dwIndex = 0;
    BPFDI bpfdi = BPFDI_CANCEL;

    if (!hwndList) {            // just do AUTO calculations
        if (!pfi)
            goto Exit;          // whoops, can't even do those
        goto ChooseBest;
    }
    dwIndex = lcbGetCurSel(hwndList, fListBox);
    if (!IsDlgError(dwIndex)) {

        if (pfi)
            pfi->fntProposed.flFnt &= ~FNT_AUTOSIZE;

        bpfdi = lcbGetBpfdi(hwndList, fListBox, dwIndex);

        if (bpfdi == BPFDI_AUTO && pfi) {
            pfi->fntProposed.flFnt |= FNT_AUTOSIZE;

ChooseBest:
            bpfdi = ChooseBestFont((UINT)pfi->winOriginal.cxCells,
                                   (UINT)pfi->winOriginal.cyCells,
                                   (UINT)pfi->winOriginal.cxClient,
                                   (UINT)pfi->winOriginal.cyClient,
                                   (UINT)pfi->fntProposed.flFnt,
                                    (INT)pfi->fntProposed.wCurrentCP);
        }
        // Set the index of the current selection (HIWORD
        // of the return code) to LB_ERR if there's an error

        if (bpfdi == BPFDI_CANCEL)
            dwIndex = (DWORD)LB_ERR;
    }
  Exit:
    if (!IsSpecialBpfdi(bpfdi))
    {
        bpfdi->Index = dwIndex;
    }

    return (DWORD_PTR)bpfdi;
}


/*  Copies data from the given BPFDI to the given PROPFNT structure.
 *
 *  Entry:
 *      lpFnt = pointer to PROPFNT structure
 *      bpfdi = based pointer to a FONTDIMENINFO structure;
 *              if a special BPFDI_* constant, no font info is changed
 *  Returns:
 *      Nothing
 */
void SetFont(LPPROPFNT lpFnt, BPFDI bpfdi)
{
    if (!IsSpecialBpfdi(bpfdi)) 
    {
        lpFnt->flFnt &= ~(FNT_RASTER | FNT_TT);

        if (bpfdi->fdiHeightReq == 0) 
        {
            /* Raster font */
            lpFnt->flFnt |= FNT_RASTER;
            lpFnt->cxFont = lpFnt->cxFontActual = (WORD) bpfdi->fdiWidthActual;
            lpFnt->cyFont = lpFnt->cyFontActual = (WORD) bpfdi->fdiHeightActual;
        }
        else 
        {
            /* TrueType font */
            lpFnt->flFnt |= FNT_TT;
            lpFnt->cxFont = (WORD) bpfdi->fdiWidthReq;
            lpFnt->cyFont = (WORD) bpfdi->fdiHeightReq;
            lpFnt->cxFontActual = (WORD) bpfdi->fdiWidthActual;
            lpFnt->cyFontActual = (WORD) bpfdi->fdiHeightActual;
        }
    }
}


/*  Performs the following calculation in LONG arithmetic to avoid
 *  overflow:
 *      return = n1 * m / n2
 *  This can be used to make an aspect ration calculation where n1/n2
 *  is the aspect ratio and m is a known value.  The return value will
 *  be the value that corresponds to m with the correct apsect ratio.
 */

//
// <This is defined as a macro for Win32 >
//

/*  Scales a point to be preview-sized instead of screen-sized.
 *  Depends on the global vars cxScreen and cyScreen established at init.
 */

void AspectPoint(LPRECT lprcPreview, LPPOINT lppt)
{
    lppt->x = AspectScale(lprcPreview->right, cxScreen, lppt->x);
    lppt->y = AspectScale(lprcPreview->bottom, cyScreen, lppt->y);
}

/*  AspectRect
 *
 *  Scales a rectangle to be preview-sized instead of screen-sized.
 *  Depends on the global vars cxScreen and cyScreen established at init.
 */

void AspectRect(LPRECT lprcPreview, LPRECT lprc)
{
    AspectPoint(lprcPreview, &((LPPOINT)lprc)[0]); /* Upper left corner */
    AspectPoint(lprcPreview, &((LPPOINT)lprc)[1]); /* Lower right corner */
}

/*  Given a BPFDI, create a font that corresponds to it.
 *
 *  Entry:
 *      bpfdi       -> FDI describing the font we want to create
 *      pfi         -> proposed font info structure
 *
 *  Returns:
 *      HFONT that was created.
 */
HFONT CreateFontFromBpfdi(BPFDI bpfdi, PFNTINFO pfi)
{
    HFONT hf;
    int   fdwClipPrecision;
    BYTE  bT2Charset;

    // a hack for japanese charset
    bT2Charset = (pfi->fntProposed.wCurrentCP == CP_JPN? 
                  0xFE: OEMCharsetFromCP(pfi->fntProposed.wCurrentCP));
    
    if (pfi->fntProposed.wCurrentCP == CP_US)
        fdwClipPrecision = CLIP_DEFAULT_PRECIS|(g_uCodePage == CP_WANSUNG? CLIP_DFA_OVERRIDE: 0);
    else
        fdwClipPrecision = CLIP_DEFAULT_PRECIS;
        
    if (bpfdi->fdiHeightReq == 0) {
        /* Raster font */
        hf = CreateFontA(bpfdi->fdiHeightActual, bpfdi->fdiWidthActual,
            0, 0, 0, 0, 0, 0, (BYTE)OEMCharsetFromCP(pfi->fntProposed.wCurrentCP), 
            OUT_RASTER_PRECIS, fdwClipPrecision,
            0, FIXED_PITCH | FF_DONTCARE, pfi->fntProposed.achRasterFaceName);
    } else {
        /* a TrueType font */
        hf = CreateFontA(bpfdi->fdiHeightReq, bpfdi->fdiWidthReq,
            0, 0, 0, 0, 0, 0, (BYTE)bT2Charset, OUT_TT_PRECIS, fdwClipPrecision,
            0, FIXED_PITCH | FF_DONTCARE, pfi->fntProposed.achTTFaceName);
    }

    return hf;
}


/** FontSelInit
 *
 *  Obtain the various font selection penalties from SYSTEM.INI
 *  and force the values into range.
 *
 *  Entry:
 *      rgwInitialTtHeights contains default values for sizes.
 *
 *  Exit:
 *      rgwInitialTtHeights contains actual values for sizes.
 */

void FontSelInit(void)
{
    GetIniWords(szNonWinSection, szTTInitialSizes,
                rgwInitialTtHeights, sizeof(rgwInitialTtHeights)/sizeof(WORD), szSystemINI);
}


/*  Convert logical dimensions for a TrueType font into physical
 *  dimensions.  If possible, we get this information from the
 *  font dimension cache, but in the case where this is not possible,
 *  we synthesize the font and measure him directly.
 *
 *  Entry:
 *      dxWidth  = logical font width
 *      dyHeight = logical font height
 *
 *  Returns:
 *      BPFDI pointing to dimension information, or BPFDI_CANCEL on failure.
 */

BPFDI GetTrueTypeFontTrueDimensions(UINT dxWidth, UINT dyHeight, INT CodePage)
{
    IFDI    ifdi;
    BPFDI   bpfdi;
    int     idx = IsBilingualCP(CodePage)? 1 : 0;
    for (ifdi = 0, bpfdi = (BPFDI)((DWORD_PTR)lpCache + bpfdiStart[idx]);  
                    ifdi < cfdiCache[idx];  ifdi++, bpfdi++)
    {
        if (bpfdi->fdiWidthReq  == dxWidth &&
            bpfdi->fdiHeightReq == dyHeight) {
            return bpfdi;
        }
    }

    /*
     * The font dimensions have not been cached.  We have to create it.
     */
    return (BPFDI)AddOneNewTrueTypeFontToFontListA(0, 0, dxWidth, dyHeight,
                                                 szTTFaceName[idx], CodePage);
}


/*  Look for a font that matches the indicated dimensions, creating
 *  one if necessary.
 *
 *  But we never create a font which is too narrow or too short.
 *  The limits are controlled by the ptNonAspectMin variable.
 *
 *  Entry:
 *      dxWidth  = desired font width
 *      dyHeight = desired font height
 *      fPerfect = see below
 *
 *          If fPerfect is TRUE, then a perfect match is requested
 *          from the font cache (we should not try to synthesize a font).
 *          In which case, the sign of dyHeight determines whether a
 *          raster font (positive) or TrueType font (negative) is
 *          desired.  If a perfect match cannot be found, then we
 *          return BPFDI_CANCEL.
 *
 *  Returns:
 *      BPFDI of of the font that matches the best.
 *      BPFDI_CANCEL if no font could be found.
 */
BPFDI FindFontMatch(UINT dxWidth, UINT dyHeight, LPINT lpfl, INT CodePage)
{
    IFDI    ifdi;
    BPFDI   bpfdi;
    BPFDI   bpfdiBest = BPFDI_CANCEL;
    PENALTY pnlBest = SENTINELPENALTY;
    int     idx;

    int fl = *lpfl;
    /*
     * First, see if a perfect match already exists.
     */
    idx = IsBilingualCP(CodePage) ? 1 : 0;
    for (ifdi = 0, bpfdi = (BPFDI)((DWORD_PTR)lpCache+bpfdiStart[idx]);  
                    ifdi < cfdiCache[idx];  ifdi++, bpfdi++)
    {

        if (fl & FFM_RESTRICTED) {
            /* Deal with the restrictions.
             * Reject the font if it is raster but we want TTONLY, or v.v.
             *
             * The condition below reads as
             *
             *      If (is a raster font != want a raster font)
             */
            if (!bpfdi->fdiHeightReq != (fl == FFM_RASTERFONTS)) {
                continue;
            }
        }
        if (bpfdi->fdiHeightActual == dyHeight && bpfdi->fdiWidthActual == dxWidth) {
            *lpfl = FFM_PERFECT;
            return bpfdi;
    }   }

    if (fl != FFM_TTFONTS)
        return BPFDI_CANCEL;
    /*
     * We got here if we couldn't find a perfect match.
     *
     * Adjust the requested height and width for aspect ratio
     * constraints.  If adjustments are necessary, trust the height.
     *
     * Comparisons are as WORDs (unsigned) so that a setting of "-1 -1"
     * lets the user forbid all non-aspect ratio fonts.
     */
    if (dyHeight < (UINT)ptNonAspectMin.y || dxWidth < (UINT)ptNonAspectMin.x) {
        dxWidth = 0;
    }
    return GetTrueTypeFontTrueDimensions(dxWidth, dyHeight, CodePage);
}

/*  We have decided whether the desired size is larger or smaller.
 *  Compute the penalty corresponding to the Initial and Scale.
 *
 *  Entry:
 *      ppnlp   -> PENALTYPAIR to apply
 *      dSmaller = the smaller dimension
 *      dLarger  = the larger dimension
 *
 *  Exit:
 *      Returns penalty to apply to the difference in dimensions.
 */
PENALTY ComputePenaltyFromPair(PPENALTYPAIR ppnlp,
                               UINT dSmaller, UINT dLarger)
{
    return (ppnlp->pnlInitial +
            ppnlp->pnlScale - MulDiv(ppnlp->pnlScale, dSmaller, dLarger));
}


/*  Compute the penalty depending on whether the desired size
 *  is smaller, equal to, or larger than the actual size.
 *
 *  Entry:
 *      ppnll   -> PENALTYLIST to apply
 *      dActual  = the actual dimension
 *      dDesired = the desired dimension
 *
 *  Exit:
 *      Returns penalty to apply to the difference in dimensions,
 *      choosing between the Overshoot and Shortfall PENALTYPAIRS,
 *      accordingly.
 */
PENALTY ComputePenaltyFromList(PPENALTYLIST ppnll,
                               UINT dActual, UINT dDesired)
{
    if (dActual == dDesired)
        return 0;

    if (dActual < dDesired)
        return ComputePenaltyFromPair(&ppnll->pnlpOvershoot, dActual, dDesired);

    return ComputePenaltyFromPair(&ppnll->pnlpShortfall, dDesired, dActual);
}


/** ComputePenalty
 *
 *  Compute the total penalty associated to a window size.
 *
 *  Entry:
 *      dxCells  = width of window in cells
 *      dyCells  = height of window in cells
 *      dxClient = actual horizontal size of window
 *      dyClient = actual vertical   size of window
 *      dxFont   = width of one character in the font
 *      dyFont   = height of one character in the font
 *
 *  Exit:
 *      Returns total penalty associated to a window of the indicated
 *      size with a font of the indicated dimensions.
 */
PENALTY ComputePenalty(UINT cxCells,  UINT cyCells,
                       UINT dxClient, UINT dyClient,
                       UINT dxFont,   UINT dyFont)
{
    return
        (ComputePenaltyFromList(&pnllX, dxClient, dxFont * cxCells) +
         ComputePenaltyFromList(&pnllY, dyClient, dyFont * cyCells));
}


/** ChooseBestFont
 *
 *  Determine which font looks best for the specified window size
 *  by picking the one which has the smallest penalty.
 *
 *  Entry:
 *      dxCells = width of window in cells
 *      dyCells = height of window in cells
 *      dxClient= width of window we want to fit into
 *      dyClient= height of window we want to fit into
 *      fl      = font pool flags
 *
 *  Returns:
 *      Word offset from lpFontTable of the font we've decided to use.
 *      BPFDI_CANCEL if no font could be found.  (Should never happen.)
 *
 *  NOTE!
 *      We do *not* FontEnum through all the fonts because that would be
 *      too slow.  Instead, we inspect the cache of available font
 *      dimensions, and only after we've chosen the best font do we
 *      load all his other info.
 *
 *      This means that if the user installs new fonts, we won't see
 *      them until the cache is updated on receipt of a WM_FONTCHANGEff
 *      message, or the user either (1) pulls down the font list box,
 *      or (2) calls up the font selection dialog box.
 */

BPFDI ChooseBestFont(UINT cxCells, UINT cyCells, UINT dxClient, UINT dyClient,
                                                         INT fl, INT CodePage)
{
    int     flTemp;
    DWORD    ifdi;
    BPFDI   bpfdi;
    PENALTY pnl;
    UINT    dxWidth, dyHeight;
    BPFDI   bpfdiBest = BPFDI_CANCEL;
    PENALTY pnlBest = SENTINELPENALTY;
    int     idx;
    static int prev_CodePage;  // Only Japan is interested in prev_CodePage.

    /*
     * First, synthesize the theoretical best match.
     */
    if (!cxCells)
        cxCells = 80;           // if we get called with no real data,
    if (!cyCells)               // at least try to do something reasonable
        cyCells = 25;

    //
    // In the case where the values passed in don't make sense,
    // we default to raster 8x12.
    //
    dxWidth = (dxClient >= cxCells)? dxClient / cxCells : 8;
    dyHeight = (dyClient >= cyCells)? dyClient / cyCells : 12;

    //
    // Now, if we bad values, make some sense out of bad values for
    // dxClient & dyClient
    //

    if ((dxClient==0) || (dyClient==0))
    {
        dxClient = dxWidth * 80;
        dyClient = dyHeight * 25;
    }

    flTemp = 0;
    if ((fl & FNT_BOTHFONTS) != FNT_BOTHFONTS) {
        flTemp = FFM_RASTERFONTS;
        if (fl & FNT_TTFONTS)
            flTemp = FFM_TTFONTS;
    }
    bpfdi = FindFontMatch(dxWidth, dyHeight, &flTemp, CodePage);
    if (flTemp == FFM_PERFECT)
    {
        prev_CodePage = CodePage;
        return bpfdi;
    }

    idx = IsBilingualCP(CodePage)? 1 : 0;
    for (ifdi = 0, bpfdi = (BPFDI)((DWORD_PTR)lpCache+bpfdiStart[idx]);  
                    ifdi < cfdiCache[idx];  ifdi++, bpfdi++)
    {
        // If the font pool is restricted, then only look at like fonts

        if (flTemp)
            if (!bpfdi->fdiHeightReq != (flTemp == FFM_RASTERFONTS))
                continue;

// was ifdef JAPAN (hack)
// to prevent DOS_BOX shrinking which occurs toggling CP437 & CP932,
// just select one size bigger font when change CP437 to CP932
        if (CodePage == 932 && prev_CodePage == 437) {
           if (dxWidth < bpfdi->fdiWidthActual) {
              if (bpfdiBest->fdiWidthActual > bpfdi->fdiWidthActual)
                 bpfdiBest = bpfdi;
              else if (bpfdiBest->fdiWidthActual == bpfdi->fdiWidthActual &&
                       bpfdiBest->fdiHeightActual > bpfdi->fdiHeightActual)
                 bpfdiBest = bpfdi;
           }
           else {
              if (dxWidth == bpfdi->fdiWidthActual) {
                 if (bpfdi->fdiHeightActual > dyHeight &&
                     bpfdiBest->fdiHeightActual > bpfdi->fdiHeightActual)
                    bpfdiBest = bpfdi;
              }
           }
        }
        else 
// was the end of ifdef JAPAN
        {
        pnl = 0;
        if (bpfdi->fdiHeightReq)
            pnl = pnlTrueType;

        pnl += ComputePenalty(cxCells, cyCells,
                              dxClient, dyClient,
                              bpfdi->fdiWidthActual,
                              bpfdi->fdiHeightActual);

        if (pnl <= pnlBest) {
            pnlBest = pnl;
            bpfdiBest = bpfdi;
        }
        }
    }
// was ifdef JAPAN
    prev_CodePage = CodePage;
// was end of ifdef JAPAN
    return bpfdiBest;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\pifdat.c ===
#include "shellprv.h"
#pragma hdrstop

#ifdef _X86_

extern PROPTSK tskDefault;
extern PROPVID vidDefault;
extern PROPMEM memDefault;
extern PROPKBD kbdDefault;
extern WORD    flWinDefault;

#define _LP386_   ((LPW386PIF30)aDataPtrs[LP386_INDEX])
#define _LPENH_   ((LPWENHPIF40)aDataPtrs[LPENH_INDEX])
#define _LPWNT40_ ((LPWNTPIF40)aDataPtrs[LPNT40_INDEX])
#define _LPWNT31_ ((LPWNTPIF31)aDataPtrs[LPNT31_INDEX])
extern const TCHAR szDefIconFile[];


/*
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (may be NULL)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpPrg -> where to store program property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetPrgData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPPRG lpPrg, int cb, UINT flOpt)
{
    int lenCmdLine;
    LPSTR lpsz;
    LPPIFDATA lppd;
    FunctionName(GetPrgData);

    if (!(NULL != (lppd = ppl->lpPIFData)) || cb < sizeof(PROPPRG))
        return 0;

    lpPrg->flPrg = PRG_DEFAULT;
    lpPrg->flPrgInit = PRGINIT_DEFAULT;
    lpPrg->dwRealModeFlags = 0;

    lpPrg->flPrgInit |= ppl->flProp & (PROP_NOPIF | PROP_DEFAULTPIF | PROP_INFSETTINGS);

    PifMgr_WCtoMBPath( (LPWSTR)szDefIconFile, lpPrg->achIconFile, ARRAYSIZE(lpPrg->achIconFile) );
    PifMgr_WCtoMBPath( ppl->ofPIF.szPathName, lpPrg->achPIFFile, ARRAYSIZE(lpPrg->achPIFFile) );
    lpPrg->wIconIndex = ICONINDEX_DEFAULT;

    if (lppd->stdpifdata.MSflags & EXITMASK)
        lpPrg->flPrg |= PRG_CLOSEONEXIT;

    StringCchCopyA(lpPrg->achTitle, ARRAYSIZE(lpPrg->achTitle), lppd->stdpifdata.appname);
    StrTrimA(lpPrg->achTitle, " ");

    lenCmdLine = lstrcpyfnameA(lpPrg->achCmdLine, ARRAYSIZE(lpPrg->achCmdLine), lppd->stdpifdata.startfile);

    lpsz = lppd->stdpifdata.params;
    if (aDataPtrs[ LP386_INDEX ]) {
        lpsz = _LP386_->PfW386params;

        CTASSERTF(PRGINIT_MINIMIZED      == (fMinimized      >> fMinimizedBit));
        CTASSERTF(PRGINIT_MAXIMIZED      == (fMaximized      >> fMinimizedBit));
        CTASSERTF(PRGINIT_REALMODE       == (fRealMode       >> fMinimizedBit));
        CTASSERTF(PRGINIT_REALMODESILENT == (fRealModeSilent >> fMinimizedBit));
        CTASSERTF(PRGINIT_QUICKSTART     == (fQuickStart     >> fMinimizedBit));
        CTASSERTF(PRGINIT_AMBIGUOUSPIF   == (fAmbiguousPIF   >> fMinimizedBit));

        if (_LP386_->PfW386Flags & fWinLie)
            lpPrg->flPrgInit |= PRGINIT_WINLIE;

        if (_LP386_->PfW386Flags & fNoSuggestMSDOS)
            lpPrg->flPrg |= PRG_NOSUGGESTMSDOS;

        lpPrg->flPrgInit |= (WORD)((_LP386_->PfW386Flags & (fMinimized | fMaximized | fRealMode | fRealModeSilent | fQuickStart | fAmbiguousPIF)) >> fMinimizedBit);
        if (_LP386_->PfW386Flags & fHasHotKey) {
            lpPrg->wHotKey = HotKeyWindowsFromOem((LPPIFKEY)&_LP386_->PfHotKeyScan);
        } else {
            lpPrg->wHotKey = 0;
        }
    }
    if (lenCmdLine == 0) {
        // If we had a problem with the appname, lets not
        // compound it by adding on arguments.
    } else {
        if (*lpsz && ((int)(lstrlenA(lpsz)) < (int)(ARRAYSIZE(lpPrg->achCmdLine)-lenCmdLine-1)))
        {
            StringCchCatA(lpPrg->achCmdLine, ARRAYSIZE(lpPrg->achCmdLine), " ");
            StringCchCatA(lpPrg->achCmdLine, ARRAYSIZE(lpPrg->achCmdLine), lpsz);
        }
    }

    lstrcpyfnameA(lpPrg->achWorkDir, ARRAYSIZE(lpPrg->achWorkDir), lppd->stdpifdata.defpath);

    if (_LPENH_) {
        if (_LPENH_->achIconFileProp[0]) {
            StringCchCopyA(lpPrg->achIconFile, ARRAYSIZE(lpPrg->achIconFile), _LPENH_->achIconFileProp);
            lpPrg->wIconIndex = _LPENH_->wIconIndexProp;
        }
        lpPrg->dwEnhModeFlags = _LPENH_->dwEnhModeFlagsProp;
        lpPrg->dwRealModeFlags = _LPENH_->dwRealModeFlagsProp;
        StringCchCopyA(lpPrg->achOtherFile, ARRAYSIZE(lpPrg->achOtherFile), _LPENH_->achOtherFileProp);
    }

    if (!(flOpt & GETPROPS_OEM)) {
        /* Convert all strings from OEM character set to Ansi */
        OemToCharA(lpPrg->achTitle, lpPrg->achTitle);       // reviewed 04/10/02
        OemToCharA(lpPrg->achCmdLine, lpPrg->achCmdLine);   // reviewed 04/10/02
        OemToCharA(lpPrg->achWorkDir, lpPrg->achWorkDir);   // reviewed 04/10/02
    }
    return sizeof(PROPPRG);
}


/** SetPrgData - set program property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (GUARANTEED!)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpPrg -> where to store program property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetPrgData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPPRG lpPrg, int cb, UINT flOpt)
{
    int i;
    LPPIFDATA lppd;
    FunctionName(SetPrgData);

    if (!(NULL != (lppd = ppl->lpPIFData)) || cb < sizeof(PROPPRG))
        return 0;

    lppd->stdpifdata.MSflags &= ~EXITMASK;
    if (lpPrg->flPrg & PRG_CLOSEONEXIT)
        lppd->stdpifdata.MSflags |= EXITMASK;

    CTASSERTF(PRGINIT_MINIMIZED      == (fMinimized      >> fMinimizedBit));
    CTASSERTF(PRGINIT_MAXIMIZED      == (fMaximized      >> fMinimizedBit));
    CTASSERTF(PRGINIT_REALMODE       == (fRealMode       >> fMinimizedBit));
    CTASSERTF(PRGINIT_REALMODESILENT == (fRealModeSilent >> fMinimizedBit));
    CTASSERTF(PRGINIT_QUICKSTART     == (fQuickStart     >> fMinimizedBit));
    CTASSERTF(PRGINIT_AMBIGUOUSPIF   == (fAmbiguousPIF   >> fMinimizedBit));

    _LP386_->PfW386Flags &= ~(fHasHotKey | fWinLie | fMinimized | fMaximized | fRealMode | fRealModeSilent | fQuickStart | fAmbiguousPIF | fNoSuggestMSDOS);
    if (lpPrg->wHotKey)
        _LP386_->PfW386Flags |= fHasHotKey;
    if (!(lpPrg->flPrg & PRGINIT_WINLIE))
        _LP386_->PfW386Flags |= fWinLie;
    if (lpPrg->flPrg & PRG_NOSUGGESTMSDOS)
        _LP386_->PfW386Flags |= fNoSuggestMSDOS;
    _LP386_->PfW386Flags |= (DWORD)(lpPrg->flPrgInit & (PRGINIT_MINIMIZED | PRGINIT_MAXIMIZED | PRGINIT_REALMODE | PRGINIT_REALMODESILENT | PRGINIT_QUICKSTART | PRGINIT_AMBIGUOUSPIF)) << fMinimizedBit;

    lstrcpypadA(lppd->stdpifdata.appname, lpPrg->achTitle, ARRAYSIZE(lppd->stdpifdata.appname));

    lstrunquotefnameA(lppd->stdpifdata.startfile, lpPrg->achCmdLine, ARRAYSIZE(lppd->stdpifdata.startfile), FALSE);

    i = lstrskipfnameA(lpPrg->achCmdLine);
    i += lstrskipcharA(lpPrg->achCmdLine+i, ' ');
    StringCchCopyA(lppd->stdpifdata.params, ARRAYSIZE(lppd->stdpifdata.params), lpPrg->achCmdLine+i);
    StringCchCopyA(_LP386_->PfW386params, ARRAYSIZE(_LP386_->PfW386params), lpPrg->achCmdLine+i);

    if (lpPrg->achWorkDir[0] != '\"')
        StringCchCopyA(lppd->stdpifdata.defpath, ARRAYSIZE(lppd->stdpifdata.defpath), lpPrg->achWorkDir);
    else
        lstrunquotefnameA(lppd->stdpifdata.defpath, lpPrg->achWorkDir, ARRAYSIZE(lppd->stdpifdata.defpath), FALSE);

    HotKeyOemFromWindows((LPPIFKEY)&_LP386_->PfHotKeyScan, lpPrg->wHotKey);

    StringCchCopyA(_LPENH_->achIconFileProp, ARRAYSIZE(_LPENH_->achIconFileProp), lpPrg->achIconFile);
    _LPENH_->wIconIndexProp = lpPrg->wIconIndex;

    _LPENH_->dwEnhModeFlagsProp = lpPrg->dwEnhModeFlags;
    _LPENH_->dwRealModeFlagsProp = lpPrg->dwRealModeFlags;

    StringCchCopyA(_LPENH_->achOtherFileProp, ARRAYSIZE(_LPENH_->achOtherFileProp), lpPrg->achOtherFile);

    MultiByteToWideChar( CP_ACP, 0,
                         lpPrg->achPIFFile, -1,
                         ppl->ofPIF.szPathName,
                         ARRAYSIZE(ppl->ofPIF.szPathName)
                        );

    if (!(flOpt & SETPROPS_OEM)) {
        /* Convert all strings from Ansi character set to OEM */
        CharToOemBuffA(lppd->stdpifdata.appname, lppd->stdpifdata.appname, ARRAYSIZE(lppd->stdpifdata.appname));
        CharToOemBuffA(lppd->stdpifdata.startfile, lppd->stdpifdata.startfile, ARRAYSIZE(lppd->stdpifdata.startfile));
        CharToOemBuffA(lppd->stdpifdata.defpath, lppd->stdpifdata.defpath, ARRAYSIZE(lppd->stdpifdata.defpath));
        CharToOemBuffA(lppd->stdpifdata.params, lppd->stdpifdata.params, ARRAYSIZE(lppd->stdpifdata.params));
    }
    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPPRG);
}


/*
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (may be NULL)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpTsk -> where to store tasking property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetTskData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPTSK lpTsk, int cb, UINT flOpt)
{
    // Set defaults in case no appropriate section exists

    *lpTsk = tskDefault;

    // If an enh section exists, get it

    if (_LPENH_)
        *lpTsk = _LPENH_->tskProp;

    // Get any data that must still be maintained in the old 386 section

    if (_LP386_) {

        lpTsk->flTsk &= ~(TSK_ALLOWCLOSE | TSK_BACKGROUND | TSK_EXCLUSIVE);
        lpTsk->flTsk |= _LP386_->PfW386Flags & (fEnableClose | fBackground);
        if (!(_LP386_->PfW386Flags & fPollingDetect))
            lpTsk->wIdleSensitivity = 0;
    }
    return sizeof(PROPTSK);
}


/** SetTskData - set tasking property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (GUARANTEED!)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpTsk -> where to store tasking property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetTskData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPTSK lpTsk, int cb, UINT flOpt)
{
    _LPENH_->tskProp = *lpTsk;

    _LP386_->PfW386Flags &= ~(fEnableClose | fBackground | fExclusive | fPollingDetect);
    _LP386_->PfW386Flags |= (lpTsk->flTsk & (TSK_ALLOWCLOSE | TSK_BACKGROUND));
    if (lpTsk->wIdleSensitivity)
        _LP386_->PfW386Flags |= fPollingDetect;

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPTSK);
}


/** GetVidData - get video property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (may be NULL)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpVid -> where to store video property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetVidData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPVID lpVid, int cb, UINT flOpt)
{
    // Set defaults in case no appropriate section exists

    *lpVid = vidDefault;

    // If an enh section exists, get it

    if (_LPENH_)
        *lpVid = _LPENH_->vidProp;

    // Get any data that must still be maintained in the old 386 section

    if (_LP386_) {

        // Clear bits that already existed in the 386 section

        lpVid->flVid &= ~(VID_TEXTEMULATE | VID_RETAINMEMORY | VID_FULLSCREEN);
        lpVid->flVid |= _LP386_->PfW386Flags2 & (fVidTxtEmulate | fVidRetainAllo);

        if (_LP386_->PfW386Flags & fFullScreen)
            lpVid->flVid |= VID_FULLSCREEN;

    }

    return sizeof(PROPVID);
}


/** SetVidData - set video property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (GUARANTEED!)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpVid -> where to store video property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetVidData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPVID lpVid, int cb, UINT flOpt)
{
    _LPENH_->vidProp = *lpVid;

    _LP386_->PfW386Flags &= ~(fFullScreen);
    if (lpVid->flVid & VID_FULLSCREEN)
        _LP386_->PfW386Flags |= fFullScreen;

    _LP386_->PfW386Flags2 &= ~(fVidTxtEmulate | fVidRetainAllo);
    _LP386_->PfW386Flags2 |= lpVid->flVid & (fVidTxtEmulate | fVidRetainAllo);

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPVID);
}


/** GetMemData - get memory property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (may be NULL)
 *  lpenh -> enhanced PIF data (NOT USED)
 *  lpMem -> where to store memory property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetMemData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPMEM lpMem, int cb, UINT flOpt)
{
    // Set defaults in case no appropriate section exists

    *lpMem = memDefault;

    // Get any data that must still be maintained in the old 386 section

    if (_LP386_) {

        // Clear bits that already exist in the 386 section

        lpMem->flMemInit &= ~(MEMINIT_NOHMA |
                              MEMINIT_LOWLOCKED |
                              MEMINIT_EMSLOCKED |
                              MEMINIT_XMSLOCKED |
                              MEMINIT_GLOBALPROTECT |
                              MEMINIT_LOCALUMBS |
                              MEMINIT_STRAYPTRDETECT);

        if (_LP386_->PfW386Flags & fNoHMA)
            lpMem->flMemInit |= MEMINIT_NOHMA;
        if (_LP386_->PfW386Flags & fVMLocked)
            lpMem->flMemInit |= MEMINIT_LOWLOCKED;
        if (_LP386_->PfW386Flags & fEMSLocked)
            lpMem->flMemInit |= MEMINIT_EMSLOCKED;
        if (_LP386_->PfW386Flags & fXMSLocked)
            lpMem->flMemInit |= MEMINIT_XMSLOCKED;
        if (_LP386_->PfW386Flags & fGlobalProtect)
            lpMem->flMemInit |= MEMINIT_GLOBALPROTECT;
        if (_LP386_->PfW386Flags & fLocalUMBs)
            lpMem->flMemInit |= MEMINIT_LOCALUMBS;

        // NOTE: we don't provide a UI for this (debugging) feature, but all
        // the support is still in place.

        if (_LP386_->PfW386Flags & fStrayPtrDetect)
            lpMem->flMemInit |= MEMINIT_STRAYPTRDETECT;

        lpMem->wMinLow = _LP386_->PfW386minmem;
        lpMem->wMinEMS = _LP386_->PfMinEMMK;
        lpMem->wMinXMS = _LP386_->PfMinXmsK;

        lpMem->wMaxLow = _LP386_->PfW386maxmem;
        lpMem->wMaxEMS = _LP386_->PfMaxEMMK;
        lpMem->wMaxXMS = _LP386_->PfMaxXmsK;
    }
    return sizeof(PROPMEM);
}


/** SetMemData - set memory property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (GUARANTEED!)
 *  lpenh -> enhanced PIF data (NOT USED)
 *  lpMem -> where to store memory property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetMemData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPMEM lpMem, int cb, UINT flOpt)
{
    _LP386_->PfW386Flags &= ~(fNoHMA |
                            fVMLocked |
                            fEMSLocked |
                            fXMSLocked |
                            fGlobalProtect |
                            fLocalUMBs |
                            fStrayPtrDetect);

    if (lpMem->flMemInit & MEMINIT_NOHMA)
        _LP386_->PfW386Flags |= fNoHMA;

    // Note that we now only honor updating the locked memory bits
    // if the corresponding memory quantity has been set to a SPECIFIC
    // value.  We want to avoid someone changing a memory setting to
    // "Automatic" and having an indeterminate amount of memory inadvertently
    // locked. -JTP

    if ((lpMem->flMemInit & MEMINIT_LOWLOCKED) && (lpMem->wMinLow == lpMem->wMaxLow))
        _LP386_->PfW386Flags |= fVMLocked;
    if ((lpMem->flMemInit & MEMINIT_EMSLOCKED) && (lpMem->wMinEMS == lpMem->wMaxEMS))
        _LP386_->PfW386Flags |= fEMSLocked;
    if ((lpMem->flMemInit & MEMINIT_XMSLOCKED) && (lpMem->wMinXMS == lpMem->wMaxXMS))
        _LP386_->PfW386Flags |= fXMSLocked;

    if (lpMem->flMemInit & MEMINIT_GLOBALPROTECT)
        _LP386_->PfW386Flags |= fGlobalProtect;
    if (lpMem->flMemInit & MEMINIT_LOCALUMBS)
        _LP386_->PfW386Flags |= fLocalUMBs;
    if (lpMem->flMemInit & MEMINIT_STRAYPTRDETECT)
        _LP386_->PfW386Flags |= fStrayPtrDetect;

    _LP386_->PfW386minmem = lpMem->wMinLow;
    _LP386_->PfMinEMMK    = lpMem->wMinEMS;
    _LP386_->PfMinXmsK    = lpMem->wMinXMS;

    _LP386_->PfW386maxmem = lpMem->wMaxLow;
    _LP386_->PfMaxEMMK    = lpMem->wMaxEMS;
    _LP386_->PfMaxXmsK    = lpMem->wMaxXMS;

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPMEM);
}


/*
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (may be NULL)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpKbd -> where to store keyboard property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetKbdData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPKBD lpKbd, int cb, UINT flOpt)
{
    // Set defaults in case no appropriate section exists

    *lpKbd = kbdDefault;

    // If an enh section exists, get it

    if (_LPENH_)
        *lpKbd = _LPENH_->kbdProp;

    // Perform limited validation; there are a variety of places we can
    // do validation (at the time defaults are captured from SYSTEM.INI,
    // and whenever properties are saved), but minimum validation requires
    // we at least check the values we're returning to the outside world
    //
    // I would also say that as a general rule ring 0 code should never
    // trust data coming from ring 3 as fully validated.  In addition, the
    // UI layer will want to do input validation to provide immediate feedback,
    // so validation in this layer seems pretty non-worthwhile.

    if (lpKbd->msAltDelay == 0)         // we know this is bad at any rate
        lpKbd->msAltDelay = KBDALTDELAY_DEFAULT;

    // Get any data that must still be maintained in the old 386 section

    if (_LP386_) {

        // Clear bits that already exist in the 386 section

        lpKbd->flKbd &= ~(KBD_FASTPASTE  |
                          KBD_NOALTTAB   |
                          KBD_NOALTESC   |
                          KBD_NOALTSPACE |
                          KBD_NOALTENTER |
                          KBD_NOALTPRTSC |
                          KBD_NOPRTSC    |
                          KBD_NOCTRLESC);

        lpKbd->flKbd |= _LP386_->PfW386Flags & (fALTTABdis | fALTESCdis | fALTSPACEdis | fALTENTERdis | fALTPRTSCdis | fPRTSCdis | fCTRLESCdis);

        if (_LP386_->PfW386Flags & fINT16Paste)
            lpKbd->flKbd |= KBD_FASTPASTE;
    }
    return sizeof(PROPKBD);
}


/** SetKbdData - set keyboard property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (GUARANTEED!)
 *  _LPENH_ -> enhanced PIF data (GUARANTEED!)
 *  lpKbd -> where to store keyboard property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetKbdData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPKBD lpKbd, int cb, UINT flOpt)
{
    _LPENH_->kbdProp = *lpKbd;

    _LP386_->PfW386Flags &= ~fINT16Paste;
    if (lpKbd->flKbd & KBD_FASTPASTE)
        _LP386_->PfW386Flags |= fINT16Paste;

    _LP386_->PfW386Flags &= ~(fALTTABdis | fALTESCdis | fALTSPACEdis | fALTENTERdis | fALTPRTSCdis | fPRTSCdis | fCTRLESCdis);
    _LP386_->PfW386Flags |= lpKbd->flKbd & (fALTTABdis | fALTESCdis | fALTSPACEdis | fALTENTERdis | fALTPRTSCdis | fPRTSCdis | fCTRLESCdis);

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPKBD);
}


/*
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  ((LPW386PIF30)aDataPtrs[ LP386_INDEX ]) -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpMse -> where to store mouse property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetMseData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPMSE lpMse, int cb, UINT flOpt)
{
    lpMse->flMse = MSE_DEFAULT;
    lpMse->flMseInit = MSEINIT_DEFAULT;

    if (_LPENH_)
        *lpMse = _LPENH_->mseProp;

    return sizeof(PROPMSE);
}


/** SetMseData - set mouse property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpMse -> where to store mouse property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetMseData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPMSE lpMse, int cb, UINT flOpt)
{
    FunctionName(SetMseData);

    _LPENH_->mseProp = *lpMse;

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPMSE);
}


/** GetSndData - get sound property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpSnd -> where to store sound property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetSndData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPSND lpSnd, int cb, UINT flOpt)
{
    lpSnd->flSnd = SND_DEFAULT;
    lpSnd->flSndInit = SNDINIT_DEFAULT;

    if (_LPENH_)
        *lpSnd = _LPENH_->sndProp;

    return sizeof(PROPSND);
}


/** SetSndData - set sound property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpSnd -> where to store sound property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetSndData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPSND lpSnd, int cb, UINT flOpt)
{
    _LPENH_->sndProp = *lpSnd;

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPSND);
}


/** GetFntData - get font property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpFnt -> where to store font property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetFntData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPFNT lpFnt, int cb, UINT flOpt)
{
    int iCount;
    BPFDI bpfdi;
    INIINFO iiTemp;

    lpFnt->flFnt = FNT_DEFAULT;
    lpFnt->wCurrentCP = (WORD) g_uCodePage;

    if (_LPENH_) {
        //
        // If we don't have any actual font data, see if we can compute some
        //
        if (!_LPENH_->fntProp.cxFontActual && _LPENH_->winProp.cxCells)
            _LPENH_->fntProp.cxFontActual = _LPENH_->winProp.cxClient / _LPENH_->winProp.cxCells;

        if (!_LPENH_->fntProp.cyFontActual && _LPENH_->winProp.cyCells)
            _LPENH_->fntProp.cyFontActual = _LPENH_->winProp.cyClient / _LPENH_->winProp.cyCells;

        *lpFnt = _LPENH_->fntProp;

        if (lpFnt->flFnt & FNT_AUTOSIZE) {

            bpfdi = ChooseBestFont(_LPENH_->winProp.cxCells,
                                   _LPENH_->winProp.cyCells,
                                   _LPENH_->winProp.cxClient,
                                   _LPENH_->winProp.cyClient,
                                   _LPENH_->fntProp.flFnt,
                                   _LPENH_->fntProp.wCurrentCP);
            SetFont(lpFnt, bpfdi);
        }
    } else {

        // Read the default INI information from the DOSAPP.INI file.
        // We only really use the information if we recognize the number of
        // WORDs read.

        iCount = GetIniWords(szDOSAPPSection, szDOSAPPDefault,
                                (WORD*)&iiTemp, INI_WORDS, szDOSAPPINI);

        if (ISVALIDINI(iCount))
            CopyIniWordsToFntData(lpFnt, &iiTemp, iCount);

        // Try to read file-specific information.  Note that any information
        // found will replace the information just read.  We only really use
        // the information if we recognize the number of WORDs read.

        iCount = GetIniWords(szDOSAPPSection, ppl->szPathName,
                                (WORD*)&iiTemp, INI_WORDS, szDOSAPPINI);

        if (ISVALIDINI(iCount))
            CopyIniWordsToFntData(lpFnt, &iiTemp, iCount);

        // If there is no font pool data (likely, if this is a 3.1 DOSAPP.INI),
        // then default to both raster and truetype.

        if (!(lpFnt->flFnt & FNT_BOTHFONTS))
            lpFnt->flFnt |= FNT_BOTHFONTS;
    }

    // Face names are taken from Frosting; the value stored in the PIF is
    // irrelevant.

    StringCchCopyA(lpFnt->achRasterFaceName, ARRAYSIZE(lpFnt->achRasterFaceName), szRasterFaceName);
    StringCchCopyA(lpFnt->achTTFaceName, ARRAYSIZE(lpFnt->achTTFaceName), szTTFaceName[IsBilingualCP(lpFnt->wCurrentCP)? 1 : 0]);

    return sizeof(PROPFNT);
}


/*
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpFnt -> where to store font property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetFntData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPFNT lpFnt, int cb, UINT flOpt)
{
    _LPENH_->fntProp = *lpFnt;

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPFNT);
}


/*
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpWin -> where to store window property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetWinData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPWIN lpWin, int cb, UINT flOpt)
{
    int iCount;
    INIINFO iiTemp;

    lpWin->flWin = flWinDefault;
    lpWin->wLength = PIF_WP_SIZE;

    if (_LPENH_) {
        *lpWin = _LPENH_->winProp;
    } else {
        // Read the default INI information from the DOSAPP.INI file.
        // We only really use the information if we recognize the number of
        // WORDs read.

        iCount = GetIniWords(szDOSAPPSection, szDOSAPPDefault,
                                (WORD*)&iiTemp, INI_WORDS, szDOSAPPINI);

        if (ISVALIDINI(iCount))
            CopyIniWordsToWinData(lpWin, &iiTemp, iCount);

        // Try to read file-specific information.  Note that any information
        // found will replace the information just read.  We only really use
        // the information if we recognize the number of WORDs read.

        iCount = GetIniWords(szDOSAPPSection, ppl->szPathName,
                                (WORD*)&iiTemp, INI_WORDS, szDOSAPPINI);

        if (ISVALIDINI(iCount))
            CopyIniWordsToWinData(lpWin, &iiTemp, iCount);
    }
    return sizeof(PROPWIN);
}


/** SetWinData - set window property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpWin -> where to store window property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetWinData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPWIN lpWin, int cb, UINT flOpt)
{
    _LPENH_->winProp = *lpWin;

    // In order to avoid excessive PIF creation, we will not set the
    // dirty bit on this particular call unless the properties were not
    // simply derived from internal defaults (no PIF file) or _DEFAULT.PIF.

    if (!(ppl->flProp & (PROP_NOPIF | PROP_DEFAULTPIF))) {
        ppl->flProp |= PROP_DIRTY;
    }
    return sizeof(PROPWIN);
}


/** GetEnvData - get environment property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpEnv -> where to store environment property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetEnvData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPENV lpEnv, int cb, UINT flOpt)
{
    BZero(lpEnv, sizeof(PROPENV));

    if (_LPENH_) {
        *lpEnv = _LPENH_->envProp;
        lpEnv->achBatchFile[ARRAYSIZE(lpEnv->achBatchFile)-1] = TEXT('\0');

    }
    if (!(flOpt & GETPROPS_OEM)) {
        /* Convert all strings from OEM character set to Ansi */
        CharToOemBuffA(lpEnv->achBatchFile, lpEnv->achBatchFile, ARRAYSIZE(lpEnv->achBatchFile));
    }
    return sizeof(PROPENV);
}


/** SetEnvData - set environment property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpEnv -> where to store environment property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetEnvData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPENV lpEnv, int cb, UINT flOpt)
{
    _LPENH_->envProp = *lpEnv;
    _LPENH_->envProp.achBatchFile[ARRAYSIZE(_LPENH_->envProp.achBatchFile)-1] = TEXT('\0');

    if (!(flOpt & SETPROPS_OEM)) {
        /* Convert all strings from Ansi character set to OEM */
        CharToOemBuffA(_LPENH_->envProp.achBatchFile, _LPENH_->envProp.achBatchFile, ARRAYSIZE(_LPENH_->envProp.achBatchFile));
    }
    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPENV);
}


/* INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386  -> 386 PIF data (NOT USED)
 *  lpenh  -> enhanced PIF data (may be NULL)
 *  lpNt40 -> where to store NT/UNICODE property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetNt40Data(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPNT40 lpnt40, int cb, UINT flOpt)
{
    PROPPRG prg;
    WCHAR   awchTmp[ MAX_PATH ];

    if (GetPrgData( ppl, aDataPtrs, &prg, sizeof(prg), flOpt) < sizeof(PROPPRG))
        return 0;

    if (!_LPWNT40_)
        return 0;

    lpnt40->flWnt = _LPWNT40_->nt40Prop.flWnt;

    // Initialize Command Line string

    if (lstrcmpA(prg.achCmdLine,_LPWNT40_->nt40Prop.achSaveCmdLine)==0) {

        StringCchCopyA(  lpnt40->achSaveCmdLine, ARRAYSIZE(lpnt40->achSaveCmdLine), _LPWNT40_->nt40Prop.achSaveCmdLine );
        StringCchCopy( lpnt40->awchCmdLine,    ARRAYSIZE(lpnt40->awchCmdLine), _LPWNT40_->nt40Prop.awchCmdLine );

    } else {

        StringCchCopyA( lpnt40->achSaveCmdLine, ARRAYSIZE(lpnt40->achSaveCmdLine),            prg.achCmdLine );
        StringCchCopyA( _LPWNT40_->nt40Prop.achSaveCmdLine, ARRAYSIZE(_LPWNT40_->nt40Prop.achSaveCmdLine), prg.achCmdLine );
        MultiByteToWideChar( CP_ACP, 0,
                             prg.achCmdLine, -1,
                             awchTmp, ARRAYSIZE(lpnt40->awchCmdLine)
                            );
        awchTmp[ARRAYSIZE(lpnt40->awchCmdLine)-1] = TEXT('\0');
        StringCchCopy( lpnt40->awchCmdLine, ARRAYSIZE(lpnt40->awchCmdLine), awchTmp );
        StringCchCopy( _LPWNT40_->nt40Prop.awchCmdLine, ARRAYSIZE(_LPWNT40_->nt40Prop.awchCmdLine), lpnt40->awchCmdLine );

    }

    // Initialize Other File string

    if (lstrcmpA(prg.achOtherFile,_LPWNT40_->nt40Prop.achSaveOtherFile)==0) {

        StringCchCopyA(  lpnt40->achSaveOtherFile, ARRAYSIZE(lpnt40->achSaveOtherFile), _LPWNT40_->nt40Prop.achSaveOtherFile );
        StringCchCopy( lpnt40->awchOtherFile,    ARRAYSIZE(lpnt40->awchOtherFile),    _LPWNT40_->nt40Prop.awchOtherFile );

    } else {

        StringCchCopyA( lpnt40->achSaveOtherFile,ARRAYSIZE(lpnt40->achSaveOtherFile), prg.achOtherFile );
        StringCchCopyA( _LPWNT40_->nt40Prop.achSaveOtherFile, ARRAYSIZE(_LPWNT40_->nt40Prop.achSaveOtherFile), prg.achOtherFile );
        MultiByteToWideChar( CP_ACP, 0,
                             prg.achOtherFile, -1,
                             awchTmp, ARRAYSIZE(lpnt40->awchOtherFile)
                            );
        awchTmp[ARRAYSIZE(lpnt40->awchOtherFile)-1] = TEXT('\0');
        StringCchCopy( lpnt40->awchOtherFile, ARRAYSIZE(lpnt40->awchOtherFile), awchTmp );
        StringCchCopy( _LPWNT40_->nt40Prop.awchOtherFile, ARRAYSIZE(_LPWNT40_->nt40Prop.awchOtherFile), lpnt40->awchOtherFile );

    }

    // Initialize PIF File string

    if (lstrcmpA(prg.achPIFFile,_LPWNT40_->nt40Prop.achSavePIFFile)==0) {

        StringCchCopyA(  lpnt40->achSavePIFFile, ARRAYSIZE(lpnt40->achSavePIFFile), _LPWNT40_->nt40Prop.achSavePIFFile );
        StringCchCopy( lpnt40->awchPIFFile,    ARRAYSIZE(lpnt40->awchPIFFile),    _LPWNT40_->nt40Prop.awchPIFFile );

    } else {

        StringCchCopyA( lpnt40->achSavePIFFile, ARRAYSIZE(lpnt40->achSavePIFFile), prg.achPIFFile );
        StringCchCopyA( _LPWNT40_->nt40Prop.achSavePIFFile, ARRAYSIZE(_LPWNT40_->nt40Prop.achSavePIFFile), prg.achPIFFile );
        MultiByteToWideChar( CP_ACP, 0,
                             prg.achPIFFile, -1,
                             awchTmp, ARRAYSIZE(lpnt40->awchPIFFile)
                            );
        awchTmp[ARRAYSIZE(lpnt40->awchPIFFile)-1] = TEXT('\0');
        StringCchCopy( lpnt40->awchPIFFile, ARRAYSIZE(lpnt40->awchPIFFile), awchTmp );
        StringCchCopy( _LPWNT40_->nt40Prop.awchPIFFile, ARRAYSIZE(_LPWNT40_->nt40Prop.awchPIFFile), lpnt40->awchPIFFile );

    }

    // Initialize Title string

    if (lstrcmpA(prg.achTitle,_LPWNT40_->nt40Prop.achSaveTitle)==0) {

        StringCchCopyA(  lpnt40->achSaveTitle, ARRAYSIZE(lpnt40->achSaveTitle), _LPWNT40_->nt40Prop.achSaveTitle );
        StringCchCopy( lpnt40->awchTitle,    ARRAYSIZE(lpnt40->awchTitle),    _LPWNT40_->nt40Prop.awchTitle );

    } else {

        StringCchCopyA( lpnt40->achSaveTitle,ARRAYSIZE(lpnt40->achSaveTitle), prg.achTitle );
        StringCchCopyA( _LPWNT40_->nt40Prop.achSaveTitle, ARRAYSIZE(_LPWNT40_->nt40Prop.achSaveTitle), prg.achTitle );
        MultiByteToWideChar( CP_ACP, 0,
                             prg.achTitle, -1,
                             awchTmp, ARRAYSIZE(lpnt40->awchTitle)
                            );
        awchTmp[ARRAYSIZE(lpnt40->awchTitle)-1] = TEXT('\0');
        StringCchCopy( lpnt40->awchTitle, ARRAYSIZE(lpnt40->awchTitle), awchTmp );
        StringCchCopy( _LPWNT40_->nt40Prop.awchTitle, ARRAYSIZE(_LPWNT40_->nt40Prop.awchTitle), lpnt40->awchTitle);

    }

    // Initialize IconFile string

    if (lstrcmpA(prg.achIconFile,_LPWNT40_->nt40Prop.achSaveIconFile)==0) {

        StringCchCopyA(  lpnt40->achSaveIconFile, ARRAYSIZE(lpnt40->achSaveIconFile), _LPWNT40_->nt40Prop.achSaveIconFile );
        StringCchCopy( lpnt40->awchIconFile,    ARRAYSIZE(lpnt40->awchIconFile),    _LPWNT40_->nt40Prop.awchIconFile );

    } else {

        StringCchCopyA( lpnt40->achSaveIconFile, ARRAYSIZE(lpnt40->achSaveIconFile), prg.achIconFile );
        StringCchCopyA( _LPWNT40_->nt40Prop.achSaveIconFile, ARRAYSIZE(_LPWNT40_->nt40Prop.achSaveIconFile), prg.achIconFile );
        MultiByteToWideChar( CP_ACP, 0,
                             prg.achIconFile, -1,
                             awchTmp, ARRAYSIZE(lpnt40->awchIconFile)
                            );
        awchTmp[ARRAYSIZE(lpnt40->awchIconFile)-1] = TEXT('\0');
        StringCchCopy( lpnt40->awchIconFile, ARRAYSIZE(lpnt40->awchIconFile), awchTmp );
        StringCchCopy( _LPWNT40_->nt40Prop.awchIconFile, ARRAYSIZE(_LPWNT40_->nt40Prop.awchIconFile), lpnt40->awchIconFile );

    }

    // Initialize Working Directory string

    if (lstrcmpA(prg.achWorkDir,_LPWNT40_->nt40Prop.achSaveWorkDir)==0) {

        StringCchCopyA(  lpnt40->achSaveWorkDir, ARRAYSIZE(lpnt40->achSaveWorkDir), _LPWNT40_->nt40Prop.achSaveWorkDir );
        StringCchCopy( lpnt40->awchWorkDir,    ARRAYSIZE(lpnt40->awchWorkDir),    _LPWNT40_->nt40Prop.awchWorkDir );

    } else {

        StringCchCopyA( lpnt40->achSaveWorkDir, ARRAYSIZE(lpnt40->achSaveWorkDir), prg.achWorkDir );
        StringCchCopyA( _LPWNT40_->nt40Prop.achSaveWorkDir, ARRAYSIZE(_LPWNT40_->nt40Prop.achSaveWorkDir), prg.achWorkDir );
        MultiByteToWideChar( CP_ACP, 0,
                             prg.achWorkDir, -1,
                             awchTmp, ARRAYSIZE(lpnt40->awchWorkDir)
                            );
        awchTmp[ARRAYSIZE(lpnt40->awchWorkDir)-1] = TEXT('\0');
        StringCchCopy( lpnt40->awchWorkDir, ARRAYSIZE(lpnt40->awchWorkDir), awchTmp );
        StringCchCopy( _LPWNT40_->nt40Prop.awchWorkDir, ARRAYSIZE(_LPWNT40_->nt40Prop.awchWorkDir), lpnt40->awchWorkDir );

    }

    // Initialize Batch File string

    if (_LPENH_) {

        if (lstrcmpA(_LPENH_->envProp.achBatchFile,_LPWNT40_->nt40Prop.achSaveBatchFile)==0) {

            StringCchCopyA(  lpnt40->achSaveBatchFile, ARRAYSIZE(lpnt40->achSaveBatchFile), _LPWNT40_->nt40Prop.achSaveBatchFile );
            StringCchCopy( lpnt40->awchBatchFile,    ARRAYSIZE(lpnt40->awchBatchFile),    _LPWNT40_->nt40Prop.awchBatchFile );

        } else {

            StringCchCopyA( lpnt40->achSaveBatchFile,ARRAYSIZE(lpnt40->achSaveBatchFile),_LPENH_->envProp.achBatchFile );
            StringCchCopyA( _LPWNT40_->nt40Prop.achSaveBatchFile, ARRAYSIZE(_LPWNT40_->nt40Prop.achSaveBatchFile), _LPENH_->envProp.achBatchFile );
            MultiByteToWideChar( CP_ACP, 0,
                                 _LPENH_->envProp.achBatchFile, -1,
                                 awchTmp, ARRAYSIZE(lpnt40->awchBatchFile)
                                );
            awchTmp[ARRAYSIZE(lpnt40->awchBatchFile)-1] = TEXT('\0');
            StringCchCopy( lpnt40->awchBatchFile, ARRAYSIZE(lpnt40->awchBatchFile), awchTmp );
            StringCchCopy( _LPWNT40_->nt40Prop.awchBatchFile, ARRAYSIZE(_LPWNT40_->nt40Prop.awchBatchFile), lpnt40->awchBatchFile );

        }

    } else {

        lpnt40->achSaveBatchFile[0] = '\0';
        _LPWNT40_->nt40Prop.achSaveBatchFile[0] = '\0';
        lpnt40->awchBatchFile[0] = TEXT('\0');
        _LPWNT40_->nt40Prop.awchBatchFile[0] = TEXT('\0');

    }

    // Initialize Console properties

    lpnt40->dwForeColor      = _LPWNT40_->nt40Prop.dwForeColor;
    lpnt40->dwBackColor      = _LPWNT40_->nt40Prop.dwBackColor;
    lpnt40->dwPopupForeColor = _LPWNT40_->nt40Prop.dwPopupForeColor;
    lpnt40->dwPopupBackColor = _LPWNT40_->nt40Prop.dwPopupBackColor;
    lpnt40->WinSize          = _LPWNT40_->nt40Prop.WinSize;
    lpnt40->BuffSize         = _LPWNT40_->nt40Prop.BuffSize;
    lpnt40->WinPos           = _LPWNT40_->nt40Prop.WinPos;
    lpnt40->dwCursorSize     = _LPWNT40_->nt40Prop.dwCursorSize;
    lpnt40->dwCmdHistBufSize = _LPWNT40_->nt40Prop.dwCmdHistBufSize;
    lpnt40->dwNumCmdHist     = _LPWNT40_->nt40Prop.dwNumCmdHist;

    return sizeof(PROPNT40);
}

/*
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpWnt -> where to store NT/UNICODE property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetNt40Data(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPNT40 lpnt40, int cb, UINT flOpt)
{
    _LPWNT40_->nt40Prop.flWnt = lpnt40->flWnt;

    // Set Command Line string

    StringCchCopyA(  _LPWNT40_->nt40Prop.achSaveCmdLine, ARRAYSIZE(_LPWNT40_->nt40Prop.achSaveCmdLine), lpnt40->achSaveCmdLine );
    StringCchCopy( _LPWNT40_->nt40Prop.awchCmdLine,    ARRAYSIZE(_LPWNT40_->nt40Prop.awchCmdLine),    lpnt40->awchCmdLine );

    // Set Other File string

    StringCchCopyA(  _LPWNT40_->nt40Prop.achSaveOtherFile, ARRAYSIZE(_LPWNT40_->nt40Prop.achSaveOtherFile), lpnt40->achSaveOtherFile );
    StringCchCopy( _LPWNT40_->nt40Prop.awchOtherFile,    ARRAYSIZE(_LPWNT40_->nt40Prop.awchOtherFile),    lpnt40->awchOtherFile );

    // Set PIF File string

    StringCchCopyA(  _LPWNT40_->nt40Prop.achSavePIFFile, ARRAYSIZE(_LPWNT40_->nt40Prop.achSavePIFFile), lpnt40->achSavePIFFile );
    StringCchCopy( _LPWNT40_->nt40Prop.awchPIFFile,    ARRAYSIZE(_LPWNT40_->nt40Prop.awchPIFFile),    lpnt40->awchPIFFile );

    // Set Title string

    StringCchCopyA(  _LPWNT40_->nt40Prop.achSaveTitle, ARRAYSIZE(_LPWNT40_->nt40Prop.achSaveTitle), lpnt40->achSaveTitle );
    StringCchCopy( _LPWNT40_->nt40Prop.awchTitle,    ARRAYSIZE(_LPWNT40_->nt40Prop.awchTitle),    lpnt40->awchTitle );

    // Set IconFile string

    StringCchCopyA(  _LPWNT40_->nt40Prop.achSaveIconFile, ARRAYSIZE(_LPWNT40_->nt40Prop.achSaveIconFile), lpnt40->achSaveIconFile );
    StringCchCopy( _LPWNT40_->nt40Prop.awchIconFile,    ARRAYSIZE(_LPWNT40_->nt40Prop.awchIconFile),    lpnt40->awchIconFile );

    // Set Working Directory string

    StringCchCopyA(  _LPWNT40_->nt40Prop.achSaveWorkDir, ARRAYSIZE(_LPWNT40_->nt40Prop.achSaveWorkDir), lpnt40->achSaveWorkDir );
    StringCchCopy( _LPWNT40_->nt40Prop.awchWorkDir,    ARRAYSIZE(_LPWNT40_->nt40Prop.awchWorkDir),    lpnt40->awchWorkDir );

    // Set Batch File string

    StringCchCopyA(  _LPWNT40_->nt40Prop.achSaveBatchFile, ARRAYSIZE(_LPWNT40_->nt40Prop.achSaveBatchFile), lpnt40->achSaveBatchFile );
    StringCchCopy( _LPWNT40_->nt40Prop.awchBatchFile,    ARRAYSIZE(_LPWNT40_->nt40Prop.awchBatchFile),    lpnt40->awchBatchFile );


    // Set Console properties

    _LPWNT40_->nt40Prop.dwForeColor      = lpnt40->dwForeColor;
    _LPWNT40_->nt40Prop.dwBackColor      = lpnt40->dwBackColor;
    _LPWNT40_->nt40Prop.dwPopupForeColor = lpnt40->dwPopupForeColor;
    _LPWNT40_->nt40Prop.dwPopupBackColor = lpnt40->dwPopupBackColor;
    _LPWNT40_->nt40Prop.WinSize          = lpnt40->WinSize;
    _LPWNT40_->nt40Prop.BuffSize         = lpnt40->BuffSize;
    _LPWNT40_->nt40Prop.WinPos           = lpnt40->WinPos;
    _LPWNT40_->nt40Prop.dwCursorSize     = lpnt40->dwCursorSize;
    _LPWNT40_->nt40Prop.dwCmdHistBufSize = lpnt40->dwCmdHistBufSize;
    _LPWNT40_->nt40Prop.dwNumCmdHist     = lpnt40->dwNumCmdHist;

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPNT40);
}

/*
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpNt31 -> where to store NT/UNICODE property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */
int GetNt31Data(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPNT31 lpnt31, int cb, UINT flOpt)
{
    lpnt31->dwWNTFlags = _LPWNT31_->nt31Prop.dwWNTFlags;
    lpnt31->dwRes1     = _LPWNT31_->nt31Prop.dwRes1;
    lpnt31->dwRes2     = _LPWNT31_->nt31Prop.dwRes2;

    // Set Config.sys file string

    StringCchCopyA( lpnt31->achConfigFile, ARRAYSIZE(lpnt31->achConfigFile), _LPWNT31_->nt31Prop.achConfigFile );

    // Set Autoexec.bat file string
    StringCchCopyA( lpnt31->achAutoexecFile, ARRAYSIZE(lpnt31->achAutoexecFile), _LPWNT31_->nt31Prop.achAutoexecFile );

    return sizeof(PROPNT31);
}


/** SetNt31Data - set environment property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpNt31 -> where to store NT/UNICODE property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */
int SetNt31Data(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPNT31 lpnt31, int cb, UINT flOpt)
{
    _LPWNT31_->nt31Prop.dwWNTFlags = lpnt31->dwWNTFlags;
    _LPWNT31_->nt31Prop.dwRes1     = lpnt31->dwRes1;
    _LPWNT31_->nt31Prop.dwRes2     = lpnt31->dwRes2;

    // Set Config.sys file string

    StringCchCopyA( _LPWNT31_->nt31Prop.achConfigFile, ARRAYSIZE(_LPWNT31_->nt31Prop.achConfigFile), lpnt31->achConfigFile );

    // Set Autoexec.bat file string
    StringCchCopyA( _LPWNT31_->nt31Prop.achAutoexecFile, ARRAYSIZE(_LPWNT31_->nt31Prop.achAutoexecFile), lpnt31->achAutoexecFile );

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPNT31);
}

/** CopyIniWordsToFntData
 *
 *  Transfer INIINFO data to PROPFNT structure.
 *
 *  Entry:
 *      lpFnt   -> PROPFNT
 *      lpii    -> INIINFO
 *      cWords  == # of INIINFO words available
 *
 *  Exit:
 *      Nothing
 */

void CopyIniWordsToFntData(LPPROPFNT lpFnt, LPINIINFO lpii, int cWords)
{
    lpFnt->flFnt = (lpii->wFlags & FNT_BOTHFONTS);

    // cWords is transformed into cBytes (only the name is the same...)
    cWords *= 2;

    if (cWords > FIELD_OFFSET(INIINFO, wFontHeight)) {

        // Note that we can set both the desired and ACTUAL fields to
        // the same thing, because in 3.1, only raster fonts were supported.

        lpFnt->flFnt |= FNT_RASTER;
        lpFnt->cxFont = lpFnt->cxFontActual = lpii->wFontWidth;
        lpFnt->cyFont = lpFnt->cyFontActual = lpii->wFontHeight;
    }
}


/*
 *  Transfer INIINFO data to PROPWIN structure.
 *
 *  Entry:
 *      lpWin   -> PROPWIN
 *      lpii    -> INIINFO
 *      cWords  == # of INIINFO words available
 *
 *  Exit:
 *      Nothing
 */

void CopyIniWordsToWinData(LPPROPWIN lpWin, LPINIINFO lpii, int cWords)
{
    lpWin->flWin = lpii->wFlags & (WIN_SAVESETTINGS | WIN_TOOLBAR);

    // The new NORESTORE bit's setting should be the opposite
    // the user's SAVESETTINGS bit

    lpWin->flWinInit &= ~WININIT_NORESTORE;
    if (!(lpWin->flWin & WIN_SAVESETTINGS))
        lpWin->flWinInit |=  WININIT_NORESTORE;

    // cWords is transformed into cBytes (only the name is the same...)
    cWords *= 2;

    if (cWords > FIELD_OFFSET(INIINFO,wWinWidth))
        memcpy(&lpWin->cxWindow, &lpii->wWinWidth,
                 min(cWords-FIELD_OFFSET(INIINFO,wWinWidth),
                     sizeof(INIINFO)-FIELD_OFFSET(INIINFO,wWinWidth)));
}


/** GetIniWords
 *
 *  Reads a sequence of WORDs or SHORTs from a specified section
 *  of an INI file into a supplied array.
 *
 *  Entry:
 *      lpszSection     -> section name (major key)
 *      lpszEntry       -> entry name (minor key)
 *      lpwBuf          -> array of WORDs to receive data
 *      cwBuf           =  size of lpwBuf
 *      lpszFilename    -> name of INI file to inspect
 *
 *  Exit:
 *      Returns number of words read, 0 on error.
 *
 *  Overview:
 *      Grab the string via GetPrivateProfileString, then manually
 *      parse the numbers out of it.
 */

WORD GetIniWords(LPCTSTR lpszSection, LPCTSTR lpszEntry,
                 LPWORD lpwBuf, WORD cwBuf, LPCTSTR lpszFilename)
{
    TCHAR szBuffer[MAX_INI_BUFFER];

    // Read the profile entry as a string

    if (!GetPrivateProfileString(lpszSection, lpszEntry,
                                 c_szNULL, szBuffer, ARRAYSIZE(szBuffer),
                                 lpszFilename))
        return 0;

    return ParseIniWords(szBuffer, lpwBuf, cwBuf, NULL);
}


/*  Reads a sequence of WORDs or SHORTs from a LPSTR into a
 *  supplied array.
 *
 *  Entry:
 *      lpsz    -> string to parse
 *      lpwBuf  -> array of WORDs to receive data
 *      cwBuf   == size of lpwBuf
 *      lppsz   -> optional pointer for address of first unscanned character
 *
 *  Exit:
 *      Returns number of words read, 0 on error.
 */

WORD ParseIniWords(LPCTSTR lpsz, LPWORD lpwBuf, WORD cwBuf, LPTSTR *lplpsz)
{
    WORD wCount = 0;

    for (; cwBuf; --cwBuf) {

        while (*lpsz == TEXT(' ') || *lpsz == TEXT('\t') || *lpsz == TEXT(','))
            ++lpsz;

        if (!*lpsz)
            break;              // end of string reached

        *lpwBuf++ = (WORD) StrToInt(lpsz);
        ++wCount;

        while (*lpsz == TEXT('-') || *lpsz >= TEXT('0')  && *lpsz <= TEXT('9'))
            ++lpsz;
    }
    if (lplpsz)
        *lplpsz = (LPTSTR)lpsz;

    return wCount;
}


/*  Given an array of words, write them out to an INI file in a manner
 *  that GetIniWords can read back.
 *
 *  Entry:
 *      lpszSection     -> section name (major key)
 *      lpszEntry       -> entry name (minor key)
 *      lpwBuf          -> array of WORDs to write
 *      cwBuf           =  size of lpwBuf, may not exceed MAXINIWORDS
 *      lpszFilename    -> name of INI file to write to
 *
 *  Exit:
 *      Returns nonzero on success.
 *
 *  Overview:
 *      Build a giant string consisting of the WORDs glommed together
 *      (separated by spaces) and write it out via WritePrivateProfileString.
 */

BOOL WriteIniWords(LPCTSTR lpszSection, LPCTSTR lpszEntry,
                   LPCWORD lpwBuf, WORD cwBuf, LPCTSTR lpszFilename)
{
    TCHAR  szBuffer[MAX_INI_BUFFER];
    TCHAR szScratch[20];

    szBuffer[0] = 0;
    for (; cwBuf; --cwBuf)
    {
        int i = *lpwBuf++;      // copy into an integer-wide location
        if (FAILED(StringCchPrintf(szScratch, ARRAYSIZE(szScratch), TEXT("%d "), i)) ||
            FAILED(StringCchCat(szBuffer, ARRAYSIZE(szBuffer), szScratch)))
        {
            return FALSE;
        }
    }

    return WritePrivateProfileString(lpszSection, lpszEntry, szBuffer, lpszFilename);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\path.c ===
#include "shellprv.h"
#pragma  hdrstop

// from mtpt.cpp
STDAPI_(BOOL) CMtPt_IsLFN(int iDrive);
STDAPI_(BOOL) CMtPt_IsSlow(int iDrive);

__inline BOOL DBL_BSLASH(LPNCTSTR psz)
{
    return (psz[0] == TEXT('\\') && psz[1] == TEXT('\\'));
}

#define IsPathSep(ch)  ((ch) == TEXT('\\') || (ch) == TEXT('/'))

// in:
//      pszPath         fully qualified path (unc or x:\) to test
//                      NULL for windows directory
//
// returns:
//      TRUE            volume supports name longer than 12 chars
//
// note: this caches drive letters, but UNCs go through every time
//
STDAPI_(BOOL) IsLFNDrive(LPCTSTR pszPath)
{
    TCHAR szRoot[MAX_PATH];
    DWORD dwMaxLength = 13;      // assume yes

    ASSERT(NULL == pszPath || IS_VALID_STRING_PTR(pszPath, -1));

    if ((pszPath == NULL) || !*pszPath)
    {
        *szRoot = 0;
        GetWindowsDirectory(szRoot, ARRAYSIZE(szRoot));
        pszPath = szRoot;
    }

    ASSERT(!PathIsRelative(pszPath));

    //
    // UNC name? gota check each time
    //
    if (PathIsUNC(pszPath))
    {
        HRESULT hr;

        hr = StringCchCopy(szRoot, ARRAYSIZE(szRoot), pszPath);
        if (FAILED(hr))
        {
            return FALSE;   // sorry, path to long, assume no LFN
        }
        PathStripToRoot(szRoot);

        // Deal with busted kernel UNC stuff
        // Is it a \\foo or a \\foo\bar thing?

        if (StrChr(szRoot+2, TEXT('\\')))
        {
            // "\\foo\bar - Append a slash to be NT compatible.
            hr = StringCchCat(szRoot, ARRAYSIZE(szRoot), TEXT("\\"));
            if (FAILED(hr))
            {
                return FALSE;
            }
        }
        else
        {
            // "\\foo" - assume it's always a LFN volume
            return TRUE;
        }
    }
    //
    // removable media? gota check each time
    //
    else if (IsRemovableDrive(DRIVEID(pszPath)))
    {
        PathBuildRoot(szRoot, DRIVEID(pszPath));
    }
    //
    // fixed media use cached value.
    //
    else
    {
        return CMtPt_IsLFN(DRIVEID(pszPath));
    }

    //
    // Right now we will say that it is an LFN Drive if the maximum
    // component is > 12
    GetVolumeInformation(szRoot, NULL, 0, NULL, &dwMaxLength, NULL, NULL, 0);
    return dwMaxLength > 12;
}


STDAPI_(BOOL) IsLFNDriveA(LPCSTR pszPath)   OPTIONAL
{
    WCHAR wsz[MAX_PATH];

    ASSERT(NULL == pszPath || IS_VALID_STRING_PTRA(pszPath, -1));

    if (pszPath)
    {
        SHAnsiToUnicode(pszPath, wsz, ARRAYSIZE(wsz));
        pszPath = (LPCSTR)wsz;
    }
    return IsLFNDrive((LPCWSTR)pszPath);
}   
 
STDAPI_(BOOL) PathIsRemovable(LPCTSTR pszPath)
{
    BOOL fIsEjectable = FALSE;
    int iDrive = PathGetDriveNumber(pszPath);

    if (iDrive != -1)
    {
        int nType = DriveType(iDrive);

        if ((DRIVE_CDROM == nType) ||
            (DRIVE_DVD == nType) ||
            (DRIVE_REMOVABLE == nType))
        {
            fIsEjectable = TRUE;
        }
    }

    return fIsEjectable;
}

STDAPI_(BOOL) PathIsRemote(LPCTSTR pszPath)
{
    BOOL fIsRemote = FALSE;
    if (PathIsUNC(pszPath))
    {
        fIsRemote = TRUE;
    }
    else
    {
        int iDrive = PathGetDriveNumber(pszPath);

        if (iDrive != -1)
        {
            int nType = DriveType(iDrive);

            if (DRIVE_REMOTE == nType || DRIVE_NO_ROOT_DIR == nType)
            {
                fIsRemote = TRUE;
            }
        }
    }
    return fIsRemote;
}


//----------------------------------------------------------------------------
// The following are creterias we currently use to tell whether a file is a temporary file
// Files with FILE_ATTRIBUTE_TEMPORARY set
// Files in Windows temp directory
// Files from the internet cache directory
// Files in the CD burning area
//---------------------------------------------------------------------------
STDAPI_(BOOL) PathIsTemporary(LPCTSTR pszPath)
{
    BOOL bRet = FALSE;
    DWORD dwAttrib = GetFileAttributes(pszPath);
    if ((-1 != dwAttrib) && (dwAttrib & FILE_ATTRIBUTE_TEMPORARY))
    {
        bRet = TRUE;    // we got the attributes and the file says it is temprary
    }
    else
    {
        TCHAR szTemp[MAX_PATH];
        if (GetTempPath(ARRAYSIZE(szTemp), szTemp))
        {
            // if possible, expand the input to the long path name so we can compare strings
            TCHAR szPath[MAX_PATH];
            if (GetLongPathName(pszPath, szPath, ARRAYSIZE(szPath)))
                pszPath = szPath;

            // GetTempPath() returns short name due to compatibility constraints.  
            // we need to convert to long name
            if (GetLongPathName(szTemp, szTemp, ARRAYSIZE(szTemp)))
            {
                bRet = PathIsEqualOrSubFolder(szTemp, pszPath) || 
                       PathIsEqualOrSubFolder(MAKEINTRESOURCE(CSIDL_INTERNET_CACHE), pszPath) ||
                       PathIsEqualOrSubFolder(MAKEINTRESOURCE(CSIDL_CDBURN_AREA), pszPath);
            }
        }
    }
    return bRet;
}


STDAPI_(BOOL) PathIsTemporaryA(LPCSTR pszPath)
{
    TCHAR szPath[MAX_PATH];
    SHOtherToTChar(pszPath, szPath, ARRAYSIZE(szPath));
    return PathIsTemporary(szPath);
}


// unfortunately, this is exported so we need to support it
STDAPI_(LPTSTR) PathGetExtension(LPCTSTR pszPath, LPTSTR pszExtension, int cchExt)
{
    LPTSTR pszExt = PathFindExtension(pszPath);

    RIPMSG(FALSE, "PathGetExtension should not be called, use PathFindExtension instead");

    if (pszExt && *pszExt)
        pszExt += 1;

    return pszExt;
}

//
// Attempts to truncate the filename pszSpec such that pszDir+pszSpec are less than MAX_PATH-5.
// The extension is protected so it won't get truncated or altered.
//
// in:
//      pszDir      the path to a directory.  No trailing '\' is needed.
//      pszSpec     the filespec to be truncated.  This should not include a path but can have an extension.
//                  This input buffer can be of any length.
//      iTruncLimit The minimum length to truncate pszSpec.  If addition truncation would be required we fail.
// out:
//      pszSpec     The truncated filespec with it's extension unaltered.
// return:
//      TRUE if the filename was truncated, FALSE if we were unable to truncate because the directory name
//      was too long, the extension was too long, or the iTruncLimit is too high.  pszSpec is unaltered
//      when this function returns FALSE.
//
STDAPI_(BOOL) PathTruncateKeepExtension(LPCTSTR pszDir, LPTSTR pszSpec, int iTruncLimit)
{
    LPTSTR pszExt = PathFindExtension(pszSpec);

    RIPMSG(pszDir && IS_VALID_STRING_PTR(pszDir, -1), "PathTruncateKeepExtension: Caller passed bad pszDir");
    RIPMSG(pszSpec && IS_VALID_STRING_PTR(pszSpec, -1) && IS_VALID_WRITE_BUFFER(pszSpec, TCHAR, MAX_PATH), "PathTruncateKeepExtension: Caller passed bad pszSpec");
    DEBUGWhackPathString(pszSpec, MAX_PATH);

    if (pszExt)
    {
        int cchExt = lstrlen(pszExt);
        int cchSpec = (int)(pszExt - pszSpec + cchExt);
        int cchKeep = MAX_PATH - lstrlen(pszDir) - 5;   // the -5 is just to provide extra padding (max lstrlen(pszExt))

        // IF...
        //  ...the filename is to long
        //  ...we are within the limit to which we can truncate
        //  ...the extension is short enough to allow the trunctation
        if ((cchSpec > cchKeep) && (cchKeep >= iTruncLimit) && (cchKeep > cchExt))
        {
            // THEN... go ahead and truncate
            if (SUCCEEDED(StringCchCopy(pszSpec + cchKeep - cchExt, MAX_PATH - (cchKeep - cchExt), pszExt)))
            {
                return TRUE;
            }
        }
    }
    return FALSE;
}


STDAPI_(int) PathCleanupSpec(LPCTSTR pszDir, LPTSTR pszSpec)
{
    LPTSTR pszNext, pszCur;
    UINT   uMatch = IsLFNDrive(pszDir) ? GCT_LFNCHAR : GCT_SHORTCHAR;
    int    iRet = 0;
    LPTSTR pszPrevDot = NULL;

    for (pszCur = pszNext = pszSpec; *pszNext; /*pszNext = CharNext(pszNext)*/)
    {
        if (PathGetCharType(*pszNext) & uMatch)
        {
            *pszCur = *pszNext;
            if (uMatch == GCT_SHORTCHAR && *pszCur == TEXT('.'))
            {
                if (pszPrevDot)    // Only one '.' allowed for short names
                {
                    *pszPrevDot = TEXT('-');
                    iRet |= PCS_REPLACEDCHAR;
                }
                pszPrevDot = pszCur;
            }
            if (IsDBCSLeadByte(*pszNext))
            {
                LPTSTR pszDBCSNext;

                pszDBCSNext = CharNext(pszNext);
                *(pszCur + 1) = *(pszNext + 1);
                pszNext = pszDBCSNext;
            }
            else
                pszNext = CharNext(pszNext);
            pszCur = CharNext(pszCur);
        }
        else
        {
            switch (*pszNext)
            {
            case TEXT('/'):         // used often for things like add/remove
            case TEXT(' '):         // blank (only replaced for short name drives)
               *pszCur = TEXT('-');
               pszCur = CharNext(pszCur);
               iRet |= PCS_REPLACEDCHAR;
               break;
            default:
               iRet |= PCS_REMOVEDCHAR;
            }
            pszNext = CharNext(pszNext);
        }
    }
    *pszCur = 0;     // null terminate

    //
    //  For short names, limit to 8.3
    //
    if (uMatch == GCT_SHORTCHAR)
    {
        int i = 8;
        for (pszCur = pszNext = pszSpec; *pszNext; pszNext = CharNext(pszNext))
        {
            if (*pszNext == TEXT('.'))
            {
                i = 4; // Copy "." + 3 more characters
            }
            if (i > 0)
            {
                *pszCur = *pszNext;
                pszCur = CharNext(pszCur);
                i--;
            }
            else
            {
                iRet |= PCS_TRUNCATED;
            }
        }
        *pszCur = 0;
        CharUpperNoDBCS(pszSpec);
    }
    else    // Path too long only possible on LFN drives
    {
        if (pszDir && (lstrlen(pszDir) + lstrlen(pszSpec) > MAX_PATH - 1))
        {
            iRet |= PCS_PATHTOOLONG | PCS_FATAL;
        }
    }
    return iRet;
}


// PathCleanupSpecEx
//
// Just like PathCleanupSpec, PathCleanupSpecEx removes illegal characters from pszSpec
// and enforces 8.3 format on non-LFN drives.  In addition, this function will attempt to
// truncate pszSpec if the combination of pszDir + pszSpec is greater than MAX_PATH.
//
// in:
//      pszDir      The directory in which the filespec pszSpec will reside
//      pszSpec     The filespec that is being cleaned up which includes any extension being used
// out:
//      pszSpec     The modified filespec with illegal characters removed, truncated to
//                  8.3 if pszDir is on a non-LFN drive, and truncated to a shorter number
//                  of characters if pszDir is an LFN drive but pszDir + pszSpec is more
//                  than MAX_PATH characters.
// return:
//      returns a bit mask indicating what happened.  This mask can include the following cases:
//          PCS_REPLACEDCHAR    One or more illegal characters were replaced with legal characters
//          PCS_REMOVEDCHAR     One or more illegal characters were removed
//          PCS_TRUNCATED       Truncated to fit 8.3 format or because pszDir+pszSpec was too long
//          PCS_PATHTOOLONG     pszDir is so long that we cannot truncate pszSpec to form a legal filename
//          PCS_FATAL           The resultant pszDir+pszSpec is not a legal filename.  Always used with PCS_PATHTOOLONG.
//
STDAPI_(int) PathCleanupSpecEx(LPCTSTR pszDir, LPTSTR pszSpec)
{
    int iRet = PathCleanupSpec(pszDir, pszSpec);
    if (iRet & (PCS_PATHTOOLONG | PCS_FATAL))
    {
        // 30 is the shortest we want to truncate pszSpec to to satisfy the
        // pszDir+pszSpec<MAX_PATH requirement.  If this amount of truncation isn't enough
        // then we go ahead and return PCS_PATHTOOLONG|PCS_FATAL without doing any further
        // truncation of pszSpec
        if (PathTruncateKeepExtension(pszDir, pszSpec, 30))
        {
            // We fixed the error returned by PathCleanupSpec so mask out the error.
            iRet |= PCS_TRUNCATED;
            iRet &= ~(PCS_PATHTOOLONG|PCS_FATAL);
        }
    }
    else
    {
        // ensure that if both of these aren't set then neither is set.
        ASSERT(!(iRet&PCS_PATHTOOLONG) && !(iRet&PCS_FATAL));
    }

    return iRet;
}


STDAPI_(BOOL) PathIsWild(LPCTSTR pszPath)
{
    while (*pszPath) 
    {
        if (*pszPath == TEXT('?') || *pszPath == TEXT('*'))
            return TRUE;
        pszPath = CharNext(pszPath);
    }
    return FALSE;
}


// given a path that potentially points to an un-extensioned program
// file, check to see if a program file exists with that name.
//
// returns: TRUE if a program with that name is found.
//               (extension is added to name).
//          FALSE no program file found or the path did not have an extension
//
BOOL LookForExtensions(LPTSTR pszPath, LPCTSTR dirs[], BOOL bPathSearch, UINT fExt)
{
    ASSERT(fExt);       // should have some bits set

    if (*PathFindExtension(pszPath) == 0)
    {
        if (bPathSearch)
        {
            // NB Try every extension on each path component in turn to
            // mimic command.com's search order.
            return PathFindOnPathEx(pszPath, dirs, fExt);
        }
        else
        {
            return PathFileExistsDefExt(pszPath, fExt);
        }
    }
    return FALSE;
}


//
// converts the relative or unqualified path name to the fully
// qualified path name.
//
// If this path is a URL, this function leaves it alone and
// returns FALSE.
//
// in:
//      pszPath        path to convert
//      pszCurrentDir  current directory to use
//
//  PRF_TRYPROGRAMEXTENSIONS (implies PRF_VERIFYEXISTS)
//  PRF_VERIFYEXISTS
//
// returns:
//      TRUE    the file was verified to exist
//      FALSE   the file was not verified to exist (but it may)
//
STDAPI_(BOOL) PathResolve(LPTSTR lpszPath, LPCTSTR dirs[], UINT fFlags)
{
    UINT fExt = (fFlags & PRF_DONTFINDLNK) ? (PFOPEX_COM | PFOPEX_BAT | PFOPEX_PIF | PFOPEX_EXE) : PFOPEX_DEFAULT;

    //
    //  NOTE:  if VERIFY SetLastError() default to FNF.  - ZekeL 9-APR-98
    //  ShellExec uses GLE() to find out why we failed.  
    //  any win32 API that we end up calling
    //  will do a SLE() to overrider ours.  specifically
    //  if VERIFY is set we call GetFileAttributes() 
    //
    if (fFlags & PRF_VERIFYEXISTS)
        SetLastError(ERROR_FILE_NOT_FOUND);
    
    PathUnquoteSpaces(lpszPath);

    if (PathIsRoot(lpszPath))
    {
        // No sense qualifying just a server or share name...
        if (!PathIsUNCServer(lpszPath) && !PathIsUNCServerShare(lpszPath))
        {
            // Be able to resolve "\" from different drives.
            if (lpszPath[0] == TEXT('\\') && lpszPath[1] == 0)
            {
                PathQualifyDef(lpszPath, fFlags & PRF_FIRSTDIRDEF ? dirs[0] : NULL, 0);
            }
        }

        if (fFlags & PRF_VERIFYEXISTS)
        {
            if (PathFileExistsAndAttributes(lpszPath, NULL))
            {
                return(TRUE);
            }
#ifdef DEBUG
            //   PathFileExistsAndAttributes() should catch this well enough.
            // If it is a UNC root, then we will see if the root exists
            //
            if (PathIsUNC(lpszPath))
            {
                // See if the network knows about this one.
                // It appears like some network provider croak if not everything
                // if filled in, so we might as well bloat ourself to make them happy...
                NETRESOURCE nr = {RESOURCE_GLOBALNET,RESOURCETYPE_ANY,
                        RESOURCEDISPLAYTYPE_GENERIC, RESOURCEUSAGE_CONTAINER,
                        NULL, lpszPath, NULL, NULL};
                HANDLE hEnum;

                if (WNetOpenEnum(RESOURCE_GLOBALNET, RESOURCETYPE_ANY,
                        RESOURCEUSAGE_ALL, &nr, &hEnum) == WN_SUCCESS)
                {
                    // If it succeeded then assume it worked...
                    WNetCloseEnum(hEnum);
                    ASSERT(FALSE);
                    return(TRUE);
                }
            }
#endif // DEBUG

            return FALSE;
        }

        return TRUE;
    }
    else if (PathIsFileSpec(lpszPath))
    {

        // REVIEW: look for programs before looking for paths

        if ((fFlags & PRF_TRYPROGRAMEXTENSIONS) && (LookForExtensions(lpszPath, dirs, TRUE, fExt)))
            return TRUE;

        if (PathFindOnPath(lpszPath, dirs))
        {
            // PathFindOnPath() returns TRUE iff PathFileExists(lpszPath),
            // so we always returns true here:
            //return (!(fFlags & PRF_VERIFYEXISTS)) || PathFileExists(lpszPath);
            return TRUE;
        }
    }
    else if (!PathIsURL(lpszPath))
    {
        // If there is a trailing '.', we should not try extensions
        PathQualifyDef(lpszPath, fFlags & PRF_FIRSTDIRDEF ? dirs[0] : NULL,
                PQD_NOSTRIPDOTS);
        if (fFlags & PRF_VERIFYEXISTS)
        {
            if ((fFlags & PRF_TRYPROGRAMEXTENSIONS) && (LookForExtensions(lpszPath, dirs, FALSE, fExt)))
                return TRUE;

            if (PathFileExistsAndAttributes(lpszPath, NULL))
                return TRUE;
        }
        else
        {
            return TRUE;
        }

    }
    return FALSE;
}


// qualify a DOS (or LFN) file name based on the currently active window.
// this code is careful to not write more than MAX_PATH characters
// into psz
//
// in:
//      psz     path to be qualified of at least MAX_PATH characters
//              ANSI string
//
// out:
//      psz     fully qualified version of input string based
//              on the current active window (current directory)
//

void PathQualifyDef(LPTSTR psz, LPCTSTR szDefDir, DWORD dwFlags)
{
    int cb, nSpaceLeft;
    TCHAR szTemp[MAX_PATH], szRoot[MAX_PATH];
    int iDrive;
    LPTSTR pOrig, pFileName;
    BOOL fLFN;
    LPTSTR pExt;

    RIPMSG(psz && IS_VALID_STRING_PTR(psz, -1) && IS_VALID_WRITE_BUFFER(psz, TCHAR, MAX_PATH), "PathQualifyDef: caller passed bad psz");
    RIPMSG(!szDefDir || (IS_VALID_STRING_PTR(szDefDir, -1) && lstrlen(szDefDir)<MAX_PATH), "PathQualifyDef: caller passed bad szDefDir");
    DEBUGWhackPathString(psz, MAX_PATH);
    
    /* Save it away. */
    if (FAILED(StringCchCopy(szTemp, ARRAYSIZE(szTemp), psz)))
    {
        return; // invalid parameter, leave it alone
    }
    
    FixSlashesAndColon(szTemp);
    
    nSpaceLeft = ARRAYSIZE(szTemp);         // MAX_PATH limited by this...
    
    pOrig = szTemp;
    pFileName = PathFindFileName(szTemp);
    
    if (PathIsUNC(pOrig))
    {
        // leave the \\ in the buffer so that the various parts
        // of the UNC path will be qualified and appended.  Note
        // we must assume that UNCs are LFN's, since computernames
        // and sharenames can be longer than 11 characters.
        fLFN = IsLFNDrive(pOrig);
        if (fLFN)
        {
            psz[2] = 0;
            nSpaceLeft -= 3;    // "\\" + nul
            pOrig += 2;
        }
        else
        {
            // NB UNC doesn't support LFN's but we don't want to truncate
            // \\foo or \\foo\bar so skip them here.
            
            // Is it a \\foo\bar\fred thing?
            LPTSTR pszSlash = StrChr(psz+2, TEXT('\\'));
            if (pszSlash && (NULL != (pszSlash = StrChr(pszSlash+1, TEXT('\\')))))
            {
                // Yep - skip the first bits but mush the rest.
                *(pszSlash+1) = 0;          // truncate to "\\345\78\"
                nSpaceLeft -= (int)(pszSlash-psz)+1;    // "\\345\78\" + nul
                pOrig += pszSlash-psz;     // skip over "\\345\78\" part
            }
            else
            {
                // Nope - just pretend it's an LFN and leave it alone.
                fLFN = TRUE;
                psz[2] = 0;
                nSpaceLeft -= 3;    // "\\" + nul
                pOrig+=2;
            }
        }
    }
    else
    {
        // Not a UNC
        iDrive = PathGetDriveNumber(pOrig);
        if (iDrive != -1)
        {
            PathBuildRoot(szRoot, iDrive);    // root specified by the file name

            ASSERT(pOrig[1] == TEXT(':'));    // PathGetDriveNumber does this

            pOrig += 2;   // Skip over the drive letter

            // and the slash if it is there...
            if (pOrig[0] == TEXT('\\'))
                pOrig++;
        }
        else
        {
            if (szDefDir && SUCCEEDED(StringCchCopy(szRoot, ARRAYSIZE(szRoot), szDefDir)))
            {
                // use the szDefDir as szRoot
            }
            else
            {
                //
                // As a default, use the windows drive (usually "C:\").
                //
                *szRoot = 0;
                GetWindowsDirectory(szRoot, ARRAYSIZE(szRoot));
                iDrive = PathGetDriveNumber(szRoot);
                if (iDrive != -1)
                {
                    PathBuildRoot(szRoot, iDrive);
                }
            }

            // if path is scoped to the root with "\" use working dir root

            if (pOrig[0] == TEXT('\\'))
                PathStripToRoot(szRoot);
        }
        fLFN = IsLFNDrive(szRoot);

        // REVIEW, do we really need to do different stuff on LFN names here?
        // on FAT devices, replace any illegal chars with underscores
        if (!fLFN)
        {
            LPTSTR pT;
            for (pT = pOrig; *pT; pT = CharNext(pT))
            {
                if (!PathIsValidChar(*pT, PIVC_SFN_FULLPATH))
                {
                    // not a valid sfn path character
                    *pT = TEXT('_');
                }
            }
        }

        StringCchCopy(psz, MAX_PATH, szRoot);   // ok to truncate - we check'd size above
        nSpaceLeft -= (lstrlen(psz) + 1);
    }

    while (*pOrig && nSpaceLeft > 0)
    {
        // If the component is parent dir, go up one dir.
        // If its the current dir, skip it, else add it normally
        if (pOrig[0] == TEXT('.'))
        {
            if (pOrig[1] == TEXT('.') && (!pOrig[2] || pOrig[2] == TEXT('\\')))
                PathRemoveFileSpec(psz);
            else if (pOrig[1] && pOrig[1] != TEXT('\\'))
                goto addcomponent;
            
            while (*pOrig && *pOrig != TEXT('\\'))
                pOrig = CharNext(pOrig);
            
            if (*pOrig)
                pOrig++;
        }
        else
        {
            LPTSTR pT, pTT = NULL;
            
addcomponent:
            if (PathAddBackslash(psz) == NULL)
            {
                nSpaceLeft = 0;
                continue;   // fail adding this component if the '\' doesn't fit
            }

            nSpaceLeft--;
            
            pT = psz + lstrlen(psz);
            
            if (fLFN)
            {
                // copy the component
                while (*pOrig && *pOrig != TEXT('\\') && nSpaceLeft>0)
                {
                    nSpaceLeft--;
                    if (IsDBCSLeadByte(*pOrig))
                    {
                        if (nSpaceLeft <= 0)
                        {
                            // Copy nothing more
                            continue;
                        }
                        
                        nSpaceLeft--;
                        *pT++ = *pOrig++;
                    }
                    *pT++ = *pOrig++;
                }
            }
            else
            {
                // copy the filename (up to 8 chars)
                for (cb = 8; *pOrig && !IsPathSep(*pOrig) && *pOrig != TEXT('.') && nSpaceLeft > 0;)
                {
                    if (cb > 0)
                    {
                        cb--;
                        nSpaceLeft--;
                        if (IsDBCSLeadByte(*pOrig))
                        {
                            if (nSpaceLeft<=0 || cb<=0)
                            {
                                // Copy nothing more
                                cb = 0;
                                continue;
                            }
                            
                            cb--;
                            nSpaceLeft--;
                            *pT++ = *pOrig++;
                        }
                        *pT++ = *pOrig++;
                    }
                    else
                    {
                        pOrig = CharNext(pOrig);
                    }
                }
                
                // if there's an extension, copy it, up to 3 chars
                if (*pOrig == TEXT('.') && nSpaceLeft > 0)
                {
                    int nOldSpaceLeft;
                    
                    *pT++ = TEXT('.');
                    nSpaceLeft--;
                    pOrig++;
                    pExt = pT;
                    nOldSpaceLeft = nSpaceLeft;
                    
                    for (cb = 3; *pOrig && *pOrig != TEXT('\\') && nSpaceLeft > 0;)
                    {
                        if (*pOrig == TEXT('.'))
                        {
                            // Another extension, start again.
                            cb = 3;
                            pT = pExt;
                            nSpaceLeft = nOldSpaceLeft;
                            pOrig++;
                        }
                        
                        if (cb > 0)
                        {
                            cb--;
                            nSpaceLeft--;
                            if (IsDBCSLeadByte(*pOrig))
                            {
                                if (nSpaceLeft<=0 || cb<=0)
                                {
                                    // Copy nothing more
                                    cb = 0;
                                    continue;
                                }
                                
                                cb--;
                                nSpaceLeft--;
                                *pT++ = *pOrig++;
                            }
                            *pT++ = *pOrig++;
                        }
                        else
                        {
                            pOrig = CharNext(pOrig);
                        }
                    }
                }
            }
            
            // skip the backslash
            
            if (*pOrig)
                pOrig++;
            
            // null terminate for next pass...
            *pT = 0;
        }
    }
    
    PathRemoveBackslash(psz);
    
    if (!(dwFlags & PQD_NOSTRIPDOTS))
    {
        // remove any trailing dots
        
        LPTSTR pszPrev = CharPrev(psz, psz + lstrlen(psz));
        if (*pszPrev == TEXT('.'))
        {
            *pszPrev = 0;
        }
    }
}

STDAPI_(void) PathQualify(LPTSTR psz)
{
    PathQualifyDef(psz, NULL, 0);
}

BOOL OnExtList(LPCTSTR pszExtList, LPCTSTR pszExt)
{
    for (; *pszExtList; pszExtList += lstrlen(pszExtList) + 1)
    {
        if (!lstrcmpi(pszExt, pszExtList))
        {
            // yes
            return TRUE;        
        }
    }

    return FALSE;
}

// Character offset where binary exe extensions begin in above
#define BINARY_EXE_OFFSET 20
const TCHAR c_achExes[] = TEXT(".cmd\0.bat\0.pif\0.scf\0.exe\0.com\0.scr\0");

STDAPI_(BOOL) PathIsBinaryExe(LPCTSTR szFile)
{
    ASSERT(BINARY_EXE_OFFSET < ARRAYSIZE(c_achExes) &&
           c_achExes[BINARY_EXE_OFFSET] == TEXT('.'));

    return OnExtList(c_achExes + BINARY_EXE_OFFSET, PathFindExtension(szFile));
}


//
// determine if a path is a program by looking at the extension
//
STDAPI_(BOOL) PathIsExe(LPCTSTR szFile)
{
    LPCTSTR temp = PathFindExtension(szFile);
    return OnExtList(c_achExes, temp);
}

//
// determine if a path is a .lnk file by looking at the extension
//
STDAPI_(BOOL) PathIsLnk(LPCTSTR szFile)
{
    if (szFile)
    {
        // Both PathFindExtension() and lstrcmpi() will crash
        // if passed NULL.  PathFindExtension() will never return
        // NULL.
        LPCTSTR lpszFileName = PathFindExtension(szFile);
        return lstrcmpi(TEXT(".lnk"), lpszFileName) == 0;
    }
    else
    {
        return FALSE;
    }
}

// Port names are invalid path names

#define IsDigit(c) ((c) >= TEXT('0') && c <= TEXT('9'))
STDAPI_(BOOL) PathIsInvalid(LPCWSTR pszName)
{
    static const TCHAR *rgszPorts3[] =  { 
        TEXT("NUL"),
        TEXT("PRN"),
        TEXT("CON"),
        TEXT("AUX"),
    };

    static const TCHAR *rgszPorts4[] =  { 
        TEXT("LPT"),  // LPT#
        TEXT("COM"),  // COM#
    };

    TCHAR sz[7];
    DWORD cch;
    int iMax;
    LPCTSTR* rgszPorts;
    
    if (FAILED(StringCchCopy(sz, ARRAYSIZE(sz), pszName)))
    {
        return FALSE;       // longer names aren't port names
    }

    PathRemoveExtension(sz);
    cch = lstrlen(sz);

    iMax = ARRAYSIZE(rgszPorts3);
    rgszPorts = rgszPorts3;
    if (cch == 4 && IsDigit(sz[3]))
    {
        //  if 4 chars start with LPT checks
        //  need to filter out:
        //      COM1, COM2, etc.  LPT1, LPT2, etc
        //  but not:
        //      COM or LPT or LPT10 or COM10
        //  COM == 1 and LPT == 0

        iMax = ARRAYSIZE(rgszPorts4);
        rgszPorts = rgszPorts4;
        sz[3] = 0;
        cch = 3;
    }

    if (cch == 3)
    {
        int i;
        for (i = 0; i < iMax; i++)
        {
            if (!lstrcmpi(rgszPorts[i], sz))
            {
                break;
            }
        }
        return (i == iMax) ? FALSE : TRUE;
    }
    return FALSE;
}


//
// Funciton: PathMakeUniqueName
//
// Parameters:
//  pszUniqueName -- Specify the buffer where the unique name should be copied
//  cchMax        -- Specify the size of the buffer
//  pszTemplate   -- Specify the base name
//  pszLongPlate  -- Specify the base name for a LFN drive. format below
//  pszDir        -- Specify the directory (at most MAX_PATH in length)
//
// History:
//  03-11-93    SatoNa      Created
//
// REVIEW:
//  For long names, we should be able to generate more user friendly name
//  such as "Copy of MyDocument" of "Link #2 to MyDocument". In this case,
//  we need additional flags which indicates if it is copy, or link.
//
// Format:
// pszLongPlate will search for the first (and then finds the matching)
// to look for a number:
//    given:  Copy () of my doc       gives:  Copy (_number_) of my doc
//    given:  Copy (1023) of my doc   gives:  Copy (_number_) of my doc
//
// PERF: if making n unique names, the time grows n^2 because it always
// starts from 0 and checks for existing file.
//
STDAPI_(BOOL) PathMakeUniqueNameEx(LPTSTR pszUniqueName, UINT cchMax,
                                   LPCTSTR pszTemplate, LPCTSTR pszLongPlate, LPCTSTR pszDir, int iMinLong)
{
    TCHAR szFormat[MAX_PATH]; // should be plenty big
    LPTSTR pszName, pszDigit;
    LPCTSTR pszStem;
    int cchStem, cchDir;
    int iMax, iMin, i;
    int cchMaxName;
    HRESULT hr;

    RIPMSG(pszUniqueName && IS_VALID_WRITE_BUFFER(pszUniqueName, TCHAR, cchMax), "PathMakeUniqueNameEx: caller passed bad pszUniqueName");
    DEBUGWhackPathBuffer(pszUniqueName, cchMax);
    RIPMSG(!pszDir || lstrlen(pszDir)<MAX_PATH, "PathMakeUniqueNameEx: pszDir exceeds MAX_PATH, helper routines don't take cch so this call is broken");
    RIPMSG(iMinLong >= 0, "PathMakeUniqueNameEx: negative iMinLong doesn't make sense");

    if (0==cchMax || !pszUniqueName)
        return FALSE;
    *pszUniqueName = 0; // just in case of failure

    if (pszLongPlate == NULL)
        pszLongPlate = pszTemplate;

    // all cases below check the length of optional pszDir, calculate early.
    // side effect: this set's up pszName and the directory portion of pszUniqueName;
    if (pszDir)
    {
        hr = StringCchCopy(pszUniqueName, cchMax-1, pszDir);    // -1 to allow for '\' from PathAddBackslash
        if (FAILED(hr))
        {
            *pszUniqueName = TEXT('\0');
            return FALSE;
        }
        pszName = PathAddBackslash(pszUniqueName);  // shouldn't fail
        if (NULL == pszName)
        {
            *pszUniqueName = TEXT('\0');
            return FALSE;
        }
        cchDir = lstrlen(pszDir); // we need an accurate count
    }
    else
    {
        cchDir = 0;
        pszName = pszUniqueName;
    }

    // Set up:
    //   pszStem    : template we're going to use
    //   cchStem    : length of pszStem we're going to use w/o wsprintf
    //   szFormat   : format string to wsprintf the number with, catenates on to pszStem[0..cchStem]
    //   iMin       : starting number for wsprintf loop
    //   iMax       : maximum number for wsprintf loop
    //   cchMaxname : !0 implies -> if resulting name length > cchMaxname, then --cchStem (only used in short name case)
    //
    if (pszLongPlate && IsLFNDrive(pszDir))
    {
        LPCTSTR pszRest;
        int cchTmp;

        cchMaxName = 0;

        // for long name drives
        pszStem = pszLongPlate;

        // Has this already been a uniquified name?
        pszRest = StrChr(pszLongPlate, TEXT('('));
        while (pszRest)
        {
            // First validate that this is the right one
            LPCTSTR pszEndUniq = CharNext(pszRest);
            while (*pszEndUniq && *pszEndUniq >= TEXT('0') && *pszEndUniq <= TEXT('9')) {
                pszEndUniq++;
            }
            if (*pszEndUniq == TEXT(')'))
                break;  // We have the right one!
            pszRest = StrChr(CharNext(pszRest), TEXT('('));
        }

        if (!pszRest)
        {
            // Never been unique'd before -- tack it on at the end. (but before the extension)
            // eg.  New Link yields New Link (1)
            pszRest = PathFindExtension(pszLongPlate);
            cchStem = (int)(pszRest - pszLongPlate);

            hr = StringCchPrintf(szFormat, ARRAYSIZE(szFormat), TEXT(" (%%d)%s"), pszRest ? pszRest : c_szNULL);
        }
        else
        {
            // we found (#), so remove the #
            // eg.  New Link (999) yields  New Link (1)

            pszRest++; // step over the '('

            cchStem = (int) (pszRest - pszLongPlate);

            // eat the '#'
            while (*pszRest && *pszRest >= TEXT('0') && *pszRest <= TEXT('9')) {
                pszRest++;
            }

            // we are guaranteed enough room because we don't include
            // the stuff before the # in this format
            hr = StringCchPrintf(szFormat, ARRAYSIZE(szFormat), TEXT("%%d%s"), pszRest);
        }
        if (FAILED(hr))
        {
            *pszUniqueName = TEXT('\0');
            return FALSE;
        }

        // how much room do we have to play?
        iMin = iMinLong;
        cchTmp = cchMax - cchDir - cchStem - (lstrlen(szFormat)-2); // -2 for "%d" which will be replaced
        switch(cchTmp)
        {
            case 1:
                iMax = 10;
                break;
            case 2:
                iMax = 100;
                break;
            default:
                if (cchTmp <= 0)
                    iMax = iMin; // no room, bail
                else
                    iMax = 1000;
                break;
        }
    }
    else // short filename case
    {
        LPCTSTR pszRest;
        int cchRest;
        int cchFormat;

        if (pszTemplate == NULL)
            return FALSE;

        // for short name drives
        pszStem = pszTemplate;
        pszRest = PathFindExtension(pszTemplate);

        // Calculate cchMaxName, ensuring our base name (cchStem+digits) will never go over 8
        //
        cchRest=lstrlen(pszRest);
        cchMaxName = 8+cchRest;

        // Now that we have the extension, we know the format string
        //
        hr = StringCchPrintf(szFormat, ARRAYSIZE(szFormat), TEXT("%%d%s"), pszRest);
        if (FAILED(hr))
        {
            *pszUniqueName = TEXT('\0');
            return FALSE;
        }
        ASSERT(lstrlen(szFormat)-2 == cchRest); // -2 for "%d" in format string
        cchFormat = cchRest;

        // Figure out how long the stem really is:
        //
        cchStem = (int)(pszRest-pszTemplate);        // 8 for "fooobarr.foo"

        // Remove all the digit characters (previous uniquifying) from the stem
        //
        for(; cchStem > 1 ; cchStem--)
        {
            TCHAR ch;

            LPCTSTR pszPrev = CharPrev(pszTemplate, pszTemplate + cchStem);
            // Don't remove if it is a DBCS character
            if (pszPrev != pszTemplate+cchStem-1)
                break;

            // Don't remove it it is not a digit
            ch=pszPrev[0];
            if (ch<TEXT('0') || ch>TEXT('9'))
                break;
        }

        // Short file names mean we use the 8.3 rule, so the stem can't be > 8...
        //
        if ((UINT)cchStem > 8-1)
            cchStem = 8-1;  // need 1 for a digit

        // Truncate the stem to make it fit when we take the directory path into consideration
        //
        while ((cchStem + cchFormat + cchDir + 1 > (int)cchMax - 1) && (cchStem > 1)) // -1 for NULL, +1 for a digit
            cchStem--;

        // We've allowed for 1 character of digit space, but...
        // How many digits can we really use?
        //
        iMin = 1;
        if (cchStem < 1) 
            iMax = iMin; // NONE!
        else if (1 == cchStem)
            iMax = 10; // There's only 1 character of stem left, so use digits 0-9
        else
            iMax = 100; // Room for stem and digits 0-99
    }

    // pszUniqueName has the optional directory in it,
    // pszName points into pszUniqueName where the stem goes,
    // now try to find a unique name!
    //
    hr = StringCchCopyN(pszName, pszUniqueName + MAX_PATH - pszName, pszStem, cchStem);
    if (FAILED(hr))
    {
        *pszUniqueName = TEXT('\0');
        return FALSE;
    }
    pszDigit = pszName + cchStem;

    for (i = iMin; i < iMax ; i++)
    {
        TCHAR szTemp[MAX_PATH];

        hr = StringCchPrintf(szTemp, ARRAYSIZE(szTemp), szFormat, i);
        if (FAILED(hr))
        {
            *pszUniqueName = TEXT('\0');
            return FALSE;
        }

        if (cchMaxName)
        {
            //
            // if we have a limit on the length of the name (ie on a non-LFN drive)
            // backup the pszDigit pointer when i wraps from 9to10 and 99to100 etc
            //
            while (cchStem > 0 && cchStem + lstrlen(szTemp) > cchMaxName)
            {
                --cchStem;
                pszDigit = CharPrev(pszName, pszDigit);
            }
            if (cchStem == 0)
            {
                *pszUniqueName = TEXT('\0');
                return FALSE;
            }
        }

        hr = StringCchCopy(pszDigit, pszUniqueName + MAX_PATH - pszDigit, szTemp);
        if (FAILED(hr))
        {
            *pszUniqueName = TEXT('\0');
            return FALSE;
        }

        TraceMsg(TF_PATH, "PathMakeUniqueNameEx: trying %s", (LPCTSTR)pszUniqueName);

        //
        // Check if this name is unique or not.
        //
        if (!PathFileExists(pszUniqueName))
        {
            return TRUE;
        }
    }

    *pszUniqueName = 0; // we failed, clear out our last attempt

    return FALSE;
}

STDAPI_(BOOL) PathMakeUniqueName(LPTSTR pszUniqueName, UINT cchMax, 
                                 LPCTSTR pszTemplate, LPCTSTR pszLongPlate, LPCTSTR pszDir)
{
    return PathMakeUniqueNameEx(pszUniqueName, cchMax, pszTemplate, pszLongPlate, pszDir, 1);
}


// in:
//      pszPath         directory to do this into or full dest path
//                      if pszShort is NULL
//      pszShort        file name (short version) if NULL assumes
//                      pszPath is both path and spec
//      pszFileSpec     file name (long version)
//
// out:
//      pszUniqueName
//
// note:
//      pszUniqueName can be the same buffer as pszPath or pszShort or pszFileSpec
//
// returns:
//      TRUE    success, name can be used

STDAPI_(BOOL) PathYetAnotherMakeUniqueName(LPTSTR pszUniqueName, LPCTSTR pszPath, LPCTSTR pszShort, LPCTSTR pszFileSpec)
{
    BOOL fRet = FALSE;

    TCHAR szTemp[MAX_PATH];
    TCHAR szPath[MAX_PATH];
    HRESULT hr;

    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1) && lstrlen(pszPath) < MAX_PATH, "PathYetAnotherMakeUniqueName: caller passed invalid pszPath");
    RIPMSG(!pszShort || IS_VALID_STRING_PTR(pszShort, -1), "PathYetAnotherMakeUniqueName: caller passed invalid pszShort");
    RIPMSG(!pszFileSpec || (IS_VALID_STRING_PTR(pszFileSpec, -1) && lstrlen(pszFileSpec) < MAX_PATH), "PathYetAnotherMakeUniqueName: caller passed invalid pszFileSpec");
    RIPMSG(pszUniqueName && IS_VALID_WRITE_BUFFER(pszUniqueName, TCHAR, MAX_PATH), "PathYetAnotherMakeUniqueName: caller passed invalid pszUniqueName");
#ifdef DEBUG
    if (pszUniqueName == pszPath || pszUniqueName == pszShort || pszUniqueName == pszFileSpec)
        DEBUGWhackPathString(pszUniqueName, MAX_PATH);
    else
        DEBUGWhackPathBuffer(pszUniqueName, MAX_PATH);
#endif

    if (pszShort == NULL)
    {
        pszShort = PathFindFileName(pszPath);
        hr = StringCchCopy(szPath, ARRAYSIZE(szPath), pszPath);
        if (FAILED(hr))
        {
            return FALSE;
        }

        PathRemoveFileSpec(szPath);
        pszPath = szPath;
    }
    if (pszFileSpec == NULL)
    {
        pszFileSpec = pszShort;
    }

    if (IsLFNDrive(pszPath))
    {
        LPTSTR lpsz;
        LPTSTR lpszNew;

        // REVIEW:  If the path+filename is too long how about this, instead of bailing out we trunctate the name
        // using my new PathTruncateKeepExtension?  Currently we have many places where the return result of this
        // function is not checked which cause failures in abserdly long filename cases.  The result ends up having
        // the wrong path which screws things up.
        if ((lstrlen(pszPath) + lstrlen(pszFileSpec) + 5) > MAX_PATH)
            return FALSE;

        // try it without the (if there's a space after it
        lpsz = StrChr(pszFileSpec, TEXT('('));
        while (lpsz)
        {
            if (*(CharNext(lpsz)) == TEXT(')'))
                break;
             lpsz = StrChr(CharNext(lpsz), TEXT('('));
        }

        if (lpsz)
        {
            // We have the ().  See if we have either x () y or x ().y in which case
            // we probably want to get rid of one of the blanks...
            int ichSkip = 2;
            LPTSTR lpszT = CharPrev(pszFileSpec, lpsz);
            if (*lpszT == TEXT(' '))
            {
                ichSkip = 3;
                lpsz = lpszT;
            }

            hr = StringCchCopy(szTemp, ARRAYSIZE(szTemp), pszPath);
            if (FAILED(hr))
            {
                return FALSE;
            }
            lpszNew = PathAddBackslash(szTemp);
            if (NULL == lpszNew)
            {
                return FALSE;
            }
            hr = StringCchCopy(lpszNew, szTemp + ARRAYSIZE(szTemp) - lpszNew, pszFileSpec);
            if (FAILED(hr))
            {
                return FALSE;
            }
            lpszNew += (lpsz - pszFileSpec);
            hr = StringCchCopy(lpszNew, szTemp + ARRAYSIZE(szTemp) - lpszNew, lpsz + ichSkip);
            if (FAILED(hr))
            {
                return FALSE;
            }
            fRet = !PathFileExists(szTemp);
        }
        else
        {
            // 1taro registers its document with '/'.
            if (lpsz = StrChr(pszFileSpec, '/'))
            {
                LPTSTR lpszT = CharNext(lpsz);
                hr = StringCchCopy(szTemp, ARRAYSIZE(szTemp), pszPath);
                if (FAILED(hr))
                {
                    return FALSE;
                }
                lpszNew = PathAddBackslash(szTemp);
                if (NULL == lpszNew)
                {
                    return FALSE;
                }
                hr = StringCchCopy(lpszNew, szTemp + ARRAYSIZE(szTemp) - lpszNew, pszFileSpec);
                if (FAILED(hr))
                {
                    return FALSE;
                }
                lpszNew += (lpsz - pszFileSpec);
                hr = StringCchCopy(lpszNew, szTemp + ARRAYSIZE(szTemp) - lpszNew, lpszT);
                if (FAILED(hr))
                {
                    return FALSE;
                }
            }
            else
            {
                if (NULL == PathCombine(szTemp, pszPath, pszFileSpec))
                {
                    return FALSE;
                }
            }
            fRet = !PathFileExists(szTemp);
        }
    }
    else
    {
        ASSERT(lstrlen(PathFindExtension(pszShort)) <= 4);

        hr = StringCchCopy(szTemp, ARRAYSIZE(szTemp), pszShort);
        if (FAILED(hr))
        {
            return FALSE;
        }
        PathRemoveExtension(szTemp);

        if (lstrlen(szTemp) <= 8)
        {
            if (NULL == PathCombine(szTemp, pszPath, pszShort))
            {
                return FALSE;
            }
            fRet = !PathFileExists(szTemp);
        }
    }

    if (!fRet)
    {
        fRet =  PathMakeUniqueNameEx(szTemp, ARRAYSIZE(szTemp), pszShort, pszFileSpec, pszPath, 2);
        if (NULL == PathCombine(szTemp, pszPath, szTemp))
        {
            return FALSE;
        }
    }

    if (fRet)
    {
        hr = StringCchCopy(pszUniqueName, MAX_PATH, szTemp);
        if (FAILED(hr))
        {
            return FALSE;
        }
    }

    return fRet;
}

STDAPI_(void) PathGetShortPath(LPTSTR pszLongPath)
{
    TCHAR szShortPath[MAX_PATH];
    UINT cch;

    RIPMSG(pszLongPath && IS_VALID_STRING_PTR(pszLongPath, -1) && IS_VALID_WRITE_BUFFER(pszLongPath, TCHAR, MAX_PATH), "PathGetShortPath: caller passed invalid pszLongPath");
    DEBUGWhackPathString(pszLongPath, MAX_PATH);

    cch = GetShortPathName(pszLongPath, szShortPath, ARRAYSIZE(szShortPath));
    if (cch != 0 && cch < ARRAYSIZE(szShortPath))
    {
        StringCchCopy(pszLongPath, MAX_PATH, szShortPath);  // must fit, MAX_PATH vs. MAX_PATH
    }
}


//
//  pszFile    -- file path
//  dwFileAttr -- The file attributes, pass -1 if not available
//
//  Note: pszFile arg may be NULL if dwFileAttr != -1.

BOOL PathIsHighLatency(LPCTSTR pszFile /*optional*/, DWORD dwFileAttr)
{
    BOOL bRet = FALSE;
    if (dwFileAttr == -1)
    {
        ASSERT(pszFile != NULL) ;
        dwFileAttr = pszFile ? GetFileAttributes(pszFile) : -1;
    }
    
    if ((dwFileAttr != -1) && (dwFileAttr & FILE_ATTRIBUTE_OFFLINE))
    {
        bRet = TRUE;
    }

    return bRet;
}

//
//  is a path slow or not
//  dwFileAttr -- The file attributes, pass -1 if not available
//
STDAPI_(BOOL) PathIsSlow(LPCTSTR pszFile, DWORD dwFileAttr)
{
    BOOL bSlow = FALSE;
    if (PathIsUNC(pszFile))
    {
        DWORD speed = GetPathSpeed(pszFile);
        bSlow = (speed != 0) && (speed <= SPEED_SLOW);
    }
    else if (CMtPt_IsSlow(PathGetDriveNumber(pszFile)))
        bSlow = TRUE;

    if (!bSlow)
        bSlow = PathIsHighLatency(pszFile, dwFileAttr);

    return bSlow;
}

STDAPI_(BOOL) PathIsSlowA(LPCSTR pszFile, DWORD dwFileAttr)
{
    WCHAR szBuffer[MAX_PATH];

    SHAnsiToUnicode(pszFile, szBuffer, ARRAYSIZE(szBuffer));
    return PathIsSlowW(szBuffer, dwFileAttr);
}

/*----------------------------------------------------------------------------
/ Purpose:
/   Process the specified command line and generate a suitably quoted
/   name, with arguments attached if required.
/
/ Notes:
/   - The destination buffer size can be determined if NULL is passed as a
/     destination pointer.
/   - If the source string is quoted then we assume that it exists on the
/     filing system.
/
/ In:
/   lpSrc -> null terminate source path
/   lpDest -> destination buffer / = NULL to return buffer size
/   iMax = maximum number of characters to return into destination
/   dwFlags =
/       PPCF_ADDQUOTES         = 1 => if path requires quotes then add them
/       PPCF_ADDARGUMENTS      = 1 => append trailing arguments to resulting string (forces ADDQUOTES)
/       PPCF_NODIRECTORIES     = 1 => don't match against directories, only file objects
/       PPCF_LONGESTPOSSIBLE   = 1 => always choose the longest possible executable name ex: d:\program files\fun.exe vs. d:\program.exe
/ Out:
/   > 0 if the call works
/   < 0 if the call fails (object not found, buffer too small for resulting string)
/----------------------------------------------------------------------------*/

STDAPI_(LONG) PathProcessCommand(LPCTSTR lpSrc, LPTSTR lpDest, int iDestMax, DWORD dwFlags)
{
    TCHAR szName[MAX_PATH];
    TCHAR szLastChoice[MAX_PATH];

    LPTSTR lpBuffer, lpBuffer2;
    LPCTSTR lpArgs = NULL;
    DWORD dwAttrib;
    LONG i, iTotal;
    LONG iResult = -1;
    BOOL bAddQuotes = FALSE;
    BOOL bQualify = FALSE;
    BOOL bFound = FALSE;
    BOOL bHitSpace = FALSE;
    BOOL bRelative = FALSE;
    LONG iLastChoice = 0;
    HRESULT hr;

    RIPMSG(lpSrc && IS_VALID_STRING_PTR(lpSrc, -1), "PathProcessCommand: caller passed invalid lpSrc");
    RIPMSG(!lpDest || (iDestMax > 0 && IS_VALID_WRITE_BUFFER(lpDest, TCHAR, iDestMax)), "PathProcessCommand: caller passed invalid lpDest,iDestMax");

    // Process the given source string, attempting to find what is that path, and what is its
    // arguments.

    if (lpSrc)
    {
        // Extract the sub string, if its is realative then resolve (if required).

        if (*lpSrc == TEXT('\"'))
        {
            for (lpSrc++, i=0 ; i<MAX_PATH && *lpSrc && *lpSrc!=TEXT('\"') ; i++, lpSrc++)
                szName[i] = *lpSrc;

            szName[i] = 0;

            if (*lpSrc)
                lpArgs = lpSrc+1;

            if ((dwFlags & PPCF_FORCEQUALIFY) || PathIsRelative(szName))
            {
                if (!PathResolve(szName, NULL, PRF_TRYPROGRAMEXTENSIONS))
                    goto exit_gracefully;
            }

            bFound = TRUE;
        }
        else
        {
            // Is this a relative object, and then take each element upto a seperator
            // and see if we hit an file system object.  If not then we can

            bRelative = PathIsRelative(lpSrc);
            if (bRelative)
                dwFlags &= ~PPCF_LONGESTPOSSIBLE;
            
            bQualify = bRelative || ((dwFlags & PPCF_FORCEQUALIFY) != 0);

            for (i=0; i < MAX_PATH; i++)
            {
                szName[i] = lpSrc[i];

                // If we hit a space then the string either contains a LFN or we have
                // some arguments.  Therefore attempt to get the attributes for the string
                // we have so far, if we are unable to then we can continue
                // checking, if we hit then we know that the object exists and the
                // trailing string are its arguments.

                if (!szName[i] || szName[i] == TEXT(' '))
                {
                    szName[i] = 0;
                    if (!bQualify || PathResolve(szName, NULL, PRF_TRYPROGRAMEXTENSIONS))
                    {
                        dwAttrib = GetFileAttributes(szName);

                        if ((dwAttrib != -1) && (! ((dwAttrib & FILE_ATTRIBUTE_DIRECTORY) && (dwFlags & PPCF_NODIRECTORIES))))
                        {
                            bFound = TRUE;                  // success
                            lpArgs = &lpSrc[i];
                        
                            if (dwFlags & PPCF_LONGESTPOSSIBLE)
                            {
                                hr = StringCchCopyN(szLastChoice, ARRAYSIZE(szLastChoice), szName, i);
                                if (FAILED(hr))
                                {
                                    goto exit_gracefully;
                                }
                                iLastChoice = i;
                            }
                            else
                                goto exit_gracefully;
                        }
                    }

                    if (bQualify)
                        memcpy(szName, lpSrc, (i+1)*sizeof(TCHAR));
                    else
                        szName[i]=lpSrc[i];

                    bHitSpace = TRUE;
                }

                if (!szName[i])
                    break;
            }
        }
    }

exit_gracefully:

    // Work out how big the temporary buffer should be, allocate it and
    // build the returning string into it.  Then compose the string
    // to be returned.

    if (bFound)
    {
        if ((dwFlags & PPCF_LONGESTPOSSIBLE) && iLastChoice)
        {
            StringCchCopyN(szName, ARRAYSIZE(szName), szLastChoice, iLastChoice);
            lpArgs = &lpSrc[iLastChoice];
        }
        
        if (StrChr(szName, TEXT(' ')))
            bAddQuotes = dwFlags & PPCF_ADDQUOTES;

        iTotal  = lstrlen(szName) + 1;                // for terminator
        iTotal += bAddQuotes ? 2 : 0;
        iTotal += (dwFlags & PPCF_ADDARGUMENTS) && lpArgs ? lstrlen(lpArgs) : 0;

        if (lpDest)
        {
            if (iTotal <= iDestMax)
            {
                lpBuffer = lpBuffer2 = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * iTotal);

                if (lpBuffer)
                {
                    // First quote if required
                    if (bAddQuotes)
                        *lpBuffer2++ = TEXT('\"');

                    // Matching name
                    hr = StringCchCopy(lpBuffer2, lpBuffer + iTotal - lpBuffer2, szName);
                    if (SUCCEEDED(hr))
                    {
                        // Closing quote if required
                        if (bAddQuotes)
                        {
                            hr = StringCchCat(lpBuffer2, lpBuffer + iTotal - lpBuffer2, TEXT("\""));
                        }

                        if (SUCCEEDED(hr))
                        {
                            // Arguments (if requested)
                            if ((dwFlags & PPCF_ADDARGUMENTS) && lpArgs)
                            {
                                hr = StringCchCat(lpBuffer2, lpBuffer + iTotal - lpBuffer2, lpArgs);
                            }
                            if (SUCCEEDED(hr))
                            {
                                // Then copy into callers buffer, and free out temporary buffer
                                hr = StringCchCopy(lpDest, iDestMax, lpBuffer);
                            }
                        }

                    }
                    if (SUCCEEDED(hr))
                    {
                        // Return the length of the resulting string
                        iResult = iTotal;
                    }
                    else
                    {
                        // iResult left at -1
                    }

                    LocalFree((HGLOBAL)lpBuffer);

                }
            }
        }
        else
        {
            // Resulting string is this big, although nothing returned (allows them to allocate a buffer)
            iResult = iTotal;
        }
    }

    return iResult;
}


// Gets the mounting point for the path passed in
//
// Return Value: TRUE:  means that we found mountpoint, e.g. c:\ or c:\hostfolder\
//               FALSE: for now means that the path is UNC or buffer too small
//
//           Mounted volume                                 Returned Path
//
//      Passed in E:\MountPoint\path 1\path 2
// C:\ as E:\MountPoint                                 E:\MountPoint
//
//      Passed in E:\MountPoint\MountInter\path 1
// C:\ as D:\MountInter and D:\ as E:\MountPoint        E:\MountPoint\MountInter
//
//      Passed in E:\MountPoint\MountInter\path 1
// No mount                                             E:\ 
BOOL PathGetMountPointFromPath(LPCTSTR pcszPath, LPTSTR pszMountPoint, int cchMountPoint)
{
    BOOL bRet = FALSE;
    HRESULT hr;

    RIPMSG(pcszPath && IS_VALID_STRING_PTR(pcszPath, -1), "PathGetMountPointFromPath: caller passed invalid pcszPath");
    RIPMSG(pszMountPoint && cchMountPoint >= 0 && IS_VALID_WRITE_BUFFER(pszMountPoint, TCHAR, cchMountPoint), "PathGetMountPointFromPath: caller passed invalid pszMountPoint, cchMountPoint");

    if (!PathIsUNC(pcszPath))
    {
        hr = StringCchCopy(pszMountPoint, cchMountPoint, pcszPath);
        if (SUCCEEDED(hr))
        {
            bRet = TRUE;

            // Is this only 'c:' or 'c:\'
            if (lstrlen(pcszPath) > 3)
            {
                //no
                LPTSTR pszNextComp = NULL;
                LPTSTR pszBestChoice = NULL;
                TCHAR cTmpChar;

                if (PathAddBackslash(pszMountPoint))
                {
                    // skip the first one, e.g. "c:\"
                    pszBestChoice = pszNextComp = PathFindNextComponent(pszMountPoint);
                    pszNextComp = PathFindNextComponent(pszNextComp);
                    while (pszNextComp)
                    {
                        cTmpChar = *pszNextComp;
                        *pszNextComp = 0;

                        if (GetVolumeInformation(pszMountPoint, NULL, 0, NULL, NULL, NULL, NULL, 0))
                        {//found something better than previous shorter path
                            pszBestChoice = pszNextComp;
                        }

                        *pszNextComp = cTmpChar;
                        pszNextComp = PathFindNextComponent(pszNextComp);
                    }

                    *pszBestChoice = 0;
                }
                else
                {
                    bRet = FALSE;
                }
            }
        }
    }

    if (!bRet)
    {
        *pszMountPoint = TEXT('\0');
    }

    return bRet;
}


// Returns TRUE if the path is a shortcut to an installed program that can
// be found under Add/Remvoe Programs 
// The current algorithm is just to make sure the target is an exe and is
// located under "program files"

STDAPI_(BOOL) PathIsShortcutToProgram(LPCTSTR pszFile)
{
    BOOL bRet = FALSE;
    if (PathIsShortcut(pszFile, -1))
    {
        TCHAR szTarget[MAX_PATH];
        HRESULT hr = GetPathFromLinkFile(pszFile, szTarget, ARRAYSIZE(szTarget));
        if (hr == S_OK)
        {
            if (PathIsExe(szTarget))
            {
                BOOL bSpecialApp = FALSE;
                HKEY hkeySystemPrograms = NULL;
                if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Management\\System Programs"), 
                    0, KEY_QUERY_VALUE, &hkeySystemPrograms))
                {
                    TCHAR szValue[MAX_PATH];
                    TCHAR szSystemPrograms[MAX_PATH];
                    DWORD cbSystemPrograms = sizeof(szSystemPrograms);
                    DWORD cchValue = ARRAYSIZE(szValue);

                    DWORD dwType; 
                    LPTSTR pszFileName = PathFindFileName(szTarget);
                    int iValue = 0;
                    while (RegEnumValue(hkeySystemPrograms, iValue, szValue, &cchValue, NULL, &dwType,
                                        (LPBYTE)szSystemPrograms, &cbSystemPrograms) == ERROR_SUCCESS)
                    {
                        if ((dwType == REG_SZ) && !StrCmpI(pszFileName, szSystemPrograms))
                        {
                            bSpecialApp = TRUE;
                            break;
                        }

                        cbSystemPrograms = sizeof(szSystemPrograms);
                        cchValue = ARRAYSIZE(szValue);
                        iValue++;
                    }
                    
                    RegCloseKey(hkeySystemPrograms);
                }

                if (!bSpecialApp)
                {
                    TCHAR szProgramFiles[MAX_PATH];
                    if (SHGetSpecialFolderPath(NULL, szProgramFiles, CSIDL_PROGRAM_FILES, FALSE))
                    {
                        if (PathIsPrefix(szProgramFiles, szTarget))
                        {
                            bRet = TRUE;
                        }
                    }
                }
                else
                    bRet = FALSE;
            }
        }
        else if (hr == S_FALSE && szTarget[0])
        {
            // Darwin shortcuts, say yes
            bRet = TRUE;
        }
    }
    return bRet;
}

//
// needed because we export TCHAR versions of these functions that 
// internal components still call
//
// Functions are forwarded to shlwapi
//

#undef PathMakePretty
STDAPI_(BOOL) PathMakePretty(LPTSTR pszPath)
{
    SHELLSTATE ss;
    
    SHGetSetSettings(&ss, SSF_DONTPRETTYPATH, FALSE);
    if (ss.fDontPrettyPath)
        return FALSE;

    return PathMakePrettyW(pszPath);
}

#undef PathGetArgs
STDAPI_(LPTSTR) PathGetArgs(LPCTSTR pszPath)
{
    return PathGetArgsW(pszPath);
}

#undef PathRemoveArgs
STDAPI_(void) PathRemoveArgs(LPTSTR pszPath)
{
    PathRemoveArgsW(pszPath);
}

#undef PathFindOnPath
STDAPI_(BOOL) PathFindOnPath(LPTSTR pszFile, LPCTSTR *ppszOtherDirs)
{
    return PathFindOnPathW(pszFile, ppszOtherDirs);
}

#undef PathFindExtension
STDAPI_(LPTSTR) PathFindExtension(LPCTSTR pszPath)
{
    return PathFindExtensionW(pszPath);
}

#undef PathRemoveExtension
STDAPI_(void) PathRemoveExtension(LPTSTR pszPath)
{
    PathRemoveExtensionW(pszPath);
}

#undef PathRemoveBlanks
STDAPI_(void) PathRemoveBlanks(LPTSTR pszString)
{
    PathRemoveBlanksW(pszString);
}

#undef PathStripToRoot
STDAPI_(BOOL) PathStripToRoot(LPTSTR szRoot)
{
    return PathStripToRootW(szRoot);
}

//CD-Autorun for Win9x called the TCHAR internal api's. So as a workaround we stub them through these function calls.

#undef PathRemoveFileSpec
STDAPI_(BOOL) PathRemoveFileSpec(LPTSTR pFile)
{
    if (SHGetAppCompatFlags(ACF_ANSI) == ACF_ANSI)
        return PathRemoveFileSpecA((LPSTR)pFile);
    else
        return PathRemoveFileSpecW(pFile);
}

#undef PathAddBackslash
STDAPI_(LPTSTR) PathAddBackslash(LPTSTR pszPath)
{
    return PathAddBackslashW(pszPath);
}

#undef PathFindFileName
STDAPI_(LPTSTR) PathFindFileName(LPCTSTR pszPath)
{
    return PathFindFileNameW(pszPath);
}

#undef PathStripPath
STDAPI_(void) PathStripPath(LPTSTR pszPath)
{
    PathStripPathW(pszPath);
}

// CD-Autorun for Win9x called the TCHAR internal api's. So as a workaround we stub them through these function calls.

#undef PathIsRoot
STDAPI_(BOOL) PathIsRoot(LPCTSTR pszPath)
{
    if (SHGetAppCompatFlags(ACF_ANSI) == ACF_ANSI)
        return PathIsRootA((LPCSTR)pszPath);
    else
        return PathIsRootW(pszPath);
}

#undef PathSetDlgItemPath
STDAPI_(void) PathSetDlgItemPath(HWND hDlg, int id, LPCTSTR pszPath)
{
    PathSetDlgItemPathW(hDlg, id, pszPath);
}

#undef PathUnquoteSpaces
STDAPI_(void) PathUnquoteSpaces(LPTSTR psz)
{
    PathUnquoteSpacesW(psz);
}

#undef PathQuoteSpaces
STDAPI_(void) PathQuoteSpaces(LPTSTR psz)
{
    PathQuoteSpacesW(psz);
}

#undef PathMatchSpec
STDAPI_(BOOL) PathMatchSpec(LPCTSTR pszFileParam, LPCTSTR pszSpec)
{
    return PathMatchSpecW(pszFileParam, pszSpec);
}

#undef PathIsSameRoot
STDAPI_(BOOL) PathIsSameRoot(LPCTSTR pszPath1, LPCTSTR pszPath2)
{
    return PathIsSameRootW(pszPath1, pszPath2);
}

#undef PathParseIconLocation
STDAPI_(int) PathParseIconLocation(IN OUT LPTSTR pszIconFile)
{
    return PathParseIconLocationW(pszIconFile);
}

#undef PathIsURL
STDAPI_(BOOL) PathIsURL(IN LPCTSTR pszPath)
{
    return PathIsURLW(pszPath);
}

#undef PathIsDirectory
STDAPI_(BOOL) PathIsDirectory(LPCTSTR pszPath)
{
    return PathIsDirectoryW(pszPath);
}

// CD-Autorun for Win9x called the TCHAR internal api's. So as a workaround we stub them through these function calls.

#undef PathFileExists
STDAPI_(BOOL) PathFileExists(LPCTSTR pszPath)
{
    if (SHGetAppCompatFlags(ACF_ANSI) == ACF_ANSI)
        return PathFileExistsAndAttributesA((LPCSTR)pszPath, NULL);
    else
        return PathFileExistsAndAttributesW(pszPath, NULL);
}

#undef PathAppend
STDAPI_(BOOL) PathAppend(LPTSTR pszPath, LPCTSTR pszMore)
{
  if (SHGetAppCompatFlags(ACF_ANSI) == ACF_ANSI)
     return PathAppendA((LPSTR)pszPath, (LPCSTR)pszMore);
  else
     return PathAppendW(pszPath, pszMore);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\pifhot.c ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1991
 *  All Rights Reserved.
 *
 *
 *  PIFHOT.C
 *  User interface routines for hot-keys
 *
 *  History:
 *  Created 21-Dec-1992 5:30pm by Jeff Parsons (based on old PIFEDIT code)
 *  Rewritten 25-Dec-1993 by Raymond Chen
 */

#include "shellprv.h"
#pragma hdrstop

#ifdef _X86_


/*
 * Values for the second argument to MapVirtualKey, mysteriously
 * missing from windows.h.
 */
#define MVK_OEMFROMVK 0
#define MVK_VKFROMOEM 1

/*
 * BEWARE!  Converting a VK to a scan code and back again does not
 * necessarily get you back where you started!  The main culprit
 * is the numeric keypad, since (for example) VK_LEFT and VK_NUMPAD4
 * both map to scan code 0x4B.  We catch the numeric keypad specially
 * for exactly this purpose.
 *
 * The following table converts VK codes VK_NUMPAD0 through VK_NUMPAD9
 * to the corresponding VK_ code if NumLock is off.
 *
 * Note that this table and the loop that accesses it assume that the
 * scan codes VK_NUMPAD0 through VK_NUMPAD9 are consecutive.
 */

WORD mpvkvk[10] = {
    VK_INSERT,                  /* VK_NUMPAD0 */
    VK_END,                     /* VK_NUMPAD1 */
    VK_DOWN,                    /* VK_NUMPAD2 */
    VK_NEXT,                    /* VK_NUMPAD3 */
    VK_LEFT,                    /* VK_NUMPAD4 */
    VK_CLEAR,                   /* VK_NUMPAD5 */
    VK_RIGHT,                   /* VK_NUMPAD6 */
    VK_HOME,                    /* VK_NUMPAD7 */
    VK_UP,                      /* VK_NUMPAD8 */
    VK_PRIOR,                   /* VK_NUMPAD9 */
};

/*
 * PIF_Ky_Val
 *      = 1, if extended code   (key is an extended code only)
 *      = 0FFh, if either       (key is EITHER extended or not extended)
 *      = 0  if not extended    (key is not extended only)
 *
 *          bit 15 - Ins depressed
 *          bit 14 - Caps Lock depressed
 *          bit 13 - Num Lock depressed
 *          bit 12 - Scroll Lock depressed
 *          bit 11 - hold state active(Ctrl-Num Lock)
 *          bit 10 - 0
 *          bit  9 - 0
 *          bit  8 - 0
 *          bit  7 - Insert state active
 *          bit  6 - Caps Lock state active
 *          bit  5 - Num Lock state active
 *          bit  4 - Scroll Lock state active
 *          bit  3 - Alt shift depressed
 *          bit  2 - Ctrl shift depressed
 *          bit  1 - left shift depressed
 *          bit  0 - right shift depressed
 */
#define fPIFSh_RShf     0x0001          /* Right shift key */
#define fPIFSh_RShfBit  0

#define fPIFSh_LShf     0x0002          /* Left shift key */
#define fPIFSh_LShfBit  1

#define fPIFSh_Ctrl     0x0004          /* Either Control shift key */
#define fPIFSh_CtrlBit  2

#define fPIFSh_Alt      0x0008          /* Either Alt shift key */
#define fPIFSh_AltBit   3

#define fPIFSh_ScLok    0x0010          /* Scroll lock active */
#define fPIFSh_ScLokBit 4

#define fPIFSh_NmLok    0x0020          /* Num lock active */
#define fPIFSh_NmLokBit 5

#define fPIFSh_CpLok    0x0040          /* Caps lock active */
#define fPIFSh_CpLokBit 6

#define fPIFSh_Insrt    0x0080          /* Insert active */
#define fPIFSh_InsrtBit 7

#define fPIFSh_Ext0     0x0400          /* Extended K/B shift */
#define fPIFSh_Ext0Bit  10

#define fPIFSh_Hold     0x0800          /* Ctrl-Num-Lock/Pause active */
#define fPIFSh_HoldBit  11

#define fPIFSh_LAlt     0x1000          /* Left Alt key is down */
#define fPIFSh_LAltBit  12

#define fPIFSh_RAlt     0x2000          /* Right Alt key is down */
#define fPIFSh_RAltBit  13

#define fPIFSh_LCtrl    0x4000          /* Left Ctrl key is down */
#define fPIFSh_LCtrlBit 14

#define fPIFSh_RCtrl    0x8000          /* Right Ctrl key is down */
#define fPIFSh_RCtrlBit 15

/** HotKeyWindowsFromOem - Convert OEM hotkey into Windows hotkey
 *
 * INPUT
 *  lppifkey -> PIFKEY describing OEM Hotkey
 *
 * OUTPUT
 *  Windows hotkey value corresponding to lpwHotkey.
 */

WORD HotKeyWindowsFromOem(LPCPIFKEY lppifkey)
{
    WORD wHotKey = 0;

    if (lppifkey->Scan) {
        wHotKey = (WORD) MapVirtualKey(lppifkey->Scan, MVK_VKFROMOEM);

        if (lppifkey->Val & 2) {
            WORD vk;
            for (vk = VK_NUMPAD0; vk <= VK_NUMPAD9; vk++) {
                if (wHotKey == mpvkvk[vk - VK_NUMPAD0]) {
                    wHotKey = vk; break;
                }
            }
            ASSERTTRUE(vk <= VK_NUMPAD9); /* Buggy PIF; do what we can */
        }

        if (lppifkey->Val & 1) wHotKey |= (HOTKEYF_EXT << 8);

        if (lppifkey->ShVal & (fPIFSh_RShf | fPIFSh_LShf))
            wHotKey |= (HOTKEYF_SHIFT << 8);

        if (lppifkey->ShVal & (fPIFSh_LCtrl|fPIFSh_RCtrl|fPIFSh_Ctrl))
            wHotKey |= (HOTKEYF_CONTROL << 8);

        if (lppifkey->ShVal & (fPIFSh_LAlt|fPIFSh_RAlt|fPIFSh_Alt))
            wHotKey |= (HOTKEYF_ALT << 8);
    }
    return wHotKey;
}


/** HotKeyOemFromWindows - Convert Windows hotkey into OEM hotkey
 *
 * INPUT
 *  lppifkey -> struct PIF_Key to receive OEM hotkey
 *  wHotKey  =  Windows hotkey
 *
 * OUTPUT
 *  lppifkey filled with hotkey info
 */

void HotKeyOemFromWindows(LPPIFKEY lppifkey, WORD wHotKey)
{
    lppifkey->Scan = 0;
    lppifkey->ShVal = 0;
    lppifkey->ShMsk = 0;
    lppifkey->Val = 0;

    if (wHotKey) {
        lppifkey->Scan = (WORD) MapVirtualKey(LOBYTE(wHotKey), MVK_OEMFROMVK);
        lppifkey->ShMsk = fPIFSh_RShf | fPIFSh_LShf | fPIFSh_Ctrl | fPIFSh_Alt;

        if (wHotKey & (HOTKEYF_EXT << 8)) lppifkey->Val |= 1;

        /* Assumes that VK_NUMPAD0 through VK_NUMPAD9 are consecutive */
        if ((wHotKey - VK_NUMPAD0) < 10) lppifkey->Val |= 2;

        if (wHotKey & (HOTKEYF_SHIFT << 8))
            lppifkey->ShVal |= fPIFSh_RShf | fPIFSh_LShf;

        if (wHotKey & (HOTKEYF_CONTROL << 8))
            lppifkey->ShVal |= fPIFSh_Ctrl;

        if (wHotKey & (HOTKEYF_ALT << 8))
            lppifkey->ShVal |= fPIFSh_Alt;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\pifinfp.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1992,1993
 *  All Rights Reserved.
 *
 *
 *  PIFINFP.H
 *  Private PIFMGR include file
 *
 *  History:
 *  Created 22-Mar-1993 2:58pm by Jeff Parsons
 */


/*
 *  APPS.INF [pif95] section fields
 */
#define APPSINF_FILENAME        0       //
#define APPSINF_TITLE           1       //
#define APPSINF_ICONFILE        2       // default is APPSINF_DEFAULT_ICONFILE
#define APPSINF_ICONINDEX       3       //
#define APPSINF_NOWORKDIR       4       //
#define APPSINF_SECTIONID       5       //
#define APPSINF_OTHERFILE       6       //
#define APPSINF_NOPIF           7       //

#define APPSINF_DEFAULT_SECTION  TEXT("default")


/*
 *  APPS.INF section key IDs
 */
#define APPSINF_KEY             0       // field number

#define KEY_PARAMS              TEXT("params")
#define KEY_BATCHFILE           TEXT("batchfile")
#define KEY_LOWMEM              TEXT("lowmem")
#define KEY_EMSMEM              TEXT("emsmem")
#define KEY_XMSMEM              TEXT("xmsmem")
#define KEY_DPMIMEM             TEXT("dpmimem")
#define KEY_ENABLE              TEXT("enable")
#define KEY_DISABLE             TEXT("disable")

#define MAX_KEY_SIZE            16

#define KEYID_UNKNOWN           -1
#define KEYID_NONE              0
#define KEYID_PARAMS            1
#define KEYID_BATCHFILE         2
#define KEYID_LOWMEM            3
#define KEYID_EMSMEM            4
#define KEYID_XMSMEM            5
#define KEYID_DPMIMEM           6
#define KEYID_ENABLE            7
#define KEYID_DISABLE           8


/*
 *  APPS.INF string switches used to set PIF options
 */
#define APPSINF_KEYVAL          1       // field number
#define APPSINF_KEYVAL2         2       // field number

#define KEYVAL_WINDOWED         TEXT("win")   // (formerly DISPUSAGE)
#define KEYVAL_BACKGROUND       TEXT("bgd")   // (formerly EXECFLAGS)
#define KEYVAL_EXCLUSIVE        TEXT("exc")   // (formerly EXECFLAGS)
#define KEYVAL_DETECTIDLE       TEXT("dit")   // (formerly PROCMEMFLAGS)
#define KEYVAL_LOWLOCKED        TEXT("lml")   // (formerly PROCMEMFLAGS:lam)
#define KEYVAL_EMSLOCKED        TEXT("eml")   // (formerly PROCMEMFLAGS)
#define KEYVAL_XMSLOCKED        TEXT("xml")   // (formerly PROCMEMFLAGS)
#define KEYVAL_USEHMA           TEXT("hma")   // (formerly PROCMEMFLAGS)
#define KEYVAL_EMULATEROM       TEXT("emt")   // (formerly DISPFLAGS)
#define KEYVAL_RETAINVRAM       TEXT("rvm")   // (formerly DISPFLAGS)
#define KEYVAL_FASTPASTE        TEXT("afp")   // (formerly OTHEROPTIONS)
#define KEYVAL_ALTTAB           TEXT("ata")   // (formerly OTHEROPTIONS)
#define KEYVAL_ALTESC           TEXT("aes")   // (formerly OTHEROPTIONS)
#define KEYVAL_CTRLESC          TEXT("ces")   // (formerly OTHEROPTIONS)
#define KEYVAL_PRTSCRN          TEXT("psc")   // (formerly OTHEROPTIONS)
#define KEYVAL_ALTPRTSCRN       TEXT("aps")   // (formerly OTHEROPTIONS)
#define KEYVAL_ALTSPACE         TEXT("asp")   // (formerly OTHEROPTIONS)
#define KEYVAL_ALTENTER         TEXT("aen")   // (formerly OTHEROPTIONS)
#define KEYVAL_WINLIE           TEXT("lie")   // (NEW)
#define KEYVAL_GLOBALMEM        TEXT("gmp")   // (NEW)
#define KEYVAL_REALMODE         TEXT("dos")   // (NEW)
#define KEYVAL_MOUSE            TEXT("mse")   // (NEW)
#define KEYVAL_EMS              TEXT("ems")   // (NEW)
#define KEYVAL_CDROM            TEXT("cdr")   // (NEW)
#define KEYVAL_NETWORK          TEXT("net")   // (NEW)
#define KEYVAL_DISKLOCK         TEXT("dsk")   // (NEW)
#define KEYVAL_PRIVATECFG       TEXT("cfg")   // (NEW)
#define KEYVAL_CLOSEONEXIT      TEXT("cwe")   // (NEW)
#define KEYVAL_ALLOWSSAVER      TEXT("sav")     // (NEW)
#define KEYVAL_UNIQUESETTINGS   TEXT("uus")     // (NEW)
#ifdef LATER
#define KEYVAL_DISPLAYTBAR      TEXT("dtb")   // (NEW)
#define KEYVAL_RESTOREWIN       TEXT("rws")   // (NEW)
#define KEYVAL_QUICKEDIT        TEXT("qme")   // (NEW)
#define KEYVAL_EXCLMOUSE        TEXT("exm")   // (NEW)
#define KEYVAL_WARNIFACTIVE     TEXT("wia")   // (NEW)
#endif

#define MAX_KEYVAL_SIZE         6

#define KEYVAL_ID_UNKNOWN       -1
#define KEYVAL_ID_NONE          0
#define KEYVAL_ID_WINDOWED      1
#define KEYVAL_ID_BACKGROUND    2
#define KEYVAL_ID_EXCLUSIVE     3
#define KEYVAL_ID_DETECTIDLE    4
#define KEYVAL_ID_LOWLOCKED     5
#define KEYVAL_ID_EMSLOCKED     6
#define KEYVAL_ID_XMSLOCKED     7
#define KEYVAL_ID_USEHMA        8
#define KEYVAL_ID_EMULATEROM    9
#define KEYVAL_ID_RETAINVRAM    10
#define KEYVAL_ID_FASTPASTE     11
#define KEYVAL_ID_ALTTAB        12
#define KEYVAL_ID_ALTESC        13
#define KEYVAL_ID_CTRLESC       14
#define KEYVAL_ID_PRTSCRN       15
#define KEYVAL_ID_ALTPRTSCRN    16
#define KEYVAL_ID_ALTSPACE      17
#define KEYVAL_ID_ALTENTER      18
#define KEYVAL_ID_WINLIE        19
#define KEYVAL_ID_GLOBALMEM     20
#define KEYVAL_ID_REALMODE      21
#define KEYVAL_ID_MOUSE         22
#define KEYVAL_ID_EMS           23
#define KEYVAL_ID_CDROM         24
#define KEYVAL_ID_NETWORK       25
#define KEYVAL_ID_DISKLOCK      26
#define KEYVAL_ID_PRIVATECFG    27
#define KEYVAL_ID_CLOSEONEXIT   28
#define KEYVAL_ID_ALLOWSSAVER   29
#define KEYVAL_ID_UNIQUESETTINGS 30
#ifdef LATER
#define KEYVAL_ID_DISPLAYTBAR   31
#define KEYVAL_ID_RESTOREWIN    32
#define KEYVAL_ID_QUICKEDIT     33
#define KEYVAL_ID_EXCLMOUSE     34
#define KEYVAL_ID_WARNIFACTIVE  35
#endif


/*
 *  Internal function prototypes
 */

#include <setupapi.h>

#ifdef UNICODE
BOOL GetAppsInfData(PPROPLINK ppl, LPPROPPRG lpPrg, LPPROPNT40 lpnt40, HINF hInf, LPCTSTR lpszApp, BOOL fNotAmbiguous, int flOpt);
#else
BOOL GetAppsInfData(PPROPLINK ppl, LPPROPPRG lpPrg, HINF hInf, LPCTSTR lpszApp, BOOL fNotAmbiguous, int flOpt);
#endif
void GetAppsInfSectionData(PINFCONTEXT pInfContext, LPCTSTR lpszSection, PPROPLINK ppl);
int  GetKeyID(PINFCONTEXT pInfContext);
int  GetKeyValID(PINFCONTEXT pInfContext, int i);

#ifdef UNICODE
void InitWorkDir(PPROPLINK ppl, LPPROPPRG lpPrg, LPPROPNT40 lpnt40);
#else
void InitWorkDir(PPROPLINK ppl, LPPROPPRG lpPrg);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\pifhotp.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1992,1993
 *  All Rights Reserved.
 *
 *
 *  PIFHOTP.H
 *  Private PIFMGR include file
 *
 *  History:
 *  Created 22-Mar-1993 2:58pm by Jeff Parsons
 */

#ifdef  OLD_HOTKEY_GOOP

#define CLASS_PIFHOTKEY         TEXT("PIFHotKey")

#define WM_SETPIFHOTKEY         (WM_USER+0)
#define WM_GETPIFHOTKEY         (WM_USER+1)

/* XLATOFF */
#define ALT_LPARAM              ((DWORD)((DWORD)(MapVirtualKey(VK_MENU,0)) << 16))
#define CTRL_LPARAM             ((DWORD)((DWORD)(MapVirtualKey(VK_CONTROL,0)) << 16))
#define SHIFT_LPARAM            ((DWORD)((DWORD)(MapVirtualKey(VK_SHIFT,0)) << 16))
/* XLATON */


/*
 *  Internal function prototypes
 */

BOOL LoadGlobalHotKeyEditData(void);
void FreeGlobalHotKeyEditData(void);
long HotKeyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void SetHotKeyCaret(PHOTINFO phi);
void ChangeHotKey(PHOTINFO phi);
void SetHotKeyText(PHOTINFO phi, PHOTKEY phk);
void SetHotKeyLen(PHOTINFO phi);
void SetHotKeyState(PHOTINFO phi, WORD keyid, LONG lParam);

#endif /* OLD_HOTKEY_GOOP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\piflib.c ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1991
 *  All Rights Reserved.
 *
 *
 *  PIFLIB.C
 *  User interface routines for PIFMGR.DLL
 *
 *  History:
 *  Created 31-Jul-1992 3:30pm by Jeff Parsons
 */

#include "shellprv.h"
#pragma hdrstop

#ifdef _X86_

#define LIB_SIG                 0x504A

#define LIB_DEFER               LOADPROPLIB_DEFER

typedef struct LIBLINK {        /* ll */
    struct  LIBLINK *pllNext;   //
    struct  LIBLINK *pllPrev;   //
    int     iSig;               // liblink signature
    int     flLib;              // proplink flags (LIB_*)
    HINSTANCE hDLL;             // if NULL, then load has been deferred
    TCHAR    achDLL[80];        // name of DLL
} LIBLINK;
typedef LIBLINK *PLIBLINK;


#define SHEET_SIG               0x504A

typedef struct SHEETLINK {      /* sl */
    struct  SHEETLINK *pslNext;
    struct  SHEETLINK *pslPrev;
    int     iSig;
    int     iType;
    PROPSHEETPAGE psi;
} SHEETLINK;
typedef SHEETLINK *PSHEETLINK;


UINT    cEdits;                 // number of edit sessions in progress

PLIBLINK pllHead;               // pointer to first lib link
HANDLE   offHighestLibLink;      // highest offset of a lib link thus far recorded

PSHEETLINK pslHead;             // pointer to first sheet link
UINT    cSheetLinks;            // number of sheet links
HANDLE  offHighestSheetLink;    // highest offset of a sheet link thus far recorded


struct {                        // built-in property sheet info
    LPCTSTR  lpTemplateName;
    DLGPROC lpfnDlgProc;
    int     iType;
} const aPSInfo[] = {
    { MAKEINTRESOURCE(IDD_PROGRAM), DlgPrgProc, SHEETTYPE_SIMPLE},
    { MAKEINTRESOURCE(IDD_FONT),    DlgFntProc, SHEETTYPE_SIMPLE},
    { MAKEINTRESOURCE(IDD_MEMORY),  DlgMemProc, SHEETTYPE_SIMPLE},
    { MAKEINTRESOURCE(IDD_SCREEN),  DlgVidProc, SHEETTYPE_SIMPLE},
    { MAKEINTRESOURCE(IDD_MISC),    DlgMscProc, SHEETTYPE_SIMPLE},
};


/** EnumPropertyLibs - enumerate property libraries
 *
 * INPUT
 *  iLib    == 0 to begin enumeration, or result of previous call
 *  lphDLL  -> where to store handle (NULL if don't care)
 *  lpszDLL -> where to store name of library (NULL if don't care)
 *  cchszDLL == size of space (in chars) to store name
 *
 * OUTPUT
 *  lphDLL and lpszDLL filled in as appropriate, 0 if no more libs (or error)
 */

HANDLE WINAPI EnumPropertyLibs(HANDLE iLib, LPHANDLE lphDLL, LPTSTR lpszDLL, int cchszDLL)
{
    register PLIBLINK pll;
    FunctionName(EnumPropertyLibs);

    if (!iLib)
        pll = pllHead;
    else
        pll = ((PLIBLINK)iLib)->pllNext;

    // Validate the handle

    if (!pll)
        return 0;

    if ((HANDLE) pll > offHighestLibLink)
        return 0;

    if (pll->iSig != LIB_SIG)
        return 0;

    if (lphDLL)
        *lphDLL = pll->hDLL;

    if (lpszDLL)
        StringCchCopy(lpszDLL, min(cchszDLL, ARRAYSIZE(pll->achDLL)), pll->achDLL);

    return pll;
}


/** LoadPropertySheets - load property sheets
 *
 * INPUT
 *  hProps = property handle
 *  flags = 0 (reserved)
 *
 * OUTPUT
 *  # of sheets loaded, 0 if error
 */

int WINAPI LoadPropertySheets(HANDLE hProps, int flags)
{
    register PLIBLINK pll;
    FunctionName(LoadPropertySheets);

    // If this is the first edit session, do global init now

    if (cEdits++ == 0)
        if (!LoadGlobalEditData())
            return 0;

    pll = NULL;
    while (NULL != (pll = (PLIBLINK)EnumPropertyLibs(pll, NULL, NULL, 0))) {
        if (!pll->hDLL && (pll->flLib & LIB_DEFER)) {

            pll->hDLL = LoadLibrary(pll->achDLL);

            // If the load failed, to us that simply means those sheets
            // will not be available; the particular error is not interesting,
            // so nullify the handle

            if (pll->hDLL < (HINSTANCE)HINSTANCE_ERROR)
                pll->hDLL = NULL;
        }
    }
    return cSheetLinks + ARRAYSIZE(aPSInfo);
}


/** EnumPropertySheets - enumerate property sheets
 *
 * INPUT
 *  hProps == property handle
 *  iType  == sheet type (see SHEETTYPE_* constants)
 *  iSheet == 0 to begin enumeration, or result of previous call
 *  lppsi -> property sheet info structure to be filled in
 *
 * OUTPUT
 *  lppsi filled in as appropriate, 0 if no more sheets (or error)
 */

INT_PTR WINAPI EnumPropertySheets(HANDLE hProps, int iType, INT_PTR iSheet, LPPROPSHEETPAGE lppsp)
{
    register PSHEETLINK psl;
    FunctionName(EnumPropertySheets);

    while (iSheet < ARRAYSIZE(aPSInfo)) {
        if (aPSInfo[iSheet].iType <= iType) {
            if (lppsp) {
                lppsp->dwSize      = SIZEOF(PROPSHEETPAGE);
                lppsp->dwFlags     = PSP_DEFAULT;
                lppsp->hInstance   = HINST_THISDLL;
                lppsp->pszTemplate = aPSInfo[iSheet].lpTemplateName;
                lppsp->pfnDlgProc  = aPSInfo[iSheet].lpfnDlgProc;
                // lppsp->pszTitle    = NULL;
                lppsp->lParam      = (LONG_PTR)hProps;
            }
            return ++iSheet;
        }
        ++iSheet;
    }
    if (iSheet == ARRAYSIZE(aPSInfo))
        psl = pslHead;
    else
        psl = ((PSHEETLINK)iSheet)->pslNext;

    // Validate the handle

    while (psl && (HANDLE) psl <= offHighestSheetLink && psl->iSig == SHEET_SIG) {

        if (psl->iType <= iType) {

            *lppsp = psl->psi;
            lppsp->lParam = (LONG_PTR)hProps;

            return (INT_PTR) psl;
        }
        psl = psl->pslNext;
    }
    return 0;                   // no more matching sheets
}


/** FreePropertySheets - free property sheets
 *
 * INPUT
 *  hProps = property handle
 *  flags = 0 (reserved)
 *
 * OUTPUT
 *  Nothing
 */

HANDLE WINAPI FreePropertySheets(HANDLE hProps, int flags)
{
    register PLIBLINK pll;
    FunctionName(FreePropertySheets);

    pll = NULL;
    while (NULL != (pll = (PLIBLINK)EnumPropertyLibs(pll, NULL, NULL, 0))) {
        if (pll->hDLL && (pll->flLib & LIB_DEFER)) {
            FreeLibrary(pll->hDLL);
            pll->hDLL = NULL;
        }
    }
    // If this is the last edit session, do global un-init now

    if (--cEdits == 0)
        FreeGlobalEditData();

    return 0;
}


/** InitRealModeFlag - Initialize PROP_REALMODE
 *
 * INPUT
 *  ppl = properties
 *
 * OUTPUT
 *  ppl->flProp PROP_REALMODE bit set if sheet is for real-mode app,
 *  else clear.
 */

void InitRealModeFlag(PPROPLINK ppl)
{
    PROPPRG prg;

    if (!PifMgr_GetProperties(ppl, MAKELP(0,GROUP_PRG),
                        &prg, SIZEOF(prg), GETPROPS_NONE)) {
        return;                 /* Weird */
    }
    if (prg.flPrgInit & PRGINIT_REALMODE) {
        ppl->flProp |= PROP_REALMODE;
    } else {
        ppl->flProp &= ~PROP_REALMODE;
    }
}


BOOL LoadGlobalEditData()
{
    FunctionName(LoadGlobalEditData);

    if (!LoadGlobalFontEditData())
        return FALSE;

    return TRUE;
}


void FreeGlobalEditData()
{
    FunctionName(FreeGlobalEditData);
    FreeGlobalFontEditData();
}


UINT CALLBACK PifPropPageRelease(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE lppsp)
{
    FunctionName(PifPropPageRelease);

    if (uMsg == PSPCB_RELEASE) {
        PPROPLINK ppl = (PPROPLINK)(INT_PTR)lppsp->lParam;

        if ((--ppl->iSheetUsage) == 0) {

            FreePropertySheets(ppl, 0);

            PifMgr_CloseProperties(ppl, CLOSEPROPS_NONE);
        }
    }
    return 1;
}

#define MZMAGIC      ((WORD)'M'+((WORD)'Z'<<8))

//
// call SHELL.DLL to get the EXE type.
//
BOOL IsWinExe(LPCTSTR lpszFile)
{
    DWORD dw = (DWORD) SHGetFileInfo(lpszFile, 0, NULL, 0, SHGFI_EXETYPE);

    return dw && LOWORD(dw) != MZMAGIC;
}

BOOL WINAPI PifPropGetPages(LPVOID lpv,
                            LPFNADDPROPSHEETPAGE lpfnAddPage,
                            LPARAM lParam)
{
#define hDrop   (HDROP)lpv
    PPROPLINK ppl;
    PROPSHEETPAGE psp;
    int iType, cSheets;
    INT_PTR iSheet;
    HPROPSHEETPAGE hpage;
    TCHAR szFileName[MAXPATHNAME];
    FunctionName(PifPropGetPages);

    // only process things if hDrop contains only one file
    if (DragQueryFile(hDrop, (UINT)-1, NULL, 0) != 1)
    {
        return TRUE;
    }

    // get the name of the file
    DragQueryFile(hDrop, 0, szFileName, ARRAYSIZE(szFileName));

    if (GetFileAttributes( szFileName) & FILE_ATTRIBUTE_OFFLINE)
    {
        return FALSE;
    }

    // if this is a windows app, don't do no properties
    if (IsWinExe(szFileName))
        return TRUE;

    // if we can't get a property handle, don't do no properties either
    if (!(ppl = (PPROPLINK)PifMgr_OpenProperties(szFileName, NULL, 0, OPENPROPS_NONE)))
        return TRUE;

    InitRealModeFlag(ppl);

    if (!(cSheets = LoadPropertySheets(ppl, 0)))
        goto CloseProps;

    // Since the user wishes to *explicitly* change settings for this app
    // we make sure that the DONTWRITE flag isn't going to get in his way...

    ppl->flProp &= ~PROP_DONTWRITE;

    iSheet = cSheets = 0;
    iType = (GetKeyState(VK_CONTROL) >= 0? SHEETTYPE_SIMPLE : SHEETTYPE_ADVANCED);

    while (TRUE) {

        if (!(iSheet = EnumPropertySheets(ppl, iType, iSheet, &psp))) {
            // done with enumeration
            break;
        }
        psp.dwFlags |= PSP_USECALLBACK;
        psp.pfnCallback = PifPropPageRelease;
        psp.pcRefParent = 0;

        hpage = CreatePropertySheetPage(&psp);
        if (hpage)
        {
            // the PROPLINK is now being used by this property sheet as well

            if (lpfnAddPage(hpage, lParam))
            {
                ppl->iSheetUsage++;
                cSheets++;
            }
            else
            {
                PifPropPageRelease(NULL, PSPCB_RELEASE, &psp);
            }
        }
    }

    if (!cSheets) {
        FreePropertySheets(ppl, 0);

CloseProps:
        PifMgr_CloseProperties(ppl, CLOSEPROPS_NONE);
    }
    return TRUE;
}
#undef hDrop

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\piffntp.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1992,1993
 *  All Rights Reserved.
 *
 *
 *  PIFFNTP.H
 *  Private PIFMGR include file
 *
 *  History:
 *  Created 22-Mar-1993 2:58pm by Jeff Parsons (from vmdosapp\fontutil.h)
 */

#define PREVIEW_BORDER          1

#define DY_TTBITMAP             12

/*
 *  These parameters control how fast the fdiCache should grow.
 */

#define FDI_TABLE_START         20      /* Number of entries to start */
#define FDI_TABLE_INC           10      /* Increment in number of slots */


typedef struct tagDISPLAYPARAMETERS {   /* dp */
    INT dpHorzSize;
    INT dpVertSize;
    INT dpHorzRes;
    INT dpVertRes;
    INT dpLogPixelsX;
    INT dpLogPixelsY;
    INT dpAspectX;
    INT dpAspectY;
    INT dpBitsPerPixel;
    TCHAR szTTFace[2][LF_FACESIZE];
} DISPLAYPARAMETERS;

//#define BACKGROUND    0x000000FF      /* bright blue  */
//#define BACKGROUNDSEL 0x00FF00FF      /* bright magenta */
//#define BUTTONFACE    0x00C0C0C0      /* bright grey  */
//#define BUTTONSHADOW  0x00808080      /* dark grey    */


#define FNTFLAGSFROMID(id)  ((id - IDC_RASTERFONTS + 1) << FNT_FONTMASKBITS)
#define IDFROMFNTFLAGS(fl)  (IDC_RASTERFONTS - 1 + (((fl) & FNT_FONTMASK) >> FNT_FONTMASKBITS))

#if FNTFLAGSFROMID(IDC_RASTERFONTS) != FNT_RASTERFONTS || \
    IDFROMFNTFLAGS(FNT_RASTERFONTS) != IDC_RASTERFONTS || \
    FNTFLAGSFROMID(IDC_TTFONTS) != FNT_TTFONTS         || \
    IDFROMFNTFLAGS(FNT_TTFONTS) != IDC_TTFONTS         || \
    FNTFLAGSFROMID(IDC_BOTHFONTS) != FNT_BOTHFONTS   || \
    IDFROMFNTFLAGS(FNT_BOTHFONTS) != IDC_BOTHFONTS
#error Dialog control IDs and FNT flags values are not compatible
#endif


/*
 * IsDlgError
 *
 *      To simplify error checking, we assume that all *_ERR values are -1
 *      and all *_ERRSPACE values are -2.
 *
 *      This also assumes a two's complement number system.
 *
 *  Entry:
 *
 *      A return code from a list box or combo box.
 *
 *  Exit:
 *
 *      Nonzero if the return code indicated an error of some sort.
 *      Zero    if the return code indiated no error.
 *
 */

#define B_ERR (-1)

#if LB_ERR != B_ERR || LB_ERRSPACE != -2 || \
    CB_ERR != B_ERR || CB_ERRSPACE != -2
#error Problem with manifest constants.
#endif

#define IsDlgError(dw) ((DWORD)(dw) >= (DWORD)(-2))


/*
 *  Low-level macros
 *
 *  BPFDIFROMREF(lParam)
 *
 *  These three macros pack and unpack list box reference data.
 *
 *  bpfdi     = based pointer into segCache describing the list box entry
 *  fTrueType = nonzero if the font is a TrueType font
 *  lParam    = the reference data
 *
 */

#define BPFDIFROMREF(lParam)         (BPFDI)(lParam)


/*
 *  High-level macros
 *
 *  These macros handle the SendMessages that go to/from list boxes
 *  and combo boxes.
 *
 *  The "lcb" prefix stands for "list or combo box".
 *
 *  Basically, we're providing mnemonic names for what would otherwise
 *  look like a whole slew of confusing SendMessage's.
 *
 */






#define lcbFindStringExact(hwnd, fListBox, lpsz) \
        (DWORD)SendMessage(hwnd, fListBox ? LB_FINDSTRINGEXACT : CB_FINDSTRINGEXACT, \
                          (WPARAM)-1, (LPARAM)(LPTSTR)lpsz)

#define lcbAddString(hwnd, fListBox, lpsz) \
        (DWORD)SendMessage(hwnd, fListBox ? LB_ADDSTRING : CB_ADDSTRING, \
                          0, (LPARAM)(LPTSTR)lpsz)

#define lcbSetItemDataPair(hwnd, fListBox, w, bpfdi, fIsTrueType) \
        if (!IsSpecialBpfdi((BPFDI)bpfdi)) \
            ((BPFDI)bpfdi)->bTT = fIsTrueType; \
        (DWORD)SendMessage(hwnd, fListBox ? LB_SETITEMDATA : CB_SETITEMDATA, \
                    (WPARAM)w, (LPARAM)bpfdi)

#define lcbGetCount(hwnd, fListBox) \
        (DWORD)SendMessage(hwnd, fListBox ? LB_GETCOUNT : CB_GETCOUNT, (WPARAM)0, (LPARAM)0)

#define lcbGetCurSel(hwnd, fListBox) \
        (DWORD)SendMessage(hwnd, fListBox ? LB_GETCURSEL : CB_GETCURSEL, (WPARAM)0, (LPARAM)0)

#define lcbSetCurSel(hwnd, fListBox, w) \
        (DWORD)SendMessage(hwnd, fListBox ? LB_SETCURSEL : CB_SETCURSEL, (WPARAM)w, (LPARAM)0)

#define lcbGetItemDataPair(hwnd, fListBox, w) \
        (DWORD_PTR)SendMessage(hwnd, fListBox ? LB_GETITEMDATA : CB_GETITEMDATA, (WPARAM)w, (LPARAM)0)

#define lcbGetBpfdi(hwnd, fListBox, w) \
        BPFDIFROMREF(lcbGetItemDataPair(hwnd, fListBox, w))

#define lcbInsertString(hwnd, fListBox, lpsz, i) \
        (DWORD)SendMessage(hwnd, fListBox ? LB_INSERTSTRING : CB_INSERTSTRING, \
                           (WPARAM)i, (LPARAM)(LPTSTR)lpsz)

/*
 * the listbox/combox strings are stored as follows. we use the tabs
 * to do TabbedTextOut().  The padding is used to keep the sorting right.
 * TT fonts are distinguished by the hiword of the item data
 *
 *  String:     \t%2d\tx\t%2d
 *               wd    ht
 *
 *  The "Auto" entry is stored as...
 *
 *  String:     \1Auto
 *
 *      The first character is \1 so that Auto sorts at the top of the list.
 *      (The \1 is not actually displayed.)
 *
 */


/*
 * FONTDIMENINFO
 *
 * The distinction between the requested and returned font dimensions is
 * important in the case of TrueType fonts, in which there is no guarantee
 * that what you ask for is what you will get.
 *
 * Note that the correspondence between "Requested" and "Actual" is broken
 * whenever the user changes his display driver, because GDI uses driver
 * parameters to control the font rasterization.
 *
 * The fdiHeightReq and fdiWidthReq fields are both zero if the font is
 * a raster font.
 *
 */

typedef struct tagFONTDIMENINFO {       /* fdi */
    UINT fdiWidthReq;                   /* Font width requested */
    UINT fdiHeightReq;                  /* Font height requested */
    UINT fdiWidthActual;                /* Font width returned */
    UINT fdiHeightActual;               /* Font height returned */
    BOOL bTT;                           /* Font is TT? */
    INT  Index;                         /* Index into listbox */
} FONTDIMENINFO, *LPFONTDIMENINFO, *LPFDI;

typedef FONTDIMENINFO *BPFDI;
typedef UINT    CFDI;
typedef UINT    IFDI;

// BILINGUAL stuff
#define CLIP_DFA_OVERRIDE   0x40    /* Disable Font Association */

extern  CFDI    cfdiCache[];            /* # used entries in fdi cache */
extern  CFDI    cfdiCacheActual[];      /* Total # entries in fdi cache */


/*
 * BPFDI_CANCEL must be 0xFFFF because that is what DialogBox returns on
 * failure.
 */
#define BPFDI_CANCEL    (BPFDI)(INT_PTR)(-1)
#define BPFDI_AUTO      (BPFDI)(INT_PTR)(-2)
#define BPFDI_IGNORE    (BPFDI)(INT_PTR)(-3)

#define IsSpecialBpfdi(bpfdi)       ((bpfdi) >= BPFDI_IGNORE)

/* This is the maximum size font we will create. */
#define MAX_FONT_HEIGHT     72          /* 72pt = 1inch */

typedef INT PENALTY;                    /* pnl */

/*
 *  Penalty structures
 *
 *  Do NOT change these structure definitions unless you know what you're
 *  doing, because the relative order of the values is crucial for proper
 *  reading and writing of the INI file in which they are stored.
 */

typedef struct tagPENALTYPAIR {         /* pnlp */
    PENALTY pnlInitial;
    PENALTY pnlScale;
} PENALTYPAIR, *PPENALTYPAIR;


typedef struct tagPENALTYLIST {         /* pnll */
    PENALTYPAIR pnlpOvershoot;
    PENALTYPAIR pnlpShortfall;
} PENALTYLIST, *PPENALTYLIST;


#define MINPENALTY      (-5000)
#define MAXPENALTY        5000
#define SENTINELPENALTY  MAXLONG      /* Must exceed any legitimate penalty */

#define NUMPENALTIES        (SIZEOF(rgpnlPenalties) / SIZEOF(INT))
#define NUMINITIALTTHEIGHTS (SIZEOF(rgwInitialTtHeights) / SIZEOF(WORD))

#define pnllX           ((PPENALTYLIST)rgpnlPenalties)[0]
#define pnllY           ((PPENALTYLIST)rgpnlPenalties)[1]
#define pnlTrueType     (rgpnlPenalties[8])

/*
 *  These values for FindFontMatch's third argument are magical.
 *  WindowInit uses the funky values (with the exception of FFM_PERFECT)
 */
#define FFM_BOTHFONTS   0x00000000
#define FFM_RESTRICTED  0x00000001
#define FFM_RASTERFONTS 0x00000001
#define FFM_TTFONTS     0x80000001

#define FFM_PERFECT     0xFFFFFFFF


/*
 *  Last but not least, per-dialog data (aka roll-your-own DLL instance data)
 */

typedef struct FNTINFO {        /* fi */
    PPROPLINK ppl;              // ppl must ALWAYS be the first field
    BPFDI     bpfdi;
    PROPFNT   fntProposed;      // The properties to use if the user selects OK
    PROPWIN   winOriginal;      // For window preview and auto font selection
    HFONT     hFontPreview;     // Used in font preview window
    BOOL      fMax;             // Should window preview show as maximized?
    POINT     ptCorner;         // Upper-left corner of window
    UINT      uDefaultCp;       // System default code page
} FNTINFO;
typedef FNTINFO *PFNTINFO;      /* pfi */


/*
 * for Font Enumlation
 */
typedef struct FNTENUMINFO {
    HWND      hwndList;
    BOOL      fListBox;
    INT       CodePage;
} FNTENUMINFO;
typedef FNTENUMINFO *LPFNTENUMINFO;

/*
 *  Internal function prototypes
 */

BOOL_PTR CALLBACK DlgFntProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
VOID InitFntDlg(HWND hDlg, PFNTINFO pfi);
VOID ApplyFntDlg(HWND hDlg, PFNTINFO pfi);

BOOL LoadGlobalFontData(void);
BOOL LoadGlobalFontEditData(void);
VOID FreeGlobalFontEditData(void);
VOID CheckDisplayParameters(void);
HBITMAP LoadBitmaps(INT id);
DWORD GetFlippedSysColor(INT nDispElement);
VOID PreviewInit(HWND hDlg, PFNTINFO pfi);
VOID PreviewUpdate(HWND hwndList, PFNTINFO pfi);
LRESULT WndPreviewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
VOID WndPreviewPaint(HWND hDlg, HWND hwnd);
LRESULT FontPreviewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

INT  WINAPI CreateFontList(HWND hwndList, BOOL fListBox, LPPROPFNT lpFnt);
VOID WINAPI DrawItemFontList(BOOL fListBox, const LPDRAWITEMSTRUCT lpdis);
BOOL WINAPI MatchCurrentFont(HWND hwndList, BOOL fListBox, LPPROPFNT lpFnt);
LONG WINAPI MeasureItemFontList(LPMEASUREITEMSTRUCT lpmi);
VOID WINAPI UpdateTTBitmap(void);

BOOL AddRasterFontsToFontListA(HWND hwndList, BOOL fListBox,
                                                  LPCSTR lpszRasterFaceName, INT CodePage);
INT CALLBACK RasterFontEnum(ENUMLOGFONTA *lpelf,
                            NEWTEXTMETRICA *lpntm,
                            INT nFontType, LPARAM lParam);
BPFDI AddToFontListCache(HWND hwndList,
                         BOOL fListBox,
                         UINT uHeightReq,
                         UINT uWidthReq,
                         UINT uHeightActual,
                         UINT uWidthActual,
                         UINT uCodePage);
BOOL  AddTrueTypeFontsToFontListA(HWND hwndList, BOOL fListBox,
                                  LPSTR lpszTTFaceName, INT CodePage);
BPFDI AddOneNewTrueTypeFontToFontListA(HWND hwndList,
                                       BOOL fListBox,
                                       UINT uWidth, UINT uHeight,
                                       LPSTR lpszTTFaceName,
                                       INT CodePage);
DWORD_PTR GetFont(HWND hwndList, BOOL fListBox, PFNTINFO pfi);
void  SetFont(LPPROPFNT lpFnt, BPFDI bpfdi);

#define AspectScale(n1,n2,m) (UINT)(((UINT)n1*(UINT)m)/(UINT)n2)

VOID AspectPoint(LPRECT lprectPreview, LPPOINT lppt);
VOID AspectRect(LPRECT lprectPreview, LPRECT lprc);

HFONT CreateFontFromBpfdi(BPFDI bpfdi, PFNTINFO pfi);

void  FontSelInit(void);

BPFDI GetTrueTypeFontTrueDimensions(UINT dxWidth, UINT dyHeight, INT CodePage);
BPFDI FindFontMatch(UINT dxWidth, UINT dyHeight, LPINT lpfl, INT CodePage);
PENALTY ComputePenaltyFromPair(PPENALTYPAIR ppnlp, UINT dSmaller, UINT dLarger);
PENALTY ComputePenaltyFromList(PPENALTYLIST ppnll, UINT dActual, UINT dDesired);
PENALTY ComputePenalty(UINT cxCells,  UINT cyCells,
                       UINT dxClient, UINT dyClient,
                       UINT dxFont,   UINT dyFont);
BPFDI ChooseBestFont(UINT cxCells, UINT cyCells, UINT dxClient, UINT dyClient, INT fl, INT CodePage);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\pifinf.c ===
// Created 07-Jan-1993 11:20am by Jeff Parsons
 
#include "shellprv.h"
#pragma hdrstop
#include <setupapi.h>

#ifdef _X86_

const TCHAR szRegKeyMSDOSApps[] = REGSTR_PATH_NEWDOSBOX;

const TCHAR szParams[]          = KEY_PARAMS;
const TCHAR szBatchFile[]       = KEY_BATCHFILE;
const TCHAR szLowMem[]          = KEY_LOWMEM;
const TCHAR szEmsMem[]          = KEY_EMSMEM;
const TCHAR szXmsMem[]          = KEY_XMSMEM;
const TCHAR szDpmiMem[]         = KEY_DPMIMEM;
const TCHAR szEnable[]          = KEY_ENABLE;
const TCHAR szDisable[]         = KEY_DISABLE;

const TCHAR szWindowed[]        = KEYVAL_WINDOWED;
const TCHAR szBackground[]      = KEYVAL_BACKGROUND;
const TCHAR szExclusive[]       = KEYVAL_EXCLUSIVE;
const TCHAR szDetectIdle[]      = KEYVAL_DETECTIDLE;
const TCHAR szLowLocked[]       = KEYVAL_LOWLOCKED;
const TCHAR szEMSLocked[]       = KEYVAL_EMSLOCKED;
const TCHAR szXMSLocked[]       = KEYVAL_XMSLOCKED;
const TCHAR szUseHMA[]          = KEYVAL_USEHMA;
const TCHAR szEmulateROM[]      = KEYVAL_EMULATEROM;
const TCHAR szRetainVRAM[]      = KEYVAL_RETAINVRAM;
const TCHAR szFastPaste[]       = KEYVAL_FASTPASTE;
const TCHAR szALTTAB[]          = KEYVAL_ALTTAB;
const TCHAR szALTESC[]          = KEYVAL_ALTESC;
const TCHAR szCTRLESC[]         = KEYVAL_CTRLESC;
const TCHAR szPRTSCRN[]         = KEYVAL_PRTSCRN;
const TCHAR szALTPRTSCRN[]      = KEYVAL_ALTPRTSCRN;
const TCHAR szALTSPACE[]        = KEYVAL_ALTSPACE;
const TCHAR szALTENTER[]        = KEYVAL_ALTENTER;
const TCHAR szWinLie[]          = KEYVAL_WINLIE;
const TCHAR szGlobalMem[]       = KEYVAL_GLOBALMEM;
const TCHAR szRealMode[]        = KEYVAL_REALMODE;
const TCHAR szMouse[]           = KEYVAL_MOUSE;
const TCHAR szEMS[]             = KEYVAL_EMS;
const TCHAR szCDROM[]           = KEYVAL_CDROM;
const TCHAR szNetwork[]         = KEYVAL_NETWORK;
const TCHAR szDiskLock[]        = KEYVAL_DISKLOCK;
const TCHAR szPrivateCFG[]      = KEYVAL_PRIVATECFG;
const TCHAR szCloseOnExit[]     = KEYVAL_CLOSEONEXIT;
const TCHAR szAllowSSaver[]     = KEYVAL_ALLOWSSAVER;
const TCHAR szUniqueSettings[]  = KEYVAL_UNIQUESETTINGS;

const LPCTSTR apszKey[] = {
    szParams,
    szBatchFile,
    szLowMem,
    szEmsMem,
    szXmsMem,
    szDpmiMem,
    szEnable,
    szDisable,
};

const LPCTSTR apszKeyVal[] = {
    szWindowed,         // abKeyValIDBits[0]
    szBackground,       // abKeyValIDBits[1]
    szExclusive,        // abKeyValIDBits[2]
    szDetectIdle,       // abKeyValIDBits[3]
    szLowLocked,        // abKeyValIDBits[4]
    szEMSLocked,        // abKeyValIDBits[5]
    szXMSLocked,        // abKeyValIDBits[6]
    szUseHMA,           // abKeyValIDBits[7]
    szEmulateROM,       // abKeyValIDBits[8]
    szRetainVRAM,       // abKeyValIDBits[9]
    szFastPaste,        // abKeyValIDBits[10]
    szALTTAB,           // abKeyValIDBits[11]
    szALTESC,           // abKeyValIDBits[12]
    szCTRLESC,          // abKeyValIDBits[13]
    szPRTSCRN,          // abKeyValIDBits[14]
    szALTPRTSCRN,       // abKeyValIDBits[15]
    szALTSPACE,         // abKeyValIDBits[16]
    szALTENTER,         // abKeyValIDBits[17]
    szWinLie,           // abKeyValIDBits[18]
    szGlobalMem,        // abKeyValIDBits[19]
    szRealMode,         // abKeyValIDBits[20]
    szMouse,            // abRMKeyValIDBits[0]
    szEMS,              // abRMKeyValIDBits[1]
    szCDROM,            // abRMKeyValIDBits[2]
    szNetwork,          // abRMKeyValIDBits[3]
    szDiskLock,         // abRMKeyValIDBits[4]
    szPrivateCFG,       // abRMKeyValIDBits[5]
    szCloseOnExit,      // special case 0 (see "special case 0" below)
    szAllowSSaver,      // special case 1 (see "special case 1" below)
    szUniqueSettings,   // Never transferred to PIF - Used to populate registry
};

//  Array of bit numbers that must be kept in sync with KEYVALIDs
//
//  0x80 means bit must be inverted
//  0x40 means bit must be set in PfW386Flags2 instead of PfW386Flags

const BYTE abKeyValIDBits[] = {
    BITNUM(fFullScreen)     | 0x80,
    BITNUM(fBackground),
    BITNUM(fExclusive),
    BITNUM(fPollingDetect),
    BITNUM(fVMLocked),
    BITNUM(fEMSLocked),
    BITNUM(fXMSLocked),
    BITNUM(fNoHMA)          | 0x80,
    BITNUM(fVidTxtEmulate)  | 0x40,
    BITNUM(fVidRetainAllo)  | 0x40,
    BITNUM(fINT16Paste),
    BITNUM(fALTTABdis)      | 0x80,
    BITNUM(fALTESCdis)      | 0x80,
    BITNUM(fCTRLESCdis)     | 0x80,
    BITNUM(fPRTSCdis)       | 0x80,
    BITNUM(fALTPRTSCdis)    | 0x80,
    BITNUM(fALTSPACEdis)    | 0x80,
    BITNUM(fALTENTERdis)    | 0x80,
    BITNUM(fWinLie),
    BITNUM(fGlobalProtect),
    BITNUM(fRealMode),
};

const BYTE abRMKeyValIDBits[] = {
    BITNUM(RMOPT_MOUSE),
    BITNUM(RMOPT_EMS),
    BITNUM(RMOPT_CDROM),
    BITNUM(RMOPT_NETWORK),
    BITNUM(RMOPT_DISKLOCK),
    BITNUM(RMOPT_PRIVATECFG),
    BITNUM(RMOPT_VESA),
};
//  FEATURE: other bits to be supported (maybe):
//      WIN_TOOLBAR,
//      WIN_SAVESETTINGS,
//      MSE_WINDOWENABLE | 0x80,
//      MSE_EXCLUSIVE,
//      TSK_NOWARNTERMINATE | 0x80,


void InitWorkDir(PPROPLINK ppl, LPPROPPRG lpPrg, LPPROPNT40 lpnt40)
{
    int i;

    if (lpnt40)
    {
        lstrcpyn((LPTSTR)lpnt40->awchWorkDir,
                 ppl->szPathName,
                 min(ARRAYSIZE(lpnt40->awchWorkDir),ppl->iFileName+1));

        // Working directories like C:\ are ok, but C:\FOO\ are not,
        // so remove trailing '\' in that case

        i = lstrlen((LPTSTR)lpnt40->awchWorkDir)-1;
        if (i > 2 && lpnt40->awchWorkDir[i] == TEXT('\\'))
            lpnt40->awchWorkDir[i] = TEXT('\0');

        WideCharToMultiByte( CP_ACP, 0, (LPWSTR)lpnt40->awchWorkDir, -1, lpPrg->achWorkDir, ARRAYSIZE(lpPrg->achWorkDir), NULL, NULL );
    }
    else
    {
        WideCharToMultiByte( CP_ACP, 0,
                             ppl->szPathName,
                             min(ARRAYSIZE(lpPrg->achWorkDir),ppl->iFileName+1),
                             (LPSTR)lpPrg->achWorkDir,
                             ARRAYSIZE(lpPrg->achWorkDir),
                             NULL,
                             NULL
                            );

        // Working directories like C:\ are ok, but C:\FOO\ are not,
        // so remove trailing '\' in that case

        i = lstrlenA(lpPrg->achWorkDir)-1;
        if (i > 2 && lpPrg->achWorkDir[i] == '\\')
            lpPrg->achWorkDir[i] = '\0';
    }
}


BOOL FAR GetAppsInfData(PPROPLINK ppl, LPPROPPRG lpPrg, LPPROPNT40 lpnt40, HINF hInf, LPCTSTR lpszApp, BOOL fNotAmbiguous, int flOpt)
{
    HINF hinfApps;
    int id, i;
    TCHAR szTmp[MAX_PATH];
    TCHAR szPIFSection[MAX_KEY_SIZE];
    BOOL fSuccess = FALSE;
    INFCONTEXT InfContext;
    DWORD dwSize;
    FunctionName(GetAppsInfData);

    //
    // Although not strictly part of INF processing, it's most
    // convenient here to search for any ICO file that might exist
    // in the same directory as the app, and select it for our default icon.
    //
    lstrcpyn(szTmp, ppl->szPathName, ppl->iFileExt+1);
    lstrcpy(szTmp + ppl->iFileExt, TEXT(".ICO"));
    if ((int)GetFileAttributes(szTmp) != -1) {
        StringCchCopy((LPTSTR)lpnt40->awchIconFile, ARRAYSIZE(lpnt40->awchIconFile), szTmp);
        WideCharToMultiByte( CP_ACP, 0, (LPWSTR)lpnt40->awchIconFile, -1, lpPrg->achIconFile, ARRAYSIZE(lpPrg->achIconFile), NULL, NULL );
        lpPrg->wIconIndex = 0;
        PifMgr_SetProperties(ppl, MAKELP(0,GROUP_PRG),
                        lpPrg, SIZEOF(*lpPrg), SETPROPS_CACHE);
        PifMgr_SetProperties(ppl, MAKELP(0,GROUP_NT40),
                        lpnt40, SIZEOF(*lpnt40), SETPROPS_CACHE);
    }

    if (hInf)
        hinfApps = hInf;
    else
        hinfApps = SetupOpenInfFileW(LoadStringSafe(NULL,
                                                IDS_APPSINF,
                                                szTmp,
                                                ARRAYSIZE(szTmp)),
                                     0, INF_STYLE_WIN4, NULL );

    if (hinfApps==INVALID_HANDLE_VALUE) {
        id = IDS_CANTOPENAPPSINF;
        if (GetLastError()==ERROR_FILE_NOT_FOUND)
            id = IDS_NOAPPSINF;
        Warning((HWND)ppl, (WORD)id, MB_ICONEXCLAMATION | MB_OK | MB_NOFOCUS);
        goto CloseDLL;
    }

    // OK, now we have APPS.INF open, so let's bounce around the [pif95]
    // section and try to find the app of interest.

    if (!SetupFindFirstLine(hinfApps, TEXT("pif95"), NULL, &InfContext)) {
        Warning((HWND)ppl, IDS_APPSINFERROR, MB_ICONEXCLAMATION | MB_OK | MB_NOFOCUS);
        goto CloseInf;
    }

    // OK, we've found the [pif95] section, so let's go to it

    do {


        if (!SetupGetStringFieldW(&InfContext, APPSINF_FILENAME, szTmp, ARRAYSIZE(szTmp), &dwSize))
            continue;

        // We need to read the rest of the fields now, before we do any
        // more processing, because otherwise we lose our place in the file

        if (lstrcmpi(szTmp, ppl->szPathName+ppl->iFileName) == 0) {

            // See if Other File was specified, and then make sure it
            // exists.  If it doesn't, then we need to continue the search.

            // Initialize szTmp with only the path portion of the app's
            // fully-qualified name.  Giving lstrcpyn a length of iFileName+1
            // insures that szTmp[ppl->iFileName] will be NULL.

            lstrcpyn(szTmp, ppl->szPathName, ppl->iFileName+1);

            SetupGetStringFieldW(&InfContext, APPSINF_OTHERFILE,
                        &szTmp[ppl->iFileName], ARRAYSIZE(lpPrg->achOtherFile), &dwSize);

            // If szTmp[ppl->iFileName] is no longer NULL, then
            // GetStringField filled it in.  See if the file exists.

            if (szTmp[ppl->iFileName]) {
                if ((int)GetFileAttributes(szTmp) == -1)
                    continue;       // Other File didn't exist, continue search
            }

            // If the PIF data we have is ambiguous, and it has already
            // been initialized with data from this APPS.INF entry, then just
            // leave the PIF data alone and LEAVE.

            if (lpPrg->flPrgInit & PRGINIT_AMBIGUOUSPIF) {

                if (lstrcmpi((LPWSTR)lpnt40->awchOtherFile, szTmp+ppl->iFileName) == 0) {

                    if (!szTmp[ppl->iFileName]) {

                        // The comparison was inconclusive;  both filenames
                        // are blank.  See if the filename contained in
                        // lpPrg->achCmdLine matches lpszApp;  if not, again
                        // we should fail the search.
                        //
                        // It's ok to whack lpPrg->achCmdLine with a null;
                        // OpenProperties (our only caller) doesn't depend on
                        // that data in lpPrg.

                        lpnt40->awchCmdLine[lstrskipfnameA(lpPrg->achCmdLine)] = L'\0';

                        if (lstrcmpi((LPWSTR)lpnt40->awchCmdLine, lpszApp) != 0)


                            goto CloseInf;  // unsuccessful search
                    }
                    fSuccess++;             // successful search
                }

                // Otherwise, this APPS.INF entry isn't a match, implying
                // some of the PIF's settings don't really apply.  We need
                // to fail this search, get back to OpenProperties, look ONLY
                // for _DEFAULT.PIF, and let it try to call GetAppsInfData
                // one more time.

                goto CloseInf;
            }

            // Otherwise, update Other File.  THIS is the APPS.INF entry
            // we're going to use!

            StringCchCopy((LPWSTR)lpnt40->awchOtherFile, ARRAYSIZE(lpnt40->awchOtherFile), szTmp + ppl->iFileName);
            WideCharToMultiByte( CP_ACP, 0, (LPWSTR)lpnt40->awchOtherFile, -1, lpPrg->achOtherFile, ARRAYSIZE( lpPrg->achOtherFile ), NULL, NULL );

            SetupGetStringFieldW(&InfContext, APPSINF_TITLE, (LPWSTR)lpnt40->awchTitle, ARRAYSIZE(lpnt40->awchTitle), &dwSize);
            WideCharToMultiByte( CP_ACP, 0, (LPWSTR)lpnt40->awchTitle, -1, lpPrg->achTitle, ARRAYSIZE( lpPrg->achTitle ), NULL, NULL );

            StringCchCopy((LPWSTR)lpnt40->awchCmdLine, ARRAYSIZE(lpnt40->awchCmdLine), lpszApp);
            WideCharToMultiByte( CP_ACP, 0, (LPWSTR)lpnt40->awchCmdLine, -1, lpPrg->achCmdLine, ARRAYSIZE( lpPrg->achCmdLine ), NULL, NULL );

            i = 0;
            SetupGetIntField(&InfContext, APPSINF_NOWORKDIR, &i);

            // Only set the working directory if "NoWorkDir" in the INF
            // is FALSE and no working directory was supplied by the caller.

            if (i == 0 && !lpnt40->awchWorkDir[0]) {
                // No hard-coded working directory, so let's provide one

                InitWorkDir(ppl, lpPrg, lpnt40);
            }

            szTmp[0] = 0;
            SetupGetStringFieldW(&InfContext, APPSINF_ICONFILE, szTmp, ARRAYSIZE(szTmp), &dwSize);

            if (!szTmp[0])
                StringCchCopy(szTmp, ARRAYSIZE(szTmp), TEXT("SHELL32.DLL"));

            i = 0;
            SetupGetIntField(&InfContext, APPSINF_ICONINDEX, &i);

            // Update the icon info now, if it's valid

            if (i != 0) {
                StringCchCopy((LPWSTR)lpnt40->awchIconFile, ARRAYSIZE(lpnt40->awchIconFile), szTmp);
                WideCharToMultiByte( CP_ACP, 0, (LPWSTR)lpnt40->awchIconFile, -1, lpPrg->achIconFile, ARRAYSIZE( lpPrg->achIconFile ), NULL, NULL );
                lpPrg->wIconIndex = (WORD) i;
            }

            SetupGetStringFieldW(&InfContext, APPSINF_SECTIONID,
                        szPIFSection, ARRAYSIZE(szPIFSection), &dwSize);

            szTmp[0] = TEXT('\0');
            SetupGetStringFieldW(&InfContext, APPSINF_NOPIF,
                        szTmp, ARRAYSIZE(szTmp), &dwSize);

            // This code used to set INHBITPIF if the app was NOT on a
            // fixed disk, knowing that we would otherwise try to create
            // a PIF in the PIF directory instead of the app's directory;
            // in other words, NOPIF really meant "no PIF in the PIF
            // directory please, because this app is ambiguously named".

            // Now, we want to always allow PIF creation, so the user
            // always has a place to save properties for an app.  But we
            // also need to propagate the old NOPIF flag to AMBIGUOUSPIF,
            // so that we'll always check to see if the PIF should be
            // regenerated (based on the presence of a NEW Other File).

            lpPrg->flPrgInit &= ~PRGINIT_AMBIGUOUSPIF;
            if (!fNotAmbiguous && szTmp[0] == TEXT('1'))
                lpPrg->flPrgInit |= PRGINIT_AMBIGUOUSPIF;

            if (flOpt & OPENPROPS_FORCEREALMODE)
                lpPrg->flPrgInit |= PRGINIT_REALMODE;

            // Time to dirty those properties!

            PifMgr_SetProperties(ppl, MAKELP(0,GROUP_PRG),
                            lpPrg, SIZEOF(*lpPrg), SETPROPS_CACHE);
            PifMgr_SetProperties(ppl, MAKELP(0,GROUP_NT40),
                            lpnt40, SIZEOF(*lpnt40), SETPROPS_CACHE);

            GetAppsInfSectionData(&InfContext, APPSINF_DEFAULT_SECTION, ppl);

            if (*szPIFSection)
                GetAppsInfSectionData(&InfContext, szPIFSection, ppl);

            // Make a note that we found INF settings (appwiz cares)

            ppl->flProp |= PROP_INFSETTINGS;

            // GetAppsInfSectionData affects program props, so get fresh copy

            PifMgr_GetProperties(ppl, MAKELP(0,GROUP_PRG),
                            lpPrg, SIZEOF(*lpPrg), GETPROPS_NONE);

            // Now call appwiz in "silent configuration mode", to create the
            // per-app config and autoexec images, if app runs in real mode;
            // BUT don't do this if the caller (NOT the INF) specified no PIF,
            // to avoid unwanted dialog boxes popping up from appwiz.  Yes, I'm
            // telling appwiz to be quiet, but sometimes he just can't contain
            // himself (ie, silent configuration may not be possible given the
            // the real-mode configuration required).

            if (!(ppl->flProp & PROP_INHIBITPIF)) {
                if (lpPrg->flPrgInit & PRGINIT_REALMODE)
                    AppWizard(NULL, ppl, WIZACTION_SILENTCONFIGPROP);
            }
            FlushPIFData(ppl, FALSE);

            fSuccess++;             // successful search
            goto CloseInf;
        }

    } while (SetupFindNextLine(&InfContext, &InfContext));

  CloseInf:
    if (!hInf)
        SetupCloseInfFile(hinfApps);

  CloseDLL:
    return fSuccess;
}


void GetAppsInfSectionData(PINFCONTEXT pInfContext, LPCTSTR lpszSection, PPROPLINK ppl)
{
    int i, j, idKey;
    LPSTDPIF lpstd;
    LPW386PIF30 lp386;
    LPWENHPIF40 lpenh;
    TCHAR szVal[MAX_KEYVAL_SIZE];
    TCHAR szVal2[MAX_KEYVAL_SIZE];
    FunctionName(GetAppsInfSectionData);

    if (!SetupFindFirstLineW(pInfContext, lpszSection, NULL, NULL))
        return;

    ppl->cLocks++;

    lpstd = (LPSTDPIF)ppl->lpPIFData;

    // lp386 may or may not exist, but we'll create if not

    lp386 = GetGroupData(ppl, szW386HDRSIG30, NULL, NULL);
    if (!lp386) {
        if (AddGroupData(ppl, szW386HDRSIG30, NULL, SIZEOF(W386PIF30))) {
            lp386 = GetGroupData(ppl, szW386HDRSIG30, NULL, NULL);
            if (!lp386)
                goto UnlockPIF;
        }
    }

    // lpenh may or may not exist, but we'll create if not

    lpenh = GetGroupData(ppl, szWENHHDRSIG40, NULL, NULL);
    if (!lpenh) {
        if (AddGroupData(ppl, szWENHHDRSIG40, NULL, SIZEOF(WENHPIF40))) {
            lpenh = GetGroupData(ppl, szWENHHDRSIG40, NULL, NULL);
            if (!lpenh)
                goto UnlockPIF;
        }
    }

    do {
        BYTE bInvert;
        DWORD dwSize;

        idKey = GetKeyID(pInfContext);

        if (!SetupGetStringFieldW(pInfContext, APPSINF_KEYVAL, szVal, ARRAYSIZE(szVal), &dwSize))
            continue;

        szVal2[0] = TEXT('\0');
        if (idKey >= KEYID_LOWMEM && idKey <= KEYID_DPMIMEM)
            SetupGetStringFieldW(pInfContext, APPSINF_KEYVAL2, szVal2, ARRAYSIZE(szVal2), &dwSize);

        bInvert = 0;

        switch (idKey)
        {
        case KEYID_UNKNOWN:
            ASSERTFAIL();
            break;

        case KEYID_NONE:
            break;

        case KEYID_PARAMS:
            {
            WCHAR szTmp[ ARRAYSIZE(lp386->PfW386params) ];

            MultiByteToWideChar( CP_ACP, 0, (LPSTR)lp386->PfW386params, -1, szTmp, ARRAYSIZE(szTmp) );
            SetupGetStringFieldW(pInfContext, APPSINF_KEYVAL, szTmp, SIZEOF(lp386->PfW386params), &dwSize);
            }

            break;

        case KEYID_BATCHFILE:
            break;

        case KEYID_LOWMEM:
            if (!lstrcmpi(szVal, g_szAuto))
                lp386->PfW386minmem = 0xFFFF;
            else
                lp386->PfW386minmem = (WORD) StrToInt(szVal);

            if (!szVal2[0])
                lp386->PfW386maxmem = 0xFFFF;
            else
                lp386->PfW386maxmem = (WORD) StrToInt(szVal2);
            break;

        case KEYID_EMSMEM:
            if (!lstrcmpi(szVal, g_szNone)) {
                lp386->PfMaxEMMK = lp386->PfMinEMMK = 0;
            }
            if (!lstrcmpi(szVal, g_szAuto)) {
                lp386->PfMinEMMK = 0;
                lp386->PfMaxEMMK = 0xFFFF;
            }
            else
                lp386->PfMaxEMMK = lp386->PfMinEMMK = (WORD) StrToInt(szVal);

            if (szVal2[0])
                lp386->PfMaxEMMK = (WORD) StrToInt(szVal2);
            break;

        case KEYID_XMSMEM:
            if (!lstrcmpi(szVal, g_szNone)) {
                lp386->PfMaxXmsK = lp386->PfMinXmsK = 0;
            }
            if (!lstrcmpi(szVal, g_szAuto)) {
                lp386->PfMinXmsK = 0;
                lp386->PfMaxXmsK = 0xFFFF;
            }
            else
                lp386->PfMaxXmsK = lp386->PfMinXmsK = (WORD) StrToInt(szVal);

            if (szVal2[0])
                lp386->PfMaxXmsK = (WORD) StrToInt(szVal2);
            break;

        case KEYID_DPMIMEM:
            if (!lstrcmpi(szVal, g_szAuto))
                lpenh->envProp.wMaxDPMI = 0;
            else
                lpenh->envProp.wMaxDPMI = (WORD) StrToInt(szVal);
            break;

        case KEYID_DISABLE:
            bInvert = 0x80;
            // fall into KEYID_ENABLE...

        case KEYID_ENABLE:
            for (i=1; 0 != (j = GetKeyValID(pInfContext, i)); i++)
            {
                int s;
                BYTE b;

                if (j == KEYVAL_ID_UNKNOWN) {
                    ASSERTFAIL();
                    continue;
                }

                if (j == KEYVAL_ID_UNIQUESETTINGS) {
                    continue;
                }

                j--;

                if (j < ARRAYSIZE(abKeyValIDBits)) {

                    b = abKeyValIDBits[j];

                    s = b & 0x3F;
                    b ^= bInvert;
                    if (!(b & 0x80)) {
                        if (!(b & 0x40)) {
                            lp386->PfW386Flags |= 1L << s;
                        }
                        else
                            lp386->PfW386Flags2 |= 1L << s;
                    }
                    else {
                        if (!(b & 0x40))
                            lp386->PfW386Flags &= ~(1L << s);
                        else
                            lp386->PfW386Flags2 &= ~(1L << s);
                    }
                }
                else {
                    j -= ARRAYSIZE(abKeyValIDBits);

                    if (j < ARRAYSIZE(abRMKeyValIDBits)) {

                        b = abRMKeyValIDBits[j];

                        s = b & 0x3F;
                        b ^= bInvert;

                        if (!(b & 0x80))
                            lpenh->dwRealModeFlagsProp |= 1L << s;
                        else
                            lpenh->dwRealModeFlagsProp &= ~(1L << s);
                    }
                    else {
                        j -= ARRAYSIZE(abRMKeyValIDBits);

                        switch(j) {
                        case 0:         // special case 0
                            if (!bInvert)
                                lpstd->MSflags |= EXITMASK;
                            else
                                lpstd->MSflags &= ~EXITMASK;
                            break;

                        case 1:         // special case 1
                            if (bInvert)
                                lpenh->tskProp.flTsk |= TSK_NOSCREENSAVER;
                            else
                                lpenh->tskProp.flTsk &= ~TSK_NOSCREENSAVER;
                            break;

                        default:
                            ASSERTFAIL();
                            break;
                        }
                    }
                }
            }
            break;
        }
    } while (SetupFindNextLine(pInfContext, pInfContext));

  UnlockPIF:
    ppl->cLocks--;

}


int GetKeyID(PINFCONTEXT pInfContext)
{
    int i;
    TCHAR szCurKey[MAX_KEY_SIZE];
    DWORD dwSize;
    FunctionName(GetKeyID);

    if (SetupGetStringFieldW(pInfContext, APPSINF_KEY, szCurKey, ARRAYSIZE(szCurKey), &dwSize)) {
        for (i=0; i<ARRAYSIZE(apszKey); i++) {
            if (!lstrcmpi(szCurKey, apszKey[i]))
                return i+1;
        }
        return KEYID_UNKNOWN;
    }
    return KEYID_NONE;
}


int GetKeyValID(PINFCONTEXT pInfContext, int i)
{
    TCHAR szCurKeyVal[MAX_KEYVAL_SIZE];
    DWORD dwSize;
    FunctionName(GetKeyValID);

    if (SetupGetStringFieldW(pInfContext, i, szCurKeyVal, ARRAYSIZE(szCurKeyVal), &dwSize)) {
        for (i=0; i<ARRAYSIZE(apszKeyVal); i++) {
            if (!lstrcmpi(szCurKeyVal, apszKeyVal[i]))
                return i+1;
        }
        return KEYVAL_ID_UNKNOWN;
    }
    return KEYVAL_ID_NONE;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\pifmsc.c ===
// Created 04-Jan-1993 1:10pm by Jeff Parsons

#include "shellprv.h"
#pragma hdrstop

#ifdef _X86_

#define VMD_DEVICE_ID           0x0000C


BINF abinfTsk[] = {
    {IDC_FGNDSCRNSAVER, BITNUM(TSK_NOSCREENSAVER)  | 0x80},
    {IDC_BGNDSUSPEND,   BITNUM(TSK_BACKGROUND)     | 0x80},
    {IDC_WARNTERMINATE, BITNUM(TSK_NOWARNTERMINATE)| 0x80},
};

BINF abinfKbd[] = {
    {IDC_ALTESC,        BITNUM(KBD_NOALTESC)    | 0x80},
    {IDC_ALTTAB,        BITNUM(KBD_NOALTTAB)    | 0x80},
    {IDC_CTRLESC,       BITNUM(KBD_NOCTRLESC)   | 0x80},
    {IDC_PRTSC,         BITNUM(KBD_NOPRTSC)     | 0x80},
    {IDC_ALTPRTSC,      BITNUM(KBD_NOALTPRTSC)  | 0x80},
    {IDC_ALTSPACE,      BITNUM(KBD_NOALTSPACE)  | 0x80},
    {IDC_ALTENTER,      BITNUM(KBD_NOALTENTER)  | 0x80},
    {IDC_FASTPASTE,     BITNUM(KBD_FASTPASTE)         },
};

BINF abinfMse[] = {
    {IDC_QUICKEDIT,     BITNUM(MSE_WINDOWENABLE)| 0x80},
    {IDC_EXCLMOUSE,     BITNUM(MSE_EXCLUSIVE)         },    // WARNING -- Assumed to be abinfMse[1] below
};

// Private function prototypes

BOOL GetSetMscProps(HWND hDlg, GETSETFN lpfn, PPROPLINK ppl, LPPROPTSK lptsk, LPPROPKBD lpkbd, LPPROPMSE lpmse, LPPROPENV lpenv, int idError);
void InitMscDlg(HWND hDlg, PPROPLINK ppl);
void ApplyMscDlg(HWND hDlg, PPROPLINK ppl);


// Context-sensitive help ids

const static DWORD rgdwHelp[] = {
    IDC_FGNDGRP,         IDH_COMM_GROUPBOX,
    IDC_FGNDSCRNSAVER,   IDH_DOS_TASKING_ALLOW_SCREENSAVER,
    IDC_BGNDGRP,         IDH_COMM_GROUPBOX,
    IDC_BGNDSUSPEND,     IDH_DOS_TASKING_SUSPEND,
    IDC_IDLEGRP,         IDH_COMM_GROUPBOX,
    IDC_IDLELOWLBL,      IDH_DOS_TASKING_IDLE_SLIDER,
    IDC_IDLEHIGHLBL,     IDH_DOS_TASKING_IDLE_SLIDER,
    IDC_IDLESENSE,       IDH_DOS_TASKING_IDLE_SLIDER,
    IDC_TERMGRP,         IDH_COMM_GROUPBOX,
    IDC_WARNTERMINATE,   IDH_DOS_WINDOWS_WARN,
    IDC_MISCMOUSEGRP,    IDH_COMM_GROUPBOX,
    IDC_QUICKEDIT,       IDH_DOS_WINDOWS_MOUSE_QUICKEDIT,
    IDC_EXCLMOUSE,       IDH_DOS_WINDOWS_MOUSE_EXCLUSIVE,
    IDC_ALTESC,          IDH_DOS_KEYBOARD_SHORTCUTS,
    IDC_MISCKBDGRP,      IDH_COMM_GROUPBOX,
    IDC_ALTTAB,          IDH_DOS_KEYBOARD_SHORTCUTS,
    IDC_CTRLESC,         IDH_DOS_KEYBOARD_SHORTCUTS,
    IDC_PRTSC,           IDH_DOS_KEYBOARD_SHORTCUTS,
    IDC_ALTPRTSC,        IDH_DOS_KEYBOARD_SHORTCUTS,
    IDC_ALTSPACE,        IDH_DOS_KEYBOARD_SHORTCUTS,
    IDC_ALTENTER,        IDH_DOS_KEYBOARD_SHORTCUTS,
    IDC_MISCOTHERGRP,    IDH_COMM_GROUPBOX,
    IDC_FASTPASTE,       IDH_DOS_KEYBOARD_FASTPASTE,
    IDC_TOOLBAR,         IDH_DOS_WINDOWS_TOOLBAR,
    IDC_WINRESTORE,      IDH_DOS_WINDOWS_RESTORE,
    IDC_REALMODEDISABLE, IDH_DOS_REALMODEPROPS,
    0, 0
};


BOOL_PTR CALLBACK DlgMscProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PPROPLINK ppl;
    FunctionName(DlgMscProc);

    ppl = (PPROPLINK)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) {
    case WM_INITDIALOG:
        lParam = ((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        ppl = (PPROPLINK)lParam;
        InitMscDlg(hDlg, ppl);
        break;

    HELP_CASES(rgdwHelp)                // Handle help messages

    case WM_HSCROLL:                    // assumed to be notifications
                                        // from our one and only trackbar
        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
        break;

    case WM_COMMAND:
        if (LOWORD(lParam) == 0)
            break;                      // message not from a control

        switch (LOWORD(wParam)) {

        case IDC_FGNDSCRNSAVER:
        case IDC_BGNDSUSPEND:
        case IDC_QUICKEDIT:
        case IDC_EXCLMOUSE:
        case IDC_WARNTERMINATE:
        case IDC_FASTPASTE:
        case IDC_INSTRUCTIONS:
        case IDC_ALTTAB:
        case IDC_CTRLESC:
        case IDC_ALTPRTSC:
        case IDC_ALTESC:
        case IDC_PRTSC:
        case IDC_ALTENTER:
        case IDC_ALTSPACE:
            if (HIWORD(wParam) == BN_CLICKED)
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) {

        case PSN_KILLACTIVE:
            // This gives the current page a chance to validate itself
            // SetWindowLong(hDlg, DWL_MSGRESULT, 0);
            break;

        case PSN_APPLY:
            // This happens on OK....
            ApplyMscDlg(hDlg, ppl);
            break;

        case PSN_RESET:
            // This happens on Cancel....
            break;
        }
        break;

    case WM_WININICHANGE:
    case WM_SYSCOLORCHANGE:
    case WM_DISPLAYCHANGE:
        RelayMessageToChildren(hDlg, uMsg, wParam, lParam);
        break;

    default:
        return FALSE;                   // return 0 when not processing
    }
    return TRUE;
}


BOOL GetSetMscProps(HWND hDlg, GETSETFN lpfn, PPROPLINK ppl, LPPROPTSK lptsk, LPPROPKBD lpkbd, LPPROPMSE lpmse, LPPROPENV lpenv, int idError)
{
    if (!(*lpfn)(ppl, MAKELP(0,GROUP_TSK),
                        lptsk, sizeof(*lptsk), GETPROPS_NONE) ||
        !(*lpfn)(ppl, MAKELP(0,GROUP_KBD),
                        lpkbd, sizeof(*lpkbd), GETPROPS_NONE) ||
        !(*lpfn)(ppl, MAKELP(0,GROUP_MSE),
                        lpmse, sizeof(*lpmse), GETPROPS_NONE) ||
        !(*lpfn)(ppl, MAKELP(0,GROUP_ENV),
                        lpenv, sizeof(*lpenv), GETPROPS_NONE)) {
        Warning(hDlg, (WORD)idError, (WORD)(MB_ICONEXCLAMATION | MB_OK));
        return FALSE;
    }
    return TRUE;
}


void InitMscDlg(HWND hDlg, PPROPLINK ppl)
{
    PROPTSK tsk;
    PROPKBD kbd;
    PROPMSE mse;
    PROPENV env;
    FunctionName(InitMscDlg);

    if (!GetSetMscProps(hDlg, PifMgr_GetProperties, ppl, &tsk, &kbd, &mse, &env, IDS_QUERY_ERROR))
        return;

    SetDlgItemPct(hDlg, IDC_IDLESENSE, tsk.wIdleSensitivity);
    SetDlgBits(hDlg, &abinfTsk[0], ARRAYSIZE(abinfTsk), tsk.flTsk);
    SetDlgBits(hDlg, &abinfKbd[0], ARRAYSIZE(abinfKbd), kbd.flKbd);
    SetDlgBits(hDlg, &abinfMse[0], ARRAYSIZE(abinfMse), mse.flMse);
}


void ApplyMscDlg(HWND hDlg, PPROPLINK ppl)
{
    PROPTSK tsk;
    PROPKBD kbd;
    PROPMSE mse;
    PROPENV env;
    FunctionName(ApplyMscDlg);

    if (!GetSetMscProps(hDlg, PifMgr_GetProperties, ppl, &tsk, &kbd, &mse, &env, IDS_UPDATE_ERROR))
        return;

    GetDlgBits(hDlg, &abinfTsk[0], ARRAYSIZE(abinfTsk), &tsk.flTsk);
    tsk.wIdleSensitivity = (WORD) GetDlgItemPct(hDlg, IDC_IDLESENSE);
    GetDlgBits(hDlg, &abinfKbd[0], ARRAYSIZE(abinfKbd), &kbd.flKbd);
    GetDlgBits(hDlg, &abinfMse[0], ARRAYSIZE(abinfMse), &mse.flMse);

    if (GetSetMscProps(hDlg, PifMgr_SetProperties, ppl, &tsk, &kbd, &mse, &env, IDS_UPDATE_ERROR)) {
        if (ppl->hwndNotify) {
            ppl->flProp |= PROP_NOTIFY;
            PostMessage(ppl->hwndNotify, ppl->uMsgNotify, sizeof(mse), (LPARAM)MAKELP(0,GROUP_MSE));
        }
    }
}


BOOL IsBufferDifferent( LPVOID lpBuff1, LPVOID lpBuff2, UINT cb )
{
    BYTE bRet = 0;
    LPBYTE lpByte1 = (LPBYTE)lpBuff1;
    LPBYTE lpByte2 = (LPBYTE)lpBuff2;

    ASSERT(cb>0);

    while ((cb!=0) && (bRet==0))
    {
        bRet = *lpByte1 - *lpByte2;

        cb--;
        lpByte1++;
        lpByte2++;

    }

    return (DWORD)bRet;
}

#endif // X86
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\pifmem.c ===
// Created 04-Jan-1993 1:10pm by Jeff Parsons

#include "shellprv.h"
#pragma hdrstop

#ifdef _X86_

BINF abinfMem[] = {
    {IDC_HMA,           BITNUM(MEMINIT_NOHMA)   | 0x80},
    {IDC_GLOBALPROTECT, BITNUM(MEMINIT_GLOBALPROTECT) },
};

VINF avinfMem[] = {
    {FIELD_OFFSET(PROPMEM,wMinLow), VINF_AUTOMINMAX, IDC_LOWMEM, MEMLOW_MIN, MEMLOW_MAX, IDS_BAD_MEMLOW},
    {FIELD_OFFSET(PROPMEM,wMinEMS), VINF_AUTOMINMAX, IDC_EMSMEM, MEMEMS_MIN, MEMEMS_MAX, IDS_BAD_MEMEMS},
    {FIELD_OFFSET(PROPMEM,wMinXMS), VINF_AUTOMINMAX, IDC_XMSMEM, MEMXMS_MIN, MEMXMS_MAX, IDS_BAD_MEMXMS},
};

VINF avinfEnvMem[] = {
    {FIELD_OFFSET(PROPENV,cbEnvironment), VINF_AUTO, IDC_ENVMEM, ENVSIZE_MIN, ENVSIZE_MAX, IDS_BAD_ENVIRONMENT},
    {FIELD_OFFSET(PROPENV,wMaxDPMI), VINF_AUTO, IDC_DPMIMEM, ENVDPMI_MIN, ENVDPMI_MAX, IDS_BAD_MEMDPMI},
};

// Per-dialog data

#define MEMINFO_RELAUNCH        0x0001          // relaunch required to take effect

#define EMS_NOEMS               0x0001          // EMS no supported in protmode
#define EMS_EMM386              0x0002          // EM386 is installed
#define EMS_QEMM                0x0004          // Third-party mmgr installed
#define EMS_RMPAGEFRAME         0x0008          // Page frame present in real mode
#define EMS_SYSINIDISABLE       0x0010          // EMS forced off by system.ini

typedef struct MEMINFO {        /* mi */
    PPROPLINK ppl;                              // pointer to property info
    DWORD     flMemInfo;                        // initially zero thx to LocalAlloc(LPTR)
    DWORD     flEms;                            // EMS support flags
} MEMINFO;
typedef MEMINFO *PMEMINFO;      /* pmi */


// Private function prototypes

BOOL GetSetMemProps(HWND hDlg, GETSETFN lpfn, PPROPLINK ppl, LPPROPMEM lpmem, LPPROPENV lpenv, int idError);
void InitMemDlg(HWND hDlg, PMEMINFO pmi);
void ApplyMemDlg(HWND hDlg, PMEMINFO pmi);
void AdjustEmsControls(HWND hDlg, PMEMINFO pmi);
void ExplainNoEms(HWND hDlg, PMEMINFO pmi);

// Context-sensitive help ids

const static DWORD rgdwHelp[] = {
        IDC_CONVMEMLBL,      IDH_DOS_MEMORY_CONV,
        IDC_LOWMEM,          IDH_DOS_MEMORY_CONV,
        IDC_GLOBALPROTECT,   IDH_DOS_MEMORY_CONV_GLOBAL,
        IDC_EXPMEMGRP,       IDH_COMM_GROUPBOX,
        IDC_EXPMEMLBL,       IDH_DOS_MEMORY_EXP,
        IDC_EMSMEM,          IDH_DOS_MEMORY_EXP,
        IDC_EXTMEMGRP,       IDH_COMM_GROUPBOX,
        IDC_XMSMEM,          IDH_DOS_MEMORY_EXT,
        IDC_EXTMEMLBL,       IDH_DOS_MEMORY_EXT,
        IDC_DPMIMEMGRP,      IDH_COMM_GROUPBOX,
        IDC_DPMIMEM,         IDH_DOS_MEMORY_DPMI,
        IDC_DPMIMEMLBL,      IDH_DOS_MEMORY_DPMI,
        IDC_HMA,             IDH_DOS_MEMORY_EXT_HMA,
        IDC_CONVMEMGRP,      IDH_COMM_GROUPBOX,
        IDC_LOCALENVLBL,     IDH_DOS_PROGRAM_ENVIRSZ,
        IDC_ENVMEM,          IDH_DOS_PROGRAM_ENVIRSZ,
        IDC_REALMODEDISABLE, IDH_DOS_REALMODEPROPS,
        IDC_NOEMSDETAILS,    IDH_DOS_MEMORY_NOEMS_DETAILS,
        0, 0
};


BOOL_PTR CALLBACK DlgMemProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fError;
    PMEMINFO pmi;
    FunctionName(DlgMemProc);

    pmi = (PMEMINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) {
    case WM_INITDIALOG:
        // allocate dialog instance data
        if (NULL != (pmi = (PMEMINFO)LocalAlloc(LPTR, SIZEOF(MEMINFO)))) {
            pmi->ppl = (PPROPLINK)((LPPROPSHEETPAGE)lParam)->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pmi);
            InitMemDlg(hDlg, pmi);
        } else {
            EndDialog(hDlg, FALSE);     // fail the dialog create
        }
        break;

    case WM_DESTROY:
        // free the pmi
        if (pmi) {
            EVAL(LocalFree(pmi) == NULL);
            SetWindowLongPtr(hDlg, DWLP_USER, 0);
        }
        break;

    HELP_CASES(rgdwHelp)                // Handle help messages

    case WM_COMMAND:
        if (LOWORD(lParam) == 0)
            break;                      // message not from a control

        switch (LOWORD(wParam)) {

        case IDC_ENVMEM:
        case IDC_LOWMEM:
        case IDC_EMSMEM:
        case IDC_XMSMEM:
        case IDC_DPMIMEM:
            if (HIWORD(wParam) == CBN_SELCHANGE ||
                HIWORD(wParam) == CBN_EDITCHANGE) {
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                pmi->flMemInfo |= MEMINFO_RELAUNCH;
            }
            break;

        case IDC_HMA:
        case IDC_GLOBALPROTECT:
            if (HIWORD(wParam) == BN_CLICKED) {
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                if (LOWORD(wParam) != IDC_GLOBALPROTECT)
                    pmi->flMemInfo |= MEMINFO_RELAUNCH;
            }
            break;

        case IDC_NOEMSDETAILS:
            if (HIWORD(wParam) == BN_CLICKED) {
                ExplainNoEms(hDlg, pmi);
            }
            return FALSE;               // return 0 if we process WM_COMMAND

        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) {
        case PSN_SETACTIVE:
            AdjustRealModeControls(pmi->ppl, hDlg);
            AdjustEmsControls(hDlg, pmi);
                                        // make sure DWL_MSGRESULT is zero,
                                        // otherwise the prsht code thinks we
                                        // "failed" this notify and switches
                                        // to another (sometimes random) page -JTP
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 0);
            break;

        case PSN_KILLACTIVE:
            // This gives the current page a chance to validate itself
            fError = ValidateDlgInts(hDlg, avinfMem, ARRAYSIZE(avinfMem));
            fError |= ValidateDlgInts(hDlg, avinfEnvMem, ARRAYSIZE(avinfEnvMem));
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, fError);
            break;

        case PSN_APPLY:
            // This happens on OK....
            ApplyMemDlg(hDlg, pmi);
            break;

        case PSN_RESET:
            // This happens on Cancel....
            break;
        }
        break;

    default:
        return FALSE;                   // return 0 when not processing
    }
    return TRUE;
}


BOOL GetSetMemProps(HWND hDlg, GETSETFN lpfn, PPROPLINK ppl, LPPROPMEM lpmem, LPPROPENV lpenv, int idError)
{
    if (!(*lpfn)(ppl, MAKELP(0,GROUP_MEM),
                        lpmem, SIZEOF(*lpmem), GETPROPS_NONE) ||
        !(*lpfn)(ppl, MAKELP(0,GROUP_ENV),
                        lpenv, SIZEOF(*lpenv), GETPROPS_NONE)) {
        Warning(hDlg, (WORD)idError, (WORD)MB_ICONEXCLAMATION | MB_OK);
        return FALSE;
    }
    return TRUE;
}


void InitMemDlg(HWND hDlg, PMEMINFO pmi)
{
    PROPMEM mem;
    PROPENV env;
    PPROPLINK ppl = pmi->ppl;
    FunctionName(InitMemDlg);

    if (!GetSetMemProps(hDlg, PifMgr_GetProperties, ppl, &mem, &env, IDS_QUERY_ERROR))
        return;

    SetDlgBits(hDlg, abinfMem, ARRAYSIZE(abinfMem), mem.flMemInit);
    SetDlgInts(hDlg, avinfMem, ARRAYSIZE(avinfMem), (LPVOID)&mem);
    SetDlgInts(hDlg, avinfEnvMem, ARRAYSIZE(avinfEnvMem), (LPVOID)&env);

    /* Disallow "None" as a valid setting for "Conventional memory" */
    SendDlgItemMessage(hDlg, IDC_LOWMEM, CB_DELETESTRING,
        (WPARAM)SendDlgItemMessage(hDlg, IDC_LOWMEM, CB_FINDSTRING,
                                   (WPARAM)-1, (LPARAM)(LPTSTR)g_szNone), 0L);

    pmi->flEms = (EMS_EMM386 | EMS_RMPAGEFRAME);
    AdjustEmsControls(hDlg, pmi);
}


void ApplyMemDlg(HWND hDlg, PMEMINFO pmi)
{
    PROPMEM mem;
    PROPENV env;
    PPROPLINK ppl = pmi->ppl;
    FunctionName(ApplyMemDlg);

    if (!GetSetMemProps(hDlg, PifMgr_GetProperties, ppl, &mem, &env, IDS_UPDATE_ERROR))
        return;

    GetDlgBits(hDlg, abinfMem, ARRAYSIZE(abinfMem), &mem.flMemInit);
    GetDlgInts(hDlg, avinfMem, ARRAYSIZE(avinfMem), (LPVOID)&mem);
    GetDlgInts(hDlg, avinfEnvMem, ARRAYSIZE(avinfEnvMem), (LPVOID)&env);

    if (GetSetMemProps(hDlg, PifMgr_SetProperties, ppl, &mem, &env, IDS_UPDATE_ERROR)) {
        if (ppl->hwndNotify) {
            ppl->flProp |= PROP_NOTIFY;
            PostMessage(ppl->hwndNotify, ppl->uMsgNotify, SIZEOF(mem), (LPARAM)MAKELP(0,GROUP_MEM));
            PostMessage(ppl->hwndNotify, ppl->uMsgNotify, SIZEOF(env), (LPARAM)MAKELP(0,GROUP_ENV));
        }
        if (ppl->hVM && (pmi->flMemInfo & MEMINFO_RELAUNCH)) {
            pmi->flMemInfo &= ~MEMINFO_RELAUNCH;
            Warning(hDlg, IDS_MEMORY_RELAUNCH, MB_ICONWARNING | MB_OK);
        }
    }
}

void HideAndDisable(HWND hwnd)
{
    ShowWindow(hwnd, SW_HIDE);
    EnableWindow(hwnd, FALSE);
}

void AdjustEmsControls(HWND hDlg, PMEMINFO pmi)
{
    if (!(pmi->ppl->flProp & PROP_REALMODE)) {
        /*
         *  When not marked as PROP_REALMODE, all the EMS-related controls
         *  are visible.  We need to choose which set to disable.
         *
         *  We cheat, because we know that there are only two controls
         *  in both cases, and they come right after each other.
         */
        UINT uiHide;
        if (pmi->flEms & EMS_NOEMS) {
            uiHide = IDC_EXPMEMLBL;
            CTASSERTF(IDC_EXPMEMLBL + 1 == IDC_EMSMEM);
        } else {
            uiHide = IDC_NOEMS;
            CTASSERTF(IDC_NOEMS + 1 == IDC_NOEMSDETAILS);
        }
        HideAndDisable(GetDlgItem(hDlg, uiHide));
        HideAndDisable(GetDlgItem(hDlg, uiHide+1));
    }
}


void ExplainNoEms(HWND hDlg, PMEMINFO pmi)
{
    WORD idsHelp;
    TCHAR szMsg[MAX_STRING_SIZE];

    /*
     * Here is where we stare at all the bits to try to figure
     * out what recommendation to make.
     */
    ASSERTTRUE(pmi->flEms & EMS_NOEMS);

    if (pmi->flEms & EMS_SYSINIDISABLE) {
        /*
         * System.ini contains the line NOEMMDRIVER=1.
         */
        idsHelp = IDS_SYSINI_NOEMS;
    } else if (pmi->flEms & EMS_RMPAGEFRAME) {
        /*
         * Had page-frame in real mode, which means that some protmode
         * guy must've messed it up.
         */
        idsHelp = IDS_RING0_NOEMS;
    } else if (pmi->flEms & EMS_EMM386) {
        /*
         * No page-frame in real mode, and EMM386 was in charge,
         * so it's EMM386's fault.
         */
        idsHelp = IDS_EMM386_NOEMS;
    } else {
        /*
         * No page-frame in real mode, and QEMM was in charge,
         * so it's QEMM's fault.
         */
        idsHelp = IDS_QEMM_NOEMS;
    }

    if (LoadStringSafe(hDlg, idsHelp+1, szMsg, ARRAYSIZE(szMsg))) {
        Warning(hDlg, idsHelp, MB_OK, (LPCTSTR)szMsg);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\pifmgr.c ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1991
 *  All Rights Reserved.
 *
 *
 *  PIFMGR.C
 *  Main module for PIFMGR.DLL
 *
 *  History:
 *  Created 31-Jul-1992 3:30pm by Jeff Parsons
 *
 *  Exported Program Information File (PIF) Manager services:
 *
 *      PifMgr_OpenProperties()
 *          Give it the name of an DOS application (com, exe, or bat),
 *          and it will open the PIF associated with that application
 *          and return a "handle" to the app's "properties".  Use this
 *          handle when calling any of the other "properties" services (ie,
 *          Get, Set, and Close).
 *
 *          If no PIF exists, it will still allocate a PIF data block
 *          in memory and initialize it, either with data from _DEFAULT.PIF
 *          or its internal defaults.  It will also construct the PIF name
 *          it was looking for but couldn')t find and save that in its internal
 *          PIF data structure, so that if PifMgr_SetProperties is ever called, the
 *          data can be saved to disk.
 *
 *      PifMgr_GetProperties()
 *          Returns the specified block of data from the associated PIF.
 *          If it is a "named" block, it must be the name of a linked
 *          extension inside the PIF, which can be any predefined name
 *          (eg, "WINDOWS 386 3.0") or the name of your own block.  You can
 *          create your own named data blocks using the PifMgr_SetProperties()
 *          service.  "Named" data can also be thought of as "raw" data,
 *          because it is returned to the caller as-is -- without translation.
 *
 *          The size of a named block can be determined by calling
 *          PifMgr_GetProperties with a size of zero; no data is copied, but the size
 *          of the requested block is returned (0 if not found).
 *
 *          All named blocks can be enumerated by passing NULL for the name,
 *          a pointer to a 16-byte buffer for the requested block name, and a
 *          0-based block index in the size parameter.  The size returned
 *          is the size of the block (0 if none).
 *
 *          If an unnamed property block is requested (ie, the selector of
 *          the name parameter is NULL, and the offset is a property group
 *          ordinal), then the associated structure is returned.  For example,
 *          PifMgr_GetProperties(GROUP_TSK) returns a predefined structure (see
 *          PROPTSK in PIF.H) containing all the tasking-related information,
 *          in a format that is PIF-independent.  This is a valuable service,
 *          because it relieves callers from having to cope with PIFs
 *          containing a wide variety of sections (known as PIF extensions),
 *          only one of which is required.  Think of this as "cooked" data.
 *
 *          A third variation is raw read/write of the entire PIF data block,
 *          if lpszGroup is NULL.  This must be used with extreme caution, and
 *          will only be allowed if the properties were opened with the
 *          OPENPROPS_RAWIO flag specified.
 *
 *      PifMgr_SetProperties()
 *          This is pretty much the opposite of PifMgr_GetProperties, except that it
 *          also takes a flags parameter that can specify that the changes
 *          be made immediately, or deferred to PifMgr_CloseProperties.
 *
 *      PifMgr_CloseProperties()
 *          Flushes any dirty PIF data in memory, and frees the local heap
 *          storage.
 *
 */

#include "shellprv.h"
#pragma hdrstop

#ifdef _X86_

/* Global R/W DLL data
 */

PPROPLINK g_pplHead;              // pointer to first prop entry
HANDLE    g_offHighestPropLink;     // highest offset of a prop thus far recorded

TCHAR g_szNone[16];                // initialized by LibMainP,
TCHAR g_szAuto[16];                // and 16 chars to allow for localization

char g_szMSDOSSTSFile[] = "C:\\MSDOSSYS.STS";

TCHAR g_szConfigFile[] = TEXT("C:") CONFIGFILE;
TCHAR g_szAutoexecFile[] = TEXT("C:") AUTOEXECFILE;

TCHAR g_szMConfigFile[] = TEXT("C:") MCONFIGFILE;
TCHAR g_szMAutoexecFile[] = TEXT("C:") MAUTOEXECFILE;

TCHAR g_szWConfigFile[] = TEXT("C:") WCONFIGFILE;
TCHAR g_szWAutoexecFile[] = TEXT("C:") WAUTOEXECFILE;

#ifdef DBCS
char ImeBatchFile[] = "DOSIME\0";
#endif

#define NT_CONFIG_FILE "%SystemRoot%\\SYSTEM32\\CONFIG.NT"
#define NT_AUTOEXEC_FILE "%SystemRoot%\\SYSTEM32\\AUTOEXEC.NT"

#define LPPH_OFF(off) ((LPBYTE)lpph + off)
#define LPPIF_FIELDOFF(off) ((LPBYTE)ppl->lpPIFData + FIELD_OFFSET(PIFDATA,off))
#define LPPIF_OFF(off) ((LPBYTE)ppl->lpPIFData + off)

//
//  g_szDefaultPIF can be in one of three states:
//
//  1.  "_DEFAULT.PIF", which means that we have never needed to search
//          for a _default.pif yet.  The next time we need to locate
//          _default.pif, we must perform a full search.  On success,
//          move to state 2.  On failure, move to state 3.
//
//  2.  A fully-qualified path to _default.pif, which means that we have
//          searched for a _default.pif and found it in the specified
//          location.  The next time we need to locate _default.pif, we
//          will look here.  If found, remain in state 2, else move to
//          state 3.
//
//  3.  The null string, which means that we searched for a _default.pif
//          and didn't find one.  The next time we need to locate
//          _default.pif, we just fail without even looking on the disk.
//          (This is the common case for a clean install.)
//
//      Note that all the cases are "sticky"; once you reach a state, you
//      can never move back to a previous state.  This sacrifices flexibility
//      for performance.
//
//      The macro fTryDefaultPif() returns nonzero if we are in cases
//      1 or 2.
//
//      The macro fDefaultPifFound() returns nonzero if we are in case 2.
//
//  WARNING!  WARNING!  WARNING!  WARNING!
//
//      Evil hack relies on the fact that the three states can be
//      distinguished by the first character of g_szDefaultPIF, which
//      in turn relies on the fact that `_' cannot be the first character
//      of a fully-qualified path.  (It is not a valid drive letter,
//      and it cannot start a UNC.)
//
//

#define INIT_INIDATA                0x01
#define INIT_PIFDIR                 0x02

CHAR     fbInit = 0;                    // see INIT_* flags
INT      iPIFName = (12*sizeof(TCHAR)); // strlen(g_szPIFDir)
INT      iWinName = (12*sizeof(TCHAR)); // strlen(g_szPIFDir)
TCHAR    g_szPIFDir[MAXPATHNAME]     = TEXT("\\WINDOWS\\PIF");
TCHAR    g_szDefaultPIF[MAXPATHNAME] = TEXT("_DEFAULT.PIF");

#define fTryDefaultPif()            g_szDefaultPIF[0]
#define fDefaultPifFound()          (g_szDefaultPIF[0] != TEXT('_'))

//
// szComspec is the name of the COMSPEC program, usually "COMMAND.COM"
// or "CMD.EXE".
//
TCHAR   szComspec[8+1+3+1];

/* Global R/O DLL data
 */

extern const TCHAR c_szNULL[];              // A string so nice...

const TCHAR szZero[]            = TEXT("0");

const int acbData[] = {
                sizeof(PROPPRG),
                sizeof(PROPTSK),
                sizeof(PROPVID),
                sizeof(PROPMEM),
                sizeof(PROPKBD),
                sizeof(PROPMSE),
                sizeof(PROPSND),
                sizeof(PROPFNT),
                sizeof(PROPWIN),
                sizeof(PROPENV),
                sizeof(PROPNT31),
                sizeof(PROPNT40),
};

/*
 * The casts are used because we intentionally mis-prototyped the GetXxxData
 * and SetXxxData functions to receive their third argument as a LPXXX instead
 * of a LPVOID.
 */

const DATAGETFN afnGetData[] = {
                (DATAGETFN)GetPrgData,
                (DATAGETFN)GetTskData,
                (DATAGETFN)GetVidData,
                (DATAGETFN)GetMemData,
                (DATAGETFN)GetKbdData,
                (DATAGETFN)GetMseData,
                (DATAGETFN)GetSndData,
                (DATAGETFN)GetFntData,
                (DATAGETFN)GetWinData,
                (DATAGETFN)GetEnvData,
                (DATAGETFN)GetNt31Data,
                (DATAGETFN)GetNt40Data,
};

const DATASETFN afnSetData[] = {
                (DATASETFN)SetPrgData,
                (DATASETFN)SetTskData,
                (DATASETFN)SetVidData,
                (DATASETFN)SetMemData,
                (DATASETFN)SetKbdData,
                (DATASETFN)SetMseData,
                (DATASETFN)SetSndData,
                (DATASETFN)SetFntData,
                (DATASETFN)SetWinData,
                (DATASETFN)SetEnvData,
                (DATASETFN)SetNt31Data,
                (DATASETFN)SetNt40Data,
};


// WIN.INI things of interest
// Note: some of these NEED to be ANSI strings, and other TCHAR
// strings.  Please do not arbitrarily change the type casts of
// these strings!!!! (RickTu)


const TCHAR szMemory[]              = TEXT("MEMORY");
const TCHAR szComp[]                = TEXT("COMPATIBLE");

CHAR szSingle[]                     = "DOS=SINGLE\r\n";
CHAR szCRLF[]                       = "\r\n";
CHAR szEcho[]                       = "ECHO ";
CHAR szPause[]                      = "\r\nPAUSE\r\n";
CHAR szCall[]                       = "CALL ";
CHAR szCD[]                         = "CD ";
CHAR szWin[]                        = "WIN";

// SYSTEM.INI things of interest

const TCHAR szSystemINI[]           = TEXT("SYSTEM.INI");
const TCHAR sz386EnhSection[]       = TEXT("386Enh");
const TCHAR szWOAFontKey[]          = TEXT("WOAFont");
const TCHAR szWOADBCSFontKey[]      = TEXT("WOADBCSFont");
const TCHAR szNonWinSection[]       = TEXT("NonWindowsApp");
const TCHAR szTTInitialSizes[]      = TEXT("TTInitialSizes");
#ifdef  CUSTOMIZABLE_HEURISTICS
const TCHAR szTTHeuristics[]        = TEXT("TTHeuristics");
const TCHAR szTTNonAspectMin[]      = TEXT("TTNonAspectMin");
#endif
TCHAR szTTCacheSection[2][32] = {TEXT("TTFontDimenCache"), TEXT("TTFontDimenCacheDBCS")};

//
// These are because they are accessed only when we need to create
// a new PIF file or convert a 3.1 PIF file into a 4.0 PIF file.
//
const TCHAR szDOSAPPINI[]           = TEXT("DOSAPP.INI");
const TCHAR szDOSAPPSection[]       = TEXT("DOS Applications");
const TCHAR szDOSAPPDefault[]       = TEXT("Default");

const TCHAR szDisplay[]             = TEXT("DISPLAY");
const TCHAR szDefIconFile[]         = ICONFILE_DEFAULT;

const TCHAR szDotExe[]              = TEXT(".EXE");
const TCHAR szDotCom[]              = TEXT(".COM");
const TCHAR szDotBat[]              = TEXT(".BAT");
const TCHAR szDotPif[]              = TEXT(".PIF");
const TCHAR szDotCmd[]              = TEXT(".CMD");
const TCHAR * apszAppType[] =  {
    szDotExe, szDotCom, szDotBat, szDotCmd, szDotPif
};

CHAR szSTDHDRSIG[]                  = STDHDRSIG;
CHAR szW286HDRSIG30[]               = W286HDRSIG30;
CHAR szW386HDRSIG30[]               = W386HDRSIG30;
CHAR szWENHHDRSIG40[]               = WENHHDRSIG40;
CHAR szWNTHDRSIG31[]                = WNTHDRSIG31;
CHAR szWNTHDRSIG40[]                = WNTHDRSIG40;

CHAR szCONFIGHDRSIG40[]             = CONFIGHDRSIG40;
CHAR szAUTOEXECHDRSIG40[]           = AUTOEXECHDRSIG40;
const TCHAR szRunOnceKey[]          = REGSTR_PATH_RUNONCE;

const TCHAR szPIFConvert[]          = TEXT("PIFConvert");
const TCHAR szPIFConvertExe[]       = TEXT("RUNDLL.EXE PIFMGR.DLL,ProcessStartupProperties");
const TCHAR szPIFConvertKey[]       = REGSTR_PATH_PIFCONVERT;
const TCHAR szMSDOSMode[]           = REGSTR_VAL_MSDOSMODE;
const TCHAR szMSDOSModeDiscard[]    = REGSTR_VAL_MSDOSMODEDISCARD;


// wsprintf formatting strings
const TCHAR szDotPercent03d[]       = TEXT(".%03d");

// miscellaneous hack-o-ramas
const TCHAR szPP4[]                 = TEXT("PP4");      // MS Powerpoint 4.0

PROPTSK tskDefault          ={TSK_DEFAULT,
                              TSKINIT_DEFAULT,
                              TSKFGNDBOOST_DEFAULT,
                              TSKBGNDBOOST_DEFAULT,
                              0,
                              0,
                              TSKIDLESENS_DEFAULT,
};

PROPVID vidDefault          ={VID_DEFAULT,
                              VIDINIT_DEFAULT,
                              0,
                              0,
                              0,
};

PROPMEM memDefault          ={MEM_DEFAULT,
                              MEMINIT_DEFAULT,
                              MEMLOW_DEFAULT,   // ignore stdpifdata.minmem?
                              MEMLOW_MAX,       // ignore stdpifdata.maxmem?
                              MEMEMS_DEFAULT,
                              MEMEMS_MAX,
                              MEMXMS_DEFAULT,
                              MEMXMS_MAX,
};

PROPKBD kbdDefault          ={KBD_DEFAULT,
                              KBDINIT_DEFAULT,
                              KBDALTDELAY_DEFAULT,
                              KBDALTPASTEDELAY_DEFAULT,
                              KBDPASTEDELAY_DEFAULT,
                              KBDPASTEFULLDELAY_DEFAULT,
                              KBDPASTETIMEOUT_DEFAULT,
                              KBDPASTESKIP_DEFAULT,
                              KBDPASTECRSKIP_DEFAULT,
};

PROPMSE mseDefault          ={MSE_DEFAULT,
                              MSEINIT_DEFAULT,
};

PROPENV envDefault          ={ENV_DEFAULT,
                              ENVINIT_DEFAULT,
                              "",
                              ENVSIZE_DEFAULT,
                              ENVDPMI_DEFAULT,
};

WORD    flWinDefault        = WIN_DEFAULT;

/*
 * Default face name to use for Raster fonts.  Currently, this is
 * just a hard-coded value (ie, not maintained in any INI file).
 */
CHAR    szRasterFaceName[LF_FACESIZE] = "Terminal";


/*
 * Default face name to use for TrueType fonts.  It must be a monospace
 * font, and it must be a font that everyone is guaranteed to have.  Currently,
 * this can be changed by setting TTFont in [NonWindowsApp] in SYSTEM.INI.
 */
// now this is initialized with string resource. The 2nd element will get
// the native typeface for the bilingual dos prompt
CHAR    szTTFaceName[2][LF_FACESIZE] = {"Lucida Console", "Courier New"};

const TCHAR szAltKeyDelay        [] = TEXT("AltKeyDelay");
const TCHAR szAltPasteDelay      [] = TEXT("AltPasteDelay");
const TCHAR szKeyPasteDelay      [] = TEXT("KeyPasteDelay");
const TCHAR szKeyBufferDelay     [] = TEXT("KeyBufferDelay");
const TCHAR szKeyPasteTimeout    [] = TEXT("KeyPasteTimeout");
const TCHAR szKeyPasteSkipCount  [] = TEXT("KeyPasteSkipCount");
const TCHAR szKeyPasteCRSkipCount[] = TEXT("KeyPasteCRSkipCount");
const TCHAR szMouseInDosBox      [] = TEXT("MouseInDosBox");
const TCHAR szDisablePositionSave[] = TEXT("DisablePositionSave");
const TCHAR szDOSPromptExitInst  [] = TEXT("DOSPromptExitInstruc");
const TCHAR szCommandEnvSize     [] = TEXT("CommandEnvSize");
const TCHAR szScreenLines        [] = TEXT("ScreenLines");

const INIDATA aINIData[] = {
    {sz386EnhSection,   szAltKeyDelay,          &kbdDefault.msAltDelay,      INIDATA_FIXEDPOINT},
    {sz386EnhSection,   szAltPasteDelay,        &kbdDefault.msAltPasteDelay, INIDATA_FIXEDPOINT},
    {sz386EnhSection,   szKeyPasteDelay,        &kbdDefault.msPasteDelay,    INIDATA_FIXEDPOINT},
    {sz386EnhSection,   szKeyBufferDelay,       &kbdDefault.msPasteFullDelay,INIDATA_FIXEDPOINT},
    {sz386EnhSection,   szKeyPasteTimeout,      &kbdDefault.msPasteTimeout,  INIDATA_FIXEDPOINT},
    {sz386EnhSection,   szKeyPasteSkipCount,    &kbdDefault.cPasteSkip,      INIDATA_DECINT},
    {sz386EnhSection,   szKeyPasteCRSkipCount,  &kbdDefault.cPasteCRSkip,    INIDATA_DECINT},
    {szNonWinSection,   szMouseInDosBox,        &mseDefault.flMse,           INIDATA_BOOLEAN,  MSE_WINDOWENABLE},
    {szNonWinSection,   szDisablePositionSave,  &flWinDefault,               INIDATA_BOOLEAN | INIDATA_INVERT,  WIN_SAVESETTINGS},
#ifdef ENVINIT_INSTRUCTIONS
    {sz386EnhSection,   szDOSPromptExitInst,    &envDefault.flEnvInit,       INIDATA_BOOLEAN,  ENVINIT_INSTRUCTIONS},
#endif
    {szNonWinSection,   szCommandEnvSize,       &envDefault.cbEnvironment,   INIDATA_DECINT},
    {szNonWinSection,   szScreenLines,          &vidDefault.cScreenLines,    INIDATA_DECINT},
};

/**************************************************************************
 *
 *  OVERVIEW OF INI FILE USAGE
 *
 *
 *  SYSTEM.INI
 *
 *  [386Enh]
 *
 *  WOAFont=<fon filename>
 *
 *  Status:     Public
 *  Default:    dosapp.fon
 *  Purpose:
 *
 *      This setting allows the user to specify which Terminal font
 *      file should be loaded when DOS box is started.
 *
 *  To change:
 *
 *      Use Notepad to edit the SYSTEM.INI file.
 *
 *
 *  [NonWindowsApp]
 *
 *  DisablePositionSave=<Boolean>
 *
 *  Status:     Public
 *  Default:    0 (FALSE)
 *  Purpose:
 *
 *      When FALSE, the position and font used in a non-Windows
 *      application is saved in the application's PIF file when
 *      you exit the application.  When TRUE, the position, fonts, and
 *      toolbar state of a non-Windows application whose settings
 *      have not been previously saved in the DOSAPP.INI file will
 *      not be saved.
 *
 *      If enabled, the setting can be overridden for each
 *      non-Windows application by selecting the Save Settings On
 *      Exit check box in the Font dialog box.
 *
 *  To change:
 *
 *      Use Notepad to edit the SYSTEM.INI file.
 *
 *  Compatibility notes:
 *
 *      In Windows 3.x, the "position save" (and font) information was
 *      saved in DOSAPP.INI, and although we will still read DOSAPP.INI
 *      in the absence of any information in the PIF file, we only *write*
 *      settings back to the PIF file.  DOSAPP.INI should be considered
 *      obsolete.
 *
 *
 *  TTFont=<fontname>
 *
 *  Status:     ?
 *  Default:    Courier New     // FEATURE -- this should be a TT OEM font
 *  Purpose:
 *
 *      This setting allows the user to specify which TrueType font
 *      will be used in a DOS box.  It must be an OEM font.
 *
 *  To change:
 *
 *      Use Notepad to edit the SYSTEM.INI file.
 *
 *
 *  TTInitialSizes=<i1 i2 i3 i4 ... i16>
 *
 *  Status:     ?
 *  Default:    4 5 6 7 8 9 10 11 12 14 16 18 20 22 36 72
 *  Purpose:
 *
 *      This setting allows the user to specify which font sizes
 *      WinOldAp initially builds for the TrueType fonts in a DOS
 *      application window.
 *
 *      At most 16 font sizes can be requested.
 *
 *      Note that this INI entry is consulted only the first time
 *      Windows is restarted after changing video drivers or fonts.
 *
 *  To change:
 *
 *      Use Notepad to edit the SYSTEM.INI file.
 *
 *
 *  TTHeuristics=<i1 i2 i3 i4 i5 i6 i7 i8 i9>
 *
 *  Status:     Public
 *  Default:    5000 1000 0 1000 5000 1000 0 1000 1
 *  Purpose:
 *
 *      These integers control the way Windows chooses the font to
 *      display for DOS applications running inside a window if you
 *      have chosen "Auto" as the font size.
 *
 *      The parameters are named as follows:
 *
 *          i1=XOvershootInitial
 *          i2=XOvershootScale
 *          i3=XShortfallInitial
 *          i4=XShortfallScale
 *          i5=YOvershootInitial
 *          i6=YOvershootScale
 *          i7=YShortfallInitial
 *          i8=YShortfallScale
 *          i9=TrueTypePenalty
 *
 *      Each penalty value may not exceed 5000.
 *
 *      When Windows needs to select a font for use in a DOS
 *      application's window, it goes through the list of font
 *      sizes available and computes the "penalty" associated
 *      with using that font.  Windows then selects the font with
 *      the smallest penalty.
 *
 *      The horizontal penalty is computed as follows:
 *
 *          Let dxActual = <actual window width>
 *          Let dxDesired = <font width> * <characters per line>
 *
 *          If dxActual = dxDesired:
 *              xPenalty = 0
 *          If dxActual < dxDesired:
 *              Let Ratio = 1 - dxDesired / dxActual
 *              xPenalty = XOvershootInitial + Ratio * XOvershootScale
 *          If dxActual > dxDesired:
 *              Let Ratio = 1 - dxActual / dxDesired
 *              xPenalty = XShortfallInitial + Ratio * XShortfallScale
 *
 *      The vertical penalty is computed similarly.
 *
 *      Note that the Ratio is always a fraction between 0 and 1.
 *
 *      The penalty associated with a font is the sum of the vertical
 *      and horizontal penalties, plus the TrueTypePenalty if the font
 *      is a TrueType font.
 *
 *      The default value of 1 for the TrueTypePenalty means that,
 *      all other things being equal, Windows will select a raster
 *      font in preference to a TrueType font.  You can set this
 *      value to -1 if you wish the opposite preference.
 *
 *  To change:
 *
 *      Use Notepad to edit the SYSTEM.INI file.
 *
 *  Internals:
 *
 *      Even though floating point appears in the computations,
 *      everything is really done in integer arithmetic.
 *
 *      Pixels are NEVER MENTIONED anywhere in the penalty computations.
 *      (All pixel values are divided by other pixel values, so that
 *      we get a dimensionless number as a result.)
 *      This keeps us independent of the display resolution as well
 *      as the display aspect ratio.
 *
 *      Since the stretch and shrink are taken as fractions of the
 *      larger dimension, this keeps us from penalizing large
 *      differences by too much.  This is important because there
 *      isn't much visible difference between being ten times too
 *      big and being eleven times too big, but there is a big
 *      difference between being just right and being twice as big.
 *
 *      We must be careful not to let the maximum possible penalty
 *      exceed 32767.  This is done by making sure that each
 *      dimension cannot produce a penalty of greater than 10000
 *      (5000+5000), and that the TrueTypePenalty is at most 5000.
 *      This makes the maximum possible penalty 25000.
 *      This range checking is done by FontSelInit.
 *
 *
 *  TTNonAspectMin=<x y>
 *
 *  Status:     Public
 *  Default:    3 3
 *  Purpose:
 *
 *      These integers control the minimum width and height font that
 *      Windows will attempt to create automatically in response to a
 *      resize operation when TrueType fonts in DOS boxes are enabled
 *      and the "Auto" font size is selected.
 *
 *      These values prevent Windows from creating visually useless
 *      fonts like 10 x 1 or 1 x 10.  The default values prevent Windows
 *      from trying to create X x Y fonts if X < 3 or Y < 3.
 *
 *      TTNonAspectMin is not consulted if the font is being created at
 *      its default aspect ratio.  In other words, Windows will create,
 *      for example, a 1 x 3 font, if 1 x 3 is the standard aspect ratio
 *      for a 3-pixel-high font.
 *
 *      To permit all aspect ratios, set the values to "0 0".
 *
 *      To forbid all aspect ratios except for the standard aspect ratio,
 *      set the values to "-1 -1".
 *
 *  [TTFontDimenCache]
 *
 *  dxWidthRequested dyHeightRequested=dxWidthActual dyWidthActual
 *
 *  Status:     Private
 *  Default:    Null
 *  Purpose:
 *
 *      The [FontDimenCache] section contains information about
 *      TrueType font sizes that have been created.  Each entry
 *      has as the keyname the width and height that were passed
 *      to CreateFont and has as the value the width and height of
 *      the font that was actually created.
 *
 *  Internals:
 *
 *      Inspected by AddTrueTypeFontsToFontList.
 *      Set by AddOneNewTrueTypeFontToFontList.
 *
 *
 **************************************************************************
 *
 *  DOSAPP.INI (obsolete, supported on a read-only basis)
 *
 *  [Dos Applications]
 *
 *  C:\FULL\PATH\TO\EXE\COM\BAT\OR.PIF=<wFlags wFontWidth wFontHeight
 *          wWinWidth wWinHeight length flags showCmd ptMinPositionX
 *          ptMinPositionY ptMaxPositionX ptMaxPositionY
 *          rcNormalLeft rcNormalTop rcNormalRight rcNormalBottom>
 *
 *  Status:     Private
 *  Purpose:
 *
 *      These values are used to restore a DOS application's window
 *      to the state it was in when the DOS app last exited normally.
 *
 *      The values are taken directly from the INIINFO structure, qv.
 *
 *      The values of ptMinPositionX and ptMinPositionY are always -1,
 *      since we do not try to preserve the icon position.
 *
 *      If wFontHeight has the high bit set, then the font that
 *      should be used is a TrueType font.
 *
 *      If wFontWidth = 1 and wFontHeight = -1, then
 *      Auto-font-selection is active.
 *
 *  Compatibility notes:
 *
 *      In Windows 3.x, the "position save" (and font) information was
 *      saved in DOSAPP.INI, and although we will still read DOSAPP.INI
 *      in the absence of any information in the PIF file, we only *write*
 *      settings back to the PIF file.  DOSAPP.INI should be considered
 *      obsolete.
 *
 *
 **************************************************************************
 *
 * THE NEXT INI VAR IS NOT IMPLEMENTED BUT SHOULD BE
 *
 **************************************************************************
 *
 *  SYSTEM.INI
 *
 *  [NonWindowsApp]
 *
 *  TTFontTolerance=<i>
 *
 *  Status:     Public
 *  Default:    200
 *  Purpose:
 *
 *      This setting indicates how large a penalty (see TTHeuristics)
 *      Windows should tolerate before trying to synthesize new font
 *      sizes from TrueType fonts.
 *
 *      Decreasing this value will result in a tighter fit of the
 *      Windows-selected font to the actual window size, but at a
 *      cost in speed and memory.
 *
 *  To change:
 *
 *      Use Notepad to edit the SYSTEM.INI file.
 *
 *
 *  Internals:
 *
 *      Inspected by ChooseBestFont, if implemented.
 *
 **************************************************************************/



void PifMgrDLL_Init()
{
    static BOOL fInit = FALSE;
    if (!fInit)
    {
        LoadString(g_hinst, IDS_PIF_NONE, g_szNone, ARRAYSIZE(g_szNone));
        LoadString(g_hinst, IDS_AUTONORMAL, g_szAuto, ARRAYSIZE(g_szAuto));
        LoadGlobalFontData();
        fInit = TRUE;
    }
}

/** GetPIFDir - Form default PIF directory name + name of given file
 *
 * INPUT
 *  None
 *
 * OUTPUT
 *  None
 */

void GetPIFDir(LPTSTR pszName)
{
    int i;
    static const TCHAR szBackslashPIF[] = TEXT("\\PIF");
    FunctionName(GetPIFDir);

    if (!(fbInit & INIT_PIFDIR)) {

        // Set up g_szPIFDir, less space for a filename, less space for \PIF

        i = ARRAYSIZE(g_szPIFDir)-lstrlen(pszName)-ARRAYSIZE(szBackslashPIF);
        if (i <= 0)                         // sanity check
            return;

        GetWindowsDirectory(g_szPIFDir, i);
        iPIFName = lstrlen(g_szPIFDir);
        if (StrRChr(g_szPIFDir, NULL, TEXT('\\')) == &g_szPIFDir[iPIFName-1])
            iPIFName--;
        iWinName = iPIFName;

        StringCchCopy(g_szPIFDir+iPIFName, ARRAYSIZE(g_szPIFDir)-iPIFName, szBackslashPIF);
        iPIFName += ARRAYSIZE(szBackslashPIF)-1;

        i = (int)GetFileAttributes(g_szPIFDir);

        if (i == -1) {

            // It didn't exist, so try to create it (returns TRUE if success)

            i = CreateDirectory(g_szPIFDir, NULL);
            if (i)
                SetFileAttributes(g_szPIFDir, FILE_ATTRIBUTE_HIDDEN);
        }
        else if (i & FILE_ATTRIBUTE_DIRECTORY)
            i = TRUE;                       // directory already exists, cool!
        else
            i = FALSE;                      // some sort of file is in the way...

        if (i) {
            g_szPIFDir[iPIFName++] = TEXT('\\');    // append the slash we'll need
                                            // to separate future filenames (the
                                            // space after is already zero-init'ed)
        }
        else                                // we'll just have to use the Windows dir
            iPIFName -= ARRAYSIZE(szBackslashPIF)-2;

        fbInit |= INIT_PIFDIR;
    }

    // Now initialize g_szPIFDir with the name of the file we're processing

    if (pszName)
        StringCchCopy(g_szPIFDir+iPIFName, ARRAYSIZE(g_szPIFDir)-iPIFName, pszName);
}

/** GetINIData - Read WIN.INI/SYSTEM.INI/DOSAPP.INI for default settings
 *
 * INPUT
 *  Nothing
 *
 * OUTPUT
 *  Nothing; global defaults (re)set
 *
 * NOTES
 *  We only do this work now if GetPIFData couldn't open a PIF file, or
 *  could but it contained no enhanced section.  And we never do it more than
 *  once per fresh load of this DLL.
 */

void GetINIData()
{
    int t;
    const INIDATA *pid;
    LPCTSTR lpsz;
    DWORD dwRet;
    TCHAR szTemp[MAX_PATH];
    FunctionName(GetINIData);

    if (fbInit & INIT_INIDATA)          // if already done
        return;                         // then go away

    for (pid=aINIData; pid-aINIData < ARRAYSIZE(aINIData); pid++) {

        t = *(INT UNALIGNED *)pid->pValue;
        if (pid->iFlags & (INIDATA_DECINT | INIDATA_BOOLEAN)) {

            if (pid->iFlags & INIDATA_BOOLEAN) {
                t &= pid->iMask;
                if (pid->iFlags & INIDATA_INVERT)
                    t ^= pid->iMask;
            }
            t = GetPrivateProfileInt(pid->pszSection,
                                     pid->pszKey,
                                     t,
                                     szSystemINI);
            if (pid->iFlags & INIDATA_BOOLEAN) {
                if (t)
                    t = pid->iMask;
                if (pid->iFlags & INIDATA_INVERT)
                    t ^= pid->iMask;
                t |= *(INT UNALIGNED *)pid->pValue & ~pid->iMask;
            }
            *(INT UNALIGNED *)pid->pValue = t;
        }
        else
        if (pid->iFlags & INIDATA_FIXEDPOINT) {
            StringCchPrintf(szTemp, ARRAYSIZE(szTemp), szDotPercent03d, t);
            GetPrivateProfileString(pid->pszSection,
                                    pid->pszKey,
                                    szTemp,
                                    szTemp,
                                    ARRAYSIZE(szTemp),
                                    szSystemINI);
            *(INT UNALIGNED *)pid->pValue = StrToInt(szTemp+1);
        }
        else
            ASSERTFAIL();
    }

    //
    // Locate COMSPEC once and for all.
    //
    dwRet = GetEnvironmentVariable(TEXT("COMSPEC"), szTemp, ARRAYSIZE(szTemp));
    if (dwRet < ARRAYSIZE(szTemp) && dwRet > 0)
    {
        lpsz = StrRChr(szTemp, NULL, TEXT('\\'));
        if (lpsz) {
            StringCchCopy(szComspec, ARRAYSIZE(szComspec), lpsz+1);
        }
    }

    fbInit |= INIT_INIDATA;
}

/** InitProperties - initialize new property structure
 *
 * INPUT
 *  ppl -> property
 *  fLocked == TRUE to return data locked, FALSE unlocked
 *
 * OUTPUT
 *  Nothing (if successful, ppl->hPIFData will become non-zero)
 */

void InitProperties(PPROPLINK ppl, BOOL fLocked)
{
    LPSTDPIF lpstd;
    LPW386PIF30 lp386 = NULL;
    CHAR achPathName[ARRAYSIZE(ppl->szPathName)];
    BYTE behavior = 0;
    FunctionName(InitProperties);

    GetINIData();       // make sure we have all the right defaults

    if (ResizePIFData(ppl, sizeof(STDPIF)) != -1) {

        // We're no longer called *only* after a fresh ZERO'd HeapAlloc
        // by ResizePIFData.  We could be getting called because PifMgr_OpenProperties
        // was told to punt on an ambiguous PIF and create new settings.
        // Hence, we always zero-init the buffer ourselves now.

        BZero(ppl->lpPIFData, ppl->cbPIFData);

        lpstd = (LPSTDPIF)ppl->lpPIFData;
        lpstd->id = 0x78;
        PifMgr_WCtoMBPath( ppl->szPathName, achPathName, ARRAYSIZE(achPathName) );
        lstrcpyncharA(lpstd->appname, achPathName+ppl->iFileName, ARRAYSIZE(lpstd->appname), '.');
        CharToOemBuffA(lpstd->appname, lpstd->appname, ARRAYSIZE(lpstd->appname));

        // NOTE: When 3.x Setup creates PIF files, it sets maxmem to 640;
        // that's typically what memDefault.wMaxLow will be too....

        lpstd->minmem = memDefault.wMinLow;
        lpstd->maxmem = (WORD) GetProfileInt(apszAppType[APPTYPE_PIF]+1, szMemory, memDefault.wMaxLow);
        StringCchCopyA(lpstd->startfile, ARRAYSIZE(lpstd->startfile), achPathName);
        CharToOemBuffA(lpstd->startfile, lpstd->startfile, ARRAYSIZE(lpstd->startfile));

        //
        // New for 4.0:  fDestroy (close on exit) is disabled by default
        // for most apps, but is enabled by default for COMSPEC.
        //
        lpstd->MSflags = 0;
        if (!lstrcmpi(ppl->szPathName+ppl->iFileName, szComspec)) {
            lpstd->MSflags = fDestroy;
        }

        // Initialize various goofy non-zero stuff just to make it
        // look like a backward-compatible PIF file -- not that we use
        // or particularly care about any of it

        // NOTE: When 3.x Setup creates PIF files, it sets screen to 0x7F

        lpstd->cPages = 1;
        lpstd->highVector = 0xFF;
        lpstd->rows = 25;
        lpstd->cols = 80;
        lpstd->sysmem = 0x0007;

        // fFullScreen is no longer default, so only if an explicit
        // COMPATIBLE=FALSE exists in the PIF section of WIN.INI will
        // we set fScreen in behavior and fFullScreen in PfW386Flags
        // Similarly, fDestroy is no longer default, but we'll go
        // back to the old way if the switch tells us to.

        if (!GetProfileInt(apszAppType[APPTYPE_PIF]+1, szComp, TRUE)) {
            lpstd->behavior = behavior = fScreen;
            lpstd->MSflags = fDestroy;
        }

        if (ppl->ckbMem != -1 && ppl->ckbMem != 1)
            lpstd->minmem = lpstd->maxmem = (WORD) ppl->ckbMem;


        if (AddGroupData(ppl, szW386HDRSIG30, NULL, sizeof(W386PIF30))) {
            if (NULL != (lp386 = GetGroupData(ppl, szW386HDRSIG30, NULL, NULL))) {
                lp386->PfW386minmem = lpstd->minmem;
                lp386->PfW386maxmem = lpstd->maxmem;
                lp386->PfFPriority = TSKFGND_OLD_DEFAULT;
                lp386->PfBPriority = TSKBGND_OLD_DEFAULT;
                lp386->PfMinEMMK = memDefault.wMinEMS;
                lp386->PfMaxEMMK = memDefault.wMaxEMS;
                lp386->PfMinXmsK = memDefault.wMinXMS;
                lp386->PfMaxXmsK = memDefault.wMaxXMS;
                lp386->PfW386Flags = fBackground + fPollingDetect + fINT16Paste;
                if (behavior & fScreen)
                    lp386->PfW386Flags |= fFullScreen;
                lp386->PfW386Flags2 = fVidTxtEmulate + fVidNoTrpTxt + fVidNoTrpLRGrfx + fVidNoTrpHRGrfx + fVidTextMd;
            }
        }
        VERIFYTRUE(AddEnhancedData(ppl, lp386));
        if (AddGroupData(ppl, szWNTHDRSIG31, NULL, sizeof(WNTPIF31))) {
            LPWNTPIF31 lpnt31;

            if (NULL != (lpnt31 = GetGroupData(ppl, szWNTHDRSIG31, NULL, NULL))) {
                StringCchCopyA( lpnt31->nt31Prop.achConfigFile, ARRAYSIZE(lpnt31->nt31Prop.achConfigFile), NT_CONFIG_FILE );
                StringCchCopyA( lpnt31->nt31Prop.achAutoexecFile, ARRAYSIZE(lpnt31->nt31Prop.achAutoexecFile), NT_AUTOEXEC_FILE );
            }
        }
        VERIFYTRUE(AddGroupData(ppl, szWNTHDRSIG40, NULL, sizeof(WNTPIF40)));

        // Can't be dirty anymore, 'cause we just set everything to defaults

        ppl->flProp &= ~PROP_DIRTY;

        if (!fLocked)
            ppl->cLocks--;
    }
    else
        ASSERTFAIL();
}


/** OpenPIFFile - Wrapper around CreateFile for opening PIF files
 *
 *  The wrapper handles the following things:
 *
 *      Passing the proper access and sharing flags to CreateFile.
 *      Setting pof->nErrCode = 0 on success.
 *      Converting ERROR_PATH_NOT_FOUND to ERROR_FILE_NOT_FOUND.
 *
 * INPUT
 *
 *  pszFile -> name of file to attempt to open
 *  pof -> PIFOFSTRUCT to fill in
 *
 *  OUTPUT
 *
 *  Same return code as CreateFile.
 *
 */

HANDLE OpenPIFFile(LPCTSTR pszFile, LPPIFOFSTRUCT pof)
{
    HANDLE hf;
    TCHAR pszFullFile[ MAX_PATH ];
    LPTSTR pszTheFile;
    DWORD dwRet;

    //
    // CreateFile does not search the path, so do that first, then
    // give CreateFile a fully qualified file name to open...
    //

    dwRet = SearchPath( NULL,
                        pszFile,
                        NULL,
                        ARRAYSIZE(pszFullFile),
                        pszFullFile,
                        &pszTheFile
                       );

    if ((dwRet==0) || (dwRet > ARRAYSIZE(pszFullFile)))
    {
        pszTheFile = (LPTSTR)pszFile;
    }
    else
    {
        pszTheFile = pszFullFile;
    }

    hf = CreateFile( pszTheFile,
                     GENERIC_READ,
                     FILE_SHARE_READ,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL );


    if (hf == INVALID_HANDLE_VALUE)
    {
        pof->nErrCode = GetLastError();
        if (pof->nErrCode == ERROR_PATH_NOT_FOUND)
            pof->nErrCode = ERROR_FILE_NOT_FOUND;
    }
    else
    {
        LPTSTR lpDummy;

        //
        //  NOTE:  Special hack for creating shortcuts.  If the PIF file
        //  that we find is 0 bytes long, pretend we did not find one at all.
        //  This is because appwiz renames a 0 length file from "New shortcut.lnk"
        //  to "appname.pif" and we end up finding it.  We'll ignore this file.
        //

        if (SetFilePointer( hf, 0, NULL, FILE_END) == 0)
        {
            CloseHandle( hf );
            hf = INVALID_HANDLE_VALUE;
            pof->nErrCode = ERROR_FILE_NOT_FOUND;
        }
        else
        {
            LPCTSTR pszNewFile;
            TCHAR szTemp[ ARRAYSIZE(pof->szPathName) ];

            SetFilePointer( hf, 0, NULL, FILE_BEGIN );
            pof->nErrCode = ERROR_SUCCESS;

            // In some cases, people pass in two pointers to the same
            // buffer.  This will hose GetFullPathName, so if they
            // are the same, then make a copy before calling GetFullPathName.
            if (pszTheFile==pof->szPathName) {
                FillMemory( szTemp, sizeof(szTemp), 0 );
                StringCchCopy( szTemp, ARRAYSIZE(szTemp), pszTheFile );
                pszNewFile = szTemp;
            }
            else
            {
                pszNewFile = pszTheFile;
            }
            GetFullPathName( pszNewFile, ARRAYSIZE(pof->szPathName),
                             pof->szPathName, &lpDummy );
        }
    }

    return hf;
}


/** PifMgr_OpenProperties - return handle to property info for application
 *
 * INPUT
 *  lpszApp -> name of application
 *  lpszPIF -> name of PIF file to use/create
 *  hInf = Inf handle, 0 if none, -1 to inhibit Inf processing
 *  flOpt = OPENPROPS_RAWIO to allow raw file updates; otherwise, 0
 *
 * OUTPUT
 *  handle to properties, FALSE if could not be opened, or out of memory
 *
 * REMARKS
 *  This should not be thought of as a function that opens a file somewhere
 *  on the disk (although that's usually the effect), but rather as an
 *  property structure allocator that is optionally initialized by disk data
 *  (currently, the file does not even remain open after this call).  So the
 *  main reason for failure in this function will be either a low memory
 *  condition *or* inability to open a specific PIF file.
 *
 *  The rules for PIF file searching are as follows:
 *
 *      If not a .PIF file:
 *          Search in current directory.
 *      Endif.
 *
 *      If path components were specified:
 *          Search in specified directory.
 *      Endif.
 *
 *      Search in PIF directory.
 *      Search the path.
 *
 *  Note that this differs from the Windows 3.1 PIF search algorithm, which
 *  was...
 *
 *      Search current directory.
 *      Search the path.
 *      Search in application directory.
 *
 *  This was a really bogus search order.  Fortunately, it seems that
 *  very few people relied on it.
 *
 *  Things to watch out for when dorking the PIF file search order:
 *
 *      Make sure editing PIF properties from the shell works.  (I.e.,
 *      if a full path to a PIF is given, then use it; don't search.)
 *
 *  Extra special thing to watch out for when dorking the PIF file
 *  search order:
 *
 *      MS Delta execs its child process as follows:
 *
 *          CreatePif("C:\DELTA\DELTABAT.PIF");
 *          SetCurrentDirectory("C:\RANDOM\PLACE");
 *          WinExec("C:\TMP\DELTABAT.BAT", SW_HIDE);
 *
 *      It expects the PIF search to pick up C:\DELTA\DELTABAT.PIF
 *      from the path, even though the WinExec supplied a full path.
 *
 */

HANDLE WINAPI PifMgr_OpenProperties(LPCTSTR lpszApp, LPCTSTR lpszPIF, UINT hInf, UINT flOpt)
{
    PPROPLINK ppl;
    LPTSTR pszExt;
    BOOL fError = FALSE;
    BOOL fFixedDisk = FALSE;
    BOOL fSearchInf = FALSE;
    BOOL fExplicitPIF = FALSE;
    PROPPRG prg;
    PROPNT40 nt40;
    LPTSTR pszName, pszFullName;
#ifdef DBCS
    PROPENV env;
#endif
    FunctionName(PifMgr_OpenProperties);
    // Allocate new prop

    if (!(ppl = (PPROPLINK)LocalAlloc(LPTR, sizeof(PROPLINK))))
        return 0;

    if (!(pszFullName = (LPTSTR)LocalAlloc(LPTR, MAXPATHNAME*sizeof(TCHAR)))) {
        EVAL(LocalFree(ppl) == NULL);
        return 0;
    }

    if ((HANDLE)ppl > g_offHighestPropLink) {
        g_offHighestPropLink = (HANDLE)ppl;

    }

    // Initialize the new prop

    ppl->ppl = ppl;
    ppl->ckbMem = -1;
    ppl->iSig = PROP_SIG;
    ppl->hPIF = INVALID_HANDLE_VALUE;
    if (flOpt & OPENPROPS_RAWIO)
        ppl->flProp |= PROP_RAWIO;

    #if (PRGINIT_INHIBITPIF != PROP_INHIBITPIF)
    #error PRGINIT_INIHIBITPIF and PROP_INHIBITPIF out of sync!
    #endif

    ppl->flProp |= (flOpt & PROP_INHIBITPIF);

    // Link into the global list

    if (NULL != (ppl->pplNext = g_pplHead))
        g_pplHead->pplPrev = ppl;
    g_pplHead = ppl;

    // Copy app name to both temp and perm buffers, and record location
    // of base filename, and extension if any, within the buffer

    StringCchCopy(pszFullName,MAXPATHNAME-4, lpszApp);
    StringCchCopy(ppl->szPathName, ARRAYSIZE(ppl->szPathName), pszFullName);

    if (NULL != (pszName = StrRChr(pszFullName, NULL, TEXT('\\'))) ||
        NULL != (pszName = StrRChr(pszFullName, NULL, TEXT(':'))))
        pszName++;
    else
        pszName = pszFullName;

    if (!(pszExt = StrRChr(pszName, NULL, TEXT('.'))))
        pszExt = pszFullName + lstrlen(pszFullName);

    ppl->iFileName = (UINT) (pszName - pszFullName);
    ppl->iFileExt = (UINT) (pszExt - pszFullName);

    // Check the application's file extension

    if (!*pszExt) {
        StringCchCat(pszFullName, MAXPATHNAME, apszAppType[APPTYPE_PIF]);
    }
    else if (!lstrcmpi(pszExt, apszAppType[APPTYPE_EXE]) ||
             !lstrcmpi(pszExt, apszAppType[APPTYPE_COM]) ||
             !lstrcmpi(pszExt, apszAppType[APPTYPE_BAT])) {
//             !lstrcmpi(pszExt, apszAppType[APPTYPE_CMD])) {
        StringCchCopy(pszExt, MAXPATHNAME-(pszExt-pszFullName), apszAppType[APPTYPE_PIF]);
    }
    else if (!lstrcmpi(pszExt, apszAppType[APPTYPE_PIF]))
        fExplicitPIF = TRUE;
    else {
        // Let's disallow random file extensions, since WinOldAp never
        // allowed them either
        goto Error;
    }

    // INFONLY means the caller just wants to search the INF, so ignore
    // any WIN.INI garbage and any PIFs laying around.  We still look for
    // _DEFAULT.PIF, since that code takes care of other important
    // initialization that needs to happen when no PIF was found at all.

    if (flOpt & OPENPROPS_INFONLY)
        goto FindDefault;

    // Backward compatibility requires that if the app is not a PIF,
    // then we must check the PIF section of WIN.INI for an entry matching
    // the base name of the app.  If the entry exists, then we have to skip
    // the PIF search, and pass the value of the entry to InitProperties,
    // which it uses to establish default memory requirements
    //
    // Also note that if IGNOREPIF is set, then ofPIF.szPathName is nothing
    // more than the name of the app that was given to PifMgr_OpenProperties;  this
    // may give us the opportunity to do something more intelligent later...

    if (!fExplicitPIF) {
        ppl->ckbMem = GetProfileInt(apszAppType[APPTYPE_PIF]+1, ppl->szPathName+ppl->iFileName, -1);
        if (ppl->ckbMem != -1) {
            ppl->flProp |= PROP_IGNOREPIF | PROP_SKIPPIF;
            StringCchCopy(ppl->ofPIF.szPathName, ARRAYSIZE(ppl->ofPIF.szPathName), lpszApp);
            goto IgnorePIF;     // entry exists, skip PIF file search
        }
    }

    //
    // Initialize default error return code.  Once we get a successful
    // open, it will be set to zero.
    //
    ppl->flProp |= PROP_NOCREATEPIF;
    ppl->ofPIF.nErrCode = ERROR_FILE_NOT_FOUND;

    //
    // We must search in the current directory if not given a path to a PIF.
    // We need to prefix `.\' to the filename so that OpenFile will not do
    // a path search.
    //
    if (!fExplicitPIF || pszName == pszFullName) {
        //
        // This relies on a feature of OpenFile, that it copies the input
        // buffer to a private buffer before stomping the output buffer,
        // thus permitting precisely the stunt we are pulling here, namely,
        // passing an input buffer equal to the output buffer.
        //
        *(LPDWORD)(ppl->ofPIF.szPathName) = 0x005C002E; /*dot backslash prefix */
        StringCchCopy( &ppl->ofPIF.szPathName[2], ARRAYSIZE(ppl->ofPIF.szPathName) - 2,
                  pszName);
        ppl->hPIF = OpenPIFFile(ppl->ofPIF.szPathName, &ppl->ofPIF);
    }

    //
    // If we were given a path component, then look in that directory.
    // (The fact that we have a backslash or drive letter will suppress
    // the path search.)
    //
    if (pszName != pszFullName && ppl->ofPIF.nErrCode == ERROR_FILE_NOT_FOUND) {

        ppl->hPIF = OpenPIFFile(pszFullName, &ppl->ofPIF);

        // If we didn't find a PIF there, we'd probably still like to create
        // one there if the media is a fixed disk.  Network shares, CD-ROM
        // drives, and floppies are not good targets for PIF files in general.
        //
        // So, if the media is a fixed disk, set the fFixedDisk flag so that
        // we'll leave pszFullName alone.

        if (ppl->hPIF == INVALID_HANDLE_VALUE && pszFullName[1] == TEXT(':')) {
            TCHAR szTemp[4];

            StringCchCopy(szTemp, ARRAYSIZE(szTemp), pszFullName);

            if (GetDriveType(szTemp) == DRIVE_FIXED)
                    fFixedDisk++;
        }
    }

    // PERF: replace this PIF dir search with a registry search -JTP
    //
    // Failing that, let's look in the PIF directory.  Again, since we're
    // supplying a full pathname, OpenFile won't try to search the PATH again.

    if (ppl->ofPIF.nErrCode == ERROR_FILE_NOT_FOUND) {
        GetPIFDir(pszName);
        ppl->hPIF = OpenPIFFile(g_szPIFDir, &ppl->ofPIF);
        if (ppl->hPIF != INVALID_HANDLE_VALUE)
            ppl->flProp |= PROP_PIFDIR;
    }

    // If we're still in trouble, our last chance is to do a path
    // search.  This is an unconditional search, thanks to the
    // wonders of MS-Delta.

    if (ppl->ofPIF.nErrCode == ERROR_FILE_NOT_FOUND) {
        ppl->hPIF = OpenPIFFile(pszName, &ppl->ofPIF);
    }

    if (ppl->hPIF == INVALID_HANDLE_VALUE) {

        if (ppl->ofPIF.nErrCode != ERROR_FILE_NOT_FOUND || fExplicitPIF) {

            // Hmmm, file *may* exist, but it cannot be opened;  if it's a
            // strange error, or we were specifically told to open that file,
            // then return error

            goto Error;
        }

    FindDefault:

        fSearchInf = TRUE;
        ppl->flProp &= ~PROP_NOCREATEPIF;

        // Any files we find now are NOT really what we wanted, so save
        // the name we'd like to use in the future, in case we need to save
        // updated properties later.
        //
        // We must save the name now because we might stomp g_szPIFDir while
        // searching for the _default.pif.  Furthermore, we must save it in
        // the buffer we HeapAlloc'ed (pszFullName) temporarily, because
        // the following calls to OpenPIFFile can still stomp on szPathName
        // in our OpenFile structure (ofPIF.szPathName).

        GetPIFDir(pszName);
        if (!fFixedDisk)                        // save desired name in
            StringCchCopy(pszFullName, MAXPATHNAME, g_szPIFDir);     // temp buffer (pszFullName)

        //
        // Try to locate the _default.pif.
        //

        if (fTryDefaultPif()) {

            if (!fDefaultPifFound()) {          // Must search for it

                // First try PIFDir

                StringCchCopy(g_szPIFDir+iPIFName, ARRAYSIZE(g_szPIFDir)-iPIFName, g_szDefaultPIF);
                ppl->hPIF = OpenPIFFile(g_szPIFDir, &ppl->ofPIF);

                if (ppl->ofPIF.nErrCode == ERROR_FILE_NOT_FOUND) { // try PATH
                    ppl->hPIF = OpenPIFFile(g_szDefaultPIF, &ppl->ofPIF);
                }

            } else {                            // Look in cached path

                // We've already found it once, so just open it

                ppl->hPIF = OpenPIFFile(g_szDefaultPIF, &ppl->ofPIF);
            }
        }

        if (ppl->hPIF != INVALID_HANDLE_VALUE) {

            ppl->flProp |= PROP_DEFAULTPIF;

            // Save the fully-qualified pathname of the default PIF file,
            // so that subsequent OpenFile() calls will be faster (note that
            // we don't specify OF_SEARCH on that particular call)

            StringCchCopy(g_szDefaultPIF, ARRAYSIZE(g_szDefaultPIF), ppl->ofPIF.szPathName);
        }
        else {

            // Not only could we not open any sort of PIF, we also need to
            // tell GetPIFData to not bother trying to open the file itself
            // (since it is unlikely someone created one in this short time)

            ppl->flProp |= PROP_NOPIF | PROP_SKIPPIF;

            if (ppl->ofPIF.nErrCode == ERROR_FILE_NOT_FOUND)
                g_szDefaultPIF[0] = 0;            // Invalidate cache.
        }

        // NOW we can set ppl->ofPIF.szPathName to the filename we REALLY
        // wanted, since we're done with all the calls to OpenPIFFile.

        StringCchCopy(ppl->ofPIF.szPathName, ARRAYSIZE(ppl->ofPIF.szPathName), pszFullName);
    }

    // Initialize the properties by PIF if we have one, by hand if not

  IgnorePIF:

    // We don't need to check the return code from GetPIFData() here,
    // because we validate hPIFData below anyway.  Please also note that
    // this GetPIFData call uses the handle we supplied (if any), and closes
    // it for us when it's done.  Furthermore, if we didn't supply a handle,
    // then we should have set PROP_SKIPPIF, so that GetPIFData won't try to
    // open anything (since we just tried!)

    GetPIFData(ppl, FALSE);

    // Now that the original file from which we obtained settings (if any) is
    // closed, we need to see if the caller wants us to create a new PIF file
    // using a specific name.  If so, force it to be created now.

    if (lpszPIF) {
        StringCchCopy(ppl->ofPIF.szPathName, ARRAYSIZE(ppl->ofPIF.szPathName), lpszPIF);
        ppl->flProp |= PROP_DIRTY;
        ppl->flProp &= ~PROP_NOCREATEPIF;
        fError = !FlushPIFData(ppl, FALSE);
    }

    // Apply INF data to the PIF data we just retrieved, as appropriate,
    // as long as it's an app file and not a PIF file (and if, in the case of
    // creating a specific PIF, we were actually able to create one).

    if (!fError && !fExplicitPIF && (hInf != -1)) {

        if (PifMgr_GetProperties(ppl, MAKELP(0,GROUP_PRG),
                            &prg, sizeof(prg), GETPROPS_NONE)) {

            // In the PRGINIT_AMBIGUOUSPIF case, GetAppsInfData must
            // again look for a matching entry;  however, if the entry it
            // finds is the same as what we've already got (based on Other
            // File), then it will leave the PIF data alone (ie, it doesn't
            // reinitialize it, it doesn't call AppWiz to silently
            // reconfigure it, etc).

            if (fSearchInf || (prg.flPrgInit & PRGINIT_AMBIGUOUSPIF)) {

                if (PifMgr_GetProperties(ppl, MAKELP(0,GROUP_NT40),
                                &nt40, sizeof(nt40), GETPROPS_NONE)) {

                if (!GetAppsInfData(ppl, &prg, &nt40, (HINF)IntToPtr( hInf ), lpszApp, fFixedDisk, flOpt)) {

                    // When GetAppsInfData fails and the PIF is ambiguous, then
                    // we need to restart the PIF search process at the point where
                    // it searches for _DEFAULT.PIF, so that the ambiguous PIF is
                    // effectively ignored now.

                    // Also, we avoid the ugly possibility of getting to this
                    // point again and infinitely jumping back FindDefault, by
                    // only jumping if fSearchInf was FALSE.  FindDefault sets
                    // it to TRUE.

                    if (!fSearchInf && (prg.flPrgInit & PRGINIT_AMBIGUOUSPIF)) {
                        goto FindDefault;
                    }
#ifdef DBCS
                    if (GetSystemDefaultLangID() == 0x0411) {
                        ZeroMemory(&env, sizeof(env));
                        StringCchCopyA(env.achBatchFile, ARRAYSIZE(env.achBatchFile), ImeBatchFile);
                        PifMgr_SetProperties(ppl, MAKELP(0,GROUP_ENV),
                                             &env, sizeof(env), SETPROPS_NONE);
                    }
#endif
                }
                }
            }
        }
    }

  Error:
    LocalFree(pszFullName);

    if (fError || !ppl->lpPIFData) {
        PifMgr_CloseProperties(ppl, 0);
        return 0;
    }

    // We should never leave PIFMGR with outstanding locks

    ASSERTTRUE(!ppl->cLocks);

    return ppl;
}


/** PifMgr_GetProperties - get property info by name
 *
 * INPUT
 *  hProps = handle to properties
 *  lpszGroup -> property group; may be one of the following:
 *      "WINDOWS 286 3.0"
 *      "WINDOWS 386 3.0"
 *      "WINDOWS VMM 4.0"
 *      "WINDOWS NT  3.1"
 *      "WINDOWS NT  4.0"
 *    or any other group name that is the name of a valid PIF extension;
 *    if NULL, then cbProps is a 0-based index of a named group, and lpProps
 *    must point to a 16-byte buffer to receive the name of the group (this
 *    enables the caller to enumerate the names of all the named groups)
 *  lpProps -> property group record to receive the data
 *  cbProps = size of property group record to get; if cbProps is zero
 *    and a named group is requested, lpProps is ignored, no data is copied,
 *    and the size of the group record is returned (this enables the caller
 *    to determine the size of a named group)
 *  flOpt = GETPROPS_RAWIO to perform raw file read (lpszGroup ignored)
 *
 *  Alternatively, if the high word (selector) of lpszGroup is 0, the low
 *  word must be a group ordinal (eg, GROUP_PRG, GROUP_TSK, etc)
 *
 * OUTPUT
 *  If the group is not found, or an error occurs, 0 is returned.
 *  Otherwise, the size of the group info transferred in bytes is returned.
 */

int WINAPI PifMgr_GetProperties(HANDLE hProps, LPCSTR lpszGroup, void *lpProps, int cbProps, UINT flOpt)
{
    int cb, i;
    void *lp;
    LPW386PIF30 lp386;
    LPWENHPIF40 lpenh;
    LPWNTPIF40 lpnt40;
    LPWNTPIF31 lpnt31;

    PPROPLINK ppl;
    FunctionName(PifMgr_GetProperties);

    cb = 0;

    if (!(ppl = ValidPropHandle(hProps)))
        return cb;

    // We should never enter PIFMGR with outstanding locks (we also call
    // here from *inside* PIFMGR, but none of those cases should require a
    // lock either)

    ASSERTTRUE(!ppl->cLocks);

    ppl->cLocks++;

    if (flOpt & GETPROPS_RAWIO) {
        if (ppl->flProp & PROP_RAWIO) {
            cb = min(ppl->cbPIFData, cbProps);
            hmemcpy(lpProps, ppl->lpPIFData, cb);
        }
        ppl->cLocks--;
        return cb;
    }

    if (!lpszGroup) {
        if (lpProps) {
            lp = GetGroupData(ppl, NULL, &cbProps, NULL);
            if (lp) {
                cb = cbProps;
                hmemcpy(lpProps, lp, PIFEXTSIGSIZE);
            }
        }
    }
    else if (IS_INTRESOURCE(lpszGroup) && lpProps) {

        // Special case: if GROUP_ICON, then do a nested call to
        // PifMgr_GetProperties to get GROUP_PRG data, then feed it to load
        // LoadPIFIcon, and finally return the hIcon, if any, to the user.

        if (LOWORD((DWORD_PTR) lpszGroup) == GROUP_ICON) {
            PPROPPRG pprg;
            PPROPNT40 pnt40 = (void *)LocalAlloc(LPTR, sizeof(PROPNT40));
            if ( pnt40 ) {
                pprg = (void *)LocalAlloc(LPTR, sizeof(PROPPRG));
                if (pprg) {
                    if ( PifMgr_GetProperties(ppl, MAKELP(0,GROUP_PRG), pprg, sizeof(PROPPRG), GETPROPS_NONE)
                          && PifMgr_GetProperties(ppl, MAKELP(0,GROUP_NT40), pnt40, sizeof(PROPNT40), GETPROPS_NONE) ) {
                        *(HICON *)lpProps = LoadPIFIcon(pprg, pnt40);
                        cb = 2;
                    }
                    EVAL(LocalFree(pprg) == NULL);
                }
                EVAL(LocalFree(pnt40) == NULL);
            }
        }
        else {
            lp386 = GetGroupData(ppl, szW386HDRSIG30, NULL, NULL);
            lpenh = GetGroupData(ppl, szWENHHDRSIG40, NULL, NULL);
            lpnt40 = GetGroupData(ppl, szWNTHDRSIG40, NULL, NULL);
            lpnt31  = GetGroupData(ppl, szWNTHDRSIG31, NULL, NULL);

            //
            // Fix anything from down-level PIF files.  Since this
            // is the first revision of the WENHPIF40 format, we
            // don't have anything to worry about (yet).
            //
            // Don't muck with PIF files from the future!
            //
            if (lpenh && lpenh->wInternalRevision != WENHPIF40_VERSION) {
                lpenh->wInternalRevision = WENHPIF40_VERSION;
                ppl->flProp |= PROP_DIRTY;

                //
                //  Old (pre-M7) PIFs did not zero-initialize the reserved
                //  fields of PIF files, so zero them out now.
                //
                lpenh->tskProp.wReserved1 = 0;
                lpenh->tskProp.wReserved2 = 0;
                lpenh->tskProp.wReserved3 = 0;
                lpenh->tskProp.wReserved4 = 0;
                lpenh->vidProp.wReserved1 = 0;
                lpenh->vidProp.wReserved2 = 0;
                lpenh->vidProp.wReserved3 = 0;
                lpenh->envProp.wMaxDPMI = 0;

                // Turn off bits that have been deleted during the development
                // cycle.
                lpenh->envProp.flEnv = 0;
                lpenh->envProp.flEnvInit = 0;
                if (lp386)
                    lp386->PfW386Flags &= ~0x00400000;
            }
            // End of "Remove this after M8"

            // Zero the input buffer first, so that the Get* functions
            // need not initialize every byte to obtain consistent results

            BZero(lpProps, cbProps);

            // The GetData functions CANNOT rely on either lp386 or lpenh

            i = LOWORD((DWORD_PTR) lpszGroup)-1;
            if (i >= 0 && i < ARRAYSIZE(afnGetData) && cbProps >= acbData[i]) {
                void *aDataPtrs[NUM_DATA_PTRS];

                aDataPtrs[ LP386_INDEX ] = (LPVOID)lp386;
                aDataPtrs[ LPENH_INDEX ] = (LPVOID)lpenh;
                aDataPtrs[ LPNT40_INDEX ] = (LPVOID)lpnt40;
                aDataPtrs[ LPNT31_INDEX ] = (LPVOID)lpnt31;

                cb = (afnGetData[i])(ppl, aDataPtrs, lpProps, cbProps, flOpt );
            }
        }
    }
    else if (NULL != (lp = GetGroupData(ppl, lpszGroup, &cb, NULL))) {
        if (lpProps && cbProps != 0) {
            cb = min(cb, cbProps);
            hmemcpy(lpProps, lp, cb);
        }
    }
    ppl->cLocks--;

#ifdef EXTENDED_DATA_SUPPORT

    // Note that for GETPROPS_EXTENDED, both the normal and extended
    // sections are returned, and that the return code reflects the success
    // or failure of reading the normal portion only.  We return both because
    // that's the most convenient thing to do for the caller.

    if (flOpt & GETPROPS_EXTENDED) {
        if (ppl->hVM) {
            WORD wGroup = EXT_GROUP_QUERY;
            if (!HIWORD(lpszGroup) && LOWORD(lpszGroup) <= MAX_GROUP)
                wGroup |= LOWORD(lpszGroup);
            GetSetExtendedData(ppl->hVM, wGroup, lpszGroup, lpProps);
        }
    }
#endif

    // We should never leave PIFMGR with outstanding locks (we also call
    // here from *inside* PIFMGR, but none of those cases should require a
    // lock either)

    ASSERTTRUE(!ppl->cLocks);

    return cb;
}


/** PifMgr_SetProperties - set property info by name
 *
 * INPUT
 *  hProps = handle to properties
 *  lpszGroup -> property group; may be one of the following:
 *      "WINDOWS 286 3.0"
 *      "WINDOWS 386 3.0"
 *      "WINDOWS PIF.400"
 *    or any other group name that is the name of a valid PIF extension
 *  lpProps -> property group record to copy the data from
 *  cbProps = size of property group record to set;  if cbProps is
 *    zero and lpszGroup is a group name, the group will be removed
 *  flOpt = SETPROPS_RAWIO to perform raw file write (lpszGroup ignored)
 *          SETPROPS_CACHE to cache changes until properties are closed
 *
 *  Alternatively, if the high word (selector) of lpszGroup is 0, the low
 *  word must be a group ordinal (eg, GROUP_PRG, GROUP_TSK, etc)
 *
 * OUTPUT
 *  If the group is not found, or an error occurs, 0 is returned.
 *  Otherwise, the size of the group info transferred in bytes is returned.
 */

int WINAPI PifMgr_SetProperties(HANDLE hProps, LPCSTR lpszGroup, void *lpProps, int cbProps, UINT flOpt)
{
    void *p = NULL;
    void *lp = NULL;
    LPW386PIF30 lp386;
    LPWENHPIF40 lpenh;
    LPWNTPIF40 lpnt40;
    LPWNTPIF31 lpnt31;
    int i, cb = 0;
    PPROPLINK ppl;

    FunctionName(PifMgr_SetProperties);

    // Can't set a NULL name (nor set-by-index)--causes squirlly behavior in RemoveGroupData
    if (!lpProps || !lpszGroup)
        return 0;

    ppl = ValidPropHandle(hProps);
    if (!ppl)
        return 0;

    // We should never enter PIFMGR with outstanding locks (we also call
    // here from *inside* PIFMGR, but none of those cases should require a
    // lock either)

    ASSERTTRUE(!ppl->cLocks);

    if (flOpt & SETPROPS_RAWIO) {
        if (ppl->flProp & PROP_RAWIO) {
            ppl->cLocks++;
            cb = min(ppl->cbPIFData, cbProps);
            if (IsBufferDifferent(ppl->lpPIFData, lpProps, cb)) {
                hmemcpy(ppl->lpPIFData, lpProps, cb);
                ppl->flProp |= PROP_DIRTY;
            }
            if (cb < ppl->cbPIFData)
                ppl->flProp |= PROP_DIRTY | PROP_TRUNCATE;
            ppl->cbPIFData = cb;
            ppl->cLocks--;
        }
        return cb;
    }

#ifdef EXTENDED_DATA_SUPPORT

    // Note that, unlike GETPROPS_EXTENDED, SETPROPS_EXTENDED only updates
    // the extended section, and that the return code reflects the existence
    // of a VM only.  This is because there's a performance hit associated
    // with setting the normal portion, and because the caller generally only
    // wants to set one or the other.

    if (flOpt & SETPROPS_EXTENDED) {
        if (ppl->hVM) {
            WORD wGroup = EXT_GROUP_UPDATE;
            cb = cbProps;
            if (!HIWORD(lpszGroup) && LOWORD(lpszGroup) <= MAX_GROUP)
                wGroup |= LOWORD(lpszGroup);
            GetSetExtendedData(ppl->hVM, wGroup, lpszGroup, lpProps);
        }
        return cb;
    }
#endif

    // For named groups, if the group does NOT exist, or DOES but is
    // a different size, then we have to remove the old data, if any, and
    // then add the new.

    if (!IS_INTRESOURCE(lpszGroup)) {

        cb = PifMgr_GetProperties(hProps, lpszGroup, NULL, 0, GETPROPS_NONE);

        if (cb == 0 || cb != cbProps) {
            if (cb) {
                RemoveGroupData(ppl, lpszGroup);
                cb = 0;
            }
            if (cbProps) {
                if (AddGroupData(ppl, lpszGroup, lpProps, cbProps))
                    cb = cbProps;
            }
            goto done;
        }
    }

    if (cbProps) {
        if (!lpszGroup)
            return cb;

        p = (void *)LocalAlloc(LPTR, cbProps);
        if (!p)
            return cb;
    }

    cb = PifMgr_GetProperties(hProps, lpszGroup, p, cbProps, GETPROPS_NONE);

    // If the group to set DOES exist, and if the data given is
    // different, copy into the appropriate group(s) in the PIF data

    if (cb != 0) {
        cbProps = min(cb, cbProps);
        if (IsBufferDifferent(p, lpProps, cbProps)) {
            cb = 0;
            ppl->cLocks++;
            i = LOWORD((DWORD_PTR) lpszGroup)-1;
            if (!IS_INTRESOURCE(lpszGroup)) {
                lp = GetGroupData(ppl, lpszGroup, NULL, NULL);
                if (lp) {
                    cb = cbProps;
                    hmemcpy(lp, lpProps, cbProps);
                    ppl->flProp |= PROP_DIRTY;
                }
            }
            else if (i >= 0 && i < ARRAYSIZE(afnSetData) && cbProps >= acbData[i]) {

                // Insure that both 386 and enhanced sections of PIF
                // file are present.  There are some exceptions:  all
                // groups from GROUP_MSE on up do not use the 386 section,
                // and GROUP_MEM does not need the enh section....

                lp386 = GetGroupData(ppl, szW386HDRSIG30, NULL, NULL);
                if (i < GROUP_MSE-1 && !lp386) {
                    if (AddGroupData(ppl, szW386HDRSIG30, NULL, sizeof(W386PIF30))) {
                        lp386 = GetGroupData(ppl, szW386HDRSIG30, NULL, NULL);
                        if (!lp386) {
                            ASSERTFAIL();
                            cbProps = 0;    // indicate error
                        }
                    }
                }
                if (cbProps) {
                    lpenh = GetGroupData(ppl, szWENHHDRSIG40, NULL, NULL);
                    if (i != GROUP_MEM-1 && !lpenh) {
                        if (!(lpenh = AddEnhancedData(ppl, lp386))) {
                            ASSERTFAIL();
                            cbProps = 0;    // indicate error
                        }
                    }
                    lpnt40 = GetGroupData(ppl, szWNTHDRSIG40, NULL, NULL);
                    if (!lpnt40)
                    {
                        if (AddGroupData(ppl, szWNTHDRSIG40, NULL, sizeof(WNTPIF40)))
                        {
                            lpnt40 = GetGroupData(ppl, szWNTHDRSIG40, NULL, NULL);
                        }
                    }
                    ASSERT(lpnt40);

                    lpnt31 = GetGroupData(ppl, szWNTHDRSIG31, NULL, NULL);
                    if (!lpnt31)
                    {
                        if (AddGroupData(ppl, szWNTHDRSIG31, NULL, sizeof(WNTPIF31)))
                        {
                            if (NULL != (lpnt31 = GetGroupData(ppl, szWNTHDRSIG31, NULL, NULL))) {
                                StringCchCopyA( lpnt31->nt31Prop.achConfigFile, ARRAYSIZE(lpnt31->nt31Prop.achConfigFile), NT_CONFIG_FILE );
                                StringCchCopyA( lpnt31->nt31Prop.achAutoexecFile, ARRAYSIZE(lpnt31->nt31Prop.achAutoexecFile), NT_AUTOEXEC_FILE );
                            }
                        }
                    }
                    ASSERT(lpnt31);
                }
                if (cbProps)
                {

                    void *aDataPtrs[NUM_DATA_PTRS];

                    //
                    // We need to re-establish the pointers because any of
                    // the AddGroupData's could have moved the block (via
                    // a HeapReAlloc call), so do that now...
                    //

                    lp386 = GetGroupData( ppl, szW386HDRSIG30, NULL, NULL );
                    lpenh = GetGroupData( ppl, szWENHHDRSIG40, NULL, NULL );
                    lpnt40 = GetGroupData( ppl, szWNTHDRSIG40, NULL, NULL );
                    lpnt31 = GetGroupData( ppl, szWNTHDRSIG31, NULL, NULL );

                    aDataPtrs[ LP386_INDEX ] = (LPVOID)lp386;
                    aDataPtrs[ LPENH_INDEX ] = (LPVOID)lpenh;
                    aDataPtrs[ LPNT40_INDEX ] = (LPVOID)lpnt40;
                    aDataPtrs[ LPNT31_INDEX ] = (LPVOID)lpnt31;
                    cb = (afnSetData[i])(ppl, aDataPtrs, lpProps, cbProps, flOpt );
                }
            }
            ppl->cLocks--;
        }
    }
    EVAL(LocalFree(p) == NULL);

  done:
    if (!(flOpt & SETPROPS_CACHE))
        if (!FlushPIFData(ppl, FALSE))
            cb = 0;

    // We should never leave PIFMGR with outstanding locks (we also call
    // here from *inside* PIFMGR, but none of those cases should require a
    // lock either)

    ASSERTTRUE(!ppl->cLocks);

    return cb;
}


/** EnumProperties - enumerate open properties
 *
 * INPUT
 *  hProps = handle to previous properties (NULL to start)
 *
 * OUTPUT
 *  next property handle, 0 if none
 */

HANDLE WINAPI EnumProperties(HANDLE hProps)
{
    PPROPLINK ppl;
    FunctionName(EnumProperties);

    if (!hProps)
        return g_pplHead;

    if (!(ppl = ValidPropHandle(hProps)))
        return NULL;

    return ppl->pplNext;
}


/** PifMgr_CloseProperties - close property info for application
 *
 * INPUT
 *  hProps = handle to properties
 *  flOpt = CLOSEPROPS_DISCARD to abandon cached PIF data, otherwise save it
 *
 * OUTPUT
 *  NULL if successful, otherwise hProps is returned as given
 */

HANDLE WINAPI PifMgr_CloseProperties(HANDLE hProps, UINT flOpt)
{
    PPROPLINK ppl;
    FunctionName(PifMgr_CloseProperties);

    if (!(ppl = ValidPropHandle(hProps)))
        return hProps;

    // When discarding on a close, set the SKIPPIF flag, so that the
    // flush code won't say "oh, not only should I throw away my current
    // set of data, but I should read in clean data" -- new data is no use
    // since the caller is closing.

    if (flOpt & CLOSEPROPS_DISCARD)
        ppl->flProp |= PROP_SKIPPIF;

    if (ppl->flProp & PROP_DIRTY) {     // this redundant check added
                                        // to avoid making FlushPIFData PRELOAD -JTP

        // Note that we avoid calling FlushPIFData if INHIBITPIF is set,
        // since FlushPIFData will just return a fake TRUE result anyway.
        // But we don't want to be fooled, we want to make sure the block
        // gets unlocked now.

        if ((ppl->flProp & PROP_INHIBITPIF) || !FlushPIFData(ppl, (flOpt & CLOSEPROPS_DISCARD))) {

            // If FlushPIFData failed, then if we still have an outstanding
            // dirty lock, force the data to become unlocked, by clearing the
            // dirty flag in the middle of a pair otherwise pointless lock/unlock
            // calls (because that's the nice, clean way to do it!)

            if (ppl->flProp & PROP_DIRTYLOCK) {
                ppl->cLocks++;
                ppl->flProp &= ~PROP_DIRTY;
                ppl->cLocks--;
            }
        }
    }

    if (ppl->lpPIFData) {
        LocalFree(ppl->lpPIFData);
        ppl->lpPIFData = NULL;
    }

    if (ppl->hPIF != INVALID_HANDLE_VALUE)
        CloseHandle(ppl->hPIF);

    // Unlink from the global list

    if (ppl->pplPrev)
        ppl->pplPrev->pplNext = ppl->pplNext;
    else
        g_pplHead = ppl->pplNext;

    if (ppl->pplNext)
        ppl->pplNext->pplPrev = ppl->pplPrev;

    LocalFree(ppl);
    return NULL;
}


/** ValidPropHandle - verify handle
 *
 * INPUT
 *  hProps = handle to properties
 *
 * OUTPUT
 *  pointer to prop, NULL otherwise
 */

PPROPLINK ValidPropHandle(HANDLE hProps)
{
    FunctionName(ValidPropHandle);
    if (!hProps ||
        (HANDLE)hProps > g_offHighestPropLink ||
        ((PPROPLINK)hProps)->iSig != PROP_SIG) {
        ASSERTFAIL();
        return NULL;
    }
    return (PPROPLINK)hProps;
}


/** ResizePIFData - verify handle and resize PIF data
 *
 * INPUT
 *  ppl -> property
 *  cbResize = bytes to resize PIF data by
 *
 * OUTPUT
 *  previous size of PIF data if successful, -1 if not
 *
 *  on success, the PIF data is returned LOCKED, so successful
 *  ResizePIFData calls should be matched with UnlockPIFData calls.
 */

int ResizePIFData(PPROPLINK ppl, INT cbResize)
{
    INT cbOld, cbNew;
    void *lpNew;
    BOOL fInitStdHdr = FALSE;
    FunctionName(ResizePIFData);

    ASSERTTRUE(cbResize != 0);

    // Cope with empty or old PIF files

    cbOld = ppl->cbPIFData;
    cbNew = ppl->cbPIFData + cbResize;

    if ((cbNew < cbOld) == (cbResize > 0))
        return -1;      // underflow/overflow

    if (!ppl->lpPIFData && cbOld == 0) {
        if (cbNew >= sizeof(STDPIF) + sizeof(PIFEXTHDR))
            fInitStdHdr = TRUE;
        lpNew = LocalAlloc(LPTR, cbNew);
    }
    else
    {

        if (cbOld == sizeof(STDPIF))
        {
            fInitStdHdr = TRUE;
            cbOld += sizeof(PIFEXTHDR);
            cbNew += sizeof(PIFEXTHDR);
        }

        lpNew = LocalReAlloc( ppl->lpPIFData, cbNew, LMEM_MOVEABLE|LMEM_ZEROINIT);

    }

    if (lpNew) {
        ppl->cbPIFData = cbNew;
        ppl->lpPIFData = (LPPIFDATA)lpNew;
        ppl->cLocks++;
        if (fInitStdHdr) {
            StringCchCopyA(ppl->lpPIFData->stdpifext.extsig, ARRAYSIZE(ppl->lpPIFData->stdpifext.extsig), szSTDHDRSIG);
            ppl->lpPIFData->stdpifext.extnxthdrfloff = LASTHDRPTR;
            ppl->lpPIFData->stdpifext.extfileoffset = 0x0000;
            ppl->lpPIFData->stdpifext.extsizebytes = sizeof(STDPIF);
        }
        return cbOld;
    }
    return -1;
}



/** GetPIFData - read PIF data back from PIF
 *
 * INPUT
 *  ppl -> property
 *  fLocked == TRUE to return data locked, FALSE unlocked
 *
 * OUTPUT
 *  TRUE if succeeded, FALSE if not
 */

BOOL GetPIFData(PPROPLINK ppl, BOOL fLocked)
{
    DWORD dwOff;
    LPTSTR pszOpen;
    BOOL fSuccess = FALSE;
    FunctionName(GetPIFData);

    // Since we're going to (re)load the property data now, reset
    // the current size, so that ResizePIFData will resize it from zero

    ppl->cbPIFData = 0;

    // If SKIPPIF is set (eg, by PifMgr_OpenProperties), then don't
    // try to open anything (since PifMgr_OpenProperties already tried!),

    if (ppl->hPIF == INVALID_HANDLE_VALUE && !(ppl->flProp & PROP_SKIPPIF)) {
        pszOpen = g_szDefaultPIF;
        if (!(ppl->flProp & PROP_DEFAULTPIF))
            pszOpen = ppl->ofPIF.szPathName;
        ppl->hPIF = CreateFile( pszOpen,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );
    }
    if (ppl->hPIF == INVALID_HANDLE_VALUE) {

        // The following warning is disabled because the presence of
        // the dialog box got WINOLDAP stuck in an infinite message loop -JTP

        InitProperties(ppl, fLocked);
        goto Exit;
    }
    dwOff = SetFilePointer(ppl->hPIF, 0, NULL, FILE_END);
    if (dwOff >= sizeof(STDPIF)) {

        ppl->flProp |= PROP_REGEN;

        if (ResizePIFData(ppl, dwOff) != -1) {

            SetFilePointer(ppl->hPIF, 0, NULL, FILE_BEGIN);
          
            if (ReadFile( ppl->hPIF, ppl->lpPIFData,
                         ppl->cbPIFData, &ppl->cbPIFData, NULL ))
            {

                // Can't be dirty anymore, 'cause we just read the PIF back in

                ppl->flProp &= ~PROP_DIRTY;

                if (ppl->flProp & PROP_DEFAULTPIF) {

                    WideCharToMultiByte( CP_ACP, 0,
                                         ppl->szPathName+ppl->iFileName,
                                         -1,
                                         ppl->lpPIFData->stdpifdata.appname,
                                         ARRAYSIZE(ppl->lpPIFData->stdpifdata.appname),
                                         NULL, NULL
                                        );

                    PifMgr_WCtoMBPath( ppl->szPathName,
                                       ppl->lpPIFData->stdpifdata.startfile,
                                       ARRAYSIZE(ppl->lpPIFData->stdpifdata.startfile)
                                      );
                    // I don't think this is generally worth dirtying the
                    // property info for, because otherwise every app that used
                    // _DEFAULT.PIF initially would get its own PIF file created
                    // later;  PIF file creation should only take place when
                    // substantive changes have been made

                    // ppl->flProp |= PROP_DIRTY;
                }

                // If we're not dealing with an enhanced PIF, then we
                // go to the various INI files to retrieve DOS app defaults

                if (!GetGroupData(ppl, szWENHHDRSIG40, NULL, NULL)) {
                    GetINIData();
                }

                // If we're not dealing with a new NT/UNICODE PIF, then
                // we add a new section so it's ALWAYS there when we're
                // UNICODE enabled.

                if (!GetGroupData(ppl, szWNTHDRSIG40, NULL, NULL)) {
                    VERIFYTRUE(AddGroupData(ppl, szWNTHDRSIG40, NULL, sizeof(WNTPIF40)));
                }
                // If we're not dealing with a NT PIF, then
                // we add the NT sections so it's ALWAYS there when we're
                // running on NT.

                if (!GetGroupData(ppl, szWNTHDRSIG31, NULL, NULL)) {
                    LPWNTPIF31 lpnt31;

                    VERIFYTRUE(AddGroupData(ppl, szWNTHDRSIG31, NULL, sizeof(WNTPIF31)));
                    if (NULL != (lpnt31 = GetGroupData(ppl, szWNTHDRSIG31, NULL, NULL))) {
                        StringCchCopyA( lpnt31->nt31Prop.achConfigFile, ARRAYSIZE(lpnt31->nt31Prop.achConfigFile), NT_CONFIG_FILE );
                        StringCchCopyA( lpnt31->nt31Prop.achAutoexecFile, ARRAYSIZE(lpnt31->nt31Prop.achAutoexecFile), NT_AUTOEXEC_FILE );
                    }
                }

                if (!fLocked)
                    ppl->cLocks--;  // UnlockPIFData(ppl);
                fSuccess++;
            }
        }
        else
            ASSERTFAIL();

        ppl->flProp &= ~PROP_REGEN;
    }
    CloseHandle(ppl->hPIF);
    ppl->hPIF = INVALID_HANDLE_VALUE;

    // As long as IGNOREPIF isn't set, clear SKIPPIF, because even if we
    // already knew the PIF didn't exist on *this* call, one may be created
    // (by someone else) by the next time we're called

  Exit:
    if (!(ppl->flProp & PROP_IGNOREPIF))
        ppl->flProp &= ~PROP_SKIPPIF;
    return fSuccess;
}


/** FlushPIFData - write dirty PIF data back to PIF
 *
 * INPUT
 *  ppl -> property
 *  fDiscard == TRUE to discard dirty data, FALSE to keep it
 *
 * OUTPUT
 *  TRUE if succeeded, FALSE if not
 *
 * NOTES
 *  We must first check the PROPLINK and see if the DONTWRITE bit has
 *  been set, in which case we have to fail the flush.  Once DONTWRITE is
 *  set in a PROPLINK, it will never be cleared, unless the caller
 *  specifies fDiscard == TRUE to reload the data.  This is BY DESIGN (ie,
 *  a UI compromise).  How does DONTWRITE get set?  By someone else
 *  having previously (and successfully) done a flush to the same PIF; at
 *  that point in time, we will look for all other properties that refer to
 *  the same file, and set their DONTWRITE bit.  What about PROPLINKs that
 *  are created later?  They're ok, they don't get DONTWRITE set until
 *  the above sequence takes place during their lifetime.
 */

BOOL FlushPIFData(PPROPLINK ppl, BOOL fDiscard)
{
    UINT u;
    BOOL fSuccess = FALSE;
    FunctionName(FlushPIFData);

    // If nothing dirty, nothing to do

    if (!(ppl->flProp & PROP_DIRTY) || (ppl->flProp & PROP_INHIBITPIF))
        return TRUE;            // ie, success

    // If discarding, then clear PROP_DIRTY and reload the data

    if (fDiscard) {
        ppl->flProp &= ~(PROP_DIRTY | PROP_DONTWRITE);
        return GetPIFData(ppl, FALSE);
    }

    if (ppl->flProp & PROP_DONTWRITE)
        return fSuccess;        // ie, FALSE (error)

    if (!ppl->lpPIFData)
        return fSuccess;        // ie, FALSE (error)

    ppl->cLocks++;

    // If we created properties without opening a file, it may have
    // been because normal PIF search processing was overridden by the
    // presence of a WIN.INI entry;  if that entry is still there,
    // then our data is not in sync with any existing file, nor is there
    // any point in creating a new file as long as that entry exists.  We
    // need to consider prompting the user as to whether he really wants
    // that WIN.INI entry, so that it's clear what the heck is going on

    if (ppl->flProp & PROP_IGNOREPIF) {

        HANDLE hProps;

        ppl->ckbMem = GetProfileInt(apszAppType[APPTYPE_PIF]+1, ppl->szPathName+ppl->iFileName, -1);
        if (ppl->ckbMem != -1)
            goto Exit;

        // The WIN.INI entry apparently went away, so let's re-attempt to
        // open the properties that we should have obtained in the first
        // place.  Assuming success, we will copy our entire block on top of
        // them (thereby flushing it), and also copy their PIF name to our
        // PIF name and their PIF flags to our PIF flags, so that future
        // flushes are of the more normal variety

        hProps = PifMgr_OpenProperties(ppl->ofPIF.szPathName, NULL, 0, OPENPROPS_RAWIO);
        if (hProps) {
            ppl->flProp &= ~(PROP_IGNOREPIF | PROP_SKIPPIF);
            ppl->flProp |= ((PPROPLINK)hProps)->flProp & (PROP_IGNOREPIF | PROP_SKIPPIF);
            StringCchCopy(ppl->ofPIF.szPathName, ARRAYSIZE(ppl->ofPIF.szPathName), ((PPROPLINK)hProps)->ofPIF.szPathName);
            if (PifMgr_SetProperties(hProps, NULL, ppl->lpPIFData, ppl->cbPIFData, SETPROPS_RAWIO) == ppl->cbPIFData) {
                fSuccess++;
                ppl->flProp &= ~(PROP_DIRTY | PROP_TRUNCATE);
            }
            PifMgr_CloseProperties(hProps, CLOSEPROPS_NONE);
        }
        goto Exit;
    }

    // Disable annoying critical error popups (NO MORE GOTOS PAST HERE PLEASE)

    u = SetErrorMode(SEM_FAILCRITICALERRORS);

    ppl->hPIF = CreateFile( ppl->ofPIF.szPathName,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

    // If we couldn't open the file, then the presumption is that the
    // app didn't have a PIF (or did but someone but someone deleted it),
    // and so we use the name we constructed during PifMgr_OpenProperties in case
    // they ever opted to save new settings (which they obviously have done!)

    // 28-Feb-95: If the PIF did exist at one time (meaning NOCREATPIF is
    // set), then don't recreate it;  somebody's trying to delete their own
    // PIF, so let them. -JTP

    if ((ppl->hPIF != INVALID_HANDLE_VALUE) && (GetLastError()!=ERROR_FILE_EXISTS)) {

        if (!(ppl->flProp & PROP_NOCREATEPIF))
            SetFilePointer( ppl->hPIF, 0, NULL, FILE_BEGIN );

        // If the create succeeded, we're no longer using the default PIF

        if (ppl->hPIF != INVALID_HANDLE_VALUE) {

            ppl->flProp |= PROP_NOCREATEPIF;

            ppl->flProp &= ~(PROP_TRUNCATE | PROP_NOPIF | PROP_DEFAULTPIF);
        }
    }

    // If either the open or the create succeeded, write the PIF data out now

    if (ppl->hPIF != INVALID_HANDLE_VALUE) {

        PPROPLINK pplEnum;
        DWORD dwDummy;

        WriteFile( ppl->hPIF, (LPCVOID)ppl->lpPIFData,
                   ppl->cbPIFData, &dwDummy, NULL );
        if (ppl->flProp & PROP_TRUNCATE)
            WriteFile(ppl->hPIF, (LPCVOID)ppl->lpPIFData, 0, &dwDummy, NULL );
        CloseHandle(ppl->hPIF);
        ppl->hPIF = INVALID_HANDLE_VALUE;
        ppl->flProp &= ~(PROP_DIRTY | PROP_TRUNCATE);
        fSuccess++;

        // Here's where we want to check for other active PROPLINKs using the
        // same PIF.  For each one found, set its DONTWRITE bit.

        pplEnum = NULL;
        while (NULL != (pplEnum = (PPROPLINK)EnumProperties(pplEnum))) {
            if (lstrcmpi(ppl->ofPIF.szPathName, pplEnum->ofPIF.szPathName) == 0) {
                if (pplEnum != ppl)
                    pplEnum->flProp |= PROP_DONTWRITE;
            }
        }
    }

    // Re-enable annoying critical error popups

    SetErrorMode(u);

  Exit:
    ppl->cLocks--;
    return fSuccess;
}


/** AddEnhancedData - create enhanced section(s) of PIF data
 *
 * INPUT
 *  ppl -> property
 *
 * OUTPUT
 *  lpenh or NULL
 */

LPWENHPIF40 AddEnhancedData(PPROPLINK ppl, LPW386PIF30 lp386)
{
    PROPPRG prg;
    PROPTSK tsk;
    PROPVID vid;
    PROPKBD kbd;
    PROPMSE mse;
    PROPFNT fnt;
    PROPWIN win;
    PROPENV env;
    void *aDataPtrs[NUM_DATA_PTRS];
    LPWENHPIF40 lpenh = NULL;

    FunctionName(AddEnhancedData);

    // Get copies of pre-enhanced and/or default settings first,
    // and do them all *before* doing the AddGroupData, because the
    // functions' behavior will change once the enhanced section is added;

    // in addition, zero those strucs that contain strings, since lstrcpy()
    // may initialize a minimum of 1 byte, leaving garbage in the rest.

    BZero(&prg, sizeof(prg));
    BZero(&fnt, sizeof(fnt));
    BZero(&win, sizeof(win));
    BZero(&env, sizeof(env));
    BZero(aDataPtrs, sizeof(aDataPtrs));

    aDataPtrs[ LP386_INDEX ] = (LPVOID)lp386;
    GetPrgData(ppl, aDataPtrs, &prg, sizeof(prg), GETPROPS_NONE);
    GetTskData(ppl, aDataPtrs, &tsk, sizeof(tsk), GETPROPS_NONE);
    GetVidData(ppl, aDataPtrs, &vid, sizeof(vid), GETPROPS_NONE);
    GetKbdData(ppl, aDataPtrs, &kbd, sizeof(kbd), GETPROPS_NONE);
    GetMseData(ppl, aDataPtrs, &mse, sizeof(mse), GETPROPS_NONE);
    GetFntData(ppl, aDataPtrs, &fnt, sizeof(fnt), GETPROPS_NONE);
    GetWinData(ppl, aDataPtrs, &win, sizeof(win), GETPROPS_NONE);
    GetEnvData(ppl, aDataPtrs, &env, sizeof(env), GETPROPS_NONE);


    if (AddGroupData(ppl, szWENHHDRSIG40, NULL, sizeof(WENHPIF40))) {

        if (NULL != (lpenh = GetGroupData(ppl, szWENHHDRSIG40, NULL, NULL))) {

            lpenh->dwEnhModeFlagsProp = prg.dwEnhModeFlags;
            lpenh->dwRealModeFlagsProp = prg.dwRealModeFlags;
            StringCchCopyA(lpenh->achOtherFileProp, ARRAYSIZE(lpenh->achOtherFileProp), prg.achOtherFile);
            StringCchCopyA(lpenh->achIconFileProp, ARRAYSIZE(lpenh->achIconFileProp), prg.achIconFile);
            lpenh->wIconIndexProp = prg.wIconIndex;
            lpenh->tskProp = tsk;
            lpenh->vidProp = vid;
            lpenh->kbdProp = kbd;
            lpenh->mseProp = mse;
            lpenh->fntProp = fnt;
            lpenh->winProp = win;
            lpenh->envProp = env;
            lpenh->wInternalRevision = WENHPIF40_VERSION;
        }
    }
    return lpenh;
}


/** AddGroupData - add NEW property group to PIF data
 *
 * INPUT
 *  ppl -> property
 *  lpszGroup -> name of new group
 *  lpGroup -> new group record (if NULL, then group data is zero-filled)
 *  cbGroup == size of new group record
 *
 * OUTPUT
 *  TRUE if successful, FALSE if not
 */

BOOL AddGroupData(PPROPLINK ppl, LPCSTR lpszGroup, LPCVOID lpGroup, int cbGroup)
{
    INT cbOld;
    LPPIFEXTHDR lpph;
    FunctionName(AddGroupData);

    if ((cbOld = ResizePIFData(ppl, cbGroup+sizeof(PIFEXTHDR))) != -1) {

        lpph = (LPPIFEXTHDR)LPPIF_FIELDOFF(stdpifext);

        while ((DWORD_PTR)lpph <= (DWORD_PTR)LPPIF_OFF(cbOld - sizeof(PIFEXTHDR)) &&
               (DWORD_PTR)lpph >= (DWORD_PTR)LPPIF_FIELDOFF(stdpifext)) {

            if (lpph->extnxthdrfloff == LASTHDRPTR) {
                lpph->extnxthdrfloff = (WORD) cbOld;
                lpph = (LPPIFEXTHDR)LPPIF_OFF(cbOld);
                StringCchCopyA(lpph->extsig, ARRAYSIZE(lpph->extsig), lpszGroup);
                lpph->extnxthdrfloff = LASTHDRPTR;
                lpph->extfileoffset = (INT)(cbOld + sizeof(PIFEXTHDR));
                lpph->extsizebytes = (WORD) cbGroup;
                if (lpGroup) {
                    hmemcpy((LPBYTE)LPPH_OFF(sizeof(PIFEXTHDR)), lpGroup, cbGroup);
                    ppl->flProp |= PROP_DIRTY;
                }
                break;
            }
            lpph = (LPPIFEXTHDR)LPPIF_OFF(lpph->extnxthdrfloff);
        }
        ppl->cLocks--;
        return TRUE;
    }
    ASSERTFAIL();
    return FALSE;
}


/** RemoveGroupData - remove EXISTING property group from PIF data
 *
 * INPUT
 *  ppl -> property
 *  lpszGroup -> name of group
 *
 * OUTPUT
 *  TRUE if successful, FALSE if not
 */

BOOL RemoveGroupData(PPROPLINK ppl, LPCSTR lpszGroup)
{
    INT cbGroup, fSuccess;
    LPBYTE lpGroup;
    WORD extnxthdrfloff;
    LPPIFEXTHDR lpph, lpphGroup;
    FunctionName(RemoveGroupData);

    ppl->cLocks++;

    fSuccess = FALSE;
    if (NULL != (lpGroup = GetGroupData(ppl, lpszGroup, &cbGroup, &lpphGroup))) {

        // Removing groups is a bit tedious, so here goes....

        // First, we will walk all the headers, attempting to find the
        // one that points to the one we're about to remove, and point it
        // to the next one, and at the same time adjust all file offsets that
        // equal or exceed the offsets of either the outgoing data or its
        // header.

        lpph = (LPPIFEXTHDR)LPPIF_FIELDOFF(stdpifext);

        while ((DWORD_PTR)lpph <= (DWORD_PTR)LPPIF_OFF(ppl->cbPIFData - sizeof(PIFEXTHDR)) &&
               (DWORD_PTR)lpph >= (DWORD_PTR)LPPIF_FIELDOFF(stdpifext)) {

            extnxthdrfloff = lpph->extnxthdrfloff;

            if ((DWORD_PTR)LPPH_OFF(lpph->extfileoffset) >= (DWORD_PTR)lpGroup)
                lpph->extfileoffset -= (WORD) cbGroup;

            if (lpphGroup) {
                if ((DWORD_PTR)LPPH_OFF(lpph->extfileoffset) >= (DWORD_PTR)lpphGroup)
                    lpph->extfileoffset -= sizeof(PIFEXTHDR);
                if ((DWORD_PTR)LPPH_OFF(lpph->extnxthdrfloff) == (DWORD_PTR)lpphGroup)
                    extnxthdrfloff = lpph->extnxthdrfloff = lpphGroup->extnxthdrfloff;
            }
            if (extnxthdrfloff == LASTHDRPTR)
                break;

            if ((DWORD_PTR)LPPH_OFF(lpph->extnxthdrfloff) >= (DWORD_PTR)lpGroup)
                lpph->extnxthdrfloff -= (WORD) cbGroup;

            if (lpphGroup)
                if ((DWORD_PTR)LPPH_OFF(lpph->extnxthdrfloff) >= (DWORD_PTR)lpphGroup)
                    lpph->extnxthdrfloff -= sizeof(PIFEXTHDR);

            lpph = (LPPIFEXTHDR)LPPIF_OFF(extnxthdrfloff);
        }

        // Next, move everything up over the data, then adjust lpph as
        // needed and move everything up over the header (this must be done
        // in two discrete steps, because we shouldn't assume anything
        // about the data's location relative to its header).

        hmemcpy(lpGroup, (LPBYTE)lpGroup+cbGroup,
                (DWORD_PTR)LPPIF_OFF(ppl->cbPIFData) - (DWORD_PTR)((LPBYTE)lpGroup+cbGroup));

        if (lpphGroup) {

            if ((DWORD_PTR)lpphGroup >= (DWORD_PTR)((LPBYTE)lpGroup+cbGroup))
                lpphGroup -= cbGroup;

            hmemcpy(lpphGroup, lpphGroup+1,
                    (DWORD_PTR)LPPIF_OFF(ppl->cbPIFData) - (DWORD_PTR)((LPBYTE)lpphGroup+1+cbGroup));

            cbGroup += sizeof(PIFEXTHDR);
        }
        ResizePIFData(ppl, -cbGroup);
        ppl->flProp |= PROP_DIRTY | PROP_TRUNCATE;
        ppl->cLocks--;
    }
    ppl->cLocks--;
    return fSuccess;
}


/** GetGroupData - get ptr to property group (by name)
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lpszGroup -> property group; may be one of the following:
 *      "WINDOWS 286 3.0"
 *      "WINDOWS 386 3.0"
 *      "WINDOWS PIF.400"
 *    or any other group name that is the name of a valid PIF extension.
 *    if NULL, then *lpcbGroup is a 0-based index of the group we are looking for
 *  lpcbGroup -> where to return size of group data (NULL if not)
 *  lplpph -> where to return ptr to pif extension header, if any (NULL if not)
 *
 * OUTPUT
 *  Returns ptr to property group info, NULL if not found
 */

void *GetGroupData(PPROPLINK ppl, LPCSTR lpszGroup,
                    LPINT lpcbGroup, LPPIFEXTHDR *lplpph)
{
    LPPIFEXTHDR lpph;
    FunctionName(GetGroupData);

    if (!ppl->lpPIFData)
        return NULL;

    lpph = (LPPIFEXTHDR)LPPIF_FIELDOFF(stdpifext);

    while ((DWORD_PTR)lpph <= (DWORD_PTR)LPPIF_OFF(ppl->cbPIFData-sizeof(PIFEXTHDR)) &&
           (DWORD_PTR)lpph >= (DWORD_PTR)LPPIF_FIELDOFF(stdpifext))
    {
        if (!lpszGroup) {
            // searching by index *lpcbGroup
            if (!(*lpcbGroup)--) {
                if (lplpph)
                    *lplpph = lpph;
                *lpcbGroup = lpph->extsizebytes;
                return lpph;
            }
        }
        else {
            CHAR szTmpSig[ARRAYSIZE(lpph->extsig)];

            // protect against non null-terminated extsig field
            ZeroMemory(szTmpSig, sizeof(szTmpSig));
            StringCchCopyA(szTmpSig, ARRAYSIZE(szTmpSig), lpph->extsig);

            // PIFEDIT 3.x can trash the first byte of our extended portion
            // (generally with a zero), so try to recover by stuffing the first
            // character of the group we're looking for into the signature;
            // if the rest of the signature matches, great, if it doesn't, then
            // re-zero it.
            if (!szTmpSig[0])      // attempt to fix
                szTmpSig[0] = *lpszGroup;

            if (lstrcmpiA(szTmpSig, lpszGroup) == 0) {
                if (lplpph)
                    *lplpph = lpph;
                if (lpcbGroup)
                    *lpcbGroup = lpph->extsizebytes;
                if (lpph->extfileoffset >= (WORD)ppl->cbPIFData) {
                    ASSERTFAIL();
                    return NULL;
                }
                return (LPBYTE)LPPIF_OFF(lpph->extfileoffset);
            }
        }
        if (lpph->extnxthdrfloff == LASTHDRPTR)
            break;
        lpph = (LPPIFEXTHDR)LPPIF_OFF(lpph->extnxthdrfloff);
    }

    // If we didn't get anywhere, check if this is a "really old" PIF;
    // ie, one without any headers;  if so, then if all they were asking for
    // was the old stuff, return it

    if (ppl->cbPIFData == sizeof(STDPIF) && lpszGroup) {
        if (lstrcmpiA(szSTDHDRSIG, lpszGroup) == 0) {
            if (lplpph)
                *lplpph = NULL;
            if (lpcbGroup)
                *lpcbGroup = sizeof(STDPIF);
            return ppl->lpPIFData;
        }
    }
    return NULL;
}

/** AppWizard - call the AppWizard CPL (appwiz.cpl)
 */



TCHAR c_szAPPWIZ[]    = TEXT("appwiz.cpl");
CHAR  c_szAppWizard[] = "AppWizard";

typedef DWORD (WINAPI *LPAPPWIZARD)(HWND hwnd, HANDLE i, UINT ui);

UINT WINAPI AppWizard(HWND hwnd, HANDLE hProps, UINT action)
{
    DWORD err = 42;
    LPAPPWIZARD XAppWizard;
    HINSTANCE hAppWizard;

    hAppWizard = LoadLibrary(c_szAPPWIZ);

    if (hAppWizard)
    {
        if (NULL != (XAppWizard = (LPAPPWIZARD)GetProcAddress(hAppWizard, c_szAppWizard)))
        {
            err = XAppWizard( hwnd, hProps, action );
        }
        FreeLibrary((HINSTANCE)hAppWizard);
    }

    return (UINT)err;
}

#else // X86
// IA64 stubs go here
HANDLE WINAPI PifMgr_OpenProperties(LPCTSTR lpszApp, LPCTSTR lpszPIF, UINT hInf, UINT flOpt)
{
    return NULL;
}
int WINAPI PifMgr_GetProperties(HANDLE hProps, LPCSTR lpszGroup, void *lpProps, int cbProps, UINT flOpt)
{
    return 0;
}
int WINAPI PifMgr_SetProperties(HANDLE hProps, LPCSTR lpszGroup, void *lpProps, int cbProps, UINT flOpt)
{
    return 0;
}
HANDLE WINAPI PifMgr_CloseProperties(HANDLE hProps, UINT flOpt)
{
    return hProps; // defined error value is to return hProps
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\pifprg.c ===
// Created 04-Jan-1993 1:10pm by Jeff Parsons

#include "shellprv.h"
#pragma hdrstop

#ifdef _X86_

BINF abinfPrg[] = {
    {IDC_CLOSEONEXIT,   BITNUM(PRG_CLOSEONEXIT)},
};

//  Per-Dialog data

typedef struct PRGINFO {     /* pi */
    PPROPLINK ppl;
    HICON     hIcon;
    TCHAR     atchIconFile[PIFDEFFILESIZE];
    WORD      wIconIndex;
    LPVOID    hConfig;
    LPVOID    hAutoexec;
    WORD      flPrgInitPrev;
    BOOL      fCfgSetByWiz;
} PRGINFO;
typedef PRGINFO * PPRGINFO;     /* ppi */


//  Private function prototypes

void            InitPrgDlg(HWND hDlg, PPRGINFO ppi);
void            AdjustMSDOSModeControls(PPROPLINK ppl, HWND hDlg);
void            ApplyPrgDlg(HWND hDlg, PPRGINFO ppi);
void            BrowseIcons(HWND hDlg, PPRGINFO ppi);

BOOL_PTR CALLBACK   DlgPifNtProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
WORD            InitNtPifDlg(HWND hDlg, register PPRGINFO ppi);
void            ApplyNtPifDlg( HWND hDlg, PPRGINFO ppi );

// Context-sensitive help ids

const static DWORD rgdwHelp[] = {
    IDC_ICONBMP,        IDH_DOS_PROGRAM_ICON,
    IDC_TITLE,          IDH_DOS_PROGRAM_DESCRIPTION,
    IDC_CMDLINE,        IDH_DOS_PROGRAM_CMD_LINE,
    IDC_CMDLINELBL,     IDH_DOS_PROGRAM_CMD_LINE,
    IDC_WORKDIR,        IDH_DOS_PROGRAM_WORKDIR,
    IDC_WORKDIRLBL,     IDH_DOS_PROGRAM_WORKDIR,
    IDC_HOTKEY,         IDH_DOS_PROGRAM_SHORTCUT,
    IDC_HOTKEYLBL,      IDH_DOS_PROGRAM_SHORTCUT,
    IDC_BATCHFILE,      IDH_DOS_PROGRAM_BATCH,
    IDC_BATCHFILELBL,   IDH_DOS_PROGRAM_BATCH,
    IDC_WINDOWSTATE,    IDH_DOS_PROGRAM_RUN,
    IDC_WINDOWSTATELBL, IDH_DOS_PROGRAM_RUN,
    IDC_CLOSEONEXIT,    IDH_DOS_WINDOWS_QUIT_CLOSE,
    IDC_CHANGEICON,     IDH_DOS_PROGRAM_CHANGEICON,
    IDC_ADVPROG,        IDH_DOS_PROGRAM_ADV_BUTTON,
    0, 0
};

const static DWORD rgdwNTHelp[] = {
    IDC_DOS,            IDH_COMM_GROUPBOX,
    10,                 IDH_DOS_ADV_AUTOEXEC,
    11,                 IDH_DOS_ADV_CONFIG,
    IDC_NTTIMER,        IDH_DOS_PROGRAM_PIF_TIMER_EMULATE,
    0, 0
};

BOOL_PTR CALLBACK DlgPrgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PPRGINFO ppi = (PPRGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) {

    case WM_INITDIALOG:
        // allocate dialog instance data
        if (NULL != (ppi = (PPRGINFO)LocalAlloc(LPTR, SIZEOF(PRGINFO)))) {
            ppi->ppl = (PPROPLINK)((LPPROPSHEETPAGE)lParam)->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)ppi);

            SHAutoComplete(GetDlgItem(hDlg, IDC_CMDLINE), 0);
            SHAutoComplete(GetDlgItem(hDlg, IDC_WORKDIR), 0);
            SHAutoComplete(GetDlgItem(hDlg, IDC_BATCHFILE), 0);
            InitPrgDlg(hDlg, ppi);
        } else {
            EndDialog(hDlg, FALSE);     // fail the dialog create
        }
        break;

    case WM_DESTROY:
        // free the ppi
        if (ppi) {
            EVAL(LocalFree(ppi) == NULL);
            SetWindowLongPtr(hDlg, DWLP_USER, 0);
        }
        break;

    HELP_CASES(rgdwHelp)                // handle help messages

    case WM_COMMAND:
        if (LOWORD(lParam) == 0)
            break;                      // message not from a control

        switch (LOWORD(wParam)) {

        case IDC_TITLE:
        case IDC_CMDLINE:
        case IDC_WORKDIR:
        case IDC_BATCHFILE:
        case IDC_HOTKEY:
            if (HIWORD(wParam) == EN_CHANGE)
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            break;

        case IDC_WINDOWSTATE:
            if (HIWORD(wParam) == CBN_SELCHANGE)
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            break;

        case IDC_CLOSEONEXIT:
            if (HIWORD(wParam) == BN_CLICKED)
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            break;

        case IDC_ADVPROG:
            if (HIWORD(wParam) == BN_CLICKED) {
                DialogBoxParam(HINST_THISDLL,
                               MAKEINTRESOURCE(IDD_PIFNTTEMPLT),
                               hDlg,
                               DlgPifNtProc,
                               (LPARAM)ppi);
            }
            return FALSE;               // return 0 if we process WM_COMMAND

        case IDC_CHANGEICON:
            if (HIWORD(wParam) == BN_CLICKED)
                BrowseIcons(hDlg, ppi);
            return FALSE;               // return 0 if we process WM_COMMAND
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) {

        case PSN_KILLACTIVE:
            // This gives the current page a chance to validate itself
            break;

        case PSN_APPLY:
            // This happens on OK....
            ApplyPrgDlg(hDlg, ppi);
            break;

        case PSN_RESET:
            // This happens on Cancel....
            break;
        }
        break;

    default:
        return FALSE;                   // return 0 when not processing
    }
    return TRUE;
}


void InitPrgDlg(HWND hDlg, register PPRGINFO ppi)
{
    int i;
    PROPPRG prg;
    PROPENV env;
    PROPNT40 nt40;
    PPROPLINK ppl = ppi->ppl;
    TCHAR szBuf[MAX_STRING_SIZE];
    FunctionName(InitPrgDlg);

    ASSERTTRUE(ppl->iSig == PROP_SIG);

    if (!PifMgr_GetProperties(ppl, MAKELP(0,GROUP_PRG),
                              &prg, SIZEOF(prg), GETPROPS_NONE
                             ) ||
        !PifMgr_GetProperties(ppl, MAKELP(0,GROUP_ENV),
                              &env, SIZEOF(env), GETPROPS_NONE
                             )
                               ||
        !PifMgr_GetProperties(ppl, MAKELP(0,GROUP_NT40),
                              &nt40, SIZEOF(nt40), GETPROPS_NONE
                             )
       ) {
        Warning(hDlg, IDS_QUERY_ERROR, MB_ICONEXCLAMATION | MB_OK);
        return;
    }

    /*
     * Initialize Icon and IconFile information
     *
     */

    ppi->wIconIndex = prg.wIconIndex;

    StringCchCopyW(ppi->atchIconFile, ARRAYSIZE(ppi->atchIconFile), nt40.awchIconFile);
    if (NULL != (ppi->hIcon = LoadPIFIcon(&prg, &nt40))) {
        VERIFYFALSE(SendDlgItemMessage(hDlg, IDC_ICONBMP, STM_SETICON, (WPARAM)ppi->hIcon, 0));
    }


    /*
     * Initialize window Title information
     *
     */

    LimitDlgItemText(hDlg, IDC_TITLE, ARRAYSIZE(prg.achTitle)-1);
    SetDlgItemTextW(hDlg, IDC_TITLE, nt40.awchTitle);

    /*
     * Initialize command line information
     *
     */

    LimitDlgItemText(hDlg, IDC_CMDLINE, ARRAYSIZE(prg.achCmdLine)-1);
    SetDlgItemTextW(hDlg, IDC_CMDLINE, nt40.awchCmdLine);

    /*
     * Initialize command line information
     *
     */

    LimitDlgItemText(hDlg, IDC_WORKDIR, ARRAYSIZE(prg.achWorkDir)-1);
    SetDlgItemTextW(hDlg, IDC_WORKDIR, nt40.awchWorkDir);

    /*
     *  Require at least one of Ctrl, Alt or Shift to be pressed.
     *  The hotkey control does not enforce the rule on function keys
     *  and other specials, which is good.
     */
    SendDlgItemMessage(hDlg, IDC_HOTKEY, HKM_SETRULES, HKCOMB_NONE, HOTKEYF_CONTROL | HOTKEYF_ALT);
    SendDlgItemMessage(hDlg, IDC_HOTKEY, HKM_SETHOTKEY, prg.wHotKey, 0);

    /*
     * Initialize batch file information
     *
     */

    LimitDlgItemText(hDlg, IDC_BATCHFILE, ARRAYSIZE(env.achBatchFile)-1);
    SetDlgItemTextW(hDlg, IDC_BATCHFILE, nt40.awchBatchFile);
    /*
     *  Fill in the "Run" combo box.
     */
    for (i=0; i < 3; i++) {
        VERIFYTRUE(LoadString(HINST_THISDLL, IDS_NORMALWINDOW+i, szBuf, ARRAYSIZE(szBuf)));
        VERIFYTRUE((int)SendDlgItemMessage(hDlg, IDC_WINDOWSTATE, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)szBuf) == i);
    }
    i = 0;
    if (prg.flPrgInit & PRGINIT_MINIMIZED)
        i = 1;
    if (prg.flPrgInit & PRGINIT_MAXIMIZED)
        i = 2;
    SendDlgItemMessage(hDlg, IDC_WINDOWSTATE, CB_SETCURSEL, i, 0);

    SetDlgBits(hDlg, &abinfPrg[0], ARRAYSIZE(abinfPrg), prg.flPrg);

    AdjustMSDOSModeControls(ppl, hDlg);
}


void AdjustMSDOSModeControls(PPROPLINK ppl, HWND hDlg)
{
    int i;
    BOOL f = TRUE;

    AdjustRealModeControls(ppl, hDlg);

    /*
     *  The working directory and startup batch file controls are only
     *  supported in real-mode if there is a private configuration (only
     *  because it's more work).  So, disable the controls appropriately.
     */
    if (ppl->flProp & PROP_REALMODE) {
        f = (PifMgr_GetProperties(ppl, szCONFIGHDRSIG40, NULL, 0, GETPROPS_NONE) != 0 ||
             PifMgr_GetProperties(ppl, szAUTOEXECHDRSIG40, NULL, 0, GETPROPS_NONE) != 0);
    }
    #if (IDC_WORKDIRLBL != IDC_WORKDIR-1)
    #error Error in IDC constants: IDC_WORKDIRLBL != IDC_WORKDIR-1
    #endif

    #if (IDC_WORKDIR != IDC_BATCHFILELBL-1)
    #error Error in IDC constants: IDC_WORKDIR != IDC_BATCHFILELBL-1
    #endif

    #if (IDC_BATCHFILELBL != IDC_BATCHFILE-1)
    #error Error in IDC constants: IDC_BATCHFILELBL != IDC_BATCHFILE-1
    #endif

    for (i=IDC_WORKDIRLBL; i<=IDC_BATCHFILE; i++)
        EnableWindow(GetDlgItem(hDlg, i), f);
}


void ApplyPrgDlg(HWND hDlg, PPRGINFO ppi)
{
    int i;
    PROPPRG prg;
    PROPENV env;
    PROPNT40 nt40;
    PPROPLINK ppl = ppi->ppl;
    FunctionName(ApplyPrgDlg);

    ASSERTTRUE(ppl->iSig == PROP_SIG);

    // Get the current set of properties, then overlay the new settings

    if (!PifMgr_GetProperties(ppl, MAKELP(0,GROUP_PRG),
                              &prg, SIZEOF(prg), GETPROPS_NONE
                             ) ||
        !PifMgr_GetProperties(ppl, MAKELP(0,GROUP_ENV),
                              &env, SIZEOF(env), GETPROPS_NONE
                             )
                               ||
        !PifMgr_GetProperties(ppl, MAKELP(0,GROUP_NT40),
                              &nt40, SIZEOF(nt40), GETPROPS_NONE
                             )

       ) {
        Warning(hDlg, IDS_UPDATE_ERROR, MB_ICONEXCLAMATION | MB_OK);
        return;
    }


    // Retrieve Icon information

    StringCchCopyW(nt40.awchIconFile, ARRAYSIZE(nt40.awchIconFile), ppi->atchIconFile );
    PifMgr_WCtoMBPath( nt40.awchIconFile, nt40.achSaveIconFile, ARRAYSIZE(nt40.achSaveIconFile) );
    StringCchCopyA( prg.achIconFile, ARRAYSIZE(prg.achIconFile), nt40.achSaveIconFile );
    prg.wIconIndex = ppi->wIconIndex;

    // Retrieve strings for Title, Command Line,
    // Working Directory and Batch File

    // Title
    GetDlgItemTextW(hDlg, IDC_TITLE, nt40.awchTitle, ARRAYSIZE(nt40.awchTitle));
    GetDlgItemTextA(hDlg, IDC_TITLE, nt40.achSaveTitle, ARRAYSIZE(nt40.achSaveTitle));
    nt40.awchTitle[ ARRAYSIZE(nt40.awchTitle)-1 ] = TEXT('\0');
    nt40.achSaveTitle[ ARRAYSIZE(nt40.achSaveTitle)-1 ] = '\0';
    StringCchCopyA( prg.achTitle, ARRAYSIZE(prg.achTitle), nt40.achSaveTitle );

    // Command Line
    GetDlgItemTextW(hDlg, IDC_CMDLINE, nt40.awchCmdLine, ARRAYSIZE(nt40.awchCmdLine));
    GetDlgItemTextA(hDlg, IDC_CMDLINE, nt40.achSaveCmdLine, ARRAYSIZE(nt40.achSaveCmdLine));
    nt40.awchCmdLine[ ARRAYSIZE(nt40.awchCmdLine)-1 ] = TEXT('\0');
    nt40.achSaveCmdLine[ ARRAYSIZE(nt40.achSaveCmdLine)-1 ] = '\0';
    StringCchCopyA( prg.achCmdLine, ARRAYSIZE(prg.achCmdLine), nt40.achSaveCmdLine );

    // Working Directory
    GetDlgItemTextW(hDlg, IDC_WORKDIR, nt40.awchWorkDir, ARRAYSIZE(nt40.awchWorkDir));
    nt40.awchWorkDir[ ARRAYSIZE(nt40.awchWorkDir)-1 ] = TEXT('\0');
    PifMgr_WCtoMBPath(nt40.awchWorkDir, nt40.achSaveWorkDir, ARRAYSIZE(nt40.achSaveWorkDir));
    StringCchCopyA(prg.achWorkDir, ARRAYSIZE(prg.achWorkDir), nt40.achSaveWorkDir);

    // Batch File
    GetDlgItemTextW(hDlg, IDC_BATCHFILE, nt40.awchBatchFile, ARRAYSIZE(nt40.awchBatchFile));
    nt40.awchBatchFile[ ARRAYSIZE(nt40.awchBatchFile)-1 ] = TEXT('\0');
    PifMgr_WCtoMBPath(nt40.awchBatchFile, nt40.achSaveBatchFile, ARRAYSIZE(nt40.achSaveBatchFile));
    StringCchCopyA(env.achBatchFile, ARRAYSIZE(env.achBatchFile), nt40.achSaveBatchFile);

    prg.wHotKey = (WORD)SendDlgItemMessage(hDlg, IDC_HOTKEY, HKM_GETHOTKEY, 0, 0);


    i = (int)SendDlgItemMessage(hDlg, IDC_WINDOWSTATE, CB_GETCURSEL, 0, 0);
    prg.flPrgInit &= ~(PRGINIT_MINIMIZED | PRGINIT_MAXIMIZED);
    if (i == 1)
        prg.flPrgInit |= PRGINIT_MINIMIZED;
    if (i == 2)
        prg.flPrgInit |= PRGINIT_MAXIMIZED;

    GetDlgBits(hDlg, &abinfPrg[0], ARRAYSIZE(abinfPrg), &prg.flPrg);

    if (!PifMgr_SetProperties(ppl, MAKELP(0,GROUP_PRG),
                        &prg, SIZEOF(prg), SETPROPS_NONE) ||
        !PifMgr_SetProperties(ppl, MAKELP(0,GROUP_ENV),
                        &env, SIZEOF(env), SETPROPS_NONE)
                                                           ||
        !PifMgr_SetProperties(ppl, MAKELP(0,GROUP_NT40),
                        &nt40, SIZEOF(nt40), SETPROPS_NONE)
       )
        Warning(hDlg, IDS_UPDATE_ERROR, MB_ICONEXCLAMATION | MB_OK);
    else
    if (ppl->hwndNotify) {
        ppl->flProp |= PROP_NOTIFY;
        PostMessage(ppl->hwndNotify, ppl->uMsgNotify, SIZEOF(prg), (LPARAM)MAKELP(0,GROUP_PRG));
        PostMessage(ppl->hwndNotify, ppl->uMsgNotify, SIZEOF(env), (LPARAM)MAKELP(0,GROUP_ENV));
        PostMessage(ppl->hwndNotify, ppl->uMsgNotify, SIZEOF(nt40), (LPARAM)MAKELP(0,GROUP_NT40));
    }
}


void BrowseIcons(HWND hDlg, PPRGINFO ppi)
{
    HICON hIcon;
    int wIconIndex = (int)ppi->wIconIndex;
    if (PickIconDlg(hDlg, ppi->atchIconFile, ARRAYSIZE(ppi->atchIconFile), (int *)&wIconIndex)) {
        hIcon = ExtractIcon(HINST_THISDLL, ppi->atchIconFile, wIconIndex);
        if ((UINT_PTR)hIcon <= 1)
            Warning(hDlg, IDS_NO_ICONS, MB_ICONINFORMATION | MB_OK);
        else {
            ppi->hIcon = hIcon;
            ppi->wIconIndex = (WORD)wIconIndex;
            hIcon = (HICON)SendDlgItemMessage(hDlg, IDC_ICONBMP, STM_SETICON, (WPARAM)ppi->hIcon, 0);
            if (hIcon)
                VERIFYTRUE(DestroyIcon(hIcon));
        }
    }
}


BOOL_PTR CALLBACK DlgPifNtProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PPRGINFO ppi = (PPRGINFO)GetWindowLongPtr( hDlg, DWLP_USER );

    switch (uMsg) 
	{
    case WM_INITDIALOG:
        ppi = (PPRGINFO)lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        InitNtPifDlg(hDlg, ppi);
        break;

    case WM_DESTROY:
        SetWindowLongPtr(hDlg, DWLP_USER, 0);
        break;

    HELP_CASES(rgdwNTHelp)               // handle help messages

    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case IDOK:
        case IDC_OK:
            ApplyNtPifDlg(hDlg, ppi);
            // fall through

        case IDCANCEL:
        case IDC_CANCEL :
            EndDialog(hDlg, 0);
            return FALSE;               // return 0 if we process WM_COMMAND

        case IDC_NTTIMER:
            CheckDlgButton(hDlg, IDC_NTTIMER, !IsDlgButtonChecked(hDlg, IDC_NTTIMER));
            break;
        }
        break;

    default:
        return(FALSE);

    }
    return(TRUE);
}


WORD InitNtPifDlg(HWND hDlg, register PPRGINFO ppi)
{
    PROPNT31 nt31;
    PPROPLINK ppl = ppi->ppl;
    FunctionName(InitAdvPrgDlg);

    ASSERTTRUE(ppl->iSig == PROP_SIG);

    if (!PifMgr_GetProperties(ppl, MAKELP(0,GROUP_NT31),
                        &nt31, SIZEOF(nt31), GETPROPS_NONE)
       ) {
        Warning(hDlg, IDS_QUERY_ERROR, MB_ICONEXCLAMATION | MB_OK);
        return 0;
    }

    // initialize the DLG controls
    SetDlgItemTextA( hDlg, IDC_CONFIGNT, nt31.achConfigFile );
    SetDlgItemTextA( hDlg, IDC_AUTOEXECNT, nt31.achAutoexecFile );

    if (nt31.dwWNTFlags & COMPAT_TIMERTIC)
        CheckDlgButton( hDlg, IDC_NTTIMER, 1 );
    else
        CheckDlgButton( hDlg, IDC_NTTIMER, 0 );

    SHAutoComplete(GetDlgItem(hDlg, IDC_AUTOEXECNT), 0);
    SHAutoComplete(GetDlgItem(hDlg, IDC_CONFIGNT), 0);
    return 0;
}


void ApplyNtPifDlg( HWND hDlg, PPRGINFO ppi )
{
    PROPNT31 nt31;
    PPROPLINK ppl = ppi->ppl;

    ASSERTTRUE(ppl->iSig == PROP_SIG);

    // Get current set of properties, then overlay new settings

    if (!PifMgr_GetProperties(ppl, MAKELP(0,GROUP_NT31),
                        &nt31, SIZEOF(nt31), GETPROPS_NONE)
       ) {
        Warning(hDlg, IDS_UPDATE_ERROR, MB_ICONEXCLAMATION | MB_OK);
        return;
    }

    GetDlgItemTextA( hDlg,
                     IDC_CONFIGNT,
                     nt31.achConfigFile,
                     ARRAYSIZE( nt31.achConfigFile )
                    );
    GetDlgItemTextA( hDlg,
                     IDC_AUTOEXECNT,
                     nt31.achAutoexecFile,
                     ARRAYSIZE( nt31.achAutoexecFile )
                    );

    nt31.dwWNTFlags &= (~COMPAT_TIMERTIC);
    if (IsDlgButtonChecked( hDlg, IDC_NTTIMER ))
        nt31.dwWNTFlags |= COMPAT_TIMERTIC;


    if (!PifMgr_SetProperties(ppl, MAKELP(0,GROUP_NT31),
                        &nt31, SIZEOF(nt31), SETPROPS_NONE)) {
        Warning(hDlg, IDS_UPDATE_ERROR, MB_ICONEXCLAMATION | MB_OK);
    }
    if (ppl->hwndNotify) {
        PostMessage(ppl->hwndNotify, ppl->uMsgNotify, SIZEOF(nt31), (LPARAM)MAKELP(0,GROUP_NT31));
    }


}


HICON LoadPIFIcon(LPPROPPRG lpprg, LPPROPNT40 lpnt40)
{
    HICON hIcon = NULL;
    WCHAR awchTmp[ MAX_PATH ];

    StringCchCopy(awchTmp, ARRAYSIZE(awchTmp), lpnt40->awchIconFile );
    PifMgr_WCtoMBPath( awchTmp, lpprg->achIconFile, ARRAYSIZE(lpprg->achIconFile) );
    hIcon = ExtractIcon(HINST_THISDLL, awchTmp, lpprg->wIconIndex);
    if ((DWORD_PTR)hIcon <= 1) {         // 0 means none, 1 means bad file
        hIcon = NULL;
    }
    return hIcon;
}
#endif // X86
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\pifsub.c ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1991
 *  All Rights Reserved.
 *
 *
 *  PIFSUB.C
 *  Misc. subroutines for PIFMGR.DLL
 *
 *  History:
 *  Created 31-Jul-1992 3:30pm by Jeff Parsons
 */


#include "shellprv.h"
#pragma hdrstop

#ifdef _X86_

// shell priv can alter the definition of IsDBCSLeadByte!
#if defined(FE_SB)
#ifdef IsDBCSLeadByte
#undef IsDBCSLeadByte
#define IsDBCSLeadByte(x) IsDBCSLeadByteEx(CP_ACP,x)
#endif
#endif

/*
 * Most of the routines in this file will need to stay ANSI.  If a UNICODE
 * version is needed, it is supplied.
 *
 * This is because for the most part, the information in the PIF files
 * is ANSI and needs to stay that way.
 *
 * (RickTu)
 *
 */


/** lstrcpypadA - copy to fixed-length string, appending trailing blanks
 *
 * INPUT
 *  lpszDst -> fixed-length destination string
 *  lpszSrc -> source string
 *  cchMax = size of fixed-length destination string (count of characters)
 *
 * OUTPUT
 *  Nothing
 */

void lstrcpypadA(LPSTR lpszDst, LPCSTR lpszSrc, int cchMax)
{
    FunctionName(lstrcpypadA);
    while (cchMax && *lpszSrc) {
        cchMax--;
        *lpszDst++ = *lpszSrc++;
    }
    while (cchMax--) {
        *lpszDst++ = ' ';
    }
}


/** lstrcpyncharA - copy variable-length string, until char
 *
 * INPUT
 *  lpszDst -> fixed-length destination string
 *  lpszSrc -> source string
 *  cchMax = size of fixed-length destination string (count of characters)
 *  ch = character to stop copying at
 *
 * OUTPUT
 *  # of characters copied, excluding terminating NULL
 */

int lstrcpyncharA(LPSTR lpszDst, LPCSTR lpszSrc, int cchMax, CHAR ch)
{
    int cch = 0;
    FunctionName(lstrcpyncharA);

    while (--cchMax && *lpszSrc && *lpszSrc != ch) {
        if (IsDBCSLeadByte(*lpszSrc)) {
            cch++;
            *lpszDst++ = *lpszSrc++;
            if (!*lpszSrc) break;   /* Eek!  String ends in DBCS lead byte! */
        }
        cch++;
        *lpszDst++ = *lpszSrc++;
    }
    *lpszDst = '\0';
    return cch;
}


/** lstrskipcharA - skip char in variable-length string
 *
 * INPUT
 *  lpszSrc -> source string
 *  ch = character to skip
 *
 * OUTPUT
 *  # of characters skipped, 0 if none
 */

int lstrskipcharA(LPCSTR lpszSrc, CHAR ch)
{
    int cch = 0;
    FunctionName(lstrskipcharA);

    while (*lpszSrc && *lpszSrc == ch) {
        cch++;
        lpszSrc++;
    }
    return cch;
}

/** lstrskiptocharA - skip *to* char in variable-length string
 *
 * INPUT
 *  lpszSrc -> source string
 *  ch = character to skip *to*
 *
 * OUTPUT
 *  # of characters skipped, 0 if none;  if char didn't exist, then all
 *  characters are skipped.
 */

int lstrskiptocharA(LPCSTR lpszSrc, CHAR ch)
{
    int cch = 0;
    FunctionName(lstrskiptocharA);

    while (*lpszSrc && *lpszSrc != ch) {
        cch++;
        lpszSrc++;
    }
    return cch;
}


/** lstrcpyfnameA - copy filename appropriately
 *
 * INPUT
 *  pszDest -> output buffer
 *  cchDest -> size of destination buffer in characters
 *  pszSrc -> source filename
 *  cbMax = size of output buffer
 *
 * OUTPUT
 *  # of characters copied, including quotes if any, excluding terminating NULL
 */

int lstrcpyfnameA(PSTR pszDest, size_t cchDest, PCSTR pszSrc)
{
    CHAR szDest[MAX_PATH];      // PathQuoteSpacesA requires a MAX_PATH buffer; ensure we're using one

    HRESULT hr = StringCchCopyA(szDest, ARRAYSIZE(szDest), pszSrc);
    if (FAILED(hr))
    {
        *pszDest = '\0';
        return 0;
    }

    PathQuoteSpacesA(szDest);   // quote if necessary
    hr = StringCchCopyA(pszDest, cchDest, szDest);
    if (FAILED(hr))
    {
        *pszDest = '\0';
        return 0;
    }
    return lstrlenA(pszDest);
}


/** lstrunquotefnameA - unquote filename if it contains quotes
 *
 * INPUT
 *  lpszDst -> output buffer
 *  lpszSrc -> source filename (quoted or unquoted)
 *  cchMax = size of output buffer (count of characters)
 *  fShort = TRUE if filename should be converted to 8.3 (eg, for real-mode);
 *           -1 if the filename is known to not be quoted and should just be converted
 * OUTPUT
 *  # of characters copied, excluding terminating NULL
 */

int lstrunquotefnameA(LPSTR lpszDst, LPCSTR lpszSrc, int cchMax, BOOL fShort)
{
    int cch;
    FunctionName(lstrunquotefnameA);

    if (fShort != -1) {

        if (lpszSrc[0] == '\"') {
            cch = lstrcpyncharA(lpszDst, lpszSrc+1, cchMax, '\"');
        }
        else {
            cch = lstrcpyncharA(lpszDst, lpszSrc, cchMax, ' ');
        }
        lpszSrc = lpszDst;
    }
    if (fShort) {
        HRESULT hr;

        if (lpszSrc != lpszDst)
        {
            // copy so we can work on lpszDst buffer of known size
            hr = StringCchCopyA(lpszDst, cchMax, lpszSrc);
            if (FAILED(hr))
            {
                *lpszDst = '\0';
                return 0;
            }
        }

        CharToOemBuffA(lpszSrc, lpszDst, cchMax);
        cch = GetShortPathNameA( lpszSrc, lpszDst, cchMax );
        if (cch >= cchMax)
        {
            *lpszDst = '\0';
            return 0;
        }

        if (cch) {                       // if no error...
            if (fShort == TRUE) {       // if conversion for real-mode...
                if ((int)GetFileAttributesA(lpszDst) == -1) {
                                        // if filename doesn't exist,
                                        // then just copy the 8.3 portion
                                        // and hope the user's real-mode PATH
                                        // ultimately finds it!

                    if (NULL != (lpszSrc = StrRChrA(lpszDst, NULL, '\\'))) {
                        hr = StringCchCopyA(lpszDst, cchMax, lpszSrc+1);
                        if (FAILED(hr))
                        {
                            *lpszDst = '\0';
                            return 0;
                        }
                    }
                }
            }
            cch = lstrlenA(lpszDst);      // recompute the length of the string
        }
    }
    return cch;
}


/** lstrskipfnameA - skip filename in string
 *
 * INPUT
 *  lpszSrc -> string beginning with filename (quoted or unquoted)
 *
 * OUTPUT
 *  # of characters skipped, 0 if none
 */

int lstrskipfnameA(LPCSTR lpszSrc)
{
    int cch = 0;
    FunctionName(lstrskipfname);

    if (lpszSrc[0] == '\"') {
        cch = lstrskiptocharA(lpszSrc+1, '\"') + 1;
        if (lpszSrc[cch] == '\"')
            cch++;
    }
    else
        cch = lstrskiptocharA(lpszSrc, ' ');
    return cch;
}


/*
 * NOTE! The careful definitions of achBuf and achFmt, so that
 * we can support total output of 2 * MAX_STRING_SIZE bytes.
 */
int cdecl Warning(HWND hwnd, WORD id, WORD type, ...)
{
    LPCTSTR lpchFmt;
    PPROPLINK ppl = NULL;
    TCHAR achBuf[2*MAX_STRING_SIZE];
#define achFmt (&achBuf[MAX_STRING_SIZE])
    va_list ArgList;
    FunctionName(Warning);

    lpchFmt = achFmt;

    // We never use MB_FOCUS to mean whatever it's really supposed
    // to mean;  we just use it as a kludge to support warning dialogs
    // when all we have is a ppl, not an hwnd.

    if (type & MB_NOFOCUS) {
        ppl = (PPROPLINK)hwnd;
        hwnd = NULL;
        type &= ~MB_NOFOCUS;
    }
    else if (hwnd)
        ppl = ((PPROPLINK)GetWindowLongPtr(hwnd, DWLP_USER))->ppl;

    if (id == IDS_ERROR + ERROR_NOT_ENOUGH_MEMORY)
        lpchFmt = TEXT("");
    else {
        if (!LoadString(g_hinst, id, achFmt, MAX_STRING_SIZE)) {
            ASSERTFAIL();
            lpchFmt = TEXT("");
        }
    }

    va_start(ArgList,type);
    wvnsprintf(achBuf, MAX_STRING_SIZE, lpchFmt, ArgList);
    va_end(ArgList);

    lpchFmt = NULL;
    if (ppl) {
        ASSERTTRUE(ppl->iSig == PROP_SIG);
        if (!(lpchFmt = ppl->lpszTitle))
            lpchFmt = ppl->szPathName+ppl->iFileName;
    }
    return MessageBox(hwnd, achBuf, lpchFmt, type);
}
#undef achFmt

int MemoryWarning(HWND hwnd)
{
    FunctionName(MemoryWarning);
    return Warning(hwnd, IDS_ERROR + ERROR_NOT_ENOUGH_MEMORY, MB_ICONEXCLAMATION | MB_OK);
}


LPTSTR LoadStringSafe(HWND hwnd, UINT id, LPTSTR lpsz, int cchsz)
{
    FunctionName(LoadStringSafe);
    if (!LoadString(g_hinst, id, lpsz, cchsz)) {
        ASSERTFAIL();
        if (hwnd) {
            MemoryWarning(hwnd);
            return NULL;
        }
        lpsz = TEXT("");
    }
    return lpsz;
}


/** SetDlgBits - Check various dialog checkboxes according to given flags
 *
 * INPUT
 *  hDlg   = HWND of dialog box
 *  pbinf -> array of bitinfo descriptors
 *  cbinf  = size of array
 *  wFlags = flags
 *
 * OUTPUT
 *  Returns NOTHING
 */

void SetDlgBits(HWND hDlg, PBINF pbinf, UINT cbinf, WORD wFlags)
{
    FunctionName(SetDlgBits);

    ASSERTTRUE(cbinf > 0);
    do {
        ASSERTTRUE((pbinf->bBit & 0x3F) < 16);
        CheckDlgButton(hDlg, pbinf->id,
                       !!(wFlags & (1 << (pbinf->bBit & 0x3F))) == !(pbinf->bBit & 0x80));
    } while (++pbinf, --cbinf);
}


/** GetDlgBits - Set various flags according to dialog checkboxes
 *
 * INPUT
 *  hDlg   = HWND of dialog box
 *  pbinf -> array of bitinfo descriptors
 *  cbinf  = size of array
 *  lpwFlags -> flags word
 *
 * OUTPUT
 *  Returns NOTHING
 */

void GetDlgBits(HWND hDlg, PBINF pbinf, UINT cbinf, LPWORD lpwFlags)
{
    WORD wFlags;
    FunctionName(GetDlgBits);

    ASSERTTRUE(cbinf > 0);
    wFlags = *lpwFlags;
    do {
        ASSERTTRUE((pbinf->bBit & 0x3F) < 16);

        if (pbinf->bBit & 0x40)         // 0x40 is a special bit mask
            continue;                   // that means "set but don't get
                                        // this control's value"
        wFlags &= ~(1 << (pbinf->bBit & 0x3F));
        if (!!IsDlgButtonChecked(hDlg, pbinf->id) == !(pbinf->bBit & 0x80))
            wFlags |= (1 << (pbinf->bBit & 0x3F));

    } while (++pbinf, --cbinf);
    *lpwFlags = wFlags;
}


/** SetDlgInts - Set various edit controls according to integer fields
 *
 * INPUT
 *  hDlg   = HWND of dialog box
 *  pvinf -> array of validation info descriptors
 *  cvinf  = size of array
 *  lp    -> structure of integers
 *
 * OUTPUT
 *  Returns NOTHING
 */

void SetDlgInts(HWND hDlg, PVINF pvinf, UINT cvinf, LPVOID lp)
{
    WORD wMin, wMax;
    FunctionName(SetDlgInts);

    ASSERTTRUE(cvinf > 0);
    do {
        wMin = wMax = *(WORD UNALIGNED *)((LPBYTE)lp + pvinf->off);

        if (pvinf->fbOpt & VINF_AUTO) {

            SendDlgItemMessage(hDlg, pvinf->id, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)g_szAuto);

            AddDlgIntValues(hDlg, pvinf->id, pvinf->iMax);

            if (wMin == 0) {
                SetDlgItemText(hDlg, pvinf->id, g_szAuto);
                continue;
            }
        }
        if (pvinf->fbOpt & VINF_AUTOMINMAX) {

            SendDlgItemMessage(hDlg, pvinf->id, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)g_szAuto);
            SendDlgItemMessage(hDlg, pvinf->id, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)g_szNone);

            AddDlgIntValues(hDlg, pvinf->id, pvinf->iMax);

            // When AUTOMINMAX is set, we assume that the field
            // we're validating is followed in its structure by a
            // corresponding max WORD.

            wMax = *(WORD UNALIGNED *)((LPBYTE)lp + pvinf->off + sizeof(WORD));

            if (wMin == 0 && wMax == 0) {
                SetDlgItemText(hDlg, pvinf->id, g_szNone);
                continue;
            }

            // Let's try to simplify things by mapping 0xFFFF (aka -1)
            // to settings that mean "Auto"

            if (wMin == 0xFFFF || wMax == 0xFFFF) {
                wMin = 0;
                wMax = (WORD)pvinf->iMax;
            }

            if (wMax == (WORD)pvinf->iMax) {
                SetDlgItemText(hDlg, pvinf->id, g_szAuto);
                continue;
            }

            if (wMin != wMax) {
                //
                // We're in a bit of a quandary here.  The settings show
                // explicit min and max values which are not equal, probably
                // due to settings inherited from a 3.1 PIF file.  We'll
                // just go with the wMax value.  Fortunately for us, we
                // don't actually have to *do* anything to make this happen.
                //
            }
        }
        SetDlgItemInt(hDlg, pvinf->id, wMin, pvinf->iMin < 0);

    } while (++pvinf, --cvinf);
}


/** AddDlgIntValues - Fill integer combo-box with appropriate values
 *
 * INPUT
 *  hDlg   = HWND of dialog box
 *  id     = dialog control ID
 *  iMax   = maximum value
 *
 * OUTPUT
 *  Returns NOTHING
 */

void AddDlgIntValues(HWND hDlg, int id, int iMax)
{
    int iStart, iInc;
    TCHAR achValue[16];

    // HACK to make this do something sensible with the environment max;
    // they can still enter larger values (up to ENVSIZE_MAX) but I don't
    // see any sense in encouraging it. -JTP

    if ((WORD)iMax == ENVSIZE_MAX)
        iMax = 4096;

    if ((iMax < 0) || (iMax == 0xFFFF)) // HACK to make this do something sensible
        iMax = 16384;           // with fields that allow huge maximums -JTP

    iStart = iInc = iMax/16;    // arbitrarily chop the range up 16 times

    while (iStart <= iMax) {
        StringCchPrintf(achValue, ARRAYSIZE(achValue), TEXT("%d"), iStart);    // ok to truncate
        SendDlgItemMessage(hDlg, id, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)achValue);
        iStart += iInc;
    }
}


/** GetDlgInts - Set various integer fields according to dialog edit controls
 *
 * INPUT
 *  hDlg   = HWND of dialog box
 *  pvinf -> array of validation info descriptors
 *  cvinf  = size of array
 *  lp    -> structure of integers
 *
 * OUTPUT
 *  Returns NOTHING
 */

void GetDlgInts(HWND hDlg, PVINF pvinf, int cvinf, LPVOID lp)
{
    WORD wMin, wMax;
    UINT uTemp;
    BOOL fSuccess;
    TCHAR achText[32];
    FunctionName(GetDlgInts);

    ASSERTTRUE(cvinf > 0);
    do {
        uTemp = GetDlgItemInt(hDlg, pvinf->id, &fSuccess, pvinf->iMin < 0);
        ASSERT(HIWORD(uTemp)==0);

        wMin = LOWORD(uTemp);

        // In case of error, make sure wMin doesn't actually change

        if (!fSuccess)
            wMin = *(WORD UNALIGNED *)((LPBYTE)lp + pvinf->off);

        if (pvinf->fbOpt & VINF_AUTO) {

            GetDlgItemText(hDlg, pvinf->id, achText, ARRAYSIZE(achText));

            if (lstrcmpi(achText, g_szAuto) == 0) {
                wMin = 0;
            }
        }

        if (pvinf->fbOpt & VINF_AUTOMINMAX) {

            // When AUTOMINMAX is set, we assume that the field
            // we're validating is followed in its structure by a
            // corresponding max WORD, which we will ZERO if the
            // user selects NONE, or set to its MAXIMUM if the user
            // selects AUTO, or otherwise set to match the specified
            // MINIMUM.

            wMax = wMin;

            GetDlgItemText(hDlg, pvinf->id, achText, ARRAYSIZE(achText));

            if (lstrcmpi(achText, g_szAuto) == 0) {
                wMin = 0;
                wMax = (WORD)pvinf->iMax;
            }
            else if (lstrcmpi(achText, g_szNone) == 0) {
                wMin = 0;
                wMax = 0;
            }

            *(WORD UNALIGNED *)((LPBYTE)lp + pvinf->off + sizeof(WORD)) = wMax;
        }

        *(WORD UNALIGNED *)((LPBYTE)lp + pvinf->off) = wMin;

    } while (++pvinf, --cvinf);
}


/** ValidateDlgInts - Validate that integer fields are value
 *
 * INPUT
 *  hDlg   = HWND of dialog box
 *  pvinf -> array of validation descriptors
 *  cvinf  = size of array
 *
 * OUTPUT
 *  Returns TRUE if something is wrong; FALSE if all is okay.
 */

BOOL ValidateDlgInts(HWND hDlg, PVINF pvinf, int cvinf)
{
    DWORD dw;
    BOOL fSuccess;
    TCHAR achText[32];
    FunctionName(ValidateDlgInts);

    ASSERTTRUE(cvinf > 0);
    do {
        dw = GetDlgItemInt(hDlg, pvinf->id, &fSuccess, pvinf->iMin < 0);

        // NOTE: AUTO is for "Auto" only, whereas AUTOMINMAX is for
        // "Auto" and "None".  However, in the interest of simplicity, I
        // don't complain if either string is used in either case.

        if (pvinf->fbOpt & (VINF_AUTO | VINF_AUTOMINMAX)) {
            if (!fSuccess) {
                GetDlgItemText(hDlg, pvinf->id, achText, ARRAYSIZE(achText));
                if (lstrcmpi(achText, g_szNone) == 0 ||
                    lstrcmpi(achText, g_szAuto) == 0) {
                    continue;   // things be lookin' good, check next int...
                }
            }
        }
        if (!fSuccess || dw < (DWORD)pvinf->iMin || dw > (DWORD)pvinf->iMax) {
            Warning(hDlg, pvinf->idMsg, MB_ICONEXCLAMATION | MB_OK, pvinf->iMin, pvinf->iMax);
            SendDlgItemMessage(hDlg, pvinf->id, EM_SETSEL, 0, MAKELPARAM(0,-1));
            SetFocus(GetDlgItem(hDlg, pvinf->id));
            return TRUE;        // things be lookin' bad, bail out...
        }
    } while (++pvinf, --cvinf);
    return FALSE;
}


/*
 * NOTE -- The compiler emits really bad code for some of these guys.
 * In those cases, we are merely wrapping a call; there is no need to save BP.
 */


/** LimitDlgItemText - Sets the limit for a dialog edit control
 *
 * INPUT
 *  hDlg = HWND of dialog box
 *  iCtl = ID of control
 *  uiLimit = text limit
 *
 * OUTPUT
 *  None.
 */
void LimitDlgItemText(HWND hDlg, int iCtl, UINT uiLimit)
{
    FunctionName(LimitDlgItemText);

    SendDlgItemMessage(hDlg, iCtl, EM_LIMITTEXT, uiLimit, 0);
}


/** SetDlgItemPosRange - Sets the pos and range for a dialog slider control
 *
 * INPUT
 *  hDlg = HWND of dialog box
 *  iCtl = ID of control
 *  uiPos = Current position
 *  dwRange = Range (min in low word, max in high word)
 *
 * OUTPUT
 *  None.
 */
void SetDlgItemPosRange(HWND hDlg, int iCtl, UINT uiPos, DWORD dwRange)
{
    FunctionName(SetDlgItemPosRange);

    SendDlgItemMessage(hDlg, iCtl, TBM_SETRANGE, 0, dwRange);
    SendDlgItemMessage(hDlg, iCtl, TBM_SETPOS, TRUE, uiPos);
}


/** GetDlgItemPos - Gets the pos of a dialog slider control
 *
 * INPUT
 *  hDlg = HWND of dialog box
 *  iCtl = ID of control
 *
 * OUTPUT
 *  Trackbar position.
 */
UINT GetDlgItemPos(HWND hDlg, int iCtl)
{
    FunctionName(GetDlgItemPos);

    return (UINT)SendDlgItemMessage(hDlg, iCtl, TBM_GETPOS, 0, 0);
}


/** SetDlgItemPct - Sets the pos for a dialog slider control that measures %
 *
 * INPUT
 *  hDlg = HWND of dialog box
 *  iCtl = ID of control
 *  uiPct = Current position (range 0 .. 100)
 *
 * OUTPUT
 *  None.
 */
void SetDlgItemPct(HWND hDlg, int iCtl, UINT uiPct)
{
    FunctionName(SetDlgItemPct);

    SetDlgItemPosRange(hDlg, iCtl, uiPct / (100/NUM_TICKS), MAKELONG(0, NUM_TICKS));
}


/** GetDlgItemPct - Gets the pos of a dialog slider control that measures %
 *
 * INPUT
 *  hDlg = HWND of dialog box
 *  iCtl = ID of control
 *
 * OUTPUT
 *  Slider position in the range 0 .. 100.
 */
UINT GetDlgItemPct(HWND hDlg, int iCtl)
{
    FunctionName(GetDlgItemPct);

    return GetDlgItemPos(hDlg, iCtl) * (100/NUM_TICKS);
}


/** AdjustRealModeControls - Disables selected items if single-app mode
 *
 *  If the proplink says that "single-application mode" is enabled,
 *  then hide all controls whose IDs are less than 4000 and show all
 *  controls whose IDs are greater than or equal to 5000.  Controls whose
 *  IDs are in the 4000's are immune to all this hiding/showing.  Controls
 *  in the 3000's are actually disabled rather than hidden.  Controls in
 *  the 6000's are actually disabled rather than hidden as well.
 *
 *  RST: Ok, this is nice in theory, but now that we've pulled over this
 *       stuff into shell32.dll, we'll have to go off the actual IDC_
 *       defines instead of the magic #'s of 3000, 4000 and 5000.
 *
 *       IDC_ICONBMP        == 3001
 *       IDC_PIF_STATIC     == 4000
 *       IDC_REALMODEISABLE == 5001
 *
 *       So, when adding things to shell232.rc or ids.h, plan
 *       accordingly.
 *
 * INPUT
 *  ppl = proplink
 *  hDlg = HWND of dialog box
 *
 * OUTPUT
 *  Dialog items have been disabled/enabled shown/hidden.
 *  Returns nonzero if we are in normal (not single-app) mode.
 */

BOOL CALLBACK EnableEnumProc(HWND hwnd, LPARAM lp)
{
    int f;
    LONG l;

    f = SW_SHOW;
    l = GetWindowLong(hwnd, GWL_ID);

    if (!LOWORD(lp) && l < IDC_PIF_STATIC || LOWORD(lp) && l >= IDC_REALMODEDISABLE)
        f = SW_HIDE;

    if (l < IDC_ICONBMP || l >= IDC_PIF_STATIC && l < IDC_CONFIGLBL)
        ShowWindow(hwnd, f);
    else
        EnableWindow(hwnd, f == SW_SHOW);

    return TRUE;
}


BOOL AdjustRealModeControls(PPROPLINK ppl, HWND hDlg)
{
    BOOL fNormal;
    FunctionName(AdjustRealModeControls);

    fNormal = !(ppl->flProp & PROP_REALMODE);
    EnumChildWindows(hDlg, EnableEnumProc, fNormal);
    return fNormal;
}


/** OnWmHelp - Handle a WM_HELP message
 *
 *  This is called whenever the user presses F1 or clicks the help
 *  button in the title bar.  We forward the call on to the help engine.
 *
 * INPUT
 *  lparam  = LPARAM from WM_HELP message (LPHELPINFO)
 *  pdwHelp = array of DWORDs of help info
 *
 * OUTPUT
 *
 *  None.
 */

void OnWmHelp(LPARAM lparam, const DWORD *pdwHelp)
{
    FunctionName(OnWmHelp);

    WinHelp((HWND) ((LPHELPINFO) lparam)->hItemHandle, NULL,
            HELP_WM_HELP, (DWORD_PTR) (LPTSTR) pdwHelp);
}

/** OnWmContextMenu - Handle a WM_CONTEXTMENU message
 *
 *  This is called whenever the user right-clicks on a control.
 *  We forward the call on to the help engine.
 *
 * INPUT
 *  wparam  = WPARAM from WM_HELP message (HWND)
 *  pdwHelp = array of DWORDs of help info
 *
 * OUTPUT
 *
 *  None.
 */

void OnWmContextMenu(WPARAM wparam, const DWORD *pdwHelp)
{
    FunctionName(OnWmContextMenu);

    WinHelp((HWND) wparam, NULL, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPTSTR) pdwHelp);
}

#ifdef UNICODE
/** PifMgr_WCtoMBPath - Converts UNICODE path to it's ANSI representation
 *
 *  This is called whenever we need to convert a UNICODE path to it's
 *  best approximation in ANSI.  Sometimes this will be a direct mapping,
 *  but sometimes not.  We may have to use the short name, etc.
 *
 * INPUT
 *  lpUniPath  -> pointer UNICODE path (NULL terminated)
 *  lpAnsiPath -> pointer to buffer to hold ANSI path
 *  cchBuf     -> size of ANSI buffer, in characters
 *
 * OUTPUT
 *
 *  lpAnsiPath buffer contains ANSI representation of lpUniPath
 */

void PifMgr_WCtoMBPath(LPWSTR lpUniPath, LPSTR lpAnsiPath, UINT cchBuf )
{
    WCHAR awchPath[ MAX_PATH ]; // Should be bigger than any PIF string
    CHAR  achPath[ MAX_PATH ];  // Should be bigger than any PIF string
    UINT  cchAnsi = 0;
    HRESULT hr;

    FunctionName(PifMgr_WCtoMBPath);

    // Try converting to Ansi and then converting back and comparing.
    // If we get back exactly what we started with, this is the "simple"
    // case.

    cchAnsi = WideCharToMultiByte( CP_ACP, 0,
                                   lpUniPath, -1,
                                   achPath, ARRAYSIZE(achPath),
                                   NULL, NULL );

    if (cchAnsi && (cchAnsi<=cchBuf)) {

        // Now try converting back
        MultiByteToWideChar( CP_ACP, 0,
                             achPath, -1,
                             awchPath, ARRAYSIZE(awchPath)
                            );

        if (lstrcmp(lpUniPath,awchPath)==0) {

            // We're done...copy over the string.
            hr = StringCchCopyA( lpAnsiPath, cchBuf, achPath );
            if (FAILED(hr))
            {
                *lpAnsiPath = '\0';
            }
            return;

        }

        // Well, the string has some unmappable UNICODE
        // character in it, so try option #2 -- using the
        // short path name.
        goto TryShortPathName;

    } else {
        int cch;

TryShortPathName:
        // Hmmm, the best we can do is to use the short path name and map
        // it to ANSI.

        cch = GetShortPathName(lpUniPath, awchPath, ARRAYSIZE(awchPath));
        if (cch == 0 || cch >= ARRAYSIZE(awchPath))
        {
            *lpAnsiPath = '\0';
            return;
        }

        cch = WideCharToMultiByte( CP_ACP, 0,
                                   awchPath, -1,
                                   lpAnsiPath, cchBuf,
                                   NULL, NULL
                                  );
        if (cch == 0)
        {
            *lpAnsiPath = '\0';
            return;
        }
    }
}
#endif

#endif // X86
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\pifvid.c ===
// Created 04-Jan-1993 1:10pm by Jeff Parsons
 
#include "shellprv.h"
#pragma hdrstop

#ifdef _X86_

BINF abinfVid[] = {
    {IDC_WINDOWED,      BITNUM(VID_FULLSCREEN)   | 0x80},
    {IDC_FULLSCREEN,    BITNUM(VID_FULLSCREEN)},
    {IDC_TEXTEMULATE,   BITNUM(VID_TEXTEMULATE)},
    {IDC_DYNAMICVIDMEM, BITNUM(VID_RETAINMEMORY) | 0x80},
};

BINF abinfWinInit[] = {
    {IDC_WINRESTORE,    BITNUM(WININIT_NORESTORE) | 0x80},
};

// Private function prototypes

void EnableVidDlg(HWND hDlg, PPROPLINK ppl);
void InitVidDlg(HWND hDlg, PPROPLINK ppl);
void ApplyVidDlg(HWND hDlg, PPROPLINK ppl);


// Context-sensitive help ids

const static DWORD rgdwHelp[] = {
    IDC_SCREENUSAGEGRP, IDH_COMM_GROUPBOX,
    IDC_FULLSCREEN,     IDH_DOS_SCREEN_USAGE_FULL,
    IDC_WINDOWED,       IDH_DOS_SCREEN_USAGE_WINDOW,
    IDC_SCREENLINESLBL, IDH_DOS_DISPLAY_SCREEN_SETTINGS,
    IDC_SCREENLINES,    IDH_DOS_DISPLAY_SCREEN_SETTINGS,
    IDC_WINDOWUSAGEGRP, IDH_COMM_GROUPBOX,
    IDC_TOOLBAR,        IDH_DOS_WINDOWS_TOOLBAR,
    IDC_SCREENPERFGRP,  IDH_COMM_GROUPBOX,
    IDC_TEXTEMULATE,    IDH_DOS_DISPLAY_ROM,
    IDC_WINRESTORE,     IDH_DOS_SCREEN_RESTORE,
    IDC_DYNAMICVIDMEM,  IDH_DOS_SCREEN_DMA,
    IDC_REALMODEDISABLE,IDH_DOS_REALMODEPROPS,
    0, 0
};

/*
 *  This is a little table that converts listbox indices into
 *  screen lines.
 *
 *  The correspondences are...
 *
 *      IDS_WHATEVER = List box index + IDS_DEFAULTLINES
 *      nLines = awVideoLines[List box index]
 */
#if IDS_25LINES - IDS_DEFAULTLINES != 1 || \
    IDS_43LINES - IDS_DEFAULTLINES != 2 || \
    IDS_50LINES - IDS_DEFAULTLINES != 3
#error Manifest constants damaged.
#endif

WORD awVideoLines[] = { 0, 25, 43, 50 };


BOOL_PTR CALLBACK DlgVidProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PPROPLINK ppl;
    FunctionName(DlgVidProc);

    ppl = (PPROPLINK)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) {
    case WM_INITDIALOG:
        lParam = ((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        ppl = (PPROPLINK)(INT_PTR)lParam;
        InitVidDlg(hDlg, ppl);
        break;

    HELP_CASES(rgdwHelp)                // Handle help messages

    case WM_COMMAND:
        if (LOWORD(lParam) == 0)
            break;                      // message not from a control

        switch (LOWORD(wParam)) {

        case IDC_SCREENLINES:
            if (HIWORD(wParam) == CBN_SELCHANGE)
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            break;

        case IDC_WINDOWED:
        case IDC_FULLSCREEN:
        case IDC_WINRESTORE:
        case IDC_TEXTEMULATE:
        case IDC_DYNAMICVIDMEM:
            if (HIWORD(wParam) == BN_CLICKED)
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) {
        case PSN_SETACTIVE:
            AdjustRealModeControls(ppl, hDlg);
            break;

        case PSN_KILLACTIVE:
            // This gives the current page a chance to validate itself
            // SetWindowLong(hDlg, DWL_MSGRESULT, 0);
            break;

        case PSN_APPLY:
            // This happens on OK....
            ApplyVidDlg(hDlg, ppl);
            break;

        case PSN_RESET:
            // This happens on Cancel....
            break;
        }
        break;

    default:
        return FALSE;                   // return 0 when not processing
    }
    return TRUE;
}


void InitVidDlg(HWND hDlg, PPROPLINK ppl)
{
    WORD w;
    HWND hwnd;
    PROPVID vid;
    PROPWIN win;
    TCHAR szBuf[MAX_STRING_SIZE];
    FunctionName(InitVidDlg);

    if (!PifMgr_GetProperties(ppl, MAKELP(0,GROUP_VID),
                        &vid, SIZEOF(vid), GETPROPS_NONE) ||
        !PifMgr_GetProperties(ppl, MAKELP(0,GROUP_WIN),
                        &win, SIZEOF(win), GETPROPS_NONE)) {
        Warning(hDlg, IDS_QUERY_ERROR, MB_ICONEXCLAMATION | MB_OK);
        return;
    }

    SetDlgBits(hDlg, &abinfVid[0], ARRAYSIZE(abinfVid), vid.flVid);
    SetDlgBits(hDlg, &abinfWinInit[0], ARRAYSIZE(abinfWinInit), win.flWinInit);

    /*
     *  Fill in the "Initial screen size" combo box.  Note that
     *  we bail on low-memory errors.  Note also that if we have
     *  a nonstandard size, we just leave the combo box with no
     *  default selection.
     */

    VERIFYTRUE(hwnd = GetDlgItem(hDlg, IDC_SCREENLINES));
    for (w = 0; w < ARRAYSIZE(awVideoLines); w++) {
        VERIFYTRUE(LoadString(HINST_THISDLL, IDS_DEFAULTLINES + w, szBuf, ARRAYSIZE(szBuf)));
        VERIFYTRUE(SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)szBuf) == w);
        if (vid.cScreenLines == awVideoLines[w]) {
            SendMessage(hwnd, CB_SETCURSEL, w, 0);
        }
    }
    if (!IsBilingualCP(g_uCodePage))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_SCREENLINESLBL), FALSE);
        EnableWindow(hwnd, FALSE);
    }
}

void ApplyVidDlg(HWND hDlg, PPROPLINK ppl)
{
    DWORD dw;
    HWND hwnd;
    PROPVID vid;
    PROPWIN win;
    FunctionName(ApplyVidDlg);

    // Get the current set of properties, then overlay the new settings

    if (!PifMgr_GetProperties(ppl, MAKELP(0,GROUP_VID),
                        &vid, SIZEOF(vid), GETPROPS_NONE) ||
        !PifMgr_GetProperties(ppl, MAKELP(0,GROUP_WIN),
                        &win, SIZEOF(win), GETPROPS_NONE)) {
        Warning(hDlg, IDS_UPDATE_ERROR, MB_ICONEXCLAMATION | MB_OK);
        return;
    }

    GetDlgBits(hDlg, &abinfVid[0], ARRAYSIZE(abinfVid), &vid.flVid);
    GetDlgBits(hDlg, &abinfWinInit[0], ARRAYSIZE(abinfWinInit), &win.flWinInit);

    /*
     *  If there is no current selection, don't change the cScreenLines
     *  property.  This allows the user to retain an unusual number of
     *  screen lines by simply not touching the field.
     */
    VERIFYTRUE(hwnd = GetDlgItem(hDlg, IDC_SCREENLINES));

    dw = (DWORD) SendMessage(hwnd, CB_GETCURSEL, 0, 0L);
    if (dw < ARRAYSIZE(awVideoLines)) {
        vid.cScreenLines = awVideoLines[dw];
    }

    if (!PifMgr_SetProperties(ppl, MAKELP(0,GROUP_VID),
                        &vid, SIZEOF(vid), SETPROPS_NONE) ||
        !PifMgr_SetProperties(ppl, MAKELP(0,GROUP_WIN),
                        &win, SIZEOF(win), SETPROPS_NONE))
        Warning(hDlg, IDS_UPDATE_ERROR, MB_ICONEXCLAMATION | MB_OK);
    else
    if (ppl->hwndNotify) {
        ppl->flProp |= PROP_NOTIFY;
        PostMessage(ppl->hwndNotify, ppl->uMsgNotify, SIZEOF(vid), (LPARAM)MAKELP(0,GROUP_VID));
        PostMessage(ppl->hwndNotify, ppl->uMsgNotify, SIZEOF(win), (LPARAM)MAKELP(0,GROUP_WIN));
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\precomp.h ===
/* Precompiled Header */

#define UNICODE 1
#define NO_PIF_HDRS

#include "..\shellprv.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\pifmgrp.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1992,1993
 *  All Rights Reserved.
 *
 *
 *  PIFMGRP.H
 *  Private PIFMGR include file
 *
 *  History:
 *  Created 31-Jul-1992 3:45pm by Jeff Parsons
 */

#include <windows.h>    // declares NULL the "right" way (as 0)

#ifndef RC_INVOKED
#include <malloc.h>     // misc. C runtime goop
#include <memory.h>
#include <stdlib.h>
#include <string.h>
#ifndef WINNT
#include <setupx.h>     // for Ip (inf) API
#endif
#include <prsht.h>      // for PropertySheet(), pulls in shell.h
#include <commdlg.h>    // for GetOpenFileName(), GetSaveFileName()
#endif /* RC_INVOKED */

#include <commctrl.h>   // for TRACKBAR_CLASS, HOTKEY_CLASS...

#include <regstr.h>
#include <winerror.h>

#ifndef RC_INVOKED
#define PIF_PROPERTY_SHEETS
#include <pif.h>

#endif /* RC_INVOKED */


/*
 *  Supported app extension types
 */
#define APPTYPE_UNKNOWN         -1
#define APPTYPE_EXE             0
#define APPTYPE_COM             1
#define APPTYPE_BAT             2
#define APPTYPE_CMD             3
#define APPTYPE_PIF             4
#define MAX_APP_TYPES           5


/*
 *  Bitmap IDs
 */

#define DX_TTBITMAP             20
#define DY_TTBITMAP             12

#define MAX_STRING_SIZE         256

#ifndef RC_INVOKED


/*
 * Some typedefs mysteriously missing from windows.h
 */
typedef const WORD * LPCWORD;
typedef const VOID *LPCVOID;// pointer to const void

#define PROP_SIG                0x504A

/*  Property flags
 *
 *  Anyone can set PROP_DIRTY, but only Lock/UnlockPIFData should set
 *  PROP_DIRTYLOCK.  The latter is set/cleared when the last lock is about
 *  to be unlocked (ie, when cLocks is going back to zero).  At that time,
 *  if PROP_DIRTY is set, then we also set PROP_DIRTYLOCK and skip the
 *  call to GlobalUnlock;  on the other hand, if PROP_DIRTY is clear, then
 *  we also clear PROP_DIRTYLOCK and allow the call to GlobalUnlock to proceed.
 *
 *  A consequence is that you must NEVER clear PROP_DIRTY while the data
 *  is unlocked, unless you plan on checking PROP_DIRTYLOCK yourself and
 *  relinquishing that outstanding lock, if it exists.  It is much preferable
 *  to either clear PROP_DIRTY while the data is locked (so that UnlockPIFData
 *  will take care of it), or to simply call FlushPIFData with fDiscard set
 *  appropriately.
 */
#define PROP_DIRTY              0x0001  // memory block modified and unwritten
#define PROP_DIRTYLOCK          0x0002  // memory block locked
#define PROP_TRUNCATE           0x0004  // memory block shrunk, truncate on write
#define PROP_RAWIO              0x0008  // direct access to memory block allowed
#define PROP_NOTIFY             0x0010  // property sheet made changes
#define PROP_IGNOREPIF          0x0020  // entry in [pif] exists, ignore any PIF
#define PROP_SKIPPIF            0x0040  // don't try to open a PIF (various reasons)
#define PROP_NOCREATEPIF        0x0080  // we opened the PIF once, so don't recreate
#define PROP_REGEN              0x0100  // GetPIFData call in progress
#define PROP_DONTWRITE          0x0200  // someone else has flushed, don't write
#define PROP_REALMODE           0x0400  // disable non-real-mode props
#define PROP_PIFDIR             0x0800  // PIF found in PIF directory
#define PROP_NOPIF              0x1000  // no PIF found
#define PROP_DEFAULTPIF         0x2000  // default PIF found
#define PROP_INFSETTINGS        0x4000  // INF settings found
#define PROP_INHIBITPIF         0x8000  // INF or OpenProperties requested no PIF

#if (PROP_NOPIF != PRGINIT_NOPIF || PROP_DEFAULTPIF != PRGINIT_DEFAULTPIF || PROP_INFSETTINGS != PRGINIT_INFSETTINGS || PROP_INHIBITPIF != PRGINIT_INHIBITPIF)
#error Bit mismatch in PIF constants
#endif

#ifndef OF_READ
#define MAXPATHNAME 260
#else
#define MAXPATHNAME 260 // (sizeof(OFSTRUCTEX)-9)
#endif


typedef struct PIFOFSTRUCT {
    DWORD   nErrCode;
    TCHAR   szPathName[MAXPATHNAME];
} PIFOFSTRUCT, *LPPIFOFSTRUCT;


typedef struct PROPLINK {       /* pl */
    struct    PROPLINK *ppl;      //
    struct    PROPLINK *pplNext;  //
    struct    PROPLINK *pplPrev;  //
    int       iSig;               // proplink signature
    int       flProp;             // proplink flags (PROP_*)
    int       cbPIFData;          // size of PIF data
    int       cLocks;             // # of locks, if any
    LPPIFDATA lpPIFData;          // pointer (non-NULL if PIF data locked)
    int       ckbMem;             // memory setting from WIN.INI (-1 if none)
    int       iSheetUsage;        // number of prop sheets using this struct
    LPCTSTR   lpszTitle;          // title to use in dialogs (NULL if none)
    HWND      hwndNotify;         // who to notify when PROP_NOTIFY has been set
    UINT      uMsgNotify;         // message number to use when notifying, 0 if none
    DWORD     hVM;                // handle to associated VM (if any)
    HWND      hwndTty;            // handle to associated window (if any)
    LPTSTR    lpArgs;             // pointer to args for this instance (if any)
    HANDLE    hPIF;               // handle to PIF file
    PIFOFSTRUCT ofPIF;            // hacked OpenFile() structure for PIF
    UINT      iFileName;          // offset of base filename in szPathName
    UINT      iFileExt;           // offset of base filename extension in szPathName
    TCHAR     szPathName[MAXPATHNAME];
} PROPLINK;
typedef PROPLINK *PPROPLINK;


#ifndef ROUNDUNITS
#define ROUNDUNITS(a,b)    (((a)+(b)-1)/(b))
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#endif

#define INI_WORDS       (5 + ROUNDUNITS(sizeof (WINDOWPLACEMENT), 2))
#define MAX_INT_LENGTH  10      // "-32767" + separator + 3 chars of slop
#define MAX_INI_WORDS   20
#define MAX_INI_BUFFER  (MAX_INT_LENGTH * MAX_INI_WORDS)
#define ISVALIDINI(w)   ((w)==1 || (w)==3 || (w)==5 || (w) == INI_WORDS)

/*  Owing to the fact that wFlags was originally defined as a combination
 *  of font and window settings, WIN_SAVESETTINGS and WIN_TOOLBAR should be
 *  considered reserved FNT flags.  It is problematic to assert that no
 *  one ever use those FNT flags for anything, but I will at least try to
 *  catch them sticking those bits into FNT_DEFAULT....
 */

#if (FNT_DEFAULT & (WIN_SAVESETTINGS | WIN_TOOLBAR))
#error Reserved FNT flags incorrectly used
#endif

#if (FNT_TTFONTS - FNT_RASTERFONTS) != (FNT_BOTHFONTS - FNT_TTFONTS)
#error Incorrect bit value(s) for FNT_RASTERFONTS and/or FNT_TTFONTS
#endif

typedef struct INIINFO {
    WORD    wFlags;             // This order is the same as written to file
    WORD    wFontWidth;         // We assume that if zero width, nothing to init
    WORD    wFontHeight;
    WORD    wWinWidth;
    WORD    wWinHeight;
    WINDOWPLACEMENT wp;         // If normalposition.left & right are zero,
    BYTE    szInvokedName[128+1];//   there is no position to restore
} INIINFO;
typedef INIINFO *PINIINFO;
typedef INIINFO *LPINIINFO;


/*
 * Types/structures for GetINIData
 */
#define INIDATA_DECINT      0x0001
#define INIDATA_FIXEDPOINT  0x0002
#define INIDATA_BOOLEAN     0x0004
#define INIDATA_INVERT      0x1000

typedef struct _INIDATA {
    const TCHAR *pszSection;
    const TCHAR *pszKey;
    void *pValue;
    int  iFlags;
    int  iMask;
} INIDATA, *PINIDATA;

/*
 *  Structure used to define bits associated with control IDs
 */
typedef struct _BITINFO {   /* binf */
    WORD id;                /* Control ID (must be edit control) */
    BYTE bBit;              /* bit #; if bit 7 set, sense of bit reversed */
};
typedef const struct _BITINFO BINF;
typedef const struct _BITINFO *PBINF;

#define Z2(m)               ((m)&1?0:(m)&2?1:2)
#define Z4(m)               ((m)&3?Z2(m):Z2((m)>>2)+2)
#define Z8(m)               ((m)&15?Z4(m):Z4((m)>>4)+4)
#define Z16(m)              ((m)&255?Z8(m):Z8((m)>>8)+8)
#define Z32(m)              ((m)&65535?Z16(m):Z16((m)>>16)+16)
#define BITNUM(m)           Z32(m)

/*
 * Warning: There is some evil overloading of these switches because
 * there isn't enough time to do it `right'.
 *
 * VINF_AUTO means that a value of zero means `Auto' and a nonzero
 * value represents itself.
 *
 * VINF_AUTOMINMAX means that there are really two fields, a min and a
 * max.  If the two values are equal to each other, then the field value
 * is the common value, possibly zero for `None'.  Otherwise, the min
 * is iMin and the max is iMax, which indicates `Auto'.
 */

#define VINF_NONE           0x00
#define VINF_AUTO           0x01    /* integer field supports AUTO only */
#define VINF_AUTOMINMAX     0x02    /* integer field supports AUTO and NONE */

/*
 *  Structure used to validate integer parameters in property sheets.
 */
typedef struct _VALIDATIONINFO {/* vinf */
    BYTE off;               /* offset of integer in property structure */
    BYTE fbOpt;             /* See VINF_* constants */
    WORD id;                /* Control ID (must be edit control) */
    INT  iMin;              /* Minimum acceptable value */
    INT  iMax;              /* Maximum acceptable value */
    WORD idMsg;             /* Message resource for error message */
};
typedef const struct _VALIDATIONINFO VINF;
typedef const struct _VALIDATIONINFO *PVINF;

#define NUM_TICKS 20        /* Number of tick marks in slider control */

/*
 *  Macro to dispatch Help subsystem messages.
 */
#define HELP_CASES(rgdwHelp)                                        \
    case WM_HELP:               /* F1 or title-bar help button */   \
        OnWmHelp(lParam, &rgdwHelp[0]);                             \
        break;                                                      \
                                                                    \
    case WM_CONTEXTMENU:        /* right mouse click */             \
        OnWmContextMenu(wParam, &rgdwHelp[0]);                      \
        break;


/*
 *  Internal function prototypes
 */

/* XLATOFF */

#ifndef DEBUG
#define ASSERTFAIL()
#define ASSERTTRUE(exp)
#define ASSERTFALSE(exp)
#define VERIFYTRUE(exp)  (exp)
#define VERIFYFALSE(exp) (exp)
#else
#define ASSERTFAIL()     ASSERT(FALSE)
#define ASSERTTRUE(exp)  ASSERT((exp))
#define ASSERTFALSE(exp) ASSERT((!(exp)))
#define VERIFYTRUE(exp)  ASSERT((exp))
#define VERIFYFALSE(exp) ASSERT((!(exp)))
#endif

/*
 * CTASSERT  -- Assert at compile-time, standalone.
 * CTASSERTF -- Assert at compile-time, inside a function.
 */

#define CTASSERTF(c) switch (0) case 0: case c:
#define CTASSERTPP(c,l) \
    static INLINE void Assert##l(void) { CTASSERTF(c); }
#define CTASSERTP(c,l) CTASSERTPP(c,l)
#define CTASSERT(c) CTASSERTP(c,__LINE__)


/*
 * FunctionName allows us to make something happen on entry to every function.
 *
 * If SWAP_TUNING is defined, then the function name is squirted out the first
 * time it is called.  This is used to decide which functions should go into
 * the PRELOAD segment and which in the RARE segment.
 */

#ifndef DEBUG
#define FunctionName(f)
#else
#ifdef SWAP_TUNING
#define FunctionName(f) \
    static fSeen = 0; if (!fSeen) { OutputDebugString(#f TEXT("\r\n")); fSeen = 1; }
#else
#define FunctionName(f)
#endif
#endif


#ifdef WINNT
#ifdef UNICODE

// NT and UNICODE
#define NUM_DATA_PTRS 4
#else

// NT, but not UNICODE
#define NUM_DATA_PTRS 3
#endif

#else

// Neither NT or UNICODE
#define NUM_DATA_PTRS 2

#endif

#define LP386_INDEX 0
#define LPENH_INDEX 1
#define LPNT31_INDEX 2
#define LPNT40_INDEX 3

#ifdef WINNT
// Macro definitions that handle codepages 
//
#define CP_US       (UINT)437
#define CP_JPN      (UINT)932
#define CP_WANSUNG  (UINT)949
#define CP_TC       (UINT)950
#define CP_SC       (UINT)936

#define IsBilingualCP(cp) ((cp)==CP_JPN || (cp)==CP_WANSUNG)
#define IsFarEastCP(cp) ((cp)==CP_JPN || (cp)==CP_WANSUNG || (cp)==CP_TC || (cp)==CP_SC)
#endif

typedef LPVOID * DATAPTRS;


typedef int (*GETSETFN)(HANDLE hProps, LPCSTR lpszGroup, LPVOID lpProps, int cbProps, UINT flOpt);
typedef int (*DATAGETFN)(PPROPLINK ppl, DATAPTRS aDataPtrs, LPVOID lpData, int cbData, UINT flOpt);
typedef int (*DATASETFN)(PPROPLINK ppl, DATAPTRS aDataPtrs, LPCVOID lpData, int cbData, UINT flOpt);


/*
 *  Constant strings used in multiple places.
 *
 *  The null string is so popular, we keep a copy of it in each segment.
 */

extern const TCHAR c_szNULL[];     // Null string in nonresident code segment
extern const TCHAR r_szNULL[];     // Null string in resident code segment

extern TCHAR g_szNone[16];
extern TCHAR g_szAuto[16];

extern const TCHAR szNoPIFSection[];

extern CHAR szSTDHDRSIG[];
extern CHAR szW286HDRSIG30[];
extern CHAR szW386HDRSIG30[];
extern CHAR szWENHHDRSIG40[];

extern CHAR szCONFIGHDRSIG40[];
extern CHAR szAUTOEXECHDRSIG40[];

extern const TCHAR szDOSAPPDefault[];
extern const TCHAR szDOSAPPINI[];
extern const TCHAR szDOSAPPSection[];

// In alphabetical order, for sanity's sake.

extern const TCHAR sz386EnhSection[];
extern const TCHAR szDisplay[];
extern const TCHAR szTTDispDimKey[];
extern const TCHAR szTTInitialSizes[];

extern const TCHAR szNonWinSection[];
extern const TCHAR szPP4[];
extern const TCHAR szSystemINI[];
extern const TCHAR szWOAFontKey[];
extern const TCHAR szWOADBCSFontKey[];
extern const TCHAR szZero[];

// these are initialized at LoadGlobalFontData()
extern TCHAR szTTCacheSection[2][32];
extern CHAR szTTFaceName[2][LF_FACESIZE];

#ifdef  CUSTOMIZABLE_HEURISTICS
extern const TCHAR szTTHeuristics[];
extern const TCHAR szTTNonAspectMin[];
#endif

extern const TCHAR *apszAppType[];

// pifdll.asm
void GetSetExtendedData(DWORD hVM, WORD wGroup, LPCTSTR lpszGroup, LPVOID lpProps);
WORD GetVxDVersion(WORD wVxdId);
BOOL IsBufferDifferent(LPVOID lpv1, LPVOID lpv2, UINT cb);
#ifndef WIN32
void BZero(LPVOID lpvBuf, UINT cb);
#else
#define BZero(lpvBuf,cb) ZeroMemory(lpvBuf,(DWORD)cb)
#endif
#ifndef WINNT
WORD flEmsSupport(void);
#endif

// pifmgr.c

void GetINIData(void);
void InitProperties(PPROPLINK ppl, BOOL fLocked);

PPROPLINK ValidPropHandle(HANDLE hProps);
int   ResizePIFData(PPROPLINK ppl, int cbResize);
BOOL  GetPIFData(PPROPLINK ppl, BOOL fLocked);
BOOL  FlushPIFData(PPROPLINK ppl, BOOL fDiscard);

LPWENHPIF40 AddEnhancedData(PPROPLINK ppl, LPW386PIF30 lp386);
BOOL        AddGroupData(PPROPLINK ppl, LPCSTR lpszGroup, LPVOID lpGroup, int cbGroup);
BOOL        RemoveGroupData(PPROPLINK ppl, LPCSTR lpszGroup);
LPVOID      GetGroupData(PPROPLINK ppl, LPCSTR lpszGroup, LPINT lpcbGroup, LPPIFEXTHDR *lplpph);

// pifdat.c


int GetPrgData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPPRG lpPrg, int cb, UINT flOpt);
int SetPrgData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPPRG lpPrg, int cb, UINT flOpt);
int GetTskData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPTSK lpTsk, int cb, UINT flOpt);
int SetTskData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPTSK lpTsk, int cb, UINT flOpt);
int GetVidData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPVID lpVid, int cb, UINT flOpt);
int SetVidData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPVID lpVid, int cb, UINT flOpt);
int GetMemData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPMEM lpMem, int cb, UINT flOpt);
int SetMemData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPMEM lpMem, int cb, UINT flOpt);
int GetKbdData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPKBD lpKbd, int cb, UINT flOpt);
int SetKbdData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPKBD lpKbd, int cb, UINT flOpt);
int GetMseData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPMSE lpMse, int cb, UINT flOpt);
int SetMseData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPMSE lpMse, int cb, UINT flOpt);
int GetSndData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPSND lpSnd, int cb, UINT flOpt);
int SetSndData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPSND lpSnd, int cb, UINT flOpt);
int GetFntData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPFNT lpFnt, int cb, UINT flOpt);
int SetFntData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPFNT lpFnt, int cb, UINT flOpt);
int GetWinData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPWIN lpWin, int cb, UINT flOpt);
int SetWinData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPWIN lpWin, int cb, UINT flOpt);
int GetEnvData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPENV lpEnv, int cb, UINT flOpt);
int SetEnvData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPENV lpEnv, int cb, UINT flOpt);
#ifdef WINNT
int GetNt31Data(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPNT31 lpNt31, int cb, UINT flOpt);
int SetNt31Data(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPNT31 lpNt31, int cb, UINT flOpt);
#endif
#ifdef UNICODE
int GetNt40Data(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPNT40 lpNt40, int cb, UINT flOpt);
int SetNt40Data(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPNT40 lpNt40, int cb, UINT flOpt);
#endif


void CopyIniWordsToFntData(LPPROPFNT lpFnt, LPINIINFO lpii, int cWords);
void CopyIniWordsToWinData(LPPROPWIN lpWin, LPINIINFO lpii, int cWords);

// These could be defined as WINAPI if we ever wanted to export them back to WinOldAp

WORD GetIniWords(LPCTSTR lpszSection, LPCTSTR lpszEntry, LPWORD lpwBuf, WORD cwBuf, LPCTSTR lpszFilename);
WORD ParseIniWords(LPCTSTR lpsz, LPWORD lpwBuf, WORD cwBuf, LPTSTR *lplpsz);
BOOL WriteIniWords(LPCTSTR lpszSection, LPCTSTR lpszEntry, LPCWORD lpwBuf, WORD cwBuf, LPCTSTR lpszFilename);

// piflib.c

BOOL LoadGlobalEditData(void);
void FreeGlobalEditData(void);
void InitRealModeFlag(PPROPLINK ppl);

// pifprg.c

BOOL_PTR CALLBACK DlgPrgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
#ifdef UNICODE
HICON LoadPIFIcon(LPPROPPRG lpprg, LPPROPNT40 lpnt40);
#else
HICON LoadPIFIcon(LPPROPPRG lpprg);
#endif

// pifvid.c

BOOL_PTR CALLBACK DlgVidProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// pifmem.c

BOOL_PTR CALLBACK DlgMemProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// pifmsc.c

BOOL_PTR CALLBACK DlgMscProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// pifhot.c

typedef struct PIFKEY { /* PIF_Ky */
        WORD    Scan;   /* Scan code in lower byte */
        WORD    ShVal;  /* Shift state */
        WORD    ShMsk;  /* Mask for shift states interested in */
        BYTE    Val;    /* Enhanced key stuff */
        BYTE    Pad[9]; /* Pad PIF struc to MAXHKYINFOSIZE bytes */
} PIFKEY;
typedef UNALIGNED PIFKEY *LPPIFKEY;
typedef const UNALIGNED PIFKEY *LPCPIFKEY;

WORD HotKeyWindowsFromOem(LPCPIFKEY lppifkey);
void HotKeyOemFromWindows(LPPIFKEY lppifkey, WORD wHotKey);

// pifsub.c

void    lstrcpypadA(LPSTR lpszDst, LPCSTR lpszSrc, int cbMax);
int     lstrcpyncharA(LPSTR lpszDst, LPCSTR lpszSrc, int cbMax, CHAR ch);
int     lstrskipcharA(LPCSTR lpszSrc, CHAR ch);
int     lstrskiptocharA(LPCSTR lpszSrc, CHAR ch);
int     lstrcpyfnameA(PSTR pszDest, size_t cchDest, PCSTR pszSrc);
int     lstrunquotefnameA(LPSTR lpszDst, LPCSTR lpszSrc, int cbMax, BOOL fShort);
int     lstrskipfnameA(LPCSTR lpszSrc);

int cdecl Warning(HWND hwnd, WORD id, WORD type, ...);
int MemoryWarning(HWND hwnd);
LPTSTR LoadStringSafe(HWND hwnd, UINT id, LPTSTR lpsz, int cbsz);
void SetDlgBits(HWND hDlg, PBINF pbinf, UINT cbinf, WORD wFlags);
void GetDlgBits(HWND hDlg, PBINF pbinf, UINT cbinf, LPWORD lpwFlags);
void SetDlgInts(HWND hDlg, PVINF pvinf, UINT cvinf, LPVOID lp);
void AddDlgIntValues(HWND hDlg, int id, int iMax);
void GetDlgInts(HWND hDlg, PVINF pvinf, int cvinf, LPVOID lp);
BOOL ValidateDlgInts(HWND hDlg, PVINF pvinf, int cvinf);

void LimitDlgItemText(HWND hDlg, int iCtl, UINT uiLimit);
void SetDlgItemPct(HWND hDlg, int iCtl, UINT uiPct);
UINT GetDlgItemPct(HWND hDlg, int iCtl);
void SetDlgItemPosRange(HWND hDlg, int iCtl, UINT uiPos, DWORD dwRange);
UINT GetDlgItemPos(HWND hDlg, int iCtl);
BOOL AdjustRealModeControls(PPROPLINK ppl, HWND hDlg);
void BrowsePrograms(HWND hDlg, UINT uiCtl, UINT uiCwd);
void OnWmHelp(LPARAM lparam, const DWORD *pdwHelp);
void OnWmContextMenu(WPARAM wparam, const DWORD *pdwHelp);
#ifdef UNICODE
void PifMgr_WCtoMBPath( LPWSTR lpUniPath, LPSTR lpAnsiPath, UINT cchBuf );
#endif

void PifMgrDLL_Init();

#ifdef  DEBUG
void DebugASSERT(TCHAR *pszModule, int line);
#endif

extern TCHAR   *pszNoMemory;

extern CHAR szRasterFaceName[];

#endif /* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\printer1.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "printer.h"
#include "copy.h"
#include "ids.h"

typedef struct
{
    UINT  uAction;
    LPTSTR lpBuf1;
    LPTSTR lpBuf2;
} PRINTERS_RUNDLL_INFO, *LPPRI;

// forward prototypes
void Printer_OpenMe(LPCTSTR pName, LPCTSTR pServer, BOOL fModal);
void Printers_ProcessCommand(HWND hwndStub, LPPRI lpPRI, BOOL fModal);

TCHAR const c_szPrintersGetCommand_RunDLL[] = TEXT("SHELL32,PrintersGetCommand_RunDLL");

//
// if uAction IS NOT MSP_NEWDRIVER then:
//    installs a printer (uAction).  If successful, notifies the shell and
//    returns a pidl to the printer.  ILFree() is callers responsibility.
// otherwise, if uAction IS MSP_NEWDRIVER then:
//    installs a printer driver (uAction).  If successful, fills the new
//    driver's name into pszPrinter (ASSUMED >= MAXNAMELEN).
//    Always returns NULL.
// if uAction is MSP_TESTPAGEPARTIALPROMPT then:
//    executes the test page code
//    Always returns NULL.
//

LPITEMIDLIST Printers_PrinterSetup(HWND hwnd, UINT uAction, LPTSTR pszPrinter, DWORD cchBufSize, LPCTSTR pszServer)
{
    LPITEMIDLIST pidl = NULL;
    TCHAR szPrinter[MAXNAMELENBUFFER];
    DWORD cchBufLen;

    // HACK! This hack is related to BUG #272207
    // This function is called from Printers_DeletePrinter for
    // printer deletion and this case we should not check
    // for REST_NOPRINTERADD restriction. -LazarI

    if (MSP_NEWPRINTER == uAction ||
        MSP_NETPRINTER == uAction ||
        MSP_NEWPRINTER_MODELESS == uAction)
    {
        if (SHIsRestricted(hwnd, REST_NOPRINTERADD))
        {
            return NULL;
        }
    }

    cchBufLen = ARRAYSIZE(szPrinter);
    if (pszPrinter)
        StringCchCopy(szPrinter, ARRAYSIZE(szPrinter), pszPrinter);
    else
        szPrinter[0] = 0;

    // We don't have to worry about PrinterSetup failing due to the
    // output buffer being too small.  It's the right size (MAXNAMELENBUFFER)
    if (bPrinterSetup(hwnd, LOWORD(uAction), cchBufLen, szPrinter, &cchBufLen, pszServer))
    {
        if (uAction == MSP_NEWDRIVER)
        {
            StringCchCopy(pszPrinter, cchBufSize, szPrinter);
        }
        else if (uAction == MSP_TESTPAGEPARTIALPROMPT)
        {
            // nothing to do for this case
        }
        else if (uAction == MSP_REMOVEPRINTER || uAction == MSP_NEWPRINTER_MODELESS || uAction == MSP_REMOVENETPRINTER)
        {
            // a bit ugly, but we need to pass back success for this case
            pidl = (LPITEMIDLIST)TRUE;
        }
        else
        {
            // do not validate the printer PIDL here because the validation mechanism in ParseDisplayName 
            // is using the folder cache and since we just added it may still not be in the folder cache, 
            // and we fail, although this a valid local printer/connection already.
            ParsePrinterNameEx(szPrinter, &pidl, TRUE, 0, 0);
        }
    }

    return pidl;
}

SHSTDAPI_(BOOL) SHInvokePrinterCommand(
    IN HWND    hwnd,
    IN UINT    uAction,
    IN LPCTSTR lpBuf1,
    IN LPCTSTR lpBuf2,
    IN BOOL    fModal)
{
    PRINTERS_RUNDLL_INFO PRI;

    PRI.uAction = uAction;
    PRI.lpBuf1 = (LPTSTR)lpBuf1;
    PRI.lpBuf2 = (LPTSTR)lpBuf2;

    Printers_ProcessCommand(hwnd, &PRI, fModal);

    return TRUE;
}

SHSTDAPI_(BOOL)
SHInvokePrinterCommandA(
    IN HWND    hwnd,
    IN UINT    uAction,
    IN LPCSTR  lpBuf1,      OPTIONAL
    IN LPCSTR  lpBuf2,      OPTIONAL
    IN BOOL    fModal)
{
    WCHAR szBuf1[MAX_PATH];
    WCHAR szBuf2[MAX_PATH];

    BOOL bSuccess = TRUE;

    if (bSuccess && lpBuf1)
    {
        bSuccess = (MultiByteToWideChar(CP_ACP, 0, lpBuf1, -1, szBuf1, SIZECHARS(szBuf1)) > 0);
        lpBuf1 = bSuccess ? (LPCSTR)szBuf1 : NULL;
    }

    if (bSuccess && lpBuf2)
    {
        bSuccess = (MultiByteToWideChar(CP_ACP, 0, lpBuf2, -1, szBuf2, SIZECHARS(szBuf2)) > 0);
        lpBuf2 = bSuccess ? (LPCSTR)szBuf2 : NULL;
    }

    if (bSuccess)
    {
        bSuccess = SHInvokePrinterCommand(hwnd, uAction, (LPCWSTR)lpBuf1, (LPCWSTR)lpBuf2, fModal);
    }

    return bSuccess;
}

void WINAPI PrintersGetCommand_RunDLL_Common(HWND hwndStub, HINSTANCE hAppInstance, LPTSTR lpszCmdLine, int nCmdShow)
{
    PRINTERS_RUNDLL_INFO    PRI;
    UINT cchBuf1;
    UINT cchBuf2;
    LPTSTR lpComma;
    LPTSTR lpCommaNext;
    lpComma = StrChr(lpszCmdLine,TEXT(','));
    if (lpComma == NULL)
    {
        goto BadCmdLine;
    }
    *lpComma = TEXT('\0');        // Terminate it here
    PRI.uAction = StrToLong(lpszCmdLine);

    lpCommaNext = StrChr(lpComma+1,TEXT(','));
    if (lpCommaNext == NULL)
    {
        goto BadCmdLine;
    }
    *lpCommaNext = TEXT('\0');        // Terminate it here
    cchBuf1 = StrToLong(lpComma+1);
    lpComma = lpCommaNext;

    lpCommaNext = StrChr(lpComma+1,TEXT(','));
    if (lpCommaNext == NULL)
    {
        goto BadCmdLine;
    }
    *lpCommaNext = TEXT('\0');        // Terminate it here
    cchBuf2 = StrToLong(lpComma+1);
    lpComma = lpCommaNext;

    PRI.lpBuf1 = lpComma+1;     // Just past the comma

    //
    // Make sure cchBuf1 & cchBuf2 are correct which means that the length 
    // of the remainder of the string should be either equal to cchBuf1 if 
    // cchBuf2 is equal to zero, OR equal to (cchBuf1 + cchBuf2 + 1) if 
    // cchBuf2 is not equal to zero.
    //
    if (lstrlen(PRI.lpBuf1) != (int)(cchBuf1 + ((!!cchBuf2) * (cchBuf2 + 1))))
    {
        goto BadCmdLine;
    }

    *(PRI.lpBuf1+cchBuf1) = '\0';

    if (cchBuf2 == 0)
    {
        PRI.lpBuf2 = NULL;
    }
    else
    {
        PRI.lpBuf2 = PRI.lpBuf1+cchBuf1+1;
    }

    // Make this modal.
    Printers_ProcessCommand(hwndStub, &PRI, TRUE);
    return;

BadCmdLine:
    DebugMsg(DM_ERROR, TEXT("pgc_rd: bad command line: %s"), lpszCmdLine);
    return;
}

void WINAPI PrintersGetCommand_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    int iLen;
    HRESULT hrInit = SHOleInitialize(0);

    if (lpszCmdLine)
    {
        //
        // Call WideCharToMultiByte to properly calculate the destination buffer length.
        //
        iLen = MultiByteToWideChar(CP_ACP, 0, lpszCmdLine, -1, NULL, 0);

        //
        // MultiByteToWideChar returns zero if the conversion fails.
        //
        if (iLen > 0)
        {
            LPWSTR lpwszCmdLine = (LPWSTR)LocalAlloc(LPTR, iLen * sizeof(WCHAR));

            //
            // Check if LocalAlloc has succeeded.
            //
            if (lpwszCmdLine)
            {
                iLen = MultiByteToWideChar(CP_ACP, 0, lpszCmdLine, -1, lpwszCmdLine, iLen);

                //
                // MultiByteToWideChar returns zero if the conversion fails.
                //
                if (iLen > 0)
                {
                    PrintersGetCommand_RunDLL_Common(hwndStub,
                                                     hAppInstance,
                                                     lpwszCmdLine,
                                                     nCmdShow);
                }

                LocalFree(lpwszCmdLine);
            }
        }
    }

    SHOleUninitialize(hrInit);
}

void WINAPI PrintersGetCommand_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
    PrintersGetCommand_RunDLL_Common( hwndStub,
                                      hAppInstance,
                                      lpwszCmdLine,
                                      nCmdShow );
}

static void 
HandleOpenPrinter(HWND hwnd, LPCTSTR pszPrinter, BOOL fModal, BOOL bConnect)
{
    BOOL                bPrinterOK = FALSE;
    DWORD               dwError = ERROR_SUCCESS;
    TCHAR               szPrinter[MAXNAMELENBUFFER];
    HANDLE              hPrinter = NULL;
    LPITEMIDLIST        pidl = NULL;
    PRINTER_INFO_2     *pPrinter = NULL;

    // we need to open the printer and get the real printer name in case
    // the passed in printer name is a sharename
    lstrcpyn(szPrinter, pszPrinter, ARRAYSIZE(szPrinter));
    hPrinter = Printer_OpenPrinter(szPrinter);
    if (hPrinter)
    {
        pPrinter = (PRINTER_INFO_2 *)Printer_GetPrinterInfo(hPrinter, 2);
        if (pPrinter)
        {
            if (pPrinter->pPrinterName && pPrinter->pPrinterName[0])
            {
                // copy the real printer name
                bPrinterOK = TRUE;
                lstrcpyn(szPrinter, pPrinter->pPrinterName, ARRAYSIZE(szPrinter));
            }
            LocalFree((HLOCAL)pPrinter);
        }
        else
        {
            // save last error
            dwError = GetLastError();
        }
        Printer_ClosePrinter(hPrinter);
    }
    else
    {
        // save last error
        dwError = GetLastError();
    }

    if (bPrinterOK)
    {
        if (bConnect)
        {
            // if the printer is not installed then we'll silently install it
            // since this is what most users will expect.
            if (FAILED(ParsePrinterName(szPrinter, &pidl)))
            {
                // connect....
                pidl = Printers_PrinterSetup(hwnd, MSP_NETPRINTER, szPrinter, 0, NULL);

                if (pidl)
                {
                    // get the real printer name from the printer's folder...
                    SHGetNameAndFlags(pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szPrinter, ARRAYSIZE(szPrinter), NULL);
                    ILFree(pidl);
                }
                else
                {
                    // failed to install the printer (it shows UI, so we shouldn't)
                    bPrinterOK = FALSE;
                }
            }
            else
            {
                // the printer is already installed
                ILFree(pidl);
            }
        }

        if (bPrinterOK)
        {
            Printer_OpenMe(szPrinter, NULL, fModal);
        }
    }
    else
    {
        // something else failed -- show up an error message
        ShowErrorMessageSC(NULL, NULL, hwnd, NULL, NULL, MB_OK|MB_ICONEXCLAMATION, dwError);
    }
}

/********************************************************************

    lpPRI structure description based on uAction.

    uAction             lpBuf1   lpBuf2

    OPEN,               printer, server
    PROPERTIES,         printer, SheetName
    NETINSTALL,         printer,
    NETINSTALLLINK,     printer, target directory to create link
    OPENNETPRN,         printer,
    TESTPAGE            printer

********************************************************************/

void Printers_ProcessCommand(HWND hwndStub, LPPRI lpPRI, BOOL fModal)
{
    switch (lpPRI->uAction)
    {
    case PRINTACTION_OPEN:
        if (!lstrcmpi(lpPRI->lpBuf1, c_szNewObject))
        {
            Printers_PrinterSetup(hwndStub, MSP_NEWPRINTER_MODELESS,
                                  lpPRI->lpBuf1, 0, lpPRI->lpBuf2);
        }
        else
        {
            HandleOpenPrinter(hwndStub, lpPRI->lpBuf1, fModal, FALSE);
        }
        break;

    case PRINTACTION_SERVERPROPERTIES:
    {
        LPCTSTR pszServer = (LPTSTR)(lpPRI->lpBuf1);

        // we should never get called with c_szNewObject
        ASSERT(lstrcmpi(lpPRI->lpBuf1, c_szNewObject));
        vServerPropPages(hwndStub, pszServer, SW_SHOWNORMAL, 0);
        break;
    }
    case PRINTACTION_DOCUMENTDEFAULTS:
    {
        // we should never get called with c_szNewObject
        ASSERT(lstrcmpi(lpPRI->lpBuf1, c_szNewObject));
        vDocumentDefaults(hwndStub, lpPRI->lpBuf1, SW_SHOWNORMAL, (LPARAM)(lpPRI->lpBuf2));
        break;
    }

    case PRINTACTION_PROPERTIES:
    {
        // we should never get called with c_szNewObject
        ASSERT(lstrcmpi(lpPRI->lpBuf1, c_szNewObject));
        vPrinterPropPages(hwndStub, lpPRI->lpBuf1, SW_SHOWNORMAL, (LPARAM)(lpPRI->lpBuf2));
        break;
    }

    case PRINTACTION_NETINSTALLLINK:
    case PRINTACTION_NETINSTALL:
    {
        LPITEMIDLIST pidl = Printers_PrinterSetup(hwndStub, MSP_NETPRINTER, lpPRI->lpBuf1, 0, NULL);
        if (pidl)
        {
            if (lpPRI->uAction == PRINTACTION_NETINSTALLLINK)
            {
                IDataObject *pdtobj;
                if (SUCCEEDED(SHGetUIObjectFromFullPIDL(pidl, NULL, IID_PPV_ARG(IDataObject, &pdtobj))))
                {
                    SHCreateLinks(hwndStub, lpPRI->lpBuf2, pdtobj, SHCL_USETEMPLATE, NULL);
                    pdtobj->lpVtbl->Release(pdtobj);
                }
            }
            ILFree(pidl);
        }

        break;
    }

    case PRINTACTION_OPENNETPRN:
    {
        HandleOpenPrinter(hwndStub, lpPRI->lpBuf1, fModal, TRUE);
        break;
    } // case PRINTACTION_OPENNETPRN

    case PRINTACTION_TESTPAGE:
        Printers_PrinterSetup(hwndStub, MSP_TESTPAGEPARTIALPROMPT,
                        lpPRI->lpBuf1, 0, NULL);
        break;

    default:
        DebugMsg(TF_WARNING, TEXT("PrintersGetCommand_RunDLL() received unrecognized uAction %d"), lpPRI->uAction);
        break;
    }
}

void Printer_OpenMe(LPCTSTR pName, LPCTSTR pServer, BOOL fModal)
{
    BOOL fOpened = FALSE;
    HKEY hkeyPrn;
    TCHAR buf[50+MAXNAMELEN];

    StringCchPrintf(buf, ARRAYSIZE(buf), TEXT("Printers\\%s"), pName);
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT, buf, &hkeyPrn))
    {
        SHELLEXECUTEINFO sei =
        {
            SIZEOF(SHELLEXECUTEINFO),
            SEE_MASK_CLASSKEY | SEE_MASK_FLAG_NO_UI, // fMask
            NULL,                       // hwnd - queue view should not be modal on the printer's folder, make it top level
            NULL,                       // lpVerb
            pName,                      // lpFile
            NULL,                       // lpParameters
            NULL,                       // lpDirectory
            SW_SHOWNORMAL,              // nShow
            NULL,                       // hInstApp
            NULL,                       // lpIDList
            NULL,                       // lpClass
            hkeyPrn,                    // hkeyClass
            0,                          // dwHotKey
            NULL                        // hIcon
        };

        fOpened = ShellExecuteEx(&sei);

        RegCloseKey(hkeyPrn);
    }

    if (!fOpened)
    {
        vQueueCreate(NULL, pName, SW_SHOWNORMAL, (LPARAM)fModal);
    }
}

//
// Arguments:
//  pidl -- (absolute) pidl to the object of interest
//
// Return '"""<Printer Name>""" """<Driver Name>""" """<Path>"""' if success,
//        NULL if failure
//
// We need """ because shlexec strips the outer quotes and converts "" to "
//
UINT Printer_GetPrinterInfoFromPidl(LPCITEMIDLIST pidl, LPTSTR *plpParms)
{
    LPTSTR lpBuffer = NULL;
    UINT uErr = ERROR_NOT_ENOUGH_MEMORY;
    HANDLE hPrinter;
    TCHAR szPrinter[MAXNAMELENBUFFER];

    SHGetNameAndFlags(pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szPrinter, ARRAYSIZE(szPrinter), NULL);
    hPrinter = Printer_OpenPrinter(szPrinter);
    if (NULL == hPrinter)
    {
        // fallback to the full name in case this was as \\server\share
        // printer drop target
        SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPrinter, ARRAYSIZE(szPrinter), NULL);
        hPrinter = Printer_OpenPrinter(szPrinter);
    }

    if (hPrinter)
    {
        PRINTER_INFO_5 *pPrinter;
        pPrinter = Printer_GetPrinterInfo(hPrinter, 5);
        if (pPrinter)
        {
            DRIVER_INFO_2 *pPrinterDriver;
            pPrinterDriver = Printer_GetPrinterDriver(hPrinter, 2);
            if (pPrinterDriver)
            {
                LPTSTR lpDriverName = PathFindFileName(pPrinterDriver->pDriverPath);
                DWORD  cchBufSize = 2+lstrlen(szPrinter)+1+
                                    2+lstrlen(lpDriverName)+1+
                                    2+lstrlen(pPrinter->pPortName)+1;
                lpBuffer = (void*)LocalAlloc(LPTR, cchBufSize * SIZEOF(TCHAR));
                if (lpBuffer)
                {
                    StringCchPrintf(lpBuffer, cchBufSize, TEXT("\"%s\" \"%s\" \"%s\""),
                             szPrinter, lpDriverName, pPrinter->pPortName);
                    uErr = ERROR_SUCCESS;
                }

                LocalFree((HLOCAL)pPrinterDriver);
            }
            LocalFree((HLOCAL)pPrinter);
        }
        Printer_ClosePrinter(hPrinter);
    }
    else
    {
        // HACK: special case this error return in calling function,
        // as we need a special error message
        uErr = ERROR_SUCCESS;
    }

    *plpParms = lpBuffer;

    return(uErr);
}


//
// Arguments:
//  hwndParent -- Specifies the parent window.
//  szFilePath -- The file to printed.
//
void Printer_PrintFile(HWND hWnd, LPCTSTR pszFilePath, LPCITEMIDLIST pidl)
{
    UINT             uErr;
    LPTSTR           lpParms       = NULL;
    BOOL             bTryPrintVerb = TRUE;
    BOOL             bShowError    = FALSE;
    LPITEMIDLIST     pidlFull      = NULL;
    SHELLEXECUTEINFO ExecInfo      = {0};


    uErr = Printer_GetPrinterInfoFromPidl(pidl, &lpParms);
    if (uErr != ERROR_SUCCESS)
    {
        bShowError = TRUE;
    }
    if (!bShowError && !lpParms)
    {
        // If you rename a printer and then try to use a link to that
        // printer, we hit this case. Also, if you get a link to a printer
        // on another computer, we'll likely hit this case.
        ShellMessageBox(HINST_THISDLL, hWnd,
            MAKEINTRESOURCE(IDS_CANTPRINT),
            MAKEINTRESOURCE(IDS_PRINTERS),
            MB_OK|MB_ICONEXCLAMATION);
        return;
    }

    //
    // Get the context menu for the file
    //

    pidlFull = ILCreateFromPath( pszFilePath );
    if (!bShowError && pidlFull)
    {
        //
        // Try the "printto" verb first...
        //

        ExecInfo.cbSize         = sizeof(ExecInfo);
        ExecInfo.fMask          = SEE_MASK_UNICODE | SEE_MASK_INVOKEIDLIST |
                                  SEE_MASK_IDLIST  | SEE_MASK_FLAG_NO_UI;
        ExecInfo.hwnd           = hWnd;
        ExecInfo.lpVerb         = c_szPrintTo;
        ExecInfo.lpParameters   = lpParms;
        ExecInfo.nShow          = SW_SHOWNORMAL;
        ExecInfo.lpIDList       = pidlFull;

        if (!ShellExecuteEx( &ExecInfo ))
        {
            //
            // Since we can't print specifying the printer name (i.e., printto),
            // our next option is to print to the default printer.  However,
            // that might not be the printer the user dragged the files onto
            // so check here and let the user set the desired printer to be
            // the default if they want...
            //

            TCHAR szPrinter[MAXNAMELENBUFFER];
            SHGetNameAndFlags(pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szPrinter, ARRAYSIZE(szPrinter), NULL);

            if (!IsDefaultPrinter(szPrinter, 0))
            {
                //
                // this isn't the default printer, ask first
                //

                if (IDYES==ShellMessageBox(
                        HINST_THISDLL, GetTopLevelAncestor(hWnd),
                        MAKEINTRESOURCE(IDS_CHANGEDEFAULTPRINTER),
                        MAKEINTRESOURCE(IDS_PRINTERS),
                        MB_YESNO|MB_ICONEXCLAMATION))
                {
                    Printer_SetAsDefault(szPrinter);
                }
                else
                {
                    bTryPrintVerb = FALSE;
                }

            }

            if (bTryPrintVerb)
            {
                //
                // Try the "print" verb
                //

                ExecInfo.lpVerb = c_szPrint;

                if (!ShellExecuteEx( &ExecInfo ))
                {
                    uErr = GetLastError();
                    bShowError = TRUE;
                }
            }

        }

        ILFree(pidlFull);
    }

    if (lpParms)
        LocalFree((HLOCAL)lpParms);

    if (bShowError)
    {
        ShellMessageBox(HINST_THISDLL, hWnd, 
            MAKEINTRESOURCE(IDS_ERRORPRINTING),
            MAKEINTRESOURCE(IDS_PRINTERS),
            MB_OK|MB_ICONEXCLAMATION);
    }
}


BOOL Printer_ModifyPrinter(LPCTSTR lpszPrinterName, DWORD dwCommand)
{
    HANDLE hPrinter = Printer_OpenPrinterAdmin(lpszPrinterName);
    BOOL fRet = FALSE;
    if (hPrinter)
    {
        fRet = SetPrinter(hPrinter, 0, NULL, dwCommand);
        Printer_ClosePrinter(hPrinter);
    }
    return fRet;
}

BOOL IsAvoidAutoDefaultPrinter(LPCTSTR pszPrinter);

// this will find the first printer (if any) and set  it as the default
// and inform the user
void Printers_ChooseNewDefault(HWND hwnd)
{
    PRINTER_INFO_4 *pPrinters = NULL;
    DWORD iPrinter, dwNumPrinters = Printers_EnumPrinters(NULL,
                                          PRINTER_ENUM_LOCAL | PRINTER_ENUM_FAVORITE,
                                          4,
                                          &pPrinters);
    if (dwNumPrinters)
    {
        if (pPrinters)
        {
            for (iPrinter = 0 ; iPrinter < dwNumPrinters ; iPrinter++)
            {
                if (!IsAvoidAutoDefaultPrinter(pPrinters[iPrinter].pPrinterName))
                    break;
            }
            if (iPrinter == dwNumPrinters)
            {
                dwNumPrinters = 0;
            }
            else
            {
                Printer_SetAsDefault(pPrinters[iPrinter].pPrinterName);
            }
        }
        else
        {
            dwNumPrinters = 0;
        }
    }

    // Inform user
    if (dwNumPrinters)
    {
        ShellMessageBox(HINST_THISDLL,
                        hwnd,
                        MAKEINTRESOURCE(IDS_DELNEWDEFAULT),
                        MAKEINTRESOURCE(IDS_PRINTERS),
                        MB_OK,
                        pPrinters[iPrinter].pPrinterName);
    }
    else
    {
        Printer_SetAsDefault(NULL); // clear the default printer
        ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_DELNODEFAULT),
                    MAKEINTRESOURCE(IDS_PRINTERS),  MB_OK);
    }

    if (pPrinters)
        LocalFree((HLOCAL)pPrinters);
}

BOOL Printer_SetAsDefault(LPCTSTR lpszPrinterName)
{
    TCHAR szDefaultPrinterString[MAX_PATH * 2];
    TCHAR szBuffer[MAX_PATH * 2];

    if (lpszPrinterName)
    {
        // Not the default, set it.
        if( !GetProfileString( TEXT( "Devices" ), lpszPrinterName, TEXT( "" ), szBuffer, ARRAYSIZE( szBuffer )))
        {
            return FALSE;
        }

        StringCchCopy(szDefaultPrinterString, ARRAYSIZE(szDefaultPrinterString), lpszPrinterName);
        StringCchCat(szDefaultPrinterString, ARRAYSIZE(szDefaultPrinterString), TEXT( "," ));
        StringCchCat(szDefaultPrinterString, ARRAYSIZE(szDefaultPrinterString), szBuffer );

        //
        // Use the new string for Windows.Device.
        //
        lpszPrinterName = szDefaultPrinterString;
    }

    if (!WriteProfileString( TEXT( "Windows" ), TEXT( "Device" ), lpszPrinterName ))
    {
        return FALSE;
    }

    // Tell the world and make everyone flash.
    SendNotifyMessage( HWND_BROADCAST, WM_WININICHANGE, 0, (LPARAM)TEXT( "Windows" ));

   return TRUE;
}

void *Printer_EnumProps(HANDLE hPrinter, DWORD dwLevel, DWORD *lpdwNum,
    ENUMPROP lpfnEnum, void *lpData)
{
    DWORD dwSize, dwNeeded;
    LPBYTE pEnum;

    dwSize = 0;
    SetLastError(0);
    lpfnEnum(lpData, hPrinter, dwLevel, NULL, 0, &dwSize, lpdwNum);
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        pEnum = NULL;
        goto Error1;
    }

    ASSERT(dwSize < 0x100000L);

    pEnum = (void*)LocalAlloc(LPTR, dwSize);
TryAgain:
    if (!pEnum)
    {
        goto Error1;
    }

    SetLastError(0);
    if (!lpfnEnum(lpData, hPrinter, dwLevel, pEnum, dwSize, &dwNeeded, lpdwNum))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            LPBYTE pTmp;
            dwSize = dwNeeded;
            pTmp = (void*)LocalReAlloc((HLOCAL)pEnum, dwSize,
                    LMEM_MOVEABLE|LMEM_ZEROINIT);
            if (pTmp)
            {
                pEnum = pTmp;
                goto TryAgain;
            }
        }

        LocalFree((HLOCAL)pEnum);
        pEnum = NULL;
    }

Error1:
    return pEnum;
}


BOOL Printers_EnumPrintersCB(void *lpData, HANDLE hPrinter, DWORD dwLevel,
    LPBYTE pEnum, DWORD dwSize, DWORD *lpdwNeeded, DWORD *lpdwNum)
{
    return EnumPrinters(PtrToUlong(lpData), (LPTSTR)hPrinter, dwLevel,
                             pEnum, dwSize, lpdwNeeded, lpdwNum);
}

DWORD Printers_EnumPrinters(LPCTSTR pszServer, DWORD dwType, DWORD dwLevel, void **ppPrinters)
{
    DWORD dwNum = 0L;

    //
    // If the server is szNULL, pass in NULL, since EnumPrinters expects
    // this for the local server.
    //
    if (pszServer && !pszServer[0])
    {
        pszServer = NULL;
    }

    *ppPrinters = Printer_EnumProps((HANDLE)pszServer, dwLevel, &dwNum, Printers_EnumPrintersCB, ULongToPtr(dwType));
    if (*ppPrinters==NULL)
    {
        dwNum = 0;
    }
    return dwNum;
}

BOOL Printers_FolderEnumPrintersCB(void *lpData, HANDLE hFolder, DWORD dwLevel,
    LPBYTE pEnum, DWORD dwSize, DWORD *lpdwNeeded, DWORD *lpdwNum)
{
    return bFolderEnumPrinters(hFolder, (PFOLDER_PRINTER_DATA)pEnum,
                                   dwSize, lpdwNeeded, lpdwNum);
}

DWORD Printers_FolderEnumPrinters(HANDLE hFolder, void **ppPrinters)
{
    DWORD dwNum = 0L;

    *ppPrinters = Printer_EnumProps(hFolder, 0, &dwNum,
                                    Printers_FolderEnumPrintersCB,
                                    NULL);
    if (*ppPrinters==NULL)
    {
        dwNum=0;
    }
    return dwNum;
}

BOOL Printers_FolderGetPrinterCB(void *lpData, HANDLE hFolder, DWORD dwLevel,
    LPBYTE pEnum, DWORD dwSize, DWORD *lpdwNeeded, DWORD *lpdwNum)
{
    return bFolderGetPrinter(hFolder, (LPCTSTR)lpData, (PFOLDER_PRINTER_DATA)pEnum, dwSize, lpdwNeeded);
}


void *Printer_FolderGetPrinter(HANDLE hFolder, LPCTSTR pszPrinter)
{
    return Printer_EnumProps(hFolder, 0, NULL, Printers_FolderGetPrinterCB, (LPVOID)pszPrinter);
}

BOOL Printers_GetPrinterDriverCB(void *lpData, HANDLE hPrinter, DWORD dwLevel,
    LPBYTE pEnum, DWORD dwSize, DWORD *lpdwNeeded, DWORD *lpdwNum)
{
    return GetPrinterDriver(hPrinter, NULL, dwLevel, pEnum, dwSize, lpdwNeeded);
}


void *Printer_GetPrinterDriver(HANDLE hPrinter, DWORD dwLevel)
{
    return Printer_EnumProps(hPrinter, dwLevel, NULL, Printers_GetPrinterDriverCB, NULL);
}

////////////////////////////////////////////////////////////////////////////////
// code moved from prcache.c
//
HANDLE Printer_OpenPrinterAdmin(LPCTSTR lpszPrinterName)
{
    HANDLE hPrinter = NULL;

    PRINTER_DEFAULTS PrinterDefaults;
    PrinterDefaults.pDatatype = NULL;
    PrinterDefaults.pDevMode  = NULL;
    PrinterDefaults.DesiredAccess  = PRINTER_ALL_ACCESS;

    // PRINTER_READ ? READ_CONTROL

    if (!OpenPrinter((LPTSTR)lpszPrinterName, &hPrinter, &PrinterDefaults))
    {
        hPrinter = NULL; // OpenPrinter may trash hPrinter
    }

    return(hPrinter);
}

HANDLE Printer_OpenPrinter(LPCTSTR lpszPrinterName)
{
    HANDLE hPrinter = NULL;

    if (!OpenPrinter((LPTSTR)lpszPrinterName, &hPrinter, NULL))
    {
        hPrinter = NULL; // OpenPrinter may trash hPrinter
    }

    return(hPrinter);
}

VOID Printer_ClosePrinter(HANDLE hPrinter)
{
    ClosePrinter(hPrinter);
}

BOOL Printers_DeletePrinter(HWND hWnd, LPCTSTR pszFullPrinter, DWORD dwAttributes, LPCTSTR pszServer, BOOL bQuietMode)
{
    DWORD dwCommand = MSP_REMOVEPRINTER;

    if (SHIsRestricted(hWnd, REST_NOPRINTERDELETE))
        return FALSE;

    if ((dwAttributes & PRINTER_ATTRIBUTE_NETWORK) && !(dwAttributes & PRINTER_ATTRIBUTE_LOCAL))
    {
        //
        // If it's not local, then it must be a remote connection.  Note
        // that we can't just check for PRINTER_ATTRIBUTE_NETWORK because
        // NT's spooler has 'masq' printers that are local printers
        // that masquarade as network printers.  Even though they
        // are created by connecting to a printer, the have both LOCAL
        // and NETWORK bits set.
        //
        dwCommand = MSP_REMOVENETPRINTER;
    }

    //
    // Don't show the confirmation dialog box if in quiet mode
    //
    if (!bQuietMode)
    {
        if (pszServer && pszServer[0])
        {
            //
            // It's a printer on the remote server.  (Skip \\ prefix on server.)
            //
            if (ShellMessageBox(HINST_THISDLL, hWnd,
                MAKEINTRESOURCE(IDS_SUREDELETEREMOTE),
                MAKEINTRESOURCE(IDS_PRINTERS), MB_YESNO|MB_ICONQUESTION,
                pszFullPrinter, SkipServerSlashes(pszServer)) != IDYES)
            {
                return FALSE;
            }
        }
        else if (dwAttributes & PRINTER_ATTRIBUTE_NETWORK)
        {
            TCHAR szScratch[MAXNAMELENBUFFER];
            LPTSTR pszPrinter, pszServer;

            Printer_SplitFullName(szScratch, ARRAYSIZE(szScratch), pszFullPrinter, &pszServer, &pszPrinter);

            if (pszServer && *pszServer)
            {
                //
                // It's a printer connection.
                //
                if (ShellMessageBox(HINST_THISDLL, hWnd,
                    MAKEINTRESOURCE(IDS_SUREDELETECONNECTION),
                    MAKEINTRESOURCE(IDS_PRINTERS), MB_YESNO|MB_ICONQUESTION,
                    pszPrinter, SkipServerSlashes(pszServer)) != IDYES)
                {
                    return FALSE;
                }
            }
            else
            {
                //
                // It's a printer connection with a printer name that 
                // does not have a server name prefix i.e. \\server\printer.  This
                // is true for the http connected printer, which have printer names
                // of the form http://server/printer on NT these printers are 
                // 'masq' printers.  A 'masq' printer is a printer which 
                // is a local printer acting as network connection.
                //
                if (ShellMessageBox(HINST_THISDLL, hWnd,
                    MAKEINTRESOURCE(IDS_SUREDELETECONNECTIONNOSERVERNAME),
                    MAKEINTRESOURCE(IDS_PRINTERS), MB_YESNO|MB_ICONQUESTION,
                    pszPrinter) != IDYES)
                {
                    return FALSE;
                }
            }
        }
        else

        //
        // Neither a remote printer nor a local connection.  The final
        // upcoming else clause is a local printer.
        //
        if (ShellMessageBox(HINST_THISDLL, hWnd, MAKEINTRESOURCE(IDS_SUREDELETE),
            MAKEINTRESOURCE(IDS_PRINTERS), MB_YESNO|MB_ICONQUESTION, pszFullPrinter)
            != IDYES)
        {
            return FALSE;
        }
    }

    if (CallPrinterCopyHooks(hWnd, PO_DELETE, 0, pszFullPrinter, 0, NULL, 0)
        != IDYES)
    {
        return FALSE;
    }

    //
    // Cast away const.  Safe since Printers_PrinterSetup only modifies
    // pszPrinter if dwCommand is MSP_NEWDRIVER.
    //
    return BOOLFROMPTR(Printers_PrinterSetup(hWnd, dwCommand,
        (LPTSTR)pszFullPrinter, 0, pszServer));
}

BOOL Printer_GPI2CB(LPVOID lpData, HANDLE hPrinter, DWORD dwLevel,
    LPBYTE pBuf, DWORD dwSize, DWORD *lpdwNeeded, DWORD *lpdwNum)
{
    return GetPrinter(hPrinter, dwLevel, pBuf, dwSize, lpdwNeeded);
}

//
// Old NT printers don't support the level 5.  So we try for the 2 after 5.
// Win96 WILL PROBABLY WANT TO DO THIS TOO!
//
LPPRINTER_INFO_5 Printer_MakePrinterInfo5( HANDLE hPrinter )
{
    LPPRINTER_INFO_5 pPI5 = NULL;
    DWORD cbPI5 = 0;
    DWORD cbName = 0;
    DWORD cbPort = 0;
    LPPRINTER_INFO_2 pPI2 = Printer_EnumProps(hPrinter, 2, NULL, Printer_GPI2CB, (LPVOID)0);
    if (!pPI2)
        return NULL;

    cbName = (lstrlen(pPI2->pPrinterName)+1) * SIZEOF(TCHAR);

    cbPI5 = SIZEOF(PRINTER_INFO_5) + cbName;

    //
    // Port name may not be supported (e.g., downlevel machines).
    //
    if (pPI2->pPortName)
    {
        cbPort = (lstrlen(pPI2->pPortName)+1) * SIZEOF(TCHAR);
        cbPI5 += cbPort;
    }

    pPI5 = (LPPRINTER_INFO_5)LocalAlloc(LPTR, cbPI5);
    if (pPI5)
    {
        ASSERT(pPI5->pPrinterName==NULL);   // These should be null for the
        ASSERT(pPI5->pPortName==NULL);      // no names case

        if (pPI2->pPrinterName)
        {
            pPI5->pPrinterName = (LPTSTR)(pPI5+1);
            //
            // Use byte-size here.
            //
            StringCbCopy(pPI5->pPrinterName, cbName, pPI2->pPrinterName);
        }
        if (pPI2->pPortName)
        {
            pPI5->pPortName    = (LPTSTR)((LPBYTE)(pPI5+1) + cbName);
            //
            // User byte-size here.
            //
            StringCbCopy(pPI5->pPortName, cbPort, pPI2->pPortName);
        }
        pPI5->Attributes = pPI2->Attributes;
        pPI5->DeviceNotSelectedTimeout = 0;
        pPI5->TransmissionRetryTimeout = 0;
    }
    LocalFree(pPI2);

    return(pPI5);
}

LPVOID Printer_GetPrinterInfo(HANDLE hPrinter, DWORD dwLevel)
{
    LPVOID pPrinter = Printer_EnumProps(hPrinter, dwLevel, NULL, Printer_GPI2CB, (LPVOID)0);
    //
    // Old NT printers don't support the level 5.  So we try for the 2 after 5.
    // Win96 WILL PROBABLY WANT TO DO THIS TOO!
    //
    if (!pPrinter && dwLevel == 5)
        return(Printer_MakePrinterInfo5(hPrinter));
    return pPrinter;

}

LPVOID Printer_GetPrinterInfoStr(LPCTSTR lpszPrinterName, DWORD dwLevel)
{
    LPPRINTER_INFO_2 pPI2 = NULL;
    HANDLE hPrinter = Printer_OpenPrinter(lpszPrinterName);
    if (hPrinter)
    {
        pPI2 = Printer_GetPrinterInfo(hPrinter, dwLevel);
        Printer_ClosePrinter(hPrinter);
    }
    return pPI2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\prnfldr.h ===
// this is really private data to CPrinterFolder
typedef struct
{
    USHORT  cb;
    USHORT  uFlags;

    #define PRINTER_MAGIC 0xBEBADB00

    DWORD   dwMagic;
    DWORD   dwType;
    WCHAR   cName[MAXNAMELENBUFFER];
    USHORT  uTerm;
} IDPRINTER;
typedef UNALIGNED IDPRINTER *LPIDPRINTER;
typedef const UNALIGNED IDPRINTER *LPCIDPRINTER;

// W95 IDPrinter structure
typedef struct
{
    USHORT  cb;
    char    cName[32];      // Win9x limitation
    USHORT  uTerm;
} W95IDPRINTER;
typedef const UNALIGNED W95IDPRINTER *LPW95IDPRINTER;

//
// Constants
//
const UINT kDNSMax = INTERNET_MAX_HOST_NAME_LENGTH;
const UINT kServerBufMax = kDNSMax + 2 + 1;

//
// Max printer name should really be MAX_PATH, but if you create
// a max path printer and connect to it remotely, win32spl prepends
// "\\server\" to it, causing it to exceed max path.  The new UI
// therefore makes the max path MAX_PATH-kServerLenMax, but we still
// allow the old case to work.
//
const UINT kPrinterBufMax = MAX_PATH + kServerBufMax + 1;


class CPrinterFolder : public IRemoteComputer,
                       public IPrinterFolder,
                       public IFolderNotify,
                       public IShellFolder2,
                       public IPersistFolder2,
                       public IContextMenuCB,
                       public IShellIconOverlay
{
    friend class CPrintersEnum;
    friend class CPrinterFolderViewCB;
public:
    CPrinterFolder();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IShellFolder
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void** ppvOut);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void** ppvOut);
    STDMETHODIMP CompareIDs(LPARAM iCol, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(HWND hwnd, REFIID riid, void** ppvOut);
    STDMETHODIMP EnumObjects(HWND hwndOwner, DWORD grfFlags, IEnumIDList** ppenum);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* prgfInOut);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST* apidl, REFIID riid, UINT* prgfInOut, void** ppvOut);
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName, ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttributes);
    STDMETHODIMP SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD dwReserved, LPITEMIDLIST* ppidlOut);

    // IShellFolder2
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD* pdwState);
    STDMETHODIMP GetDefaultSearchGUID(LPGUID pGuid);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS* pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iCol, SHCOLUMNID* pscid);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);
    STDMETHODIMP GetClassID(LPCLSID lpClassID);

    // IShellIconOverlay
    STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int* pIndex);
    STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIndex);

    // IRemoteComputer
    STDMETHODIMP Initialize(const WCHAR *pszMachine, BOOL bEnumerating);

    // IPrinterFolder
    STDMETHODIMP_(BOOL) IsPrinter(LPCITEMIDLIST pidl);

    // IFolderNotify
    STDMETHODIMP_(BOOL) ProcessNotify(FOLDER_NOTIFY_TYPE NotifyType, LPCWSTR pszName, LPCWSTR pszNewName);

    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwnd,IDataObject *pdo, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // DUI webview impl.
    HRESULT GetWebViewLayout(IUnknown *pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT GetWebViewContent(IUnknown *pv, SFVM_WEBVIEW_CONTENT_DATA* pData);
    HRESULT GetWebViewTasks(IUnknown *pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks);

    // mask passsed to _IsContextMenuVerbEnabled to determine the selection type in which 
    // this command is applicable
    enum 
    {
        // nothing is selected
        SEL_NONE                = 0x0000, // nothing is selected 

        // single selection types
        SEL_SINGLE_ADDPRN       = 0x0001, // the add printer wizard object is selected
        SEL_SINGLE_PRINTER      = 0x0002, // 1 printer is selected
        SEL_SINGLE_LINK         = 0x0004, // 1 link is selected
        
        // any single selection type
        SEL_SINGLE_ANY          = SEL_SINGLE_ADDPRN | SEL_SINGLE_PRINTER | SEL_SINGLE_LINK,

        // multi selection types
        SEL_MULTI_PRINTER       = 0x0010, // 2+ printers are selected
        SEL_MULTI_LINK          = 0x0020, // 2+ links are selected
        SEL_MULTI_MIXED         = 0x0040, // 2+ objects of any type are selected

        // any link in the selection
        SEL_LINK_ANY            = SEL_SINGLE_LINK | SEL_MULTI_LINK | SEL_MULTI_MIXED,

        // any printer in the selection
        SEL_PRINTER_ANY         = SEL_SINGLE_ADDPRN | SEL_SINGLE_ADDPRN | 
                                  SEL_MULTI_PRINTER | SEL_MULTI_MIXED,
        
        // any multi selection type
        SEL_MULTI_ANY           = SEL_MULTI_PRINTER | SEL_MULTI_LINK | SEL_MULTI_MIXED,

        // any selection type
        SEL_ANY                 = SEL_SINGLE_ANY | SEL_MULTI_ANY,
    };

    // split the selection into its parts (printers and links) and determine the 
    // selection type (see the enum above)
    HRESULT SplitSelection(IDataObject *pdo, UINT *puSelType, IDataObject **ppdoPrinters, IDataObject **ppdoLinks);

    // webview verbs
    enum WV_VERB
    {
        // standard verbs
        WVIDM_DELETE,
        WVIDM_RENAME,
        WVIDM_PROPERTIES,

        // common verbs
        WVIDM_ADDPRINTERWIZARD,
        WVIDM_SERVERPROPERTIES,
        WVIDM_SETUPFAXING,
        WVIDM_CREATELOCALFAX,
        WVIDM_SENDFAXWIZARD,

        // special common verbs
        WVIDM_TROUBLESHOOTER,
        WVIDM_GOTOSUPPORT,

        // printer verbs
        WVIDM_OPENPRN,
        WVIDM_NETPRN_INSTALL,
        WVIDM_SETDEFAULTPRN,
        WVIDM_DOCUMENTDEFAULTS,
        WVIDM_PAUSEPRN,
        WVIDM_RESUMEPRN,
        WVIDM_PURGEPRN,
        WVIDM_SHARING,
        WVIDM_WORKOFFLINE,
        WVIDM_WORKONLINE,

        // special commands
        WVIDM_VENDORURL,
        WVIDM_PRINTERURL,

        WVIDM_COUNT,
    };

    // webview support - core APIs
    HRESULT _WebviewVerbIsEnabled(WV_VERB eVerbID, UINT uSelMask, BOOL *pbEnabled);
    HRESULT _WebviewVerbInvoke(WV_VERB eVerbID, IUnknown* pv, IShellItemArray *psiItemArray);
    HRESULT _WebviewCheckToUpdateDataObjectCache(IDataObject *pdo);

private:
    virtual ~CPrinterFolder();

    // data access
    LPCTSTR GetServer() { return _pszServer; }
    HANDLE GetFolder()  { CheckToRegisterNotify(); return _hFolder; }
    BOOL GetAdminAccess() { CheckToRegisterNotify(); return _bAdminAccess; }

    static LPCTSTR GetStatusString(PFOLDER_PRINTER_DATA pData, LPTSTR pBuff, UINT uSize);
    static INT GetCompareDisplayName(LPCTSTR pName1, LPCTSTR pName2);
    INT CompareData(LPCIDPRINTER pidp1, LPCIDPRINTER pidp2, LPARAM iCol);
    static ReduceToLikeKinds(UINT *pcidl, LPCITEMIDLIST **papidl, BOOL fPrintObjects);
    DWORD SpoolerVersion();
    void CheckToRegisterNotify();
    void CheckToRefresh();
    void RequestRefresh();
    HRESULT _GetFullIDList(LPCWSTR pszPrinter, LPITEMIDLIST *ppidl);
    static HRESULT _Parse(LPCWSTR pszPrinter, LPITEMIDLIST *ppidl, DWORD dwType = 0, USHORT uFlags = 0);
    static void _FillPidl(LPIDPRINTER pidl, LPCTSTR szName, DWORD dwType = 0, USHORT uFlags = 0);
    LPCTSTR _BuildPrinterName(LPTSTR pszFullPrinter, DWORD cchBufSize, LPCIDPRINTER pidp, LPCTSTR pszPrinter);
    void _MergeMenu(LPQCMINFO pqcm, LPCTSTR pszPrinter);
    HRESULT _InvokeCommand(HWND hwnd, LPCIDPRINTER pidp, WPARAM wParam, LPARAM lParam, LPBOOL pfChooseNewDefault);
    HRESULT _InvokeCommandRunAs(HWND hwnd, LPCIDPRINTER pidp, WPARAM wParam, LPARAM lParam, LPBOOL pfChooseNewDefault);
    BOOL _PurgePrinter(HWND hwnd, LPCTSTR pszFullPrinter, UINT uAction, BOOL bQuietMode);
    LPTSTR _FindIcon(LPCTSTR pszPrinterName, LPTSTR pszModule, ULONG cbModule, int *piIcon, int *piShortcutIcon);
    static HRESULT CALLBACK _DFMCallBack(IShellFolder *psf, HWND hwnd,
        IDataObject *pdo, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT _PrinterObjectsCallBack(HWND hwnd, UINT uSelType, 
        IDataObject *pdo, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LPTSTR _ItemName(LPCIDPRINTER pidp, LPTSTR pszName, UINT cch);
    static BOOL _IsAddPrinter(LPCIDPRINTER pidp);
   
    HRESULT _UpdateDataObjectCache();
    HRESULT _AssocCreate(REFIID riid, void **ppv);
    HRESULT _OnRefresh(BOOL bPriorRefresh);

    LONG                _cRef;                  // ref count
    LPITEMIDLIST        _pidl;                  // the PIDL of this folder
    LPTSTR              _pszServer;             // the print server this folder is browsing (NULL means local PF)
    DWORD               _dwSpoolerVersion;      // the spooler version
    HANDLE              _hFolder;               // handle to the printer folder cache (in printui)
    BOOL                _bAdminAccess;          // TRUE if you have admin access to this print server
    BOOL                _bReqRefresh;           // whether we should request a full refresh during the next enum


    // our webview get command state cache. we have 35+ commands and unpacking 
    // the same data object each time we need to verify the state of a command 
    // can be very expensive! we are going to maintain a cache with each command 
    // state and update the cache each time the data object gets changed, so 
    // the get state callbacks will finish very quickly just by consulting 
    // the cache.
    
    IDataObject        *_pdoCache;                          // current data object
    UINT                _uSelCurrent;                       // current selection type
    BOOL                _aWVCommandStates[WVIDM_COUNT];     // commands state cache

    // the folder has to be MT safe
    CCSLock             _csLock;

    // slow data. this members below should refresh every time the selection changes,
    // but we should do this in a separate thread since updating them can take a while

    enum ESlowWebviewDataType
    {
        WV_SLOW_DATA_OEM_SUPPORT_URL,
        WV_SLOW_DATA_PRINTER_WEB_URL,

        WV_SLOW_DATA_COUNT,
    };

    enum 
    {
        // in miliseconds
        WV_SLOW_DATA_CACHE_TIMEOUT = 5000,
    };

    class CSlowWVDataCacheEntry
    {
    public:
        CSlowWVDataCacheEntry(CPrinterFolder *ppf):
            _ppf(ppf),
            _bDataPending(TRUE),
            _nLastTimeUpdated(0)
        {}

        HRESULT Initialize(LPCTSTR pszPrinterName)
        { 
            HRESULT hr = S_OK;
            if (pszPrinterName)
            {
                _bstrPrinterName = pszPrinterName; 
                hr = _bstrPrinterName ? S_OK : E_OUTOFMEMORY;
            }
            else
            {
                hr = E_INVALIDARG;
            }
            return hr;
        }

        CPrinterFolder     *_ppf;
        BOOL                _bDataPending;
        DWORD               _nLastTimeUpdated;
        CComBSTR            _bstrPrinterName;
        CComBSTR            _arrData[WV_SLOW_DATA_COUNT];
    };

    static DWORD WINAPI _SlowWebviewData_WorkerProc(LPVOID lpParameter);
    static HRESULT _SlowWVDataRetrieve(LPCTSTR pszPrinterName, BSTR *pbstrSupportUrl, BSTR *pbstrPrinterWebUrl);
    static int _CompareSlowWVDataCacheEntries(CSlowWVDataCacheEntry *p1, 
        CSlowWVDataCacheEntry *p2, LPARAM lParam);

    HRESULT _GetSelectedPrinter(BSTR *pbstrVal);
    HRESULT _GetSlowWVDataForCurrentPrinter(ESlowWebviewDataType eType, BSTR *pbstrVal);
    HRESULT _GetSlowWVData(LPCTSTR pszPrinterName, ESlowWebviewDataType eType, BSTR *pbstrVal);
    HRESULT _UpdateSlowWVDataCacheEntry(CSlowWVDataCacheEntry *pCacheEntry);
    HRESULT _SlowWVDataUpdateWebviewPane();
    HRESULT _SlowWVDataCacheResetUnsafe();
    HRESULT _GetCustomSupportURL(BSTR *pbstrVal);

    CComBSTR _bstrSelectedPrinter;
    CDPA<CSlowWVDataCacheEntry> _dpaSlowWVDataCache;

    // fax support...
    static HRESULT _GetFaxControl(IDispatch **ppDisp);
    static HRESULT _GetFaxCommand(UINT_PTR *puCmd);
    static HRESULT _InvokeFaxControlMethod(LPCTSTR pszMethodName);
    static DWORD WINAPI _ThreadProc_InstallFaxService(LPVOID lpParameter);
    static DWORD WINAPI _ThreadProc_InstallLocalFaxPrinter(LPVOID lpParameter);
};

STDAPI CPrinterFolderDropTarget_CreateInstance(HWND hwnd, IDropTarget **ppdropt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\printer.h ===
#ifndef _PRINTER_H_
#define _PRINTER_H_

#include "shell32p.h"
#include <winspool.h>

#define MAXCOMPUTERNAME (2 + INTERNET_MAX_HOST_NAME_LENGTH + 1)
#define MAXNAMELEN MAX_PATH
#define MAXNAMELENBUFFER (MAXNAMELEN + MAXCOMPUTERNAME + 1)

STDAPI_(void) Printer_SplitFullName(LPTSTR pszScratch, DWORD cchSize, LPCTSTR pszFullName, LPCTSTR *ppszServer, LPCTSTR *ppszPrinter);
STDAPI_(BOOL) Printer_CheckShowFolder(LPCTSTR pszMachine);
STDAPI_(BOOL) Printer_CheckNetworkPrinterByName(LPCTSTR pszPrinter, LPCTSTR* ppszLocal);

STDAPI_(IShellFolder2 *) CPrintRoot_GetPSF();
STDAPI_(BOOL) IsDefaultPrinter(LPCTSTR pszPrinter, DWORD dwAttributesHint);
STDAPI_(BOOL) IsPrinterInstalled(LPCTSTR pszPrinter);
STDAPI_(BOOL) IsAvoidAutoDefaultPrinter(LPCTSTR pszPrinter);

STDAPI_(DWORD) Printers_EnumPrinters(LPCTSTR pszServer, DWORD dwType, DWORD dwLevel, void **ppPrinters);
STDAPI_(DWORD) Printers_FolderEnumPrinters(HANDLE hFolder, void **ppPrinters);
STDAPI_(void *) Printer_FolderGetPrinter(HANDLE hFolder, LPCTSTR pszPrinter);
STDAPI_(BOOL) Printer_ModifyPrinter(LPCTSTR lpszPrinterName, DWORD dwCommand);
STDAPI_(void *) Printer_GetPrinterDriver(HANDLE hPrinter, DWORD dwLevel);
STDAPI_(void *) Printer_GetPrinter(HANDLE hPrinter, DWORD dwLevel);
STDAPI_(BOOL) Printers_DeletePrinter(HWND, LPCTSTR, DWORD, LPCTSTR, BOOL);
STDAPI_(BOOL) Printer_SetAsDefault(LPCTSTR lpszPrinterName);
STDAPI_(void) Printers_ChooseNewDefault(HWND hWnd);

typedef BOOL (*ENUMPROP)(void *lpData, HANDLE hPrinter, DWORD dwLevel,
        LPBYTE pEnum, DWORD dwSize, DWORD *lpdwNeeded, DWORD *lpdwNum);
STDAPI_(void *) Printer_EnumProps(HANDLE hPrinter, DWORD dwLevel, DWORD *lpdwNum,
        ENUMPROP lpfnEnum, void *lpData);

STDAPI_(HANDLE) Printer_OpenPrinter(LPCTSTR lpszPrinterName);
STDAPI_(HANDLE) Printer_OpenPrinterAdmin(LPCTSTR lpszPrinterName);

STDAPI_(void) Printer_ClosePrinter(HANDLE hPrinter);
STDAPI_(BOOL) Printer_GPI2CB(void *lpData, HANDLE hPrinter, DWORD dwLevel, LPBYTE pBuf, DWORD dwSize, DWORD *lpdwNeeded, DWORD *lpdwNum);
STDAPI_(void *) Printer_GetPrinterInfo(HANDLE hPrinter, DWORD dwLevel );
STDAPI_(void *) Printer_GetPrinterInfoStr(LPCTSTR lpszPrinterName, DWORD dwLevel);

// prqwnd.c
STDAPI_(LPITEMIDLIST) Printjob_GetPidl(LPCTSTR szName, LPSHCNF_PRINTJOB_DATA pData);

// printer1.c
STDAPI_(LPITEMIDLIST) Printers_GetInstalledNetPrinter(LPCTSTR lpNetPath);
STDAPI_(void) Printer_PrintFile(HWND hWnd, LPCTSTR pszFilePath, LPCITEMIDLIST pidl);
STDAPI_(LPITEMIDLIST) Printers_PrinterSetup(HWND hwndStub, UINT uAction, LPTSTR lpBuffer, DWORD cchBufSize, LPCTSTR pszServerName);

// prnfldr.cpp
STDAPI CPrinterDropTarget_CreateInstance(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt);

////////////////////////////////////////////////////////////////////
// IPrintersBindInfo - bind context info for parsing printer PIDLs
#undef  INTERFACE
#define INTERFACE  IPrintersBindInfo

DECLARE_INTERFACE_(IPrintersBindInfo, IUnknown)
{
    //////////////////
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    ///////////////////////
    // IPrintersBindInfo
    STDMETHOD(SetPIDLType)(THIS_ DWORD dwType) PURE;
    STDMETHOD(GetPIDLType)(THIS_ LPDWORD pdwType) PURE;
    STDMETHOD(IsValidated)(THIS) PURE;
    STDMETHOD(SetCookie)(THIS_ LPVOID pCookie) PURE;
    STDMETHOD(GetCookie)(THIS_ LPVOID *ppCookie) PURE;
};

STDAPI Printers_CreateBindInfo(LPCTSTR pszPrinter, DWORD dwType, BOOL bValidated, LPVOID pCookie, IPrintersBindInfo **ppbc);

#endif // _PRINTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\privshl.h ===
#define WCHAR_COLON     L':'
#define WCHAR_NULL      L'\0'
#define WCHAR_COMMA     L','
#define WCHAR_A         L'a'
#define WCHAR_CAP_A     L'A'
#define WCHAR_C         L'c'
#define WCHAR_Z         L'z'
#define WCHAR_BSLASH    L'\\'
#define WCHAR_DOT       L'.'
#define WCHAR_QMARK     L'?'
#define WCHAR_STAR      L'*'
#define WCHAR_SLASH     L'/'
#define WCHAR_SPACE     L' '
#define WCHAR_QUOTE     L'"'
#define WCHAR_PLUS      L'+'
#define WCHAR_LTHAN     L'<'
#define WCHAR_BAR       L'|'
#define WCHAR_LBRACKET  L'['
#define WCHAR_RBRACKET  L']'
#define WCHAR_EQUAL     L'='
#define WCHAR_SEMICOLON L';'
#define WCHAR_HAT       L'^'

#define WSTR_DOT L"."
#define WSTR_BLANK L""
#define WSTR_SPACE L" "

#define CHAR_COLON      ':'
#define CHAR_BSLASH     '\\'
#define CHAR_NULL       '\0'
#define CHAR_COMMA      ','
#define CHAR_A          'a'
#define CHAR_CAP_A      'A'
#define CHAR_C          'c'
#define CHAR_Z          'z'
#define CHAR_BSLASH     '\\'
#define CHAR_DOT        '.'
#define CHAR_QMARK      '?'
#define CHAR_STAR       '*'
#define CHAR_SLASH      '/'
#define CHAR_SPACE      ' '
#define CHAR_QUOTE      '"'
#define CHAR_PLUS       '+'
#define CHAR_LTHAN      '<'
#define CHAR_BAR        '|'
#define CHAR_LBRACKET   '['
#define CHAR_RBRACKET   ']'
#define CHAR_EQUAL      '='
#define CHAR_SEMICOLON  ';'
#define CHAR_HAT        '^'
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\prndrop.cpp ===
#include "shellprv.h"
#pragma  hdrstop

// Must have access to:
// IID_IPrinterFolder & IID_IFolderNotify interfaces
// declared in windows\inc\winprtp.h
//
#include <initguid.h>
#include <winprtp.h>

#include "w32utils.h"
#include "dpa.h"
#include <msprintx.h>
#include "ids.h"
#include "printer.h"
#include "copy.h"
#include "fstreex.h"
#include "datautil.h"
#include "infotip.h"
#include "idldrop.h"
#include "ovrlaymn.h"
#include "netview.h"
#include "prnfldr.h"

// thread data param
typedef struct {
    CIDLDropTarget *pdt;
    IStream     *pstmDataObj;
    IDataObject *pdtobj;
    DWORD        grfKeyState;
    POINTL       pt;
    DWORD        dwEffect;
} PRINT_DROP_THREAD;

class CPrinterFolderDropTarget : public CIDLDropTarget
{
    friend HRESULT CPrinterFolderDropTarget_CreateInstance(HWND hwnd, IDropTarget **ppdropt);
public:
    CPrinterFolderDropTarget(HWND hwnd) : CIDLDropTarget(hwnd) { };

    // IDropTarget methods overwirte
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    static STDMETHODIMP _HIDATestForRmPrns( LPIDA pida, int * pcRPFs, int * pcNonRPFs );
    static void _FreePrintDropData(PRINT_DROP_THREAD *pthp);
    static DWORD CALLBACK _ThreadProc(void *pv);
};

STDMETHODIMP CPrinterFolderDropTarget::_HIDATestForRmPrns(LPIDA pida, int *pcRPFs, int *pcNonRPFs)
{
    // check to see if any of the ID's are remote printers....
    for (UINT i = 0; i < pida->cidl; i++)
    {
        LPITEMIDLIST pidlTo = IDA_ILClone(pida, i);
        if (pidlTo)
        {
            LPCITEMIDLIST pidlRemainder = NULL;
            // *pidlRemainder will be NULL for remote print folders,
            // and non-NULL for printers under remote print folders
            if (NET_IsRemoteRegItem(pidlTo, CLSID_Printers, &pidlRemainder)) // && (pidlRemainder->mkid.cb == 0))
            {
                (*pcRPFs)++;
            }
            else
            {
                (*pcNonRPFs)++;
            }
            ILFree(pidlTo);
        }
    }

    return S_OK;
}

STDMETHODIMP CPrinterFolderDropTarget::DragEnter(IDataObject * pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    // We allow printer shares to be dropped for installing
    // But we don't want to spend the time on DragEnter finding out if it's
    // a printer share, so allow drops of any net resource or HIDA
    // REVIEW: Actually, it wouldn't take long to check the first one, but
    // sequencing through everything does seem like a pain.

    // let the base-class process it now to save away the pdwEffect
    CIDLDropTarget::DragEnter(pdtobj, grfKeyState, pt, pdwEffect);

    // are we dropping on the background ? Do we have the IDLIST clipformat ?
    if (m_dwData & DTID_HIDA)
    {
        int cRPFs = 0;
        int cNonRPFs = 0;
        
        STGMEDIUM medium;
        FORMATETC fmte = {g_cfNetResource, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        
        LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
        if (pida)
        {
            _HIDATestForRmPrns( pida, &cRPFs, &cNonRPFs );
            HIDA_ReleaseStgMedium(pida, &medium);
        }

        // if we have no Remote printers or we have any non "remote printers"
        // and we have no other clipformat to test...
        if ((( cRPFs == 0 ) || ( cNonRPFs != 0 )) && !( m_dwData & DTID_NETRES ))
        {
            // the Drop code below only handles drops for HIDA format on NT
            // and only if all off them are Remote Printers
            *pdwEffect &= ~DROPEFFECT_LINK;
        }
    }   

    if ((m_dwData & DTID_NETRES) || (m_dwData & DTID_HIDA))
    {
        *pdwEffect &= DROPEFFECT_LINK;
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
    }

    m_dwEffectLastReturned = *pdwEffect;
    return S_OK;
}

void CPrinterFolderDropTarget::_FreePrintDropData(PRINT_DROP_THREAD *pthp)
{
    if (pthp->pstmDataObj)
        pthp->pstmDataObj->Release();

    if (pthp->pdtobj)
        pthp->pdtobj->Release();

    pthp->pdt->Release();
    LocalFree((HLOCAL)pthp);
}

DWORD CALLBACK CPrinterFolderDropTarget::_ThreadProc(void *pv)
{
    PRINT_DROP_THREAD *pthp = (PRINT_DROP_THREAD *)pv;
    STGMEDIUM medium;
    HRESULT hres = E_FAIL;
    FORMATETC fmte = {g_cfHIDA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    CoGetInterfaceAndReleaseStream(pthp->pstmDataObj, IID_IDataObject, (void **)&pthp->pdtobj);
    pthp->pstmDataObj = NULL;

    if (pthp->pdtobj == NULL)
    {
        _FreePrintDropData(pthp);
        return 0;
    }

    // First try to drop as a link to a remote print folder
    LPIDA pida = DataObj_GetHIDA(pthp->pdtobj, &medium);
    if (pida)
    {
        // Make sure that if one item in the dataobject is a
        // remote print folder, that they are all remote print folders.

        // If none are, we just give up on dropping as a RPF link, and
        // fall through to checking for printer shares via the
        // NETRESOURCE clipboard format, below.
        int cRPFs = 0, cNonRPFs = 0;
        
        _HIDATestForRmPrns( pida, &cRPFs, &cNonRPFs );

        if ((cRPFs > 0) && (cNonRPFs == 0))
        {
            // All the items in the dataobject are remote print folders or
            // printers under remote printer folders
            for (UINT i = 0; i < pida->cidl; i++)
            {
                LPITEMIDLIST pidlTo = IDA_ILClone(pida, i);
                if (pidlTo)
                {
                    LPCITEMIDLIST pidlRemainder; // The part after the remote regitem
                    NET_IsRemoteRegItem(pidlTo, CLSID_Printers, &pidlRemainder);
                    if (ILIsEmpty(pidlRemainder))
                    {
                        // This is a remote printer folder.  Drop a link to the
                        // 'PrintHood' directory

                        IShellFolder2 *psf = CPrintRoot_GetPSF();
                        if (psf)
                        {
                            IDropTarget *pdt;
                            hres = psf->CreateViewObject(pthp->pdt->_GetWindow(),
                                                                 IID_PPV_ARG(IDropTarget, &pdt));
                            if (SUCCEEDED(hres))
                            {
                                pthp->dwEffect = DROPEFFECT_LINK;
                                hres = SHSimulateDrop(pdt, pthp->pdtobj, pthp->grfKeyState, &pthp->pt, &pthp->dwEffect);
                                pdt->Release();
                            }
                        }
                    }
                    else
                    {
                        TCHAR szPrinter[MAX_PATH];

                        SHGetNameAndFlags(pidlTo, SHGDN_FORPARSING, szPrinter, ARRAYSIZE(szPrinter), NULL);
                        //
                        // Setup if not the add printer wizard.
                        //
                        if (lstrcmpi(szPrinter, c_szNewObject))
                        {
                            LPITEMIDLIST pidl = Printers_PrinterSetup(pthp->pdt->_GetWindow(), MSP_NETPRINTER, szPrinter, 0, NULL);
                            if (pidl)
                                ILFree(pidl);
                        }

                        // make sure we set hres to S_OK, so we don't break the main loop
                        hres = S_OK;
                    }
                    ILFree(pidlTo);

                    if (FAILED(hres))
                        break;
                }
            }
            HIDA_ReleaseStgMedium(pida, &medium);
            SHChangeNotifyHandleEvents();       // force update now
            goto Cleanup;
        }
        else if ((cRPFs > 0) && (cNonRPFs > 0))
        {
            // At least one, but not all, item(s) in this dataobject
            // was a remote printer folder.  Jump out now.
            goto Cleanup;
        }

        // else none of the items in the dataobject were remote print
        // folders, so fall through to the NETRESOURCE parsing
    }

    // Reset FORMATETC to NETRESOURCE clipformat for next GetData call
    fmte.cfFormat = g_cfNetResource;

    // DragEnter only allows network resources to be DROPEFFECT_LINKed
    ASSERT(S_OK == pthp->pdtobj->QueryGetData(&fmte));

    if (SUCCEEDED(pthp->pdtobj->GetData(&fmte, &medium)))
    {
        LPNETRESOURCE pnr = (LPNETRESOURCE)LocalAlloc(LPTR, 1024);
        if (pnr)
        {
            BOOL fNonPrnShare = FALSE;
            UINT cItems = SHGetNetResource(medium.hGlobal, (UINT)-1, NULL, 0);
            for (UINT iItem = 0; iItem < cItems; iItem++)
            {
                if (SHGetNetResource(medium.hGlobal, iItem, pnr, 1024) &&
                    pnr->dwDisplayType == RESOURCEDISPLAYTYPE_SHARE &&
                    pnr->dwType == RESOURCETYPE_PRINT)
                {
                    LPITEMIDLIST pidl = Printers_PrinterSetup(pthp->pdt->_GetWindow(),
                               MSP_NETPRINTER, pnr->lpRemoteName, 0, NULL);

                    if (pidl)
                        ILFree(pidl);
                }
                else
                {
                    if (!fNonPrnShare)
                    {
                        // so we don't get > 1 of these messages per drop
                        fNonPrnShare = TRUE;

                        // let the user know that they can't drop non-printer
                        // shares into the printers folder
                        SetForegroundWindow(pthp->pdt->_GetWindow());
                        ShellMessageBox(HINST_THISDLL,
                            pthp->pdt->_GetWindow(),
                            MAKEINTRESOURCE(IDS_CANTINSTALLRESOURCE), NULL,
                            MB_OK|MB_ICONINFORMATION,
                            (LPTSTR)pnr->lpRemoteName);
                    }
                }
            }

            LocalFree((HLOCAL)pnr);
        }
        ReleaseStgMedium(&medium);
    }

Cleanup:
    _FreePrintDropData(pthp);
    return 0;
}

STDMETHODIMP CPrinterFolderDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_LINK;

    HRESULT hr = CIDLDropTarget::DragDropMenu(DROPEFFECT_LINK, pdtobj,
        pt, pdwEffect, NULL, NULL, MENU_PRINTOBJ_NEWPRN_DD, grfKeyState);

    if (*pdwEffect)
    {
        PRINT_DROP_THREAD *pthp = (PRINT_DROP_THREAD *)LocalAlloc(LPTR, SIZEOF(*pthp));
        if (pthp)
        {
            pthp->grfKeyState = grfKeyState;
            pthp->pt          = pt;
            pthp->dwEffect    = *pdwEffect;

            CoMarshalInterThreadInterfaceInStream(IID_IDataObject, (IUnknown *)pdtobj, &pthp->pstmDataObj);

            pthp->pdt = this;
            pthp->pdt->AddRef();

            if (SHCreateThread(_ThreadProc, pthp, CTF_COINIT, NULL))
            {
                hr = S_OK;
            }
            else
            {
                _FreePrintDropData(pthp);
                hr = E_OUTOFMEMORY;
            }
        }
    }
    CIDLDropTarget::DragLeave();

    return hr;
}

STDAPI CPrinterFolderDropTarget_CreateInstance(HWND hwnd, IDropTarget **ppdropt)
{
    *ppdropt = NULL;

    HRESULT hr;
    CPrinterFolderDropTarget *ppfdt = new CPrinterFolderDropTarget(hwnd);
    if (ppfdt)
    {
        hr = ppfdt->QueryInterface(IID_PPV_ARG(IDropTarget, ppdropt));
        ppfdt->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\prnfldr.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include <initguid.h>
#include <winprtp.h>    // IID_IPrinterFolder & IID_IFolderNotify interfaces declared in windows\inc\winprtp.h
#include <guids.h>      // IID_IPrintersBindInfo

#include "w32utils.h"
#include "dpa.h"
#include "idlcomm.h"
#include "idldrop.h"
#include "printer.h"
#include "copy.h"
#include "fstreex.h"
#include "datautil.h"
#include "infotip.h"
#include "idldata.h"
#include "ovrlaymn.h"
#include "netview.h"
#include "ids.h"
#include "views.h"
#include "basefvcb.h"
#include "prnfldr.h"
#include "shstr.h"
#include "views.h"
#include "defview.h"
#include "prop.h"
#undef PATH_SEPARATOR_STR
#include "faxreg.h"
#include "filetbl.h"
#include "msprintx.h"
#include "defcm.h"
#include "enumidlist.h"
#include "ole2dup.h"

// FMTID_GroupByDetails - {FE9E4C12-AACB-4aa3-966D-91A29E6128B5}
#define STR_FMTID_GroupByDetails    TEXT("{FE9E4C12-AACB-4aa3-966D-91A29E6128B5}")
DEFINE_GUID(FMTID_GroupByDetails,   0xfe9e4c12, 0xaacb, 0x4aa3, 0x96, 0x6d, 0x91, 0xa2, 0x9e, 0x61, 0x28, 0xb5);
#define PSCID_GroupByDetails       {0xfe9e4c12, 0xaacb, 0x4aa3, 0x96, 0x6d, 0x91, 0xa2, 0x9e, 0x61, 0x28, 0xb5}

#define PID_PRN_NAME            0
#define PID_PRN_QUEUESIZE       1
#define PID_PRN_STATUS          2
#define PID_PRN_COMMENT         3
#define PID_PRN_LOCATION        4
#define PID_PRN_MODEL           5

DEFINE_SCID(SCID_PRN_QUEUESIZE,     PSCID_GroupByDetails,   PID_PRN_QUEUESIZE);
DEFINE_SCID(SCID_PRN_STATUS,        PSCID_GroupByDetails,   PID_PRN_STATUS);
DEFINE_SCID(SCID_PRN_LOCATION,      PSCID_GroupByDetails,   PID_PRN_LOCATION);
DEFINE_SCID(SCID_PRN_MODEL,         PSCID_GroupByDetails,   PID_PRN_MODEL);

// file system folder, CSIDL_PRINTHOOD for printer shortcuts
IShellFolder2 *g_psfPrintHood = NULL;

enum
{
    PRINTERS_ICOL_NAME = 0,
    PRINTERS_ICOL_QUEUESIZE,
    PRINTERS_ICOL_STATUS,
    PRINTERS_ICOL_COMMENT,
    PRINTERS_ICOL_LOCATION,
    PRINTERS_ICOL_MODEL,
};

const COLUMN_INFO c_printers_cols[] =
{
    DEFINE_COL_STR_ENTRY(SCID_NAME,             20, IDS_NAME_COL),
    DEFINE_COL_INT_ENTRY(SCID_PRN_QUEUESIZE,    12, IDS_PSD_QUEUESIZE),
    DEFINE_COL_STR_ENTRY(SCID_PRN_STATUS,       12, IDS_PRQ_STATUS),
    DEFINE_COL_STR_ENTRY(SCID_Comment,          30, IDS_EXCOL_COMMENT),
    DEFINE_COL_STR_ENTRY(SCID_PRN_LOCATION,     20, IDS_PSD_LOCATION),
    DEFINE_COL_STR_ENTRY(SCID_PRN_MODEL,        20, IDS_PSD_MODEL),
};

// converts ProgID or string representation of a GUID to a GUID.
static HRESULT _GetClassIDFromString(LPCTSTR psz, LPCLSID pClsID)
{
    HRESULT hr = E_FAIL;
    if (psz[0] == TEXT('{'))
    {
        hr = CLSIDFromString((LPOLESTR)T2COLE(psz), pClsID);
    }
    else
    {
        hr = CLSIDFromProgID(T2COLE(psz), pClsID);
    }
    return hr;
}

class CPrintersBindInfo: public IPrintersBindInfo
{
public:
    // construction/destruction
    CPrintersBindInfo();
    CPrintersBindInfo(DWORD dwType, BOOL bValidated, LPVOID pCookie = NULL);
    ~CPrintersBindInfo();

    //////////////////
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    ///////////////////////
    // IPrintersBindInfo
    STDMETHODIMP SetPIDLType(DWORD dwType);
    STDMETHODIMP GetPIDLType(LPDWORD pdwType);
    STDMETHODIMP IsValidated();
    STDMETHODIMP SetCookie(LPVOID pCookie);
    STDMETHODIMP GetCookie(LPVOID *ppCookie);

private:
    LONG    m_cRef;
    DWORD   m_dwType;
    BOOL    m_bValidated;
    LPVOID  m_pCookie;
};

// construction/destruction
CPrintersBindInfo::CPrintersBindInfo()
    : m_cRef(1),
      m_dwType(0),
      m_bValidated(FALSE),
      m_pCookie(NULL)
{
}

CPrintersBindInfo::CPrintersBindInfo(DWORD dwType, BOOL bValidated, LPVOID pCookie)
    : m_cRef(1),
      m_dwType(dwType),
      m_bValidated(bValidated),
      m_pCookie(pCookie)
{
}

CPrintersBindInfo::~CPrintersBindInfo()
{
    // nothing special to do here
}

/////////////////////////////////
// IUnknown - standard impl.
STDMETHODIMP CPrintersBindInfo::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CPrintersBindInfo, IPrintersBindInfo),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CPrintersBindInfo::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CPrintersBindInfo::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

///////////////////////
// IPrintersBindInfo
STDMETHODIMP CPrintersBindInfo::SetPIDLType(DWORD dwType)
{
    m_dwType = dwType;
    return S_OK;
}

STDMETHODIMP CPrintersBindInfo::GetPIDLType(LPDWORD pdwType)
{
    HRESULT hr = E_INVALIDARG;
    if (pdwType)
    {
        *pdwType = m_dwType;
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CPrintersBindInfo::IsValidated()
{
    return m_bValidated ? S_OK : S_FALSE;
}

STDMETHODIMP CPrintersBindInfo::SetCookie(LPVOID pCookie)
{
    m_pCookie = pCookie;
    return S_OK;
}

STDMETHODIMP CPrintersBindInfo::GetCookie(LPVOID *ppCookie)
{
    HRESULT hr = E_INVALIDARG;
    if (ppCookie)
    {
        *ppCookie = m_pCookie;
        hr = S_OK;
    }
    return hr;
}

STDAPI Printers_CreateBindInfo(LPCTSTR pszPrinter, DWORD dwType, BOOL bValidated, LPVOID pCookie, IPrintersBindInfo **ppbc)
{
    HRESULT hr = E_INVALIDARG;
    if (ppbc)
    {
        *ppbc = NULL;

        CPrintersBindInfo *pObj = new CPrintersBindInfo(dwType, bValidated, pCookie);
        hr = pObj ? pObj->QueryInterface(IID_PPV_ARG(IPrintersBindInfo, ppbc)) : E_OUTOFMEMORY;

        if (pObj)
        {
            pObj->Release();
        }
    }
    return hr;
}

#define PRINTER_HACK_WORK_OFFLINE 0x80000000

// {EAE0A5E1-CE32-4296-9A44-9F0C069F73D4}
DEFINE_GUID(SID_SAuxDataObject, 0xeae0a5e1, 0xce32, 0x4296, 0x9a, 0x44, 0x9f, 0xc, 0x6, 0x9f, 0x73, 0xd4);

class CPrintersData: public CIDLDataObj,
                     public IServiceProvider
{
public:
    CPrintersData(IDataObject *pdoAux, LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[]):
      _pdoAux(pdoAux), CIDLDataObj(pidlFolder, cidl, apidl)
    {
        if (_pdoAux)
            _pdoAux->AddRef();
    }

    ~CPrintersData()
    {
        IUnknown_SafeReleaseAndNullPtr(_pdoAux);
    }

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void)   { return CIDLDataObj::AddRef();  }
    STDMETHODIMP_(ULONG) Release(void)  { return CIDLDataObj::Release(); }

    // IDataObject
    STDMETHODIMP GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
    STDMETHODIMP QueryGetData(FORMATETC *pFmtEtc);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

private:
    // auxiliary data object. we are going to use this data object to store the
    // selected printhood objects since they are in a different folder which is
    // a file system folder and their PIDLs don't have the printers folder as
    // parent. This is a limitation of the IDL array clipboard format -- it can
    // hold only PIDLs that have the same parent folder. the zero PIDL is the
    // PIDL of the parent folder and then we have the array of relative PIDLs
    // of the selected objects (childs).
    IDataObject *_pdoAux;
};


UINT Printer_BitsToString(DWORD bits, UINT idsSep, LPTSTR lpszBuf, UINT cchMax);



#define PRINTERS_EVENTS \
    SHCNE_UPDATEITEM | \
    SHCNE_DELETE | \
    SHCNE_RENAMEITEM | \
    SHCNE_ATTRIBUTES | \
    SHCNE_CREATE

class CPrinterFolderViewCB : public CBaseShellFolderViewCB
{
public:
    CPrinterFolderViewCB(CPrinterFolder *ppf, LPCITEMIDLIST pidl)
        : CBaseShellFolderViewCB(pidl, PRINTERS_EVENTS),  _ppf(ppf)
    {
        _ppf->AddRef();
    }

    // IShellFolderViewCB
    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);


private:
    ~CPrinterFolderViewCB()
    {
        _ppf->Release();
    }

    HRESULT OnINVOKECOMMAND(DWORD pv, UINT wP)
    {
        return _ppf->CallBack(_ppf, _hwndMain, NULL, DFM_INVOKECOMMAND, wP, 0);
    }

    HRESULT OnGETHELPTEXT(DWORD pv, UINT id, UINT cch, LPTSTR lP)
    {
#ifdef UNICODE
        return _ppf->CallBack(_ppf, _hwndMain, NULL, DFM_GETHELPTEXTW, MAKEWPARAM(id, cch), (LPARAM)lP);
#else
        return _ppf->CallBack(_ppf, _hwndMain, NULL, DFM_GETHELPTEXT, MAKEWPARAM(id, cch), (LPARAM)lP);
#endif
    }

    HRESULT OnBACKGROUNDENUM(DWORD pv)
    {
        return _ppf->GetServer() ? S_OK : E_FAIL;
    }

    HRESULT OnREFRESH(DWORD pv, UINT wP)
    {
        HRESULT hr = S_OK;
        if (wP)
        {
            // start the net crawler
            RefreshNetCrawler();
        }

        if (_ppf)
        {
            // delegate to the folder
            hr = _ppf->_OnRefresh(static_cast<BOOL>(wP));
        }
        else
        {
            hr = E_UNEXPECTED;
        }
        return hr;
    }

    HRESULT OnGETHELPTOPIC(DWORD pv, SFVM_HELPTOPIC_DATA * phtd)
    {
        if (IsOS(OS_ANYSERVER))
        {
            StringCchCopy(phtd->wszHelpFile, ARRAYSIZE(phtd->wszHelpFile), L"printing.chm");
        }
        else
        {
            lstrcpynW(phtd->wszHelpTopic, 
                L"hcp://services/layout/xml?definition=MS-ITS%3A%25HELP_LOCATION%25%5Cntdef.chm%3A%3A/Printers_and_Faxes.xml",
                ARRAYSIZE(phtd->wszHelpTopic));
        }
        return S_OK;
    }

    HRESULT OnDELAYWINDOWCREATE(DWORD pv, HWND hwnd)
    {
        RefreshNetCrawler();        // start the net crawler
        return S_OK;
    }

    // by default we want tiles, grouped by location
    HRESULT OnDEFERRED_VIEW_SETTING(DWORD pv, SFVM_DEFERRED_VIEW_SETTINGS *pdvs)
    {
        pdvs->fvm = FVM_TILE;
        pdvs->fGroupView = FALSE;
        pdvs->uSortCol = PRINTERS_ICOL_NAME;
        pdvs->iSortDirection = 1; // ascending
        return S_OK;
    }

    // DUI webview commands
    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
    {
        return _ppf ? _ppf->GetWebViewLayout(
            static_cast<IServiceProvider*>(this), uViewMode, pData) : E_UNEXPECTED;
    }

    HRESULT OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
    {
        return _ppf ? _ppf->GetWebViewContent(
            static_cast<IServiceProvider*>(this), pData) : E_UNEXPECTED;
    }

    HRESULT OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
    {
        return _ppf ? _ppf->GetWebViewTasks(
            static_cast<IServiceProvider*>(this), pTasks) : E_UNEXPECTED;
    }

    CPrinterFolder *_ppf;
};


class CPrinterDropTarget : public CIDLDropTarget
{
    friend HRESULT CPrinterDropTarget_CreateInstance(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt);
public:
    CPrinterDropTarget(HWND hwnd) : CIDLDropTarget(hwnd) { };

    // IDropTarget methods overwirte
    STDMETHODIMP DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

private:
    STDMETHODIMP _DropCallback(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect, LPTHREAD_START_ROUTINE pfn);
};

LPCTSTR GetPrinterName(PFOLDER_PRINTER_DATA pPrinter, UINT Index)
{
    return ((PFOLDER_PRINTER_DATA)(((PBYTE)pPrinter)+pPrinter->cbSize*Index))->pName;
}

IShellFolder2* CPrintRoot_GetPSF()
{
    SHCacheTrackingFolder(MAKEINTIDLIST(CSIDL_PRINTERS), CSIDL_PRINTHOOD | CSIDL_FLAG_CREATE, &g_psfPrintHood);
    return g_psfPrintHood;
}

typedef enum
{
    HOOD_COL_PRINTER = 0,
    HOOD_COL_FILE    = 1
} PIDLTYPE ;


PIDLTYPE _IDListType(LPCITEMIDLIST pidl)
{
    LPCIDPRINTER pidlprint = (LPCIDPRINTER) pidl;
    if (pidlprint->cb >= sizeof(DWORD) + FIELD_OFFSET(IDPRINTER, dwMagic) &&
        pidlprint->dwMagic == PRINTER_MAGIC)
    {
        return HOOD_COL_PRINTER;
    }
    else
    {
        // This HACK is a little ugly but have to do it, in order to support
        // the legacy Win9x printer shortcuts under Win2k.
        //
        // Details: If the PRINTER_MAGIC field check fails it might still
        // be a valid Win9x PIDL. The only reliable way I can think of
        // to determine whether this is the case is to check if pidlprint->cb
        // points inside a W95IDPRINTER structure and also to check whether
        // the name is tighten up to the PIDL size.
        LPW95IDPRINTER pidlprint95 = (LPW95IDPRINTER)pidl;
        int nPIDLSize = sizeof(pidlprint95->cb) + lstrlenA(pidlprint95->cName) + 1;

        if (nPIDLSize < sizeof(W95IDPRINTER) &&     // Must be inside W95IDPRINTER
            pidlprint95->cb == nPIDLSize)                  // The PIDL size must match the ANSI name
        {
            // Well it might be a Win95 printer PIDL.
            return  HOOD_COL_PRINTER;
        }
        else
        {
            // This PIDL is not a valid printer PIDL.
            return HOOD_COL_FILE;
        }
    }
}

/*++
   Inserts a backslash before each double quote in a string and saves the new string in a pre-allocated memory.
   For all the backslash immediately before the double, we will insert additional backslashes. 
   This is mostly used by passing a command line between processes. 
  
   The rule is the same as rundll32. 
   Rules: each double quote ==> backslash + double quote
          N backslashes + double quote ==> 2N + 1 backslashes + double quote 
          N backslashes ==> N backslashes 

   Arguments:
        pszSrc -- [IN] source string
        pszDest -- [IN] destination string
        cbBuf -- [IN] size of the buffer for the destination string.
        pcbNeeded -- [OUT] the size of the buffer needed for destination string. If cbBuf is less than this value,
                     this function will return E_OUTOFMEMORY.
                     
   Return:
        standard HRESULT value.
--*/

HRESULT CheckAndVerboseQuote(LPTSTR pszSrc, LPTSTR pszDest, DWORD cbBuf, LPDWORD pcbNeeded)
{
    LPTSTR  pBegin;
    LPTSTR  pBack; // for back tracing '\\' when we meet a '\"'
    UINT    cAdd = 0;
    TCHAR const cchQuote = TEXT('\"');
    TCHAR const cchSlash = TEXT('\\');
    HRESULT hr = E_INVALIDARG;

    if (pszSrc && pcbNeeded)
    {
        hr = S_OK;
        pBegin = pszSrc;
        while (*pBegin) 
        {
            // check whether the buffer is large enough
            if (*pBegin == cchQuote) 
            {
                // check if the case is N backslashes + double quote
                // for each backslash before double quote, we add an additional backslash
                pBack = pBegin - 1; 
                // make sure pBack will not be out of bound
                while (pBack >= pszSrc && *pBack-- == cchSlash)
                {
                    cAdd++;
                }

                // for each double quote, we change it to backslash + double quote
                cAdd++;
            }
            pBegin++;
        }

        *pcbNeeded = (lstrlen(pszSrc) + cAdd + 1) * sizeof(TCHAR);
        if (*pcbNeeded > cbBuf)
        {
            hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            // do the copy and verbose work
            pBegin = pszSrc;
            while (*pBegin) 
            {
                if (*pBegin == cchQuote) 
                {
                    pBack = pBegin - 1; 
                    while (pBack >= pszSrc && *pBack-- == cchSlash)
                    {
                        *pszDest++ = cchSlash;
                    }

                    *pszDest++ = cchSlash;
                }
                *pszDest++ = *pBegin++;
            }
            *pszDest = 0;
        }
    }
    return hr;
}

/*++
    Inserts a backslash before each double quote in a string and allocates memory to save the new string.
    For all the backslash immediately before the double, we will insert additional backslashes. 
    This is mostly used by passing a command line between processes. 

    Arguments:
        pszSrc -- [IN] source string
        ppszDest -- [OUT] destination string
                     
    Return:
        standard HRESULT value.

    Note: CheckAndVerboseQuote() does the real work.
--*/

HRESULT InsertBackSlash(LPTSTR pszSrc, LPTSTR *ppszDest)
{
    LPTSTR  pszDest;
    DWORD   cbNeeded = 0;
    HRESULT hr = E_INVALIDARG;

    if (pszSrc && ppszDest)
    {
        hr = CheckAndVerboseQuote(pszSrc, NULL, 0, &cbNeeded);

        if (hr == E_OUTOFMEMORY && cbNeeded)
        {
            pszDest = (LPTSTR)SHAlloc(cbNeeded);

            if (pszDest)
            {
                hr = CheckAndVerboseQuote(pszSrc, pszDest, cbNeeded, &cbNeeded);
                if (SUCCEEDED(hr))
                {
                    *ppszDest = pszDest;
                }
                else
                {
                    SHFree(pszDest);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

/*  Registers a modeless, non-top level window with the shell.  When
    the user requests a window, we search for other instances of that
    window.  If we find one, we switch to it rather than creating
    a new window.

    This function is used by PRINTUI.DLL

    pszPrinter - Name of the printer resource.  Generally a fully
        qualified printer name (\\server\printer for remote print
        folders) or a server name for the folder itself.

    dwType - Type of property window.  May refer to properties, document
        defaults, or job details.  Should use the PRINTER_PIDL_TYPE_*
        flags.

    ph - Receives the newly created handle to the registered
        object.  NULL if window already exists.

    phwnd - Receives the newly created hwndStub.  The property sheet
        should use this as the parent, since subsequent calls to
        this function will set focus to the last active popup of
        hwndStub.  phwnd will be set to NULL if the window already
        exists.

    TRUE - Success, either the printer was registered, or a window
           already exists.
*/

STDAPI_(BOOL) Printers_RegisterWindow(LPCTSTR pszPrinter, DWORD dwType, HANDLE *ph, HWND *phwnd)
{
    BOOL bReturn = FALSE;

    *ph = NULL;
    *phwnd = NULL;

    LPITEMIDLIST pidl = NULL;
    if (NULL == pszPrinter || 0 == pszPrinter[0])
    {
        // they ask us to register the local print server - i.e. server properties dialog
        pidl = SHCloneSpecialIDList(NULL, CSIDL_PRINTERS, FALSE);
        bReturn = (pidl != NULL);
    }
    else
    {
        bReturn = SUCCEEDED(ParsePrinterNameEx(pszPrinter, &pidl, TRUE, dwType, 0));
    }

    if (bReturn && pidl)
    {
        UNIQUESTUBINFO *pusi = (UNIQUESTUBINFO *)LocalAlloc(LPTR, sizeof(*pusi));

        if (pusi)
        {
            // Create a new stub window if necessary.
            if (EnsureUniqueStub(pidl, STUBCLASS_PROPSHEET, NULL, pusi))
            {
                *phwnd = pusi->hwndStub;
                *ph = pusi;     // it's just a cookie
            }
            else
            {
                LocalFree(pusi);
            }
        }

        ILFree(pidl);
    }

    return bReturn;
}

/* Unregister a window handle.

    hClassPidl - Registration handle returned from Printers_RegisterWindow.
        It's really a pointer to a UNIQUESTUBINFO structure.
*/
void Printers_UnregisterWindow(HANDLE hClassPidl, HWND hwnd)
{
    UNIQUESTUBINFO* pusi = (UNIQUESTUBINFO*)hClassPidl;
    if (pusi)
    {
        ASSERT(pusi->hwndStub == hwnd);
        FreeUniqueStub(pusi);
        LocalFree(pusi);
    }
}

void CPrinterFolder::_FillPidl(LPIDPRINTER pidl, LPCTSTR pszName, DWORD dwType, USHORT uFlags)
{
    ualstrcpyn(pidl->cName, pszName, ARRAYSIZE(pidl->cName));

    pidl->cb = (USHORT)(FIELD_OFFSET(IDPRINTER, cName) + (ualstrlen(pidl->cName) + 1) * sizeof(pidl->cName[0]));
    *(UNALIGNED USHORT *)((LPBYTE)(pidl) + pidl->cb) = 0;
    pidl->uFlags = uFlags;
    pidl->dwType = dwType;
    pidl->dwMagic = PRINTER_MAGIC;
}

// creates a relative PIDL to a printer.
HRESULT CPrinterFolder::_Parse(LPCTSTR pszPrinterName, LPITEMIDLIST *ppidl, DWORD dwType, USHORT uFlags)
{
    HRESULT hr = E_INVALIDARG;
    if (pszPrinterName && ppidl)
    {
        IDPRINTER idp;
        _FillPidl(&idp, pszPrinterName, dwType, uFlags);
        *ppidl = ILClone((LPCITEMIDLIST)&idp);
        hr = (*ppidl) ? S_OK : E_OUTOFMEMORY;
    }
    return hr;
}

TCHAR const c_szNewObject[]             =  TEXT("WinUtils_NewObject");
TCHAR const c_szFileColon[]             =  TEXT("FILE:");
TCHAR const c_szTwoSlashes[]            =  TEXT("\\\\");
TCHAR const c_szPrinters[]              =  TEXT("Printers");
TCHAR const c_szPrintersDefIcon[]       =  TEXT("Printers\\%s\\DefaultIcon");
TCHAR const c_szNewLine[]               =  TEXT("\r\n");

BOOL IsAvoidAutoDefaultPrinter(LPCTSTR pszPrinter)
{
    return lstrcmp(pszPrinter, TEXT("Fax")) == 0;
}

//---------------------------------------------------------------------------
//
// this implements IContextMenu via defcm.c for a printer object
//

BOOL Printer_WorkOnLine(LPCTSTR pszPrinter, BOOL fWorkOnLine)
{
    LPPRINTER_INFO_5 ppi5;
    BOOL bRet = FALSE;
    HANDLE hPrinter = Printer_OpenPrinterAdmin(pszPrinter);
    if (hPrinter)
    {
        ppi5 = (LPPRINTER_INFO_5)Printer_GetPrinterInfo(hPrinter, 5);
        if (ppi5)
        {
            if (fWorkOnLine)
                ppi5->Attributes &= ~PRINTER_ATTRIBUTE_WORK_OFFLINE;
            else
                ppi5->Attributes |= PRINTER_ATTRIBUTE_WORK_OFFLINE;

            bRet = SetPrinter(hPrinter, 5, (LPBYTE)ppi5, 0);
            LocalFree((HLOCAL)ppi5);
        }
        Printer_ClosePrinter(hPrinter);
    }

    return bRet;
}

TCHAR const c_szConfig[] =  TEXT("Config");

BOOL IsWinIniDefaultPrinter(LPCTSTR pszPrinter)
{
    BOOL bRet = FALSE;
    TCHAR szPrinterDefault[kPrinterBufMax];
    DWORD dwSize = ARRAYSIZE(szPrinterDefault);

    if(GetDefaultPrinter(szPrinterDefault, &dwSize))
    {
        bRet = lstrcmpi(szPrinterDefault, pszPrinter) == 0;
    }

    return bRet;
}

BOOL IsDefaultPrinter(LPCTSTR pszPrinter, DWORD dwAttributesHint)
{
    return (dwAttributesHint & PRINTER_ATTRIBUTE_DEFAULT) ||
            IsWinIniDefaultPrinter(pszPrinter);
}

// more win.ini uglyness
BOOL IsPrinterInstalled(LPCTSTR pszPrinter)
{
    //
    // No need to null terminate szScratch here since we don't use it anymore
    // The intention for this function is just to check if the printer is installed.
    // 
    TCHAR szScratch[2];
    return GetProfileString(TEXT("Devices"), pszPrinter, TEXT(""), szScratch, ARRAYSIZE(szScratch));
}

BOOL IsRedirectedPort(LPCTSTR pszPortName)
{
    if (!pszPortName || lstrlen(pszPortName) < 2)
    {
        return FALSE;
    }
    else
    {
        return (*(pszPortName+0) == TEXT('\\')) && (*(pszPortName+1) == TEXT('\\'));
    }
}

void CPrinterFolder::_MergeMenu(LPQCMINFO pqcm, LPCTSTR pszPrinter)
{
    INT idCmdFirst = pqcm->idCmdFirst;

    //
    // pszPrinter may be the share name of a printer rather than
    // the "real" printer name.  Use the real printer name instead,
    // which is returned from GetPrinter().
    //
    // These three only valid if pData != NULL.
    //
    LPCTSTR pszRealPrinterName;
    DWORD dwAttributes;
    DWORD dwStatus;
    PFOLDER_PRINTER_DATA pData = NULL;
    HMENU hmenuRunAs = NULL;
    BOOL bRemoveOffline = FALSE;

    TCHAR szFullPrinter[MAXNAMELENBUFFER];
    TCHAR szMenuText[255];

    // Insert verbs
    CDefFolderMenu_MergeMenu(HINST_THISDLL, MENU_PRINTOBJ_VERBS, 0, pqcm);

    // find the "Run as..." menu (if there is one) and update it in sync
    // with the main menu.
    MENUITEMINFO mii = {0};
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_SUBMENU;
    if (GetMenuItemInfo(pqcm->hmenu, idCmdFirst + FSIDM_RUNAS, MF_BYCOMMAND, &mii))
    {
        hmenuRunAs = mii.hSubMenu;
    }

    if (pszPrinter && GetFolder())
    {
        pData = (PFOLDER_PRINTER_DATA)Printer_FolderGetPrinter(GetFolder(), pszPrinter);
        if (pData)
        {
            _BuildPrinterName(szFullPrinter, ARRAYSIZE(szFullPrinter), NULL, ((PFOLDER_PRINTER_DATA)pData)->pName);
            pszRealPrinterName = szFullPrinter;
            dwStatus = ((PFOLDER_PRINTER_DATA)pData)->Status;
            dwAttributes = ((PFOLDER_PRINTER_DATA)pData)->Attributes;
        }
    }

    // Remove document defaults if it's a remote print folder.
    // This command should be removed from the context menu independently
    // on whether we have mutiple selection or not - i.e. pData.
    if (GetServer())
    {
        DeleteMenu(pqcm->hmenu, idCmdFirst + FSIDM_DOCUMENTDEFAULTS, MF_BYCOMMAND);
    }

    // disable/remove/rename verbs
    if (pData)
    {
        if (dwStatus & PRINTER_STATUS_PAUSED)
        {
            MENUITEMINFO mii;

            // we need to change the menu text to "Resume Printer" anc change the command ID
            LoadString(HINST_THISDLL, IDS_RESUMEPRINTER, szMenuText, ARRAYSIZE(szMenuText));
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_STRING | MIIM_ID;
            mii.dwTypeData = szMenuText;
            mii.wID = idCmdFirst + FSIDM_RESUMEPRN;
            SetMenuItemInfo(pqcm->hmenu, idCmdFirst + FSIDM_PAUSEPRN, MF_BYCOMMAND, &mii);

            if (hmenuRunAs)
            {
                mii.wID = idCmdFirst + FSIDM_RUNAS_RESUMEPRN;
                SetMenuItemInfo(hmenuRunAs, idCmdFirst + FSIDM_RUNAS_PAUSEPRN, MF_BYCOMMAND, &mii);
            }
        }

        if (0 == pData->cJobs)
        {
            // delete "Cancel All Documents" command if there are no any jobs in the queue
            DeleteMenu(pqcm->hmenu, idCmdFirst + FSIDM_PURGEPRN, MF_BYCOMMAND);
            if (hmenuRunAs)
            {
                DeleteMenu(hmenuRunAs, idCmdFirst + FSIDM_RUNAS_PURGEPRN, MF_BYCOMMAND);
            }
        }

        // Remove default printer if it's a remote print folder.
        if (GetServer() || IsDefaultPrinter(pszRealPrinterName, dwAttributes))
        {
            DeleteMenu(pqcm->hmenu, idCmdFirst + FSIDM_SETDEFAULTPRN, MF_BYCOMMAND);
        }

        // Check whether the printer is already installed. If it
        // is, remove the option to install it.

        if (IsPrinterInstalled(pszRealPrinterName))
        {
            DeleteMenu(pqcm->hmenu, idCmdFirst + FSIDM_NETPRN_INSTALL, MF_BYCOMMAND);
        }

        // Remove Delete if it is a network printer but not a masq printer
        // or a down level print server (SMB connection)
        //
        // can't delete printer connections as another user (they are per user)
        DWORD dwSpoolerVersion = SpoolerVersion();

        if ((dwAttributes & PRINTER_ATTRIBUTE_NETWORK) || (dwSpoolerVersion <= 2))
        {
            if (hmenuRunAs && !(dwAttributes & PRINTER_ATTRIBUTE_LOCAL))
            {
                DeleteMenu(hmenuRunAs, idCmdFirst + FSIDM_RUNAS_DELETE, MF_BYCOMMAND);
            }
        }

        // Remove work on/off-line if any of the following is met
        //  - remote print folder
        //  - network printer (including masq printer)
        //  - down level print server

        // Remove work offline if it's a redirected port printer
        // But we may show online command if a the printer is currently offline
        if (IsRedirectedPort(pData->pPortName))
        {
            bRemoveOffline = TRUE;
        }

        if (GetServer() ||
            (dwAttributes & PRINTER_ATTRIBUTE_NETWORK) ||
            (dwSpoolerVersion <= 2))
        {
            bRemoveOffline = TRUE;
        }
        else if (dwAttributes & PRINTER_ATTRIBUTE_WORK_OFFLINE)
        {
            MENUITEMINFO mii;

            // we need to change the menu text to "Use Printer Online" anc change the command ID
            LoadString(HINST_THISDLL, IDS_WORKONLINE, szMenuText, ARRAYSIZE(szMenuText));
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_STRING | MIIM_ID;
            mii.dwTypeData = szMenuText;
            mii.wID = idCmdFirst + FSIDM_WORKONLINE;
            SetMenuItemInfo(pqcm->hmenu, idCmdFirst + FSIDM_WORKOFFLINE, MF_BYCOMMAND, &mii);

            if (hmenuRunAs)
            {
                mii.wID = idCmdFirst + FSIDM_RUNAS_WORKONLINE;
                SetMenuItemInfo(hmenuRunAs, idCmdFirst + FSIDM_RUNAS_WORKOFFLINE, MF_BYCOMMAND, &mii);
            }

            bRemoveOffline = FALSE;
        }
    }
    else
    {
        // we have multiple printers selected
        if (!GetServer())
        {
            // if we are in the local printer's folder, do not display the "Connect..."
            // verb for the multiple selection case...
            DeleteMenu(pqcm->hmenu, idCmdFirst + FSIDM_NETPRN_INSTALL, MF_BYCOMMAND);
        }

        DeleteMenu(pqcm->hmenu, idCmdFirst + FSIDM_SETDEFAULTPRN, MF_BYCOMMAND);

        DeleteMenu(pqcm->hmenu, idCmdFirst + FSIDM_PAUSEPRN, MF_BYCOMMAND);
        if (hmenuRunAs)
        {
            DeleteMenu(hmenuRunAs, idCmdFirst + FSIDM_RUNAS_PAUSEPRN, MF_BYCOMMAND);
        }

        bRemoveOffline = TRUE;
    }

    if (bRemoveOffline)
    {
        DeleteMenu(pqcm->hmenu, idCmdFirst + FSIDM_WORKOFFLINE, MF_BYCOMMAND);
        if (hmenuRunAs)
        {
            DeleteMenu(hmenuRunAs, idCmdFirst + FSIDM_RUNAS_WORKOFFLINE, MF_BYCOMMAND);
        }
    }

    if (hmenuRunAs)
    {
        _SHPrettyMenu(hmenuRunAs);
    }

    if (pData)
    {
        LocalFree((HLOCAL)pData);
    }
}

//
// All string parsing functions should be localized here.
//

void Printer_SplitFullName(LPTSTR pszScratch, DWORD cchSize, LPCTSTR pszFullName, LPCTSTR *ppszServer, LPCTSTR *ppszPrinter)

/*++

    Splits a fully qualified printer connection name into server and
    printer name parts.

Arguments:

    pszScratch - Scratch buffer used to store output strings.  

    cchSize - Scratch buffer size, in characters including the null-terminator.

    pszFullName - Input name of a printer.  If it is a printer
        connection (\\server\printer), then we will split it.  If
        it is a true local printer (not a masq) then the server is
        szNULL.

    ppszServer - Receives pointer to the server string.  If it is a
        local printer, szNULL is returned.

    ppszPrinter - Receives a pointer to the printer string.  OPTIONAL

Return Value:

--*/

{
    LPTSTR pszPrinter;

    StringCchCopy(pszScratch, cchSize, pszFullName);

    if (pszFullName[0] != TEXT('\\') || pszFullName[1] != TEXT('\\'))
    {
        //
        // Set *ppszServer to szNULL since it's the local machine.
        //
        *ppszServer = szNULL;
        pszPrinter = pszScratch;
    }
    else
    {
        *ppszServer = pszScratch;
        pszPrinter = StrChr(*ppszServer + 2, TEXT('\\'));

        if (!pszPrinter)
        {
            //
            // We've encountered a printer called "\\server"
            // (only two backslashes in the string).  We'll treat
            // it as a local printer.  We should never hit this,
            // but the spooler doesn't enforce this.  We won't
            // format the string.  Server is local, so set to szNULL.
            //
            pszPrinter = pszScratch;
            *ppszServer = szNULL;
        }
        else
        {
            //
            // We found the third backslash; null terminate our
            // copy and set bRemote TRUE to format the string.
            //
            *pszPrinter++ = 0;
        }
    }

    if (ppszPrinter)
    {
        *ppszPrinter = pszPrinter;
    }
}

BOOL Printer_CheckShowFolder(LPCTSTR pszMachine)
{
    HANDLE hServer = Printer_OpenPrinter(pszMachine);
    if (hServer)
    {
        Printer_ClosePrinter(hServer);
        return TRUE;
    }
    return FALSE;
}

LPTSTR CPrinterFolder::_ItemName(LPCIDPRINTER pidp, LPTSTR pszName, UINT cch)
{
    ualstrcpyn(pszName, pidp->cName, cch);
    return pszName;
}

BOOL CPrinterFolder::_IsAddPrinter(LPCIDPRINTER pidp)
{
    TCHAR szPrinter[MAXNAMELENBUFFER];
    return 0 == lstrcmp(c_szNewObject, _ItemName(pidp, szPrinter, ARRAYSIZE(szPrinter)));
}

/*++
    Parses an unaligned partial printer name and printer shell folder
    into a fullly qualified printer name, and pointer to aligned printer
    name.

Arguments:

    pszFullPrinter - Buffer to receive fully qualified printer name
        Must be MAXNAMELENBUFFER is size.

    cchBufSize - The size of pszFullPrinter. Must be MAXNAMELENBUFFER.

    pidp - Optional pass in the pidl to allow us to try to handle cases where maybe an
        old style printer pidl was passed in.

    pszPrinter - Unaligned partial (local) printer name.

Return Value:

    LPCTSTR pointer to aligned partal (local) printer name.
--*/
LPCTSTR CPrinterFolder::_BuildPrinterName(LPTSTR pszFullPrinter, DWORD cchBufSize, LPCIDPRINTER pidp, LPCTSTR pszPrinter)
{
    UINT cchLen = 0;

    if (GetServer())
    {
        ASSERT(!pszPrinter || (lstrlen(pszPrinter) < MAXNAMELEN));

        StringCchPrintf(pszFullPrinter, cchBufSize, TEXT("%s\\"), GetServer());
        cchLen = lstrlen(pszFullPrinter);
    }

    if (pidp)
    {
        LPCIDPRINTER pidlprint = (LPCIDPRINTER) pidp;
        if (pidlprint->cb >= sizeof(DWORD) + FIELD_OFFSET(IDPRINTER, dwMagic) &&
            (pidlprint->dwMagic == PRINTER_MAGIC))
        {
            _ItemName(pidlprint, &pszFullPrinter[cchLen], MAXNAMELEN);
        }
        else
        {
            // Win95 form...
            SHAnsiToTChar(((LPW95IDPRINTER)pidp)->cName, &pszFullPrinter[cchLen], MAXNAMELEN);
        }
    }
    else
        lstrcpyn(&pszFullPrinter[cchLen], pszPrinter, MAXNAMELEN);

    ASSERT(lstrlen(pszFullPrinter) < MAXNAMELENBUFFER);

    return pszFullPrinter + cchLen;
}

/*++
    Check whether the printer is a local printer by looking at
    the name for the "\\localmachine\" prefix or no server prefix.

    This is a HACK: we should check by printer attributes, but when
    it's too costly or impossible (e.g., if the printer connection
    no longer exists), then we use this routine.

    Note: this only works for WINNT since the WINNT spooler forces
    printer connections to be prefixed with "\\server\."  Win9x
    allows the user to rename the printer connection to any arbitrary
    name.

    We determine if it's a masq  printer by looking for the
    weird format "\\localserver\\\remoteserver\printer."

Arguments:

    pszPrinter - Printer name.

    ppszLocal - Returns local name only if the printer is a local printer.
        (May be network and local if it's a masq printer.)

Return Value:

    TRUE: it's a network printer (true or masq).

    FALSE: it's a local printer.

--*/

BOOL Printer_CheckNetworkPrinterByName(LPCTSTR pszPrinter, LPCTSTR* ppszLocal)
{
    BOOL bNetwork = FALSE;
    LPCTSTR pszLocal = NULL;

    if (pszPrinter[0] == TEXT('\\') && pszPrinter[1] == TEXT('\\'))
    {
        TCHAR szComputer[MAX_COMPUTERNAME_LENGTH+1];
        DWORD cchComputer = ARRAYSIZE(szComputer);

        bNetwork = TRUE;
        pszLocal = NULL;

        //
        // Check if it's a masq printer.  If it has the format
        // \\localserver\\\server\printer then it's a masq case.
        //
        if (GetComputerName(szComputer, &cchComputer))
        {
            if (IntlStrEqNI(&pszPrinter[2], szComputer, cchComputer) &&
                pszPrinter[cchComputer] == TEXT('\\'))
            {
                if (pszPrinter[cchComputer+1] == TEXT('\\') &&
                    pszPrinter[cchComputer+2] == TEXT('\\'))
                {
                    //
                    // It's a masq printer.
                    //
                    pszLocal = &pszPrinter[cchComputer+1];
                }
            }
        }
    }
    else
    {
        // It's a local printer.
        pszLocal = pszPrinter;
    }

    if (ppszLocal)
    {
        *ppszLocal = pszLocal;
    }
    return bNetwork;
}

/*++
    Purges the specified printer, and prompting the user if
    they are really sure they want to purge the deviece.   It is
    kind of an extreme action to cancel all the documents on
    the printer.

    psf - pointer to shell folder
    hwnd - handle to view window
    pszFullPrinter - Fully qualified printer name.
    uAction - action to execute.

Return Value:

    TRUE: printer was purged successfully or the user choose to cancel
    the action, FALSE: an error occurred attempting to purge the device.

--*/
BOOL CPrinterFolder::_PurgePrinter(HWND hwnd, LPCTSTR pszFullPrinter, UINT uAction, BOOL bQuietMode)
{
    BOOL                    bRetval     = FALSE;
    LPTSTR                  pszRet      = NULL;
    LPCTSTR                 pszPrinter  = NULL;
    LPCTSTR                 pszServer   = NULL;
    TCHAR                   szTemp[MAXNAMELENBUFFER] = {0};
    BOOL                    bPurge = TRUE;

    if (!bQuietMode)
    {
        // We need to break up the full printer name in its components.
        // in order to construct the display name string.
        Printer_SplitFullName(szTemp, ARRAYSIZE(szTemp), pszFullPrinter, &pszServer, &pszPrinter);

        // If there is a server name then construct a friendly printer name.
        if (pszServer && *pszServer)
        {
            pszRet = ShellConstructMessageString(HINST_THISDLL,
                                                  MAKEINTRESOURCE(IDS_DSPTEMPLATE_WITH_ON),
                                                  &pszServer[2],
                                                  pszPrinter);
            pszPrinter = pszRet;
        }

        // If we are referring to a local printer or shell construct message
        // sting failed then just use the full printer name in the warning
        // message.
        if (!pszRet)
        {
            pszPrinter = pszFullPrinter;
        }

        // Ask the user if they are sure they want to cancel all documents.
        if (IDYES == ShellMessageBox(HINST_THISDLL, hwnd,
                             MAKEINTRESOURCE(IDS_SUREPURGE), MAKEINTRESOURCE(IDS_PRINTERS),
                             MB_YESNO | MB_ICONQUESTION, pszPrinter))
        {
            bPurge = TRUE;
        }
        else
        {
            bPurge = FALSE;
        }
    }

    // invoke the purge command
    bRetval = bPurge ? Printer_ModifyPrinter(pszFullPrinter, uAction) : TRUE;

    if (pszRet)
    {
        LocalFree(pszRet);
    }

    return bRetval;
}

HRESULT CPrinterFolder::_InvokeCommand(HWND hwnd, LPCIDPRINTER pidp, WPARAM wParam, LPARAM lParam,
                              BOOL *pfChooseNewDefault)
{
    HRESULT hr = S_OK;
    BOOL bNewObject = _IsAddPrinter(pidp);
    LPCTSTR pszPrinter;
    LPCTSTR pszFullPrinter;

    //
    // If it's a remote machine, prepend server name.
    //
    TCHAR szFullPrinter[MAXNAMELENBUFFER];

    if (bNewObject)
    {
        pszFullPrinter = pszPrinter = c_szNewObject;
    }
    else
    {
        pszPrinter = _BuildPrinterName(szFullPrinter, ARRAYSIZE(szFullPrinter), pidp, NULL);
        pszFullPrinter = szFullPrinter;
    }

    switch(wParam)
    {
        case FSIDM_RUNAS_SHARING:
        case FSIDM_RUNAS_OPENPRN:
        case FSIDM_RUNAS_RESUMEPRN:
        case FSIDM_RUNAS_PAUSEPRN:
        case FSIDM_RUNAS_WORKONLINE:
        case FSIDM_RUNAS_WORKOFFLINE:
        case FSIDM_RUNAS_PURGEPRN:
        case FSIDM_RUNAS_DELETE:
        case FSIDM_RUNAS_PROPERTIES:
            {
                // handle all "Run As..." commands here
                hr = _InvokeCommandRunAs(hwnd, pidp, wParam, lParam, pfChooseNewDefault);
            }
            break;

    case FSIDM_OPENPRN:
        SHInvokePrinterCommand(hwnd, PRINTACTION_OPEN, pszFullPrinter, GetServer(), FALSE);
        break;

    case FSIDM_ADDPRINTERWIZARD:
        if (NULL == GetServer() || GetAdminAccess())
        {
            // This is the local printers folder or it is the remote printers folder, but you have
            // admin access to to the remote machine - go ahead.
            SHInvokePrinterCommand(hwnd, PRINTACTION_OPEN, pszFullPrinter, GetServer(), FALSE);
        }
        else
        {
            // This is the remote printers folder and the user don't have the necessary access to install
            // a printer - then ask to run as different user.
            if (IDYES == ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_ADDPRINTERTRYRUNAS),
                MAKEINTRESOURCE(IDS_PRINTERS), MB_YESNO|MB_ICONQUESTION, GetServer()))
            {
                _InvokeCommandRunAs(hwnd, pidp, FSIDM_RUNAS_ADDPRN, lParam, pfChooseNewDefault);
            }
        }
        break;

    case FSIDM_RUNAS_ADDPRN:
        if (bNewObject)
        {
            _InvokeCommandRunAs(hwnd, pidp, FSIDM_RUNAS_ADDPRN, lParam, pfChooseNewDefault);
        }
        break;

    case FSIDM_DOCUMENTDEFAULTS:
        if (!bNewObject)
        {
            SHInvokePrinterCommand(hwnd, PRINTACTION_DOCUMENTDEFAULTS, pszFullPrinter, NULL, 0);
        }
        break;

    case FSIDM_SHARING:
    case DFM_CMD_PROPERTIES:

        if (!bNewObject)
        {
            SHInvokePrinterCommand(hwnd, PRINTACTION_PROPERTIES, pszFullPrinter,
                                 wParam == FSIDM_SHARING ?
                                     (LPCTSTR)PRINTER_SHARING_PAGE :
                                     (LPCTSTR)lParam, FALSE);
        }
        break;

    case DFM_CMD_DELETE:
        if (!bNewObject &&
            IDYES == CallPrinterCopyHooks(hwnd, PO_DELETE,
                0, pszFullPrinter, 0, NULL, 0))
        {
            BOOL bNukedDefault = FALSE;
            DWORD dwAttributes = 0;

            LPCTSTR pszPrinterCheck = pszFullPrinter;
            PFOLDER_PRINTER_DATA pData = (PFOLDER_PRINTER_DATA)Printer_FolderGetPrinter(GetFolder(), pszFullPrinter);
            if (pData)
            {
                dwAttributes = pData->Attributes;
                pszPrinterCheck = pData->pName;
            }

            if (GetServer() == NULL)
            {
                // this is a local print folder then
                // we need to check if we're deleting the default printer.
                bNukedDefault = IsDefaultPrinter(pszPrinterCheck, dwAttributes);
            }

            if (pData)
                LocalFree((HLOCAL)pData);

            BOOL fSuccess = Printers_DeletePrinter(hwnd, pszPrinter, dwAttributes, GetServer(), (BOOL)lParam);
            // if so, make another one the default
            if (bNukedDefault && fSuccess && pfChooseNewDefault)
            {
                // don't choose in the middle of deletion,
                // or we might delete the "default" again.
                *pfChooseNewDefault = TRUE;
            }
        }
        break;

    case FSIDM_SETDEFAULTPRN:
        Printer_SetAsDefault(pszFullPrinter);
        break;

    case FSIDM_PAUSEPRN:
        if (!Printer_ModifyPrinter(pszFullPrinter, PRINTER_CONTROL_PAUSE))
            goto WarnOnError;
        break;

    case FSIDM_RESUMEPRN:
        if (!Printer_ModifyPrinter(pszFullPrinter, PRINTER_CONTROL_RESUME))
            goto WarnOnError;
        break;

    case FSIDM_PURGEPRN:
        if (!bNewObject)
        {
            if (!_PurgePrinter(hwnd, pszFullPrinter, PRINTER_CONTROL_PURGE, (BOOL)lParam))
            {
WarnOnError:
                // show an appropriate error message based on the last error
                ShowErrorMessageSC(NULL, NULL, hwnd, NULL, NULL, MB_OK|MB_ICONEXCLAMATION, GetLastError());
            }
        }
        break;

    case FSIDM_NETPRN_INSTALL:
        {
            SHInvokePrinterCommand(hwnd, PRINTACTION_NETINSTALL, pszFullPrinter, NULL, FALSE);
        }
        break;

    case FSIDM_WORKONLINE:
        if (!Printer_WorkOnLine(pszFullPrinter, TRUE))
        {
            // show an appropriate error message based on the last error
            ShowErrorMessageSC(NULL, NULL, hwnd, NULL, NULL, MB_OK|MB_ICONEXCLAMATION, GetLastError());
        }
        break;

    case FSIDM_WORKOFFLINE:
        if (!Printer_WorkOnLine(pszFullPrinter, FALSE))
        {
            // show an appropriate error message based on the last error
            ShowErrorMessageSC(NULL, NULL, hwnd, NULL, NULL, MB_OK|MB_ICONEXCLAMATION, GetLastError());
        }
        break;

    case DFM_CMD_LINK:
    case DFM_CMD_RENAME:
    case DFM_CMD_PASTE:
        // let defcm handle this too
        hr = S_FALSE;
        break;

    default:
        // GetAttributesOf doesn't set other SFGAO_ bits,
        // BUT accelerator keys will get unavailable menu items,
        // so we need to return failure here.
        hr = E_NOTIMPL;
        break;
    } // switch(wParam)

    return hr;
}

// implements a bunch of admin related "Run as..." command using printui.dll rundll32 interface.
HRESULT CPrinterFolder::_InvokeCommandRunAs(HWND hwnd, LPCIDPRINTER pidp, WPARAM wParam, LPARAM lParam,
                                            LPBOOL pfChooseNewDefault)
{
    HRESULT hr = S_OK;                      // assume success
    TCHAR szCmdLine[2048];                  // the command line buffer - 2K should be enough.
    BOOL bNewObject = FALSE;                // TRUE if "Add Printer" icon is selected
    TCHAR szFullPrinter[MAXNAMELENBUFFER];  // buffer to expand the full printer name i.e. \\server\printer
    LPCTSTR pszPrinter = NULL;              // only the printer name is here
    LPTSTR pszFullPrinter = NULL;           // the fully qulified printer name i.e. \\server\printer

    if (pidp)
    {
        bNewObject = _IsAddPrinter(pidp);
        if (!bNewObject)
        {
            pszPrinter = _BuildPrinterName(szFullPrinter, ARRAYSIZE(szFullPrinter), pidp, NULL);

            // insert backslashes for command parsing
            hr = InsertBackSlash(szFullPrinter, &pszFullPrinter);
            if (FAILED(hr))
            {
                goto Done;
            }
        }
    }

    // build the command line here
    szCmdLine[0] = 0;
    int iResult = -1;

    switch(wParam)
    {
    case FSIDM_RUNAS_SHARING:
        // bring up the properties dialog for this printer, positioned on the sharing page
        iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /p /t1 /n\"%s\""), pszFullPrinter);
        break;

    case FSIDM_RUNAS_ADDPRN:
        {
            // invoke the add printer wizard here
            iResult = (NULL == GetServer()) ?
                // local server - simply format the command
                wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("%s"), TEXT("printui.dll,PrintUIEntry /il")):
                // remote server case - specify the machine name
                wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /il /c\"%s\""), GetServer());
        }
        break;

    case FSIDM_RUNAS_SVRPROP:
        {
            // bring up the server properties dialog for this print server
            iResult = (NULL == GetServer()) ?
                // local server - simply format the command
                wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("%s"), TEXT("printui.dll,PrintUIEntry /s /t0")):
                // remote server case - specify the machine name
                wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /s /t0 /n\"%s\""), GetServer());
        }
        break;

    case FSIDM_RUNAS_OPENPRN:
        // bring up the print queue for this printer
        iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /o /n\"%s\""), pszFullPrinter);
        break;

    case FSIDM_RUNAS_RESUMEPRN:
        // pause the printer (assume ready)
        iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /Xs /n\"%s\" Status Resume"), pszFullPrinter);
        break;

    case FSIDM_RUNAS_PAUSEPRN:
        // resume a paused printer back to ready mode
        iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /Xs /n\"%s\" Status Pause"), pszFullPrinter);
        break;

    case FSIDM_RUNAS_WORKONLINE:
        // resume an offline printer back to online mode
        iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /Xs /n\"%s\" Attributes -WorkOffline"), pszFullPrinter);
        break;

    case FSIDM_RUNAS_WORKOFFLINE:
        // make the printer available offline (assume online mode)
        iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /Xs /n\"%s\" Attributes +WorkOffline"), pszFullPrinter);
        break;

    case FSIDM_RUNAS_PURGEPRN:
        {
            // cancel all documents pending to print on this printer
            LPTSTR pszMsg = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_SUREPURGE), szFullPrinter);

            if (pszMsg)
            {
                LPTSTR pszNewMsg = NULL;
                if (SUCCEEDED(hr = InsertBackSlash(pszMsg, &pszNewMsg)))
                {
                    iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /Mq\"%s\" /Xs /n\"%s\" Status Purge"), pszNewMsg, pszFullPrinter);
                    SHFree(pszNewMsg);
                }
                SHFree(pszMsg);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

        }
        break;

    case FSIDM_RUNAS_DELETE:
        {
            LPTSTR pszMsg = NULL;
            LPCTSTR pszP = NULL, pszS = NULL;
            TCHAR szBuffer[MAXNAMELENBUFFER] = {0};

            Printer_SplitFullName(szBuffer, ARRAYSIZE(szBuffer), pszPrinter, &pszS, &pszP);

            if (pszS && *pszS)
            {
                // this can be a masq printer - use the connection template in this case
                pszMsg = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_SUREDELETECONNECTION), 
                    pszP, SkipServerSlashes(pszS));
            }
            else
            {
                if (GetServer())
                {
                    // this is a local printer in the remote PF - use the remote PF template
                    pszMsg = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_SUREDELETEREMOTE), 
                        pszPrinter, SkipServerSlashes(GetServer()));
                }
                else
                {
                    // this is a local printer in the local PF - use the local PF template
                    pszMsg = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_SUREDELETE), pszPrinter);
                }
            }

            hr = pszMsg ? S_OK : E_OUTOFMEMORY;

            if (SUCCEEDED(hr))
            {
                LPTSTR pszNewMsg = NULL;
                if (SUCCEEDED(hr = InsertBackSlash(pszMsg, &pszNewMsg)))
                {
                    iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /Mq\"%s\" /dl /n\"%s\""), pszNewMsg, pszFullPrinter);
                    SHFree(pszNewMsg);
                }
                SHFree(pszMsg);
            }
        }
        break;

    case FSIDM_RUNAS_PROPERTIES:
        // bring up the properties dialog for this printer
        iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /p /t0 /n\"%s\""), pszFullPrinter);
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    if (SUCCEEDED(hr) && -1 == iResult)
    {
        hr = E_NOTIMPL;
    }

    if (SUCCEEDED(hr))
    {
        // invokes the command as different user (run as) through rundll process...
        SHRunDLLProcess(hwnd, szCmdLine, SW_SHOWNORMAL, IDS_PRINTERS, TRUE);
    }

Done:
    // clean up
    SHFree(pszFullPrinter);
    return hr;
}


//
// The printer name specified in the _SHARE_INFO_502 structure in a call
// to NetShareAdd() which is in localspl.dll, contains a printer name that
// is expressed as \\server_name\printer_name,LocalsplOnly.  (',LocalsplOnly'
// post fix string was recently added for clustering support)  The server
// name prefix and the post fix string prevent the maximum printer name from
// being a valid size in a call to NetShareAdd(), because NetShareAdd() will
// only accept a maximum share name path of 256 characters, therefore the
// maximum printer name calculation has been changed to.  This change only
// applies to the windows nt spooler.  Because the remote printers folder can
// view non shared printers on downlevel print servers we cannot change the
// maxnamelen define to 220 this would break long printer name printers on
// downlevel print servers.
//
// max local printer name = max shared net path - (wack + wack + max server name + wack + comma + 'LocalsplOnly' + null)
// max local printer name = 256 - (1 + 1 + 13 + 1 + 1 + 12 + 1)
// max local printer name = 256 - 30
// max local printer name = 226 - 5 to round to some reasonable number
// max local printer name = 221
//
#define MAXLOCALNAMELEN 221

// returns 0 if this is a legal name
// returns the IDS_ string id of the error string for an illegal name
int _IllegalPrinterName(LPTSTR pszName)
{
    int fIllegal = 0;

    if (*pszName == 0)
    {
        fIllegal = IDS_PRTPROP_RENAME_NULL;
    }
    else if (lstrlen(pszName) >= MAXLOCALNAMELEN)
    {
        fIllegal = IDS_PRTPROP_RENAME_TOO_LONG;
    }
    else
    {
        while (*pszName         &&
               *pszName != TEXT('!')  &&
               *pszName != TEXT('\\') &&
               *pszName != TEXT(',')   )
        {
            pszName++ ;
        }
        if (*pszName)
        {
            fIllegal = IDS_PRTPROP_RENAME_BADCHARS;
        }
    }

    return fIllegal;
}

const struct
{
    UINT_PTR    uVerbID;
    LPCSTR      pszCanonicalName;
}
g_CanonicalVerbNames[] =
{
    {DFM_CMD_DELETE,        "delete"        },
    {DFM_CMD_MOVE,          "cut"           },
    {DFM_CMD_COPY,          "copy"          },
    {DFM_CMD_PASTE,         "paste"         },
    {DFM_CMD_LINK,          "link"          },
    {DFM_CMD_PROPERTIES,    "properties"    },
    {DFM_CMD_PASTELINK,     "pastelink"     },
    {DFM_CMD_RENAME,        "rename"        },
};

static LPCSTR _GetStandardCommandCanonicalName(UINT_PTR uVerbID)
{
    LPCSTR pszCmd = NULL;
    for (int i=0; i<ARRAYSIZE(g_CanonicalVerbNames); i++)
    {
        if (uVerbID == g_CanonicalVerbNames[i].uVerbID)
        {
            pszCmd = g_CanonicalVerbNames[i].pszCanonicalName;
            break;
        }
    }
    return pszCmd;
}

HRESULT CALLBACK CPrinterFolder::_DFMCallBack(IShellFolder *psf, HWND hwnd,
   IDataObject *pdo, UINT uMsg, WPARAM wParam, LPARAM lParam)

{

    CPrinterFolder* This;
    HRESULT hr = psf->QueryInterface(CLSID_Printers, (void**)&This);
    if (FAILED(hr))
        return hr;

    hr = E_INVALIDARG;
    if (pdo)
    {
        // let't split the selection into its components (printers and links)
        IDataObject *pdoP = NULL;
        IDataObject *pdoL = NULL;
        UINT uSelType = SEL_NONE;

        if (SUCCEEDED(hr = This->SplitSelection(pdo, &uSelType, &pdoP, &pdoL)))
        {
            if (pdoP)
            {
                // we have printer objects in the selection delegate the call to
                // _PrinterObjectsCallBack
                hr = This->_PrinterObjectsCallBack(hwnd, uSelType, pdoP, uMsg, wParam, lParam);
            }

            if (SUCCEEDED(hr) && pdoL && DFM_INVOKECOMMAND == uMsg)
            {
                // we have link objects. this can only happen if we have mixed selection
                // of print and link objects. we need to handle some of the commands through
                // printhood
                IShellFolder2* psfPrinthood = CPrintRoot_GetPSF();
                if (psfPrinthood)
                {
                    LPCSTR pszCmd = _GetStandardCommandCanonicalName(wParam);
                    hr = pszCmd ? SHInvokeCommandOnDataObject(hwnd, psfPrinthood, pdoL, 0, pszCmd) : E_NOTIMPL;
                }
            }
        }

        if (pdoP)
            pdoP->Release();

        if (pdoL)
            pdoL->Release();
    }

    This->Release();
    return hr;
}

HRESULT CPrinterFolder::_PrinterObjectsCallBack(HWND hwnd, UINT uSelType,
    IDataObject *pdo, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = E_INVALIDARG;

    if (pdo)
    {
        STGMEDIUM medium;
        LPIDA pida = DataObj_GetHIDA(pdo, &medium);

        hr = E_OUTOFMEMORY;
        if (pida)
        {
            hr = S_OK;
            switch (uMsg)
            {
            case DFM_MERGECONTEXTMENU:
                //  returning S_FALSE indicates no need to use default verbs
                hr = S_FALSE;
                break;

            case DFM_MERGECONTEXTMENU_TOP:
            {
                // merge the printer commands in the context menu only if
                // there are no link objects in the selection
                if (0 == (SEL_LINK_ANY & uSelType))
                {
                    LPQCMINFO pqcm = (LPQCMINFO)lParam;
                    UINT idCmdBase = pqcm->idCmdFirst; // must be called before merge
                    UINT idRunAs =  FSIDM_RUNAS;

                    if (pida->cidl == 1 && _IsAddPrinter((LPCIDPRINTER)IDA_GetIDListPtr(pida, 0)))
                    {
                        // The only selected object is the "New Printer" thing

                        // insert verbs
                        CDefFolderMenu_MergeMenu(HINST_THISDLL, MENU_ADDPRINTER_OPEN_VERBS, 0, pqcm);

                        idRunAs = FSIDM_RUNAS_ADDPRN;
                    }
                    else
                    {
                        LPCTSTR pszFullPrinter = NULL;
                        TCHAR szFullPrinter[MAXNAMELENBUFFER];
                        // We're dealing with printer objects

                        if (!(wParam & CMF_DEFAULTONLY))
                        {
                            if (pida->cidl == 1)
                            {
                                LPIDPRINTER pidp = (LPIDPRINTER)IDA_GetIDListPtr(pida, 0);
                                if (pidp)
                                {
                                    _BuildPrinterName(szFullPrinter, ARRAYSIZE(szFullPrinter), pidp, NULL);
                                    pszFullPrinter = szFullPrinter;
                                }
                            }
                        }

                        _MergeMenu(pqcm, pszFullPrinter);
                    }

                    if (!(wParam & CMF_EXTENDEDVERBS) || (pida->cidl > 1))
                    {
                        // if the extended verbs are not enabled (shift key is not down) then
                        // delete the "Run as..." command(s).
                        DeleteMenu(pqcm->hmenu, idCmdBase + idRunAs, MF_BYCOMMAND);
                    }

                    SetMenuDefaultItem(pqcm->hmenu, 0, MF_BYPOSITION);
                }
                break;
            }

            case DFM_GETHELPTEXT:
            case DFM_GETHELPTEXTW:
            {
                // this is applicale only for our printer commands
                if (0 == (SEL_LINK_ANY & uSelType))
                {
                    int idCmd = LOWORD(wParam);
                    int cchMax = HIWORD(wParam);
                    LPBYTE pBuf = (LPBYTE)lParam;

                    if (FSIDM_RUNAS_FIRST < idCmd && idCmd < FSIDM_RUNAS_LAST)
                    {
                        // all runas commands have the same help text (FSIDM_RUNAS)
                        idCmd = FSIDM_RUNAS;
                    }

                    if (uMsg == DFM_GETHELPTEXTW)
                        LoadStringW(HINST_THISDLL, idCmd + IDS_MH_FSIDM_FIRST,
                                    (LPWSTR)pBuf, cchMax);
                    else
                        LoadStringA(HINST_THISDLL, idCmd + IDS_MH_FSIDM_FIRST,
                                    (LPSTR)pBuf, cchMax);

                    break;
                }
            }

            case DFM_INVOKECOMMAND:
            {
                BOOL fChooseNewDefault = FALSE;

                // Assume not quiet mode
                lParam = 0;
                switch (wParam)
                {
                    case (DFM_CMD_DELETE):
                    case (FSIDM_PURGEPRN):
                    {
                        UINT uMsgID = DFM_CMD_DELETE == wParam ? IDS_SUREDELETEMULTIPLE :
                                      FSIDM_PURGEPRN == wParam ? IDS_SUREPURGEMULTIPLE : 0;

                        if (uMsgID && pida->cidl > 1)
                        {
                            // delete multiple printers. ask the user once for confirmation and then delete
                            // all the selected printers quietly
                            if (ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(uMsgID),
                                MAKEINTRESOURCE(IDS_PRINTERS), MB_YESNO|MB_ICONQUESTION)
                                != IDYES)
                            {
                                goto Bail;
                            }

                            // Turn on the quiet mode
                            lParam = 1;
                        }
                    }
                    break;
                }

                for (int i = pida->cidl - 1; i >= 0; i--)
                {
                    LPIDPRINTER pidp = (LPIDPRINTER)IDA_GetIDListPtr(pida, i);

                    hr = _InvokeCommand(hwnd, pidp, wParam, lParam, &fChooseNewDefault);

                    if (hr != S_OK)
                        goto Bail;
                }

                if (fChooseNewDefault)
                    Printers_ChooseNewDefault(hwnd);

                break;
            } // case DFM_INVOKECOMMAND

            default:
                hr = E_NOTIMPL;
                break;
            } // switch (uMsg)

Bail:
            HIDA_ReleaseStgMedium(pida, &medium);
        }
    }

    return hr;
}

//
// IContextMenuCB::Callback entry for the background menu (right click backgrond of folder)
//
HRESULT CPrinterFolder::CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdo,
                                  UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    LPQCMINFO pqcm;
    UINT idCmdBase;

    switch(uMsg)
    {
        case DFM_MERGECONTEXTMENU:
            //  returning S_FALSE indicates no need to use default verbs
            hr = S_FALSE;
            break;

        case DFM_MERGECONTEXTMENU_TOP:
        {
            pqcm = (LPQCMINFO)lParam;
            idCmdBase = pqcm->idCmdFirst; // must be called before merge
            CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_DRIVES_PRINTERS, 0, pqcm);

            if (!(wParam & CMF_EXTENDEDVERBS))
            {
                // if the extended verbs are not enabled (shift key is not down) then
                // delete the "Run as..." command(s).
                DeleteMenu(pqcm->hmenu, idCmdBase + FSIDM_RUNAS, MF_BYCOMMAND);
            }

            // fax related commands are applicable only for the local printers folder
            UINT_PTR uCmd;
            if (GetServer() || FAILED(_GetFaxCommand(&uCmd)))
            {
                uCmd = 0;
            }

            UINT_PTR arrFaxCmds[] = 
            { 
                FSIDM_SETUPFAXING, 
                FSIDM_CREATELOCALFAX, 
                FSIDM_SENDFAXWIZARD
            };

            // all fax commands are mutually exclusive - only the one returned from 
            // _GetFaxCommand is applicable. 

            for (INT_PTR i = 0; i < ARRAYSIZE(arrFaxCmds); i++)
            {
                if (uCmd != arrFaxCmds[i])
                {
                    DeleteMenu(pqcm->hmenu, idCmdBase + arrFaxCmds[i], MF_BYCOMMAND);
                }
            }
        }
        break;

    case DFM_GETHELPTEXT:
    case DFM_GETHELPTEXTW:
        {
            int idCmd = LOWORD(wParam);
            int cchMax = HIWORD(wParam);

            if (FSIDM_RUNAS_FIRST < idCmd && idCmd < FSIDM_RUNAS_LAST)
            {
                // all runas commands have the same help text (FSIDM_RUNAS)
                idCmd = FSIDM_RUNAS;
            }

            if (DFM_GETHELPTEXT == uMsg)
            {
                LoadStringA(HINST_THISDLL, idCmd + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, cchMax);
            }
            else
            {
                LoadStringW(HINST_THISDLL, idCmd + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, cchMax);
            }
        }
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam)
        {
        case FSIDM_CONNECT_PRN:
            SHNetConnectionDialog(hwnd, NULL, RESOURCETYPE_PRINT);
            break;

        case FSIDM_DISCONNECT_PRN:
            WNetDisconnectDialog(hwnd, RESOURCETYPE_PRINT);
            break;

        case FSIDM_ADDPRINTERWIZARD:
            if (NULL == GetServer() || GetAdminAccess())
            {
                // This is the local printers folder or it is the remote printers folder, but you have
                // admin access to to the remote machine - go ahead.
                SHInvokePrinterCommand(hwnd, PRINTACTION_OPEN, c_szNewObject, GetServer(), FALSE);
            }
            else
            {
                // This is the remote printers folder and the user don't have the necessary access to install
                // a printer - then ask to run as different user.
                if (IDYES == ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_ADDPRINTERTRYRUNAS),
                    MAKEINTRESOURCE(IDS_PRINTERS), MB_YESNO|MB_ICONQUESTION, GetServer()))
                {
                    _InvokeCommandRunAs(hwnd, NULL, FSIDM_RUNAS_ADDPRN, lParam, NULL);
                }
            }
            break;

        case FSIDM_SERVERPROPERTIES:
            SHInvokePrinterCommand(hwnd, PRINTACTION_SERVERPROPERTIES,
                GetServer() ? GetServer() : TEXT(""), NULL, FALSE);
            break;

        case FSIDM_SENDFAXWIZARD:
            // just invoke faxsend.exe here
            ShellExecute(hwnd, TEXT("open"), FAX_SEND_IMAGE_NAME, TEXT(""), NULL, SW_SHOWNORMAL);
            break;
        
        case FSIDM_SETUPFAXING:
            // push the command in background
            SHQueueUserWorkItem(reinterpret_cast<LPTHREAD_START_ROUTINE>(_ThreadProc_InstallFaxService), 
                NULL, 0, 0, NULL, "shell32.dll", 0);
            break;

        case FSIDM_CREATELOCALFAX:
            // push the command in background
            SHQueueUserWorkItem(reinterpret_cast<LPTHREAD_START_ROUTINE>(_ThreadProc_InstallLocalFaxPrinter), 
                NULL, 0, 0, NULL, "shell32.dll", 0);
            break;

        case FSIDM_RUNAS_ADDPRN:
        case FSIDM_RUNAS_SVRPROP:
            {
                // handle all "Run As..." commands here
                hr = _InvokeCommandRunAs(hwnd, NULL, wParam, lParam, NULL);
            }
            break;

        default:
            // one of view menu items, use the default code.
            hr = S_FALSE;
            break;
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}

////////////////////////
// CPrintersEnum
////////////////////////

class CPrintersEnum: public CEnumIDListBase
{
public:
    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST* ppidl, ULONG* pceltFetched);

    // CreateInstance
    static HRESULT CreateInstance(DWORD grfFlags, DWORD dwRemote, IEnumIDList* peunk, CPrinterFolder* ppsf, IEnumIDList **ppenum);

private:
    CPrintersEnum(DWORD grfFlags, DWORD dwRemote, IEnumIDList* peunk, CPrinterFolder* ppsf);
    virtual ~CPrintersEnum();

    DWORD _grfFlags;
    int _nLastFound;
    CPrinterFolder* _ppsf;
    PFOLDER_PRINTER_DATA _pPrinters;
    DWORD _dwNumPrinters;
    DWORD _dwRemote;
    IEnumIDList* _peunk;            // file system enumerator
};

// Flags for the dwRemote field
//

#define RMF_SHOWLINKS   0x00000001  // Hoodlinks need to be shown

CPrintersEnum::CPrintersEnum(DWORD grfFlags, DWORD dwRemote, IEnumIDList* peunk, CPrinterFolder* ppsf)
{
    _nLastFound = -1;
    _pPrinters = NULL;

    _grfFlags = grfFlags;
    _dwRemote = dwRemote;
    _peunk = peunk;
    _ppsf = ppsf;
}

CPrintersEnum::~CPrintersEnum()
{
    if (_pPrinters)
        LocalFree((HLOCAL)_pPrinters);

    // Release the link (filesystem) enumerator.
    if (_peunk)
        _peunk->Release();
}

//
// IEnumIDList
//

STDMETHODIMP CPrintersEnum::Next(ULONG celt, LPITEMIDLIST* ppidl, ULONG* pceltFetched)
{
    HRESULT hr = S_OK;

    if (pceltFetched)
        *pceltFetched = 0;

    // We don't do any form of folder

    if (!(_grfFlags & SHCONTF_NONFOLDERS))
    {
        return S_FALSE;
    }

    // Are we looking for the links right now?
    if (_dwRemote & RMF_SHOWLINKS)
    {
        // Yes, use the link (PrintHood folder) enumerator
        if (_peunk)
        {
            hr = _peunk->Next(1, ppidl, pceltFetched);
            if (hr == S_OK)
            {
                // Added link
                return S_OK;
            }
        }
        _dwRemote &= ~RMF_SHOWLINKS; // Done enumerating links
    }

    // Carry on with enumerating printers now
    ASSERT(_nLastFound >= 0 || _nLastFound == -1);

    if (_nLastFound == -1)
    {
        // check if refresh has been requested
        _ppsf->CheckToRefresh();

        // free up the memory if _pPrinters is not NULL
        if (_pPrinters)
        {
            LocalFree((HLOCAL)_pPrinters);
            _pPrinters = NULL;
        }

        // note that _pPrinters may be NULL if no printers are installed.
        _dwNumPrinters = _ppsf->GetFolder() ? Printers_FolderEnumPrinters(
            _ppsf->GetFolder(), (void**)&_pPrinters) : 0;

        if (S_FALSE != SHShouldShowWizards(_punkSite) && !SHRestricted(REST_NOPRINTERADD))
        {
            // special case the Add Printer Wizard.
            hr = _ppsf->_Parse(c_szNewObject, ppidl);
            goto Done;
        }

        // Not an admin, skip the add printer wizard and return the
        // first item.
        _nLastFound = 0;
    }

    if (_nLastFound >= (int)_dwNumPrinters)
        return S_FALSE;

    hr = _ppsf->_Parse(GetPrinterName(_pPrinters, _nLastFound), ppidl);

Done:

    if (SUCCEEDED(hr))
    {
        ++_nLastFound;
        if (pceltFetched)
            *pceltFetched = 1;
    }

    return hr;
}

// CreateInstance
HRESULT CPrintersEnum::CreateInstance(DWORD grfFlags, DWORD dwRemote, IEnumIDList *peunk, CPrinterFolder *ppsf, IEnumIDList **ppenum)
{
    HRESULT hr = E_INVALIDARG;
    if (ppenum && ppsf)
    {
        *ppenum = NULL;
        hr = E_OUTOFMEMORY;
        CPrintersEnum *pObj = new CPrintersEnum(grfFlags, dwRemote, peunk, ppsf);
        if (pObj)
        {
            hr = pObj->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
            pObj->Release();
        }
    }
    return hr;
}

//
// CPrinterFolder
//

CPrinterFolder::CPrinterFolder()
{
    _cRef = 1;
    _pszServer = NULL;
    _dwSpoolerVersion = -1;
    _pidl = NULL;

    _hFolder = NULL;
    _bAdminAccess = FALSE;
    _bReqRefresh = FALSE;
}

CPrinterFolder::~CPrinterFolder()
{
    if (_hFolder)
    {
        // unregister from the folder cache
        UnregisterPrintNotify(_pszServer, this, &_hFolder);
    }

    //
    // The pidl must be freed here!! (after unregister from PRUNTUI.DLL),
    // because if you move this code before the call to PRINTUI
    // serious race condition occurs. Have in mind that the interface which
    // is used for communication with PRINTUI is part this class and
    // and uses the pidl in its ProcessNotify(...) member
    //
    if (_pidl)
    {
        ILFree(_pidl);
    }

    if (_pszServer)
    {
        LocalFree(_pszServer);
    }

    // clear the PDO cache
    _WebviewCheckToUpdateDataObjectCache(NULL);

    // cleanup the slow webview data cache
    if (_dpaSlowWVDataCache)
    {
        _SlowWVDataCacheResetUnsafe();
        ASSERT(0 == _dpaSlowWVDataCache.GetPtrCount());
        _dpaSlowWVDataCache.Destroy();
    }
}


/*++

    Returns the printer status string in the privided
    buffer.

Arguments:

    pData - pointer to printer data, i.e. cache data
    pBuff - pointer to buffer where to return status string.
    uSize - size in characters of status buffer.

Return Value:

    pointer to printer status string.

--*/

LPCTSTR CPrinterFolder::GetStatusString(PFOLDER_PRINTER_DATA pData, LPTSTR pBuff, UINT uSize)
{
    LPCTSTR pszReturn = pBuff;
    DWORD dwStatus = pData->Status;

    *pBuff = 0;

    // HACK: Use this free bit for "Work Offline"
    // 99/03/30 #308785 vtan: compare the strings displayed. Adjust
    // for this hack from GetDetailsOf().
    if (pData->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE)
        dwStatus |= PRINTER_HACK_WORK_OFFLINE;

    // If there is queue status value then convert the status id to a
    // readable status string.
    if (dwStatus)
    {
        Printer_BitsToString(dwStatus, IDS_PRQSTATUS_SEPARATOR, pBuff, uSize);
    }
    else
    {
        // If we do not have queue status string then the status of the queue
        // is 0 and assumed ready, display ready rather than an empty string.
        if (!pData->pStatus)
        {
            LoadString(HINST_THISDLL, IDS_PRN_INFOTIP_READY, pBuff, uSize);
        }
        else
        {
            // If we do not have a queue status value then we assume we
            // must have a queue status string.  Queue status strings
            // are cooked up string from printui to indicate pending
            // connection status. i.e. opening|retrying|unable to connect|etc.
            pszReturn = pData->pStatus;
        }
    }
    return pszReturn;
}

/*++
    Compares the printers display name for column sorting
    support.

Arguments:

    pName1 - pointer to unalligned printer name.
    pName2 - pointer to unalligned printer name.

Return Value:

    -1 = pName1 less than pName2
     0 = pName1 equal to pName2
     1 = pName1 greather than pName2

--*/

INT CPrinterFolder::GetCompareDisplayName(LPCTSTR pName1, LPCTSTR pName2)
{
    LPCTSTR pszServer = NULL;
    LPCTSTR pszPrinter = NULL;
    LPTSTR  pszRet2 = NULL;
    TCHAR   szTemp[MAXNAMELENBUFFER]    = {0};

    //
    // We need to break up the full printer name in its components.
    // in order to construct the display name string.
    //
    Printer_SplitFullName(szTemp, ARRAYSIZE(szTemp), pName1, &pszServer, &pszPrinter);
    LPTSTR pszRet1 = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_DSPTEMPLATE_WITH_ON),
                                          &pszServer[2], pszPrinter);
    if (pszRet1)
    {
        Printer_SplitFullName(szTemp, ARRAYSIZE(szTemp), pName2, &pszServer, &pszPrinter);
        pszRet2 = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_DSPTEMPLATE_WITH_ON),
                                              &pszServer[2], pszPrinter);

        if (pszRet2)
        {
            pName1 = pszRet1;
            pName2 = pszRet2;
        }
    }

    int iResult = lstrcmpi(pName1, pName2);

    if (pszRet1)
        LocalFree(pszRet1);

    if (pszRet2)
        LocalFree(pszRet2);

    return iResult;
}

/*++

    Compares printer column  data using the
    column index as a guide indicating which data to compare.

Arguments:

    psf   - pointer to the containter shell folder.
    pidp1 - pointer to unalligned printer name.
    pidp1 - pointer to unalligned printer name.
    iCol  - column index shich to sort on.

Return Value:

    -1 = pName1 less than pName2
     0 = pName1 equal to pName2
     1 = pName1 greather than pName2

--*/

INT CPrinterFolder::CompareData(LPCIDPRINTER pidp1, LPCIDPRINTER pidp2, LPARAM iCol)
{
    LPCTSTR pName1              = NULL;
    LPCTSTR pName2              = NULL;
    INT     iResult             = 0;
    TCHAR   szTemp1[MAX_PATH]   = {0};
    TCHAR   szTemp2[MAX_PATH]   = {0};
    BOOL    bDoStringCompare    = TRUE;

    // since the pidp's are UNALIGNED we need to copy the strings out.
    TCHAR   szName1[MAX_PATH];
    _ItemName(pidp1, szName1, ARRAYSIZE(szName1));
    TCHAR   szName2[MAX_PATH];
    _ItemName(pidp2, szName2, ARRAYSIZE(szName2));

    // There is no reason to hit the cache for the printer name.
    if ((iCol & SHCIDS_COLUMNMASK) == PRINTERS_ICOL_NAME)
    {
        return GetCompareDisplayName(szName1, szName2);
    }

    PFOLDER_PRINTER_DATA pData1 = (PFOLDER_PRINTER_DATA)Printer_FolderGetPrinter(GetFolder(), szName1);
    PFOLDER_PRINTER_DATA pData2 = (PFOLDER_PRINTER_DATA)Printer_FolderGetPrinter(GetFolder(), szName2);

    if (pData1 && pData2)
    {
        switch (iCol & SHCIDS_COLUMNMASK)
        {
        case PRINTERS_ICOL_QUEUESIZE:
            iResult = pData1->cJobs - pData2->cJobs;
            bDoStringCompare = FALSE;
            break;

        case PRINTERS_ICOL_STATUS:
            pName1 = GetStatusString(pData1, szTemp1, ARRAYSIZE(szTemp1));
            pName2 = GetStatusString(pData2, szTemp2, ARRAYSIZE(szTemp1));
            break;

        case PRINTERS_ICOL_COMMENT:
            pName1 = pData1->pComment;
            pName2 = pData2->pComment;
            break;

        case PRINTERS_ICOL_LOCATION:
            pName1 = pData1->pLocation;
            pName2 = pData2->pLocation;
            break;

        case PRINTERS_ICOL_MODEL:
            pName1 = pData1->pDriverName;
            pName2 = pData2->pDriverName;
            break;

        default:
            bDoStringCompare = FALSE;
            break;
        }

        if (bDoStringCompare)
        {
            if (!pName1)
                pName1 = TEXT("");

            if (!pName2)
                pName2 = TEXT("");

            TraceMsg(TF_GENERAL, "CPrinters_SF_CompareData %ws %ws", pName1, pName2);

            iResult = lstrcmpi(pName1, pName2);
        }
    }

    if (pData1)
        LocalFree((HLOCAL)pData1);

    if (pData2)
        LocalFree((HLOCAL)pData2);
    return iResult;
}

//
// Stolen almost verbatim from netviewx.c's CNetRoot_MakeStripToLikeKinds
//
// Takes a possibly-heterogenous pidl array, and strips out the pidls that
// don't match the requested type.  (If fPrinterObjects is TRUE, we're asking
// for printers pidls, otherwise we're asking for the filesystem/link
// objects.)  The return value is TRUE if we had to allocate a new array
// in which to return the reduced set of pidls (in which case the caller
// should free the array with LocalFree()), FALSE if we are returning the
// original array of pidls (in which case no cleanup is required).
//
BOOL CPrinterFolder::ReduceToLikeKinds(UINT *pcidl, LPCITEMIDLIST **papidl, BOOL fPrintObjects)
{
    LPITEMIDLIST *apidl = (LPITEMIDLIST*)*papidl;
    int cidl = *pcidl;

    int iidl;
    LPITEMIDLIST *apidlHomo;
    int cpidlHomo;

    for (iidl = 0; iidl < cidl; iidl++)
    {
        if ((HOOD_COL_PRINTER == _IDListType(apidl[iidl])) != fPrintObjects)
        {
            apidlHomo = (LPITEMIDLIST *)LocalAlloc(LPTR, sizeof(LPITEMIDLIST) * cidl);
            if (!apidlHomo)
                return FALSE;

            cpidlHomo = 0;
            for (iidl = 0; iidl < cidl; iidl++)
            {
                if ((HOOD_COL_PRINTER == _IDListType(apidl[iidl])) == fPrintObjects)
                    apidlHomo[cpidlHomo++] = apidl[iidl];
            }

            // Setup to use the stripped version of the pidl array...
            *pcidl = cpidlHomo;
            *papidl = (LPCITEMIDLIST*)apidlHomo;
            return TRUE;
        }
    }

    return FALSE;
}

DWORD CPrinterFolder::SpoolerVersion()
{
    CCSLock::Locker lock(_csLock);
    if (lock)
    {
        if (_dwSpoolerVersion == -1)
        {
            _dwSpoolerVersion = 0;

            HANDLE hServer = Printer_OpenPrinter(_pszServer);
            if (hServer)
            {
                DWORD dwNeeded = 0, dwType = REG_DWORD;
                GetPrinterData(hServer, TEXT("MajorVersion"), &dwType, (PBYTE)&_dwSpoolerVersion,
                                    sizeof(_dwSpoolerVersion), &dwNeeded);
                Printer_ClosePrinter(hServer);
            }
        }
    }
    else
    {
        // unable to enter the CS -- this can happen only in extremely low memory conditions!
        SetLastError(ERROR_OUTOFMEMORY);
    }
    return _dwSpoolerVersion;
}

void CPrinterFolder::CheckToRegisterNotify()
{
    CCSLock::Locker lock(_csLock);
    if (lock)
    {
        if (NULL == _hFolder && FAILED(RegisterPrintNotify(_pszServer, this, &_hFolder, &_bAdminAccess)))
        {
            // paranoia...
            ASSERT(NULL == _hFolder);
            _hFolder = NULL;
        }
    }
    else
    {
        // unable to enter the CS -- this can happen only in extremely low memory conditions!
        SetLastError(ERROR_OUTOFMEMORY);
    }
}

void CPrinterFolder::CheckToRefresh()
{
    if (_bReqRefresh)
    {
        // kick off a full refresh...
        _bReqRefresh = FALSE;
        bFolderRefresh(_hFolder, &_bAdminAccess);
    }
}

void CPrinterFolder::RequestRefresh()
{
    _bReqRefresh = TRUE;
}

HRESULT CPrinterFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CPrinterFolder, IShellFolder),
        QITABENTMULTI(CPrinterFolder, IShellFolder2, IShellFolder),
        QITABENT(CPrinterFolder, IPersist),
        QITABENTMULTI(CPrinterFolder, IPersistFolder, IPersist),
        QITABENTMULTI(CPrinterFolder, IPersistFolder2, IPersistFolder),
        QITABENT(CPrinterFolder, IShellIconOverlay),
        QITABENT(CPrinterFolder, IRemoteComputer),
        QITABENT(CPrinterFolder, IPrinterFolder),
        QITABENT(CPrinterFolder, IFolderNotify),
        QITABENT(CPrinterFolder, IContextMenuCB),
        { 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppv);
    if (FAILED(hr))
    {
        // Internal only
        if (IsEqualGUID(riid, CLSID_Printers))
        {
            *ppv = (CPrinterFolder*)this;
            AddRef();
            hr = S_OK;
        }
    }

    return hr;
}

ULONG CPrinterFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPrinterFolder::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IShellFolder2

STDMETHODIMP CPrinterFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    *ppv = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CPrinterFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

STDMETHODIMP CPrinterFolder::CompareIDs(LPARAM iCol, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    UNALIGNED IDPRINTER *pidp1 = (UNALIGNED IDPRINTER*)pidl1;
    UNALIGNED IDPRINTER *pidp2 = (UNALIGNED IDPRINTER*)pidl2;

    PIDLTYPE ColateType1 = _IDListType(pidl1);
    PIDLTYPE ColateType2 = _IDListType(pidl2);

    if (ColateType1 == ColateType2)
    {
        // pidls are of same type.

        if (ColateType1 == HOOD_COL_FILE)
        {
            // pidls are both of type file, so pass on to the IShellFolder
            // interface for the hoods custom directory.

            IShellFolder2* psf = CPrintRoot_GetPSF();
            if (psf)
                return psf->CompareIDs(iCol, pidl1, pidl2);
        }
        else
        {
            // pidls are same and not files, so must be printers
            if (pidp1->dwType != pidp2->dwType)
            {
                return (pidp1->dwType < pidp2->dwType) ?
                       ResultFromShort(-1) :
                       ResultFromShort(1);
            }
            int i = ualstrcmpi(pidp1->cName, pidp2->cName);
            if (i != 0)
            {
                // add printer wizard is "less" than everything else
                // This implies that when the list is sorted
                // either accending or decending the add printer
                // wizard object will always appear at the extream
                // ends of the list, i.e. the top or bottom.
                //
                if (_IsAddPrinter(pidp1))
                    i = -1;
                else if (_IsAddPrinter(pidp2))
                    i = 1;
                else
                {
                    // Both of the names are not the add printer wizard
                    // object then compare further i.e. using the cached
                    // column data.

                    // 99/03/24 #308785 vtan: Make the compare data call.
                    // If that fails use the name compare result which is
                    // known to be non-zero.

                    int iDataCompareResult = CompareData(pidp1, pidp2, iCol);
                    if (iDataCompareResult != 0)
                        i = iDataCompareResult;
                }
            }
            return ResultFromShort(i);
        }
    }
    else
    {
        // pidls are not of same type, so have already been correctly
        // collated (consequently, sorting is first by type and
        // then by subfield).

        return ResultFromShort((((INT)(ColateType2 - ColateType1)) > 0) ? -1 : 1);
    }
    return E_FAIL;
}

STDMETHODIMP CPrinterFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr;

    if (IsEqualIID(riid, IID_IShellView))
    {
        SFV_CREATE sSFV;

        sSFV.cbSize   = sizeof(sSFV);
        sSFV.pshf     = this;
        sSFV.psvOuter = NULL;
        sSFV.psfvcb   = new CPrinterFolderViewCB(this, _pidl);

        hr = SHCreateShellFolderView(&sSFV, (IShellView**)ppv);

        if (sSFV.psfvcb)
            sSFV.psfvcb->Release();
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        hr = CPrinterFolderDropTarget_CreateInstance(hwnd, (IDropTarget **)ppv);
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        hr = CDefFolderMenu_Create2Ex(NULL, hwnd,
                0, NULL, this, this,
                0, NULL, (IContextMenu **)ppv);
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    return hr;
}

STDMETHODIMP CPrinterFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList** ppenum)
{
    // By default we always do standard (printer) enumeration
    DWORD dwRemote = 0;

    // Only add links (from the PrintHood directory) to the enumeration
    // if this is the local print folder

    IEnumIDList* peunk = NULL;

    if (_pszServer == NULL)
    {
        // Always try to enum links.
        IShellFolder2 *psfPrintHood = CPrintRoot_GetPSF();

        if (psfPrintHood)
            psfPrintHood->EnumObjects(NULL, grfFlags, &peunk);

        if (peunk)
        {
            // If this went OK, we will also enumerate links
            dwRemote |= RMF_SHOWLINKS;
        }
    }

    return CPrintersEnum::CreateInstance(grfFlags, dwRemote, peunk, this, ppenum);
}

STDMETHODIMP CPrinterFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* prgf)
{
    HRESULT hr = S_OK;
    ULONG rgfOut = SFGAO_CANLINK | SFGAO_CANDELETE | SFGAO_CANRENAME | SFGAO_HASPROPSHEET | SFGAO_DROPTARGET;
    ULONG rgfIn = *prgf;

    if (cidl && (HOOD_COL_FILE == _IDListType(apidl[0])))
    {
        IShellFolder2 *psf = CPrintRoot_GetPSF();
        if (psf)
            return psf->GetAttributesOf(cidl, apidl, prgf);
        return E_INVALIDARG;
    }

    // if new printer wizard is selected, we support CANLINK *only*
    for (UINT i = 0 ; i < cidl ; i++)
    {
        LPIDPRINTER pidp = (LPIDPRINTER)apidl[i];

        TCHAR szPrinter[MAXNAMELENBUFFER];
        _ItemName(pidp, szPrinter, ARRAYSIZE(szPrinter));

        if (_IsAddPrinter(pidp))
        {
            // add printer wiz, we support CANLINK *only*
            rgfOut &= SFGAO_CANLINK;

            // added SFGAO_CANDELETE if multiple printers are selected
            // otherwise it's hard to tell why the del key doesn't work.
            if (cidl > 1)
            {
                rgfOut |= SFGAO_CANDELETE;
            }
        }
        else if (Printer_CheckNetworkPrinterByName(szPrinter, NULL))
        {
            // Don't allow renaming of printer connections on WINNT.
            // This is disallowed becase on WINNT, the printer connection
            // name _must_ be the in the format \\server\printer.  On
            // win9x, the user can rename printer connections.
            rgfOut &= ~SFGAO_CANRENAME;
        }
    }

    *prgf &= rgfOut;

    if (cidl == 1 && (rgfIn & (SFGAO_SHARE | SFGAO_GHOSTED)))
    {
        LPIDPRINTER pidp = (LPIDPRINTER)apidl[0];
        void *pData = NULL;
        DWORD dwAttributes = 0;
        TCHAR szFullPrinter[MAXNAMELENBUFFER];
        LPCTSTR pszPrinter = _BuildPrinterName(szFullPrinter, ARRAYSIZE(szFullPrinter), pidp, NULL);

        // If we have notification code, use the hFolder to get
        // printer data instead of querying the printer directly.
        if (GetFolder())
        {
            pData = Printer_FolderGetPrinter(GetFolder(), pszPrinter);
            if (pData)
                dwAttributes = ((PFOLDER_PRINTER_DATA)pData)->Attributes;
        }
        else
        {
            pData = Printer_GetPrinterInfoStr(szFullPrinter, 5);
            if (pData)
                dwAttributes = ((PPRINTER_INFO_5)pData)->Attributes;
        }

        if (pData)
        {
            if (dwAttributes & PRINTER_ATTRIBUTE_SHARED
                // NT appears to return all network printers with their
                // share bit on. I think this is intentional.
                //
                && (dwAttributes & PRINTER_ATTRIBUTE_NETWORK) == 0
               )
            {
                *prgf |= SFGAO_SHARE;
            }
            if (dwAttributes & PRINTER_ATTRIBUTE_WORK_OFFLINE)
                *prgf |= SFGAO_GHOSTED;
            else
                *prgf &= ~SFGAO_GHOSTED;

            LocalFree((HLOCAL)pData);
        }
        else
        {
            // This fct used to always return E_OUTOFMEMORY if pData was NULL.  pData can be
            // NULL for other reasons than out of memory.  So this failure is not really valid.
            // However the Shell handle this failure (which is bad in the first place).
            // If we fail, we just set the attributes to 0 and go on as if nothing happenned.
            // Star Office 5.0, does not handle the E_OUTOFMEMORY properly, they handle it as
            // a failure (which is exactly what we report to them) and they stop their
            // processing to show the Add Printer icon.  But they're bad on one point, they
            // check for S_OK directly so I cannot return S_FALSE. (stephstm, 07/30/99)

            if (SHGetAppCompatFlags(ACF_STAROFFICE5PRINTER) &&
                (ERROR_INVALID_PRINTER_NAME == GetLastError()))
            {
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

STDMETHODIMP CPrinterFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *psr)
{
    LPIDPRINTER pidc = (LPIDPRINTER)pidl;
    BOOL bPrinterOnServerFormat = FALSE;
    LPCTSTR pszServer;
    TCHAR szBuffer[MAXNAMELENBUFFER];
    TCHAR szTemp[MAXNAMELENBUFFER];
    LPCTSTR pszTemp;
    LPCTSTR pszPrinter = szBuffer;

    if (pidl && HOOD_COL_FILE == _IDListType(pidl))
    {
        IShellFolder2 *psf = CPrintRoot_GetPSF();
        if (psf)
            return psf->GetDisplayNameOf(pidl, uFlags, psr);
        return E_INVALIDARG;
    }

    if (!_IsAddPrinter(pidc))
    {
        pszPrinter = _ItemName(pidc, szBuffer, ARRAYSIZE(szBuffer));

        if (uFlags & SHGDN_INFOLDER)
        {
            // relative name (to the folder)

            if (!(SHGDN_FORPARSING & uFlags))
            {
                // If it's a connection then format as "printer on server."

                Printer_SplitFullName(szTemp, ARRAYSIZE(szTemp), pszPrinter, &pszServer, &pszTemp);

                if (pszServer[0])
                {
                    bPrinterOnServerFormat = TRUE;
                    pszPrinter = pszTemp;
                }
            }
        }
        else                        // SHGDN_NORMAL
        {
            if (!(SHGDN_FORPARSING & uFlags))
            {
                // If it's a RPF then extract the server name from psf.
                // Note in the case of masq connections, we still do this
                // (for gateway services: sharing a masq printer).

                if (_pszServer)
                {
                    pszServer = _pszServer;
                    bPrinterOnServerFormat = TRUE;
                }
                else
                {
                    // If it's a connection then format as "printer on server."
                    Printer_SplitFullName(szTemp, ARRAYSIZE(szTemp), pszPrinter, &pszServer, &pszTemp);

                    if (pszServer[0])
                    {
                        bPrinterOnServerFormat = TRUE;
                        pszPrinter = pszTemp;
                    }
                }
            }
            else                      // SHGDN_NORMAL | SHGDN_FORPARSING
            {
                // Fully qualify the printer name if it's not
                // the add printer wizard.
                if (!_IsAddPrinter(pidc))
                {
                    _BuildPrinterName(szTemp, ARRAYSIZE(szTemp), pidc, NULL);
                    pszPrinter = szTemp;
                }
            }
        }
    }
    else
    {
        LoadString(HINST_THISDLL, IDS_NEWPRN, szBuffer, ARRAYSIZE(szBuffer));

        // Use "Add Printer Wizard on \\server" description only if not
        // remote and if not in folder view (e.g., on the desktop).
        if (_pszServer && (uFlags == SHGDN_NORMAL))
        {
            bPrinterOnServerFormat = TRUE;
            pszServer = _pszServer;
            pszPrinter = szBuffer;
        }
        else if (uFlags & SHGDN_FORPARSING)
        {
            // Return the raw add printer wizard object.
            pszPrinter = (LPTSTR)c_szNewObject;
        }
    }

    HRESULT hr;
    if (bPrinterOnServerFormat)
    {
        // When bRemote is set, we want to translate the name to
        // "printer on server."  Note: we should not have a rename problem
        // since renaming connections is disallowed.
        //
        // pszServer and pszPrinter must be initialize if bRemote is TRUE.
        // Also skip the leading backslashes for the server name.

        ASSERT(pszServer[0] == TEXT('\\') && pszServer[1] == TEXT('\\'));
        LPTSTR pszRet = ShellConstructMessageString(HINST_THISDLL,
                     MAKEINTRESOURCE(IDS_DSPTEMPLATE_WITH_ON),
                     &pszServer[2], pszPrinter);
        if (pszRet)
        {
            hr = StringToStrRet(pszRet, psr);
            LocalFree(pszRet);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        hr = StringToStrRet(pszPrinter, psr);
    }
    return hr;
}

STDMETHODIMP CPrinterFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST* apidl, REFIID riid, UINT *prgf, void **ppv)
{
    HRESULT hr = E_INVALIDARG;

    UINT cidlPrinters = cidl;
    LPCITEMIDLIST *apidlPrinters = apidl;
    BOOL bStrippedLinks = FALSE;

    if (cidl)
    {
        // strip out the link PIDLs and leave only the printer ones
        bStrippedLinks = ReduceToLikeKinds(&cidlPrinters, &apidlPrinters, TRUE);
    }

    if (cidl && 0 == cidlPrinters)
    {
        // if we don't have any printer PIDLs then just defer the operation
        // to the printhood folder.
        IShellFolder2* psfPrintRoot = CPrintRoot_GetPSF();
        hr = psfPrintRoot ? psfPrintRoot->GetUIObjectOf(hwnd, cidl, apidl, riid, prgf, ppv) : E_INVALIDARG;
    }
    else
    {
        //
        // we have some printer PIDLs selected, but it could be a mixed selection
        // of printer PIDLs and file system link objects. we will handle the data
        // object explicitly not to loose information about the selection type.
        // the IDL array format doesn't support different type of PIDLs so we have
        // to create two data objects and combine them into one data object which
        // supports IServiceProvider and then the caller can query our compound data
        // object for SID_SAuxDataObject service to get IDataObject interface of our
        // auxiliary data object (in case it needs access to the link PIDLs).
        //
        if (cidl && IsEqualIID(riid, IID_IDataObject))
        {
            // strip out the printer PIDLs and leave only the link ones
            // we are going to use those PIDLs to create our auxiliary data object
            UINT cidlLinks = cidl;
            LPCITEMIDLIST *apidlLinks = apidl;
            BOOL bStrippedPrinters = FALSE;

            if (cidl)
            {
                // strip out the printer PIDLs and leave only the link ones
                bStrippedPrinters = ReduceToLikeKinds(&cidlLinks, &apidlLinks, FALSE);
            }

            hr = S_OK;
            IDataObject *pdoLinks = NULL;
            if (cidlLinks && apidlLinks)
            {
                // we have some link PIDLs. let's ask the printhood folder to create
                // data object for us to embedd into our data object.
                IShellFolder2* psfPrintRoot = CPrintRoot_GetPSF();
                hr = psfPrintRoot ?
                     psfPrintRoot->GetUIObjectOf(hwnd, cidlLinks, apidlLinks, riid, prgf, (void **)&pdoLinks) :
                     E_INVALIDARG;

                // just out of paranoia...
                if (FAILED(hr))
                    pdoLinks = NULL;
            }

            if (SUCCEEDED(hr))
            {
                // create our compund printers data object and pass in the private
                // auxiliary data object which will contain the link PIDLs
                CPrintersData *ppd = new CPrintersData(pdoLinks, _pidl, cidlPrinters, apidlPrinters);
                if (ppd)
                {
                    hr = ppd->QueryInterface(riid, ppv);
                    ppd->Release();
                }
                else
                    hr = E_OUTOFMEMORY;
            }

            // release allocated objects/memory
            if (pdoLinks)
                pdoLinks->Release();

            if (bStrippedPrinters)
                LocalFree((HLOCAL)apidlLinks);
        }
        else
        {
            // operate only on the printer PIDLs selection (the current behaviour)
            // and ignore the links selection. this may be wrong in some cases, but
            // this code has been busted either way (so far), so we'll fix those on
            // per case basis. the best solution will be to cut of the printhood
            // functionality, but alas...
            LPCIDPRINTER pidp = cidlPrinters > 0 ? (LPIDPRINTER)apidlPrinters[0] : NULL;

            if (pidp && (IsEqualIID(riid, IID_IExtractIconA) || IsEqualIID(riid, IID_IExtractIconW)))
            {
                int iIcon;
                int iShortcutIcon;
                TCHAR szBuf[MAX_PATH+20];
                TCHAR szFullPrinter[MAXNAMELENBUFFER];
                LPTSTR pszModule = NULL;

                _BuildPrinterName(szFullPrinter, ARRAYSIZE(szFullPrinter), pidp, NULL);

                if (_IsAddPrinter(pidp))
                    iIcon = iShortcutIcon = IDI_NEWPRN;
                else
                {
                    pszModule = _FindIcon(szFullPrinter, szBuf, ARRAYSIZE(szBuf), &iIcon, &iShortcutIcon);
                }

                hr = SHCreateDefExtIconKey(NULL, pszModule, EIRESID(iIcon), -1, -1, EIRESID(iShortcutIcon), GIL_PERINSTANCE, riid, ppv);
            }
            else if (pidp && IsEqualIID(riid, IID_IContextMenu))
            {
                HKEY hkeyBaseProgID = NULL;
                int nCount = 0;

                if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT, c_szPrinters, &hkeyBaseProgID))
                    nCount++;

                hr = CDefFolderMenu_Create2(_pidl, hwnd,
                    cidl, apidl, SAFECAST(this, IShellFolder*), _DFMCallBack,
                    nCount, &hkeyBaseProgID, (IContextMenu **)ppv);

                if (hkeyBaseProgID)
                    RegCloseKey(hkeyBaseProgID);
            }
            else if (pidp && IsEqualIID(riid, IID_IDropTarget))
            {
                if (_IsAddPrinter(pidp))
                {
                    // "NewPrinter" accepts network printer shares
                    hr = CreateViewObject(hwnd, riid, ppv);   // folder drop target
                }
                else
                {
                    LPITEMIDLIST pidl;
                    hr = SHILCombine(_pidl, apidl[0], &pidl);
                    if (SUCCEEDED(hr))
                    {
                        hr = CPrinterDropTarget_CreateInstance(hwnd, pidl, (IDropTarget**)ppv);
                        ILFree(pidl);
                    }
                }
            }
            else if (pidp && IsEqualIID(riid, IID_IQueryInfo))
            {
                // get the infotip from IQA
                IQueryAssociations *pqa;
                hr = _AssocCreate(IID_PPV_ARG(IQueryAssociations, &pqa));

                if (SUCCEEDED(hr))
                {
                    WCHAR szText[INFOTIPSIZE];
                    DWORD cch = ARRAYSIZE(szText);
                    hr = pqa->GetString(0, ASSOCSTR_INFOTIP, NULL, szText, &cch);
                    if (SUCCEEDED(hr))
                    {
                        hr = CreateInfoTipFromItem(SAFECAST(this, IShellFolder2*),
                            (LPCITEMIDLIST)pidp, szText, riid, ppv);
                    }
                    pqa->Release();
                }
            }
            else if (pidp && IsEqualIID(riid, IID_IQueryAssociations))
            {
                // return our IQA
                hr = _AssocCreate(riid, ppv);
            }
        }
    }

    // release the memory allocated from ReduceToLikeKinds
    if (bStrippedLinks)
        LocalFree((HLOCAL)apidlPrinters);

    return hr;
}

STDMETHODIMP CPrinterFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszName, ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttributes)
{
    HRESULT hr = E_INVALIDARG;

    // check if this is not a PrintHood object first
    IShellFolder2 *psfPrintHood = CPrintRoot_GetPSF();
    if (psfPrintHood)
    {
        hr = psfPrintHood->ParseDisplayName(hwnd, pbc, pszName, pchEaten, ppidl, pdwAttributes);
    }

    if (FAILED(hr))
    {
        // not a printhood object - try the folder cache
        hr = E_INVALIDARG;

        if (ppidl)
            *ppidl = NULL;

        if (pszName && ppidl)
        {
            hr = S_OK;
            DWORD dwType = 0;
            BOOL bValidated = FALSE;
            void *pData = NULL;

            // check the bind info first
            if (pbc)
            {
                IUnknown *pUnk;
                hr = pbc->GetObjectParam(PRINTER_BIND_INFO, &pUnk);
                if (SUCCEEDED(hr))
                {
                    IPrintersBindInfo *pInfo;
                    hr = pUnk->QueryInterface(IID_PPV_ARG(IPrintersBindInfo, &pInfo));
                    if (SUCCEEDED(hr))
                    {
                        // update dwType & bValidated from the bind info
                        pInfo->GetPIDLType(&dwType);
                        bValidated = (S_OK == pInfo->IsValidated());
                        pInfo->Release();
                    }
                    pUnk->Release();
                }
            }

            if (SUCCEEDED(hr))
            {
                // the "add printer" icon doesn't need validation
                if (StrStrIW(pszName, c_szNewObject))
                {
                    bValidated = TRUE;
                }

                // hit the folder cache to see if this printer belongs to this folder.
                if (bValidated || (pData = (GetFolder() ? Printer_FolderGetPrinter(GetFolder(), pszName) : NULL)))
                {
                    // well, looks like this printer belongs to our folder -
                    // create a printer PIDL (relative to this folder).
                    hr = _Parse(pszName, ppidl, dwType);
                }
                else
                {
                    // the printer doesn't belong to this folder - cook up correct HRESULT.
                    // usually the last error here is ERROR_INVALID_PRINTER_NAME
                    DWORD dwLastErr = GetLastError();
                    hr = ERROR_SUCCESS == dwLastErr ? HRESULT_FROM_WIN32(ERROR_INVALID_PRINTER_NAME)
                                                    : HRESULT_FROM_WIN32(dwLastErr);
                }
            }

            if (pData)
                LocalFree((HLOCAL)pData);
        }

        // check to return pchEaten
        if (SUCCEEDED(hr) && pchEaten)
        {
            *pchEaten = lstrlen(pszName);
        }

        // check to return pdwAttributes
        if (SUCCEEDED(hr) && pdwAttributes)
        {
            hr = GetAttributesOf(1, (LPCITEMIDLIST *)ppidl, pdwAttributes);
        }
    }

    return hr;
}

STDMETHODIMP CPrinterFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszNewName, DWORD dwRes, LPITEMIDLIST* ppidlOut)
{
    HRESULT hr = S_OK;
    HANDLE hPrinter = NULL;
    LPPRINTER_INFO_2 pPrinter = NULL;

    if (HOOD_COL_FILE == _IDListType(pidl))
    {
        IShellFolder2 *psf = CPrintRoot_GetPSF();
        hr = psf ?  psf->SetNameOf(hwnd, pidl, pszNewName, dwRes, ppidlOut) : E_INVALIDARG;
        goto Exit;
    }
    else
    {
        LPIDPRINTER pidc = (LPIDPRINTER)pidl;

        ASSERT(!_IsAddPrinter(pidc));  // does not have _CANRENAME bit

        TCHAR szNewName[MAX_PATH];
        SHUnicodeToTChar(pszNewName, szNewName, ARRAYSIZE(szNewName));
        PathRemoveBlanks(szNewName);

        TCHAR szOldName[MAXNAMELENBUFFER];
        _ItemName(pidc, szOldName, ARRAYSIZE(szOldName));

        if (0 == lstrcmp(szOldName, szNewName))
            goto Exit;

        TCHAR szFullPrinter[MAXNAMELENBUFFER];
        _BuildPrinterName(szFullPrinter, ARRAYSIZE(szFullPrinter), NULL, szOldName);
        LPCTSTR pszFullOldName = szFullPrinter;

        hPrinter = Printer_OpenPrinterAdmin(pszFullOldName);
        if (NULL == hPrinter)
            goto Error;

        pPrinter = (LPPRINTER_INFO_2)Printer_GetPrinterInfo(hPrinter, 2);
        if (NULL == pPrinter)
            goto Error;

        int nTmp = _IllegalPrinterName(szNewName);
        if (0 != nTmp)
        {
            // NTRAID95214-2000-03-17:
            // We need to impl ::SetSite() and pass it to UI APIs
            // to go modal if we display UI.
            if (hwnd)
            {
                ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(nTmp),
                    MAKEINTRESOURCE(IDS_PRINTERS),
                    MB_OK|MB_ICONEXCLAMATION);
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                goto Exit;
            }
        }
        else if (IDYES != CallPrinterCopyHooks(hwnd, PO_RENAME, 0, szNewName, 0, pszFullOldName, 0))
        {
            // user canceled a shared printer name change, bail.
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            goto Exit;
        }
        else
        {
            pPrinter->pPrinterName = szNewName;
            if (FALSE == SetPrinter(hPrinter, 2, (LPBYTE)pPrinter, 0))
                goto Error;

            // return the new pidl if requested
            hr = ppidlOut ? _Parse(szNewName, ppidlOut) : S_OK;

            if (SUCCEEDED(hr))
                goto Exit;
        }
    }

Error:
    if (SUCCEEDED(hr))
    {
        // get the correct error from win32
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    // show an appropriate error message based on the HRESULT
    ShowErrorMessageHR(NULL, NULL, hwnd, NULL, NULL, MB_OK|MB_ICONEXCLAMATION, hr);

Exit:
    if( pPrinter )
    {
        LocalFree((HLOCAL)pPrinter);
    }

    if( hPrinter )
    {
        Printer_ClosePrinter(hPrinter);
    }
    return hr;
}

STDMETHODIMP CPrinterFolder::EnumSearches(IEnumExtraSearch **ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CPrinterFolder::GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPrinterFolder::GetDefaultColumnState(UINT iColumn, DWORD* pdwState)
{
    HRESULT hr;

    if (iColumn < ARRAYSIZE(c_printers_cols))
    {
        *pdwState = c_printers_cols[iColumn].csFlags;
        hr = S_OK;
    }
    else
    {
        *pdwState = 0;
        hr = E_NOTIMPL;
    }
    return hr;
}

STDMETHODIMP CPrinterFolder::GetDefaultSearchGUID(LPGUID pGuid)
{
    *pGuid = SRCID_SFindPrinter;
    return S_OK;
}

STDMETHODIMP CPrinterFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv)
{
    BOOL fFound;
    HRESULT hr = AssocGetDetailsOfSCID(this, pidl, pscid, pv, &fFound);
    if (FAILED(hr) && !fFound)
    {
        int iCol = FindSCID(c_printers_cols, ARRAYSIZE(c_printers_cols), pscid);
        if (iCol >= 0)
        {
            SHELLDETAILS sd;
            hr = GetDetailsOf(pidl, iCol, &sd);
            if (SUCCEEDED(hr))
            {
                if (PRINTERS_ICOL_LOCATION == iCol)
                {
                    // widen the scope of the location by 1, so it does make more sense
                    WCHAR szTemp[MAX_PATH];
                    hr = StrRetToBufW(&sd.str, pidl, szTemp, ARRAYSIZE(szTemp));

                    if (SUCCEEDED(hr))
                    {
                        WCHAR *p = szTemp + lstrlen(szTemp);

                        // cut the last slash if any
                        if (p > szTemp && L'/' == *p)
                        {
                            p--;
                        }

                        // search for a slash from the end
                        while(p > szTemp && L'/' != *p)
                        {
                            p--;
                        }

                        // if found, cut the text here, so the scope gets wider
                        if (p > szTemp)
                        {
                            *p = 0;
                        }

                        hr = InitVariantFromStr(pv, szTemp);
                    }
                }
                else
                {
                    hr = InitVariantFromStrRet(&sd.str, pidl, pv);
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP CPrinterFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *psd)
{
    LPIDPRINTER pidp = (LPIDPRINTER)pidl;
    HRESULT hr = S_OK;
    TCHAR szTemp[MAX_PATH];
    TCHAR szPrinter[MAXNAMELENBUFFER];

    if (pidl && (HOOD_COL_FILE == _IDListType(pidl)))
    {
        IShellFolder2 *psf = CPrintRoot_GetPSF();
        if (psf)
        {
            if (iColumn >= 1)
                return E_NOTIMPL;

            return psf->GetDisplayNameOf(pidl, SHGDN_INFOLDER, &(psd->str));
        }
        return E_INVALIDARG;
    }

    psd->str.uType = STRRET_CSTR;
    psd->str.cStr[0] = 0;

    if (!pidp)
    {
        return GetDetailsOfInfo(c_printers_cols, ARRAYSIZE(c_printers_cols), iColumn, psd);
    }

    _ItemName(pidp, szPrinter, ARRAYSIZE(szPrinter));

    if (iColumn == PRINTERS_ICOL_NAME)
    {
#ifdef UNICODE
        LPCTSTR pszPrinterName = szPrinter;
        TCHAR szPrinterName[MAXNAMELENBUFFER];

        //
        // If we have a valid server name and the printer is not
        // the add printer wizard object then return a fully qualified
        // printer name in the remote printers folder.
        //
        if (GetServer() && !_IsAddPrinter(pidp))
        {
            //
            // Build the name which consists of the
            // server name plus slash plus the printer name.
            //
            StringCchCopy(szPrinterName, ARRAYSIZE(szPrinterName), GetServer());
            StringCchCat(szPrinterName, ARRAYSIZE(szPrinterName), TEXT("\\"));
            StringCchCat(szPrinterName, ARRAYSIZE(szPrinterName), pszPrinterName);
            pszPrinterName = szPrinterName;
        }
        hr = StringToStrRet(pszPrinterName, &psd->str);
#else
        hr = StringToStrRet(szPrinter, &psd->str);
#endif
    }
    else if (!_IsAddPrinter(pidp))
    {
        PFOLDER_PRINTER_DATA pData = (PFOLDER_PRINTER_DATA)Printer_FolderGetPrinter(GetFolder(), szPrinter);
        if (pData)
        {
            switch (iColumn)
            {
            case PRINTERS_ICOL_QUEUESIZE:
                StringCchPrintf(szTemp, ARRAYSIZE(szTemp), TEXT("%ld"), pData->cJobs);
                hr = StringToStrRet(szTemp, &psd->str);
                break;

            case PRINTERS_ICOL_STATUS:
            {
                DWORD dwStatus = pData->Status;

                // HACK: Use this free bit for "Work Offline"
                if (pData->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE)
                    dwStatus |= PRINTER_HACK_WORK_OFFLINE;

                szTemp[0] = 0;
                Printer_BitsToString(dwStatus, IDS_PRQSTATUS_SEPARATOR, szTemp, ARRAYSIZE(szTemp));

                hr = StringToStrRet(szTemp, &psd->str);

                // If the status word is null and we have a connection status string
                // display the status string.  This only works on NT because printui.dll
                // in will generate printer connection status i.e. <opening> | <access denied> etc.
                if (!dwStatus)
                {
                    LPCTSTR pStr = pData->pStatus;

                    // Discard the previous status StrRet if any.
                    StrRetToBuf(&psd->str, NULL, szTemp, ARRAYSIZE(szTemp));

                    //
                    // If we do not have a connection status string and the status
                    // is 0 then the printer is ready, display ready rather than an empty string.
                    //
                    if (!pStr)
                    {
                        LoadString(HINST_THISDLL, IDS_PRN_INFOTIP_READY, szTemp, ARRAYSIZE(szTemp));
                        pStr = szTemp;
                    }
                    hr = StringToStrRet(pStr, &psd->str);
                }
                break;
            }

            case PRINTERS_ICOL_COMMENT:
                if (pData->pComment)
                {
                    // pComment can have newlines in it because it comes from
                    // a multi-line edit box. BUT we display it here in a
                    // single line edit box. Strip out the newlines
                    // to avoid the ugly characters.
                    lstrcpyn(szTemp, pData->pComment, ARRAYSIZE(szTemp));
                    LPTSTR pStr = szTemp;
                    while (*pStr)
                    {
                        if (*pStr == TEXT('\r') || *pStr == TEXT('\n'))
                            *pStr = TEXT(' ');
                        pStr = CharNext(pStr);
                    }
                    hr = StringToStrRet(szTemp, &psd->str);
                }
                break;

            case PRINTERS_ICOL_LOCATION:
                if (pData->pLocation)
                    hr = StringToStrRet(pData->pLocation, &psd->str);
                break;

            case PRINTERS_ICOL_MODEL:
                if (pData->pDriverName)
                    hr = StringToStrRet(pData->pDriverName, &psd->str);
                break;
            }

            LocalFree((HLOCAL)pData);
        }
    }

    return hr;
}

STDMETHODIMP CPrinterFolder::MapColumnToSCID(UINT iCol, SHCOLUMNID* pscid)
{
    return MapColumnToSCIDImpl(c_printers_cols, ARRAYSIZE(c_printers_cols), iCol, pscid);
}

// IPersistFolder2

STDMETHODIMP CPrinterFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    return GetCurFolderImpl(_pidl, ppidl);
}

STDMETHODIMP CPrinterFolder::Initialize(LPCITEMIDLIST pidl)
{
    ASSERT(_pidl == NULL);

    // if _csLock is false then InitializeCriticalSection has thrown exception.
    // this can happen only in extremely low memory conditions!
    HRESULT hr = _csLock ? S_OK : E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
    {
        hr = SHILClone(pidl, &_pidl);
    }

    if (!_dpaSlowWVDataCache.Create(16))
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

STDMETHODIMP CPrinterFolder::GetClassID(LPCLSID lpClassID)
{
    *lpClassID = CLSID_Printers;
    return S_OK;
}

// IShellIconOverlay

STDMETHODIMP CPrinterFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int* pIndex)
{
    HRESULT hr = E_INVALIDARG;
    if (pidl)
    {
        ULONG uAttrib = SFGAO_SHARE;

        hr = E_FAIL;      // Until proven otherwise...
        GetAttributesOf(1, &pidl, &uAttrib);
        if (uAttrib & SFGAO_SHARE)
        {
            IShellIconOverlayManager* psiom;
            hr = GetIconOverlayManager(&psiom);
            if (SUCCEEDED(hr))
            {
                hr = psiom->GetReservedOverlayInfo(L"0", 0, pIndex, SIOM_OVERLAYINDEX, SIOM_RESERVED_SHARED);
                psiom->Release();
            }
        }
    }
    return hr;
}

STDMETHODIMP CPrinterFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    return E_NOTIMPL;
}

// this function is assuming the printer name is valid. it is for private use.
// if you need a printer PIDL call CPrinterFolder::ParseDisplayName instead.
// we don't use CPrinterFolder::ParseDisplayName because it's heavy to use.
// it's hitting the folder cache (and potentionally creating it!).
HRESULT CPrinterFolder::_GetFullIDList(LPCWSTR pszPrinter, LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_INVALIDARG;

    if (ppidl)
    {
        *ppidl = NULL;

        if (pszPrinter)
        {
            // if pszPrinter isn't NULL this means a printer PIDL is requested.
            LPITEMIDLIST pidl;
            hr = _Parse(pszPrinter, &pidl, 0, 0);

            if (SUCCEEDED(hr))
            {
                hr = SHILCombine(_pidl, pidl, ppidl);
                ILFree(pidl);
            }
        }
        else
        {
            // if pszPrinter is NULL this means the printers folder PIDL is requested.
            hr = SHILClone(_pidl, ppidl);
        }
    }

    return hr;
}

// IRemoteComputer

STDMETHODIMP CPrinterFolder::Initialize(const WCHAR *pszMachine, BOOL bEnumerating)
{
    // if _csLock is false then InitializeCriticalSection has thrown exception.
    // this can happen only in extremely low memory conditions!
    HRESULT hr = _csLock ? S_OK : E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
    {
        // for servers, we want to show the remote printer folder. only check during enumeration
        hr = (bEnumerating && !Printer_CheckShowFolder(pszMachine)) ? E_FAIL : S_OK;
        if (SUCCEEDED(hr))
        {
            TCHAR szBuf[MAXCOMPUTERNAME];
            SHUnicodeToTChar(pszMachine, szBuf, ARRAYSIZE(szBuf));
            _pszServer = StrDup(szBuf);
            hr = _pszServer ? S_OK : E_OUTOFMEMORY;
        }
    }

    return hr;
}

// IPrinterFolder

BOOL CPrinterFolder::IsPrinter(LPCITEMIDLIST pidl)
{
    return _IDListType(pidl) == HOOD_COL_PRINTER;
}

// IFolderNotify

STDMETHODIMP_(BOOL) CPrinterFolder::ProcessNotify(FOLDER_NOTIFY_TYPE NotifyType, LPCWSTR pszName, LPCWSTR pszNewName)
{
    static const DWORD aNotifyTypes[] = {
        kFolderUpdate,        SHCNE_UPDATEITEM,
        kFolderCreate,        SHCNE_CREATE,
        kFolderDelete,        SHCNE_DELETE,
        kFolderRename,        SHCNE_RENAMEITEM,
        kFolderAttributes,    SHCNE_ATTRIBUTES };

    BOOL bReturn = FALSE;
    UINT uFlags = SHCNF_IDLIST | SHCNF_FLUSH | SHCNF_FLUSHNOWAIT;

    if (kFolderUpdateAll == NotifyType)
    {
        //
        // Clear the this->bRefreshed flag, which will force invalidating the folder cache
        // during the next print folder enumeration, and then request the defview to update
        // the entire printers folder content (i.e. to re-enumerate the folder).
        //
        RequestRefresh();
        NotifyType = kFolderUpdate;
        pszName = NULL;
    }

    for (int i = 0; i < ARRAYSIZE(aNotifyTypes); i += 2)
    {
        if (aNotifyTypes[i] == (DWORD)NotifyType)
        {
            LPITEMIDLIST pidl = NULL;
            LPITEMIDLIST pidlNew = NULL;
            HRESULT hr = _GetFullIDList(pszName, &pidl);
            if (SUCCEEDED(hr) && pszNewName)
                hr = _GetFullIDList(pszNewName, &pidlNew);

            // We can get a null pidl if the printer receives a refresh,
            // and before we call Printers_GetPidl the printer is gone.
            if (SUCCEEDED(hr))
                SHChangeNotify(aNotifyTypes[i+1], uFlags, pidl, pidlNew);

            ILFree(pidl);
            ILFree(pidlNew);

            bReturn = SUCCEEDED(hr);
            break;
        }
    }

    return bReturn;
}

// The IClassFactory callback for CLSID_Printers

STDAPI CPrinters_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;

    CPrinterFolder* ppf = new CPrinterFolder();
    if (!ppf)
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = ppf->QueryInterface(riid, ppv);
        ppf->Release();  // Already have a ref count from new
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
// CPrintersData
//

// IUnknown
STDMETHODIMP CPrintersData::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    if (ppv)
    {
        if (IsEqualIID(riid, IID_IServiceProvider))
        {
            // we implement IServiceProvider
            *ppv = reinterpret_cast<void*>(static_cast<IServiceProvider*>(this));
            reinterpret_cast<IUnknown*>(*ppv)->AddRef();
            hr = S_OK;
        }
        else
        {
            // delegate to CIDLDataObj
            hr = CIDLDataObj::QueryInterface(riid, ppv);
        }
    }
    return hr;
}

STDMETHODIMP CPrintersData::QueryGetData(FORMATETC *pformatetc)
{
    if ((pformatetc->cfFormat == g_cfPrinterFriendlyName) &&
        (pformatetc->tymed & TYMED_HGLOBAL))
    {
        return S_OK;
    }

    return CIDLDataObj::QueryGetData(pformatetc);
}

STDMETHODIMP CPrintersData::GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
    HRESULT hr = E_INVALIDARG;

    // g_cfPrinterFriendlyName creates an HDROP-like structure that contains
    // friendly printer names (instead of absolute paths) for the objects
    // in pdo. The handle returned from this can be used by the HDROP
    // functions DragQueryFile, DragQueryInfo, ...
    //
    if ((pformatetcIn->cfFormat == g_cfPrinterFriendlyName) &&
        (pformatetcIn->tymed & TYMED_HGLOBAL))
    {
        STGMEDIUM medium;
        UINT cbRequired = sizeof(DROPFILES) + sizeof(TCHAR); // dbl null terminated
        LPIDA pida = DataObj_GetHIDA(this, &medium);

        for (UINT i = 0; i < pida->cidl; i++)
        {
            LPIDPRINTER pidp = (LPIDPRINTER)IDA_GetIDListPtr(pida, i);
            cbRequired += ualstrlen(pidp->cName) * sizeof(pidp->cName[0]) + sizeof(pidp->cName[0]);
        }

        pmedium->pUnkForRelease = NULL; // caller should release hmem
        pmedium->tymed = TYMED_HGLOBAL;
        pmedium->hGlobal = GlobalAlloc(GPTR, cbRequired);
        if (pmedium->hGlobal)
        {
            LPDROPFILES pdf = (LPDROPFILES)pmedium->hGlobal;

            pdf->pFiles = sizeof(DROPFILES);
            pdf->fWide = (sizeof(TCHAR) == sizeof(WCHAR));

            LPTSTR lps = (LPTSTR)((LPBYTE)pdf + pdf->pFiles);
            
            for (i = 0; i < pida->cidl; i++)
            {
                LPIDPRINTER pidp = (LPIDPRINTER)IDA_GetIDListPtr(pida, i);
                ualstrcpy(lps, pidp->cName);
                lps += lstrlen(lps) + 1;
            }
            ASSERT(*lps == 0);

            hr = S_OK;
        }
        else
            hr = E_OUTOFMEMORY;

        HIDA_ReleaseStgMedium(pida, &medium);
    }
    else
    {
        hr = CIDLDataObj::GetData(pformatetcIn, pmedium);
    }

    return hr;
}

// IServiceProvider
STDMETHODIMP CPrintersData::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    if (_pdoAux && IsEqualIID(guidService, SID_SAuxDataObject))
    {
        hr = _pdoAux->QueryInterface(riid, ppv);
    }
    return hr;
}

////////////////////////////////////////////////////////////////////////////////
// CPrinterDropTarget
//

STDAPI CPrinterDropTarget_CreateInstance(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt)
{
    *ppdropt = NULL;

    HRESULT hr;
    CPrinterDropTarget *ppdt = new CPrinterDropTarget(hwnd);
    if (ppdt)
    {
        hr = ppdt->_Init(pidl);
        if (SUCCEEDED(hr))
            ppdt->QueryInterface(IID_PPV_ARG(IDropTarget, ppdropt));
        ppdt->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

STDMETHODIMP CPrinterDropTarget::DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    // let the base-class process it now to save away pdwEffect
    CIDLDropTarget::DragEnter(pDataObj, grfKeyState, pt, pdwEffect);

    // We allow files to be dropped for printing
    // if it is from the bitbucket only DROEFFECT_MOVE will be set in *pdwEffect
    // so this will keep us from printing wastbasket items.

    if (m_dwData & DTID_HDROP)
        *pdwEffect &= DROPEFFECT_COPY;
    else
        *pdwEffect = DROPEFFECT_NONE;   // Default action is nothing

    m_dwEffectLastReturned = *pdwEffect;

    return S_OK;
}

void _PrintHDROPFiles(HWND hwnd, HDROP hdrop, LPCITEMIDLIST pidlPrinter)
{
    DRAGINFO di;

    di.uSize = sizeof(di);
    if (DragQueryInfo(hdrop, &di))
    {
        BOOL bInstalled = FALSE;
        TCHAR szPrinter[MAXNAMELENBUFFER];

        //
        // first check if the printer is already installed (in the local printer's folder)
        // and if not installed asks the user if he wants to install it. you can't print
        // to a printer which isn't installed locally.
        //
        if (SUCCEEDED(SHGetNameAndFlags(pidlPrinter, SHGDN_FORPARSING, szPrinter, ARRAYSIZE(szPrinter), NULL)))
        {
            //
            // let's see if this printer is accessible and get the real printer name
            // (since szPrinter could be a share name - \\machine\share)
            //
            DWORD dwError = ERROR_SUCCESS;
            BOOL bPrinterOK = FALSE;

            HANDLE hPrinter = Printer_OpenPrinter(szPrinter);
            if (hPrinter)
            {
                PRINTER_INFO_5 *pPrinter = (PRINTER_INFO_5 *)Printer_GetPrinterInfo(hPrinter, 5);
                if (pPrinter)
                {
                    // the printer looks accessible, get the real printer name
                    bPrinterOK = TRUE;
                    lstrcpyn(szPrinter, pPrinter->pPrinterName, ARRAYSIZE(szPrinter));
                    LocalFree((HLOCAL)pPrinter);
                }
                else
                {
                    // save the last error
                    dwError = GetLastError();
                }
                Printer_ClosePrinter(hPrinter);
            }
            else
            {
                // save the last error
                dwError = GetLastError();
            }

            if (bPrinterOK)
            {
                LPITEMIDLIST pidl = NULL;
                if (SUCCEEDED(ParsePrinterName(szPrinter, &pidl)))
                {
                    // the printer is installed in the local printer's folder
                    bInstalled = TRUE;
                    ILFree(pidl);
                }
                else
                {
                    //
                    // tell the user this printer isn't installed and ask if he wants to install the printer
                    // before printing the files(s).
                    //
                    if (IDYES == ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_PRINTER_NOTCONNECTED),
                                    MAKEINTRESOURCE(IDS_PRINTERS), MB_YESNO|MB_ICONQUESTION))
                    {
                        pidl = Printers_PrinterSetup(hwnd, MSP_NETPRINTER, szPrinter, 0, NULL);
                        if (pidl)
                        {
                            bInstalled = TRUE;
                            ILFree(pidl);
                        }
                    }
                }
            }
            else
            {
                if( ERROR_SUCCESS == dwError )
                {
                    //
                    // the printer is unreachable for some reason or some other weird error occured -
                    // just show up an appropriate error message and continue.
                    //
                    // since all the above APIs are poorly designed it's very hard to tell what
                    // exactly has failed. it isn't possible to use the last error, since it's already
                    // stomped and probably totally wrong.
                    //
                    ShellMessageBox(HINST_THISDLL, hwnd,
                        MAKEINTRESOURCE(IDS_CANTPRINT),
                        MAKEINTRESOURCE(IDS_PRINTERS),
                        MB_OK|MB_ICONEXCLAMATION);
                }
                else
                {
                    // if ERROR_SUCCESS != dwError then we have meaningfull error to show up to
                    // the user. just do it.
                    ShowErrorMessageSC(NULL, NULL, hwnd, NULL, NULL, MB_OK|MB_ICONEXCLAMATION, dwError);
                }
            }
        }

        if (bInstalled)
        {
            //
            // at this point the printer we are trying to print to should be installed
            // locally, so we can safely proceed with printing the selected files(s).
            //
            LPTSTR pszFile = di.lpFileList;
            int i = IDYES;

            // Printing more than one file at a time can easily fail.
            // Ask the user to confirm this operation.
            if (*pszFile && *(pszFile + lstrlen(pszFile) + 1))
            {
                i = ShellMessageBox(HINST_THISDLL,
                    NULL,
                    MAKEINTRESOURCE(IDS_MULTIPLEPRINTFILE),
                    MAKEINTRESOURCE(IDS_PRINTERS),
                    MB_YESNO|MB_ICONINFORMATION);
            }

            if (i == IDYES)
            {
                // FEATURE: It would be really nice to have a progress bar when
                // printing multiple files.  And there should definitely be a way
                // to cancel this operation. Oh well, we warned them...

                while (*pszFile)
                {
                    Printer_PrintFile(hwnd, pszFile, pidlPrinter);
                    pszFile += lstrlen(pszFile) + 1;
                }
            }
        }

        SHFree(di.lpFileList);
    }
}

typedef struct {
    HWND        hwnd;
    IDataObject *pDataObj;
    IStream *pstmDataObj;       // to marshall the data object
    DWORD       dwEffect;
    POINT       ptDrop;
    LPITEMIDLIST    pidl;   // relative pidl of printer printing to
} PRNTHREADPARAM;


void FreePrinterThreadParam(PRNTHREADPARAM *pthp)
{
    if (pthp->pDataObj)
        pthp->pDataObj->Release();

    if (pthp->pstmDataObj)
        pthp->pstmDataObj->Release();

    ILFree(pthp->pidl);
    LocalFree((HLOCAL)pthp);
}
//
// This is the entry of "drop thread"
//
DWORD CALLBACK CPrintObj_DropThreadProc(void *pv)
{
    PRNTHREADPARAM *pthp = (PRNTHREADPARAM *)pv;
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    CoGetInterfaceAndReleaseStream(pthp->pstmDataObj, IID_PPV_ARG(IDataObject, &pthp->pDataObj));
    pthp->pstmDataObj = NULL;

    if (pthp->pDataObj && SUCCEEDED(pthp->pDataObj->GetData(&fmte, &medium)))
    {
        _PrintHDROPFiles(pthp->hwnd, (HDROP)medium.hGlobal, pthp->pidl);
        ReleaseStgMedium(&medium);
    }

    FreePrinterThreadParam(pthp);
    return 0;
}

HRESULT PrintObj_DropPrint(IDataObject *pDataObj, HWND hwnd, DWORD dwEffect, LPCITEMIDLIST pidl, LPTHREAD_START_ROUTINE pfn)
{
    HRESULT hr = E_OUTOFMEMORY; // assume the worst

    PRNTHREADPARAM *pthp = (PRNTHREADPARAM *)LocalAlloc(LPTR, sizeof(*pthp));
    if (pthp)
    {
        hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, (IUnknown *)pDataObj, &pthp->pstmDataObj);

        if (SUCCEEDED(hr))
        {
            if (hwnd)
                ShellFolderView_GetAnchorPoint(hwnd, FALSE, &pthp->ptDrop);
            pthp->hwnd = hwnd;
            pthp->dwEffect = dwEffect;
            hr = SHILClone(pidl, &pthp->pidl);
            if (SUCCEEDED(hr))
            {
                if (!SHCreateThread(pfn, pthp, CTF_COINIT, NULL))
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (FAILED(hr))
            FreePrinterThreadParam(pthp);
    }
    return hr;
}

STDMETHODIMP CPrinterDropTarget::_DropCallback(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect, LPTHREAD_START_ROUTINE pfn)
{
    *pdwEffect = m_dwEffectLastReturned;

    HRESULT hr;

    if (*pdwEffect)
        hr = DragDropMenu(DROPEFFECT_COPY, pDataObj, pt, pdwEffect, NULL, NULL, MENU_PRINTOBJ_DD, grfKeyState);
    else
        hr = S_FALSE;

    if (*pdwEffect)
        hr = PrintObj_DropPrint(pDataObj, _GetWindow(), *pdwEffect, m_pidl, pfn);

    CIDLDropTarget::DragLeave();
    return hr;
}

STDMETHODIMP CPrinterDropTarget::Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    return _DropCallback(pDataObj, grfKeyState, pt, pdwEffect, CPrintObj_DropThreadProc);
}



// cbModule = sizeof(*pszModule)  and  cbModule ~== MAX_PATH+slop
// returns NULL and sets *pid to the icon id in HINST_THISDLL   or
// returns pszModule and sets *pid to the icon id for module pszModule

LPTSTR CPrinterFolder::_FindIcon(LPCTSTR pszPrinterName, LPTSTR pszModule, ULONG cbModule, int *piIcon, int *piShortcutIcon)
{
    TCHAR szFullPrinter[MAXNAMELENBUFFER];
    LPTSTR pszRet = NULL;
    TCHAR szKeyName[256];
    int iStandardIcon;
    int iDefaultIcon;

    // Sanitize the printer name so it doesn't have backslashes.
    // We're about to use the string as a registry key name, where
    // backslashes are illegal.
    lstrcpyn(szFullPrinter, pszPrinterName, ARRAYSIZE(szFullPrinter));
    LPTSTR psz = szFullPrinter;
    while ((psz = StrChr(psz, TEXT('\\'))) != NULL)
    {
        *psz = TEXT('/');
    }

    // registry override of the icon
    wnsprintf(szKeyName, ARRAYSIZE(szKeyName), c_szPrintersDefIcon, szFullPrinter);

    //
    // Find an appropriate icon for the printer
    // 

    void *pData = NULL;
    DWORD dwAttributes = 0;
    LPTSTR pszPort = NULL;
    BOOL fDef;
    BOOL bIsFax = FALSE;

    // Try retrieving the information from hFolder if it's remote
    // to avoid hitting the net.
    //
    if (GetServer() && (pData = Printer_FolderGetPrinter(GetFolder(), pszPrinterName)))
    {
        dwAttributes = ((PFOLDER_PRINTER_DATA)pData)->Attributes;
        bIsFax = dwAttributes & PRINTER_ATTRIBUTE_FAX;

        LocalFree((HLOCAL)pData);
        pData = NULL;
    }
    else if (Printer_CheckNetworkPrinterByName(pszPrinterName, NULL))
    {
        // no remote fax icon if we have to resort to this
        // avoid hitting the network.
        dwAttributes = PRINTER_ATTRIBUTE_NETWORK;
    }
    else
    {
        pData = Printer_GetPrinterInfoStr(pszPrinterName, 5);
        if (pData)
        {
            dwAttributes = ((LPPRINTER_INFO_5)pData)->Attributes;
            pszPort = ((LPPRINTER_INFO_5)pData)->pPortName;
            bIsFax = dwAttributes & PRINTER_ATTRIBUTE_FAX;

            if (!bIsFax)
            {
                // the last resort -- check by port name
                bIsFax = !lstrcmp(pszPort, FAX_MONITOR_PORT_NAME);
            }
        }
    }

    // check if the delected printer is default
    fDef = IsDefaultPrinter(pszPrinterName, dwAttributes);

    if (dwAttributes & PRINTER_ATTRIBUTE_NETWORK)
    {
        if (bIsFax)
        {
            iStandardIcon = IDI_FAX_PRINTER_NET;
            iDefaultIcon = IDI_FAX_PRINTER_DEF_NET;
        }
        else
        {
            iStandardIcon = IDI_PRINTER_NET;
            iDefaultIcon = IDI_DEF_PRINTER_NET;
        }
    }
    else if (pszPort && !lstrcmp(pszPort, c_szFileColon))
    {
        iStandardIcon = IDI_PRINTER_FILE;
        iDefaultIcon = IDI_DEF_PRINTER_FILE;
    }
    else if (pszPort && !StrCmpNI(pszPort, c_szTwoSlashes, lstrlen(c_szTwoSlashes)))
    {
        iStandardIcon = IDI_PRINTER_NET;
        iDefaultIcon = IDI_DEF_PRINTER_NET;
    }
    else if (bIsFax)
    {
        iStandardIcon = IDI_FAX_PRINTER;
        iDefaultIcon = IDI_FAX_PRINTER_DEF;
    }
    else
    {
        iStandardIcon = IDI_PRINTER;
        iDefaultIcon = IDI_DEF_PRINTER;
    }

    // Shortcut icon never shows "default" checkmark...
    *piShortcutIcon = iStandardIcon;

    if (fDef)
        *piIcon = iDefaultIcon;
    else
        *piIcon = iStandardIcon;

    if (pData)
        LocalFree((HLOCAL)pData);

    return pszRet;
}

////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
//
// DUI WebView
//

// path to the scanners & cameras folder
const TCHAR g_szScanAndCam_Path[] =
    TEXT("::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\")
    TEXT("::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\")
    TEXT("::{E211B736-43FD-11D1-9EFB-0000F8757FCD}");

// printer's folder webview callbacks namespace
namespace PF_WV_CB
{
    HRESULT WebviewVerbIsEnabled(CPrinterFolder::WV_VERB eVerbID, UINT uSelMask,
        IUnknown* pv, IShellItemArray *psiItemArray, BOOL *pbEnabled)
    {
        HRESULT hr = E_FAIL;

        CPrinterFolder *ppf;
        hr = IUnknown_QueryService(pv, CLSID_Printers, CLSID_Printers, (void**)&ppf);
        if (SUCCEEDED(hr))
        {
            IDataObject *pdo = NULL;

            if (psiItemArray)
            {
                hr = psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_PPV_ARG(IDataObject,&pdo));
            }

            if (SUCCEEDED(hr))
            {

                hr = ppf->_WebviewCheckToUpdateDataObjectCache(pdo);
                if (SUCCEEDED(hr))
                {
                    hr = ppf->_WebviewVerbIsEnabled(eVerbID, uSelMask, pbEnabled);
                }

                ATOMICRELEASE(pdo);
            }
    
            ppf->Release();
        }

        return hr;
    }

    HRESULT WebviewVerbInvoke(CPrinterFolder::WV_VERB eVerbID, IUnknown* pv,IShellItemArray *psiItemArray)
    {
        CPrinterFolder *ppf;
        HRESULT hr = E_NOINTERFACE;
        if (SUCCEEDED(hr = IUnknown_QueryService(pv, CLSID_Printers, CLSID_Printers, (void**)&ppf)))
        {
            // just delegate the call to the printer's folder
            ULONG_PTR ulCookie = 0;
            if (SHActivateContext(&ulCookie))
            {
                hr = ppf->_WebviewVerbInvoke(eVerbID, pv, psiItemArray);
                SHDeactivateContext(ulCookie);
            }
            ppf->Release();
        }
        return hr;
    }

// get state handler
#define DEFINE_WEBVIEW_STATE_HANDLER(verb, eSelType)                \
{                                                                   \
    BOOL bEnabled = FALSE;                                          \
    HRESULT hr = WebviewVerbIsEnabled(                              \
        CPrinterFolder::##verb,                                     \
        CPrinterFolder::##eSelType,                                 \
            pv, psiItemArray, &bEnabled);                                    \
    *puisState = (SUCCEEDED(hr) ?                                   \
        (bEnabled ? UIS_ENABLED : UIS_HIDDEN) : UIS_HIDDEN);        \
    return hr;                                                      \
}                                                                   \

// invoke handler
#define DEFINE_WEBVIEW_INVOKE_HANDLER(verb)                         \
{                                                                   \
    return WebviewVerbInvoke(CPrinterFolder::##verb, pv, psiItemArray);  \
}                                                                   \

    ////////////////////////////////////////////////////////////////////////////////////
    // getState callbacks
    HRESULT CanADDPRINTER          (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_ADDPRINTERWIZARD, SEL_ANY)
    }

    HRESULT CanSRVPROPS            (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_SERVERPROPERTIES, SEL_ANY)
    }

    HRESULT CanSENDFAX             (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_SENDFAXWIZARD, SEL_ANY)
    }

    HRESULT CanTROUBLESHOOTER      (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_TROUBLESHOOTER, SEL_ANY)
    }

    HRESULT CanGOTOSUPPORT         (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_GOTOSUPPORT, SEL_ANY)
    }

    HRESULT CanSETUPFAXING         (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_SETUPFAXING, SEL_ANY)
    }

    HRESULT CanCREATELOCALFAX      (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_CREATELOCALFAX, SEL_ANY)
    }

    HRESULT CanFLD_RENAME          (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_RENAME, SEL_SINGLE_LINK)
    }

    HRESULT CanFLD_DELETE          (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_DELETE, SEL_SINGLE_LINK)
    }

    HRESULT CanFLD_PROPERTIES      (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_PROPERTIES, SEL_SINGLE_LINK)
    }

    HRESULT CanPRN_RENAME          (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_RENAME, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_DELETE          (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_DELETE, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_PROPERTIES      (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_PROPERTIES, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_OPENQUEUE       (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_OPENPRN, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_PREFERENCES     (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_DOCUMENTDEFAULTS, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_PAUSE           (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_PAUSEPRN, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_RESUME          (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_RESUMEPRN, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_SHARE           (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_SHARING, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_VENDORURL       (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_VENDORURL, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_PRINTERURL      (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_PRINTERURL, SEL_SINGLE_PRINTER)
    }

    HRESULT CanMUL_DELETE          (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_DELETE, SEL_MULTI_PRINTER)
    }

    HRESULT CanMUL_PROPERTIES      (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_PROPERTIES, SEL_MULTI_PRINTER)
    }

    HRESULT CanFLDMUL_DELETE       (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_DELETE, SEL_MULTI_LINK)
    }

    HRESULT CanFLDMUL_PROPERTIES   (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_PROPERTIES, SEL_MULTI_LINK)
    }

    HRESULT CanANYMUL_DELETE       (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_DELETE, SEL_MULTI_MIXED)
    }

    HRESULT CanANYMUL_PROPERTIES   (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_PROPERTIES, SEL_MULTI_MIXED)
    }

    ////////////////////////////////////////////////////////////////////////////////////
    // Invoke callbacks
    //

    HRESULT OnADDPRINTER          (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_ADDPRINTERWIZARD)
    }

    HRESULT OnSRVPROPS            (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_SERVERPROPERTIES)
    }

    HRESULT OnSENDFAX             (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_SENDFAXWIZARD)
    }

    HRESULT OnTROUBLESHOOTER      (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_TROUBLESHOOTER)
    }

    HRESULT OnGOTOSUPPORT         (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_GOTOSUPPORT)
    }

    HRESULT OnSETUPFAXING         (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_SETUPFAXING)
    }

    HRESULT OnCREATELOCALFAX      (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_CREATELOCALFAX)
    }

    HRESULT OnFLD_RENAME          (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_RENAME)
    }

    HRESULT OnFLD_DELETE          (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_DELETE)
    }

    HRESULT OnFLD_PROPERTIES      (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_PROPERTIES)
    }

    HRESULT OnPRN_RENAME          (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_RENAME)
    }

    HRESULT OnPRN_DELETE          (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_DELETE)
    }

    HRESULT OnPRN_PROPERTIES      (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_PROPERTIES)
    }

    HRESULT OnPRN_OPENQUEUE       (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_OPENPRN)
    }

    HRESULT OnPRN_PREFERENCES     (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_DOCUMENTDEFAULTS)
    }

    HRESULT OnPRN_PAUSE           (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_PAUSEPRN)
    }

    HRESULT OnPRN_RESUME          (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_RESUMEPRN)
    }

    HRESULT OnPRN_SHARE           (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_SHARING)
    }

    HRESULT OnPRN_VENDORURL       (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_VENDORURL)
    }

    HRESULT OnPRN_PRINTERURL      (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_PRINTERURL)
    }

    HRESULT OnMUL_DELETE          (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_DELETE)
    }

    HRESULT OnMUL_PROPERTIES      (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_PROPERTIES)
    }

    HRESULT OnFLDMUL_DELETE       (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_DELETE)
    }

    HRESULT OnFLDMUL_PROPERTIES   (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_PROPERTIES)
    }

    HRESULT OnANYMUL_DELETE       (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_DELETE)
    }

    HRESULT OnANYMUL_PROPERTIES   (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_PROPERTIES)
    }

}; // namespace PFWV_CALLBACKS

///////////////////////////////////////////////////////////////////
// GUIDS for the printer's folder webview commands
//

// *************************************** PRINTER COMMANDS ***************************************

// {D351FCED-C179-41ae-AD50-CAAC892DF24A}
DEFINE_GUID(UICID_Printers_OpenQueue,   0xd351fced, 0xc179, 0x41ae, 0xad, 0x50, 0xca, 0xac, 0x89, 0x2d, 0xf2, 0x4a);

// {A263A9D6-F1BA-4607-B7AA-CF471DEA17FF}
DEFINE_GUID(UICID_Printers_Preferences, 0xa263a9d6, 0xf1ba, 0x4607, 0xb7, 0xaa, 0xcf, 0x47, 0x1d, 0xea, 0x17, 0xff);

// {73149B3F-1E6D-4b00-9047-4576BC853A41}
DEFINE_GUID(UICID_Printers_Pause,       0x73149b3f, 0x1e6d, 0x4b00, 0x90, 0x47, 0x45, 0x76, 0xbc, 0x85, 0x3a, 0x41);

// {A7920561-FAAD-44a0-8C4C-FD769587F807}
DEFINE_GUID(UICID_Printers_Resume,      0xa7920561, 0xfaad, 0x44a0, 0x8c, 0x4c, 0xfd, 0x76, 0x95, 0x87, 0xf8, 0x7);

// {538536A1-5BC3-4b9c-8287-7562D53BE380}
DEFINE_GUID(UICID_Printers_Share,       0x538536a1, 0x5bc3, 0x4b9c, 0x82, 0x87, 0x75, 0x62, 0xd5, 0x3b, 0xe3, 0x80);

// {1461CC4A-308E-4ae5-B03A-F9682E3232B0}
DEFINE_GUID(UICID_Printers_Properties,  0x1461cc4a, 0x308e, 0x4ae5, 0xb0, 0x3a, 0xf9, 0x68, 0x2e, 0x32, 0x32, 0xb0);

// {A1F67BA0-5DEF-4e12-9E64-EA77670BFF26}
DEFINE_GUID(UICID_Printers_VendorURL,   0xa1f67ba0, 0x5def, 0x4e12, 0x9e, 0x64, 0xea, 0x77, 0x67, 0xb, 0xff, 0x26);

// {8D4D326C-30A4-47dc-BF51-4BC5863883E3}
DEFINE_GUID(UICID_Printers_PrinterURL,  0x8d4d326c, 0x30a4, 0x47dc, 0xbf, 0x51, 0x4b, 0xc5, 0x86, 0x38, 0x83, 0xe3);

// *************************************** STANDARD COMMANDS ***************************************

// those are defined in shlguidp.h
//
// UICID_Rename
// UICID_Delete

// *************************************** COMMON COMMANDS ***************************************

// {6D9778A5-C27D-464a-8511-36F7243BD0ED}
DEFINE_GUID(UICID_Printers_AddPrinter,      0x6d9778a5, 0xc27d, 0x464a, 0x85, 0x11, 0x36, 0xf7, 0x24, 0x3b, 0xd0, 0xed);

// {E1391312-2DAC-48db-994B-0BF22DB7576D}
DEFINE_GUID(UICID_Printers_SrvProps,        0xe1391312, 0x2dac, 0x48db, 0x99, 0x4b, 0xb, 0xf2, 0x2d, 0xb7, 0x57, 0x6d);

// {27DC81DF-73DB-406a-9A86-5EF38BA67CA8}
DEFINE_GUID(UICID_Printers_SendFax,         0x27dc81df, 0x73db, 0x406a, 0x9a, 0x86, 0x5e, 0xf3, 0x8b, 0xa6, 0x7c, 0xa8);

// {A21E3CCF-68D4-49cd-99A2-A272E9FF3A20}
DEFINE_GUID(UICID_Printers_GotoSupport, 0xa21e3ccf, 0x68d4, 0x49cd, 0x99, 0xa2, 0xa2, 0x72, 0xe9, 0xff, 0x3a, 0x20);

// {793542CF-5720-49f3-9A09-CAA3079508B9}
DEFINE_GUID(UICID_Printers_Troubleshooter,  0x793542cf, 0x5720, 0x49f3, 0x9a, 0x9, 0xca, 0xa3, 0x7, 0x95, 0x8, 0xb9);

// {EED61EFC-6A20-48dd-82FD-958DFDB96F1E}
DEFINE_GUID(UICID_Printers_SetupFaxing,     0xeed61efc, 0x6a20, 0x48dd, 0x82, 0xfd, 0x95, 0x8d, 0xfd, 0xb9, 0x6f, 0x1e);

// {224ACF1D-BB4E-4979-A8B8-D078E2154BCC}
DEFINE_GUID(UICID_Printers_CreateFax,       0x224acf1d, 0xbb4e, 0x4979, 0xa8, 0xb8, 0xd0, 0x78, 0xe2, 0x15, 0x4b, 0xcc);


///////////////////////////////////////////////////////////////////
// Header items
//

const WVTASKITEM
g_cPrintersVW_HeaderTasks =
    WVTI_HEADER(
        L"shell32.dll",                     // module where the resources are
        IDS_PRINTERS_WV_HEADER_TASKS,       // statis header for all cases
        IDS_PRINTERS_WV_HEADER_TASKS_TT     // tooltip
        );

const WVTASKITEM
g_cPrintersVW_HeaderSeeAlso =
    WVTI_HEADER(
        L"shell32.dll",                     // module where the resources are
        IDS_PRINTERS_WV_HEADER_SEEALSO,     // statis header for all cases
        IDS_PRINTERS_WV_HEADER_SEEALSO_TT   // tooltip
        );

// **************************************************************************************
// ****************************** sample command definition *****************************
//
//    WVTI_ENTRY_ALL_TITLE(
//        UICID_MyCmd,                                      // command GUID
//        L"shell32.dll",                                   // module
//        IDS_PRINTERS_WV_MYCMD,                            // no selection
//        IDS_PRINTERS_WV_MYCMD,                            // 1 file
//        IDS_PRINTERS_WV_MYCMD,                            // 1 folder selected
//        IDS_PRINTERS_WV_MYCMD,                            // multiple selection
//        IDS_PRINTERS_WV_MYCMD_TT,                         // tooltip
//        IDI_PRINTERS_WV_MYCMD,                            // icon
//        PF_WV_CB::CanMYCMD,                               // get UI state callback
//        PF_WV_CB::OnMYCMD                                 // OnVerb callback
//        ),
//

const WVTASKITEM g_cPrintersTasks[] =
{
    ////////////////////////////////////////////////////////////////////////////////////
    // commands in the 'Tasks' section when there is no selection
    ////////////////////////////////////////////////////////////////////////////////////

    // add printer command - always enabled regardless of the selection type!
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_AddPrinter,                          // command GUID
        L"shell32.dll",                                     // module
        IDS_PRINTERS_WV_ADDPRINTER,                         // no selection
        IDS_PRINTERS_WV_ADDPRINTER,                         // 1 file
        IDS_PRINTERS_WV_ADDPRINTER,                         // 1 folder selected
        IDS_PRINTERS_WV_ADDPRINTER,                         // multiple selection
        IDS_PRINTERS_WV_ADDPRINTER_TT,                      // tooltip
        IDI_PRINTERS_WV_ADDPRINTER,                         // icon
        PF_WV_CB::CanADDPRINTER,                            // get UI state callback
        PF_WV_CB::OnADDPRINTER                              // OnVerb callback
        ),

    // server properties command
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_SrvProps,                            // command GUID
        L"shell32.dll",                                     // module
        IDS_PRINTERS_WV_SRVPROPS,                           // no selection
        0,                                                  // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_SRVPROPS_TT,                        // tooltip
        IDI_PRINTERS_WV_SRVPROPS,                           // icon
        PF_WV_CB::CanSRVPROPS,                              // get UI state callback
        PF_WV_CB::OnSRVPROPS                                // OnVerb callback
        ),

    // send fax command
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_SendFax,                             // command GUID
        L"shell32.dll",                                     // module
        IDS_PRINTERS_WV_SENDFAX,                            // no selection
        0,                                                  // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_SENDFAX_TT,                         // tooltip
        IDI_PRINTERS_WV_SENDFAX,                            // icon
        PF_WV_CB::CanSENDFAX,                               // get UI state callback
        PF_WV_CB::OnSENDFAX                                 // OnVerb callback
        ),

    // setup faxing
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_SetupFaxing,                         // command GUID
        L"shell32.dll",                                     // module
        IDS_PRINTERS_WV_SETUPFAXING,                        // no selection
        0,                                                  // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_SETUPFAXING_TT,                     // tooltip
        IDI_PRINTERS_WV_FAXING,                             // icon
        PF_WV_CB::CanSETUPFAXING,                           // get UI state callback
        PF_WV_CB::OnSETUPFAXING                             // OnVerb callback
        ),

    // create fax printer
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_CreateFax,                           // command GUID
        L"shell32.dll",                                     // module
        IDS_PRINTERS_WV_CREATEFAXPRN,                       // no selection
        0,                                                  // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_CREATEFAXPRN_TT,                    // tooltip
        IDI_PRINTERS_WV_FAXING,                             // icon
        PF_WV_CB::CanCREATELOCALFAX,                        // get UI state callback
        PF_WV_CB::OnCREATELOCALFAX                          // OnVerb callback
        ),

    // open printer queue command
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_OpenQueue,                           // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_OPENQUEUE,                      // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_OPENQUEUE_TT,                   // tooltip
        IDI_PRINTERS_WV_OPENQUEUE,                          // icon
        PF_WV_CB::CanPRN_OPENQUEUE,                         // get UI state callback
        PF_WV_CB::OnPRN_OPENQUEUE                           // OnVerb callback
        ),

    // single selection printer preferences
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Preferences,                         // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_PREFERENCES,                    // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_PREFERENCES_TT,                 // tooltip
        IDI_PRINTERS_WV_PREFERENCES,                        // icon
        PF_WV_CB::CanPRN_PREFERENCES,                       // get UI state callback
        PF_WV_CB::OnPRN_PREFERENCES                         // OnVerb callback
        ),

    // pause printer
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Pause,                               // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_PAUSE,                          // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_PAUSE_TT,                       // tooltip
        IDI_PRINTERS_WV_PAUSE,                              // icon
        PF_WV_CB::CanPRN_PAUSE,                             // get UI state callback
        PF_WV_CB::OnPRN_PAUSE                               // OnVerb callback
        ),

    // resume printer
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Resume,                              // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_RESUME,                         // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_RESUME_TT,                      // tooltip
        IDI_PRINTERS_WV_RESUME,                             // icon
        PF_WV_CB::CanPRN_RESUME,                            // get UI state callback
        PF_WV_CB::OnPRN_RESUME                              // OnVerb callback
        ),

    // single selection share printer
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Share,                               // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_SHARE,                          // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_SHARE_TT,                       // tooltip
        IDI_PRINTERS_WV_SHARE,                              // icon
        PF_WV_CB::CanPRN_SHARE,                             // get UI state callback
        PF_WV_CB::OnPRN_SHARE                               // OnVerb callback
        ),

    // single sel. rename for printer
    WVTI_ENTRY_ALL_TITLE(
        UICID_Rename,                                       // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_RENAME,                         // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_RENAME_TT,                      // tooltip
        IDI_PRINTERS_WV_RENAME,                             // icon
        PF_WV_CB::CanPRN_RENAME,                            // get UI state callback
        PF_WV_CB::OnPRN_RENAME                              // OnVerb callback
        ),

    // single sel. rename for link
    WVTI_ENTRY_ALL_TITLE(
        UICID_Rename,                                       // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_FLD_RENAME,                         // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_FLD_RENAME_TT,                      // tooltip
        IDI_PRINTERS_WV_RENAME,                             // icon
        PF_WV_CB::CanFLD_RENAME,                            // get UI state callback
        PF_WV_CB::OnFLD_RENAME                              // OnVerb callback
        ),

    // single sel. delete for printer
    WVTI_ENTRY_ALL_TITLE(
        UICID_Delete,                                       // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_DELETE,                         // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_DELETE_TT,                      // tooltip
        IDI_PRINTERS_WV_DELETE,                             // icon
        PF_WV_CB::CanPRN_DELETE,                            // get UI state callback
        PF_WV_CB::OnPRN_DELETE                              // OnVerb callback
        ),

    // single sel. delete for link
    WVTI_ENTRY_ALL_TITLE(
        UICID_Delete,                                       // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_FLD_DELETE,                         // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_FLD_DELETE_TT,                      // tooltip
        IDI_PRINTERS_WV_DELETE,                             // icon
        PF_WV_CB::CanFLD_DELETE,                            // get UI state callback
        PF_WV_CB::OnFLD_DELETE                              // OnVerb callback
        ),

    // multi sel. delete for printers
    WVTI_ENTRY_ALL_TITLE(
        UICID_Delete,                                       // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        0,                                                  // 1 file
        0,                                                  // 1 folder selected
        IDS_PRINTERS_WV_MUL_DELETE,                         // multiple selection
        IDS_PRINTERS_WV_MUL_DELETE_TT,                      // tooltip
        IDI_PRINTERS_WV_DELETE,                             // icon
        PF_WV_CB::CanMUL_DELETE,                            // get UI state callback
        PF_WV_CB::OnMUL_DELETE                              // OnVerb callback
        ),

    // multi sel. delete for links
    //
    // NOTE: note that this command will be enabled for
    // the single selection as well because we don't really know
    // what has been selected until we verify the selection type
    WVTI_ENTRY_ALL_TITLE(
        UICID_Delete,                                       // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_FLDMUL_DELETE,                      // 1 file
        0,                                                  // 1 folder selected
        IDS_PRINTERS_WV_FLDMUL_DELETE,                      // multiple selection
        IDS_PRINTERS_WV_FLDMUL_DELETE_TT,                   // tooltip
        IDI_PRINTERS_WV_DELETE,                             // icon
        PF_WV_CB::CanFLDMUL_DELETE,                         // get UI state callback
        PF_WV_CB::OnFLDMUL_DELETE                           // OnVerb callback
        ),

    // multi sel. delete for mixed objects...
    //
    // NOTE: note that this command will be enabled for
    // the single selection as well because we don't really know
    // what has been selected until we verify the selection type
    WVTI_ENTRY_ALL_TITLE(
        UICID_Delete,                                       // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_ANYMUL_DELETE,                      // 1 file
        0,                                                  // 1 folder selected
        IDS_PRINTERS_WV_ANYMUL_DELETE,                      // multiple selection
        IDS_PRINTERS_WV_ANYMUL_DELETE_TT,                   // tooltip
        IDI_PRINTERS_WV_DELETE,                             // icon
        PF_WV_CB::CanANYMUL_DELETE,                         // get UI state callback
        PF_WV_CB::OnANYMUL_DELETE                           // OnVerb callback
        ),

    // single sel. properties for printer
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Properties,                          // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_PROPERTIES,                     // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_PROPERTIES_TT,                  // tooltip
        IDI_PRINTERS_WV_PROPERTIES,                         // icon
        PF_WV_CB::CanPRN_PROPERTIES,                        // get UI state callback
        PF_WV_CB::OnPRN_PROPERTIES                          // OnVerb callback
        ),

    // single sel. properties for link
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Properties,                          // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_FLD_PROPERTIES,                     // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_FLD_PROPERTIES_TT,                  // tooltip
        IDI_PRINTERS_WV_PROPERTIES,                         // icon
        PF_WV_CB::CanFLD_PROPERTIES,                        // get UI state callback
        PF_WV_CB::OnFLD_PROPERTIES                          // OnVerb callback
        ),

    // multi sel. properties of printers
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Properties,                          // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        0,                                                  // 1 file
        0,                                                  // 1 folder selected
        IDS_PRINTERS_WV_MUL_PROPERTIES,                     // multiple selection
        IDS_PRINTERS_WV_MUL_PROPERTIES_TT,                  // tooltip
        IDI_PRINTERS_WV_PROPERTIES,                         // icon
        PF_WV_CB::CanMUL_PROPERTIES,                        // get UI state callback
        PF_WV_CB::OnMUL_PROPERTIES                          // OnVerb callback
        ),

    // multi sel. properties of links
    //
    // NOTE: note that this command will be enabled for
    // the single selection as well because we don't really know
    // what has been selected until we verify the selection type
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Properties,                          // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_FLDMUL_PROPERTIES,                  // 1 file
        0,                                                  // 1 folder selected
        IDS_PRINTERS_WV_FLDMUL_PROPERTIES,                  // multiple selection
        IDS_PRINTERS_WV_FLDMUL_PROPERTIES_TT,               // tooltip
        IDI_PRINTERS_WV_PROPERTIES,                         // icon
        PF_WV_CB::CanFLDMUL_PROPERTIES,                     // get UI state callback
        PF_WV_CB::OnFLDMUL_PROPERTIES                       // OnVerb callback
        ),

    // multi sel. properties of mixed objects
    //
    // NOTE: note that this command will be enabled for
    // the single selection as well because we don't really know
    // what has been selected until we verify the selection type
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Properties,                          // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_ANYMUL_PROPERTIES,                  // 1 file
        0,                                                  // 1 folder selected
        IDS_PRINTERS_WV_ANYMUL_PROPERTIES,                  // multiple selection
        IDS_PRINTERS_WV_ANYMUL_PROPERTIES_TT,               // tooltip
        IDI_PRINTERS_WV_PROPERTIES,                         // icon
        PF_WV_CB::CanANYMUL_PROPERTIES,                     // get UI state callback
        PF_WV_CB::OnANYMUL_PROPERTIES                       // OnVerb callback
        ),
};

const WVTASKITEM g_cPrintersSeeAlso[] =
{
    ////////////////////////////////////////////////////////////////////////////////////
    // commands in the 'See Also' section when there is no selection
    ////////////////////////////////////////////////////////////////////////////////////

    // open print troubleshooter
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Troubleshooter,                      // command GUID
        L"shell32.dll",                                     // module
        IDS_PRINTERS_WV_TROUBLESHOOTER,                     // no selection
        0,                                                  // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_TROUBLESHOOTER_TT,                  // tooltip
        IDI_PRINTERS_WV_TROUBLESHOOTER,                     // icon
        PF_WV_CB::CanTROUBLESHOOTER,                        // get UI state callback
        PF_WV_CB::OnTROUBLESHOOTER                          // OnVerb callback
        ),

    // goto support
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_GotoSupport,                         // command GUID
        L"shell32.dll",                                     // module
        IDS_PRINTERS_WV_GOTOSUPPORT,                        // no selection
        0,                                                  // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_GOTOSUPPORT_TT,                     // tooltip
        IDI_PRINTERS_WV_GOTOSUPPORT,                        // icon
        PF_WV_CB::CanGOTOSUPPORT,                           // get UI state callback
        PF_WV_CB::OnGOTOSUPPORT                             // OnVerb callback
        ),

    ////////////////////////////////////////////////////////////////////////////////////
    // commands in the 'See Also' section when there is 1 printer selected
    ////////////////////////////////////////////////////////////////////////////////////

    // goto vendor URL command
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_VendorURL,                           // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_VENDORURL,                      // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_VENDORURL_TT,                   // tooltip
        IDI_PRINTERS_WV_VENDORURL,                          // icon
        PF_WV_CB::CanPRN_VENDORURL,                         // get UI state callback
        PF_WV_CB::OnPRN_VENDORURL                           // OnVerb callback
        ),

    // goto printer URL command
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_PrinterURL,                          // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_PRINTERURL,                     // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_PRINTERURL_TT,                  // tooltip
        IDI_PRINTERS_WV_PRINTERURL,                         // icon
        PF_WV_CB::CanPRN_PRINTERURL,                        // get UI state callback
        PF_WV_CB::OnPRN_PRINTERURL                          // OnVerb callback
        ),
};

// DUI webview impl.
HRESULT CPrinterFolder::GetWebViewLayout(IUnknown *pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    pData->dwLayout = SFVMWVL_NORMAL;
    return S_OK;
}

HRESULT CPrinterFolder::GetWebViewContent(IUnknown *pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    // those must be NULL when called
    ASSERT(NULL == pData->pIntroText);
    ASSERT(NULL == pData->pSpecialTaskHeader);
    ASSERT(NULL == pData->pFolderTaskHeader);
    ASSERT(NULL == pData->penumOtherPlaces);

    LPCTSTR rgCsidls[] = { g_szScanAndCam_Path, MAKEINTRESOURCE(CSIDL_PERSONAL), MAKEINTRESOURCE(CSIDL_MYPICTURES), MAKEINTRESOURCE(CSIDL_DRIVES) };
    HRESULT hr = CreateIEnumIDListOnCSIDLs(_pidl, rgCsidls, ARRAYSIZE(rgCsidls), &pData->penumOtherPlaces);
    if (FAILED(hr) ||
        FAILED(hr = Create_IUIElement(&g_cPrintersVW_HeaderTasks, &pData->pSpecialTaskHeader)) ||
        FAILED(hr = Create_IUIElement(&g_cPrintersVW_HeaderSeeAlso, &pData->pFolderTaskHeader)))
    {
        // something has failed - cleanup
        IUnknown_SafeReleaseAndNullPtr(pData->pIntroText);
        IUnknown_SafeReleaseAndNullPtr(pData->pSpecialTaskHeader);
        IUnknown_SafeReleaseAndNullPtr(pData->pFolderTaskHeader);
        IUnknown_SafeReleaseAndNullPtr(pData->penumOtherPlaces);
    }

    return hr;
}

HRESULT CPrinterFolder::GetWebViewTasks(IUnknown *pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
{
    ZeroMemory(pTasks, sizeof(*pTasks));

    HRESULT hr = S_OK;
    if (FAILED(hr = Create_IEnumUICommand(pv, g_cPrintersTasks,
            ARRAYSIZE(g_cPrintersTasks), &pTasks->penumSpecialTasks)) ||
        FAILED(hr = Create_IEnumUICommand(pv, g_cPrintersSeeAlso,
            ARRAYSIZE(g_cPrintersSeeAlso), &pTasks->penumFolderTasks)))
    {
        // something has failed - cleanup.
        IUnknown_SafeReleaseAndNullPtr(pTasks->penumSpecialTasks);
        IUnknown_SafeReleaseAndNullPtr(pTasks->penumFolderTasks);
    }
    else
    {
        // request to update webview each time the contents change
        pTasks->dwUpdateFlags = SFVMWVTSDF_CONTENTSCHANGE;
    }

    return hr;
}

HRESULT CPrinterFolder::SplitSelection(IDataObject *pdo,
    UINT *puSelType, IDataObject **ppdoPrinters, IDataObject **ppdoLinks)
{
    HRESULT hr = E_INVALIDARG;
    if (pdo)
    {
        hr = S_OK;
        UINT uSel = SEL_NONE;
        IDataObject *pdoPrinters = NULL;
        IDataObject *pdoLinks = NULL;

        // create a PIDL array from the passed in data object
        STGMEDIUM medium, mediumAux;
        LPIDA pida = NULL, pidaAux = NULL;
        pida = DataObj_GetHIDA(pdo, &medium);

        // now we'll query this data object for SID_SAuxDataObject to see if we have such
        IDataObject *pdoAux;
        if (SUCCEEDED(IUnknown_QueryService(pdo, SID_SAuxDataObject, IID_PPV_ARG(IDataObject, &pdoAux))))
        {
            pidaAux = DataObj_GetHIDA(pdoAux, &mediumAux);
        }
        else
        {
            pdoAux = NULL;
        }

        // check to see if PIDL array is created
        if (pida && pida->cidl)
        {
            PIDLTYPE pidlType;
            LPCITEMIDLIST pidl;
            UINT uPrinters = 0, uLinks = 0, uAddPrn = 0;

            // walk through the PIDLs array to count the number of PIDLs of each type
            for (UINT i = 0; i < pida->cidl; i++)
            {
                pidl = (LPCITEMIDLIST)IDA_GetIDListPtr(pida, i);
                pidlType = _IDListType(pidl);

                if (HOOD_COL_PRINTER == pidlType)
                {
                    // this is a printer PIDL - it could be a printer object
                    // or the add printer wizard special PIDL
                    if (_IsAddPrinter((LPCIDPRINTER)pidl))
                    {
                        // this is the wizard object
                        uAddPrn++;
                    }
                    else
                    {
                        // this is a regular printer object
                        uPrinters++;
                    }
                }
                else
                {
                    // not a printer PIDL - link is the only other possiblity
                    uLinks++;
                }
            }

            if (pidaAux)
            {
                // the auxiliary data object (if any) can contain only links
                uLinks += pidaAux->cidl;
            }

            // determine the selection type
            UINT uTotal = uPrinters + uLinks + uAddPrn;
            if (uTotal)
            {
                if (1 == uTotal)
                {
                    // single selection case
                    if (uPrinters)
                    {
                        pdoPrinters = pdo;
                        uSel = SEL_SINGLE_PRINTER;
                    }
                    else if (uLinks)
                    {
                        pdoLinks = pdo;
                        uSel = SEL_SINGLE_LINK;
                    }
                    else
                    {
                        pdoPrinters = pdo;
                        uSel = SEL_SINGLE_ADDPRN;
                    }
                }
                else
                {
                    // multiple selection case
                    if (0 == uLinks)
                    {
                        // only printers are selected
                        pdoPrinters = pdo;
                        uSel = SEL_MULTI_PRINTER;
                    }
                    else if (0 == uPrinters)
                    {
                        if (uAddPrn)
                        {
                            // only add printer wizard and links are selected
                            pdoPrinters = pdo;
                            pdoLinks = pdoAux;
                        }
                        else
                        {
                            // only links are selected
                            pdoLinks = pdo;
                        }
                        uSel = SEL_MULTI_LINK;
                    }
                    else
                    {
                        // mixed selection case
                        pdoPrinters = pdo;
                        pdoLinks = pdoAux;
                        uSel = SEL_MULTI_MIXED;
                    }
                }
            }
        }

        // addref and return the out parameters
        if (ppdoPrinters)
        {
            if (pdoPrinters)
                pdoPrinters->AddRef();
            *ppdoPrinters = pdoPrinters;
        }

        if (ppdoLinks)
        {
            if (pdoLinks)
                pdoLinks->AddRef();
            *ppdoLinks = pdoLinks;
        }

        if (puSelType)
        {
            *puSelType = uSel;
        }

        // check to release the PIDL array
        if (pida)
            HIDA_ReleaseStgMedium(pida, &medium);

        // check to release the auxiliary data object and storage medium
        if (pidaAux)
            HIDA_ReleaseStgMedium(pidaAux, &mediumAux);

        if (pdoAux)
            pdoAux->Release();

    }
    return hr;
}

HRESULT CPrinterFolder::_UpdateDataObjectCache()
{
    HRESULT hr = S_OK;

    CCSLock::Locker lock(_csLock);
    if (lock)
    {
        _bstrSelectedPrinter.Empty();

        // clear the cache -- zero can mean disabled or undefined --
        // we don't really care about the difference
        _uSelCurrent = SEL_NONE;
        ZeroMemory(&_aWVCommandStates, sizeof(_aWVCommandStates));

        if (_pdoCache)
        {
            IDataObject *pdoP = NULL;

            // collect state information relevant to the selection
            if (SUCCEEDED(hr = SplitSelection(_pdoCache, &_uSelCurrent, &pdoP, NULL)) &&
                SEL_SINGLE_PRINTER == _uSelCurrent)
            {
                STGMEDIUM medium;
                LPIDA pida = DataObj_GetHIDA(pdoP, &medium);

                if (pida)
                {
                    // this is pretty much the same type of logic we do in _MergeMenu()
                    TCHAR szFullPrinter[MAXNAMELENBUFFER];
                    LPCTSTR pszPrinter = _BuildPrinterName(szFullPrinter, ARRAYSIZE(szFullPrinter),
                        (LPIDPRINTER)IDA_GetIDListPtr(pida, 0), NULL);

                    PFOLDER_PRINTER_DATA pData = (PFOLDER_PRINTER_DATA)
                        Printer_FolderGetPrinter(GetFolder(), szFullPrinter);

                    if (pData)
                    {
                        ULONG ulAttributes;
                        LPCITEMIDLIST pidl = IDA_GetIDListPtr(pida, 0);

                        ulAttributes = SFGAO_CANDELETE;
                        _aWVCommandStates[WVIDM_DELETE] =
                            SUCCEEDED(GetAttributesOf(1, &pidl, &ulAttributes)) ? !!ulAttributes : FALSE;

                        ulAttributes = SFGAO_CANRENAME;
                        _aWVCommandStates[WVIDM_RENAME] =
                            SUCCEEDED(GetAttributesOf(1, &pidl, &ulAttributes)) ? !!ulAttributes : FALSE;

                        // enabled only for the local PF and if not default already
                        _aWVCommandStates[WVIDM_SETDEFAULTPRN] =
                            (NULL == GetServer() && FALSE == IsDefaultPrinter(szFullPrinter, pData->Attributes));

                        // enabled only for the local PF
                        _aWVCommandStates[WVIDM_DOCUMENTDEFAULTS] = (NULL == GetServer());

                        // enabled only if not paused already
                        _aWVCommandStates[WVIDM_PAUSEPRN] = !(pData->Status & PRINTER_STATUS_PAUSED);

                        // enabled only if paused
                        _aWVCommandStates[WVIDM_RESUMEPRN] = !!(pData->Status & PRINTER_STATUS_PAUSED);

                        // enabled only if the printer has jobs in the queue
                        _aWVCommandStates[WVIDM_PURGEPRN] = (0 != pData->cJobs);

                        if ((pData->Attributes & PRINTER_ATTRIBUTE_NETWORK) || (SpoolerVersion() <= 2))
                        {
                            // not enabled for network, masq and downlevel printers
                            _aWVCommandStates[WVIDM_WORKOFFLINE] = FALSE;
                        }
                        else
                        {
                            // enabled only if not offline already
                            _aWVCommandStates[WVIDM_WORKOFFLINE] =
                                !(pData->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE);
                        }

                        if ((pData->Attributes & PRINTER_ATTRIBUTE_NETWORK) || (SpoolerVersion() <= 2))
                        {
                            // not enabled for network, masq and downlevel printers
                            _aWVCommandStates[WVIDM_WORKONLINE] = FALSE;
                        }
                        else
                        {
                            // enabled only if offline
                            _aWVCommandStates[WVIDM_WORKONLINE] =
                                !!(pData->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE);
                        }

                        // remember the name of the selected printer
                        _bstrSelectedPrinter = szFullPrinter;
                        if (!_bstrSelectedPrinter)
                        {
                            hr = E_OUTOFMEMORY;
                        }

                        // free up the memory allocated from Printer_FolderGetPrinter
                        LocalFree((HLOCAL)pData);
                    }
                    else
                    {
                        // Printer_FolderGetPrinter failed
                        hr = E_OUTOFMEMORY;
                    }

                    // release the PIDL array
                    HIDA_ReleaseStgMedium(pida, &medium);
                }
                else
                {
                    // DataObj_GetHIDA failed
                    hr = E_OUTOFMEMORY;
                }
            }

            if (pdoP)
                pdoP->Release();
        }
    }
    else
    {
        // unable to enter the CS -- this can happen only in extremely low memory conditions!
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CPrinterFolder::_AssocCreate(REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    IQueryAssociations *pqa;
    hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));

    if (SUCCEEDED(hr))
    {
        hr = pqa->Init(0, c_szPrinters, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            hr = pqa->QueryInterface(riid, ppv);
        }
        pqa->Release();
    }
    return hr;
}

HRESULT CPrinterFolder::_OnRefresh(BOOL bPriorRefresh)
{
    HRESULT hr = S_OK;
    if (bPriorRefresh)
    {
        CCSLock::Locker lock(_csLock);
        if (lock)
        {
            // reset the slow webview data cache
            _SlowWVDataCacheResetUnsafe();

            // request a full refresh during the next enum
            RequestRefresh();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

// thread proc for obtaining the slow webview data
DWORD WINAPI CPrinterFolder::_SlowWebviewData_WorkerProc(LPVOID lpParameter)
{
    HRESULT hr = S_OK;
    CSlowWVDataCacheEntry *pCacheEntry = reinterpret_cast<CSlowWVDataCacheEntry*>(lpParameter);
    if (pCacheEntry && pCacheEntry->_ppf && pCacheEntry->_bDataPending)
    {
        CPrinterFolder *ppf = pCacheEntry->_ppf;
        CComBSTR bstrOemSupportUrl;
        CComBSTR bstrPrinterWebUrl;

        // retreive the slow webview data...
        HRESULT hrCOMInit = SHCoInitialize();
        if (SUCCEEDED(hr = hrCOMInit))
        {
            ASSERT(pCacheEntry->_bstrPrinterName);
            hr = _SlowWVDataRetrieve(pCacheEntry->_bstrPrinterName, &bstrOemSupportUrl, &bstrPrinterWebUrl);
        }

        // update the cache...
        do
        {
            CCSLock::Locker lock(pCacheEntry->_ppf->_csLock);
            if (lock)
            {
                pCacheEntry->_arrData[WV_SLOW_DATA_OEM_SUPPORT_URL].Empty();
                pCacheEntry->_arrData[WV_SLOW_DATA_PRINTER_WEB_URL].Empty();

                if (SUCCEEDED(hr))
                {
                    if (bstrOemSupportUrl)
                    {
                        pCacheEntry->_arrData[WV_SLOW_DATA_OEM_SUPPORT_URL] = bstrOemSupportUrl;
                    }

                    if (bstrPrinterWebUrl)
                    {
                        pCacheEntry->_arrData[WV_SLOW_DATA_PRINTER_WEB_URL] = bstrPrinterWebUrl;
                    }
                }

                // mark the data as ready...
                pCacheEntry->_nLastTimeUpdated = GetTickCount();
                pCacheEntry->_bDataPending = FALSE;
                hr = S_OK;
            }
            else
            {
                // even if we fail to enter the CS then we still should update
                // those fields to prevent further leaks.

                pCacheEntry->_nLastTimeUpdated = GetTickCount();
                pCacheEntry->_bDataPending = FALSE;
                hr = E_OUTOFMEMORY;
            }

            // pCacheEntry shouldn't be accessed beyond this point!
            pCacheEntry = NULL;
        }
        while (false);

        // update the webview pane...
        hr = ppf->_SlowWVDataUpdateWebviewPane();

        // shutdown...
        ppf->Release();
        SHCoUninitialize(hrCOMInit);
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return SUCCEEDED(hr) ? EXIT_SUCCESS : EXIT_FAILURE;
}

HRESULT CPrinterFolder::_SlowWVDataRetrieve(LPCTSTR pszPrinterName, BSTR *pbstrOemSupportUrl, BSTR *pbstrPrinterWebUrl)
{
    HRESULT hr = S_OK;

    // pszPrinterName can be NULL. if pszPrinterName is NULL that means that the 
    // custom support URL is requested (if any)

    if (pbstrOemSupportUrl && pbstrPrinterWebUrl)
    {
        *pbstrOemSupportUrl = NULL;
        *pbstrPrinterWebUrl = NULL;

        CLSID clsID = GUID_NULL;
        hr = _GetClassIDFromString(TEXT("OlePrn.PrinterURL"), &clsID);
        if (SUCCEEDED(hr))
        {
            IDispatch *pDisp = NULL;
            // SHExtCoCreateInstance to go through approval/app compat layer
            hr = SHExtCoCreateInstance(NULL, &clsID, NULL, IID_PPV_ARG(IDispatch, &pDisp));
            if (SUCCEEDED(hr))
            {
                CComVariant varOemSupportURL;
                CComVariant varPrinterWebURL;
                CComDispatchDriver drvDispatch(pDisp);

                // if pszPrinterName isn't NULL then on return pbstrOemSupportUrl will be the OEM
                // support URL. if it is NULL then it will be the custom support URL (if any)

                if (pszPrinterName)
                {
                    CComVariant varPrinterName(pszPrinterName);
                    if (varPrinterName.vt && varPrinterName.bstrVal)
                    {
                        hr = drvDispatch.PutPropertyByName(TEXT("PrinterName"), &varPrinterName);
                        if (SUCCEEDED(hr))
                        {
                            if (SUCCEEDED(drvDispatch.GetPropertyByName(TEXT("PrinterOemURL"), &varOemSupportURL)) &&
                                VT_BSTR == varOemSupportURL.vt && varOemSupportURL.bstrVal && varOemSupportURL.bstrVal[0])
                            {
                                *pbstrOemSupportUrl = SysAllocString(varOemSupportURL.bstrVal);
                            }

                            if (SUCCEEDED(drvDispatch.GetPropertyByName(TEXT("PrinterWebURL"), &varPrinterWebURL)) &&
                                VT_BSTR == varPrinterWebURL.vt && varPrinterWebURL.bstrVal && varPrinterWebURL.bstrVal[0])
                            {
                                *pbstrPrinterWebUrl = SysAllocString(varPrinterWebURL.bstrVal);
                            }

                            hr = S_OK;
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    hr = drvDispatch.GetPropertyByName(TEXT("SupportLink"), &varOemSupportURL);
                    if (SUCCEEDED(hr))
                    {
                        if (VT_BSTR == varOemSupportURL.vt && varOemSupportURL.bstrVal && varOemSupportURL.bstrVal[0])
                        {
                            *pbstrOemSupportUrl = SysAllocString(varOemSupportURL.bstrVal);
                            hr = S_OK;
                        }
                        else
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                }

                pDisp->Release();
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

int CPrinterFolder::_CompareSlowWVDataCacheEntries(CSlowWVDataCacheEntry *p1, 
    CSlowWVDataCacheEntry *p2, LPARAM lParam)
{
    ASSERT(p1 && p1->_bstrPrinterName);
    ASSERT(p2 && p2->_bstrPrinterName);

    return lstrcmpi(p1->_bstrPrinterName, p2->_bstrPrinterName);
}

HRESULT CPrinterFolder::_GetSelectedPrinter(BSTR *pbstrVal)
{
    HRESULT hr = S_OK;
    if (pbstrVal)
    {
        CCSLock::Locker lock(_csLock);
        if (lock)
        {
            if (_bstrSelectedPrinter)
            {
                *pbstrVal = _bstrSelectedPrinter.Copy();
                hr = (*pbstrVal) ? S_OK : E_OUTOFMEMORY;
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT CPrinterFolder::_GetSlowWVDataForCurrentPrinter(ESlowWebviewDataType eType, BSTR *pbstrVal)
{
    HRESULT hr = S_OK;

    CComBSTR bstrSelectedPrinter;
    if (SUCCEEDED(hr = _GetSelectedPrinter(&bstrSelectedPrinter)) &&
        SUCCEEDED(hr = _GetSlowWVData(bstrSelectedPrinter, eType, pbstrVal)))
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT CPrinterFolder::_GetSlowWVData(LPCTSTR pszPrinterName, ESlowWebviewDataType eType, BSTR *pbstrVal)
{
    HRESULT hr = S_OK;
    if (pszPrinterName && pbstrVal && eType >= 0 && eType < WV_SLOW_DATA_COUNT)
    {
        *pbstrVal = NULL;
        CCSLock::Locker lock(_csLock);
        if (lock)
        {
            CSlowWVDataCacheEntry entry(this);
            hr = entry.Initialize(pszPrinterName);
            if (SUCCEEDED(hr))
            {
                CSlowWVDataCacheEntry *pCacheEntry = NULL;
                // search the cache...
                INT iPos = _dpaSlowWVDataCache.Search(&entry, 0, 
                    _CompareSlowWVDataCacheEntries, 0L, DPAS_SORTED);

                if (iPos >= 0)
                {
                    // this item in the cache, check if it hasn't expired
                    pCacheEntry = _dpaSlowWVDataCache.GetPtr(iPos);
                    ASSERT(pCacheEntry);

                    // let's see if the requested data is available...
                    if (pCacheEntry->_arrData[eType])
                    {
                        *pbstrVal = pCacheEntry->_arrData[eType].Copy();
                        hr = (*pbstrVal) ? S_OK : E_OUTOFMEMORY;
                    }
                    else
                    {
                        hr = E_PENDING;
                    }

                    if (!pCacheEntry->_bDataPending)
                    {
                        // let's see if this entry hasn't expired...
                        DWORD dwTicks = GetTickCount();

                        // this can happen if the cache entry hasn't been touched for more than 49 days!
                        // pretty unlikely, but we should handle properly.

                        if (dwTicks < pCacheEntry->_nLastTimeUpdated)
                        {
                            pCacheEntry->_nLastTimeUpdated = 0;
                            _UpdateSlowWVDataCacheEntry(pCacheEntry);
                        }
                        else
                        {
                            if ((dwTicks - pCacheEntry->_nLastTimeUpdated) > WV_SLOW_DATA_CACHE_TIMEOUT)
                            {
                                // this cache entry has expired, kick off a thread to update...
                                _UpdateSlowWVDataCacheEntry(pCacheEntry);
                            }
                        }
                    }
                }
                else
                {
                    // this item isn't in the cache - let's create a new one and request update.
                    pCacheEntry = new CSlowWVDataCacheEntry(this);
                    if (pCacheEntry)
                    {
                        hr = pCacheEntry->Initialize(pszPrinterName);
                        if (SUCCEEDED(hr))
                        {
                            iPos = _dpaSlowWVDataCache.Search(pCacheEntry, 0, 
                                _CompareSlowWVDataCacheEntries, 0L, DPAS_SORTED | DPAS_INSERTAFTER);
                            iPos = _dpaSlowWVDataCache.InsertPtr(iPos, pCacheEntry);

                            if (-1 == iPos)
                            {
                                // failed to insert, bail...
                                delete pCacheEntry;
                                pCacheEntry = NULL;
                                hr = E_OUTOFMEMORY;
                            }
                            else
                            {
                                // kick off a thread to update...
                                hr = _UpdateSlowWVDataCacheEntry(pCacheEntry);

                                if (SUCCEEDED(hr))
                                {
                                    // everything succeeded - return pending to the caller
                                    hr = E_PENDING;
                                }
                                else
                                {
                                    // failed to create the thread, cleanup
                                    delete _dpaSlowWVDataCache.DeletePtr(iPos);
                                    pCacheEntry = NULL;
                                }
                            }
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT CPrinterFolder::_UpdateSlowWVDataCacheEntry(CSlowWVDataCacheEntry *pCacheEntry)
{
    HRESULT hr = S_OK;
    if (pCacheEntry)
    {
        pCacheEntry->_bDataPending = TRUE;
        pCacheEntry->_ppf->AddRef();
        if (!SHQueueUserWorkItem(reinterpret_cast<LPTHREAD_START_ROUTINE>(_SlowWebviewData_WorkerProc), 
                pCacheEntry, 0, 0, NULL, "shell32.dll", 0))
        {
            // failed to queue the work item - call Release() to balance the AddRef() call. 
            pCacheEntry->_bDataPending = FALSE;
            pCacheEntry->_nLastTimeUpdated = GetTickCount();
            pCacheEntry->_ppf->Release();

            // let's see if we can make something out of the win32 last error
            DWORD dw = GetLastError();
            hr = ((ERROR_SUCCESS == dw) ? E_FAIL : HRESULT_FROM_WIN32(dw));
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT CPrinterFolder::_SlowWVDataUpdateWebviewPane()
{
    HRESULT hr = S_OK;
    CComBSTR bstrSelectedPrinter;
    UINT uFlags = SHCNF_IDLIST | SHCNF_FLUSH | SHCNF_FLUSHNOWAIT;

    // we fire SHCNE_UPDATEITEM for the PIDL of the currently selected printer 
    // to force refresh of the webview pane. 

    if (SUCCEEDED(hr = _GetSelectedPrinter(&bstrSelectedPrinter)))
    {
        if (GetServer())
        {
            LPCTSTR pszServer = NULL;
            LPCTSTR pszPrinter = NULL;
            TCHAR szBuffer[MAXNAMELENBUFFER] = {0};

            // in the remote printer's folder we need to strip off the server
            // part from the full printer name.

            Printer_SplitFullName(szBuffer, ARRAYSIZE(szBuffer), bstrSelectedPrinter, &pszServer, &pszPrinter);
            if (pszPrinter && pszPrinter[0])
            {
                bstrSelectedPrinter = pszPrinter;
            }
        }

        LPITEMIDLIST pidl = NULL;
        if (SUCCEEDED(hr = _GetFullIDList(bstrSelectedPrinter, &pidl)))
        {
            SHChangeNotify(SHCNE_UPDATEITEM, uFlags, pidl, NULL);
            ILFree(pidl);
        }
    }

    return hr;
}

HRESULT CPrinterFolder::_SlowWVDataCacheResetUnsafe()
{
    // this is reseting the slow webview data cache
    if (_dpaSlowWVDataCache)
    {
        INT_PTR iPos = 0;
        CSlowWVDataCacheEntry *pCacheEntry = NULL;
        while (iPos < _dpaSlowWVDataCache.GetPtrCount())
        {
            // delete only the entries which are not in pending 
            pCacheEntry = _dpaSlowWVDataCache.GetPtr(iPos);
            if (!pCacheEntry->_bDataPending)
            {
                delete _dpaSlowWVDataCache.DeletePtr(iPos);
            }
            else
            {
                // this one is pending - skip.
                iPos++;
            }
        }
    }
    return S_OK;
}

HRESULT CPrinterFolder::_GetCustomSupportURL(BSTR *pbstrVal)
{
    HRESULT hr = S_OK;
    if (pbstrVal)
    {
        *pbstrVal = NULL;
        CComBSTR bstrOemSupportUrl;
        CComBSTR bstrPrinterWebUrl;
        hr = _SlowWVDataRetrieve(NULL, &bstrOemSupportUrl, &bstrPrinterWebUrl);

        if (SUCCEEDED(hr))
        {
            *pbstrVal = bstrOemSupportUrl.Copy();
            hr = S_OK;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT CPrinterFolder::_GetFaxControl(IDispatch **ppDisp)
{
    HRESULT hr = E_INVALIDARG;
    if (ppDisp)
    {
        *ppDisp = NULL;
        CLSID clsID = GUID_NULL;
        hr = _GetClassIDFromString(TEXT("FaxControl.FaxControl"), &clsID);

        if (SUCCEEDED(hr))
        {
            // SHExtCoCreateInstance to go through approval/app compat layer
            hr = SHExtCoCreateInstance(NULL, &clsID, NULL, IID_PPV_ARG(IDispatch, ppDisp));
        }
    }
    return hr;
}

HRESULT CPrinterFolder::_GetFaxCommand(UINT_PTR *puCmd)
{
    HRESULT hr = E_INVALIDARG;
    if (puCmd)
    {
        *puCmd = 0;
        IDispatch *pDisp = NULL;
        hr = _GetFaxControl(&pDisp);

        if (SUCCEEDED(hr))
        {
            CComDispatchDriver drvDispatch(pDisp);

            CComVariant varIsFxSvcInstalled;
            CComVariant varIsFxPrnInstalled;

            if (SUCCEEDED(hr = drvDispatch.GetPropertyByName(TEXT("IsFaxServiceInstalled"), &varIsFxSvcInstalled)) &&
                SUCCEEDED(hr = drvDispatch.GetPropertyByName(TEXT("IsLocalFaxPrinterInstalled"), &varIsFxPrnInstalled)))
            {
                if (VT_BOOL == varIsFxSvcInstalled.vt && VT_BOOL == varIsFxPrnInstalled.vt)
                {
                    if (VARIANT_TRUE == varIsFxSvcInstalled.boolVal)
                    {
                        if (VARIANT_TRUE == varIsFxPrnInstalled.boolVal)
                        {
                            *puCmd = FSIDM_SENDFAXWIZARD;
                        }
                        else
                        {
                            *puCmd = FSIDM_CREATELOCALFAX;
                        }
                    }
                    else
                    {
                        *puCmd = FSIDM_SETUPFAXING;
                    }
                    
                    hr = S_OK;
                }
                else
                {
                    hr = E_UNEXPECTED;
                }
            }

            pDisp->Release();
        }
    }
    return hr;
}

HRESULT CPrinterFolder::_InvokeFaxControlMethod(LPCTSTR pszMethodName)
{
    HRESULT hr = E_INVALIDARG;
    if (pszMethodName)
    {
        // this function will be called from background threads, so
        // we need to call SHCoInitialize first.

        HRESULT hrCOMInit = SHCoInitialize();
        if (SUCCEEDED(hr = hrCOMInit))
        {
            IDispatch *pDisp = NULL;
            hr = _GetFaxControl(&pDisp);

            if (SUCCEEDED(hr))
            {
                CComDispatchDriver drvDispatch(pDisp);
                hr = drvDispatch.Invoke0(pszMethodName);
                pDisp->Release();
            }
        }
        SHCoUninitialize(hrCOMInit);
    }
    return hr;
}

DWORD WINAPI CPrinterFolder::_ThreadProc_InstallFaxService(LPVOID lpParameter)
{
    HRESULT hr = _InvokeFaxControlMethod(TEXT("InstallFaxService"));
    return SUCCEEDED(hr) ? EXIT_SUCCESS : EXIT_FAILURE;
}

DWORD WINAPI CPrinterFolder::_ThreadProc_InstallLocalFaxPrinter(LPVOID lpParameter)
{
    HRESULT hr = _InvokeFaxControlMethod(TEXT("InstallLocalFaxPrinter"));
    return SUCCEEDED(hr) ? EXIT_SUCCESS : EXIT_FAILURE;
}


// conversion table from webview verbs into printer folder verbs
static const UINT_PTR
g_cVerbWV2VerbFolder[CPrinterFolder::WVIDM_COUNT] =
{
    #define INVALID_CMD static_cast<UINT_PTR>(-1)

    // folder verbs                                 // corresponding webview verbs
    DFM_CMD_DELETE,                                 // WVIDM_DELETE,
    DFM_CMD_RENAME,                                 // WVIDM_RENAME,
    DFM_CMD_PROPERTIES,                             // WVIDM_PROPERTIES,

    // common verbs// common verbs
    FSIDM_ADDPRINTERWIZARD,                         // WVIDM_ADDPRINTERWIZARD,
    FSIDM_SERVERPROPERTIES,                         // WVIDM_SERVERPROPERTIES,
    FSIDM_SETUPFAXING,                              // WVIDM_SETUPFAXING,
    FSIDM_CREATELOCALFAX,                           // WVIDM_CREATELOCALFAX,
    FSIDM_SENDFAXWIZARD,                            // WVIDM_SENDFAXWIZARD,

    // special common verbs// special common verbs
    INVALID_CMD,                                    // WVIDM_TROUBLESHOOTER,
    INVALID_CMD,                                    // WVIDM_GOTOSUPPORT,

    // printer verbs// printer verbs
    FSIDM_OPENPRN,                                  // WVIDM_OPENPRN,
    FSIDM_NETPRN_INSTALL,                           // WVIDM_NETPRN_INSTALL,
    FSIDM_SETDEFAULTPRN,                            // WVIDM_SETDEFAULTPRN,
    FSIDM_DOCUMENTDEFAULTS,                         // WVIDM_DOCUMENTDEFAULTS,
    FSIDM_PAUSEPRN,                                 // WVIDM_PAUSEPRN,
    FSIDM_RESUMEPRN,                                // WVIDM_RESUMEPRN,
    FSIDM_PURGEPRN,                                 // WVIDM_PURGEPRN,
    FSIDM_SHARING,                                  // WVIDM_SHARING,
    FSIDM_WORKOFFLINE,                              // WVIDM_WORKOFFLINE,
    FSIDM_WORKONLINE,                               // WVIDM_WORKONLINE,

    // special commands// special commands
    INVALID_CMD,                                    // WVIDM_VENDORURL,
    INVALID_CMD,                                    // WVIDM_PRINTERURL,
};

HRESULT CPrinterFolder::_WebviewVerbIsEnabled(WV_VERB eVerbID, UINT uSelMask, BOOL *pbEnabled)
{
    HRESULT hr = S_OK;

    CCSLock::Locker lock(_csLock);
    if (lock)
    {
        // not enabled by default
        ASSERT(pbEnabled);
        *pbEnabled = FALSE;

        if (_pdoCache)
        {
            // if _pdoCache isn't NULL that means we have a selection
            // let's see what command set will be enabled depending on
            // the current selection (_uSelCurrent, _pdoCache) and on
            // the passed in selection mask (uSelMask)

            if (uSelMask & _uSelCurrent)
            {
                switch (_uSelCurrent)
                {
                    case SEL_SINGLE_ADDPRN:
                        // only WVIDM_ADDPRINTERWIZARD is enabled
                        *pbEnabled = ((eVerbID == WVIDM_ADDPRINTERWIZARD) && !SHRestricted(REST_NOPRINTERADD));
                        break;

                    case SEL_SINGLE_PRINTER:
                        {
                            switch (eVerbID)
                            {
                                case WVIDM_PROPERTIES:
                                case WVIDM_OPENPRN:
                                case WVIDM_SHARING:
                                    // always enabled
                                    *pbEnabled = TRUE;
                                    break;

                                case WVIDM_VENDORURL:
                                    {
                                        *pbEnabled = FALSE;
                                        CComBSTR bstrCustomSupportURL;
                                        if (FAILED(_GetCustomSupportURL(&bstrCustomSupportURL)))
                                        {
                                            // OEM support URL will be enabled only if there is no custom support URL.
                                            CComBSTR bstrURL;
                                            *pbEnabled = SUCCEEDED(_GetSlowWVDataForCurrentPrinter(WV_SLOW_DATA_OEM_SUPPORT_URL, &bstrURL));
                                        }
                                    }
                                    break;

                                case WVIDM_PRINTERURL:
                                    {
                                        CComBSTR bstrURL;
                                        *pbEnabled = SUCCEEDED(_GetSlowWVDataForCurrentPrinter(WV_SLOW_DATA_PRINTER_WEB_URL, &bstrURL));
                                    }
                                    break;

                                default:
                                    // consult the cache
                                    *pbEnabled = _aWVCommandStates[eVerbID];
                                    break;
                            }
                        }
                        break;

                    case SEL_SINGLE_LINK:
                        {
                            // commands enabled for multiple selection of printer objects
                            switch (eVerbID)
                            {
                                case WVIDM_DELETE:
                                case WVIDM_RENAME:
                                case WVIDM_PROPERTIES:
                                    *pbEnabled = TRUE;
                                    break;

                                default:
                                    break;
                            }
                        }
                        break;

                    case SEL_MULTI_PRINTER:
                        {
                            switch (eVerbID)
                            {
                                case WVIDM_DELETE:
                                case WVIDM_PROPERTIES:

                                case WVIDM_OPENPRN:
                                case WVIDM_DOCUMENTDEFAULTS:
                                case WVIDM_PURGEPRN:
                                case WVIDM_SHARING:
                                    // those are always enabled
                                    *pbEnabled = TRUE;
                                    break;

                                default:
                                    break;
                            }
                        }
                        break;

                    case SEL_MULTI_LINK:
                    case SEL_MULTI_MIXED:
                        {
                            switch (eVerbID)
                            {
                                case WVIDM_DELETE:
                                case WVIDM_PROPERTIES:
                                    // those are always enabled
                                    *pbEnabled = TRUE;
                                    break;

                                default:
                                    break;
                            }
                        }
                        break;
                }

                // here we deal with commands which are always enabled regardless 
                // of the selection type.

                switch (eVerbID)
                {
                    case WVIDM_ADDPRINTERWIZARD:
                        *pbEnabled = !SHRestricted(REST_NOPRINTERADD);
                        break;

                    default:
                        break;
                }
            }
        }
        else
        {
            // if _pdoCache is NULL that means we have no selection
            // let's see what command set will be enabled depending
            // on the passed in selection mask (uSelMask)

            switch (eVerbID)
            {
                case WVIDM_ADDPRINTERWIZARD:
                    *pbEnabled = !SHRestricted(REST_NOPRINTERADD);
                    break;

                case WVIDM_TROUBLESHOOTER:
                case WVIDM_GOTOSUPPORT:
                    // the troubleshooter and goto support commands are always enabled.
                    *pbEnabled = TRUE;
                    break;

                case WVIDM_SERVERPROPERTIES:
                    // server properties will be enabled in the non-selection case
                    // only on server SKUs.
                    *pbEnabled = IsOS(OS_ANYSERVER);
                    break;

                case WVIDM_SETUPFAXING:
                case WVIDM_CREATELOCALFAX:
                case WVIDM_SENDFAXWIZARD:
                    {
                        UINT_PTR uCmd;
                        if (GetServer() || FAILED(_GetFaxCommand(&uCmd)))
                        {
                            uCmd = 0;
                        }
                        *pbEnabled = (uCmd == g_cVerbWV2VerbFolder[eVerbID]);
                    }
                    break;

                default:
                    break;
            }
        }
    }
    else
    {
        // unable to enter the CS -- this can happen only in extremely low memory conditions!
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CPrinterFolder::_WebviewVerbInvoke(WV_VERB eVerbID, IUnknown* pv, IShellItemArray *psiItemArray)
{
    HRESULT hr = S_OK;
    HWND hwnd = NULL;
    IShellView *psv = NULL;
    IDataObject *pdo = NULL;

    if (psiItemArray)
    {
        hr = psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_PPV_ARG(IDataObject,&pdo));
    }

    if (SUCCEEDED(hr))
    {
        // quey some basic interfaces from the PIDL array
        if (SUCCEEDED(hr = IUnknown_QueryService(pv, IID_IShellView, IID_PPV_ARG(IShellView, &psv))) &&
            SUCCEEDED(hr = psv->GetWindow(&hwnd)))
        {
            switch( eVerbID)
            {
            // special common verbs
            case WVIDM_TROUBLESHOOTER:
                ShellExecute(hwnd, TEXT("open"), TEXT("helpctr.exe"),
                    TEXT("-Url hcp://help/tshoot/tsprint.htm"), NULL, SW_SHOWNORMAL);
                break;

            case WVIDM_GOTOSUPPORT:
                {
                    CComBSTR bstrURL;
                    if (SUCCEEDED(_GetCustomSupportURL(&bstrURL)))
                    {
                        // the admin has provided a custom URL for support - navigate to it.
                        ShellExecute(hwnd, TEXT("open"), bstrURL, NULL, NULL, SW_SHOWNORMAL);
                    }
                    else
                    {
                        // custom support isn't provided - go to the default support URL.
                        ShellExecute(hwnd, TEXT("open"),
                            TEXT("http://www.microsoft.com/isapi/redir.dll?prd=Win2000&ar=Support&sba=printing"),
                            NULL, NULL, SW_SHOWNORMAL);
                    }
                }
                break;


                // common verbs
                case WVIDM_ADDPRINTERWIZARD:
                case WVIDM_SERVERPROPERTIES:
                case WVIDM_SETUPFAXING:
                case WVIDM_CREATELOCALFAX:
                case WVIDM_SENDFAXWIZARD:
                    {
                        // delegate the command to CPrinterFolder::CallBack
                        ASSERT(INVALID_CMD != g_cVerbWV2VerbFolder[eVerbID]);
                        hr = CallBack(this, hwnd, pdo, DFM_INVOKECOMMAND, g_cVerbWV2VerbFolder[eVerbID], 0L);
                    }
                    break;


            // standard verbs
            case WVIDM_DELETE:
            case WVIDM_RENAME:
            case WVIDM_PROPERTIES:

            // printer verbs
            case WVIDM_OPENPRN:
            case WVIDM_NETPRN_INSTALL:
            case WVIDM_SETDEFAULTPRN:
            case WVIDM_DOCUMENTDEFAULTS:
            case WVIDM_PAUSEPRN:
            case WVIDM_RESUMEPRN:
            case WVIDM_PURGEPRN:
            case WVIDM_SHARING:
            case WVIDM_WORKOFFLINE:
            case WVIDM_WORKONLINE:
                {
                    if (DFM_CMD_RENAME == g_cVerbWV2VerbFolder[eVerbID])
                    {
                        // we need to handle rename explicitly through IShellView2
                        IShellView2 *psv2;
                        if (SUCCEEDED(hr = IUnknown_QueryService(pv, IID_IShellView2,
                            IID_PPV_ARG(IShellView2, &psv2))))
                        {
                            // passing NULL to HandleRename is making defview to
                            // operate on the currently selected object
                            hr = psv2->HandleRename(NULL);
                            psv2->Release();
                        }
                    }
                    else
                    {
                        // just delegate the command to CPrinterFolder::_DFMCallBack
                        hr = _DFMCallBack(this, hwnd, pdo, DFM_INVOKECOMMAND, g_cVerbWV2VerbFolder[eVerbID], 0L);
                    }
                }
                break;

            // special commands
            case WVIDM_VENDORURL:
                {
                    CComBSTR bstrVendorURL;
                    hr = _GetSlowWVDataForCurrentPrinter(WV_SLOW_DATA_OEM_SUPPORT_URL, &bstrVendorURL);
                    if (SUCCEEDED(hr))
                    {
                        ShellExecute(hwnd, TEXT("open"), bstrVendorURL, NULL, NULL, SW_SHOWNORMAL);
                    }
                }
                break;

            case WVIDM_PRINTERURL:
                {
                    CComBSTR bstrPrinterURL;
                    hr = _GetSlowWVDataForCurrentPrinter(WV_SLOW_DATA_PRINTER_WEB_URL, &bstrPrinterURL);
                    if (SUCCEEDED(hr))
                    {
                        ShellExecute(hwnd, TEXT("open"), bstrPrinterURL, NULL, NULL, SW_SHOWNORMAL);
                    }
                }
                break;
            }
        }

        ATOMICRELEASE(pdo);
        ATOMICRELEASE(psv);
    }

    return hr;
}

HRESULT CPrinterFolder::_WebviewCheckToUpdateDataObjectCache(IDataObject *pdo)
{
    HRESULT hr = S_OK;

    CCSLock::Locker lock(_csLock);
    if (lock)
    {
        if (pdo)
        {
            // we need to compare the passed in data object with the one we are
            // caching and update the cache if necessary
            if (_pdoCache)
            {
                // compare the objects using the COM rules
                IUnknown *punk1;
                IUnknown *punk2;

                if (SUCCEEDED(hr = pdo->QueryInterface(IID_PPV_ARG(IUnknown, &punk1))))
                {
                    if (SUCCEEDED(hr = _pdoCache->QueryInterface(IID_PPV_ARG(IUnknown, &punk2))))
                    {
                        if (punk1 != punk2)
                        {
                            // release the current data object
                            _pdoCache->Release();
                            _pdoCache = pdo;
                            _pdoCache->AddRef();

                            // update the cache
                            hr = _UpdateDataObjectCache();
                        }
                        punk2->Release();
                    }
                    punk1->Release();
                }
            }
            else
            {
                // _pdoCache is NULL, rebuild the cache
                _pdoCache = pdo;
                _pdoCache->AddRef();

                // update the cache
                hr = _UpdateDataObjectCache();
            }
        }
        else
        {
            if (_pdoCache)
            {
                // clear the cache
                _pdoCache->Release();
                _pdoCache = NULL;

                // update the cache
                hr = _UpdateDataObjectCache();
            }
        }
    }
    else
    {
        // unable to enter the CS -- this can happen only in extremely low memory conditions!
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// export for printui. uses standard namespace stuff
STDAPI_(void) Printer_LoadIcons(LPCTSTR pszPrinterName, HICON *phLargeIcon, HICON *phSmallIcon)
{
    if (phLargeIcon) *phLargeIcon = NULL;
    if (phSmallIcon) *phSmallIcon = NULL;

    LPITEMIDLIST pidl;
    if (SUCCEEDED(ParsePrinterNameEx(pszPrinterName, &pidl, TRUE, 0, 0)))
    {
        SHFILEINFO sfi;

        if (phLargeIcon && SHGetFileInfo((LPCTSTR)pidl, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_PIDL))
        {
            *phLargeIcon = sfi.hIcon;
        }

        if (phSmallIcon && SHGetFileInfo((LPCTSTR)pidl, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_SMALLICON | SHGFI_PIDL))
        {
            *phSmallIcon = sfi.hIcon;
        }
        ILFree(pidl);
    }

    // if above fails fallback to default icons
    if (phLargeIcon && (NULL == *phLargeIcon))
        *phLargeIcon = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_PRINTER), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
    if (phSmallIcon && (NULL == *phSmallIcon))
        *phSmallIcon = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_PRINTER), IMAGE_ICON, g_cxSmIcon, g_cxSmIcon, 0);
}

typedef struct
{
    USHORT              cb;
    SHCNF_PRINTJOB_DATA data;
    USHORT              uTerm;
} IDPRINTJOB, *LPIDPRINTJOB;
typedef const IDPRINTJOB *LPCIDPRINTJOB;

void Printjob_FillPidl(LPIDPRINTJOB pidl, LPSHCNF_PRINTJOB_DATA pData)
{
    pidl->cb = FIELD_OFFSET(IDPRINTJOB, uTerm);
    if (pData)
    {
        pidl->data = *pData;
    }
    else
    {
        ZeroMemory(&(pidl->data), sizeof(SHCNF_PRINTJOB_DATA));
    }
    pidl->uTerm = 0;
}

LPITEMIDLIST Printjob_GetPidl(LPCTSTR szName, LPSHCNF_PRINTJOB_DATA pData)
{
    LPITEMIDLIST pidl = NULL;

    LPITEMIDLIST pidlParent;
    if (SUCCEEDED(ParsePrinterNameEx(szName, &pidlParent, TRUE, 0, 0)))
    {
        IDPRINTJOB idj;
        Printjob_FillPidl(&idj, pData);
        pidl = ILCombine(pidlParent, (LPITEMIDLIST)&idj);
        ILFree(pidlParent);
    }

    return pidl;
}

const struct
{
    DWORD bit;          // bit of a bitfield
    UINT  uStringID;    // the string id this bit maps to
}
c_map_bit_to_status[] =
{
    PRINTER_STATUS_PAUSED,              IDS_PRQSTATUS_PAUSED,
    PRINTER_STATUS_ERROR,               IDS_PRQSTATUS_ERROR,
    PRINTER_STATUS_PENDING_DELETION,    IDS_PRQSTATUS_PENDING_DELETION,
    PRINTER_STATUS_PAPER_JAM,           IDS_PRQSTATUS_PAPER_JAM,
    PRINTER_STATUS_PAPER_OUT,           IDS_PRQSTATUS_PAPER_OUT,
    PRINTER_STATUS_MANUAL_FEED,         IDS_PRQSTATUS_MANUAL_FEED,
    PRINTER_STATUS_PAPER_PROBLEM,       IDS_PRQSTATUS_PAPER_PROBLEM,
    PRINTER_STATUS_OFFLINE,             IDS_PRQSTATUS_OFFLINE,
    PRINTER_STATUS_IO_ACTIVE,           IDS_PRQSTATUS_IO_ACTIVE,
    PRINTER_STATUS_BUSY,                IDS_PRQSTATUS_BUSY,
    PRINTER_STATUS_PRINTING,            IDS_PRQSTATUS_PRINTING,
    PRINTER_STATUS_OUTPUT_BIN_FULL,     IDS_PRQSTATUS_OUTPUT_BIN_FULL,
    PRINTER_STATUS_NOT_AVAILABLE,       IDS_PRQSTATUS_NOT_AVAILABLE,
    PRINTER_STATUS_WAITING,             IDS_PRQSTATUS_WAITING,
    PRINTER_STATUS_PROCESSING,          IDS_PRQSTATUS_PROCESSING,
    PRINTER_STATUS_INITIALIZING,        IDS_PRQSTATUS_INITIALIZING,
    PRINTER_STATUS_WARMING_UP,          IDS_PRQSTATUS_WARMING_UP,
    PRINTER_STATUS_TONER_LOW,           IDS_PRQSTATUS_TONER_LOW,
    PRINTER_STATUS_NO_TONER,            IDS_PRQSTATUS_NO_TONER,
    PRINTER_STATUS_PAGE_PUNT,           IDS_PRQSTATUS_PAGE_PUNT,
    PRINTER_STATUS_USER_INTERVENTION,   IDS_PRQSTATUS_USER_INTERVENTION,
    PRINTER_STATUS_OUT_OF_MEMORY,       IDS_PRQSTATUS_OUT_OF_MEMORY,
    PRINTER_STATUS_DOOR_OPEN,           IDS_PRQSTATUS_DOOR_OPEN,

    PRINTER_HACK_WORK_OFFLINE,          IDS_PRQSTATUS_WORK_OFFLINE,
} ;



// maps bits into a string representation, putting
// the string idsSep in between each found bit.
// Returns the size of the created string.
UINT Printer_BitsToString(DWORD bits, UINT idsSep, LPTSTR lpszBuf, UINT cchMax)
{
    UINT cchBuf = 0;
    UINT cchSep = 0;
    TCHAR szSep[20];

    if (LoadString(HINST_THISDLL, idsSep, szSep, ARRAYSIZE(szSep)))
        cchSep = lstrlen(szSep);

    for (UINT i = 0; i < ARRAYSIZE(c_map_bit_to_status); i++)
    {
        if (bits & c_map_bit_to_status[i].bit)
        {
            TCHAR szTmp[258];

            if (LoadString(HINST_THISDLL, c_map_bit_to_status[i].uStringID, szTmp, ARRAYSIZE(szTmp)))
            {
                UINT cchTmp = lstrlen(szTmp);

                if (cchBuf + cchSep + cchTmp < cchMax)
                {
                    if (cchBuf)
                    {
                        StringCchCat(lpszBuf, cchMax, szSep);
                        cchBuf += cchSep;
                    }
                    StringCchCat(lpszBuf, cchMax, szTmp);
                    cchBuf += cchTmp;
                }
            }
        }
    }

    return cchBuf;
}

STDMETHODIMP CPrinterFolderViewCB::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_INVOKECOMMAND, OnINVOKECOMMAND);
    HANDLE_MSG(0, SFVM_GETHELPTEXT, OnGETHELPTEXT);
    HANDLE_MSG(0, SFVM_BACKGROUNDENUM, OnBACKGROUNDENUM);
    HANDLE_MSG(0, SFVM_GETHELPTOPIC, OnGETHELPTOPIC);
    HANDLE_MSG(0, SFVM_REFRESH, OnREFRESH);
    HANDLE_MSG(0, SFVM_DELAYWINDOWCREATE, OnDELAYWINDOWCREATE);
    HANDLE_MSG(0, SFVM_GETDEFERREDVIEWSETTINGS, OnDEFERRED_VIEW_SETTING);

    // DUI webview commands
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, OnGetWebViewContent);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTASKS, OnGetWebViewTasks);

    default:
        return E_FAIL;
    }

    return S_OK;
}

STDMETHODIMP CPrinterFolderViewCB::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    IUnknown *punkThis = static_cast<IServiceProvider*>(this);
    IUnknown *punkSite = NULL;
    HRESULT hr = E_NOINTERFACE;

    //
    // we are going to use IServiceProvider to be able to query the callback for some
    // core interfaces associated with it (like IShellFolderView and IShellFolder, etc...).
    // basically the idea is that we try QueryService/QueryInterafce on the printer's
    // folder first and then if it fails we try our current site which supposedly will
    // be defview.
    //

    if (_ppf)
    {
        IUnknown *punkPF = static_cast<IShellFolder*>(_ppf);

        // try QueryService on the printer's folder
        if (SUCCEEDED(hr = IUnknown_QueryService(punkPF, riid, riid, ppv)))
            goto Exit;

        // try QueryInterface on the printer's folder
        if (SUCCEEDED(hr = punkPF->QueryInterface(riid, ppv)))
            goto Exit;
    }

    if (FAILED(hr) && (SUCCEEDED(hr = IUnknown_GetSite(punkThis, IID_PPV_ARG(IUnknown, &punkSite)))))
    {
        ASSERT(punkSite);

        // try QueryService on the site object
        if (SUCCEEDED(hr = IUnknown_QueryService(punkSite, riid, riid, ppv)))
            goto Exit;

        // try QueryInterface on the site object
        if (SUCCEEDED(hr = punkSite->QueryInterface(riid, ppv)))
            goto Exit;
    }
    else
    {
        ASSERT(NULL == punkSite);
    }

Exit:
    if (punkSite)
    {
        punkSite->Release();
    }
    return hr;
}

// shell32.dll export, from srch.exe results no one uses this
STDAPI Printers_GetPidl(LPCITEMIDLIST pidlParent, LPCTSTR pszPrinterName, DWORD dwType, LPITEMIDLIST *ppidl)
{
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\prop.cpp ===
#include "shellprv.h"

#include "prop.h"
#include <ntquery.h>    // defines some values used for fmtid and pid
#include "findfilter.h" // includes oledb (which defines some values used for fmtid and pid) properly
#include "ids.h"
#include "imgprop.h"
#include <gdiplus\gdiplus.h> // for PropertyTag* definitions

#define MAX_UTF8_CHAR_SIZE        (sizeof(CHAR) * 3)

//  FMTID_ExeDllInformation,
//// {0CEF7D53-FA64-11d1-A203-0000F81FEDEE}
#define PSFMTID_VERSION { 0xcef7d53, 0xfa64, 0x11d1, 0xa2, 0x3, 0x0, 0x0, 0xf8, 0x1f, 0xed, 0xee }

#define PIDVSI_FileDescription   0x003
#define PIDVSI_FileVersion       0x004
#define PIDVSI_InternalName      0x005
#define PIDVSI_OriginalFileName  0x006
#define PIDVSI_ProductName       0x007
#define PIDVSI_ProductVersion    0x008

#define TIFFTAG_FAX_END_TIME            40052
#define TIFFTAG_SENDER_NAME             40021
#define TIFFTAG_TSID                    40002
#define TIFFTAG_CALLERID                40005
#define TIFFTAG_RECIP_NAME              40006
#define TIFFTAG_RECIP_NUMBER            40007
#define TIFFTAG_CSID                    40001
#define TIFFTAG_ROUTING                 40004


// Internal PSGUID/PIDs
//
// Note:
//  This section was added to allow SCIDs to be defined without exposing them
//  externally (via public header files).  In this way, we can define SCIDs
//  without having to worry about maintaining external support for them in
//  future.

// {8D72ACA1-0716-419a-9AC1-ACB07B18DC32}
#define PSGUID_PRV_STORAGE  {0x8d72aca1, 0x716, 0x419a, 0x9a, 0xc1, 0xac, 0xb0, 0x7b, 0x18, 0xdc, 0x32}
#define PID_PRV_STG_ATTRIBUTES_DESCRIPTION  2


DEFINE_SCID(SCID_Author                             , PSGUID_SUMMARYINFORMATION             , PIDSI_AUTHOR); 
DEFINE_SCID(SCID_LastAuthor                         , PSGUID_SUMMARYINFORMATION             , PIDSI_LASTAUTHOR);
DEFINE_SCID(SCID_RevNumber                          , PSGUID_SUMMARYINFORMATION             , PIDSI_REVNUMBER);
DEFINE_SCID(SCID_AppName                            , PSGUID_SUMMARYINFORMATION             , PIDSI_APPNAME);
DEFINE_SCID(SCID_Title                              , PSGUID_SUMMARYINFORMATION             , PIDSI_TITLE);
DEFINE_SCID(SCID_Subject                            , PSGUID_SUMMARYINFORMATION             , PIDSI_SUBJECT);
DEFINE_SCID(SCID_Category                           , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_CATEGORY);
DEFINE_SCID(SCID_Keywords                           , PSGUID_SUMMARYINFORMATION             , PIDSI_KEYWORDS );
DEFINE_SCID(SCID_Rating                             , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_RATING );
DEFINE_SCID(SCID_Template                           , PSGUID_SUMMARYINFORMATION             , PIDSI_TEMPLATE );
DEFINE_SCID(SCID_Copyright                          , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_COPYRIGHT);
DEFINE_SCID(SCID_CompanyName                        , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_COMPANY);
DEFINE_SCID(SCID_Manager                            , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_MANAGER);
DEFINE_SCID(SCID_PresFormat                         , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_PRESFORMAT);
DEFINE_SCID(SCID_PageCount                          , PSGUID_SUMMARYINFORMATION             , PIDSI_PAGECOUNT);
DEFINE_SCID(SCID_Comment                            , PSGUID_SUMMARYINFORMATION             , PIDSI_COMMENTS);
DEFINE_SCID(SCID_DocCreated                         , PSGUID_SUMMARYINFORMATION             , PIDSI_CREATE_DTM);   // in the doc, not file system
DEFINE_SCID(SCID_WordCount                          , PSGUID_SUMMARYINFORMATION             , PIDSI_WORDCOUNT);
DEFINE_SCID(SCID_CharCount                          , PSGUID_SUMMARYINFORMATION             , PIDSI_CHARCOUNT);
DEFINE_SCID(SCID_LastSaveDTM                        , PSGUID_SUMMARYINFORMATION             , PIDSI_LASTSAVE_DTM);
DEFINE_SCID(SCID_LastPrinted                        , PSGUID_SUMMARYINFORMATION             , PIDSI_LASTPRINTED);
DEFINE_SCID(SCID_EditTime                           , PSGUID_SUMMARYINFORMATION             , PIDSI_EDITTIME);
DEFINE_SCID(SCID_ByteCount                          , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_BYTECOUNT);
DEFINE_SCID(SCID_LineCount                          , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_LINECOUNT);
DEFINE_SCID(SCID_ParagraphCount                     , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_PARCOUNT);
DEFINE_SCID(SCID_SlideCount                         , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_SLIDECOUNT);
DEFINE_SCID(SCID_NoteCount                          , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_NOTECOUNT);
DEFINE_SCID(SCID_HiddenCount                        , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_HIDDENCOUNT);
DEFINE_SCID(SCID_MMClipCount                        , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_MMCLIPCOUNT);
DEFINE_SCID(SCID_Scale                              , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_SCALE);
DEFINE_SCID(SCID_LinksDirty                         , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_LINKSDIRTY);
DEFINE_SCID(SCID_TYPE                               , PSGUID_STORAGE                        , PID_STG_STORAGETYPE);
DEFINE_SCID(SCID_NAME                               , PSGUID_STORAGE                        , PID_STG_NAME);
DEFINE_SCID(SCID_SIZE                               , PSGUID_STORAGE                        , PID_STG_SIZE);
DEFINE_SCID(SCID_ATTRIBUTES                         , PSGUID_STORAGE                        , PID_STG_ATTRIBUTES);
DEFINE_SCID(SCID_WRITETIME                          , PSGUID_STORAGE                        , PID_STG_WRITETIME);
DEFINE_SCID(SCID_CREATETIME                         , PSGUID_STORAGE                        , PID_STG_CREATETIME);
DEFINE_SCID(SCID_ACCESSTIME                         , PSGUID_STORAGE                        , PID_STG_ACCESSTIME);
DEFINE_SCID(SCID_DIRECTORY                          , PSGUID_STORAGE                        , PID_STG_DIRECTORY);
DEFINE_SCID(SCID_FREESPACE                          , PSGUID_VOLUME                         , PID_VOLUME_FREE);
DEFINE_SCID(SCID_CAPACITY                           , PSGUID_VOLUME                         , PID_VOLUME_CAPACITY);
DEFINE_SCID(SCID_FILESYSTEM                         , PSGUID_VOLUME                         , PID_VOLUME_FILESYSTEM);
DEFINE_SCID(SCID_DELETEDFROM                        , PSGUID_DISPLACED                      , PID_DISPLACED_FROM);
DEFINE_SCID(SCID_DATEDELETED                        , PSGUID_DISPLACED                      , PID_DISPLACED_DATE);
DEFINE_SCID(SCID_SYNCCOPYIN                         , PSGUID_BRIEFCASE                      , PID_SYNC_COPY_IN);
DEFINE_SCID(SCID_RANK                               , PSGUID_QUERY_D                        , PID_QUERY_RANK);
DEFINE_SCID(SCID_LASTVISITED                        , PSGUID_INTERNETSITE                   , PID_INTSITE_LASTVISIT);
DEFINE_SCID(SCID_LASTMODIFIED                       , PSGUID_INTERNETSITE                   , PID_INTSITE_LASTMOD);
DEFINE_SCID(SCID_VISITCOUNT                         , PSGUID_INTERNETSITE                   , PID_INTSITE_VISITCOUNT);
DEFINE_SCID(SCID_STATUS                             , PSGUID_INTERNETSITE                   , PID_INTSITE_FLAGS);
DEFINE_SCID(SCID_FINDDATA                           , PSGUID_SHELLDETAILS                   , PID_FINDDATA);
DEFINE_SCID(SCID_NETRESOURCE                        , PSGUID_SHELLDETAILS                   , PID_NETRESOURCE);
DEFINE_SCID(SCID_DESCRIPTIONID                      , PSGUID_SHELLDETAILS                   , PID_DESCRIPTIONID);
DEFINE_SCID(SCID_WHICHFOLDER                        , PSGUID_SHELLDETAILS                   , PID_WHICHFOLDER);
DEFINE_SCID(SCID_NETWORKLOCATION                    , PSGUID_SHELLDETAILS                   , PID_NETWORKLOCATION);
DEFINE_SCID(SCID_COMPUTERNAME                       , PSGUID_SHELLDETAILS                   , PID_COMPUTERNAME);
DEFINE_SCID(SCID_OWNER                              , PSGUID_MISC                           , PID_MISC_OWNER);
// DEFINE_SCID(SCID_STATUS                          , PSGUID_MISC                            , PID_MISC_STATUS);
// DEFINE_SCID(SCID_ACCESSCOUNT                     , PSGUID_MISC                            , PID_MISC_ACCESSCOUNT);
DEFINE_SCID(SCID_DetailsProperties                  , PSGUID_WEBVIEW                        , PID_DISPLAY_PROPERTIES);
DEFINE_SCID(SCID_FolderIntroText                    , PSGUID_WEBVIEW                        , PID_INTROTEXT);
DEFINE_SCID(SCID_CONTROLPANELCATEGORY               , PSGUID_CONTROLPANEL                   , PID_CONTROLPANEL_CATEGORY);
DEFINE_SCID(SCID_MUSIC_Artist                       , PSGUID_MUSIC                          , PIDSI_ARTIST);
DEFINE_SCID(SCID_MUSIC_Album                        , PSGUID_MUSIC                          , PIDSI_ALBUM);
DEFINE_SCID(SCID_MUSIC_Year                         , PSGUID_MUSIC                          , PIDSI_YEAR);
DEFINE_SCID(SCID_MUSIC_Track                        , PSGUID_MUSIC                          , PIDSI_TRACK);
DEFINE_SCID(SCID_MUSIC_Genre                        , PSGUID_MUSIC                          , PIDSI_GENRE);
DEFINE_SCID(SCID_MUSIC_Lyrics                       , PSGUID_MUSIC                          , PIDSI_LYRICS);
DEFINE_SCID(SCID_DRM_Protected                      , PSGUID_DRM                            , PIDDRSI_PROTECTED);
DEFINE_SCID(SCID_DRM_Description                    , PSGUID_DRM                            , PIDDRSI_DESCRIPTION);
DEFINE_SCID(SCID_DRM_PlayCount                      , PSGUID_DRM                            , PIDDRSI_PLAYCOUNT);
DEFINE_SCID(SCID_DRM_PlayStarts                     , PSGUID_DRM                            , PIDDRSI_PLAYSTARTS);
DEFINE_SC