tructs merge structures and fucb
//
ERR LOG::ErrLGRIRedoMergeStructures( PIB		*ppib,
									 DBTIME		dbtime,
									 MERGEPATH	**ppmergePathLeaf, 
									 FUCB		**ppfucb )
	{
	ERR				err;
	const LRMERGE	*plrmerge	= (LRMERGE *) ppib->PvLogrec( dbtime );
	const DBID		dbid 		= plrmerge->dbid;
	const PGNO		pgnoFDP		= plrmerge->le_pgnoFDP;
	const OBJID		objidFDP	= plrmerge->le_objidFDP;	// Debug only info
	const BOOL		fUnique		= plrmerge->FUnique();
	const BOOL		fSpace		= plrmerge->FSpace();

	INST			*pinst = PinstFromPpib( ppib );
	IFMP			ifmp = pinst->m_mpdbidifmp[ dbid ];

	for ( INT ibNextLR = 0; 
		  ibNextLR < ppib->CbSizeLogrec( dbtime ); 
		  ibNextLR += CbLGSizeOfRec( plrmerge ) )
		{
		plrmerge = (LRMERGE *) ( (BYTE *) ppib->PvLogrec( dbtime ) + ibNextLR );
		Assert( lrtypMerge == plrmerge->lrtyp );

		//	insert and initialize mergePath for this level
		//
		Call( ErrLGIRedoMergePath( ppib, plrmerge, ppmergePathLeaf ) );
		}

	//	get fucb
	//
	Assert( pfucbNil == *ppfucb );
	Call( ErrLGRIGetFucb( m_ptablehfhash, ppib, ifmp, pgnoFDP, objidFDP, fUnique, fSpace, ppfucb ) );

	//	initialize rglineinfo for leaf level of merge
	//
	Assert( NULL != *ppmergePathLeaf );
	Assert( NULL == (*ppmergePathLeaf)->pmergePathChild );

	Call( ErrLGRIRedoInitializeMerge( ppib, *ppfucb, plrmerge, *ppmergePathLeaf ) );
	
HandleError:
	return err;
	}

	
//	reconstructs split structures, FUCB, dirflag and kdf for split
//
ERR LOG::ErrLGIRedoSplitStructures(
	PIB				*ppib,
	DBTIME			dbtime,
	SPLITPATH		**ppsplitPathLeaf,
	FUCB			**ppfucb,
	DIRFLAG			*pdirflag,
	KEYDATAFLAGS	*pkdf,
	RCEID			*prceidOper1,
	RCEID			*prceidOper2 )
	{
	ERR				err;
	LR				*plr;
	SPLITPATH		*psplitPath;
	const LRSPLIT	*plrsplit	= (LRSPLIT *) ppib->PvLogrec( dbtime );
	const DBID		dbid 		= plrsplit->dbid;
	const PGNO		pgnoFDP		= plrsplit->le_pgnoFDP;
	const OBJID		objidFDP	= plrsplit->le_objidFDP;
	IFMP			ifmp;

	Assert(	dbtime	== plrsplit->le_dbtime );
	
	//	split with no oper will use the space fucb
	//
	BOOL			fUnique 	= plrsplit->FUnique();
	BOOL			fSpace		= fTrue;

	Assert( rceidNull == *prceidOper1 );
	Assert( rceidNull == *prceidOper2 );
	
	pkdf->Nullify();
	Assert( fDIRNull == *pdirflag );
	
	for ( INT ibNextLR = 0; 
		  ibNextLR < ppib->CbSizeLogrec( dbtime ); 
		  ibNextLR += CbLGSizeOfRec( plr ) )
		{
		plr = (LR *) ( (BYTE *)ppib->PvLogrec( dbtime ) + ibNextLR );
		switch( plr->lrtyp )
			{
			case lrtypSplit:
				{
				const LRSPLIT	*plrsplitT = (LRSPLIT *) plr;

				Assert( dbtime == plrsplitT->le_dbtime );
				Assert( pgnoFDP == plrsplitT->le_pgnoFDP );
				Call( ErrLGRIRedoSplitPath( ppib, plrsplitT, ppsplitPathLeaf ) );
				}
				break;
				
			case lrtypInsert:
				{
				LRINSERT	*plrinsert = (LRINSERT *) plr;

				pkdf->key.suffix.SetPv( (BYTE *) plrinsert + sizeof( LRINSERT ) );
				pkdf->key.suffix.SetCb( plrinsert->CbPrefix() + plrinsert->CbSuffix() );

				pkdf->data.SetPv( (BYTE *) plrinsert + 
								  sizeof( LRINSERT ) +
								  plrinsert->CbPrefix() + 
								  plrinsert->CbSuffix() );
				pkdf->data.SetCb( plrinsert->CbData() );
				*pdirflag |= fDIRInsert;

				*prceidOper1 = plrinsert->le_rceid;
				}
				break;
				
			case lrtypFlagInsertAndReplaceData:
				{
				LRFLAGINSERTANDREPLACEDATA	*plrfiard = (LRFLAGINSERTANDREPLACEDATA *) plr;

				pkdf->key.prefix.Nullify();
				pkdf->key.suffix.SetCb( plrfiard->CbKey() );
				pkdf->key.suffix.SetPv( plrfiard->rgbData );
				pkdf->data.SetPv( (BYTE *) plrfiard + 
								  sizeof( LRFLAGINSERTANDREPLACEDATA ) +
								  plrfiard->CbKey() );
				pkdf->data.SetCb( plrfiard->CbData() );

				*pdirflag 		|= fDIRFlagInsertAndReplaceData;
				*prceidOper1	= plrfiard->le_rceid;
				*prceidOper2	= plrfiard->le_rceidReplace;
				}
				break;
				
			case lrtypReplace:
				{
				LRREPLACE	*plrreplace = (LRREPLACE *) plr;

				pkdf->data.SetPv( (BYTE *) plrreplace + sizeof ( LRREPLACE ) );
				pkdf->data.SetCb( plrreplace->CbNewData() );

				*pdirflag		|= fDIRReplace;
				*prceidOper1	= plrreplace->le_rceid;
				}
				break;
				
			default:
				Assert( fFalse );
				break;
			}

		if ( lrtypSplit != plr->lrtyp )
			{
			//	get fUnique and dirflag
			//
			const LRNODE_	*plrnode	= (LRNODE_ *) plr;

			Assert(	plrnode->le_pgnoFDP == pgnoFDP );
			Assert( plrnode->dbid == dbid );
			Assert( plrnode->le_dbtime == dbtime );

			fUnique		= plrnode->FUnique();
			fSpace		= plrnode->FSpace();

			if ( !plrnode->FVersioned() )
				*pdirflag |= fDIRNoVersion;
			}
		}


	ifmp = PinstFromPpib( ppib )->m_mpdbidifmp[ dbid ];
	
	//	get fucb
	//
	Assert( pfucbNil == *ppfucb );
	Call( ErrLGRIGetFucb( m_ptablehfhash, ppib, ifmp, pgnoFDP, objidFDP, fUnique, fSpace, ppfucb ) );

	//	initialize rglineinfo for every level of split
	//
	for ( psplitPath = *ppsplitPathLeaf; 
		  psplitPath != NULL;
		  psplitPath = psplitPath->psplitPathParent )
		{
		Assert( latchRIW == psplitPath->csr.Latch() );
 		
		err = JET_errSuccess;
		if ( psplitPath->psplit != NULL
			&& ( FLGNeedRedoCheckDbtimeBefore( psplitPath->csr, dbtime, psplitPath->dbtimeBefore, &err )
			 	|| FLGNeedRedoPage( psplitPath->psplit->csrNew, dbtime ) ) )
			{
			Call( err );
			
#ifdef DEBUG
			ERR			errT;
			SPLIT*		psplit			= psplitPath->psplit;
			Assert( NULL != psplit );

			const BOOL	fRedoSplitPage	= FLGNeedRedoCheckDbtimeBefore(
												psplitPath->csr,
												dbtime,
												psplitPath->dbtimeBefore,
												&errT );
			const BOOL	fRedoNewPage	= FLGNeedRedoPage( psplit->csrNew, dbtime );
			CallS( errT );

			if ( !fRedoSplitPage )
				{
				Assert( fRedoNewPage );
				Assert( !FBTISplitDependencyRequired( psplit ) );
				}
#endif

			//	if split page needs redo
			//		allocate and set lineinfo for split page
			//
			Call( ErrLGIRedoSplitLineinfo(
						*ppfucb, 
						psplitPath,
						dbtime,
						( psplitPath == *ppsplitPathLeaf ?
								*pkdf :
								psplitPath->psplitPathChild->psplit->kdfParent ) ) );
			}
		}

HandleError:
	return err;
	}


//	updates dbtime to given value on all write-latched pages
//
LOCAL VOID LGIRedoMergeUpdateDbtime( MERGEPATH *pmergePathLeaf, DBTIME dbtime )
	{
	MERGEPATH	*pmergePath = pmergePathLeaf;
	
	for ( ; pmergePath != NULL; pmergePath = pmergePath->pmergePathParent )
		{
		LGRIRedoDirtyAndSetDbtime( &pmergePath->csr, dbtime );

		MERGE	*pmerge = pmergePath->pmerge;
		if ( pmerge != NULL )
			{
			LGRIRedoDirtyAndSetDbtime( &pmerge->csrLeft, dbtime );
			LGRIRedoDirtyAndSetDbtime( &pmerge->csrRight, dbtime );
			}
		}
		
	return;
	}


//	updates dbtime to given value on all write-latched pages
//
LOCAL VOID LGIRedoSplitUpdateDbtime( SPLITPATH *psplitPathLeaf, DBTIME dbtime )
	{
	SPLITPATH	*psplitPath = psplitPathLeaf;
	
	for ( ; psplitPath != NULL; psplitPath = psplitPath->psplitPathParent )
		{
		LGRIRedoDirtyAndSetDbtime( &psplitPath->csr, dbtime );

		SPLIT	*psplit = psplitPath->psplit;
		if ( psplit != NULL )
			{
			LGRIRedoDirtyAndSetDbtime( &psplit->csrNew, dbtime );
			LGRIRedoDirtyAndSetDbtime( &psplit->csrRight, dbtime );
			}
		}
		
	return;
	}


//	creates version for operation performed atomically with split
//		also links version into appropriate lists
//
ERR	ErrLGIRedoSplitCreateVersion(
	SPLIT				*psplit, 
	FUCB				*pfucb,
	const KEYDATAFLAGS&	kdf,
	const DIRFLAG		dirflag,
	const RCEID			rceidOper1,
	const RCEID			rceidOper2,
	const LEVEL			level )
	{
	ERR					err	= JET_errSuccess;


	Assert( splitoperInsert == psplit->splitoper
		|| splitoperReplace == psplit->splitoper
		|| splitoperFlagInsertAndReplaceData == psplit->splitoper );

	Assert( pfucb->ppib->FAfterFirstBT() );

	Assert( rceidOper1 != rceidNull );
	Assert( splitoperFlagInsertAndReplaceData != psplit->splitoper
		|| rceidOper2 != rceidNull );
	Assert( psplit->fNewPageFlags & CPAGE::fPageLeaf );

	RCE			*prceOper1	= prceNil;
	RCE			*prceOper2	= prceNil;
	const BOOL	fNeedRedo	= ( psplit->ilineOper < psplit->ilineSplit ?
										latchWrite == psplit->psplitPath->csr.Latch() :
										latchWrite == psplit->csrNew.Latch() );
		
	VERPROXY	verproxy;

	verproxy.rceid = rceidOper1;
	verproxy.level = level;
	verproxy.proxy = proxyRedo;

	if ( splitoperReplace == psplit->splitoper )
		{
		//	create version only if page with oper needs redo
		//
		if ( !fNeedRedo )
			{
			Assert( pfucb->bmCurr.key.FNull() );
			goto HandleError;
			}

		Assert( latchWrite == psplit->psplitPath->csr.Latch() ); 
		Assert( dirflag & fDIRReplace );
		Assert( FFUCBUnique( pfucb ) );
		Assert( !pfucb->bmCurr.key.FNull() );

		Call( PverFromPpib( pfucb->ppib )->ErrVERModify( pfucb, pfucb->bmCurr, operReplace, &prceOper1, &verproxy ) );
		}
	else
		{
		Assert( splitoperFlagInsertAndReplaceData == psplit->splitoper ||
				splitoperInsert == psplit->splitoper );
		Assert( ( dirflag & fDIRInsert ) ||
				( dirflag & fDIRFlagInsertAndReplaceData ) );

		//	create version for insert even if oper needs no redo
		//
		BOOKMARK	bm;
		NDGetBookmarkFromKDF( pfucb, kdf, &bm );
		Call( PverFromPpib( pfucb->ppib )->ErrVERModify( pfucb, bm, operInsert, &prceOper1, &verproxy ) );

		//	create version for replace if oper needs redo
		//
		if ( splitoperFlagInsertAndReplaceData == psplit->splitoper
			&& fNeedRedo )
			{
			Assert( dirflag & fDIRFlagInsertAndReplaceData );
			verproxy.rceid = rceidOper2;
			BTISplitGetReplacedNode( pfucb, psplit );
			Call( PverFromPpib( pfucb->ppib )->ErrVERModify( pfucb, bm, operReplace, &prceOper2, &verproxy ) );
			}
		}

	//	link RCE(s) to lists
	//
	Assert( prceNil != prceOper1 );
	Assert( splitoperFlagInsertAndReplaceData == psplit->splitoper &&
				( prceNil != prceOper2 || !fNeedRedo ) ||
			splitoperFlagInsertAndReplaceData != psplit->splitoper &&
				prceNil == prceOper2 );
	BTISplitInsertIntoRCELists( pfucb, 
								psplit->psplitPath, 
								&kdf, 
								prceOper1, 
								prceOper2, 
								&verproxy );

HandleError:
	return err;
	}


//	upgrades latches on pages that need redo
//
LOCAL ERR ErrLGIRedoMergeUpgradeLatches( MERGEPATH *pmergePathLeaf, DBTIME dbtime )
	{
	ERR			err			= JET_errSuccess;
	MERGEPATH*	pmergePath;

	for ( pmergePath = pmergePathLeaf;
		  pmergePath != NULL; 
		  pmergePath = pmergePath->pmergePathParent )
		{
		Assert( pmergePath->csr.FLatched() );
		Assert( latchRIW == pmergePath->csr.Latch() );

 		if ( FLGNeedRedoCheckDbtimeBefore( pmergePath->csr, dbtime, pmergePath->dbtimeBefore, &err ) )
			{
			Call( err );
			pmergePath->csr.UpgradeFromRIWLatch();
			}
		CallS( err );
			
		MERGE	*pmerge = pmergePath->pmerge;
		if ( pmerge != NULL )
			{
			Assert( pmergePath == pmergePathLeaf );
			Assert( ( pgnoNull == pmerge->csrRight.Pgno()
						&& !pmerge->csrRight.FLatched() )
				|| latchRIW == pmerge->csrRight.Latch() );

			if ( pmerge->csrRight.FLatched() && FLGNeedRedoCheckDbtimeBefore( pmerge->csrRight, dbtime, pmerge->dbtimeRightBefore, &err ) )
				{
				Call( err );
				pmerge->csrRight.UpgradeFromRIWLatch();
				}
			CallS( err );

			Assert( ( pgnoNull == pmerge->csrLeft.Pgno()
						&& !pmerge->csrLeft.FLatched() )
				|| latchRIW == pmerge->csrLeft.Latch() );

			if ( pmerge->csrLeft.FLatched() && FLGNeedRedoCheckDbtimeBefore( pmerge->csrLeft, dbtime, pmerge->dbtimeLeftBefore, &err ) )
				{
				Call( err );
				pmerge->csrLeft.UpgradeFromRIWLatch();
				}
			CallS( err );
			}
		}
HandleError:		
	return err;
	}


//	recovers a merge or an empty page operation 
//		with accompanying node delete operations
//	
ERR LOG::ErrLGRIRedoMerge( PIB *ppib, DBTIME dbtime )
	{
	ERR				err;
	const LRMERGE	*plrmerge	= (LRMERGE *) ppib->PvLogrec( dbtime );
	const DBID		dbid 		= plrmerge->dbid;

	Assert( lrtypMerge == plrmerge->lrtyp );
	Assert( dbtime	== plrmerge->le_dbtime );
	
	const OBJID		objidFDP	= plrmerge->le_objidFDP;
	MERGEPATH		*pmergePathLeaf = NULL;
	
	Assert( ppib->FMacroGoing( dbtime ) );
	BOOL fSkip;
	CallR( ErrLGRICheckRedoCondition(
				dbid,
				dbtime,
				objidFDP,
				ppib,
				fFalse,
				&fSkip ) );
	if ( fSkip )
		return JET_errSuccess;
		
	//	reconstructs merge structures write-latching pages that need redo
	//
	FUCB			*pfucb = pfucbNil;
	
	Call( ErrLGRIRedoMergeStructures( ppib, 
									  dbtime,
									  &pmergePathLeaf, 
									  &pfucb ) );
	Assert( pmergePathLeaf != NULL );
	Assert( pmergePathLeaf->pmerge != NULL );

	Assert( pfucb->bmCurr.key.FNull() );
	Assert( pfucb->bmCurr.data.FNull() );

	//	write latch pages that need redo
	//
	Call( ErrLGIRedoMergeUpgradeLatches( pmergePathLeaf, dbtime ) );
	
	//	sets dirty and dbtime on all updated pages
	//
	LGIRedoMergeUpdateDbtime( pmergePathLeaf, dbtime );
	
	//	calls BTIPerformSplit
	//
	BTIPerformMerge( pfucb, pmergePathLeaf );
	
HandleError:
	//	release latches
	//
	if ( pmergePathLeaf != NULL )
		{
		BTIReleaseMergePaths( pmergePathLeaf );
		}

	return err;
	}

//	upgrades latches on pages that need redo
//
LOCAL ERR ErrLGIRedoSplitUpgradeLatches( SPLITPATH *psplitPathLeaf, DBTIME dbtime )
	{
	ERR			err			= JET_errSuccess;
	SPLITPATH*	psplitPath;
	
	for ( psplitPath = psplitPathLeaf;
		  psplitPath != NULL; 
		  psplitPath = psplitPath->psplitPathParent )
		{
		Assert( latchRIW == psplitPath->csr.Latch() );

		if ( FLGNeedRedoCheckDbtimeBefore( psplitPath->csr, dbtime, psplitPath->dbtimeBefore, &err ) )
			{
			Call ( err );
			psplitPath->csr.UpgradeFromRIWLatch();
			}
		CallS( err );

		SPLIT	*psplit = psplitPath->psplit;
		if ( psplit != NULL )
			{
			//	new page should already be write-latched if redo is needed
			//
#ifdef DEBUG			
			if ( FLGNeedRedoPage( psplit->csrNew, dbtime ) )
				{
				Assert( latchWrite == psplit->csrNew.Latch() );
				}
			else
				{
				Assert( latchRIW == psplit->csrNew.Latch() );
 				}

			if ( pgnoNull == psplit->csrRight.Pgno() )
				{
				Assert( !psplit->csrRight.FLatched() );
				}
			else
				{
				Assert( latchRIW == psplit->csrRight.Latch() );
 				}
#endif			

			if ( psplit->csrRight.FLatched() && FLGNeedRedoCheckDbtimeBefore( psplit->csrRight, dbtime, psplit->dbtimeRightBefore, &err ) )
				{
				Call( err );
				psplit->csrRight.UpgradeFromRIWLatch();
				}
			CallS( err );
			}
		}
HandleError:
	return err;
	}

	
//	recovers split operation
//		reconstructs split structures write-latching pages that need redo
//		creates version for operation
//		calls BTIPerformSplit
//		sets dbtime on all updated pages
//
ERR LOG::ErrLGRIRedoSplit( PIB *ppib, DBTIME dbtime )
	{
	ERR				err;
	const LRSPLIT	*plrsplit	= (LRSPLIT *) ppib->PvLogrec( dbtime );
	const DBID		dbid 		= plrsplit->dbid;

	Assert( lrtypSplit == plrsplit->lrtyp );
	Assert( ppib->FMacroGoing( dbtime ) );
	Assert( dbtime == plrsplit->le_dbtime );
	
	const LEVEL		level		= plrsplit->level;
	
	//	if operation was performed by concurrent CreateIndex, the
	//	updater could be at a higher trx level than when the
	//	indexer logged the operation
	Assert( level == ppib->level
			|| ( level < ppib->level && plrsplit->FConcCI() ) );

	const OBJID		objidFDP	= plrsplit->le_objidFDP;
	SPLITPATH		*psplitPathLeaf = NULL;
	
	BOOL fSkip;
	CallR( ErrLGRICheckRedoCondition(
				dbid,
				dbtime,
				objidFDP,
				ppib,
				fFalse,
				&fSkip ) );
	if ( fSkip )
		return JET_errSuccess;
		
	//	reconstructs split structures write-latching pages that need redo
	//
	FUCB			*pfucb				= pfucbNil;
	KEYDATAFLAGS	kdf;
	DIRFLAG			dirflag				= fDIRNull;	
	BOOL			fVersion;
	RCEID			rceidOper1			= rceidNull;
	RCEID			rceidOper2			= rceidNull;
	BOOL			fOperNeedsRedo		= fFalse;
	SPLIT			*psplit;
	BYTE			*rgb				= NULL;
//	BYTE			rgb[g_cbPageMax];
	
	Call( ErrLGIRedoSplitStructures( ppib, 
									 dbtime,
									 &psplitPathLeaf, 
									 &pfucb, 
									 &dirflag, 
									 &kdf,
									 &rceidOper1,
									 &rceidOper2 ) );
	Assert( psplitPathLeaf != NULL );
	Assert( psplitPathLeaf->psplit != NULL );

	Assert( pfucb->bmCurr.key.FNull() );
	Assert( pfucb->bmCurr.data.FNull() );

	//	upgrade latches on pages that need redo
	//
	Call ( ErrLGIRedoSplitUpgradeLatches( psplitPathLeaf, dbtime ) );
	
	psplit = psplitPathLeaf->psplit;

	Assert( !fOperNeedsRedo );		//	initial value
	if ( splitoperNone != psplit->splitoper )
		{
		if ( psplit->ilineOper < psplit->ilineSplit )
			{
			fOperNeedsRedo = ( latchWrite == psplitPathLeaf->csr.Latch() );
			}
		else
			{
			fOperNeedsRedo = ( latchWrite == psplit->csrNew.Latch() );
			}
		}
					  
	if ( splitoperReplace == psplitPathLeaf->psplit->splitoper
		&& fOperNeedsRedo )
		{
		//	copy bookmark to FUCB
		//
		BTISplitGetReplacedNode( pfucb, psplitPathLeaf->psplit );

		Assert( FFUCBUnique( pfucb ) );

		BFAlloc( (VOID **)&rgb );
		pfucb->kdfCurr.key.CopyIntoBuffer( rgb, g_cbPage );
		pfucb->bmCurr.key.suffix.SetPv( rgb );
		pfucb->bmCurr.key.suffix.SetCb( pfucb->kdfCurr.key.Cb() );
		}
	else if ( splitoperFlagInsertAndReplaceData == psplitPathLeaf->psplit->splitoper )
		{
		NDGetBookmarkFromKDF( pfucb, kdf, &pfucb->bmCurr );
		}

	//	creates version for operation
	//
	fVersion = !( dirflag & fDIRNoVersion ) &&
			   !rgfmp[ pfucb->ifmp ].FVersioningOff() && 
			   splitoperNone != psplitPathLeaf->psplit->splitoper;
								
	if ( fVersion )
		{
		Assert( rceidNull != rceidOper1 );
		Assert( level > 0 );
		Call( ErrLGIRedoSplitCreateVersion( psplitPathLeaf->psplit,
											pfucb,
											kdf,
											dirflag,
											rceidOper1,
											rceidOper2,
											level ) );
		}
	
	//	sets dirty and dbtime on all updated pages
	//
	LGIRedoSplitUpdateDbtime( psplitPathLeaf, dbtime );
	
	//	calls BTIPerformSplit
	//
	BTIPerformSplit( pfucb, psplitPathLeaf, &kdf, dirflag );
	
HandleError:
	//	release latches
	//
	if ( psplitPathLeaf != NULL )
		{
		BTIReleaseSplitPaths( PinstFromPpib( ppib ), psplitPathLeaf );
		}

	if ( NULL != rgb )
		{
		BFFree( rgb );
		}

	return err;
	}

	
//	redoes macro operation
//		[either a split or a merge]
//
ERR LOG::ErrLGRIRedoMacroOperation( PIB *ppib, DBTIME dbtime )
	{
	ERR		err;
	LR 		*plr 	= (LR *) ppib->PvLogrec( dbtime );
	LRTYP	lrtyp	= plr->lrtyp;

	Assert( lrtypSplit == lrtyp || lrtypMerge == lrtyp );
	if ( lrtypSplit == lrtyp )
		err = ErrLGRIRedoSplit( ppib, dbtime );
	else
		err = ErrLGRIRedoMerge( ppib, dbtime );

	return err;
	}


//	Page ref is consumed if its a real page number,
//	and if we didn't just encounter this page.
//	Used in inner RedoOperations loop

INLINE UINT CLGRIConsumePageRef( const PGNO pgno, PGNO* const ppgnoLast )
	{
	if ( pgnoNull != pgno && pgno != *ppgnoLast )
		{
		*ppgnoLast = pgno;
		return 1;
		}
	else
		{
		return 0;
		}
	}

//	Scan from lgposRedoFrom to end of usable log generations. 
//	For each log record, perform operations to redo original operation.
//

ERR LOG::ErrLGRIRedoOperations( IFileSystemAPI *const pfsapi, const LE_LGPOS *ple_lgposRedoFrom, BYTE *pbAttach, LGSTATUSINFO *plgstat )
	{
	ERR					err 					= JET_errSuccess;
	ERR 				errT 					= JET_errSuccess;
	LR					*plr;
	BOOL				fLastLRIsQuit			= fFalse;
	BOOL				fShowSectorStatus		= fFalse;

	const CHAR			*szLogNameCurr 			= m_szLogName;
	LGPOS 				lgposPrevGenMaxUpd 		= lgposMin;

	//	initialize global variable
	//
	m_lgposRedoShutDownMarkGlobal = lgposMin;

	//	reset m_pbLastMSFlush before restart
	//
	// Make a log reader to be used by ErrLGLocateFirstRedoLogRec() and ErrLGGetNextRec()
	// and ErrLGCheckReadLastLogRecord().
	Assert( m_plread == pNil );
	m_plread = new LogReader();
	if ( pNil == m_plread )
		{
		CallR( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//	get the size of the log file

	Assert( m_pfapiLog );
	QWORD	cbSize;
	Call( m_pfapiLog->ErrSize( &cbSize ) );

	Assert( m_cbSec > 0 );
	Assert( ( cbSize % m_cbSec ) == 0 );
	UINT	csecSize;
	csecSize = UINT( cbSize / m_cbSec );
	Assert( csecSize > m_csecHeader );

	//	setup the log reader

	Call( m_plread->ErrLReaderInit( this, csecSize ) );
	Call( m_plread->ErrEnsureLogFile() );

	//	scan the log to find traces of corruption before going record-to-record
	//	if any corruption is found, an error will be returned
	BOOL fDummy;
	err = ErrLGCheckReadLastLogRecordFF( pfsapi, &fDummy );
	//	remember errors about corruption but don't do anything with them yet
	//	we will go up to the point of corruption and then return the right error
	if ( err == JET_errSuccess || FErrIsLogCorruption( err ) )
		{
		errT = err;
		}
	else
		{
		Assert( err < 0 );
		Call( err );
		}

	//	now scan thve first record
	//	there should be no errors about corruption since they'll be handled by ErrLGCheckReadLastLogRecordFF
	err = ErrLGLocateFirstRedoLogRecFF( (LE_LGPOS *)ple_lgposRedoFrom, (BYTE **) &plr );
	if ( err == errLGNoMoreRecords )
		{
		//	no records existed in this log -- this means that the log is corrupt
		//	tanslate to the proper corruption message

		//	what recovery mode are we in?

		if ( m_fHardRestore )
			{

			//	we are in hard-recovery mode

			if ( m_plgfilehdr->lgfilehdr.le_lGeneration <= m_lGenHighRestore )
				{

				//	this generation is part of a backup set

				Assert( m_plgfilehdr->lgfilehdr.le_lGeneration >= m_lGenLowRestore );
				Call( ErrERRCheck( JET_errLogCorruptDuringHardRestore ) );
				}
			else
				{

				//	the current log generation is not part of the backup-set

				Call( ErrERRCheck( JET_errLogCorruptDuringHardRecovery ) );
				}
			}
		else
			{

			//	we are in soft-recovery mode 

			Call( ErrERRCheck( JET_errLogFileCorrupt ) );
			}
		}
	else if ( err != JET_errSuccess )
		{
		Call( err );
		}
	//	we don't expect any warnings, so this must be successful
	CallS( err );

#ifdef DEBUG
//	if ( m_lgposLastRec.isec )
		{
		LGPOS	lgpos;
		GetLgposOfPbNext( &lgpos );
		Assert( CmpLgpos( &lgpos, &m_lgposLastRec ) < 0 );
		}
#endif

	//	log redo progress.
	UtilReportEvent( 
				eventInformation, 
				LOGGING_RECOVERY_CATEGORY, 
				STATUS_REDO_ID, 
				1, 
				&szLogNameCurr, 
				0, 
				NULL, 
				m_pinst );

	if ( plgstat )
		{
		fShowSectorStatus = plgstat->fCountingSectors;
		if ( fShowSectorStatus )
			{
			//	reset byte counts
			//
			plgstat->cSectorsSoFar = ple_lgposRedoFrom->le_isec;
			plgstat->cSectorsExpected = m_plgfilehdr->lgfilehdr.le_csecLGFile;
			}
		}


	m_fLastLRIsShutdown = fFalse;

#ifdef UNLIMITED_DB
	Assert( m_fNeedInitialDbList );
#endif

		{
		for ( UINT idbid = 0; idbid < cdbidMax; ++idbid )
			{
			m_rgpgnoLast[ idbid ] = pgnoNull;
			}
		}

	do
		{
		FMP		*pfmp;			// for db operations
		DBID	dbid;			// for db operations
		IFMP	ifmp;

		if ( errLGNoMoreRecords == err )
			{
			INT	fNSNextStep;

			//	if we had a corruption error on this generation, do not process other other generations

			if ( errT != JET_errSuccess )
				{
				goto Done;
				}

			//	bring in the next generation
			err = ErrLGRedoFill( pfsapi, &plr, fLastLRIsQuit, &fNSNextStep );
			//	remember errors about corruption but don't do anything with them yet
			//	we will go up to the point of corruption and then return the right error
			if ( FErrIsLogCorruption( err ) )
				{
				errT = err;
				
				//	make sure we process this log generation (up to the point of corruption)

				fNSNextStep = fNSGotoCheck;
				}
			else if ( err == errLGNoMoreRecords )
				{
				//	no records existed in this log because ErrLGLocateFirstRedoLogRecFF returned this error
				//		this means that the log is corrupt -- setup the proper corruption message

				//	what recovery mode are we in?

				if ( m_fHardRestore )
					{

					//	we are in hard-recovery mode

					if ( m_plgfilehdr->lgfilehdr.le_lGeneration <= m_lGenHighRestore )
						{

						//	this generation is part of a backup set

						Assert( m_plgfilehdr->lgfilehdr.le_lGeneration >= m_lGenLowRestore );
						errT = ErrERRCheck( JET_errLogCorruptDuringHardRestore );
						}
					else
						{

						//	the current log generation is not part of the backup-set

						errT = ErrERRCheck( JET_errLogCorruptDuringHardRecovery );
						}
					}
				else
					{

					//	we are in soft-recovery mode 

					errT = ErrERRCheck( JET_errLogFileCorrupt );
					}

				//	make sure we process this log generation
				
				fNSNextStep = fNSGotoCheck;
				}
			else if ( err != JET_errSuccess )
				{
				Assert( err < 0 );
				Call( err );
				}

			switch( fNSNextStep )
				{
				case fNSGotoDone:
					goto Done;

				case fNSGotoCheck:
					//	log redo progress.
					UtilReportEvent(
							eventInformation,
							LOGGING_RECOVERY_CATEGORY,
							STATUS_REDO_ID,
							1,
							&szLogNameCurr,
							0,
							NULL,
							m_pinst );

					if ( !plgstat )
						{
						if ( fGlobalRepair )
							printf( " Recovering Generation %d.\n", LONG( m_plgfilehdr->lgfilehdr.le_lGeneration ) );
						}
					else
						{
						JET_SNPROG	*psnprog = &(plgstat->snprog);
						ULONG		cPercentSoFar;

						plgstat->cGensSoFar += 1;
						Assert(plgstat->cGensSoFar <= plgstat->cGensExpected);
						cPercentSoFar = (ULONG)
							((plgstat->cGensSoFar * 100) / plgstat->cGensExpected);

						Assert( cPercentSoFar >= psnprog->cunitDone );
						if ( cPercentSoFar > psnprog->cunitDone )
							{
							psnprog->cunitDone = cPercentSoFar;
							(*plgstat->pfnStatus)( 0, JET_snpRestore,
								JET_sntProgress, psnprog);
							}

						if ( fShowSectorStatus )
							{
							/*	reset byte counts
							/**/
							plgstat->cSectorsSoFar = 0;
							plgstat->cSectorsExpected = m_plgfilehdr->lgfilehdr.le_csecLGFile;
							}
						}
					Assert( m_pbNext != pbNil );
					goto CheckNextRec;
				}

			/*	should never get here
			/**/
			Assert( fFalse );
			}

CheckNextRec:
		GetLgposOfPbNext(&m_lgposRedo);

#ifdef RTM
#else
		extern LGPOS g_lgposRedoTrap;
		AssertSzRTL( CmpLgpos( m_lgposRedo, g_lgposRedoTrap ), "Redo Trap" );
#endif

		//	Keep track of last LR to see if it is shutdown mark
		//	Skip those lr that does nothing material. Do not change
		//	m_fLastLRIsShutdown if LR is debug only log record.

		if ( ! m_fDumppingLogs )
			{
			// Possibly pre-read database pages
			Call( ErrLGIPrereadCheck() );

			// Count how many page references we'll be consuming.
		
			switch( plr->lrtyp )
				{
				case lrtypInsert:
				case lrtypFlagInsert:
				case lrtypFlagInsertAndReplaceData:
				case lrtypReplace:
				case lrtypReplaceD:
				case lrtypFlagDelete:
				case lrtypDelete:
				case lrtypDelta:
				case lrtypSLVSpace:
				case lrtypSetExternalHeader:
					{
					const LRPAGE_ * const plrpage = (LRPAGE_ *)plr;
					const PGNO pgno = plrpage->le_pgno;
					const INT idbid = plrpage->dbid - 1;
					if( idbid >= cdbidMax )
						break;

					m_cPageRefsConsumed += CLGRIConsumePageRef( pgno, &m_rgpgnoLast[ idbid ] );
					}
					break;

				case lrtypSplit:
					{
					const LRSPLIT * const plrsplit = (LRSPLIT *)plr;
					const INT idbid = plrsplit->dbid - 1;
					if( idbid >= cdbidMax )
						break;

					m_cPageRefsConsumed += CLGRIConsumePageRef( plrsplit->le_pgno, &m_rgpgnoLast[ idbid ] );
					m_cPageRefsConsumed += CLGRIConsumePageRef( plrsplit->le_pgnoNew, &m_rgpgnoLast[ idbid ] );
					m_cPageRefsConsumed += CLGRIConsumePageRef( plrsplit->le_pgnoParent, &m_rgpgnoLast[ idbid ] );
					m_cPageRefsConsumed += CLGRIConsumePageRef( plrsplit->le_pgnoRight, &m_rgpgnoLast[ idbid ] );
					}
					break;
					
				case lrtypMerge:
					{
					const LRMERGE * const plrmerge = (LRMERGE *)plr;	
					const INT idbid = plrmerge->dbid - 1;
					if( idbid >= cdbidMax )
						break;

					m_cPageRefsConsumed += CLGRIConsumePageRef( plrmerge->le_pgno, &m_rgpgnoLast[ idbid ] );
					m_cPageRefsConsumed += CLGRIConsumePageRef( plrmerge->le_pgnoRight, &m_rgpgnoLast[ idbid ] );
					m_cPageRefsConsumed += CLGRIConsumePageRef( plrmerge->le_pgnoLeft, &m_rgpgnoLast[ idbid ] );
					m_cPageRefsConsumed += CLGRIConsumePageRef( plrmerge->le_pgnoParent, &m_rgpgnoLast[ idbid ] );
					}
					break;

				default:
					break;
				}
			}

		//	if initial DbList has not yet been created,
		//	it must be because we haven't reached
		//	the DbList (or Init) log record yet
		Assert( !m_fNeedInitialDbList
			|| lrtypChecksum == plr->lrtyp
			|| lrtypDbList == plr->lrtyp
			|| lrtypInit2 == plr->lrtyp );

		// update genMaxReq for the databases to avoid the following scenario:
		// - backup set 3-5, play forward 6-10
		// - replay up to 8 and crash
		// - delete logs 7-10
		// - run hard recovery w/o restoring the files
		// we also want to update for soft recovery if we have an older than logs database
		// (like during soft recovery of a offline backup or snapshot)
		if ( m_lgposRedo.lGeneration > lgposPrevGenMaxUpd.lGeneration )
			{
			m_critCheckpoint.Enter();
			err = ErrLGIUpdateGenRequired(
						pfsapi,
						0, // pass 0 to preserve the existing value
						m_lgposRedo.lGeneration,
						m_plgfilehdr->lgfilehdr.tmCreate,
						NULL );
			m_critCheckpoint.Leave();
			CallR ( err );
		 	lgposPrevGenMaxUpd = m_lgposRedo;
		 	}

		switch ( plr->lrtyp )
			{
		case lrtypNOP:
			continue;

			// This may not be optimally efficient to put this
			// so high on the log record processing.
		case lrtypChecksum:
			continue;

		case lrtypTrace:					/* Debug purpose only log records. */
		case lrtypJetOp:
		case lrtypRecoveryUndo:
		case lrtypRecoveryUndo2:
		case lrtypForceFlushLog:
			break;

		case lrtypFullBackup:				/* Debug purpose only log records */
			m_lgposFullBackup = m_lgposRedo;
			m_fRestoreMode = fRestoreRedo;
			break;
			
		case lrtypIncBackup:				/* Debug purpose only log records */
			m_lgposIncBackup = m_lgposRedo;
			m_fRestoreMode = fRestoreRedo;
			break;

		case lrtypBackup:					/* Debug purpose only log records */
			{
			LRLOGBACKUP * plrlb = (LRLOGBACKUP *) plr;
			if ( plrlb->FFull() )
				{
				m_lgposFullBackup = m_lgposRedo;
				m_fRestoreMode = fRestoreRedo;
				}
			else if ( plrlb->FIncremental() )
				{
				m_lgposIncBackup = m_lgposRedo;
				m_fRestoreMode = fRestoreRedo;
				}
			else if ( plrlb->FSnapshotStart() )
				{
				// if we restore a snapshot and the Snapshot Start of the database is the current log record
				if ( fSnapshotBefore == m_fSnapshotMode && 0 == CmpLgpos ( &m_lgposSnapshotStart, &m_lgposRedo ) )
					{
					m_fSnapshotMode = fSnapshotDuring;
					}
				}
			else if ( plrlb->FSnapshotStop() )
				{
				// first SnapshotStop when we are in the logs during the restored snapshot
				// must be the end of the snapshot
				if ( fSnapshotDuring == m_fSnapshotMode )
					{
					m_fSnapshotMode = fSnapshotAfter;
					}
				if ( !m_fHardRestore )
					{
					// snapshot mode set only on hard recovery
					Assert ( fSnapshotNone == m_fSnapshotMode );

					for ( DBID dbidToCheck = dbidUserLeast; dbidToCheck < dbidMax; dbidToCheck++ )
						{
						if ( ifmpMax == m_pinst->m_mpdbidifmp[ dbidToCheck ] )
							continue;
						
						pfmp = &rgfmp[ m_pinst->m_mpdbidifmp[ dbidToCheck ] ];

						if ( !pfmp->FInUse() || !pfmp->FAttached() )
							continue;

						Assert ( pfmp->Pdbfilehdr() );
						
						// if db has snapshot start but no stop (on stop we reset snapshot start)
						// the it must be a crash during snapshot or
						// from a snapshot backup set
						// If crash we should not find the snapshot stop log record during soft recovery
						if ( 0 != CmpLgpos ( &(pfmp->Pdbfilehdr()->bkinfoSnapshotCur.le_lgposMark), &lgposMin ) )
							{
							Assert ( 0 != CmpLgpos ( &(pfmp->Pdbfilehdr()->bkinfoSnapshotCur.le_lgposMark), &m_lgposRedo ) );
							
							// if we found snapshot stop log record past the snapshot start mark in db header
							if ( 0 > CmpLgpos ( &(pfmp->Pdbfilehdr()->bkinfoSnapshotCur.le_lgposMark), &m_lgposRedo ) )
								{
								Call ( ErrERRCheck ( JET_errSoftRecoveryOnSnapshot ) );
								}
							}
						}
					}
				}
			else
				{
				Assert ( fFalse );
				}
			break;
			}

		case lrtypShutDownMark:			/* Last consistency point */
			m_lgposRedoShutDownMarkGlobal = m_lgposRedo;
			m_fLastLRIsShutdown = fTrue;
			break;

		default:
			{
			m_fLastLRIsShutdown = fFalse;

			//	Check the LR that does the real work from here:

			switch ( plr->lrtyp )
				{
			case lrtypEnd:
				AssertSz( fFalse, "lrtypEnd record showed up in a FASTFLUSH log that should not have lrtypEnd records." );
				Call( ErrERRCheck( JET_errLogCorrupted ) );
				break;

			case lrtypMacroBegin:
				{
				PIB *ppib;

				LRMACROBEGIN *plrMacroBegin = (LRMACROBEGIN *) plr;
				Call( ErrLGRIPpibFromProcid( plrMacroBegin->le_procid, &ppib ) );
				
				Assert( !ppib->FMacroGoing( plrMacroBegin->le_dbtime ) );
				Call( ppib->ErrSetMacroGoing( plrMacroBegin->le_dbtime ) );
				break;
				}

			case lrtypMacroCommit:
			case lrtypMacroAbort:
				{
				PIB 		*ppib;
				LRMACROEND 	*plrmend = (LRMACROEND *) plr;
				DBTIME		dbtime = plrmend->le_dbtime;

				Call( ErrLGRIPpibFromProcid( plrmend->le_procid, &ppib ) );

				//	if it is commit, redo all the recorded log records,
				//	otherwise, throw away the logs
				//
				if ( lrtypMacroCommit == plr->lrtyp && ppib->FAfterFirstBT() )
					{					
					Call(ErrLGRIRedoMacroOperation( ppib, dbtime ) );
					}

				//	disable MacroGoing
				//
				ppib->ResetMacroGoing( dbtime );
				
				break;
				}

			case lrtypInit2:
			case lrtypInit:
				{
				/*	start mark the jet init. Abort all active seesions.
				/**/
				LRINIT2  *plrstart = (LRINIT2 *)plr;

				LGRITraceRedo( plr );

				if ( !m_fAfterEndAllSessions )
					{
					Call( ErrLGRIEndAllSessions( pfsapi, fFalse, ple_lgposRedoFrom, pbAttach ) );
					m_fAfterEndAllSessions = fTrue;
					m_fNeedInitialDbList = fFalse;
#ifdef DEBUG
					m_lgposRedoShutDownMarkGlobal = lgposMin;
#endif
					}

				/*	Check Init session for hard restore only.
				 */
				Assert( 0 == *pbAttach );
				Call( ErrLGRIInitSession(
							pfsapi,
							&plrstart->dbms_param,
							pbAttach,
							plgstat,
							redoattachmodeInitLR ) );
				m_fAfterEndAllSessions = fFalse;
				}
				break;

			case lrtypRecoveryQuit:
			case lrtypRecoveryQuit2:
			case lrtypTerm:
			case lrtypTerm2:
				/*	all records are re/done. all rce entries should be gone now.
				/**/
#ifdef DEBUG
				{
				CPPIB   *pcppib = m_rgcppib;
				CPPIB   *pcppibMax = pcppib + m_ccppib;
				for ( ; pcppib < pcppibMax; pcppib++ )
					if ( pcppib->ppib != ppibNil &&
						 pcppib->ppib->prceNewest != prceNil )
						{
						RCE *prceT = pcppib->ppib->prceNewest;
						while ( prceT != prceNil )
							{
							Assert( prceT->FOperNull() );
							prceT = prceT->PrcePrevOfSession();
							}
						}
				}
#endif
				
				/*	quit marks the end of a normal run. All sessions
				/*	have ended or must be forced to end. Any further
				/*	sessions will begin with a BeginT.
				/**/
#ifdef DEBUG
				m_fDBGNoLog = fTrue;
#endif
				/*	set m_lgposLogRec such that later start/shut down
				 *	will put right lgposConsistent into dbfilehdr
				 *	when closing the database.
				 */
				if ( !m_fAfterEndAllSessions )
					{
					Call( ErrLGRIEndAllSessions( pfsapi, fFalse, ple_lgposRedoFrom, pbAttach ) );
					m_fAfterEndAllSessions = fTrue;
#ifdef DEBUG
					m_lgposRedoShutDownMarkGlobal = lgposMin;
#endif
					}

				fLastLRIsQuit = fTrue;
				continue;

	   		/****************************************************/
	   		/*	Database Operations                          */
	   		/****************************************************/
	   		case lrtypDbList:
	   			{
#ifdef UNLIMITED_DB	   			
	   			LRDBLIST*		plrdblist		= (LRDBLIST *)plr;

	   			LGRITraceRedo( plr );

				//	if never replayed an Init and we hit a DbList,
				//	this implicitly tells us we need to redo the Init
	   			if ( m_fNeedInitialDbList )
	   				{
					err = ErrLGLoadFMPFromAttachments( m_pinst, pfsapi, plrdblist->rgb );
					CallS( err );
					Call( err );

					Call( ErrLGRIRedoInitialAttachments_( pfsapi ) );

	   				m_fNeedInitialDbList = fFalse;
	   				}
#endif
				break;
	   			}
	            
			case lrtypCreateDB:
				{
				PIB				*ppib;
				REDOATTACH		redoattach;
				LRCREATEDB		*plrcreatedb	= (LRCREATEDB *)plr;

				dbid = plrcreatedb->dbid;
				Assert( dbid != dbidTemp );

				LGRITraceRedo(plr);
				Call( ErrLGRIPpibFromProcid( plrcreatedb->le_procid, &ppib ) );

				// set-up the FMP
				{
				// build an ATTACHINFO based on this log record
				ATTACHINFO *	pAttachInfo		= NULL;
				const ULONG		cbAttachInfo	= sizeof(ATTACHINFO) + plrcreatedb->CbPath();

				pAttachInfo = static_cast<ATTACHINFO *>( PvOSMemoryHeapAlloc( cbAttachInfo ) );
				if ( NULL == pAttachInfo )
					{
					CallR ( ErrERRCheck( JET_errOutOfMemory ) );
					}

				memset( pAttachInfo, 0, cbAttachInfo );
				pAttachInfo->SetDbid( plrcreatedb->dbid );

				Assert ( !pAttachInfo->FSLVExists() );
				if ( plrcreatedb->FCreateSLV() )
					{
					pAttachInfo->SetFSLVExists();
					}

				Assert ( !pAttachInfo->FSLVProviderNotEnabled() );
				if ( plrcreatedb->FSLVProviderNotEnabled() )
					{
					pAttachInfo->SetFSLVProviderNotEnabled();
					}
					
				pAttachInfo->SetCbNames( plrcreatedb->CbPath() );
				pAttachInfo->SetDbtime( 0 );
				pAttachInfo->SetObjidLast( objidNil );
				pAttachInfo->SetCpgDatabaseSizeMax( plrcreatedb->le_cpgDatabaseSizeMax );
				pAttachInfo->le_lgposAttach = m_lgposRedo;
				pAttachInfo->le_lgposConsistent = lgposMin;
				memcpy( &pAttachInfo->signDb, &plrcreatedb->signDb, sizeof(SIGNATURE) );
				memcpy ( pAttachInfo->szNames, (CHAR *)plrcreatedb->rgb, plrcreatedb->CbPath() );		

				err = ErrLGRISetupFMPFromAttach( pfsapi, ppib, &m_signLog, pAttachInfo, plgstat);
				Assert ( pAttachInfo );
				OSMemoryHeapFree( pAttachInfo );
				CallR ( err );
				}
				
				ifmp = m_pinst->m_mpdbidifmp[ dbid ];
				FMP::AssertVALIDIFMP( ifmp );
				pfmp = &rgfmp[ ifmp ];

				if ( pfmp->FSkippedAttach() || pfmp->FDeferredAttach() )
					{
					break;
					}

				const BOOL	fDBPathValid	= ( ErrUtilDirectoryValidate( pfsapi, pfmp->SzDatabaseName() ) >= 0 );
				const BOOL	fDBFileMissing	= ( !fDBPathValid || ( ErrUtilPathExists( pfsapi, pfmp->SzDatabaseName() ) < 0 ) );
				const BOOL	fSLVFileNeeded	= ( NULL != pfmp->SzSLVName()  );
				const BOOL	fSLVFileMissing	= ( fSLVFileNeeded && ( ErrUtilPathExists( pfsapi, pfmp->SzSLVName() ) < 0 ) );
					
				if ( fDBPathValid
					&& fDBFileMissing
					&& ( !fSLVFileNeeded || fSLVFileMissing ) )
					{
					//	both database and SLV are missing, so recreate them
					redoattach = redoattachCreate;
					}
				else
					{
					Assert(	!fDBPathValid
						|| ( !fSLVFileNeeded && !fDBFileMissing )						// DBFile only needed and exists
						|| ( fSLVFileNeeded &&  !fSLVFileMissing && !fDBFileMissing )	// both needed and exist
						|| ( fSLVFileNeeded && ( fSLVFileMissing ^ fDBFileMissing ) )	// both needed but only one exists
						);

					Assert( !pfmp->FReadOnlyAttach() );
					Call( ErrLGRICheckAttachedDb(
								pfsapi,
								ifmp,
								NULL,
								&redoattach,
								redoattachmodeCreateDbLR ) );
					Assert( NULL != pfmp->Pdbfilehdr()
						|| redoattachCreate == redoattach );

					if ( fDBFileMissing )
						{
						// if missing, it is deferred
						Assert( redoattachDefer == redoattach );
						}
					else
						{
		                // database present and need not deferable, but SLV file missing
						if ( redoattachNow == redoattach && fSLVFileNeeded && fSLVFileMissing )
							{
		        	        Call( ErrERRCheck( JET_errSLVStreamingFileMissing ) );
		            	    }					
						}

					//	if redoing attach on db, then SLV must also be present (or not needed)
					Assert( redoattachNow != redoattach
							|| !fSLVFileNeeded
							|| !fSLVFileMissing );
					}

				switch( redoattach )
					{
					case redoattachCreate:
						//	we've already pre-determined (in ErrLGRICheckRedoCreateDb())
						//	that any existing database needs to be overwritten, so
						//	it's okay to unequivocally pass in JET_bitDbOverwriteExisting
						Call( ErrLGRIRedoCreateDb(
									ppib,
									ifmp,
									dbid,
									plrcreatedb->le_grbit | JET_bitDbOverwriteExisting,
									&plrcreatedb->signDb ) );
						break;

					case redoattachNow:
						Assert( !pfmp->FReadOnlyAttach() );
						Call( ErrLGRIRedoAttachDb(
									pfsapi,
									ifmp,
									plrcreatedb->le_cpgDatabaseSizeMax,
									redoattachmodeCreateDbLR ) );
						break;

					default:
						Assert( fFalse );	//	should be impossible, but as a firewall, set to defer the attachment
					case redoattachDefer:
						Assert( !pfmp->FReadOnlyAttach() );
						LGRISetDeferredAttachment( ifmp );
						break;
					}
				}
				break;

			case lrtypAttachDB:
				{
				PIB			*ppib;
				REDOATTACH	redoattach;
				LRATTACHDB  *plrattachdb	= (LRATTACHDB *)plr;
				
				dbid = plrattachdb->dbid;
				Assert( dbid != dbidTemp );

				LGRITraceRedo( plr );

				Call( ErrLGRIPpibFromProcid( plrattachdb->le_procid, &ppib ) );

				if ( m_fHardRestore )
					{
					CHAR        *szDbName		= reinterpret_cast<CHAR *>( plrattachdb->rgb );
					CHAR		*szSLVName		= ( plrattachdb->FSLVExists() ?
														szDbName + strlen( szDbName ) + 1 :		//	SLV name follows db name
														NULL );
					err = ErrReplaceRstMapEntry( szDbName, &plrattachdb->signDb, fFalse );
					if ( JET_errFileNotFound == err )
						{
						//	database not in restore map, so it won't be restored
						//
						err = JET_errSuccess;
						}
					Call( err );

					if ( NULL != szSLVName )
						{
						err = ErrReplaceRstMapEntry( szSLVName, &plrattachdb->signDb, fTrue );
						if ( JET_errFileNotFound == err )
							{
							//	streaming file not in restore map, so it won't be restored
							//
							err = JET_errSuccess;
							}
						Call( err );
						}
					}

				// set-up the FMP
				{
				// build an ATTACHINFO based on this log record
				ATTACHINFO *	pAttachInfo		= NULL;
				const ULONG		cbAttachInfo	= sizeof(ATTACHINFO) + plrattachdb->CbPath();

				pAttachInfo = static_cast<ATTACHINFO *>( PvOSMemoryHeapAlloc( cbAttachInfo ) );
				if ( NULL == pAttachInfo )
					{
					CallR ( ErrERRCheck( JET_errOutOfMemory ) );
					}

				memset( pAttachInfo, 0, cbAttachInfo );
				pAttachInfo->SetDbid( plrattachdb->dbid );

				Assert ( !pAttachInfo->FSLVExists() );
				if ( plrattachdb->FSLVExists() )
					{
					pAttachInfo->SetFSLVExists();
					}

				Assert ( !pAttachInfo->FSLVProviderNotEnabled() );
				if ( plrattachdb->FSLVProviderNotEnabled() )
					{
					pAttachInfo->SetFSLVProviderNotEnabled();
					}
					
				pAttachInfo->SetCbNames( plrattachdb->CbPath() );
				pAttachInfo->SetDbtime( 0 );
				pAttachInfo->SetObjidLast( objidNil );
				pAttachInfo->SetCpgDatabaseSizeMax( plrattachdb->le_cpgDatabaseSizeMax );
				pAttachInfo->le_lgposAttach = m_lgposRedo;
				pAttachInfo->le_lgposConsistent = plrattachdb->lgposConsistent;
				memcpy( &pAttachInfo->signDb, &plrattachdb->signDb, sizeof(SIGNATURE) );
				memcpy ( pAttachInfo->szNames, (CHAR *)plrattachdb->rgb, plrattachdb->CbPath() );		

				err = ErrLGRISetupFMPFromAttach( pfsapi, ppib, &m_signLog, pAttachInfo, plgstat);
				Assert ( pAttachInfo );
				OSMemoryHeapFree( pAttachInfo );
				CallR ( err );
				}
				
				ifmp = m_pinst->m_mpdbidifmp[ dbid ];
				FMP::AssertVALIDIFMP( ifmp );
				pfmp = &rgfmp[ ifmp ];

				if ( pfmp->FSkippedAttach() || pfmp->FDeferredAttach() )
					{
					break;
					}
					
				Assert( !pfmp->FReadOnlyAttach() );
				Call( ErrLGRICheckAttachedDb(
							pfsapi,
							ifmp,
							&plrattachdb->signLog,
							&redoattach,
							redoattachmodeAttachDbLR ) );
				Assert( NULL != pfmp->Pdbfilehdr() );
					
				switch ( redoattach )
					{
					case redoattachNow:
						Assert( !pfmp->FReadOnlyAttach() );
						Call( ErrLGRIRedoAttachDb(
									pfsapi,
									ifmp,
									plrattachdb->le_cpgDatabaseSizeMax,
									redoattachmodeAttachDbLR ) );
						break;

					case redoattachCreate:
					default:
						Assert( fFalse );	//	should be impossible, but as a firewall, set to defer the attachment
					case redoattachDefer:
						Assert( !pfmp->FReadOnlyAttach() );
						LGRISetDeferredAttachment( ifmp );
						break;
					}
				}
				break;

			case lrtypForceDetachDB:
				{
				LRFORCEDETACHDB *	plrforcedetachdb 	= (LRFORCEDETACHDB *)plr;
				PIB * 				ppibToClean 		= m_pinst->m_ppibGlobal;

				dbid = plrforcedetachdb->dbid;
				ifmp = m_pinst->m_mpdbidifmp[ dbid ];
				FMP::AssertVALIDIFMP( ifmp );
				pfmp = &rgfmp[ ifmp ];

				Assert ( !pfmp->FReadOnlyAttach() );

				if ( pfmp->Pdbfilehdr() )
					{
					//	Set current time to one at the detach moment
					Assert ( plrforcedetachdb->Dbtime() >= pfmp->DbtimeLast() );
					pfmp->SetDbtimeLast( plrforcedetachdb->Dbtime() );

					// need do add a new state to the db ? Like JET_dbstateDuringForceDetach ...
					// is the db unusable between this point and the detach moment following ?
					Assert ( !m_pinst->m_plog->m_fLogDisabled );
					pfmp->Pdbfilehdr()->SetDbstate( JET_dbstateForceDetach, m_pinst->m_plog->m_plgfilehdr->lgfilehdr.le_lGeneration, &m_pinst->m_plog->m_plgfilehdr->lgfilehdr.tmCreate );				
					pfmp->Pdbfilehdr()->le_dbtimeDirtied = pfmp->DbtimeLast();

					Assert ( !pfmp->FUndoForceDetach() );
					pfmp->SetDbtimeUndoForceDetach( plrforcedetachdb->Dbtime() + (DBTIME) plrforcedetachdb->RceidMax() );
					Assert ( pfmp->FUndoForceDetach() );

					// unnecessary check. It was made during Attach
					// if ( pfmp->Pdbfilehdr()->FSLVExists() )
					//	{
					//	CallR( ErrSLVReadHeader( pfs, ifmp ) );
					//	}
					
					Call( ErrUtilWriteShadowedHeader(	pfsapi, 
														pfmp->SzDatabaseName(), 
														fTrue,
														(BYTE *)pfmp->Pdbfilehdr(), 
														g_cbPage,
														pfmp->Pfapi() ) );

					if ( plrforcedetachdb->FCloseSessions() )
					// we have to Undo operations
						{		
						while ( ppibToClean != ppibNil )
							{						
							if ( ppibToClean->pfucbOfSession && ppibToClean->pfucbOfSession->ifmp == ifmp )
								{
#ifdef DEBUG
								// all FUCB's in this session should be on the same DB
								// (we checked this on ForceDetach)
								{
								FUCB * pfucbToCheck = ppibToClean->pfucbOfSession;
								while ( pfucbToCheck )
									{
									Assert ( pfucbToCheck->ifmp == ifmp );
									pfucbToCheck = pfucbToCheck->pfucbNextOfSession;
									}
								}
#endif // DEBUG
								while ( 1 <= ppibToClean->level )
									{
#ifdef DEBUG
									LEVEL level = ppibToClean->level;
#endif // DEBUG
									
									PIBSetTrxContext( ppibToClean );
									CallSx ( ErrDIRRollback( ppibToClean ), JET_errRollbackError );
									CallR ( err );
									Assert ( ppibToClean->level == level - 1 );
									}							
								}							
							 ppibToClean = ppibToClean->ppibNext;
							 }
						}
#ifdef DEBUG
					else
						{
						// no sessions using the database are supposed to exist at this point
						// 		
						while ( ppibToClean != ppibNil )
							{						
							Assert ( ppibToClean->rgcdbOpen[ pfmp->Dbid() ] == 0 );
							ppibToClean = ppibToClean->ppibNext;
							}
						}
#endif
					Assert ( pfmp->FUndoForceDetach() );
					pfmp->ResetDbtimeUndoForceDetach( );
					Assert ( !pfmp->FUndoForceDetach() );
					
					}
				else
					{
					Assert( pfmp->FSkippedAttach() || pfmp->FDeferredAttach() );
					}
				}
				// after that we just have to perform a normal detach
				
			case lrtypDetachDB:
				{
				LRDETACHDB		*plrdetachdb = (LRDETACHDB *)plr;
				// WARNING WARNING WARNING
				// =======================
				// rgb does not point to Path if it is a LRFORCEDETACH record.
				// If you gonna use that field be sure that you use it correctly.
				// Check plr->lrtyp
				dbid = plrdetachdb->dbid;

				Assert( dbid != dbidTemp );
				ifmp = m_pinst->m_mpdbidifmp[ dbid ];
				FMP::AssertVALIDIFMP( ifmp );
				pfmp = &rgfmp[ifmp];

				if ( pfmp->Pdbfilehdr() )
					{
					/*	close database for all active user.
					 */
					CPPIB   *pcppib = m_rgcppib;
					CPPIB   *pcppibMax = pcppib + m_ccppib;
					PIB		*ppib;

					/*	find pcppib corresponding to procid if it exists
					 */
					for ( ; pcppib < pcppibMax; pcppib++ )
						{
						ppib = pcppib->ppib;
						
						if ( ppib == NULL )
							continue;

						while( FPIBUserOpenedDatabase( ppib, dbid ) )
							{
							if ( NULL != m_ptablehfhash )
								{
								//	close all fucb on this database
								//
								m_ptablehfhash->Purge( ppib, ifmp );
								}
							Call( ErrDBCloseDatabase( ppib, ifmp, 0 ) );
							}
						}

					/*	if attached before this detach.
					 *	there should be no more operations on this database entry.
					 *	detach it!!
					 */
					 {
					BKINFO *	pbkInfoToCopy;

					if ( FSnapshotRestore() )
						{
						pbkInfoToCopy = &(pfmp->Pdbfilehdr()->bkinfoSnapshotCur);
						}
					else
						{
						pbkInfoToCopy = &(pfmp->Pdbfilehdr()->bkinfoFullCur);
						}


					if ( pbkInfoToCopy->le_genLow != 0 )
						{
						Assert( pbkInfoToCopy->le_genHigh != 0 );
						Assert ( m_fHardRestore );
						pfmp->Pdbfilehdr()->bkinfoFullPrev = *pbkInfoToCopy;
						memset(	&pfmp->Pdbfilehdr()->bkinfoFullCur, 0, sizeof( BKINFO ) );
						memset(	&pfmp->Pdbfilehdr()->bkinfoIncPrev, 0, sizeof( BKINFO ) );
						memset(	&pfmp->Pdbfilehdr()->bkinfoSnapshotCur, 0, sizeof( BKINFO ) );
						}
					}
					

#ifdef BKINFO_DELETE_ON_HARD_RECOVERY
					// BUG: 175058: delete the previous backup info on any hard recovery
					// this will prevent a incremental backup and log truncation problems
					// UNDONE: the above logic to copy bkinfoFullPrev is probably not needed
					// (we may consider this and delete it)
					if ( m_fHardRestore )
						{
						memset(	&pfmp->Pdbfilehdr()->bkinfoFullPrev, 0, sizeof( BKINFO ) );
						}
#endif // BKINFO_DELETE_ON_HARD_RECOVERY

					Call( ErrLGRIPpibFromProcid( plrdetachdb->le_procid, &ppib ) );
					Assert( !pfmp->FReadOnlyAttach() );

					//	make the size matching, but must flush first to prevent following
					//	sequence of events:
					//	- determine we need to extend from x to x+n
					//	- async flush occurs at page x+y, where 1<=y<=n
					//	- zero out pages from x+1 to x+n, thus overwriting async flush of page x+y
					Call( ErrBFFlush( ifmp ) );
					Call( ErrBFFlush( ifmp | ifmpSLV ) );

					Call( ErrLGICheckDatabaseFileSize( pfsapi, ppib, ifmp ) );

					//	If there is no redo operations on an attached db, then
					//	pfmp->dbtimeCurrent may == 0, then do not change pdbfilehdr->dbtime

					if ( pfmp->DbtimeCurrentDuringRecovery() > pfmp->DbtimeLast() )
						{
						pfmp->SetDbtimeLast( pfmp->DbtimeCurrentDuringRecovery() );
						}

					Call( ErrIsamDetachDatabase( (JET_SESID) ppib, NULL, pfmp->SzDatabaseName(), plrdetachdb->Flags() ) );
					}
				else
					{
					Assert( pfmp->FInUse() );
					if ( pfmp->FInUse() )
						{
						//	SLV name/root, if any, is allocated in same space as db name
						OSMemoryHeapFree( pfmp->SzDatabaseName() );
						pfmp->SetSzDatabaseName( NULL );
						pfmp->SetSzSLVName( NULL );
						pfmp->SetSzSLVRoot( NULL );
						}
					else
						{
						Assert( NULL == pfmp->SzSLVName() );
						}

					pfmp->ResetFlags();
					pfmp->Pinst()->m_mpdbidifmp[ pfmp->Dbid() ] = ifmpMax;
					}

				//	verify skipped/deferred attachment is removed
				Assert( !pfmp->FSkippedAttach() );
				Assert( !pfmp->FDeferredAttach() );

				if ( pfmp->Patchchk() )
					{
					OSMemoryHeapFree( pfmp->Patchchk() );
					pfmp->SetPatchchk( NULL );
					}

				if ( pfmp->PatchchkRestored() )
					{
					OSMemoryHeapFree( pfmp->PatchchkRestored() );
					pfmp->SetPatchchkRestored( NULL );
					}

				LGRITraceRedo(plr);
				}
				break;

			case lrtypExtRestore:
				// for tracing only, should be at a new log generation 
				break;

	   		/****************************************************/
	   		/*	Operations Using ppib (procid)                  */
	   		/****************************************************/
	            
			default:
				Call( ErrLGRIRedoOperation( plr ) );
				} /* switch */
			} /* outer default */
		} /* outer switch */

#ifdef DEBUG
		m_fDBGNoLog = fFalse;
#endif
		fLastLRIsQuit = fFalse;

		/*	update sector status, if we moved to a new sector
		/**/
		Assert( !fShowSectorStatus || m_lgposRedo.isec >= plgstat->cSectorsSoFar );
		Assert( m_lgposRedo.isec != 0 );
		if ( fShowSectorStatus && m_lgposRedo.isec > plgstat->cSectorsSoFar )
			{
			ULONG		cPercentSoFar;
			JET_SNPROG	*psnprog = &(plgstat->snprog);

			Assert( plgstat->pfnStatus );
			
			plgstat->cSectorsSoFar = m_lgposRedo.isec;
			cPercentSoFar = (ULONG)((100 * plgstat->cGensSoFar) / plgstat->cGensExpected);
			
			cPercentSoFar += (ULONG)((plgstat->cSectorsSoFar * 100) /
				(plgstat->cSectorsExpected * plgstat->cGensExpected));

			Assert( cPercentSoFar <= 100 );

			/*	because of rounding, we might think that we finished
			/*	the generation when we really have not, so comparison
			/*	is <= instead of <.
			/**/
			Assert( cPercentSoFar <= (ULONG)( ( 100 * ( plgstat->cGensSoFar + 1 ) ) / plgstat->cGensExpected ) );

			Assert( cPercentSoFar >= psnprog->cunitDone );
			if ( cPercentSoFar > psnprog->cunitDone )
				{
				psnprog->cunitDone = cPercentSoFar;
				(*plgstat->pfnStatus)( 0, JET_snpRestore, JET_sntProgress, psnprog );
				}
			}
		}
	while ( ( err = ErrLGGetNextRecFF( (BYTE **) &plr ) ) == JET_errSuccess
			|| errLGNoMoreRecords == err );

	//	we have dropped out of the replay loop with an unexpected result
	//	this should be some types of error
	Assert( err < 0 );
	//	dispatch the error
	Call( err );

Done:
	err = errT; //JET_errSuccess;
	
HandleError:
	/*	assert all operations successful for restore from consistent
	/*	backups
	/**/
#ifndef RFS2
	AssertSz( err >= 0,     "Debug Only, Ignore this Assert");
#endif

	// Deallocate LogReader
	if ( pNil != m_plread )
		{
		if ( err == JET_errSuccess )
			{
			err = m_plread->ErrLReaderTerm();
			}
		else
			{
			m_plread->ErrLReaderTerm();
			}
		delete m_plread;
		m_plread = pNil;
		}

	return err;
	}



//	cleanup the current logs/checkpoint and start a new sequence
//
//	if we succeed, we will return wrnCleanedUpMismatchedFiles and the user will be at gen 1
//	if we fail, the user will be forced to delete the remaining logs/checkpoint by hand

ERR LOG::ErrLGRICleanupMismatchedLogFiles( IFileSystemAPI* const pfsapi )
	{
	ERR		err = JET_errSuccess;
	ERR		errT;
	LONG	lGen;
	LONG	lGenLast;
	CHAR	rgchFName[IFileSystemAPI::cchPathMax];
	CHAR	szPath[IFileSystemAPI::cchPathMax];

	//	circular logging must be on so that the user knows hard recovery is definitely impossible

	Assert( m_fLGCircularLogging );

	//	close the current log file (this will prevent any log flushing)

	m_critLGFlush.Enter();
	if ( m_pfapiLog )
		{
		delete m_pfapiLog;
		m_pfapiLog = NULL;
		}

	LGCreateAsynchWaitForCompletion();

	m_critLGFlush.Leave();

	//	find the first and last generations

	CallR( ErrLGIGetGenerationRange( pfsapi, m_szLogCurrent, &lGen, &lGenLast ) );

	//	delete edbxxxx.log
	//	start deleting only if we found something (lGen > 0)
	
	for ( ; lGen > 0 && lGen <= lGenLast; lGen++ )
		{
		LGSzFromLogId( rgchFName, lGen );
		strcpy( szPath, m_szLogCurrent );
		strcat( szPath, rgchFName );
		strcat( szPath, szLogExt );
		errT = pfsapi->ErrFileDelete( szPath );
		if ( errT < JET_errSuccess && JET_errFileNotFound != errT && err >= JET_errSuccess )
			{
			err = errT;
			}
		}

	//	delete edb.log and edbtmp.log

	strcpy( szPath, m_szLogCurrent );
	strcat( szPath, m_szJetLog );
	errT = pfsapi->ErrFileDelete( szPath );
	if ( errT < JET_errSuccess && JET_errFileNotFound != errT && err >= JET_errSuccess )
		{
		err = errT;
		}

	strcpy( szPath, m_szLogCurrent );
	strcat( szPath, m_szJetTmpLog );
	errT = pfsapi->ErrFileDelete( szPath );
	if ( errT < JET_errSuccess && JET_errFileNotFound != errT && err >= JET_errSuccess )
		{
		err = errT;
		}

	//	delete the checkpoint file

	LGFullNameCheckpoint( pfsapi, szPath );
	errT = pfsapi->ErrFileDelete( szPath );
	if ( errT < JET_errSuccess && JET_errFileNotFound != errT && err >= JET_errSuccess )
		{
		err = errT;
		}

	//	this is the end of the file-cleanup -- handle the resulting error, if any

	CallR( err );

	//	create the new log (gen 1) using the new log-file size

	m_csecLGFile = CsecLGIFromSize( m_pinst->m_lLogFileSize );

	//	create a new log and open it (using the new size in lLogFileSize)

	m_critLGFlush.Enter();
	
	err = ErrLGNewLogFile( pfsapi, 0, fLGOldLogNotExists );
	if ( err >= JET_errSuccess )
		{

		//	we successfully created a new log

		//	reset fSignLogSetGlobal because we have a new log signature now (setup by ErrLGNewLogFile)

		m_fSignLogSet = fFalse;

		m_critLGBuf.Enter();
		memcpy( m_plgfilehdr, m_plgfilehdrT, sizeof( LGFILEHDR ) );
		m_isecWrite = m_csecHeader;
		m_critLGBuf.Leave();

		Assert( 1 == m_plgfilehdr->lgfilehdr.le_lGeneration );
		Assert( m_pbLastChecksum == m_pbLGBufMin );
		//Assert( 1 == m_lgposLastChecksum.lGeneration );	//	not set by ErrLGNewLogFile
		
		//	open the new log file

		LGMakeLogName( m_szLogName, (CHAR *)m_szJet );
		err = pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog );

		if ( err >= JET_errSuccess )
			{

			//	read the log file hdr and initialize the log params (including the new log signature)

			Assert( !m_fSignLogSet );
			err = ErrLGReadFileHdr( m_pfapiLog, m_plgfilehdr, fFalse );
#ifdef DEBUG
			if ( err >= JET_errSuccess )
				{
				m_lgposLastLogRec = lgposMin;	//	reset the log position of the last record
				}
#endif	//	DEBUG
			}

		}
	else
		{

		//	failed to create the new log

		//	this is ok because we have consistent databases and no logs/checkpoint
		//	soft recovery will run and create the first log generation

		//	nop
		}
	m_critLGFlush.Leave();
	CallR( err );

	//	return a warning indicating that the old logs/checkpoint have been cleaned up

	return ErrERRCheck( wrnCleanedUpMismatchedFiles );//JET_errSuccess;
	}


ERR LOG::ErrLGDeleteOutOfRangeLogFiles( IFileSystemAPI * const pfsapi )
	{
	ERR				err = JET_errSuccess;
	LGFILEHDR * 	plgfilehdr = NULL;
	const LONG 		lCurrentGeneration = m_plgfilehdr->lgfilehdr.le_lGeneration;
	
	Assert( lCurrentGeneration != 0 );
	
	LONG 			lgenMin = 0;
	LONG 			lgenMax = 0;
	LONG 			igen = 0;

	Assert ( m_fDeleteOutOfRangeLogs );

	//	get range of log files in directory by file enumeration
	//
	CallR( ErrLGIGetGenerationRange( pfsapi, m_szLogFilePath, &lgenMin, &lgenMax ) );

	if ( lgenMin == 0 )
		{
		Assert ( 0 == lgenMax );
		return JET_errSuccess;
		}

	//	if all we have is below current generation then we are done
	//
	if ( lgenMax < lCurrentGeneration )
		{
		return JET_errSuccess;
		}
	
	//	start from the current generation number, because the current generation is edb.log!
	//
	lgenMin = max( lgenMin, lCurrentGeneration );
	lgenMax = max( lgenMax, lCurrentGeneration );

	//	we need a buffer to read the log headers
	//	so that we can check that they do not match the current signature.
	//
	plgfilehdr = (LGFILEHDR *)PvOSMemoryPageAlloc( sizeof(LGFILEHDR), NULL );
	if ( plgfilehdr == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}	
	else
		{
		CHAR			szFileFrom[16];
		CHAR			szFileTo[16];
		CHAR			szGeneration[32];
		const CHAR *	rgszT[]		= { szGeneration, szFileFrom, szFileTo };

		LGSzFromLogId( szFileFrom, lgenMin );
		LGSzFromLogId( szFileTo, lgenMax );
		sprintf( szGeneration, "%d", lCurrentGeneration );

		UtilReportEvent(
				eventWarning,
				LOGGING_RECOVERY_CATEGORY,
				DELETE_LOG_FILE_TOO_NEW_ID,
				sizeof(rgszT) / sizeof(rgszT[0]),
				rgszT,
				0,
				NULL,
				m_pinst );
		}

	for ( igen = lgenMin; igen <= lgenMax; igen++ )
		{
		CHAR		szFileT[IFileSystemAPI::cchPathMax];
		CHAR		szFullName[IFileSystemAPI::cchPathMax];
		IFileAPI *	pfapiT = NULL;

		err = ErrLGRSTOpenLogFile( pfsapi, m_szLogFilePath, igen, &pfapiT );
		if ( JET_errFileNotFound == err )
			{
			continue;
			}
		Call ( err );

		//	read and check the log signature
		//
		err = ErrLGReadFileHdr( pfapiT, plgfilehdr, fCheckLogID );
		delete pfapiT;
		pfapiT = NULL;
		Call ( err );

		//	file present with current signature,
		//	checked via ReadFileHdr with fCheckLogID set,
		//	but above the soft-recovery range so delete it.
		//
		LGSzFromLogId( szFileT, igen );
		LGMakeLogName( szFullName, szFileT );
		err = pfsapi->ErrFileDelete( szFullName );
		if ( JET_errFileNotFound == err )
			{
			err = JET_errSuccess;
			}
		Call( err );
		}

	err = JET_errSuccess;

HandleError:
	OSMemoryPageFree( plgfilehdr );
	return err;
	}


//	Redoes database operations in log from lgposRedoFrom to end.
//
//  GLOBAL PARAMETERS
//                      szLogName		(IN)		full path to szJetLog (blank if current)
//                      lgposRedoFrom	(INOUT)		starting/ending lGeneration and ilgsec.
//
//  RETURNS
//                      JET_errSuccess
//						error from called routine
//
ERR LOG::ErrLGRRedo( IFileSystemAPI *const pfsapi, CHECKPOINT *pcheckpoint, LGSTATUSINFO *plgstat )
	{
	ERR		err, errBeforeRedo = JET_errSuccess, errRedo = JET_errSuccess, errAfterRedo = JET_errSuccess;
	PIB		*ppibRedo			= ppibNil;
	LGPOS	lgposRedoFrom;
	INT		fStatus;

	//	set flag to suppress logging
	//
	m_fRecovering = fTrue;
	m_fRecoveringMode = fRecoveringRedo;

	Assert( m_pinst->m_fUseRecoveryLogFileSize == fTrue );

//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//	//	setup the sector-size checking parameters
//
Assert( m_cbSec == m_cbSecVolume );
//	Assert( m_cbSecVolume == ~(ULONG)0 );
//	{
//		CHAR rgchFullName[IFileSystemAPI::cchPathMax];
//	
//		//	get atomic write size
//
//		if ( pfsapi->ErrPathComplete( m_szLogFilePath, rgchFullName ) == JET_errInvalidPath )
//			{
//			const CHAR	*szPathT[1] = { m_szLogFilePath };
//			UtilReportEvent(
//				eventError,
//				LOGGING_RECOVERY_CATEGORY,
//				FILE_NOT_FOUND_ERROR_ID,
//				1, szPathT, 0, NULL, m_pinst );
//			return ErrERRCheck( JET_errFileNotFound );
//			}
//
//		CallR( pfsapi->ErrFileAtomicWriteSize( rgchFullName, (DWORD*)&m_cbSecVolume ) );
//	}

	//	open the proper log file
	//
	// lgposRedoFrom is based on the checkpoint, which is based on
	// lgposStart which is based on the beginning of a log
	// record (beginning of a begin-transaction).
	lgposRedoFrom = pcheckpoint->checkpoint.le_lgposCheckpoint;

	Call( ErrLGRIOpenRedoLogFile( pfsapi, &lgposRedoFrom, &fStatus ) );
	Assert( m_pfapiLog );

	//	capture the result of ErrLGRIOpenRedoLogFile; it might have a warning from ErrLGCheckReadLastLogRecordFF
	errBeforeRedo = err;

	if ( fStatus != fRedoLogFile )
		{
		Call( ErrERRCheck( JET_errMissingPreviousLogFile ) );
		}

	Assert( m_fRecoveringMode == fRecoveringRedo );
	Call( ErrLGInitLogBuffers( pcheckpoint->checkpoint.dbms_param.le_lLogBuffers ) );

	// XXX
	// The flush point should actually be after the current record
	// because the semantics of m_lgposToFlush are to point to the log
	// record that has not been flushed to disk.
	m_lgposToFlush = lgposRedoFrom;

	m_logtimeFullBackup = pcheckpoint->checkpoint.logtimeFullBackup;
	m_lgposFullBackup = pcheckpoint->checkpoint.le_lgposFullBackup;
	m_logtimeIncBackup = pcheckpoint->checkpoint.logtimeIncBackup;
	m_lgposIncBackup = pcheckpoint->checkpoint.le_lgposIncBackup;

	//	Check attached db already. No need to check in LGInitSession.
	//
	Call( ErrLGRIInitSession(
				pfsapi,
				&pcheckpoint->checkpoint.dbms_param,
				pcheckpoint->rgbAttach,
				plgstat,
				redoattachmodeInitBeforeRedo ) );
	m_fAfterEndAllSessions = fFalse;
#ifdef UNLIMITED_DB
	m_fNeedInitialDbList = fTrue;
#endif

	Assert( m_pfapiLog );

	err = ErrLGRIRedoOperations(
					pfsapi,
					&pcheckpoint->checkpoint.le_lgposCheckpoint,
					pcheckpoint->rgbAttach,
					plgstat );
	//	remember the error code from ErrLGRIRedoOperations() which may have a corruption warning
	//		from ErrLGCheckReadLastLogRecordFF() which it may eventually call
	errRedo = err;

	//	we should have the right sector size by now or an error that will make redo fail

	Assert( m_plgfilehdr != NULL );
	Assert( m_cbSec == m_plgfilehdr->lgfilehdr.le_cbSec || errRedo < 0 );
	Assert( m_cbSec == m_cbSecVolume || errRedo < 0 );
				
	if ( err < 0 )
		{
		//	Flush as much as possible before bail out

		m_fLogDisabledDueToRecoveryFailure = fTrue;
		for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid ++ )
			{
			if ( m_pinst->m_mpdbidifmp[ dbid ] < ifmpMax )
				{
				(VOID)ErrBFFlush( m_pinst->m_mpdbidifmp[ dbid ] );
				(VOID)ErrBFFlush( m_pinst->m_mpdbidifmp[ dbid ] | ifmpSLV );
				}
			}
		m_fLogDisabledDueToRecoveryFailure = fFalse;

#ifdef DEBUG
		//	Recovery should never fail unless some hardware problems
		//	or out of memory (mainly with RFS enabled)
		//	NOTE: it can also fail from corruption
		if ( JET_errDiskFull != errRedo &&
			 JET_errOutOfBuffers != errRedo &&
			 JET_errOutOfMemory != errRedo &&
//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//			 JET_errLogSectorSizeMismatch != errRedo &&
//			 JET_errLogSectorSizeMismatchDatabasesConsistent != errRedo &&
			 !FErrIsLogCorruption( errRedo ) )
			{

			//	force the error code to be reported in the assert

			Assert( JET_errSuccess != errRedo );
			CallS( errRedo );
			AssertSz( fFalse, "Unexpected recovery failure" );
			}
#endif	//	DEBUG

		if ( !m_fAfterEndAllSessions )
			{
			CallR( ErrLGRIEndAllSessionsWithError() );
			}

		Assert( m_ptablehfhash == NULL );
		}
	else
		{	
		//	Check lGenMaxRequired before any UNDO operations
		
		for ( DBID dbidT = dbidUserLeast; dbidT < dbidMax; dbidT++ )
			{
			const IFMP	ifmp	= m_pinst->m_mpdbidifmp[ dbidT ];

			if ( ifmp >= ifmpMax )
				continue;

			FMP 		*pfmpT			= &rgfmp[ ifmp ];

			Assert( !pfmpT->FReadOnlyAttach() );
			if ( pfmpT->FSkippedAttach()
				|| pfmpT->FDeferredAttach() )
				{
				//	skipped attachments is a restore-only concept
				Assert( !pfmpT->FSkippedAttach() || m_fHardRestore );
				continue;
				}

			DBFILEHDR_FIX *pdbfilehdr	= pfmpT->Pdbfilehdr();
			Assert( pdbfilehdr );

			LONG lGenMaxRequired = pdbfilehdr->le_lGenMaxRequired;
			LONG lGenCurrent = m_plgfilehdr->lgfilehdr.le_lGeneration;
			
			if ( lGenMaxRequired > lGenCurrent )
				{	
				LONG lGenMinRequired = pfmpT->Pdbfilehdr()->le_lGenMinRequired;
				CHAR szT1[16];
				CHAR szT2[16];
				CHAR szT3[16];	
				const UINT	csz = 4;
				const CHAR *rgszT[csz];

				rgszT[0] = pfmpT->SzDatabaseName();
				sprintf( szT1, "%d", lGenMinRequired );
				rgszT[1] = szT1;
				sprintf( szT2, "%d", lGenMaxRequired );
				rgszT[2] = szT2;
				sprintf( szT3, "%d", lGenCurrent );
				rgszT[3] = szT3;
		
				UtilReportEvent(	
							eventError,
							LOGGING_RECOVERY_CATEGORY,
							REDO_MISSING_HIGH_LOG_ERROR_ID,
							sizeof( rgszT ) / sizeof( rgszT[ 0 ] ),
							rgszT,
							0,
							NULL,
							m_pinst );

				//	Flush as much as possible before bail out

				m_fLogDisabledDueToRecoveryFailure = fTrue;
				for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid ++ )
					{
					if ( m_pinst->m_mpdbidifmp[ dbid ] < ifmpMax )
						{
						(VOID)ErrBFFlush( m_pinst->m_mpdbidifmp[ dbid ] );
						(VOID)ErrBFFlush( m_pinst->m_mpdbidifmp[ dbid ] | ifmpSLV );
						}
					}
				m_fLogDisabledDueToRecoveryFailure = fFalse;

				if ( !m_fAfterEndAllSessions )
					{
					CallS( ErrLGRIEndAllSessionsWithError() );
					}

				return ErrERRCheck( JET_errRequiredLogFilesMissing );
				}
			}

#ifdef DEBUG
		m_fDBGNoLog = fFalse;
#endif

		//	set checkpoint before any logging activity
		//
		m_pcheckpoint->checkpoint.le_lgposCheckpoint = pcheckpoint->checkpoint.le_lgposCheckpoint;

		BOOL fDummy;
		// Setup log buffers to have end of the current log file.
		Call( ErrLGCheckReadLastLogRecordFF( pfsapi, &fDummy ) );
		CallS( err );

		//	capture the result of this operation
		//
		errAfterRedo = err;

		// switch from a finished log file to a new one if necessary
#ifdef UNLIMITED_DB		
		const BOOL	fLGFlags	= fLGLogAttachments;
#else		
		const BOOL	fLGFlags	= 0;
#endif		
		Call( ErrLGISwitchToNewLogFile( pfsapi, fLGFlags ) );

		// allow flush thread to do flushing now.
		m_critLGFlush.Enter();
		m_critLGBuf.Enter();
		m_fNewLogRecordAdded = fTrue;
		m_critLGBuf.Leave();
		m_critLGFlush.Leave();

		/*  close and reopen log file in R/W mode
		/**/
		m_critLGFlush.Enter();
		delete m_pfapiLog;
		m_pfapiLog = NULL;
		err = pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog );
		m_critLGFlush.Leave();
		Call( err );

		//  switch to undo mode

		m_fRecoveringMode = fRecoveringUndo;

//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//		if ( m_cbSec != m_cbSecVolume )
//			{
//			if ( m_fLastLRIsShutdown || m_fAfterEndAllSessions )
//				{
//				Call( ErrERRCheck( JET_errLogSectorSizeMismatchDatabasesConsistent ) );
//				}
//			else
//				{
//				Call( ErrERRCheck( JET_errLogSectorSizeMismatch ) );
//				}
//			}

		Assert( !m_fAfterEndAllSessions || !m_fLastLRIsShutdown );
		if ( !m_fAfterEndAllSessions )
			{
			//	DbList must have been loaded bb now
			//	UNDONE: Is it possible to have the
			//	RcvUndo as the first log record in
			//	a log file (eg. crash after creating
			//	log file, but before anything but
			//	the header can be flushed?)
			Enforce( !m_fNeedInitialDbList );

			if ( !m_fLastLRIsShutdown )
				{
				//	write a RecoveryUndo record to indicate start to undo
				//	this corresponds to the RecoveryQuit record that
				//	will be written out in LGRIEndAllSessions()
				CallR( ErrLGRecoveryUndo( this ) );
				m_lgposRecoveryUndo = m_lgposLogRec;
				}

			Call( ErrLGRIEndAllSessions(
						pfsapi,
						fTrue,
						&pcheckpoint->checkpoint.le_lgposCheckpoint,
						pcheckpoint->rgbAttach ) );
			m_fAfterEndAllSessions = fTrue;

#ifdef DEBUG
			m_lgposRedoShutDownMarkGlobal = lgposMin;
#endif
			}
		//	At the end of hard recovery we have to regenerate the
		//	checkpoint file even if we had a clean shutdown in the logs
		//	Ignore any error, because in the worst case, we just end
		//	up rescanning all the log files only to find out nothing
		//	needs to be redone.
		else if ( m_fHardRestore )
			{
			/*      enable checkpoint updates */
			m_fLGFMPLoaded = fTrue;
			(VOID)ErrLGUpdateCheckpointFile( pfsapi, fFalse );
			/*      stop checkpoint updates */
			m_fLGFMPLoaded = fFalse;
            }
		
		Assert( m_pfapiLog );

		// ensure that everything hits the disk
		Call( ErrLGWaitAllFlushed( pfsapi ) );

		//	check the current generation

		Assert( lGenerationMax < lGenerationMaxDuringRecovery );
		if ( m_plgfilehdr->lgfilehdr.le_lGeneration >= lGenerationMax )
			{

			//	the current generation is beyond the last acceptable non-recovery generation
			//		(e.g. we have moved into the reserved generations which are between 
			//		 lGenerationMax and lGenerationMaxDuringRecovery)

			Assert( m_plgfilehdr->lgfilehdr.le_lGeneration <= lGenerationMaxDuringRecovery );

			//	do not allow any more generations -- user must wipe logs and restart at generation 1

			Call( ErrERRCheck( JET_errLogSequenceEndDatabasesConsistent ) );
			}
		}

HandleError:
	//	we are no longer using the recovery logfile size

	m_pinst->m_fUseRecoveryLogFileSize = fFalse;

	//	set flag to suppress logging
	//
	m_fRecovering = fFalse;
	m_fRecoveringMode = fRecoveringNone;

	//	there are 4 errors to consolidate here: err, errBeforeRedo, errRedo, errAfterRedo
	//	precedence is as follows: (most) err, errBeforeRedo, errRedo, errAfterRedo (least)

	if ( err == JET_errSuccess )
		{
		if ( errBeforeRedo == JET_errSuccess )
			{
			if ( errRedo == JET_errSuccess )
				err = errAfterRedo;
			else
				err = errRedo;
			}
		else
			err = errBeforeRedo;
		}


	if ( err >= JET_errSuccess )
		{
		//	verify the log sector size

		Assert( m_plgfilehdr != NULL );
		Assert( m_cbSec == m_plgfilehdr->lgfilehdr.le_cbSec );
		Assert( m_cbSec == m_cbSecVolume || err < 0 );

		//	verify the log file size

		const LONG lLogFileSizeHeader = LONG( ( QWORD( m_plgfilehdr->lgfilehdr.le_csecLGFile ) * 
								   			  m_plgfilehdr->lgfilehdr.le_cbSec ) / 1024 );

		if ( !m_pinst->m_fSetLogFileSize )
			{

			//	the user never set the log file size, so we will set it on their behalf

			m_pinst->m_fSetLogFileSize = fTrue;
			m_pinst->m_lLogFileSize = lLogFileSizeHeader;
			Assert( m_csecLGFile == m_plgfilehdr->lgfilehdr.le_csecLGFile );
			Assert( m_cbSec == m_plgfilehdr->lgfilehdr.le_cbSec );
			Assert( m_csecHeader == sizeof( LGFILEHDR ) / m_cbSec );
			}

		//	the user chose a specific log file size, so we must enforce it

		else if ( m_pinst->m_lLogFileSize != lLogFileSizeHeader )
			{

			//	the logfile size doesn't match

			if ( !m_pinst->m_fCleanupMismatchedLogFiles )
				{

				//	we are not allowed to cleanup the mismatched logfiles

				Error( ErrERRCheck( JET_errLogFileSizeMismatchDatabasesConsistent ), ReturnError );
				}

			//	we can cleanup the old logs/checkpoint and start a new sequence
			//
			//	if we succeed, we will return wrnCleanedUpMismatchedFiles and the user will be at gen 1
			//	if we fail, the user will be forced to delete the remaining logs/checkpoint by hand

			CallJ( ErrLGRICleanupMismatchedLogFiles( pfsapi ), ReturnError );

			//	we should have gotten this warning after successfully cleaning up the logs/checkpoint

			Assert( wrnCleanedUpMismatchedFiles == err );
			}
		}

ReturnError:

	Assert( !m_pinst->m_fUseRecoveryLogFileSize );

	return err;
	}

#ifdef ESENT

struct DBINFO {
	char * szLogfilePath;
	char * szSystemPath;
	char * szBaseName;
};

const char 	szUser[]		= "user";
const char	szPassword[]	= "";

const char	szJetInit[]		= "JetInit@4";
const char	szJetTerm2[]	= "JetTerm2@8";
const char	szJetSetSystemParameter[] = "JetSetSystemParameter@20";

typedef JET_ERR (__stdcall FNJETINIT)( JET_INSTANCE *pinstance );               
typedef JET_ERR (__stdcall FNJETTERM2)( JET_INSTANCE instance, JET_GRBIT grbit );
typedef JET_ERR (__stdcall FNJETSETSYSTEMPARAMETER)(                          
                                        JET_INSTANCE *pinstance,              
                                        JET_SESID sesid,                      
                                        unsigned long paramid,                
                                        unsigned long lParam,                 
                                        const char *sz );                      
                                                                              
typedef FNJETINIT *PFNJETINIT;                                                
typedef FNJETTERM2 *PFNJETTERM2;                                              
typedef FNJETSETSYSTEMPARAMETER *PFNJETSETSYSTEMPARAMETER;                    

//  ================================================================
JET_ERR ErrLGRecoverUsingDifferentDLL(
	const INST * const pinst,
	const DBINFO * const rgdbinfo,
	const int cdbinfo,
	const char * const szLibrary,
	const CPRINTF * pfnprintf )
//  ================================================================
	{
	JET_ERR 		err;
	JET_ERR 		errT;
	JET_INSTANCE 	instance = 0;
	LIBRARY 		library = 0;

	if( !FUtilLoadLibrary( szLibrary, &library, fGlobalEseutil ) )
		{
		const CHAR *rgszT[1];
		rgszT[0] = szLibrary;
		UtilReportEvent(
				eventError,
				GENERAL_CATEGORY,
				FILE_NOT_FOUND_ERROR_ID,
				1,
				rgszT,
				0,
				NULL,
				pinst );
		Call( ErrERRCheck( JET_errCallbackNotResolved ) );
		}
	
	PFNJETINIT					pfnjetinit;
	PFNJETTERM2					pfnjetterm2;
	PFNJETSETSYSTEMPARAMETER	pfnjetsetsystemparameter;

	if( NULL == ( pfnjetinit = (PFNJETINIT)PfnUtilGetProcAddress( library, szJetInit ) ) )
		{
		const CHAR *rgszT[2];
		rgszT[0] = szJetInit;
		rgszT[1] = szLibrary;
		UtilReportEvent(
				eventError,
				GENERAL_CATEGORY,
				FUNCTION_NOT_FOUND_ERROR_ID,
				2,
				rgszT,
				0,
				NULL,
				pinst );
		Call( ErrERRCheck( JET_errCallbackNotResolved ) );
		}

	if( NULL == ( pfnjetterm2 = (PFNJETTERM2)PfnUtilGetProcAddress( library, szJetTerm2 ) ) )
		{
		const CHAR *rgszT[2];
		rgszT[0] = szJetTerm2;
		rgszT[1] = szLibrary;
		UtilReportEvent(
				eventError,
				GENERAL_CATEGORY,
				FUNCTION_NOT_FOUND_ERROR_ID,
				2,
				rgszT,
				0,
				NULL,
				pinst );
		Call( ErrERRCheck( JET_errCallbackNotResolved ) );
		}

	if( NULL == ( pfnjetsetsystemparameter = (PFNJETSETSYSTEMPARAMETER)PfnUtilGetProcAddress( library, szJetSetSystemParameter ) ) )
		{
		const CHAR *rgszT[2];
		rgszT[0] = szJetSetSystemParameter;
		rgszT[1] = szLibrary;
		UtilReportEvent(
				eventError,
				GENERAL_CATEGORY,
				FUNCTION_NOT_FOUND_ERROR_ID,
				2,
				rgszT,
				0,
				NULL,
				pinst );
		Call( ErrERRCheck( JET_errCallbackNotResolved ) );
		}

	int idbinfo;
	for( idbinfo = 0; idbinfo < cdbinfo; idbinfo++ )
		{
		(*pfnprintf)( "Recovering using %s (LogfilePath: %s, SystemPath: %s)\r\n",
					szLibrary,
					rgdbinfo[idbinfo].szLogfilePath,
					rgdbinfo[idbinfo].szSystemPath );

		Call( (*pfnjetsetsystemparameter)( &instance, 0, JET_paramDatabasePageSize, g_cbPage, NULL ) );
		Call( (*pfnjetsetsystemparameter)( &instance, 0, JET_paramRecovery, 0, "on" ) );
		Call( (*pfnjetsetsystemparameter)( &instance, 0, JET_paramLogFilePath, 0, rgdbinfo[idbinfo].szLogfilePath ) );
		Call( (*pfnjetsetsystemparameter)( &instance, 0, JET_paramSystemPath, 0, rgdbinfo[idbinfo].szSystemPath ) );
		Call( (*pfnjetsetsystemparameter)( &instance, 0, JET_paramBaseName, 0, rgdbinfo[idbinfo].szBaseName ) );
		Call( (*pfnjetsetsystemparameter)( &instance, 0, JET_paramEventLogCache, g_cbEventHeapMax, NULL ) );

		err = (*pfnjetinit)( &instance );
		errT = (*pfnjetterm2)( instance, JET_bitTermComplete );
		if( errT >= 0 )
			{
			errT = err;
			}
		Call( err );
		}

HandleError:
	UtilFreeLibrary( library );
	return err;
	}

#endif	//	ESENT


//
//  Soft start tries to start the system from current directory.
//  The database maybe in one of the following state:
//  1) no log files.
//  2) database was shut down normally.
//  3) database was rolled back abruptly.
//  In case 1, a new log file is generated.
//  In case 2, the last log file is opened.
//  In case 3, soft redo is incurred.
//  At the end of the function, it a proper szJetLog must exists.
//
ERR LOG::ErrLGSoftStart( IFileSystemAPI *const pfsapi, BOOL fNewCheckpointFile, BOOL *pfJetLogGeneratedDuringSoftStart )
	{
	ERR					err;
	BOOL				fCloseNormally;
	BOOL				fSoftRecovery = fFalse;
	CHAR				szFNameT[IFileSystemAPI::cchPathMax];
	CHAR				szT[IFileSystemAPI::cchPathMax];
	CHAR   				szPathJetChkLog[IFileSystemAPI::cchPathMax];
	LGFILEHDR			*plgfilehdrCurrent = NULL;
	LGFILEHDR			*plgfilehdrT = NULL;
	CHECKPOINT			*pcheckpointT = NULL;
	LONG				lgenT;
	ULONG				cbSecVolumeSave;
	BOOL				fCreatedReserveLogs = fFalse;
	LONG				lLogBuffersSaved = m_pinst->m_lLogBuffers;

	*pfJetLogGeneratedDuringSoftStart = fFalse;
	m_fAbruptEnd = fFalse;

	//	disable the sector-size checks

	Assert( m_cbSecVolume != ~(ULONG)0 );
	Assert( m_cbSec == m_cbSecVolume );
	cbSecVolumeSave = m_cbSecVolume;
//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//	m_cbSecVolume = ~(ULONG)0;

	//	use the right log file size for recovery
	//
	Assert( m_pinst->m_fUseRecoveryLogFileSize == fFalse );
	m_pinst->m_fUseRecoveryLogFileSize = fTrue;

	//	set m_szLogCurrent
	//
	m_szLogCurrent = m_szLogFilePath;

	//	if the m_fDeleteOldLogs set, then check if it is consistent.
	//	If so, then delete the logs and continue as no log exists before.
	//
	if ( m_fDeleteOldLogs )
		{
		Assert( !m_pfapiLog );
		
		if ( ( err = ErrLGOpenJetLog( pfsapi ) ) == JET_errSuccess )
			{
			err = ErrLGReadFileHdr( m_pfapiLog, m_plgfilehdr, fCheckLogID );
			delete m_pfapiLog;
			m_pfapiLog = NULL;
			}

		if ( err == JET_errBadLogVersion )
			{
#ifdef ESENT
#ifndef _WIN64	//	no upgrade path from 32-bit to 64-bit

			const char * const szOldDLL = "ESENT97.DLL";
			
			DBINFO dbinfo;
			dbinfo.szLogfilePath 	= m_szLogFilePath;;
			dbinfo.szSystemPath		= m_pinst->m_szSystemPath;
			dbinfo.szBaseName		= m_pinst->m_plog->m_szBaseName;

#ifdef DEBUG
			Call( ErrLGRecoverUsingDifferentDLL( m_pinst, &dbinfo, 1, szOldDLL, CPRINTFSTDOUT::PcprintfInstance() ) );
#else
			Call( ErrLGRecoverUsingDifferentDLL( m_pinst, &dbinfo, 1, szOldDLL, CPRINTFNULL::PcprintfInstance() ) );
#endif

#endif	//	!_WIN64
#endif	//	ESENT
			
			//	delete all the logs
			//
			LONG lGen, lGenLast;
			CHAR rgchFName[IFileSystemAPI::cchPathMax];
			CHAR szPath[IFileSystemAPI::cchPathMax];
			
			(void) ErrLGIGetGenerationRange( pfsapi, m_szLogCurrent, &lGen, &lGenLast );

			//	delete jetxxxx.log
			//

			//	start deleting only if we found something (lGen > 0)
			//
			for ( ; lGen > 0 && lGen <= lGenLast; lGen++ )
				{
				LGSzFromLogId( rgchFName, lGen );
				strcpy( szPath, m_szLogCurrent );
				strcat( szPath, rgchFName );
				strcat( szPath, szLogExt );
				(VOID)pfsapi->ErrFileDelete( szPath );
				}

			//	delete jet.log, jettemp.log
			//			
			strcpy( szPath, m_szLogCurrent );
			strcat( szPath, m_szJetLog );
			(VOID)pfsapi->ErrFileDelete( szPath );

			strcpy( szPath, m_szLogCurrent );
			strcat( szPath, m_szJetTmpLog );
			(VOID)pfsapi->ErrFileDelete( szPath );
			}
		}
		
	//	CONSIDER: for tight check, we may check if all log files are
	//	CONSIDER: continuous by checking the generation number and
	//	CONSIDER: previous gen's creatiion date.

	//	try to open current log file to decide the status of log files.
	//
	err = ErrLGOpenJetLog( pfsapi );
	if ( err < 0 )
		{
		if ( JET_errFileNotFound != err )
			{

			//	we were unable to open edb.log or edbtmp.log
			//	also, the error doesn't reveal whether or not edb.log and edbtmp.log even exist
			//	we'll treat the error as a critical failure during file-open -- we can not proceed with recovery

			goto HandleError;
			}

		//	neither szJetLog nor szJetTmpLog exist. If no old generation
		//	files exists, gen a new logfile at generation 1.
		//
		CallR ( ErrLGIGetGenerationRange( pfsapi, m_szLogCurrent, NULL, &lgenT ) );
		if ( lgenT != 0 )
			{
			if ( !m_fReplayingReplicatedLogFiles )
				{
				//	if edbxxxxx.log exist but no edb.log, return error.
				//
				LGReportError( LOG_OPEN_FILE_ERROR_ID, JET_errFileNotFound );
				return ErrERRCheck( JET_errMissingLogFile );
				}

			//	Open the last generation and replay the logs

			LGSzFromLogId( szFNameT, lgenT );
			LGMakeLogName( m_szLogName, szFNameT );
			err = pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog );
			if ( err < 0 )
				{
				LGReportError( LOG_OPEN_FILE_ERROR_ID, err );
				goto HandleError;
				}
			goto CheckLogs;
			}
		else if ( fGlobalEseutil )
			{
			//	if running from ESEUTIL, never create new log stream
			LGReportError( LOG_OPEN_FILE_ERROR_ID, JET_errFileNotFound );
			return ErrERRCheck( JET_errMissingLogFile );
			}

		//	Delete the leftover checkpoint file before creating new gen 1 log file
		
		LGFullNameCheckpoint( pfsapi, szPathJetChkLog );
		(VOID)pfsapi->ErrFileDelete( szPathJetChkLog );

		//	use the right log file size for generating the new log file

		m_pinst->m_fUseRecoveryLogFileSize = fFalse;

		//	restore the volume sector size for creating the new log file

//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//		Assert( m_cbSecVolume == ~(ULONG)0 );
		m_cbSecVolume = cbSecVolumeSave;
		m_cbSec = m_cbSecVolume;
		m_csecHeader = sizeof( LGFILEHDR ) / m_cbSec;
		m_csecLGFile = CsecLGIFromSize( m_pinst->m_lLogFileSize );

		//	NOTE: no need to force the log buffer size here -- we won't be recovering, and
		//		  we won't fill up the current buffer (filling up the buffer is a problem
		//		  because there could be more than 2 active logs in it if it were too large)

		m_critLGFlush.Enter();
		
		if ( ( err = ErrLGNewLogFile( pfsapi, 0, fLGOldLogNotExists ) ) < 0 ) // generation 0 + 1 	
			{
			m_critLGFlush.Leave();
			goto HandleError;
			}
		
		m_critLGBuf.Enter();
		UtilMemCpy( m_plgfilehdr, m_plgfilehdrT, sizeof( LGFILEHDR ) );
		m_isecWrite = m_csecHeader;
		m_critLGBuf.Leave();
		
		m_critLGFlush.Leave();

		//	set flag for initialization
		//
		*pfJetLogGeneratedDuringSoftStart = fTrue;

		Assert( m_plgfilehdr->lgfilehdr.le_lGeneration == 1 );

		// XXX
		// Must fix these Assert()'s.
		//Assert( m_pbLastMSFlush == m_pbLGBufMin );
		//Assert( m_lgposLastMSFlush.lGeneration == 1 );
		}
	else
		{
CheckLogs:
		//	read current log file header
		//
		Call( ErrLGReadFileHdr( m_pfapiLog, m_plgfilehdr, fCheckLogID ) );

		//	re-initialize log buffers according to check pt env
		//
		Call( ErrLGInitLogBuffers( m_plgfilehdr->lgfilehdr.dbms_param.le_lLogBuffers ) );

		//	restore the volume sector size for ErrLGCheckReadLastLogRecordFF

		m_cbSecVolume = cbSecVolumeSave;

		//	verify and patch the current log file

		err = ErrLGCheckReadLastLogRecordFF( pfsapi, &fCloseNormally );

//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//		//	reset the volume sector size
//
//		m_cbSecVolume = ~(ULONG)0;

		//	eat errors about corruption -- we will go up to the point of corruption 
		//		and then return the right error in ErrLGRRedo()

		if ( err == JET_errSuccess || FErrIsLogCorruption( err ) )
			{
			err = JET_errSuccess;
			}
		else
			{
			Assert( err < 0 );
			Call( err );
			}

		delete m_pfapiLog;
		m_pfapiLog = NULL;

		//	if delete out of range logs is set then delete all out of range logs
		//
		if ( !m_fHardRestore && m_fDeleteOutOfRangeLogs )
			{
			Call ( ErrLGDeleteOutOfRangeLogFiles( pfsapi ) );
			}

		//	If the edb.log was not closed normally or the checkpoint file was
		//	missing and new one is created, then do soft recovery.
		//
		if ( !fCloseNormally || fNewCheckpointFile )
			{
			BOOL		fOpenFile = fFalse;

			//	always redo from beginning of a log generation.
			//	This is needed such that the attach info will be matching
			//	the with the with the redo point. Note that the attach info
			//	is not necessarily consistent with the checkpoint.
			//
			if ( plgfilehdrT == NULL )
				{
				plgfilehdrT = (LGFILEHDR *)PvOSMemoryPageAlloc( sizeof(LGFILEHDR), NULL );
				if  ( plgfilehdrT == NULL )
					{
					err = ErrERRCheck( JET_errOutOfMemory );
					goto HandleError;
					}
				}

			if ( pcheckpointT == NULL )
				{
				pcheckpointT = (CHECKPOINT *)PvOSMemoryPageAlloc( sizeof(CHECKPOINT), NULL );
				if  ( pcheckpointT == NULL )
					{
					err = ErrERRCheck( JET_errOutOfMemory );
					goto HandleError;
					}
				}
			
			//  did not terminate normally and need to redo from checkpoint
			//
			LGFullNameCheckpoint( pfsapi, szPathJetChkLog );

			if ( fNewCheckpointFile )
				{
				//	Delete the newly created empty checkpoint file.
				//	Let redo recreate one.
				 
				(VOID)pfsapi->ErrFileDelete( szPathJetChkLog );
				goto DoNotUseCheckpointFile;
				}

			//	if checkpoint could not be read, then revert to redoing
			//	log from first log record in first log generation file.
			//
			err = ErrLGReadCheckpoint( pfsapi, szPathJetChkLog, pcheckpointT, fFalse );
			if ( err >= 0 )
				{
				m_logtimeFullBackup = pcheckpointT->checkpoint.logtimeFullBackup;
				m_lgposFullBackup = pcheckpointT->checkpoint.le_lgposFullBackup;
				m_logtimeIncBackup = pcheckpointT->checkpoint.logtimeIncBackup;
				m_lgposIncBackup = pcheckpointT->checkpoint.le_lgposIncBackup;
				
				if ( (LONG) m_plgfilehdr->lgfilehdr.le_lGeneration == (LONG) pcheckpointT->checkpoint.le_lgposCheckpoint.le_lGeneration )
					{
					err = ErrLGOpenJetLog( pfsapi );
					if ( JET_errFileNotFound == err )
						{
						//	all other errors will be reported in ErrLGOpenJetLog()
						LGReportError( LOG_OPEN_FILE_ERROR_ID, JET_errFileNotFound );
						}
					}
				else
					{
					LGSzFromLogId( szFNameT, pcheckpointT->checkpoint.le_lgposCheckpoint.le_lGeneration );
					strcpy( szT, m_szLogFilePath );
					strcat( szT, szFNameT );
					strcat( szT, szLogExt );
					err = pfsapi->ErrFileOpen( szT, &m_pfapiLog, fTrue );
					if ( err < 0 )
						{
						CHAR s[20];
						const UINT csz = 2;
						const CHAR *rgsz[csz];
						_itoa( err, s, 10 );
						rgsz[0] = szT;
						rgsz[1] = s;
						UtilReportEvent( 
							eventError, 
							LOGGING_RECOVERY_CATEGORY, 
							LOG_OPEN_FILE_ERROR_ID, 
							csz, 
							rgsz, 
							0, 
							NULL,
							m_pinst );
						}
					}
				//	read log file header
				//
				if ( err >= 0 )
					{
					fOpenFile = fTrue;
					err = ErrLGReadFileHdr( m_pfapiLog, plgfilehdrT, fCheckLogID );
					if ( err >= 0 )
						{
						plgfilehdrCurrent = plgfilehdrT;
						}
					}

				if ( JET_errFileNotFound == err )
					{
					err = ErrERRCheck( JET_errMissingLogFile );
					}
				}
			else
				{
DoNotUseCheckpointFile:
				(void) ErrLGIGetGenerationRange( pfsapi, m_szLogFilePath, &lgenT, NULL );
				if ( lgenT == 0 )
					{
					plgfilehdrCurrent = m_plgfilehdr;
					err = JET_errSuccess;
					}
				else
					{
					LGSzFromLogId( szFNameT, lgenT );
					strcpy( szT, m_szLogFilePath );
					strcat( szT, szFNameT );
					strcat( szT, szLogExt );
					err = pfsapi->ErrFileOpen( szT, &m_pfapiLog, fTrue );
					//	read log file header
					//
					if ( err >= 0 )
						{
						fOpenFile = fTrue;
						err = ErrLGReadFileHdr( m_pfapiLog, plgfilehdrT, fCheckLogID );
						if ( err >= 0 )
							{
							plgfilehdrCurrent = plgfilehdrT;
							}
						}
					else
						{
						CHAR s[20];
						const UINT csz = 2;
						const CHAR *rgsz[csz];
						_itoa( err, s, 10 );
						rgsz[0] = szT;
						rgsz[1] = s;
						UtilReportEvent( 
							eventError, 
							LOGGING_RECOVERY_CATEGORY, 
							LOG_OPEN_FILE_ERROR_ID, 
							csz, 
							rgsz,
							0,
							NULL,
							m_pinst );
						}
					}
				}

			if ( err >= 0 )
				{
				//	set up checkpoint

				//	Make the checkpoint point to the start of this log generation so that
				//	we replay all attachment related log records.
				pcheckpointT->checkpoint.dbms_param = plgfilehdrCurrent->lgfilehdr.dbms_param;
				pcheckpointT->checkpoint.le_lgposCheckpoint.le_lGeneration = plgfilehdrCurrent->lgfilehdr.le_lGeneration;
				pcheckpointT->checkpoint.le_lgposCheckpoint.le_isec = (WORD) m_csecHeader;
				pcheckpointT->checkpoint.le_lgposCheckpoint.le_ib = 0;
				UtilMemCpy( pcheckpointT->rgbAttach, plgfilehdrCurrent->rgbAttach, cbAttach );
				}
				
			if ( fOpenFile )
				{
				delete m_pfapiLog;
				m_pfapiLog = NULL;
				}

			Call( err );

			//	set log path to current directory
			//
			Assert( m_szLogCurrent == m_szLogFilePath );

			//	create the reserve logs

			Assert( m_pinst->m_fUseRecoveryLogFileSize );
			Assert( CsecLGIFromSize( m_pinst->m_lLogFileSizeDuringRecovery ) == m_csecLGFile );
			Assert( !fCreatedReserveLogs );
			m_critLGResFiles.Enter();
			m_ls = lsNormal;
			err = ErrLGICreateReserveLogFiles( pfsapi, fTrue );
			m_critLGResFiles.Leave();
			Call( err );
			fCreatedReserveLogs = fTrue;

			UtilReportEvent(
					eventInformation,
					LOGGING_RECOVERY_CATEGORY, 
					START_REDO_ID,
					0,
					NULL,
					0,
					NULL,
					m_pinst );
			fSoftRecovery = fTrue;
				
			//	redo from last checkpoint
			//
			m_fAbruptEnd = fFalse;
			m_errGlobalRedoError = JET_errSuccess;
			Call( ErrLGRRedo( pfsapi, pcheckpointT, NULL ) )

			if ( wrnCleanedUpMismatchedFiles == err )
				{

				//	special warning from ErrLGRedo indicating that we cleaned up (deleted) old log files
				//		and the old checkpoint file because the log files had a different size than we 
				//		wanted and the user set JET_paramCleanupMismatchedLogFiles 
				//	after the cleanup, we created edb.log using the new log file size requested by the user
				//	we do all this nonsense because the DS doesn't want to do it themselves

				Assert( m_pinst->m_fCleanupMismatchedLogFiles );

				//	we created a new log file (at the end of ErrLGRRedo)

				*pfJetLogGeneratedDuringSoftStart = fTrue;
				}
			else
				{
				CallS( err );	//	no other warnings expected
				}

			//	we should be using the right log file size now

			Assert( m_pinst->m_fUseRecoveryLogFileSize == fFalse );

			//	sector-size checking should now be on

			Assert( m_cbSecVolume != ~(ULONG)0 );
			Assert( m_cbSec == m_cbSecVolume );

			m_critLGFlush.Enter();
			delete m_pfapiLog;
			m_pfapiLog = NULL;
			m_critLGFlush.Leave();

			if ( fGlobalRepair && m_errGlobalRedoError != JET_errSuccess )
				{
				Call( ErrERRCheck( JET_errRecoveredWithErrors ) );
				}

			UtilReportEvent(
					eventInformation,
					LOGGING_RECOVERY_CATEGORY, 
					STOP_REDO_ID,
					0,
					NULL,
					0,
					NULL,
					m_pinst );
			}
		else
			{
			//	we did not need to run recovery
			//

			//	do not use the recovery log file size anymore
			//	
			m_pinst->m_fUseRecoveryLogFileSize = fFalse;

			//	restore the volume sector size
			//
//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//			Assert( m_cbSecVolume == ~(ULONG)0 );
			m_cbSecVolume = cbSecVolumeSave;
			m_cbSec = m_cbSecVolume;
			m_csecHeader = sizeof( LGFILEHDR ) / m_cbSec;

			//	setup the log file size
			//
			if ( !m_pinst->m_fSetLogFileSize )
				{

				//	the user never specified a log-file size, but edb.log exists
				//	set it to the size of edb.log on the user's behalf

				m_pinst->m_fSetLogFileSize = fTrue;
				Assert( 0 != m_pinst->m_lLogFileSizeDuringRecovery );
				m_pinst->m_lLogFileSize = m_pinst->m_lLogFileSizeDuringRecovery;
				}

			//	the user chose a specific log file size, so we must enforce it
			//
			else if ( m_pinst->m_lLogFileSize != m_pinst->m_lLogFileSizeDuringRecovery )
				{
				//	the logfile size doesn't match
				//
				if ( !m_pinst->m_fCleanupMismatchedLogFiles )
					{
					//	we are not allowed to cleanup the mismatched logfiles
					//
					Error( ErrERRCheck( JET_errLogFileSizeMismatchDatabasesConsistent ), HandleError );
					}

				//	we can cleanup the old logs/checkpoint and start a new sequence
				//
				//	if we succeed, we will return wrnCleanedUpMismatchedFiles and the user will be at gen 1
				//	if we fail, the user will be forced to delete the remaining logs/checkpoint by hand
				//
				Call( ErrLGRICleanupMismatchedLogFiles( pfsapi ) );

				//	we should have gotten this warning after successfully cleaning up the logs/checkpoint
				//
				Assert( wrnCleanedUpMismatchedFiles == err );

				//	we created a new log file, so we should clean it up if we fail 
				//	(leaves us with an empty log set which is ok because we are 100% recovered)
				//
				*pfJetLogGeneratedDuringSoftStart = fTrue;

				//	close the log file (code below expects it to be closed)
				//
				m_critLGFlush.Enter();
				delete m_pfapiLog;
				m_pfapiLog = NULL;
				m_critLGFlush.Leave();
				}

			//	extract the size of the log in sectors (some codepaths don't set this, so we should do it now)
			//
			m_csecLGFile = CsecLGIFromSize( m_pinst->m_lLogFileSize );
			}
		}

	//	we should now be using the right log file size
	//
	Assert( m_pinst->m_fUseRecoveryLogFileSize == fFalse );

	//	sector-size checking should now be on
	//
	Assert( m_cbSecVolume != ~(ULONG)0 );
	Assert( m_cbSec == m_cbSecVolume );

	if ( !fCreatedReserveLogs )
		{
		//	create the reserve logs
		//
		Assert( m_szLogCurrent == m_szLogFilePath );
		m_critLGResFiles.Enter();
		m_ls = lsNormal;
		err = ErrLGICreateReserveLogFiles( pfsapi, fTrue );
		m_critLGResFiles.Leave();
		Call( err );
		fCreatedReserveLogs = fTrue;
		}

	//	at this point, we have a szJetLog file, reopen the log files
	//
	m_fAbruptEnd = fFalse;

	//	disabled flushing while we reinit the log buffers and check the last log file

	m_critLGFlush.Enter();
	m_critLGBuf.Enter();
	m_fNewLogRecordAdded = fFalse;
	m_critLGBuf.Leave();
	m_critLGFlush.Leave();

	//	re-initialize the buffer manager with user settings
	//
#ifdef AFOXMAN_FIX_148537

	//	NOTE: we MUST force the number of log buffers <= log file size
	//		  due to issues with the log buffer holding more than 2 log files

	Assert( m_csecLGFile == CsecLGIFromSize( m_pinst->m_lLogFileSize ) );

	UINT	csecMin;
	UINT	csecMax;

	Assert( 0 == OSMemoryPageReserveGranularity() % m_cbSec );
	csecMin = OSMemoryPageReserveGranularity() / m_cbSec;
	csecMax = CsecUtilAllocGranularityAlign( m_csecLGFile, m_cbSec );
	if ( csecMax > m_csecLGFile )
		{
		Assert( csecMax >= 2 * ( OSMemoryPageReserveGranularity() / m_cbSec ) );
		Assert( csecMax - ( OSMemoryPageReserveGranularity() / m_cbSec ) <= m_csecLGFile );
		csecMax -= OSMemoryPageReserveGranularity() / m_cbSec;
		}
	Assert( csecMax > 0 );
	Assert( CsecUtilAllocGranularityAlign( csecMax, m_cbSec ) == csecMax );
	Assert( csecMax <= m_csecLGFile );
	Assert( csecMin <= csecMax );

	UINT	csecBuf;

	csecBuf = CsecUtilAllocGranularityAlign( lLogBuffersSaved, m_cbSec );
	if ( csecBuf < csecMin )
		{
		csecBuf = csecMin;
		}
	else if ( csecBuf > csecMax )
		{
		csecBuf = csecMax;
		}
	Assert( csecBuf > 0 );
	Assert( csecBuf <= m_csecLGFile );
	Assert( CsecUtilAllocGranularityAlign( csecBuf, m_cbSec ) == csecBuf );

	m_pinst->m_lLogBuffers = csecBuf;
	Call( ErrLGInitLogBuffers( m_pinst->m_lLogBuffers ) );
#else	//	!AFOXMAN_FIX_148537
	Call( ErrLGInitLogBuffers( lLogBuffersSaved ) );
#endif	//	AFOXMAN_FIX_148537

	//  reopen the log file
	//
	LGMakeLogName( m_szLogName, (CHAR *)m_szJet );
	err = pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog, fTrue );
	if ( err < 0 )
		{
		LGReportError( LOG_OPEN_FILE_ERROR_ID, err );
		goto HandleError;
		}
	err = ErrLGReadFileHdr( m_pfapiLog, m_plgfilehdr, fCheckLogID );
	if ( err == JET_errLogFileSizeMismatch )
		{
		err = ErrERRCheck( JET_errLogFileSizeMismatchDatabasesConsistent );
		}
	else if ( err == JET_errLogSectorSizeMismatch )
		{
//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
Assert( fFalse );
		err = ErrERRCheck( JET_errLogSectorSizeMismatchDatabasesConsistent );
		}
	Call( err );

	//	set up log variables properly

	Call( ErrLGCheckReadLastLogRecordFF( pfsapi, &fCloseNormally ) );
	CallS( err );
	err = ErrLGISwitchToNewLogFile( pfsapi, 0 );
	if ( err == JET_errLogFileSizeMismatch )
		{
		err = ErrERRCheck( JET_errLogFileSizeMismatchDatabasesConsistent );
		}
	else if ( err == JET_errLogSectorSizeMismatch )
		{
//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
Assert( fFalse );
		err = ErrERRCheck( JET_errLogSectorSizeMismatchDatabasesConsistent );
		}
	else if ( err == JET_errLogSequenceEnd )
		{
		err = ErrERRCheck( JET_errLogSequenceEndDatabasesConsistent );
		}
	Call( err );
	if ( !fCloseNormally && !(*pfJetLogGeneratedDuringSoftStart ) )
		{
		Assert( fCloseNormally );
		//	Unknown reason to fail to open for logging, most likely
		//	the file got locked.
		Call( ErrERRCheck( JET_errLogWriteFail ) );
		}

	//	check for log-sequence-end

	if ( m_fLogSequenceEnd )
		{
		Assert( m_plgfilehdr->lgfilehdr.le_lGeneration >= lGenerationMax );
		Error( ErrERRCheck( JET_errLogSequenceEndDatabasesConsistent ), HandleError );
		}
	else
		{
		Assert( m_plgfilehdr->lgfilehdr.le_lGeneration < lGenerationMax );
		}

	delete m_pfapiLog;
	m_pfapiLog = NULL;
	err = pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog );
	if ( err < 0 )
		{
		LGReportError( LOG_OPEN_FILE_ERROR_ID, err );
		goto HandleError;
		}

	//	should be set properly
	//
	Assert( m_isecWrite != 0 );

	//  m_pbEntry and m_pbWrite were set for next record in LocateLastLogRecord
	//
	Assert( m_pbWrite == PbSecAligned(m_pbWrite) );
	Assert( m_pbWrite <= m_pbEntry );
	Assert( m_pbEntry <= m_pbWrite + m_cbSec );

#ifdef	AFOXMAN_FIX_148537

	//	verify that the log buffer size <= log file size

	Assert( m_csecLGBuf <= m_csecLGFile );

#else	//	!AFOXMAN_FIX_148537
#endif	//	AFOXMAN_FIX_148537

	Assert( m_fRecovering == fFalse );
 	Assert( m_fHardRestore == fFalse );

 	m_fNewLogRecordAdded = fTrue;

HandleError:
	if ( err < 0 )
		{
		Assert( m_fHardRestore == fFalse );

		delete m_pfapiLog;
		m_pfapiLog = NULL;

		if ( fSoftRecovery )
			{
			UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, RESTORE_DATABASE_FAIL_ID, err, m_pinst );
			}
		}

	OSMemoryPageFree( plgfilehdrT );

	OSMemoryPageFree( pcheckpointT );

	m_pinst->m_fUseRecoveryLogFileSize = fFalse;
	m_cbSecVolume = cbSecVolumeSave;

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_osu\eventu.cxx ===
#include "osustd.hxx"

#ifdef MINIMAL_FUNCTIONALITY
#else

#include "std.hxx"

#include <malloc.h>

void UtilReportEvent(
	const EEventType	type, 
	const CategoryId	catid, 
	const MessageId		msgid, 
	const DWORD			cString, 
	const _TCHAR*		rgpszString[], 
	const DWORD			cbRawData, 
	void*				pvRawData, 
	const INST*			pinst,
	const LONG			lEventLoggingLevel )
	{
	extern LONG			g_lEventLoggingLevel;
	extern BOOL			g_fNoInformationEvent;
	const LONG			levelMaxReportable		= ( NULL != pinst ?  pinst->m_lEventLoggingLevel : g_lEventLoggingLevel );
	const UINT			cAdditionalParam		= 3;
	
	if ( lEventLoggingLevel > levelMaxReportable )
		{
		return;
	 	}
	else if ( eventInformation == type )
		{
		const BOOL	fIgnoreEvent	= ( NULL != pinst ? pinst->m_fNoInformationEvent : g_fNoInformationEvent );
		if ( fIgnoreEvent )
			return;
		}


	const _TCHAR**	rgpsz	= (const _TCHAR**)_alloca( sizeof( const _TCHAR* ) * ( cString + cAdditionalParam ) );

	//  validate IN args

    Assert( catid < MAC_CATEGORY );
    Assert( DWORD( WORD( catid ) ) == catid );
    Assert( DWORD( WORD( cString + 2 ) ) == cString + 2 );

    //  get event source and process ID strings
	
	if ( pinst && pinst->m_szEventSource && pinst->m_szEventSource[0] != 0 )
   		rgpsz[0] = pinst->m_szEventSource;
   	else if ( g_szEventSource[0] != 0 )
   		rgpsz[0] = g_szEventSource;
   	else
		rgpsz[0] = SzUtilProcessName();
 
	_TCHAR szPID[16];
	_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
	rgpsz[1] = szPID;

	_TCHAR szDisplayName[JET_cbFullNameMost + 3]; // 3 = sizof(": ") + 1
	/*
	IF 		m_szDisplayName exists
   	THEN 	display m_szDisplayName
   	ELSE IF 	m_szInstanceName exists
   		 THEN	display m_szInstanceName
   	ELSE	display nothing
	*/
	if ( pinst && pinst->m_szDisplayName ) 
		{
		_stprintf( szDisplayName, _T( "%s: " ), pinst->m_szDisplayName );
			}
	else if ( pinst && pinst->m_szInstanceName ) 
		{
		_stprintf( szDisplayName, _T( "%s: " ), pinst->m_szInstanceName );
		}
	else 
		{
		_tcscpy( szDisplayName, "" );
		}
	rgpsz[2] = szDisplayName;
		
	//  copy in remaining strings

	UtilMemCpy( &rgpsz[3], rgpszString, sizeof(const _TCHAR*) * cString );

	//	Get event source key in case we need to open the event source.

	const _TCHAR* szEventSourceKey;
	
	if ( pinst && pinst->m_szEventSourceKey && pinst->m_szEventSourceKey[0] != 0 )
   		szEventSourceKey = pinst->m_szEventSourceKey;
   	else if ( g_szEventSourceKey[0] != 0 )
   		szEventSourceKey = g_szEventSourceKey;
   	else
		szEventSourceKey = SzUtilImageVersionName();
 
	//  the event log isn't open
	
	OSEventReportEvent(
			szEventSourceKey,
			type,
			catid,
			msgid, 
			cString + cAdditionalParam,
			rgpsz,
			cbRawData,
			pvRawData );
			
	}


//	reports error event in the context of a category and optionally in the
//	context of a MessageId.  If the MessageId is 0, then a MessageId is chosen
//	based on the given error code.  If MessageId is !0, then the appropriate
//	event is reported

void UtilReportEventOfError(
	const CategoryId	catid,
	const MessageId		msgid,
	const ERR			err,
	const INST *		pinst )
	{
	_TCHAR				szT[16];
	const _TCHAR *		rgszT[1];

	_stprintf( szT, _T( "%d" ), err );
	rgszT[0] = szT;

	Assert( 0 != msgid );
//	the following code is dead, as the
//	assert above affirms
//	if ( 0 == msgid && JET_errDiskFull == err )
//		{
//		msgid = DISK_FULL_ERROR_ID;
//		rgszT[0] = pinst->m_plog->m_szJetLog;
//		}

	UtilReportEvent( eventError, catid, msgid, 1, rgszT, 0, NULL, pinst );
	}


#endif	//	MINIMAL_FUNCTIONALITY


//  terminate event subsystem

void OSUEventTerm()
	{
	//  nop
	}


//  init event subsystem

ERR ErrOSUEventInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_osu\configu.cxx ===
#include "osustd.hxx"


#ifdef DISABLE_REGISTRY

#define OSUConfigLoadParameterOverrides()

#else

//  Persistent Configuration

//  system parameters

LOCAL const DWORD rgparam[] =
	{
	JET_paramSystemPath,
	JET_paramTempPath,
	JET_paramLogFilePath,
	JET_paramLogFileFailoverPath,
	JET_paramBaseName,
	JET_paramMaxSessions,
	JET_paramMaxOpenTables,
	JET_paramPreferredMaxOpenTables,
	JET_paramMaxCursors,
	JET_paramMaxVerPages,
	JET_paramGlobalMinVerPages,
	JET_paramPreferredVerPages,
	JET_paramMaxTemporaryTables,
	JET_paramLogFileSize,
	JET_paramLogBuffers,
	JET_paramLogCheckpointPeriod,
	JET_paramCommitDefault,
	JET_paramCircularLog,
	JET_paramDbExtensionSize,
	JET_paramPageTempDBMin,
	JET_paramPageFragment,
	JET_paramVersionStoreTaskQueueMax, 
	JET_paramCacheSizeMin,
	JET_paramCacheSizeMax,
	JET_paramCheckpointDepthMax,
	JET_paramLRUKCorrInterval,
	JET_paramLRUKHistoryMax,
	JET_paramLRUKPolicy,
	JET_paramLRUKTimeout,
	JET_paramStartFlushThreshold,
	JET_paramStopFlushThreshold,
	JET_paramExceptionAction,
	JET_paramEventLogCache,
	JET_paramRecovery,
	JET_paramEnableOnlineDefrag,
	JET_paramAssertAction,
	JET_paramRFS2IOsPermitted,
	JET_paramRFS2AllocsPermitted,
	JET_paramCheckFormatWhenOpenFail,
	JET_paramEnableIndexChecking,
	JET_paramEnableTempTableVersioning,
	JET_paramZeroDatabaseDuringBackup,
	JET_paramIgnoreLogVersion,
	JET_paramDeleteOldLogs,
	JET_paramEnableImprovedSeekShortcut,
	JET_paramBackupChunkSize,
	JET_paramBackupOutstandingReads,
	JET_paramCreatePathIfNotExist,
	JET_paramPageHintCacheSize,
	-1
	};

LOCAL const _TCHAR* const rglpszParam[] =
	{
	_T( "SystemPath" ),
	_T( "TempPath" ),
	_T( "LogFilePath" ),
	_T( "LogFileFailoverPath" ),
	_T( "BaseName" ),
	_T( "MaxSessions" ),
	_T( "MaxOpenTables" ),
	_T( "PreferredMaxOpenTables" ),
	_T( "MaxCursors" ),
	_T( "MaxVerPages" ),
	_T( "GlobalMinVerPages" ),
	_T( "PreferredVerPages" ),
	_T( "MaxTemporaryTables" ),
	_T( "LogFileSize" ),
	_T( "LogBuffers" ),
	_T( "LogCheckpointPeriod" ),
	_T( "CommitDefault" ),
	_T( "CircularLog" ),
	_T( "DbExtensionSize" ),
	_T( "PageTempDBMin" ),
	_T( "PageFragment" ),
	_T( "VERTasksPostMax" ),
	_T( "CacheSizeMin" ),
	_T( "CacheSizeMax" ),
	_T( "CheckpointDepthMax" ),
	_T( "LRUKCorrInterval" ),
	_T( "LRUKHistoryMax" ),
	_T( "LRUKPolicy" ),
	_T( "LRUKTimeout" ),
	_T( "StartFlushThreshold" ),
	_T( "StopFlushThreshold" ),
	_T( "ExceptionAction" ),
	_T( "EventLogCache" ),
	_T( "Recovery" ),
	_T( "EnableOnlineDefrag" ),
	_T( "AssertAction" ),
	_T( "RFS2IOsPermitted" ),
	_T( "RFS2AllocsPermitted" ),
	_T( "CheckFormatWhenOpenFail" ),
	_T( "EnableIndexChecking" ),
	_T( "EnableTempTableVersioning" ),
	_T( "ZeroDatabaseDuringBackup" ),
	_T( "IgnoreLogVersion" ),
	_T( "DeleteOldLogs" ),
	_T( "EnableImprovedSeekShortcut" ),
	_T( "BackupChunkSize" ),
	_T( "BackupOutstandingReads" ),
	_T( "CreatePathIfNotExist" ),
	_T( "PageHintCacheSize" ),
	NULL
	};


//  loads all system parameter overrides

LOCAL const _TCHAR szParamRoot[] = _T( "System Parameter Overrides" ); 

LOCAL void OSUConfigLoadParameterOverrides()
	{
	//  read all system parameters from the registry or create null entries if
	//  they do not exist
	
	for ( int iparam = 0; rglpszParam[iparam]; iparam++ )
		{
		_TCHAR szParam[512];
		if ( FOSConfigGet(	szParamRoot,
							rglpszParam[iparam],
							szParam,
							512 ) )
			{
			if ( szParam[0] )
				{
				extern ERR ErrSetSystemParameter(
								JET_INSTANCE	jinst,
								JET_SESID		sesid,
								unsigned long	paramid,
								ULONG_PTR		lParam,
								const char *	sz );
				(VOID)ErrSetSystemParameter(
								0,
								0,
								rgparam[iparam],
								_tcstoul( szParam, NULL, 0 ),
								szParam );
				}
			else
				{
/*				FOSConfigGet() will create the key if it doesn't exist				
				(void)FOSConfigSet(	szParamRoot,
									rglpszParam[iparam],
									szParam );
*/									
				}
			}
		else
			{
			//  UNDONE:  gripe in the event log that the value was too big
			}
		}
	}

#endif  //  DISABLE_REGISTRY


//  terminate config subsystem

void OSUConfigTerm()
	{
	//  nop
	}

//  init config subsystem

ERR ErrOSUConfigInit()
	{
	//  load configuration

	OSUConfigLoadParameterOverrides();

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_log\logutil.cxx ===
#include "std.hxx"

#include <stdarg.h>
#include <io.h>

#define szTemp	"temp"

//	Forward declaration

VOID LGMakeName( IFileSystemAPI *const pfsapi, CHAR *szName, const CHAR *szPath, const CHAR *szFName, const CHAR *szExt );


extern VOID	ITDBGSetConstants( INST * pinst = NULL);

ERR ISAMAPI ErrIsamBeginExternalBackup( JET_INSTANCE jinst, JET_GRBIT grbit );
ERR ISAMAPI ErrIsamGetAttachInfo( JET_INSTANCE jinst, VOID *pv, ULONG cbMax, ULONG *pcbActual );
ERR ISAMAPI ErrIsamOpenFile( JET_INSTANCE jinst,  const CHAR *szFileName,
	JET_HANDLE	*phfFile, ULONG *pulFileSizeLow, ULONG *pulFileSizeHigh );
ERR ISAMAPI ErrIsamReadFile( JET_INSTANCE jinst, JET_HANDLE hfFile, VOID *pv, ULONG cbMax, ULONG *pcbActual );
ERR ISAMAPI ErrIsamCloseFile( JET_INSTANCE jinst,  JET_HANDLE hfFile );
ERR ISAMAPI ErrIsamGetLogInfo( JET_INSTANCE jinst,  VOID *pv, ULONG cbMax, ULONG *pcbActual, JET_LOGINFO *pLogInfo );
ERR ISAMAPI ErrIsamTruncateLog(  JET_INSTANCE jinst );
ERR ISAMAPI ErrIsamEndExternalBackup(  JET_INSTANCE jinst, JET_GRBIT grbit );

#ifdef ELIMINATE_PATCH_FILE
#else
VOID LGIClosePatchFile( FMP *pfmp );
#endif


#ifdef ELIMINATE_PATCH_FILE

ERR ErrLGCheckDBFiles( INST *pinst, IFileSystemAPI *const pfsapi, RSTMAP * pDbMapEntry, CHAR *szPatch, int genLow, int genHigh, LGPOS *plgposSnapshotRestore = NULL )
	{
	ERR err;
	DBFILEHDR_FIX *pdbfilehdrDb;
	PATCHHDR *	ppatchHdr;
	SIGNATURE *psignLog = &(pinst->m_plog->m_signLog);
	
	Assert ( pDbMapEntry );
	const CHAR * szDatabase = pDbMapEntry->szNewDatabaseName;
	
	BOOL fFromSnapshotBackup = fFalse;
	unsigned long ulGenHighFound = 0;
	unsigned long ulGenLowFound = 0;

	Assert ( NULL == szPatch );

	/*	check if dbfilehdr of database and patchfile are the same.
	/**/
	pdbfilehdrDb = (DBFILEHDR_FIX *)PvOSMemoryPageAlloc( g_cbPage, NULL );
	if ( pdbfilehdrDb == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	err = ErrUtilReadShadowedHeader(	pfsapi, 
										szDatabase, 
										(BYTE*)pdbfilehdrDb, 
										g_cbPage, 
										OffsetOf( DBFILEHDR_FIX, le_cbPageSize ) );
	if ( err < 0 )
		{
		if ( err == JET_errDiskIO )
			err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto EndOfCheckHeader2;
		}

	// fill in the RSTMAP the found database signature 
	pDbMapEntry->fSLVFile = (attribSLV == pdbfilehdrDb->le_attrib);
	memcpy ( &pDbMapEntry->signDatabase, &pdbfilehdrDb->signDb , sizeof(SIGNATURE) );
	
	// check here if it is an SLV file
	// if so, exit with a specific error
	if ( attribSLV == pdbfilehdrDb->le_attrib )
		{
		err = ErrERRCheck( wrnSLVDatabaseHeader );
		goto EndOfCheckHeader2;		
		}

	// should be a db header or patch file header
	if ( attribDb != pdbfilehdrDb->le_attrib )
		{
		Assert ( fFalse );
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto EndOfCheckHeader2;				
		}
			
	fFromSnapshotBackup = ( CmpLgpos ( &(pdbfilehdrDb->bkinfoSnapshotCur.le_lgposMark), &lgposMin ) > 0 );

	if ( plgposSnapshotRestore )
		{
		*plgposSnapshotRestore = pdbfilehdrDb->bkinfoSnapshotCur.le_lgposMark;
		}

	// with snapshot backup, we don't use a patch file
	// exit with no error
	if ( fFromSnapshotBackup )
		{
		Assert ( plgposSnapshotRestore );
		err = JET_errSuccess; 

		if ( memcmp( &pdbfilehdrDb->signLog, psignLog, sizeof( SIGNATURE ) ) != 0 )
			{
			const UINT csz = 1;
			const CHAR *rgszT[csz];

			rgszT[0] = szDatabase;

			// UNDONE: change event message and error
			UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
				DATABASE_PATCH_FILE_MISMATCH_ERROR_ID, csz, rgszT, 0, NULL, pinst);
			CallJ ( ErrERRCheck( JET_errDatabasePatchFileMismatch ), EndOfCheckHeader2 );
			}
			
		ulGenHighFound = pdbfilehdrDb->bkinfoSnapshotCur.le_genHigh;
		ulGenLowFound = pdbfilehdrDb->bkinfoSnapshotCur.le_genLow;

		goto EndOfCheckLogRange;
		}
		
	ppatchHdr = (PATCHHDR *)PvOSMemoryPageAlloc( g_cbPage, NULL );
	if ( ppatchHdr == NULL )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto EndOfCheckHeader2;
		}

	if ( 0 == pdbfilehdrDb->bkinfoFullCur.le_genLow )
		{
		//	only way this is possible is if the database is not
		//	a backup database (eg. it's a clean-shutdown or
		//	dirty-shutdown database)
		//
		err = ErrERRCheck( JET_errRestoreOfNonBackupDatabase );
		goto EndOfCheckHeader;
		}

	// if we have already the trailer moved to the header
	// we are good to go
	if ( pdbfilehdrDb->bkinfoFullCur.le_genHigh )
		{
		ulGenHighFound = pdbfilehdrDb->bkinfoFullCur.le_genHigh;
		ulGenLowFound = pdbfilehdrDb->bkinfoFullCur.le_genLow;
		goto EndOfCheckLogRange;
		}

	//	the patch file is always on the OS file-system
	CallJ ( pinst->m_plog->ErrLGBKReadAndCheckDBTrailer(pfsapi, szDatabase, (BYTE*)ppatchHdr ), EndOfCheckHeader);
		
	if ( memcmp( &pdbfilehdrDb->signDb, &ppatchHdr->signDb, sizeof( SIGNATURE ) ) != 0 ||
		 memcmp( &pdbfilehdrDb->signLog, psignLog, sizeof( SIGNATURE ) ) != 0 ||
		 memcmp( &ppatchHdr->signLog, psignLog, sizeof( SIGNATURE ) ) != 0 ||
		 CmpLgpos( &pdbfilehdrDb->bkinfoFullCur.le_lgposMark,
				   &ppatchHdr->bkinfo.le_lgposMark ) != 0 )
		{
		const UINT csz = 1;
		const CHAR *rgszT[csz];
		
		rgszT[0] = szDatabase;
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					DATABASE_PATCH_FILE_MISMATCH_ERROR_ID, csz, rgszT, 0, NULL, pinst );
		CallJ ( ErrERRCheck( JET_errDatabasePatchFileMismatch ), EndOfCheckHeader);
		}
	else
		{
		ulGenHighFound = ppatchHdr->bkinfo.le_genHigh;
		ulGenLowFound = ppatchHdr->bkinfo.le_genLow;
		}


EndOfCheckLogRange:
	if ( ulGenLowFound < (ULONG) genLow )
		{
		/*	It should start at most from bkinfoFullCur.genLow
		 */
		CHAR	szT1[IFileSystemAPI::cchPathMax];
		CHAR	szT2[IFileSystemAPI::cchPathMax];		
		const CHAR *rgszT[] = { szT1, szT2 };

		// use szPatch as this should be the path of the log files as well
		pinst->m_plog->LGFullLogNameFromLogId(pfsapi, szT1, genLow, szPatch);
		pinst->m_plog->LGFullLogNameFromLogId(pfsapi, szT2, ulGenLowFound, szPatch);
 		 		
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					STARTING_RESTORE_LOG_TOO_HIGH_ERROR_ID, 2, rgszT, 0, NULL, pinst );
		err = ErrERRCheck( JET_errStartingRestoreLogTooHigh );
		}

	else if ( ulGenHighFound > (ULONG) genHigh )
		{
		/*	It should be at least from bkinfoFullCur.genHigh
		 */
		CHAR	szT1[IFileSystemAPI::cchPathMax];
		CHAR	szT2[IFileSystemAPI::cchPathMax];		
		const CHAR *rgszT[] = { szT1, szT2 };

		// use szPatch as this should be the path of the log files as well
		pinst->m_plog->LGFullLogNameFromLogId(pfsapi, szT1, genHigh, szPatch);
		pinst->m_plog->LGFullLogNameFromLogId(pfsapi, szT2, ulGenHighFound, szPatch);	
 		
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					ENDING_RESTORE_LOG_TOO_LOW_ERROR_ID, 2, rgszT, 0, NULL, pinst );
		err = ErrERRCheck( JET_errEndingRestoreLogTooLow );
		}

	// we can update the database header and we don't need the trailer
	Assert ( ulGenLowFound == pdbfilehdrDb->bkinfoFullCur.le_genLow);
	Assert ( ulGenHighFound <= genHigh);

	// we update genMax with the max that we restored,
	// mot just with was in the header file
	pdbfilehdrDb->bkinfoFullCur.le_genHigh = genHigh;
	CallJ( ErrUtilWriteShadowedHeader(	pfsapi, 
										szDatabase, 
										fTrue,
										(BYTE *)pdbfilehdrDb, 
										g_cbPage ), EndOfCheckHeader );		 

	
EndOfCheckHeader:	
	OSMemoryPageFree( ppatchHdr );

EndOfCheckHeader2:	
	OSMemoryPageFree( pdbfilehdrDb );

	return err;
	}

#else	//	ELIMINATE_PATCH_FILE

ERR ErrLGCheckDBFiles( INST *pinst, IFileSystemAPI *const pfsapi, RSTMAP * pDbMapEntry, CHAR *szPatch, int genLow, int genHigh, LGPOS *plgposSnapshotRestore = NULL )
	{
	ERR err;
	DBFILEHDR_FIX *pdbfilehdrDb;
	DBFILEHDR_FIX *pdbfilehdrPatch;
	SIGNATURE *psignLog = &(pinst->m_plog->m_signLog);

	Assert ( pDbMapEntry );
	const CHAR * szDatabase = pDbMapEntry->szNewDatabaseName;
	
	BOOL fFromSnapshotBackup = fFalse;
	unsigned long ulGenHighFound = 0;
	unsigned long ulGenLowFound = 0;
	
	/*	check if dbfilehdr of database and patchfile are the same.
	/**/
	pdbfilehdrDb = (DBFILEHDR_FIX * )PvOSMemoryPageAlloc( g_cbPage, NULL );
	if ( pdbfilehdrDb == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	err = ErrUtilReadShadowedHeader(	pfsapi,
										szDatabase,
										(BYTE*)pdbfilehdrDb,
										g_cbPage,
										OffsetOf( DBFILEHDR_FIX, le_cbPageSize ) );
	if ( err < 0 )
		{
		if ( err == JET_errDiskIO )
			err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto EndOfCheckHeader2;
		}

	// fill in the RSTMAP the found database signature
	pDbMapEntry->fSLVFile = (attribSLV == pdbfilehdrDb->le_attrib);
	memcpy ( &pDbMapEntry->signDatabase, &pdbfilehdrDb->signDb , sizeof(SIGNATURE) );
	
	// check here if it is an SLV file
	// if so, exit with a specific error
	if ( attribSLV == pdbfilehdrDb->le_attrib )
		{
		err = ErrERRCheck( wrnSLVDatabaseHeader );
		goto EndOfCheckHeader2;		
		}

	// should be a db header or patch file header
	if ( attribDb != pdbfilehdrDb->le_attrib )
		{
		Assert ( fFalse );
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto EndOfCheckHeader2;				
		}
			
	fFromSnapshotBackup = ( CmpLgpos ( &(pdbfilehdrDb->bkinfoSnapshotCur.le_lgposMark), &lgposMin ) > 0 );

	if ( plgposSnapshotRestore )
		{
		*plgposSnapshotRestore = pdbfilehdrDb->bkinfoSnapshotCur.le_lgposMark;
		}

	// with snapshot backup, we don't use a patch file
	// exit with no error
	if ( fFromSnapshotBackup )
		{
		Assert ( plgposSnapshotRestore );
		err = JET_errSuccess;

		if (  memcmp( &pdbfilehdrDb->signLog, psignLog, sizeof( SIGNATURE ) ) != 0 )
			{
			const UINT csz = 1;
			const CHAR *rgszT[csz];

			rgszT[0] = szDatabase;

			// UNDONE: change event message and error
			UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
				DATABASE_PATCH_FILE_MISMATCH_ERROR_ID, csz, rgszT, 0, NULL, pinst);
			CallJ ( ErrERRCheck( JET_errDatabasePatchFileMismatch ), EndOfCheckHeader2 );
			}
			
		ulGenHighFound = pdbfilehdrDb->bkinfoSnapshotCur.le_genHigh;
		ulGenLowFound = pdbfilehdrDb->bkinfoSnapshotCur.le_genLow;

		goto EndOfCheckLogRange;
		}
		
	pdbfilehdrPatch = (DBFILEHDR_FIX * )PvOSMemoryPageAlloc( g_cbPage, NULL );
	if ( pdbfilehdrPatch == NULL )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto EndOfCheckHeader2;
		}

	err = ErrUtilReadShadowedHeader(	pinst->m_pfsapi, 
										szPatch, 
										(BYTE*)pdbfilehdrPatch, 
										g_cbPage );
	if ( err < 0 )
		{
		if ( err == JET_errDiskIO )
			err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto EndOfCheckHeader;
		}

	if ( memcmp( &pdbfilehdrDb->signDb, &pdbfilehdrPatch->signDb, sizeof( SIGNATURE ) ) != 0 ||
		 memcmp( &pdbfilehdrDb->signLog, psignLog, sizeof( SIGNATURE ) ) != 0 ||
		 memcmp( &pdbfilehdrPatch->signLog, psignLog, sizeof( SIGNATURE ) ) != 0 ||
		 CmpLgpos( &pdbfilehdrDb->bkinfoFullCur.le_lgposMark,
				   &pdbfilehdrPatch->bkinfoFullCur.le_lgposMark ) != 0 )
		{
		const UINT csz = 1;
		const CHAR *rgszT[csz];
		
		rgszT[0] = szDatabase;
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					DATABASE_PATCH_FILE_MISMATCH_ERROR_ID, csz, rgszT, 0, NULL, pinst );
		CallJ ( ErrERRCheck( JET_errDatabasePatchFileMismatch ), EndOfCheckHeader);
		}
	else
		{
		ulGenHighFound = pdbfilehdrPatch->bkinfoFullCur.le_genHigh;
		ulGenLowFound = pdbfilehdrPatch->bkinfoFullCur.le_genLow;
		}
		
EndOfCheckLogRange:
	if ( ulGenLowFound < (ULONG) genLow )
		{
		/*	It should start at most from bkinfoFullCur.genLow
		 */
		CHAR	szT1[IFileSystemAPI::cchPathMax];
		CHAR	szT2[IFileSystemAPI::cchPathMax];		
		const CHAR *rgszT[] = { szT1, szT2 };

		// use szPatch as this should be the path of the log files as well
		pinst->m_plog->LGFullLogNameFromLogId(pfsapi, szT1, genLow, szPatch);
		pinst->m_plog->LGFullLogNameFromLogId(pfsapi, szT2, ulGenLowFound, szPatch);
 		 		
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					STARTING_RESTORE_LOG_TOO_HIGH_ERROR_ID, 2, rgszT, 0, NULL, pinst );
		err = ErrERRCheck( JET_errStartingRestoreLogTooHigh );
		}

	else if ( ulGenHighFound > (ULONG) genHigh )
		{
		/*	It should be at least from bkinfoFullCur.genHigh
		 */
		CHAR	szT1[IFileSystemAPI::cchPathMax];
		CHAR	szT2[IFileSystemAPI::cchPathMax];		
		const CHAR *rgszT[] = { szT1, szT2 };

		// use szPatch as this should be the path of the log files as well
		pinst->m_plog->LGFullLogNameFromLogId(pfsapi, szT1, genHigh, szPatch);
		pinst->m_plog->LGFullLogNameFromLogId(pfsapi, szT2, ulGenHighFound, szPatch);	
 		
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					ENDING_RESTORE_LOG_TOO_LOW_ERROR_ID, 2, rgszT, 0, NULL, pinst );
		err = ErrERRCheck( JET_errEndingRestoreLogTooLow );
		}
		
EndOfCheckHeader:	
	OSMemoryPageFree( pdbfilehdrPatch );
EndOfCheckHeader2:	
	OSMemoryPageFree( pdbfilehdrDb );

	return err;
	}

#endif	//	ELIMINATE_PATCH_FILE


LOCAL ERR LOG::ErrLGRSTOpenLogFile(	IFileSystemAPI *const	pfsapi,
									CHAR 						*szLogPath,
									INT 						gen,
									IFileAPI **const		ppfapi )
	{
	CHAR   		rgchFName[IFileSystemAPI::cchPathMax];
	CHAR		szPath[IFileSystemAPI::cchPathMax];

	strcpy( szPath, szLogPath );

	if ( gen == 0 )
		strcat( szPath, m_szJetLog );
	else
		{
		LGSzFromLogId( rgchFName, gen );
		strcat( szPath, rgchFName );
		strcat( szPath, szLogExt );
		}

	return pfsapi->ErrFileOpen( szPath, ppfapi );
	}


#define fLGRSTIncludeJetLog	fTrue
#define fLGRSTNotIncludeJetLog fFalse
LOCAL VOID LOG::LGRSTDeleteLogs( IFileSystemAPI *const pfsapi, CHAR *szLog, INT genLow, INT genHigh, BOOL fIncludeJetLog )
	{
	INT  gen;
	CHAR rgchFName[IFileSystemAPI::cchPathMax];
	CHAR szPath[IFileSystemAPI::cchPathMax];

	for ( gen = genLow; gen <= genHigh; gen++ )
		{
		LGSzFromLogId( rgchFName, gen );
		strcpy( szPath, szLog );
		strcat( szPath, rgchFName );
		strcat( szPath, szLogExt );
		CallSx( pfsapi->ErrFileDelete( szPath ), JET_errFileNotFound );
		}

	if ( fIncludeJetLog )
		{
		strcpy( szPath, szLog );
		strcat( szPath, m_szJetLog );
		CallSx( pfsapi->ErrFileDelete( szPath ), JET_errFileNotFound );
		}
	}

	
ERR LOG::ErrLGRSTCheckSignaturesLogSequence(
	IFileSystemAPI *const pfsapi,
	char *szRestorePath,
	char *szLogFilePath,
	INT	genLow,
	INT	genHigh,
	char *szTargetInstanceFilePath,
	INT	genHighTarget )
	{
	ERR				err = JET_errSuccess;
	LONG			gen;
	LONG			genLowT;
	LONG			genHighT;
	IFileAPI	*pfapiT = NULL;
	LGFILEHDR		*plgfilehdrT = NULL;
	LGFILEHDR		*plgfilehdrCur[2] = { NULL, NULL };
	LGFILEHDR		*plgfilehdrLow = NULL;
	LGFILEHDR		*plgfilehdrHigh = NULL;
	INT				ilgfilehdrAvail = 0;
	INT				ilgfilehdrCur;
	INT				ilgfilehdrPrv;
	BOOL			fReadyToCheckContiguity;
//	ERR				wrn = JET_errSuccess;

	BOOL fTargetInstanceCheck = fFalse;
	CHAR * szLogFilePathCheck = NULL;

	plgfilehdrT = (LGFILEHDR *)PvOSMemoryPageAlloc( sizeof(LGFILEHDR) * 4, NULL );
	if ( plgfilehdrT == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	plgfilehdrCur[0] = plgfilehdrT;
	plgfilehdrCur[1] = plgfilehdrT + 1;
	plgfilehdrLow = plgfilehdrT + 2;
	plgfilehdrHigh = plgfilehdrT + 3;

	/*	starting from lowest generation of the restored path.
	 *	Check the given logs are all correct and contiguous
	 */
	for ( gen = genLow; gen <= genHigh; gen++ )
		{
		ilgfilehdrCur = ilgfilehdrAvail++ % 2;
		ilgfilehdrPrv = ilgfilehdrAvail % 2;

		Call( ErrLGRSTOpenLogFile( pfsapi, szRestorePath, gen, &pfapiT ) );
		Call( ErrLGReadFileHdr( pfapiT, plgfilehdrCur[ ilgfilehdrCur ], fCheckLogID ) );
		delete pfapiT;
		pfapiT = NULL;

		if ( gen == genLow )
			{
			UtilMemCpy( plgfilehdrLow, plgfilehdrCur[ ilgfilehdrCur ], sizeof( LGFILEHDR ) );
			}

		if ( gen == genHigh )
			{
			UtilMemCpy( plgfilehdrHigh, plgfilehdrCur[ ilgfilehdrCur ], sizeof( LGFILEHDR ) );
			}

		if ( gen > genLow )
			{			
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.signLog,
						 &plgfilehdrCur[ ilgfilehdrPrv ]->lgfilehdr.signLog,
						 sizeof( SIGNATURE ) ) != 0 )
				{
				CHAR szT[IFileSystemAPI::cchPathMax];
				const UINT	csz = 1;
				const CHAR *rgszT[csz];
				rgszT[0] = szT;

				LGFullLogNameFromLogId(pfsapi, szT, gen, szRestorePath);
				
				UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					RESTORE_LOG_FILE_HAS_BAD_SIGNATURE_ERROR_ID, csz, rgszT, 0, NULL, m_pinst );
				Call( ErrERRCheck( JET_errGivenLogFileHasBadSignature ) );
				}
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.tmPrevGen,
						 &plgfilehdrCur[ ilgfilehdrPrv ]->lgfilehdr.tmCreate,
						 sizeof( LOGTIME ) ) != 0 )
				{
				CHAR szT[20];
				const UINT	csz = 1;
				const CHAR *rgszT[csz];
				_itoa( gen, szT, 16 );
				rgszT[0] = szT;
				UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					RESTORE_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID, csz, rgszT, 0, NULL, m_pinst );
				Call( ErrERRCheck( JET_errGivenLogFileIsNotContiguous ) );
				}
			}
		}

	if ( gen <= genHigh )
		{
		// I can't see how this path can be taken after the loop ...
		Assert ( 0 );
		
		CHAR szT[IFileSystemAPI::cchPathMax];
		const UINT	csz = 1;
		const CHAR *rgszT[csz];		
		rgszT[0] = szT;

		LGFullLogNameFromLogId(pfsapi, szT, gen, szRestorePath);
		
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
				RESTORE_LOG_FILE_MISSING_ERROR_ID, csz, rgszT, 0, NULL, m_pinst );
		Call( ErrERRCheck( JET_errMissingRestoreLogFiles ) );
		}

	// we are going to check the log sequence from the backup set ()
	// and szLogFilePath or szTargetInstanceFilePath (if used)

	if ( szTargetInstanceFilePath )
		{
		Assert ( genHighTarget );
		fTargetInstanceCheck = fTrue;
		szLogFilePathCheck = szTargetInstanceFilePath;
		}
	else
		{
		Assert ( ! fTargetInstanceCheck );
		szLogFilePathCheck = szLogFilePath;
		}

	Assert ( szLogFilePathCheck );
	
	/*	if Restore path and log path is different, delete all the unrelated log files
	 *	in the restore log path.
	 */
	{
	CHAR  	szFullLogPath[IFileSystemAPI::cchPathMax];
	CHAR  	szFullLogFilePathCheck[IFileSystemAPI::cchPathMax];

	Call( pfsapi->ErrPathComplete( szRestorePath, szFullLogPath ) );
	Call( pfsapi->ErrPathComplete( szLogFilePathCheck, szFullLogFilePathCheck ) );

#ifdef DEBUG
	// TargetInstance, the TargetInstance should be different the the recover instance directory
	if ( szTargetInstanceFilePath )
		{
		Assert ( szLogFilePathCheck == szTargetInstanceFilePath );
		
		CallS ( pfsapi->ErrPathComplete( szLogFilePath, szFullLogPath ) );
		Assert ( UtilCmpFileName( szFullLogPath, szFullLogFilePathCheck ) );
		}
#endif // DEBUG

	Call( pfsapi->ErrPathComplete( szRestorePath, szFullLogPath ) );
		
	if ( UtilCmpFileName( szFullLogPath, szFullLogFilePathCheck ) != 0 &&
		( JET_errSuccess == ErrLGIGetGenerationRange( pfsapi, szRestorePath, &genLowT, &genHighT ) ) )
		{
		LGRSTDeleteLogs( pfsapi, szRestorePath, genLowT, genLow - 1, fLGRSTNotIncludeJetLog );
		LGRSTDeleteLogs( pfsapi, szRestorePath, genHigh + 1, genHighT, fLGRSTIncludeJetLog );
		}
	}
	
	/*	Check the log directory. Make sure all the log files has the same signature.
	 */
	Call ( ErrLGIGetGenerationRange( pfsapi, szLogFilePathCheck, &genLowT, &genHighT ) );

	if ( fTargetInstanceCheck )
		{
		Assert ( genHighTarget );
		Assert ( genHighT >= genHighTarget );
		Assert ( genLowT <= genHighTarget );
		

		if ( genHighT < genHighTarget || genLowT > genHighTarget || 0 == genLowT )
			{
			//	Someone delete the logs since last time we checked the
			//	restore log files.

			Assert(0);
			CHAR szT[IFileSystemAPI::cchPathMax];
			const UINT	csz = 1;
			const CHAR *rgszT[csz];		
			rgszT[0] = szT;

			LGFullLogNameFromLogId(pfsapi, szT, genHighTarget, szLogFilePathCheck);
			
			UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					RESTORE_LOG_FILE_MISSING_ERROR_ID, csz, rgszT, 0, NULL, m_pinst );
			Call( ErrERRCheck( JET_errMissingRestoreLogFiles ) );
			}
			
		// set the max log to check to genHighTarget
		genHighT = genHighTarget;
		}
		
	/*	genHighT + 1 implies JetLog file (edb.log).
	 */
	if ( genLowT > genHigh )
		fReadyToCheckContiguity = fTrue;
	else
		fReadyToCheckContiguity = fFalse;

	for ( gen = genLowT; gen <= (fTargetInstanceCheck?genHighT:genHighT + 1); gen++ )
		{
		if ( gen == 0 )
			{
			
			Assert ( !fTargetInstanceCheck );
			
			/*	A special case. Check if JETLog(edb.log) exist?
			 */
			if ( ErrLGRSTOpenLogFile( pfsapi, szLogFilePathCheck, 0, &pfapiT ) < 0 )
				break;

			/*	Set break condition. Also set condition to check if
			 *	the log is contiguous from the restore logs ( genHigh + 1 )
			 */
			gen = genHigh + 1;
			genHighT = genHigh;
			Assert( gen == genHighT + 1 );
			}
		else
			{
			if ( gen == genHighT + 1 )
				{
				Assert ( !fTargetInstanceCheck );
				
				/*	A special case. Check if JETLog(edb.log) exist?
				 */
				if ( ErrLGRSTOpenLogFile( pfsapi, szLogFilePathCheck, 0, &pfapiT ) < 0 )
					break;
				}
			else
				{
				err = ErrLGRSTOpenLogFile( pfsapi, szLogFilePathCheck, gen, &pfapiT );
				if ( err == JET_errFileNotFound )
					{
					// The expected log generation is missing...
					CHAR szT[IFileSystemAPI::cchPathMax];
					const UINT	csz = 1;
					const CHAR *rgszT[csz];

					LGFullLogNameFromLogId(pfsapi, szT, gen, szLogFilePathCheck);
						
					rgszT[0] = szT;
					if ( gen <= genHigh )
						{
						if ( _stricmp( szRestorePath, szLogFilePathCheck ) != 0 )
							{
							//	skip all the logs that can be found in
							//	szRestorePath. Continue from genHigh+1
							gen = genHigh;
							continue;
							}

						//	Someone delete the logs since last time we checked the
						//	restore log files.

						Assert(0);
						UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
								RESTORE_LOG_FILE_MISSING_ERROR_ID, csz, rgszT, 0, NULL, m_pinst );
						Call( ErrERRCheck( JET_errMissingRestoreLogFiles ) );
						}
					else
						{
						UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
							CURRENT_LOG_FILE_MISSING_ERROR_ID, csz, rgszT, 0, NULL, m_pinst );
						err = ErrERRCheck( JET_errMissingCurrentLogFiles );
						}
					}
				Call( err );
				}
			}


		ilgfilehdrCur = ilgfilehdrAvail++ % 2;
		ilgfilehdrPrv = ilgfilehdrAvail % 2;

		Call( ErrLGReadFileHdr( pfapiT, plgfilehdrCur[ ilgfilehdrCur ], fNoCheckLogID ) );
		delete pfapiT;
		pfapiT = NULL;

		if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.signLog,
					 &plgfilehdrHigh->lgfilehdr.signLog,
					 sizeof( SIGNATURE ) ) != 0 )
			{
			INT genCurrent;
			char szT1[20];
			const UINT	csz = 1;
			const char *rgszT[csz];
			rgszT[0] = szT1;

			if ( gen < genLow )
				{
				genCurrent = genLow - 1;
				}
			else if ( gen <= genHigh )
				{
				genCurrent = gen;
				}
			else
				{
				genCurrent = genHighT + 1;	// to break out the loop
				}
				
			if ( gen == genHighT + 1 || 0 == gen )
				{
				sprintf( szT1, "%s.log", m_szBaseName );
				}
			else
				{
				sprintf( szT1, "%s%05X.log", m_szBaseName, gen );
				}
				
			UtilReportEvent( eventWarning, LOGGING_RECOVERY_CATEGORY,
					EXISTING_LOG_FILE_HAS_BAD_SIGNATURE_ERROR_ID_2, csz, rgszT, 0, NULL, m_pinst );

			err = ErrERRCheck( JET_errExistingLogFileHasBadSignature );
			gen = genCurrent;
			fReadyToCheckContiguity = fFalse;
			continue;
			}

		if ( fReadyToCheckContiguity )
			{
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.tmPrevGen,
						 &plgfilehdrCur[ ilgfilehdrPrv ]->lgfilehdr.tmCreate,
						 sizeof( LOGTIME ) ) != 0 )
				{
				CHAR szT1[20];
				CHAR szT2[20];
				const UINT	csz = 2;
				const CHAR *rgszT[csz];
				LONG genCur = plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.le_lGeneration;
				LONG genPrv = plgfilehdrCur[ ilgfilehdrPrv ]->lgfilehdr.le_lGeneration;

//				wrn = ErrERRCheck( JET_wrnExistingLogFileIsNotContiguous );
				err = ErrERRCheck( JET_errExistingLogFileIsNotContiguous );

				if ( genPrv == genHighT + 1 || 0 == genPrv )
					{
					sprintf( szT1, "%s.log", m_szBaseName );
					}
				else
					{
					sprintf( szT1, "%s%05X.log", m_szBaseName, genPrv );
					}

				if ( genCur == genHighT + 1 || 0 == genCur )
					{
					sprintf( szT2, "%s.log", m_szBaseName );
					}
				else
					{
					sprintf( szT2, "%s%05X.log", m_szBaseName, genCur );
					}
				rgszT[0] = szT1;
				rgszT[1] = szT2;
				UtilReportEvent( eventWarning, LOGGING_RECOVERY_CATEGORY,
					EXISTING_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID_2, csz, rgszT, 0, NULL, m_pinst );

				if ( gen < genLow )
					{
					continue;
					}
				else if ( gen <= genHigh )
					{
					gen = genHigh;
					continue;
					}
				else
					{
					break;
					}
				}
			}

		if ( gen == genLow - 1 )
			{
			/*	make sure it and the restore log are contiguous. If not, then delete
			 *	all the logs up to genLow - 1.
			 */
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.tmCreate,
						 &plgfilehdrLow->lgfilehdr.tmPrevGen,
						 sizeof( LOGTIME ) ) != 0 )
				{
				CHAR szT1[20];
				CHAR szT2[20];
				const UINT csz = 2;
				const CHAR *rgszT[csz];
				LONG genCur = plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.le_lGeneration;
				LONG genPrv = plgfilehdrLow->lgfilehdr.le_lGeneration;

				if ( genPrv == genHighT + 1 || 0 == genPrv )
					{
					sprintf( szT1, "%s.log", m_szBaseName );
					}
				else
					{
					sprintf( szT1, "%s%05X.log", m_szBaseName, genPrv );
					}

				if ( genCur == genHighT + 1 || 0 == genCur )
					{
					sprintf( szT2, "%s.log", m_szBaseName );
					}
				else
					{
					sprintf( szT2, "%s%05X.log", m_szBaseName, genCur );
					}
					
				rgszT[0] = szT1;
				rgszT[1] = szT2;
				UtilReportEvent( eventWarning, LOGGING_RECOVERY_CATEGORY,
					EXISTING_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID_2, csz, rgszT, 0, NULL, m_pinst );
				
				err = ErrERRCheck( JET_errExistingLogFileIsNotContiguous );
				fReadyToCheckContiguity = fFalse;
				continue;
				}
			}

		if ( gen == genLow )
			{
			/*	make sure it and the restore log are the same. If not, then delete
			 *	all the logs up to genHigh.
			 */
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.tmCreate,
						 &plgfilehdrLow->lgfilehdr.tmCreate,
						 sizeof( LOGTIME ) ) != 0 )
				{
				CHAR szT1[20];
				CHAR szT2[20];
				const UINT csz = 2;
				const CHAR *rgszT[csz];
				LONG genCur = plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.le_lGeneration;
				LONG genPrv = plgfilehdrLow->lgfilehdr.le_lGeneration;

				if ( genPrv == genHighT + 1 || 0 == genPrv )
					{
					sprintf( szT1, "%s.log", m_szBaseName );
					}
				else
					{
					sprintf( szT1, "%s%05X.log", m_szBaseName, genPrv );
					}

				if ( genCur == genHighT + 1 || 0 == genCur )
					{
					sprintf( szT2, "%s.log", m_szBaseName );
					}
				else
					{
					sprintf( szT2, "%s%05X.log", m_szBaseName, genCur );
					}
	
				rgszT[0] = szT1;
				rgszT[1] = szT2;
				UtilReportEvent( eventWarning, LOGGING_RECOVERY_CATEGORY,
					EXISTING_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID_2, csz, rgszT, 0, NULL, m_pinst );

				err = ErrERRCheck( JET_errExistingLogFileIsNotContiguous );

				Assert( _stricmp( szRestorePath, szLogFilePathCheck ) != 0 );
				gen = genHigh;
				continue;
				}
			}

		if ( gen == genHigh + 1 )
			{
			/*	make sure it and the restore log are contiguous. If not, then delete
			 *	all the logs higher than genHigh.
			 */
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.tmPrevGen,
						 &plgfilehdrHigh->lgfilehdr.tmCreate,
						 sizeof( LOGTIME ) ) != 0 )
				{
				CHAR szT1[20];
				CHAR szT2[20];
				const UINT csz = 2;
				const CHAR *rgszT[csz];
				LONG genCur = plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.le_lGeneration;
				LONG genPrv = plgfilehdrHigh->lgfilehdr.le_lGeneration;

				if ( genPrv == genHighT + 1 || 0 == genPrv )
					{
					sprintf( szT1, "%s.log", m_szBaseName );
					}
				else
					{
					sprintf( szT1, "%s%05X.log", m_szBaseName, genPrv );
					}

				if ( genCur == genHighT + 1 || 0 == genCur )
					{
					sprintf( szT2, "%s.log", m_szBaseName );
					}
				else
					{
					sprintf( szT2, "%s%05X.log", m_szBaseName, genCur );
					}
					
				rgszT[0] = szT1;
				rgszT[1] = szT2;
				UtilReportEvent( eventWarning, LOGGING_RECOVERY_CATEGORY,
					EXISTING_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID_2, csz, rgszT, 0, NULL, m_pinst );

				err = ErrERRCheck( JET_errExistingLogFileIsNotContiguous );
				break;
				}
			}
		
		fReadyToCheckContiguity = fTrue;
		}

HandleError:
//	if ( err == JET_errSuccess )
//		err = wrn;

	// if we have a TargetInstance, map the error codes for bad log files to JET_errBadRestoreTargetInstance
	if ( fTargetInstanceCheck &&
		( JET_errMissingCurrentLogFiles == err || JET_errExistingLogFileIsNotContiguous == err || JET_errExistingLogFileHasBadSignature == err ) )
		{
		err = ErrERRCheck ( JET_errBadRestoreTargetInstance );
		}
	
	delete pfapiT;
	
	OSMemoryPageFree( plgfilehdrT );

	return err;
	}


/*	caller has to make sure szDir has enough space for appending "*"
/**/
LOCAL ERR ErrLGDeleteAllFiles( IFileSystemAPI *const pfsapi, CHAR *szDir )
	{
	ERR				err		= JET_errSuccess;
	IFileFindAPI*	pffapi	= NULL;
	BOOL			fAddDelimiter;

	Assert( strlen( szDir ) + 1 + 1 < IFileSystemAPI::cchPathMax );

	//  iterate over all files in this directory

	fAddDelimiter = !FOSSTRTrailingPathDelimiterA( szDir );
	if ( fAddDelimiter )
		{
		OSSTRAppendPathDelimiterA( szDir, fFalse );
		}
	strcat( szDir, "*" );
	Call( pfsapi->ErrFileFind( szDir, &pffapi ) );
	if ( fAddDelimiter )
		{
		szDir[ strlen( szDir ) - 2 ] = '\0';
		}
	else
		{
		szDir[ strlen( szDir ) - 1 ] = '\0';
		}

	while ( ( err = pffapi->ErrNext() ) == JET_errSuccess )
		{
		CHAR szFileName[IFileSystemAPI::cchPathMax];
		char szDirT[IFileSystemAPI::cchPathMax];
		char szFileT[IFileSystemAPI::cchPathMax];
		char szExtT[IFileSystemAPI::cchPathMax];
		char szFileNameT[IFileSystemAPI::cchPathMax];

		Call( pffapi->ErrPath( szFileName ) );
		Call( pfsapi->ErrPathParse( szFileName, szDirT, szFileT, szExtT ) );
		szDirT[0] = 0;
		Call( pfsapi->ErrPathBuild( szDirT, szFileT, szExtT, szFileNameT ) );
		
		/* not . , and .. and not temp
		/**/
		if (	strcmp( szFileNameT, "." ) &&
				strcmp( szFileNameT, ".." ) &&
				UtilCmpFileName( szFileNameT, szTemp ) )
			{
			err = pfsapi->ErrFileDelete( szFileName );
			if ( err != JET_errSuccess )
				{
				Call( ErrERRCheck( JET_errDeleteBackupFileFail ) );
				}
			}
		}
	Call( err == JET_errFileNotFound ? JET_errSuccess : err );

	err = JET_errSuccess;

HandleError:
	/*	assert restored szDir
	/**/
	Assert( szDir[strlen(szDir)] != '*' );

	delete pffapi;

	return err;
	}


/*	caller has to make sure szDir has enough space for appending "*"
/**/
LOCAL ERR ErrLGCheckDir( IFileSystemAPI *const pfsapi, CHAR *szDir, CHAR *szSearch )
	{
	ERR				err		= JET_errSuccess;
	IFileFindAPI*	pffapi	= NULL;
	BOOL			fAddDelimiter;

	Assert( strlen( szDir ) + 1 + 1 < IFileSystemAPI::cchPathMax );

	//  iterate over all files in this directory

	fAddDelimiter = !FOSSTRTrailingPathDelimiterA( szDir );
	if ( fAddDelimiter )
		{
		OSSTRAppendPathDelimiter( szDir, fFalse );
		}
	strcat( szDir, "*" );
	Call( pfsapi->ErrFileFind( szDir, &pffapi ) );
	if ( fAddDelimiter )
		{
		szDir[ strlen( szDir ) - 2 ] = '\0';
		}
	else
		{
		szDir[ strlen( szDir ) - 1 ] = '\0';
		}

	while ( ( err = pffapi->ErrNext() ) == JET_errSuccess )
		{
		CHAR szFileName[IFileSystemAPI::cchPathMax];
		char szDirT[IFileSystemAPI::cchPathMax];
		char szFileT[IFileSystemAPI::cchPathMax];
		char szExtT[IFileSystemAPI::cchPathMax];
		char szFileNameT[IFileSystemAPI::cchPathMax];

		Call( pffapi->ErrPath( szFileName ) );
		Call( pfsapi->ErrPathParse( szFileName, szDirT, szFileT, szExtT ) );
		szDirT[0] = 0;
		Call( pfsapi->ErrPathBuild( szDirT, szFileT, szExtT, szFileNameT ) );
		
		/* not . , and .. and not szSearch
		/**/
		if (	strcmp( szFileNameT, "." ) &&
				strcmp( szFileNameT, ".." ) &&
				( !szSearch || !UtilCmpFileName( szFileNameT, szSearch ) ) )
			{
			Call( ErrERRCheck( JET_errBackupDirectoryNotEmpty ) );
			}
		}
	Call( err == JET_errFileNotFound ? JET_errSuccess : err );

	err = JET_errSuccess;

HandleError:
	/*	assert restored szDir
	/**/
	Assert( szDir[strlen(szDir)] != '*' );

	delete pffapi;

	return err;
	}


//	padding to add to account for log files
#define cBackupStatusPadding	0.05

/*	calculates initial backup size, and accounts for
/*	database growth during backup.
/**/
LOCAL VOID LGGetBackupSize( INST *pinst, FMP *pfmpNextToBackup, ULONG cPagesSoFar, ULONG *pcExpectedPages )
	{
	DBID	dbid;
	ULONG	cNewExpected;
	ULONG	cPagesLeft		= pfmpNextToBackup->PgnoMost();

	Assert( cPagesLeft > 0 );

	//	calculate sizes of databases to be backed up after this one
	for ( dbid = DBID( pfmpNextToBackup->Dbid() + 1 ); dbid < dbidMax; dbid++ )
		{
		const IFMP	ifmpT	= pinst->m_mpdbidifmp[dbid];
		if ( ifmpT >= ifmpMax )
			continue;
			
		const FMP	*pfmpT	= &rgfmp[ifmpT];
		if ( !pfmpT->FInUse() || !pfmpT->FLogOn() )
			continue;

		cPagesLeft += ULONG( pfmpT->PgnoLast() );
		}

	cNewExpected = cPagesSoFar + cPagesLeft;
	cNewExpected += (ULONG)( cBackupStatusPadding * cNewExpected );

	Assert( cNewExpected >= *pcExpectedPages );

	/*	check if grown since our last determination of backup size
	/**/
	if ( cNewExpected > *pcExpectedPages )
		*pcExpectedPages = cNewExpected;
	}



/*  backup read completion function
/**/
struct LGBK_ARGS
	{
	volatile ERR			err;
	volatile long*			pacRead;
	CAutoResetSignal*		pasigDone;
	BOOL					fCheckPagesOffset;
	};
	
void LGBKReadPagesCompleted(	const ERR err,
								IFileAPI *const pfapi,
								const QWORD ibOffset,
								const DWORD cbData,
								const BYTE* const pbData,
								LGBK_ARGS* const plgbkargs )
	{
	/*  we are not already in an error state
	/**/
	if ( plgbkargs->err >= 0 )
		{
		/*  there was an error on this read
		/**/
		if ( err < 0 )
			{
			/*  return the error
			/**/
			plgbkargs->err = err;
			}

		/*  there was no error
		/**/
		else
			{
			/*  verify the chunk's pages
			/**/
			for ( DWORD ib = 0; ib < cbData && plgbkargs->err >= 0; ib += g_cbPage )
				{
				ERR			errVerify	= JET_errSuccess;
				MessageId	msgid;
				DWORD		dwExpected;
				DWORD		dwActual;
				CPAGE		cpage;

				cpage.LoadPage( (void*)( pbData + ib ) );
				const ULONG ulChecksumExpected	= *( (LittleEndian<DWORD>*) ( pbData + ib ) );
				const ULONG ulChecksumActual	= UlUtilChecksum( pbData + ib, g_cbPage );

				/*  the checksum is invalid
				/**/
				if ( ulChecksumExpected != ulChecksumActual )
					{
					/*  the page is initialized
					/**/
					if ( cpage.Pgno() != pgnoNull || !plgbkargs->fCheckPagesOffset )
						{
						/*  read verification failure
						/**/
						errVerify	= ErrERRCheck( JET_errReadVerifyFailure );
						msgid		= (	plgbkargs->fCheckPagesOffset ?
											DATABASE_PAGE_CHECKSUM_MISMATCH_ID :
											PATCH_PAGE_CHECKSUM_MISMATCH_ID );
						dwExpected	= ulChecksumExpected;
						dwActual	= ulChecksumActual;
						}
					}

				/*  the checksum is valid and the page is initialized but has a bad
				/*  page number
				/**/
				else if (	cpage.Pgno() != pgnoNull &&
							plgbkargs->fCheckPagesOffset &&
							cpage.Pgno() != PgnoOfOffset( ibOffset + ib ) )
					{
					/*  read verification failure
					/**/
					errVerify	= ErrERRCheck( JET_errReadVerifyFailure );
					msgid		= DATABASE_PAGE_NUMBER_MISMATCH_ID;
					dwExpected	= PgnoOfOffset( ibOffset + ib );
					dwActual	= cpage.Pgno();
					}

				cpage.UnloadPage();

				//  there was a verification error

				if ( errVerify < JET_errSuccess )
					{
					//  fail the backup of this file with the error

					plgbkargs->err = errVerify;

					//  log the error
					
					const _TCHAR*	rgpsz[ 6 ];
					DWORD			irgpsz		= 0;
					_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
					_TCHAR			szOffset[ 64 ];
					_TCHAR			szLength[ 64 ];
					_TCHAR			szError[ 64 ];
					_TCHAR			szExpected[ 64 ];
					_TCHAR			szActual[ 64 ];

					CallS( pfapi->ErrPath( szAbsPath ) );
					_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset + ib, ibOffset + ib );
					_stprintf( szLength, _T( "%u (0x%08x)" ), g_cbPage, g_cbPage );
					_stprintf( szError, _T( "%i (0x%08x)" ), errVerify, errVerify );
					_stprintf( szExpected, _T( "%u (0x%08x)" ), dwExpected, dwExpected );
					_stprintf( szActual, _T( "%u (0x%08x)" ), dwActual, dwActual );
			
					rgpsz[ irgpsz++ ]	= szAbsPath;
					rgpsz[ irgpsz++ ]	= szOffset;
					rgpsz[ irgpsz++ ]	= szLength;
					rgpsz[ irgpsz++ ]	= szError;
					rgpsz[ irgpsz++ ]	= szExpected;
					rgpsz[ irgpsz++ ]	= szActual;

					UtilReportEvent(	eventError,
										LOGGING_RECOVERY_CATEGORY,
										msgid,
										irgpsz,
										rgpsz );
					}
				}
			}
		}

	/*  we are the last outstanding read
	/**/
	if ( !AtomicDecrement( (long*)plgbkargs->pacRead ) )
		{
		/*  signal the issuer thread that all reads are done
		/**/
		plgbkargs->pasigDone->Set();
		}
	}

/*	read cpage into buffer ppageMin for backup.
 */

ERR LOG::ErrLGReadPages(
	IFileAPI *pfapi,
	BYTE *pbData,
	LONG pgnoStart,
	LONG pgnoEnd,
	BOOL fCheckPagesOffset )
	{
	ERR		err		= JET_errSuccess;
	/*  copy pages in aligned chunks of pages using groups of async reads
	/**/
	extern long g_cpgBackupChunk;
	
	PGNO pgnoMax = pgnoEnd + 1;

	volatile long acRead = 0;
	CAutoResetSignal asigDone( CSyncBasicInfo( _T( "ErrLGBKReadPages::asigDone" ) ) );

	LGBK_ARGS lgbkargs;
	lgbkargs.err = JET_errSuccess;
	lgbkargs.pacRead = &acRead;
	lgbkargs.pasigDone = &asigDone;
	lgbkargs.fCheckPagesOffset = fCheckPagesOffset;

	DWORD cReadIssue;
	cReadIssue = 0;
	PGNO pgno1, pgno2;
	for ( pgno1 = pgnoStart,
		  pgno2 = min( ( ( pgnoStart + cpgDBReserved - 1 ) / g_cpgBackupChunk + 1 ) * g_cpgBackupChunk - cpgDBReserved + 1, pgnoMax );
		  pgno1 < pgnoMax && lgbkargs.err >= 0;
		  pgno1 = pgno2,
		  pgno2 = min( pgno1 + g_cpgBackupChunk, pgnoMax ) )
		{
		/*  issue a read for the current aligned chunk of pages
		/**/
		QWORD ibOffset;
		ibOffset = OffsetOfPgno( pgno1 );

		DWORD cbData;
		cbData = ( pgno2 - pgno1 ) * g_cbPage;
		
		err = pfapi->ErrIORead(	ibOffset,
								cbData,
								pbData,
								IFileAPI::PfnIOComplete( LGBKReadPagesCompleted ),
								DWORD_PTR( &lgbkargs ) );
		if ( err < 0 && lgbkargs.err >= 0 )
			{
			lgbkargs.err = err;
			}
		pbData += cbData;

		cReadIssue++;
		
		}

	/*  wait for all issued reads to complete
	/**/
	if ( AtomicExchangeAdd( (long*)&acRead, cReadIssue ) + cReadIssue != 0 )
		{
		CallS( pfapi->ErrIOIssue() );
		asigDone.Wait();
		}

	/*  get the error code from the reads
	/**/
	err = ( err < 0 ? err : lgbkargs.err );
	return err;
	}
	
ERR LOG::ErrLGBKReadPages(
	IFMP ifmp,
	VOID *pvPageMin,
	INT	cpage,
	INT	*pcbActual
#ifdef DEBUG
	,BYTE	*pbLGDBGPageList
#endif
	)
	{
	ERR		err = JET_errSuccess;
	INT		cpageT;
	INT		ipageT;
	FMP		*pfmp = &rgfmp[ifmp];

	// we add a final page, the former patch file header
	BOOL fRoomForFinalHeaderPage = fFalse;

#ifdef MINIMAL_FUNCTIONALITY
#else

	/*  determine if we are scrubbing the database
	/**/
	BOOL fScrub = m_fScrubDB;

	/*  we are scrubbing the database
	/**/
	if ( fScrub )
		{
		/*  we are scrubbing the first page of the database
		/**/
		if ( rgfmp[ ifmp ].PgnoCopyMost() == 0 )
			{
			/*  init the scrub
			/**/
			const CHAR * rgszT[1];
			INT isz = 0;

			Assert( NULL == m_pscrubdb );
			m_pscrubdb = new SCRUBDB( ifmp );
			if( NULL == m_pscrubdb )
				{
				CallR( ErrERRCheck( JET_errOutOfMemory ) );
				}

			CallR( m_pscrubdb->ErrInit( m_ppibBackup, CUtilProcessProcessor() ) );

			m_ulSecsStartScrub = UlUtilGetSeconds();
			m_dbtimeLastScrubNew = rgfmp[ifmp].DbtimeLast();

			rgszT[isz++] = rgfmp[ifmp].SzDatabaseName();
			Assert( isz <= sizeof( rgszT ) / sizeof( rgszT[0] ) );
		
			UtilReportEvent(
					eventInformation,
					DATABASE_ZEROING_CATEGORY,
					DATABASE_ZEROING_STARTED_ID,
					isz,
					rgszT,
					0,
					NULL,
					m_pinst );
			}
		}

#endif	//	MINIMAL_FUNCTIONALITY

	//	caller should have verified that buffer is not empty
	//
	Assert( cpage > 0 );

	/*	assume that database will be read in sets of cpage
	/*	pages.  Preread next cpage pages while the current
	/*	cpage pages are being read, and copied to caller
	/*	buffer.
	/*
	/*	preread next next cpage pages.  These pages should
	/*	be read while the next cpage pages are written to
	/*	the backup datababase file.
	/**/

	/*	read pages, which may have been preread, up to cpage but
	/*	not beyond last page at time of initiating backup.
	/**/
	Assert( pfmp->PgnoMost() >= pfmp->PgnoCopyMost() );
	cpageT = min( cpage, (INT)( pfmp->PgnoMost() - pfmp->PgnoCopyMost() + ( 0 == pfmp->PgnoCopyMost() ? cpgDBReserved : 0 ) ) );
	*pcbActual = 0;
	ipageT = 0;

#ifdef ELIMINATE_PATCH_FILE
	// we check if we have space for the last page
	fRoomForFinalHeaderPage =  ( cpageT < cpage );
#endif // ELIMINATE_PATCH_FILE

	/*  if we have no more pages to read, we're done
	/**/
	if ( cpageT == 0
		&& ( !fRoomForFinalHeaderPage || pfmp->FCopiedPatchHeader() ) )
		{
		Assert( pfmp->PgnoMost() == pfmp->PgnoCopyMost() );
		return JET_errSuccess;
		}

	if ( pfmp->PgnoCopyMost() == 0 )
		{
		//	caller should have verified that buffer has enough
		//	space for the reserved pages, plus at least one
		//	more page (to ensure that PgnoCopyMost advances
		//	beyond 0)
		//
		Assert( cpage > cpgDBReserved );

#ifdef ELIMINATE_PATCH_FILE

		UtilMemCpy( (BYTE *)pvPageMin, pfmp->Pdbfilehdr(), g_cbPage );
		DBFILEHDR *pdbfilehdr = (DBFILEHDR*)pvPageMin;
		BKINFO *pbkinfo = &pdbfilehdr->bkinfoFullCur;
		pbkinfo->le_lgposMark = m_lgposFullBackupMark;
		pbkinfo->logtimeMark = m_logtimeFullBackupMark;
		pbkinfo->le_genLow = m_lgenCopyMic;
		Assert( pbkinfo->le_genLow != 0 );
		Assert( pbkinfo->le_genHigh == 0 );

		pdbfilehdr->le_ulChecksum = UlUtilChecksum( (BYTE *)pdbfilehdr, g_cbPage );
		UtilMemCpy( (BYTE *) pvPageMin + g_cbPage, pdbfilehdr, g_cbPage );

#else // ELIMINATE_PATCH_FILE

		/* Copy header
		 */
		DBFILEHDR *pdbfilehdr = pfmp->Ppatchhdr();
		memcpy( pdbfilehdr, pfmp->Pdbfilehdr(), g_cbPage );
		BKINFO *pbkinfo = &pdbfilehdr->bkinfoFullCur;
		pbkinfo->le_lgposMark = m_lgposFullBackupMark;
		pbkinfo->logtimeMark = m_logtimeFullBackupMark;
		pbkinfo->le_genLow = m_lgenCopyMic;
		Assert( pbkinfo->le_genLow != 0 );
		Assert( pbkinfo->le_genHigh == 0 );

		pdbfilehdr->le_ulChecksum = UlUtilChecksum( (BYTE *)pdbfilehdr, g_cbPage );
		UtilMemCpy( (BYTE *)pvPageMin, pdbfilehdr, g_cbPage );
		UtilMemCpy( (BYTE *) pvPageMin + g_cbPage, pdbfilehdr, g_cbPage );

#endif // ELIMINATE_PATCH_FILE

		/*	we use first 2 pages buffer
		 */
		*pcbActual += g_cbPage * 2;
		ipageT += 2;
		Assert( 2 == cpgDBReserved );
		Assert( cpage >= ipageT );
		}

	const PGNO	pgnoStart	= pfmp->PgnoCopyMost() + 1;
	const PGNO	pgnoEnd		= pfmp->PgnoCopyMost() + ( cpageT - ipageT );

	if ( pgnoStart <= pgnoEnd  )
		{
		//	engage range lock for the region to copy	
		CallR( pfmp->ErrRangeLock( pgnoStart, pgnoEnd ) );

		// we will revert this on error after the RangeUnlock
		pfmp->SetPgnoCopyMost( pgnoEnd );
		}
	else
		{
		Assert( fRoomForFinalHeaderPage );
		}

	//  we will retry failed reads during backup in the hope of saving the
	//  backup set

	const TICK	tickStart	= TickOSTimeCurrent();
	const TICK	tickBackoff	= 100;
	const int	cRetry		= 16;

	int			iRetry		= 0;

#ifdef ELIMINATE_PATCH_FILE
	// if we have just the last page, avoid the loop
	// and the range locking part
	if ( pgnoStart > pgnoEnd )
		{
		Assert( fRoomForFinalHeaderPage );
		goto CopyFinalHeaderPage;
		}
#endif

	do
		{
		err = ErrLGReadPages( pfmp->Pfapi(), (BYTE *)pvPageMin + ( ipageT << g_shfCbPage ), pgnoStart, pgnoEnd, fTrue );

		if ( err < JET_errSuccess )
			{
			if ( iRetry < cRetry )
				{
				UtilSleep( ( iRetry + 1 ) * tickBackoff );
				}
			}
		else
			{
			if ( iRetry > 0 )
				{
				const _TCHAR*	rgpsz[ 5 ];
				DWORD			irgpsz		= 0;
				_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
				_TCHAR			szOffset[ 64 ];
				_TCHAR			szLength[ 64 ];
				_TCHAR			szFailures[ 64 ];
				_TCHAR			szElapsed[ 64 ];

				CallS( pfmp->Pfapi()->ErrPath( szAbsPath ) );
				_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), OffsetOfPgno( pgnoStart ), OffsetOfPgno( pgnoStart ) );
				_stprintf( szLength, _T( "%u (0x%08x)" ), ( pgnoEnd - pgnoStart + 1 ) * g_cbPage, ( pgnoEnd - pgnoStart + 1 ) * g_cbPage );
				_stprintf( szFailures, _T( "%i" ), iRetry );
				_stprintf( szElapsed, _T( "%g" ), ( TickOSTimeCurrent() - tickStart ) / 1000.0 );
		
				rgpsz[ irgpsz++ ]	= szAbsPath;
				rgpsz[ irgpsz++ ]	= szOffset;
				rgpsz[ irgpsz++ ]	= szLength;
				rgpsz[ irgpsz++ ]	= szFailures;
				rgpsz[ irgpsz++ ]	= szElapsed;

				UtilReportEvent(	eventError,
									LOGGING_RECOVERY_CATEGORY,
									TRANSIENT_READ_ERROR_DETECTED_ID,
									irgpsz,
									rgpsz,
									0,
									NULL,
									m_pinst );
				}
			}
		}
	while ( iRetry++ < cRetry && err < JET_errSuccess );

#ifdef MINIMAL_FUNCTIONALITY
#else

	/*  we are scrubbing the database and there was no error reading the pages
	/**/
	if ( fScrub && err >= JET_errSuccess )
		{
		/*  load all pages from the backup region into the cache so that they
		/*  can be scrubbed, skipping any uninitialized pages
		/**/
		PGNO pgnoScrubStart = 0xFFFFFFFF;
		PGNO pgnoScrubEnd	= 0x00000000;
		
		for ( PGNO pgno = pgnoStart; pgno <= pgnoEnd; pgno++ )
			{
			/*  get the raw page data
			/**/
			void* pv = (BYTE *)pvPageMin + ( pgno - pgnoStart + ipageT ) * g_cbPage;

			/*  get the pgno of this page from the page data
			/**/
			CPAGE cpage;
			cpage.LoadPage( pv );
			PGNO pgnoData = cpage.Pgno();
			cpage.UnloadPage();

			/*  this page is initialized
			/**/
			if ( pgnoData != pgnoNull )
				{
				/*  load this page data into the cache if not already cached
				/**/
				BFLatch bfl;
				if ( ErrBFWriteLatchPage( &bfl, ifmp, pgno, BFLatchFlags( bflfNoCached | bflfNew ) ) >= JET_errSuccess )
					{
					BFDirty( &bfl );
					UtilMemCpy( bfl.pv, pv, g_cbPage );
					BFWriteUnlatch( &bfl );
					}

				/*  we need to scrub this page eventually
				/**/
				pgnoScrubStart	= min( pgnoScrubStart, pgno );
				pgnoScrubEnd	= max( pgnoScrubEnd, pgno );
				}

			/*  this page is not initialized or we are on the last page
			/**/
			if ( pgnoData == pgnoNull || pgno == pgnoEnd )
				{
				/*  we have pages to scrub
				/**/
				if ( pgnoScrubStart <= pgnoScrubEnd )
					{
					/*  scrub these pages
					/**/
					err = m_pscrubdb->ErrScrubPages( pgnoScrubStart, pgnoScrubEnd - pgnoScrubStart + 1 );

					/*  reset scrub range
					/**/
					pgnoScrubStart	= 0xFFFFFFFF;
					pgnoScrubEnd	= 0x00000000;
					}
				}
			}

		/*  all pages had better be scrubbed!
		/**/
		Assert( pgnoScrubStart == 0xFFFFFFFF );
		Assert( pgnoScrubEnd == 0x00000000 );
		}

#endif	//	MINIMAL_FUNCTIONALITY

	if ( err < JET_errSuccess )
		{
		Assert ( pgnoStart > 0 );
		// we need to revert CopyMost on error
		pfmp->SetPgnoCopyMost( pgnoStart - 1 );
		}

	/*  disengage range lock for the region copied
	/**/
	pfmp->RangeUnlock( pgnoStart, pgnoEnd );

	Call( err );

	/*  update the read data count
	/**/
	*pcbActual += g_cbPage * ( cpageT - ipageT );

#ifdef ELIMINATE_PATCH_FILE
CopyFinalHeaderPage:
	if ( fRoomForFinalHeaderPage )
		{
		LGBKMakeDbTrailer( ifmp, (BYTE *)pvPageMin + *pcbActual);
		*pcbActual += g_cbPage;
		}
#endif

#ifdef DEBUG
	for ( PGNO pgnoCur = pfmp->PgnoCopyMost() - ( cpageT - ipageT ) + 1;
		ipageT < cpageT;
		ipageT++, pgnoCur++ )
		{
		if ( m_fDBGTraceBR > 1 && pbLGDBGPageList )
			{
			CPAGE cpage;
			cpage.LoadPage( (BYTE*) pvPageMin + g_cbPage * ipageT );
			sprintf(	reinterpret_cast<CHAR *>( pbLGDBGPageList ),
						"(%ld, %l64d) ",
						pgnoCur,
						cpage.Dbtime() );
			cpage.UnloadPage();
			pbLGDBGPageList += strlen( reinterpret_cast<CHAR *>( pbLGDBGPageList ) );
			}
		}
#endif

HandleError:
	if ( err < JET_errSuccess )
		{
		*pcbActual = 0;
		}

#ifdef MINIMAL_FUNCTIONALITY
#else

	/*  we just scrubbed the last page in the database
	/**/
	if ( fScrub
		&& ( NULL != m_pscrubdb )
		&& ( rgfmp[ ifmp ].PgnoCopyMost() == rgfmp[ ifmp ].PgnoMost() ) )
		{
		/*  term the scrub
		/**/
		err = m_pscrubdb->ErrTerm();
		
		const ULONG_PTR ulSecFinished 	= UlUtilGetSeconds();
		const ULONG_PTR ulSecs 			= ulSecFinished - m_ulSecsStartScrub;

		const CHAR * rgszT[16];
		INT isz = 0;

		CHAR	szSeconds[16];
		CHAR	szErr[16];
		CHAR	szPages[16];
		CHAR	szBlankPages[16];
		CHAR	szUnchangedPages[16];
		CHAR	szUnusedPages[16];
		CHAR	szUsedPages[16];
		CHAR	szDeletedRecordsZeroed[16];
		CHAR	szOrphanedLV[16];

	
		sprintf( szSeconds, "%"FMTSZ3264"d", ulSecs );
		sprintf( szErr, "%d", err );
		sprintf( szPages, "%d", m_pscrubdb->Scrubstats().cpgSeen );
		sprintf( szBlankPages, "%d", m_pscrubdb->Scrubstats().cpgUnused );
		sprintf( szUnchangedPages, "%d", m_pscrubdb->Scrubstats().cpgUnchanged );
		sprintf( szUnusedPages, "%d", m_pscrubdb->Scrubstats().cpgZeroed );
		sprintf( szUsedPages, "%d", m_pscrubdb->Scrubstats().cpgUsed );
		sprintf( szDeletedRecordsZeroed, "%d", m_pscrubdb->Scrubstats().cFlagDeletedNodesZeroed );
		sprintf( szOrphanedLV, "%d", m_pscrubdb->Scrubstats().cOrphanedLV );

		rgszT[isz++] = rgfmp[ifmp].SzDatabaseName();
		rgszT[isz++] = szSeconds;
		rgszT[isz++] = szErr;
		rgszT[isz++] = szPages;
		rgszT[isz++] = szBlankPages;
		rgszT[isz++] = szUnchangedPages;
		rgszT[isz++] = szUnusedPages;
		rgszT[isz++] = szUsedPages;
		rgszT[isz++] = szDeletedRecordsZeroed;
		rgszT[isz++] = szOrphanedLV;
		
		Assert( isz <= sizeof( rgszT ) / sizeof( rgszT[0] ) );
		UtilReportEvent(
				eventInformation,
				DATABASE_ZEROING_CATEGORY,
				DATABASE_ZEROING_STOPPED_ID,
				isz,
				rgszT,
				0,
				NULL,
				m_pinst );

		delete m_pscrubdb;
		m_pscrubdb = NULL;

		rgfmp[ifmp].SetDbtimeLastScrub( m_dbtimeLastScrubNew );
		LOGTIME logtimeScrub;
		LGIGetDateTime( &logtimeScrub );	
		rgfmp[ifmp].SetLogtimeScrub( logtimeScrub );
		}

#endif	//	MINIMAL_FUNCTIONALITY

	return err;
	}


/*	begin new log file and compute log backup parameters:
 *		m_lgenCopyMac = m_plgfilehdr->lGeneration;
 *		m_lgenCopyMic = fFullBackup ? set befor database copy : m_lgenDeleteMic.
 *		m_lgenDeleteMic = first generation in m_szLogFilePath
 *		m_lgenDeleteMac = current checkpoint, which may be several gen less than m_lgenCopyMac
 */
ERR LOG::ErrLGBKPrepareLogFiles(
	IFileSystemAPI *const	pfsapi,
	JET_GRBIT					grbit,
	CHAR						*szLogFilePath,
	CHAR						*szPathJetChkLog,
	CHAR						*szBackupPath )
	{
	ERR			err;
	CHECKPOINT	*pcheckpointT = NULL;
	LGPOS		lgposRecT;

	const BOOL	fFullBackup = ( 0 == grbit );
	const BOOL	fIncrementalBackup = ( JET_bitBackupIncremental == grbit );
	const BOOL	fSnapshotBackup = ( JET_bitBackupSnapshot == grbit );

	Assert ( 0 == grbit || JET_bitBackupIncremental == grbit || JET_bitBackupSnapshot == grbit );

	if ( fFullBackup )
		{
		CallR( ErrLGFullBackup( this, "", &lgposRecT ) );
		m_lgposFullBackup = lgposRecT;
		LGIGetDateTime( &m_logtimeFullBackup );
		}
	else if ( fIncrementalBackup )
		{
		CallR( ErrLGIncBackup( this, "", &lgposRecT ) );
		m_lgposIncBackup = lgposRecT;
		LGIGetDateTime( &m_logtimeIncBackup );
		}
	else
		{
		Assert ( fSnapshotBackup );
		// on snapshot we log at begin backup time
		Assert ( 0 != CmpLgpos ( &m_lgposSnapshotStart, &lgposMin) );

		// if SnapshotStart wasn't done, error out at this point
		for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			IFMP 	ifmp = m_pinst->m_mpdbidifmp[ dbid ];
			if ( ifmp >= ifmpMax )
				continue;

			FMP *pfmp = &rgfmp[ifmp];

			if ( pfmp->FInUse()
				&& pfmp->FLogOn()
				&& pfmp->FAttached()
				&& !pfmp->FInBackupSession()
				&& pfmp->FDuringSnapshot() )
					{
					CallR ( ErrERRCheck ( JET_errInvalidBackupSequence ) );
					}
			}

		// we log the end of snapshot as the db backup should be done by now
		CallR( ErrLGSnapshotStopBackup( this, &lgposRecT ) );
		m_lgposFullBackup = lgposRecT;
		LGIGetDateTime( &m_logtimeFullBackup );
		}


	while ( lgposRecT.lGeneration > m_plgfilehdr->lgfilehdr.le_lGeneration )
		{
		if ( m_fLGNoMoreLogWrite )
			{
			return( ErrERRCheck( JET_errLogWriteFail ) );
			}
		UtilSleep( cmsecWaitGeneric );
		}

	m_fBackupBeginNewLogFile = fTrue;

	/*	compute m_lgenCopyMac:
	/*	copy all log files up to but not including current log file
	/**/
	m_critLGFlush.Enter();
	Assert( m_lgenCopyMac == 0 );
	m_lgenCopyMac = m_plgfilehdr->lgfilehdr.le_lGeneration;
	Assert( m_lgenCopyMac != 0 );
	m_critLGFlush.Leave();
	Call( err );
			
	/*	set m_lgenDeleteMic
	/*	to first log file generation number.
	/**/
	Assert( m_lgenDeleteMic == 0 );
	Call ( ErrLGIGetGenerationRange( pfsapi, szLogFilePath, &m_lgenDeleteMic, NULL ) );
	if ( 0 == m_lgenDeleteMic )
		{
		Call ( ErrERRCheck( JET_errFileNotFound ) );
		}
	Assert( m_lgenDeleteMic != 0 );

	if ( fIncrementalBackup && szBackupPath )
		{
		LONG lgenT;
		/*	validate incremental backup against previous
		/*	full and incremenal backup.
		/**/
		Call ( ErrLGIGetGenerationRange( pfsapi, szBackupPath, NULL, &lgenT ) );
		if ( m_lgenDeleteMic > lgenT + 1 )
			{
			Call( ErrERRCheck( JET_errInvalidLogSequence ) );
			}
		}

	if ( fIncrementalBackup )
		{
		Call ( ErrLGCheckLogsForIncrementalBackup( m_lgenDeleteMic ) );
		}
	
	/*	set m_lgenDeleteMac to checkpoint log file
	/**/
	pcheckpointT = (CHECKPOINT *) PvOSMemoryPageAlloc( sizeof(CHECKPOINT), NULL );
	if ( pcheckpointT == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	
	LGFullNameCheckpoint( pfsapi, szPathJetChkLog );
	Call( ErrLGReadCheckpoint( pfsapi, szPathJetChkLog, pcheckpointT, fFalse ) );
	Assert( m_lgenDeleteMac == 0 );
	m_lgenDeleteMac = pcheckpointT->checkpoint.le_lgposCheckpoint.le_lGeneration;
	Assert( m_lgenDeleteMac <= m_lgenCopyMac );

	// calculate delete range the databases considering the
	// databases that were not involved in the backup process
	//
	if ( fFullBackup || fSnapshotBackup )
		{
		for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			IFMP 	ifmp = m_pinst->m_mpdbidifmp[ dbid ];
			if ( ifmp >= ifmpMax )
				continue;

			FMP *pfmp = &rgfmp[ifmp];


			if ( pfmp->FInUse()
				&& pfmp->FLogOn()
				&& pfmp->FAttached()
				&& !pfmp->FInBackupSession() )
				{		
				Assert( !pfmp->FSkippedAttach() );
				Assert( !pfmp->FDeferredAttach() );

				ULONG genLastFullBackupForDb = (ULONG) pfmp->Pdbfilehdr()->bkinfoFullPrev.le_genHigh;
				ULONG genLastIncBackupForDb = (ULONG) pfmp->Pdbfilehdr()->bkinfoIncPrev.le_genHigh;
				
//				m_lgenDeleteMac = min ( m_lgenDeleteMac, max( genLastFullBackupForDb, genLastIncBackupForDb ) );			
				// see bug 148811: if one database not in this full backup has a differential backup
				// (which shows as an incremental for JET), we will truncate the logs. We don't want this
				// (the log truncation must be done using a full or incremental backup)
				m_lgenDeleteMac = min ( m_lgenDeleteMac, genLastFullBackupForDb );			
				}
			}
		m_lgenDeleteMic = min( m_lgenDeleteMac, m_lgenDeleteMic );
		}	
	Assert( m_lgenDeleteMac <= m_lgenCopyMac );

	/*	compute m_lgenCopyMic
	/**/
	if ( fFullBackup || fSnapshotBackup)
		{
		/*	m_lgenCopyMic set before database copy
		/**/
		Assert( m_lgenCopyMic != 0 );
		}
	else
		{
		Assert ( fIncrementalBackup );
		/*	copy all files that are deleted for incremental backup
		/**/
		Assert( m_lgenDeleteMic != 0 );
		m_lgenCopyMic = m_lgenDeleteMic;
		}
		
	Assert ( m_lgenDeleteMic <= m_lgenDeleteMac );
	Assert ( m_lgenCopyMic <= m_lgenCopyMac );

	// report start backup of log file
		{
		CHAR 			szFullLogNameCopyMic[IFileSystemAPI::cchPathMax];
		CHAR 			szFullLogNameCopyMac[IFileSystemAPI::cchPathMax];
		CHAR 			szFullLogFilePath[IFileSystemAPI::cchPathMax];
		CHAR 			szFNameT[IFileSystemAPI::cchPathMax];
		const CHAR *	rgszT[]			= { szFullLogNameCopyMic, szFullLogNameCopyMac };			
		const INT		cbFillBuffer	= 128;
		CHAR			szTrace[cbFillBuffer + 1];

		if ( JET_errSuccess > m_pinst->m_pfsapi->ErrPathComplete( m_szLogFilePath, szFullLogFilePath ) )
			{
			strcpy( szFullLogFilePath, "" );
			}

		LGSzFromLogId( szFNameT, m_lgenCopyMic );
		LGMakeName(
			m_pinst->m_pfsapi,
			szFullLogNameCopyMic,
			szFullLogFilePath,
			szFNameT,
			(CHAR *)szLogExt );

		Assert ( m_lgenCopyMic < m_lgenCopyMac );
		LGSzFromLogId( szFNameT, m_lgenCopyMac - 1 );
		LGMakeName(
			m_pinst->m_pfsapi,
			szFullLogNameCopyMac,
			szFullLogFilePath,
			szFNameT,
			(CHAR *)szLogExt );

		UtilReportEvent(
			eventInformation,
			LOGGING_RECOVERY_CATEGORY,
			BACKUP_LOG_FILES_START,
			2,
			rgszT,
			0,
			NULL,
			m_pinst );

		szTrace[ cbFillBuffer ] = '\0';
		_snprintf(
			szTrace,
			cbFillBuffer,
			"BACKUP PREPARE LOGS (copy 0x%05X-0x%05X, delete 0x%05X-0x%05X)",
			m_lgenCopyMic,
			m_lgenCopyMac - 1,
			m_lgenDeleteMic,
			m_lgenDeleteMac );
		Call( ErrLGTrace( m_ppibBackup, szTrace ) );
		}

HandleError:
	// UNDONE: if this function failed, we should stop the backup
	// not relay on the backup client behaviour and on or on the
	// fact that the code in log copy/truncate part will deal with
	// the state in which the backup is.
	
	OSMemoryPageFree( pcheckpointT );
	return err;
	}
	

ERR ErrLGCheckIncrementalBackup( INST *pinst )
	{
	DBID dbid;
	BKINFO *pbkinfo;
	
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP ifmp = pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;
		
		FMP	*pfmp = &rgfmp[ifmp];
		
		/*	make sure all the attached DB are qaulified for incremental backup.
		 */
		if ( pfmp->FAttached() )
			{
			Assert( pfmp->Pdbfilehdr() );
			Assert( !pfmp->FSkippedAttach() );
			Assert( !pfmp->FDeferredAttach() );
			pbkinfo = &pfmp->Pdbfilehdr()->bkinfoFullPrev;
			if ( pbkinfo->le_genLow == 0 )
				{
				const UINT	csz	= 1;
				const char	*rgszT[csz];
				rgszT[0] = pfmp->SzDatabaseName();
				UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					DATABASE_MISS_FULL_BACKUP_ERROR_ID, csz, rgszT, 0, NULL, pinst );
				return ErrERRCheck( JET_errMissingFullBackup );
				}
			}
		}
	return JET_errSuccess;
	}
	

ERR LOG::ErrLGCheckLogsForIncrementalBackup( LONG lGenMinExisting )
	{
	DBID dbid;
	ERR			err = JET_errSuccess;
	
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP ifmp = m_pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;
		
		FMP	*pfmp = &rgfmp[ifmp];
		
		if ( pfmp->FAttached() )
			{
			Assert( pfmp->Pdbfilehdr() );
			Assert( !pfmp->FSkippedAttach() );
			Assert( !pfmp->FDeferredAttach() );

			LONG lGenMaxBackup = max ( 	pfmp->Pdbfilehdr()->bkinfoFullPrev.le_genHigh,
										pfmp->Pdbfilehdr()->bkinfoIncPrev.le_genHigh );
			
			if ( lGenMinExisting > lGenMaxBackup  + 1 )
				{
				const UINT 		csz = 1;
				const CHAR *	rgszT[csz];
				CHAR 			szFullLogName[IFileSystemAPI::cchPathMax];
				CHAR 			szFullLogFilePath[IFileSystemAPI::cchPathMax];
				CHAR 			szFNameT[IFileSystemAPI::cchPathMax];
				
				rgszT[0] = szFullLogName;
				
				CallR( m_pinst->m_pfsapi->ErrPathComplete( m_szLogFilePath, szFullLogFilePath ) );
				
				LGSzFromLogId( szFNameT, lGenMaxBackup + 1 );
				LGMakeName( m_pinst->m_pfsapi, szFullLogName, szFullLogFilePath, szFNameT, (CHAR *)szLogExt );
				
				UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
						BACKUP_LOG_FILE_MISSING_ERROR_ID, csz, rgszT, 0, NULL, m_pinst );
						
				return ErrERRCheck( JET_errMissingFileToBackup );
				}				
			}
		}
	return JET_errSuccess;
	}


/*	copies database files and logfile generations starting at checkpoint
 *  record to directory specified by the environment variable BACKUP.
 *  No flushing or switching of log generations is involved.
 *  The Backup call may be issued at any time, and does not interfere
 *  with the normal functioning of the system - nothing gets locked.
 *
 *  The database page is copied page by page in page sequence number. If
 *  a copied page is dirtied after it is copied, the page has to be
 *  recopied again. A flag is indicated if a database is being copied. If
 *  BufMan is writing a dirtied page and the page is copied, then BufMan
 *  has to copy the dirtied page to both the backup copy and the current
 *  database.
 *
 *  If the copy is later used to Restore without a subsequent log file, the
 *  restored database will be consistent and will include any transaction
 *  committed prior to backing up the very last log record; if there is a
 *  subsequent log file, that file will be used during Restore as a
 *  continuation of the backed-up log file.
 *
 *	PARAMETERS
 *
 *	RETURNS
 *		JET_errSuccess, or the following error codes:
 *			JET_errNoBackupDirectory
 *			JET_errFailCopyDatabase
 *			JET_errFailCopyLogFile
 *
 */
ERR ISAMAPI ErrIsamBackup( JET_INSTANCE jinst, const CHAR *szPathName, JET_GRBIT grbit, JET_PFNSTATUS pfnStatus )
	{
	ERR				err = JET_errSuccess;
	INST * const	pinst	= (INST *)jinst;
	_TCHAR			szBackup[IFileSystemAPI::cchPathMax];
	
	CallR( pinst->m_pfsapi->ErrPathComplete( szPathName, szBackup ) );
	return pinst->m_plog->ErrLGBackup( pinst->m_pfsapi, szBackup, grbit, pfnStatus );
	}
	
ERR ErrLGIRemoveTempDir( IFileSystemAPI *const pfsapi, char *szT, char *szBackupPath, const char *szTempDir )
	{
	ERR err;
	
  	strcpy( szT, szBackupPath );
	strcat( szT, szTempDir );
	CallR( ErrLGDeleteAllFiles( pfsapi, szT ) );
  	strcpy( szT, szBackupPath );
	strcat( szT, szTempDir );
	err = pfsapi->ErrFolderRemove( szT );
	return err == JET_errInvalidPath ? JET_errSuccess : err;
	}
	
#define	cpageBackupBufferMost	256

#define JET_INVALID_HANDLE 	JET_HANDLE(-1)
ERR LOG::ErrLGBackupCopyFile( IFileSystemAPI *const pfsapi, const CHAR *szFileName, const CHAR *szBackup,  JET_PFNSTATUS pfnStatus, const BOOL fOverwriteExisting	 )
	{
	ERR				err 				= JET_errSuccess;
	JET_HANDLE		hfFile 				= JET_INVALID_HANDLE;
	QWORD 			qwFileSize 			= 0;
	QWORD 			ibOffset 			= 0;
	
	DWORD 			cbBuffer 			= cpageBackupBufferMost * g_cbPage;
	VOID * 			pvBuffer 			= NULL;
	IFileAPI *		pfapiBackupDest 	= NULL;

	// UNDONE: keep status

	{
	ULONG			ulFileSizeLow 		= 0;
	ULONG			ulFileSizeHigh 		= 0;
	CallR( ErrLGBKOpenFile( pfsapi, szFileName, &hfFile, &ulFileSizeLow, &ulFileSizeHigh, m_fBackupFull ) );
	qwFileSize = ( QWORD(ulFileSizeHigh) << 32) + QWORD(ulFileSizeLow);
	if ( 0 == ulFileSizeHigh )
		{
		cbBuffer = min( cbBuffer, ulFileSizeLow);
		}
	}

	
	pvBuffer = PvOSMemoryPageAlloc( cbBuffer, NULL );
	if ( pvBuffer == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	{
	CHAR	szDirT[ IFileSystemAPI::cchPathMax ];
	CHAR	szExtT[ IFileSystemAPI::cchPathMax ];
	CHAR	szFNameT[ IFileSystemAPI::cchPathMax ];
	CHAR	szBackupDest[ IFileSystemAPI::cchPathMax ];
	CHAR	szBackupPath[IFileSystemAPI::cchPathMax];

	CallS( pfsapi->ErrPathParse( szFileName, szDirT, szFNameT, szExtT ) );

	/*	backup directory
	/**/
	strcpy( szBackupPath, szBackup );
	OSSTRAppendPathDelimiter( szBackupPath, fTrue );

	LGMakeName( m_pinst->m_pfsapi, szBackupDest, szBackupPath, szFNameT, (CHAR *) szExtT );	

	Call( pfsapi->ErrFileCreate( szBackupDest, &pfapiBackupDest, fFalse, fFalse, fOverwriteExisting ) );
	}

	Assert ( pfapiBackupDest );

	while ( qwFileSize )
		{
		ULONG cbActual;

		if ( m_pinst->m_fTermInProgress )
			{
			Call ( ErrERRCheck( JET_errTermInProgress ) );
			}
		
		Call ( ErrLGBKReadFile( pfsapi, hfFile, pvBuffer, cbBuffer, &cbActual ));

		Call( pfapiBackupDest->ErrIOWrite( ibOffset, cbActual, (BYTE*)pvBuffer ) );
		
		ibOffset += QWORD(cbActual);
		qwFileSize -= QWORD(cbActual);
		}

	Assert ( JET_INVALID_HANDLE != hfFile );
	Call ( ErrLGBKCloseFile( hfFile ) );
	hfFile = JET_INVALID_HANDLE;
	Assert ( JET_errSuccess == err );

HandleError:

	if ( NULL != pvBuffer )
		{
		OSMemoryPageFree( pvBuffer );
		pvBuffer = NULL;		
		}
		
	if ( NULL != pfapiBackupDest )
		{
		delete pfapiBackupDest;
		pfapiBackupDest = NULL;
		}
		
	if ( JET_INVALID_HANDLE != hfFile )
		{
		(void) ErrLGBKCloseFile( hfFile );
		hfFile = JET_INVALID_HANDLE;
		}
	return err;	
	}

ERR LOG::ErrLGBackupPrepareDirectory( IFileSystemAPI *const pfsapi, const CHAR *szBackup, CHAR *szBackupPath, JET_GRBIT grbit )
	{
	ERR				err 			= JET_errSuccess;
	const BOOL		fFullBackup 	= !( grbit & JET_bitBackupIncremental );
	const BOOL		fBackupAtomic 	= ( grbit & JET_bitBackupAtomic );
	
	CHAR			szT[IFileSystemAPI::cchPathMax];
	CHAR			szFrom[IFileSystemAPI::cchPathMax];

	/*	backup directory
	/**/
	strcpy( szBackupPath, szBackup );
	OSSTRAppendPathDelimiter( szBackupPath, fTrue );
	if ( m_pinst->m_fCreatePathIfNotExist )
		{
		Call( ErrUtilCreatePathIfNotExist( pfsapi, szBackupPath, NULL ) );
		}

	/*	reconsist atomic backup directory
	/*	1)	if temp directory, delete temp directory
	/**/
	Call( ErrLGIRemoveTempDir( pfsapi, szT, szBackupPath, szTempDir ) );

	if ( fBackupAtomic )
		{
		/*	2)	if old and new directories, delete old directory
		/*	3)	if new directory, move new to old
		/*
		/*	Now we should have an empty direcotry, or a directory with
		/*	an old subdirectory with a valid backup.
		/*
		/*	4) make a temporary directory for the current backup.
		/**/
		err = ErrLGCheckDir( pfsapi, szBackupPath, (CHAR *)szAtomicNew );
		if ( err == JET_errBackupDirectoryNotEmpty )
			{
	  		strcpy( szT, szBackupPath );
			strcat( szT, szAtomicOld );
			OSSTRAppendPathDelimiter( szT, fTrue );
			Call( ErrLGDeleteAllFiles( pfsapi, szT ) );
	  		strcpy( szT, szBackupPath );
			strcat( szT, szAtomicOld );
			err = pfsapi->ErrFolderRemove( szT );
			Call( err == JET_errInvalidPath ? JET_errSuccess : err );

			strcpy( szFrom, szBackupPath );
			strcat( szFrom, (CHAR *)szAtomicNew );
			Call( pfsapi->ErrFileMove( szFrom, szT ) );
			}

		/*	if incremental, set backup directory to szAtomicOld
		/*	else create and set to szTempDir
		/**/
		if ( !fFullBackup )
			{
			/*	backup to old directory
			/**/
			strcat( szBackupPath, szAtomicOld );
			OSSTRAppendPathDelimiter( szBackupPath, fTrue );
			}
		else
			{
			strcpy( szT, szBackupPath );
			strcat( szT, szTempDir );
			err = pfsapi->ErrFolderCreate( szT );
			if ( err < 0 )
				{
				Call( ErrERRCheck( JET_errMakeBackupDirectoryFail ) );
				}

			/*	backup to temp directory
			/**/
			strcat( szBackupPath, szTempDir );
			}
		}
	else
		{
		if ( !fFullBackup )
			{
			/*	check for non-atomic backup directory empty
			/**/
			Call( ErrLGCheckDir( pfsapi, szBackupPath, (CHAR *)szAtomicNew ) );
			Call( ErrLGCheckDir( pfsapi, szBackupPath, (CHAR *)szAtomicOld ) );
			}
		else
			{
			/*	check for backup directory empty
			/**/
			Call( ErrLGCheckDir( pfsapi, szBackupPath, NULL ) );
			}
		}
		
	HandleError:
		return err;
		}


ERR LOG::ErrLGBackupPromoteDirectory( IFileSystemAPI *const pfsapi, const CHAR *szBackup,  CHAR *szBackupPath, JET_GRBIT grbit )
	{
	ERR				err 			= JET_errSuccess;
	const BOOL		fFullBackup 	= !( grbit & JET_bitBackupIncremental );
	const BOOL		fBackupAtomic 	= ( grbit & JET_bitBackupAtomic );
	
	//	for full backup, graduate temp backup to new backup and delete old backup.
	
	if ( !fBackupAtomic || !fFullBackup )
		return JET_errSuccess;

	CHAR			szFrom[IFileSystemAPI::cchPathMax];
	CHAR			szT[IFileSystemAPI::cchPathMax];
		
  	strcpy( szFrom, szBackupPath );

	/*	reset backup path
	/**/
	szBackupPath[strlen(szBackupPath) - strlen(szTempDir)] = '\0';

	strcpy( szT, szBackupPath );
	strcat( szT, (CHAR *)szAtomicNew );
	err = pfsapi->ErrFileMove( szFrom, szT );
	if ( JET_errFileNotFound == err )
		{
		err = JET_errSuccess;
		}
	Call( err );

	strcpy( szT, szBackupPath );
	strcat( szT, szAtomicOld );
	OSSTRAppendPathDelimiter( szT, fTrue );
	Call( ErrLGDeleteAllFiles( pfsapi, szT ) );
	strcpy( szT, szBackupPath );
	strcat( szT, szAtomicOld );
	
	err = pfsapi->ErrFolderRemove( szT );
	
	if ( JET_errInvalidPath == err )
		{
		err = JET_errSuccess;
		}
		
	HandleError:
		return err;
	}

ERR LOG::ErrLGBackupCleanupDirectory( IFileSystemAPI *const pfsapi, const CHAR *szBackup, CHAR *szBackupPath )
	{
	ERR			err = JET_errSuccess;

	if ( szBackup && szBackup[0] )
		{
		CHAR	szT[IFileSystemAPI::cchPathMax];
		
		strcpy( szBackupPath, szBackup );
		OSSTRAppendPathDelimiter( szBackupPath, fTrue );
		CallS( ErrLGIRemoveTempDir( pfsapi, szT, szBackupPath, szTempDir ) );
		}

	return err;
	}
		
ERR LOG::ErrLGBackup( IFileSystemAPI *const pfsapi, const CHAR *szBackup, JET_GRBIT grbit, JET_PFNSTATUS pfnStatus )
	{
	ERR			err = JET_errSuccess;

	BOOL		fFullBackup = !( grbit & JET_bitBackupIncremental );
	BOOL		fBackupAtomic = ( grbit & JET_bitBackupAtomic );

	ULONG		cPagesSoFar = 0;
	ULONG		cExpectedPages = 0;
	JET_SNPROG	snprog;
	BOOL		fShowStatus = fFalse;

	CHAR		szBackupPath[IFileSystemAPI::cchPathMax];

	unsigned long 			cInstanceInfo 	= 0;
	JET_INSTANCE_INFO * 	aInstanceInfo 	= NULL;
	JET_INSTANCE_INFO * 	pInstanceInfo 	= NULL;
	CHAR * 					szNames 		= NULL;

	if ( m_fLogDisabled )
		{
		return ErrERRCheck( JET_errLoggingDisabled );
		}

	if ( m_fLGNoMoreLogWrite )
		{
		Assert( fFalse );
		return ErrERRCheck( JET_errLogWriteFail );
		}

	if ( !fFullBackup && m_fLGCircularLogging )
		{
		return ErrERRCheck( JET_errInvalidBackup );
		}

	CallR( ErrLGBKBeginExternalBackup( pfsapi, ( fFullBackup ? 0 : JET_bitBackupIncremental ) ) );
	Assert ( m_fBackupInProgress );

	/*	if NULL backup directory then just delete log files
	/**/
	if ( szBackup == NULL || szBackup[0] == '\0' )
		{
		//	set lgenDeleteMac to current checkpoint
		m_lgenDeleteMac = m_pcheckpoint->checkpoint.le_lgposCheckpoint.le_lGeneration;

		//	if circular logging is not enabled, try to set lgenDeleteMic
		//	to first log file generation number
		//	if circular logging is enabled, no point in truncating
		//	logs (it will just happen naturally)
		m_lgenDeleteMic = 0;

		if ( !m_fLGCircularLogging )
			{
			//	ignore any errors (we will just force TruncateLog
			//	not to do anything)
			(void)ErrLGIGetGenerationRange( pfsapi, m_szLogFilePath, &m_lgenDeleteMic, NULL );
			}

		if ( 0 == m_lgenDeleteMic )
			{
			//	this will force TruncateLog not to do anything
			m_lgenDeleteMic = m_lgenDeleteMac;
			}

		goto DeleteLogs;
		}

	Call ( ErrLGBackupPrepareDirectory( pfsapi, szBackup, szBackupPath, grbit ) );	
	if ( !fFullBackup )
		{
		goto CopyLogFiles;
		}

	/*	full backup
	/**/
	Assert( fFullBackup );

	/*	initialize status
	/**/
	if ( fShowStatus = (pfnStatus != NULL) )
		{
		snprog.cbStruct = sizeof(JET_SNPROG);
		snprog.cunitDone = 0;
		snprog.cunitTotal = 100;

		/*	status callback
		/**/
		(*pfnStatus)(0, JET_snpBackup, JET_sntBegin, &snprog);
		}
		
	Call ( ErrIsamGetInstanceInfo( &cInstanceInfo, &aInstanceInfo ) );

	// find the instance and backup all database file: edb + stm
	{
	pInstanceInfo = NULL;
	for ( unsigned long iInstanceInfo = 0; iInstanceInfo < cInstanceInfo && !pInstanceInfo; iInstanceInfo++)
		{
		if ( aInstanceInfo[iInstanceInfo].hInstanceId == (JET_INSTANCE)m_pinst )
			{
			pInstanceInfo = aInstanceInfo + iInstanceInfo;
			}
		}
	// we should find at least the instance in which we are running
	AssertRTL ( pInstanceInfo );

	for ( ULONG_PTR iDatabase = 0; iDatabase < pInstanceInfo->cDatabases; iDatabase++)
		{
		Assert ( pInstanceInfo->szDatabaseFileName );
		Assert ( pInstanceInfo->szDatabaseFileName[iDatabase] );
		Call ( ErrLGBackupCopyFile( pfsapi, pInstanceInfo->szDatabaseFileName[iDatabase], szBackupPath, pfnStatus ) );		

		Assert ( pInstanceInfo->szDatabaseSLVFileName );
		if ( pInstanceInfo->szDatabaseSLVFileName[iDatabase] )
			{
			Call ( ErrLGBackupCopyFile( pfsapi, pInstanceInfo->szDatabaseSLVFileName[iDatabase], szBackupPath, pfnStatus ) );		
			}
		}
	}
	/*	successful copy of all the databases */

CopyLogFiles:
	{
	ULONG 			cbNames;
	
	Call ( ErrLGBKGetLogInfo( pfsapi, NULL, 0, &cbNames, NULL, fFullBackup ) );	
	szNames = (CHAR *)PvOSMemoryPageAlloc( cbNames, NULL );
	if ( szNames == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	Call ( ErrLGBKGetLogInfo( pfsapi, szNames, cbNames, NULL, NULL, fFullBackup ) );	
	Assert ( szNames );
	}

	// now backup all files (patch and logs) in szNames
	CHAR *szNamesWalking;
	szNamesWalking = szNames;
	while ( *szNamesWalking )
		{
		Call ( ErrLGBackupCopyFile( pfsapi, szNamesWalking, szBackupPath, pfnStatus, fTrue ) );
		szNamesWalking += strlen( szNamesWalking ) + 1;
		}

	Call ( ErrLGBackupPromoteDirectory( pfsapi, szBackup, szBackupPath, grbit ) );

DeleteLogs:	
	Assert( err == JET_errSuccess );
	Call ( ErrLGBKTruncateLog(pfsapi) );

	/*	complete status update
	/**/
	if ( fShowStatus )
		{
		Assert( snprog.cbStruct == sizeof(snprog) && snprog.cunitTotal == 100 );
		snprog.cunitDone = 100;
		(*pfnStatus)(0, JET_snpBackup, JET_sntComplete, &snprog);
		}

HandleError:

	{
	ERR errT;
	errT = ErrIsamEndExternalBackup( (JET_INSTANCE)m_pinst, ( JET_errSuccess <= err )?JET_bitBackupEndNormal:JET_bitBackupEndAbort );
	if ( JET_errSuccess <= err )
		{
		err = errT;
		}		
	}
	
	if ( aInstanceInfo )
		{
		JetFreeBuffer( (char *)aInstanceInfo );
		aInstanceInfo = NULL;
		}

	if ( szNames )
		{
		OSMemoryPageFree( szNames );
		szNames = NULL;		
		}

	CallS ( ErrLGBackupCleanupDirectory( pfsapi, szBackup, szBackupPath ) );
		
	return err;	
	}


/*
 *	Restores databases from database backups and log generations.  Redoes
 *	log from latest checkpoint record. After the backed-up logfile is
 *  Restored, the initialization process continues with Redo of the current
 *  logfile as long as the generation numbers are contiguous. There must be a
 *  log file szJetLog in the backup directory, else the Restore process fails.
 *
 *	GLOBAL PARAMETERS
 *		m_szRestorePath (IN) 	pathname of the directory with backed-up files.
 *		lgposRedoFrom(OUT)	is the position (generation, logsec, displacement)
 *							of the last saved log record; Redo of the
 *							current logfile will continue from this point.
 *
 *	RETURNS
 *		JET_errSuccess, or error code from failing routine, or one
 *				of the following "local" errors:
 *				-AfterInitialization
 *				-errFailRestoreDatabase
 *				-errNoRestoredDatabases
 *				-errMissingJetLog
 *  FAILS ON
 *		missing szJetLog or System.mdb on backup directory
 *		noncontiguous log generation
 *
 *  SIDE EFFECTS:
 *		All databases may be changed.
 *
 *  COMMENTS
 *		this call is executed during the normal first JetInit call,
 *  	if the environment variable RESTORE is set. Subsequent to
 *		the successful execution of Restore,
 *		system operation continues normally.
 */
VOID LOG::LGRSTFreeRstmap( VOID )
	{
	if ( NULL != m_rgrstmap )
		{
		RSTMAP *prstmapCur = m_rgrstmap;
		RSTMAP *prstmapMax = m_rgrstmap + m_irstmapMac;
		
		while ( prstmapCur < prstmapMax )
			{
			if ( prstmapCur->szDatabaseName )
				OSMemoryHeapFree( prstmapCur->szDatabaseName );
			if ( prstmapCur->szNewDatabaseName )
				OSMemoryHeapFree( prstmapCur->szNewDatabaseName );
			if ( prstmapCur->szGenericName )
				OSMemoryHeapFree( prstmapCur->szGenericName );
#ifdef ELIMINATE_PATCH_FILE
#else
			if ( prstmapCur->szPatchPath )
				OSMemoryHeapFree( prstmapCur->szPatchPath );
#endif

			prstmapCur++;
			}
		OSMemoryHeapFree( m_rgrstmap );
		m_rgrstmap = NULL;
		}

	m_irstmapMac = 0;
	}
	
	
/*	initialize log path, restore log path, and check its continuity
/**/
ERR LOG::ErrLGRSTInitPath( IFileSystemAPI *const pfsapi, CHAR *szBackupPath, CHAR *szNewLogPath, CHAR *szRestorePath, CHAR *szLogDirPath )
	{
	ERR err;
	
	CallR( pfsapi->ErrPathComplete( szBackupPath == NULL ? "." : szBackupPath, szRestorePath ) );
	OSSTRAppendPathDelimiter( szRestorePath, fTrue );

	m_szLogCurrent = szRestorePath;

	CallR( pfsapi->ErrPathComplete( szNewLogPath, szLogDirPath ) );
	OSSTRAppendPathDelimiter( szLogDirPath, fTrue );

	return JET_errSuccess;
	}


/*	log restore checkpoint setup
/**/
ERR LOG::ErrLGRSTSetupCheckpoint( IFileSystemAPI *const pfsapi, LONG lgenLow, LONG lgenHigh, CHAR *szCurCheckpoint )
	{
	ERR			err;
	CHAR		szFNameT[IFileSystemAPI::cchPathMax];
	CHAR		szT[IFileSystemAPI::cchPathMax];
	LGPOS		lgposCheckpoint;

	//	UNDONE:	optimize to start at backup checkpoint

	/*	Set up *checkpoint* and related *system parameters*.
	 *	Read checkpoint file in backup directory. If does not exist, make checkpoint
	 *	as the oldest log files. Also set dbms_paramT as the parameter for the redo
	 *	point.
	 */

	/*  redo backeup logfiles beginning with first gen log file.
	/**/
	LGSzFromLogId( szFNameT, lgenLow );
	strcpy( szT, m_szRestorePath );
	strcat( szT, szFNameT );
	strcat( szT, szLogExt );
	Assert( strlen( szT ) <= sizeof( szT ) - 1 );
	Call( pfsapi->ErrFileOpen( szT, &m_pfapiLog ) );

	/*	read log file header
	/**/
	Call( ErrLGReadFileHdr( m_pfapiLog, m_plgfilehdr, fCheckLogID ) );
	m_pcheckpoint->checkpoint.dbms_param = m_plgfilehdr->lgfilehdr.dbms_param;

	lgposCheckpoint.lGeneration = lgenLow;
	lgposCheckpoint.isec = (WORD) m_csecHeader;
	lgposCheckpoint.ib = 0;
	m_pcheckpoint->checkpoint.le_lgposCheckpoint = lgposCheckpoint;

	Assert( sizeof( m_pcheckpoint->rgbAttach ) == cbAttach );
	UtilMemCpy( m_pcheckpoint->rgbAttach, m_plgfilehdr->rgbAttach, cbAttach );

	/*	delete the old checkpoint file
	/**/
	if ( szCurCheckpoint )
		{
		strcpy( szT, szCurCheckpoint );
		OSSTRAppendPathDelimiter( szT, fTrue );
		strcat( szT, m_szJet );
		strcat( szT, szChkExt );

		Assert ( NULL == m_pcheckpointDeleted );

		m_pcheckpointDeleted = (CHECKPOINT *) PvOSMemoryPageAlloc( sizeof( CHECKPOINT ), NULL );
		if ( NULL == m_pcheckpointDeleted )
			Call ( ErrERRCheck( JET_errOutOfMemory ) );
		
		err = ErrLGReadCheckpoint( pfsapi, szT, m_pcheckpointDeleted, fFalse );
		if ( err < JET_errSuccess )
			{
			OSMemoryPageFree ( (void *) m_pcheckpointDeleted );
			m_pcheckpointDeleted = NULL;
			
			if ( JET_errCheckpointFileNotFound == err )
				{
				err = JET_errSuccess;
				}
			else
				{
				Call ( err );
				}
			}
			

		CallSx(  pfsapi->ErrFileDelete( szT ), JET_errFileNotFound );

		strcpy( m_pinst->m_szSystemPath, szCurCheckpoint );
		}
	
HandleError:
	delete m_pfapiLog;
	m_pfapiLog = NULL;

	return err;
	}


/*	for log restore to build restore map RSTMAP
/**/
ERR LOG::ErrLGRSTBuildRstmapForRestore( VOID )
	{
	ERR				err			= JET_errSuccess;
	INT				irstmap		= 0;
	INT				irstmapMac	= 0;
	RSTMAP*			rgrstmap	= NULL;
	RSTMAP*			prstmap;
	CHAR			szSearch[IFileSystemAPI::cchPathMax];
	CHAR			szFileName[IFileSystemAPI::cchPathMax];
	CHAR			szFile[IFileSystemAPI::cchPathMax];
	CHAR			szT[IFileSystemAPI::cchPathMax];
	IFileFindAPI*	pffapi		= NULL;

	/*	build rstmap, scan all *.pat files and build RSTMAP
	 *	build generic name for search the destination. If szDest is null, then
	 *	keep szNewDatabase Null so that it can be copied backup to szOldDatabaseName.
	 */
	Assert( FOSSTRTrailingPathDelimiter( m_szRestorePath ) );
	Assert( strlen( m_szRestorePath ) + strlen( "*" ) + strlen( szPatExt ) + 1 < IFileSystemAPI::cchPathMax );

	strcpy( szSearch, m_szRestorePath );
	strcat( szSearch, "*" );
	strcat( szSearch, szPatExt );

	//	patch files are always on the OS file-system

	Call( m_pinst->m_pfsapi->ErrFileFind( szSearch, &pffapi ) );
	while ( ( err = pffapi->ErrNext() ) == JET_errSuccess )
		{
		/*	run out of rstmap entries, allocate more
		/**/
		if ( irstmap + 1 >= irstmapMac )
			{
			prstmap = static_cast<RSTMAP *>( PvOSMemoryHeapAlloc( sizeof(RSTMAP) * ( irstmap + 8 ) ) );
			if ( prstmap == NULL )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			memset( prstmap + irstmap, 0, sizeof( RSTMAP ) * 8 );
			if ( rgrstmap != NULL )
				{
				UtilMemCpy( prstmap, rgrstmap, sizeof(RSTMAP) * irstmap );
				OSMemoryHeapFree( rgrstmap );
				}
			rgrstmap = prstmap;
			irstmapMac += 8;
			}

		/*	keep resource db null for non-external restore.
		 *	Store generic name ( szFileName without .pat extention )
		 */
		Call( pffapi->ErrPath( szFileName ) );
		Call( m_pinst->m_pfsapi->ErrPathParse( szFileName, szT, szFile, szT ) );
		prstmap = rgrstmap + irstmap;
		if ( (prstmap->szGenericName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( szFile ) + 1 ) ) ) == NULL )
			Call( ErrERRCheck( JET_errOutOfMemory ) );
		strcpy( prstmap->szGenericName, szFile );
		prstmap->fSLVFile = fFalse;
		irstmap++;

		// fill an entry for the SLV file. If it will be missing, it's ok, we ignore the entry
		prstmap = rgrstmap + irstmap;
		if ( (prstmap->szGenericName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( szFile ) + 1 ) ) ) == NULL )
			Call( ErrERRCheck( JET_errOutOfMemory ) );
		strcpy( prstmap->szGenericName, szFile );
		prstmap->fSLVFile = fTrue;
		irstmap++;
		
		}
	Call( err == JET_errFileNotFound ? JET_errSuccess : err );

	if ( 0 == irstmap )
		{
		//	didn't find any patch files
		//
		Call( ErrERRCheck( JET_errPatchFileMissing ) );
		}

	m_irstmapMac = irstmap;
	m_rgrstmap = rgrstmap;

	delete pffapi;
	return JET_errSuccess;

HandleError:
	while ( rgrstmap && --irstmap >= 0 )
		{
		OSMemoryHeapFree( rgrstmap[ irstmap ].szGenericName );
		}
	OSMemoryHeapFree( rgrstmap );
	delete pffapi;
	return err;
	}


ERR ErrLGIPatchPage( PIB *ppib, PGNO pgno, IFMP ifmp, PATCH *ppatch )
	{
	ERR				err		= JET_errSuccess;
	BFLatch			bfl;
	IFileSystemAPI*	pfsapi	= PinstFromPpib( ppib )->m_pfsapi;
	CPAGE			cpage;

	Assert( NULL != rgfmp[ifmp].PfapiPatch() );

	//  write latch a new page to receive the patch page

	CallR( ErrBFWriteLatchPage( &bfl, ifmp, pgno, bflfNew ) );

	//  read the new page data in from the patch file

	QWORD ibOffset;
	ibOffset = OffsetOfPgno( ppatch->ipage + 1 );

	Call( rgfmp[ifmp].PfapiPatch()->ErrIORead( ibOffset, g_cbPage, (BYTE*)bfl.pv ) );
	cpage.LoadPage( bfl.pv );

	ULONG ulChecksumExpected;
	ULONG ulChecksumActual;
	ulChecksumExpected	= *( (LittleEndian<DWORD>*)bfl.pv );
	ulChecksumActual	= UlUtilChecksum( (BYTE*)bfl.pv, g_cbPage );
	
	if ( ulChecksumExpected != ulChecksumActual || pgno != cpage.Pgno() )
		{
		const _TCHAR*	rgpsz[ 6 ];
		DWORD			irgpsz		= 0;
		_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szOffset[ 64 ];
		_TCHAR			szLength[ 64 ];
		_TCHAR			szError[ 64 ];

		CallS( rgfmp[ifmp].PfapiPatch()->ErrPath( szAbsPath ) );
		_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset, ibOffset );
		_stprintf( szLength, _T( "%u (0x%08x)" ), g_cbPage, g_cbPage );
		_stprintf( szError, _T( "%i (0x%08x)" ), JET_errReadVerifyFailure, JET_errReadVerifyFailure );

		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szOffset;
		rgpsz[ irgpsz++ ]	= szLength;
		rgpsz[ irgpsz++ ]	= szError;

		if ( pgno != cpage.Pgno() )
			{
			char	szPgnoExpected[ 64 ];
			char	szPgnoActual[ 64 ];

			sprintf( szPgnoExpected, "%u (0x%08x)", pgno, pgno );
			sprintf( szPgnoActual, "%u (0x%08x)", cpage.Pgno(), cpage.Pgno() );
	
			rgpsz[ irgpsz++ ]	= szPgnoExpected;
			rgpsz[ irgpsz++ ]	= szPgnoActual;

			UtilReportEvent(	eventError,
								LOGGING_RECOVERY_CATEGORY,
								PATCH_PAGE_NUMBER_MISMATCH_ID,
								irgpsz,
								rgpsz,
								0,
								NULL,
								PinstFromPpib( ppib ) );
			}
		else
			{
			char	szChecksumExpected[ 64 ];
			char	szChecksumActual[ 64 ];

			sprintf( szChecksumExpected, "%u (0x%08x)", ulChecksumExpected, ulChecksumExpected );
			sprintf( szChecksumActual, "%u (0x%08x)", ulChecksumActual, ulChecksumActual );
	
			rgpsz[ irgpsz++ ]	= szChecksumExpected;
			rgpsz[ irgpsz++ ]	= szChecksumActual;

			UtilReportEvent(	eventError,
								LOGGING_RECOVERY_CATEGORY,
								PATCH_PAGE_CHECKSUM_MISMATCH_ID,
								irgpsz,
								rgpsz,
								0,
								NULL,
								PinstFromPpib( ppib ) );
			}

		Call( ErrERRCheck( JET_errReadVerifyFailure ) );
		}
	BFDirty( &bfl );

HandleError:
	cpage.UnloadPage();
	BFWriteUnlatch( &bfl );
	return err;
	}


#ifdef ELIMINATE_PATCH_FILE
#else
VOID LOG::LGRSTPatchTerm()
	{
	INT	ippatchlst;

	if ( m_rgppatchlst == NULL )
		return;

	for ( ippatchlst = 0; ippatchlst < cppatchlstHash; ippatchlst++ )
		{
		PATCHLST	*ppatchlst = m_rgppatchlst[ippatchlst];

		while( ppatchlst != NULL )
			{
			PATCHLST	*ppatchlstNext = ppatchlst->ppatchlst;
			PATCH		*ppatch = ppatchlst->ppatch;

			while( ppatch != NULL )
				{
				PATCH *ppatchNext = ppatch->ppatch;

				OSMemoryHeapFree( ppatch );
				ppatch = ppatchNext;
				}

			OSMemoryHeapFree( ppatchlst );
			ppatchlst = ppatchlstNext;
			}
		}

	Assert( m_rgppatchlst != NULL );
	OSMemoryHeapFree( m_rgppatchlst );
	m_rgppatchlst = NULL;

	return;
	}
#endif	//	ELIMINATE_PATCH_FILE


#define cRestoreStatusPadding	0.10	// Padding to add to account for DB copy.

ERR LOG::ErrLGGetDestDatabaseName(
	IFileSystemAPI *const pfsapi,
	const CHAR *szDatabaseName,
	INT *pirstmap,
	LGSTATUSINFO *plgstat,
	const CHAR *szDatabaseNameIfSLV )
	{
	ERR		err;
	CHAR	szDirT[IFileSystemAPI::cchPathMax];
	CHAR	szFNameT[IFileSystemAPI::cchPathMax];
	CHAR	szExtT[IFileSystemAPI::cchPathMax];
	CHAR	szRestoreT[IFileSystemAPI::cchPathMax];
	CHAR	szT[IFileSystemAPI::cchPathMax];
	CHAR	*szNewDatabaseName;
	INT		irstmap;

	Assert( szDatabaseName );

	irstmap = IrstmapLGGetRstMapEntry( szDatabaseName, szDatabaseNameIfSLV );
	*pirstmap = irstmap;
	
	if ( irstmap < 0 )
		{
		return( ErrERRCheck( JET_errFileNotFound ) );
		}
#ifdef ELIMINATE_PATCH_FILE
	else if ( m_rgrstmap[irstmap].fDestDBReady )
		return JET_errSuccess;
#else
	else if ( m_rgrstmap[irstmap].fPatchSetup || m_rgrstmap[irstmap].fDestDBReady )
		return JET_errSuccess;
#endif

	/*	check if there is any database in the restore directory.
	 *	Make sure szFNameT is big enough to hold both name and extention.
	 */
	CallS( pfsapi->ErrPathParse( szDatabaseName, szDirT, szFNameT, szExtT ) );
	strcat( szFNameT, szExtT );

	/* make sure szRestoreT has enogh trailing space for the following function to use.
	 */
	strcpy( szRestoreT, m_szRestorePath );
	if ( ErrLGCheckDir( pfsapi, szRestoreT, szFNameT ) != JET_errBackupDirectoryNotEmpty )
		return( ErrERRCheck( JET_errFileNotFound ) );

	/*	goto next block, copy it back to working directory for recovery
	 */
	if ( m_fExternalRestore )
		{
		Assert( _stricmp( m_rgrstmap[irstmap].szDatabaseName, szDatabaseName ) == 0 );
		Assert( irstmap < m_irstmapMac );
		
		szNewDatabaseName = m_rgrstmap[irstmap].szNewDatabaseName;
		}
	else
		{
		CHAR		*szSrcDatabaseName;
		CHAR		szFullPathT[IFileSystemAPI::cchPathMax];

		/*	store source path in rstmap
		/**/
		if ( ( szSrcDatabaseName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( szDatabaseName ) + 1 ) ) ) == NULL )
			return ErrERRCheck( JET_errOutOfMemory );
		strcpy( szSrcDatabaseName, szDatabaseName );
		m_rgrstmap[irstmap].szDatabaseName = szSrcDatabaseName;

		/*	store restore path in rstmap
		/**/
		if ( m_szNewDestination[0] != '\0' )
			{
			if ( ( szNewDatabaseName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( m_szNewDestination ) + strlen( szFNameT ) + 1 ) ) ) == NULL )
				return ErrERRCheck( JET_errOutOfMemory );
			strcpy( szNewDatabaseName, m_szNewDestination );
			strcat( szNewDatabaseName, szFNameT );
			}
		else
			{
			if ( ( szNewDatabaseName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( szDatabaseName ) + 1 ) ) ) == NULL )
				return ErrERRCheck( JET_errOutOfMemory );
			strcpy( szNewDatabaseName, szDatabaseName );
			}
		m_rgrstmap[irstmap].szNewDatabaseName = szNewDatabaseName;

		/*	copy database if not external restore.
		 *	make database names and copy the database.
		 */
		CallS( pfsapi->ErrPathParse( szDatabaseName, szDirT, szFNameT, szExtT ) );
		strcpy( szT, m_szRestorePath );
		strcat( szT, szFNameT );

		if ( szExtT[0] != '\0' )
			{
			strcat( szT, szExtT );
			}

		CallR( ErrUtilPathExists( pfsapi, szT, szFullPathT ) );

		if ( _stricmp( szFullPathT, szNewDatabaseName ) != 0 )
			{
			CallR( pfsapi->ErrFileCopy( szT, szNewDatabaseName, fTrue ) );
 			}
			
#ifdef ELIMINATE_PATCH_FILE
		Assert( m_fSignLogSet );
		CallR( ErrLGCheckDBFiles( m_pinst, pfsapi, m_rgrstmap + irstmap, NULL, m_lGenLowRestore, m_lGenHighRestore ) );
#else
		LGIGetPatchName( m_pinst->m_pfsapi, szFullPathT, szNewDatabaseName, m_szRestorePath );
		Assert( m_fSignLogSet );
		CallR( ErrLGCheckDBFiles( m_pinst, pfsapi, m_rgrstmap + irstmap, szFullPathT, m_lGenLowRestore, m_lGenHighRestore ) );
#endif

		Assert( FLGRSTCheckDuplicateSignature( ) );		
		}

	/*	make patch name prepare to patch the database.
	/**/

#ifdef ELIMINATE_PATCH_FILE
#else
	CHAR	*sz;

	LGIGetPatchName( m_pinst->m_pfsapi, szT, szNewDatabaseName, m_szRestorePath );

	/*	store patch path in rstmap
	/**/
	if ( ( sz = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( szT ) + 1 ) ) ) == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	strcpy( sz, szT );
	m_rgrstmap[irstmap].szPatchPath = sz;
#endif

	m_rgrstmap[irstmap].fDestDBReady = fTrue;
	*pirstmap = irstmap;

	if ( plgstat != NULL )
		{
		JET_SNPROG	*psnprog = &plgstat->snprog;
		ULONG		cPercentSoFar;
		ULONG		cDBCopyEstimate;

		cDBCopyEstimate = max((ULONG)(plgstat->cGensExpected * cRestoreStatusPadding / m_irstmapMac), 1);
		plgstat->cGensExpected += cDBCopyEstimate;
		plgstat->cGensSoFar += cDBCopyEstimate;

		cPercentSoFar = (ULONG)( ( cDBCopyEstimate * 100 ) / plgstat->cGensExpected );
		Assert( cPercentSoFar > 0  &&  cPercentSoFar < 100 );
		Assert( cPercentSoFar <= ( cDBCopyEstimate * 100) / plgstat->cGensExpected );

		if ( cPercentSoFar > psnprog->cunitDone )
			{
			Assert( psnprog->cbStruct == sizeof(JET_SNPROG)  &&
					psnprog->cunitTotal == 100 );
			psnprog->cunitDone = cPercentSoFar;
			( *( plgstat->pfnStatus ) )( 0, JET_snpRestore, JET_sntProgress, psnprog );
			}
		}

	return JET_errSuccess;
	}


#ifdef ELIMINATE_PATCH_FILE
#else
/*	set new db path according to the passed rstmap
/**/
ERR LOG::ErrLGRSTPatchInit( VOID )
	{
	/*	set up a patch hash table and fill it up with the patch file
	/**/
	INT cbT = sizeof( PATCHLST * ) * cppatchlstHash;

	if ( ( m_rgppatchlst = (PATCHLST **) PvOSMemoryHeapAlloc( cbT ) ) == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	memset( m_rgppatchlst, 0, cbT );
	return JET_errSuccess;
	}
#endif


VOID LOG::LGIRSTPrepareCallback(
	IFileSystemAPI *const	pfsapi,
	LGSTATUSINFO				*plgstat,
	LONG						lgenHigh,
	LONG						lgenLow,
	JET_PFNSTATUS				pfn
	)
	{
	/*	get last generation in log dir directory.  Compare with last generation
	/*	in restore directory.  Take the higher.
	/**/
	if ( m_szLogFilePath && *m_szLogFilePath != '\0' )
		{
		LONG	lgenHighT;
		CHAR	szFNameT[IFileSystemAPI::cchPathMax];

		/*	check if it is needed to continue the log files in current
		/*	log working directory.
		/**/
		(void)ErrLGIGetGenerationRange( pfsapi, m_szLogFilePath, NULL, &lgenHighT );

		/*	check if edb.log exist, if it is, then add one more generation.
		/**/
		strcpy( szFNameT, m_szLogFilePath );
		strcat( szFNameT, m_szJetLog );
			
		if ( ErrUtilPathExists( pfsapi, szFNameT ) == JET_errSuccess )
			{
			lgenHighT++;
			}

		lgenHigh = max( lgenHigh, lgenHighT );

		Assert( lgenHigh >= m_pcheckpoint->checkpoint.le_lgposCheckpoint.le_lGeneration );
		}

	plgstat->cGensSoFar = 0;
	plgstat->cGensExpected = lgenHigh - lgenLow + 1;

	/*	If the number of generations is less than about 67%, then count sectors,
	/*	otherwise, just count generations.  We set the threshold at 67% because
	/*	this equates to about 1.5% per generation.  Any percentage higher than
	/*	this (meaning fewer generations) and we count sectors.  Any percentage
	/*	lower than this (meaning more generations) and we just count generations.
	/**/
	plgstat->fCountingSectors = (plgstat->cGensExpected <
			(ULONG)((100 - (cRestoreStatusPadding * 100)) * 2/3));

	/*	Granularity of status callback is 1%.
	/*	Assume we callback after every generation.  If there are 67
	/*	callbacks, this equates to 1.5% per generation.  This seems like a
	/*	good cutoff value.  So, if there are 67 callbacks or more, count
	/*	generations.  Otherwise, count bytes per generation.
	/**/
	plgstat->pfnStatus = pfn;
	plgstat->snprog.cbStruct = sizeof(JET_SNPROG);
	plgstat->snprog.cunitDone = 0;
	plgstat->snprog.cunitTotal = 100;

	(*(plgstat->pfnStatus))(0, JET_snpRestore, JET_sntBegin, &plgstat->snprog);
	}
		
ERR LOG::ErrLGRestore( IFileSystemAPI *const pfsapi, CHAR *szBackup, CHAR *szDest, JET_PFNSTATUS pfn )
	{
	ERR					err;
	CHAR				szBackupPath[IFileSystemAPI::cchPathMax];
	CHAR				szLogDirPath[cbFilenameMost + 1];
	BOOL				fLogDisabledSav;
	LONG				lgenLow;
	LONG				lgenHigh;
	LGSTATUSINFO		lgstat;
	LGSTATUSINFO		*plgstat = NULL;
	const CHAR			*rgszT[2];
	INT					irstmap;
	BOOL				fNewCheckpointFile;
	ULONG				cbSecVolumeSave;
	BOOL				fGlobalRepairSave = fGlobalRepair;

	Assert( !fGlobalRepair );

	if ( _stricmp( m_szRecovery, "repair" ) == 0 )
		{
		// If m_szRecovery is exactly "repair", then enable logging.  If anything
		// follows "repair", then disable logging.
		fGlobalRepair = fTrue;
		}

	strcpy( szBackupPath, szBackup );

	Assert( m_pinst->m_fSTInit == fSTInitDone || m_pinst->m_fSTInit == fSTInitNotDone );
	if ( m_pinst->m_fSTInit == fSTInitDone )
		{
		Error( ErrERRCheck( JET_errAfterInitialization ), ResetGlobalRepair );
		}

	if ( szDest )
		{
		if ( m_pinst->m_fCreatePathIfNotExist )
			{
			CHAR szT[IFileSystemAPI::cchPathMax];

			strcpy( szT, szDest );
			OSSTRAppendPathDelimiter( szT, fTrue );
			CallJ( ErrUtilCreatePathIfNotExist( pfsapi, szT, m_szNewDestination ), ResetGlobalRepair );
			}
		else
			{
			CallJ( pfsapi->ErrPathComplete( szDest, m_szNewDestination ), ResetGlobalRepair );
			OSSTRAppendPathDelimiter( m_szNewDestination, fTrue );
			}
		}
	else
		m_szNewDestination[0] = '\0';

	m_fSignLogSet = fFalse;

	//	disable the sector-size checks

//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//	---** TEMPORARY FIX **---
{
	CHAR rgchFullName[IFileSystemAPI::cchPathMax];
	if ( pfsapi->ErrPathComplete( m_szLogFilePath, rgchFullName ) == JET_errInvalidPath )
		{
		const CHAR	*szPathT[1] = { m_szLogFilePath };
		UtilReportEvent(
				eventError,
				LOGGING_RECOVERY_CATEGORY,
				FILE_NOT_FOUND_ERROR_ID,
				1,
				szPathT,
				0,
				NULL,
				m_pinst );
		CallJ( ErrERRCheck( JET_errFileNotFound ), ResetGlobalRepair );
		}

	CallJ( pfsapi->ErrFileAtomicWriteSize( rgchFullName, (DWORD*)&m_cbSecVolume ), ResetGlobalRepair );
}

	cbSecVolumeSave = m_cbSecVolume;
//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//	m_cbSecVolume = ~(ULONG)0;

	//	use the right log file size for restore

	Assert( m_pinst->m_fUseRecoveryLogFileSize == fFalse );
	m_pinst->m_fUseRecoveryLogFileSize = fTrue;

	CallJ( ErrLGRSTInitPath( pfsapi, szBackupPath, m_szLogFilePath, m_szRestorePath, szLogDirPath ), ReturnError );
	CallJ ( ErrLGIGetGenerationRange( pfsapi, m_szRestorePath, &lgenLow, &lgenHigh ), ReturnError );
	Assert( ( lgenLow > 0 && lgenHigh >= lgenLow ) || ( 0 == lgenLow && 0 == lgenHigh ) );

	if ( 0 == lgenLow || 0 == lgenHigh )
		{
	
		//	we didn't find anything in the given restore path
		//	check the szAtomicNew subdirectory (what is this???)

		OSSTRAppendPathDelimiter( szBackupPath, fTrue );
		err = ErrLGCheckDir( pfsapi, szBackupPath, (CHAR *)szAtomicNew );
		if ( err == JET_errBackupDirectoryNotEmpty )
			{
			strcat( szBackupPath, (CHAR *)szAtomicNew );
			CallJ( ErrLGRSTInitPath( pfsapi, szBackupPath, m_szLogFilePath, m_szRestorePath, szLogDirPath ), ReturnError );
			CallJ ( ErrLGIGetGenerationRange( pfsapi, m_szRestorePath, &lgenLow, &lgenHigh ), ReturnError );
			Assert( ( lgenLow > 0 && lgenHigh >= lgenLow ) || ( 0 == lgenLow && 0 == lgenHigh ) );
			}
		CallJ( err, ReturnError );
		}

	if ( 0 == lgenLow || 0 == lgenHigh )
		{

		//	we didn't find anything in the NEW restore path
		//	check the szAtomicOld subdirectory (what is this???)

		OSSTRAppendPathDelimiter( szBackupPath, fTrue );
		err = ErrLGCheckDir( pfsapi, szBackupPath, (CHAR *) szAtomicOld );
 		if ( err == JET_errBackupDirectoryNotEmpty )
			{
			strcat( szBackupPath, szAtomicOld );
			CallJ( ErrLGRSTInitPath( pfsapi, szBackupPath, m_szLogFilePath, m_szRestorePath, szLogDirPath ), ReturnError );
			CallJ ( ErrLGIGetGenerationRange( pfsapi, m_szRestorePath, &lgenLow, &lgenHigh ), ReturnError );
			Assert( ( lgenLow > 0 && lgenHigh >= lgenLow ) || ( 0 == lgenLow && 0 == lgenHigh ) );
			}
		CallJ( err, ReturnError );
		}

	if ( 0 == lgenLow || 0 == lgenHigh )
		{

		//	we didn't find any log file anywhere -- error out

		Error( ErrERRCheck( JET_errFileNotFound ), ReturnError );
		}

	Assert( lgenLow > 0 );
	Assert( lgenHigh >= lgenLow );
	CallJ( ErrLGRSTCheckSignaturesLogSequence( pfsapi, m_szRestorePath, szLogDirPath, lgenLow, lgenHigh, NULL, 0 ), ReturnError );

	Assert( strlen( m_szRestorePath ) < sizeof( m_szRestorePath ) - 1 );
	Assert( strlen( szLogDirPath ) < sizeof( szLogDirPath ) - 1 );
	Assert( m_szLogCurrent == m_szRestorePath );

//	CallR( FMP::ErrFMPInit() );

	fLogDisabledSav = m_fLogDisabled;
	m_fHardRestore = fTrue;
	m_fRestoreMode = fRestorePatch;
	m_fLogDisabled = fFalse;
	m_fAbruptEnd = fFalse;

	/*  initialize log manager and set working log file path
	/**/
	CallJ( ErrLGInit( pfsapi, &fNewCheckpointFile ), TermFMP );

	rgszT[0] = m_szRestorePath;
	rgszT[1] = szLogDirPath;
	UtilReportEvent(
			eventInformation,
			LOGGING_RECOVERY_CATEGORY,
			START_RESTORE_ID,
			2,
			rgszT,
			0,
			NULL,
			m_pinst );

	/*	all saved log generation files, database backups
	/*	must be in m_szRestorePath.
	/**/
	Call( ErrLGRSTSetupCheckpoint( pfsapi, lgenLow, lgenHigh, NULL ) );
		
	m_lGenLowRestore = lgenLow;
	m_lGenHighRestore = lgenHigh;

	/*	prepare for callbacks
	/**/
	if ( pfn != NULL )
		{
		plgstat = &lgstat;
		LGIRSTPrepareCallback( pfsapi, plgstat, lgenHigh, lgenLow, pfn );
		}
	Assert( m_szLogCurrent == m_szRestorePath );

	Call( ErrLGRSTBuildRstmapForRestore( ) );

	/*	make sure all the patch files have enough logs to replay
	/**/
	for ( irstmap = 0; irstmap < m_irstmapMac; irstmap++ )
		{
		/*	Open patch file and check its minimum requirement for full backup.
		 */
		CHAR *szNewDatabaseName = m_rgrstmap[irstmap].szNewDatabaseName;

		if ( !szNewDatabaseName )
			continue;
			
#ifdef ELIMINATE_PATCH_FILE
		Assert( m_fSignLogSet );
		err = ErrLGCheckDBFiles( m_pinst, pfsapi, m_rgrstmap + irstmap, NULL, lgenLow, lgenHigh );
#else
		CHAR	szRestPath[ IFileSystemAPI::cchPathMax ];
		LGIGetPatchName( m_pinst->m_pfsapi, szRestPath, szNewDatabaseName, m_szRestorePath );
		
		Assert( m_fSignLogSet );
		err = ErrLGCheckDBFiles( m_pinst, pfsapi, m_rgrstmap + irstmap, szRestPath, lgenLow, lgenHigh );
#endif

		// we don't check streaming file header during backup
		// UNDONE: maybe it is possible to check this, now that there are supposed to be in sync
		if ( wrnSLVDatabaseHeader == err )
			{
			err = JET_errSuccess;
			continue;
			}
			
		Call( err );
		}

	// check that there are no databases with same signature
	Assert ( FLGRSTCheckDuplicateSignature( ) );

	/*	adjust fmp according to the restore map.
	/**/
	Assert( m_fExternalRestore == fFalse );

#ifdef ELIMINATE_PATCH_FILE
#else
	Call( ErrLGRSTPatchInit( ) );
#endif

	/*	do redo according to the checkpoint, dbms_params, and rgbAttach
	/*	set in checkpointGlobal.
	/**/
	Assert( m_szLogCurrent == m_szRestorePath );
	m_errGlobalRedoError = JET_errSuccess;
	Call( ErrLGRRedo( pfsapi, m_pcheckpoint, plgstat ) );

	//	we should be using the right log file size now
	
	Assert( m_pinst->m_fUseRecoveryLogFileSize == fFalse );

	//	sector-size checking should now be on

	Assert( m_cbSecVolume != ~(ULONG)0 );
	Assert( m_cbSecVolume == m_cbSec );

	//	update saved copy
	
	cbSecVolumeSave = m_cbSecVolume;

	if ( plgstat )
		{
		lgstat.snprog.cunitDone = lgstat.snprog.cunitTotal;		//lint !e644
		(*lgstat.pfnStatus)( 0, JET_snpRestore, JET_sntComplete, &lgstat.snprog );
		}

HandleError:

#ifdef ELIMINATE_PATCH_FILE
#else
		//  UNDONE: if the DetachDb was redone during recover (the soft recover part)
		// we don't have the dbid in m_mpdbidifmp and we don't delete the patch
		// file for it. TODO: delete the patch file in ResetFMP
		// anyway, DELETE_PATCH_FILES is dot define so we don't delete those patch files
		// at this level but only in ESEBACK2, on restore without error
		{
		/*	delete .pat files
		/**/
		for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			IFMP ifmp = m_pinst->m_mpdbidifmp[ dbid ];
			if ( ifmp >= ifmpMax )
				continue;
			
			FMP *pfmpT = &rgfmp[ifmp];

			if ( pfmpT->SzPatchPath() )
				{
				delete pfmpT->PfapiPatch();
				pfmpT->SetPfapiPatch( NULL );
#ifdef DELETE_PATCH_FILES
				CallSx( m_pinst->m_pfsapi->ErrFileDelete( pfmpT->SzPatchPath() ), JET_errFileNotFound );
#endif
				OSMemoryHeapFree( pfmpT->SzPatchPath() );
				pfmpT->SetSzPatchPath( NULL );
				}
			}
		}

	/*	delete the patch hash table
	/**/
	LGRSTPatchTerm();

#endif	//	ELIMINATE_PATCH_FILE

	/*	delete restore map
	/**/

	CallSx( m_pinst->m_pfsapi->ErrFileDelete( (CHAR *)szRestoreMap ), JET_errFileNotFound );

	LGRSTFreeRstmap( );

	if ( err < 0  &&  m_pinst->m_fSTInit != fSTInitNotDone )
		{
		Assert( m_pinst->m_fSTInit == fSTInitDone );
		CallS( m_pinst->ErrINSTTerm( termtypeError ) );
		}

//	CallS( ErrLGTerm( pfsapi, err >= JET_errSuccess ) );
	CallS( ErrLGTerm( pfsapi, fFalse ) );

TermFMP:	
//	FMP::Term( );

	m_fHardRestore = fFalse;
	Assert ( fSnapshotNone == m_fSnapshotMode || fSnapshotAfter == m_fSnapshotMode );
	m_fSnapshotMode = fSnapshotNone;
	m_lgposSnapshotStart = lgposMin;
	
	Assert( fRestorePatch == m_fRestoreMode || fRestoreRedo == m_fRestoreMode );
	m_fRestoreMode = fRecoveringNone;

	/*	reset initialization state
	/**/
	m_pinst->m_fSTInit = err >= JET_errSuccess ? fSTInitNotDone : fSTInitFailed;

	if ( err != JET_errSuccess && !FErrIsLogCorruption( err ) )
		{
		UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, RESTORE_DATABASE_FAIL_ID, err, m_pinst );
		}
	else
		{
		if ( fGlobalRepair && m_errGlobalRedoError != JET_errSuccess )
			err = ErrERRCheck( JET_errRecoveredWithErrors );
		}
	UtilReportEvent(
			eventInformation,
			LOGGING_RECOVERY_CATEGORY,
			STOP_RESTORE_ID,
			0,
			NULL,
			0,
			NULL,
			m_pinst );

	m_fSignLogSet = fFalse;

	m_fLogDisabled = fLogDisabledSav;

ReturnError:
	m_cbSecVolume = cbSecVolumeSave;
	m_pinst->m_fUseRecoveryLogFileSize = fFalse;

ResetGlobalRepair:
	fGlobalRepair = fGlobalRepairSave;
	return err;
	}

ERR ISAMAPI ErrIsamRestore( JET_INSTANCE jinst, CHAR *szBackup, CHAR *szDest, JET_PFNSTATUS pfn )
	{
	ERR			err;
	DBMS_PARAM	dbms_param;
//	LGBF_PARAM	lgbf_param;
	INST		*pinst = (INST *)jinst;
	
	//	Save the configuration
	
	pinst->SaveDBMSParams( &dbms_param );
//	LGSaveBFParams( &lgbf_param );
	
	err = pinst->m_plog->ErrLGRestore( pinst->m_pfsapi, szBackup, szDest, pfn );
	
	pinst->RestoreDBMSParams( &dbms_param );
//	LGRestoreBFParams( &lgbf_param );

	//	Uninitialize the global variables, if not released yet.
	
	Assert( pinst );
	
	return err;
	}


#ifdef DEBUG
VOID DBGBRTrace( CHAR *sz )
	{
	DBGprintf( "%s", sz );
	}
#endif


#ifdef ELIMINATE_PATCH_FILE
#else

//	build in-memory structure for restore to use. The structure
//	is to keep track of the patch pages in the patch file and can
//	be quickly searched when needed during restore.

ERR LOG::ErrLGPatchDatabase(
	IFileSystemAPI *const pfsapi,
	IFMP ifmp,
	DBID dbid )
	{
	ERR				err = JET_errSuccess;
	IFileAPI		*pfapiDatabase = NULL;
	IFileAPI		*pfapiPatch = NULL;
	PGNO			pgnoT;
	BYTE			*pbPageCache = NULL;
	PGNO			pgnoMost;
	INT				ipage;
	CPAGE			cpage;

	CHAR			*szDatabase = rgfmp[ifmp].SzDatabaseName();
	Assert ( szDatabase );
	
	const INT 		irstmap = IrstmapSearchNewName( szDatabase ) ;
	Assert ( 0 <= irstmap );
	
	CHAR			*szPatch = m_rgrstmap[irstmap].szPatchPath;


	// on snapshot restore, we don't have a patch file
	if ( fSnapshotNone != m_fSnapshotMode )
		{
		return JET_errSuccess;
		}
		
	//	open the patch file

	Assert( NULL != szPatch );
	err = m_pinst->m_pfsapi->ErrFileOpen( szPatch, &pfapiPatch, fTrue );
	if ( JET_errFileNotFound == err )
		{
		//	patch file should always exist
		err = ErrERRCheck( JET_errPatchFileMissing );
		}
	CallR( err );

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];

		sprintf( sz, "     Apply patch file %s\n", szPatch );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif

	QWORD cbPatchFile;
	// just opened the file, so the file size must be correctly buffered
	Call( pfapiPatch->ErrSize( &cbPatchFile ) );

	QWORD ibPatchFile;
	ibPatchFile = QWORD( cpgDBReserved ) * g_cbPage;

#ifdef ELIMINATE_PAGE_PATCHING
	if ( ibPatchFile != cbPatchFile )
		{
		//	should be impossible
		EnforceSz( fFalse, "Patching no longer supported." );
		Call( ErrERRCheck( JET_errBadPatchPage ) );
		}
#endif

	//	allocate a page

	pbPageCache = (BYTE *)PvOSMemoryPageAlloc( g_cbPage*cpageBackupBufferMost, NULL );
	if ( pbPageCache == NULL )
		Call( ErrERRCheck( JET_errOutOfMemory ) );

	//	Cache first run of pages
	QWORD ibCacheEnd;
	ibCacheEnd = min( g_cbPage*cpageBackupBufferMost, cbPatchFile );
	Assert( ibCacheEnd >= 0 );
	Call( ErrLGReadPages( pfapiPatch, pbPageCache + ibPatchFile, PgnoOfOffset( ibPatchFile ), PgnoOfOffset( ibCacheEnd ) - 1, fFalse ) );
		
	//	open database file

	Call( pfsapi->ErrFileOpen( szDatabase, &pfapiDatabase ) );

	//	find out database size.

	QWORD cbDatabaseFile;
	Call( pfapiDatabase->ErrSize( &cbDatabaseFile ) );
	if ( cbDatabaseFile == 0 || cbDatabaseFile % g_cbPage != 0 )
		{
		const UINT	csz = 1;
		const CHAR *rgszT[csz];
		
		rgszT[0] = szDatabase;
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
			BAD_BACKUP_DATABASE_SIZE, csz, rgszT, 0, NULL, m_pinst );
		Call( ErrERRCheck( JET_errBadBackupDatabaseSize ) );
		}

	// Subtract cpgDBReserved to compensate for adding it on in ErrIsamOpenFile().

	pgnoMost = (ULONG)( cbDatabaseFile / g_cbPage ) - cpgDBReserved;

	//	read each patch file page and write it to
	//	database file according to page number.

	ipage = -1;
	while ( ibPatchFile < cbPatchFile )
		{
		PATCHLST **pppatchlst;
		PATCH	**pppatch;
		PATCH	*ppatch;

		if ( ibPatchFile == ibCacheEnd )
			{
			Assert( cbPatchFile > ibCacheEnd );
			Assert( 0 == (ibCacheEnd % cpageBackupBufferMost*g_cbPage) );
			ibCacheEnd += cpageBackupBufferMost*g_cbPage;
			if ( ibCacheEnd > cbPatchFile )
				{
				ibCacheEnd = cbPatchFile;
				}
			Call( ErrLGReadPages( pfapiPatch, pbPageCache, PgnoOfOffset( ibPatchFile ), PgnoOfOffset( ibCacheEnd ) - 1, fFalse ) );
			}
		else
			{
			Assert( ibPatchFile < ibCacheEnd );
			}

		cpage.LoadPage( pbPageCache + ( ibPatchFile % ( g_cbPage * cpageBackupBufferMost ) ) );

		ibPatchFile += g_cbPage;
		ipage++;

		pgnoT = cpage.Pgno();

		//	If the patched page is greater than the backup database
		//	size, then we need to grow the database size at least
		//	the patched db size.

		if ( pgnoT > pgnoMost )
			{
			//	pgnoT + 1 to get to the end of page

			cbDatabaseFile = OffsetOfPgno( pgnoT + 1 );
			
			//	need to grow the database size
			Assert( PinstFromIfmp( ifmp )->FRecovering() );
			Call( pfapiDatabase->ErrSetSize( cbDatabaseFile ) );

			//	set new database size

			pgnoMost = pgnoT;
			}
		
		pppatchlst = &m_rgppatchlst[ IppatchlstHash( pgnoT, dbid ) ];

		//	Find the corresponding hash entry for patch list. If not found
		//	allocate an entry and put into the hash table.

		while ( *pppatchlst != NULL &&
				( (*pppatchlst)->pgno != pgnoT ||
				  (*pppatchlst)->dbid != dbid ) )
			pppatchlst = &(*pppatchlst)->ppatchlst;

		if ( *pppatchlst == NULL )
			{
			//	Not found, allocate an entry.

			PATCHLST *ppatchlst;
			
			if ( ( ppatchlst = static_cast<PATCHLST *>( PvOSMemoryHeapAlloc( sizeof( PATCHLST ) ) ) ) == NULL )
				Call( ErrERRCheck( JET_errOutOfMemory ) );
			ppatchlst->ppatch = NULL;
			ppatchlst->dbid = dbid;
			ppatchlst->pgno	= pgnoT;
			ppatchlst->ppatchlst = *pppatchlst;
			*pppatchlst = ppatchlst;
			}

		//	For the given patch list, put the patch into the list in time order.

		pppatch = &(*pppatchlst)->ppatch;
		while ( *pppatch != NULL && (*pppatch)->dbtime < cpage.Dbtime() )
			pppatch = &(*pppatch)->ppatch;

		if ( ( ppatch = static_cast<PATCH *>( PvOSMemoryHeapAlloc( sizeof( PATCH ) ) ) ) == NULL )
			Call( ErrERRCheck( JET_errOutOfMemory ) );

		ppatch->dbtime = cpage.Dbtime();
		ppatch->ipage = ipage;

		//	Hook it up to the patch list

		ppatch->ppatch = *pppatch;
		*pppatch = ppatch;

		cpage.UnloadPage();
		}
	Assert( err == JET_errSuccess );

	//	Store the patch file name

	{
	CHAR *szT = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( szPatch ) + 1 ) );
	if ( szT == NULL )
		Call( ErrERRCheck( JET_errOutOfMemory ) );
	strcpy( szT, szPatch );
	if ( rgfmp[ifmp].SzPatchPath() != NULL )
		OSMemoryHeapFree( rgfmp[ifmp].SzPatchPath() );
	rgfmp[ifmp].SetSzPatchPath( szT );
	rgfmp[ifmp].SetPfapiPatch( pfapiPatch );
	}

	m_rgrstmap[irstmap].fPatchSetup = fTrue;

HandleError:

	if ( pbPageCache )
		{
		cpage.UnloadPage();
		OSMemoryPageFree( pbPageCache );
		}
	
	//	close database file

	delete pfapiDatabase;

	//	close patch file

	if ( err < JET_errSuccess )
		{
		delete pfapiPatch;
		}

	return err;
	}

#endif	//	ELIMINATE_PATCH_FILE

	
/***********************************************************
/********************* EXTERNAL BACKUP *********************/

ERR ISAMAPI ErrIsamBeginExternalBackup( JET_INSTANCE jinst, JET_GRBIT grbit )
	{
	INST *pinst = (INST *)jinst;
	return pinst->m_plog->ErrLGBKBeginExternalBackup( pinst->m_pfsapi, grbit );
	}
	
ERR LOG::ErrLGBKBeginExternalBackup( IFileSystemAPI *const pfsapi, JET_GRBIT grbit )
	{
	ERR			err = JET_errSuccess;
	CHECKPOINT	*pcheckpointT = NULL;
	CHAR 	  	szPathJetChkLog[IFileSystemAPI::cchPathMax];

	const BOOL	fFullBackup = ( 0 == grbit );
	const BOOL	fIncrementalBackup = ( JET_bitBackupIncremental == grbit );
	const BOOL	fSnapshotBackup = ( JET_bitBackupSnapshot == grbit );

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		DBGBRTrace("** Begin BeginExternalBackup - ");
#endif

	if ( m_fLogDisabled )
		{
		return ErrERRCheck( JET_errLoggingDisabled );
		}

	if ( m_fRecovering || m_fLGNoMoreLogWrite )
		{
		Assert( fFalse );
		return ErrERRCheck( JET_errLogWriteFail );
		}

	/*	grbit may be 0 or JET_bitBackupIncremental or JET_bitBackupSnapshot
	/**/
	if ( ! ( ( grbit == JET_bitBackupIncremental ) || ( grbit == JET_bitBackupSnapshot ) || ( 0 == grbit ) ) )
		{
		return ErrERRCheck( JET_errInvalidGrbit );
		}

	Assert ( 0 == grbit || JET_bitBackupIncremental == grbit || JET_bitBackupSnapshot == grbit );

	Assert( m_ppibBackup != ppibNil );

	if ( fIncrementalBackup && m_fLGCircularLogging )
		{
		return ErrERRCheck( JET_errInvalidBackup );
		}

	m_critBackupInProgress.Enter();
	
	if ( m_fBackupInProgress )
		{
		m_critBackupInProgress.Leave();
		return ErrERRCheck( JET_errBackupInProgress );
		}
	
	//	flush the cache so that we will have less pages to patch.

	for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid ++ )
		{
		if ( m_pinst->m_mpdbidifmp[ dbid ] < ifmpMax )
			{
			CallJ( ErrBFFlush( m_pinst->m_mpdbidifmp[ dbid ], fFalse ), LeaveBackupInProgress );
			CallJ( ErrBFFlush( m_pinst->m_mpdbidifmp[ dbid ] | ifmpSLV, fFalse ), LeaveBackupInProgress );
			}
		}

	Assert ( backupStateNotStarted == m_fBackupStatus);

	m_lgenCopyMic = 0;
	m_lgenCopyMac = 0;
	m_lgenDeleteMic = 0;
	m_lgenDeleteMac = 0;

	m_fStopBackup = fFalse;
	m_fBackupInProgress = fTrue;
	m_critBackupInProgress.Leave();

	while ( m_pinst->CNonLoggedIndexCreators() > 0 )
		{
		//	wait for non-logged index creators
		//	to begin logging again
		//
		UtilSleep( cmsecWaitGeneric );
		}

	if ( fIncrementalBackup )
		{
		m_fBackupStatus = backupStateLogsAndPatchs;
		}
	else
		{
		Assert ( fFullBackup || fSnapshotBackup );
		m_fBackupStatus = backupStateDatabases;
		}
	
	//	make sure no detach/attach going. If there are, let them continue and finish.

CheckDbs:
	BOOL fDetachAttach;

	fDetachAttach = fFalse;
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP ifmp = m_pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;
		if ( ( fDetachAttach = rgfmp[ifmp].CrefWriteLatch() != 0 ) != fFalse )
			break;
		}

	if ( fDetachAttach )
		{
		UtilSleep( cmsecWaitGeneric );
		goto CheckDbs;
		}

	// FULL: clean the "involved" in backup flag for all databases in a full backup. We mark the
	// databases as involved in the backup process during JetOpenFile for the database file
	// INCREMENTAL: set the "involved" in backup flag for all databases in a incremental backup
	// because in this case the database file is not used and, in fact, all the daatbases are
	// contained in the log files.
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP ifmp = m_pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;

		// on Incremental, all the databases are part of the backup
		// on Full, we mark the Db as part of the backup only on JetOpenFile on it
		// on Snapshot we mark the Db as part of the backup on SnapshotStart
		if ( fIncrementalBackup )
			{
			rgfmp[ifmp].SetInBackupSession();
			}
		else
			{
			rgfmp[ifmp].ResetInBackupSession();
			}
		}

	if ( fIncrementalBackup )
		{

//	UNDONE: need to do tight checking to make sure there was a full backup before and
//	UNDONE: the logs after that full backup are still available.
		//	The UNDONE it is not done by ErrLGCheckLogsForIncrementalBackup later on.
	
		Call( ErrLGCheckIncrementalBackup( m_pinst ) )
		}
	else
		{
		Assert ( fFullBackup || fSnapshotBackup ) ;
		m_critLGBuf.Enter();
		m_lgposFullBackupMark = m_lgposLogRec;
		m_critLGBuf.Leave();
		LGIGetDateTime( &m_logtimeFullBackupMark );
		}
	
	Assert( m_ppibBackup != ppibNil );

	//	reset global copy/delete generation variables

	m_fBackupBeginNewLogFile = fFalse;

	/*	if incremental backup set copy/delete mic and mac variables,
	/*	else backup is full and set copy/delete mic and delete mac.
	/*	Copy mac will be computed after database copy is complete.
	/**/
	if ( fIncrementalBackup )
		{
#ifdef DEBUG
		if ( m_fDBGTraceBR )
			DBGBRTrace( "Incremental Backup.\n" );
#endif
		UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY,
				START_INCREMENTAL_BACKUP_INSTANCE_ID, 0, NULL, 0, NULL, m_pinst );
		m_fBackupFull = fFalse;
		m_fBackupSnapshot = fFalse;

		/*	if all database are allowed to do incremental backup? Check bkinfo prev.
		 */
		}
	else
		{
		Assert ( fFullBackup || fSnapshotBackup ) ;
#ifdef DEBUG
		if ( m_fDBGTraceBR )
			DBGBRTrace( fFullBackup?"Full Backup.\n":"Snapshot Backup.\n");
#endif
		UtilReportEvent(
			eventInformation,
			LOGGING_RECOVERY_CATEGORY,
			fFullBackup?START_FULL_BACKUP_INSTANCE_ID:START_SNAPSHOT_BACKUP_INSTANCE_ID,
			0,
			NULL,
			0,
			NULL,
			m_pinst );
		m_fBackupFull = fFullBackup;
		m_fBackupSnapshot = fSnapshotBackup;

		Assert ( m_fBackupSnapshot ^ m_fBackupFull );
		
		pcheckpointT = (CHECKPOINT *) PvOSMemoryPageAlloc( sizeof(CHECKPOINT), NULL );
		if ( pcheckpointT == NULL )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		LGFullNameCheckpoint( pfsapi, szPathJetChkLog );

		// This call should only return an error on hardware failure.
		err = ErrLGReadCheckpoint( pfsapi, szPathJetChkLog, pcheckpointT, fFalse );
		Assert( JET_errSuccess == err
			|| JET_errCheckpointCorrupt == err
			|| JET_errCheckpointFileNotFound == err );
		Call( err );

		m_lgenCopyMic = pcheckpointT->checkpoint.le_lgposCheckpoint.le_lGeneration;
		Assert( m_lgenCopyMic != 0 );
		}

	{
	const int cbFillBuffer = 128;
	char szTrace[cbFillBuffer + 1];
	szTrace[ cbFillBuffer ] = '\0';
	_snprintf( szTrace, cbFillBuffer, "EXT BACKUP START (chk 0x%05X, grbit %d)", m_lgenCopyMic, grbit );
	(void) ErrLGTrace( m_ppibBackup, szTrace);
	}

	// we need to log the operation here for snapshot as we need the
	// log position during db snapshot (to mark the db header)
	if ( m_fBackupSnapshot )
		{
		LGPOS lgposRecT;
		CallR( ErrLGSnapshotStartBackup( this, &lgposRecT ) );
		m_lgposSnapshotStart = lgposRecT;
		}
		
HandleError:
	if ( pcheckpointT != NULL )
		{
		OSMemoryPageFree( pcheckpointT );
		}

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];

		sprintf( sz, "   End BeginExternalBackup (%d).\n", err );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif

	if ( err < 0 )
		{
		m_fBackupInProgress = fFalse;
		m_fStopBackup = fFalse;
		m_fBackupStatus = backupStateNotStarted;
		}

	return err;

LeaveBackupInProgress:

	m_critBackupInProgress.Leave();
	return err;
	}


ERR ISAMAPI ErrIsamGetAttachInfo( JET_INSTANCE jinst, VOID *pv, ULONG cbMax, ULONG *pcbActual )
	{
	INST * pinst = (INST *)jinst;
	return pinst->m_plog->ErrLGBKGetAttachInfo( pinst->m_pfsapi, pv, cbMax, pcbActual );
	}

ERR LOG::ErrLGBKGetAttachInfo( IFileSystemAPI *const pfsapi, VOID *pv, ULONG cbMax, ULONG *pcbActual )
	{
	ERR		err = JET_errSuccess;
	DBID	dbid;
	ULONG	cbActual;
	CHAR	*pch = NULL;
	CHAR	*pchT;

	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}
	else if ( m_fStopBackup )
		{
		return ErrERRCheck( JET_errBackupAbortByServer );
		}

	// no snapshot backup using the old backup API
	Assert ( !m_fBackupSnapshot );
	
	/*	should not get attach info if not performing full backup
	/**/
	if ( !m_fBackupFull )
		{
		return ErrERRCheck( JET_errInvalidBackupSequence );
		}

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		DBGBRTrace( "** Begin GetAttachInfo.\n" );
#endif

	/*	compute cbActual, for each database name with NULL terminator
	/*	and with terminator of super string.
	/**/
	cbActual = 0;
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP 	ifmp = m_pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;

		FMP		*pfmp = &rgfmp[ifmp];
		if ( pfmp->FInUse()
			&& pfmp->FLogOn()
			&& pfmp->FAttached() )
			{
			Assert( !pfmp->FSkippedAttach() );
			Assert( !pfmp->FDeferredAttach() );

			cbActual += (ULONG) strlen( pfmp->SzDatabaseName() ) + 1;
			if ( pfmp->FSLVAttached() )
				{
				Assert ( pfmp->SzSLVName() );
				Assert ( strlen ( pfmp->SzSLVName() ) != 1 );
				cbActual += (ULONG) strlen( pfmp->SzSLVName() ) + 1;				
				}
			}
		}
	cbActual += 1;

	pch = static_cast<CHAR *>( PvOSMemoryHeapAlloc( cbActual ) );
	if ( pch == NULL )
		{
		Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
		}

	pchT = pch;
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP 	ifmp = m_pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;

		FMP		*pfmp = &rgfmp[ifmp];

		if ( pfmp->FInUse()
			&& pfmp->FLogOn()
			&& pfmp->FAttached() )
			{
			Assert( !pfmp->FSkippedAttach() );
			Assert( !pfmp->FDeferredAttach() );

			Assert( pchT + strlen( pfmp->SzDatabaseName() ) + 1 < pchT + cbActual );
			strcpy( pchT, pfmp->SzDatabaseName() );
			pchT += strlen( pfmp->SzDatabaseName() );
			Assert( *pchT == 0 );
			pchT++;
			if ( pfmp->FSLVAttached() )
				{
				Assert ( pfmp->SzSLVName() );
				Assert ( strlen ( pfmp->SzSLVName() ) != 1 );
				
				CHAR	* szSLVPath = pfmp->SzSLVName();
				
				Assert( pchT + strlen( szSLVPath ) + 1 < pchT + cbActual );
				strcpy( pchT, szSLVPath );
				pchT += strlen( szSLVPath );
				Assert( *pchT == 0 );
				pchT++;
				}
			}
		}
	Assert( pchT == pch + cbActual - 1 );
	*pchT = 0;

	/*	return cbActual
	/**/
	if ( pcbActual != NULL )
		{
		*pcbActual = cbActual;
		}

	/*	return data
	/**/
	if ( pv != NULL )
		UtilMemCpy( pv, pch, min( cbMax, cbActual ) );

HandleError:
	/*	free buffer
	/**/
	if ( pch != NULL )
		{
		OSMemoryHeapFree( pch );
		pch = NULL;
		}

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];
		CHAR *pch;

		if ( err >= 0 )
			{
			sprintf( sz, "   Attach Info with cbActual = %d and cbMax = %d :\n", cbActual, cbMax );
			Assert( strlen( sz ) <= sizeof( sz ) - 1 );
			DBGBRTrace( sz );

			if ( pv != NULL )
				{
				pch = static_cast<CHAR *>( pv );

				do {
					if ( strlen( pch ) != 0 )
						{
						sprintf( sz, "     %s\n", pch );
						Assert( strlen( sz ) <= sizeof( sz ) - 1 );
						DBGBRTrace( sz );
						pch += strlen( pch );
						}
					pch++;
					} while ( *pch );
				}
			}

		sprintf( sz, "   End GetAttachInfo (%d).\n", err );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif
		
	if ( err < 0 )
		{
		CallS( ErrLGBKIExternalBackupCleanUp( pfsapi, err ) );
		Assert( !m_fBackupInProgress );
		}

	return err;
	}


// ********************** LOG CHECKSUM VERIFICATION ********************* //

class LOGVERIFIER;  //  TODO:  rewrite this class.  this is some of the worst C++ I've ever seen

// ======================= Abstract class to describe a state of verifying the log

class VERIFYSTATE
	{
public:
	virtual ERR ErrVerify( LOGVERIFIER* pLogVerifier, const BYTE* pb, ULONG cb ) = 0;
protected:
	VOID ChangeState( LOGVERIFIER* pLogVerifier, VERIFYSTATE* pVerifyState );
	VOID SetCompleted( LOGVERIFIER* pLogVerifier );
	};

// ======================== Verify a log file header =====================

class VERIFYHEADER : public VERIFYSTATE
	{
public:
	virtual ERR ErrVerify( LOGVERIFIER* pLogVerifier, const BYTE* pb, ULONG cb );
	};

// ======================== Verify runs of LRCHECKSUM regions =================

class VERIFYCHECKSUM : public VERIFYSTATE
	{
public:
	VERIFYCHECKSUM( ULONG ibLRCK, ULONG32 lGeneration );
	virtual ERR ErrVerify( LOGVERIFIER* pLogVerifier, const BYTE* pb, ULONG cb );
	ERR ErrVerifyLRCKStart( LOGVERIFIER* pLogVerifier, const BYTE* pb, ULONG cb );
	ERR ErrVerifyLRCKContinue( LOGVERIFIER* pLogVerifier, const BYTE* pb, ULONG cb );
	ERR ErrCheckLRCKEnd( LOGVERIFIER* pLogVerifier );

private:
	enum STATE
		{
		state_Start,
		state_Continue
		};

	ULONG						m_cbSeen;	// index of byte after last byte we've been passed in ErrVerify
	ULONG						m_ibLRCK;	// index of m_lrck
	ULONG						m_ibChecksumIncremental;	// index of byte after last byte checksummed
	LOG::CHECKSUMINCREMENTAL	m_ck;		// state of incremental checksumming into next block
	LRCHECKSUM					m_lrck;		// copy of current LRCHECKSUM we're verifying
	STATE						m_state;	// need to continue checksumming bytes in next block?
	ULONG32						m_lGeneration;	// gen # of log file
	};

// ===================== Log verification interface ===========================

class LOGVERIFIER
	{
public:
	LOGVERIFIER( IFileAPI* const pfapi, ERR* const pErr );
	~LOGVERIFIER();
	
	ERR	ErrVerify( const BYTE* pb, ULONG cb );

	BOOL	FCompleted() const;

	IFileAPI* Pfapi() const { return m_pfapi; }
	
private:
	// API for VERIFYSTATEs to change state of log verification
	friend class VERIFYSTATE;
	VOID	ChangeState( VERIFYSTATE* pVerifyState );
	VOID	SetCompleted();

private:
	// Member variables
	IFileAPI* const	m_pfapi;
	VERIFYSTATE*	m_pVerifyState;
	};

// This code is Source Insight-enhanced

#define VERIFYHEADER_CODE
#define VERIFYCHECKSUM_CODE
#define VERIFYSTATE_CODE
#define LOGVERIFIER_CODE


#ifdef VERIFYHEADER_CODE

ERR
VERIFYHEADER::ErrVerify( LOGVERIFIER* const pLogVerifier, const BYTE* const pb, const ULONG cb )
	{
	ERR	err = JET_errSuccess;

	Assert( pNil != pLogVerifier );
	Assert( pNil != pb );
	Assert( cb >= sizeof( LGFILEHDR ) );

	const LGFILEHDR* const plgfilehdr = reinterpret_cast< const LGFILEHDR* >( pb );
	if ( ::UlUtilChecksum( reinterpret_cast< const BYTE* >( plgfilehdr ), sizeof( LGFILEHDR ) ) !=
		plgfilehdr->lgfilehdr.le_ulChecksum )
		{
		const _TCHAR*	rgpsz[ 4 ];
		DWORD			irgpsz		= 0;
		_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szOffset[ 64 ];
		_TCHAR			szLength[ 64 ];
		_TCHAR			szError[ 64 ];

		CallS( pLogVerifier->Pfapi()->ErrPath( szAbsPath ) );
		_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), QWORD( 0 ), QWORD( 0 ) );
		_stprintf( szLength, _T( "%u (0x%08x)" ), sizeof( LGFILEHDR ), sizeof( LGFILEHDR ) );
		_stprintf( szError, _T( "%i (0x%08x)" ), JET_errLogReadVerifyFailure, JET_errLogReadVerifyFailure );

		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szOffset;
		rgpsz[ irgpsz++ ]	= szLength;
		rgpsz[ irgpsz++ ]	= szError;

		UtilReportEvent(	eventError,
							LOGGING_RECOVERY_CATEGORY,
							LOG_RANGE_CHECKSUM_MISMATCH_ID,
							irgpsz,
							rgpsz );

		return ErrERRCheck( JET_errLogReadVerifyFailure );
		}

	VERIFYCHECKSUM* const pVerifyChecksum = new VERIFYCHECKSUM( sizeof( LGFILEHDR ), plgfilehdr->lgfilehdr.le_lGeneration );
	if ( pNil == pVerifyChecksum )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	ChangeState( pLogVerifier, pVerifyChecksum );
	delete this;
	Call( pLogVerifier->ErrVerify( pb + sizeof( LGFILEHDR ), cb - sizeof( LGFILEHDR ) ) );

HandleError:
	return err;
	}

#endif

#ifdef VERIFYCHECKSUM_CODE

VERIFYCHECKSUM::VERIFYCHECKSUM
	(
	ULONG	ibLRCK,			// index of LRCK in the log file
	ULONG32	lGeneration		// gen # of log file
	)
	: m_ibLRCK( ibLRCK ), m_ibChecksumIncremental( ibLRCK + sizeof( LRCHECKSUM ) ), m_cbSeen( ibLRCK ),
	m_state( state_Start ), m_lGeneration( lGeneration )
	{
	memset( &m_lrck, 0, sizeof( m_lrck ) );
	}

ERR
VERIFYCHECKSUM::ErrCheckLRCKEnd( LOGVERIFIER* const pLogVerifier )
	{
	// compute end of forward region
	const ULONG ibEndOfForward = m_ibLRCK + sizeof( m_lrck ) + m_lrck.le_cbForwards;

	Assert( ibEndOfForward >= m_ibChecksumIncremental );
	if ( ibEndOfForward == m_ibChecksumIncremental )
		{
		// done checksumming forward region & everything else
		if ( m_lrck.le_ulChecksum != m_ck.EndChecksum() )
			{
			return ErrERRCheck( JET_errLogReadVerifyFailure );
			}
		if ( 0 == m_lrck.le_cbNext )
			{
			// no next LRCK region, thus we've gone through entire log file and verified every byte
			SetCompleted( pLogVerifier );
			delete this;
			}
		else
			{
			// setup for next LRCHECKSUM
			// next LRCK could be in next block, or it could be in this block
			m_ibLRCK += sizeof( LRCHECKSUM ) + m_lrck.le_cbNext;
			m_ibChecksumIncremental = m_ibLRCK + sizeof( LRCHECKSUM );
			m_state = state_Start;
			}
		}
	else
		{
		// more data to checksum in next block, so setup continue state
		m_state = state_Continue;
		}
	return JET_errSuccess;
	}

ERR
VERIFYCHECKSUM::ErrVerifyLRCKContinue( LOGVERIFIER* const pLogVerifier, const BYTE* const pb, const ULONG cb )
	{
	// if we checksummed from beginning of this block (which is m_ibChecksumIncremental) to
	// however far the forwards pointer goes
	const ULONG ibEndOfForwards = m_ibLRCK + sizeof( m_lrck ) + m_lrck.le_cbForwards;
	Assert( ibEndOfForwards > m_ibChecksumIncremental );
	const ULONG cbMaxForwards = ibEndOfForwards - m_ibChecksumIncremental;
	const BYTE* const pbMax = pb + min( cb, cbMaxForwards );
	
	if ( ( pbMax < pb ) ||
		( pbMax > pb + cb ) )
		{
		// max out of buffer
		return ErrERRCheck( JET_errLogReadVerifyFailure );
		}
	m_ck.ChecksumBytes( pb, pbMax );
	m_ibChecksumIncremental += ULONG( pbMax - pb );

	return ErrCheckLRCKEnd( pLogVerifier );
	}

// Note: pb != plrck necessarily because an LRCK can be placed anywhere in a sector,
// thus anywhere on a data block.
// pb defined to be beginning of block that we have access to
// plrck defined to be beginning of LRCK in the block we have access to.
// plrck is within the block.
//
//	This function is based on LOG::UlComputeChecksum, so be sure these are in sync.

ERR
VERIFYCHECKSUM::ErrVerifyLRCKStart( LOGVERIFIER* const pLogVerifier, const BYTE* const pb, const ULONG cb )
	{
	ULONG32 ulChecksum = ulLRCKChecksumSeed;
	
	// distance from LRCK in this block to beginning of block
	Assert( m_ibLRCK >= m_cbSeen );
	const LRCHECKSUM* const plrck = reinterpret_cast< const LRCHECKSUM* >( pb + ( m_ibLRCK - m_cbSeen ) );

	// LRCK must be within the buffer
	if ( ( reinterpret_cast< const BYTE* >( plrck ) < pb ) ||
		( reinterpret_cast< const BYTE* >( plrck ) + sizeof( *plrck ) > cb + pb ) )
		{
		return ErrERRCheck( JET_errLogReadVerifyFailure );
		}

	// copy
	m_lrck = *plrck;
	
	// checksum backward region
		{
		const BYTE* const pbMin = reinterpret_cast< const BYTE* >( plrck ) - plrck->le_cbBackwards;
		if ( ( pbMin < pb ) ||
			( pbMin >= cb + pb ) )
			{
			// le_cbBackwards was corrupt if it is outside of buffer
			return ErrERRCheck( JET_errLogReadVerifyFailure );
			}
		const BYTE* const pbMax = reinterpret_cast< const BYTE* >( plrck );
		ulChecksum = LOG::UlChecksumBytes( pbMin, pbMax, ulChecksum );
		}

	// checksum various other attributes of LRCHECKSUM
	
	ulChecksum ^= plrck->le_cbBackwards;
	ulChecksum ^= plrck->le_cbForwards;
	ulChecksum ^= plrck->le_cbNext;
	
	ulChecksum ^= (ULONG32) plrck->bUseShortChecksum;

	ulChecksum ^= m_lGeneration;

	// prepare to start checksumming forward region which may extend into other blocks
	m_ck.BeginChecksum( ulChecksum );

	// end of bytes incrementally checksummed so far
	m_ibChecksumIncremental = m_ibLRCK + sizeof( *plrck );
	
	// checksum forward region
		{
		const BYTE* const pbMin = reinterpret_cast< const BYTE* >( plrck ) + sizeof( *plrck );
		const BYTE* const pbMaxForwards = pbMin + plrck->le_cbForwards;
		const BYTE* const pbMaxBlock = pb + cb;
		const BYTE* const pbMax = min( pbMaxForwards, pbMaxBlock );

		if ( ( pbMin < pb ) ||
			( pbMin > pb + cb ) )
			{
			// min out of buffer
			return ErrERRCheck( JET_errLogReadVerifyFailure );
			}
		if ( ( pbMax < pb ) ||
			( pbMax > pb + cb ) )
			{
			// max out of buffer
			return ErrERRCheck( JET_errLogReadVerifyFailure );
			}
		if ( pbMax < pbMin )
			{
			// psychotic pointers -- avoid access violation here
			return ErrERRCheck( JET_errLogReadVerifyFailure );
			}
		m_ck.ChecksumBytes( pbMin, pbMax );
		m_ibChecksumIncremental += ULONG( pbMax - pbMin );
		}
		
	return ErrCheckLRCKEnd( pLogVerifier );
	}

ERR
VERIFYCHECKSUM::ErrVerify( LOGVERIFIER* const pLogVerifier, const BYTE* const pb, const ULONG cb )
	{
	ERR err = JET_errSuccess;
	
	Assert( pNil != pb );
	Assert( cb > 0 );
	Assert( pNil != pLogVerifier );

	do
		{
		switch ( m_state )
			{
			case state_Start:
				Call( ErrVerifyLRCKStart( pLogVerifier, pb, cb ) );
				break;
				
			case state_Continue:
				Call( ErrVerifyLRCKContinue( pLogVerifier, pb, cb ) );
				break;

			default:
				Assert( fFalse );
				break;
			}
		}
	while ( ( ! pLogVerifier->FCompleted() ) && ( m_ibLRCK < m_cbSeen + cb ) && ( state_Continue != m_state ) );
	// while there's more in the log file to check and the next LRCK is in this block

	if ( ! pLogVerifier->FCompleted() )
		{
		// Next LRCK to checkout should be in next block
		Assert( ( state_Continue == m_state ) || ( m_ibLRCK >= m_cbSeen + cb ) );

		m_cbSeen += cb;
		}

HandleError:
	if ( err == JET_errLogReadVerifyFailure )
		{
		QWORD			ibOffset	= m_ibLRCK - m_lrck.le_cbBackwards;
		DWORD			cbLength	= m_lrck.le_cbBackwards + sizeof( LRCHECKSUM ) + m_lrck.le_cbForwards;
		
		const _TCHAR*	rgpsz[ 4 ];
		DWORD			irgpsz		= 0;
		_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szOffset[ 64 ];
		_TCHAR			szLength[ 64 ];
		_TCHAR			szError[ 64 ];

		CallS( pLogVerifier->Pfapi()->ErrPath( szAbsPath ) );
		_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset, ibOffset );
		_stprintf( szLength, _T( "%u (0x%08x)" ), cbLength, cbLength );
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );

		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szOffset;
		rgpsz[ irgpsz++ ]	= szLength;
		rgpsz[ irgpsz++ ]	= szError;

		UtilReportEvent(	eventError,
							LOGGING_RECOVERY_CATEGORY,
							LOG_RANGE_CHECKSUM_MISMATCH_ID,
							irgpsz,
							rgpsz );
		}
	return err;
	}

#endif

	
#ifdef LOGVERIFIER_CODE

LOGVERIFIER::LOGVERIFIER( IFileAPI* const pfapi, ERR* const pErr )
	:	m_pfapi( pfapi ),
		m_pVerifyState( pNil )
	{
	VERIFYHEADER* const pVerifyHeader = new VERIFYHEADER;
	if ( pNil == pVerifyHeader )
		{
		*pErr = ErrERRCheck( JET_errOutOfMemory );
		return;
		}
	ChangeState( pVerifyHeader );
	*pErr = JET_errSuccess;
	}

LOGVERIFIER::~LOGVERIFIER()
	{
	delete m_pVerifyState;
	}

INLINE VOID
LOGVERIFIER::ChangeState( VERIFYSTATE* const pVerifyState )
	{
	Assert( pVerifyState != pNil );
	m_pVerifyState = pVerifyState;
	}

INLINE ERR
LOGVERIFIER::ErrVerify( const BYTE* const pb, const ULONG cb )
	{
	if ( FCompleted() )
		{
		return JET_errSuccess;
		}
	else
		{
		Assert( pNil != m_pVerifyState );
		Assert( pNil != pb );
		return m_pVerifyState->ErrVerify( this, pb, cb );
		}
	}

INLINE BOOL
LOGVERIFIER::FCompleted() const
	{
	return pNil == m_pVerifyState;
	}

INLINE VOID
LOGVERIFIER::SetCompleted()
	{
	m_pVerifyState = pNil;
	}
#endif

#ifdef VERIFYSTATE_CODE

INLINE VOID
VERIFYSTATE::ChangeState( LOGVERIFIER* const pLogVerifier, VERIFYSTATE* const pVerifyState )
	{
	Assert( pNil != pLogVerifier );
	Assert( pNil != pVerifyState );
	pLogVerifier->ChangeState( pVerifyState );
	}

INLINE VOID
VERIFYSTATE::SetCompleted( LOGVERIFIER* const pLogVerifier )
	{
	Assert( pNil != pLogVerifier );
	pLogVerifier->SetCompleted();
	}
	
#endif

//	Abstract base class to describe class to process chunks of data during file read processing

class ChunkProcessor
	{
public:
	virtual ERR ErrProcessChunk( const DWORD ichunk ) = 0;
	};


class ANYORDERCOMPLETION
	{
public:
	ANYORDERCOMPLETION( const DWORD cChunks, ERR* const pErr )
		: m_asigDone( CSyncBasicInfo( _T( "ANYORDERCOMPLETION::m_asigDone" ) ) ),
		m_err( JET_errSuccess ),
		m_cOutstandingChunks( 0 ),
		m_cIssuedChunks( 0 )
		{
		*pErr = JET_errSuccess;
		}

	//	During your issue process, you may not want to continue issuing if
	//	we've already reached an error state.
	
	INLINE BOOL	FContinueIssuing() const
		{
		return m_err >= 0;
		}

	//	Call you know a chunk will complete in the future.
	
	INLINE VOID	Issue()
		{
		// not done atomically, since same thread doing Issue()'s should do WaitForAll()
		++m_cIssuedChunks;
		}

	class DoNothing
		{
	public:
		INLINE VOID BeforeWaitProcess()
			{
			}
		};

	//	Wait for all the outstanding chunks to complete and be processed, returning
	//	any error from any chunk processing.

	ERR ErrWaitForAll()
		{
		return ErrWaitForAll( DoNothing() );
		}

	template< class T >
	ERR	ErrWaitForAll( T& pfnBeforeWait )
		{
		if ( 0 != AtomicExchangeAdd( &m_cOutstandingChunks, m_cIssuedChunks ) + m_cIssuedChunks )
			{
			//	May want to do additional processing before we sleep.
			pfnBeforeWait.BeforeWaitProcess();
			m_asigDone.Wait();
			}
		else
			{
			//	Asynch. events all completed and we were last to increment negative value to zero,
			//	which means signal is already set and we don't even need to check it.

			// Assert( m_asigDone.FIsSet() );	// Synch-God where are you?!
			}
		const ERR err = m_err;
		return err;
		}

	VOID	Completion( const DWORD ichunk, ChunkProcessor& cp, const ERR errCompletion );

	INLINE VOID	Completion( const DWORD ichunkCompleted, ChunkProcessor& cp )
		{
		Completion( ichunkCompleted, cp, JET_errSuccess );
		}
		
private:
	CAutoResetSignal	m_asigDone;			// Set when all completions have finished.
	volatile ERR		m_err;				// any error returned from completion function
	long				m_cOutstandingChunks;	// Number of issued chunks whose completion functions haven't been called
	long				m_cIssuedChunks;
	};



VOID
ANYORDERCOMPLETION::Completion( const DWORD ichunk, ChunkProcessor& cp, const ERR errCompletion )
	{
	if ( m_err < 0 )
		{
		// already have an error, so do not call anymore ChunkCompletion functions
		goto HandleError;
		}

	if ( errCompletion < 0 )
		{
		//	If someone beats us, that's fine because there's no real order anyway.
		(VOID) AtomicCompareExchange( (long*) &m_err, JET_errSuccess, errCompletion );
		goto HandleError;
		}

		{
		const ERR err = cp.ErrProcessChunk( ichunk );
									
		if ( JET_errSuccess != err )
			{
			(VOID) AtomicCompareExchange( (long*) &m_err, JET_errSuccess, err );
			}
		}
		
HandleError:
	if ( 0 == AtomicDecrement( &m_cOutstandingChunks ) )
		{
		m_asigDone.Set();
		}
	}
		
// To be used in situations of asynchronous completion of many "chunks" where
// completion functions need to be called in order of issue
// even if order of actual completion doesn't match order of issue.
//
// i.e.
// Issue Order: 0, 1, 2
// Actual Completion Order: 1, 2, 0
// Completion Order Maintained by this API: 0, 1, 2
//
// A "completion" is defined as the completion function being called
// for a chunk.
//
// CONSIDER: may want to redesign interface to allow clients to set when
// we go into a non-issue state, instead of being JET_err* based.
//

class INORDERCOMPLETION
	{
public:
	INORDERCOMPLETION( const DWORD cChunks, ERR* const pErr )
		: m_asigDone( CSyncBasicInfo( _T( "INORDERCOMPLETION::m_asigDone" ) ) ),
		m_ichunkNext( 0 ),
		m_crit( CLockBasicInfo( CSyncBasicInfo( _T( "INORDERCOMPLETION::m_crit" ) ), 0, 0 ) ),
		m_rgfCompleted( new bool[ cChunks ] ),
		m_cfCompleted( cChunks ),
		m_err( JET_errSuccess ),
		m_cOutstandingChunks( 0 ),
		m_cIssuedChunks( 0 )
		{
		Assert( cChunks > 0 );
		Assert( pNil != pErr );
		
		if ( NULL == m_rgfCompleted )
			{
			*pErr = ErrERRCheck( JET_errOutOfMemory );
			return;
			}

		memset( m_rgfCompleted, 0, sizeof( bool ) * cChunks );

		*pErr = JET_errSuccess;
		}

	~INORDERCOMPLETION()
		{
		Assert( 0 == m_cOutstandingChunks );
		delete[] m_rgfCompleted;
		}

	//	During your issue process, you may not want to continue issuing if
	//	we've already reached an error state.
	
	INLINE BOOL	FContinueIssuing() const
		{
		return m_err >= 0;
		}

	//	Call you know a chunk will complete in the future.
	
	INLINE VOID	Issue()
		{
		Assert( m_cIssuedChunks < m_cfCompleted );
		// not done atomically, since same thread doing Issue()'s should do WaitForAll()
		++m_cIssuedChunks;
		}

	class DoNothing
		{
	public:
		INLINE VOID BeforeWaitProcess()
			{
			}
		};

	//	Wait for all the outstanding chunks to complete and be processed, returning
	//	any error from any chunk processing.

	ERR ErrWaitForAll()
		{
		return ErrWaitForAll( DoNothing() );
		}

	template< class T >
	ERR	ErrWaitForAll( T& pfnBeforeWait )
		{
		if ( 0 != AtomicExchangeAdd( &m_cOutstandingChunks, m_cIssuedChunks ) + m_cIssuedChunks )
			{
			//	May want to do additional processing before we sleep.
			pfnBeforeWait.BeforeWaitProcess();
			m_asigDone.Wait();
			}
		else
			{
			//	Asynch. events all completed and we were last to increment negative value to zero,
			//	which means signal is already set and we don't even need to check it.

			// Assert( m_asigDone.FIsSet() );	// Synch-God where are you?!
			}
		const ERR err = m_err;
		return err;
		}

	VOID Completion( const DWORD ichunkCompleted, ChunkProcessor& cp, const ERR errCompletion );

	//	Call when ichunkCompleted has completed asynchronously successfully
	//	pfnChunkCompletion is functor to be called on any chunks that have
	//	completed now, if linear ordering is satisfied (in other words, the functor
	//	may not be called when you call Completion()).
	
	INLINE VOID	Completion( const DWORD ichunkCompleted, ChunkProcessor& cp )
		{
		Completion( ichunkCompleted, cp, JET_errSuccess );
		}

private:
	CAutoResetSignal	m_asigDone;			// Set when all completions have finished.
	DWORD				m_ichunkNext;		// next chunk that we should complete to maintain proper order
	CCriticalSection	m_crit;				
	bool* const			m_rgfCompleted;		// flag set when a chunk completes
	const DWORD			m_cfCompleted;		// number of elements of m_rgfCompleted
	volatile ERR		m_err;				// any error returned from completion function
	long				m_cOutstandingChunks;	// Number of issued chunks whose completion functions haven't been called
	long				m_cIssuedChunks;
	};

VOID
INORDERCOMPLETION::Completion( const DWORD ichunkCompleted, ChunkProcessor& cp, const ERR errCompletion )
	{
	Assert( m_crit.FNotOwner() );
	m_crit.Enter();
	
	if ( m_err < 0 )
		{
		// already have an error, so do not call anymore ChunkCompletion functions
		goto HandleError;
		}

	if ( errCompletion < 0 )
		{
		m_err = errCompletion;
		goto HandleError;
		}

	Assert( ichunkCompleted < m_cfCompleted );
	m_rgfCompleted[ ichunkCompleted ] = fTrue;		// mark us as completed

	if ( ichunkCompleted == m_ichunkNext )
		{
		// if it's our turn, process forward as far as possible
		Assert( m_crit.FOwner() );
		m_crit.Leave();	// leave crit during processing

		DWORD ichunk = ichunkCompleted;		// start with our chunk and continue as far as possible
LProcessForwardChunks:
		for ( ; ichunk < m_cfCompleted; ++ichunk )
			{
			// look forward in completion status array
			if ( m_rgfCompleted[ ichunk ] )
				{
				const ERR err = cp.ErrProcessChunk( ichunk );
									
				if ( JET_errSuccess != err )
					{
					Assert( m_crit.FNotOwner() );
					m_crit.Enter();
					if ( m_err >= 0 )
						{
						// don't blow away a previous error
						m_err = err;
						}
					goto HandleError;
					}
				}
			else
				{
				// chunk has not completed, so we'll set it as the next to execute
				break;
				}
			}
		// try to set ichunkNext to the next one that should be processed
		m_crit.Enter();
		if ( ( ichunk < m_cfCompleted ) && ( m_rgfCompleted[ ichunk ] ) )
			{
			// the one we were going to mark as next has already completed & exited, so
			// we must handle it now
			m_crit.Leave();
			goto LProcessForwardChunks;
			}
		else
			{
			// the one we're going to mark next has not yet completed. If it's going to complete
			// once we leave this critical section, it will execute next.

			m_ichunkNext = ichunk;
			}
		}
		
HandleError:
	Assert( m_crit.FOwner() );
	m_crit.Leave();
	if ( 0 == AtomicDecrement( &m_cOutstandingChunks ) )
		{
		m_asigDone.Set();
		}
	}

//	Abstract base class to describe object with member function to handle FileRead completion
//	for different file types.

class FileReadCompletor
	{
public:
	virtual VOID FileReadCompletion(
		const ERR err,
		const QWORD ibOffset,
		const DWORD	cbData,
		const BYTE* const pbData ) = 0;
	};

//	Specify interfaces to read files of different types

class FileReadInterface
	{
public:
	virtual ERR FileRead( const QWORD ib, const DWORD cb, BYTE* const pb, FileReadCompletor* pfrc ) = 0;
	virtual VOID IssueIOs() = 0;
	virtual ERR ErrPath( _TCHAR* const szAbsPath ) = 0;
	};

//	FileReadInterface to read files of type: IFileAPI

class OSFILEREAD : public FileReadInterface
	{
public:
	INLINE OSFILEREAD( IFileAPI *const pfapi )
		: m_pfapi( pfapi )
		{
		Assert( pfapi );
		}
		
	ERR	FileRead( const QWORD ib, const DWORD cb, BYTE* const pb, FileReadCompletor* pfrc )
		{
		Assert( cb > 0 );
		Assert( pb );
		Assert( pfrc );
		ERR err = m_pfapi->ErrIORead( ib, cb, pb, FileReadIOCompletion, DWORD_PTR( pfrc ) );
		Call( err );
		
	HandleError:
		return err;
		}

	VOID	IssueIOs()
		{
		CallS( m_pfapi->ErrIOIssue() );
		}

	ERR ErrPath( _TCHAR* const szAbsPath )
		{
		return m_pfapi->ErrPath( szAbsPath );
		}

private:
	static VOID FileReadIOCompletion(
		const ERR			errIO,
		IFileAPI *const	pfapi,
		const QWORD			ibOffset,
		const DWORD			cbData,
		const BYTE* const	pbData,
		const DWORD_PTR		dwCompletionKey
		)
		{
		FileReadCompletor* const	pfrc = reinterpret_cast< FileReadCompletor* const >( dwCompletionKey );
		Assert( pfrc );
		pfrc->FileReadCompletion( errIO, ibOffset, cbData, pbData );
		}

private:
	IFileAPI *m_pfapi;
	};

//	Helper class that will start issuing IOs on a FileReadInterface when BeforeWaitProcess() is called.

class ISSUEIOS
	{
public:
	INLINE ISSUEIOS( FileReadInterface& fri )
		: m_fri( fri )
		{
		}

	INLINE VOID BeforeWaitProcess()
		{
		m_fri.IssueIOs();
		}
	
private:
	FileReadInterface&	m_fri;
	};

template< class CompletionConstraint >
class FileReadProcessor : public FileReadCompletor
	{
public:
	// public interface to FileReadProcessor
	static ERR
	ErrFileReadAndProcess(
		FileReadInterface&	fri,			// how to read file
		const QWORD			ibFile,			// what portion of file to read
		const DWORD			cbBlock,		// how much data to read -- never causes us to read past end of file
		BYTE* const			pbBlock,		// where to put file data
		const DWORD			cbIO,			// size of IO
		ChunkProcessor&		cp );			// how to process data in order

private:
	FileReadProcessor( const BYTE* const pbBlock, const DWORD cbBlock, const DWORD cbIO, CompletionConstraint& ioc, ChunkProcessor& cp )
		: m_pbBlock( pbBlock ), m_cbBlock( cbBlock ), m_cbIO( cbIO ), m_ioc( ioc ), m_cp( cp )
		{
		Assert( pbBlock );
		Assert( cbBlock > 0 );
		Assert( cbIO > 0 );
		}
		
	~FileReadProcessor()
		{
		}

	//	Asynchronous FileRead completion.
	//	Dispatch to INORDERCOMPLETION who will execute ChunkProcessor in proper order
	
	virtual VOID FileReadCompletion
		(
		const ERR			err,
		const QWORD			ibOffset,
		const DWORD			cbData,
		const BYTE* const	pbData
		)
		{
		Assert( pbData );
		Assert( m_pbBlock );
		Assert( pbData >= m_pbBlock );
		Assert( m_cbIO > 0 );
		Assert( 0 == ( ( pbData - m_pbBlock ) % m_cbIO ) );
		const DWORD ichunkCompleted = DWORD( pbData - m_pbBlock ) / m_cbIO;

		m_ioc.Completion( ichunkCompleted, m_cp, err );
		}

private:
	const BYTE* const		m_pbBlock;		// beginning of block of memory where all data will be brought in
	const DWORD				m_cbBlock;		// size of entire block
	const DWORD				m_cbIO;
	CompletionConstraint&	m_ioc;
	ChunkProcessor&			m_cp;
	};


//	VC5 generates code for every template usage, so let's preempt that

ERR
ErrFileReadAndProcessAnyOrder(
	FileReadInterface&	fri,			// how to read file
	const QWORD			ibFile,			// what portion of file to read
	const DWORD			cbBlock,		// how much data to read -- never causes us to read past end of file
	BYTE* const			pbBlock,		// where to put file data
	const DWORD			cbIO,			// size of IO
	ChunkProcessor&		cp )			// how to process data in order
	{
	return FileReadProcessor< ANYORDERCOMPLETION >::ErrFileReadAndProcess( fri, ibFile, cbBlock, pbBlock, cbIO, cp );
	}

template< class CompletionConstraint >
ERR
FileReadProcessor< CompletionConstraint >::ErrFileReadAndProcess(
	FileReadInterface&	fri,			// how to read file
	const QWORD			ibFile,			// what portion of file to read
	const DWORD			cbBlock,		// how much data to read -- never causes us to read past end of file
	BYTE* const			pbBlock,		// where to put file data
	const DWORD			cbIO,			// size of IO
	ChunkProcessor&		cp )			// how to process data in order
	{
	ERR	err = JET_errSuccess;

	//  we will retry failed reads during backup in the hope of saving the
	//  backup set

	const TICK	tickStart	= TickOSTimeCurrent();
	const TICK	tickBackoff	= 100;
	const int	cRetry		= 16;

	int			iRetry		= 0;
	
	do
		{
		err = JET_errSuccess;
		
		// algorithm for issuing as many IOs as possible to FileReadInterface and processing each IO
		// with ChunkProcessor with any ordering constraint as specified by the template parameter.

		Assert( cbBlock > 0 );
		Assert( pbBlock );
		Assert( cbIO > 0 );
				
		const DWORD	cIOs = 1 + ( cbBlock - 1 ) / cbIO;	// number of IOs we'll try to kick off
		CompletionConstraint	ioc( cIOs, &err );
		Call( err );

			{
			FileReadProcessor	frio( pbBlock, cbBlock, cbIO, ioc, cp );

			for ( DWORD iIO = 0;
				( iIO < cIOs ) && ( err >= 0 ) && ioc.FContinueIssuing();
				++iIO )
				{
				const DWORD cbBefore = iIO * cbIO;
				const DWORD cb = min( cbIO, cbBlock - cbBefore );

				err = fri.FileRead( ibFile + cbBefore, cb, pbBlock + cbBefore, &frio );

				if ( err >= 0 )
					{
					ioc.Issue();
					}
				}

			// need to ensure IOs have been issued if we're indeed going to wait
			const ERR errWait = ioc.ErrWaitForAll( ISSUEIOS( fri ) );

			Call( err );		// Die on original error, if exists
			Call( errWait );	// Die on wait error, if exists
			}

	HandleError:
		if ( err < JET_errSuccess )
			{
			if ( iRetry < cRetry )
				{
				UtilSleep( ( iRetry + 1 ) * tickBackoff );
				}
			}
		else
			{
			if ( iRetry > 0 )
				{
				const _TCHAR*	rgpsz[ 5 ];
				DWORD			irgpsz		= 0;
				_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
				_TCHAR			szOffset[ 64 ];
				_TCHAR			szLength[ 64 ];
				_TCHAR			szFailures[ 64 ];
				_TCHAR			szElapsed[ 64 ];

				CallS( fri.ErrPath( szAbsPath ) );
				_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibFile, ibFile );
				_stprintf( szLength, _T( "%u (0x%08x)" ), cbBlock, cbBlock );
				_stprintf( szFailures, _T( "%i" ), iRetry );
				_stprintf( szElapsed, _T( "%g" ), ( TickOSTimeCurrent() - tickStart ) / 1000.0 );
		
				rgpsz[ irgpsz++ ]	= szAbsPath;
				rgpsz[ irgpsz++ ]	= szOffset;
				rgpsz[ irgpsz++ ]	= szLength;
				rgpsz[ irgpsz++ ]	= szFailures;
				rgpsz[ irgpsz++ ]	= szElapsed;

				UtilReportEvent(	eventError,
									LOGGING_RECOVERY_CATEGORY,
									TRANSIENT_READ_ERROR_DETECTED_ID,
									irgpsz,
									rgpsz );
				}
			}
		}
	while ( iRetry++ < cRetry && err < JET_errSuccess );

	return err;
	}

//	Bridge between LOGVERIFIER and ChunkProcessor interface

class LogChunkVerifier : public ChunkProcessor
	{
public:
	LogChunkVerifier( LOGVERIFIER* pLogVerifier, const BYTE* const pbBlock, const DWORD cbBlock, const DWORD cbChunk )
		: m_pLogVerifier( pLogVerifier ), m_pbBlock( pbBlock ), m_cbBlock( cbBlock ), m_cbChunk( cbChunk )
		{
		Assert( pLogVerifier );
		Assert( pbBlock );
		Assert( cbBlock > 0 );
		Assert( cbChunk > 0 );
		}

	ERR ErrProcessChunk( const DWORD ichunk )
		{
		Assert( m_cbChunk > 0 );
		// bytes before our chunk
		const DWORD cbBefore = ichunk * m_cbChunk;
		Assert( m_pbBlock );
		const BYTE* const pb = m_pbBlock + cbBefore;
		Assert( m_cbBlock > cbBefore );
		// ensure that we properly size last chunk which may be less than m_cbChunk
		const DWORD cb = min( m_cbChunk, m_cbBlock - cbBefore );
		
		Assert( cb > 0 );
		Assert( m_pLogVerifier );
		return m_pLogVerifier->ErrVerify( pb, cb );
		}

private:
	LOGVERIFIER* const	m_pLogVerifier;
	const BYTE* const	m_pbBlock;
	const DWORD			m_cbBlock;
	const DWORD			m_cbChunk;
	};


#ifdef DISABLE_SLV
#else

//	Bridge between SLVVERIFIER and ChunkProcessor interface

class SLVChunkVerifier : public ChunkProcessor
	{
public:
	SLVChunkVerifier
		(
		const SLVVERIFIER* const pSLVVerifier,	// Verifier we'll use
		const BYTE* const pb,				// start of the big block with the many chunks
		const DWORD cb,						// size of entire block
		const DWORD cbChunk,				// size of each chunk in the block (last chunk may be smaller than this)
		IFileAPI* const	pfapi,				// SLV file
		const QWORD ibFile					// what portion of the SLV file are we looking at?
		)
		: m_pSLVVerifier( pSLVVerifier ), m_pb( pb ), m_cbBlock( cb ), m_cbChunk( cbChunk ), m_pfapi( pfapi ), m_ib( ibFile )
		{
		Assert( pSLVVerifier );
		Assert( pb );
		Assert( cb > 0 );
		Assert( cbChunk > 0 );
		Assert( pfapi );
		}
		
	// for each chunk of size m_cbChunk (or less in the case of the last chunk) inside of [ m_pb, m_pb + SLVPAGE_SIZE * cpg ]
	// where each chunk contains up to ( m_cbChunk / SLVPAGE_SIZE ) # of pages
	
	ERR	ErrProcessChunk( const DWORD ichunk )
		{
		Assert( m_cbChunk > 0 );
		// bytes before our chunk
		const DWORD cbBefore = ichunk * m_cbChunk;
		Assert( m_pb );
		const BYTE* const pb = m_pb + cbBefore;
		Assert( m_cbBlock > cbBefore );
		// ensure that we properly size last chunk which may be less than m_cbChunk
		const DWORD cb = min( m_cbChunk, m_cbBlock - cbBefore );
		const QWORD ib = m_ib + cbBefore;
		
		// call into SLVVERIFIER
		Assert( m_pSLVVerifier );
		return m_pSLVVerifier->ErrVerify(
			pb,											// SLV page data starts here
			cb,												// for this many pages.
			ib		// SLV page number for first page in pbChunk
			);
		}
		
private:
	const SLVVERIFIER* const	m_pSLVVerifier;
	const BYTE* const			m_pb;
	const DWORD					m_cbBlock;
	const DWORD					m_cbChunk;
	IFileAPI* const				m_pfapi;
	const QWORD					m_ib;
	};

#endif	//	DISABLE_SLV

class PatchChunkVerifier : public ChunkProcessor
	{
public:
	PatchChunkVerifier
		(
		const BYTE* const pb,				// start of the read block
		const DWORD cb,						// size of entire block
		const DWORD cbChunk,				// size of each chunk in the block (last chunk may be smaller than this)
		IFileAPI* const	pfapi,				// patch file
		const QWORD ibFile					// what portion of the patch file are we looking at?
		)
		: m_pb( pb ), m_cb( cb ), m_cbChunk( cbChunk ), m_pfapi( pfapi ), m_ib( ibFile )
		{
		Assert( pb );
		Assert( cb > 0 );
		Assert( cbChunk > 0 );
		Assert( pfapi );
		}
//	virtual ERR ErrProcessChunk( const DWORD ichunk ) = 0;
	ERR	ErrProcessChunk( const DWORD ichunk )
		{
		ERR		err			= JET_errSuccess;
		
		//  get parameters for the chunk to process
		
		size_t	ibStart		= ichunk * m_cbChunk;
		size_t	ibEnd		= ibStart + min( m_cbChunk, m_cb - ibStart );

		QWORD	ibOffset	= m_ib + ibStart;

		//  process each page of this chunk

		size_t ib;
		for ( ib = ibStart; ib < ibEnd; ib += g_cbPage, ibOffset += g_cbPage )
			{
			//  get page

			const BYTE* pbPage = m_pb + ib;
			
			//  check page

			const ULONG	ulChecksumExpected	= *( (LittleEndian<DWORD>*)pbPage );
			const ULONG	ulChecksumActual	= UlUtilChecksum( pbPage, g_cbPage );

			//  if the checksum doesn't match then we have failed verification
			
			if ( ulChecksumExpected != ulChecksumActual )
				{
				const _TCHAR*	rgpsz[ 6 ];
				DWORD			irgpsz		= 0;
				_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
				_TCHAR			szOffset[ 64 ];
				_TCHAR			szLength[ 64 ];
				_TCHAR			szError[ 64 ];
				_TCHAR			szChecksumExpected[ 64 ];
				_TCHAR			szChecksumActual[ 64 ];

				CallS( m_pfapi->ErrPath( szAbsPath ) );
				_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset, ibOffset );
				_stprintf( szLength, _T( "%u (0x%08x)" ), g_cbPage, g_cbPage );
				_stprintf( szError, _T( "%i (0x%08x)" ), JET_errReadVerifyFailure, JET_errReadVerifyFailure );
				_stprintf( szChecksumExpected, _T( "%u (0x%08x)" ), ulChecksumExpected, ulChecksumExpected );
				_stprintf( szChecksumActual, _T( "%u (0x%08x)" ), ulChecksumActual, ulChecksumActual );

				rgpsz[ irgpsz++ ]	= szAbsPath;
				rgpsz[ irgpsz++ ]	= szOffset;
				rgpsz[ irgpsz++ ]	= szLength;
				rgpsz[ irgpsz++ ]	= szError;
				rgpsz[ irgpsz++ ]	= szChecksumExpected;
				rgpsz[ irgpsz++ ]	= szChecksumActual;

				UtilReportEvent(	eventError,
									LOGGING_RECOVERY_CATEGORY,
									PATCH_PAGE_CHECKSUM_MISMATCH_ID,
									irgpsz,
									rgpsz );

				Call( ErrERRCheck( JET_errReadVerifyFailure ) );
				}
			}

		//  this chunk verified
		
		return JET_errSuccess;
		
	HandleError:
		return err;
		}
		
private:
	const BYTE* const			m_pb;
	const DWORD					m_cb;
	const DWORD					m_cbChunk;
	IFileAPI* const				m_pfapi;
	const QWORD					m_ib;
	};


//	====================================================
//	Spin off IOs of optimal size to fill buffer.
//	As IOs complete, if its chunk in the buffer is the next to checksum,
//	checksum that along with any other chunks forward in the buffer that
//	have also completed. If it's not the chunk's turn to checksum, simply
//	make a note that it should be checksummed later (it will be checksummed
//	by the chunk who's turn comes up next).
//	====================================================
	

// *********************************************************** END log verification stuff

ERR ISAMAPI ErrIsamOpenFile(
	JET_INSTANCE jinst,
	const CHAR *szFileName,
	JET_HANDLE		*phfFile,
	ULONG			*pulFileSizeLow,
	ULONG			*pulFileSizeHigh )
	{
	INST *pinst = (INST *)jinst;
	return pinst->m_plog->ErrLGBKOpenFile( pinst->m_pfsapi, szFileName, phfFile, pulFileSizeLow, pulFileSizeHigh, fFalse );
	}
	
ERR LOG::ErrLGBKOpenFile(
	IFileSystemAPI *const	pfsapi,
	const CHAR					*szFileName,
	JET_HANDLE					*phfFile,
	ULONG						*pulFileSizeLow,
	ULONG						*pulFileSizeHigh,
	const BOOL					fIncludePatch )
	{
	ERR		err;
	INT		irhf;
	IFMP	ifmpT;
	CHAR	szDirT[IFileSystemAPI::cchPathMax];
	CHAR	szFNameT[IFileSystemAPI::cchPathMax];
	CHAR	szExtT[IFileSystemAPI::cchPathMax];
	
	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}
	else if ( m_fStopBackup )
		{
		return ErrERRCheck( JET_errBackupAbortByServer );
		}

	if ( NULL == szFileName || 0 == *szFileName )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	/*	allocate rhf from rhf array.
	/**/
	if ( m_crhfMac < crhfMax )
		{
		irhf = m_crhfMac;
		m_crhfMac++;
		}
	else
		{
		Assert( m_crhfMac == crhfMax );
		for ( irhf = 0; irhf < crhfMax; irhf++ )
			{
			if ( !m_rgrhf[irhf].fInUse )
				{
				break;
				}
			}
		}
	if ( irhf == crhfMax )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
		
	Assert( irhf < m_crhfMac );

	CallR ( pfsapi->ErrPathComplete( szFileName, szFNameT ) );

	m_rgrhf[irhf].fInUse		= fTrue;
	m_rgrhf[irhf].fDatabase		= fFalse;
	m_rgrhf[irhf].fIsLog		= fFalse;
	m_rgrhf[irhf].pLogVerifier	= pNil;
	m_rgrhf[irhf].pSLVVerifier	= pNil;
	m_rgrhf[irhf].pfapi			= NULL;
	m_rgrhf[irhf].fIsSLVFile	= fFalse;
	m_rgrhf[irhf].ifmp			= ifmpMax;
	m_rgrhf[irhf].ib			= 0;
	m_rgrhf[irhf].cb			= 0;
	m_rgrhf[irhf].szFileName 	= NULL;


	Assert ( strlen(szFNameT) > 0 );
	m_rgrhf[irhf].szFileName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( sizeof(CHAR ) * ( 1 + strlen(szFNameT) ) ) );
	if ( NULL == m_rgrhf[irhf].szFileName )
		{
		m_rgrhf[irhf].fInUse = fFalse;
		CallR ( ErrERRCheck( JET_errOutOfMemory ) );
		}
	strcpy( m_rgrhf[irhf].szFileName, szFNameT );
	
	Assert ( backupStateLogsAndPatchs == m_fBackupStatus || backupStateDatabases == m_fBackupStatus );

	if ( m_fBackupSnapshot )
		{
		if ( backupStateDatabases == m_fBackupStatus )
			{
			return ErrERRCheck( JET_errInvalidBackupSequence );
			}
			
		Assert( !m_rgrhf[irhf].pfapi );
	   	m_rgrhf[irhf].fDatabase = fFalse;
	   	
		goto readLogOrPatch;
		}

	err = ErrDBOpenDatabase( m_ppibBackup, (CHAR *)szFileName, &ifmpT, 0 );
	Assert( err < 0 || err == JET_errSuccess || err == JET_wrnFileOpenReadOnly );
	if ( err < 0 && err != JET_errDatabaseNotFound )
		{
		goto HandleError;
		}
	if ( err == JET_errSuccess || err == JET_wrnFileOpenReadOnly )
		{
		PATCH_HEADER_PAGE *ppatchhdr;

		/*	should not open database if not performing full backup
		/**/
		if ( !m_fBackupFull )
			{
			Assert ( backupStateLogsAndPatchs == m_fBackupStatus );			
			CallS( ErrDBCloseDatabase( m_ppibBackup, ifmpT, 0 ) );
			Call ( ErrERRCheck( JET_errInvalidBackupSequence ) );
			}

		/*	should not open database if we are during log copy phase
		/**/
		if ( backupStateDatabases != m_fBackupStatus )
			{
			// it looks like it is called after ErrLGBKGetLogInfo
			Assert ( m_fBackupBeginNewLogFile );
			CallS( ErrDBCloseDatabase( m_ppibBackup, ifmpT, 0 ) );	
			Call ( ErrERRCheck( JET_errInvalidBackupSequence ) );
			}

		Assert( !m_rgrhf[irhf].pfapi );
	   	m_rgrhf[irhf].fDatabase = fTrue;
	   	m_rgrhf[irhf].ifmp = ifmpT;

		FMP		*pfmpT = &rgfmp[ifmpT];

		/*	database should be loggable or would not have been
		/*	given out for backup purposes.
		/**/
		Assert( pfmpT->FLogOn() );

		if ( fIncludePatch )
			{
			/*	create a local patch file
			/**/

			/*	patch file should be in database directory during backup. In log directory during
			 *	restore.
			 */

			CHAR  	szPatch[IFileSystemAPI::cchPathMax];

			LGIGetPatchName( m_pinst->m_pfsapi, szPatch, pfmpT->SzDatabaseName() );

#ifdef ELIMINATE_PATCH_FILE
			IFileAPI *pfapiPatch;
			Call( m_pinst->m_pfsapi->ErrFileCreate( szPatch, &pfapiPatch, fFalse, fFalse, fTrue ) );
			delete pfapiPatch;
#else
			pfmpT->ResetCpagePatch();

			/*	avoid aliasing of patch file pages by deleting
			/*	preexisting patch file if present
			/**/
			err = m_pinst->m_pfsapi->ErrFileDelete( szPatch );

			if ( err < 0 && err != JET_errFileNotFound )
				{
				goto HandleError;
				}
			Assert( pfmpT->CPatchIO() == 0 );
			IFileAPI *pfapiPatch;
			Call( m_pinst->m_pfsapi->ErrFileCreate( szPatch, &pfapiPatch ) );
			pfmpT->SetPfapiPatch( pfapiPatch );
			pfmpT->SetErrPatch( JET_errSuccess );
			Call( pfapiPatch->ErrSetSize( QWORD( cpgDBReserved ) * g_cbPage ) );
#endif	//	ELIMINATE_PATCH_FILE
			}

		Assert( pfmpT->PgnoCopyMost() == 0 );

		//	set backup database file size to current database file size
		//	(this simultaneously enables FBFIPatch())

		pfmpT->CritLatch().Enter();

		m_rgrhf[irhf].cb = pfmpT->CbFileSize();
		pfmpT->SetPgnoMost( pfmpT->PgnoLast() );
		pfmpT->ResetFCopiedPatchHeader();

		//	set the returned file size.
		// Must add on cpgDBReserved to accurately inform backup of file size

		m_rgrhf[irhf].cb += g_cbPage * cpgDBReserved;

#ifdef ELIMINATE_PATCH_FILE
		// we add the additional header added at the end
		// to replace information stored in the patch file header
		m_rgrhf[irhf].cb += g_cbPage;
#endif // ELIMINATE_PATCH_FILE

		pfmpT->CritLatch().Leave();
		
		//	setup patch file header for copy.

		if ( !( ppatchhdr = (PATCH_HEADER_PAGE *)PvOSMemoryPageAlloc( g_cbPage, NULL ) ) )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		pfmpT->SetPpatchhdr( ppatchhdr );

		// mark database as involved in an external backup
		pfmpT->SetInBackupSession();

#ifdef DEBUG
		if ( m_fDBGTraceBR )
			{
			const int cbFillBuffer = 128;
			char szTrace[cbFillBuffer + 1];
			szTrace[ cbFillBuffer ] = '\0';
			_snprintf( szTrace, cbFillBuffer, "START COPY DB %ld", pfmpT->PgnoMost() );
			CallS( ErrLGTrace( ppibNil, szTrace ) );

			m_cbDBGCopied = pfmpT->PgnoMost() * g_cbPage;
			}
#endif
		}
	else
		{
		Assert( err == JET_errDatabaseNotFound );
		Assert( !m_rgrhf[irhf].pfapi );
	   	m_rgrhf[irhf].fDatabase = fFalse;

		err = ErrDBOpenDatabaseBySLV( pfsapi, m_ppibBackup, (CHAR *)szFileName, &ifmpT );
		Assert ( JET_errSuccess >= err || JET_wrnFileOpenReadOnly == err );
		
		if ( backupStateDatabases == m_fBackupStatus )
			{
			// we are in backup databases mode but database file (edb or slv)
			// is not found in the FMP's.
			
			// UNDONE: we return JET_errDatabaseNotFound at this point
			// maybe we shell return something like "database unmounted" ...
			Call( err );

#ifdef DISABLE_SLV
			Call( ErrERRCheck( JET_wrnNyi ) );
#else
			Assert ( JET_errSuccess == err || JET_wrnFileOpenReadOnly == err );
			err = JET_errSuccess;

			FMP::AssertVALIDIFMP( ifmpT );

			m_rgrhf[irhf].fIsSLVFile = fTrue;
			m_rgrhf[irhf].ifmp = ifmpT;

			m_rgrhf[irhf].pSLVVerifier = new SLVVERIFIER( m_rgrhf[irhf].ifmp, &err );
			if ( ! m_rgrhf[irhf].pSLVVerifier )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			Call( err );

			/*  get the current size of the streaming file
			/**/
			Assert( rgfmp[ifmpT].PfapiSLV() );

			// wait until the STM extending process is done
			rgfmp[ifmpT].RwlSLVSpace().EnterAsReader();
			m_rgrhf[irhf].cb = rgfmp[ifmpT].CbTrueSLVFileSize();
			rgfmp[ifmpT].RwlSLVSpace().LeaveAsReader();
			
#endif	//	DISABLE_SLV

			}
		else
			{
readLogOrPatch:
			Assert ( backupStateLogsAndPatchs == m_fBackupStatus );

			// we backup just patch and log files at this point

			// UNDONE: check the format of the file (extension, etc.)

			Assert( !m_rgrhf[irhf].fDatabase );
			Assert( !m_rgrhf[irhf].fIsSLVFile );

			//	first try opening the file from the regular file-system

			IFileSystemAPI *pfsapiT = pfsapi;
			Assert( pfsapi == m_pinst->m_pfsapi );
			err = pfsapiT->ErrFileOpen( szFileName, &m_rgrhf[irhf].pfapi, fTrue );

			//	CONSIDER: Instead of checking extension, read in header to see if it's
			//	a valid log file header, else try to see if it's a valid patch file,
			//	else die because it's not a correct file that we recognize.
			//	Better yet, check if it's a log file first, since we open more log files
			//	than anything.

			CallS( pfsapiT->ErrPathParse( szFileName, szDirT, szFNameT, szExtT ) );
			m_rgrhf[irhf].fIsLog = ( UtilCmpFileName( szExtT, szLogExt ) == 0 );
				

			if ( JET_errFileNotFound == err )
				{
				const char * rgszT[] = { szFileName };

				UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
						BACKUP_LOG_FILE_MISSING_ERROR_ID, 1, rgszT, 0, NULL, m_pinst );
						
				err = ErrERRCheck( JET_errMissingFileToBackup );
				}
			Call( err );

			if ( m_rgrhf[irhf].fIsLog )
				{
				m_rgrhf[irhf].pLogVerifier = new LOGVERIFIER( m_rgrhf[irhf].pfapi, &err );
				if ( pNil == m_rgrhf[irhf].pLogVerifier )
					{
					Call( ErrERRCheck( JET_errOutOfMemory ) );
					}
				Call( err );
				}
			
			/*	get file size
			/**/
			// just opened the file, so the file size must be correctly buffered
			Call( m_rgrhf[irhf].pfapi->ErrSize( &m_rgrhf[irhf].cb ) );
			Assert( m_rgrhf[irhf].cb > 0 );			
			}
			
#ifdef DEBUG
		if ( m_fDBGTraceBR )
			m_cbDBGCopied = DWORD( m_rgrhf[irhf].cb );
#endif
		}
		
	*phfFile = (JET_HANDLE)irhf;
	{
	QWORDX cbFile;
	cbFile.SetQw( m_rgrhf[irhf].cb );
	*pulFileSizeLow = cbFile.DwLow();
	*pulFileSizeHigh = cbFile.DwHigh();
	}
	err = JET_errSuccess;


	// report start backup of file (report only EDB and STM)
	if ( m_rgrhf[irhf].fDatabase || m_rgrhf[irhf].fIsSLVFile )
		{
		char szSize[32];
		
		Assert ( m_rgrhf[irhf].szFileName );
		
		const char * rgszT[] = { m_rgrhf[irhf].szFileName, szSize };			

		if ( m_rgrhf[irhf].cb > QWORD(1024 * 1024) )
			{
			sprintf( szSize, "%I64u Mb", m_rgrhf[irhf].cb / QWORD(1024 * 1024) );
			}
		else
			{
			sprintf( szSize, "%I64u Kb", m_rgrhf[irhf].cb / QWORD(1024) );
			}
		
		UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY, BACKUP_FILE_START, 2, rgszT, 0, NULL, m_pinst );

		{
		const int cbFillBuffer = 64 + IFileSystemAPI::cchPathMax;
		char szTrace[cbFillBuffer + 1];
		szTrace[ cbFillBuffer ] = '\0';
		_snprintf( szTrace, cbFillBuffer, "Start backup file %s, size %s", m_rgrhf[irhf].szFileName, szSize );
		(void) ErrLGTrace( m_ppibBackup, szTrace);
		}
		
		}	
	
HandleError:

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];
	
		sprintf( sz, "** OpenFile (%d) %s of size %ld.\n", err, szFileName, m_cbDBGCopied );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		m_cbDBGCopied = 0;
		}
#endif

	if ( err < 0 )
		{
		// if they try to backup a unmounted database or we get an error on one database
		// we will not stop the backup
		// on all other errors (logs, patch files) we stop the backup of the instance
		if ( backupStateDatabases == m_fBackupStatus )
			{
			char szError[32];
			Assert ( m_rgrhf[irhf].szFileName );
			const char * rgszT[] = { szError, m_rgrhf[irhf].szFileName };			
			
			sprintf( szError, "%d", err );

			if ( m_rgrhf[irhf].ifmp < ifmpMax )
				{
				FMP * pfmpT = rgfmp + m_rgrhf[irhf].ifmp;
				Assert ( pfmpT );
				pfmpT->ResetInBackupSession();

				if ( pfmpT->Ppatchhdr() )
					{
					OSMemoryPageFree( pfmpT->Ppatchhdr() );
					pfmpT->SetPpatchhdr( NULL );
					}

				if ( fIncludePatch )
					{
					CHAR	szPatch[IFileSystemAPI::cchPathMax];

					// delete the created patch file
					// (we might be during STM file Open so, szPatch might not we set)

					//	UNDONE: Does this work?? If patch file was created, there might
					//	be a handle open on the file, in which case deletion will fail

					LGIGetPatchName( m_pinst->m_pfsapi, szPatch, rgfmp[ m_rgrhf[irhf].ifmp ].SzDatabaseName()  );
					ERR errAux;
					errAux = m_pinst->m_pfsapi->ErrFileDelete( szPatch );
					if ( JET_errFileNotFound == errAux )
						{
						errAux = JET_errSuccess;
						}
					CallSRFS( errAux, ( JET_errFileAccessDenied, 0 ) );
					}
				}

			UtilReportEvent(
					eventError,
					LOGGING_RECOVERY_CATEGORY,
					BACKUP_ERROR_FOR_ONE_DATABASE,
					2,
					rgszT,
					0,
					NULL,
					m_pinst );

			Assert( m_fBackupInProgress );
						
			/*	release file handle resource on error
			/**/
			Assert ( m_rgrhf[irhf].szFileName );
			OSMemoryHeapFree( m_rgrhf[irhf].szFileName );
			m_rgrhf[irhf].szFileName = NULL;	
			
			m_rgrhf[irhf].fInUse = fFalse;		
			}
		else
			{

			/*	release file handle resource on error
			/**/
			Assert ( m_rgrhf[irhf].szFileName );
			OSMemoryHeapFree( m_rgrhf[irhf].szFileName );
			m_rgrhf[irhf].szFileName = NULL;	
			
			m_rgrhf[irhf].fInUse = fFalse;		
			
			CallS( ErrLGBKIExternalBackupCleanUp( pfsapi, err ) );
			Assert( !m_fBackupInProgress );
			}
		}

	return err;
	}


ERR ISAMAPI ErrIsamReadFile( JET_INSTANCE jinst, JET_HANDLE hfFile, VOID *pv, ULONG cbMax, ULONG *pcbActual )
	{
	INST *pinst = (INST *)jinst;
	return pinst->m_plog->ErrLGBKReadFile( pinst->m_pfsapi, hfFile, pv, cbMax, pcbActual );
	}
	
ERR LOG::ErrLGBKReadFile(	IFileSystemAPI *const	pfsapi,
							JET_HANDLE					hfFile,
							VOID 						*pv,
							ULONG 						cbMax,
							ULONG 						*pcbActual )
	{
	ERR		err = JET_errSuccess;
	INT		irhf = (INT)hfFile;
	INT		cpage;
	VOID	*pvPageMin;
	FMP		*pfmpT;
	INT		cbActual = 0;

#ifdef DEBUG
	CHAR	*szLGDBGPageList = NULL;
#endif

	BOOL 	fInTransaction 	= fFalse;

	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}
	else if ( m_fStopBackup )
		{
		return ErrERRCheck( JET_errBackupAbortByServer );
		}

	if ( !m_rgrhf[irhf].fDatabase )
		{
		Assert ( ( backupStateLogsAndPatchs == m_fBackupStatus && !m_rgrhf[irhf].fIsSLVFile ) ||
				( backupStateDatabases == m_fBackupStatus && m_rgrhf[irhf].fIsSLVFile ) );
				
		// adding support for checksum
		// we need to impose page boundaries
		if ( ( cbMax % SLVPAGE_SIZE ) != 0 )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}			

		if ( 0 == cbMax || ( cbMax / SLVPAGE_SIZE < cpgDBReserved && 0 == m_rgrhf[irhf].ib ) )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}


		if ( ( cbMax % g_cbPage ) != 0 )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}			

		if ( cbMax / g_cbPage < cpgDBReserved && 0 == m_rgrhf[irhf].ib )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
				
		DWORD 		cbToRead 		= DWORD( min( m_rgrhf[irhf].cb - m_rgrhf[irhf].ib, cbMax ) );

		Assert ( 0 == ( cbToRead % SLVPAGE_SIZE ) );

		Assert ( 0 == ( cbToRead % g_cbPage ) );

		Assert ( 0 == m_ppibBackup->level );
		Call ( ErrDIRBeginTransaction( m_ppibBackup, NO_GRBIT ) );
		fInTransaction = fTrue;
		Assert ( 1 == m_ppibBackup->level );

		if ( cbToRead > 0 )
			{
			BYTE* const pb = reinterpret_cast< BYTE* const >( pv );
			const DWORD cbOptimal = 64 * 1024;

			// should be db page size multiple
			Assert ( 0 == ( cbOptimal % g_cbPage ) );
			
			if ( m_rgrhf[irhf].fIsLog )
				{
				Call( FileReadProcessor< INORDERCOMPLETION >::ErrFileReadAndProcess( OSFILEREAD( m_rgrhf[irhf].pfapi ),
					m_rgrhf[irhf].ib, cbToRead, pb, cbOptimal,
					LogChunkVerifier( m_rgrhf[irhf].pLogVerifier, pb, cbToRead, cbOptimal ) ) );
				}
			else if ( m_rgrhf[irhf].fIsSLVFile )
				{
#ifdef DISABLE_SLV
				Call( ErrERRCheck( JET_wrnNyi ) );
#else
				Call( m_rgrhf[irhf].pSLVVerifier->ErrGrabChecksums( m_rgrhf[irhf].ib, cbToRead, m_ppibBackup ) );

				FMP::AssertVALIDIFMP( m_rgrhf[irhf].ifmp );
				
				// standard file read API
				
				err = ErrFileReadAndProcessAnyOrder(	OSFILEREAD( rgfmp[ m_rgrhf[ irhf ].ifmp ].PfapiSLV() ),
														m_rgrhf[irhf].ib,
														cbToRead,
														pb,
														cbOptimal,
														SLVChunkVerifier(	m_rgrhf[irhf].pSLVVerifier,
																			pb,
																			cbToRead,
																			cbOptimal,
																			rgfmp[ m_rgrhf[ irhf ].ifmp ].PfapiSLV(),
																			m_rgrhf[irhf].ib ) );

				if ( err < 0 )
					{
					// delete SLVVerifier now so it'll DIRClose now, instead of trying to DIRClose
					// it later after it's already been closed (but we can't tell).
					//
					// yes, this looks kind of gross
					delete m_rgrhf[irhf].pSLVVerifier;
					m_rgrhf[irhf].pSLVVerifier = pNil;
					Call( err );
					}
					
				Call( m_rgrhf[irhf].pSLVVerifier->ErrDropChecksums() );
#endif	//	DISABLE_SLV
			}
			else
				{

				//	should be a patch file (patch files ALWAYS sit on the OS file-system)

				Call( ErrFileReadAndProcessAnyOrder( OSFILEREAD(  m_rgrhf[irhf].pfapi ),
					m_rgrhf[irhf].ib, cbToRead, pb, cbOptimal,
					PatchChunkVerifier( pb, cbToRead, cbOptimal, m_rgrhf[irhf].pfapi, m_rgrhf[irhf].ib ) ) );
				}
			}	// cbToRead > 0

		Assert ( 1 == m_ppibBackup->level );

		Call( ErrDIRCommitTransaction( m_ppibBackup, NO_GRBIT ) );
		fInTransaction = fFalse;
		Assert ( 0 == m_ppibBackup->level );
		
		m_rgrhf[irhf].ib += cbToRead;
		if ( pcbActual )
			{
			*pcbActual = cbToRead;
			}

		Assert( m_rgrhf[irhf].ib <= m_rgrhf[irhf].cb );
		if ( m_rgrhf[irhf].ib == m_rgrhf[irhf].cb && m_rgrhf[irhf].fIsLog )
			{
			// this is the last call to JetReadFile() that will return data.
			// If log verification isn't completed yet, we should return an error
			// now, instead of waiting for the JetCloseFile(), which clients
			// are likely to ignore the return code from.
			Assert( m_rgrhf[irhf].pLogVerifier );
			if ( ! m_rgrhf[irhf].pLogVerifier->FCompleted() )
				{
				// If log verification hasn't completed, which means it still
				// expects more data to checksum (i.e. bad LRCK), log file is hosed.
				Call( ErrERRCheck( JET_errLogReadVerifyFailure ) );
				}
			}

#ifdef DEBUG
		if ( m_fDBGTraceBR )
			m_cbDBGCopied += min( cbMax, *pcbActual );
#endif
		}
	else
		{
		Assert ( backupStateDatabases == m_fBackupStatus );
		FMP::AssertVALIDIFMP( m_rgrhf[irhf].ifmp );
		
		pfmpT = &rgfmp[ m_rgrhf[irhf].ifmp ];

		if ( ( cbMax % g_cbPage ) != 0 )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}

		cpage = cbMax / g_cbPage;

		//	we need to read at least 2 pages for the database header,
		//	plus one more to ensure PgnoCopyMost advances beyond 0
		//
		if ( 0 == cpage || ( cpage <= cpgDBReserved && 0 == pfmpT->PgnoCopyMost() ) )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}

#ifdef DEBUG
	if ( m_fDBGTraceBR > 1 )
		{
		szLGDBGPageList = static_cast<CHAR *>( PvOSMemoryHeapAlloc( cpage * 20 ) );
		if ( szLGDBGPageList )
			{
			szLGDBGPageList[0] = '\0';
			}
		}
#endif

		// check database as involved in an external backup
		Assert ( pfmpT->FInBackupSession() );
		
		if ( cpage > 0 )
			{
			pvPageMin = pv;

			/*	read next cpageBackupBuffer pages
			/**/
#ifdef DEBUG
			Call( ErrLGBKReadPages(
				m_rgrhf[irhf].ifmp,
				pvPageMin,
				cpage,
				&cbActual,
				(BYTE *)szLGDBGPageList ) );
			
			if ( m_fDBGTraceBR )
				m_cbDBGCopied += cbActual;

			/*	if less then 16 M (4k * 4k),
			 *	then put an artificial wait.
			 */
#ifdef ELIMINATE_PATCH_FILE
#else
			if ( pfmpT->PgnoMost() <= 4096 )
				UtilSleep( rand() % 1000 );
#endif			

#else	//	DEBUG
			Call( ErrLGBKReadPages(
				m_rgrhf[irhf].ifmp,
				pvPageMin,
				cpage,
				&cbActual ) );
#endif	//	DEBUG

			// set the data read (used just to check at the end if all was read.
			m_rgrhf[irhf].ib += cbActual;
#ifdef ELIMINATE_PATCH_FILE
			Assert( (m_rgrhf[irhf].ib / g_cbPage) == (rgfmp[ m_rgrhf[irhf].ifmp ].PgnoCopyMost() + cpgDBReserved )
					|| ( (rgfmp[ m_rgrhf[irhf].ifmp ].PgnoCopyMost() == rgfmp[ m_rgrhf[irhf].ifmp ].PgnoMost() ) 
						&& (m_rgrhf[irhf].ib / g_cbPage) == (rgfmp[ m_rgrhf[irhf].ifmp ].PgnoCopyMost() + cpgDBReserved + 1) ) );
#else // ELIMINATE_PATCH_FILE
			Assert( (m_rgrhf[irhf].ib / g_cbPage) == (rgfmp[ m_rgrhf[irhf].ifmp ].PgnoCopyMost() + cpgDBReserved ) );
#endif // ELIMINATE_PATCH_FILE
			}

		if ( pcbActual )
			{
			*pcbActual = cbActual;
			}
		}

HandleError:

	if ( fInTransaction )
		{
		CallSx ( ErrDIRRollback( m_ppibBackup ), JET_errRollbackError );
		fInTransaction = fFalse;
		}

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];
	
		sprintf( sz, "** ReadFile (%d) ", err );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		if ( m_fDBGTraceBR > 1 )
			DBGBRTrace( szLGDBGPageList );		
		DBGBRTrace( "\n" );
		}
	if (szLGDBGPageList)
		{
		OSMemoryHeapFree( (void *)szLGDBGPageList );
		szLGDBGPageList = NULL;
		}
#endif
	
	if ( m_rgrhf[irhf].fDatabase && pfmpT->ErrPatch() < JET_errSuccess )		//lint !e644
		err = pfmpT->ErrPatch();

	if ( err < 0 )
		{
		char szError[32];
		Assert ( m_rgrhf[irhf].szFileName );
		
		const CHAR	* rgszT[] = { szError, m_rgrhf[irhf].szFileName };			

		sprintf( szError, "%d", err );						
		
		// if they try to backup a unmounted database or we get an error on one database
		// we will not stop the backup
		// on all other errors (logs, patch files) we stop the backup of the instance
		if ( backupStateDatabases == m_fBackupStatus )
			{	
			FMP::AssertVALIDIFMP( m_rgrhf[irhf].ifmp );
			
			pfmpT = rgfmp + m_rgrhf[irhf].ifmp;
			Assert ( pfmpT );
			Assert ( pfmpT->FInBackupSession() );
			pfmpT->ResetInBackupSession();

			if ( pfmpT->Ppatchhdr() )
				{
				OSMemoryPageFree( pfmpT->Ppatchhdr() );
				pfmpT->SetPpatchhdr( NULL );
				}
	
#ifdef ELIMINATE_PATCH_FILE
#else
			// delete the created patch file
			CHAR  	szPatch[IFileSystemAPI::cchPathMax];
			
			LGIGetPatchName( m_pinst->m_pfsapi, szPatch, pfmpT->SzDatabaseName()  );
#endif

			UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,	
				BACKUP_ERROR_FOR_ONE_DATABASE, 2, rgszT, 0, NULL, m_pinst );

			CallS( ErrLGBKCloseFile( hfFile ) );

#ifdef ELIMINATE_PATCH_FILE
#else
			// delete the patch now, that we closed the patch file
			CallSRFS( m_pinst->m_pfsapi->ErrFileDelete( szPatch ), ( JET_errFileAccessDenied, 0 ) );
#endif
			
			Assert( m_fBackupInProgress );
			}
		else
			{
			UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,	
				BACKUP_ERROR_READ_FILE, 2, rgszT, 0, NULL, m_pinst );
			
			CallS( ErrLGBKIExternalBackupCleanUp( pfsapi, err ) );
			Assert( !m_fBackupInProgress );
			}
		}

	return err;
	}


#ifdef ELIMINATE_PATCH_FILE
#else
VOID LGIClosePatchFile( FMP *pfmp )
	{
	IFileAPI *pfapiT = pfmp->PfapiPatch();
	
	for (;;)
		{
		pfmp->CritLatch().Enter();
		
		if ( pfmp->CPatchIO() )
			{
			pfmp->CritLatch().Leave();
			UtilSleep( 1 );
			continue;
			}
		else
			{
			/*	no need for buffer manager to make extra copy from now on
			/**/
			pfmp->SetPgnoMost( 0 );
			pfmp->SetPgnoCopyMost( 0 );
			pfmp->ResetFCopiedPatchHeader();
			pfmp->SetPfapiPatch( NULL );
			pfmp->CritLatch().Leave();
			break;
			}
		}

	delete pfapiT;
	}
#endif	//	ELIMINATE_PATCH_FILE


ERR ISAMAPI ErrIsamCloseFile( JET_INSTANCE jinst,  JET_HANDLE hfFile )
	{
	INST *pinst = (INST*) jinst;
	return pinst->m_plog->ErrLGBKCloseFile( hfFile );
	}
	
ERR LOG::ErrLGBKCloseFile( JET_HANDLE hfFile )
	{
	INT		irhf = (INT)hfFile;
	IFMP	ifmpT = ifmpMax;

	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}

	if ( irhf < 0 ||
		irhf >= m_crhfMac ||
		!m_rgrhf[irhf].fInUse )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	/*	check if handle if for database file or non-database file.
	/*	if handle is for database file, then terminate patch file
	/*	support and release recovery handle for file.
	/*
	/*	if handle is for non-database file, then close file handle
	/*	and release recovery handle for file.
	/**/
	if ( m_rgrhf[irhf].fDatabase )
		{
		Assert( backupStateDatabases == m_fBackupStatus );
		Assert( !m_rgrhf[irhf].pfapi );
		FMP::AssertVALIDIFMP( m_rgrhf[irhf].ifmp );
		
		ifmpT = m_rgrhf[irhf].ifmp;

#ifdef ELIMINATE_PATCH_FILE
		rgfmp[ifmpT].SetPgnoMost( 0 );
		rgfmp[ifmpT].SetPgnoCopyMost( 0 );
		rgfmp[ifmpT].ResetFCopiedPatchHeader();
#else
		LGIClosePatchFile( &rgfmp[ifmpT] );
#endif

		// Assert no longer valid as we reset this flag defore
		// calling CloseFile in ReadFile on error
		
		// check database as involved in an external backup
		// Assert ( rgfmp[ifmpT].FInBackupSession() );		

#ifdef DEBUG
		if ( m_fDBGTraceBR )
			{
			const int cbFillBuffer = 64;
			char szTrace[cbFillBuffer + 1];
			szTrace[ cbFillBuffer ] = '\0';
			_snprintf( szTrace, cbFillBuffer, "STOP COPY DB" );
			CallS( ErrLGTrace( ppibNil, szTrace ) );
			}
#endif

#ifdef MINIMAL_FUNCTIONALITY
#else
		// if the scrub object is left because they haven't read
		// all the pages from the db, hence we haven't stopped 
		// the scrubbing at the end of the ReadFile phase
		if( m_pscrubdb )
			{
			CallS( m_pscrubdb->ErrTerm() );	// may fail with JET_errOutOfMemory. what to do?
			delete m_pscrubdb;
			m_pscrubdb = NULL;
			}
#endif

		CallS( ErrDBCloseDatabase( m_ppibBackup, ifmpT, 0 ) );
		}
	else
		{
		Assert ( ( backupStateLogsAndPatchs == m_fBackupStatus && !m_rgrhf[irhf].fIsSLVFile ) ||
				( backupStateDatabases == m_fBackupStatus && m_rgrhf[irhf].fIsSLVFile ) );
				
		if ( m_rgrhf[irhf].fIsSLVFile )
			{			
#ifdef DISABLE_SLV
#else
			delete m_rgrhf[irhf].pSLVVerifier;
			m_rgrhf[irhf].pSLVVerifier = pNil;

			CallS( ErrDBCloseDatabaseBySLV( m_ppibBackup, m_rgrhf[irhf].ifmp ) );

			Assert( !m_rgrhf[irhf].pfapi );
#endif			
			}
		else
			{
			delete m_rgrhf[irhf].pfapi;
			m_rgrhf[irhf].pfapi = NULL;
			}
			
		if ( m_rgrhf[irhf].fIsLog )
			{
			delete m_rgrhf[irhf].pLogVerifier;
			m_rgrhf[irhf].pLogVerifier = pNil;
			}
		}

	// report end backup of file
		{
		char szSizeRead[32];
		char szSizeAll[32];
		
		Assert ( m_rgrhf[irhf].szFileName );
		
		const char * rgszT[] = { m_rgrhf[irhf].szFileName, szSizeRead, szSizeAll };			

		if ( m_rgrhf[irhf].ib == m_rgrhf[irhf].cb )
			{
			// if all file read, report just EDB ans STM files
			if ( m_rgrhf[irhf].fDatabase || m_rgrhf[irhf].fIsSLVFile )
				{
				UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY, BACKUP_FILE_STOP_OK, 1, rgszT, 0, NULL, m_pinst );
				}
			}
		else
		// if not all file was read, issue a warning
			{
			sprintf( szSizeRead, "%I64u", m_rgrhf[irhf].ib );
			sprintf( szSizeAll, "%I64u", m_rgrhf[irhf].cb );
			
			UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY, BACKUP_FILE_STOP_BEFORE_END, 3, rgszT, 0, NULL, m_pinst );
			}

		if ( m_rgrhf[irhf].fDatabase || m_rgrhf[irhf].fIsSLVFile )
			{
			const int cbFillBuffer = 64 + IFileSystemAPI::cchPathMax;
			char szTrace[cbFillBuffer + 1];
			szTrace[ cbFillBuffer ] = '\0';
			_snprintf( szTrace, cbFillBuffer, "Stop backup file %s", m_rgrhf[irhf].szFileName );
			(void) ErrLGTrace( m_ppibBackup, szTrace);
			}
		
		}	

	OSMemoryHeapFree( m_rgrhf[irhf].szFileName );
	
	/*	reset backup file handle and free
	/**/
	Assert( m_rgrhf[irhf].fInUse );
	
	m_rgrhf[irhf].fInUse			= fFalse;
	m_rgrhf[irhf].fDatabase			= fFalse;
	m_rgrhf[irhf].fIsLog			= fFalse;
	m_rgrhf[irhf].pLogVerifier		= pNil;
	m_rgrhf[irhf].pSLVVerifier		= pNil;
	m_rgrhf[irhf].pfapi				= NULL;
	m_rgrhf[irhf].fIsSLVFile		= fFalse;
	m_rgrhf[irhf].ifmp				= ifmpMax;
	m_rgrhf[irhf].ib				= 0;
	m_rgrhf[irhf].cb				= 0;
	m_rgrhf[irhf].szFileName 		= NULL;

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];
		
		sprintf( sz, "** CloseFile (%d) - %ld Bytes.\n", 0, m_cbDBGCopied );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif
	
	return JET_errSuccess;
	}

ERR LOG::ErrLGBKIPrepareLogInfo(	IFileSystemAPI *const 	pfsapi )
	{
	ERR		err = JET_errSuccess;
	INT		irhf;
	CHAR	szPathJetChkLog[IFileSystemAPI::cchPathMax];

	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}
	else if ( m_fStopBackup )
		{
		return ErrERRCheck( JET_errBackupAbortByServer );
		}

	/*	all backup files must be closed
	/**/
	for ( irhf = 0; irhf < m_crhfMac; irhf++ )
		{
		if ( m_rgrhf[irhf].fInUse )
			{
			return ErrERRCheck( JET_errInvalidBackupSequence );
			}
		}

	Assert ( backupStateDatabases == m_fBackupStatus || backupStateLogsAndPatchs == m_fBackupStatus );


	/*	begin new log file and compute log backup parameters
	/**/
	if ( !m_fBackupBeginNewLogFile )
		{
		Call( ErrLGBKPrepareLogFiles(
			pfsapi,
			m_fBackupFull ?0: (m_fBackupSnapshot? JET_bitBackupSnapshot:JET_bitBackupIncremental ),
			m_szLogFilePath,
			szPathJetChkLog,
			NULL ) );
		}
		
HandleError:
	return err;
	}
	
ERR LOG::ErrLGBKIGetLogInfo(	IFileSystemAPI *const 	pfsapi,
								const ULONG					ulGenLow,
								const ULONG					ulGenHigh,
								const BOOL					fIncludePatch,
								VOID 						*pv,
								ULONG 						cbMax,
								ULONG 						*pcbActual,
								JET_LOGINFO 				*pLogInfo )
	{
	ERR			err = JET_errSuccess;
	LONG		lT;
	CHAR		*pch = NULL;
	CHAR		*pchT;
	ULONG		cbActual;
	CHAR		szDirT[IFileSystemAPI::cchPathMax];
	CHAR		szFNameT[IFileSystemAPI::cchPathMax];
	CHAR		szExtT[IFileSystemAPI::cchPathMax];
	CHAR  		szT[IFileSystemAPI::cchPathMax];
	CHAR  		szFullLogFilePath[IFileSystemAPI::cchPathMax];

	/*	make full path from log file path, including trailing back slash
	/**/
	CallR( pfsapi->ErrPathComplete( m_szLogFilePath, szFullLogFilePath ) );
	
#ifdef DEBUG
	if ( m_fDBGTraceBR )
		DBGBRTrace("** Begin GetLogInfo.\n" );
#endif

	Assert( FOSSTRTrailingPathDelimiter( szFullLogFilePath ) ||
			strlen( szFullLogFilePath ) + 1 + 1 <= sizeof( szFullLogFilePath ) );
	OSSTRAppendPathDelimiter( szFullLogFilePath, fTrue );

	Assert ( m_fBackupBeginNewLogFile );
	
	/*	get cbActual for log file and patch files.
	/**/
	cbActual = 0;

	CallS( pfsapi->ErrPathParse( szFullLogFilePath, szDirT, szFNameT, szExtT ) );
	for ( lT = ulGenLow; lT < ulGenHigh; lT++ )
		{
		LGSzFromLogId( szFNameT, lT );
		LGMakeName( pfsapi, szT, szDirT, szFNameT, (CHAR *)szLogExt );
		cbActual += (ULONG) strlen( szT ) + 1;
		}

	if ( fIncludePatch )
		{
		/*	put all the patch file info
		/**/
		for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			IFMP 	ifmp = m_pinst->m_mpdbidifmp[ dbid ];
			if ( ifmp >= ifmpMax )
				continue;

			FMP *	pfmp = &rgfmp[ifmp];

			if ( pfmp->FInUse()
//				&& pfmp->CpagePatch() > 0
				&& pfmp->FAttached()
				&& pfmp->FInBackupSession() )
				{
				Assert( !pfmp->FSkippedAttach() );
				Assert( !pfmp->FDeferredAttach() );

				/*	database with patch file must be loggable
				/**/

				Assert( pfmp->FLogOn() );
				LGIGetPatchName( m_pinst->m_pfsapi, szT, pfmp->SzDatabaseName() );
				cbActual += (ULONG) strlen( szT ) + 1;
				}
			}
		}
	cbActual++;

	pch = static_cast<CHAR *>( PvOSMemoryHeapAlloc( cbActual ) );
	if ( pch == NULL )
		{
		Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
		}

	/*	return list of log files and patch files
	/**/
	pchT = pch;

	CallS( pfsapi->ErrPathParse( szFullLogFilePath, szDirT, szFNameT, szExtT ) );
	for ( lT = ulGenLow; lT < ulGenHigh; lT++ )
		{
		LGSzFromLogId( szFNameT, lT );
		LGMakeName( pfsapi, szT, szDirT, szFNameT, (CHAR *)szLogExt );
		Assert( pchT + strlen( szT ) + 1 < pchT + cbActual );
		strcpy( pchT, szT );
		pchT += strlen( szT );
		Assert( *pchT == 0 );
		pchT++;
		}

	// on snapshot we don't have patch file
	if ( fIncludePatch )
		{
		/*	copy all the patch file info
		/**/
		for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			IFMP 	ifmp = m_pinst->m_mpdbidifmp[ dbid ];
			if ( ifmp >= ifmpMax )
				continue;

			FMP *	pfmp = &rgfmp[ifmp];

			if ( pfmp->FInUse()
				&& pfmp->FAttached()
				&& pfmp->FInBackupSession() )
				{
				Assert( !pfmp->FSkippedAttach() );
				Assert( !pfmp->FDeferredAttach() );

				LGIGetPatchName( m_pinst->m_pfsapi, szT, pfmp->SzDatabaseName() );
				Assert( pchT + strlen( szT ) + 1 < pchT + cbActual );
				strcpy( pchT, szT );
				pchT += strlen( szT );
				Assert( *pchT == 0 );
				pchT++;

				/*	Write out patch file header.
				 */
				DBFILEHDR_FIX *	const	pdbfilehdr	= (DBFILEHDR_FIX *)pfmp->Ppatchhdr();
				Assert( NULL != pdbfilehdr );

#ifdef ELIMINATE_PATCH_FILE
#else
				memcpy( pdbfilehdr, pfmp->Pdbfilehdr(), g_cbPage );

				BKINFO * const			pbkinfo		= &pdbfilehdr->bkinfoFullCur;
				pbkinfo->le_lgposMark = m_lgposFullBackupMark;
				pbkinfo->logtimeMark = m_logtimeFullBackupMark;
				pbkinfo->le_genLow = m_lgenCopyMic;
				pbkinfo->le_genHigh = m_lgenCopyMac - 1;
#endif

				Call( ErrUtilWriteShadowedHeader( m_pinst->m_pfsapi, szT, fFalse, (BYTE*)pdbfilehdr, g_cbPage ) );
				}
			}
		}
	Assert( pchT == pch + cbActual - 1 );
	*pchT = 0;

	/*	return cbActual
	/**/
	if ( pcbActual != NULL )
		{
		*pcbActual = cbActual;
		}

	/*	return data
	/**/
	if ( pv != NULL )
		UtilMemCpy( pv, pch, min( cbMax, cbActual ) );

HandleError:

	if ( pch != NULL )
		{
		OSMemoryHeapFree( pch );
		pch = NULL;
		}
	
#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];
		CHAR *pch;

		if ( err >= 0 )
			{
			sprintf( sz, "   Log Info with cbActual = %d and cbMax = %d :\n", cbActual, cbMax );
			Assert( strlen( sz ) <= sizeof( sz ) - 1 );
			DBGBRTrace( sz );

			if ( pv != NULL )
				{
				pch = static_cast<CHAR *>( pv );

				do {
					if ( strlen( pch ) != 0 )
						{
						sprintf( sz, "     %s\n", pch );
						Assert( strlen( sz ) <= sizeof( sz ) - 1 );
						DBGBRTrace( sz );
						pch += strlen( pch );
						}
					pch++;
					} while ( *pch );
				}
			}

		sprintf( sz, "   End GetLogInfo (%d).\n", err );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif

	if ( err < 0 )
		{
		CallS( ErrLGBKIExternalBackupCleanUp( pfsapi, err ) );
		Assert( !m_fBackupInProgress );
		}
	else
		{
		if ( NULL != pLogInfo )
			{
			Assert ( pLogInfo->cbSize == sizeof( JET_LOGINFO ) );
			
			pLogInfo->ulGenLow = ulGenLow;
			pLogInfo->ulGenHigh = ulGenHigh - 1;
			Assert ( JET_BASE_NAME_LENGTH == strlen( m_szBaseName ) );
			strcpy( pLogInfo->szBaseName, m_szBaseName );
			}
			
		Assert ( backupStateDatabases == m_fBackupStatus || backupStateLogsAndPatchs == m_fBackupStatus );
		// switch to the LogAndPatch status
		m_fBackupStatus = backupStateLogsAndPatchs;
		}
	return err;
	}


ERR ISAMAPI ErrIsamGetLogInfo( JET_INSTANCE jinst,  VOID *pv, ULONG cbMax, ULONG *pcbActual, JET_LOGINFO *pLogInfo )
	{
	INST *pinst = (INST *)jinst;
	return pinst->m_plog->ErrLGBKGetLogInfo( pinst->m_pfsapi, pv, cbMax, pcbActual, pLogInfo, fFalse );
	}
	
ERR LOG::ErrLGBKGetLogInfo(	IFileSystemAPI *const 	pfsapi,
							VOID 						*pv,
							ULONG 						cbMax,
							ULONG 						*pcbActual,
							JET_LOGINFO 				*pLogInfo,
							const BOOL					fIncludePatch )
	{
	ERR		err = JET_errSuccess;

	CallR ( ErrLGBKIPrepareLogInfo( pfsapi ) );

	Assert ( m_lgenCopyMic );
	Assert ( m_lgenCopyMac );
	Assert ( m_lgenCopyMic <= m_lgenCopyMac );
	return ErrLGBKIGetLogInfo( pfsapi, m_lgenCopyMic, m_lgenCopyMac, fIncludePatch, pv, cbMax, pcbActual, pLogInfo );
	}

	
ERR ISAMAPI ErrIsamGetTruncateLogInfo( JET_INSTANCE jinst,  VOID *pv, ULONG cbMax, ULONG *pcbActual )
	{
	INST *pinst = (INST *)jinst;
	return pinst->m_plog->ErrLGBKGetTruncateLogInfo( pinst->m_pfsapi, pv, cbMax, pcbActual );
	}

ERR LOG::ErrLGBKGetTruncateLogInfo(	IFileSystemAPI *const 	pfsapi,
									VOID 						*pv,
									ULONG 						cbMax,
									ULONG 						*pcbActual )
	{
	ERR		err = JET_errSuccess;

	CallR ( ErrLGBKIPrepareLogInfo( pfsapi ) );

	Assert ( m_lgenDeleteMic <= m_lgenDeleteMac );
	
	return ErrLGBKIGetLogInfo( pfsapi, m_lgenDeleteMic, m_lgenDeleteMac, fFalse, pv, cbMax, pcbActual, NULL);	
	}


ERR ISAMAPI ErrIsamTruncateLog( JET_INSTANCE jinst )
	{
	INST *pinst = (INST *)jinst;
	return pinst->m_plog->ErrLGBKTruncateLog( pinst->m_pfsapi );
	}
	
ERR LOG::ErrLGBKTruncateLog( IFileSystemAPI *const pfsapi )
	{
	ERR		err = JET_errSuccess;
	CHAR	szFNameT[IFileSystemAPI::cchPathMax];
	CHAR	szDeleteFile[IFileSystemAPI::cchPathMax];
	LONG 	cDeleted = 0;

	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}
	else if ( m_fStopBackup )
		{
		return ErrERRCheck( JET_errBackupAbortByServer );
		}

	//	all backup files must be closed
	for ( UINT irhf = 0; irhf < m_crhfMac; irhf++ )
		{
		if ( m_rgrhf[irhf].fInUse )
			{
			return ErrERRCheck( JET_errInvalidBackupSequence );
			}
		}

	// switch to the LogAndPatch status if not already there
	Assert( backupStateDatabases == m_fBackupStatus			//	this state is possible via JetBackup( NULL )
		|| backupStateLogsAndPatchs == m_fBackupStatus );
	m_fBackupStatus = backupStateLogsAndPatchs;

	if ( m_lgenDeleteMic >= m_lgenDeleteMac )
		{
		//	nothing to delete

		UtilReportEvent(
				eventInformation,
				LOGGING_RECOVERY_CATEGORY,
				BACKUP_NO_TRUNCATE_LOG_FILES,
				0,
				NULL,
				0,
				NULL,
				m_pinst );
		}	

	else
		{
		//	report the deletion range and then perform the file deletions

		CHAR 			szFullLogNameDeleteMic[IFileSystemAPI::cchPathMax];
		CHAR 			szFullLogNameDeleteMac[IFileSystemAPI::cchPathMax];
		const char * 	rgszT[] = { szFullLogNameDeleteMic, szFullLogNameDeleteMac };			
		CHAR 			szFullPathName[IFileSystemAPI::cchPathMax];
		
		if ( JET_errSuccess > m_pinst->m_pfsapi->ErrPathComplete( m_szLogFilePath, szFullPathName ) )
			{
			strcpy( szFullPathName, "" );
			}
				

		LGSzFromLogId( szFNameT, m_lgenDeleteMic );
		LGMakeName( m_pinst->m_pfsapi, szFullLogNameDeleteMic, szFullPathName, szFNameT, (CHAR *)szLogExt );

		Assert( m_lgenDeleteMic < m_lgenDeleteMac );
		LGSzFromLogId( szFNameT, m_lgenDeleteMac - 1);
		LGMakeName( m_pinst->m_pfsapi, szFullLogNameDeleteMac, szFullPathName, szFNameT, (CHAR *)szLogExt );
				
		UtilReportEvent(
				eventInformation,
				LOGGING_RECOVERY_CATEGORY,
				BACKUP_TRUNCATE_LOG_FILES,
				2,
				rgszT,
				0,
				NULL,
				m_pinst );


		/*	delete logs.  Note that log files must be deleted in
		/*	increasing number order.
		/**/
		
		for ( LONG lT = m_lgenDeleteMic; lT < m_lgenDeleteMac; lT++ )
			{
			LGSzFromLogId( szFNameT, lT );
			LGMakeName( pfsapi, szDeleteFile, m_szLogFilePath, szFNameT, (CHAR *)szLogExt );
			err = pfsapi->ErrFileDelete( szDeleteFile );
			if ( err != JET_errSuccess )
				{
				/*	must maintain a continuous log file sequence,
				/*	No need to clean up (reset m_fBackupInProgress etc) if fails.
				/**/
				break;
				}
			cDeleted++;
			}
		}


#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];
	
		sprintf( sz, "** TruncateLog (%d) %d - %d.\n", err, m_lgenDeleteMic, m_lgenDeleteMac );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif

	const INT	cbFillBuffer	= 128;
	char		szTrace[cbFillBuffer + 1];

	szTrace[ cbFillBuffer ] = '\0';
	_snprintf( szTrace, cbFillBuffer, "Truncate %d logs starting with 0x%05X (error %d)", cDeleted, m_lgenDeleteMic, err );

	const ERR	errT	= ErrLGTrace( m_ppibBackup, szTrace );

	return ( JET_errSuccess == err ? errT : err );
	}


ERR ISAMAPI ErrIsamEndExternalBackup(  JET_INSTANCE jinst, JET_GRBIT grbit )
	{
	INST *pinst = (INST *)jinst;

	Assert ( grbit == JET_bitBackupEndNormal || grbit == JET_bitBackupEndAbort );

	ERR err;
	if ( JET_bitBackupEndNormal == grbit )
		{
		err = JET_errSuccess;
		}
	else
		{
		err = ErrERRCheck( errBackupAbortByCaller );
		}
	return pinst->m_plog->ErrLGBKIExternalBackupCleanUp( pinst->m_pfsapi, err );
	}


ERR LOG::ErrLGBKIExternalBackupCleanUp( IFileSystemAPI *const pfsapi, ERR error )
	{
	BOOL	fNormal		= ( JET_errSuccess == error );
	ERR		err;
	DBID	dbid;

	/*  determine if we are scrubbing the database
	/**/
	BOOL	fScrub		= m_fScrubDB;


	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}

	if ( fNormal )
		{
		if ( m_fStopBackup )
			{
			//	premature termination specifically requested
			//
			fNormal = fFalse;
			error = ErrERRCheck( JET_errBackupAbortByServer );
			}
		else if ( m_fBackupStatus == backupStateDatabases )
			{
			// if backup client calls BackupEnd without error
			// before logs are read, force the backup as "with error"
			//
			fNormal = fFalse;
			error = ErrERRCheck( errBackupAbortByCaller );
			}
		}

	/*	delete patch files, if present, for all databases.
	/**/
	//	first close the patch file if needed
	for ( INT irhf = 0; irhf < crhfMax; ++irhf )
		{
		if ( m_rgrhf[irhf].fInUse && m_rgrhf[irhf].pfapi )
			{
			Assert ( !m_rgrhf[irhf].fIsSLVFile );
			Assert ( !m_rgrhf[irhf].fDatabase );
			delete m_rgrhf[irhf].pfapi;
			m_rgrhf[irhf].pfapi = NULL;
			}					
		}

	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP 	ifmp = m_pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;

		FMP *pfmp = &rgfmp[ifmp];


		if ( pfmp->FInUse()
			&& pfmp->FLogOn()
			&& pfmp->FAttached()
			&& pfmp->FInBackupSession() )
			{			
			Assert( !pfmp->FSkippedAttach() );
			Assert( !pfmp->FDeferredAttach() );


			// on snapshot, sync flush the header
			// UNDONE: we still have a problem if we crash between stop snapshot log record and writing the header
			// or if we fail writing it
		 	if ( pfmp->FDuringSnapshot() )
		 		{
			 	CallS ( pfmp->ErrSnapshotStop( pfsapi ) );
			 	CallS ( ErrDBCloseDatabase( m_ppibBackup, ifmp, 0 ) );
				}

			// only full backup is using patch files
			if ( m_fBackupFull )
				{
#ifdef ELIMINATE_PATCH_FILE
				pfmp->SetPgnoMost( 0 );
				pfmp->SetPgnoCopyMost( 0 );
				pfmp->ResetFCopiedPatchHeader();
#else
				CHAR  	szT[ IFileSystemAPI::cchPathMax ];

				LGIGetPatchName( m_pinst->m_pfsapi, szT, pfmp->SzDatabaseName()  );
				if ( pfmp->PfapiPatch() )
					{
					LGIClosePatchFile( pfmp );
					Assert( !pfmp->PfapiPatch() );
					}
				ERR errAux;
				errAux = m_pinst->m_pfsapi->ErrFileDelete( szT );
				if ( JET_errFileNotFound == errAux )
					{
					errAux = JET_errSuccess;
					}
				CallSRFS( errAux, ( JET_errFileAccessDenied, 0 ) );
#endif	//	ELIMINATE_PATCH_FILE
				}

			m_critCheckpoint.Enter();
			
			if ( fNormal )
				{
				if ( m_fBackupFull )
					{
					/*	set up database file header accordingly.
					 */
					Assert( pfmp->Ppatchhdr() );

					PATCH_HEADER_PAGE * ppatchHdr = pfmp->Ppatchhdr();

#ifdef ELIMINATE_PATCH_FILE
					pfmp->Pdbfilehdr()->bkinfoFullPrev = ppatchHdr->bkinfo;

					// in the patch trailier, genMax is what is needed
					// we don't know that the backup set has more than this, up to m_lgenCopyMac - 1
					// so we update the db header with this
					Assert( pfmp->Pdbfilehdr()->bkinfoFullPrev.le_genLow );
					Assert( pfmp->Pdbfilehdr()->bkinfoFullPrev.le_genHigh <=  m_lgenCopyMac - 1 );
					pfmp->Pdbfilehdr()->bkinfoFullPrev.le_genHigh =  m_lgenCopyMac - 1;
#else
					pfmp->Pdbfilehdr()->bkinfoFullPrev = ppatchHdr->bkinfoFullCur;
#endif

					Assert(	pfmp->Pdbfilehdr()->bkinfoFullCur.le_genLow == 0 );
					memset( &pfmp->Pdbfilehdr()->bkinfoIncPrev, 0, sizeof( BKINFO ) );

					// clean the snapshot info after a normal full backup
					memset( &(pfmp->Pdbfilehdr()->bkinfoSnapshotCur), 0, sizeof( BKINFO ) );
					}
				else  if ( m_fBackupSnapshot )
				 	{					
					Assert( !pfmp->Ppatchhdr() );					
					Assert( pfmp->Pdbfilehdr() );	

					BKINFO * pbkinfo;
					
					pbkinfo = &(pfmp->Pdbfilehdr()->bkinfoFullPrev);
					pbkinfo->le_lgposMark = m_lgposFullBackupMark;
					pbkinfo->logtimeMark = m_logtimeFullBackupMark;
					pbkinfo->le_genLow = m_lgenCopyMic;
					pbkinfo->le_genHigh = m_lgenCopyMac - 1;

					Assert(	pfmp->Pdbfilehdr()->bkinfoFullCur.le_genLow == 0 );
					memset( &pfmp->Pdbfilehdr()->bkinfoIncPrev, 0, sizeof( BKINFO ) );

					}
				else
					{
					pfmp->Pdbfilehdr()->bkinfoIncPrev.le_lgposMark = m_lgposIncBackup;
					pfmp->Pdbfilehdr()->bkinfoIncPrev.logtimeMark = m_logtimeIncBackup;					
					pfmp->Pdbfilehdr()->bkinfoIncPrev.le_genLow = m_lgenCopyMic;
					pfmp->Pdbfilehdr()->bkinfoIncPrev.le_genHigh = m_lgenCopyMac - 1;
					}
				}
				
			m_critCheckpoint.Leave();

			if ( pfmp->Ppatchhdr() )
				{
				OSMemoryPageFree( pfmp->Ppatchhdr() );
				pfmp->SetPpatchhdr( NULL );
				}

#if !defined( MINIMAL_FUNCTIONALITY ) && !defined( DISABLE_SLV )

			// try to start SLV scrub task
			if ( fScrub && fNormal && pfmp->FSLVAttached() && ( m_fBackupFull || m_fBackupSnapshot ) )
				{
				ERR errPostScrubSLV = JET_errSuccess;

				FMP::AssertVALIDIFMP( ifmp );
				
				SCRUBSLVTASK * pSCRUBSLVTASK = new SCRUBSLVTASK( ifmp );

				if( NULL == pSCRUBSLVTASK )
					{
					errPostScrubSLV = ErrERRCheck( JET_errOutOfMemory );
					}
				else
					{
					errPostScrubSLV = m_pinst->Taskmgr().ErrTMPost( TASK::DispatchGP, pSCRUBSLVTASK );
					if ( errPostScrubSLV < JET_errSuccess )
						{
						delete pSCRUBSLVTASK;
						}
					}
					
				// UNDONE: eventlog error but continue
				
				}

#endif	//	!defined( MINIMAL_FUNCTIONALITY ) && !defined( DISABLE_SLV )

			pfmp->ResetInBackupSession();
			Assert ( !pfmp->FDuringSnapshot() );
			
			}
		Assert( ! pfmp->FInBackupSession() );
		}


	/*	clean up rhf entries.
	 */
	
		{
		for ( INT irhf = 0; irhf < crhfMax; ++irhf )
			{
			if ( m_rgrhf[irhf].fInUse )
				{
				if ( m_rgrhf[irhf].fDatabase )
					{
					const IFMP ifmp = m_rgrhf[irhf].ifmp;
					FMP::AssertVALIDIFMP( ifmp );
					// patch file already been closed
					Assert( !rgfmp[ ifmp ].PfapiPatch() );
					CallS( ErrDBCloseDatabase( m_ppibBackup, ifmp, 0 ) );
					}
				else if ( m_rgrhf[irhf].fIsSLVFile )
					{
#ifdef DISABLE_SLV
#else
					delete m_rgrhf[irhf].pSLVVerifier;
					m_rgrhf[irhf].pSLVVerifier = pNil;

					CallS( ErrDBCloseDatabaseBySLV( m_ppibBackup, m_rgrhf[irhf].ifmp ) );
#endif
					}

				// we close those files defore deleting the patch files
				Assert( NULL == m_rgrhf[irhf].pfapi );
					
				if ( m_rgrhf[irhf].fIsLog )
					{
					delete m_rgrhf[irhf].pLogVerifier;
					m_rgrhf[irhf].pLogVerifier = pNil;
					}
				m_rgrhf[irhf].fInUse = fFalse;

				OSMemoryHeapFree ( m_rgrhf[irhf].szFileName );
				m_rgrhf[irhf].szFileName = NULL;

				}
			}
		}

	/*	Log error event
	 */
	if ( fNormal )
		{
		CallS( error );

		UtilReportEvent(
				eventInformation,
				LOGGING_RECOVERY_CATEGORY, 	
				STOP_BACKUP_INSTANCE_ID,
				0,
				NULL,
				0,
				NULL,
				m_pinst );

		// write the db header so that the info we updated is written.
		// otherwise a crash before other db header updates
		// may result in backup information lost.

		ERR		errUpdate;
		BOOL	fSkippedAttachDetach;
		LOGTIME tmEmpty;
		memset( &tmEmpty, 0, sizeof(LOGTIME) );
		
		m_critCheckpoint.Enter();
		errUpdate = ErrLGIUpdateGenRequired( pfsapi, 0, 0, tmEmpty, &fSkippedAttachDetach );
		m_critCheckpoint.Leave();

		// on error, report a Warning and continue as the backup is OK from it's point of view.
		if ( errUpdate < JET_errSuccess )
			{
			char	sz1T[32];
			const char	*rgszT[1];
		
			sprintf( sz1T, "%d", errUpdate );
			rgszT[0] = sz1T;
			
			UtilReportEvent( eventWarning, LOGGING_RECOVERY_CATEGORY, BACKUP_ERROR_INFO_UPDATE, 1, rgszT, 0 , NULL, m_pinst );
			}
		else
			{
			Assert( !fSkippedAttachDetach );
			}		
		}
	// special messages for frequent error cases
	else if ( errBackupAbortByCaller == error )
		{
		UtilReportEvent(
				eventError,
				LOGGING_RECOVERY_CATEGORY,
				STOP_BACKUP_ERROR_ABORT_BY_CALLER_INSTANCE_ID,
				0,
				NULL,
				0,
				NULL,
				m_pinst );		
		}
	else if ( JET_errBackupAbortByServer == error )
		{
		UtilReportEvent(
				eventError,
				LOGGING_RECOVERY_CATEGORY, 
				STOP_BACKUP_ERROR_ABORT_BY_SERVER_INSTANCE_ID,
				0,
				NULL,
				0,
				NULL,
				m_pinst );		
		}
	else
		{	
		char		sz1T[32];
		const UINT	csz			= 1;
		const char	*rgszT[csz];

		sprintf( sz1T, "%d", error );
		rgszT[0] = sz1T;

		UtilReportEvent(
				eventError,
				LOGGING_RECOVERY_CATEGORY,
				STOP_BACKUP_ERROR_INSTANCE_ID,
				csz,
				rgszT,
				0,
				NULL,
				m_pinst );
		}

#ifdef MINIMAL_FUNCTIONALITY
#else
	if( m_fScrubDB && m_pscrubdb )
		{
		CallS( m_pscrubdb->ErrTerm() );	// may fail with JET_errOutOfMemory. what to do?
		delete m_pscrubdb;
		m_pscrubdb = NULL;
		}
#endif

	m_fBackupInProgress = fFalse;
	m_fStopBackup = fFalse;
	m_fBackupStatus = backupStateNotStarted;
	m_fBackupSnapshot = fFalse;

	err = JET_errSuccess;				

	{
	const int cbFillBuffer = 64;
	char szTrace[cbFillBuffer + 1];
	szTrace[ cbFillBuffer ] = '\0';
	_snprintf( szTrace, cbFillBuffer, "EXT BACKUP STOP (err %d)", err );
	(void) ErrLGTrace( m_ppibBackup, szTrace);
	}
	
#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];
	
		sprintf( sz, "** EndExternalBackup (%d).\n", err );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif
	
	return err;
	}


ERR LOG::ErrLGRSTBuildRstmapForSoftRecovery( const JET_RSTMAP * const rgjrstmap, const int cjrstmap )
	{
	ERR			err;
	INT			irstmapMac = 0;
	INT			irstmap = 0;
	RSTMAP		*rgrstmap;

	if ( ( rgrstmap = static_cast<RSTMAP *>( PvOSMemoryHeapAlloc( sizeof(RSTMAP) * cjrstmap ) ) ) == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	memset( rgrstmap, 0, sizeof( RSTMAP ) * cjrstmap );

	for ( irstmap = 0; irstmap < cjrstmap; irstmap++ )
		{
		const JET_RSTMAP * const pjrstmap 	= rgjrstmap + irstmap;
		RSTMAP * const prstmap 				= rgrstmap + irstmap;
		
		if ( (prstmap->szDatabaseName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( pjrstmap->szDatabaseName ) + 1 ) ) ) == NULL )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		strcpy( prstmap->szDatabaseName, pjrstmap->szDatabaseName );

		if ( (prstmap->szNewDatabaseName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( pjrstmap->szNewDatabaseName ) + 1 ) ) ) == NULL )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		strcpy( prstmap->szNewDatabaseName, pjrstmap->szNewDatabaseName );

		prstmap->fDestDBReady 	= fTrue;

#ifdef ELIMINATE_PATCH_FILE
#else
		prstmap->szPatchPath	= NULL;
#endif
		}

	m_irstmapMac 	= irstmap;
	m_rgrstmap 		= rgrstmap;

	return JET_errSuccess;

HandleError:
	Assert( rgrstmap != NULL );
	LGRSTFreeRstmap( );
	
	Assert( m_irstmapMac == 0 );
	Assert( m_rgrstmap == NULL );
	
	return err;
	}

BOOL LOG::FLGRSTCheckDuplicateSignature(  )
	{
	//ERR LOG::ErrReplaceRstMapEntry( const CHAR *szName, SIGNATURE * pDbSignature, const BOOL fSLVFile )
	INT  irstmap;
	
	for ( irstmap = 0; irstmap < m_irstmapMac; irstmap++ )
		{
		INT  irstmapSearch;

		if ( !m_rgrstmap[irstmap].szDatabaseName )
			continue;
			
		for ( irstmapSearch = irstmap + 1; irstmapSearch < m_irstmapMac; irstmapSearch++ )
			{
			if ( !m_rgrstmap[irstmap].szNewDatabaseName )
				continue;
				
			if ( 0 == memcmp( 	&m_rgrstmap[irstmap].signDatabase,
								&m_rgrstmap[irstmapSearch].signDatabase,
								sizeof(SIGNATURE) ) &&
				m_rgrstmap[irstmap].fSLVFile == m_rgrstmap[irstmapSearch].fSLVFile )
				{
				return fFalse;
				}
			}
		}

	return fTrue;
	}

ERR LOG::ErrLGRSTBuildRstmapForExternalRestore( JET_RSTMAP *rgjrstmap, int cjrstmap )
	{
	ERR			err;
	INT			irstmapMac = 0;
	INT			irstmap = 0;
	RSTMAP		*rgrstmap;
	RSTMAP		*prstmap;
	JET_RSTMAP	*pjrstmap;

	if ( ( rgrstmap = static_cast<RSTMAP *>( PvOSMemoryHeapAlloc( sizeof(RSTMAP) * cjrstmap ) ) ) == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	memset( rgrstmap, 0, sizeof( RSTMAP ) * cjrstmap );

	for ( irstmap = 0; irstmap < cjrstmap; irstmap++ )
		{
		pjrstmap = rgjrstmap + irstmap;
		prstmap = rgrstmap + irstmap;
		if ( (prstmap->szDatabaseName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( pjrstmap->szDatabaseName ) + 1 ) ) ) == NULL )
			Call( ErrERRCheck( JET_errOutOfMemory ) );
		strcpy( prstmap->szDatabaseName, pjrstmap->szDatabaseName );

		if ( (prstmap->szNewDatabaseName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( pjrstmap->szNewDatabaseName ) + 1 ) ) ) == NULL )
			Call( ErrERRCheck( JET_errOutOfMemory ) );
		strcpy( prstmap->szNewDatabaseName, pjrstmap->szNewDatabaseName );

		/*	make patch name prepare to patch the database.
		/**/

#ifdef ELIMINATE_PATCH_FILE
#else
		//	patch files are always on the OS file-system
		_TCHAR szT[ IFileSystemAPI::cchPathMax ];

		LGIGetPatchName( m_pinst->m_pfsapi, szT, pjrstmap->szDatabaseName, m_szRestorePath );

		if ( ( prstmap->szPatchPath = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( szT ) + 1 ) ) ) == NULL )
			return ErrERRCheck( JET_errOutOfMemory );
		strcpy( prstmap->szPatchPath, szT );
#endif

		prstmap->fDestDBReady = fTrue;
		}

	m_irstmapMac = irstmap;
	m_rgrstmap = rgrstmap;

	return JET_errSuccess;

HandleError:
	Assert( rgrstmap != NULL );
	LGRSTFreeRstmap( );
	
	Assert( m_irstmapMac == 0 );
	Assert( m_rgrstmap == NULL );
	
	return err;
	}


ERR ISAMAPI ErrIsamExternalRestore(
	JET_INSTANCE jinst,
	CHAR *szCheckpointFilePath,
	CHAR *szNewLogPath,
	JET_RSTMAP *rgjrstmap,
	int cjrstmap,
	CHAR *szBackupLogPath,
	LONG lgenLow,
	LONG lgenHigh,
	JET_PFNSTATUS pfn )
	{
	ERR err;
	INST *pinst = (INST *)jinst;

//	Assert( szNewLogPath );
	Assert( rgjrstmap );
	Assert( szBackupLogPath );
//	Assert( lgenLow );
//	Assert( lgenHigh );

#ifdef DEBUG
	ITDBGSetConstants( pinst );
#endif

	Assert( pinst->m_fSTInit == fSTInitDone || pinst->m_fSTInit == fSTInitNotDone );
	if ( pinst->m_fSTInit == fSTInitDone )
		{
		return ErrERRCheck( JET_errAfterInitialization );
		}

	LOG *plog = pinst->m_plog;
		
	err = plog->ErrLGRSTExternalRestore(	pinst->m_pfsapi,
											szCheckpointFilePath,
											szNewLogPath,
											rgjrstmap,
											cjrstmap,
											szBackupLogPath,
											lgenLow,
											lgenHigh,
											pfn );
	
	return err;
	}

	
ERR LOG::ErrLGRSTExternalRestore(	IFileSystemAPI *const	pfsapi,
									CHAR 						*szCheckpointFilePath,
									CHAR 						*szNewLogPath,
									JET_RSTMAP 					*rgjrstmap,
									int 						cjrstmap,
									CHAR 						*szBackupLogPath,
									LONG 						lgenLow,
									LONG 						lgenHigh,
									JET_PFNSTATUS 				pfn )
	{
	ERR					err;
	BOOL				fLogDisabledSav;
	DBMS_PARAM			dbms_param;
//	LGBF_PARAM			lgbf_param;
	LGSTATUSINFO		lgstat;
	LGSTATUSINFO		*plgstat = NULL;
	const CHAR			*rgszT[2];
	INT					irstmap;
	BOOL				fNewCheckpointFile;
	ULONG				cbSecVolumeSave;

	BOOL fSnapshotFlagComputed = fFalse;

	//	create paths now if they do not exist
		{
		INST * pinst = m_pinst;
		
		//	make sure the temp path does NOT have a trailing '\' and the log/sys paths do

		Assert( !FOSSTRTrailingPathDelimiter( pinst->m_szTempDatabase ) );
		Assert( FOSSTRTrailingPathDelimiter( pinst->m_szSystemPath ) );
		Assert( FOSSTRTrailingPathDelimiter( m_szLogFilePath ) );

		//	create paths

		CallR( ErrUtilCreatePathIfNotExist( pinst->m_pfsapi, pinst->m_szTempDatabase, NULL ) );
		CallR( ErrUtilCreatePathIfNotExist( pinst->m_pfsapi, pinst->m_szSystemPath, NULL ) );
		CallR( ErrUtilCreatePathIfNotExist( pinst->m_pfsapi, m_szLogFilePath, NULL ) );
		}

	//	Start the restore work
	
	m_fSignLogSet = fFalse;

	/*	set restore path
	/**/			
	CallR( ErrLGRSTInitPath( pfsapi, szBackupLogPath, szNewLogPath, m_szRestorePath, m_szLogFilePath ) );
	Assert( strlen( m_szRestorePath ) < sizeof( m_szRestorePath ) - 1 );
	Assert( strlen( m_szLogFilePath ) < IFileSystemAPI::cchPathMax );
	Assert( m_szLogCurrent == m_szRestorePath );

	//	disable the sector-size checks

//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//	---** TEMPORARY FIX **---
{
	CHAR rgchFullName[IFileSystemAPI::cchPathMax];
	if ( pfsapi->ErrPathComplete( m_szLogFilePath, rgchFullName ) == JET_errInvalidPath )
		{
		const CHAR	*szPathT[1] = { m_szLogFilePath };
		UtilReportEvent(
				eventError,
				LOGGING_RECOVERY_CATEGORY,
				FILE_NOT_FOUND_ERROR_ID,
				1,
				szPathT,
				0,
				NULL,
				m_pinst );
		return ErrERRCheck( JET_errFileNotFound );
		}

	CallR( pfsapi->ErrFileAtomicWriteSize( rgchFullName, (DWORD*)&m_cbSecVolume ) );
}
	cbSecVolumeSave = m_cbSecVolume;
//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//	m_cbSecVolume = ~(ULONG)0;

	//	use the proper log file size for recovery

	Assert( m_pinst->m_fUseRecoveryLogFileSize == fFalse );
	m_pinst->m_fUseRecoveryLogFileSize = fTrue;

	/*	check log signature and database signatures
	/**/

	Assert ( 0 == m_lGenHighTargetInstance || m_szTargetInstanceLogPath[0] );

	//	check log signature and database signatures
	if ( m_lGenHighTargetInstance )
		{
		CallJ( ErrLGRSTCheckSignaturesLogSequence(
			pfsapi, m_szRestorePath, m_szLogFilePath, lgenLow, lgenHigh, m_szTargetInstanceLogPath, m_lGenHighTargetInstance ), ReturnError );
		}
	else
		{
		CallJ( ErrLGRSTCheckSignaturesLogSequence(
			pfsapi, m_szRestorePath, m_szLogFilePath, lgenLow, lgenHigh, NULL, 0 ), ReturnError );
		}

	fLogDisabledSav = m_fLogDisabled;
	m_pinst->SaveDBMSParams( &dbms_param );
//	LGSaveBFParams( &lgbf_param );

	m_fHardRestore = fTrue;
	m_fRestoreMode = fRestorePatch;
	m_fLogDisabled = fFalse;
	m_fAbruptEnd = fFalse;

	CallJ( ErrLGRSTBuildRstmapForExternalRestore( rgjrstmap, cjrstmap ), TermResetGlobals );

	/*	make sure all the patch files have enough logs to replay
	/**/

	for ( irstmap = 0; irstmap < m_irstmapMac; irstmap++ )
		{		
		/*	open patch file and check its minimum requirement for full backup,
		/*  skipping any SLV streaming files we see
		/**/
		CHAR *szDatabaseName = m_rgrstmap[irstmap].szDatabaseName;
		CHAR *szNewDatabaseName = m_rgrstmap[irstmap].szNewDatabaseName;

		LGPOS lgposSnapshotDb = lgposMin;
		Assert( m_fSignLogSet );

#ifdef ELIMINATE_PATCH_FILE
		err = ErrLGCheckDBFiles( m_pinst, pfsapi, m_rgrstmap + irstmap, NULL, lgenLow, lgenHigh, &lgposSnapshotDb );
#else
        _TCHAR szT[ IFileSystemAPI::cchPathMax ];

		//	patch files are always on the OS file-system
		LGIGetPatchName( pfsapi, szT, szDatabaseName, m_szRestorePath );

		err = ErrLGCheckDBFiles( m_pinst, pfsapi, m_rgrstmap + irstmap, szT, lgenLow, lgenHigh, &lgposSnapshotDb );
#endif

		// we don't check streaming file header during backup
		// UNDONE: maybe it is possible to check this, not that there are supposed to be in sync
		if ( wrnSLVDatabaseHeader == err )
			{
			err = JET_errSuccess;
			continue;
			}
			
		CallJ( err, TermFreeRstmap );

		// we have to check the all dbs do have the same lgposSnapshotStart
		// or none of those are from Snapshot backup set
		if ( !fSnapshotFlagComputed )
			{
			Assert ( CmpLgpos ( &m_lgposSnapshotStart, &lgposMin) == 0 );
			Assert ( fSnapshotNone == m_fSnapshotMode );
			
			if ( CmpLgpos ( &lgposSnapshotDb, &lgposMin) > 0 )
				{
				m_fSnapshotMode = fSnapshotBefore;
				m_lgposSnapshotStart = lgposSnapshotDb;
				}
			}

		// the lgposSnapshotStart must be the same for all db's (set or lgposMin)
		if ( CmpLgpos ( &lgposSnapshotDb, &m_lgposSnapshotStart) != 0 )
			{
			// UNDONE: define a new error
			CallJ ( ErrERRCheck ( JET_errDatabasesNotFromSameSnapshot ), TermFreeRstmap );
			}				
		fSnapshotFlagComputed = fTrue;
		}

	// check that there are no databases with same signature
	Assert ( FLGRSTCheckDuplicateSignature( ) );

//	CallJ( FMP::ErrFMPInit(), TermFreeRstmap );

	//  initialize log manager and set working log file path
	
	CallJ( ErrLGInit( pfsapi, &fNewCheckpointFile ), TermFMP );

	rgszT[0] = m_szRestorePath;
	rgszT[1] = m_szLogFilePath;
	UtilReportEvent(
			eventInformation,
			LOGGING_RECOVERY_CATEGORY,
			START_RESTORE_ID,
			2,
			rgszT,
			0,
			NULL,
			m_pinst );

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];
	
		sprintf( sz, "** Begin ExternalRestore:\n" );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );

		if ( szCheckpointFilePath )
			{
			sprintf( sz, "     CheckpointFilePath: %s\n", szCheckpointFilePath );
			Assert( strlen( sz ) <= sizeof( sz ) - 1 );
			DBGBRTrace( sz );
			}
		if ( szNewLogPath )
			{
			sprintf( sz, "     LogPath: %s\n", szNewLogPath );
			Assert( strlen( sz ) <= sizeof( sz ) - 1 );
			DBGBRTrace( sz );
			}
		if ( szBackupLogPath )
			{
			sprintf( sz, "     BackupLogPath: %s\n", szBackupLogPath );
			Assert( strlen( sz ) <= sizeof( sz ) - 1 );
			DBGBRTrace( sz );
			}
		sprintf( sz, "     Generation number: %d - %d\n", lgenLow, lgenHigh );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );

		if ( m_irstmapMac )
			{
			INT irstmap;

			for ( irstmap = 0; irstmap < m_irstmapMac; irstmap++ )
				{
				RSTMAP *prstmap = m_rgrstmap + irstmap;
			
				sprintf( sz, "     %s --> %s\n", prstmap->szDatabaseName, prstmap->szNewDatabaseName );
				Assert( strlen( sz ) <= sizeof( sz ) - 1 );
				DBGBRTrace( sz );
				}
			}	
		}
#endif

	/*	set up checkpoint file for restore
	/**/
	Call ( ErrLGIGetGenerationRange( pfsapi, m_szRestorePath,
			!lgenLow?&lgenLow:NULL,
			!lgenHigh?&lgenHigh:NULL ) );
	
	Call( ErrLGRSTSetupCheckpoint( pfsapi, lgenLow, lgenHigh, szCheckpointFilePath ) );

	m_lGenLowRestore = lgenLow;
	m_lGenHighRestore = lgenHigh;

	/*	prepare for callbacks
	/**/
	if ( pfn != NULL )
		{
		plgstat = &lgstat;
		LGIRSTPrepareCallback( pfsapi, plgstat, lgenHigh, lgenLow, pfn );
		}

	/*	adjust fmp according to the restore map
	/**/
	m_fExternalRestore = fTrue;

#ifdef ELIMINATE_PATCH_FILE
#else
	Call( ErrLGRSTPatchInit() );
#endif
	
	/*	do redo according to the checkpoint, dbms_params, and rgbAttach
	/*	set in checkpointGlobal.
	/**/
	Assert( m_szLogCurrent == m_szRestorePath );
	m_errGlobalRedoError = JET_errSuccess;
	Call( ErrLGRRedo( pfsapi, m_pcheckpoint, plgstat ) );

	//	we should be using the right log file size by now

	Assert( m_pinst->m_fUseRecoveryLogFileSize == fFalse );

	//	sector-size checking should now be on

	Assert( m_cbSecVolume != ~(ULONG)0 );
	Assert( m_cbSecVolume == m_cbSec );

	//	update saved copy
	
	cbSecVolumeSave = m_cbSecVolume;

	/*	same as going to shut down, Make all attached databases consistent
	/**/
	if ( plgstat )
		{
		/*	top off the progress metre and wrap it up
		/**/
		lgstat.snprog.cunitDone = lgstat.snprog.cunitTotal;		//lint !e644
		(*lgstat.pfnStatus)(0, JET_snpRestore, JET_sntComplete, &lgstat.snprog);
		}
	
HandleError:

#ifdef ELIMINATE_PATCH_FILE
#else
		//  UNDONE: if the DetachDb was redone during recover (the soft recover part)
		// we don't have the dbid in m_mpdbidifmp and we don't delete the patch
		// file for it. TODO: delete the patch file in ResetFMP
		// anyway, DELETE_PATCH_FILES is dot define so we don't delete those patch files
		// at this level but only in ESEBACK2, on restore without error
		/*	delete .pat files
		/**/
		{
		/*	delete .pat files
		/**/
		for ( DBID dbidT = dbidUserLeast; dbidT < dbidMax; dbidT++ )
			{
			IFMP 	ifmp = m_pinst->m_mpdbidifmp[ dbidT ];
			if ( ifmp >= ifmpMax )
				continue;

			FMP *pfmpT = &rgfmp[ ifmp ];

			if ( pfmpT->SzPatchPath() )
				{
				delete pfmpT->PfapiPatch();
				pfmpT->SetPfapiPatch( NULL );
#ifdef DELETE_PATCH_FILES
				CallSx( m_pinst->m_pfsapi->ErrFileDelete( pfmpT->SzPatchPath() ), JET_errFileNotFound );
#endif
				OSMemoryHeapFree( pfmpT->SzPatchPath() );
				pfmpT->SetSzPatchPath( NULL );
				}
			}
		}

	/*	delete the patch hash table
	/**/
	LGRSTPatchTerm();

#endif	//	ELIMINATE_PATCH_FILE

	/*	either error or terminated
	/**/
	Assert( err < 0 || m_pinst->m_fSTInit == fSTInitNotDone );
	if ( err < 0  &&  m_pinst->m_fSTInit != fSTInitNotDone )
		{
		Assert( m_pinst->m_fSTInit == fSTInitDone );
		CallS( m_pinst->ErrINSTTerm( termtypeError ) );
		}

//	CallS( ErrLGTerm( pfsapi, err >= JET_errSuccess ) );
	CallS( ErrLGTerm( pfsapi, fFalse ) );

	// on success, delete the files generated by this instance
	// (logs, chk, res1.log, res2.log)
	if ( err >= 0 )
		{
		CHAR	szFileName[IFileSystemAPI::cchPathMax];
		CHAR	szFullLogPath[IFileSystemAPI::cchPathMax];
		CHAR	szFullTargetPath[IFileSystemAPI::cchPathMax];
		
		//	delete the log files generated if those files are not in
		//	the instance that is runnign.
		//
		Assert ( 0 == m_lGenHighTargetInstance || m_szTargetInstanceLogPath[0] );
		Assert ( m_szLogFilePath );

		CallS( pfsapi->ErrPathComplete( m_szTargetInstanceLogPath, szFullTargetPath ) );		
		CallS( pfsapi->ErrPathComplete( m_szLogFilePath, szFullLogPath ) );		
				
		Assert ( 0 == m_lGenHighTargetInstance || (0 != UtilCmpFileName( szFullTargetPath, szFullLogPath ) ) );
		if ( m_lGenHighTargetInstance && ( 0 != UtilCmpFileName( szFullTargetPath, szFullLogPath ) ) )
			{
/*			LONG		genLowT;
			LONG		genHighT;
			
			Assert ( m_lGenHighTargetInstance );

			genLowT = m_lGenHighTargetInstance + 1;
			LGILastGeneration( pfsapi, m_szLogFilePath, &genHighT );
			// if only edb.log new generated, genHighT will be the max one from the
			// backup set (if in that directory)
			genHighT = max ( genHighT, genLowT);
			LGRSTDeleteLogs( pfsapi, m_szLogFilePath, genLowT, genHighT, fLGRSTIncludeJetLog );		

			LGFullNameCheckpoint( pfsapi, szFileName );
			CallSx( pfsapi->ErrFileDelete( szFileName ), JET_errFileNotFound );				
*/
			LGMakeLogName( szFileName, szLogRes1 );
			CallSx( pfsapi->ErrFileDelete( szFileName ), JET_errFileNotFound );
			LGMakeLogName( szFileName, szLogRes2 );
			CallSx( pfsapi->ErrFileDelete( szFileName ), JET_errFileNotFound );				
			}
		}
		
TermFMP:	
//	FMP::Term();
	
TermFreeRstmap:
	LGRSTFreeRstmap( );

TermResetGlobals:
	m_fHardRestore = fFalse;
	m_fRestoreMode = fRecoveringNone;
	m_fSnapshotMode = fSnapshotNone;
	m_lgposSnapshotStart = lgposMin;

	m_szTargetInstanceLogPath[0] = '\0';
	
	/*	reset initialization state
	/**/
	m_pinst->m_fSTInit = ( err >= 0 ) ? fSTInitNotDone : fSTInitFailed;

	if ( err != JET_errSuccess && !FErrIsLogCorruption( err ) )
		{
		UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, RESTORE_DATABASE_FAIL_ID, err, m_pinst );
		}
	else
		{
		if ( fGlobalRepair && m_errGlobalRedoError != JET_errSuccess )
			err = ErrERRCheck( JET_errRecoveredWithErrors );
		}
	UtilReportEvent(
			eventInformation,
			LOGGING_RECOVERY_CATEGORY,
			STOP_RESTORE_ID,
			0,
			NULL,
			0,
			NULL,
			m_pinst );

	// signal the caller that we found a running instance
	// the caller (eseback2) will deal with the resulting logs
	// generated by the restore instance in  szNewLogPath
	if ( m_lGenHighTargetInstance && JET_errSuccess <= err )
		{
		err = ErrERRCheck( JET_wrnTargetInstanceRunning );
		}
	m_lGenHighTargetInstance = 0;


	m_fSignLogSet = fFalse;

	m_fLogDisabled = fLogDisabledSav;
	m_pinst->RestoreDBMSParams( &dbms_param );
//	LGRestoreBFParams( &lgbf_param );

	m_fExternalRestore = fFalse;

ReturnError:
	m_cbSecVolume = cbSecVolumeSave;
	m_pinst->m_fUseRecoveryLogFileSize = fFalse;
	return err;
	}


VOID LGMakeName( IFileSystemAPI *const pfsapi, CHAR *szName, const CHAR *szPath, const CHAR *szFName, const CHAR *szExt )
	{
	CHAR	szDirT[IFileSystemAPI::cchPathMax];
	CHAR	szFNameT[IFileSystemAPI::cchPathMax];
	CHAR	szExtT[IFileSystemAPI::cchPathMax];

	CallS( pfsapi->ErrPathParse( szPath, szDirT, szFNameT, szExtT ) );
	CallS( pfsapi->ErrPathBuild( szDirT, szFName, szExt, szName ) );
	}

VOID LOG::LGFullLogNameFromLogId( IFileSystemAPI *const pfsapi, CHAR *szFullLogFileName, LONG lGeneration, CHAR * szDirectory )
	{
	CHAR	szBaseNameT[IFileSystemAPI::cchPathMax];
	CHAR	szFullPathT[IFileSystemAPI::cchPathMax];
		
	LGSzFromLogId( szBaseNameT, lGeneration );

	//	we should always be able to get the full path as it should be the restore path
	//	which is already checked in the calling context.
	//
	CallS( pfsapi->ErrPathComplete( szDirectory, szFullPathT ) );
	
	LGMakeName( pfsapi, szFullLogFileName, szFullPathT, szBaseNameT, (CHAR *)szLogExt );

	return;
	}

// build in szFindPath the patch file full name for a database
// in a certain directory. If directory is NULL, build in the
// database directory (patch file during backup)
VOID LOG::LGIGetPatchName( IFileSystemAPI *const pfsapi, CHAR *szPatch, const char * szDatabaseName, char * szDirectory )
	{
	Assert ( szDatabaseName );

	CHAR	szFNameT[ IFileSystemAPI::cchPathMax ];
	CHAR	szDirT[ IFileSystemAPI::cchPathMax ];
	CHAR	szExtT[ IFileSystemAPI::cchPathMax ];
	
	CallS( pfsapi->ErrPathParse( szDatabaseName, szDirT, szFNameT, szExtT ) );

	//	patch file is always on the OS file-system
	if ( szDirectory )
		// patch file in the specified directory
		// (m_szRestorePath during restore)
		{
		LGMakeName( m_pinst->m_pfsapi, szPatch, szDirectory, szFNameT, (CHAR *) szPatExt );	
		}
	else
		// patch file in the same directory with the database
		{
		LGMakeName( m_pinst->m_pfsapi, szPatch, szDirT, szFNameT, (CHAR *) szPatExt );	
		}
	}


// returns JET_errSuccess even if not found (then lgen will be 0)
//
ERR LOG::ErrLGIGetGenerationRange( IFileSystemAPI* const pfsapi, char* szFindPath, long* plgenLow, long* plgenHigh )
	{
	ERR				err			= JET_errSuccess;
	char			szFind[ IFileSystemAPI::cchPathMax ];
	char			szFileName[ IFileSystemAPI::cchPathMax ];
	IFileFindAPI*	pffapi		= NULL;

	long			lGenMax		= 0;
	long			lGenMin		= lGenerationMaxDuringRecovery + 1;
	
	Assert ( szFindPath );
	Assert ( pfsapi );
	/*	make search string "<search path> \ edb * .log\0"
	/**/
	Assert( strlen( szFindPath ) + 1 + strlen( m_szJet ) + strlen( "*" ) + strlen( szLogExt ) + 1 <= IFileSystemAPI::cchPathMax );
	
	strcpy( szFind, szFindPath );
	OSSTRAppendPathDelimiterA( szFind, fTrue );
	strcat( szFind, m_szJet );
	strcat( szFind, "*" );
	strcat( szFind, szLogExt );

	Call( pfsapi->ErrFileFind( szFind, &pffapi ) );
	while ( ( err = pffapi->ErrNext() ) == JET_errSuccess )
		{
		CHAR	szT[4];
		CHAR	szDirT[IFileSystemAPI::cchPathMax];
		CHAR	szFNameT[IFileSystemAPI::cchPathMax];
		CHAR	szExtT[IFileSystemAPI::cchPathMax];

		/*	get file name and extension
		/**/
		Call( pffapi->ErrPath( szFileName ) );
		Call( pfsapi->ErrPathParse( szFileName, szDirT, szFNameT, szExtT ) );

		/* if length of a numbered log file name and has log file extension
		/**/
		if ( strlen( szFNameT ) == 8 && UtilCmpFileName( szExtT, szLogExt ) == 0 )
			{
			UtilMemCpy( szT, szFNameT, 3 );
			szT[3] = '\0';

			/* if has not the current base name
			/**/
			if ( UtilCmpFileName( szT, m_szJet ) )
				{
				continue;
				}
			
			INT			ib;
			const INT	ibMax = 8;
			LONG		lGen = 0;

			for (ib = 3; ib < ibMax; ib++ )
				{
				BYTE	b = szFNameT[ib];

				if ( b >= '0' && b <= '9' )
					lGen = lGen * 16 + b - '0';
				else if ( b >= 'A' && b <= 'F' )
					lGen = lGen * 16 + b - 'A' + 10;
				else if ( b >= 'a' && b <= 'f' )
					lGen = lGen * 16 + b - 'a' + 10;
				else
					break;
				}
			
			if ( ib != ibMax )
				{
				continue;
				}
				
			lGenMax = max( lGenMax, lGen );
			lGenMin = min( lGenMin, lGen );
			
			}
		}
	Call( err == JET_errFileNotFound ? JET_errSuccess : err );

HandleError:
	
	delete pffapi;

	// JET_errFileNotFound is not an error, we return JET_errSuccess and (0,0) as range

	// on error, we return (0,0)
	if ( err < JET_errSuccess )
		{
		Assert ( JET_errFileNotFound != err );
		lGenMin = 0;
		lGenMax = 0;
		}
	
	// nothing found
	if ( lGenerationMaxDuringRecovery + 1 == lGenMin )
		{
		Assert ( JET_errSuccess == err );
		Assert( 0 == lGenMax );
		lGenMin = 0;
		}

	Assert( 0 <= lGenMin );
	Assert( 0 <= lGenMax );

	Assert( lGenMin <= lGenerationMaxDuringRecovery );
	Assert( lGenMax <= lGenerationMaxDuringRecovery );
	Assert( lGenMin <= lGenMax );

	if ( plgenLow )
		{
		*plgenLow = lGenMin;
		}
	
	if ( plgenHigh )
		{
		*plgenHigh = lGenMax;
		}

	return err;
	}

ERR ISAMAPI  ErrIsamSnapshotStart(	JET_INSTANCE 		instance,
									char * 				szDatabases,
									JET_GRBIT			grbit)
	{
	INST *pinst = (INST *)instance;
	return pinst->m_plog->ErrLGBKSnapshotStart( pinst->m_pfsapi, szDatabases, grbit );
	}
	
ERR LOG::ErrLGBKSnapshotStart(	IFileSystemAPI *const	pfsapi,
								char 						*szDatabases,
								JET_GRBIT					grbit )
	{
	char * 		szCurrentDatabase 	= szDatabases;
	ERR 		err 				= JET_errSuccess;
	BKINFO 		bkInfo;

	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}
	else if ( m_fStopBackup )
		{
		return ErrERRCheck( JET_errBackupAbortByServer );
		}

	if ( !m_fBackupSnapshot || backupStateDatabases != m_fBackupStatus )
		{
		return ErrERRCheck( JET_errInvalidBackupSequence );
		}

	if ( !szDatabases )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	Assert ( backupStateDatabases == m_fBackupStatus );
	Assert ( m_fBackupSnapshot );

	memset( &bkInfo, 0, sizeof( BKINFO ) );
	bkInfo.le_lgposMark = m_lgposSnapshotStart;
	bkInfo.logtimeMark = m_logtimeFullBackupMark;
	bkInfo.le_genLow = m_lgenCopyMic;

	// for each db ERR FMP::ErrSnapshotStart( pfsapi, lgposFullBackup )
	while ( szCurrentDatabase[0] )
		{
		IFMP ifmpT;
		
		Call ( ErrDBOpenDatabase( m_ppibBackup, (CHAR *)szCurrentDatabase, &ifmpT, 0 ) );
		Assert( err == JET_errSuccess || err == JET_wrnFileOpenReadOnly );

		Assert ( 0 != CmpLgpos( &m_lgposSnapshotStart, &lgposMin) );

		Call ( rgfmp[ifmpT].ErrSnapshotStart( pfsapi, &bkInfo ) );

		szCurrentDatabase += strlen( szCurrentDatabase );
		}

	Assert ( JET_errSuccess == err );

HandleError:

	// if we do have some DBs in snapshot session, we need to stop those
	if ( JET_errSuccess > err )
		{
		(void)ErrLGBKSnapshotStop( pfsapi, 0 );
		}
		
	return err;
	}

ERR ISAMAPI  ErrIsamSnapshotStop(	JET_INSTANCE 		instance,
									JET_GRBIT			grbit)
	{
	INST *pinst = (INST *)instance;
	return pinst->m_plog->ErrLGBKSnapshotStop( pinst->m_pfsapi, grbit );
	}

ERR LOG::ErrLGBKSnapshotStop( IFileSystemAPI *const pfsapi, JET_GRBIT grbit )
	{
	ERR 	err 				= JET_errSuccess;
	ERR 	errT 				= JET_errSuccess;

	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}
		
	if ( !m_fBackupSnapshot || backupStateDatabases != m_fBackupStatus )
		{
		return ErrERRCheck( JET_errInvalidBackupSequence );
		}

	Assert ( backupStateDatabases == m_fBackupStatus );
	Assert ( m_fBackupSnapshot );

	for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP ifmp = m_pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;

		FMP * pfmp = rgfmp + ifmp;
		Assert ( pfmp );
		
		if ( !pfmp->FDuringSnapshot() )
			continue;

		// if we error for one DB, go for all DBs
		// and save the error
		errT = pfmp->ErrSnapshotStop( pfsapi );

		// we should have reset the flag even on error
		Assert ( !pfmp->FDuringSnapshot() );
		
		if ( JET_errSuccess <= err )
			{
			err = errT;
			}
		
		CallS ( ErrDBCloseDatabase( m_ppibBackup, ifmp, 0 ) );
		}
		
	// on error, stop the backup session, don't allow
	// JetGetLogInfo as we may failed to update the DB header and
	// logging StopSnapshot (in JetGetLogInfo) must not occure.
	if ( err < JET_errSuccess )
		{
		(void)ErrLGBKIExternalBackupCleanUp( pfsapi, err );
		}
		
	return err;
	}


#ifdef ELIMINATE_PATCH_FILE

VOID LOG::LGBKMakeDbTrailer(const IFMP ifmp, BYTE *pvPage)
	{
	FMP		*pfmp = &rgfmp[ifmp];

	PATCHHDR * const ppatchHdr = pfmp->Ppatchhdr();
	BKINFO * pbkinfo;

	Assert( pfmp->PgnoCopyMost() == pfmp->PgnoMost() );
	Assert( !pfmp->FCopiedPatchHeader() );

	memset( (void *)ppatchHdr, '\0', g_cbPage );
	
	pbkinfo = &ppatchHdr->bkinfo;
	pbkinfo->le_lgposMark = m_lgposFullBackupMark;
	pbkinfo->logtimeMark = m_logtimeFullBackupMark;
	pbkinfo->le_genLow = m_lgenCopyMic;

	UtilMemCpy( (BYTE*)&ppatchHdr->signDb, &pfmp->Pdbfilehdr()->signDb, sizeof(SIGNATURE) );
	UtilMemCpy( (BYTE*)&ppatchHdr->signLog, &pfmp->Pdbfilehdr()->signLog, sizeof(SIGNATURE) );

	m_critLGFlush.Enter();
	pbkinfo->le_genHigh = m_plgfilehdr->lgfilehdr.le_lGeneration;
	m_critLGFlush.Leave();

	Assert( pbkinfo->le_genLow != 0 );
	Assert( pbkinfo->le_genHigh != 0 );
	Assert ( pbkinfo->le_genHigh >= pbkinfo->le_genLow );
			
	ppatchHdr->m_hdrNormalPage.ulChecksumParity = UlUtilChecksum( (const BYTE*) ppatchHdr, g_cbPage );
	UtilMemCpy( (BYTE *)pvPage, ppatchHdr, g_cbPage );

	pfmp->SetFCopiedPatchHeader();
	}

ERR LOG::ErrLGBKReadDBTrailer(	IFileSystemAPI *const pfsapi, const _TCHAR*	szFileName, BYTE* pbTrailer, const DWORD	cbTrailer )
	{
	ERR			err 	= JET_errSuccess;
	IFileAPI * 	pfapi 	= NULL;
	QWORD 		cbSize 	= 0;
	
	CallR ( pfsapi->ErrFileOpen( szFileName, &pfapi, fTrue ) )

	Call ( pfapi->ErrSize( &cbSize ) );

	// we already read the headers
	Assert ( cbSize > QWORD ( cpgDBReserved ) * g_cbPage );

	// we need at least the patch page
	if ( cbSize < QWORD ( cpgDBReserved + 1 )  * g_cbPage )
		{
		Call ( ErrERRCheck( JET_errDatabaseCorrupted ) );
		}
	
	Call ( pfapi->ErrIORead( cbSize - QWORD(g_cbPage), cbTrailer, pbTrailer ) );

		
	Assert ( JET_errSuccess == err );
HandleError:

	if ( pfapi )
		{
		delete pfapi;
		pfapi = NULL;
		}

	if ( err == JET_errDiskIO )
		err = ErrERRCheck( JET_errDatabaseCorrupted );

	return err;
	}

ERR LOG::ErrLGBKReadAndCheckDBTrailer(IFileSystemAPI *const pfsapi, const _TCHAR* szFileName, BYTE * pbBuffer )
	{
	ERR			err			= JET_errSuccess;
	PATCHHDR *	ppatchHdr	= (PATCHHDR *)pbBuffer;

	CallR( ErrLGBKReadDBTrailer( pfsapi, szFileName, (BYTE*)ppatchHdr, g_cbPage ) );

	if ( ppatchHdr->m_hdrNormalPage.ulChecksumParity != UlUtilChecksum( (const BYTE*) ppatchHdr, g_cbPage )
		|| 0 != ppatchHdr->m_hdrNormalPage.pgnoThis )
		{
		//  the page has a verification failure
		CallR( ErrERRCheck( JET_errBadPatchPage ) );
		}

	return JET_errSuccess;
	}

#endif // ELIMINATE_PATCH_FILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_osu\normu.cxx ===
#include "osustd.hxx"


#ifndef TO_UPPER_ONLY
#include "b71iseng.hxx"
#endif


ERR ErrUtilNormText(
	const char		*pbText,
	int				cbText,
	int				cbKeyBufLeft,
	char			*pbNorm,
	int				*pcbNorm )
	{
	ERR				err			= JET_errSuccess;

#ifdef TO_UPPER_ONLY

	Assert( cbText >= 0 );
	Assert( cbKeyBufLeft >= 0 );

	if ( cbKeyBufLeft > cbText )
		{
		memcpy( pbNorm, pbText, cbText );
		pbNorm[ cbText ] = 0;

		//To prevent normalizing text strings with embedded null-terminators
		Assert( cbText >= strlen( pbNorm ) );
		cbText = (int)strlen( pbNorm );

		_strupr( pbNorm );

		*pcbNorm	= cbText + 1;
		CallS( err );
		}
	else if ( cbKeyBufLeft > 0 )
		{
		int	cbTextToNormalise	= cbKeyBufLeft - 1;		//	make room for null-terminator

		memcpy( pbNorm, pbText, cbTextToNormalise );
		pbNorm[ cbTextToNormalise ] = 0;

		//To prevent normalizing text strings with embedded null-terminators
		Assert( cbTextToNormalise >= strlen( pbNorm ) );
		cbTextToNormalise = (int)strlen( pbNorm );

		_strupr( pbNorm );

		Assert( cbKeyBufLeft >= cbTextToNormalise + 1 );
		if ( cbKeyBufLeft == ( cbTextToNormalise + 1 )
			&& ( 0 != pbText[cbTextToNormalise] ) )
			{
			// no null-terminators are embedded inside the text string
			// and cbText >= cbKeyBufLeft
			pbNorm[ cbTextToNormalise ] = (CHAR)_toupper( pbText[ cbTextToNormalise ] );
			err	= ErrERRCheck( wrnFLDKeyTooBig );
			}
		else
			{
			//	embedded null-terminators caused us to halt normalisation
			//	before the end of the keyspace, so we still have
			//	keyspace left
			CallS( err );
			}

		*pcbNorm	= cbTextToNormalise + 1;
		}
	else
		{
		//	UNDONE: how come we don't return a warning when there
		//	is no keyspace left?
		*pcbNorm	= 0;
		CallS( err );
		}

#else

	char            *pbNormBegin = pbNorm;
	char            rgbAccent[ (KEY::cbKeyMax + 1) / 2 + 1 ];
	char            *pbAccent = rgbAccent;
	char            *pbBeyondKeyBufLeft = pbNorm + cbKeyBufLeft;
	const char      *pbBeyondText;
	const char      *pbTextLastChar = pbText + cbText - 1;
	char            bAccentTmp = 0;

	while ( *pbTextLastChar-- == ' ' )
		cbText--;

	/*	add one back to the pointer
	/**/
	pbTextLastChar++;

	Assert( pbTextLastChar == pbText + cbText - 1 );
	pbBeyondText = pbTextLastChar + 1;

	while ( pbText <  pbBeyondText && pbNorm < pbBeyondKeyBufLeft )
		{
		char	bTmp;

		/*	do a single to single char conversion
		/**/
		*pbNorm = bTmp = BGetTranslation(*pbText);

		if ( bTmp >= 250 )
			{
			/*	do a single to double char conversion
			/**/
			*pbNorm++ = BFirstByteForSingle(bTmp);
			if ( pbNorm < pbBeyondKeyBufLeft )
				*pbNorm = BSecondByteForSingle(bTmp);
			else
				break;

			/*	no need to do accent any more,
			/*	so break out of while loop
			/**/
			}

		pbNorm++;

		/*	at this point, pbText should point to the char for accent mapping
		/**/

		/*	do accent now
		/*	the side effect is to increment pbText
		/**/
		if ( bAccentTmp == 0 )
			{
			/*	first nibble of accent
			/**/
			bAccentTmp = (char)( BGetAccent( *pbText++ ) << 4 );
			Assert( bAccentTmp > 0 );
			}
		else
			{
			/*	already has first nibble
			/**/
			*pbAccent++ = BGetAccent(*pbText++) | bAccentTmp;
			bAccentTmp = 0;
			/*	reseting the accents
			/**/
			}
		}

	if ( pbNorm < pbBeyondKeyBufLeft )
		{
		/*	need to do accent
		/**/
		*pbNorm++ = 0;

		/*	key-accent separator
		/**/
		if ( bAccentTmp != 0 && bAccentTmp != 0x10 )
			{
			/*	an trailing accent which is not 0x10 should be kept
			/**/
			*pbAccent++ = bAccentTmp;
			}

		/*	at this point, pbAccent is pointing at one char
		/*	beyond the accent bytes.  clear up trailing 0x11's
		/**/
		while (--pbAccent >= rgbAccent && *pbAccent == 0x11)
			;
		*( pbAccent + 1 ) = 0;

		/*	append accent to text.
		/*	copy bytes up to and including '\0'.
		/*	case checked for rgbAccent being empty.
		/**/
		pbAccent = rgbAccent;
		Assert( pbNorm <= pbBeyondKeyBufLeft );
		while ( pbNorm < pbBeyondKeyBufLeft  &&  (*pbNorm++  =  *pbAccent++ ) )
			;
		}

	/*	compute the length of the normalized key and return
	/**/
	*pcbNorm = pbNorm - pbNormBegin;

	err = ( pbNorm < pbBeyondKeyBufLeft ? JET_errSuccess : ErrERRCheck( wrnFLDKeyTooBig ) );
	
#endif	// TO_UPPER_ONLY

	CallSx( err, wrnFLDKeyTooBig );
	return err;
	}


//  terminate norm subsystem

void OSUNormTerm()
	{
	//  nop
	}

//  init norm subsystem

ERR ErrOSUNormInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_osu\osustd.cxx ===
#include "osustd.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_osu\fileu.cxx ===
#include "osustd.hxx"


/********************
/* optimised version of UlUtilChecksum for calculating the
/* checksum on pages. we assume that the pagesize is a multiple
/* of 16 bytes, this is true for 4k and 8k pages.
/*
/* because it is a bottleneck we turn on the optimisations
/* even in debug 
/*
/**/
#pragma optimize( "agtw", on )

//  ================================================================
inline void CachePrefetch ( const void * const p )
//  ================================================================
	{
#ifdef _X86_
	  _asm
	  {
	   mov  eax,p
 
	   _emit 0x0f  // PrefetchNTA
	   _emit 0x18
	   _emit 0x00
	  }
#endif
	}

typedef DWORD (*PFNCHECKSUM)( const BYTE * const, const DWORD );

//  ================================================================
static DWORD DwChecksumESEBigEndian( const BYTE * const pb, const DWORD cb )
//  ================================================================
	{
	PFNCHECKSUM pfn = DwChecksumESEBigEndian;
	
	const DWORD	* pdw 			= (DWORD *)pb;
	INT cbT						= cb;
	
	DWORD	dwChecksum = ReverseBytesOnBE( 0x89abcdef ) ^ pdw[0];

	do
		{
		dwChecksum 	^= pdw[0]
					^ pdw[1]
					^ pdw[2]
					^ pdw[3]
					^ pdw[4]
					^ pdw[5]
					^ pdw[6]
					^ pdw[7];
		cbT -= 32;
		pdw += 8;
		} while ( cbT );

	dwChecksum = ReverseBytesOnBE( dwChecksum );

	return dwChecksum;
	}


//  ================================================================
static DWORD DwChecksumESEPrefetch( const BYTE * const pb, const DWORD cb )
//  ================================================================
	{
	PFNCHECKSUM pfn = DwChecksumESEPrefetch;
	
	const DWORD	* pdw 			= (DWORD *)pb;
	INT cbT						= cb;

	//	touching this memory puts the page in the processor TLB (needed
	//	for prefetch) and brings in the first cacheline (cacheline 0)
	
	DWORD	dwChecksum = 0x89abcdef ^ pdw[0];

	do
		{
		CachePrefetch ( pdw + 16 );	
		dwChecksum 	^= pdw[0]
					^ pdw[1]
					^ pdw[2]
					^ pdw[3]
					^ pdw[4]
					^ pdw[5]
					^ pdw[6]
					^ pdw[7];
		cbT -= 32;
		pdw += 8;
		} while ( cbT );

	return dwChecksum;
	}


//  ================================================================
static DWORD DwChecksumESENoPrefetch( const BYTE * const pb, const DWORD cb )
//  ================================================================
	{
	PFNCHECKSUM pfn = DwChecksumESENoPrefetch;
	
	const DWORD	* pdw 			= (DWORD *)pb;
	INT cbT						= cb;
	
	DWORD	dwChecksum = 0x89abcdef ^ pdw[0];

	do
		{
		dwChecksum 	^= pdw[0]
					^ pdw[1]
					^ pdw[2]
					^ pdw[3]
					^ pdw[4]
					^ pdw[5]
					^ pdw[6]
					^ pdw[7];
		cbT -= 32;
		pdw += 8;
		} while ( cbT );

	return dwChecksum;
	}


//  ================================================================
static DWORD DwChecksumESE64Bit( const BYTE * const pb, const DWORD cb )
//  ================================================================
	{
	const unsigned __int64	* pqw 	= (unsigned __int64 *)pb;
	unsigned __int64	qwChecksum	= 0;
	DWORD cbT						= cb;
	
	//	checksum the first four bytes twice to remove the checksum
	
	qwChecksum ^= pqw[0] & 0x00000000FFFFFFFF;
		
	do
		{
		qwChecksum ^= pqw[0];
		qwChecksum ^= pqw[1];
		qwChecksum ^= pqw[2];
		qwChecksum ^= pqw[3];
		cbT -= ( 4 * sizeof( unsigned __int64 ) );
		pqw += 4;
		} while ( cbT );

	const unsigned __int64 qwUpper = ( qwChecksum >> ( sizeof( DWORD ) * 8 ) );
	const unsigned __int64 qwLower = qwChecksum & 0x00000000FFFFFFFF;
	qwChecksum = qwUpper ^ qwLower;
	
	const DWORD ulChecksum = static_cast<DWORD>( qwChecksum ) ^ 0x89abcdef;
	return ulChecksum;
	}


//  ================================================================
DWORD UlUtilChecksum( const BYTE* pb, DWORD cb )
//  ================================================================
	{
	static PFNCHECKSUM pfnChecksumESE = NULL;
	
	if( NULL == pfnChecksumESE )
		{
		if( !fHostIsLittleEndian )
			{
			pfnChecksumESE = DwChecksumESEBigEndian;
			}
		else if( sizeof( DWORD_PTR ) == sizeof( DWORD ) * 2 )
			{
			pfnChecksumESE = DwChecksumESE64Bit;
			}
		else if( FHardwareCanPrefetch() )
			{
			pfnChecksumESE = DwChecksumESEPrefetch;
			}
		else
			{
			pfnChecksumESE = DwChecksumESENoPrefetch;
			}
		}
	return (*pfnChecksumESE)( pb, cb );
	}
#pragma optimize( "", on )


INLINE BOOL FValidCbPage( const ULONG cb )
	{
	return ( 0 == cb || cbPageDefault == cb || 2048 == cb || 8192 == cb );
	}

/****************************
/*	read shadowed header. The header is multiple sectors.
/*  Checksum must be the first 4 bytes of the header.
/**/

#define HEADER_OK	0
#define PRIMARY_BAD	1
#define SHADOW_BAD	2
#define	HEADER_BAD 	( PRIMARY_BAD | SHADOW_BAD )

ERR ErrUtilOnlyReadShadowedHeader(
	IFileSystemAPI	* const pfsapi,
	const _TCHAR	* szFileName,
	BYTE			* pbHeader,
	const DWORD		cbHeader,
	const ULONG		cbOffsetOfPageSize,
	INT				* pbHeaderDamaged,
	IFileAPI		* const pfapi )
	{
	ERR				err			= JET_errSuccess;
	IFileAPI		* pfapiT	= NULL;
	ERR				errT		= JET_errSuccess;
	BYTE			* pbT		= NULL;

	*pbHeaderDamaged = HEADER_OK;
	pbT = (BYTE*)PvOSMemoryHeapAlloc( cbHeader );
	if ( pbT == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	if ( !pfapi )
		{
		pfapiT = NULL;
		
		//  open the specified file

		Call( pfsapi->ErrFileOpen( szFileName, &pfapiT, fTrue ) );
		}
	else
		{
		pfapiT = pfapi;
		}

	//  read the primary copy of the header into the specified buffer

	err = pfapiT->ErrIORead( QWORD( 0 ), cbHeader, pbHeader );

	//  the primary copy of the header is damaged
	
	if ( err < 0 )
		{
		*pbHeaderDamaged |= PRIMARY_BAD;
		}
	else if ( UlUtilChecksum( pbHeader, cbHeader ) != DWORD( *( (LittleEndian<DWORD>*)pbHeader ) ) )
		{
		*pbHeaderDamaged |= PRIMARY_BAD;

		// checksum error in header
		// check if pagesize is wrong (if call is made with location of pagesize specified)
		if ( 0 != cbOffsetOfPageSize )
			{
			Assert( cbHeader > 0 );
			Assert( FValidCbPage( cbHeader ) );

			// requested size must "cover" the cbPageSize member in structure
			Assert( cbHeader >= cbOffsetOfPageSize + sizeof(ULONG));

			ULONG	cbPageSize 	= *( (UnalignedLittleEndian<ULONG> *)( pbHeader + cbOffsetOfPageSize ) );
			if ( FValidCbPage( cbPageSize ) )
				{
				if ( 0 == cbPageSize )
					{
					cbPageSize = cbPageDefault;
					}
				if ( cbPageSize != cbHeader )
					{
					Call( ErrERRCheck( JET_errPageSizeMismatch ) );
					}
				}
			}
		}

	errT = pfapiT->ErrIORead( QWORD( cbHeader ), cbHeader, pbT );

	if ( errT < 0 || UlUtilChecksum( pbT, cbHeader ) != *( (LittleEndian<DWORD>*) pbT ) )
		{
		*pbHeaderDamaged |= SHADOW_BAD;
		if ( errT >= 0 )
			{
			errT = ErrERRCheck( JET_errDiskIO );
			}
		}
	switch ( *pbHeaderDamaged )
		{
	case HEADER_OK:
		if ( memcmp( pbT, pbHeader, cbHeader ) != 0 )
			{
			*pbHeaderDamaged = PRIMARY_BAD;
			}
		else
			{
			break;
			}
	case PRIMARY_BAD:
		Assert( *pbHeaderDamaged == PRIMARY_BAD );
		memcpy( pbHeader, pbT, cbHeader );
		break;
	case SHADOW_BAD:
		Assert( *pbHeaderDamaged == SHADOW_BAD );
		break;
	case HEADER_BAD:
		Assert( *pbHeaderDamaged == HEADER_BAD );
		err = errT;
		break;
	default:
		Assert( fFalse );
		}

#ifdef NEVER
	if ( *pfPrimaryDamaged )
		{
		//  read the secondary copy of the header into the specified buffer
		err = pfapiT->ErrIORead( QWORD( cbHeader ), cbHeader, pbHeader );

		//  the secondary copy of the header is damaged
		
		if ( err >= 0 && UlUtilChecksum( pbHeader, cbHeader ) != *( (LittleEndian<DWORD>*) pbHeader ) )
			{
			//  we have failed to read the header
			err = ErrERRCheck( JET_errDiskIO );
			}
		}
#endif		
		
HandleError:
	if ( !pfapi )
		{
		delete pfapiT;
		}
	OSMemoryHeapFree( pbT );
	return err;
	}


/***************************
/* Read shadowed header
/*
/* PURPOSE: Read only access to file.
/*	It will not try to patch damaged
/*	primary page with secondary one if last is OK
/**/
ERR ErrUtilReadShadowedHeader(
	IFileSystemAPI	* const pfsapi,
	const _TCHAR	* szFileName,
	BYTE*			pbHeader,
	const DWORD		cbHeader,
	const ULONG		cbOffsetOfPageSize,
	IFileAPI 		* const pfapi )
	{
	ERR				err;
	INT				bHeaderDamaged;

	Call( ErrUtilOnlyReadShadowedHeader(	pfsapi, 
											szFileName, 
											pbHeader, 
											cbHeader, 
											cbOffsetOfPageSize, 
											&bHeaderDamaged, 
											pfapi ) );

	//	if succeed to read the page but primary page is damaged
	//	it wont be fixed anyway so put a message in event log, 
	//	because assumption that file is read only for this user
	if ( bHeaderDamaged )
		{
		Assert( bHeaderDamaged == PRIMARY_BAD || bHeaderDamaged == SHADOW_BAD );
		
		const _TCHAR	* rgszT[1] = { szFileName };
		UtilReportEvent(
			eventWarning,
			LOGGING_RECOVERY_CATEGORY,
			( PRIMARY_BAD == bHeaderDamaged ? PRIMARY_PAGE_READ_FAIL_ID : SHADOW_PAGE_READ_FAIL_ID ),
			1,
			rgszT,
			0,
			NULL,
			pfsapi->Pinst() );
		}
			
HandleError:
	return err;
	}
	

/***************************
/* Read shadowed header abd patch primary page if neccessary
/*
/* if primary page is corrupted and secondary is fine 
/* then patch the primary page with the secondary
/*
/* WARNING: Write access is neccessary
/**/
ERR ErrUtilReadAndFixShadowedHeader(
	IFileSystemAPI *const	pfsapi,
	const _TCHAR*			szFileName,
	BYTE*					pbHeader,
	const DWORD				cbHeader,
	const ULONG				cbOffsetOfPageSize,
	IFileAPI *const			pfapi )
	{
	ERR err;
	INT bHeaderDamaged;
	
	Call( ErrUtilOnlyReadShadowedHeader(	pfsapi, 
											szFileName, 
											pbHeader, 
											cbHeader, 
											cbOffsetOfPageSize, 
											&bHeaderDamaged, 
											pfapi ) );

	if ( bHeaderDamaged )
		{
		Assert( bHeaderDamaged == PRIMARY_BAD || bHeaderDamaged == SHADOW_BAD );
		// try to patch the bad page
		// and if do not succeed then put the warning in the event log

		IFileAPI	*pfapiT = NULL;

		if ( !pfapi )
			{
			
			//  open the specified file

			err = pfsapi->ErrFileOpen( szFileName, &pfapiT, fFalse );
			}
		else
			{
			//	file is already open 
			pfapiT = pfapi;
			err = JET_errSuccess;
			}
		if ( err >= 0 )
			{
			Assert( bHeaderDamaged == PRIMARY_BAD || bHeaderDamaged == SHADOW_BAD );
			err = pfapiT->ErrIOWrite( QWORD( (bHeaderDamaged == PRIMARY_BAD)?0: cbHeader ), cbHeader, pbHeader );
			}
		if ( err < 0 )
			{
			CHAR szT[12];
			const _TCHAR* rgszT[2] = { szFileName, szT };
			_itoa( err, szT, 10 );

			UtilReportEvent(
					eventError,
					LOGGING_RECOVERY_CATEGORY,
					SHADOW_PAGE_WRITE_FAIL_ID,
					2,
					rgszT,
					0,
					NULL,
					pfsapi->Pinst() );
			}
		if ( !pfapi )
			{
			//	we opened the file on behalf of the user, so we should now clean it up
			
			delete pfapiT;
			}
		}

HandleError:
	return err;
	}


ERR ErrUtilWriteShadowedHeader(	IFileSystemAPI *const	pfsapi, 
								const _TCHAR			*szFileName, 
								const BOOL				fAtomic,
								BYTE					*pbHeader, 
								const DWORD 			cbHeader, 
								IFileAPI *const			pfapi )
	{
	ERR err;
	IFileAPI *pfapiT;
	
	if ( !pfapi )
		{
		pfapiT = NULL;
		
		//  open the specified file

		err = pfsapi->ErrFileOpen( szFileName, &pfapiT );

		//  we could not open the file

		if ( JET_errFileNotFound == err )
			{
			//  create the specified file

			Call( pfsapi->ErrFileCreate( szFileName, &pfapiT, fAtomic ) );
			Call( pfapiT->ErrSetSize( 2 * QWORD( cbHeader ) ) );
			}
		Call( err );
		}
	else
		{
		pfapiT = pfapi;
		}

	//  compute the checksum of the header to write

	*( (LittleEndian<DWORD>*) pbHeader ) = UlUtilChecksum( pbHeader, cbHeader );
	
	//  write two copies of the header synchronously.  if one is corrupted,
	//  the other will be valid containing either the old or new header data

	Call( pfapiT->ErrIOWrite( QWORD( 0 ), cbHeader, pbHeader ) );
	Call( pfapiT->ErrIOWrite( QWORD( cbHeader ), cbHeader, pbHeader ) );

HandleError:
	if ( !pfapi )
		{
		delete pfapiT;
		}

	if ( err < 0 )
		{
		CHAR szT[16];
		const _TCHAR* rgszT[2] = { szFileName, szT };
		_itoa( err, szT, 10 );

		UtilReportEvent(
				eventError,
				LOGGING_RECOVERY_CATEGORY,
				SHADOW_PAGE_WRITE_FAIL_ID,
				2,
				rgszT,
				0,
				NULL,
				pfsapi->Pinst() );
		}
		
	return err;
	}


ERR ErrUtilFullPathOfFile( 
	IFileSystemAPI* const	pfsapi, 
	_TCHAR* const			szPathOnly,
	const _TCHAR* const		szFile )
	{
	ERR						err;
	_TCHAR					szAbsPath[IFileSystemAPI::cchPathMax];
	_TCHAR					szDir[IFileSystemAPI::cchPathMax];
	_TCHAR					szT[IFileSystemAPI::cchPathMax];

	CallR( pfsapi->ErrPathComplete( szFile, szAbsPath ) );
	CallR( pfsapi->ErrPathParse( szAbsPath, szDir, szT, szT ) );
	szT[0] = _T( '\0' );
	CallR( pfsapi->ErrPathBuild( szDir, szT, szT, szPathOnly ) );
	return JET_errSuccess;
	}


ERR ErrUtilCreatePathIfNotExist(
	IFileSystemAPI *const	pfsapi,
	const _TCHAR 			*szPath,
 	_TCHAR *const			szAbsPath )
	{
	ERR						err;
	CHAR 					szPathT[IFileSystemAPI::cchPathMax];
	CHAR					*psz, *pszT, *pszEnd, *pszMove;
	CHAR					ch;
	BOOL					fFileName = fFalse;

	//	copy the path, remove any trailing filename, and point to the ending path-delimiter
	//
	if( strlen( szPath ) >= IFileSystemAPI::cchPathMax )
		{
		CallR( ErrERRCheck( JET_errInvalidPath ) );
		}
	strcpy( szPathT, szPath );
	OSSTRCharPrev( szPathT, szPathT + strlen( szPathT ), &pszEnd );
	while ( *pszEnd != _T( bPathDelimiter ) && pszEnd >= szPathT )
		{
		fFileName = fTrue;
		OSSTRCharPrev( szPathT, pszEnd, &pszMove );
		if ( pszMove < pszEnd )
			{
			pszEnd = pszMove;
			}
		else
			{
			//	we cannot move backwards anymore
			//
			Assert( pszMove == szPathT );

			//	there were no path delimiters which means we were given only a filename.
			//	Resolve the path before returning.
			//
			err = pfsapi->ErrPathComplete( szPath, szAbsPath );
			CallR( err );
			
			return JET_errSuccess;
			}
		}
				
	Assert( *pszEnd == _T( bPathDelimiter ) );
	pszEnd[1] = _T( '\0' );

	//	loop until we find a directory that exists
	//
	psz = pszEnd;
	do
		{
		//	try to validate the current path
		//
		Assert( *psz == _T( bPathDelimiter ) );
		ch = psz[1];
		psz[1] = _T( '\0' );
		err = ErrUtilDirectoryValidate( pfsapi, szPathT );
		psz[1] = ch;
		if ( err == JET_errInvalidPath )
			{
			//	path does not exist, so we will chop off a subdirectory
			//	and try to validate the parent.
			//
			OSSTRCharPrev( szPathT, psz, &pszT );
			while ( *pszT != _T( bPathDelimiter ) && pszT >= szPathT )
				{
				OSSTRCharPrev( szPathT, pszT, &pszMove );
				if ( pszMove < pszT )
					{
					pszT = pszMove;
					}
				else
					{
					//	we cannot move backwards anymore
					//
					Assert( pszMove == szPathT );

					//	none of the directories in the path exist
					//	we need to start creating at this point
					//	from the outer-most directory.
					//
					goto BeginCreation;
					}
				}

			//	move the real path ptr
			//
			psz = pszT;
			}
		else
			{
			//	we found an existing directory
			//
			CallS( err );			
			}
		}
	while ( err == JET_errInvalidPath );

	//	loop until all directories are created
	//
	while ( psz < pszEnd )
		{

		//	move forward to the next directory
		//
		Assert( *psz == _T( bPathDelimiter ) );
		psz++;
		while ( *psz != _T( bPathDelimiter ) )
			{
#ifdef DEBUG
			OSSTRCharNext( psz, &pszMove );

			//	if this assert fires, it means we scanned to the end 
			//	of the path string and did not find a path
			//	delimiter; this should never happen because
			//	we append a path delimiter at the start of
			//	this function.
			//
			Assert( pszMove <= pszEnd );

			//	if this assert fires, the one before it should have
			//	fired as well; this means that we can no longer
			//	move to the next character because the string
			//	is completely exhausted.
			//		
			Assert( pszMove > psz );

			//	move next
			//
			psz = pszMove;
#else	//	!DEBUG
			OSSTRCharNext( psz, &psz );
#endif	//	DEBUG
			}

BeginCreation:
		Assert( psz <= pszEnd );
		Assert( *psz == _T( bPathDelimiter ) );

		//	make sure the name of the directory we
		//	need to create is not already in use by a file
		//
		ch = psz[0];
		psz[0] = _T( '\0' );
		err = ErrUtilPathExists( pfsapi, szPathT );
		if ( err >= JET_errSuccess )
			{
			return ErrERRCheck( JET_errInvalidPath );
			}
		else if ( JET_errFileNotFound != err )
			{
			return err;		//	unexpected error
			}
		psz[0] = ch;

		//	create the directory
		//
		ch = psz[1];
		psz[1] = _T( '\0' );
		CallR( pfsapi->ErrFolderCreate( szPathT ) );
		psz[1] = ch;
		}

	//	verify the new path and prepare the absolute path
	//
	CallS( ErrUtilDirectoryValidate( pfsapi, szPathT, szAbsPath ) );
	if ( fFileName && szAbsPath )
		{
		OSSTRAppendPathDelimiter( szAbsPath, fTrue );

		//	copy the filename over to the absolute path as well
		//
#ifdef DEBUG
		Assert( *pszEnd == _T( bPathDelimiter ) );
		Assert( pszEnd[1] == _T( '\0' ) );
		pszT = const_cast< _TCHAR * >( szPath ) + ( pszEnd - szPathT );
		Assert( *pszT == _T( bPathDelimiter ) );
		Assert( pszT[1] != _T( '\0' ) );
#endif	//	DEBUG
		strcpy( szAbsPath + strlen( szAbsPath ), szPath + ( pszEnd - szPathT ) + 1 );
		}

	return JET_errSuccess;
	}


//  tests if the given path exists.  Full path of the given path is
//  returned in szAbsPath if that path exists and szAbsPath is not NULL.
//
ERR ErrUtilPathExists(
	IFileSystemAPI* const	pfsapi,
	const _TCHAR* const		szPath,
	_TCHAR* const			szAbsPath )
	{
	ERR						err		= JET_errSuccess;
	IFileFindAPI*			pffapi	= NULL;

	Call( pfsapi->ErrFileFind( szPath, &pffapi ) );
	Call( pffapi->ErrNext() );
	if ( szAbsPath )
		{
		Call( pffapi->ErrPath( szAbsPath ) );
		}

	delete pffapi;
	return JET_errSuccess;

HandleError:
	delete pffapi;
	if ( szAbsPath )
		{
		_tcscpy( szAbsPath, _T( "" ) );
		}
	return err;
	}


ERR ErrUtilPathComplete(
	IFileSystemAPI* const	pfsapi,
	const _TCHAR* const		szPath,
	_TCHAR* const			szAbsPath,
	const BOOL				fPathMustExist )
	{
	ERR						err;
	CHAR					rgchName[IFileSystemAPI::cchPathMax];
	
	err = pfsapi->ErrPathComplete( szPath, rgchName );
	Assert( JET_errFileNotFound != err );
	Call( err );

	//	at this point we have a "well-formed" path
	//
	
	//	do a FileFindExact to try an convert from an 8.3 equivalent to the full path
	//	but if the file doesn't exist then continue on for the temp database error-handling.
	//
	err = ErrUtilPathExists( pfsapi, rgchName, szAbsPath );
	if( JET_errFileNotFound == err && !fPathMustExist )
		{
		//	the file isn't there. we'll deal with this later
		//
		strcpy( szAbsPath, rgchName );
		err = JET_errSuccess;
		}
	Call( err );

HandleError:
	Assert( JET_errFileNotFound != err || fPathMustExist );
	return err;
	}


//  tests if the given path is read only
//
ERR ErrUtilPathReadOnly(
	IFileSystemAPI* const	pfsapi,
	const _TCHAR* const		szPath,
	BOOL* const				pfReadOnly )
	{
	ERR						err		= JET_errSuccess;
	IFileFindAPI*			pffapi	= NULL;

	Call( pfsapi->ErrFileFind( szPath, &pffapi ) );
	Call( pffapi->ErrNext() );
	Call( pffapi->ErrIsReadOnly( pfReadOnly ) );

	delete pffapi;
	return JET_errSuccess;

HandleError:
	delete pffapi;
	*pfReadOnly = fFalse;
	return err;
	}


//	checks whether or not the specified directory exists
//	if not, JET_errInvalidPath will be returned.
//	if so, JET_errSuccess will be returned and szAbsPath
//	will contain the full path to the directory.
//
ERR ErrUtilDirectoryValidate(
	IFileSystemAPI* const	pfsapi,
	const _TCHAR* const		szPath,
	_TCHAR* const			szAbsPath )
	{
	ERR						err = JET_errSuccess;
	_TCHAR					szFolder[ IFileSystemAPI::cchPathMax ];
	_TCHAR					szT[ IFileSystemAPI::cchPathMax ];
	
	//  extract the folder from the path
	//
	Call( pfsapi->ErrPathParse( szPath, szFolder, szT, szT ) );

	//  see if the path exists
	//
	Call( ErrUtilPathExists( pfsapi, szFolder, szAbsPath ) );
	return JET_errSuccess;

HandleError:
	if ( JET_errFileNotFound == err )
		{
		err = ErrERRCheck( JET_errInvalidPath );
		}
	if ( szAbsPath )
		{
		_tcscpy( szAbsPath, _T( "" ) );
		}
	return err;
	}


//  log file extension pattern buffer
//
ULONG	cbLogExtendPattern;
BYTE*	rgbLogExtendPattern;


INLINE ERR ErrUtilIApplyLogExtendPattern(
	IFileAPI *const pfapi,
	const QWORD qwSize,
	const QWORD ibFormatted = 0 )
	{
	ERR		err		= JET_errSuccess;
	QWORD	ib;
	QWORD	cbWrite;
	
	for ( ib = ibFormatted; ib < qwSize; ib += cbWrite )
		{
		//  compute the size of the current chunk to be written.  this will
		//  account for the fact that the extension area is not necessarily
		//  chunk aligned at its start or end
		//
		cbWrite = min( cbLogExtendPattern - ib % cbLogExtendPattern, qwSize - ib );

		//  zero this portion of the file with a sync write.  we use single
		//  sync writes to extend the file because it is optimal on NT due
		//  to the way its file security works wrt file extension
		//
		Call( pfapi->ErrIOWrite( ib, ULONG( cbWrite ), rgbLogExtendPattern ) );
		}

	return JET_errSuccess;

HandleError:
	return err;
	}


//	create a log file
//
ERR ErrUtilCreateLogFile(
	IFileSystemAPI *const	pfsapi,
	const _TCHAR* const		szPath,
	IFileAPI **const		ppfapi,
	const QWORD				qwSize,
	const BOOL				fOverwriteExisting )
	{
	ERR 					err;

	//	verify input
	//
	Assert( szPath );
	Assert( ppfapi );

	//	create the empty file
	//
	CallR( pfsapi->ErrFileCreate( szPath, ppfapi, fFalse, fFalse, fOverwriteExisting ) );

	//	apply the pattern to it
	//
	err = ErrUtilIApplyLogExtendPattern( *ppfapi, qwSize );
	if ( err < JET_errSuccess )
		{
		//	the operation has failed
		//

		//	close the file
		//
		delete *ppfapi;
		*ppfapi = NULL;

		//	delete the file
		//	it should be deletable, unless by some random act it was made read-only
		//	or opened by another process; in the failure case, we will leave 
		//	the malformed log file there, but it will be reformatted/resized
		//	before we actually use it -- in a sense, it will be "recreated" in-place.
		//
		ERR	errDelFile = pfsapi->ErrFileDelete( szPath );
#ifdef DEBUG
		if ( JET_errSuccess != errDelFile
			&& !FRFSFailureDetected( OSFileDelete ) )
			{
			CallS( errDelFile );
			}
#endif	//	DEBUG
		}

	return err;
	}


//	re-format an existing log file
//
ERR ErrUtilFormatLogFile( IFileAPI *const pfapi, const QWORD qwSize, const QWORD ibFormatted )
	{
	ERR 	err;
	QWORD	qwRealSize;

	//	apply the pattern to the log file
	//	(the file will expand if necessary)
	//
	CallR( ErrUtilIApplyLogExtendPattern( pfapi, qwSize, ibFormatted ) );

	//	we may need to truncate the rest of the file
	//
	CallR( pfapi->ErrSize( &qwRealSize ) );
	Assert( qwRealSize >= qwSize );
	if ( qwRealSize > qwSize )
		{

		//	do the truncation
		//
		CallR( pfapi->ErrSetSize( qwSize ) );
		}

	return JET_errSuccess;
	}


COSMemoryMap osmmOSUFile;


//  init file subsystem
//
ERR ErrOSUFileInit()
	{
	ERR err = JET_errSuccess;

	//  reset all pointers
	//
	rgbLogExtendPattern = NULL;

	//  init log file extension buffer
	//
	if ( COSMemoryMap::FCanMultiMap() )
		{
		//  set all configuration defaults
		//
		cbLogExtendPattern = 1 * 1024 * 1024;

		//  allocate log file extension buffer by allocating the smallest chunk of page
		//  store possible and remapping it consecutively in memory until we hit the
		//  desired chunk size
		//

		//	init the memory map
		//
		COSMemoryMap::ERR errOSMM;
		errOSMM = osmmOSUFile.ErrOSMMInit();
		if ( COSMemoryMap::errSuccess != errOSMM )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		//	allocate the pattern
		//
		errOSMM = osmmOSUFile.ErrOSMMPatternAlloc(	OSMemoryPageReserveGranularity(), 
													cbLogExtendPattern, 
													(void**)&rgbLogExtendPattern );
		if ( COSMemoryMap::errSuccess != errOSMM )
			{
			AssertSz(	COSMemoryMap::errOutOfBackingStore == errOSMM ||
						COSMemoryMap::errOutOfAddressSpace == errOSMM ||
						COSMemoryMap::errOutOfMemory == errOSMM, 
						"unexpected error while allocating memory pattern" );
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		Assert( rgbLogExtendPattern );
		}
	else
		{
		//  set all configuration defaults

		cbLogExtendPattern = 64 * 1024;

		//  allocate the log file extension buffer

		if ( !( rgbLogExtendPattern = (BYTE*)PvOSMemoryPageAlloc( size_t( cbLogExtendPattern ), NULL ) ) )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		}

	ULONG ib;
	ULONG cb;

	cb = 512;	//	this must be EXACTLY 512 bytes (not 1 sector)

	Assert( bLOGUnusedFill == 0xDA );	//	don't let this change
	Assert( cbLogExtendPattern >= cb );
	Assert( 0 == ( cbLogExtendPattern % cb ) );

	//	make the unique 512 byte logfile pattern
	//
	memset( rgbLogExtendPattern, bLOGUnusedFill, cb );
	for ( ib = 0; ib < cb; ib += 16 )
		{
		rgbLogExtendPattern[ib] = BYTE( bLOGUnusedFill + ib );
		}

	//	copy it until we fill the whole buffer
	//
	for ( ib = cb; ib < cbLogExtendPattern; ib += cb )
		{
		memcpy( rgbLogExtendPattern + ib, rgbLogExtendPattern, cb );
		}

	return JET_errSuccess;

HandleError:
	OSUFileTerm();
	return err;
	}


//  terminate file subsystem
//
void OSUFileTerm()
	{
	if ( COSMemoryMap::FCanMultiMap() )
		{

		//  free log file extension buffer

		if ( rgbLogExtendPattern )
			{
			osmmOSUFile.OSMMPatternFree();
			rgbLogExtendPattern = NULL;
			}

		//	term the memory map

		osmmOSUFile.OSMMTerm();
		}
	else
		{
		//  free log file extension buffer

		if ( rgbLogExtendPattern )
			{
			OSMemoryPageFree( rgbLogExtendPattern );
			rgbLogExtendPattern = NULL;
			}
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_osu\syncu.cxx ===
#include "osustd.hxx"


//  terminate sync subsystem

void OSUSyncTerm()
	{
	}

//  init sync subsystem

ERR ErrOSUSyncInit()
	{
	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_osu\osu.cxx ===
#include "osustd.hxx"

//	allocate PLS (Processor Local Storage)

static ERR ErrOSUInitProcessorLocalStorage()
	{
	extern ULONG ipinstMax;					// 	set before init is called
	extern LONG g_iPerfCounterOffset;		//  incremented in static constructors
	const size_t cbPLS = sizeof( PLS ) + ( ipinstMax + 1 ) * g_iPerfCounterOffset;

	if ( !FOSSyncConfigureProcessorLocalStorage( cbPLS ) )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}	

	//	FOSSyncPreinit counted the processors when the DLL was attached
	
	for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
		{
		PLS* const ppls = (PLS*)OSSyncGetProcessorLocalStorage( iProc );

		new( ppls ) PLS;
		}
	
	return JET_errSuccess;
	}

//	free PLS (Processor Local Storage)

static VOID OSUTermProcessorLocalStorage()
	{
	for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
		{
		PLS* const ppls = (PLS*)OSSyncGetProcessorLocalStorage( iProc );

		if ( ppls )
			{
			ppls->~PLS();
			}
		}
}

//  init OSU subsystem

const ERR ErrOSUInit()
	{
	ERR err;

	//	init PLS, perfmon (and other things) need this so do it forst

	Call( ErrOSUInitProcessorLocalStorage() );

	//  init the OS subsystem

	Call( ErrOSInit() );
	
	//  initialize all OSU subsystems in dependency order

	Call( ErrOSUTimeInit() );
	Call( ErrOSUConfigInit() );
	Call( ErrOSUEventInit() );
	Call( ErrOSUSyncInit() );
	Call( ErrOSUFileInit() );
	Call( ErrOSUNormInit() );

	return JET_errSuccess;

HandleError:
	OSUTerm();
	return err;
	}

//  terminate OSU subsystem

void OSUTerm()
	{
	//  terminate all OSU subsystems in reverse dependency order

	OSUNormTerm();
	OSUFileTerm();
	OSUSyncTerm();
	OSUEventTerm();
	OSUConfigTerm();
	OSUTimeTerm();

	//  term the OS subsystem

	OSTerm();

	//	terminate PLS last as perfmon uses it
	
	OSUTermProcessorLocalStorage();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_osu\timeu.cxx ===
#include "osustd.hxx"


#include <math.h>
#define AFX_STATIC_DATA
#define AFX_STATIC
#define AFXAPI
#define DATE double
#define FALSE 0
#define TRUE 1

///////////////////////////////////////////////////////////////////////////////
//  BEGIN:  OLE DATE code copied from VC6\MFC\SRC\olevar.cpp
///////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// COleDateTime class HELPER definitions

// Verifies will fail if the needed buffer size is too large
#define MAX_TIME_BUFFER_SIZE    128         // matches that in timecore.cpp
#define MIN_DATE                (-657434L)  // about year 100
#define MAX_DATE                2958465L    // about year 9999

// Half a second, expressed in days
#define HALF_SECOND  (1.0/172800.0)

// One-based array of days in year at month start
AFX_STATIC_DATA int _afxMonthDays[13] =
	{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};

/////////////////////////////////////////////////////////////////////////////
// COleDateTime class HELPERS - implementation

AFX_STATIC BOOL AFXAPI _AfxOleDateFromTm(WORD wYear, WORD wMonth, WORD wDay,
	WORD wHour, WORD wMinute, WORD wSecond, DATE& dtDest)
{
	// Validate year and month (ignore day of week and milliseconds)
	if (wYear > 9999 || wMonth < 1 || wMonth > 12)
		return FALSE;

	//  Check for leap year and set the number of days in the month
	BOOL bLeapYear = ((wYear & 3) == 0) &&
		((wYear % 100) != 0 || (wYear % 400) == 0);

	int nDaysInMonth =
		_afxMonthDays[wMonth] - _afxMonthDays[wMonth-1] +
		((bLeapYear && wDay == 29 && wMonth == 2) ? 1 : 0);

	// Finish validating the date
	if (wDay < 1 || wDay > nDaysInMonth ||
		wHour > 23 || wMinute > 59 ||
		wSecond > 59)
	{
		return FALSE;
	}

	// Cache the date in days and time in fractional days
	long nDate;
	double dblTime;

	//It is a valid date; make Jan 1, 1AD be 1
	nDate = wYear*365L + wYear/4 - wYear/100 + wYear/400 +
		_afxMonthDays[wMonth-1] + wDay;

	//  If leap year and it's before March, subtract 1:
	if (wMonth <= 2 && bLeapYear)
		--nDate;

	//  Offset so that 12/30/1899 is 0
	nDate -= 693959L;

	dblTime = (((long)wHour * 3600L) +  // hrs in seconds
		((long)wMinute * 60L) +  // mins in seconds
		((long)wSecond)) / 86400.;

	dtDest = (double) nDate + ((nDate >= 0) ? dblTime : -dblTime);

	return TRUE;
}

AFX_STATIC BOOL AFXAPI _AfxTmFromOleDate(DATE dtSrc, struct tm& tmDest)
{
	// The legal range does not actually span year 0 to 9999.
	if (dtSrc > MAX_DATE || dtSrc < MIN_DATE) // about year 100 to about 9999
		return FALSE;

	long nDays;             // Number of days since Dec. 30, 1899
	long nDaysAbsolute;     // Number of days since 1/1/0
	long nSecsInDay;        // Time in seconds since midnight
	long nMinutesInDay;     // Minutes in day

	long n400Years;         // Number of 400 year increments since 1/1/0
	long n400Century;       // Century within 400 year block (0,1,2 or 3)
	long n4Years;           // Number of 4 year increments since 1/1/0
	long n4Day;             // Day within 4 year block
							//  (0 is 1/1/yr1, 1460 is 12/31/yr4)
	long n4Yr;              // Year within 4 year block (0,1,2 or 3)
	BOOL bLeap4 = TRUE;     // TRUE if 4 year block includes leap year

	double dblDate = dtSrc; // tempory serial date

	// If a valid date, then this conversion should not overflow
	nDays = (long)dblDate;

	// Round to the second
	dblDate += ((dtSrc > 0.0) ? HALF_SECOND : -HALF_SECOND);

	nDaysAbsolute = (long)dblDate + 693959L; // Add days from 1/1/0 to 12/30/1899

	dblDate = fabs(dblDate);
	nSecsInDay = (long)((dblDate - floor(dblDate)) * 86400.);

	// Calculate the day of week (sun=1, mon=2...)
	//   -1 because 1/1/0 is Sat.  +1 because we want 1-based
	tmDest.tm_wday = (int)((nDaysAbsolute - 1) % 7L) + 1;

	// Leap years every 4 yrs except centuries not multiples of 400.
	n400Years = (long)(nDaysAbsolute / 146097L);

	// Set nDaysAbsolute to day within 400-year block
	nDaysAbsolute %= 146097L;

	// -1 because first century has extra day
	n400Century = (long)((nDaysAbsolute - 1) / 36524L);

	// Non-leap century
	if (n400Century != 0)
	{
		// Set nDaysAbsolute to day within century
		nDaysAbsolute = (nDaysAbsolute - 1) % 36524L;

		// +1 because 1st 4 year increment has 1460 days
		n4Years = (long)((nDaysAbsolute + 1) / 1461L);

		if (n4Years != 0)
			n4Day = (long)((nDaysAbsolute + 1) % 1461L);
		else
		{
			bLeap4 = FALSE;
			n4Day = (long)nDaysAbsolute;
		}
	}
	else
	{
		// Leap century - not special case!
		n4Years = (long)(nDaysAbsolute / 1461L);
		n4Day = (long)(nDaysAbsolute % 1461L);
	}

	if (bLeap4)
	{
		// -1 because first year has 366 days
		n4Yr = (n4Day - 1) / 365;

		if (n4Yr != 0)
			n4Day = (n4Day - 1) % 365;
	}
	else
	{
		n4Yr = n4Day / 365;
		n4Day %= 365;
	}

	// n4Day is now 0-based day of year. Save 1-based day of year, year number
	tmDest.tm_yday = (int)n4Day + 1;
	tmDest.tm_year = n400Years * 400 + n400Century * 100 + n4Years * 4 + n4Yr;

	// Handle leap year: before, on, and after Feb. 29.
	if (n4Yr == 0 && bLeap4)
	{
		// Leap Year
		if (n4Day == 59)
		{
			/* Feb. 29 */
			tmDest.tm_mon = 2;
			tmDest.tm_mday = 29;
			goto DoTime;
		}

		// Pretend it's not a leap year for month/day comp.
		if (n4Day >= 60)
			--n4Day;
	}

	// Make n4DaY a 1-based day of non-leap year and compute
	//  month/day for everything but Feb. 29.
	++n4Day;

	// Month number always >= n/32, so save some loop time */
	for (tmDest.tm_mon = (n4Day >> 5) + 1;
		n4Day > _afxMonthDays[tmDest.tm_mon]; tmDest.tm_mon++);

	tmDest.tm_mday = (int)(n4Day - _afxMonthDays[tmDest.tm_mon-1]);

DoTime:
	if (nSecsInDay == 0)
		tmDest.tm_hour = tmDest.tm_min = tmDest.tm_sec = 0;
	else
	{
		tmDest.tm_sec = (int)nSecsInDay % 60L;
		nMinutesInDay = nSecsInDay / 60L;
		tmDest.tm_min = (int)nMinutesInDay % 60;
		tmDest.tm_hour = (int)nMinutesInDay / 60;
	}

	return TRUE;
}

AFX_STATIC void AFXAPI _AfxTmConvertToStandardFormat(struct tm& tmSrc)
{
	// Convert afx internal tm to format expected by runtimes (_tcsftime, etc)
	tmSrc.tm_year -= 1900;  // year is based on 1900
	tmSrc.tm_mon -= 1;      // month of year is 0-based
	tmSrc.tm_wday -= 1;     // day of week is 0-based
	tmSrc.tm_yday -= 1;     // day of year is 0-based
}

AFX_STATIC double AFXAPI _AfxDoubleFromDate(DATE dt)
{
	// No problem if positive
	if (dt >= 0)
		return dt;

	// If negative, must convert since negative dates not continuous
	// (examples: -1.25 to -.75, -1.50 to -.50, -1.75 to -.25)
	double temp = ceil(dt);
	return temp - (dt - temp);
}

AFX_STATIC DATE AFXAPI _AfxDateFromDouble(double dbl)
{
	// No problem if positive
	if (dbl >= 0)
		return dbl;

	// If negative, must convert since negative dates not continuous
	// (examples: -.75 to -1.25, -.50 to -1.50, -.25 to -1.75)
	double temp = floor(dbl); // dbl is now whole part
	return temp + (temp - dbl);
}

///////////////////////////////////////////////////////////////////////////////
//  END:  OLE DATE code copied from VC6\MFC\SRC\olevar.cpp
///////////////////////////////////////////////////////////////////////////////


//  returns the date and time in date serial format:  Date and time values
//  between the years 100 and 9999. Stored as a floating-point value. The
//  integer portion represents the number of days since December 30, 1899. The
//  fractional portion represents the number of seconds since midnight.

void UtilGetDateTime( DATESERIAL *pdt )
	{
	//  get the current date and time
	
	DATETIME dt;
	UtilGetCurrentDateTime( &dt );

	//  convert the date and time into a JET_DATESERIAL (a.k.a. OLE DATE)

	if ( !_AfxOleDateFromTm(	WORD( dt.year ),
								WORD( dt.month ),
								WORD( dt.day ),
								WORD( dt.hour ),
								WORD( dt.minute ),
								WORD( dt.second ),
								*pdt ) )
		{
		AssertSz( fFalse, "Invalid date:  Is it really 10000 A.D. already?" );
		}
	}


//  terminate time subsystem

void OSUTimeTerm()
	{
	//  nop
	}

//  init time subsystem

ERR ErrOSUTimeInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\dllentry.cxx ===
#include "osstd.hxx"


#define _DECL_DLLMAIN
#include <process.h>


//  OS Layer Init / Term functions

extern BOOL FOSPreinit();
extern void OSPostterm();


//  external parameters

extern volatile BOOL fProcessAbort;


//  DLL Entry Point

extern BOOL FINSTSomeInitialized();
extern BOOL FreeAllInitFaildInstances();

volatile DWORD tidDLLEntryPoint;

extern "C"
	{	
	BOOL WINAPI DLLEntryPoint( void* hinstDLL, DWORD fdwReason, LPVOID lpvReserved )
		{
		tidDLLEntryPoint = GetCurrentThreadId();
		
		BOOL fResult = fTrue;

		switch( fdwReason )
			{
			case DLL_THREAD_ATTACH:
				fResult = fResult && _CRT_INIT( hinstDLL, fdwReason, lpvReserved );
				break;

			case DLL_THREAD_DETACH:
				(void)_CRT_INIT( hinstDLL, fdwReason, lpvReserved );
				OSThreadDetach();
				OSSyncDetach();
				break;

			case DLL_PROCESS_ATTACH:

				//  init OS Layer

				fResult = fResult && FOSPreinit();

				//  init CRT

				fResult = fResult && _CRT_INIT( hinstDLL, fdwReason, lpvReserved );
				break;

			case DLL_PROCESS_DETACH:
				
				//  if JET is still initialized, we are experiencing an abnormal
				//  termination
				fProcessAbort = fProcessAbort || FINSTSomeInitialized();

				//  terminate CRT
				
				(void)_CRT_INIT( hinstDLL, fdwReason, lpvReserved );

				//  terminate OS Layer

				OSPostterm();
				break;
			}

		tidDLLEntryPoint = 0;
			
		return fResult;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\cprintf.cxx ===
#include "osstd.hxx"


CPRINTFNULL cprintfNull;

CPRINTFSTDOUT cprintfStdout;

#ifdef DEBUG

CPRINTFDEBUG cprintfDEBUG;

#endif  //  DEBUG


//  ================================================================
CPRINTF* CPRINTFDBGOUT::PcprintfInstance()
//  ================================================================
	{
	static CPRINTFDBGOUT cprintfDbgout;
	return &cprintfDbgout;
	}

//  ================================================================
void __cdecl CPRINTFDBGOUT::operator()( const _TCHAR* szFormat, ... ) const
//  ================================================================
	{
	CHAR	szBuf[1024];
	int		cchT;
	
	va_list arg_ptr;
	va_start( arg_ptr, szFormat );
	cchT = _vstprintf( szBuf, szFormat, arg_ptr );
	va_end( arg_ptr );
	Assert( cchT < 1024 );
	OutputDebugString( szBuf );
	}


CPRINTFFILE::CPRINTFFILE( const _TCHAR* szFile )
	{
	//  open the file for append

	if ( ( m_hFile = (void*)CreateFile( szFile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ) ) == INVALID_HANDLE_VALUE )
		{
		return;
		}
	SetHandleInformation( HANDLE( m_hFile ), HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	if ( !( m_hMutex = (void*)CreateMutex( NULL, FALSE, NULL ) ) )
		{
		SetHandleInformation( HANDLE( m_hFile ), HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( HANDLE( m_hFile ) );
		m_hFile = INVALID_HANDLE_VALUE;
		return;
		}
	SetHandleInformation( HANDLE( m_hMutex ), HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	}

CPRINTFFILE::~CPRINTFFILE()
	{
	//  close the file

	if ( m_hMutex )
		{
		SetHandleInformation( HANDLE( m_hMutex ), HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( HANDLE( m_hMutex ) );
		m_hMutex = NULL;
		}

	if ( m_hFile != INVALID_HANDLE_VALUE )
		{
		SetHandleInformation( HANDLE( m_hFile ), HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( HANDLE( m_hFile ) );
		m_hFile = INVALID_HANDLE_VALUE;
		}
	}

//  ================================================================
void __cdecl CPRINTFFILE::operator()( const _TCHAR* szFormat, ... ) const
//  ================================================================
	{
	if ( HANDLE( m_hFile ) != INVALID_HANDLE_VALUE )
		{
		const SIZE_T cchBuf = 1024;
		_TCHAR szBuf[ cchBuf ];

		//  print into a temp buffer, truncating the string if too large
		
		va_list arg_ptr;
		va_start( arg_ptr, szFormat );
		_vsntprintf( szBuf, cchBuf - 1, szFormat, arg_ptr );
		szBuf[ cchBuf - 1 ] = 0;
		va_end( arg_ptr );
		
		//  append the string to the file

		WaitForSingleObject( HANDLE( m_hMutex ), INFINITE );

		SetFilePointer( HANDLE( m_hFile ), 0, NULL, FILE_END );

		DWORD cbWritten;
		WriteFile( HANDLE( m_hFile ), szBuf, (ULONG)(_tcslen( szBuf ) * sizeof( _TCHAR )), &cbWritten, NULL );

		ReleaseMutex( HANDLE( m_hMutex ) );
		}
	}
	

//  ================================================================
CPRINTFTLSPREFIX::CPRINTFTLSPREFIX( CPRINTF* pcprintf, const _TCHAR* const szPrefix ) :
//  ================================================================
	m_cindent( 0 ),
	m_pcprintf( pcprintf ),
	m_szPrefix( szPrefix )
	{
	}

	
//  ================================================================
void __cdecl CPRINTFTLSPREFIX::operator()( const _TCHAR* szFormat, ... ) const
//  ================================================================
	{		
	_TCHAR rgchBuf[1024];
	_TCHAR *pchBuf = rgchBuf;

	if( Ptls()->szCprintfPrefix )
		{
		pchBuf += _stprintf( pchBuf, "%s:\t%d:\t", Ptls()->szCprintfPrefix, DwUtilThreadId() );
		}
	if( m_szPrefix )
		{
		pchBuf += _stprintf( pchBuf, _T( "%s" ), m_szPrefix );
		}

	va_list arg_ptr;
	va_start( arg_ptr, szFormat );
	_vstprintf( pchBuf, szFormat, arg_ptr );
	va_end( arg_ptr );

	(*m_pcprintf)( _T( "%s" ), rgchBuf );
	}


//  ================================================================
INLINE void CPRINTFTLSPREFIX::Indent()
//  ================================================================
	{
	}


//  ================================================================
INLINE void CPRINTFTLSPREFIX::Unindent()
//  ================================================================
	{
	}



//  retrieves the current width of stdout

DWORD UtilCprintfStdoutWidth()
	{
	//	open stdout
	//
	HANDLE hConsole = GetStdHandle( STD_OUTPUT_HANDLE );
	if( INVALID_HANDLE_VALUE == hConsole )
		{
		return 80;
		}

	//	get attributes of console receiving stdout
	//
	CONSOLE_SCREEN_BUFFER_INFO csbi;
	const BOOL fSuccess = GetConsoleScreenBufferInfo( hConsole, &csbi );

	//	return width of console window or the standard 80 if unknown
	//
	return fSuccess ? csbi.dwMaximumWindowSize.X : 80;
	}

	
//  post-terminate cprintf subsystem

void OSCprintfPostterm()
	{
	//  nop
	}

//  pre-init cprintf subsystem

BOOL FOSCprintfPreinit()
	{
	//  nop

	return fTrue;
	}


//  terminate cprintf subsystem

void OSCprintfTerm()
	{
	//  nop
	}

//  init cprintf subsystem

ERR ErrOSCprintfInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\config.cxx ===
#include "osstd.hxx"


#ifdef DISABLE_REGISTRY
#else

//  Persistent Configuration Management
//
//  Configuration information is organized in a way very similar to a file
//  system.  Each configuration datum is a name and value pair stored in a
//  path.  All paths, names, ans values are text strings.
//
//  For Win32, we will store this information in the registry under the
//  following two paths:
//
//    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\<Image Name>\Global\
//    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\<Image Name>\Process\<Process Name>\
//
//  Global settings are overridden by Process settings.

LOCAL _TCHAR szConfigGlobal[_MAX_PATH];
LOCAL _TCHAR szConfigProcess[_MAX_PATH];

//  sets the specified name in the specified path to the given value, returning
//  fTrue on success.  any intermediate path that does not exist will be created
//
//  NOTE:  either '/' or '\\' is a valid path separator

const BOOL FOSConfigISet( _TCHAR* const szPath, const _TCHAR* const szName, const _TCHAR* const szValue )
	{
	//  create / open each path segment, returning fFalse on any failures

	const _TCHAR szDelim[] = _T( "/\\" );
	_TCHAR* szPathSeg = _tcstok( szPath, szDelim );
	HKEY hkeyPathSeg = HKEY_LOCAL_MACHINE;
	
	while ( szPathSeg != NULL )
		{
		HKEY hkeyPathSegOld = hkeyPathSeg;
		DWORD dwDisposition;
		DWORD dw = RegCreateKeyEx(	hkeyPathSegOld,
									szPathSeg,
									0,
									NULL,
									REG_OPTION_NON_VOLATILE,
									KEY_WRITE,
									NULL,
									&hkeyPathSeg,
									&dwDisposition );

		if ( hkeyPathSegOld != HKEY_LOCAL_MACHINE )
			{
			DWORD dwClosedKey = RegCloseKey( hkeyPathSegOld );
			Assert( dwClosedKey == ERROR_SUCCESS );
			}
		
		if ( dw != ERROR_SUCCESS )
			{
			return fFalse;
			}

		szPathSeg = _tcstok( NULL, szDelim );
		}

	//  delete existing name so that in case it has the wrong type, there will
	//  be no problems setting it

	(void)RegDeleteValue(	hkeyPathSeg,
							szName );

	//  set name to value

	DWORD dw = RegSetValueEx(	hkeyPathSeg,
								szName,
								0,
								REG_SZ,
								(LPBYTE)szValue,
								(ULONG)_tcslen( szValue ) + 1 );

	//  close path
	
	DWORD dwClosedKey = RegCloseKey( hkeyPathSeg );
	Assert( dwClosedKey == ERROR_SUCCESS );

	//  return result of setting the name to the value as our success

	return dw == ERROR_SUCCESS;
	}

const BOOL FOSConfigSet( const _TCHAR* const szPath, const _TCHAR* const szName, const _TCHAR* const szValue )
	{
	//  validate IN args

	Assert( szPath != NULL );
	Assert( _tcslen( szPath ) > 0 );
	Assert( _tcslen( szConfigProcess ) + _tcslen( szPath ) < _MAX_PATH );
	Assert( szPath[0] != _T( '/' ) );
	Assert( szPath[0] != _T( '\\' ) );
	Assert( szPath[_tcslen( szPath ) - 1] != _T( '/' ) );
	Assert( szPath[_tcslen( szPath ) - 1] != _T( '\\' ) );
	Assert( szName != NULL );
	Assert( _tcslen( szName ) > 0 );
	Assert( szValue != NULL );

	//  convert any '/' in the relative path into '\\'

	_TCHAR szRelPath[_MAX_PATH];
	for ( int itch = 0; szPath[itch]; itch++ )
		{
		if ( szPath[itch] == _T( '/' ) )
			{
			szRelPath[itch] = _T( '\\' );
			}
		else
			{
			szRelPath[itch] = szPath[itch];
			}
		}
	szRelPath[itch] = 0;

	//  build the absolute path to our process configuration

	_TCHAR szAbsPath[_MAX_PATH];
	_tcscpy( szAbsPath, szConfigProcess );
	_tcscat( szAbsPath, szRelPath );

	//  set our process configuration

	return FOSConfigISet( szAbsPath, szName, szValue );
	}

//  gets the value of the specified name in the specified path and places it in
//  the provided buffer, returning fFalse if the buffer is too small.  if the
//  value is not set, an empty string will be returned
//
//  NOTE:  either '/' or '\\' is a valid path separator

const BOOL FOSConfigIGet( _TCHAR* const szPath, const _TCHAR* const szName, _TCHAR* const szBuf, const long cbBuf )
	{
	//  open registry key with this path

	HKEY hkeyPath;
	DWORD dw = RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
								szPath,
								0,
								KEY_READ,
								&hkeyPath );

	//  we failed to open the key
	
	if ( dw != ERROR_SUCCESS )
		{
		//  create the key / value with a NULL value, ignoring any errors

		(void)FOSConfigISet( szPath, szName, _T( "" ) );

		//  return an empty string if space permits

		if ( cbBuf >= sizeof( szBuf[0] ) )
			{
			szBuf[0] = 0;
			return fTrue;
			}
		else
			{
			return fFalse;
			}
		}

	//  retrieve the value into the user buffer

	DWORD dwType;
	DWORD cbValue = cbBuf;
	dw = RegQueryValueEx(	hkeyPath,
							szName,
							0,
							&dwType,
							(LPBYTE)szBuf,
							&cbValue );
							
	//  there was some error reading the value
	
	if ( dw != ERROR_SUCCESS || dwType != REG_SZ )
		{
		//  close the key
		
		DWORD dwClosedKey = RegCloseKey( hkeyPath );
		Assert( dwClosedKey == ERROR_SUCCESS );
		
		//  create the key / value with a NULL value, ignoring any errors

		(void)FOSConfigISet( szPath, szName, _T( "" ) );

		//  return an empty string if space permits

		if ( cbBuf >= sizeof( szBuf[0] ) )
			{
			szBuf[0] = 0;
			return fTrue;
			}
		else
			{
			return fFalse;
			}
		}

	//  if the value is bigger than the buffer, return fFalse

	if ( cbValue > cbBuf )
		{
		DWORD dwClosedKey = RegCloseKey( hkeyPath );
		Assert( dwClosedKey == ERROR_SUCCESS );
		return fFalse;
		}

	//  we succeeded in reading the value, so close the key and return

	DWORD dwClosedKey = RegCloseKey( hkeyPath );
	Assert( dwClosedKey == ERROR_SUCCESS );
	return fTrue;
	}

const BOOL FOSConfigGet( const _TCHAR* const szPath, const _TCHAR* const szName, _TCHAR* const szBuf, const long cbBuf )
	{
	//  validate IN args

	Assert( szPath != NULL );
	Assert( _tcslen( szPath ) > 0 );
	Assert( _tcslen( szConfigGlobal ) + _tcslen( szPath ) < _MAX_PATH );
	Assert( _tcslen( szConfigProcess ) + _tcslen( szPath ) < _MAX_PATH );
	Assert( szPath[0] != _T( '/' ) );
	Assert( szPath[0] != _T( '\\' ) );
	Assert( szPath[_tcslen( szPath ) - 1] != _T( '/' ) );
	Assert( szPath[_tcslen( szPath ) - 1] != _T( '\\' ) );
	Assert( szName != NULL );
	Assert( _tcslen( szName ) > 0 );
	Assert( szBuf != NULL );

	//  convert any '/' in the relative path into '\\'

	_TCHAR szRelPath[_MAX_PATH];
	for ( int itch = 0; szPath[itch]; itch++ )
		{
		if ( szPath[itch] == _T( '/' ) )
			{
			szRelPath[itch] = _T( '\\' );
			}
		else
			{
			szRelPath[itch] = szPath[itch];
			}
		}
	szRelPath[itch] = 0;

	//  build the absolute path to our process configuration

	_TCHAR szAbsPath[_MAX_PATH];
	_tcscpy( szAbsPath, szConfigProcess );
	_tcscat( szAbsPath, szRelPath );

	//  get our process configuration, failing on insufficient buffer

	if ( !FOSConfigIGet( szAbsPath, szName, szBuf, cbBuf ) )
		{
		return fFalse;
		}

	//  if we have process specific configuration, we're done

	if ( szBuf[0] )
		{
		return fTrue;
		}

	//  build the absolute path to our global configuration

	_tcscpy( szAbsPath, szConfigGlobal );
	_tcscat( szAbsPath, szRelPath );

	//  return our global configuration, whatever it is

	return FOSConfigIGet( szAbsPath, szName, szBuf, cbBuf );
	}

#endif	//	DISABLE_REGISTRY

//  post-terminates the configuration subsystem

void OSConfigPostterm()
	{
	//  nop
	}

//  pre-initializes the configuration subsystem

BOOL FOSConfigPreinit()
	{
#ifdef DISABLE_REGISTRY
#else
	//  build configuration paths

	szConfigGlobal[0] = 0;
	_tcscat( szConfigGlobal, _T( "SOFTWARE\\Microsoft\\" ) );
	_tcscat( szConfigGlobal, SzUtilImageVersionName() );
	_tcscat( szConfigGlobal, _T( "\\Global\\" ) );

	szConfigProcess[0] = 0;
	_tcscat( szConfigProcess, _T( "SOFTWARE\\Microsoft\\" ) );
	_tcscat( szConfigProcess, SzUtilImageVersionName() );
	_tcscat( szConfigProcess, _T( "\\Process\\" ) );
	_tcscat( szConfigProcess, SzUtilProcessName() );
	_tcscat( szConfigProcess, _T( "\\" ) );
#endif

	return fTrue;
	}

//  terminate config subsystem

void OSConfigTerm()
	{
	//  nop
	}

//  init config subsystem

ERR ErrOSConfigInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\error.cxx ===
#include "osstd.hxx"


const _TCHAR szNewLine[] 		= _T( "\r\n" );

enum {
	cchPtrHexWidth = sizeof( void* ) * 8 / 4
};
#ifdef _WIN64
#define SZPTRFORMATPREFIX _T( "I64" )
#define SZPTRFORMAT _T( "%016" ) SZPTRFORMATPREFIX _T( "x" )
#else
#define SZPTRFORMATPREFIX _T( "l" )
#define SZPTRFORMAT _T( "%08" ) SZPTRFORMATPREFIX _T( "x" )
#endif

#ifdef RTM
#else

#include <imagehlp.h>

typedef DWORD IMAGEAPI WINAPI PFNUnDecorateSymbolName( PCSTR, PSTR, DWORD, DWORD );
typedef DWORD IMAGEAPI PFNSymSetOptions( DWORD );
typedef BOOL IMAGEAPI PFNSymCleanup( HANDLE );
typedef DWORD IMAGEAPI PFNSymGetOptions( VOID );
typedef BOOL IMAGEAPI PFNSymInitialize( HANDLE, PSTR, BOOL );
typedef BOOL IMAGEAPI PFNSymGetSearchPath( HANDLE, PSTR, DWORD );
typedef BOOL IMAGEAPI PFNSymSetSearchPath( HANDLE, PSTR );
typedef BOOL IMAGEAPI PFNSymGetSymFromAddr( HANDLE, void *, PDWORD_PTR, PIMAGEHLP_SYMBOL );
typedef BOOL IMAGEAPI PFNSymGetModuleInfo( HANDLE, void *, PIMAGEHLP_MODULE );
typedef DWORD_PTR IMAGEAPI PFNSymGetModuleBase( HANDLE, IN  DWORD_PTR );
typedef PVOID IMAGEAPI PFNSymFunctionTableAccess( HANDLE, DWORD_PTR );
typedef BOOL IMAGEAPI PFNSymGetLineFromAddr( HANDLE, void *, PDWORD, PIMAGEHLP_LINE );
typedef BOOL IMAGEAPI PFNStackWalk(	DWORD,
									HANDLE,
									HANDLE,
									LPSTACKFRAME,
									PVOID,
									PREAD_PROCESS_MEMORY_ROUTINE,
									PFUNCTION_TABLE_ACCESS_ROUTINE,
									PGET_MODULE_BASE_ROUTINE,
									PTRANSLATE_ADDRESS_ROUTINE );
typedef PIMAGE_NT_HEADERS IMAGEAPI PFNImageNtHeader ( IN PVOID );

PFNUnDecorateSymbolName*	pfnUnDecorateSymbolName;
PFNSymSetOptions*			pfnSymSetOptions;
PFNSymCleanup*				pfnSymCleanup;
PFNSymGetOptions*			pfnSymGetOptions;
PFNSymInitialize*			pfnSymInitialize;
PFNSymGetSearchPath*		pfnSymGetSearchPath;
PFNSymSetSearchPath*		pfnSymSetSearchPath;
PFNSymGetSymFromAddr*		pfnSymGetSymFromAddr;
PFNSymGetModuleInfo*		pfnSymGetModuleInfo;
PFNSymGetModuleBase*		pfnSymGetModuleBase;
PFNSymFunctionTableAccess*	pfnSymFunctionTableAccess;
PFNSymGetLineFromAddr*		pfnSymGetLineFromAddr;
PFNStackWalk*				pfnStackWalk;
PFNImageNtHeader*			pfnImageNtHeader;

LIBRARY libraryImagehlp;

//  term stack walker

void OSErrorIStackwalkTerm()
	{
	if ( libraryImagehlp )
		{
		if ( pfnSymCleanup )
			pfnSymCleanup( GetCurrentProcess() );
		UtilFreeLibrary( libraryImagehlp );
		}
	}

//  init stack walker

const BOOL FOSErrorIStackwalkInit()
	{
	//  if we have already been initialized, return success

	if ( libraryImagehlp )
		{
		return fTrue;
		}
		
	//  load dbghelp.dll or imagehlp.dll and the functions we need for dumping the callstack

	if ( !FUtilLoadLibrary( _T( "dbghelp.dll" ), &libraryImagehlp, fFalse ) &&
		!FUtilLoadLibrary( _T( "imagehlp.dll" ), &libraryImagehlp, fFalse ) )
		{
		goto HandleError;
		}
	pfnSymGetLineFromAddr = (PFNSymGetLineFromAddr*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymGetLineFromAddr" ) );
	if ( !( pfnStackWalk = (PFNStackWalk*)PfnUtilGetProcAddress( libraryImagehlp, _T( "StackWalk" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymFunctionTableAccess = (PFNSymFunctionTableAccess*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymFunctionTableAccess" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetModuleBase = (PFNSymGetModuleBase*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymGetModuleBase" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetModuleInfo = (PFNSymGetModuleInfo*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymGetModuleInfo" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetSymFromAddr = (PFNSymGetSymFromAddr*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymGetSymFromAddr" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymSetSearchPath = (PFNSymSetSearchPath*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymSetSearchPath" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetSearchPath = (PFNSymGetSearchPath*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymGetSearchPath" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymInitialize = (PFNSymInitialize*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymInitialize" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetOptions = (PFNSymGetOptions*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymGetOptions" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymCleanup = (PFNSymCleanup*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymCleanup" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymSetOptions = (PFNSymSetOptions*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymSetOptions" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnUnDecorateSymbolName = (PFNUnDecorateSymbolName*)PfnUtilGetProcAddress( libraryImagehlp, _T( "UnDecorateSymbolName" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnImageNtHeader = (PFNImageNtHeader*)PfnUtilGetProcAddress( libraryImagehlp, _T( "ImageNtHeader" ) ) ) )
		{
		goto HandleError;
		}

	//  initialize stack walker

	DWORD dwOptions;
	dwOptions = pfnSymGetOptions();
	pfnSymSetOptions( dwOptions | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES );
	if ( !pfnSymInitialize( GetCurrentProcess(), NULL, TRUE ) )
		{
		pfnSymInitialize = NULL;
		goto HandleError;
		}

	_TCHAR szOldPath[4 * _MAX_PATH];
	if ( pfnSymGetSearchPath( GetCurrentProcess(), szOldPath, sizeof( szOldPath ) ) )
		{
		_TCHAR szNewPath[6 * _MAX_PATH];
		_TCHAR szDrive[_MAX_DRIVE];
		_TCHAR szDir[_MAX_DIR];
		_TCHAR szPath[_MAX_PATH];

		szNewPath[ 0 ] = 0;
		
		_tcscat( szNewPath, szOldPath );
		_tcscat( szNewPath, ";" );
		
		_tsplitpath( SzUtilImagePath(), szDrive, szDir, NULL, NULL );
		_tmakepath( szPath, szDrive, szDir, NULL, NULL );
		_tcscat( szNewPath, szPath );
		_tcscat( szNewPath, ";" );
		
		_tsplitpath( SzUtilProcessPath(), szDrive, szDir, NULL, NULL );
		_tmakepath( szPath, szDrive, szDir, NULL, NULL );
		_tcscat( szNewPath, szPath );
		
		pfnSymSetSearchPath( GetCurrentProcess(), szNewPath );
		}

	return fTrue;

HandleError:
	OSErrorIStackwalkTerm();
	return fFalse;
	}


INLINE BOOL FUtilStackWalk( STACKFRAME* pstkfrm, CONTEXT* pctxt )
	{

	return	pfnStackWalk(	
#if defined( _M_IX86 )
						IMAGE_FILE_MACHINE_I386,
#elif defined( _M_AMD64 )
						IMAGE_FILE_MACHINE_AMD64,
#elif defined( _M_IA64 )
						IMAGE_FILE_MACHINE_IA64,
#else
						IMAGE_FILE_MACHINE_UNKNOWN,
#endif
						GetCurrentProcess(),
						GetCurrentThread(),
						pstkfrm,
						pctxt,
						NULL,
						pfnSymFunctionTableAccess,
						pfnSymGetModuleBase,
						NULL );
	}

void UtilDumpFrame( CPRINTF* const pcprintf, const DWORD iFrame, const STACKFRAME* const pstkfrm )
	{
	//  do not dump this frame if the PC is NULL
	
	void *pvAddress = (void *)pstkfrm->AddrPC.Offset;
	if ( !pvAddress )
		{
		return;
		}
	
	//  dump the frame number, frame index, return address, and first four parameters
	
	(*pcprintf)(	_T( "%02x  " )
					SZPTRFORMAT _T( "  " )
					SZPTRFORMAT _T( "  " )
					SZPTRFORMAT _T( " " )
					SZPTRFORMAT _T( " " )
					SZPTRFORMAT _T( " " )
					SZPTRFORMAT _T( " " ),
					iFrame,
					pstkfrm->AddrFrame.Offset,
					pstkfrm->AddrReturn.Offset,
					pstkfrm->Params[0],
					pstkfrm->Params[1],
					pstkfrm->Params[2],
					pstkfrm->Params[3] );
	
	//  dump the name of the module that contains this address

	IMAGEHLP_MODULE		im			= { sizeof( IMAGEHLP_MODULE ) };
	
	if ( pfnSymGetModuleInfo( GetCurrentProcess(), pvAddress, &im ) )
		{
		(*pcprintf)( _T( "%s!" ), im.ModuleName );
		}

	//  dump the name of the symbol that contains this address
	
	BYTE				rgbData[ sizeof( IMAGEHLP_SYMBOL ) + IFileSystemAPI::cchPathMax ] = { 0 };
	IMAGEHLP_SYMBOL*	pis				= (IMAGEHLP_SYMBOL *)rgbData;
	DWORD_PTR			dwDisplacement	= 0;
	DWORD				dwDisplacementDword = 0;
	pis->SizeOfStruct	= sizeof( IMAGEHLP_SYMBOL );
	pis->MaxNameLength	= IFileSystemAPI::cchPathMax;

	if ( pfnSymGetSymFromAddr( GetCurrentProcess(), pvAddress, &dwDisplacement, pis ) )
		{
		_TCHAR szSymbol[256];
		if ( pfnUnDecorateSymbolName( pis->Name, szSymbol, sizeof( szSymbol ), UNDNAME_COMPLETE ) )
			{
			(*pcprintf)( _T( "%s+0x%" ) SZPTRFORMATPREFIX _T( "x" ), szSymbol, dwDisplacement );
			}
		else
			{
			(*pcprintf)( _T( "%s+0x%" ) SZPTRFORMATPREFIX _T( "x" ), pis->Name, dwDisplacement );
			}
		}
	else
		{
		(*pcprintf)( SZPTRFORMAT, pvAddress );
		}

	IMAGEHLP_LINE il = { sizeof( IMAGEHLP_LINE ) };
	if (	pfnSymGetLineFromAddr &&
			pfnSymGetLineFromAddr( GetCurrentProcess(), pvAddress, &dwDisplacementDword, &il ) )
		{
		CHAR szDrive[_MAX_DRIVE];
		CHAR szDir[_MAX_DIR];
		CHAR szFname[_MAX_FNAME];
		CHAR szExt[_MAX_EXT];
		_splitpath( il.FileName, szDrive, szDir, szFname, szExt );

		CHAR szFile[_MAX_PATH];
		_makepath( szFile, "", "", szFname, szExt );
		
		(*pcprintf)( _T( " [ %s @ %d ]" ), szFile, il.LineNumber );
		}

	BOOL fTimestampMismatch = fFalse;
	BOOL fChecksumMismatch = fFalse;
	IMAGE_NT_HEADERS* pnh = pfnImageNtHeader( (void*)im.BaseOfImage );
	if (	pnh &&
			pnh->FileHeader.TimeDateStamp != im.TimeDateStamp )
		{
		fTimestampMismatch = fTrue;
		}
	if (	pnh &&
			pnh->FileHeader.SizeOfOptionalHeader >= IMAGE_SIZEOF_NT_OPTIONAL_HEADER &&
			pnh->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC &&
			pnh->OptionalHeader.CheckSum != im.CheckSum &&
			(	pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
				_stricmp( im.ModuleName, "kernel32" ) &&
				_stricmp( im.ModuleName, "ntdll" ) ) )
		{
		fChecksumMismatch = fTrue;
		}

	if ( fTimestampMismatch || fChecksumMismatch )
		{
		_TCHAR szImageFile[_MAX_PATH];
		_TCHAR szSymbolFile[_MAX_PATH];

		_tfullpath( szImageFile, im.ImageName, _MAX_PATH );
		_tfullpath( szSymbolFile, im.LoadedImageName, _MAX_PATH );
		
		(*pcprintf)(	_T( "    * %s%s%s mismatch between image file %s and symbol file %s" ),
						fTimestampMismatch ? _T( "timestamp" ) : _T( "" ),
						fTimestampMismatch && fChecksumMismatch ? _T( " and " ) : _T( "" ),
						fChecksumMismatch ? _T( "checksum" ) : _T( "" ),
						szImageFile,
						szSymbolFile );
		}

	if ( !pnh )
		{
		(*pcprintf)(	_T( "    * unknown image" ) );
		}
		
	(*pcprintf)( _T( "%s" ), szNewLine );
	}

void UtilDumpCallstack( CPRINTF* const pcprintf, const CONTEXT* const pctxt = NULL, DWORD cFrameSkip = 0 )
	{
	CONTEXT		ctxt	= { 0 };
	STACKFRAME	stkfrm	= { 0 };

	if ( !pctxt )
		{
		ctxt.ContextFlags = CONTEXT_FULL;
		if ( GetThreadContext( GetCurrentThread(), &ctxt ) )
			{
			cFrameSkip = 1;
			}
		}
	else
		{
		ctxt	= *pctxt;
		}

	//	Notice that we copy *pctxt. If we allow StackWalk() to write to
	//	*pctxt and pctxt points to the memory returned from
	//	GetExceptionInformation() (which callers are likely to pass us), the
	//	system will kill our process (seen on IA64).

	stkfrm.AddrPC.Mode = AddrModeFlat;
	stkfrm.AddrStack.Mode = AddrModeFlat;
	stkfrm.AddrFrame.Mode = AddrModeFlat;

#if defined( _M_IX86 )
	stkfrm.AddrPC.Offset	= ctxt.Eip;
	stkfrm.AddrStack.Offset	= ctxt.Esp;
	stkfrm.AddrFrame.Offset	= ctxt.Ebp;
#elif defined( _M_ALPHA )
	stkfrm.AddrPC.Offset	= ctxt.Fir;
	stkfrm.AddrStack.Offset	= ctxt.IntSp;
	stkfrm.AddrFrame.Offset	= ctxt.IntSp;
#elif defined( _M_IA64 )
	//	Leave zeroed values as per sample code
#else
#endif

    //  dump the call stack header

    (*pcprintf)( _T( "%s" ), szNewLine );
    (*pcprintf)( _T( "%s" ), szNewLine );
    (*pcprintf)( _T( "PID / TID:  %d / %d%s" ), DwUtilProcessId(), DwUtilThreadId(), szNewLine );
    (*pcprintf)( _T( "%s" ), szNewLine );
    (*pcprintf)( _T( "#   " )
    	_T( "%-*s  " )
    	_T( "%-*s  " )
    	_T( "%-*s " )
    	_T( "%-*s " )
    	_T( "%-*s " )
    	_T( "%-*s " )
    	_T( "Module!Function%s" ),
    	cchPtrHexWidth,
    	_T( "Frame" ),
    	cchPtrHexWidth,
    	_T( "Return" ),
    	cchPtrHexWidth,
    	_T( "Param1" ),
    	cchPtrHexWidth,
    	_T( "Param2" ),
    	cchPtrHexWidth,
    	_T( "Param3" ),
    	cchPtrHexWidth,
    	_T( "Param4" ),
    	szNewLine );
	for ( DWORD i = 0; i < cchPtrHexWidth * 6; ++i )
		{
		(*pcprintf)( _T( "-" ) );
		}
	(*pcprintf)( _T( "---------------------------%s" ), szNewLine );

	//  we successfully init the stack walker

	if ( FOSErrorIStackwalkInit() )
		{
		//  walk up the stack as far as possible dumping the symbol names

		DWORD iFrame = 0;
		while ( FUtilStackWalk( &stkfrm, &ctxt ) )
			{
			if ( cFrameSkip )
				{
				cFrameSkip--;
				}
			else
				{
				UtilDumpFrame( pcprintf, iFrame++, &stkfrm );
				}
			}
		}

	//  we did not successfully init the stack walker

	else
		{
		//  print error message

	    (*pcprintf)( _T( "The stack could not be dumped due to a run time error.%s" ), szNewLine );
		}

	//  dump the call stack footer

    (*pcprintf)( _T( "%s" ), szNewLine );
	}

#endif	//	RTM


//	dynamically load MessageBox to avoid linking with the DLL


int UtilMessageBox( IN const _TCHAR * const szText, IN const _TCHAR * const szCaption, IN const UINT uType )
	{
	typedef WINUSERAPI int WINAPI PFNMessageBox( HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType );
#ifdef _UNICODE
	const char * const szFunction = _T( "MessageBoxW" );
#else
	const char * const szFunction = "MessageBoxA";
#endif

	HMODULE					hmodUser32		= NULL;
	PFNMessageBox *			pfnMessageBox	= NULL;
	int						retval			= 0;

	if ( !( hmodUser32 = LoadLibrary( _T( "user32.dll" ) ) ) )
		{
		goto NoMessageBox;
		}
	if ( !( pfnMessageBox = (PFNMessageBox*)GetProcAddress( hmodUser32, szFunction ) ) )
		{
		goto NoMessageBox;
		}
	
	retval = (*pfnMessageBox)( NULL, szText, szCaption, uType );

NoMessageBox:
	if ( hmodUser32 )
		{
		FreeLibrary( hmodUser32 );
		}
	return retval;
	}


//  returns fTrue if a debugger is attached to this process

BOOL IsDebuggerAttached()
	{
	typedef WINBASEAPI BOOL WINAPI PFNIsDebuggerPresent( VOID );

	HMODULE					hmodKernel32			= NULL;
	PFNIsDebuggerPresent*	pfnIsDebuggerPresent	= NULL;
	BOOL					fDebuggerPresent		= fFalse;

	if ( !( hmodKernel32 = LoadLibrary( _T( "kernel32.dll" ) ) ) )
		{
		goto NoIsDebuggerPresent;
		}
	if ( !( pfnIsDebuggerPresent = (PFNIsDebuggerPresent*)GetProcAddress( hmodKernel32, _T( "IsDebuggerPresent" ) ) ) )
		{
		goto NoIsDebuggerPresent;
		}

	fDebuggerPresent = pfnIsDebuggerPresent();

NoIsDebuggerPresent:
	if ( hmodKernel32 )
		{
		FreeLibrary( hmodKernel32 );
		}
	return fDebuggerPresent;
	}

//  returns fTrue if a debugger can be attached to this process

BOOL IsDebuggerAttachable()
	{
	extern volatile DWORD tidDLLEntryPoint;

	return tidDLLEntryPoint != GetCurrentThreadId();
	}


void KernelDebugBreakPoint()
	{
	DebugBreak();
	}

void UserDebugBreakPoint()
	{
	//  if this is an NT box then we must prevent ourselves from falling into
	//  the kernel debugger by issuing a debug break with no debugger attached

	OSVERSIONINFO osvi;
	memset( &osvi, 0, sizeof( osvi ) );
	osvi.dwOSVersionInfoSize = sizeof( osvi );

	if (	GetVersionEx( &osvi ) &&
			osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
			!IsDebuggerAttached() )
		{
		//  if it is possible to attach a debugger to the current process then
		//  we will do so
		
		if ( IsDebuggerAttachable() )
			{
			while ( !IsDebuggerAttached() )
				{
				//  get the AE Debug command line if present
				
				char szCmdFormat[ 256 ];
		
				if ( !GetProfileString(	"AeDebug",
										"Debugger",
										"",
										szCmdFormat,
										sizeof( szCmdFormat ) - 1 ) )
					{
					szCmdFormat[ 0 ] = 0;
					}

				//  ignore the AE Debug command line if it is pointing to Dr. Watson

				char szCmdFname[ 256 ];
				
				_splitpath( szCmdFormat, NULL, NULL, szCmdFname, NULL );
				if ( !_stricmp( szCmdFname, "drwtsn32" ) )
					{
					szCmdFormat[ 0 ] = 0;
					}

				//  try to use the AE Debug command line to start the debugger

	            SECURITY_ATTRIBUTES	sa;
	            HANDLE				hEvent;
	            STARTUPINFO			si;
	            PROCESS_INFORMATION	pi;
	            CHAR				szCmd[ 256 ];

	            sa.nLength				= sizeof( SECURITY_ATTRIBUTES );
	            sa.lpSecurityDescriptor	= NULL;
	            sa.bInheritHandle		= TRUE;

	            hEvent = CreateEvent( &sa, TRUE, FALSE, NULL );

	            memset( &si, 0, sizeof( STARTUPINFO ) );
	            
	            sprintf( szCmd, szCmdFormat, GetCurrentProcessId(), hEvent );
				Assert( strlen( szCmd ) < sizeof(szCmd)/sizeof(CHAR) );
	            
	            si.cb			= sizeof( STARTUPINFO );
	            si.lpDesktop	= _T( "Winsta0\\Default" );
	            
	            if (	hEvent &&
	            		CreateProcess(	NULL,
										szCmd,
										NULL,
										NULL,
										TRUE,
										0,
										NULL,
										NULL,
										&si,
										&pi ) )
					{
					//	wait for debugger to load (force timeout to ensure we
					//	don't hang if "-e" was omitted from the command line)
					for ( DWORD dw = WaitForSingleObjectEx( hEvent, 3000, TRUE );
						( WAIT_IO_COMPLETION == dw || WAIT_TIMEOUT == dw ) && !IsDebuggerAttached();
						dw = WaitForSingleObjectEx( hEvent, 30000, TRUE ) )
						{
						NULL;
						}
					}

				//  if we couldn't start the debugger, prompt for one to be installed
				
				else
					{
					char szMessage[ 1024 ];

					if ( !szCmdFormat[ 0 ] )
						{
						sprintf( szMessage, "No debugger is installed on this machine.  Please install one now." );
						Assert( strlen( szMessage ) < sizeof(szMessage)/sizeof(char) );
						}
					else
						{
						DWORD	gle			= GetLastError();
						char*	szMsgBuf	= NULL;
						
						FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
											FORMAT_MESSAGE_FROM_SYSTEM |
											FORMAT_MESSAGE_MAX_WIDTH_MASK ),
									    NULL,
									    gle,
									    MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
									    (LPTSTR) &szMsgBuf,
									    0,
									    NULL );
						sprintf(	szMessage,
									"The debugger could not be attached to process %d!  Win32 error %d%s%s",
									GetCurrentProcessId(),
									gle,
									szMsgBuf ? ":  " : ".",
									szMsgBuf ? szMsgBuf : "" );
						Assert( strlen( szMessage ) < sizeof(szMessage)/sizeof(char) );

						LocalFree( (LPVOID)szMsgBuf );
						}
					
					if ( UtilMessageBox(	szMessage,
											SzUtilImageVersionName(),
											MB_SERVICE_NOTIFICATION | MB_SYSTEMMODAL | MB_ICONSTOP | MB_RETRYCANCEL ) == IDCANCEL )
						{
						break;
						}
					}
				if ( hEvent )
					{
					CloseHandle( hEvent );
					}
				}
			}

		//  if we make it here and there is still no debugger attached, we will
		//  just kill the process

		if ( !IsDebuggerAttached() )
			{
			TerminateProcess( GetCurrentProcess(), -1 );
			}
		}

	//  stop in the debugger

	DebugBreak();
	}


#if defined( DEBUG ) || defined( MEM_CHECK ) || defined( ENABLE_EXCEPTIONS )

const _TCHAR szReleaseHdr[] 	= _T( "Rel. " );
const _TCHAR szFileHdr[] 		= _T( ", File " );
const _TCHAR szLineHdr[] 		= _T( ", Line " );
const _TCHAR szErrorHdr[] 		= _T( ", Err. " );
const _TCHAR szMsgHdr[] 		= _T( ": " );
const _TCHAR szPidHdr[] 		= _T( "PID: " );
const _TCHAR szTidHdr[] 		= _T( ", TID: " );

const _TCHAR szAssertFile[] 	= _T( "assert.txt" );
const _TCHAR szAssertHdr[] 		= _T( "Assertion Failure: " );

const _TCHAR szAssertInfo[]		= _T( "More complete information can be found in:  " );

const _TCHAR szAssertCaption[] 	= _T( "JET Assertion Failure" );
const _TCHAR szAssertPrompt[]	= _T( "Choose OK to continue execution or CANCEL to debug the process." );
const _TCHAR szAssertPrompt2[]	= _T( "Choose OK to continue execution or CANCEL to terminate the process (attaching the debugger is impossible during process initialization and termination)." );

#endif	//	DEBUG || MEM_CHECK || ENABLE_EXCEPTIONS

#ifdef DEBUG

int fNoWriteAssertEvent = 0;

/*      write assert to assert.txt
/*      may raise alert
/*      may log to event log
/*      may pop up
/*
/*      condition parameters
/*      assemble monolithic string for assert.txt,
/*              alert and event log
/*      assemble separated string for pop up
/*      
/**/

LOCAL HANDLE	hsemAssert;
LOCAL BOOL		fAssertFired	= fFalse;

LOCAL DWORD	pidAssert = GetCurrentProcessId();
LOCAL DWORD	tidAssert = GetCurrentThreadId();
LOCAL const _TCHAR * szFilenameAssert;
LOCAL long lLineAssert;

EExceptionFilterAction ExceptionFilterDumpCallstack( CPRINTF* const pcprintf, EXCEPTION_POINTERS* const pexp, const DWORD cFrameSkip )
{
	UtilDumpCallstack( pcprintf, pexp->ContextRecord, cFrameSkip );
	return efaExecuteHandler;
}

#pragma warning( disable : 4509 )
void __stdcall AssertFail( const _TCHAR* szMessage, const _TCHAR* szFilename, long lLine )
	{
	/*  acquire hsemAssert to prevent additional asserts from popping up
	/*  during debugger startup
	/**/
	WaitForSingleObjectEx( hsemAssert, INFINITE, FALSE );

	fAssertFired = fTrue;

	_TCHAR          szAssertText[1024];
	int             id;
	DWORD           dw;

	/*      get last error before another system call
	/**/
	dw = GetLastError();

	szFilenameAssert = szFilename;
	lLineAssert = lLine;

	/*      select file name from file path
	/**/
	szFilename = ( NULL == _tcsrchr( szFilename, _T( bPathDelimiter ) ) ) ? szFilename : _tcsrchr( szFilename, _T( bPathDelimiter ) ) + sizeof( TCHAR );

	/*      assemble monolithic assert string
	/**/
	_stprintf(
		szAssertText,
		_T( "%s%s%s%s%d.%d%s%s%s%d: %s%d%s%s%s" ),
		szNewLine,
		szNewLine,
		szAssertHdr,
		szReleaseHdr,
		DwUtilImageBuildNumberMajor(),
		DwUtilImageBuildNumberMinor(),
		szFileHdr,
		szFilename,
		szLineHdr,
		lLine,
		szTidHdr,
		DwUtilThreadId(),	
		szMsgHdr,
		szMessage,
		szNewLine
		);
	Assert( _tcslen( szAssertText ) < sizeof( szAssertText ) / sizeof( _TCHAR ) );

	/******************************************************
	/**/

	/*      if event log environment variable set then write
	/*      assertion to event log.
	/**/
	if ( !fNoWriteAssertEvent )
		{
		const _TCHAR *	rgszT[1];

		rgszT[0] = szAssertText;

		UtilReportEvent(
				eventError,
				GENERAL_CATEGORY,
				PLAIN_TEXT_ID,
				1,
				rgszT );
		}

	/*  make sure that the log is flushed to facilitate debugging, ignoring any
	/*	errors that may be returned
	/**/
//	extern CAutoResetSignal m_asigLogFlush;
//	m_asigLogFlush.Set();
	
		{
		CPRINTFFILE cprintffileAssert( szAssertFile );
		cprintffileAssert( _T( "%s" ), szAssertText );

#if defined( _M_IX86 )
		OSVERSIONINFO osvi;
		memset( &osvi, 0, sizeof( osvi ) );
		osvi.dwOSVersionInfoSize = sizeof( osvi );

		if (	GetVersionEx( &osvi ) &&
			VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
			{
			//  We've been dumping callstacks in NT from this context for ages
			//  without any problems, so why mess with a good thing?

			UtilDumpCallstack( &cprintffileAssert );
			}
		else
#endif
			{
			enum {
				excCode = 0xC0DE0E5E
			};
			
			__try
				{
				RaiseException( excCode, 0, 0, NULL );
				}
			__except( excCode == GetExceptionCode() ?
				ExceptionFilterDumpCallstack(
					&cprintffileAssert,
					GetExceptionInformation(),
#if defined( _M_IX86 )
					0	// X86 platform has special hacks so RaiseException isn't on the callstack
#elif defined( _M_IA64 )
					2	// remove KERNEL32!RaiseException and NTDLL!RtlRaiseException from callstack
#else
					0
#endif
					) :
				efaContinueSearch )
				{
				}
			}
		}

	extern UINT g_wAssertAction;
	if ( g_wAssertAction == JET_AssertExit )
		{
		TerminateProcess( GetCurrentProcess(), -1 );
		}
	else if ( g_wAssertAction == JET_AssertBreak )
		{
		KernelDebugBreakPoint();
		}
	else if ( g_wAssertAction == JET_AssertStop )
		{
		for( ;; )
			{
			/*	wait for developer, or anyone else, to debug the failure
			/**/
			Sleep( 100 );
			}
		}
	else if ( g_wAssertAction == JET_AssertMsgBox )
		{
		_TCHAR	szT[10];
		
		/*	assemble monolithic assert string
		/**/
		szAssertText[0] = '\0';
		/*	copy version number to message
		/**/
		_tcscat( szAssertText, szReleaseHdr );
		_ltot( DwUtilImageBuildNumberMajor(), szT, 10 );
		_tcscat( szAssertText, szT );
		_tcscat( szAssertText, _T( "." ) );
		_ltot( DwUtilImageBuildNumberMinor(), szT, 10 );
		_tcscat( szAssertText, szT );
		/*      file name
		/**/
		_tcscat( szAssertText, szFileHdr );
		_tcscat( szAssertText, szFilename );
		/*      line number
		/**/
		_tcscat( szAssertText, szLineHdr );
		_ultot( lLine, szT, 10 );
		_tcscat( szAssertText, szT );
		/*      error
		/**/
		if ( dw && dw != ERROR_IO_PENDING )
			{
			_tcscat( szAssertText, szErrorHdr );
			_ltot( dw, szT, 10 );
			_tcscat( szAssertText, szT );
			}
		_tcscat( szAssertText, szNewLine );
		/*      assert txt
		/**/
		_tcscat( szAssertText, szMessage );
		_tcscat( szAssertText, szNewLine );

		/*	process and thread id
		/**/
		_tcscat( szAssertText, szPidHdr );
		_ultot( DwUtilProcessId(), szT, 10 );
		_tcscat( szAssertText, szT );
		_tcscat( szAssertText, szTidHdr );
		_ultot( DwUtilThreadId(), szT, 10 );
		_tcscat( szAssertText, szT );

		/*  assert file notification
		/**/
		_tcscat( szAssertText, szNewLine );
		_tcscat( szAssertText, szNewLine );
		_tcscat( szAssertText, szAssertInfo );
		_TCHAR szAssertFilePath[_MAX_PATH];		
		_tfullpath( szAssertFilePath, szAssertFile, _MAX_PATH );
		_tcscat( szAssertText, szAssertFilePath );

		/*  assert dialog action prompt
		/**/
		_tcscat( szAssertText, szNewLine );
		_tcscat( szAssertText, szNewLine );
		_tcscat( szAssertText, IsDebuggerAttachable() || IsDebuggerAttached() ? szAssertPrompt : szAssertPrompt2 );

		id = UtilMessageBox(	szAssertText,
								szAssertCaption,
								MB_SERVICE_NOTIFICATION | MB_SYSTEMMODAL | MB_ICONSTOP |
								( IsDebuggerAttachable() || IsDebuggerAttached() ? MB_OKCANCEL : MB_OK ) );

		BOOL	fOKAllowed		= fFalse;
		_TCHAR	szComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
		DWORD	cbComputerName	= sizeof( szComputerName );
		fOKAllowed = fOKAllowed || !GetComputerName( szComputerName, &cbComputerName );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "ANDREIMA" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "ANDYGO" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "ESE" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "EXIFS" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "JLIEM" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "LAURIONB" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "PARKERS" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "MARTINC" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "IANJO" ) );
		
		if ( IDOK != id || !fOKAllowed )
			{
			UserDebugBreakPoint();
			}
		}

	fAssertFired = fFalse;
	ReleaseSemaphore( hsemAssert, 1, NULL );

	return;
	}
#pragma warning( default : 4509 )

	
void AssertErr( const ERR err, const _TCHAR* szFileName, const long lLine )
	{
	_TCHAR szMsg[32];

	if ( JET_errSuccess == err )
		_tcscpy( szMsg, _T( "Bogus Assert" ) );  // only call this routine if we know err != JET_errSuccess
	else
		_stprintf( szMsg, _T( "Unexpected error: %d" ), err );
		
	AssertFail( szMsg, szFileName, lLine );
	}

void AssertTrap( const ERR err, const _TCHAR* szFileName, const long lLine )
	{
	_TCHAR szMsg[32];

	if ( JET_errSuccess == err )
		_tcscpy( szMsg, _T( "Bogus Assert" ) );  // only call this routine if we know err != JET_errSuccess
	else
		_stprintf( szMsg, _T( "Error Trap: %d" ), err );
		
	AssertFail( szMsg, szFileName, lLine );
	}

#else  //  !DEBUG

void __stdcall AssertFail( const _TCHAR* szMessage, const _TCHAR* szFilename, long lLine )
	{
	const _TCHAR *	szFilenameNoPath;
	_TCHAR			szLine[8];
	const _TCHAR *	rgszT[2];

	szFilenameNoPath = ( NULL == _tcsrchr( szFilename, _T( bPathDelimiter ) ) ) ? szFilename : _tcsrchr( szFilename, _T( bPathDelimiter ) ) + sizeof( TCHAR );
	rgszT[0] = szFilenameNoPath;

	_itot( lLine, szLine, 10 );
	rgszT[1] = szLine;

	UtilReportEvent(
			eventInformation,
			GENERAL_CATEGORY,
			INTERNAL_TRACE_ID,
			2,
			rgszT );

#ifdef RTM
#else  //  !RTM
	UserDebugBreakPoint();
#endif  //  RTM
	}

#endif  //  DEBUG


//  Enforces

//  Enforce Failure action
//
//  called when a strictly enforced condition has been violated

BOOL fOverrideEnforceFailure = fFalse;

void __stdcall EnforceFail( const _TCHAR* szMessage, const _TCHAR* szFilename, long lLine )
	{
	AssertFail( szMessage, szFilename, lLine );

	//  UNDONE:  log an event

	if ( !fOverrideEnforceFailure )
		{
		TerminateProcess( GetCurrentProcess(), -1 );
		}
	}


//  Exceptions

#ifdef ENABLE_EXCEPTIONS

//  Exception Information function for use by an exception filter
//
//  NOTE:  must be called in the scope of the exception filter expression

typedef DWORD_PTR EXCEPTION;

EXCEPTION (*pfnExceptionInfo)();

//  Exception Failure action
//
//  used as the filter whenever any exception that occurs is considered a failure

const _TCHAR szExceptionHdr[]		= _T( "Exception: " );
const _TCHAR szExceptionCaption[] 	= _T( "JET Exception" );
const _TCHAR szExceptionInfo[]		= _T( "More complete information can be found in:  " );
const _TCHAR szExceptionPrompt[]	= _T( "Choose OK to terminate the process or CANCEL to debug the process." );
const _TCHAR szExceptionPrompt2[]	= _T( "Choose OK to terminate the process (attaching the debugger is impossible during process initialization and termination)." );

//  ================================================================
LOCAL BOOL ExceptionDialog( const _TCHAR szException[] )
//  ================================================================
	{
	_TCHAR		szMessage[1024];
#ifdef RTM
	_TCHAR *	szFmt			= _T( "%s%d.%d%s%s%s%s%s%d%s%d%s%s%s" );
#else
	_TCHAR *	szFmt			= _T( "%s%d.%d%s%s%s%s%s%d%s%d%s%s%s%s%s%s%s" );
	_TCHAR		szExceptionFilePath[_MAX_PATH];		
	_tfullpath( szExceptionFilePath, szAssertFile, _MAX_PATH );
#endif	
	
	_stprintf( szMessage, szFmt,
		szReleaseHdr,
		DwUtilImageBuildNumberMajor(),
		DwUtilImageBuildNumberMinor(),
		szMsgHdr,
		szNewLine,
		szException,
		szNewLine,
		szPidHdr,
		DwUtilProcessId(),
		szTidHdr,
		DwUtilThreadId(),
		szNewLine,
		szNewLine,

#ifdef RTM
#else
		szExceptionInfo,
		szExceptionFilePath,
		szNewLine,
		szNewLine,
#endif		
		IsDebuggerAttachable() || IsDebuggerAttached() ? szExceptionPrompt : szExceptionPrompt2
		);

	Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
	const int id = UtilMessageBox(
						szMessage,
						szExceptionCaption,
						MB_SERVICE_NOTIFICATION | MB_SYSTEMMODAL | MB_ICONSTOP |
						( IsDebuggerAttachable() || IsDebuggerAttached() ? MB_OKCANCEL : MB_OK ) );
	return ( IDOK != id );
	}


HANDLE	hsemExcept;
BOOL	fRetryCode = fFalse;

//  ================================================================
EExceptionFilterAction _ExceptionFail( const _TCHAR* szMessage, EXCEPTION exception )
//  ================================================================
	{
	PEXCEPTION_POINTERS pexp 			= PEXCEPTION_POINTERS( exception );
	PEXCEPTION_RECORD	pexr			= pexp->ExceptionRecord;
	PCONTEXT			pcxr			= pexp->ContextRecord;
	
	const DWORD			dwException		= pexr->ExceptionCode;
	const VOID * const	pvAddress		= pexr->ExceptionAddress;

	HANDLE				hFile			= NULL;
	DWORD				cchActual		= 0;

	const _TCHAR *		szException		= _T( "UNKNOWN" );

	//  this exception has already been trapped once, so the user must have
	//  allowed the exception to be passed on to the application by the
	//  debugger

	if ( fRetryCode )
		{
		//  let any other exception filters on the stack handle the error
		
		fRetryCode = fFalse;
		return efaContinueSearch;
		}
			
	//  prevent other exceptions from firing while we are handling this one

	WaitForSingleObjectEx( hsemExcept, INFINITE, FALSE );

#if defined(DEBUG)
	//  we are here as the result of an assertion failure
	extern BOOL fAssertFired;
	const BOOL	fUseSystemExceptionHandler		= fAssertFired;
#elif defined(RTM)
	//	this is shipping code, so don't pop up a dialog
	const BOOL	fUseSystemExceptionHandler		= fTrue;
#else
	//	pop up a dialog
	const BOOL	fUseSystemExceptionHandler		= fFalse;
#endif

	if ( fUseSystemExceptionHandler )
		{
		//  display the system unhandled exception dialog

		EExceptionFilterAction efa = EExceptionFilterAction( UnhandledExceptionFilter( pexp ) );

		//  the user chose to debug the application

		if ( efa == efaContinueSearch )
			{
			//  re-execute the debug break to halt the debugger in the assert code
			
			ReleaseSemaphore( hsemExcept, 1, NULL );
			return efaContinueExecution;
			}

		//  the user chose to terminate the application

		else
			{
			//  terminate the process

			TerminateProcess( GetCurrentProcess(), -1 );

			//  never reached

			return efaExecuteHandler;
			}
		}


#ifdef RTM
#else

	//  start our handler
	
	switch( dwException )
		{
#ifdef SZEXP
#error	SZEXP already defined
#endif	//	SZEXP

#define SZEXP( EXP )					\
		case EXP:						\
			szException = _T( #EXP );	\
			break;

		SZEXP( EXCEPTION_ACCESS_VIOLATION );
		SZEXP( EXCEPTION_ARRAY_BOUNDS_EXCEEDED );
		SZEXP( EXCEPTION_BREAKPOINT );
		SZEXP( EXCEPTION_DATATYPE_MISALIGNMENT );
		SZEXP( EXCEPTION_FLT_DENORMAL_OPERAND );
		SZEXP( EXCEPTION_FLT_DIVIDE_BY_ZERO );
		SZEXP( EXCEPTION_FLT_INEXACT_RESULT );
		SZEXP( EXCEPTION_FLT_INVALID_OPERATION );
		SZEXP( EXCEPTION_FLT_OVERFLOW );
		SZEXP( EXCEPTION_FLT_STACK_CHECK );
		SZEXP( EXCEPTION_FLT_UNDERFLOW );
		SZEXP( EXCEPTION_ILLEGAL_INSTRUCTION );
		SZEXP( EXCEPTION_IN_PAGE_ERROR );
		SZEXP( EXCEPTION_INT_DIVIDE_BY_ZERO );
		SZEXP( EXCEPTION_INT_OVERFLOW );
		SZEXP( EXCEPTION_INVALID_DISPOSITION );
		SZEXP( EXCEPTION_NONCONTINUABLE_EXCEPTION );
		SZEXP( EXCEPTION_PRIV_INSTRUCTION );
		SZEXP( EXCEPTION_SINGLE_STEP );
		SZEXP( EXCEPTION_STACK_OVERFLOW );

#undef SZEXP
		}


	//  print the exception information and callstack to our assert file

		{
		CPRINTFFILE cprintffileAssert( szAssertFile );

		cprintffileAssert(	_T( "JET Exception: Function \"%s\" raised exception 0x%08X (%s) at address 0x%0*I64X (base:0x%0*I64X, exr:0x%0*I64X, cxr:0x%0*I64X)." ),
							szMessage,
							dwException,
							szException,
							sizeof( LONG_PTR ) * 2,
							(QWORD)pvAddress,
							sizeof( LONG_PTR ) * 2,
							(QWORD)PvUtilImageBaseAddress(),
							sizeof( LONG_PTR ) * 2,
							(QWORD)pexr,
							sizeof( LONG_PTR ) * 2,
							(QWORD)pcxr );

		UtilDumpCallstack( &cprintffileAssert, pexp->ContextRecord );
		}


	//  ask user what they want to do with the exception

	_TCHAR szT[256];
	_stprintf( 	szT,
				_T( "JET Exception: Function \"%s\" raised exception 0x%08X (%s) at address 0x%0*I64X (base:0x%0*I64X, exr:0x%0*I64X, cxr:0x%0*I64X)." ),
				szMessage,
				dwException,
				szException,
				sizeof( LONG_PTR ) * 2,
				(QWORD)pvAddress,
				sizeof( LONG_PTR ) * 2,
				(QWORD)PvUtilImageBaseAddress(),
				sizeof( LONG_PTR ) * 2,
				(QWORD)pexr,
				sizeof( LONG_PTR ) * 2,
				(QWORD)pcxr );
	Assert( _tcslen( szT ) < sizeof(szT)/sizeof(_TCHAR) );

	BOOL fDebug = ExceptionDialog( szT );

	//  the user chose to debug the process

	if ( fDebug )
		{
		//  Here is the exception that has caused the program failure:

		static DWORD dwExceptionCode = pexp->ExceptionRecord->ExceptionCode;

		//  halt the debugger
		
		UserDebugBreakPoint();

		//  To debug the exception, perform the following steps:
		//
		//  MS Developer Studio:
		//
		//    Go to the exception setup dialog and configure the debugger to
		//      Stop Always when exception <dwExceptionCode> occurs
		//    Continue program execution.  The debugger will stop on the
		//      offending code
		//
		//  Windbg:
		//
		//    Enter "SXE <dwExceptionCode> /C" to enable first chance handling
		//      of the exception
		//    Continue program execution.  The debugger will stop on the
		//      offending code
		//
		//  If you choose none of the above, the exception will simply be
		//  passed on to the next higher exception filter on the stack

		//  retry the instruction that caused the exception
		
		fRetryCode = fTrue;
		ReleaseSemaphore( hsemExcept, 1, NULL );
		return efaContinueExecution;
		}
		
	//  the user chose to terminate the process through either dialog

	TerminateProcess( GetCurrentProcess(), -1 );

#endif	//	!RTM

	//should never be reached
	return efaExecuteHandler;
	}

#endif	//	ENABLE_EXCEPTIONS

//  returns the exception id of an exception

const DWORD ExceptionId( EXCEPTION exception )
	{
	PEXCEPTION_POINTERS pexp = PEXCEPTION_POINTERS( exception );

	return pexp->ExceptionRecord->ExceptionCode;
	}


#ifdef DEBUG

/***********************************************************
/******************** error handling ***********************
/***********************************************************
/**/
ERR ErrERRCheck_( const ERR err, const _TCHAR* szFile, const long lLine )
	{

	//	if an assert is hit in one thread, dead-loop all other threads
	while ( fAssertFired )
		{
		UtilSleep( 1000 );
		}

	extern ERR g_errTrap;
	AssertSzRTL( err != g_errTrap, "Error Trap" );

	/*	to trap a specific error/warning, either set your breakpoint here 
	/*	or include a specific case below for the error/warning trapped
	/*	and set your breakpoint there.
	/**/
	switch( err )
		{
		case JET_errSuccess:
			Assert( fFalse );	// Shouldn't call ErrERRCheck() with JET_errSuccess.
			break;

		case JET_errInvalidTableId:
			QwUtilHRTCount();
			break;

		case JET_errKeyDuplicate:
			QwUtilHRTCount();
			break;

		case JET_errDiskIO:
			QwUtilHRTCount();
			break;
			
		case JET_errReadVerifyFailure:
			QwUtilHRTCount();
			break;

		case JET_errOutOfMemory:
			QwUtilHRTCount();
			break;

		case JET_errDerivedColumnCorruption:
			AssertSz( fFalse, "Corruption detected in column space of derived columns." );	//	allow debugging of corruption
			break;

		default:
			break;
		}

	Ptls()->szFileLastErr = szFile;
	Ptls()->ulLineLastErr = lLine;
	Ptls()->errLastErr	= err;
	
	return err;
	}

#endif  //  DEBUG


#ifdef RFS2

/*  RFS2 Options Text  */

LOCAL const CHAR szDisableRFS[]                = "Disable RFS";
LOCAL const CHAR szLogJETCall[]                = "Enable JET Call Logging";
LOCAL const CHAR szLogRFS[]                    = "Enable RFS Logging";
LOCAL const CHAR szRFSAlloc[]                  = "RFS Allocations (-1 to allow all)";
LOCAL const CHAR szRFSIO[]                     = "RFS IOs (-1 to allow all)";

/*  RFS2 Defaults  */

LOCAL const DWORD_PTR rgrgdwRFS2Defaults[][2] =
	{
	(DWORD_PTR)szDisableRFS,            0x00000001,             /*  Disable RFS  */
	(DWORD_PTR)szLogJETCall,            0x00000000,             /*  Disable JET call logging  */
	(DWORD_PTR)szLogRFS,                0x00000000,             /*  Disable RFS logging  */
	(DWORD_PTR)szRFSAlloc,              0xffffffff,             /*  Allow ALL RFS allocations  */
	(DWORD_PTR)szRFSIO,                 0xffffffff,             /*  Allow ALL RFS IOs  */
	(DWORD_PTR)NULL,                    0x00000000,             /*  <EOL>  */
	};

DWORD  g_fDisableRFS		= 0x00000001;
DWORD  g_fAuxDisableRFS	= 0x00000000;
DWORD  g_fLogJETCall		= 0x00000000;
DWORD  g_fLogRFS			= 0x00000000;
DWORD  g_cRFSAlloc		= 0xffffffff;
DWORD  g_cRFSIO			= 0xffffffff;

	/*
		RFS allocator:  returns 0 if allocation is disallowed.  Also handles RFS logging.
		g_cRFSAlloc is the global allocation counter.  A value of -1 disables RFS in debug mode.
	*/

DWORD  cRFSAllocBreak	= 0xfffffffe;
DWORD  cRFSIOBreak		= 0xfffffffe;

int UtilRFSAlloc( const _TCHAR* szType, int Type )
	{
	/*  leave ASAP if we are not enabled  */

	if ( g_fDisableRFS )
		return UtilRFSLog( szType, 1 );
		
	/*  Breaking here on RFS failure allows easy change to RFS success during debugging  */
	
	if (	(	( cRFSAllocBreak == g_cRFSAlloc && Type == 0 ) ||
				( cRFSIOBreak == g_cRFSIO && Type == 1 ) ) &&
			!( g_fDisableRFS || g_fAuxDisableRFS ) )
		UserDebugBreakPoint();

	switch ( Type )
		{
		case 0:  //  general allocation
			if ( g_cRFSAlloc == -1 || ( g_fDisableRFS || g_fAuxDisableRFS ) )
				return UtilRFSLog( szType, 1 );
			if ( !g_cRFSAlloc )
				return UtilRFSLog( szType, 0 );
			g_cRFSAlloc--;
			return UtilRFSLog( szType, 1 );
		case 1:  //  IO operation
			if ( g_cRFSIO == -1 || ( g_fDisableRFS || g_fAuxDisableRFS ) )
				return UtilRFSLog( szType, 1 );
			if ( !g_cRFSIO )
				return UtilRFSLog( szType, 0 );
			g_cRFSIO--;
			return UtilRFSLog( szType, 1 );
		default:
			Assert( 0 );
			break;
		}

	return 0;
	}

BOOL FRFSFailureDetected( UINT Type )
	{
	if ( g_fDisableRFS )
		return fFalse;

	if ( 0 == Type )		//	general allocations
		{
		return ( 0 == g_cRFSAlloc );
		}
	else if ( 1 == Type )	//	I/O
		{
		return ( 0 == g_cRFSIO );
		}

	Assert( fFalse );		//	unknown RFS type
	return fFalse;
	}

BOOL FRFSAnyFailureDetected()
	{
	return ( !g_fDisableRFS
			&& ( 0 == g_cRFSAlloc || 0 == g_cRFSIO ) );
	}
	/*
		RFS logging (log on success/failure).  If fPermitted == 0, access was denied .  Returns fPermitted.
		Turns on JET call logging if fPermitted == 0
	*/

int UtilRFSLog( const _TCHAR* szType, int fPermitted )
	{
	const _TCHAR *	rgszT[1];

	if ( !fPermitted )
		g_fLogJETCall = 1;
	
	if ( !g_fLogRFS && fPermitted )
		return fPermitted;

	rgszT[0] = (_TCHAR*)szType;
		
	UtilReportEvent(
			fPermitted ? eventInformation : eventWarning,
			RFS2_CATEGORY,
			fPermitted ? RFS2_PERMITTED_ID : RFS2_DENIED_ID,
			1,
			rgszT );
	
	return fPermitted;
	}

	/*  JET call logging (log on failure)
	/*  Logging will start even if disabled when RFS denies an allocation
	/**/

void UtilRFSLogJETCall( const _TCHAR* szFunc, ERR err, const _TCHAR* szFile, unsigned Line )
	{
	_TCHAR			rgrgchT[2][16];
	const _TCHAR *	rgszT[4];
	
	if ( err >= 0 || !g_fLogJETCall )
		return;

	rgszT[0] = (_TCHAR*) szFunc;

	_ltot( err, rgrgchT[0], 10 );
	rgszT[1] = rgrgchT[0];

	rgszT[2] = (_TCHAR *)szFile;

	_ltot( Line, rgrgchT[1], 10 );
	rgszT[3] = rgrgchT[1];
	
	UtilReportEvent(
			eventInformation,
			RFS2_CATEGORY,
			RFS2_JET_CALL_ID,
			4,
			rgszT );
	}

	/*  JET INLINE error logging (logging controlled by JET call flags)  */

void UtilRFSLogJETErr( ERR err, const _TCHAR* szLabel, const _TCHAR* szFile, unsigned Line )
	{
	_TCHAR			rgrgchT[2][16];
	const _TCHAR *	rgszT[4];

	if ( !g_fLogJETCall )
		return;
	
	_ltot( err, rgrgchT[0], 10 );
	rgszT[0] = rgrgchT[0];

	rgszT[1] = (_TCHAR*) szLabel;

	rgszT[2] = (_TCHAR*) szFile;

	_ltot( Line, rgrgchT[1], 10 );
	rgszT[3] = rgrgchT[1];
	
	UtilReportEvent(
		eventInformation,
		PERFORMANCE_CATEGORY,
		RFS2_JET_ERROR_ID,
		4,
		rgszT );
	}

BOOL RFSError::Check( ERR err, ... ) const
	{
	va_list arg_ptr;
	va_start( arg_ptr, err );
	
	for ( ; err != 0; err = va_arg( arg_ptr, ERR ) )
		{
		Assert( err > -9000 && err < 9000 );
		// acceptable RFS error
		if ( m_err == err )
			{
			break;
			}
		}
		
	va_end( arg_ptr );
	return (err != 0);
	}
#endif  /*  RFS2  */


//  post-terminate error subsystem

void OSErrorPostterm()
	{
	//  delete critical sections
	
#ifdef ENABLE_EXCEPTIONS
	if ( hsemExcept )
		{
		SetHandleInformation( hsemExcept, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hsemExcept );
		hsemExcept = NULL;
		}
#endif  //  ENABLE_EXCEPTIONS
#ifdef DEBUG
	if ( hsemAssert )
		{
		SetHandleInformation( hsemAssert, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hsemAssert );
		hsemAssert = NULL;
		}
#endif  //  DEBUG
	}

//  pre-init error subsystem

BOOL FOSErrorPreinit()
	{
	//  initialize critical sections

#ifdef ENABLE_EXCEPTIONS
	if ( !( hsemExcept = CreateSemaphore( NULL, 1, 1, NULL ) ) )
		{
		return fFalse;
		}
	SetHandleInformation( hsemExcept, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
#endif  //  ENABLE_EXCEPTIONS
#ifdef DEBUG
	if ( !( hsemAssert = CreateSemaphore( NULL, 1, 1, NULL ) ) )
		{
		SetHandleInformation( hsemExcept, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hsemExcept );
		hsemExcept = NULL;
		return fFalse;
		}
	SetHandleInformation( hsemAssert, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
#endif  //  DEBUG

	return fTrue;
	}


//  terminate error subsystem

void OSErrorTerm()
	{
	//  nop
	}

//  init error subsystem

ERR ErrOSErrorInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\event.cxx ===
#include "osstd.hxx"

#ifdef MINIMAL_FUNCTIONALITY

VOID OSEventPostterm()		{}
BOOL FOSEventPreinit()		{ return fTrue; }
VOID OSEventTerm()			{}
ERR ErrOSEventInit()		{ return JET_errSuccess; }

#else

#include <malloc.h>


//  Event Logging

LOCAL volatile HANDLE hEventSource;

LOCAL CRITICAL_SECTION csEventCache;
LOCAL BOOL fcsEventCacheInit;

#pragma warning ( disable : 4200 )	//  we allow zero sized arrays

struct EVENT
	{
	SIZE_T			cb;
	EVENT*			peventNext;
	const _TCHAR*	szSourceEventKey;
	EEventType		type;
	CategoryId		catid;
	MessageId		msgid;
	DWORD			cbRawData;
	void*			pvRawData;
	DWORD			cString;
	const _TCHAR*	rgpsz[0];
	};

LOCAL EVENT*		peventCacheHead;
LOCAL EVENT*		peventCacheTail;
LOCAL DWORD			ceventLost;
LOCAL SIZE_T		cbEventCache;


//  writes all cached events to the event log, ignoring any errors encountered

void OSEventIFlushEventCache()
	{
	EVENT*	peventPrev	= NULL;
	EVENT*	pevent;
	EVENT*	peventNext;

	//  report all cached events

	for ( pevent = peventCacheHead; NULL != pevent; pevent = peventNext )
		{
		//	save next event, because this one may go away
		peventNext = pevent->peventNext;
		
		hEventSource = RegisterEventSource( NULL, pevent->szSourceEventKey );
		if ( hEventSource )
			{
			SIZE_T	cbAlloc		= pevent->cb;

			//	remove this event from the list
			if ( NULL == peventPrev )
				{
				Assert( pevent == peventCacheHead );
				peventCacheHead = pevent->peventNext;
				}
			else
				{
				AssertTracking();		//	JLIEM: do we really have a case where only SOME events get removed from the list?
				peventPrev->peventNext = pevent->peventNext;
				}
			if ( pevent == peventCacheTail )
				peventCacheTail = peventPrev;
			
			(void)ReportEvent(	hEventSource,
								WORD( pevent->type ),
								WORD( pevent->catid ),
								pevent->msgid,
								0,
								WORD( pevent->cString ),
								WORD( pevent->cbRawData ),
								(const _TCHAR**)pevent->rgpsz,
								pevent->pvRawData );

			//	free the event
			const BOOL	fFreedEventMemory	= !LocalFree( pevent );
			Assert( fFreedEventMemory );

			DeregisterEventSource( hEventSource );
			hEventSource = NULL;

			Assert( cbEventCache >= cbAlloc );
			cbEventCache -= cbAlloc;
			}
		else
			{
			//	this event is going to remain in the list
			peventPrev = pevent;
			}
		}

	Assert( NULL == peventCacheHead ? NULL == peventCacheTail : NULL != peventCacheTail );

	//  we have lost some cached events

	if ( ceventLost )
		{
		//  UNDONE:  gripe about it in the event log
		ceventLost = 0;
		}
	}



#ifdef DEBUG
LOCAL BOOL	fOSSuppressEvents	= fFalse;
#endif
	

//  reports the specifed event using the given data to the system event log
	
#pragma optimize( "y", off )

void OSEventReportEvent( const _TCHAR* szSourceEventKey, 
						 const EEventType type, 
						 const CategoryId catid, 
						 const MessageId msgid, 
						 const DWORD cString, 
						 const _TCHAR* rgpszString[], 
						 const DWORD cbRawData, 
						 void *pvRawData )
	{
#ifdef DEBUG
	//	ensure we don't get into a vicious cycle if we recursively enter this function
	//	because an assert fired within this function (and we go to report the assert in
	//	the event log)
	//	NOTE: this check doesn't need to be in the critical section because it's only
	//	designed to protect the current thread from recursively calling this function
	//	via an assert firing
	if ( fOSSuppressEvents )
		{
		return;
		}
#endif		

	//  the event log isn't open
	
	EnterCriticalSection( &csEventCache );

#ifdef DEBUG
	fOSSuppressEvents = fTrue;
#endif	

	Assert( !hEventSource );

	Assert( cbRawData == 0 || pvRawData != NULL );
	
	//  write all cached events to the event log
	if ( NULL != peventCacheHead )
		OSEventIFlushEventCache();

	//  try once again to open the event log
	
	hEventSource = RegisterEventSource( NULL, szSourceEventKey );

	//  we still failed to open the event log

	if ( !hEventSource )
		{
		//  allocate memory to cache this event

		extern LONG		g_cbEventHeapMax;
		EVENT*			pevent				= NULL;
		SIZE_T 			cbAlloc				= sizeof(EVENT);

		//	allocate room for eventsource, plus null terminator
		cbAlloc += _tcslen( szSourceEventKey ) + sizeof(_TCHAR );

		//	allocate room for string array
		cbAlloc += sizeof(const _TCHAR*) * cString;

		//	allocate room for individual strings, plus null terminator
		for ( DWORD ipsz = 0; ipsz < cString; ipsz++ )
			{
			cbAlloc += _tcslen( rgpszString[ipsz] ) + sizeof(_TCHAR);
			}

		//	allocate room for raw data
		cbAlloc += cbRawData;
		
		if ( cbEventCache + cbAlloc < g_cbEventHeapMax )
			{
			pevent = (EVENT*)LocalAlloc( 0, cbAlloc );
			if ( pevent )
				{
				cbEventCache += cbAlloc;
				}
			}

		//  we are out of memory
		
		if ( !pevent )
			{
			//  we lost this event

			ceventLost++;
			}

		//  we got the memory

		else
			{
			//  insert the event into the event cache
			_TCHAR*		psz;

			pevent->cb = cbAlloc;
			pevent->peventNext = NULL;
			pevent->type = type;
			pevent->catid = catid;
			pevent->msgid = msgid;
			pevent->cbRawData = cbRawData;
			pevent->cString = cString;

			//	start storing strings after the string array
			psz = (_TCHAR*)pevent->rgpsz + ( sizeof(const _TCHAR*) * cString );

			//	eventsource comes first
			pevent->szSourceEventKey = psz;
			_tcscpy( psz, szSourceEventKey );
			psz += _tcslen( szSourceEventKey ) + sizeof(_TCHAR);

			//	next store raw data
			if ( cbRawData > 0 )
				{
				pevent->pvRawData = (void*)psz;
				memcpy( psz, pvRawData, cbRawData );
				psz += cbRawData;
				}
			else
				{
				pevent->pvRawData = NULL;
				}

			//	finally store individual strings
			for ( DWORD ipsz = 0; ipsz < cString; ipsz++ )
				{
				pevent->rgpsz[ipsz] = psz;
				_tcscpy( psz, rgpszString[ipsz] );
				psz += _tcslen( rgpszString[ipsz] ) + sizeof(_TCHAR);
				}

			if ( psz - (_TCHAR*)pevent == cbAlloc )
				{
				if ( NULL != peventCacheTail )
					{
					Assert( NULL != peventCacheHead );
					peventCacheTail->peventNext = pevent;
					}
				else
					{
					Assert( NULL == peventCacheHead );
					peventCacheHead = pevent;
					}
				peventCacheTail = pevent;
				}
			else
				{
				Assert( fFalse );	//	should be impossible
				const BOOL	fFreedEventMemory = !LocalFree( pevent );
				Assert( fFreedEventMemory );
				}

			}
		}

	//  we opened the event log

	else
		{
		//  write event to the event log, ignoring any errors encountered
		
		(void)ReportEvent(	hEventSource,
							WORD( type ),
							WORD( catid ),
							msgid,
							0,
							WORD( cString ),
							WORD( cbRawData ),
							rgpszString,
							pvRawData );

		DeregisterEventSource( hEventSource );
		hEventSource = NULL;
		}

#ifdef DEBUG
	fOSSuppressEvents = fFalse;
#endif	

	LeaveCriticalSection( &csEventCache );
	}

#pragma optimize( "", on )


//  post-terminate event subsystem

void OSEventPostterm()
	{
	//	with our current eventlog scheme, it should be impossible to come here with an open event source
	Assert( !hEventSource || FUtilProcessAbort() );

	//  the event log is not open and we still have cached events

	if ( NULL != peventCacheHead )
		{
		Assert( NULL != peventCacheTail );

		//  try one last time to open the event log and write all cached events
		if ( hEventSource )
			{
			Assert( FUtilProcessAbort() );
			DeregisterEventSource( hEventSource );
			hEventSource = NULL;
			}
		OSEventIFlushEventCache();

		//  purge remaining cached events
		//  CONSIDER:  write remaining cached events to a file
		EVENT*	pevent;
		EVENT*	peventNext;			
		for ( pevent = peventCacheHead; pevent; pevent = pevent = peventNext )
			{
			peventNext = pevent->peventNext;
			const BOOL	fFreedEventMemory	= !LocalFree( pevent );
			Assert( fFreedEventMemory );
			}
		}
	else
		{
		Assert( NULL == peventCacheTail );
		}

	//  the event log is open

	if ( hEventSource )
		{
		//	UNDONE: this code path should be dead
		Assert( FUtilProcessAbort() );

		//  we should not have any cached events

		Assert( NULL == peventCacheHead );
		Assert( NULL == peventCacheTail );

		//  close the event log
		//
		//  NOTE:  ignore any error returned as the event log service may have
		//  already been shut down
		
		DeregisterEventSource( hEventSource );
		hEventSource = NULL;
		}

	//  reset the event cache
	
	peventCacheHead	= NULL;
	peventCacheTail	= NULL;
	ceventLost		= 0;
	cbEventCache	= 0;

	//  delete the event cache critical section

	if( fcsEventCacheInit )
		{
		DeleteCriticalSection( &csEventCache );
		fcsEventCacheInit = fFalse;
		}
	}

//  pre-init event subsystem

BOOL FOSEventPreinit()
	{
	//  initialize the event cache critical section

	InitializeCriticalSection( &csEventCache );
	fcsEventCacheInit = fTrue;
	
	//  reset the event cache
	
	peventCacheHead	= NULL;
	peventCacheTail	= NULL;
	ceventLost		= 0;
	cbEventCache	= 0;
	
	//  add ourself as an event source in the registry

	static const _TCHAR szApplicationKeyPath[] = _T( "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\" );
	_TCHAR szImageKeyPath[ sizeof( szApplicationKeyPath ) + _MAX_FNAME ];
	_stprintf( szImageKeyPath, _T( "%s%.*s" ), szApplicationKeyPath, _MAX_FNAME, SzUtilImageVersionName() );

	DWORD error;
	HKEY hkeyImage;
	DWORD Disposition;
	error = RegCreateKeyEx(	HKEY_LOCAL_MACHINE,
							szImageKeyPath,
							0,
							NULL,
							REG_OPTION_NON_VOLATILE,
							KEY_WRITE,
							NULL,
							&hkeyImage,
							&Disposition );
	if ( error == ERROR_SUCCESS )
		{
		error = RegSetValueEx(	hkeyImage,
								_T( "EventMessageFile" ),
								0,
								REG_EXPAND_SZ,
								LPBYTE( SzUtilImagePath() ),
								(ULONG)_tcslen( SzUtilImagePath() ) + 1 );
		Assert( error == ERROR_SUCCESS );
		error = RegSetValueEx(	hkeyImage,
								_T( "CategoryMessageFile" ),
								0,
								REG_EXPAND_SZ,
								LPBYTE( SzUtilImagePath() ),
								(ULONG)_tcslen( SzUtilImagePath() ) + 1 );
		Assert( error == ERROR_SUCCESS );
		DWORD Data = MAC_CATEGORY - 1;
		error = RegSetValueEx(	hkeyImage,
								_T( "CategoryCount" ),
								0,
								REG_DWORD,
								LPBYTE( &Data ),
								sizeof( Data ) );
		Assert( error == ERROR_SUCCESS );
		Data = EVENTLOG_INFORMATION_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_ERROR_TYPE;
		error = RegSetValueEx(	hkeyImage,
								_T( "TypesSupported" ),
								0,
								REG_DWORD,
								LPBYTE( &Data ),
								sizeof( Data ) );
		Assert( error == ERROR_SUCCESS );
		error = RegCloseKey( hkeyImage );
		Assert( error == ERROR_SUCCESS );
		}
	else if ( error != ERROR_ACCESS_DENIED )
		{
		goto HandleError;
		}

	return fTrue;

HandleError:
	OSEventPostterm();
	return fFalse;
	}

//  terminate event subsystem

void OSEventTerm()
	{
	//  nop
	}

//  init event subsystem

ERR ErrOSEventInit()
	{
	//  nop

	return JET_errSuccess;
	}

#endif	//	MINIMAL_FUNCTIONALITY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\library.cxx ===
#include "osstd.hxx"


//  Dynamically Loaded Libraries

//  loads the library from the specified file, returning fTrue and the library
//  handle on success

BOOL FUtilLoadLibrary( const _TCHAR* szLibrary, LIBRARY* plibrary, const BOOL fPermitDialog )
	{
	while ( NULL == ( *plibrary = (LIBRARY)LoadLibrary( (LPTSTR)szLibrary ) )
		&& fPermitDialog )
		{		
		_TCHAR szMessage[256];
		(void)_stprintf(
			szMessage,
			_T( 	"Unable to find the callback library %s (or one of its dependencies).\r\n"
					"Copy in the file and hit OK to retry, or hit Cancel to abort.\r\n" ),
			szLibrary );
		Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );

		const int id = UtilMessageBox(
							szMessage,
							_T( "Callback DLL not found" ),
							MB_SERVICE_NOTIFICATION | MB_SYSTEMMODAL | MB_ICONSTOP |
							MB_OKCANCEL );

		if ( IDOK != id )
			{
			break;
			}
		}
		
	return ( NULL != *plibrary );
	}

//  retrieves the function pointer from the specified library or NULL if that
//  function is not found in the library

PFN PfnUtilGetProcAddress( LIBRARY library, const char* szFunction )
	{
	return (PFN) GetProcAddress( (HMODULE) library, szFunction );
	}

//  unloads the specified library

void UtilFreeLibrary( LIBRARY library )
	{
	FreeLibrary( (HMODULE) library );
	}

	
//  post-terminate library subsystem

void OSLibraryPostterm()
	{
	//  nop
	}

//  pre-init library subsystem

BOOL FOSLibraryPreinit()
	{
	//  nop

	return fTrue;
	}


//  terminate library subsystem

void OSLibraryTerm()
	{
	//  nop
	}

//  init library subsystem

ERR ErrOSLibraryInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\edbg.cxx ===
#include "osstd.hxx"


#include <imagehlp.h>
#include <wdbgexts.h>


#include "std.hxx"
#include "_bf.hxx"
#include "_osslv.hxx"
#include "_tls.hxx"


#ifdef DEBUGGER_EXTENSION

#define EDBGAddGlobal( x )		{ #x, (VOID *)&x }

//	forward references
extern SIZE_T		cEDBGGlobals;
extern DWORD		cAllocHeap;
extern DWORD		cFreeHeap;
extern DWORD		cbAllocHeap;
extern DWORD_PTR	cbReservePage;
extern DWORD_PTR	cbCommitPage;
extern CRES *		g_pcresVERPool;

EDBGGLOBALVAR		rgEDBGGlobals[]	=
						{
						EDBGAddGlobal( cEDBGGlobals ),		//	must be first entry
						EDBGAddGlobal( g_cbPage ),
						EDBGAddGlobal( rgfmp ),
						EDBGAddGlobal( ifmpMax ),
						EDBGAddGlobal( g_rgpinst ),
						EDBGAddGlobal( ipinstMax ),
						EDBGAddGlobal( cbfChunk ),
						EDBGAddGlobal( rgpbfChunk ),
						EDBGAddGlobal( cbfCache ),
						EDBGAddGlobal( cpgChunk ),
						EDBGAddGlobal( rgpvChunk ),
						EDBGAddGlobal( cAllocHeap ),
						EDBGAddGlobal( cFreeHeap ),
						EDBGAddGlobal( cbAllocHeap ),
						EDBGAddGlobal( cbReservePage ),
						EDBGAddGlobal( cbCommitPage ),
						EDBGAddGlobal( CPAGE::cbHintCache ),
						EDBGAddGlobal( CPAGE::maskHintCache ),
						EDBGAddGlobal( g_pcresVERPool )
						};

SIZE_T				cEDBGGlobals			= sizeof(rgEDBGGlobals) / sizeof(EDBGGLOBALVAR);

//	debugger's copy of the globals table
EDBGGLOBALVAR *		rgEDBGGlobalsDebugger	= NULL;


//  ****************************************************************
//  STRUCTURES AND CLASSES
//  ****************************************************************


//  ================================================================
typedef VOID (*EDBGFUNC)(
//  ================================================================
	const HANDLE hCurrentProcess,
	const HANDLE hCurrentThread,
	const DWORD dwCurrentPc,
    const PWINDBG_EXTENSION_APIS lpExtensionApis,
    const INT argc,
    const CHAR * const argv[]
    );


//  ================================================================
class CPRINTFWDBG : public CPRINTF
//  ================================================================
	{
	public:
		VOID __cdecl operator()( const char * szFormat, ... ) const;
		static CPRINTF * PcprintfInstance();

		~CPRINTFWDBG() {}

	private:
		CPRINTFWDBG() {}
		static CHAR szBuf[1024];	//  WARNING: not multi-threaded safe!
	};


//  ================================================================
class CDUMP
//  ================================================================
	{
	public:
		CDUMP() {}
		virtual ~CDUMP() {}

		virtual VOID Dump( HANDLE, HANDLE, DWORD, PWINDBG_EXTENSION_APIS, INT, const CHAR * const [] ) = 0;
	};


//  ================================================================
template< class _STRUCT>
class CDUMPA : public CDUMP
//  ================================================================
	{
	public:
		VOID Dump(
			    HANDLE hCurrentProcess,
			    HANDLE hCurrentThread,
			    DWORD dwCurrentPc,
			    PWINDBG_EXTENSION_APIS lpExtensionApis,
			    INT argc,
			    const CHAR * const argv[] );
		static CDUMPA	instance;
	};


//  ================================================================
struct EDBGFUNCMAP
//  ================================================================
	{
	const char * 	szCommand;
	EDBGFUNC		function;
	const char * 	szHelp;
	};


//  ================================================================
struct CDUMPMAP
//  ================================================================
	{
	const char * 	szCommand;
	CDUMP 	   *	pcdump;
	const char * 	szHelp;
	};


//	HACK: declare dummy instances of these classes to allow dumping them
//
typedef CDynamicHashTable<DWORD,DWORD>			CDynamicHashTableEDBG;
typedef CApproximateIndex<DWORD,DWORD,0>		CApproximateIndexEDBG;
typedef CInvasiveList<DWORD,0>					CInvasiveListEDBG;


//  ****************************************************************
//  PROTOTYPES
//  ****************************************************************


#define VariableNameToString( var )	#var

#define DUMPA(_struct)	{ #_struct, &(CDUMPA<_struct>::instance), #_struct " <address>" }

#define DEBUG_EXT( name )					\
	LOCAL VOID name(						\
		const HANDLE hCurrentProcess,		\
		const HANDLE hCurrentThread,		\
		const DWORD dwCurrentPc,			\
	    const PWINDBG_EXTENSION_APIS lpExtensionApis,	\
	    const INT argc,						\
	    const CHAR * const argv[]  )

DEBUG_EXT( EDBGBFOB0FindOldest );
DEBUG_EXT( EDBGCacheFind );
DEBUG_EXT( EDBGCacheFindOldest );
DEBUG_EXT( EDBGCacheMap );
DEBUG_EXT( EDBGChecksum );
DEBUG_EXT( EDBGDebug );
DEBUG_EXT( EDBGDump );
DEBUG_EXT( EDBGDumpCacheMap );
DEBUG_EXT( EDBGDumpInvasiveList );
DEBUG_EXT( EDBGDumpLinkedList );
DEBUG_EXT( EDBGDumpMetaData );
DEBUG_EXT( EDBGDumpLR );
DEBUG_EXT( EDBGErr );
DEBUG_EXT( EDBGFCBFind );
DEBUG_EXT( EDBGFindRes );
DEBUG_EXT( EDBGGlobals );
DEBUG_EXT( EDBGHash );
DEBUG_EXT( EDBGHelp );
DEBUG_EXT( EDBGHelpDump );
DEBUG_EXT( EDBGLoad );
DEBUG_EXT( EDBGMemory );
DEBUG_EXT( EDBGSeek );
DEBUG_EXT( EDBGSync );
DEBUG_EXT( EDBGTableFind );
DEBUG_EXT( EDBGTest );
DEBUG_EXT( EDBGTid2PIB );
DEBUG_EXT( EDBGUnload );
DEBUG_EXT( EDBGVersion );
DEBUG_EXT( EDBGVerStore );
DEBUG_EXT( EDBGDumpAllFMPs );
DEBUG_EXT( EDBGDumpAllINSTs );
DEBUG_EXT( EDBGSympath );



extern VOID DBUTLDumpRec( const VOID * const pv, const INT cb, CPRINTF * pcprintf, const INT cbWidth );
extern VOID JetErrorToString( JET_ERR err, const char **szError, const char **szErrorText );
extern UINT g_wAssertAction;



//  ****************************************************************
//  GLOBALS
//  ****************************************************************



LOCAL WINDBG_EXTENSION_APIS ExtensionApis;

LOCAL BOOL		fDebugMode		 	= fFalse;	//	enable exceptions and assert dialogs
LOCAL BOOL		fInit 				= fFalse;	//	debugger extensions have been initialized
LOCAL ULONG		cSymInitFail		= 0;		//	number of times attempts to initialise the symbols sub-system failed
const ULONG		cSymInitAttemptsMax	= 3;		//	max attempts to initialise the symbols sub-system

LOCAL HINSTANCE	hLibrary			= NULL;		//	if we load outselves

CHAR CPRINTFWDBG::szBuf[1024];

template< class _STRUCT>
CDUMPA<_STRUCT> CDUMPA<_STRUCT>::instance;


//  ================================================================
LOCAL EDBGFUNCMAP rgfuncmap[] = {
//  ================================================================

	{
		"HELP",				EDBGHelp,
		"HELP                               - Print this help message"
	},
	{
		"BFOB0FINDOLDEST",	EDBGBFOB0FindOldest,
		"BFOB0FINDOLDEST <ifmp> [<gen>]     - Finds the BFOB0 entry of the given ifmp containing the oldest lgposBegin0"
	},
	{
		"CACHEFIND",		EDBGCacheFind,
		"CACHEFIND <ifmp> <pgno>            - Finds the BF containing the given ifmp:pgno"
	},
	{
		"CACHEFINDOLDEST",	EDBGCacheFindOldest,
		"CACHEFINDOLDEST <ifmp> [<gen>]     - Finds the BF of the given ifmp containing the oldest lgposBegin0"
	},
	{
		"CACHEMAP",			EDBGCacheMap,
		"CACHEMAP <address>                 - Performs pv => pbf or pbf => pv mapping"
	},
	{
		"CHECKSUM",			EDBGChecksum,
		"CHECKSUM <address> [<length>]      - Checksum a <g_cbPage> range of memory"
	},
	{
		"DEBUG",			EDBGDebug,
		"DEBUG                              - Toggle debug mode"
	},
	{
		"DUMP",				EDBGDump,
		"DUMP <class> <address>             - Dump an ESE structure at the given address"
	},
	{
		"DUMPCACHEMAP",		EDBGDumpCacheMap,
		"DUMPCACHEMAP                       - Dump the database cache memory map"
	},
	{
		"DUMPFMPS",			EDBGDumpAllFMPs,
		"DUMPFMPS [<rgfmp> <ifmpMax>] [*]   - Dump all used FMPs ([*] - also dump unused FMPs)"
	},
	{
		"DUMPINSTS",		EDBGDumpAllINSTs,
		"DUMPINSTS [<g_rgpinst>]            - Dump all instances"
	},
	{
		"DUMPINVASIVELIST",	EDBGDumpInvasiveList,
		"DUMPINVASIVELIST <address> [+/-]<offset> [<dwords to display> <max elements>]\n\t"
		"                                   - Dump elements of an invasive list"
	},
	{
		"DUMPLINKEDLIST",	EDBGDumpLinkedList,
		"DUMPLINKEDLIST <address> <offset> [<dwords to display> <max elements>]\n\t"
		"                                   - Dump elements of a linked list"
	},
	{
		"DUMPLR",			EDBGDumpLR,
		"DUMPLR                             - Dump a log record"
	},
	{
		"DUMPMETADATA",		EDBGDumpMetaData,
		"DUMPMETADATA <pfcb>                - Dumps meta-data for the specified FCB"
	},
	{
		"GLOBALS",			EDBGGlobals,
		"GLOBALS [<rgEDBGGlobals>]          - Load debuggee's table of globals (use when symbol mapping does not work)."
	},
	{
		"ERR",				EDBGErr,
		"ERR <error>                        - Turn an error number into a string"
	},
	{
		"FCBFIND",			EDBGFCBFind,
		"FCBFIND <FDP> [<instance>]         - Finds all FCB's with an objidFDP or pgnoFDP matching <FDP>"
	},
	{
		"FINDRES",			EDBGFindRes,
		"FINDRES <cres> <address> <length>  - Find pointers to memory in the CRES in the address range"
	},
	{
		"HASH",				EDBGHash,
		"HASH <ifmp> <pgnoFDP> <pbPrefix> <cbPrefix> <pbSuffix> <cbSuffix> <pbData> <cbData>\n\t"
		"                                   - Generate the version store hash for a given key"
	},
	{
		"LOAD",				EDBGLoad,
		"LOAD                               - Load the DLL"
	},
	{
		"MEMORY",			EDBGMemory,
		"MEMORY                             - Dump memory usage information"
	},
	{
		"SEEK",				EDBGSeek,
		"SEEK <ifmp> <pgnoRoot> <pbPrefix> <cbPrefix> [<pbSuffix> <cbSuffix> [<pbData> <cbData>]]\n\t"
		"                                   - Seeks to the specified bookmark starting from the specified page"
	},
	{
		"SYNC",				EDBGSync,
		"SYNC ...                           - Synchronization Library Debugger Extensions"
	},
	{
		"SYMPATH", 			EDBGSympath,
		"SYMPATH [<pathname>]               - Set symbol path"
	},
	{
		"TABLEFIND",		EDBGTableFind,
		"TABLEFIND <szTable> [<instance>]   - Finds the FCB for the specified table"
	},
	{
		"TEST",				EDBGTest,
		"TEST                               - Test function"
	},
	{
		"TID2PIB",			EDBGTid2PIB,
		"TID2PIB <tid> [<g_rgpinst>]        - Find the PIB for a given TID"
	},
	{
		"UNLOAD",			EDBGUnload,
		"UNLOAD                             - Unload the DLL"
	},
	{
		"VERSION",			EDBGVersion,
		"VERSION                            - Version info for ESE.DLL"
	},
	{
		"VERSTORE",			EDBGVerStore,
		"VERSTORE <instance id>             - Dump version store usage information for the specified instance"
	},
	};

const int cfuncmap = sizeof( rgfuncmap ) / sizeof( EDBGFUNCMAP );



//  ================================================================
LOCAL CDUMPMAP rgcdumpmap[] = {
//  ================================================================

	DUMPA( BF ),
	DUMPA( RCE ),
	DUMPA( PIB ),
	DUMPA( FUCB ),
	DUMPA( CSR ),
	DUMPA( REC ),
	DUMPA( FCB ),
	DUMPA( IDB ),
	DUMPA( TDB ),
	DUMPA( CRES ),
	DUMPA( INST ),
	DUMPA( FMP ),
	DUMPA( LOG ),
	DUMPA( VER ),
	{
		"MEMPOOL", 	&(CDUMPA<MEMPOOL>::instance),
 		"MEMPOOL <address> [<itag>|*]       - <itag>=specified tag only, *=all tags"
	},
	DUMPA( SPLIT ),
	DUMPA( SPLITPATH ),
	DUMPA( MERGE ),
	DUMPA( MERGEPATH ),
	DUMPA( DBFILEHDR ),
	{
		"CDynamicHashTable", &(CDUMPA<CDynamicHashTableEDBG>::instance),
		"CDynamicHashTable <address>"
	},
	{
		"CApproximateIndex", &(CDUMPA<CApproximateIndexEDBG>::instance),
		"CApproximateIndex <address>"
	},
	DUMPA( COSFile ),
	DUMPA( COSFileFind ),
	DUMPA( COSFileLayout ),
	DUMPA( COSFileSystem ),
	{
		"PAGE", 	&(CDUMPA<CPAGE>::instance),
		"PAGE [a|h|t|*|2|4|8] <address>     - a=alloc map, h=header, t=tags, *=all, 2/4/8=pagesize"
	},

#ifdef DISABLE_SLV
#else
	DUMPA( CSLVBackingFile ),
	DUMPA( CSLVFileInfo ),
	DUMPA( CSLVFileTable ),
	DUMPA( CSLVInfo ),
	DUMPA( _SLVROOT ),
#endif
	};

const int ccdumpmap = sizeof( rgcdumpmap ) / sizeof( CDUMPMAP );



//  ****************************************************************
//  FUNCTIONS
//  ****************************************************************



//  ================================================================
inline VOID __cdecl CPRINTFWDBG::operator()( const char * szFormat, ... ) const
//  ================================================================
	{
	va_list arg_ptr;
	va_start( arg_ptr, szFormat );
	_vsnprintf( szBuf, sizeof( szBuf ), szFormat, arg_ptr );
	va_end( arg_ptr );
	szBuf[ sizeof( szBuf ) - 1 ] = 0;
	(ExtensionApis.lpOutputRoutine)( "%s", szBuf );
	}


//  ================================================================
CPRINTF * CPRINTFWDBG::PcprintfInstance()
//  ================================================================
	{
	static CPRINTFWDBG CPrintfWdbg;
	return &CPrintfWdbg;
	}


//  ================================================================
LOCAL INT SzToRgsz( CHAR * rgsz[], CHAR * const sz )
//  ================================================================
	{
	INT irgsz = 0;
	CHAR * szT = sz;
	while( NULL != ( rgsz[irgsz] = strtok( szT, " \t\n" ) ) )
		{
		++irgsz;
		szT = NULL;
		}
	return irgsz;
	}


//  ================================================================
LOCAL BOOL FArgumentMatch( const CHAR * const sz, const CHAR * const szCommand )
//  ================================================================
	{
	const BOOL fMatch = ( ( strlen( sz ) == strlen( szCommand ) )
			&& !( _strnicmp( sz, szCommand, strlen( szCommand ) ) ) );
	return fMatch;
	}


namespace OSSYM {

#include <imagehlp.h>
#include <psapi.h>


typedef DWORD IMAGEAPI WINAPI PFNUnDecorateSymbolName( PCSTR, PSTR, DWORD, DWORD );
typedef DWORD IMAGEAPI PFNSymSetOptions( DWORD );
typedef BOOL IMAGEAPI PFNSymCleanup( HANDLE );
typedef BOOL IMAGEAPI PFNSymInitialize( HANDLE, PSTR, BOOL );
typedef BOOL IMAGEAPI PFNSymGetSymFromAddr( HANDLE, DWORD_PTR, DWORD_PTR*, PIMAGEHLP_SYMBOL );
typedef BOOL IMAGEAPI PFNSymGetSymFromName( HANDLE, PSTR, PIMAGEHLP_SYMBOL );
typedef BOOL IMAGEAPI PFNSymGetSearchPath( HANDLE, PSTR, DWORD );
typedef BOOL IMAGEAPI PFNSymSetSearchPath( HANDLE, PSTR );
typedef BOOL IMAGEAPI PFNSymGetModuleInfo( HANDLE, DWORD_PTR, PIMAGEHLP_MODULE );
typedef DWORD IMAGEAPI PFNSymLoadModule( HANDLE, HANDLE, PSTR, PSTR, DWORD_PTR, DWORD );
typedef DWORD IMAGEAPI PFNSymUnloadModule( HANDLE, DWORD_PTR );
typedef PIMAGE_NT_HEADERS IMAGEAPI PFNImageNtHeader( PVOID );

PFNUnDecorateSymbolName*	pfnUnDecorateSymbolName;
PFNSymSetOptions*			pfnSymSetOptions;
PFNSymCleanup*				pfnSymCleanup;
PFNSymInitialize*			pfnSymInitialize;
PFNSymGetSymFromAddr*		pfnSymGetSymFromAddr;
PFNSymGetSymFromName*		pfnSymGetSymFromName;
PFNSymGetSearchPath*		pfnSymGetSearchPath;
PFNSymSetSearchPath*		pfnSymSetSearchPath;
PFNSymGetModuleInfo*		pfnSymGetModuleInfo;
PFNSymLoadModule*			pfnSymLoadModule;
PFNSymUnloadModule*			pfnSymUnloadModule;
PFNImageNtHeader*			pfnImageNtHeader;

HMODULE hmodImagehlp;

typedef BOOL WINAPI PFNEnumProcessModules( HANDLE, HMODULE*, DWORD, LPDWORD );
typedef DWORD WINAPI PFNGetModuleFileNameExA( HANDLE, HMODULE, LPSTR, DWORD );
typedef DWORD WINAPI PFNGetModuleBaseNameA( HANDLE, HMODULE, LPSTR, DWORD );
typedef BOOL WINAPI PFNGetModuleInformation( HANDLE, HMODULE, LPMODULEINFO, DWORD );

PFNEnumProcessModules*		pfnEnumProcessModules;
PFNGetModuleFileNameExA*	pfnGetModuleFileNameExA;
PFNGetModuleBaseNameA*		pfnGetModuleBaseNameA;
PFNGetModuleInformation*	pfnGetModuleInformation;

HMODULE hmodPsapi;

LOCAL const DWORD symopt =	SYMOPT_CASE_INSENSITIVE |
							SYMOPT_UNDNAME |
							SYMOPT_OMAP_FIND_NEAREST |
							SYMOPT_DEFERRED_LOADS;
LOCAL CHAR szParentImageName[_MAX_FNAME];
LOCAL HANDLE ghDbgProcess;


//  ================================================================
LOCAL BOOL SymLoadAllModules( HANDLE hProcess, BOOL fReload = fFalse )
//  ================================================================
	{
	HMODULE* rghmodDebuggee = NULL;

	//  fetch all modules in the debuggee process and manually load their symbols.
	//  we do this because telling imagehlp to invade the debuggee process doesn't
	//  work when we are already running in the context of a debugger

	DWORD cbNeeded;
	if ( !pfnEnumProcessModules( hProcess, NULL, 0, &cbNeeded ) )
		{
		goto HandleError;
		}

	DWORD cbActual;
	do	{
		cbActual = cbNeeded;
		rghmodDebuggee = (HMODULE*)LocalAlloc( 0, cbActual );
		if ( NULL == rghmodDebuggee )
			{
			goto HandleError;
			}

		if ( !pfnEnumProcessModules( hProcess, rghmodDebuggee, cbActual, &cbNeeded ) )
			{
			goto HandleError;
			}
		}
	while ( cbNeeded > cbActual );

	SIZE_T ihmod;
	SIZE_T ihmodLim;

	ihmodLim = cbNeeded / sizeof( HMODULE );
	for ( ihmod = 0; ihmod < ihmodLim; ihmod++ )
		{
		char szModuleImageName[ _MAX_PATH ];
		if ( !pfnGetModuleFileNameExA( hProcess, rghmodDebuggee[ ihmod ], szModuleImageName, _MAX_PATH ) )
			{
			goto HandleError;
			}

		char szModuleBaseName[ _MAX_FNAME ];
		if ( !pfnGetModuleBaseNameA( hProcess, rghmodDebuggee[ ihmod ], szModuleBaseName, _MAX_FNAME ) )
			{
			goto HandleError;
			}

		MODULEINFO mi;
		if ( !pfnGetModuleInformation( hProcess, rghmodDebuggee[ ihmod ], &mi, sizeof( mi ) ) )
			{
			goto HandleError;
			}

		if ( fReload )
			{
			pfnSymUnloadModule( hProcess, DWORD_PTR( mi.lpBaseOfDll ) );
			}

		if ( !pfnSymLoadModule(	hProcess,
								NULL,
								szModuleImageName,
								szModuleBaseName,
								DWORD_PTR( mi.lpBaseOfDll ),
								mi.SizeOfImage ) )
			{
			goto HandleError;
			}

		IMAGEHLP_MODULE im;
		im.SizeOfStruct = sizeof( IMAGEHLP_MODULE );

		if ( !pfnSymGetModuleInfo( hProcess, DWORD_PTR( mi.lpBaseOfDll ), &im ) )
			{
			goto HandleError;
			}
		}

	return fTrue;

HandleError:
	if ( NULL != (void *)rghmodDebuggee )
		{
		LocalFree( (void*)rghmodDebuggee );
		}
	return fFalse;
	}

//  ================================================================
LOCAL BOOL SymInitializeEx(	HANDLE hProcess, HANDLE* phProcess )
//  ================================================================
	{
	//  init our out param

	*phProcess = NULL;

	//  duplicate the given debuggee process handle so that we have our own
	//  sandbox in imagehlp

	if ( !DuplicateHandle(	GetCurrentProcess(),
							hProcess,
							GetCurrentProcess(),
							phProcess,
							0,
							FALSE,
							DUPLICATE_SAME_ACCESS ) )
		{
		goto HandleError;
		}
	SetHandleInformation( *phProcess, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	//  init imagehlp for the debuggee process

	if ( !pfnSymInitialize( *phProcess, NULL, FALSE ) )
		{
		goto HandleError;
		}

	//  we're done

	return fTrue;

HandleError:
	if ( *phProcess )
		{
		SetHandleInformation( *phProcess, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( *phProcess );
		*phProcess = NULL;
		}
	return fFalse;
	}

//  ================================================================
LOCAL void SymTerm()
//  ================================================================
	{
	//  shut down imagehlp

	if ( pfnSymCleanup )
		{
		if ( ghDbgProcess )
			{
			pfnSymCleanup( ghDbgProcess );
			}
		pfnSymCleanup = NULL;
		}

	//  free psapi

	if ( hmodPsapi )
		{
		FreeLibrary( hmodPsapi );
		hmodPsapi = NULL;
		}

	//  free imagehlp

	if ( hmodImagehlp )
		{
		FreeLibrary( hmodImagehlp );
		hmodImagehlp = NULL;
		}

	//  close our process handle

	if ( ghDbgProcess )
		{
		SetHandleInformation( ghDbgProcess, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( ghDbgProcess );
		ghDbgProcess = NULL;
		}
	}

//  ================================================================
LOCAL BOOL FSymInit( HANDLE hProc )
//  ================================================================
	{
	HANDLE hThisProcess = NULL;

	//  reset all pointers

	ghDbgProcess	= NULL;
	hmodImagehlp	= NULL;
	pfnSymCleanup	= NULL;
	hmodPsapi		= NULL;

	//  load all calls in imagehlp

	if ( !( hmodImagehlp = LoadLibrary( "imagehlp.dll" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetSymFromAddr = (PFNSymGetSymFromAddr*)GetProcAddress( hmodImagehlp, "SymGetSymFromAddr" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetSymFromName = (PFNSymGetSymFromName*)GetProcAddress( hmodImagehlp, "SymGetSymFromName" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymInitialize = (PFNSymInitialize*)GetProcAddress( hmodImagehlp, "SymInitialize" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymCleanup = (PFNSymCleanup*)GetProcAddress( hmodImagehlp, "SymCleanup" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymSetOptions = (PFNSymSetOptions*)GetProcAddress( hmodImagehlp, "SymSetOptions" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnUnDecorateSymbolName = (PFNUnDecorateSymbolName*)GetProcAddress( hmodImagehlp, "UnDecorateSymbolName" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetSearchPath = (PFNSymGetSearchPath*)GetProcAddress( hmodImagehlp, "SymGetSearchPath" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymSetSearchPath = (PFNSymSetSearchPath*)GetProcAddress( hmodImagehlp, "SymSetSearchPath" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetModuleInfo = (PFNSymGetModuleInfo*)GetProcAddress( hmodImagehlp, "SymGetModuleInfo" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymLoadModule = (PFNSymLoadModule*)GetProcAddress( hmodImagehlp, "SymLoadModule" ) ) )
		{
		goto HandleError;
		}

	if ( !( pfnSymUnloadModule = (PFNSymUnloadModule*)GetProcAddress( hmodImagehlp, "SymUnloadModule" ) ) )
		{
		goto HandleError;
		}

	if ( !( pfnImageNtHeader = (PFNImageNtHeader*)GetProcAddress( hmodImagehlp, "ImageNtHeader" ) ) )
		{
		goto HandleError;
		}

	//  load all calls in psapi

	if ( !( hmodPsapi = LoadLibrary( "psapi.dll" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnEnumProcessModules = (PFNEnumProcessModules*)GetProcAddress( hmodPsapi, "EnumProcessModules" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnGetModuleFileNameExA = (PFNGetModuleFileNameExA*)GetProcAddress( hmodPsapi, "GetModuleFileNameExA" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnGetModuleBaseNameA = (PFNGetModuleBaseNameA*)GetProcAddress( hmodPsapi, "GetModuleBaseNameA" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnGetModuleInformation = (PFNGetModuleInformation*)GetProcAddress( hmodPsapi, "GetModuleInformation" ) ) )
		{
		goto HandleError;
		}

	//  get the name of our parent image in THIS process.  we need this name so
	//  that we can prefix symbols with the default module name and so that we
	//  can add the image path to the symbol path

	MEMORY_BASIC_INFORMATION mbi;
	if ( !VirtualQueryEx( GetCurrentProcess(), FSymInit, &mbi, sizeof( mbi ) ) )
		{
		goto HandleError;
		}
	char szImage[_MAX_PATH];
	if ( !GetModuleFileNameA( HINSTANCE( mbi.AllocationBase ), szImage, sizeof( szImage ) ) )
		{
		goto HandleError;
		}
	_splitpath( (const _TCHAR *)szImage, NULL, NULL, szParentImageName, NULL );

	//  init imagehlp for the debuggee process

	if ( !SymInitializeEx( hProc, &ghDbgProcess ) )
		{
		goto HandleError;
		}

	//  set our symbol path to include the path of this image and the process
	//  executable

	char szOldPath[ 4 * _MAX_PATH ];
	if ( pfnSymGetSearchPath( ghDbgProcess, szOldPath, sizeof( szOldPath ) ) )
		{
		char szNewPath[ 6 * _MAX_PATH ];
		char szDrive[ _MAX_DRIVE ];
		char szDir[ _MAX_DIR ];
		char szPath[ _MAX_PATH ];

		szNewPath[ 0 ] = 0;

		strcat( szNewPath, szOldPath );
		strcat( szNewPath, ";" );

		HMODULE hImage = GetModuleHandle( szParentImageName );
		GetModuleFileName( hImage, szPath, _MAX_PATH );
		_splitpath( szPath, szDrive, szDir, NULL, NULL );
		_makepath( szPath, szDrive, szDir, NULL, NULL );
		strcat( szNewPath, szPath );
		strcat( szNewPath, ";" );

		GetModuleFileName( NULL, szPath, _MAX_PATH );
		_splitpath( szPath, szDrive, szDir, NULL, NULL );
		_makepath( szPath, szDrive, szDir, NULL, NULL );
		strcat( szNewPath, szPath );

		pfnSymSetSearchPath( ghDbgProcess, szNewPath );
		}

	//  set our default symbol options

	pfnSymSetOptions( symopt );

	//  prepare symbols for the debuggee process

	if ( !SymLoadAllModules( ghDbgProcess ) )
		{
		goto HandleError;
		}

	return fTrue;

HandleError:
	if ( hThisProcess )
		{
		SetHandleInformation( hThisProcess, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hThisProcess );
		}
	SymTerm();
	return fFalse;
	}

//  ================================================================
LOCAL BOOL FUlFromSz( const char* const sz, ULONG* const pul, const int base = 16 )
//  ================================================================
	{
	if( sz && *sz )
		{
		char* pchEnd;
		*pul = strtoul( sz, &pchEnd, base );
		return !( *pchEnd );
		}
	return fFalse;
	}

//  ================================================================
template< class T >
LOCAL BOOL FAddressFromSz( const char* const sz, T** const ppt )
//  ================================================================
	{
	if ( sz && *sz )
		{
		int		n;
		QWORD	first;
		DWORD	second;
		int		cchRead;
		BOOL	f;

		n = sscanf( sz, "%I64x%n%*[` ]%8lx%n", &first, &cchRead, &second, &cchRead );

		switch ( n )
			{
			case 2:
				*ppt = (T*)( ( first << 32 ) | second );
				f = fTrue;
				break;

			case 1:
				*ppt = (T*)( first );
				f = fTrue;
				break;

			default:
				f = fFalse;
				break;
			};
		if ( cchRead != int( strlen( sz ) ) )
			{
			f = fFalse;
			}

		return f;
		}
	return fFalse;
	}

//  ================================================================
template< class T >
LOCAL BOOL FHintAddressFromGlobal( const char* const szGlobal, T** const ppt )
//  ================================================================
	{
	if ( NULL != rgEDBGGlobalsDebugger )
		{
		//	search in the table for the particular global name
		for ( SIZE_T i = 1; i < (SIZE_T)rgEDBGGlobalsDebugger[0].pvAddress; i++ )
			{
			if ( 0 == _stricmp( rgEDBGGlobalsDebugger[i].szName, szGlobal ) )
				{
				*ppt = (T*)rgEDBGGlobalsDebugger[i].pvAddress;
				return fTrue;
				}
			}
		}
	return fFalse;
	}

//  ================================================================
template< class T >
LOCAL BOOL FAddressFromGlobal( const char* const szGlobal, T** const ppt )
//  ================================================================
	{
	if ( FHintAddressFromGlobal( szGlobal, ppt ) )
		{
		return fTrue;
		}
	else if ( !fInit )
		{
		return fFalse;
		}

	//  add the module prefix to the global name to form the symbol

	SIZE_T	cchSymbol	= strlen( szParentImageName ) + 1 + strlen( szGlobal );
	char*	szSymbol	= (char*)LocalAlloc( 0, ( cchSymbol + 1 ) * sizeof( char ) );
	if ( !szSymbol )
		{
		return fFalse;
		}
	szSymbol[ 0 ] = 0;
	if ( !strchr( szGlobal, '!' ) )
		{
		strcat( szSymbol, szParentImageName );
		strcat( szSymbol, "!" );
		}
	strcat( szSymbol, szGlobal );

	//  try forever until we manage to retrieve the entire undecorated symbol
	//  and address corresponding to this symbol

	SIZE_T cbBuf = 1024;
	BYTE* rgbBuf = (BYTE*)LocalAlloc( 0, cbBuf );
	if ( !rgbBuf )
		{
		LocalFree( (void*)szSymbol );
		return fFalse;
		}


	IMAGEHLP_SYMBOL* pis;
	do	{
		pis							= (IMAGEHLP_SYMBOL*)rgbBuf;
		pis->SizeOfStruct			= sizeof( IMAGEHLP_SYMBOL );
		pis->MaxNameLength			= DWORD( ( cbBuf - sizeof( IMAGEHLP_SYMBOL ) ) / sizeof( char ) );

		DWORD	symoptOld	= pfnSymSetOptions( symopt );
		BOOL	fSuccess	= pfnSymGetSymFromName( ghDbgProcess, PSTR( szSymbol ), pis );
		DWORD	symoptNew	= pfnSymSetOptions( symoptOld );

		if ( !fSuccess )
			{
			LocalFree( (void*)szSymbol );
			LocalFree( (void*)rgbBuf );
			return fFalse;
			}

		if ( strlen( pis->Name ) == cbBuf - 1 )
			{
			LocalFree( (void*)rgbBuf );
			cbBuf *= 2;
			if ( !( rgbBuf = (BYTE*)LocalAlloc( 0, cbBuf ) ) )
				{
				LocalFree( (void*)szSymbol );
				return fFalse;
				}
			}
		}
	while ( strlen( pis->Name ) == cbBuf - 1 );

	//  validate the symbols for the image containing this address

	IMAGEHLP_MODULE		im	= { sizeof( IMAGEHLP_MODULE ) };
	IMAGE_NT_HEADERS*	pnh;

	if (	!pfnSymGetModuleInfo( ghDbgProcess, pis->Address, &im ) ||
			!( pnh = pfnImageNtHeader( (void*)im.BaseOfImage ) ) ||
			pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
			pnh->FileHeader.SizeOfOptionalHeader >= IMAGE_SIZEOF_NT_OPTIONAL_HEADER &&
			pnh->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC &&
			pnh->OptionalHeader.CheckSum != im.CheckSum &&
			(	pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
				_stricmp( im.ModuleName, "kernel32" ) &&
				_stricmp( im.ModuleName, "ntdll" ) ) )
		{
		LocalFree( (void*)szSymbol );
		LocalFree( (void*)rgbBuf );
		return fFalse;
		}

	//  return the address of the symbol

	*ppt = (T*)pis->Address;

	LocalFree( (void*)szSymbol );
	LocalFree( (void*)rgbBuf );
	return fTrue;
	}

//  ================================================================
template< class T >
LOCAL BOOL FGlobalFromAddress( T* const pt, char* szGlobal, const SIZE_T cchMax, DWORD_PTR* const pdwOffset = NULL )
//  ================================================================
	{
	//  validate the symbols for the image containing this address

	IMAGEHLP_MODULE		im	= { sizeof( IMAGEHLP_MODULE ) };
	IMAGE_NT_HEADERS*	pnh;

	if (	!pfnSymGetModuleInfo( ghDbgProcess, DWORD_PTR( pt ), &im ) ||
			!( pnh = pfnImageNtHeader( (void*)im.BaseOfImage ) ) ||
			pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
			pnh->FileHeader.SizeOfOptionalHeader >= IMAGE_SIZEOF_NT_OPTIONAL_HEADER &&
			pnh->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC &&
			pnh->OptionalHeader.CheckSum != im.CheckSum &&
			(	pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
				_stricmp( im.ModuleName, "kernel32" ) &&
				_stricmp( im.ModuleName, "ntdll" ) ) )
		{
		return fFalse;
		}

	//  try forever until we manage to retrieve the entire undecorated symbol
	//  corresponding to this address

	SIZE_T cbBuf = 1024;
	BYTE* rgbBuf = (BYTE*)LocalAlloc( 0, cbBuf );
	if ( !rgbBuf )
		{
		return fFalse;
		}

	IMAGEHLP_SYMBOL* pis;
	do	{
		DWORD_PTR	dwT;
		DWORD_PTR*	pdwDisp	= pdwOffset ? pdwOffset : &dwT;

		pis							= (IMAGEHLP_SYMBOL*)rgbBuf;
		pis->SizeOfStruct			= sizeof( IMAGEHLP_SYMBOL );
		pis->MaxNameLength			= DWORD( cbBuf - sizeof( IMAGEHLP_SYMBOL ) );

		DWORD	symoptOld	= pfnSymSetOptions( symopt );
		BOOL	fSuccess	= pfnSymGetSymFromAddr( ghDbgProcess, DWORD_PTR( pt ), pdwDisp, pis );
		DWORD	symoptNew	= pfnSymSetOptions( symoptOld );

		if ( !fSuccess )
			{
			LocalFree( (void*)rgbBuf );
			return fFalse;
			}

		if ( strlen( pis->Name ) == cbBuf - 1 )
			{
			LocalFree( (void*)rgbBuf );
			cbBuf *= 2;
			if ( !( rgbBuf = (BYTE*)LocalAlloc( 0, cbBuf ) ) )
				{
				return fFalse;
				}
			}
		}
	while ( strlen( pis->Name ) == cbBuf - 1 );

	//  undecorate the symbol (if possible).  if not, use the decorated symbol

	char* szSymbol = (char*)LocalAlloc( 0, cchMax );
	if ( !szSymbol )
		{
		LocalFree( (void*)rgbBuf );
		return fFalse;
		}

	if ( !pfnUnDecorateSymbolName( pis->Name, szSymbol, DWORD( cchMax ), UNDNAME_COMPLETE ) )
		{
		strncpy( szSymbol, pis->Name, size_t( cchMax ) );
		szGlobal[ cchMax - 1 ] = 0;
		}

	//  write the module!symbol into the user's buffer

	_snprintf( szGlobal, size_t( cchMax ), "%s!%s", im.ModuleName, szSymbol );

	LocalFree( (void*)szSymbol );
	LocalFree( (void*)rgbBuf );
	return fTrue;
	}

//  ================================================================
template< class T >
INLINE BOOL FReadVariable( T* const rgtDebuggee, T* const rgt, const SIZE_T ct = 1 )
//  ================================================================
	{
	return ExtensionApis.lpReadProcessMemoryRoutine(
				(ULONG_PTR)rgtDebuggee,
				(VOID *)rgt,
				DWORD( sizeof( T ) * ct ),
				NULL );
	}

//  ================================================================
template< class T >
LOCAL BOOL FFetchVariable( T* const rgtDebuggee, T** const prgt, SIZE_T ct = 1 )
//  ================================================================
	{
	//  allocate enough storage to retrieve the requested type array

	if ( !( *prgt = (T*)LocalAlloc( 0, sizeof( T ) * ct ) ) )
		{
		return fFalse;
		}

	//  retrieve the requested type array

	if ( !FReadVariable( rgtDebuggee, *prgt, ct ) )
		{
		LocalFree( (VOID *)*prgt );
		return fFalse;
		}

	return fTrue;
	}

//  ================================================================
template< class T >
LOCAL BOOL FReadGlobal( const CHAR * const szGlobal, T* const rgt, const SIZE_T ct = 1 )
//  ================================================================
	{
	//  get the address of the global in the debuggee and fetch it

	T*	rgtDebuggee;

	if ( FAddressFromGlobal( szGlobal, &rgtDebuggee )
		&& FReadVariable( rgtDebuggee, rgt, ct ) )
		{
		return fTrue;
		}
	else
		{
		dprintf( "Error: Could not read global variable '%s'.\n", szGlobal );
		return fFalse;
		}
	}

//  ================================================================
template< class T >
LOCAL BOOL FReadGlobalAndFetchVariable( const CHAR * const szGlobal, T** const prgt, const SIZE_T ct = 1 )
//  ================================================================
	{
	//  get the address of the global in the debuggee and fetch its contents

	T*	rgtDebuggee;

	if ( FReadGlobal( szGlobal, &rgtDebuggee ) )
		{
		if ( FFetchVariable( rgtDebuggee, prgt, ct ) )
			return fTrue;
		else
			dprintf( "Error: Could not fetch global variable '%s'.\n", szGlobal );
		}

	return fFalse;
	}

//  ================================================================
template< class T >
LOCAL BOOL FFetchGlobal( const CHAR * const szGlobal, T** const prgt, SIZE_T ct = 1 )
//  ================================================================
	{
	//  get the address of the global in the debuggee and fetch it

	T*	rgtDebuggee;

	if ( FAddressFromGlobal( szGlobal, &rgtDebuggee )
		&& FFetchVariable( rgtDebuggee, prgt, ct ) )
		{
		return fTrue;
		}
	else
		{
		dprintf( "Error: Could not fetch global variable '%s'.\n", szGlobal );
		return fFalse;
		}
	}

//  ================================================================
template< class T >
LOCAL BOOL FFetchSz( T* const szDebuggee, T** const psz )
//  ================================================================
	{
	//  scan for the null terminator in the debuggee starting at the given
	//  address to get the size of the string

	const SIZE_T	ctScan				= 256;
	const SIZE_T	cbScan				= ctScan * sizeof( T );
	BYTE			rgbScan[ cbScan ];
	T*				rgtScan				= (T*)rgbScan;  //  because T can be const
	SIZE_T			itScan				= -1;
	SIZE_T			itScanLim			= 0;

	do	{
		if ( !( ++itScan % ctScan ) )
			{
			ULONG	cbRead;
			ExtensionApis.lpReadProcessMemoryRoutine(
								ULONG_PTR( szDebuggee + itScan ),
								(void*)rgbScan,
								cbScan,
								&cbRead );

			itScanLim = itScan + cbRead / sizeof( T );
			}
		}
	while ( itScan < itScanLim && rgtScan[ itScan % ctScan ] );

	//  we found a null terminator

	if ( itScan < itScanLim )
		{
		//  fetch the string using the determined string length

		return FFetchVariable( szDebuggee, psz, itScan + 1 );
		}

	//  we did not find a null terminator

	else
		{
		//  fail the operation

		return fFalse;
		}
	}

//  ================================================================
template< class T >
LOCAL void Unfetch( T* const rgt )
//  ================================================================
	{
	LocalFree( (void*)rgt );
	}

template <class T>
class FetchWrap
	{
	private:
		T m_t;
		FetchWrap &operator=( FetchWrap const & ); // forbidden

	public:
		FetchWrap() { m_t = NULL; }
		~FetchWrap() { Unfetch(); }
		BOOL FVariable( T const rgtDebuggee, SIZE_T ct = 1 ) { Unfetch(); return FFetchVariable( rgtDebuggee, &m_t, ct ); }
		BOOL FGlobal( const char * const szGlobal, SIZE_T ct = 1 ) { Unfetch(); return FFetchGlobal( szGlobal, &m_t, ct ); }
		BOOL FSz( T const szDebuggee ) { Unfetch(); return FFetchSz( szDebuggee, &m_t ); }
		VOID Unfetch() { OSSYM::Unfetch( m_t ); }
		T Release() { T t = m_t; m_t = NULL; return t; }	//		dereference the pointer, so the user will take care to Unfetch

		operator T() { return m_t; }
		T operator->() { return m_t; }
	};

}  //  namespace OSSYM


#define FCall( x, szError ) { if ( !x ) { dprintf szError; goto HandleError; } }
#define FCallR( x, szError ) { if ( !x ) { dprintf szError; return; } }

using namespace OSSYM;


//  ================================================================
BOOL FDuplicateHandle( const HANDLE hSourceProcess, const HANDLE hSource, HANDLE * const phDest )
//  ================================================================
	{
	const HANDLE hDestinationProcess	= GetCurrentProcess();
	const DWORD dwDesiredAccess			= GENERIC_READ;
	const BOOL bInheritHandle			= FALSE;
	const DWORD dwOptions				= 0;

	const BOOL fSuccess = DuplicateHandle(
			hSourceProcess,
			hSource,
			hDestinationProcess,
			phDest,
			dwDesiredAccess,
			bInheritHandle,
			dwOptions );

	if( !fSuccess )
		{
		dprintf( "DuplicateHandle failed with error %d\n", GetLastError() );
		}
	return fSuccess;
	}


//  ================================================================
const CHAR * SzEDBGHexDump( const VOID * const pv, const INT cb )
//  ================================================================
//
//	WARNING: not multi-threaded safe
//
	{
	static CHAR rgchBuf[1024];
	rgchBuf[0] = '\n';
	rgchBuf[1] = '\0';

	if( NULL == pv )
		{
		return rgchBuf;
		}

	DBUTLSprintHex(
		rgchBuf,
		(BYTE *)pv,
		cb,
		cb + 1,
		4,
		0,
		0 );

	return rgchBuf;
	}


//  ================================================================
DEBUG_EXT( EDBGVersion )
//  ================================================================
	{
	dprintf(	"%s version %d.%02d.%04d.%04d (%s)\n",
				SzUtilImageVersionName(),
				DwUtilImageVersionMajor(),
				DwUtilImageVersionMinor(),
				DwUtilImageBuildNumberMajor(),
				DwUtilImageBuildNumberMinor(),
				SzUtilImageBuildClass() );
	dprintf(	"\tDAE version		= 0x%x.%x\n",
				ulDAEVersion,
				ulDAEUpdate );
	dprintf(	"\tLog version		= %d.%04d.%02d\n",
				ulLGVersionMajor,
				ulLGVersionMinor,
				ulLGVersionUpdate );
	dprintf(	"\t     cbPage		= 0x%x, %d\n",
				g_cbPage,
				g_cbPage );

#ifdef MEM_CHECK
	if ( g_fMemCheck )
		{
		dprintf(	"\tMemory allocation tracking is Enabled\n" );
		}
	else
		{
		dprintf(	"\tMemory allocation tracking is Disabled\n" );
		}
#endif	//	MEM_CHECK
	}


//  ================================================================
DEBUG_EXT( EDBGDebug )
//  ================================================================
	{
	if( fDebugMode )
		{
		dprintf( "changing to non-debug mode\n" );
		fDebugMode = fFalse;
		}
	else
		{
		dprintf( "changing to debug mode\n" );
		fDebugMode = fTrue;
		}
	}


//  ================================================================
DEBUG_EXT( EDBGTest )
//  ================================================================
	{
	dprintf( "================================================================\n" );
	dprintf( "fDebugMode = %d\n", fDebugMode );
	dprintf( "fInit = %d\n", fInit );
	dprintf( "ExtensionApis.nSize = %d\n", ExtensionApis.nSize );
	dprintf( "\n" );

	dprintf( "sizeof PIB = %d (0x%04x)\n", sizeof(PIB), sizeof(PIB) );
	dprintf( "sizeof FCB = %d (0x%04x)\n", sizeof(FCB), sizeof(FCB) );
	dprintf( "sizeof TDB = %d (0x%04x)\n", sizeof(TDB), sizeof(TDB) );
	dprintf( "sizeof IDB = %d (0x%04x)\n", sizeof(IDB), sizeof(IDB) );
	dprintf( "sizeof SCB = %d (0x%04x)\n", sizeof(SCB), sizeof(SCB) );
	dprintf( "sizeof RCE = %d (0x%04x)\n", sizeof(RCE), sizeof(RCE) );
	dprintf( "sizeof VER = %d (0x%04x)\n", sizeof(VER), sizeof(VER) );
	dprintf( "sizeof LOG = %d (0x%04x)\n", sizeof(LOG), sizeof(LOG) );
	dprintf( "sizeof FMP = %d (0x%04x)\n", sizeof(FMP), sizeof(FMP) );
	dprintf( "sizeof CSR = %d (0x%04x)\n", sizeof(CSR), sizeof(CSR) );
	dprintf( "sizeof FUCB = %d (0x%04x)\n", sizeof(FUCB), sizeof(FUCB) );
	dprintf( "sizeof INST = %d (0x%04x)\n", sizeof(INST), sizeof(INST) );
	dprintf( "\n" );

	LONG 	cbPage;
	if ( FReadGlobal( "g_cbPage", &cbPage ) )
		{
		dprintf( "g_cbPage = %d\n", cbPage );
		}
	else
		{
		dprintf( "g_cbPage = [Error: cannot determine the page size of debuggee.]\n" );
		}
	dprintf( "\n" );

	if( NULL != rgEDBGGlobalsDebugger )
		{
		dprintf( "Globals table has been loaded internally.\n" );
		}
	else
		{
		dprintf( "Globals table has NOT been loaded internally.\n" );
		}
	dprintf( "\n" );

	if( NULL != hLibrary )
		{
		dprintf( "Library has been loaded internally.\n" );
		}
	else
		{
		dprintf( "Library has NOT been loaded internally.\n" );
		}
	dprintf( "\n" );

	if ( argc >= 1 )
		{
		void* pv;
		if ( FAddressFromGlobal( argv[ 0 ], &pv ) )
			{
			dprintf( "The address of %s is 0x%p.\n", argv[0], pv );
			}
		else
			{
			dprintf( "Could not find the symbol.\n" );
			}
		}
	if ( argc >= 2 )
		{
		void* pv;
		if ( FAddressFromSz( argv[ 1 ], &pv ) )
			{
			char		szGlobal[ 1024 ];
			DWORD_PTR	dwOffset;
			if ( FGlobalFromAddress( pv, szGlobal, sizeof( szGlobal ), &dwOffset ) )
				{
				dprintf(	"The symbol closest to 0x%p is %s+0x%I64X.\n",
							pv,
							szGlobal,
							QWORD( dwOffset ) );
				}
			else
				{
				dprintf( "Could not map this address to a symbol.\n" );
				}
			}
		else
			{
			dprintf( "That is not a valid address.\n" );
			}
		}

	dprintf( "================================================================\n" );
	dprintf( "\n" );
	}


LOCAL VOID EDBGUnloadGlobals()
	{
	if ( NULL != rgEDBGGlobalsDebugger )
		{
		for ( SIZE_T i = 0; i < (SIZE_T)rgEDBGGlobalsDebugger[0].pvAddress; i++ )
			{
			Unfetch( rgEDBGGlobalsDebugger[i].szName );
			}
		Unfetch( rgEDBGGlobalsDebugger );
		rgEDBGGlobalsDebugger = NULL;
		}
	}

//  ================================================================
DEBUG_EXT( EDBGGlobals )
//  ================================================================
	{
	EDBGGLOBALVAR *		rgEDBGGlobalsDebuggee	= NULL;

	dprintf( "\n" );

	if ( argc > 1
		|| ( 1 == argc && !FAddressFromSz( argv[0], &rgEDBGGlobalsDebuggee ) )
		|| ( 0 == argc && NULL == rgEDBGGlobalsDebugger ) )
		{
		if ( NULL == rgEDBGGlobalsDebugger )
			dprintf( "Globals table not currently loaded.\n\n" );

		dprintf( "Usage: GLOBALS [<rgEDBGGlobals>]\n" );
		dprintf( "\n" );
		dprintf( "       Loads the debuggee's table of globals (for use when symbols are not present or inaccurate).\n" );
		dprintf( "       If <rgEDBGGlobals> is inaccessible, it may also be found in each INST as m_rgEDBGGlobals.\n" );
		dprintf( "       If <rgEDBGGlobals> is not specified, the current globals table is dumped.\n\n" );
		return;
		}

	if ( 1 == argc )
		{
		EDBGGLOBALVAR		globalvar;
		SIZE_T				cGlobals;
		CHAR *				szName					= NULL;

		//	free any previous copy of the globals table
		EDBGUnloadGlobals();

		if ( FReadVariable( rgEDBGGlobalsDebuggee, &globalvar )
			&& FReadVariable( (SIZE_T *)globalvar.pvAddress, &cGlobals )
			&& FFetchSz( (CHAR *)globalvar.szName, &szName )
			&& 0 == _stricmp( szName, "cEDBGGlobals" )
			&& FFetchVariable( rgEDBGGlobalsDebuggee, &rgEDBGGlobalsDebugger, cGlobals ) )
			{
			//	SPECIAL-CASE: for first entry, store count of globals
			rgEDBGGlobalsDebugger[0].szName = szName;
			rgEDBGGlobalsDebugger[0].pvAddress = (VOID *)cGlobals;

			for ( SIZE_T i = 1; i < cGlobals; i++ )
				{
				if ( !FFetchSz( (CHAR *)rgEDBGGlobalsDebugger[i].szName, &szName ) )
					{
					dprintf( "Error: Failed loading globals table.\n" );

					//	free only the entries we've already updated
					rgEDBGGlobalsDebugger[0].pvAddress = (VOID *)i;
					EDBGUnloadGlobals();
					break;
					}

				//	update the debugger's copy of the globals table entry
				//	to store its own copy of the variable name
				rgEDBGGlobalsDebugger[i].szName = szName;
				}

			if ( NULL != rgEDBGGlobalsDebugger )
				dprintf( "Successfully loaded Globals table from 0x%p\n", rgEDBGGlobalsDebuggee );
			}
		else
			{
			dprintf( "Error: Failed loading globals table.\n" );
			Unfetch( szName );
			}
		}

	else
		{
		dprintf( "Globals table: 0x%p\n", rgEDBGGlobalsDebugger );
		for ( SIZE_T i = 0; i < (SIZE_T)rgEDBGGlobalsDebugger[0].pvAddress; i++ )
			{
			dprintf( "    %-24s: 0x%p\n", rgEDBGGlobalsDebugger[i].szName, rgEDBGGlobalsDebugger[i].pvAddress );
			}
		}

	dprintf( "\n--------------------\n\n" );

	}


//  ================================================================
DEBUG_EXT( EDBGLoad )
//  ================================================================
	{
	hLibrary = LoadLibrary( SzUtilImagePath() );
	if( NULL == hLibrary )
		{
		dprintf( "Unable to load %s!\n", SzUtilImagePath() );
		}
	else
		{
		//	free any previous copy of the globals table
		EDBGUnloadGlobals();
		dprintf( "Library successfully loaded internally: %s\n", SzUtilImagePath() );
		}
	}


//  ================================================================
DEBUG_EXT( EDBGUnload )
//  ================================================================
	{
	if( NULL != hLibrary )
		{
		EDBGUnloadGlobals();
		FreeLibrary( hLibrary );
		}
	else
		{
		dprintf( "%s not loaded!", SzUtilImagePath() );
		}
	}


//  ================================================================
DEBUG_EXT( EDBGErr )
//  ================================================================
	{
	LONG lErr;
	if( 1 == argc
		&& FUlFromSz( argv[0], (ULONG *)&lErr ) )
		{
		const CHAR * szError;
		const CHAR * szErrorText;
		JetErrorToString( lErr, &szError, &szErrorText );
		dprintf( "0x%x, %d: %s (%s)\n", lErr, lErr, szError, szErrorText );
		}
	else
		{
		dprintf( "Usage: ERR <error>\n" );
		}
	}


//  ================================================================
DEBUG_EXT( EDBGHelp )
//  ================================================================
	{
	INT ifuncmap;
	for( ifuncmap = 0; ifuncmap < cfuncmap; ifuncmap++ )
		{
		dprintf( "\t%s\n", rgfuncmap[ifuncmap].szHelp );
		}
	dprintf( "\n--------------------\n\n" );
	}


//  ================================================================
DEBUG_EXT( EDBGFindRes )
//  ================================================================
	{
	CRES*	pcresDebuggee	= NULL;
	CRES*	pcres			= NULL;
	VOID**	rgpvDebuggee	= NULL;
	VOID**	rgpv			= NULL;
	DWORD	cpv;

	if (	argc != 3 ||
			!FAddressFromSz( argv[0], &pcresDebuggee ) ||
			!FAddressFromSz( argv[1], &rgpvDebuggee ) ||
			!FUlFromSz( argv[2], &cpv ) )
		{
		dprintf( "Usage: DUMP <cres> <address> <length>\n" );
		return;
		}

	if ( FFetchVariable( pcresDebuggee, &pcres )
		&& FFetchVariable( rgpvDebuggee, &rgpv, cpv ) )
		{
		dprintf(	"pbMin = 0x%p, pbMax = 0x%p, cbBlock = 0x%x\n",
					pcres->PbMin(),
					pcres->PbMax(),
					pcres->CbBlock() );

		for ( SIZE_T ipv = 0; ipv < cpv; ipv++ )
			{
			if (	(BYTE*)rgpv[ ipv ] >= pcres->PbMin() &&
					(BYTE*)rgpv[ ipv ] < pcres->PbMax() )
				{
				//  this is possibly a pointer to something in the CRES

				dprintf( "0x%p  0x%p ", rgpvDebuggee + ipv, rgpv[ipv] );

				void* pvAligned = (void*)( pcres->PbMin() + ( ( (BYTE*)rgpv[ ipv ] - pcres->PbMin() ) / pcres->CbBlock() ) * pcres->CbBlock() );
				if ( pvAligned == rgpv[ ipv ] )
					{
					dprintf( "(aligned)\n" );
					}
				else
					{
					dprintf( "(not-aligned, possibly 0x%p)\n", pvAligned );
					}
				}
			}
		}

	Unfetch( rgpv );
	Unfetch( pcres );
	}


namespace OSSYNC
	{
	VOID OSSYNCAPI OSSyncDebuggerExtension(
	    HANDLE hCurrentProcess,
	    HANDLE hCurrentThread,
	    DWORD dwCurrentPc,
	    PWINDBG_EXTENSION_APIS lpExtensionApis,
		const INT argc,
	    const CHAR * const argv[] );
	};


//  ================================================================
DEBUG_EXT( EDBGSync )
//  ================================================================
	{
	OSSyncDebuggerExtension(	hCurrentProcess,
								hCurrentThread,
								dwCurrentPc,
								lpExtensionApis,
								argc,
								argv );
	}


//  ================================================================
DEBUG_EXT( EDBGCacheFind )
//  ================================================================
	{
	ULONG		ifmp;
	ULONG		pgno;
	PBF			pbf					= pbfNil;
	BF **		rgpbfChunkDebuggee	= NULL;
	BF **		rgpbfChunkT			= NULL;
	ULONG		cbfChunkDebuggee;
	LONG_PTR	cbfChunkT;
	ULONG		cbfCacheDebuggee;
	LONG_PTR	cbfCacheT;
	BOOL		fValidUsage;

	switch ( argc )
		{
		case 2:
			fValidUsage = ( FUlFromSz( argv[0], &ifmp )
							&& FUlFromSz( argv[1], &pgno )
							&& pgno > 0 );
			break;

		case 5:
			fValidUsage = ( FUlFromSz( argv[0], &ifmp )
							&& FUlFromSz( argv[1], &pgno )
							&& pgno > 0
							&& FAddressFromSz( argv[2], &rgpbfChunkDebuggee )
							&& FUlFromSz( argv[3], &cbfChunkDebuggee )
							&& FUlFromSz( argv[4], &cbfCacheDebuggee ) );
			break;

		default:
			fValidUsage = fFalse;
			break;
		}

	dprintf( "\n" );

	if ( !fValidUsage )
		{
		dprintf( "Usage: CACHEFIND <ifmp> <pgno> [<rgpbfChunk> <cbfChunk> <cbfCache>]\n\n" );
		dprintf( "    <ifmp> is the index to the FMP entry for the desired database file\n" );
		dprintf( "    <pgno> is the desired page number from this FMP\n\n" );
		return;
		}

	if ( NULL == rgpbfChunkDebuggee )
		{
		if ( !FReadGlobal( "cbfChunk", &cbfChunkT )
			|| !FReadGlobal( "cbfCache", &cbfCacheT )
			|| !FReadGlobal( "rgpbfChunk", &rgpbfChunkDebuggee ) )
			{
			dprintf( "Error: Could not load BF parameters.\n\n" );
			return;
			}
		}
	else
		{
		cbfChunkT = cbfChunkDebuggee;
		cbfCacheT = cbfCacheDebuggee;
		}

	if ( !FFetchVariable( rgpbfChunkDebuggee, &rgpbfChunkT, cCacheChunkMax ) )
		{
		dprintf( "Error: Could not load BF parameters.\n\n" );
		return;
		}

	pbf = (PBF)LocalAlloc( 0, sizeof(BF) );
	if ( NULL == pbf )
		{
		dprintf( "Error: Could not allocate BF buffer.\n" );
		Unfetch( rgpbfChunkT );
		return;
		}

	//  scan all valid BFs looking for this IFMP / PGNO

	BOOL fFoundBF = fFalse;
	for ( LONG_PTR ibf = 0; ibf < cbfCacheT; ibf++ )
		{
		//  compute the address of the target BF

		PBF pbfDebuggee = rgpbfChunkT[ ibf / cbfChunkT ] + ibf % cbfChunkT;

		//  we failed to read this BF

		if ( !FReadVariable( pbfDebuggee, pbf ) )
			{
			dprintf( "Error: Could not read BF at 0x%p. Aborting\n", pbfDebuggee );
			fFoundBF = fTrue;
			break;
			}

		//  this BF contains this IFMP / PGNO

		if (	pbf->ifmp == IFMP( ifmp ) &&
				pbf->pgno == PGNO( pgno ) &&
				( pbf->fCurrentVersion || pbf->fOlderVersion ) )
			{
			dprintf(	"%X:%08X is cached in BF 0x%p (CurrentVersion==%s, pv==0x%p).\n",
						ifmp,
						pgno,
						pbfDebuggee,
						pbf->fCurrentVersion ? "TRUE" : "FALSE",
						pbf->pv );
			fFoundBF = fTrue;
			}
		}

	//  we did not find the IFMP / PGNO

	if ( fFoundBF )
		{
		dprintf( "\n" );
		}
	else
		{
		dprintf( "%X:%08X is not cached.\n\n", ifmp, pgno );
		}

	//  unload BF parameters

	LocalFree( pbf );
	Unfetch( rgpbfChunkT );
	}

//  ================================================================
DEBUG_EXT( EDBGCacheFindOldest )
//  ================================================================
	{
	ULONG		ifmp;
	ULONG		lgen				= 0;
	PBF			pbf					= pbfNil;
	BF **		rgpbfChunkDebuggee	= NULL;
	BF **		rgpbfChunkT			= NULL;
	ULONG		cbfChunkDebuggee;
	LONG_PTR	cbfChunkT;
	ULONG		cbfCacheDebuggee;
	LONG_PTR	cbfCacheT;
	BOOL		fValidUsage;
	PBF			pbfOldestBegin0		= pbfNil;
	LGPOS		lgposOldestBegin0	= lgposMax;
	BOOL		fFoundTargetGen		= fFalse;

	switch ( argc )
		{
		case 1:
			fValidUsage = ( FUlFromSz( argv[0], &ifmp ) );
			break;

		case 2:
			fValidUsage = ( FUlFromSz( argv[0], &ifmp )
							&& FUlFromSz( argv[1], &lgen )
							&& lgen > 0 );
			break;

		case 4:
			fValidUsage = ( FUlFromSz( argv[0], &ifmp )
							&& FAddressFromSz( argv[2], &rgpbfChunkDebuggee )
							&& FUlFromSz( argv[3], &cbfChunkDebuggee )
							&& FUlFromSz( argv[4], &cbfCacheDebuggee ) );
			break;

		case 5:
			fValidUsage = ( FUlFromSz( argv[0], &ifmp )
							&& FUlFromSz( argv[1], &lgen )
							&& lgen > 0
							&& FAddressFromSz( argv[2], &rgpbfChunkDebuggee )
							&& FUlFromSz( argv[3], &cbfChunkDebuggee )
							&& FUlFromSz( argv[4], &cbfCacheDebuggee ) );
			break;

		default:
			fValidUsage = fFalse;
			break;
		}

	dprintf( "\n" );

	if ( !fValidUsage )
		{
		dprintf( "Usage: CACHEFINDOLDEST <ifmp> [<gen>] [<rgpbfChunk> <cbfChunk> <cbfCache>]\n" );
		dprintf( "\n" );
		dprintf( "    <ifmp> - index to the FMP entry for the desired database file\n" );
		dprintf( "    <gen>  - find all BF's with lgposBegin0 less than or equal to\n" );
		dprintf( "             specified log generation\n" );
		return;
		}

	if ( NULL == rgpbfChunkDebuggee )
		{
		if ( !FReadGlobal( "cbfChunk", &cbfChunkT )
			|| !FReadGlobal( "cbfCache", &cbfCacheT )
			|| !FReadGlobal( "rgpbfChunk", &rgpbfChunkDebuggee ) )
			{
			dprintf( "Error: Could not load BF parameters.\n" );
			return;
			}
		}
	else
		{
		cbfChunkT = cbfChunkDebuggee;
		cbfCacheT = cbfCacheDebuggee;
		}

	if ( !FFetchVariable( rgpbfChunkDebuggee, &rgpbfChunkT, cCacheChunkMax ) )
		{
		dprintf( "Error: Could not load BF parameters.\n" );
		return;
		}

	pbf = (PBF)LocalAlloc( 0, sizeof(BF) );
	if ( NULL == pbf )
		{
		dprintf( "Error: Could not allocate BF buffer.\n" );
		goto HandleError;
		}

	//  scan all valid BFs looking for the oldest lgposBegin0 of this IFMP

	if ( lgen > 0 )
		{
		dprintf(
			"Scanning all BF's for ifmp 0x%x with lgposBegin0 less than or equal to generation %d (0x%x):\n",
			ifmp,
			lgen,
			lgen );
		}
	else
		{
		dprintf( "Scanning all BF's...\n" );
		}

	for ( LONG_PTR ibf = 0; ibf < cbfCacheT; ibf++ )
		{
		//  compute the address of the target BF

		PBF pbfDebuggee = rgpbfChunkT[ ibf / cbfChunkT ] + ibf % cbfChunkT;

		//  we failed to read this BF

		if ( !FReadVariable( pbfDebuggee, pbf ) )
			{
			dprintf( "Error: Could not read BF at 0x%p. Aborting.\n", pbfDebuggee );
			goto HandleError;
			}

		//  compare lgposBegin0 of this IFMP / PGNO

		if ( pbf->ifmp == IFMP( ifmp )
			&& ( pbf->fCurrentVersion || pbf->fOlderVersion ) )
			{
			if ( lgen > 0 )
				{
				if ( pbf->lgposOldestBegin0.lGeneration <= lgen )
					{
					dprintf(
						"    BF 0x%p: gen %d (0x%x)\n",
						pbfDebuggee,
						pbf->lgposOldestBegin0.lGeneration,
						pbf->lgposOldestBegin0.lGeneration );
					fFoundTargetGen = fTrue;
					}
				}

			if ( CmpLgpos( &pbf->lgposOldestBegin0, &lgposOldestBegin0 ) < 0 )
				{
				lgposOldestBegin0 = pbf->lgposOldestBegin0;
				pbfOldestBegin0 = pbfDebuggee;
 				}
			}
		}

	//	report BF with oldest Begin0

	if ( lgen > 0 && !fFoundTargetGen )
		{
		//	didn't find any BF for this ifmp
		//
		dprintf( "    <none>\n" );
		}

	if ( pbfNil != pbfOldestBegin0 )
		{
		dprintf(
			"Oldest lgposBegin0 (generation 0x%x) for ifmp 0x%x is cached in BF 0x%p.\n",
			lgposOldestBegin0.lGeneration,
			ifmp,
			pbfOldestBegin0 );
		}
	else
		{
		dprintf( "No pages cached for ifmp 0x%x.\n", ifmp );
		}

	//  unload BF parameters
HandleError:
	dprintf( "\n" );

	LocalFree( pbf );
	Unfetch( rgpbfChunkT );
	}


//  ================================================================
LOCAL BOOL FEDBGFetchTableMetaData(
	FCB * const	pfcbTableDebuggee,
	FCB **		ppfcbTable )
//  ================================================================
	{
	FCB *		pfcbTable				= pfcbNil;
	TDB *		ptdb					= ptdbNil;
	FCB *		pfcbTemplate			= pfcbNil;
	TDB *		ptdbTemplate			= ptdbNil;
	FCB *		pfcbBuffer				= pfcbNil;
	ULONG		cFieldsInitial			= 0;
	ULONG		cTemplateFieldsInitial	= 0;
	ULONG		cbAlloc					= sizeof(FCB) + sizeof(TDB);
	BOOL		fResult 				= fTrue;

	if ( !FFetchVariable( pfcbTableDebuggee, &pfcbTable ) )
		{
		dprintf( "Error: Could not fetch FCB at 0x%p.\n", pfcbTableDebuggee );
		fResult = fFalse;
		goto HandleError;
		}

	if ( !pfcbTable->FTypeTable() )
		{
		//	not actually a table FCB, so just return the FCB
		//
		*ppfcbTable = pfcbTable;
		return fTrue;
		}

	if ( !FFetchVariable( pfcbTable->Ptdb(), &ptdb ) )
		{
		dprintf( "Error: Could not fetch TDB at 0x%p.\n", pfcbTable->Ptdb() );
		fResult = fFalse;
		goto HandleError;
		}

	//	adjust buffer by size of MEMPOOL buffer
	//
	cbAlloc += ptdb->MemPool().CbBufSize();

	//	adjust buffer for initial fields
	//

	cFieldsInitial = ( ptdb->FidFixedLastInitial() + 1 - ptdb->FidFixedFirst() );
	cFieldsInitial += ( ptdb->FidVarLastInitial() + 1 - ptdb->FidVarFirst() );
	cFieldsInitial += ( ptdb->FidTaggedLastInitial() + 1 - ptdb->FidTaggedFirst() );
	cbAlloc += ( cFieldsInitial * sizeof(FIELD) );

	if ( pfcbNil != ptdb->PfcbTemplateTable() )
		{
		if ( !FFetchVariable( ptdb->PfcbTemplateTable(), &pfcbTemplate ) )
			{
			dprintf( "Error: Could not fetch FCB at 0x%p.\n", ptdb->PfcbTemplateTable() );
			fResult = fFalse;
			goto HandleError;
			}

		if ( !FFetchVariable( pfcbTemplate->Ptdb(), &ptdbTemplate ) )
			{
			dprintf( "Error: Could not fetch TDB at 0x%p.\n", pfcbTemplate->Ptdb() );
			fResult = fFalse;
			goto HandleError;
			}

		//	adjust buffer by size of template table FCB, TDB, and MEMPOOL buffer
		//
		cbAlloc += sizeof(FCB) + sizeof(TDB) + ptdbTemplate->MemPool().CbBufSize();

		//	adjust buffer for initial fields
		//
		cTemplateFieldsInitial = ( ptdbTemplate->FidFixedLastInitial() + 1 - ptdbTemplate->FidFixedFirst() );
		cTemplateFieldsInitial += ( ptdbTemplate->FidVarLastInitial() + 1 - ptdbTemplate->FidVarFirst() );
		cTemplateFieldsInitial += ( ptdbTemplate->FidTaggedLastInitial() + 1 - ptdbTemplate->FidTaggedFirst() );
		cbAlloc += ( cTemplateFieldsInitial * sizeof(FIELD) );
		}

	//	now allocate one big buffer for the table (and template table) FCB, TDB, and MEMPOOL buffer
	//
	pfcbBuffer = (FCB *)LocalAlloc( 0, cbAlloc );
	if ( NULL == pfcbBuffer )
		{
		dprintf( "Error: Could not allocate %d-byte buffer for meta-data.\n", cbAlloc );
		fResult = fFalse;
		goto HandleError;
		}

	//	copy everything to final buffer
	//
	memcpy( pfcbBuffer, pfcbTable, sizeof(FCB) );

	//	TDB allocated after the FCB
	//
	pfcbBuffer->SetPtdb( (TDB *)( pfcbBuffer + 1 ) );
	memcpy( pfcbBuffer->Ptdb(), ptdb, sizeof(TDB) );

	//	MEMPOOL buffer allocated after the TDB
	//
	pfcbBuffer->Ptdb()->MemPool().SetPbuf( (BYTE *)( pfcbBuffer->Ptdb() + 1 ) );
	if ( !FReadVariable( ptdb->MemPool().Pbuf(), pfcbBuffer->Ptdb()->MemPool().Pbuf(), ptdb->MemPool().CbBufSize() ) )
		{
		dprintf(
			"Error: Could not read %d-byte MEMPOOL buffer at 0x%p.\n",
			ptdb->MemPool().CbBufSize(),
			ptdb->MemPool().Pbuf() );
		fResult = fFalse;
		goto HandleError;
		}

	//	buffer for initial fields allocated after MEMPOOL
	//
	pfcbBuffer->Ptdb()->SetPfieldInitial( (FIELD *)( pfcbBuffer->Ptdb()->MemPool().Pbuf() + pfcbBuffer->Ptdb()->MemPool().CbBufSize() ) );
	if ( !FReadVariable( ptdb->PfieldsInitial(), pfcbBuffer->Ptdb()->PfieldsInitial(), cFieldsInitial ) )
		{
		dprintf(
			"Error: Could not read %d-byte FIELD buffer at 0x%p.\n",
			cFieldsInitial * sizeof(FIELD),
			ptdb->PfieldsInitial() );
		fResult = fFalse;
		goto HandleError;
		}

	if ( pfcbNil != pfcbTemplate )
		{
		//	template table follows derived table
		//
		FCB *	pfcbT	= (FCB *)( pfcbBuffer->Ptdb()->PfieldsInitial() + cFieldsInitial );

		pfcbBuffer->Ptdb()->SetPfcbTemplateTable( pfcbT );
		memcpy( pfcbT, pfcbTemplate, sizeof(FCB) );

		pfcbT->SetPtdb( (TDB *)( pfcbT + 1 ) );
		memcpy( pfcbT->Ptdb(), ptdbTemplate, sizeof(TDB) );

		pfcbT->Ptdb()->MemPool().SetPbuf( (BYTE *)( pfcbT->Ptdb() + 1 ) );
		if ( !FReadVariable( ptdbTemplate->MemPool().Pbuf(), pfcbT->Ptdb()->MemPool().Pbuf(), ptdbTemplate->MemPool().CbBufSize() ) )
			{
			dprintf(
				"Error: Could not read %d-byte MEMPOOL buffer at 0x%p.\n",
				ptdbTemplate->MemPool().CbBufSize(),
				ptdbTemplate->MemPool().Pbuf() );
			fResult = fFalse;
			goto HandleError;
			}

		pfcbT->Ptdb()->SetPfieldInitial( (FIELD *)( pfcbT->Ptdb()->MemPool().Pbuf() + pfcbT->Ptdb()->MemPool().CbBufSize() ) );
		if ( !FReadVariable( ptdbTemplate->PfieldsInitial(), pfcbT->Ptdb()->PfieldsInitial(), cTemplateFieldsInitial ) )
			{
			dprintf(
				"Error: Could not read %d-byte FIELD buffer at 0x%p.\n",
				cTemplateFieldsInitial * sizeof(FIELD),
				ptdbTemplate->PfieldsInitial() );
			fResult = fFalse;
			goto HandleError;
			}
		}

	//	return the buffer
	//
	*ppfcbTable = pfcbBuffer;

	//	since we're returning the buffer, ensure it doesn't get freed
	//
	pfcbBuffer = pfcbNil;


HandleError:
	LocalFree( pfcbBuffer );
	Unfetch( ptdbTemplate );
	Unfetch( pfcbTemplate );
	Unfetch( ptdb );
	Unfetch( pfcbTable );

	return fResult;
	}

//  ================================================================
LOCAL VOID EDBGDumpIndexMetaData(
	const FCB * const	pfcbIndex,
	const FCB * const	pfcbTable,
	const FCB * const	pfcbIndexDebuggee )
//  ================================================================
	{
	const TDB * const	ptdb		= pfcbTable->Ptdb();
	IDB *				pidb		= pidbNil;
	const IDXSEG *		rgidxseg;

	if ( !FFetchVariable( pfcbIndex->Pidb(), &pidb ) )
		{
		dprintf( "Error: Could not fetch IDB at 0x%p.\n", pfcbIndex->Pidb() );
		goto HandleError;
		}

	dprintf( "Index: \"%s\"", ptdb->SzIndexName( pidb->ItagIndexName(), pfcbIndex->FDerivedIndex() ) );

	if ( pfcbIndex->FDerivedIndex() )
		dprintf( " (derived)" );

	dprintf( "\n" );		
	dprintf( "    pfcb=0x%p\n", pfcbIndexDebuggee );
	dprintf( "    pidb=0x%p\n", pfcbIndex->Pidb() );
	dprintf( "    ifmp=0x%x\n", pfcbIndex->Ifmp() );
	dprintf( "    objidFDP=0x%x\n", pfcbIndex->ObjidFDP() );
	dprintf( "    pgnoFDP=0x%x\n", pfcbIndex->PgnoFDP() );
	dprintf( "    flags=0x%04x\n", pidb->FPersistedFlags() );

	dprintf( "    key segments (%d):\n", pidb->Cidxseg() );
	rgidxseg = PidxsegIDBGetIdxSeg( pidb, ptdb );
	for ( ULONG i = 0; i < pidb->Cidxseg(); i++ )
		{
		const BOOL			fDerived	= ( rgidxseg[i].FTemplateColumn() && !ptdb->FTemplateTable() );
		const FIELD * const	pfield		= ptdb->Pfield( rgidxseg[i].Columnid() );
		dprintf(
			"        %c%s (0x%08x)\n",
			( rgidxseg[i].FDescending() ? '-' : '+' ),
			ptdb->SzFieldName( pfield->itagFieldName, fDerived ),
			rgidxseg[i].Columnid() );
		}

	if ( pidb->CidxsegConditional() > 0 )
		{
		dprintf( "    conditional columns (%d):\n", pidb->CidxsegConditional() );
		rgidxseg = PidxsegIDBGetIdxSegConditional( pidb, ptdb );
		for ( ULONG i = 0; i < pidb->CidxsegConditional(); i++ )
			{
			const BOOL			fDerived	= ( rgidxseg[i].FTemplateColumn() && !ptdb->FTemplateTable() );
			const FIELD * const	pfield		= ptdb->Pfield( rgidxseg[i].Columnid() );
			dprintf(
				"        %s (0x%08x, %s)\n",
				ptdb->SzFieldName( pfield->itagFieldName, fDerived ),
				rgidxseg[i].Columnid(),
				( rgidxseg[i].FMustBeNull() ? "MustBeNull" : "MustBeNonNull" ) );
			}
		}

	dprintf( "\n" );

HandleError:
	Unfetch( pidb );
	}

//  ================================================================
const INLINE CHAR * SzColumnType( const JET_COLTYP coltyp )
//  ================================================================
	{
	CHAR * szType;

	switch ( coltyp )
		{
		case JET_coltypBit:
			szType = "Bit";
			break;
			
		case JET_coltypUnsignedByte:
			szType = "UnsignedByte";
			break;

		case JET_coltypShort:
			szType = "Short";
			break;

		case JET_coltypLong:
			szType = "Long";
			break;
			
		case JET_coltypCurrency:
			szType = "Currency";
			break;

		case JET_coltypIEEESingle:
			szType = "IEEESingle";
			break;
			
		case JET_coltypIEEEDouble:
			szType = "IEEEDouble";
			break;
			
		case JET_coltypDateTime:
			szType = "DateTime";
			break;
			
		case JET_coltypBinary:
			szType = "Binary";
			break;

		case JET_coltypText:
			szType = "Text";
			break;

		case JET_coltypLongBinary:
			szType = "LongBinary";
			break;

		case JET_coltypLongText:
			szType = "LongText";
			break;

		case JET_coltypSLV:
			szType = "SLV";
			break;

		case JET_coltypNil:
			szType = "<deleted>";
			break;
			
		default:
			szType = "<unknown>";
			break;
		}

	return szType;
	}

//  ================================================================
LOCAL VOID EDBGDumpColumnMetaData(
	const TDB * const		ptdb,
	const COLUMNID			columnid )
//  ================================================================
	{
	const FIELD * const		pfield		= ptdb->Pfield( columnid );
	const BOOL				fDeleted	= ( 0 == pfield->itagFieldName );
	const CHAR * const		szType		= ( fDeleted ? "<deleted>" : SzColumnType( pfield->coltyp ) );

	dprintf( "    0x%04x - ", FidOfColumnid( columnid ) );

	if ( fDeleted )
		{
		dprintf( "<deleted>" );
		}
	else
		{
		dprintf( "\"%s\"", ptdb->SzFieldName( pfield->itagFieldName, fFalse ) );
		}

	dprintf(
		"  [%s%s, ",
		szType,
		( FRECTextColumn( pfield->coltyp ) && usUniCodePage == pfield->cp ? " (Unicode)" : "" ) );

	if ( FFixedFid( FidOfColumnid( columnid ) ) )
		{
		dprintf( "offset=0x%04x, ", pfield->ibRecordOffset );
		}

	dprintf( "flags=0x%04x]\n", pfield->ffield );
	}

//  ================================================================
LOCAL VOID EDBGDumpTableMetaData(
	FCB * const			pfcbDebuggee,
	const TDB * const	ptdbDebuggee )
//  ================================================================
	{
	FCB *				pfcbTable	= pfcbNil;
	FCB *				pfcbIndex	= pfcbNil;

 	if ( FEDBGFetchTableMetaData( pfcbDebuggee, &pfcbTable ) )
		{
		const TDB * const	ptdb	= pfcbTable->Ptdb();

 		dprintf( "Table: \"%s\"", ptdb->SzTableName() );

		if ( pfcbTable->FDerivedTable() )
			dprintf( " (derived)" );

		dprintf( "\n" );		
		dprintf( "    pfcb=0x%p\n", pfcbDebuggee );
		dprintf( "    ptdb=0x%p\n", ptdbDebuggee );
		dprintf( "    ifmp=0x%x\n", pfcbTable->Ifmp() );
		dprintf( "    objidFDP=0x%x\n", pfcbTable->ObjidFDP() );
		dprintf( "    pgnoFDP=0x%x\n", pfcbTable->PgnoFDP() );
		dprintf( "    pfcbLV=0x%p\n", ptdb->PfcbLV() );
		dprintf( "\n" );

		//	if primary index exists, dump it
		//
		if ( pidbNil != pfcbTable->Pidb() )
			{
			EDBGDumpIndexMetaData( pfcbTable, pfcbTable, pfcbDebuggee ); 
			}

		pfcbIndex = (FCB *)LocalAlloc( 0, sizeof(FCB) );
		if ( pfcbNil == pfcbIndex )
			{
			dprintf( "Error: Could not allocate FCB buffer.\n" );
			goto HandleError;
			}

		//	dump secondary indexes
		//
		for ( FCB * pfcbT = pfcbTable->PfcbNextIndex();
			pfcbNil != pfcbT;
			pfcbT = pfcbIndex->PfcbNextIndex() )
			{
			if ( !FReadVariable( pfcbT, pfcbIndex ) )
				{
				dprintf( "Error: Could not read FCB at 0x%p.\n", pfcbT );
				goto HandleError;
				}
		
			EDBGDumpIndexMetaData( pfcbIndex, pfcbTable, pfcbT );
			}

		//	dump columns
		//
		dprintf( "Columns:\n" );

		for ( FID fid = ptdb->FidFixedFirst(); fid <= ptdb->FidFixedLast(); fid++ )
			{
			EDBGDumpColumnMetaData( ptdb, ColumnidOfFid( fid, ptdb->FTemplateTable() ) );
			}
		for ( FID fid = ptdb->FidVarFirst(); fid <= ptdb->FidVarLast(); fid++ )
			{
			EDBGDumpColumnMetaData( ptdb, ColumnidOfFid( fid, ptdb->FTemplateTable() ) );
			}
		for ( FID fid = ptdb->FidTaggedFirst(); fid <= ptdb->FidTaggedLast(); fid++ )
			{
			EDBGDumpColumnMetaData( ptdb, ColumnidOfFid( fid, ptdb->FTemplateTable() ) );
			}

		dprintf( "\n" );
		}


HandleError:
	LocalFree( pfcbIndex );
	Unfetch( pfcbTable );
	}

//  ================================================================
DEBUG_EXT( EDBGDumpMetaData )
//  ================================================================
	{
	FCB *		pfcbDebuggee		= pfcbNil;
	FCB *		pfcb				= pfcbNil;
	const BOOL	fValidUsage			= ( 1 == argc && FAddressFromSz( argv[0], &pfcbDebuggee ) );

	dprintf( "\n" );

	if ( !fValidUsage )
		{
		dprintf( "Usage: DUMPMETADATE <pfcb>\n\n" );
		dprintf( "    <pfcb> - address of FCB for which meta-data is to be dumped\n" );
		goto HandleError;
		}

	if ( !FFetchVariable( pfcbDebuggee, &pfcb ) )
		{
		dprintf( "Error: Could not fetch FCB at 0x%p.\n", pfcbDebuggee );
		goto HandleError;
		}

	if ( pfcb->FTypeTable() )
		{
		EDBGDumpTableMetaData( pfcbDebuggee, pfcb->Ptdb() );
		}
	else if ( pfcb->FTypeSecondaryIndex() )
		{
		FCB *	pfcbTable;

	 	if ( FEDBGFetchTableMetaData( pfcb->PfcbTable(), &pfcbTable ) )
	 		{
			EDBGDumpIndexMetaData( pfcb, pfcbTable, pfcbDebuggee );
	 		}
		}
	else
		{
		CHAR *	szBtree;

		if ( pfcb->FTypeDatabase() )
			{
			szBtree = "Database";
			}
		else if ( pfcb->FTypeTemporaryTable() )
			{
			szBtree = "TempTable";
			}
		else if ( pfcb->FTypeSort() )
			{
			szBtree = "Sort";
			}
		else if ( pfcb->FTypeSentinel() )
			{
			szBtree = "Sentinel";
			}
		else if ( pfcb->FTypeLV() )
			{
			szBtree = "Long-Value";
			}
		else if ( pfcb->FTypeSLVAvail() )
			{
			szBtree = "SLV Avail";
			}
		else if ( pfcb->FTypeSLVOwnerMap() )
			{
			szBtree = "SLV Owner Map";
			}
		else
			{
			szBtree = "UNKNOWN";
			}

		dprintf(
			"Btree: <%s>  [pfcb=0x%p, ifmp=0x%x, objidFDP=0x%x, pgnoFDP=0x%x]\n",
			szBtree,
			pfcbDebuggee,
			pfcb->Ifmp(),
			pfcb->ObjidFDP(),
			pfcb->PgnoFDP() );
		}

HandleError:

	//  unload parameters
	//
	dprintf( "\n--------------------\n\n" );

	Unfetch( pfcb );
	}


//  ================================================================
LOCAL BOOL FEDBGReadAndCheckFCB(
	FCB * const		pfcbDebuggee,
	FCB * const		pfcb,
	const ULONG		ulFDP,
	BOOL * const	pfFoundFCB )
//  ================================================================
	{
	const BOOL		fResult		= FReadVariable( pfcbDebuggee, pfcb );

	if ( fResult )
		{
		if ( pfcb->ObjidFDP() == ulFDP || pfcb->PgnoFDP() == ulFDP )
			{
			dprintf(
				"    0x%p [ifmp:0x%x, objidFDP:0x%x, pgnoFDP:0x%x]\n",
				pfcbDebuggee,
				pfcb->Ifmp(),
				pfcb->ObjidFDP(),
				pfcb->PgnoFDP() );
			*pfFoundFCB = fTrue;
			}
		}
	else
		{
		dprintf( "    Error: Could not read FCB at 0x%p. Aborting.\n", pfcbDebuggee );
		}

	return fResult;
	}

//  ================================================================
DEBUG_EXT( EDBGFCBFind )
//  ================================================================
	{
	ULONG		ulFDP;
	INST *		pinstTarget			= NULL;
	ULONG		cNumInstances		= 0;
	INST **		rgpinstDebuggee		= NULL;
	INST **		rgpinst				= NULL;
	INST *		pinst				= pinstNil;
	FCB *		pfcb				= pfcbNil;
	TDB *		ptdb				= ptdbNil;
	BOOL		fFoundFCB			= fFalse;
	BOOL		fValidUsage			= fTrue;

	switch ( argc )
		{
		case 2:
			fValidUsage = ( fValidUsage && FAddressFromSz( argv[1], &pinstTarget ) );
			//	FALL THROUGH to validate rest of args

		case 1:
			fValidUsage = ( fValidUsage 
							&& FUlFromSz( argv[0], &ulFDP )
							&& ulFDP > 0 );
			break;

		default:
			fValidUsage = fFalse;
		}

	if ( !fValidUsage )
		{
		dprintf( "\nUsage: FCBFIND <FDP> [<instance>]\n\n" );
		dprintf( "    <FDP> - the objidFDP or pgnoFDP to search for\n" );
		dprintf( "    <instance> - an optional parameter specifying the pointer\n" );
		dprintf( "                 to the instance for which to limit the scan\n" );
		goto HandleError;
		}

	if ( NULL != pinstTarget )
		{
		//	scan just the specified instance
		//
		cNumInstances = 1;
		}
	else
		{
		//	scan all instances (we will need to fetch g_rgpinst to do this)
		//
		cNumInstances = cMaxInstances;

		if ( !FAddressFromGlobal( "g_rgpinst", &rgpinstDebuggee )
			|| !FFetchVariable( rgpinstDebuggee, &rgpinst, cNumInstances ) )
			{
			dprintf( "\nError: Could not fetch instance table.\n" );
			goto HandleError;
			}
		}

	pinst = (INST *)LocalAlloc( 0, sizeof(INST) );
	if ( pinstNil == pinst )
		{
		dprintf( "\nError: Could not allocate INST buffer.\n" );
		goto HandleError;
		}

	pfcb = (FCB *)LocalAlloc( 0, sizeof(FCB) );
	if ( pfcbNil == pfcb )
		{
		dprintf( "\nError: Could not allocate FCB buffer.\n" );
		goto HandleError;
		}

	ptdb = (TDB *)LocalAlloc( 0, sizeof(TDB) );
	if ( ptdbNil == ptdb )
		{
		dprintf( "\nError: Could not allocate TDB buffer.\n" );
		goto HandleError;
		}

	//  scan FCB list of all INST's
	//
	for ( SIZE_T ipinst = 0; ipinst < cNumInstances; ipinst++ )
		{
		INST * pinstDebuggee	= ( NULL != pinstTarget ? pinstTarget : rgpinst[ipinst] );

		if ( pinstNil == pinstDebuggee )
			{
			continue;
			}

		dprintf( "\nScanning all FCB's of instance 0x%p...\n", pinstDebuggee );
		if ( FReadVariable( pinstDebuggee, pinst ) )
			{
			FCB *	pfcbDebuggee	= pinst->m_pfcbList;
			FCB *	pfcbNextInList	= pfcbNil;
			
			for ( pfcbDebuggee = pinst->m_pfcbList;
				pfcbNil != pfcbDebuggee;
				pfcbDebuggee = pfcbNextInList )
				{
				//	check main FCB
				//
				if ( !FEDBGReadAndCheckFCB( pfcbDebuggee, pfcb, ulFDP, &fFoundFCB ) )
					{
					goto HandleError;
					}

				//	pfcb variable will be re-used, so save
				//	off pointer to next FCB in global list
				//
				pfcbNextInList = pfcb->PfcbNextList();

				//	check possible index FCB's
				//
				for ( pfcbDebuggee = pfcb->PfcbNextIndex();
					pfcbNil != pfcbDebuggee;
					pfcbDebuggee = pfcb->PfcbNextIndex() )
					{
					if ( !FEDBGReadAndCheckFCB( pfcbDebuggee, pfcb, ulFDP, &fFoundFCB ) )
						{
						goto HandleError;
						}
					}

				//	check possible LV FCB
				//
				if ( NULL != pfcb->Ptdb() )
					{
					if ( !FReadVariable( pfcb->Ptdb(), ptdb ) )
						{
						dprintf( "    Error: Could not read TDB at 0x%p. Aborting.\n", pfcb->Ptdb() );
						goto HandleError;
						}

					if ( NULL != ptdb->PfcbLV()
						&& !FEDBGReadAndCheckFCB( ptdb->PfcbLV(), pfcb, ulFDP, &fFoundFCB ) )
						{
						goto HandleError;
						}
					}
				}
			}
		else
			{
			if ( NULL != pinstTarget )
				{
				dprintf( "    Error: Could not read INST at 0x%p. Aborting.\n", pinstTarget );
				}
			else
				{
				dprintf(
					"    g_rgpinst[0x%x]  Error: Could not read INST at 0x%p. Aborting.\n",
					ipinst,
					rgpinst[ipinst] );
				}
			goto HandleError;
			}
		}

	if ( !fFoundFCB )
		{
		//	we did not find the FCB
		//
		dprintf( "\nCould not find any FCB's with an objidFDP or pgnoFDP of %d (0x%x).\n", ulFDP, ulFDP );
		}


HandleError:

	//  unload parameters
	//
	dprintf( "\n--------------------\n\n" );

	LocalFree( ptdb );
	LocalFree( pfcb );
	LocalFree( pinst );
	Unfetch( rgpinst );
	}


//  ================================================================
DEBUG_EXT( EDBGTableFind )
//  ================================================================
	{
	const CHAR *	szTableName;
	INST *			pinstTarget			= NULL;
	ULONG			cNumInstances		= 0;
	INST **			rgpinstDebuggee		= NULL;
	INST **			rgpinst				= NULL;
	INST *			pinst				= pinstNil;
	BOOL			fFoundFCB			= fFalse;
	BOOL			fValidUsage			= fTrue;

	switch ( argc )
		{
		case 2:
			fValidUsage = ( fValidUsage && FAddressFromSz( argv[1], &pinstTarget ) );
			//	FALL THROUGH to validate rest of args

		case 1:
			szTableName = argv[0];
			break;

		default:
			fValidUsage = fFalse;
		}

	if ( !fValidUsage )
		{
		dprintf( "\nUsage: TABLEFIND <szTable> [<instance>]\n\n" );
		dprintf( "    <szTable> - name of table to search for\n" );
		dprintf( "    <instance> - an optional parameter specifying the pointer\n" );
		dprintf( "                 to the instance for which to limit the scan\n" );
		goto HandleError;
		}

	if ( NULL != pinstTarget )
		{
		//	scan just the specified instance
		//
		cNumInstances = 1;
		}
	else
		{
		//	scan all instances (we will need to fetch g_rgpinst to do this)
		//
		cNumInstances = cMaxInstances;

		if ( !FAddressFromGlobal( "g_rgpinst", &rgpinstDebuggee )
			|| !FFetchVariable( rgpinstDebuggee, &rgpinst, cNumInstances ) )
			{
			dprintf( "\nError: Could not fetch instance table.\n" );
			goto HandleError;
			}
		}

	pinst = (INST *)LocalAlloc( 0, sizeof(INST) );
	if ( pinstNil == pinst )
		{
		dprintf( "\nError: Could not allocate INST buffer.\n" );
		goto HandleError;
		}

	//  scan FCB list of all INST's
	//
	for ( SIZE_T ipinst = 0; ipinst < cNumInstances; ipinst++ )
		{
		INST * pinstDebuggee	= ( NULL != pinstTarget ? pinstTarget : rgpinst[ipinst] );

		if ( pinstNil == pinstDebuggee )
			{
			continue;
			}

		dprintf( "\nScanning all FCB's of instance 0x%p...\n", pinstDebuggee );
		if ( FReadVariable( pinstDebuggee, pinst ) )
			{
			FCB *	pfcbDebuggee	= pinst->m_pfcbList;

			while ( pfcbNil != pfcbDebuggee )
				{
				FCB *	pfcb;

				//	retrieve meta-data
				//
				if ( !FEDBGFetchTableMetaData( pfcbDebuggee, &pfcb ) )
					{
					goto HandleError;
					}

				//	see if this FCB is a match
				//
				if ( pfcb->FTypeTable()
					&& 0 == UtilCmpName( szTableName, pfcb->Ptdb()->SzTableName() ) )
					{
					dprintf(
						"    0x%p [ifmp:0x%x, objidFDP:0x%x, pgnoFDP:0x%x]\n",
						pfcbDebuggee,
						pfcb->Ifmp(),
						pfcb->ObjidFDP(),
						pfcb->PgnoFDP() );
					fFoundFCB = fTrue;
					}

				pfcbDebuggee = pfcb->PfcbNextList();
				Unfetch( pfcb );
				}
			}
		else
			{
			if ( NULL != pinstTarget )
				{
				dprintf( "    Error: Could not read INST at 0x%p. Aborting.\n", pinstTarget );
				}
			else
				{
				dprintf(
					"    g_rgpinst[0x%x]  Error: Could not read INST at 0x%p. Aborting.\n",
					ipinst,
					rgpinst[ipinst] );
				}
			goto HandleError;
			}
		}

	if ( !fFoundFCB )
		{
		//	we did not find the FCB
		//
		dprintf( "\nCould not find any FCB's with table name \"%s\".\n", szTableName );
		}


HandleError:

	//  unload parameters
	//
	dprintf( "\n--------------------\n\n" );

	LocalFree( pinst );
	Unfetch( rgpinst );
	}


//  ================================================================
DEBUG_EXT( EDBGCacheMap )
//  ================================================================
	{
	void *pvOffset;
	if ( argc == 1 && FAddressFromSz( argv[ 0 ], &pvOffset ) )
		{
		//  load BF parameters

		LONG_PTR	cbfChunkT;
		BF **		rgpbfChunkT				= NULL;
		LONG_PTR	cpgChunkT;
		VOID **		rgpvChunkT			= NULL;
		LONG		cbPageT;

		if ( !FReadGlobal( "cbfChunk", &cbfChunkT )
			|| !FReadGlobalAndFetchVariable( "rgpbfChunk", &rgpbfChunkT, cCacheChunkMax )
			|| !FReadGlobal( "cpgChunk", &cpgChunkT )
			|| !FReadGlobalAndFetchVariable( "rgpvChunk", &rgpvChunkT, cCacheChunkMax )
			|| !FReadGlobal( "g_cbPage", &cbPageT ) )
			{
			dprintf( "Error: Could not load BF parameters.\n" );
			}

		else
			{
			//  lookup this offset in both tables

			IBF ibf = ibfNil;
			for ( LONG_PTR ibfChunk = 0; ibfChunk < cCacheChunkMax; ibfChunk++ )
				{
				if (	rgpbfChunkT[ ibfChunk ] &&
						rgpbfChunkT[ ibfChunk ] <= PBF( pvOffset ) &&
						PBF( pvOffset ) < rgpbfChunkT[ ibfChunk ] + cbfChunkT  )
					{
					ibf = ibfChunk * cbfChunkT + PBF( pvOffset ) - rgpbfChunkT[ ibfChunk ];
					}
				}

			IPG ipg = ipgNil;
			for ( LONG_PTR ipgChunk = 0; ipgChunk < cCacheChunkMax; ipgChunk++ )
				{
				if (	rgpvChunkT[ ipgChunk ] &&
						rgpvChunkT[ ipgChunk ] <= pvOffset &&
						pvOffset < (BYTE*)rgpvChunkT[ ipgChunk ] + cpgChunkT * cbPageT )
					{
					ipg = ipgChunk * cpgChunkT + ( (BYTE*)pvOffset - (BYTE*)rgpvChunkT[ ipgChunk ] ) / cbPageT;
					}
				}

			//  this is a BF

			if ( ibf != ibfNil )
				{
				PBF		pbfDebuggee	= rgpbfChunkT[ ibf / cbfChunkT ] + ibf % cbfChunkT;
				void*	pvDebuggee	= (BYTE*)rgpvChunkT[ ibf / cpgChunkT ] + ( ibf % cpgChunkT ) * cbPageT;

				dprintf(	"0x%0*I64X detected as BF 0x%p\n",
							sizeof( void* ) * 2,
							QWORD( pvOffset ),
							pbfDebuggee );
				dprintf(	"\tPage Image is at 0x%p\n",
							pvDebuggee );
				}

			//  this is a page pointer

			else if ( ipg != ipgNil )
				{
				PBF		pbfDebuggee	= rgpbfChunkT[ ipg / cbfChunkT ] + ipg % cbfChunkT;
				void*	pvDebuggee	= (BYTE*)rgpvChunkT[ ipg / cpgChunkT ] + ( ipg % cpgChunkT ) * cbPageT;

				dprintf(	"0x%0*I64X detected as Page Image 0x%p\n",
							sizeof( void* ) * 2,
							QWORD( pvOffset ),
							pvDebuggee );
				dprintf(	"\tBF is at 0x%p\n",
							pbfDebuggee );
				}

			//  this is an unknown pointer

			else
				{
				dprintf(	"0x%0*I64X is not part of the cache.\n",
							sizeof( void* ) * 2,
							QWORD( pvOffset ) );
				}
			}

		//  unload BF parameters

		Unfetch( rgpbfChunkT );
		Unfetch( rgpvChunkT );
		}
	else
		{
		dprintf( "Usage: CACHEMAP <address>\n" );
		dprintf( "\n" );
		dprintf( "    <address> can be any address within a valid BF or page image\n" );
		}
	}


//  ================================================================
DEBUG_EXT( EDBGDumpCacheMap )
//  ================================================================
	{
	//  load BF parameters

	LONG_PTR	cbfChunkT;
	BF **		rgpbfChunkT				= NULL;
	LONG_PTR	cpgChunkT;
	VOID **		rgpvChunkT			= NULL;
	LONG		cbPageT;

	if ( !FReadGlobal( "cbfChunk", &cbfChunkT )
		|| !FReadGlobalAndFetchVariable( "rgpbfChunk", &rgpbfChunkT, cCacheChunkMax )
		|| !FReadGlobal( "cpgChunk", &cpgChunkT )
		|| !FReadGlobalAndFetchVariable( "rgpvChunk", &rgpvChunkT, cCacheChunkMax )
		|| !FReadGlobal( "g_cbPage", &cbPageT ) )
		{
		dprintf( "Error: Could not load BF parameters.\n" );
		}

	else
		{
		dprintf( "BF:\n" );
		for ( LONG_PTR ibfChunk = 0; ibfChunk < cCacheChunkMax && rgpbfChunkT[ ibfChunk ]; ibfChunk++ )
			{
			dprintf(	"\t[0x%0*I64X, 0x%0*I64X)\n",
						sizeof( PBF ) * 2,
						QWORD( rgpbfChunkT[ ibfChunk ] ),
						sizeof( PBF ) * 2,
						QWORD( rgpbfChunkT[ ibfChunk ] + cbfChunkT ) );
			}
		dprintf( "\n" );

		dprintf( "Page Image:\n" );
		for ( LONG_PTR ipvChunk = 0; ipvChunk < cCacheChunkMax && rgpvChunkT[ ipvChunk ]; ipvChunk++ )
			{
			dprintf(	"\t[0x%0*I64X, 0x%0*I64X)\n",
						sizeof( void* ) * 2,
						QWORD( rgpvChunkT[ ipvChunk ] ),
						sizeof( void* ) * 2,
						QWORD( (BYTE*)rgpvChunkT[ ipvChunk ] + cpgChunkT * cbPageT ) );
			}
		dprintf( "\n" );
		}

	//  unload BF parameters

	Unfetch( rgpbfChunkT );
	Unfetch( rgpvChunkT );
	}


//  ================================================================
DEBUG_EXT( EDBGTid2PIB )
//  ================================================================
	{
	ULONG		ulTid				= 0;
	INST **		rgpinstDebuggee		= NULL;
	INST **		rgpinst				= NULL;
	BOOL		fFoundPIB			= fFalse;
	BOOL		fValidUsage;

	switch ( argc )
		{
		case 1:
			fValidUsage = FUlFromSz( argv[0], &ulTid );
			break;
		case 2:
			fValidUsage = ( FAddressFromSz( argv[1], &rgpinstDebuggee )
							&& FUlFromSz( argv[0], &ulTid ) );
			break;
		default:
			fValidUsage = fFalse;
			break;
		}

	if ( !fValidUsage )
		{
		dprintf( "Usage: TID2PIB <tid> [<g_rgpinst>]\n" );
		return;
		}

	if ( ( NULL == rgpinstDebuggee && !FAddressFromGlobal( "g_rgpinst", &rgpinstDebuggee ) )
		|| !FFetchVariable( rgpinstDebuggee, &rgpinst, cMaxInstances ) )
		{
		dprintf( "Error: Could not fetch instance table.\n" );
		return;
		}

	dprintf( "\nScanning 0x%X INST's starting at 0x%p...\n", cMaxInstances, rgpinstDebuggee );

	for ( SIZE_T ipinst = 0; ipinst < cMaxInstances; ipinst++ )
		{
		if ( rgpinst[ipinst] != pinstNil )
			{
			INST* pinst;
			if ( !FFetchVariable( rgpinst[ipinst], &pinst ) )
				{
				dprintf( "Error: Could not fetch instance definition at 0x%p.\n", rgpinst[ipinst] );
				Unfetch( rgpinst );
				return;
				}

			PIB* ppibDebuggee = pinst->m_ppibGlobal;

			while ( ppibDebuggee != ppibNil )
				{
				PIB* ppib;
				if ( !FFetchVariable( ppibDebuggee, &ppib ) )
					{
					dprintf( "Error: Could not fetch PIB at 0x%p.\n", ppibDebuggee );
					Unfetch( pinst );
					Unfetch( rgpinst );
					return;
					}

				_TLS* ptlsDebuggee = (_TLS*)ppib->ptls;

				if ( ptlsDebuggee )
					{
					_TLS* ptls;
					if ( !FFetchVariable( ptlsDebuggee, &ptls ) )
						{
						dprintf( "Error: Could not fetch TLS at 0x%p.\n", ptlsDebuggee );
						Unfetch( ppib );
						Unfetch( pinst );
						Unfetch( rgpinst );
						return;
						}

					if ( ptls->dwThreadId == ulTid )
						{
						dprintf( "TID %d (0x%x) was the last user of PIB 0x%p.\n",
									ptls->dwThreadId,
									ptls->dwThreadId,
									ppibDebuggee );

						fFoundPIB = fTrue;
						}

					Unfetch( ptls );
					}

				ppibDebuggee = ppib->ppibNext;

				Unfetch( ppib );
				}

			Unfetch( pinst );
			}
		}

	if ( !fFoundPIB )
		{
		dprintf( "This thread was not the last user of any PIBs.\n" );
		}

	Unfetch( rgpinst );
	}


//  ================================================================
DEBUG_EXT( EDBGChecksum )
//  ================================================================
	{
	BYTE*	rgbDebuggee;
	ULONG	cb;

	if (	argc < 1 ||
			argc > 2 ||
			!FAddressFromSz( argv[ 0 ], &rgbDebuggee ) ||
			argc == 2 && !FUlFromSz( argv[ 1 ], &cb ) )
		{
		dprintf( "Usage: CHECKSUM <address> [<length>]\n" );
		return;
		}

	LONG	cbPage;
	if ( argc == 1 && !FReadGlobal( "g_cbPage", &cbPage ) )
		{
		dprintf( "Error: cannot determine page size of debuggee.\n" );
		return;
		}

	cb = ( argc == 1 ? cbPage : cb );

	BYTE*	rgb;
	if ( !FFetchVariable( rgbDebuggee, &rgb, cb ) )
		{
		dprintf( "Error: Could not retrieve data to checksum.\n" );
		return;
		}

	const ULONG ulChecksum = UlUtilChecksum( rgb, cb );
	dprintf(	"Checksum of 0x%X bytes starting at 0x%p is:  %u (0x%08X).\n",
				cb,
				rgbDebuggee,
				ulChecksum,
				ulChecksum );

	Unfetch( rgb );
	}


//  ================================================================
DEBUG_EXT( EDBGDumpLinkedList )
//  ================================================================
	{
	ULONG			ulOffset				= 0;
	ULONG			cDwordsToDisplay		= 8;
	ULONG			cbToFetch				= 0;
	ULONG			cMaxElements			= 32;
	ULONG			cElements				= 0;
	const ULONG		cDwordsPerLine			= 4;
	const ULONG		cDwordsToDisplayMax		= 0x1000;
	const ULONG		cMaxElementsAbsolute	= 0x8000;
	BYTE *			pbDebuggee				= NULL;
	BYTE *			rgbBuf					= NULL;
	BOOL			fValidUsage				= fTrue;

	switch ( argc )
		{
		case 4:
			fValidUsage = ( fValidUsage && FUlFromSz( argv[3], &cMaxElements ) );
			//	FALL THROUGH to validate rest of args

		case 3:
			fValidUsage = ( fValidUsage && FUlFromSz( argv[2], &cDwordsToDisplay ) );
			//	FALL THROUGH to validate rest of args

		case 2:
			fValidUsage = ( fValidUsage
							&& FAddressFromSz( argv[0], &pbDebuggee )
							&& FUlFromSz( argv[1], &ulOffset ) );
			break;

		default:
			fValidUsage = fFalse;
			break;
		}

	dprintf( "\n" );

	if ( !fValidUsage )
		{
		dprintf( "Usage: DUMPLINKEDLIST <address> <offset> [<dwords to display> <max elements>]\n" );
		dprintf( "\n" );
		dprintf( "    <address> - address of initial linked list element\n" );
		dprintf( "    <offset>  - offset (in bytes) of pointer to next linked list element\n" );
		dprintf( "    <dwords to display> - number of dwords to display per element\n" );
		dprintf( "    <max elements> - maximum linked list elements to traverse\n" );
		dprintf( "\n" );
		return;
		}

	//	for each element, we need to ensure we fetch enough
	//	to read the next pointer and to display the requested
	//	number of dwords
	//
	cbToFetch = max( ulOffset + sizeof(VOID *), cDwordsToDisplay * sizeof(DWORD) );
	rgbBuf = (BYTE *)LocalAlloc( 0, cbToFetch );
	if ( NULL == rgbBuf )
		{
		dprintf( "Error: Could not allocate %d-byte buffer for linked list elements.\n", cbToFetch );
		goto HandleError;
		}

	//	cap maximum dwords to display per element
	//	to ensure we don't dump too much
	//
	cDwordsToDisplay = min( cDwordsToDisplay, cDwordsToDisplayMax );

	//	cap maximum elements to traverse to ensure
	//	we don't loop forever
	//
	cMaxElements = min( cMaxElements, cMaxElementsAbsolute );

	//	traverse linked list and dump each element
	//
	while ( NULL != pbDebuggee
		&& cElements < cMaxElements )
		{
		if ( !FReadVariable( pbDebuggee, rgbBuf, cbToFetch ) )
			{
			dprintf( "Error: Could not fetch linked list element at 0x%p.\n", pbDebuggee );
			goto HandleError;
			}

        dprintf( "0x%p%s\n", pbDebuggee, ( cDwordsToDisplay > 0 ? ":" : ""  ) );
        for ( ULONG ib = 0; ib < cDwordsToDisplay * sizeof(DWORD); NULL )
        	{
			dprintf( "\t" );
			for ( ULONG ibMaxThisLine = min( ib + ( sizeof(DWORD) * cDwordsPerLine ), cDwordsToDisplay * sizeof(DWORD) );
				ib < ibMaxThisLine;
				ib += sizeof(DWORD) )
				{
				dprintf( "%08x ", *(ULONG *)( rgbBuf + ib ) );
				}
			dprintf( "\n" );
        	}
		cElements++;

		if ( pbDebuggee == *(BYTE **)( rgbBuf + ulOffset ) )
			{
			//	SPECIAL-CASE: next pointer points back to this element
			//	(we terminate some linked lists in this fashion)
			//
			break;
			}

		pbDebuggee = *(BYTE **)( rgbBuf + ulOffset );
		}

	dprintf( "\nElements traversed: %d\n", cElements );
	if ( NULL != pbDebuggee )
		{
		dprintf( "(End of list was not reached. Next element: 0x%p)\n", pbDebuggee );
		}

HandleError:
	dprintf( "\n" );

	LocalFree( rgbBuf );
	}


//  ================================================================
DEBUG_EXT( EDBGDumpInvasiveList )
//  ================================================================
	{
	ULONG			ulOffset				= 0;
	ULONG			cDwordsToDisplay		= 8;
	ULONG			cbToFetch				= 0;
	ULONG			cMaxElements			= 32;
	ULONG			cElements				= 0;
	BOOL			fFollowPrevPointer		= fFalse;
	const ULONG		cDwordsPerLine			= 4;
	const ULONG		cDwordsToDisplayMax		= 0x1000;
	const ULONG		cMaxElementsAbsolute	= 0x8000;
	BYTE *			pbDebuggee				= NULL;
	BYTE *			rgbBuf					= NULL;
	BOOL			fValidUsage				= fTrue;

	switch ( argc )
		{
		case 4:
			fValidUsage = ( fValidUsage && FUlFromSz( argv[3], &cMaxElements ) );
			//	FALL THROUGH to validate rest of args

		case 3:
			fValidUsage = ( fValidUsage && FUlFromSz( argv[2], &cDwordsToDisplay ) );
			//	FALL THROUGH to validate rest of args

		case 2:
			fFollowPrevPointer = ( '-' == argv[1][0] );
			fValidUsage = ( fValidUsage
							&& FAddressFromSz( argv[0], &pbDebuggee )
							&& FUlFromSz( argv[1] + ( fFollowPrevPointer ? 1 : 0 ), &ulOffset ) );
			break;

		default:
			fValidUsage = fFalse;
			break;
		}

	dprintf( "\n" );

	if ( !fValidUsage )
		{
		dprintf( "Usage: DUMPINVASIVELIST <address> [<+/->]<offset> [<dwords to display> <max elements>]\n" );
		dprintf( "\n" );
		dprintf( "    <address> - address of initial invasive list element (NOT address of invasive list head)\n" );
		dprintf( "    <+/-> - specify '+' to follow \"next\" pointer, '-' to follow \"prev\" pointer\n" );
		dprintf( "    <offset>  - offset (in bytes) of invasive list within the element\n" );
		dprintf( "    <dwords to display> - number of dwords to display per element\n" );
		dprintf( "    <max elements> - maximum invasive list elements to traverse\n" );
		dprintf( "\n" );
		return;
		}

	//	for each element, we need to ensure we fetch enough
	//	to read the next pointer and to display the requested
	//	number of dwords
	//
	cbToFetch = max( ulOffset + sizeof(CInvasiveListEDBG::CElement), cDwordsToDisplay * sizeof(DWORD) );
	rgbBuf = (BYTE *)LocalAlloc( 0, cbToFetch );
	if ( NULL == rgbBuf )
		{
		dprintf( "Error: Could not allocate %d-byte buffer for linked list elements.\n", cbToFetch );
		goto HandleError;
		}

	//	cap maximum dwords to display per element
	//	to ensure we don't dump too much
	//
	cDwordsToDisplay = min( cDwordsToDisplay, cDwordsToDisplayMax );

	//	cap maximum elements to traverse to ensure
	//	we don't loop forever
	//
	cMaxElements = min( cMaxElements, cMaxElementsAbsolute );

	//	traverse linked list and dump each element
	//
	while ( NULL != pbDebuggee
		&& cElements < cMaxElements )
		{
		if ( !FReadVariable( pbDebuggee, rgbBuf, cbToFetch ) )
			{
			dprintf( "Error: Could not fetch invasive list element at 0x%p.\n", pbDebuggee );
			goto HandleError;
			}

        dprintf( "0x%p%s\n", pbDebuggee, ( cDwordsToDisplay > 0 ? ":" : ""  ) );
        for ( ULONG ib = 0; ib < cDwordsToDisplay * sizeof(DWORD); NULL )
        	{
			dprintf( "\t" );
			for ( ULONG ibMaxThisLine = min( ib + ( sizeof(DWORD) * cDwordsPerLine ), cDwordsToDisplay * sizeof(DWORD) );
				ib < ibMaxThisLine;
				ib += sizeof(DWORD) )
				{
				dprintf( "%08x ", *(ULONG *)( rgbBuf + ib ) );
				}
			dprintf( "\n" );
        	}
		cElements++;

		pbDebuggee = *(BYTE **)(
							rgbBuf
							+ ulOffset
							+ ( fFollowPrevPointer ?
									0 :					//	OffsetOf( CInvasiveList::CElement, m_pilePrev )
									sizeof(VOID *) ) );	//	OffsetOf( CInvasiveList::CElement, m_pileNext )

		if ( NULL == pbDebuggee				//	should be impossible, but just in case
			|| (VOID *)-1 == pbDebuggee )	//	this element is not actually in an invasive list
			{
			break;
			}

		pbDebuggee -= ulOffset;
		}

	dprintf( "\nElements traversed: %d\n", cElements );
	if ( NULL != pbDebuggee )
		{
		dprintf( "(End of list was not reached. Next element: 0x%p)\n", pbDebuggee );
		}

HandleError:
	dprintf( "\n" );

	LocalFree( rgbBuf );
	}


//  ================================================================
DEBUG_EXT( EDBGDumpLR )
//  ================================================================
	{
	LR* plrDebuggee;
	if (	argc != 1 ||
			!FAddressFromSz( argv[ 0 ], &plrDebuggee ) )
		{
		dprintf( "Usage: DUMPLR <address>\n" );
		return;
		}

	//  get the fixed size of this log record

	LR	lr;
	if ( !FReadVariable( plrDebuggee, &lr ) )
		{
		dprintf( "Error: Could not fetch the log record type.\n" );
		return;
		}
	const SIZE_T	cbLRFixed	= CbLGFixedSizeOfRec( &lr );

	//  get the full size of this log record

	LR*	plrFixed;
	if ( !FFetchVariable( (BYTE*)plrDebuggee, (BYTE**)&plrFixed, cbLRFixed ) )
		{
		dprintf( "Error: Could not fetch the fixed-sized part of this log record.\n" );
		return;
		}
	const SIZE_T	cbLR		= CbLGSizeOfRec( plrFixed );

	Unfetch( (BYTE*)plrFixed );

	//  get the full log record

	LR*	plr;
	if ( !FFetchVariable( (BYTE*)plrDebuggee, (BYTE**)&plr, cbLR ) )
		{
		dprintf( "Error: Could not fetch the entire log record.\n" );
		return;
		}

	//  dump the log record

	dprintf(	"0x%0*I64X bytes @ 0x%p\n",
				sizeof( SIZE_T ) * 2,
				QWORD( cbLR ),
				plr );

#ifdef DEBUG

	CHAR szBuf[ 2048 ];
	LrToSz( plr, szBuf, NULL );
	dprintf( "%s\n", szBuf );

#endif	//	DEBUG

	Unfetch( (BYTE*)plr );
	}


//  ================================================================
DEBUG_EXT( EDBGHash )
//  ================================================================
	{
	ULONG	ifmp;
	ULONG	pgnoFDP;
	BYTE*	rgbPrefixDebuggee;
	ULONG	cbPrefix;
	BYTE*	rgbSuffixDebuggee;
	ULONG	cbSuffix;
	BYTE*	rgbDataDebuggee;
	ULONG	cbData;

	dprintf( "\n" );

	if (	argc != 8 ||
			!FUlFromSz( argv[ 0 ], &ifmp ) ||
			!FUlFromSz( argv[ 1 ], &pgnoFDP ) ||
			!FAddressFromSz( argv[ 2 ], &rgbPrefixDebuggee ) ||
			!FUlFromSz( argv[ 3 ], &cbPrefix ) ||
			!FAddressFromSz( argv[ 4 ], &rgbSuffixDebuggee ) ||
			!FUlFromSz( argv[ 5 ], &cbSuffix ) ||
			!FAddressFromSz( argv[ 6 ], &rgbDataDebuggee ) ||
			!FUlFromSz( argv[ 7 ], &cbData ) )
		{
		dprintf( "Usage: HASH <ifmp> <pgnoFDP> <pbPrefix> <cbPrefix> <pbSuffix> <cbSuffix> <pbData> <cbData>\n\n" );
		return;
		}

	BYTE*	rgbPrefix	= NULL;
	BYTE*	rgbSuffix	= NULL;
	BYTE*	rgbData		= NULL;
	if ( !FFetchVariable( rgbPrefixDebuggee, &rgbPrefix, cbPrefix )
		|| !FFetchVariable( rgbSuffixDebuggee, &rgbSuffix, cbSuffix )
		|| !FFetchVariable( rgbDataDebuggee, &rgbData, cbData ) )
		{
		dprintf( "Error: Couldn't fetch the prefix / suffix / data from the debuggee.\n" );
		}
	else
		{
		BOOKMARK bookmark;
		bookmark.key.prefix.SetPv( rgbPrefix );
		bookmark.key.prefix.SetCb( cbPrefix );
		bookmark.key.suffix.SetPv( rgbSuffix );
		bookmark.key.suffix.SetCb( cbSuffix );
		bookmark.data.SetPv( rgbData );
		bookmark.data.SetCb( cbData );

		const ULONG ulVERChecksum = UiVERHash( IFMP( ifmp ), PGNO( pgnoFDP ), bookmark );

		dprintf(	"VER checksum is:  %u (0x%08X)\n",
					ulVERChecksum,
					ulVERChecksum );
		}

	dprintf( "\n" );

	Unfetch( rgbPrefix );
	Unfetch( rgbSuffix );
	Unfetch( rgbData );
	}


//  ================================================================
LOCAL BOOL FEDBGLoadPage_(
	const IFMP	ifmp,
	const PGNO	pgno,
	BYTE *		rgbPageBuf,
	PBF			pbfBuf )
//  ================================================================
	{
	//  scan all valid BFs looking for this IFMP / PGNO
	//
	for ( LONG_PTR ibf = 0; ibf < cbfCache; ibf++ )
		{
		//  compute the address of the target BF
		//
		PBF	pbfDebuggee	= rgpbfChunk[ ibf / cbfChunk ] + ibf % cbfChunk;

		//  we failed to read this BF
		//
		if ( !FReadVariable( pbfDebuggee, pbfBuf ) )
			{
			dprintf( "Error: Could not read BF at 0x%p.\n", pbfDebuggee );
			return fFalse;
			}

		//	see if this BF contains this IFMP / PGNO
		//
		if ( pbfBuf->ifmp == IFMP( ifmp )
			&& pbfBuf->pgno == PGNO( pgno )
			&& pbfBuf->fCurrentVersion )
			{
			if ( FReadVariable( (BYTE *)pbfBuf->pv, rgbPageBuf, g_cbPage ) )
				{
				return fTrue;
				}
			else
				{
				dprintf( "Error: Could not read %d-byte PAGE at 0x%p.\n", g_cbPage, pbfBuf->pv );
				return fFalse;
				}
			}
		}

	dprintf( "Error: [%d:%d] is not cached.\n", ifmp, pgno );
	return fFalse;
	}

//  ================================================================
LOCAL VOID EDBGSeek_(
	const IFMP	ifmp,
	const PGNO	pgnoRoot,
	BOOKMARK&	bm )
//  ================================================================
	{
	CPAGE		cpage;
	INT			compare;
	INT			iline;
	BYTE *		rgbPageBuf;
	PBF			pbfBuf;

	rgbPageBuf = (BYTE *)LocalAlloc( 0, g_cbPage );
	if ( NULL == rgbPageBuf )
		{
		dprintf( "Error: Could not allocate PAGE buffer.\n" );
		return;
		}

	pbfBuf = (PBF)LocalAlloc( 0, sizeof(BF) );
	if ( NULL == pbfBuf )
		{
		dprintf( "Error: Could not allocate BF buffer.\n" );
		LocalFree( rgbPageBuf );
		return;
		}

	cpage.LoadPage( rgbPageBuf );

	dprintf( "Path to bookmark:\n" );

	if ( !FEDBGLoadPage_( ifmp, pgnoRoot, rgbPageBuf, pbfBuf ) )
		goto HandleError;

	//	now seek down the btree for the bookmark
	//
	while ( !cpage.FLeafPage() )
		{
		iline = IlineNDISeekGEQInternal( cpage, bm, &compare );

		if ( 0 == compare )
			{
			//	see ErrNDISeekInternalPage() for an
			//	explanation of why we increment by 1 here
			//
			iline++;
			}

		dprintf( "\t[%d:%d:%d]  (", ifmp, cpage.Pgno(), iline );
		if ( cpage.FRootPage() )
			dprintf( "root," );
		if ( cpage.FParentOfLeaf() )
			dprintf( "parent-of-leaf," );
		else
			dprintf( "internal," );
		dprintf( "pv==0x%p)\n", pbfBuf->pv );

		KEYDATAFLAGS	kdf;
		NDIGetKeydataflags( cpage, iline, &kdf );

		if ( sizeof(PGNO) != kdf.data.Cb() )
			{
			dprintf( "Error: bad parent page pointer.\n" );
			goto HandleError;
			}

		const PGNO	pgnoChild	= *(UnalignedLittleEndian< PGNO > *)kdf.data.Pv();

		if ( !FEDBGLoadPage_( ifmp, pgnoChild, rgbPageBuf, pbfBuf ) )
			goto HandleError;
		}

	//	find the first node in the leaf page that's
	//	greater than or equal to the specified bookmark
	//
	iline = IlineNDISeekGEQ( cpage, bm, !cpage.FNonUniqueKeys(), &compare );
	Assert( iline < cpage.Clines( ) );
	if ( iline < 0 )
		{
		//	all nodes in page are less than key
		//
		iline = cpage.Clines( ) - 1;
		}

	dprintf(
		"\t[%d:%d:%d]  (%sleaf,pv==0x%p)\n",
		ifmp,
		cpage.Pgno(),
		iline,
		( cpage.FRootPage() ? "root," : "" ),
		pbfBuf->pv );

HandleError:
	cpage.UnloadPage();
	LocalFree( pbfBuf );
	LocalFree( rgbPageBuf );
	}

//  ================================================================
DEBUG_EXT( EDBGSeek )
//  ================================================================
	{
	ULONG		ifmp;
	ULONG		pgnoRoot;
	BYTE *		rgbPrefixDebuggee	= NULL;
	BYTE *		rgbPrefix			= NULL;
	ULONG		cbPrefix			= 0;
	BYTE *		rgbSuffixDebuggee	= NULL;
	BYTE *		rgbSuffix			= NULL;
	ULONG		cbSuffix			= 0;
	BYTE *		rgbDataDebuggee		= NULL;
	BYTE *		rgbData				= NULL;
	ULONG		cbData				= 0;
	ULONG		cbPage				= 0;
	BF **		rgpbfChunkDebuggee	= NULL;
	BF **		rgpbfChunkT			= NULL;
	LONG_PTR	cbfChunkT			= 0;
	LONG_PTR	cbfCacheT			= 0;
	BOOL		fBadUsage			= fFalse;

	dprintf( "\n" );

	switch ( argc )
		{
		case 8:
			if ( !FAddressFromSz( argv[ 6 ], &rgbDataDebuggee )
				|| !FUlFromSz( argv[ 7 ], &cbData ) )
				{
				fBadUsage = fTrue;
				break;
				}
			//	FALL THROUGH
		case 6:
			if ( !FAddressFromSz( argv[ 4 ], &rgbSuffixDebuggee )
				|| !FUlFromSz( argv[ 5 ], &cbSuffix ) )
				{
				fBadUsage = fTrue;
				break;
				}
			//	FALL THROUGH
		case 4:
			if ( FUlFromSz( argv[ 0 ], &ifmp )
				&& FUlFromSz( argv[ 1 ], &pgnoRoot )
				&& FAddressFromSz( argv[ 2 ], &rgbPrefixDebuggee )
				&& FUlFromSz( argv[ 3 ], &cbPrefix ) )
				{
				break;
				}
			//	FALL THROUGH
		default:
			fBadUsage = fTrue;
		}

	if ( fBadUsage )
		{
		dprintf( "Usage: SEEK <ifmp> <pgnoRoot> <pbPrefix> <cbPrefix> [<pbSuffix> <cbSuffix> [<pbData> <cbData>]]\n" );
		}
	else if ( ( cbPrefix > 0 && !FFetchVariable( rgbPrefixDebuggee, &rgbPrefix, cbPrefix ) )
		|| ( cbSuffix > 0 && !FFetchVariable( rgbSuffixDebuggee, &rgbSuffix, cbSuffix ) )
		|| ( cbData > 0 && !FFetchVariable( rgbDataDebuggee, &rgbData, cbData ) ) )
		{
		dprintf( "Error: Couldn't fetch the bookmark from the debuggee.\n" );
		}
	else if ( !FReadGlobal( "g_cbPage", &cbPage ) )
		{
		dprintf( "Error: Could not retrieve g_cbPage from the debuggee.\n" );
		}
	else if ( !FReadGlobal( "cbfChunk", &cbfChunkT )
		|| !FReadGlobal( "cbfCache", &cbfCacheT )
		|| !FReadGlobal( "rgpbfChunk", &rgpbfChunkDebuggee )
		|| !FFetchVariable( rgpbfChunkDebuggee, &rgpbfChunkT, cCacheChunkMax ) )
		{
		dprintf( "Error: Could not load BF parameters.\n" );
		}
	else
		{
		//	set up debugger to mirror debuggee
		//
		g_cbPage = cbPage;
		SetCbPageRelated();

		cbfChunk = cbfChunkT;
		cbfCache = cbfCacheT;
		rgpbfChunk = rgpbfChunkT;

		//	perform seek to bookmark
		//
		BOOKMARK bm;
		bm.key.prefix.SetPv( rgbPrefix );
		bm.key.prefix.SetCb( cbPrefix );
		bm.key.suffix.SetPv( rgbSuffix );
		bm.key.suffix.SetCb( cbSuffix );
		bm.data.SetPv( rgbData );
		bm.data.SetCb( cbData );

		EDBGSeek_( IFMP( ifmp ), PGNO( pgnoRoot ), bm );
		}

	dprintf( "\n" );

	Unfetch( rgpbfChunkT );
	Unfetch( rgbPrefix );
	Unfetch( rgbSuffix );
	Unfetch( rgbData );
	}


//  ================================================================
DEBUG_EXT( EDBGVerStore )
//  ================================================================
	{
	INST *		pinstDebuggee			= NULL;
	INST *		pinst					= NULL;
	INST::PLS *	rgpls					= NULL;
	PIB *		ppibTrxOldestDebuggee	= NULL;
	PIB *		ppibTrxOldest			= NULL;
	VER	*		pver					= NULL;
	CRES *		pcresVER				= NULL;

	dprintf( "\n" );

	if ( argc != 1
		|| !FAddressFromSz( argv[0], &pinstDebuggee ) )
		{
		dprintf( "Usage: VERSTORE <instance id>\n" );
		dprintf( "\n" );
		dprintf( "       <instance id> is the JET_INSTANCEID of the instance\n" );
		dprintf( "       for which to dump version store information. If you\n" );
		dprintf( "       do not know the instance id, you may be able to find\n" );
		dprintf( "       it by manually scanning the instance id array, which\n" );
		dprintf( "       begins at '%s!%s' and contains '%s!%s'\n",
						SzUtilImageName(),
						VariableNameToString( g_rgpinst ),
						SzUtilImageName(),
						VariableNameToString( ipinstMac ) );
		dprintf( "       entries.\n" );
		return;
		}

	if ( !FFetchVariable( pinstDebuggee, &pinst )
		|| !FFetchVariable( pinst->m_rgpls, &rgpls, pinst->m_cpls ) )
		{
		dprintf( "Error: Could not fetch instance and/or processor-local-storage variables.\n" );
		goto HandleError;
		}
	for ( size_t iProc = 0; iProc < pinst->m_cpls; iProc++ )
		{
		PIB *	ppibTrxOldestCandidateDebuggee	= rgpls[ iProc ].m_ilTrxOldest.PrevMost();

		if ( NULL != ppibTrxOldestCandidateDebuggee )
			{
			PIB *	ppibTrxOldestCandidate;

			if ( !FFetchVariable( ppibTrxOldestCandidateDebuggee, &ppibTrxOldestCandidate ) )
				{
				dprintf( "Error: Could not fetch ppibTrxOldestCandidate from processor-local-storage.\n" );
				goto HandleError;
				}
			if ( !ppibTrxOldest
				|| TrxCmp( ppibTrxOldestCandidate->trxBegin0, ppibTrxOldest->trxBegin0 ) < 0 )
				{
				Unfetch( ppibTrxOldest );
				ppibTrxOldestDebuggee = ppibTrxOldestCandidateDebuggee;
				ppibTrxOldest = ppibTrxOldestCandidate;
				}
			else
				{
				Unfetch( ppibTrxOldestCandidate );
				}
			}
		}

	if ( FFetchVariable( pinst->m_pver, &pver )
		&& FFetchVariable( pver->m_pcresVERPool, &pcresVER ) )
		{
		SIZE_T		dwOffset;

		//	dump version store-related members of various structs

		dwOffset = (BYTE *)pinstDebuggee - (BYTE *)pinst;
		dprintf( "INSTANCE: 0x%p\n", pinstDebuggee );
		dprintf( FORMAT_POINTER( INST, pinst, m_pver, dwOffset ) );
		dprintf( FORMAT_INT( INST, pinst, m_lVerPagesMax, dwOffset ) );
		dprintf( FORMAT_INT( INST, pinst, m_lVerPagesPreferredMax, dwOffset ) );
		dprintf( FORMAT_BOOL( INST, pinst, m_fPreferredSetByUser, dwOffset ) );
		dprintf( FORMAT_INT( INST, pinst, m_trxNewest, dwOffset ) );
		dprintf( "\n" );

		if ( NULL != ppibTrxOldest )
			{
			dwOffset = (BYTE *)ppibTrxOldestDebuggee - (BYTE *)ppibTrxOldest;
			dprintf( "OLDEST TRANSACTION: 0x%p\n", ppibTrxOldestDebuggee );
			dprintf( FORMAT_UINT( PIB, ppibTrxOldest, dwTrxContext, dwOffset ) );
			dprintf( FORMAT_UINT( PIB, ppibTrxOldest, trxBegin0, dwOffset ) );
			dprintf( FORMAT_UINT( PIB, ppibTrxOldest, trxCommit0, dwOffset ) );
			dprintf( FORMAT_INT( PIB, ppibTrxOldest, level, dwOffset ) );
			dprintf( FORMAT_INT( PIB, ppibTrxOldest, levelRollback, dwOffset ) );
			dprintf( FORMAT_INT( PIB, ppibTrxOldest, levelBegin, dwOffset ) );
			dprintf( FORMAT_INT( PIB, ppibTrxOldest, clevelsDeferBegin, dwOffset ) );
			dprintf( FORMAT_UINT( PIB, ppibTrxOldest, dwSessionContext, dwOffset ) );
			dprintf( FORMAT_UINT( PIB, ppibTrxOldest, dwSessionContextThreadId, dwOffset ) );
			}
		else
			{
			dprintf( "OLDEST TRANSACTION: <none>\n" );
			}
		dprintf( "\n" );

		dwOffset = (BYTE *)pinst->m_pver - (BYTE *)pver;
		dprintf( "VER: 0x%p\n", pinst->m_pver );
		dprintf( FORMAT_POINTER( VER, pver, m_pcresVERPool, dwOffset ) );
		dprintf( FORMAT_POINTER( VER, pver, m_pbucketGlobalHead, dwOffset ) );
		dprintf( FORMAT_POINTER( VER, pver, m_pbucketGlobalTail, dwOffset ) );

#ifdef MOVEABLE_RCE
		dprintf( FORMAT_POINTER( VER, pver, m_pbucketGlobalLastDelete, dwOffset ) );
		dprintf( FORMAT_INT( VER, pver, m_cbucketGlobalAllocDelete, dwOffset ) );
#endif

		dprintf( FORMAT_INT( VER, pver, m_cbucketGlobalAlloc, dwOffset ) );
		dprintf( FORMAT_UINT( VER, pver, m_cbucketDynamicAlloc, dwOffset ) );
		dprintf( FORMAT_INT( VER, pver, m_cbucketGlobalAllocMost, dwOffset ) );
		dprintf( FORMAT_INT( VER, pver, m_cbucketGlobalAllocPreferred, dwOffset ) );
		dprintf( FORMAT_UINT( VER, pver, m_ulVERTasksPostMax, dwOffset ) );
		dprintf( FORMAT_UINT( VER, pver, m_trxBegin0LastLongRunningTransaction, dwOffset ) );
		dprintf( FORMAT_POINTER( VER, pver, m_ppibTrxOldestLastLongRunningTransaction, dwOffset ) );
		dprintf( FORMAT_UINT( VER, pver, m_dwTrxContextLastLongRunningTransaction, dwOffset ) );
		dprintf( "\n" );

		dprintf( "STATISTICS:\n" );
		dprintf( "-----------\n" );
		dprintf( "Bucket size (in bytes): %d (0x%08x)\n", pcresVER->CbBlock(), pcresVER->CbBlock() );
		dprintf( "Global reserved buckets: %d (0x%08x)\n", pcresVER->CBlocksAllocated(), pcresVER->CBlocksAllocated() );
		dprintf( "Global reserved buckets start address: 0x%0*I64x\n", sizeof(BYTE*) * 2, QWORD( pcresVER->PbBlocksAllocated() ) );
		dprintf( "Global reserved buckets committed: %d (0x%08x)\n", pcresVER->CBlockCommit(), pcresVER->CBlockCommit() );
		dprintf( "\n" );

		dprintf( "Scanning buckets for this instance...\n" );
		ULONG_PTR	cBuckets					= 0;
		ULONG_PTR	cBucketsReserved			= 0;
		ULONG_PTR	cBucketsDynamic				= 0;
		ULONG_PTR	cRCETotal					= 0;
		ULONG_PTR	cbRCESizeTotal				= 0;
		ULONG_PTR	cbRCESizeMax				= 0;
		ULONG_PTR	cRCEMoved					= 0;
		ULONG_PTR	cbRCEMoved					= 0;
		ULONG_PTR	cRCEProxy					= 0;
		ULONG_PTR	cbRCEProxy					= 0;
		ULONG_PTR	cRCERolledBack				= 0;
		ULONG_PTR	cbRCERolledBack				= 0;
		ULONG_PTR	cRCENullified				= 0;
		ULONG_PTR	cbRCENullified				= 0;
		ULONG_PTR	cRCEUncommitted				= 0;
		ULONG_PTR	cbRCEUncommitted			= 0;
		ULONG_PTR	cRCECleanable				= 0;
		ULONG_PTR	cbRCECleanable				= 0;
		ULONG_PTR	cRCECleanableFlagDelete		= 0;
		ULONG_PTR	cRCECleanableDelta			= 0;
		ULONG_PTR	cRCECleanableSLVSpace		= 0;
		ULONG_PTR	cRCEUncleanable				= 0;
		ULONG_PTR	cbRCEUncleanable			= 0;
		ULONG_PTR	cRCEUncleanableFlagDelete	= 0;
		ULONG_PTR	cRCEUncleanableDelta		= 0;
		ULONG_PTR	cRCEUncleanableSLVSpace		= 0;

		BUCKET *	pbucket;
		BUCKET *	pbucketDebuggee;
		for ( pbucketDebuggee = pver->m_pbucketGlobalTail;
			NULL != pbucketDebuggee;
			pbucketDebuggee = pbucket->hdr.pbucketNext )
			{

			if ( !FFetchVariable( pbucketDebuggee, &pbucket ) )
				{
				dprintf( "Error: Could not read BUCKET memory. Aborting.\n\n" );
				break;
				}

			//	determine whether bucket was pre-reserved or
			//	dynamically allocated and increment appropriate
			//	counter
			cBuckets++;
			if ( pcresVER->FContains( (BYTE *)pbucketDebuggee ) )
				{
				cBucketsReserved++;
				}
			else
				{
				cBucketsDynamic++;
				}

			//	scan RCE's in this bucket
			const RCE *			prce			= (RCE *)pbucket->rgb;
			const RCE * const	prceNextNew		= (RCE *)( (BYTE *)pbucket->hdr.prceNextNew - (BYTE *)pbucketDebuggee + (BYTE *)pbucket );
			const BYTE * const	pbLastDelete	= pbucket->hdr.pbLastDelete - (BYTE *)pbucketDebuggee + (BYTE *)pbucket;

			while (	prceNextNew != prce )
				{
				const ULONG		cbRCE		= prce->CbRceEDBG();
				const BYTE *	pbNextRce	= reinterpret_cast<BYTE *>( PvAlignForAllPlatforms( (BYTE *)prce + cbRCE ) );

				//	increment total and size counters
				cRCETotal++;
				cbRCESizeTotal += cbRCE;
				cbRCESizeMax = max( cbRCESizeMax, cbRCE );

				//	was RCE moved?
				if ( prce->FMoved() )
					{
					cRCEMoved++;
					cbRCEMoved += cbRCE;
					}

				//	was RCE created by proxy?
				if ( prce->FProxy() )
					{
					cRCEProxy++;
					cbRCEProxy += cbRCE;
					}

				//	was RCE rolled back?
				if ( prce->FRolledBackEDBG() )
					{
					cRCERolledBack++;
					cbRCERolledBack += cbRCE;
					}

				//	determine the state of the RCE and increment
				//	appropriate counters
				if ( prce->FOperNull() )
					{
					cRCENullified++;
					cbRCENullified += cbRCE;
					}
				else if ( trxMax == prce->TrxCommittedEDBG() )
					{
					cRCEUncommitted++;
					cbRCEUncommitted += cbRCE;
					}
				else if ( NULL == ppibTrxOldest
					|| TrxCmp( prce->TrxCommittedEDBG(), ppibTrxOldest->trxBegin0 ) < 0 )
					{
					cRCECleanable++;
					cbRCECleanable += cbRCE;

					switch ( prce->Oper() )
						{
						case operFlagDelete:
							cRCECleanableFlagDelete++;
							break;
						case operDelta:
							cRCECleanableDelta++;
							break;
						case operSLVSpace:
							cRCECleanableSLVSpace++;
							break;
						default:
							break;
						}
					}
				else
					{
					cRCEUncleanable++;
					cbRCEUncleanable += cbRCE;

					switch ( prce->Oper() )
						{
						case operFlagDelete:
							cRCEUncleanableFlagDelete++;
							break;
						case operDelta:
							cRCEUncleanableDelta++;
							break;
						case operSLVSpace:
							cRCEUncleanableSLVSpace++;
							break;
						default:
							break;
						}
					}

				//	move to next RCE, being careful to account
				//	for case where we are on the last moved RCE
				if ( pbNextRce != pbLastDelete )
					{
					prce = (RCE *)pbNextRce;
					}
				else
					{
					prce = (RCE *)( (BYTE *)pbucket->hdr.prceOldest - (BYTE *)pbucketDebuggee + (BYTE *)pbucket );
					}

				}
			}

		dprintf( "  Total buckets in use: %d (0x%0*I64x)\n", cBucketsReserved+cBucketsDynamic, sizeof(ULONG_PTR)*2, QWORD( cBucketsReserved+cBucketsDynamic ) );
		dprintf( "  Reserved buckets: %d (0x%0*I64x)\n", cBucketsReserved, sizeof(ULONG_PTR)*2, QWORD( cBucketsReserved ) );
		dprintf( "  Dynamic buckets: %d (0x%0*I64x)\n", cBucketsDynamic, sizeof(ULONG_PTR)*2, QWORD( cBucketsDynamic ) );
		dprintf( "\n" );

		dprintf( "  Total version store entries: %d (0x%0*I64x)\n", cRCETotal, sizeof(ULONG_PTR)*2, QWORD( cRCETotal ) );
		dprintf( "  Total size of all entries (in bytes): %d (0x%0*I64x)\n", cbRCESizeTotal, sizeof(ULONG_PTR)*2, QWORD( cbRCESizeTotal ) );
		dprintf( "  Max. entry size (in bytes): %d (0x%0*I64x)\n", cbRCESizeMax, sizeof(ULONG_PTR)*2, QWORD( cbRCESizeMax ) );
		dprintf( "  Average entry size (in bytes): %d (0x%0*I64x)\n", ( 0 != cRCETotal ? cbRCESizeTotal/cRCETotal : 0 ), sizeof(ULONG_PTR)*2, QWORD( 0 != cRCETotal ? cbRCESizeTotal/cRCETotal : 0 ) );
		dprintf( "\n" );

		dprintf( "  Entries moved: %d (0x%0*I64x)\n", cRCEMoved, sizeof(ULONG_PTR)*2, QWORD( cRCEMoved ) );
		dprintf( "  Total size of moved entries (in bytes): %d (0x%0*I64x)\n", cbRCEMoved, sizeof(ULONG_PTR)*2, QWORD( cbRCEMoved ) );
		dprintf( "\n" );

		dprintf( "  Entries created by proxy: %d (0x%0*I64x)\n", cRCEProxy, sizeof(ULONG_PTR)*2, QWORD( cRCEProxy ) );
		dprintf( "  Total size of entries created by proxy (in bytes): %d (0x%0*I64x)\n", cbRCEProxy, sizeof(ULONG_PTR)*2, QWORD( cbRCEProxy ) );
		dprintf( "\n" );

		dprintf( "  Entries rolled-back: %d (0x%0*I64x)\n", cRCERolledBack, sizeof(ULONG_PTR)*2, QWORD( cRCERolledBack ) );
		dprintf( "  Total size of rolled-back entries (in bytes): %d (0x%0*I64x)\n", cbRCERolledBack, sizeof(ULONG_PTR)*2, QWORD( cbRCERolledBack ) );
		dprintf( "\n" );

		dprintf( "  Entries nullified: %d (0x%0*I64x)\n", cRCENullified, sizeof(ULONG_PTR)*2, QWORD( cRCENullified ) );
		dprintf( "  Total size of nullified entries (in bytes): %d (0x%0*I64x)\n", cbRCENullified, sizeof(ULONG_PTR)*2, QWORD( cbRCENullified ) );
		dprintf( "\n" );

		dprintf( "  Entries uncommitted: %d (0x%0*I64x)\n", cRCEUncommitted, sizeof(ULONG_PTR)*2, QWORD( cRCEUncommitted ) );
		dprintf( "  Total size of uncommitted entries (in bytes): %d (0x%0*I64x)\n", cbRCEUncommitted, sizeof(ULONG_PTR)*2, QWORD( cbRCEUncommitted ) );
		dprintf( "\n" );

		dprintf( "  Entries committed: %d (0x%0*I64x)\n", cRCECleanable+cRCEUncleanable, sizeof(ULONG_PTR)*2, QWORD( cRCECleanable+cRCEUncleanable ) );
		dprintf( "  Total size of committed entries (in bytes): %d (0x%0*I64x)\n", cbRCECleanable+cbRCEUncleanable, sizeof(ULONG_PTR)*2, QWORD( cbRCECleanable+cbRCEUncleanable ) );
		dprintf( "    Cleanable Entries: %d (0x%0*I64x)\n", cRCECleanable, sizeof(ULONG_PTR)*2, QWORD( cRCECleanable ) );
		dprintf( "    Total size of cleanable entries (in bytes): %d (0x%0*I64x)\n", cbRCECleanable, sizeof(ULONG_PTR)*2, QWORD( cbRCECleanable ) );
		dprintf( "      Cleanable 'FlagDelete' entries: %d (0x%0*I64x)\n", cRCECleanableFlagDelete, sizeof(ULONG_PTR)*2, QWORD( cRCECleanableFlagDelete ) );
		dprintf( "      Cleanable 'Delta' entries: %d (0x%0*I64x)\n", cRCECleanableDelta, sizeof(ULONG_PTR)*2, QWORD( cRCECleanableDelta ) );
		dprintf( "      Cleanable 'SLVSpace' entries:): %d (0x%0*I64x)\n", cRCECleanableSLVSpace, sizeof(ULONG_PTR)*2, QWORD( cRCECleanableSLVSpace ) );
		dprintf( "    Uncleanable Entries: %d (0x%0*I64x)\n", cRCEUncleanable, sizeof(ULONG_PTR)*2, QWORD( cRCEUncleanable ) );
		dprintf( "    Total size of Uncleanable entries (in bytes): %d (0x%0*I64x)\n", cbRCEUncleanable, sizeof(ULONG_PTR)*2, QWORD( cbRCEUncleanable ) );
		dprintf( "      Uncleanable 'FlagDelete' entries: %d (0x%0*I64x)\n", cRCEUncleanableFlagDelete, sizeof(ULONG_PTR)*2, QWORD( cRCEUncleanableFlagDelete ) );
		dprintf( "      Uncleanable 'Delta' entries: %d (0x%0*I64x)\n", cRCEUncleanableDelta, sizeof(ULONG_PTR)*2, QWORD( cRCEUncleanableDelta ) );
		dprintf( "      Uncleanable 'SLVSpace' entries:): %d (0x%0*I64x)\n", cRCEUncleanableSLVSpace, sizeof(ULONG_PTR)*2, QWORD( cRCEUncleanableSLVSpace ) );
		}
	else
		{
		dprintf( "Error: Could not read some version store variables.\n" );
		}

HandleError:
	dprintf( "\n--------------------\n\n" );

	Unfetch( pcresVER );
	Unfetch( pver );
	Unfetch( ppibTrxOldest );
	Unfetch( rgpls );
	Unfetch( pinst );
	}


//  ================================================================
DEBUG_EXT( EDBGMemory )
//  ================================================================
	{
	DWORD			cAllocHeapT;
	DWORD			cFreeHeapT;
	DWORD			cbAllocHeapT;
	DWORD_PTR		cbReservePageT;
	DWORD_PTR		cbCommitPageT;
	LONG			cbPageT;
	LONG_PTR		cbfCacheT;
	SIZE_T			cbHintCacheT;
	SIZE_T			maskHintCacheT;
	ULONG			ipinstMaxT;
	INST **			rgpinst				= NULL;
	CRES *			pcresVER			= NULL;

	dprintf( "\n" );

	if ( FReadGlobal( "cAllocHeap", &cAllocHeapT )
		&& FReadGlobal( "cFreeHeap", &cFreeHeapT )
		&& FReadGlobal( "cbAllocHeap", &cbAllocHeapT )
		&& FReadGlobal( "cbReservePage", &cbReservePageT )
		&& FReadGlobal( "cbCommitPage", &cbCommitPageT )
		&& FReadGlobal( "g_cbPage", &cbPageT )
		&& FReadGlobal( "cbfCache", &cbfCacheT )
		&& FReadGlobal( "CPAGE::cbHintCache", &cbHintCacheT )
		&& FReadGlobal( "CPAGE::maskHintCache", &maskHintCacheT )
		&& FReadGlobal( "ipinstMax", &ipinstMaxT )
		&& ipinstMaxT <= cMaxInstances
		&& FFetchGlobal( "g_rgpinst", &rgpinst, ipinstMaxT )
		&& FReadGlobalAndFetchVariable( "g_pcresVERPool", &pcresVER ) )
		{
		dprintf( "Heap Usage\n" );
		dprintf( "----------\n" );
		dprintf( "  Bytes currently allocated: %d (0x%0*I64x)\n", cbAllocHeapT, sizeof(DWORD_PTR)*2, QWORD( cbAllocHeapT ) );
		dprintf( "  Current allocations: %d (0x%0*I64x)\n", cAllocHeapT - cFreeHeapT, sizeof(DWORD_PTR)*2, QWORD( cAllocHeapT - cFreeHeapT ) );
		dprintf( "  Total allocations (life of instance): %d (0x%0*I64x)\n", cAllocHeapT, sizeof(DWORD_PTR)*2, QWORD( cAllocHeapT ) );
		dprintf( "  Total de-allocations (life of instance): %d (0x%0*I64x)\n", cFreeHeapT, sizeof(DWORD_PTR)*2, QWORD( cFreeHeapT ) );
		dprintf( "\n" );

		dprintf( "Virtual Address Space Usage\n" );
		dprintf( "---------------------------\n" );
		dprintf( "  Bytes reserved: %d (0x%0*I64x)\n", cbReservePageT, sizeof(DWORD_PTR)*2, QWORD( cbReservePageT ) );
		dprintf( "  Bytes committed: %d (0x%0*I64x)\n", cbCommitPageT, sizeof(DWORD_PTR)*2, QWORD( cbCommitPageT ) );
		dprintf( "\n" );


		//	break down virtual address space usage
		//	into its major consumers

		ULONG_PTR	cbucketDynamicAlloc		= 0;
		ULONG_PTR	cbTablesReserved		= 0;
		ULONG_PTR	cbTablesCommitted		= 0;
		ULONG_PTR	cbCursorsReserved		= 0;
		ULONG_PTR	cbCursorsCommitted		= 0;
		ULONG_PTR	cbSessionsReserved		= 0;
		ULONG_PTR	cbSessionsCommitted		= 0;
		ULONG_PTR	cbSortsReserved			= 0;
		ULONG_PTR	cbSortsCommitted		= 0;

		//	sum up individual instance totals to
		//	yield totals for the process

		for ( ULONG i = 0; i < ipinstMaxT; i++ )
			{
			if ( pinstNil == rgpinst[i] )
				continue;

			INST *	pinst		= NULL;
			VER *	pver		= NULL;
			CRES *	pcresFCB	= NULL;
			CRES *	pcresTDB	= NULL;
			CRES *	pcresIDB	= NULL;
			CRES *	pcresSCB	= NULL;
			CRES *	pcresFUCB	= NULL;
			CRES *	pcresPIB	= NULL;

			if ( FFetchVariable( rgpinst[i], &pinst )
				&& FFetchVariable( pinst->m_pver, &pver )
				&& FFetchVariable( pinst->m_pcresFCBPool, &pcresFCB )
				&& FFetchVariable( pinst->m_pcresTDBPool, &pcresTDB )
				&& FFetchVariable( pinst->m_pcresIDBPool, &pcresIDB )
				&& ( 0 == pinst->m_lTemporaryTablesMax || FFetchVariable( pinst->m_pcresSCBPool, &pcresSCB ) )
				&& FFetchVariable( pinst->m_pcresFUCBPool, &pcresFUCB )
				&& FFetchVariable( pinst->m_pcresPIBPool, &pcresPIB ) )
				{
				cbucketDynamicAlloc += pver->m_cbucketDynamicAlloc;

				cbTablesReserved += pcresFCB->CBlocksAllocated() * pcresFCB->CbBlock();
				cbTablesCommitted += pcresFCB->CBlockCommit() * pcresFCB->CbBlock();

				cbTablesReserved += pcresTDB->CBlocksAllocated() * pcresTDB->CbBlock();
				cbTablesCommitted += pcresTDB->CBlockCommit() * pcresTDB->CbBlock();

				cbTablesReserved += pcresIDB->CBlocksAllocated() * pcresIDB->CbBlock();
				cbTablesCommitted += pcresIDB->CBlockCommit() * pcresIDB->CbBlock();

				if ( pinst->m_lTemporaryTablesMax > 0 )
					{
					cbSortsReserved += pcresSCB->CBlocksAllocated() * pcresSCB->CbBlock();
					cbSortsCommitted += pcresSCB->CBlockCommit() * pcresSCB->CbBlock();
					}

				cbCursorsReserved += pcresFUCB->CBlocksAllocated() * pcresFUCB->CbBlock();
				cbCursorsCommitted += pcresFUCB->CBlockCommit() * pcresFUCB->CbBlock();

				cbSessionsReserved += pcresPIB->CBlocksAllocated() * pcresPIB->CbBlock();
				cbSessionsCommitted += pcresPIB->CBlockCommit() * pcresPIB->CbBlock();
				}
			else
				{
				dprintf( "Error: Could not read INST information. Skipped an instance.\n" );
				}

			Unfetch( pcresPIB );
			Unfetch( pcresFUCB );
			Unfetch( pcresSCB );
			Unfetch( pcresIDB );
			Unfetch( pcresTDB );
			Unfetch( pcresFCB );
			Unfetch( pver );
			Unfetch( pinst );
			}

		dprintf( "  Buffer Manager:\n" );
		dprintf( "    Current buffers: %d (0x%0*I64x)\n", cbfCacheT, sizeof(LONG_PTR)*2, QWORD( cbfCacheT ) );
		dprintf( "    Current cache size (in bytes): %d (0x%0*I64x)\n", cbfCacheT * cbPageT, sizeof(LONG_PTR)*2, QWORD( cbfCacheT * cbPageT ) );
		dprintf( "    Current cache overhead (in bytes): %d (0x%0*I64x)\n", cbfCacheT * sizeof(BF), sizeof(LONG_PTR)*2, QWORD( cbfCacheT * sizeof(BF) ) );
		dprintf( "    Committed hint cache size (in bytes): %d (0x%0*I64x)\n", cbHintCacheT, sizeof(SIZE_T)*2, QWORD( cbHintCacheT ) );
		dprintf( "    Hint cache size in use (in bytes): %d (0x%0*I64x)\n", ( maskHintCacheT + 1 ) * sizeof(DWORD_PTR), sizeof(SIZE_T)*2, QWORD( ( maskHintCacheT + 1 ) * sizeof(DWORD_PTR) ) );
		dprintf( "  Version Store:\n" );
		dprintf( "    Pre-reserved bytes: %d (0x%0*I64x)\n", pcresVER->CBlocksAllocated() * pcresVER->CbBlock(), sizeof(ULONG_PTR)*2, QWORD( pcresVER->CBlocksAllocated() * pcresVER->CbBlock() ) );
		dprintf( "    Pre-reserved bytes committed: %d (0x%0*I64x)\n", pcresVER->CBlockCommit() * pcresVER->CbBlock(), sizeof(ULONG_PTR)*2, QWORD( pcresVER->CBlockCommit() * pcresVER->CbBlock() ) );
		dprintf( "    Dynamic bytes committed: %d (0x%0*I64x)\n", cbucketDynamicAlloc * pcresVER->CbBlock(), sizeof(ULONG_PTR)*2, QWORD( cbucketDynamicAlloc * pcresVER->CbBlock() ) );
		dprintf( "  Tables and Indexes (FCB,TDB,IDB):\n" );
		dprintf( "    Bytes reserved: %d (0x%0*I64x)\n", cbTablesReserved, sizeof(ULONG_PTR)*2, QWORD( cbTablesReserved ) );
		dprintf( "    Bytes committed: %d (0x%0*I64x)\n", cbTablesCommitted, sizeof(ULONG_PTR)*2, QWORD( cbTablesCommitted ) );
		dprintf( "  Sorts and Temporary Tables (SCB):\n" );
		dprintf( "    Bytes reserved: %d (0x%0*I64x)\n", cbSortsReserved, sizeof(ULONG_PTR)*2, QWORD( cbSortsReserved ) );
		dprintf( "    Bytes committed: %d (0x%0*I64x)\n", cbSortsCommitted, sizeof(ULONG_PTR)*2, QWORD( cbSortsCommitted ) );
		dprintf( "  Cursors (FUCB):\n" );
		dprintf( "    Bytes reserved: %d (0x%0*I64x)\n", cbCursorsReserved, sizeof(ULONG_PTR)*2, QWORD( cbCursorsReserved ) );
		dprintf( "    Bytes committed: %d (0x%0*I64x)\n", cbCursorsCommitted, sizeof(ULONG_PTR)*2, QWORD( cbCursorsCommitted ) );
		dprintf( "  Sessions (PIB):\n" );
		dprintf( "    Bytes reserved: %d (0x%0*I64x)\n", cbSessionsReserved, sizeof(ULONG_PTR)*2, QWORD( cbSessionsReserved ) );
		dprintf( "    Bytes committed: %d (0x%0*I64x)\n", cbSessionsCommitted, sizeof(ULONG_PTR)*2, QWORD( cbSessionsCommitted ) );
		}
	else
		{
		dprintf( "Error: Could not read some/all memory-related variables.\n" );
		}

	dprintf( "\n--------------------\n\n" );

	Unfetch( pcresVER );
	Unfetch( rgpinst );
	}


//  ================================================================
DEBUG_EXT( EDBGHelpDump )
//  ================================================================
	{
	INT icdumpmap;
	for( icdumpmap = 0; icdumpmap < ccdumpmap; icdumpmap++ )
		{
		dprintf( "\t%s\n", rgcdumpmap[icdumpmap].szHelp );
		}
	dprintf( "\n--------------------\n\n" );
	}


//  ================================================================
DEBUG_EXT( EDBGDump )
//  ================================================================
	{
	if( argc < 2 )
		{
		EDBGHelpDump( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, argv );
		return;
		}

	INT icdumpmap;
	for( icdumpmap = 0; icdumpmap < ccdumpmap; ++icdumpmap )
		{
		if( FArgumentMatch( argv[0], rgcdumpmap[icdumpmap].szCommand ) )
			{
			(rgcdumpmap[icdumpmap].pcdump)->Dump(
				hCurrentProcess,
				hCurrentThread,
				dwCurrentPc,
				lpExtensionApis,
				argc - 1, argv + 1 );
			return;
			}
		}
	EDBGHelpDump( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, argv );
	}


//  ================================================================
template< class _STRUCT>
VOID CDUMPA<_STRUCT>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[]
    )
//  ================================================================
	{
	_STRUCT* ptDebuggee;
	if (	argc != 1 ||
			!FAddressFromSz( argv[ 0 ], &ptDebuggee ) )
		{
		dprintf( "Usage: DUMP <class> <address>\n" );
		return;
		}

	_STRUCT* pt;
	if ( FFetchVariable( ptDebuggee, &pt ) )
		{
		dprintf(	"0x%0*I64X bytes @ 0x%p\n",
					sizeof( size_t ) * 2,
					QWORD( sizeof( _STRUCT ) ),
					ptDebuggee );
		pt->Dump( CPRINTFWDBG::PcprintfInstance(), (BYTE*)ptDebuggee - (BYTE*)pt );
		Unfetch( pt );
		}
	}


//  ================================================================
VOID CDUMPA<CPAGE>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[]
    )
//  ================================================================
	{
	BOOL	fDumpAllocMap 	= fFalse;
	BOOL	fDumpBinary		= fFalse;
	BOOL	fDumpHeader 	= fFalse;
	BOOL	fDumpTags 		= fFalse;
	CHAR *	pchPageSize;

	switch ( argc )
		{
		case 1:
			fDumpHeader = fTrue;	//	no flags, so default is to dump header
			pchPageSize = NULL;
			break;

		case 2:
			fDumpAllocMap 	= ( strpbrk( argv[0], "aA*" ) != NULL );
			fDumpBinary 	= ( strpbrk( argv[0], "bB*" ) != NULL );
			fDumpHeader		= ( strpbrk( argv[0], "hH*" ) != NULL );
			fDumpTags		= ( strpbrk( argv[0], "tT*" ) != NULL );
			pchPageSize		= strpbrk( argv[0], "248" );
			break;

		default:
			dprintf( "Usage: DUMP PAGE [a|b|h|t|*|2|4|8] <address>\n" );
			return;
		}


	LONG	cbPage			= 0;
	BYTE *	rgbPageDebuggee	= NULL;
	BYTE *	rgbPage			= NULL;

	if ( NULL != pchPageSize )
		{
		Assert( '2' == *pchPageSize
			|| '4' == *pchPageSize
			|| '8' == *pchPageSize );
		cbPage = ( *pchPageSize - '0' ) * 1024;

		//	default to header dump if no other dumps specified
		if ( !fDumpAllocMap && !fDumpBinary && !fDumpTags )
			fDumpHeader = fTrue;
		}
	else if ( !FReadGlobal( "g_cbPage", &cbPage ) )
		{
		dprintf( "Error: Could not retrieve g_cbPage from the debuggee.\n" );
		return;
		}

	if ( !FAddressFromSz( argv[argc-1], &rgbPageDebuggee )
		|| !FFetchVariable( rgbPageDebuggee, &rgbPage, cbPage ) )
		{
		dprintf( "Error: Could not retrieve the required data from the debuggee.\n" );
		}
	else
		{
		g_cbPage = cbPage;
		SetCbPageRelated();

		CPAGE cpage;
		cpage.LoadPage( (void*)rgbPage );

		if ( fDumpHeader )
			{
			(VOID)cpage.DumpHeader( CPRINTFWDBG::PcprintfInstance(), rgbPageDebuggee - rgbPage );
			}
		if ( fDumpTags )
			{
			(VOID)cpage.DumpTags( CPRINTFWDBG::PcprintfInstance(), rgbPageDebuggee - rgbPage );
			}
		if ( fDumpAllocMap )
			{
			(VOID)cpage.DumpAllocMap( CPRINTFWDBG::PcprintfInstance() );
			}
		if ( fDumpBinary )
			{
			char* szBuf = (char*)LocalAlloc( 0, g_cbPageMax * 8 );
			if ( szBuf )
				{
				DBUTLSprintHex( (char* const)szBuf, rgbPage, g_cbPage, 16 );

				CHAR* szLine = strtok( (char* const)szBuf, "\n" );
				while ( szLine )
					{
					dprintf( "%s\n", szLine );
					szLine = strtok( NULL, "\n" );
					}

				LocalFree( (void*)szBuf );
				}
			}

		cpage.UnloadPage();
		}

	Unfetch( rgbPage );
	}


//  ================================================================
VOID CDUMPA<REC>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[]
    )
//  ================================================================
	{
	BYTE*	rgbRecDebuggee;
	BYTE*	rgbRec;
	ULONG	cbRec;
	ULONG	cbPage				= 0;

	if (	argc != 2 ||
			!FAddressFromSz( argv[ 0 ], &rgbRecDebuggee ) ||
			!FUlFromSz( argv[ 1 ], &cbRec ) )
		{
		dprintf( "Usage: DUMP REC <address> <length>\n" );
		return;
		}

	else if ( !FFetchVariable( rgbRecDebuggee, &rgbRec, cbRec ) )
		{
		dprintf( "Error: Could not fetch record from debuggee.\n" );
		return;
		}

	else if ( FReadGlobal( "g_cbPage", &cbPage ) )
		{
		g_cbPage = cbPage;
		SetCbPageRelated();
		}

	else
		{
		dprintf( "Warning: Could not retrieve g_cbPage from the debuggee.\n" );
		dprintf( "         Record may not dump properly.\n" );
		}

	dprintf( "\n" );
	DBUTLDumpRec( rgbRec, cbRec, CPRINTFWDBG::PcprintfInstance(), 16 );

	Unfetch( rgbRec );
	}


//  ================================================================
VOID CDUMPA<MEMPOOL>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[]
    )
//  ================================================================
	{
	MEMPOOL *	pmempool;
	MEMPOOL *	pmempoolDebuggee;
	BOOL		fDumpTags		= fFalse;
	BOOL		fDumpAll		= fFalse;
	ULONG		itagDump		= 0;

	dprintf( "\n" );

	if ( argc < 1
		|| argc > 2
		|| !FAddressFromSz( argv[0], &pmempoolDebuggee )
		|| ( ( fDumpTags = ( argc == 2 ) )
			&& !( fDumpAll = ( strpbrk( argv[1], "*" ) != NULL ) )
			&& !FUlFromSz( argv[1], &itagDump ) ) )
		{
		dprintf( "Usage: DUMP MEMPOOL <address> [<itag>|*]\n" );
		return;
		}

	if ( !FFetchVariable( pmempoolDebuggee, &pmempool ) )
		{
		dprintf( "Error: Could not fetch MEMPOOL.\n" );
		return;
		}

	pmempool->Dump(
		CPRINTFWDBG::PcprintfInstance(),
		fDumpTags,
		fDumpAll,
		(MEMPOOL::ITAG)itagDump,
		(BYTE *)pmempoolDebuggee - (BYTE *)pmempool );

	Unfetch( pmempool );
	}


//  ================================================================
VOID CSR::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_INT( CSR, this, m_dbtimeSeen, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CSR, this, m_pgno, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CSR, this, m_iline, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CSR, this, m_latch, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSR, this, m_cpage, dwOffset ) );

	dprintf( "\n\t [CPAGE] 0x%0*I64X bytes @ 0x%p\n",  
			sizeof( size_t ) * 2,
			QWORD( sizeof( CPAGE ) ),
			(char *)this + dwOffset + OffsetOf( CSR, m_cpage )
			);

	(VOID)m_cpage.Dump( CPRINTFWDBG::PcprintfInstance(), dwOffset );
	}


//  ================================================================
VOID RCE::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_UINT( RCE, this, m_trxBegin0, dwOffset ) );

#ifdef NO_BEGIN0_COMMIT0_LOCK
	(*pcprintf)( FORMAT_UINT( RCE, this, m_trxCommittedInactive, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_ptrxCommitted, dwOffset ) );
#else
	(*pcprintf)( FORMAT_UINT( RCE, this, m_trxCommitted, dwOffset ) );
#endif

	(*pcprintf)( FORMAT_UINT( RCE, this, m_rceid, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_updateid, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_uiHash, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_ifmp, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_pgnoFDP, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_pgnoUndoInfo, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( RCE, this, m_pfcb, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_pfucb, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prceUndoInfoNext, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prceUndoInfoPrev, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prceNextOfSession, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prcePrevOfSession, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prceNextOfFCB, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prcePrevOfFCB, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prceNextOfNode, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prcePrevOfNode, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prceHashOverflow, dwOffset ) );

	(*pcprintf)( FORMAT_INT( RCE, this, m_ulFlags, dwOffset ) );

	PRINT_METHOD_FLAG( pcprintf, FOperNull );
	PRINT_METHOD_FLAG( pcprintf, FOperDDL );
	PRINT_METHOD_FLAG( pcprintf, FUndoableLoggedOper );
	PRINT_METHOD_FLAG( pcprintf, FOperInHashTable );
	PRINT_METHOD_FLAG( pcprintf, FOperReplace );
	PRINT_METHOD_FLAG( pcprintf, FOperConcurrent );
	PRINT_METHOD_FLAG( pcprintf, FOperAffectsSecondaryIndex );
	PRINT_METHOD_FLAG( pcprintf, FMoved );
	PRINT_METHOD_FLAG( pcprintf, FProxy );

	(*pcprintf)( FORMAT_INT_BF( RCE, this, m_level, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( RCE, this, m_cbBookmarkKey, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_cbBookmarkData, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_cbData, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_oper, dwOffset ) );

	(*pcprintf)( FORMAT_0ARRAY( RCE, this, m_rgbData, dwOffset ) );
	}


//  ================================================================
VOID FCB::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_precdangling, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_ls, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( FCB, this, m_ptdb, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_pfcbNextIndex, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_pfcbLRU, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_pfcbMRU, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_pfcbNextList, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_pfcbPrevList, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_pfcbTable, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_pidb, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_pfucb, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FCB, this, m_wRefCount, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FCB, this, m_objidFDP, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FCB, this, m_pgnoFDP, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FCB, this, m_pgnoOE, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FCB, this, m_pgnoAE, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FCB, this, m_ifmp, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FCB, this, m_ulFCBListFlags, dwOffset ) );
	PRINT_METHOD_FLAG( pcprintf, FInList );
	PRINT_METHOD_FLAG( pcprintf, FInLRU );

	(*pcprintf)( FORMAT_INT( FCB, this, m_ulFCBFlags, dwOffset ) );
	PRINT_METHOD_FLAG( pcprintf, FTypeDatabase );
	PRINT_METHOD_FLAG( pcprintf, FTypeTable );
	PRINT_METHOD_FLAG( pcprintf, FTypeSecondaryIndex );
	PRINT_METHOD_FLAG( pcprintf, FTypeTemporaryTable );
	PRINT_METHOD_FLAG( pcprintf, FTypeSort );
	PRINT_METHOD_FLAG( pcprintf, FTypeSentinel );
	PRINT_METHOD_FLAG( pcprintf, FTypeLV );
	PRINT_METHOD_FLAG( pcprintf, FTypeSLVAvail );
	PRINT_METHOD_FLAG( pcprintf, FTypeSLVOwnerMap );
	PRINT_METHOD_FLAG( pcprintf, FPrimaryIndex );
	PRINT_METHOD_FLAG( pcprintf, FSequentialIndex );
	PRINT_METHOD_FLAG( pcprintf, FFixedDDL );
	PRINT_METHOD_FLAG( pcprintf, FTemplateTable );
	PRINT_METHOD_FLAG( pcprintf, FDerivedTable );
	PRINT_METHOD_FLAG( pcprintf, FTemplateIndex );
	PRINT_METHOD_FLAG( pcprintf, FDerivedIndex );
	PRINT_METHOD_FLAG( pcprintf, FInitialized );
	PRINT_METHOD_FLAG( pcprintf, FAboveThreshold );
	PRINT_METHOD_FLAG( pcprintf, FDeletePending );
	PRINT_METHOD_FLAG( pcprintf, FDeleteCommitted );
	PRINT_METHOD_FLAG( pcprintf, FUnique );
	PRINT_METHOD_FLAG( pcprintf, FNonUnique );
	PRINT_METHOD_FLAG( pcprintf, FNoCache );
	PRINT_METHOD_FLAG( pcprintf, FPreread );

#ifdef TABLES_PERF
	(*pcprintf)( FORMAT_INT( FCB, this, m_tableclass, dwOffset ) );
#endif  //  TABLES_PERF

	(*pcprintf)( FORMAT_INT( FCB, this, m_cbDensityFree, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( FCB, this, m_prceNewest, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_prceOldest, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( FCB, this, m_ppibDomainDenyRead, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FCB, this, m_crefDomainDenyRead, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FCB, this, m_crefDomainDenyWrite, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FCB, this, m_pgnoNextAvailSE, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_psplitbufdangling, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FCB, this, m_bflPgnoFDP, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( FCB, this, m_bflPgnoOE, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( FCB, this, m_bflPgnoAE, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FCB, this, m_ctasksActive, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FCB, this, m_errInit, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FCB, this, m_critRCEList, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FCB, this, m_sxwl, dwOffset ) );

	}


//  ================================================================
VOID IDB::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_INT( IDB, this, m_crefCurrentIndex, dwOffset ) );

	(*pcprintf)( FORMAT_INT( IDB, this, m_fidbPersisted, dwOffset ) );
	PRINT_METHOD_FLAG( pcprintf, FPrimary );
	PRINT_METHOD_FLAG( pcprintf, FUnique );
	PRINT_METHOD_FLAG( pcprintf, FAllowAllNulls );
	PRINT_METHOD_FLAG( pcprintf, FAllowFirstNull );
	PRINT_METHOD_FLAG( pcprintf, FAllowSomeNulls );
	PRINT_METHOD_FLAG( pcprintf, FNoNullSeg );
	PRINT_METHOD_FLAG( pcprintf, FSortNullsHigh );
	PRINT_METHOD_FLAG( pcprintf, FMultivalued );
	PRINT_METHOD_FLAG( pcprintf, FLocaleId );
	PRINT_METHOD_FLAG( pcprintf, FLocalizedText );
	PRINT_METHOD_FLAG( pcprintf, FTemplateIndex );
	PRINT_METHOD_FLAG( pcprintf, FDerivedIndex );

	(*pcprintf)( FORMAT_INT( IDB, this, m_fidbNonPersisted, dwOffset ) );
	PRINT_METHOD_FLAG( pcprintf, FVersioned );
	PRINT_METHOD_FLAG( pcprintf, FDeleted );
	PRINT_METHOD_FLAG( pcprintf, FVersionedCreate );
	PRINT_METHOD_FLAG( pcprintf, FHasPlaceholderColumn );
	PRINT_METHOD_FLAG( pcprintf, FSparseIndex );
	PRINT_METHOD_FLAG( pcprintf, FSparseConditionalIndex );
	PRINT_METHOD_FLAG( pcprintf, FTuples );

	(*pcprintf)( FORMAT_INT( IDB, this, m_idxunicode.lcid, dwOffset ) );
	(*pcprintf)( FORMAT_INT( IDB, this, m_idxunicode.dwMapFlags, dwOffset ) );
	(*pcprintf)( FORMAT_INT( IDB, this, m_crefVersionCheck, dwOffset ) );
	(*pcprintf)( FORMAT_INT( IDB, this, m_itagIndexName, dwOffset ) );
	(*pcprintf)( FORMAT_INT( IDB, this, m_cbVarSegMac, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( IDB, this, m_cidxseg, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( IDB, this, m_cidxsegConditional, dwOffset ) );
	if ( FIsRgidxsegInMempool() )
		{
		(*pcprintf)( "\tItagRgidxseg: %d\n", ItagRgidxseg() );
		}
	else
		{
		(*pcprintf)( FORMAT_VOID( IDB, this, rgidxseg, dwOffset ) );
		}
	if ( FIsRgidxsegConditionalInMempool() )
		{
		(*pcprintf)( "\tItagRgidxsegConditional: %d\n", ItagRgidxsegConditional() );
		}
	else
		{
		(*pcprintf)( FORMAT_VOID( IDB, this, rgidxsegConditional, dwOffset ) );
		}
	(*pcprintf)( FORMAT_VOID( IDB, this, m_rgbitIdx, dwOffset ) );
	}


//  ================================================================
VOID MEMPOOL::Dump(
	CPRINTF * 		pcprintf,
	const BOOL		fDumpTags,
	const BOOL		fDumpAll,
	const ITAG		itagDump,
	const DWORD_PTR	dwOffset )
//  ================================================================
	{
	(*pcprintf)( FORMAT_POINTER( MEMPOOL, this, m_pbuf, dwOffset ) );
	(*pcprintf)( FORMAT_INT( MEMPOOL, this, m_cbBufSize, dwOffset ) );
	(*pcprintf)( FORMAT_INT( MEMPOOL, this, m_ibBufFree, dwOffset ) );
	(*pcprintf)( FORMAT_INT( MEMPOOL, this, m_itagUnused, dwOffset ) );
	(*pcprintf)( FORMAT_INT( MEMPOOL, this, m_itagFreed, dwOffset ) );

	if ( fDumpTags )
		{
		BYTE *	rgbBufDebuggee	= Pbuf();
		BYTE *	rgbBuf;

		if ( FFetchVariable( rgbBufDebuggee, &rgbBuf, CbBufSize() ) )
			{
			SetPbuf( rgbBuf );

			dprintf( "\n" );
			if ( fDumpAll )
				{
				//	dump the entire mempool
				for ( ITAG itag = 0; itag < ItagUnused(); itag++ )
					{
					DumpTag( pcprintf, itag, rgbBufDebuggee - rgbBuf );
					}
				}
			else
				{
				//	dump just the specified tag
				DumpTag( pcprintf, itagDump, rgbBufDebuggee - rgbBuf );
				}
			dprintf( "\n--------------------\n\n" );
			Unfetch( rgbBuf );
			}
		else
			{
			dprintf( "Error: Could not fetch MEMPOOL buffer.\n" );
			}
		}
	}


//  ================================================================
VOID MEMPOOL::DumpTag( CPRINTF * pcprintf, const ITAG itag, const SIZE_T lOffset ) const
//  ================================================================
	{
	MEMPOOLTAG	* const rgbTags = (MEMPOOLTAG *)Pbuf();
	if( 0 != rgbTags[itag].cb )
		{
		//  this tag is used
		(*pcprintf)( "TAG %3d        address:0x%p    cb:0x%04x    ib:0x%04x\n",
				 	itag, (BYTE *)(&(rgbTags[itag])) + lOffset, rgbTags[itag].cb, rgbTags[itag].ib );
		(*pcprintf)( "\t%s", SzEDBGHexDump( Pbuf() + rgbTags[itag].ib, min( 32, rgbTags[itag].cb ) ) );
		}
	else
		{
		//  this is a free tag
		(*pcprintf)( "TAG %3d (FREE) address:0x%p    cb:0x%04x    ib:0x%04x\n",
				 	itag, (BYTE *)(&(rgbTags[itag])) + lOffset, rgbTags[itag].cb, rgbTags[itag].ib );
		}
	}


//  ================================================================
VOID PIB::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_UINT( PIB, this, trxBegin0, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( PIB, this, trxCommit0, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( PIB, this, m_pinst, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( PIB, this, dwTrxContext, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( PIB, this, m_fFlags, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fUserSession, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fAfterFirstBT, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fRecoveringEndAllSessions, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fOLD, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fSystemCallback, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fCIMCommitted, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fCIMDirty, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fSetAttachDB, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fUseSessionContextForTrxContext, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fBegin0Logged, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fLGWaiting, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fReadOnlyTrx, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fDistributedTrx, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fPreparedToCommitTrx, dwOffset ) );

	(*pcprintf)( FORMAT_INT( PIB, this, m_cInJetAPI, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( PIB, this, prceNewest, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( PIB, this, pfucbOfSession, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( PIB, this, procid, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( PIB, this, rgcdbOpen, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( PIB, this, ptls, dwOffset ) );

	(*pcprintf)( FORMAT_INT( PIB, this, level, dwOffset ) );
	(*pcprintf)( FORMAT_INT( PIB, this, levelBegin, dwOffset ) );
	(*pcprintf)( FORMAT_INT( PIB, this, clevelsDeferBegin, dwOffset ) );
	(*pcprintf)( FORMAT_INT( PIB, this, levelRollback, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( PIB, this, ppibNext, dwOffset ) );

	(*pcprintf)( FORMAT_INT( PIB, this, updateid, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( PIB, this, critCursors, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( PIB, this, grbitsCommitDefault, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( PIB, this, m_ileTrxOldest, dwOffset ) );

	(*pcprintf)( FORMAT_LGPOS( PIB, this, lgposStart, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( PIB, this, lgposCommit0, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( PIB, this, asigWaitLogFlush, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( PIB, this, ppibNextWaitFlush, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( PIB, this, ppibPrevWaitFlush, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( PIB, this, critLogDeferBeginTrx, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( PIB, this, dwSessionContext, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( PIB, this, dwSessionContextThreadId, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( PIB, this, m_pplsTrxOldest, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( PIB, this, critTrx, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( PIB, this, m_pvRecordFormatConversionBuffer, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( PIB, this, m_pMacroNext, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( PIB, this, m_pfucbCache, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( PIB, this, m_cfucbCache, dwOffset ) );

	(*pcprintf)( FORMAT_INT( PIB, this, m_errRollbackFailure, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( PIB, this, m_simplelistRceidDeferred, dwOffset ) );

#ifdef INDEPENDENT_DB_FAILURE
	(*pcprintf)( FORMAT_INT( PIB, this, m_ifmpForceDetach, dwOffset ) );
#endif

#ifdef DTC
	(*pcprintf)( FORMAT_POINTER( PIB, this, m_pvDistributedTrxData, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( PIB, this, m_cbDistributedTrxData, dwOffset ) );
#endif
	}


//  ================================================================
VOID FUCB::Dump( CPRINTF * pcprintf, DWORD_PTR ulBase ) const
//  ================================================================
	{
	if( 0 == ulBase )
		{
		ulBase = reinterpret_cast<DWORD_PTR>( this );
		}

	(*pcprintf)( FORMAT_POINTER( FUCB, this, pvtfndef, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, ppib, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, pfucbNextOfSession, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, u.pfcb, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, u.pscb, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, ifmp, ulBase ) );

	(*pcprintf)( FORMAT_UINT( FUCB, this, ulFlags, ulBase ) );

	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fIndex					, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fSecondary				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fCurrentSecondary		, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fLV					, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fSort					, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fSystemTable			, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fWrite					, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fDenyRead				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fDenyWrite				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fPermitDDL				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fDeferClose			, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fVersioned				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fLimstat				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fInclusive				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fUpper					, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fMayCacheLVCursor		, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fUpdateSeparateLV		, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fDeferredChecksum		, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fAvailExt				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fOwnExt				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fSequential			, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fPreread				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fPrereadForward		, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fPrereadBackward		, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fBookmarkPreviouslySaved, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fTouch					, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fRepair				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fAlwaysRetrieveCopy	, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fNeverRetrieveCopy		, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fTagImplicitOp			, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fSLVOwnerMapNeedUpdate	, ulBase ) );

	(*pcprintf)( FORMAT_VOID( FUCB, this, csr, ulBase ) );

	(*pcprintf)( FORMAT_VOID( FUCB, this, kdfCurr, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, locLogical, ulBase ) );

	(*pcprintf)( FORMAT_INT( FUCB, this, cbBMBuffer, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, pvBMBuffer, ulBase ) );
	(*pcprintf)( FORMAT_VOID( FUCB, this, bmCurr, ulBase ) );
	(*pcprintf)( FORMAT_VOID( FUCB, this, rgbBMCache, ulBase ) );

	(*pcprintf)( FORMAT_POINTER( FUCB, this, pfucbCurIndex, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, pfucbLV, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, pfucbNextOfFile, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, pfucbPrevOfFile, ulBase ) );

	(*pcprintf)( FORMAT_INT( FUCB, this, ispairCurr, ulBase ) );

	(*pcprintf)( FORMAT_INT( FUCB, this, keystat, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, cColumnsInSearchKey, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, fUsingTableSearchKeyBuffer, ulBase ) );
	(*pcprintf)( FORMAT_VOID( FUCB, this, dataSearchKey, ulBase ) );

	(*pcprintf)( FORMAT_INT( FUCB, this, rceidBeginUpdate, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, updateid, ulBase ) );
	(*pcprintf)( FORMAT_UINT( FUCB, this, ulChecksum, ulBase ) );

	(*pcprintf)( FORMAT_INT( FUCB, this, levelOpen, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, levelNavigate, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, levelPrep, ulBase ) );

	(*pcprintf)( FORMAT_INT( FUCB, this, cbstat, ulBase ) );

	(*pcprintf)( FORMAT_VOID( FUCB, this, dataWorkBuf, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, pvWorkBuf, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, pvRCEBuffer, ulBase ) );

	(*pcprintf)( FORMAT_VOID( FUCB, this, rgbitSet, ulBase ) );

	(*pcprintf)( FORMAT_INT( FUCB, this, cpgPreread, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, cpgPrereadNotConsumed, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, cbSequentialDataRead, ulBase ) );

	(*pcprintf)( FORMAT_POINTER( FUCB, this, pfucbTable, ulBase ) );

	(*pcprintf)( FORMAT_POINTER( FUCB, this, pcsrRoot, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, pfucbCacheNext, ulBase ) );

	(*pcprintf)( FORMAT_VOID( FUCB, this, ls, ulBase ) );

	(*pcprintf)( FORMAT_UINT( FUCB, this, ulLTLast, ulBase ) );
	(*pcprintf)( FORMAT_UINT( FUCB, this, ulTotalLast, ulBase ) );
	(*pcprintf)( FORMAT_UINT( FUCB, this, ulLTCurr, ulBase ) );
	(*pcprintf)( FORMAT_UINT( FUCB, this, ulTotalCurr, ulBase ) );
	}


//  ================================================================
VOID TDB::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidTaggedFirst, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidTaggedLastInitial, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidFixedFirst, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidFixedLastInitial, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidVarFirst, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidVarLastInitial, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidTaggedLast, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidFixedLast, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidVarLast, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_itagTableName, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_ibEndFixedColumns, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( TDB, this, m_pfieldsInitial, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( TDB, this, m_pdataDefaultRecord, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( TDB, this, m_pfcbTemplateTable, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( TDB, this, m_pfcbLV, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_ulLongIdLast, dwOffset ) );

	(*pcprintf)( FORMAT_INT( TDB, this, m_fidTaggedLastOfESE97Template, dwOffset ) );

	(*pcprintf)( FORMAT_INT( TDB, this, m_usFlags, dwOffset ) );
	PRINT_METHOD_FLAG( pcprintf, FTemplateTable );
	PRINT_METHOD_FLAG( pcprintf, FESE97TemplateTable );
	PRINT_METHOD_FLAG( pcprintf, FDerivedTable );
	PRINT_METHOD_FLAG( pcprintf, FESE97DerivedTable );
	PRINT_METHOD_FLAG( pcprintf, FTableHasSLVColumn );
	PRINT_METHOD_FLAG( pcprintf, F8BytesAutoInc );
	PRINT_METHOD_FLAG( pcprintf, FTableHasDefault );
	PRINT_METHOD_FLAG( pcprintf, FTableHasNonEscrowDefault );
	PRINT_METHOD_FLAG( pcprintf, FTableHasUserDefinedDefault );
	PRINT_METHOD_FLAG( pcprintf, FInitialisingDefaultRecord );

	(*pcprintf)( FORMAT_INT( TDB, this, m_qwAutoincrement, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidVersion, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidAutoincrement, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_dbkMost, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( TDB, this, m_mempool, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( TDB, this, m_blIndexes, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( TDB, this, m_rgbitAllIndex, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( TDB, this, m_rwlDDL, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( TDB, this, m_pcbdesc, dwOffset ) );
	}


//	CRES dumping

CHAR mpresidsz[ residMax - residMin ][ 16 ] =
	{
	"residFCB",
	"residFUCB",
	"residTDB",
	"residIDB",
	"residPIB",
	"residSCB",
	"residVER",
	};

//  ================================================================
VOID CRES::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_INT( CRES, this, m_cbBlock, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CRES, this, m_cBlocksAllocated, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CRES, this, m_pbBlocksAllocated, dwOffset ) );

	(*pcprintf)( FORMAT_INT( CRES, this, m_cBlockAvail, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CRES, this, m_pbBlockAvail, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CRES, this, m_cBlockCommit, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( CRES, this, m_pinst, dwOffset ) );

	if ( residVER == m_resid )
		{
		(*pcprintf)( FORMAT_INT( CRES, this, m_cBlockCommitThreshold, dwOffset ) );
		(*pcprintf)( FORMAT_INT( CRES, this, m_iBlockToCommit, dwOffset ) );
		}
	else
		{
		(*pcprintf)( FORMAT_POINTER( CRES, this, m_pbPreferredThreshold, dwOffset ) );
		}

	(*pcprintf)( FORMAT_VOID( CRES, this, m_crit, dwOffset ) );
	(*pcprintf)( FORMAT_ENUM( CRES, this, m_resid, dwOffset, mpresidsz, residMin, residMax ) );
	}


//  ================================================================
VOID INST::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_POINTER( INST, this, m_rgEDBGGlobals, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_rgfmp, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_rgpinst, dwOffset ) );

	PRINT_SZ_ON_HEAP( pcprintf, INST, this, m_szInstanceName, dwOffset );
	PRINT_SZ_ON_HEAP( pcprintf, INST, this, m_szDisplayName, dwOffset );
	(*pcprintf)( FORMAT_INT( INST, this, m_iInstance, dwOffset ) );

	(*pcprintf)( FORMAT_INT( INST, this, m_cSessionInJetAPI, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fJetInitialized, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fTermInProgress, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fTermAbruptly, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fSTInit, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fBackupAllowed, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fStopJetService, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_errInstanceUnavailable, dwOffset ) );

	(*pcprintf)( FORMAT_INT( INST, this, m_lSessionsMax, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lVerPagesMax, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lVerPagesPreferredMax, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fPreferredSetByUser, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lOpenTablesMax, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lOpenTablesPreferredMax, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lTemporaryTablesMax, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lCursorsMax, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lLogBuffers, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lLogFileSize, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fSetLogFileSize, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lLogFileSizeDuringRecovery, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fUseRecoveryLogFileSize, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_cpgSESysMin, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lPageFragment, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_cpageTempDBMin, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_grbitsCommitDefault, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pfnRuntimeCallback, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( INST, this, m_chIndexTuplesLengthMin, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( INST, this, m_chIndexTuplesLengthMax, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( INST, this, m_chIndexTuplesToIndexMax, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( INST, this, m_ulParams, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( INST, this, m_fTempTableVersioning, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( INST, this, m_fCreatePathIfNotExist, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( INST, this, m_fCleanupMismatchedLogFiles, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( INST, this, m_fNoInformationEvent, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( INST, this, m_fSLVProviderEnabled, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL_BF( INST, this, m_fEnableIndexChecking, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( INST, this, m_fEnableIndexCleanup, dwOffset ) );

	(*pcprintf)( FORMAT_INT( INST, this, m_fOLDLevel, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lEventLoggingLevel, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( INST, this, m_idxunicodeDefault, dwOffset ) );

	(*pcprintf)( FORMAT_SZ( INST, this, m_szSystemPath, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( INST, this, m_szTempDatabase, dwOffset ) );

	(*pcprintf)( FORMAT_SZ( INST, this, m_szEventSource, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( INST, this, m_szEventSourceKey, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( INST, this, m_critLV, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_ppibLV, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_plog, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pver, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( INST, this, m_mpdbidifmp, dwOffset ) );

	(*pcprintf)( FORMAT_INT( INST, this, m_updateid, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( INST, this, m_critPIB, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_pcresPIBPool, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_ppibGlobal, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_ppibGlobalMin, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_ppibGlobalMax, dwOffset ) );

	(*pcprintf)( FORMAT_INT( INST, this, m_trxNewest, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_pcresFCBPool, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pcresTDBPool, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pcresIDBPool, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_cFCBPreferredThreshold, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_pfcbhash, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( INST, this, m_critFCBList, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pfcbList, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pfcbAvailBelowMRU, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pfcbAvailBelowLRU, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pfcbAvailAboveMRU, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pfcbAvailAboveLRU, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( INST, this, m_cFCBAvail, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( INST, this, m_cFCBAboveThresholdSinceLastPurge, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( INST, this, m_critFCBCreate, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_pcresFUCBPool, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pcresSCBPool, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( INST, this, m_fFlushLogForCleanThread, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_pbAttach, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( INST, this, m_taskmgr, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_cOpenedSystemPibs, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_cUsedSystemPibs, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_rgoldstatDB, dwOffset ) );

	(*pcprintf)( FORMAT_INT( INST, this, m_lSLVDefragFreeThreshold, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lSLVDefragMoveThreshold, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_pfsapi, dwOffset ) );

	(*pcprintf)( FORMAT_INT( INST, this, m_cNonLoggedIndexCreators, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_plnppibBegin, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_plnppibEnd, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( INST, this, m_critLNPPIB, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( INST, this, m_cpls, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_rgpls, dwOffset ) );


	// m_mpdbidifmp

	FMP *		rgfmpDebuggee;
	IFMP		ifmpMaxDebuggee		= ifmpMax;
	const BOOL	fReadGlobals		= ( FReadGlobal( "rgfmp", &rgfmpDebuggee )
										&& FReadGlobal( "ifmpMax", &ifmpMaxDebuggee ));

	(*pcprintf)( "\t\tDatabases:\n" );

	for ( DBID dbid = 0; dbid < dbidMax; dbid++ )
		{
		//	UNDONE: what's the correct value to use
		//	if we can't read ifmpMax from the
		//	debuggee
		if ( m_mpdbidifmp[dbid] < ifmpMaxDebuggee )
			{
			(*pcprintf)( "\t\t\t [%d] = IFMP:0x%x (FMP:",
							dbid,
							m_mpdbidifmp[dbid] );
			if ( fReadGlobals )
				{
				(*pcprintf)( "0x%p)\n", rgfmpDebuggee + m_mpdbidifmp[dbid] );
				}
			else
				{
				(*pcprintf)( "\?\?\?)\n" );
				}
			}
		}

	dprintf( "\n--------------------\n\n" );
	}


//  ================================================================
VOID FMP::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	PRINT_SZ_ON_HEAP( pcprintf, FMP, this, m_szDatabaseName, dwOffset );
	(*pcprintf)( FORMAT_POINTER( FMP, this, m_pinst, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_dbid, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( FMP, this, m_fFlags, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fCreatingDB, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fAttachingDB, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fDetachingDB, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fExclusiveOpen, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fReadOnlyAttach, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fLogOn, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fVersioningOff, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fSkippedAttach, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fAttached, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fDeferredAttach, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fRunningOLD, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fInBackupSession, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fAllowForceDetach, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fForceDetaching, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fRedoSLVProviderNotEnabled, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fDuringSnapshot, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fAllowHeaderUpdate, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fDefragSLVCopy, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fCopiedPatchHeader, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FMP, this, m_dbtimeLast, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_dbtimeOldestGuaranteed, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_dbtimeOldestCandidate, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_dbtimeOldestTarget, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( FMP, this, m_trxOldestCandidate, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( FMP, this, m_trxOldestTarget, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FMP, this, m_objidLast, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FMP, this, m_ctasksActive, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( FMP, this, m_pfapi, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FMP, this, m_pdbfilehdr, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_critLatch, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( FMP, this, m_gateWriteLatch, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( FMP, this, m_cbFileSize, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( FMP, this, m_semExtendingDB, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( FMP, this, m_semIOExtendDB, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FMP, this, m_cPin, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_crefWriteLatch, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FMP, this, m_ppibWriteLatch, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FMP, this, m_ppibExclusiveOpen, dwOffset ) );

	(*pcprintf)( FORMAT_LGPOS( FMP, this, m_lgposAttach, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( FMP, this, m_lgposDetach, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_rwlDetaching, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( FMP, this, m_trxNewestWhenDiscardsLastReported, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_cpgDatabaseSizeMax, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_pgnoMost, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_pgnoCopyMost, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_semRangeLock, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( FMP, this, m_msRangeLock, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_rgprangelock, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_rgdwBFContext, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_rwlBFContext, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_ileBFICleanList, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( FMP, this, m_fBFICleanFlags, dwOffset ) );
	PRINT_METHOD_FLAG( pcprintf, FBFICleanDb );
	PRINT_METHOD_FLAG( pcprintf, FBFICleanSLV );

	(*pcprintf)( FORMAT_INT( FMP, this, m_errPatch, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_cpagePatch, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_cPatchIO, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FMP, this, m_pfapiPatch, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( FMP, this, m_ppatchhdr, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FMP, this, m_dbtimeCurrentDuringRecovery, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_dbtimeUndoForceDetach, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FMP, this, m_dbtimeLastScrub, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( FMP, this, m_logtimeScrub, dwOffset ) );

	PRINT_SZ_ON_HEAP( pcprintf, FMP, this, m_szPatchPath, dwOffset );

	(*pcprintf)( FORMAT_POINTER( FMP, this, m_patchchk, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FMP, this, m_patchchkRestored, dwOffset ) );

#ifdef DISABLE_SLV
#else

 	(*pcprintf)( FORMAT_POINTER( FMP, this, m_pslvspacenodecache, dwOffset ) );

	PRINT_SZ_ON_HEAP( pcprintf, FMP, this, m_szSLVName, dwOffset );
	PRINT_SZ_ON_HEAP( pcprintf, FMP, this, m_szSLVRoot, dwOffset );

	(*pcprintf)( FORMAT_POINTER( FMP, this, m_pfapiSLV, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FMP, this, m_slvrootSLV, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( FMP, this, m_pfcbSLVAvail, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FMP, this, m_pfcbSLVOwnerMap, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_cbSLVFileSize, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_rwlSLVSpace, dwOffset ) );

	(*pcprintf)(	"\t%*.*s <0x%0*I64x,%3i>:  \n",
					SYMBOL_LEN_MAX,
					SYMBOL_LEN_MAX,
					"m_rgcslvspaceoper",
					sizeof( char* ) * 2,
					QWORD( (char*)this + dwOffset + OffsetOf( FMP, m_rgcslvspaceoper ) ),
					sizeof( (this)->m_rgcslvspaceoper ) );
	(*pcprintf)(	"\t\t\t\tSLV Space Operation Summary:\n" );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"slvspaceoperFreeToReserved",
					m_rgcslvspaceoper[ slvspaceoperFreeToReserved ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"slvspaceoperReservedToCommitted",
					m_rgcslvspaceoper[ slvspaceoperReservedToCommitted ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"slvspaceoperFreeToCommitted",
					m_rgcslvspaceoper[ slvspaceoperFreeToCommitted ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"slvspaceoperCommittedToDeleted",
					m_rgcslvspaceoper[ slvspaceoperCommittedToDeleted ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"slvspaceoperDeletedToFree",
					m_rgcslvspaceoper[ slvspaceoperDeletedToFree ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"slvspaceoperFree",
					m_rgcslvspaceoper[ slvspaceoperFree ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"slvspaceoperFreeReserved",
					m_rgcslvspaceoper[ slvspaceoperFreeReserved ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"slvspaceoperDeletedToCommitted",
					m_rgcslvspaceoper[ slvspaceoperDeletedToCommitted ] );
	(*pcprintf)(	"\t%*.*s <0x%0*I64x,%3i>:  \n",
					SYMBOL_LEN_MAX,
					SYMBOL_LEN_MAX,
					"m_rgcslvspace",
					sizeof( char* ) * 2,
					QWORD( (char*)this + dwOffset + OffsetOf( FMP, m_rgcslvspace ) ),
					sizeof( (this)->m_rgcslvspace ) );

	(*pcprintf)(	"\t\t\t\tSLV Space Summary:\n" );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"sFree",
					m_rgcslvspace[ SLVSPACENODE::sFree ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"sReserved",
					m_rgcslvspace[ SLVSPACENODE::sReserved ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"sDeleted",
					m_rgcslvspace[ SLVSPACENODE::sDeleted ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"sCommitted",
					m_rgcslvspace[ SLVSPACENODE::sCommitted ] );
#endif	//	DISABLE_SLV
	}

//  ================================================================
VOID LOG::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pinst, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fLogInitialized, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fLogDisabled, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fLogDisabledDueToRecoveryFailure, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fNewLogRecordAdded, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fLGNoMoreLogWrite, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_errNoMoreLogWrite, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_ls, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fLogSequenceEnd, dwOffset ) );

	(*pcprintf)( FORMAT_INT( LOG, this, m_errCheckpointUpdate, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposCheckpointUpdateError, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fRecovering, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_fRecoveringMode, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fHardRestore, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_fRestoreMode, dwOffset ) );

	(*pcprintf)( FORMAT_INT( LOG, this, m_fSnapshotMode, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposSnapshotStart, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fLGCircularLogging, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fLGFMPLoaded, dwOffset ) );

#ifdef UNLIMITED_DB
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pbLGDbListBuffer, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_cbLGDbListBuffer, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_cbLGDbListInUse, dwOffset ) );
	(*pcprintf)( FORMAT_UINT_BF( LOG, this, m_cLGAttachments, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( LOG, this, m_fLGNeedToLogDbList, dwOffset ) );
#endif

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fAlternateDbDirDuringRecovery, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( LOG, this, m_szAlternateDbDirDuringRecovery, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( LOG, this, m_signLog, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fSignLogSet, dwOffset ) );

	(*pcprintf)( FORMAT_SZ( LOG, this, m_szRecovery, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( LOG, this, m_csecLGFile, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_csecLGBuf, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fLGIgnoreVersion, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pfapiLog, dwOffset ) );

	(*pcprintf)( FORMAT_SZ( LOG, this, m_szBaseName, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( LOG, this, m_szJet, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( LOG, this, m_szJetLog, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( LOG, this, m_szJetLogNameTemplate, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( LOG, this, m_szJetTmp, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( LOG, this, m_szJetTmpLog, dwOffset ) );

	(*pcprintf)( FORMAT_SZ( LOG, this, m_szLogName, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( LOG, this, m_szLogFilePath, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fCreateAsynchLogFile, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pfapiJetTmpLog, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fCreateAsynchResUsed, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_errCreateAsynch, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_asigCreateAsynchIOCompleted, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_ibJetTmpLog, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposCreateAsynchTrigger, dwOffset ) );

	PRINT_SZ_ON_HEAP( pcprintf, LOG, this, m_szLogCurrent, dwOffset );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_plgfilehdr, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_plgfilehdrT, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pbLGBufMin, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pbLGBufMax, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_osmmLGBuf, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( LOG, this, m_cbLGBuf, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pbEntry, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pbWrite, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_isecWrite, dwOffset ) );

	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposLogRec, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposToFlush, dwOffset ) );

	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposMaxFlushPoint, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pbLGFileEnd, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_isecLGFileEnd, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pbLastChecksum, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposLastChecksum, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fHaveShadow, dwOffset ) );

	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposStart, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposRecoveryUndo, dwOffset ) );

	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposFullBackup, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_logtimeFullBackup, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposIncBackup, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_logtimeIncBackup, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( LOG, this, m_cbSec, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_cbSecVolume, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_csecHeader, dwOffset ) );

	(*pcprintf)( FORMAT_INT( LOG, this, m_fLGFlushWait, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_msLGTaskExec, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_asigLogFlushDone, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fLGFailedToPostFlushTask, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( LOG, this, m_critLGResFiles, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_critLGFlush, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_critLGBuf, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_critLGTrace, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_critLGWaitQ, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_ppibLGFlushQHead, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_ppibLGFlushQTail, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( LOG, this, m_cLGWrapAround, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pcheckpoint, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_critCheckpoint, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fDisableCheckpoint, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fReplayingReplicatedLogFiles, dwOffset ) );
#ifdef IGNORE_BAD_ATTACH
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fReplayingIgnoreMissingDB, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_rceidLast, dwOffset ) );
#endif

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pbNext, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pbRead, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_isecRead, dwOffset ) );

	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposRedo, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposLastRec, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fAbruptEnd, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_plread, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( LOG, this, m_lrstatePreread, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposPbNextPreread, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposLastChecksumPreread, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_cPagesPrereadInitial, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_cPagesPrereadThreshold, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_cPagesPrereadAmount, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_cPageRefsConsumed, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fPreread, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_rgpgnoLast, dwOffset ) );

	(*pcprintf)( FORMAT_INT( LOG, this, m_errGlobalRedoError, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( LOG, this, m_fAfterEndAllSessions, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( LOG, this, m_fLastLRIsShutdown, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( LOG, this, m_fNeedInitialDbList, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposRedoShutDownMarkGlobal, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_rgcppib, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pcppibAvail, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_ccppib, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_ptablehfhash, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( LOG, this, m_critBackupInProgress, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fBackupInProgress, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fStopBackup, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposFullBackupMark, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_logtimeFullBackupMark, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_lgenCopyMic, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_lgenCopyMac, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_lgenDeleteMic, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_lgenDeleteMac, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_ppibBackup, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fBackupFull, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fBackupSnapshot, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fBackupBeginNewLogFile, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_rgppatchlst, dwOffset ) );

	(*pcprintf)( FORMAT_SZ( LOG, this, m_szRestorePath, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( LOG, this, m_szNewDestination, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_rgrstmap, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_irstmapMac, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_fBackupStatus, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fScrubDB, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pscrubdb, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_ulSecsStartScrub, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_dbtimeLastScrubNew, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fExternalRestore, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_lGenLowRestore, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_lGenHighRestore, dwOffset ) );

	(*pcprintf)( FORMAT_SZ( LOG, this, m_szTargetInstanceLogPath, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_lGenHighTargetInstance, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pcheckpointDeleted, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fDumppingLogs, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pttFirst, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pttLast, dwOffset ) );

#ifdef DEBUG
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposLastLogRec, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_dwDBGLogThreadId, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fDBGTraceLog, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fDBGTraceLogWrite, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fDBGFreezeCheckpoint, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fDBGTraceRedo, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fDBGTraceBR, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fDBGNoLog, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_cbDBGCopied, dwOffset ) );
#endif

	(*pcprintf)( FORMAT_VOID( LOG, this, m_rgrhf, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_crhfMac, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_cNOP, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fDeleteOldLogs, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fDeleteOutOfRangeLogs, dwOffset ) );
	}


//  ================================================================
VOID VER::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_POINTER( VER, this, m_pinst, dwOffset ) );

	(*pcprintf)( FORMAT_INT( VER, this, m_fVERCleanUpWait, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( VER, this, m_ulVERTasksPostMax, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( VER, this, m_tickLastRCEClean, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( VER, this, m_msigRCECleanPerformedRecently, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( VER, this, m_asigRCECleanDone, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( VER, this, m_critRCEClean, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( VER, this, m_critBucketGlobal, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( VER, this, m_pbucketGlobalHead, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( VER, this, m_pbucketGlobalTail, dwOffset ) );
	(*pcprintf)( FORMAT_INT( VER, this, m_cbucketGlobalAlloc, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( VER, this, m_cbucketDynamicAlloc, dwOffset ) );
	(*pcprintf)( FORMAT_INT( VER, this, m_cbucketGlobalAllocMost, dwOffset ) );
	(*pcprintf)( FORMAT_INT( VER, this, m_cbucketGlobalAllocPreferred, dwOffset ) );

#ifdef MOVEABLE_RCE
	(*pcprintf)( FORMAT_POINTER( VER, this, m_pbucketGlobalLastDelete, dwOffset ) );
	(*pcprintf)( FORMAT_INT( VER, this, m_cbucketGlobalAllocDelete, dwOffset ) );
#endif

	(*pcprintf)( FORMAT_POINTER( VER, this, m_ppibRCEClean, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( VER, this, m_ppibRCECleanCallback, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( VER, this, m_ppibTrxOldestLastLongRunningTransaction, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( VER, this, m_dwTrxContextLastLongRunningTransaction, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( VER, this, m_trxBegin0LastLongRunningTransaction, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( VER, this, m_fSyncronousTasks, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( VER, this, m_pcresVERPool, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( VER, this, m_rgrceheadHashTable, dwOffset ) );
	}


//  ================================================================
DEBUG_EXT( EDBGDumpAllFMPs )
//  ================================================================
	{
	FMP *	rgfmpDebuggee		= NULL;
	ULONG 	ifmpMaxDebuggee;
	BOOL	fDumpAll			= fFalse;
	BOOL	fValidUsage;

	switch ( argc )
		{
		case 0:
			//	use defaults
			fValidUsage = fTrue;
			break;
		case 1:
			//	'*' only
			fValidUsage = ( '*' == argv[0][0] );
			break;
		case 2:
			//	<rgfmp> and <ifmpMax>
			fValidUsage = ( FAddressFromSz( argv[0], &rgfmpDebuggee )
							&& FUlFromSz( argv[1], &ifmpMaxDebuggee ) );
			break;
		case 3:
			if ( '*' == argv[0][0] )
				{
				//	'*' followed by <rgfmp> and <ifmpMax>
				fDumpAll = fTrue;
				fValidUsage = ( FAddressFromSz( argv[1], &rgfmpDebuggee )
								&& FUlFromSz( argv[2], &ifmpMaxDebuggee ) );
				}
			else if ( '*' == argv[2][0] )
				{
				//	<rgfmp> and <ifmpMax> followed by '*'
				fDumpAll = fTrue;
				fValidUsage = ( FAddressFromSz( argv[0], &rgfmpDebuggee )
								&& FUlFromSz( argv[1], &ifmpMaxDebuggee ) );
				}
			else
				{
				//	neither first nor third argument is a '*', so must be an error
				fValidUsage = fFalse;
				}
			break;
		default:
			fValidUsage = fFalse;
			break;
		}

	if ( !fValidUsage )
		{
		dprintf( "Usage: DUMPFMPS [<rgfmp> <ifmpMax>] [*]\n" );
		return;
		}

	if ( NULL == rgfmpDebuggee )
		{
		if ( !FReadGlobal( "rgfmp", &rgfmpDebuggee )
			|| !FReadGlobal( "ifmpMax", &ifmpMaxDebuggee ) )
			{
			dprintf( "Error: Could not fetch FMP variables.\n" );
			return;
			}
		}

	dprintf( "\nScanning 0x%X FMPs starting at 0x%p...\n", ifmpMaxDebuggee, rgfmpDebuggee );

	for ( IFMP ifmp = 0; ifmp < ifmpMaxDebuggee; ifmp++ )
		{
		FMP *	pfmp				= NULL;
		CHAR *	szDatabaseName		= NULL;

		if ( !FFetchVariable( rgfmpDebuggee + ifmp, &pfmp ) ||
			( pfmp->FInUse() && !FFetchSz( pfmp->SzDatabaseName(), &szDatabaseName ) ) )
			{
			dprintf(	"\n rgfmp[0x%x]  Error: Could not fetch FMP at 0x%p. Aborting.\n",
						ifmp,
						rgfmpDebuggee + ifmp );

			//	force out of loop
			ifmp = ifmpMaxDebuggee;
			}
		else
			{
			if ( szDatabaseName || fDumpAll )
				{
				dprintf(	"\n rgfmp[0x%x]  (FMP 0x%p)\n",
							ifmp,
							rgfmpDebuggee + ifmp );
				dprintf(	"           \t %*.*s : %s\n",
							SYMBOL_LEN_MAX,
							SYMBOL_LEN_MAX,
							"m_szDatabaseName",
							szDatabaseName );
				dprintf(	"           \t %*.*s : 0x%p\n",
							SYMBOL_LEN_MAX,
							SYMBOL_LEN_MAX,
							"m_pinst",
							pfmp->Pinst() );
				}
			}

		Unfetch( pfmp );
		Unfetch( szDatabaseName );
		}

	dprintf( "\n--------------------\n\n" );
	}

//  ================================================================
DEBUG_EXT( EDBGDumpAllINSTs )
//  ================================================================
	{
	INST **		rgpinstDebuggee		= NULL;
	INST **		rgpinst				= NULL;

	if ( 0 != argc
		&& ( 1 != argc || !FAddressFromSz( argv[0], &rgpinstDebuggee ) ) )
		{
		dprintf( "Usage: DUMPINSTS [<g_rgpinst>]\n" );
		return;
		}

	if ( ( NULL == rgpinstDebuggee && !FAddressFromGlobal( "g_rgpinst", &rgpinstDebuggee ) )
		|| !FFetchVariable( rgpinstDebuggee, &rgpinst, cMaxInstances ) )
		{
		dprintf( "Error: Could not fetch instance table.\n" );
		return;
		}

	dprintf( "\nScanning 0x%X INST's starting at 0x%p...\n", cMaxInstances, rgpinstDebuggee );

	for ( SIZE_T ipinst = 0; ipinst < cMaxInstances; ipinst++ )
		{
		if ( rgpinst[ipinst] != pinstNil )
			{
			INST *	pinst			= NULL;
			CHAR *	szInstanceName	= NULL;

			if ( !FFetchVariable( rgpinst[ ipinst ], &pinst )
				|| ( pinst->m_szInstanceName && !FFetchSz( pinst->m_szInstanceName, &szInstanceName ) ) )
				{
				dprintf(	"\n g_rgpinst[0x%x]  Error: Could not fetch INST at 0x%p. Aborting.\n",
							ipinst,
							rgpinst[ipinst] );

				//	force out of loop
				ipinst = cMaxInstances;
				}
			else
				{
				dprintf(	"\n g_rgpinst[0x%x]  (INST 0x%p)\n",
							ipinst,
							rgpinst[ipinst] );
				dprintf(	"              \t %*.*s : %s\n",
							SYMBOL_LEN_MAX,
							SYMBOL_LEN_MAX,
							"m_szInstanceName",
							szInstanceName );
				dprintf(	"              \t %*.*s : %s\n",
							SYMBOL_LEN_MAX,
							SYMBOL_LEN_MAX,
							"m_szSystemPath",
							pinst->m_szSystemPath );
				dprintf(	"              \t %*.*s : %s\n",
							SYMBOL_LEN_MAX,
							SYMBOL_LEN_MAX,
							"m_szTempDatabase",
							pinst->m_szTempDatabase );
				dprintf(	"              \t %*.*s : 0x%p\n",
							SYMBOL_LEN_MAX,
							SYMBOL_LEN_MAX,
							"m_pver",
							pinst->m_pver );
				dprintf(	"              \t %*.*s : 0x%p\n",
							SYMBOL_LEN_MAX,
							SYMBOL_LEN_MAX,
							"m_plog",
							pinst->m_plog );
				dprintf(	"              \t %*.*s : 0x%p\n",
							SYMBOL_LEN_MAX,
							SYMBOL_LEN_MAX,
							"m_pfsapi",
							pinst->m_pfsapi );
				}

			Unfetch( pinst );
			Unfetch( szInstanceName );
			}
		}

	dprintf( "\n--------------------\n\n" );

	Unfetch( rgpinst );
	}


// =========================================================================
VOID UtilUpdateSymPath(
	const HANDLE hCurrentProcess,
	const char * szSymPathIn
	)
// =========================================================================
	{
	char szNewSymPath[_MAX_PATH];

	strncpy( szNewSymPath, szSymPathIn, _MAX_PATH );
	szNewSymPath[_MAX_PATH-1] = 0;

	if ( !pfnSymSetSearchPath( hCurrentProcess, szNewSymPath ) )
		{
		dprintf( "Updating sympath failed\n" );
		}

	if ( SymLoadAllModules( hCurrentProcess, fTrue ) )
		{
		pfnSymGetSearchPath(hCurrentProcess, szNewSymPath, sizeof( szNewSymPath ));
		dprintf( "SYMPATH: %s\n", szNewSymPath );
		}
	else
		{
		dprintf("Reload Modules Failed \n");
		}
	}



// =========================================================================
DEBUG_EXT( EDBGSympath )
// =========================================================================
	{
	if ( 0 == argc )  // dump current sympath
		{
		char szOldSympath[_MAX_PATH];

		if ( pfnSymGetSearchPath(hCurrentProcess, szOldSympath, sizeof( szOldSympath ) ) )
			{
			dprintf( "SYMPATH: %s\n", szOldSympath );
			}
		else
			{
			dprintf("Unable to dump the current sympath\n");
			}
		}
	else if ( 1 == argc )
		{
		UtilUpdateSymPath( hCurrentProcess, argv[0] );
		}
	else 	// print usage error
		{
		dprintf( "Usage: SYMPATH [<pathname>]\n" );
		}
	}


//	SPLIT dumping

CHAR mpsplittypesz[ splittypeMax - splittypeMin ][ 32 ] =
	{
	"splittypeVertical",
	"splittypeRight",
	"splittypeAppend",
	};

CHAR mpsplitopersz[ splitoperMax - splitoperMin ][ 64 ] =
	{
	"splitoperNone",
	"splitoperInsert",
	"splitoperReplace",
	"splitoperFlagInsertAndReplaceData",
	};

//  ================================================================
VOID CDUMPA<SPLIT>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[]
    )
//  ================================================================
	{
	SPLIT *		psplitDebuggee		= NULL;
	SPLIT *		psplit				= NULL;

	if ( argc != 1 || !FAddressFromSz( argv[0], &psplitDebuggee ) )
		{
		dprintf( "Usage: DUMP SPLIT <address>\n" );
		return;
		}

	if ( FFetchVariable( psplitDebuggee, &psplit ) )
		{
		const SIZE_T	dwOffset	= (BYTE *)psplitDebuggee - (BYTE *)psplit;

		dprintf(	"[SPLIT] 0x%0*I64X bytes @ 0x%p\n",
					sizeof( size_t ) * 2,
					QWORD( sizeof( SPLIT ) ),
					psplitDebuggee );

		dprintf( FORMAT_VOID( SPLIT, psplit, csrNew, dwOffset ) );
		dprintf( FORMAT_VOID( SPLIT, psplit, csrRight, dwOffset ) );
		dprintf( FORMAT_UINT( SPLIT, psplit, pgnoSplit, dwOffset ) );
		dprintf( FORMAT_UINT( SPLIT, psplit, pgnoNew, dwOffset ) );
		dprintf( FORMAT_INT( SPLIT, psplit, dbtimeRightBefore, dwOffset ) );
		dprintf( FORMAT_ENUM( SPLIT, psplit, splittype, dwOffset, mpsplittypesz, splittypeMin, splittypeMax ) );
		dprintf( FORMAT_POINTER( SPLIT, psplit, psplitPath, dwOffset ) );
		dprintf( FORMAT_ENUM( SPLIT, psplit, splitoper, dwOffset, mpsplitopersz, splitoperMin, splitoperMax ) );
		dprintf( FORMAT_INT( SPLIT, psplit, ilineOper, dwOffset ) );
		dprintf( FORMAT_INT( SPLIT, psplit, clines, dwOffset ) );
		dprintf( FORMAT_UINT( SPLIT, psplit, fNewPageFlags, dwOffset ) );
		dprintf( FORMAT_UINT( SPLIT, psplit, fSplitPageFlags, dwOffset ) );
		dprintf( FORMAT_INT( SPLIT, psplit, cbUncFreeDest, dwOffset ) );
		dprintf( FORMAT_INT( SPLIT, psplit, cbUncFreeSrc, dwOffset ) );
		dprintf( FORMAT_INT( SPLIT, psplit, ilineSplit, dwOffset ) );
		dprintf( FORMAT_VOID( SPLIT, psplit, prefixinfoSplit, dwOffset ) );
		dprintf( FORMAT_VOID( SPLIT, psplit, prefixSplitOld, dwOffset ) );
		dprintf( FORMAT_VOID( SPLIT, psplit, prefixSplitNew, dwOffset ) );
		dprintf( FORMAT_VOID( SPLIT, psplit, prefixinfoNew, dwOffset ) );
		dprintf( FORMAT_VOID( SPLIT, psplit, kdfParent, dwOffset ) );
		dprintf( FORMAT_BOOL_BF( SPLIT, psplit, fAllocParent, dwOffset ) );
		dprintf( FORMAT_BOOL_BF( SPLIT, psplit, fHotpoint, dwOffset ) );
		dprintf( FORMAT_POINTER( SPLIT, psplit, rglineinfo, dwOffset ) );

		Unfetch( psplit );
		}
	}

// SPLITPATH dumping
//  ================================================================
VOID CDUMPA<SPLITPATH>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[]
    )
//  ================================================================
	{
	SPLITPATH *		psplitpathDebuggee	= NULL;
	SPLITPATH *		psplitpath			= NULL;

	if ( argc != 1 || !FAddressFromSz( argv[0], &psplitpathDebuggee ) )
		{
		dprintf( "Usage: DUMP SPLITPATH <address>\n" );
		return;
		}

	if ( FFetchVariable( psplitpathDebuggee, &psplitpath ) )
		{
		const SIZE_T	dwOffset		= (BYTE *)psplitpathDebuggee - (BYTE *)psplitpath;

		dprintf(	"[SPLITPATH] 0x%0*I64X bytes @ 0x%p\n",
					sizeof( size_t ) * 2,
					QWORD( sizeof( SPLITPATH ) ),
					psplitpathDebuggee );

		dprintf( FORMAT_VOID( SPLITPATH, psplitpath, csr, dwOffset ) );
		dprintf( FORMAT_INT( SPLITPATH, psplitpath, dbtimeBefore, dwOffset ) );
		dprintf( FORMAT_POINTER( SPLITPATH, psplitpath, psplitPathParent, dwOffset ) );
		dprintf( FORMAT_POINTER( SPLITPATH, psplitpath, psplitPathChild, dwOffset ) );
		dprintf( FORMAT_POINTER( SPLITPATH, psplitpath, psplit, dwOffset ) );

		Unfetch( psplitpath );
		}
	}


//	MERGE dumping

CHAR mpmergetypesz[ mergetypeMax - mergetypeMin ][ 32 ] =
	{
	"mergetypeNone",
	"mergetypeEmptyPage",
	"mergetypeFullRight",
	"mergetypePartialRight",
	"mergetypeEmptyTree",
	};

//  ================================================================
VOID CDUMPA<MERGE>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[]
    )
//  ================================================================
	{
	MERGE *		pmergeDebuggee		= NULL;
	MERGE *		pmerge				= NULL;

	if ( argc != 1 || !FAddressFromSz( argv[0], &pmergeDebuggee ) )
		{
		dprintf( "Usage: DUMP MERGE <address>\n" );
		return;
		}

	if ( FFetchVariable( pmergeDebuggee, &pmerge ) )
		{
		const SIZE_T	dwOffset	= (BYTE *)pmergeDebuggee - (BYTE *)pmerge;

		dprintf(	"[MERGE] 0x%0*I64X bytes @ 0x%p\n",
					sizeof( size_t ) * 2,
					QWORD( sizeof( MERGE ) ),
					pmergeDebuggee );

		dprintf( FORMAT_VOID( MERGE, pmerge, csrLeft, dwOffset ) );
		dprintf( FORMAT_VOID( MERGE, pmerge, csrRight, dwOffset ) );
		dprintf( FORMAT_INT( MERGE, pmerge, dbtimeLeftBefore, dwOffset ) );
		dprintf( FORMAT_INT( MERGE, pmerge, dbtimeRightBefore, dwOffset ) );
		dprintf( FORMAT_ENUM( MERGE, pmerge, mergetype, dwOffset, mpmergetypesz, mergetypeMin, mergetypeMax ) );
		dprintf( FORMAT_POINTER( MERGE, pmerge, pmergePath, dwOffset ) );
		dprintf( FORMAT_VOID( MERGE, pmerge, kdfParentSep, dwOffset ) );
		dprintf( FORMAT_BOOL_BF( MERGE, pmerge, fAllocParentSep, dwOffset ) );
		dprintf( FORMAT_INT( MERGE, pmerge, ilineMerge, dwOffset ) );
		dprintf( FORMAT_INT( MERGE, pmerge, cbSavings, dwOffset ) );
		dprintf( FORMAT_INT( MERGE, pmerge, cbSizeTotal, dwOffset ) );
		dprintf( FORMAT_INT( MERGE, pmerge, cbSizeMaxTotal, dwOffset ) );
		dprintf( FORMAT_INT( MERGE, pmerge, cbUncFreeDest, dwOffset ) );
		dprintf( FORMAT_INT( MERGE, pmerge, clines, dwOffset ) );
		dprintf( FORMAT_POINTER( MERGE, pmerge, rglineinfo, dwOffset ) );

		Unfetch( pmerge );
		}
	}

// MERGEPATH dumping
//  ================================================================
VOID CDUMPA<MERGEPATH>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[]
    )
//  ================================================================
	{
	MERGEPATH *		pmergepathDebuggee	= NULL;
	MERGEPATH *		pmergepath			= NULL;

	if ( argc != 1 || !FAddressFromSz( argv[0], &pmergepathDebuggee ) )
		{
		dprintf( "Usage: DUMP MERGEPATH <address>\n" );
		return;
		}

	if ( FFetchVariable( pmergepathDebuggee, &pmergepath ) )
		{
		const SIZE_T	dwOffset		= (BYTE *)pmergepathDebuggee - (BYTE *)pmergepath;

		dprintf(	"[MERGEPATH] 0x%0*I64X bytes @ 0x%p\n",
					sizeof( size_t ) * 2,
					QWORD( sizeof( MERGEPATH ) ),
					pmergepathDebuggee );

		dprintf( FORMAT_VOID( MERGEPATH, pmergepath, csr, dwOffset ) );
		dprintf( FORMAT_INT( MERGEPATH, pmergepath, dbtimeBefore, dwOffset ) );
		dprintf( FORMAT_POINTER( MERGEPATH, pmergepath, pmergePathParent, dwOffset ) );
		dprintf( FORMAT_POINTER( MERGEPATH, pmergepath, pmergePathChild, dwOffset ) );
		dprintf( FORMAT_POINTER( MERGEPATH, pmergepath, pmerge, dwOffset ) );
		dprintf( FORMAT_INT( MERGEPATH, pmergepath, iLine, dwOffset ) );
		dprintf( FORMAT_BOOL_BF( MERGEPATH, pmergepath, fKeyChange, dwOffset ) );
		dprintf( FORMAT_BOOL_BF( MERGEPATH, pmergepath, fDeleteNode, dwOffset ) );
		dprintf( FORMAT_BOOL_BF( MERGEPATH, pmergepath, fEmptyPage, dwOffset ) );

		Unfetch( pmergepath );
		}
	}


// DBFILEHDR dumping
//  ================================================================
VOID CDUMPA<DBFILEHDR>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[]
    )
//  ================================================================
	{
	DBFILEHDR *		pdbfilehdrDebuggee	= NULL;
	DBFILEHDR *		pdbfilehdr			= NULL;

	if ( argc != 1 || !FAddressFromSz( argv[0], &pdbfilehdrDebuggee ) )
		{
		dprintf( "Usage: DUMP DBFILEHDR <address>\n" );
		return;
		}

	if ( FFetchVariable( pdbfilehdrDebuggee, &pdbfilehdr ) )
		{
		const SIZE_T	dwOffset		= (BYTE *)pdbfilehdrDebuggee - (BYTE *)pdbfilehdr;

		dprintf(	"[DBFILEHDR] 0x%0*I64X bytes @ 0x%p\n",
					sizeof( size_t ) * 2,
					QWORD( sizeof( DBFILEHDR ) ),
					pdbfilehdrDebuggee );

		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_ulChecksum, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_ulMagic, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_ulVersion, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_attrib, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_dbtimeDirtied, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, signDb, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_dbstate, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, le_lgposConsistent, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, logtimeConsistent, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, logtimeAttach, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, le_lgposAttach, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, logtimeDetach, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, le_lgposDetach, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_dbid, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, signLog, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, bkinfoFullPrev, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, bkinfoIncPrev, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, bkinfoFullCur, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, m_ulDbFlags, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_objidLast, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_dwMajorVersion, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_dwMinorVersion, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_dwBuildNumber, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_lSPNumber, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_ulUpdate, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_cbPageSize, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_ulRepairCount, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, logtimeRepair, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, signSLV, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_dbtimeLastScrub, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, logtimeScrub, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_lGenMinRequired, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_lGenMaxRequired, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_cpgUpgrade55Format, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_cpgUpgradeFreePages, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_cpgUpgradeSpaceMapPages, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, bkinfoSnapshotCur, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_ulCreateVersion, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_ulCreateUpdate, dwOffset ) );

		Unfetch( pdbfilehdr );
		}
	}


// Dump members of CPAGE class
VOID CPAGE::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
    {
	(*pcprintf)( FORMAT_POINTER( CPAGE, this, m_ppib, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE, this, m_ifmp, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CPAGE, this, m_pgno, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CPAGE, this, m_bfl, dwOffset ) );
	}


//  BF Dumping

CHAR mpbfdfsz[ bfdfMax - bfdfMin ][ 16 ] =
	{
	"bfdfClean",
	"bfdfUntidy",
	"bfdfDirty",
	"bfdfFilthy",
	};

CHAR mpbflssz[ bflsMax - bflsMin ][ 16 ] =
	{
	"bflsNormal",
	"bflsNominee1",
	"bflsNominee2",
	"bflsNominee3",
	"bflsElect",
	"bflsHashed",
	};

CHAR mpbfrssz[ bfrsMax - bfrsMin ][ 32 ] =
	{
	"bfrsNotCommitted",
	"bfrsNewlyCommitted",
	"bfrsNotResident",
	"bfrsResident",
	};

void BF::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
#ifdef _WIN64

	(*pcprintf)( FORMAT_VOID( BF, this, ob0ic, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( BF, this, lgposOldestBegin0, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( BF, this, lgposModify, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( BF, this, sxwl, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, ifmp, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( BF, this, pgno, dwOffset ) );
	(*pcprintf)( FORMAT_INT( BF, this, err, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fNewlyEvicted, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fQuiesced, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fAvailable, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fMemory, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fWARLatch, dwOffset ) );
	(*pcprintf)( FORMAT_ENUM_BF( BF, this, bfdf, dwOffset, mpbfdfsz, bfdfMin, bfdfMax ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fInOB0OL, dwOffset ) );
	(*pcprintf)( FORMAT_UINT_BF( BF, this, irangelock, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fCurrentVersion, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fOlderVersion, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fFlushed, dwOffset ) );
	(*pcprintf)( FORMAT_ENUM_BF( BF, this, bfls, dwOffset, mpbflssz, bflsMin, bflsMax ) );
	if ( bfls == bflsHashed )
		{
		(*pcprintf)( FORMAT_UINT( BF, this, iHashedLatch, dwOffset ) );
		}
	else
		{
		(*pcprintf)( FORMAT_UINT( BF, this, tickEligibleForNomination, dwOffset ) );
		}
	(*pcprintf)( FORMAT_ENUM_BF( BF, this, bfrs, dwOffset, mpbfrssz, bfrsMin, bfrsMax ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pv, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( BF, this, lrukic, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfTimeDepChainPrev, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfTimeDepChainNext, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( BF, this, fDependentPurged, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, prceUndoInfoNext, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfDependent, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfDepChainHeadPrev, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfDepChainHeadNext, dwOffset ) );

#else  //  !_WIN64

	(*pcprintf)( FORMAT_VOID( BF, this, ob0ic, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( BF, this, lgposOldestBegin0, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( BF, this, lgposModify, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfTimeDepChainPrev, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfTimeDepChainNext, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( BF, this, sxwl, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfDependent, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfDepChainHeadPrev, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfDepChainHeadNext, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, ifmp, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( BF, this, pgno, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pv, dwOffset ) );
	(*pcprintf)( FORMAT_INT( BF, this, err, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fNewlyEvicted, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fQuiesced, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fAvailable, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fMemory, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fWARLatch, dwOffset ) );
	(*pcprintf)( FORMAT_ENUM_BF( BF, this, bfdf, dwOffset, mpbfdfsz, bfdfMin, bfdfMax ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fInOB0OL, dwOffset ) );
	(*pcprintf)( FORMAT_UINT_BF( BF, this, irangelock, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fCurrentVersion, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fOlderVersion, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fFlushed, dwOffset ) );
	(*pcprintf)( FORMAT_ENUM_BF( BF, this, bfls, dwOffset, mpbflssz, bflsMin, bflsMax ) );
	if ( bfls == bflsHashed )
		{
		(*pcprintf)( FORMAT_UINT( BF, this, iHashedLatch, dwOffset ) );
		}
	else
		{
		(*pcprintf)( FORMAT_UINT( BF, this, tickEligibleForNomination, dwOffset ) );
		}
	(*pcprintf)( FORMAT_ENUM_BF( BF, this, bfrs, dwOffset, mpbfrssz, bfrsMin, bfrsMax ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, prceUndoInfoNext, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( BF, this, fDependentPurged, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( BF, this, lrukic, dwOffset ) );

#endif  //  _WIN64
	}


template< class CKey, class CEntry >
VOID CDynamicHashTable< CKey, CEntry >::Dump(
	CPRINTF *			pcprintf,
	const DWORD_PTR		dwOffset ) const
	{
	(*pcprintf)( FORMAT_UINT( CDynamicHashTable, this, m_cLoadFactor, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CDynamicHashTable, this, m_centryBucket, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CDynamicHashTable, this, m_cbBucket, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CDynamicHashTable, this, m_rankDHTrwlBucket, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CDynamicHashTable, this, m_rghs, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CDynamicHashTable, this, m_chs, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CDynamicHashTable, this, m_cbucketMin, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( CDynamicHashTable, this, m_rgbRsvdNever, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( CDynamicHashTable, this, m_dirptrs, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CDynamicHashTable, this, m_rgrgBucket, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( CDynamicHashTable, this, m_cOpSensitivity, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CDynamicHashTable, this, m_cBucketPreferred, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CDynamicHashTable, this, m_stateCur, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( CDynamicHashTable, this, m_rgbRsvdOften, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( CDynamicHashTable, this, m_semPolicy, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CDynamicHashTable, this, m_cCompletions, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( CDynamicHashTable, this, m_rgbRsvdAlways, dwOffset ) );
	}

template< class CKey, class CEntry, PfnOffsetOf OffsetOfIC >
VOID CApproximateIndex< CKey, CEntry, OffsetOfIC >::Dump(
	CPRINTF *			pcprintf,
	const DWORD_PTR		dwOffset ) const
	{
	(*pcprintf)( FORMAT_UINT( CApproximateIndex, this, m_shfKeyPrecision, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CApproximateIndex, this, m_shfKeyUncertainty, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CApproximateIndex, this, m_shfBucketHash, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CApproximateIndex, this, m_shfFillMSB, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CApproximateIndex, this, m_maskBucketKey, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CApproximateIndex, this, m_maskBucketPtr, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CApproximateIndex, this, m_maskBucketID, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CApproximateIndex, this, m_didRangeMost, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( CApproximateIndex, this, m_critUpdateIdRange, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CApproximateIndex, this, m_cidRange, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CApproximateIndex, this, m_idRangeFirst, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CApproximateIndex, this, m_idRangeLast, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CApproximateIndex, this, m_rgbReserved2, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( CApproximateIndex, this, m_bt, dwOffset ) );
	}

VOID CDUMPA<CDynamicHashTableEDBG>::Dump(
	HANDLE					hCurrentProcess,
	HANDLE					hCurrentThread,
	DWORD					dwCurrentPc,
	PWINDBG_EXTENSION_APIS	lpExtensionApis,
	INT						argc,
	const CHAR * const		argv[] )
//  ================================================================
	{
	CDynamicHashTableEDBG *	pdhtDebuggee	= NULL;
	CDynamicHashTableEDBG *	pdht			= NULL;

	if ( argc != 1 || !FAddressFromSz( argv[0], &pdhtDebuggee ) )
		{
		dprintf( "Usage: DUMP CDynamicHashTable <address>\n" );
		return;
		}

	if ( FFetchVariable( pdhtDebuggee, &pdht ) )
		{
		const SIZE_T	dwOffset		= (BYTE *)pdhtDebuggee - (BYTE *)pdht;

		dprintf(	"[CDynamicHashTable] 0x%0*I64X bytes @ 0x%p\n",
					sizeof( size_t ) * 2,
					QWORD( sizeof( CDynamicHashTableEDBG ) ),
					pdhtDebuggee );

		pdht->Dump( CPRINTFWDBG::PcprintfInstance(), dwOffset );

		Unfetch( pdht );
		}
	}

VOID CDUMPA<CApproximateIndexEDBG>::Dump(
	HANDLE					hCurrentProcess,
	HANDLE					hCurrentThread,
	DWORD					dwCurrentPc,
	PWINDBG_EXTENSION_APIS	lpExtensionApis,
	INT						argc,
	const CHAR * const		argv[] )
//  ================================================================
	{
	CApproximateIndexEDBG *	paiDebuggee	= NULL;
	CApproximateIndexEDBG *	pai			= NULL;

	if ( argc != 1 || !FAddressFromSz( argv[0], &paiDebuggee ) )
		{
		dprintf( "Usage: DUMP CApproximateIndex <address>\n" );
		return;
		}

	if ( FFetchVariable( paiDebuggee, &pai ) )
		{
		const SIZE_T	dwOffset		= (BYTE *)paiDebuggee - (BYTE *)pai;

		dprintf(	"[CApproximateIndex] 0x%0*I64X bytes @ 0x%p\n",
					sizeof( size_t ) * 2,
					QWORD( sizeof( CApproximateIndexEDBG ) ),
					paiDebuggee );

		pai->Dump( CPRINTFWDBG::PcprintfInstance(), dwOffset );

		Unfetch( pai );
		}
	}


struct IFMPGEN
	{
	IFMP	ifmp;
	ULONG	lgen;
	};

DEBUG_EXT( EDBGBFOB0FindOldest )
	{
	IFMPGEN			ifmpgen				= { 0, 0 };
	FMP *			rgfmpDebuggee		= NULL;
	FMP *			pfmp				= NULL;
	ULONG			ifmpMaxDebuggee;
	BFFMPContext *	pbffmp;
	BOOL			fValidUsage;

	switch ( argc )
		{
		case 1:
			fValidUsage = ( FUlFromSz( argv[0], (ULONG *)&ifmpgen.ifmp ) );
			break;

		case 2:
			fValidUsage = ( FUlFromSz( argv[0], (ULONG *)&ifmpgen.ifmp )
							&& FUlFromSz( argv[1], &ifmpgen.lgen )
							&& ifmpgen.lgen > 0 );
			break;

		default:
			fValidUsage = fFalse;
			break;
		}

	dprintf( "\n" );

	if ( !fValidUsage )
		{
		dprintf( "Usage: BFOB0FINDOLDEST <ifmp> [<gen>]\n" );
		dprintf( "\n" );
		dprintf( "    <ifmp> - index to the FMP entry for the desired database file\n" );
		dprintf( "    <gen>  - find all BF's with lgposBegin0 less than or equal to\n" );
		dprintf( "             specified log generation\n" );
		return;
		}

	if ( !FReadGlobal( "rgfmp", &rgfmpDebuggee )
		|| !FReadGlobal( "ifmpMax", &ifmpMaxDebuggee ) )
		{
		dprintf( "Error: Could not fetch FMP variables.\n" );
		return;
		}

	if ( ifmpgen.ifmp >= ifmpMaxDebuggee )
		{
		dprintf( "Error: Illegal ifmp (ifmpMax==0x%x)\n", ifmpMaxDebuggee );
		return;
		}

	if ( !FFetchVariable( rgfmpDebuggee + ifmpgen.ifmp, &pfmp ) )
		{
		return;
		}

	if ( FFetchVariable( (BFFMPContext *)pfmp->DwBFContext( 0 ), &pbffmp ) )
		{
		dprintf( "BFOB0: 0x%p\n", pfmp->DwBFContext( 0 ) );
		pbffmp->bfob0.Scan( CPRINTFWDBG::PcprintfInstance(), (VOID *)&ifmpgen );

		Unfetch( pbffmp );
		}

	Unfetch( pfmp );
	}

VOID BFOB0::CBucketTable::Scan( CPRINTF * pcprintf, VOID * pv ) const
	{
	const IFMPGEN *	pifmpgen				= (IFMPGEN *)pv;
	const SIZE_T	crgBucket				= sizeof(m_rgrgBucket) / sizeof(m_rgrgBucket[0]);
	BYTE *			rgbBucket				= NULL;
	BYTE *			pbBucket				= NULL;
	PBF				pbf						= pbfNil;
	PBF				pbfOldestBegin0			= pbfNil;
	LGPOS			lgposOldestBegin0		= lgposMax;
	SIZE_T			ientryOldestBegin0		= 0;
	SIZE_T			iBucketOldestBegin0		= 0;
	SIZE_T			irgBucketOldestBegin0	= 0;
	BOOL			fFoundTargetGen			= fFalse;

	pbBucket = (BYTE *)LocalAlloc( 0, m_cbBucket );
	if ( NULL == pbBucket )
		{
		(*pcprintf)( "Error: Could not allocate BUCKET buffer.\n" );
		goto HandleError;
		}

	pbf = (PBF)LocalAlloc( 0, sizeof(BF) );
	if ( NULL == pbf )
		{
		(*pcprintf)( "Error: Could not allocate BF buffer.\n" );
		goto HandleError;
		}

	if ( pifmpgen->lgen > 0 )
		{
		(*pcprintf)(
			"Scanning BFOB0 [bucket array/bucket/entry] for ifmp 0x%x with lgposBegin0 at generation %d (0x%x) or older:\n",
			pifmpgen->ifmp,
			pifmpgen->lgen,
			pifmpgen->lgen );
		}
	else
		{
		(*pcprintf)( "Scanning all BFOB0 entries [bucket array/bucket/entry]...\n" );
		}

	//	scan each DHT directory entry
	//
    for ( SIZE_T irgBucket = 0; irgBucket < crgBucket && NULL != m_rgrgBucket[irgBucket]; irgBucket++ )
    	{
		//	number of buckets grows exponentially, with a minimum of 2
		//
		const PBUCKET	pbucket				= PBUCKET( pbBucket );
		const SIZE_T	cBuckets			= max( 2, 1 << irgBucket );
		BYTE * const	rgbBucketDebuggee	= m_rgrgBucket[irgBucket];

		if ( !FFetchVariable( rgbBucketDebuggee, &rgbBucket, m_cbBucket * cBuckets ) )
			{
			(*pcprintf)( "Error: Could not fetch bucket array at 0x%p.\n", rgbBucketDebuggee );
			goto HandleError;
			}

		//	scan all DHT buckets in this directory entry
		//
		for ( SIZE_T iBucket = 0; iBucket < cBuckets; iBucket++ )
			{
			//	scan this bucket and its overflow buckets
			//
			BOOL		fLastBucketInChain	= fFalse;
			BYTE *		pbBucketDebuggee	= rgbBucketDebuggee + ( iBucket * m_cbBucket );
			while ( !fLastBucketInChain )
				{
				const CKeyEntry *	pEntryMost;

				//	UNDONE: don't actually need to read the first bucket (it's
				//	already read in in the bucket array as the head of this
				//	chain), but it makes the loop easier to code if we do
				//
				if ( !FReadVariable( pbBucketDebuggee, pbBucket, m_cbBucket ) )
					{
					(*pcprintf)( "Error: Could not read bucket at 0x%p.\n", pbBucketDebuggee );
					goto HandleError;
					}

				if ( NULL == pbucket->m_pb )
					{
					//	bucket was empty, so end of chain was reached
					//
					fLastBucketInChain = fTrue;
					pEntryMost = pbucket->m_rgEntry;
					}
				else if ( pbucket->m_pb > pbBucketDebuggee
					&& pbucket->m_pb < pbBucketDebuggee + m_cbBucket )
					{
					//	m_pEntryLast is valid, so end of chain was reached
					//
					fLastBucketInChain = fTrue;
					pEntryMost = (CKeyEntry *)( pbBucket + ( pbucket->m_pb - pbBucketDebuggee ) );

					//	m_pEntryLast actually points to the last valid entry,
					//	so move one past
					//
					pEntryMost++;
					}
				else
					{
					pEntryMost = pbucket->m_rgEntry + m_centryBucket;
					}

				//	scan all entries in this bucket
				//

				for ( CKeyEntry * pEntryThis = pbucket->m_rgEntry;
					pEntryThis < pEntryMost;
					pEntryThis++ )
					{
					//	scan invasive list for this entry
					//
					BFOB0::CBucket		listHead;
					pEntryThis->GetEntry( &listHead );

					for ( PBF pbfDebuggee = listHead.m_il.PrevMost();
						pbfNil != pbfDebuggee;
						pbfDebuggee = listHead.m_il.Next( pbf ) )
						{
						if ( !FReadVariable( pbfDebuggee, pbf ) )
							{
							(*pcprintf)( "Error: Could not read BF at 0x%p.\n", pbfDebuggee );
							goto HandleError;
							}

						if ( pbf->ifmp == pifmpgen->ifmp
							&& ( pbf->fCurrentVersion || pbf->fOlderVersion ) )
							{
							if ( pifmpgen->lgen > 0 )
								{
								if ( pbf->lgposOldestBegin0.lGeneration <= pifmpgen->lgen )
									{
									(*pcprintf)(
										"    [%d/%d/%d] BF 0x%p: gen %d (0x%x)\n",
										irgBucket,
										iBucket,
										( pEntryThis - pbucket->m_rgEntry ),
										pbfDebuggee,
										pbf->lgposOldestBegin0.lGeneration,
										pbf->lgposOldestBegin0.lGeneration );
									fFoundTargetGen = fTrue;
									}
								}

							if ( CmpLgpos( &pbf->lgposOldestBegin0, &lgposOldestBegin0 ) < 0 )
								{
								lgposOldestBegin0 = pbf->lgposOldestBegin0;
								pbfOldestBegin0 = pbfDebuggee;
								irgBucketOldestBegin0 = irgBucket;
								iBucketOldestBegin0 = iBucket;
								ientryOldestBegin0 = ( pEntryThis - pbucket->m_rgEntry );
								}
							}
						}
					}

				pbBucketDebuggee = (BYTE *)pbucket->m_pBucketNext;
				}
			}

		Unfetch( rgbBucket );
		rgbBucket = NULL;
    	}

	if ( pifmpgen->lgen > 0 && !fFoundTargetGen )
		{
		//	didn't find any BF for this ifmp
		//
		(*pcprintf)( "    <none>\n" );
		}

	if ( pbfNil != pbfOldestBegin0 )
		{
		(*pcprintf)(
			"Oldest lgposBegin0 (generation 0x%x) for ifmp 0x%x is cached in BF 0x%p,",
			lgposOldestBegin0.lGeneration,
			pifmpgen->ifmp,
			pbfOldestBegin0 );
		(*pcprintf)(
			"which is in the BFOB0 at [%d/%d/%d].\n",
			irgBucketOldestBegin0,
			iBucketOldestBegin0,
			ientryOldestBegin0 );
		}
	else
		{
		(*pcprintf)( "No pages found for ifmp 0x%x.\n", pifmpgen->ifmp );
		}

HandleError:
	(*pcprintf)( "\n" );

	LocalFree( pbf );
	LocalFree( pbBucket );
	Unfetch( rgbBucket );
	}


#ifdef DISABLE_SLV
#else

void CSLVFileInfo::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	(*pcprintf)( FORMAT_BOOL( CSLVFileInfo, this, m_fFreeCache, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( CSLVFileInfo, this, m_fUpdateChecksum, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( CSLVFileInfo, this, m_fUpdateSlist, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( CSLVFileInfo, this, m_fCloseBuffer, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( CSLVFileInfo, this, m_fCloseCursor, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSLVFileInfo, this, m_rgbLocalCache, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_rgbCache, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CSLVFileInfo, this, m_cbCache, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_pffeainf, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CSLVFileInfo, this, m_cbffeainf, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_wszFileName, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVFileInfo, this, m_cwchFileName, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_pstatusCommit, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_pdwInstanceID, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_pdwChecksum, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_ptickOpenDeadline, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_pslist, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CSLVFileInfo, this, m_cbslist, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CSLVFileInfo, this, m_irun, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_psle, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSLVFileInfo, this, m_buffer, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSLVFileInfo, this, m_cursor, dwOffset ) );
	}

void CSLVFileTable::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	(*pcprintf)( FORMAT_BOOL( CSLVFileTable, this, m_fInit, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileTable, this, m_pslvroot, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CSLVFileTable, this, m_cDeferredCleanup, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSLVFileTable, this, m_semCleanup, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVFileTable, this, m_fileidNextCleanup, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVFileTable, this, m_cbReserved, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVFileTable, this, m_cbDeleted, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVFileTable, this, m_centryInsert, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVFileTable, this, m_centryDelete, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVFileTable, this, m_centryClean, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSLVFileTable, this, m_et, dwOffset ) );
	}

void CSLVInfo::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	(*pcprintf)( FORMAT_POINTER( CSLVInfo, this, m_pfucb, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_columnid, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_itagSequence, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( CSLVInfo, this, m_fCopyBuffer, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_ibOffsetChunkMic, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_ibOffsetChunkMac, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_ibOffsetRunMic, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_ibOffsetRunMac, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_ibOffsetRun, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( CSLVInfo, this, m_fCacheDirty, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVInfo, this, m_pvCache, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_cbCache, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSLVInfo, this, m_rgbSmallCache, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( CSLVInfo, this, m_fHeaderDirty, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSLVInfo, this, m_header, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( CSLVInfo, this, m_fFileNameVolatile, dwOffset ) );
	(*pcprintf)( FORMAT_WSZ( CSLVInfo, this, m_wszFileName, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_fileid, dwOffset ) );
	}

void _SLVROOT::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	(*pcprintf)( FORMAT_UINT( _SLVROOT, this, hFileRoot, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( _SLVROOT, this, dwInstanceID, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( _SLVROOT, this, pfapiBackingFile, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( _SLVROOT, this, pslvft, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( _SLVROOT, this, pfnSpaceReq, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( _SLVROOT, this, dwSpaceReqKey, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( _SLVROOT, this, semSpaceReq, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( _SLVROOT, this, semSpaceReqComp, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( _SLVROOT, this, msigTerm, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( _SLVROOT, this, msigTermAck, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( _SLVROOT, this, cbGrant, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( _SLVROOT, this, cbCommit, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( _SLVROOT, this, pfnSpaceFree, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( _SLVROOT, this, dwSpaceFreeKey, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( _SLVROOT, this, cbfgeainf, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( _SLVROOT, this, rgbEA, dwOffset ) );
	(*pcprintf)( FORMAT_WSZ( _SLVROOT, this, wszRootName, dwOffset ) );
	}

void CSLVBackingFile::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	COSFile::Dump( pcprintf, dwOffset );
	(*pcprintf)( FORMAT_POINTER( CSLVBackingFile, this, m_slvroot, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( CSLVBackingFile, this, m_szAbsPathSLV, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSLVBackingFile, this, m_semSetSize, dwOffset ) );
	}

#endif	//	DISABLE_SLV


void COSFileSystem::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	(*pcprintf)( FORMAT_BOOL( COSFileSystem, this, m_fWin9x, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFileSystem, this, m_hmodKernel32, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( COSFileSystem, this, m_pfnGetVolumePathName, dwOffset ) );
	}

void COSFileFind::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	(*pcprintf)( FORMAT_POINTER( COSFileFind, this, m_posfs, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( COSFileFind, this, m_szFindPath, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( COSFileFind, this, m_szAbsFindPath, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( COSFileFind, this, m_fBeforeFirst, dwOffset ) );
	(*pcprintf)( FORMAT_INT( COSFileFind, this, m_errFirst, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFileFind, this, m_hFileFind, dwOffset ) );
	(*pcprintf)( FORMAT_INT( COSFileFind, this, m_errCurrent, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( COSFileFind, this, m_fFolder, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( COSFileFind, this, m_szAbsFoundPath, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFileFind, this, m_cbSize, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( COSFileFind, this, m_fReadOnly, dwOffset ) );
	}

void COSFile::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	(*pcprintf)( FORMAT_SZ( COSFile, this, m_szAbsPath, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFile, this, m_hFile, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFile, this, m_cbFileSize, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( COSFile, this, m_fReadOnly, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFile, this, m_cbIOSize, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFile, this, m_cbMMSize, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( COSFile, this, m_pfnEndUpdate, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFile, this, m_keyEndUpdate, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( COSFile, this, m_pfnBeginUpdate, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFile, this, m_keyBeginUpdate, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( COSFile, this, m_p_osf, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( COSFile, this, m_msFileSize, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( COSFile, this, m_rgcbFileSize, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( COSFile, this, m_semChangeFileSize, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( COSFile, this, m_critDefer, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( COSFile, this, m_ilDefer, dwOffset ) );
	}

void COSFileLayout::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	(*pcprintf)( FORMAT_POINTER( COSFileLayout, this, m_posf, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFileLayout, this, m_ibVirtualFind, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFileLayout, this, m_cbSizeFind, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( COSFileLayout, this, m_fBeforeFirst, dwOffset ) );
	(*pcprintf)( FORMAT_INT( COSFileLayout, this, m_errFirst, dwOffset ) );
	(*pcprintf)( FORMAT_INT( COSFileLayout, this, m_errCurrent, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( COSFileLayout, this, m_szAbsVirtualPath, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFileLayout, this, m_ibVirtual, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFileLayout, this, m_cbSize, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( COSFileLayout, this, m_szAbsLogicalPath, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFileLayout, this, m_ibLogical, dwOffset ) );
	}

#endif	//	DEBUGGER_EXTENSION


extern "C" {

//	================================================================
VOID __stdcall ese(
	HANDLE hCurrentProcess,
	HANDLE hCurrentThread,
	DWORD dwCurrentPc,
	PWINDBG_EXTENSION_APIS lpExtensionApis,
	LPSTR lpArgumentString )
//	================================================================
	{
#ifdef DEBUGGER_EXTENSION

	TRY
		{
#ifdef DEBUG
		//  we don't want assertions appearing on the screen during debugging
		if( !fDebugMode )
			{
			g_wAssertAction = 3/* no action */;
			}
		else
			{
			g_wAssertAction = JET_AssertMsgBox;
			}
#endif

		if ( sizeof( WINDBG_EXTENSION_APIS ) != lpExtensionApis->nSize )
			{
			(lpExtensionApis->lpOutputRoutine)(
					"WARNING: EXTENSION_APIS has unexpected size: 0x%x bytes (expected 0x%x bytes)\n",
					lpExtensionApis->nSize,
					sizeof( WINDBG_EXTENSION_APIS ) );
			}

	    ExtensionApis 	= *lpExtensionApis;

		if ( !fInit && NULL != hCurrentProcess && cSymInitFail < cSymInitAttemptsMax )
			{
			//	UNDONE: Is the symbols sub-system even necessary anymore?
			//	A much cleaner approach is just to use the GLOBALS extension
			//	to load the global variables needed by all the other
			//	extensions
			//
			fInit = FSymInit( hCurrentProcess );
			if ( fInit )
				{
				dprintf( "Symbols sub-system successfully initialised.\n" );
				}
			else
				{
				dprintf( "WARNING: Failed initialisation of symbols sub-system.\n" );
				if ( ++cSymInitFail >= cSymInitAttemptsMax )
					dprintf( "WARNING: No further attempts will be made to initialise the symbols sub-system.\n" );
				}
			}

		VOID * pv = LocalAlloc( LMEM_ZEROINIT, strlen( lpArgumentString ) + 1 );
		if ( NULL == pv )
			{
			dprintf( "ERROR: Could not parse argument string (OutOfMemory).\n" );
			goto Return;
			}

		memcpy( pv, lpArgumentString, strlen( lpArgumentString ) );
		CHAR * argv[256];
		INT argc = SzToRgsz( argv, reinterpret_cast<CHAR *>( pv ) );

		if( argc < 1 )
			{
			EDBGHelp( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, (const CHAR **)argv );
			goto Return;
			}

		INT ifuncmap;
		for( ifuncmap = 0; ifuncmap < cfuncmap; ifuncmap++ )
			{
			if( FArgumentMatch( argv[0], rgfuncmap[ifuncmap].szCommand ) )
				{
				(rgfuncmap[ifuncmap].function)(
					hCurrentProcess,
					hCurrentThread,
					dwCurrentPc,
					lpExtensionApis,
					argc - 1, (const CHAR **)( argv + 1 ) );
				goto Return;
				}
			}

		EDBGHelp( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, (const CHAR **)argv );
		goto Return;

	Return:
		if ( NULL != pv )
			{
			LocalFree( pv );
			pv = NULL;
			}
		}
	EXCEPT( fDebugMode ? ExceptionFail( _T( "ESE Debugger Extension" ) ) : efaContinueSearch )
		{
		}
	ENDEXCEPT

#endif	//	DEBUGGER_EXTENSION
    }

//	================================================================
VOID __stdcall esent(
	DWORD dwCurrentPc,
	PWINDBG_EXTENSION_APIS lpExtensionApis,
	LPSTR lpArgumentString )
//	================================================================
	{
	//	UNDONE: this entry point is a hack to allow debugger
	//	extensions to work with KD - the true fix is to export
	//	the entry points necessary to comply with current
	//	WINDBG protocol (since we don't, the WINDBG engine
	//	invokes us with obsolete APIs)
	ese( NULL, NULL, dwCurrentPc, lpExtensionApis, lpArgumentString );
	}


#ifdef DEBUG

//	sample callback function
//
//  ================================================================
JET_ERR JET_API YouHaveBadSymbols(
	JET_SESID 		sesid,
	JET_DBID 		ifmp,
	JET_TABLEID 	tableid,
	JET_CBTYP 		cbtyp,
	void *			pvArg1,
	void *			pvArg2,
	void *			pvContext,
	ULONG_PTR		ulUnused )
//  ================================================================
	{
	//  this line should only compile if the signatures match
	JET_CALLBACK	callback = YouHaveBadSymbols;

	static BOOL fMessageBox = fTrue;

	const char * szCbtyp = "UNKNOWN";
	switch( cbtyp )
		{
		case JET_cbtypNull:
			szCbtyp = "NULL";
			break;
		case JET_cbtypBeforeInsert:
			szCbtyp = "BeforeInsert";
			break;
		case JET_cbtypAfterInsert:
			szCbtyp = "AfterInsert";
			break;
		case JET_cbtypBeforeReplace:
			szCbtyp = "BeforeReplace";
			break;
		case JET_cbtypAfterReplace:
			szCbtyp = "AfterReplace";
			break;
		case JET_cbtypBeforeDelete:
			szCbtyp = "BeforeDelete";
			break;
		case JET_cbtypAfterDelete:
			szCbtyp = "AfterDelete";
			break;
		}

	CHAR szMessage[384];
	sprintf( szMessage,
			"YouHaveBadSymbols:\n"
			"\tsesid   		= 0x%x\n"
			"\tifmp    		= 0x%x\n"
			"\ttableid 		= 0x%x\n"
			"\tcbtyp   		= 0x%x (%s)\n"
			"\tpvArg1  		= 0x%0*I64X\n"
			"\tpvArg2 		= 0x%0*I64X\n"
			"\tpvContext  	= 0x%0*I64X\n"
			"\tulUnused  	= 0x%x\n"
			"\n",
			sesid, ifmp, tableid, cbtyp, szCbtyp,
				sizeof( LONG_PTR )*2, pvArg1,
				sizeof( LONG_PTR )*2, pvArg2,
				sizeof( LONG_PTR )*2, pvContext,
				ulUnused );
	printf( "%s", szMessage );

	JET_ERR err;
	char szName[JET_cbNameMost+1];

	err = JetGetTableInfo( sesid, tableid, szName, sizeof( szName ), JET_TblInfoName );
	if( JET_errSuccess != err )
		{
		printf( "JetGetTableInfo returns %d\n", err );
		}
	else
		{
		char szBuf[JET_cbColumnMost + 16];
		sprintf( szBuf, "Table \"%s\"\n", szName );
		strcat( szMessage, szBuf );
		printf( "%s", szBuf );
		}

	err = JetGetCurrentIndex( sesid, tableid, szName, sizeof( szName ) );
	if( JET_errSuccess != err )
		{
		printf( "JetGetCurrentIndex returns %d\n", err );
		}
	else
		{
		char szBuf[JET_cbColumnMost + 16];
		sprintf( szBuf, "Index \"%s\"\n", szName );
		strcat( szMessage, szBuf );
		printf( "%s", szBuf );
		}

	err = JetMove( sesid, tableid, JET_MoveFirst, NO_GRBIT );
	Assert( JET_errSuccess != err );
	err = JetSetCurrentIndex( sesid, tableid, NULL );
	Assert( JET_errSuccess != err );
	JET_TABLEID tableid2;
	err = JetDupCursor( sesid, tableid, &tableid2, NO_GRBIT );
	Assert( JET_errSuccess == err );
	err = JetCloseTable( sesid, tableid );
	Assert( JET_errSuccess != err );
	err = JetCloseTable( sesid, tableid2 );
	Assert( JET_errSuccess == err );

	err = JET_errSuccess;

	switch( cbtyp )
		{
		case JET_cbtypBeforeInsert:
		case JET_cbtypBeforeReplace:
		case JET_cbtypBeforeDelete:
			if( fMessageBox )
				{
				strcat( szMessage,
						"\n"
						"Allow the callback to succeed?" );
				const int id = UtilMessageBox(
					szMessage,
					"YouHaveBadSymbols",
					MB_SERVICE_NOTIFICATION | MB_SYSTEMMODAL | MB_ICONQUESTION | MB_YESNOCANCEL );
				if( IDNO == id )
					{
					err = JET_errCallbackFailed;
					}
				else if( IDCANCEL == id )
					{
					fMessageBox = fFalse;
					}
				}
			break;
		}

	printf( "YouHaveBadSymbols returns %d.\n\n", err );
	return err;
	}

#endif	//	DEBUG

}	//	OSSYM


//  post-terminate edbg subsystem

void OSEdbgPostterm()
	{
	//  nop
	}

//  pre-init edbg subsystem

BOOL FOSEdbgPreinit()
	{
	//  nop

	return fTrue;
	}


//  terminate edbg subsystem

void OSEdbgTerm()
	{
	//  term OSSYM
#ifdef DEBUGGER_EXTENSION
	SymTerm();
#endif
	}

//  init edbg subsystem

ERR ErrOSEdbgInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\norm.cxx ===
#include "osstd.hxx"

#include < malloc.h >


LOCAL BOOL			fUnicodeSupport				= fFalse;

const SORTID		sortidDefault				= SORT_DEFAULT;
const SORTID		sortidNone					= SORT_DEFAULT;
const LANGID		langidDefault				= MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
const LANGID		langidNone					= MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL );

extern const LCID	lcidDefault					= MAKELCID( langidDefault, sortidDefault );
extern const LCID	lcidNone					= MAKELCID( langidNone, sortidNone );

extern const DWORD	dwLCMapFlagsDefaultOBSOLETE	= ( LCMAP_SORTKEY | NORM_IGNORECASE | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH );
extern const DWORD	dwLCMapFlagsDefault			= ( LCMAP_SORTKEY | NORM_IGNORECASE | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH );


#ifdef DEBUG
VOID AssertNORMConstants()
	{
	//	since we now persist LCMapString() flags, we must verify
	//	that NT doesn't change them from underneath us
	Assert( LCMAP_SORTKEY == 0x00000400 );
	Assert( LCMAP_BYTEREV == 0x00000800 );
	Assert( NORM_IGNORECASE == 0x00000001 );
	Assert( NORM_IGNORENONSPACE == 0x00000002 );
	Assert( NORM_IGNORESYMBOLS == 0x00000004 );
	Assert( NORM_IGNOREKANATYPE == 0x00010000 );
	Assert( NORM_IGNOREWIDTH == 0x00020000 );
	Assert( SORT_STRINGSORT == 0x00001000 );

	Assert( sortidDefault == 0 );
	Assert( langidDefault == 0x0409 );
	Assert( lcidDefault == 0x00000409 );
	Assert( sortidNone == 0 );
	Assert( langidNone == 0 );
	Assert( lcidNone == 0 );

	CallS( ErrNORMCheckLcid( NULL, lcidDefault ) );
	CallS( ErrNORMCheckLCMapFlags( NULL, dwLCMapFlagsDefault ) );
	}
#endif	

const LCID LcidFromLangid( const LANGID langid )
	{
	return MAKELCID( langid, sortidDefault );
	}

const LANGID LangidFromLcid( const LCID lcid )
	{
	return LANGIDFROMLCID( lcid );
	}

//	allocates memory for psz using new []
LOCAL ERR ErrNORMGetLcidInfo( const LCID lcid, const LCTYPE lctype, _TCHAR ** psz )
	{
	ERR			err			= JET_errSuccess;
	const INT	cbNeeded	= GetLocaleInfo( lcid, lctype, NULL, 0 );

	if ( NULL == ( *psz = new _TCHAR[cbNeeded] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	else
		{
		const INT	cbT		= GetLocaleInfo( lcid, lctype, *psz, cbNeeded );

		Assert( cbT == cbNeeded );
		if ( 0 == cbT )
			{
			Call( ErrERRCheck( JET_errInternalError ) );
			}
		}

HandleError:
	return err;
	}

LOCAL ERR ErrNORMReportInvalidLcid( INST * const pinst, const LCID lcid )
	{
	ERR 			err				= JET_errSuccess;
	_TCHAR			szLcid[16];
	_TCHAR *		szLanguage		= NULL;
	_TCHAR *		szEngLanguage 	= NULL;
	const ULONG		cszT			= 3;
	const _TCHAR*	rgszT[cszT]		= { szLcid, NULL, NULL };

	//	these routines allocate memory, remember to free it with delete[]

	Call( ErrNORMGetLcidInfo( lcid, LOCALE_SLANGUAGE, &szLanguage ) );	
	Call( ErrNORMGetLcidInfo( lcid, LOCALE_SENGLANGUAGE, &szEngLanguage ) );

	rgszT[1] = szLanguage;
	rgszT[2] = szEngLanguage;

	_stprintf( szLcid, _T( "0x%0*x" ), sizeof(LCID)*2, lcid );
	Assert( _tcslen( szLcid ) < sizeof( szLcid ) / sizeof( _TCHAR ) );

	UtilReportEvent(
			eventError,
			GENERAL_CATEGORY,
			LANGUAGE_NOT_SUPPORTED_ID,
			cszT,
			rgszT,
			0,
			NULL,
			pinst );
	err = ErrERRCheck( JET_errInvalidLanguageId );

HandleError:
	delete [] szEngLanguage;
	delete [] szLanguage;
	
	return err;
	}

ERR ErrNORMCheckLcid( INST * const pinst, const LCID lcid )
	{
	//	don't support LCID_SUPPORTED, must always have the lcid installed before using it
	const BOOL	fValidLocale	= ( lcidNone != lcid && IsValidLocale( lcid, LCID_INSTALLED ) );
	return ( fValidLocale ? JET_errSuccess : ErrNORMReportInvalidLcid( pinst, lcid ) );
	}

ERR ErrNORMCheckLcid( INST * const pinst, LCID * const plcid )
	{
	//	lcidNone filtered out before calling this function
	Assert( lcidNone != *plcid );

	//	if langid is system default, then coerce to system default
	if ( *plcid == LOCALE_SYSTEM_DEFAULT )
		{
		*plcid = GetSystemDefaultLCID();
		}
	else if ( *plcid == LOCALE_USER_DEFAULT )
		{
		*plcid = GetUserDefaultLCID();
		}

	return ErrNORMCheckLcid( pinst, *plcid );
	}


#ifndef RTM

//  ****************************************************************
//	provide the ability to "undefine" Unicode characters through
//	the registry. read a registry key of the form "char,char,char"
//	e.g.: 0x2a,0x1b,0x30
//	set a bitmap to show which characters are undefined, strip
//	them out of strings when normalizing
//  ****************************************************************

LOCAL BOOL g_fUndefinedChars;
LOCAL BYTE g_rgbUndefinedChars[8192];	//	bit array. TRUE means the character is not defined


//  ================================================================
LOCAL VOID NORMDebugUndefineUnicodeChar( const WCHAR ch )
//  ================================================================
	{
	const INT i = ch;
	g_rgbUndefinedChars[i/8] |= (BYTE)( 1 << ( i % 8 ) );
	}


//  ================================================================
LOCAL BOOL FNORMDebugIsUnicodeCharDefined( const WCHAR ch )
//  ================================================================
	{
	const int i = ch;
	return !( ( g_rgbUndefinedChars[i/8] ) & ( (BYTE)( 1 << ( i % 8 ) ) ) );
	}


//  ================================================================
LOCAL VOID NORMDebugReportUndefinedCharLoaded( const INT ch )
//  ================================================================
	{
	_TCHAR			szPID[16];
	_TCHAR			szMessage[256];
	const _TCHAR *	rgsz[]	= { SzUtilProcessName(), szPID, "", szMessage };

	_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
	_stprintf(	szMessage, 
				_T( "Unicode character 0x%x has been marked as undefined through the registry" ), 
				ch );
	UtilReportEvent( eventWarning, PERFORMANCE_CATEGORY, PLAIN_TEXT_ID, sizeof( rgsz ) / sizeof( rgsz[0] ), rgsz );
	}


//  ================================================================
LOCAL VOID NORMDebugReportBadCharLoaded( const INT ch )
//  ================================================================
	{
	_TCHAR			szPID[16];
	_TCHAR			szMessage[256];
	const _TCHAR *	rgsz[]	= { SzUtilProcessName(), szPID, "", szMessage };

	_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
	_stprintf(	szMessage, 
				_T( "Unknown unicode character 0x%x in registry overrides" ), 
				ch );
	UtilReportEvent( eventError, PERFORMANCE_CATEGORY, PLAIN_TEXT_ID, sizeof( rgsz ) / sizeof( rgsz[0] ), rgsz );
	}


//  ================================================================
LOCAL VOID NORMDebugLoadUndefinedCharsFromString( _TCHAR * const sz )
//  ================================================================
	{
	Assert( sz );
	 _TCHAR * szT		= _tcstok( sz, _T( "," ) );		
	while( szT )
		{
		const INT ch = _tcstol( szT, NULL, 0 );
		if( ch < 0 || ch > 0xffff )
			{
			NORMDebugReportBadCharLoaded( ch ); 
			}
		else
			{
			NORMDebugUndefineUnicodeChar( (WCHAR)ch );
			NORMDebugReportUndefinedCharLoaded( ch ); 
			}
		szT = _tcstok( NULL, _T( "," ) );
		}
	}


//  ================================================================
LOCAL VOID NORMDebugResetUndefinedChars()
//  ================================================================
	{
	memset( g_rgbUndefinedChars, 0, sizeof( g_rgbUndefinedChars ) );
	}


//  ================================================================
LOCAL VOID NORMDebugLoadUndefinedCharsFromRegistry()
//  ================================================================
	{
	_TCHAR sz[1024];

	if ( FOSConfigGet( _T( "OS" ), _T( "UndefinedUnicodeChars" ), sz, sizeof( sz ) - 1 ) && sz[0] )
		{
		g_fUndefinedChars = fTrue;
		NORMDebugLoadUndefinedCharsFromString( sz );
		}	
	}


//  ================================================================
LOCAL BOOL FNORMDebugStringHasUndefinedChars( const BYTE * const pbColumn, const INT cbColumn )
//  ================================================================
	{
	const WCHAR * const sz = (WCHAR *)pbColumn;
	const INT cch = cbColumn / sizeof( WCHAR );
	for( INT ich = 0; ich < cch; ++ich )
		{
		if( !FNORMDebugIsUnicodeCharDefined( sz[ich] ) )
			{
			return fTrue;
			}
		}
	return fFalse;
	}


//  ================================================================
LOCAL BOOL FNORMDebugStripUndefinedChars( WCHAR * const sz, const INT cch )
//  ================================================================
//
//	Overwrite "undefined" characters with '#'
//
//-
	{
	BOOL fUndefinedChar = fFalse;
	
	for ( INT ich = 0; ich < cch; ++ich )
		{
		if( !FNORMDebugIsUnicodeCharDefined( sz[ich] ) )
			{
			sz[ich] = L'#';
			fUndefinedChar = fTrue;
			}			
		}
	return fUndefinedChar;
	}


//  ================================================================
LOCAL VOID NORMDebugUnitTest()
//  ================================================================
//
//	a unit test for the overrides on undefined chars
//
//-
	{

	NORMDebugResetUndefinedChars();

	Enforce( FNORMDebugIsUnicodeCharDefined( L'A' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'B' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'C' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'D' ) );
	
	Enforce( FNORMDebugIsUnicodeCharDefined( L'E' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'a' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'b' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'c' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'd' ) );

	_TCHAR szUndefined[256];
	_tcscpy( szUndefined, _T( "0x0041,0x0042,0x0043,0x0044,0xfaaaa" ) );

	NORMDebugLoadUndefinedCharsFromString( szUndefined );

	Enforce( !FNORMDebugIsUnicodeCharDefined( L'A' ) );
	Enforce( !FNORMDebugIsUnicodeCharDefined( L'B' ) );
	Enforce( !FNORMDebugIsUnicodeCharDefined( L'C' ) );
	Enforce( !FNORMDebugIsUnicodeCharDefined( L'D' ) );
	
	Enforce( FNORMDebugIsUnicodeCharDefined( L'E' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'a' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'b' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'c' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'd' ) );

	const WCHAR * szBefore 	= L"ABCDEFGHIJKLMabcdefghijklm123456&*()-=";
	const WCHAR * szAfter	= L"XXXXEFGHIJLKMabcdefghijklm123456&*()-=";

	const INT cb	= sizeof( szBefore );
	Enforce( cb == sizeof( szAfter ) );
	const INT cch 	= cb / sizeof( WCHAR );

	WCHAR szT[cch];

	Enforce( FNORMDebugStringHasUndefinedChars( (BYTE *)szBefore, cb ) );
	Enforce( !FNORMDebugStringHasUndefinedChars( (BYTE *)szAfter, cb ) );
	
	memcpy( szT, szBefore, cb );
	Enforce( 0 == memcmp( szT, szBefore, cb ) );

	Enforce( FNORMDebugStripUndefinedChars( szT, cch ) );
	Enforce( 0 == memcmp( szT, szAfter, cb ) );
		
	NORMDebugResetUndefinedChars();

	Enforce( FNORMDebugIsUnicodeCharDefined( L'A' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'B' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'C' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'D' ) );
	
	Enforce( FNORMDebugIsUnicodeCharDefined( L'E' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'a' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'b' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'c' ) );
	Enforce( FNORMDebugIsUnicodeCharDefined( L'd' ) );
	
	}	


#endif	//	!RTM


typedef
WINBASEAPI
BOOL
WINAPI
PFNGetNLSVersion(
    IN  NLS_FUNCTION     Function,
    IN  LCID             Locale,
    OUT LPNLSVERSIONINFO lpVersionInformation );

typedef
WINBASEAPI
BOOL
WINAPI
PFNIsNLSDefinedString(
    IN NLS_FUNCTION     Function,
    IN DWORD            dwFlags,
    IN LPNLSVERSIONINFO lpVersionInformation,
    IN LPCWSTR          lpString,
    IN INT              cchStr );
	
LOCAL BOOL WINAPI GetNLSNotSupported(
    IN  NLS_FUNCTION     Function,
    IN  LCID             Locale,
    OUT LPNLSVERSIONINFO lpVersionInformation );

LOCAL BOOL WINAPI IsNLSDefinedStringNotSupported(
    IN NLS_FUNCTION     Function,
    IN DWORD            dwFlags,
    IN LPNLSVERSIONINFO lpVersionInformation,
    IN LPCWSTR          lpString,
    IN INT              cchStr);

LOCAL PFNGetNLSVersion*			g_pfnGetNLSVersion 		= NULL;
LOCAL PFNIsNLSDefinedString*	g_pfnIsNLSDefinedString = NULL;

LOCAL HMODULE			g_hmod;


//  ================================================================
LOCAL ERR ErrLoadNORMFunctions()
//  ================================================================
	{
	if ( NULL == ( g_hmod = LoadLibrary( _T( "kernel32.dll" ) ) ) )
		{
		return ErrERRCheck( JET_errFileNotFound );
		}

	g_pfnGetNLSVersion = (PFNGetNLSVersion*)GetProcAddress( g_hmod, _T( "GetNLSVersion" ) );
	if( NULL == g_pfnGetNLSVersion )
		{
		g_pfnGetNLSVersion = GetNLSNotSupported;
		}

	g_pfnIsNLSDefinedString = (PFNIsNLSDefinedString*)GetProcAddress( g_hmod, _T( "IsNLSDefinedString" ) );
	if( NULL == g_pfnIsNLSDefinedString )
		{
		g_pfnIsNLSDefinedString = IsNLSDefinedStringNotSupported;
		}

	return JET_errSuccess;
	}


//  ================================================================
LOCAL VOID UnloadNORMFunctions()
//  ================================================================
	{
	if ( g_hmod )
		{
		FreeLibrary( g_hmod );
		}		

	g_hmod 					= NULL;
	g_pfnGetNLSVersion 		= NULL;
	g_pfnIsNLSDefinedString = NULL;
	}


//  ================================================================
LOCAL BOOL WINAPI GetNLSNotSupported(
    IN  NLS_FUNCTION     Function,
    IN  LCID             Locale,
    OUT LPNLSVERSIONINFO lpVersionInformation )
//  ================================================================
	{
	Assert( sizeof( NLSVERSIONINFO ) == lpVersionInformation->dwNLSVersionInfoSize );
	if( sizeof( NLSVERSIONINFO ) != lpVersionInformation->dwNLSVersionInfoSize )
		{
		Assert( fFalse );
		return fFalse;
		}
	lpVersionInformation->dwNLSVersion 		= 0;
	lpVersionInformation->dwDefinedVersion	= 0;
	return fTrue;
	}


//  ================================================================
LOCAL BOOL WINAPI IsNLSDefinedStringNotSupported(
    IN NLS_FUNCTION     Function,
    IN DWORD            dwFlags,
    IN LPNLSVERSIONINFO lpVersionInformation,
    IN LPCWSTR          lpString,
    IN INT              cchStr )
//  ================================================================
	{
	return fFalse;
	}


//  ================================================================
ERR ErrNORMGetSortVersion( const LCID lcid, QWORD * const pqwVersion )
//  ================================================================
//
//-
	{
	*pqwVersion = 0;

#ifndef RTM
	//	check registry overrides for this LCID
	//	the override should be a string of the form version.defined version (e.g. 123.789)

	_TCHAR sz[64];
	_TCHAR szLcid[16];

	_stprintf( szLcid, "%d", lcid );

	if ( FOSConfigGet( _T( "OS\\LCID" ), szLcid, sz, sizeof( sz ) - 1 ) && sz[0] )
		{
		const _TCHAR * const szNLS		= _tcstok( sz, _T( "." ) );		
		const _TCHAR * const szDefined	= _tcstok( NULL, _T( "." ) );		
		const DWORD dwNLS				= atoi( szNLS );
		const DWORD dwDefined			= atoi( szDefined );
		/*
		_TCHAR					szMessage[256];
		const _TCHAR *			rgszT[1]			= { szMessage };
		
		_stprintf(
				szMessage, 
				_T( "Sort ordering for LCID %d changed through the registry to %d.%d" ), 
				lcid,
				dwNLS,
				dwDefined );
		UtilReportEvent(
				eventWarning,
				GENERAL_CATEGORY,
				PLAIN_TEXT_ID,
				1,
				rgszT );
		*/
		
		*pqwVersion = QwSortVersionFromNLSDefined( dwNLS, dwDefined );
		
		return JET_errSuccess;
		}

#endif

	NLSVERSIONINFO nlsversioninfo;
	nlsversioninfo.dwNLSVersionInfoSize = sizeof( nlsversioninfo );
	
	const BOOL fSuccess = (*g_pfnGetNLSVersion)( COMPARE_STRING, lcid, &nlsversioninfo );

	if( !fSuccess )
		{
		Assert( 0 == *pqwVersion );
		return ErrERRCheck( JET_errInvalidLanguageId );
		}
	else
		{
		*pqwVersion = QwSortVersionFromNLSDefined( nlsversioninfo.dwNLSVersion, nlsversioninfo.dwDefinedVersion );		

		return JET_errSuccess;
		}
	}


//  ================================================================
BOOL FNORMStringHasUndefinedChars(
		IN const BYTE * pbColumn,
		IN const INT cbColumn )
//  ================================================================
	{
#ifdef _X86_
#else
	//	convert pbColumn to aligned pointer for IA64 builds
	BYTE    rgbColumn[JET_cbKeyMost+1];
	Assert( cbColumn <= sizeof( rgbColumn ) );
	UtilMemCpy( rgbColumn, pbColumn, cbColumn );
	pbColumn = rgbColumn;
#endif

#ifndef RTM
	if( FNORMDebugStringHasUndefinedChars( pbColumn, cbColumn ) )
		{
		return fTrue;
		}
#endif

	const INT cchColumn = cbColumn / sizeof( WCHAR );	
	return !(*g_pfnIsNLSDefinedString)( COMPARE_STRING, 0, NULL, (LPCWSTR)pbColumn, cchColumn );
	}


//  ================================================================
BOOL FNORMStringHasUndefinedCharsIsSupported()
//  ================================================================
	{
	return ( g_pfnIsNLSDefinedString != NULL
			&& g_pfnIsNLSDefinedString != IsNLSDefinedStringNotSupported );
	}


LOCAL ERR ErrNORMReportInvalidLCMapFlags( INST * const pinst, const DWORD dwLCMapFlags )
	{
	_TCHAR			szLCMapFlags[16];
	const ULONG		cszT				= 1;
	const _TCHAR*	rgszT[cszT]			= { szLCMapFlags };

	_stprintf( szLCMapFlags, _T( "0x%0*x" ), sizeof(DWORD)*2, dwLCMapFlags );
	Assert( _tcslen( szLCMapFlags ) < sizeof( szLCMapFlags ) / sizeof( _TCHAR ) );
	UtilReportEvent(
			eventError,
			GENERAL_CATEGORY,
			INVALID_LCMAPFLAGS_ID,
			cszT,
			rgszT,
			0,
			NULL,
			pinst );
	return ErrERRCheck( JET_errInvalidLCMapStringFlags );
	}

ERR ErrNORMCheckLCMapFlags( INST * const pinst, const DWORD dwLCMapFlags )
	{
	const DWORD		dwValidFlags	= ( LCMAP_BYTEREV
										| NORM_IGNORECASE
										| NORM_IGNORENONSPACE
										| NORM_IGNORESYMBOLS
										| NORM_IGNOREKANATYPE
										| NORM_IGNOREWIDTH
										| SORT_STRINGSORT );

	//	MUST have at least LCMAP_SORTKEY
	return ( LCMAP_SORTKEY == ( dwLCMapFlags & ~dwValidFlags ) ?
				JET_errSuccess :
				ErrNORMReportInvalidLCMapFlags( pinst, dwLCMapFlags ) );
	}


ERR ErrNORMCheckLCMapFlags( INST * const pinst, DWORD * const pdwLCMapFlags )
	{
	*pdwLCMapFlags |= LCMAP_SORTKEY;
	return ErrNORMCheckLCMapFlags( pinst, *pdwLCMapFlags );
	}


//	We are relying on the fact that the normalised key will never be
//	smaller than the original data, so we know that we can normalise
//	at most cbKeyMax characters.
const ULONG		cbColumnNormMost	= JET_cbKeyMost + 1;	//	ensure word-aligned

//	UNDONE: refine this constant based on unicode key format
//	Allocate enough for the common case - if more is required it will be
//	allocated dynamically
const ULONG		cbUnicodeKeyMost	= cbColumnNormMost * 3 + 32;

/*	From K.D. Chang, Lori Brownell, and Julie Bennett, here's the maximum
	sizes, in bytes, of a normalised string returned by LCMapString():

	If there are no Japanese Katakana or Hiragana characters:
	(number of input chars) * 4 + 5
	(number of input chars) * 3 + 5		// IgnoreCase

	If there are Japanese Katakana or Hiragana characters:
	(number of input chars) * 8 + 5
	(number of input chars) * 5 + 5		// IgnoreCase, IgnoreKanatype, IgnoreWidth

	So given that we ALWAYS specify IgnoreCase, IgnoreKanatype, and
	IgnoreWidth, that means our cbUnicodeKeyMost constant will almost
	always be enough to	satisfy any call to LCMapString(), except if
	Japanese Katakana or Hiragana characters are in a very long string
	(160 bytes or more), in which case we may need to make multiple calls
	to LCMapString() and dynamically allocate a big	enough buffer.
*/


#ifdef DEBUG_NORM
VOID NORMPrint( const BYTE * const pb, const INT cb )
	{
	INT		cbT		= 0;

	while ( cbT < cb )
		{
		INT	i;
		INT	cbTSav	= cbT;
		for ( i = 0; i < 16; i++ )
			{
			if ( cbT < cb )
				{
				printf( "%02x ", pb[cbT] );
				cbT++;
				}
			else
				{
				printf( "   " );
				}
			}

		cbT = cbTSav;
		for ( i = 0; i < 16; i++ )
			{
			if ( cbT < cb )
				{
				printf( "%c", ( isprint( pb[cbT] ) ? pb[cbT] : '.' ) );
				cbT++;
				}
			else
				{
				printf( " " );
				}
			}
		printf( "\n" );
		}
	}
#endif	//	DEBUG_NORM


INLINE CbNORMMapString_(
	const LCID			lcid,
	const DWORD			dwLCMapFlags,
	BYTE *				pbColumn,
	const INT			cbColumn,
	BYTE *				rgbKey,
	const INT			cbKeyMost )
	{
	Assert( fUnicodeSupport );

	return LCMapStringW(
					lcid,
					dwLCMapFlags,
					(LPCWSTR)pbColumn,
					cbColumn / sizeof(WCHAR),
					(LPWSTR)rgbKey,
					cbKeyMost );
	}


LOCAL ERR ErrNORMIMapString(
	const LCID		lcid,
	const DWORD		dwLCMapFlags,
	BYTE *			pbColumn,
	INT				cbColumn,
	BYTE * const	rgbSeg,
	const INT		cbMax,
	INT * const		pcbSeg )
	{
	ERR				err							= JET_errSuccess;
	BYTE    		rgbKey[cbUnicodeKeyMost];
	INT				cbKey;

	if ( !fUnicodeSupport )
		return ErrERRCheck( JET_errUnicodeNormalizationNotSupported );

	//	assert key buffer doesn't exceed maximum (minus header byte)
	Assert( cbMax < JET_cbKeyMost );

	//	assert non-zero length unicode string
	Assert( cbColumn > 0 );
	cbColumn = min( cbColumn, cbColumnNormMost );

	Assert( cbColumn > 0 );
	Assert( cbColumn % 2 == 0 );

#ifdef _X86_
#else
	//	convert pbColumn to aligned pointer for MIPS/Alpha builds
	BYTE    rgbColumn[cbColumnNormMost];
	UtilMemCpy( rgbColumn, pbColumn, cbColumn );
	pbColumn = rgbColumn;
#endif

	Assert( lcidNone != lcid );
	
	cbKey = CbNORMMapString_(
					lcid,
					dwLCMapFlags,
					pbColumn,
					cbColumn,
					rgbKey,
					cbUnicodeKeyMost );
		
	if ( 0 == cbKey )
		{
		DWORD	dwErr	= GetLastError();

		if ( ERROR_INSUFFICIENT_BUFFER == dwErr )
			{
			//	ERROR_INSUFFICIENT_BUFFER means that our preallocated buffer was not big enough
			//	to hold the normalised string.  This should only happen in *extremely* rare
			//	circumstances (see comments just above this function).
			//	So what we have to do here is call LCMapString() again with a NULL buffer.
			//	This will return to us the size, in bytes, of the normalised string without
			//	actually returning the normalised string.  We then dynamically allocate
			//	a buffer of the specified size, then make the call to LCMapString() again
			//	using that buffer.
			//	UNDONE: We could avoid this whole path if LCMapString() normalised as much
			//	as possible even if the buffer is not large enough.  Unfortunately, it does
			//	not work that way.

			cbKey = CbNORMMapString_(
							lcid,
							dwLCMapFlags,
							pbColumn,
							cbColumn,
							NULL,
							0 );
			if ( 0 == cbKey )
				{
				dwErr = GetLastError();
				}
			else
				{
				BYTE		*pbNormBuf;
				const ULONG	cbNormBuf	= cbKey;

				Assert( IsValidLocale( lcid, LCID_INSTALLED ) );

				//	we should be guaranteed to overrun the default buffer
				//	and also the remaining key space
				Assert( cbKey > cbUnicodeKeyMost );
				Assert( cbKey > cbMax );

				pbNormBuf = (BYTE *)PvOSMemoryHeapAlloc( cbNormBuf );
				if ( NULL == pbNormBuf )
					{
					err = ErrERRCheck( JET_errOutOfMemory );
					}
				else
					{
					cbKey = CbNORMMapString_(
									lcid,
									dwLCMapFlags,
									pbColumn,
									cbColumn,
									pbNormBuf,
									cbNormBuf );

					//	this call shouldn't fail because we've
					//	already validated the lcid and
					//	allocated a sufficiently large buffer
					Assert( 0 != cbKey );

					if ( 0 != cbKey )
						{
						Assert( IsValidLocale( lcid, LCID_INSTALLED ) );
						Assert( cbKey > cbMax );
						Assert( cbNormBuf == cbKey );
						UtilMemCpy( rgbSeg, pbNormBuf, cbMax );
						*pcbSeg = cbMax;
						err = ErrERRCheck( wrnFLDKeyTooBig );
						}

					OSMemoryHeapFree( pbNormBuf );
					}
				}
			}

		if ( 0 == cbKey )
			{
			switch( dwErr )
				{
				case ERROR_INVALID_USER_BUFFER:
				case ERROR_NOT_ENOUGH_MEMORY:
				case ERROR_WORKING_SET_QUOTA:
				case ERROR_NO_SYSTEM_RESOURCES:
					err = ErrERRCheck( JET_errOutOfMemory );
					break;

				case ERROR_INSUFFICIENT_BUFFER:
					Assert( fFalse );	//	should be impossible, since filtered out above
				default:
					err = ErrERRCheck( JET_errUnicodeTranslationFail );
				}
			}
		}
	else
		{
		Assert( cbKey > 0 );
		Assert( IsValidLocale( lcid, LCID_INSTALLED ) );

		if ( cbKey > cbMax )
			{
			err = ErrERRCheck( wrnFLDKeyTooBig );
			*pcbSeg = cbMax;
			}
		else
			{
			CallS( err );
			*pcbSeg = cbKey;
			}
		UtilMemCpy( rgbSeg, rgbKey, *pcbSeg );
		}

#ifdef DEBUG_NORM
	printf( "\nOriginal Text (length %d):\n", cbColumn );
	NORMPrint( pbColumn, cbColumn );
	printf( "Normalized Text (length %d):\n", *pcbSeg );
	NORMPrint( rgbSeg, *pcbSeg );
	printf( "\n" );
#endif	
	
	return err;
	}


ERR ErrNORMMapString(
	const LCID		lcid,
	const DWORD		dwLCMapFlags,
	BYTE *			pbColumn,
	INT				cbColumn,
	BYTE * const	rgbSeg,
	const INT		cbMax,
	INT * const		pcbSeg )
	{
#ifndef RTM
	if( g_fUndefinedChars )
		{
		WCHAR rgchColumn[cbColumnNormMost];
		UtilMemCpy( rgchColumn, pbColumn, cbColumn );
		(VOID)FNORMDebugStripUndefinedChars( rgchColumn, cbColumn / sizeof( WCHAR ) );
		return ErrNORMIMapString( lcid, dwLCMapFlags, (BYTE *)rgchColumn, cbColumn, rgbSeg, cbMax, pcbSeg );
		}
#endif	
	return ErrNORMIMapString( lcid, dwLCMapFlags, pbColumn, cbColumn, rgbSeg, cbMax, pcbSeg );
	}



#ifdef DEAD_CODE

ERR ErrNORMWideCharToMultiByte(	unsigned int CodePage,
								DWORD dwFlags,
								const wchar_t* lpWideCharStr,
								int cwchWideChar,
								char* lpMultiByteStr,
								int cchMultiByte,
								const char* lpDefaultChar,
								BOOL* lpUsedDefaultChar,
								int* pcchMultiByteActual )
	{
	int cch = WideCharToMultiByte( CodePage, dwFlags, lpWideCharStr,
				cwchWideChar, lpMultiByteStr, cchMultiByte, lpDefaultChar, lpUsedDefaultChar );
	if (!cch )
		{
		DWORD dw = GetLastError();
		if ( dw == ERROR_INSUFFICIENT_BUFFER )
			return ErrERRCheck( JET_errUnicodeTranslationBufferTooSmall );
		else
			{
			Assert( dw == ERROR_INVALID_FLAGS ||
			    	dw == ERROR_INVALID_PARAMETER );
			return ErrERRCheck( JET_errUnicodeTranslationFail );
			}
		}
	*pcchMultiByteActual = cch;
	return JET_errSuccess;
	}

ERR ErrNORMMultiByteToWideChar(	unsigned int CodePage,			// code page
								DWORD dwFlags,					// character-type options
								const char* lpMultiByteStr,		// address of string to map
								int cchMultiByte,				// number of characters in string
								wchar_t* lpWideCharStr,			// address of wide-character buffer 
								int cwchWideChar,				// size of buffer
								int* pcwchActual )
	{
	int cwch = MultiByteToWideChar( CodePage, dwFlags, lpMultiByteStr,
			cchMultiByte, lpWideCharStr, cwchWideChar );
	if (!cwch )
		{
		DWORD dw = GetLastError();
		if ( dw == ERROR_INSUFFICIENT_BUFFER )
			return ErrERRCheck( JET_errUnicodeTranslationBufferTooSmall );
		else
			{
			Assert( dw == ERROR_INVALID_FLAGS ||
			 		dw == ERROR_INVALID_PARAMETER ||
			 		dw == ERROR_NO_UNICODE_TRANSLATION );
			return ErrERRCheck( JET_errUnicodeTranslationFail );
			}
		}

	*pcwchActual = cwch;
	return JET_errSuccess;
	}

#endif	//	DEAD_CODE


//  post-terminate norm subsystem

void OSNormPostterm()
	{
	//  nop
	}

//  pre-init norm subsystem

BOOL FOSNormPreinit()
	{
	//  nop

	return fTrue;
	}


//  terminate norm subsystem

void OSNormTerm()
	{
	fUnicodeSupport = fFalse;

	UnloadNORMFunctions();
	}

//  init norm subsystem

ERR ErrOSNormInit()
	{
	fUnicodeSupport = ( 0 != LCMapStringW( LOCALE_NEUTRAL, LCMAP_LOWERCASE, L"\0", 1, NULL, 0 ) );

#ifdef DEBUG
	AssertNORMConstants();
#endif	//	DEBUG

#ifndef RTM

	//	a unit test for the convenience functions

	const DWORD dwNLSVersion 		= 0x1234;
	const DWORD dwDefinedVersion	= 0x5678;

	const QWORD qwVersion 			= QwSortVersionFromNLSDefined( dwNLSVersion, dwDefinedVersion );
	const DWORD dwNLSVersionT		= DwNLSVersionFromSortVersion( qwVersion );
	const DWORD dwDefinedVersionT	= DwDefinedVersionFromSortVersion( qwVersion );

	Enforce( dwNLSVersionT == dwNLSVersion );
	Enforce( dwDefinedVersionT == dwDefinedVersion );

///	NORMDebugUnitTest();
	NORMDebugLoadUndefinedCharsFromRegistry();
	
#endif	//	!RTM

	ERR err = JET_errSuccess;

	Call( ErrLoadNORMFunctions() );

HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\memory.cxx ===
#include "osstd.hxx"

#include "mpheap.hxx"			//	MP Heap

#include <math.h>
#include <malloc.h>


#if defined( RTM ) || !defined( DEBUG ) && defined( _M_IA64 )
#else  //  !RTM && ( DEBUG || !_M_IA64 )
#define ENABLE_MEM_COUNTERS
#endif  //  RTM || !DEBUG && _M_IA64

#ifdef MEM_CHECK

void OSMemoryIDumpAlloc( const _TCHAR* szDumpFile, const BOOL memDump = fTrue );

int g_fMemCheck = 0;

#endif	//	MEM_CHECK


//  System Memory Attributes

//  returns the system page reserve granularity

LOCAL DWORD dwPageReserveGran;

DWORD OSMemoryPageReserveGranularity()
	{
	return dwPageReserveGran;
	}

//  returns the system page commit granularity

LOCAL DWORD dwPageCommitGran;

DWORD OSMemoryPageCommitGranularity()
	{
	return dwPageCommitGran;
	}

//  returns the current available physical memory in the system

HKEY hkeyWin9xStats;

DWORD_PTR OSMemoryAvailable()
	{
	//  we are running on NT

	if ( !hkeyWin9xStats )
		{
		//  return the amount of available physical memory as reported by NT

		MEMORYSTATUS ms = { sizeof( MEMORYSTATUS ) };
		GlobalMemoryStatus( &ms );
		return ms.dwAvailPhys;
		}

	//  we are running on Windows

	else
		{
		//  get the amount of available physical memory as reported by Windows.
		//  this amount does not include any RAM used by the disk cache

		MEMORYSTATUS ms = { sizeof( MEMORYSTATUS ) };
		GlobalMemoryStatus( &ms );

		//  get the current and minimum size of the disk cache.  the difference
		//  is the amount of memory that Windows could give up

		DWORD	cbData;
		DWORD	cbDiskcache;
		DWORD	cbDiskcacheMin;

		cbDiskcache		= 0;
		cbData			= sizeof( cbDiskcache );
		(void)RegQueryValueEx(	hkeyWin9xStats,
								"VMM\\cpgDiskcache",
								NULL,
								NULL,
								(BYTE*)&cbDiskcache,
								&cbData );

		cbDiskcacheMin	= 0;
		cbData			= sizeof( cbDiskcacheMin );
		(void)RegQueryValueEx(	hkeyWin9xStats,
								"VMM\\cpgDiskcacheMin",
								NULL,
								NULL,
								(BYTE*)&cbDiskcacheMin,
								&cbData );

		//  return the amount of available physical memory including what the
		//  Windows disk cache could release

		return ms.dwAvailPhys + cbDiskcache - cbDiskcacheMin;
		}
	}

//  returns the total physical memory in the system

LOCAL DWORD_PTR cbMemoryTotal;

DWORD_PTR OSMemoryTotal()
	{
	return cbMemoryTotal;
	}

//  returns the current available virtual address space in the process

DWORD_PTR OSMemoryPageReserveAvailable()
	{
	MEMORYSTATUS ms = { sizeof( MEMORYSTATUS ) };
	GlobalMemoryStatus( &ms );
	return ms.dwAvailVirtual;
	}

//  returns the total virtual address space in the process

LOCAL DWORD_PTR cbPageReserveTotal;

DWORD_PTR OSMemoryPageReserveTotal()
	{
	return cbPageReserveTotal;
	}

//  returns the total number of physical memory pages evicted from the system

typedef
NTSYSCALLAPI
NTSTATUS
NTAPI
PFNNtQuerySystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

BOOL							fEvictStatsInit;
PFNNtQuerySystemInformation*	pfnNtQuerySystemInformation;

enum	{ cRollingAvgDepth = 3 };
size_t	cAvailPage[ cRollingAvgDepth ];
int		icAvailPageOldest;
double	cAvailPageSum;
double	cAvailPageAvg;
long	cPageAllocLast;
DWORD	cPageEvict;

DWORD OSMemoryPageEvictionCount()
	{
	//  we are running on Windows

	if ( hkeyWin9xStats )
		{
		//  read the page eviction rate straight from Windows

		DWORD	cbData;
		DWORD	cDiscards;

		cDiscards		= 0;
		cbData			= sizeof( cDiscards );
		(void)RegQueryValueEx(	hkeyWin9xStats,
								"VMM\\cDiscards",
								NULL,
								NULL,
								(BYTE*)&cDiscards,
								&cbData );

		cPageEvict = cDiscards;
		}

	//  we are running on NT

	else
		{
		//  try to read the page eviction rate straight from NT

    	SYSTEM_FILECACHE_INFORMATION sysfcinfo = { 0 };
		pfnNtQuerySystemInformation(	SystemFileCacheInformation,
										&sysfcinfo,
										sizeof( sysfcinfo ),
										NULL );

		//  if the page eviction count was not set then it must not exist on
		//  this version of NT so we will have to try to estimate it

		if ( !sysfcinfo.TransitionRePurposeCount )
			{
			//  NT isn't courteous enough to expose its page eviction rate so we must
			//  go through a lot of machinations to estimate it.  we do this by
			//  ASSUMING that as memory gets short, all page faults indirectly cause
			//  a page eviction to satisfy them.  note that this number is less
			//  accurate when someone on the system is churning quickly through a
			//  small pool of memory but not actually applying memory pressure
			//
			//  NOTE:  this function must be called often to be accurate

			const size_t cAvailPageMin = 1024;  //  NT's page eviction threshold

			if ( !fEvictStatsInit )
				{
				size_t cAvailPageInit = OSMemoryAvailable() / OSMemoryPageCommitGranularity();
				for ( icAvailPageOldest = cRollingAvgDepth - 1; icAvailPageOldest >= 0; icAvailPageOldest-- )
					{
					cAvailPage[ icAvailPageOldest ] = cAvailPageInit;
					}
				icAvailPageOldest = 0;
				cAvailPageSum = cRollingAvgDepth * (double)cAvailPageInit;
				cAvailPageAvg = (double)cAvailPageInit;

				SYSTEM_PERFORMANCE_INFORMATION sysperfinfo;
				pfnNtQuerySystemInformation(	SystemPerformanceInformation,
												&sysperfinfo,
												sizeof( sysperfinfo ),
												NULL );
				cPageAllocLast	= sysperfinfo.PageFaultCount;

				cPageEvict		= 0;

				fEvictStatsInit	= fTrue;
				}
			else
				{
				cAvailPageSum -= cAvailPage[ icAvailPageOldest ];
				cAvailPage[ icAvailPageOldest ] = OSMemoryAvailable() / OSMemoryPageCommitGranularity();
				cAvailPageSum += cAvailPage[ icAvailPageOldest ];
				icAvailPageOldest = ( icAvailPageOldest + 1 ) % cRollingAvgDepth;
				cAvailPageAvg = (double)cAvailPageSum / (double)cRollingAvgDepth;

		    	SYSTEM_PERFORMANCE_INFORMATION sysperfinfo;
				pfnNtQuerySystemInformation(	SystemPerformanceInformation,
												&sysperfinfo,
												sizeof( sysperfinfo ),
												NULL );
				long	cPageAlloc		= sysperfinfo.PageFaultCount;
				long	dcPageAlloc		= cPageAlloc - cPageAllocLast;

				double	k;
				if ( cAvailPageAvg > 1.125 * cAvailPageMin )
					{
					k = 0;
					}
				else if ( cAvailPageAvg > 1.0 * cAvailPageMin )
					{
					k = 1 - ( cAvailPageAvg - 1.0 * cAvailPageMin ) / ( ( 1.125 - 1.0 ) * cAvailPageMin );
					}
				else
					{
					k = 1;
					}

				double	dcPageEvict;
				modf( k * dcPageAlloc + 0.5, &dcPageEvict );

				cPageAllocLast	= cPageAlloc;
				cPageEvict		= cPageEvict + long( dcPageEvict );
				}
			}

		//  we are running on a version of NT that exposes the page eviction
		//  rate directly

		else
			{
			//  read the page eviction rate straight from NT

			cPageEvict = sysfcinfo.TransitionRePurposeCount;
			}
		}

	//  return the current page eviction count

	return cPageEvict;
	}


//  Sparse Bitmap implementation of IBitmapAPI

class CSparseBitmap  //  sbm
	:	public IBitmapAPI
	{
	public:  //  specialized API

		//  ctor

		CSparseBitmap();

		//  initializes the Sparse Bitmap

		ERR ErrInit( const size_t cbit );

		//  sets the bitmap to read only mode

		ERR ErrDisableUpdates();

	public:  //  IBitmapAPI

		virtual ~CSparseBitmap();

		virtual ERR ErrSet( const size_t iBit, const BOOL fValue );
		virtual ERR ErrGet( const size_t iBit, BOOL* const pfValue );

	private:

		size_t	m_cbit;
		void*	m_rgbit;
		size_t	m_cbitUpdate;
		size_t	m_cbitCommit;
		void*	m_rgbitCommit;
		size_t	m_shfCommit;
	};

CSparseBitmap::CSparseBitmap()
	:	m_cbit( 0 ),
		m_rgbit( NULL ),
		m_cbitUpdate( 0 ),
		m_cbitCommit( 0 ),
		m_rgbitCommit( NULL ),
		m_shfCommit( 0 )
	{
	}

IBitmapAPI::ERR CSparseBitmap::ErrInit( const size_t cbit )
	{
	if ( m_cbit || !cbit )
		{
		return IBitmapAPI::errInvalidParameter;
		}

	m_cbit	= cbit;
	m_rgbit	= PvOSMemoryPageReserve( ( m_cbit + 7 ) / 8, NULL );

	if ( !m_rgbit )
		{
		m_cbit = 0;
		return IBitmapAPI::errOutOfMemory;;
		}

	m_cbitUpdate = m_cbit;

	m_cbitCommit	= ( ( m_cbit + 7 ) / 8 + OSMemoryPageCommitGranularity() - 1 ) / OSMemoryPageCommitGranularity();
	m_rgbitCommit	= new BYTE[ ( m_cbitCommit + 7 ) / 8 ];

	if ( !m_rgbitCommit )
		{
		m_cbit = 0;
		OSMemoryPageFree( m_rgbit );
		m_rgbit = NULL;
		m_cbitUpdate = 0;
		m_cbitCommit = 0;
		return IBitmapAPI::errOutOfMemory;;
		}

	memset( m_rgbitCommit, 0, ( m_cbitCommit + 7 ) / 8 );

	for ( m_shfCommit = 0; ( 1 << m_shfCommit ) < 8 * OSMemoryPageCommitGranularity(); m_shfCommit++ );

	return IBitmapAPI::errSuccess;
	}

IBitmapAPI::ERR CSparseBitmap::ErrDisableUpdates()
	{
	if ( !m_cbit )
		{
		return IBitmapAPI::errInvalidParameter;
		}

	m_cbitUpdate = 0;

	return IBitmapAPI::errSuccess;
	}

CSparseBitmap::~CSparseBitmap()
	{
	m_cbit = 0;
	OSMemoryPageDecommit( m_rgbit, ( m_cbit + 7 ) / 8 );
	OSMemoryPageFree( m_rgbit );
	m_rgbit = NULL;
	m_cbitUpdate = 0;
	m_cbitCommit = 0;
	delete [] m_rgbitCommit;
	m_rgbitCommit = NULL;
	m_shfCommit = 0;
	}

IBitmapAPI::ERR CSparseBitmap::ErrSet( const size_t iBit, const BOOL fValue )
	{
	size_t	iBitCommit;
	BYTE	bitCommit;
	BYTE*	pbyteCommit;
	BYTE 	bit;
	BYTE*	pbyte;
	BYTE	set;
	BYTE 	mask;

	if ( iBit >= m_cbitUpdate )
		{
		return IBitmapAPI::errInvalidParameter;
		}

	iBitCommit	= iBit >> m_shfCommit;
	bitCommit	= (BYTE)( 1 << ( iBitCommit & 7 ) );
	pbyteCommit	= (BYTE*)m_rgbitCommit + iBitCommit / 8;

	bit		= (BYTE)( 1 << ( iBit & 7 ) );
	pbyte	= (BYTE*)m_rgbit + iBit / 8;
	set		= (BYTE)( fValue ? bit : 0 );
	mask	= bit ^ 0xFF;

	if ( !( *pbyteCommit & bitCommit ) )
		{
		Assert( (BYTE*)m_rgbit + iBitCommit * OSMemoryPageCommitGranularity() <= pbyte );
		Assert( pbyte < (BYTE*)m_rgbit + ( iBitCommit + 1 ) * OSMemoryPageCommitGranularity() );
		if ( !FOSMemoryPageCommit( pbyte, 1 ) )
			{
			return IBitmapAPI::errOutOfMemory;
			}
		*pbyteCommit = *pbyteCommit | bitCommit;
		}
	Assert( !IsBadWritePtr( pbyte, 1 ) );

	*pbyte = *pbyte & mask | set;

	return IBitmapAPI::errSuccess;
	}

IBitmapAPI::ERR CSparseBitmap::ErrGet( const size_t iBit, BOOL* const pfValue )
	{
	size_t	iBitCommit;
	BYTE	bitCommit;
	BYTE*	pbyteCommit;
	BYTE	bit;
	BYTE*	pbyte;

	if ( iBit >= m_cbit )
		{
		return IBitmapAPI::errInvalidParameter;
		}

	iBitCommit	= iBit >> m_shfCommit;
	bitCommit	= (BYTE)( 1 << ( iBitCommit & 7 ) );
	pbyteCommit	= (BYTE*)m_rgbitCommit + iBitCommit / 8;

	bit		= (BYTE)( 1 << ( iBit & 7 ) );
	pbyte	= (BYTE*)m_rgbit + iBit / 8;

	if ( !( *pbyteCommit & bitCommit ) )
		{
		Assert( (BYTE*)m_rgbit + iBitCommit * OSMemoryPageCommitGranularity() <= pbyte );
		Assert( pbyte < (BYTE*)m_rgbit + ( iBitCommit + 1 ) * OSMemoryPageCommitGranularity() );
		if ( !FOSMemoryPageCommit( pbyte, 1 ) )
			{
			return IBitmapAPI::errOutOfMemory;
			}
		*pbyteCommit = *pbyteCommit | bitCommit;
		}
	Assert( !IsBadReadPtr( pbyte, 1 ) );

	*pfValue = !!( *pbyte & bit );

	return IBitmapAPI::errSuccess;
	}

//  returns a bitmap representing the residence of individual virtual memory
//  pages in physical memory

typedef
NTSYSCALLAPI
NTSTATUS
NTAPI
PFNNtQueryVirtualMemory (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN MEMORY_INFORMATION_CLASS MemoryInformationClass,
    OUT PVOID MemoryInformation,
    IN SIZE_T MemoryInformationLength,
    OUT PSIZE_T ReturnLength OPTIONAL
    );
PFNNtQueryVirtualMemory* pfnNtQueryVirtualMemory;

typedef
NTSYSCALLAPI
NTSTATUS
NTAPI
PFNNtQueryInformationProcess (
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
PFNNtQueryInformationProcess* pfnNtQueryInformationProcess;

DWORD			cPageOutput;
TICK			tickLastUpdate;
const TICK		dtickUpdateMin = 1 * 1000;  //  1 sec
DWORD 			dwUpdateId;
CSparseBitmap*	psbm;

ERR ErrOSMemoryPageResidenceMap( DWORD* const pdwUpdateId, IBitmapAPI** const ppbmapi )
	{
	ERR									err			= JET_errSuccess;
	CSparseBitmap*						psbmNew		= NULL;
	PMEMORY_WORKING_SET_INFORMATION		pmwsinfo	= NULL;

	//  we need to recompute our page residence map if:
	//  -  the kernel has trimmed memory since the last call and
	//  -  it has been some time since we refreshed the map

	if ( !pfnNtQuerySystemInformation )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	SYSTEM_PERFORMANCE_INFORMATION sysperfinfo;
	pfnNtQuerySystemInformation(	SystemPerformanceInformation,
									&sysperfinfo,
									sizeof( sysperfinfo ),
									NULL );
	if (	sysperfinfo.DirtyPagesWriteCount != cPageOutput &&
			TickOSTimeCurrent() - tickLastUpdate > dtickUpdateMin )
		{
		IBitmapAPI::ERR errBM = IBitmapAPI::errSuccess;

		//  get a new sparse bitmap object

        if ( !( psbmNew = new CSparseBitmap ) )
        {
            Call( ErrERRCheck( JET_errOutOfMemory ) );
        }

		//  setup an empty sparse bitmap object big enough to represent every
		//  possible VM page in our virtual address space

		size_t cPage;
		cPage = OSMemoryPageReserveTotal() / OSMemoryPageCommitGranularity();

		size_t cbit;
		for ( cbit = 1; cbit < cPage; cbit *= 2 );

		errBM = psbmNew->ErrInit( cbit );
		if ( errBM != IBitmapAPI::errSuccess )
			{
			Assert( errBM == IBitmapAPI::errOutOfMemory );
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		//  if we do not have a cached bitmap then we will leave the first
		//  cached bitmap empty and set the resulting update id to zero

		if ( !psbm )
			{
			dwUpdateId = -1;
			}

		//  fill the bitmap with our working set data

		else {
			NTSTATUS	status	= STATUS_INFO_LENGTH_MISMATCH;
			size_t		cb		= 0;

			//  fetch our working set list

			while ( status == STATUS_INFO_LENGTH_MISMATCH )
				{
				VM_COUNTERS vmcounters;
				pfnNtQueryInformationProcess(	GetCurrentProcess(),
												ProcessVmCounters,
												(void*)&vmcounters,
												sizeof( vmcounters ),
												NULL );
				size_t cpgPeakWorkingSetSize;
				cpgPeakWorkingSetSize = vmcounters.PeakWorkingSetSize / OSMemoryPageCommitGranularity();

				cb = sizeof( MEMORY_WORKING_SET_INFORMATION );
				cb = cb + ( cpgPeakWorkingSetSize - 1 ) * sizeof( MEMORY_WORKING_SET_BLOCK );
				cb = cb + cb / 10;  //  10% overkill in case we are growing

				OSMemoryPageFree( pmwsinfo );
				Alloc( pmwsinfo = (PMEMORY_WORKING_SET_INFORMATION)PvOSMemoryPageAlloc( cb, NULL ) );

				status = pfnNtQueryVirtualMemory(	GetCurrentProcess(),
													NULL,
													MemoryWorkingSetInformation,
													(void*)pmwsinfo,
													cb,
													NULL );
				}
			if ( !NT_SUCCESS( status ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}

			//  set a bit in the bitmap for each VM page that is present in the
			//  working set list

			size_t iWSInfo;
			for ( iWSInfo = 0; iWSInfo < pmwsinfo->NumberOfEntries; iWSInfo++ )
				{
				size_t iPage = pmwsinfo->WorkingSetInfo[ iWSInfo ].VirtualPage;

				errBM = psbmNew->ErrSet( iPage, fTrue );
				if ( errBM == IBitmapAPI::errOutOfMemory )
					{
					Call( ErrERRCheck( JET_errOutOfMemory ) );
					}
				}

			//  disable future updates of the bitmap

			errBM = psbmNew->ErrDisableUpdates();
			Assert( errBM == IBitmapAPI::errSuccess );
			}

		//  update our cached bitmap

		cPageOutput = sysperfinfo.DirtyPagesWriteCount;
		tickLastUpdate = TickOSTimeCurrent();
		dwUpdateId++;
		delete psbm;
		psbm = psbmNew;
		psbmNew = NULL;
		}

	//  return the cached update id and bitmap

	*pdwUpdateId	= dwUpdateId;
	*ppbmapi		= psbm;

HandleError:
	if ( err < JET_errSuccess )
		{
		delete psbmNew;
		*pdwUpdateId	= 0;
		*ppbmapi		= NULL;
		}
	OSMemoryPageFree( pmwsinfo );
	return err;
	}

//  returns the current available physical memory in the system taking any
//  existing process quotas into account

DWORD_PTR OSMemoryQuotaAvailable()
	{
	if ( pfnNtQueryInformationProcess )
		{
		NTSTATUS			status;
		QUOTA_LIMITS_EX		quota;
		ULONG				cbRet;
		status = pfnNtQueryInformationProcess(	GetCurrentProcess(),
												ProcessQuotaLimits,
												(void*)&quota,
												sizeof( quota ),
												&cbRet );
		if ( 	NT_SUCCESS( status ) && cbRet == sizeof( quota ) &&
				( quota.Flags & QUOTA_LIMITS_HARDWS_MAX_ENABLE ) )
			{
			VM_COUNTERS vmcounters;
			pfnNtQueryInformationProcess(	GetCurrentProcess(),
											ProcessVmCounters,
											(void*)&vmcounters,
											sizeof( vmcounters ),
											NULL );
			return min( OSMemoryAvailable(), quota.MaximumWorkingSetSize - vmcounters.WorkingSetSize );
			}
		}

	return OSMemoryAvailable();
	}

//  returns the total physical memory in the system taking any existing process
//  quotas into account

DWORD_PTR OSMemoryQuotaTotal()
	{
	if ( pfnNtQueryInformationProcess )
		{
		NTSTATUS			status;
		QUOTA_LIMITS_EX		quota;
		ULONG				cbRet;
		status = pfnNtQueryInformationProcess(	GetCurrentProcess(),
												ProcessQuotaLimits,
												(void*)&quota,
												sizeof( quota ),
												&cbRet );
		if ( 	NT_SUCCESS( status ) && cbRet == sizeof( quota ) &&
				( quota.Flags & QUOTA_LIMITS_HARDWS_MAX_ENABLE ) )
			{
			return min( OSMemoryTotal(), quota.MaximumWorkingSetSize );
			}
		}

	return OSMemoryTotal();
	}


//  Memory statistics

DWORD cAllocHeap;

long LOSHeapAllocPerSecCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = cAllocHeap;

	return 0;
	}

DWORD cFreeHeap;

long LOSHeapFreePerSecCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = cFreeHeap;

	return 0;
	}

long LOSHeapAllocCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = cAllocHeap - cFreeHeap;

	return 0;
	}

DWORD cbAllocHeap;

long LOSHeapBytesAllocCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = cbAllocHeap;

	return 0;
	}

DWORD_PTR cbReservePage;

long LOSPageBytesReservedCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = (unsigned long)cbReservePage;

	return 0;
	}

DWORD_PTR cbCommitPage;

long LOSPageBytesCommittedCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = (unsigned long)cbCommitPage;

	return 0;
	}


//  Memory Subsystem Init / Term

//    global MP heap

//NOTE:	Cannot initialise this variable because the code that allocates
//		TLS and uses this variable to store the index executes before
//		CRTInit, which would subsequently re-initialise the variable
//		with the value specified here
//DWORD tlsiHeapHint	= dwTlsInvalid;
DWORD	tlsiHeapHint;
BOOL	fTlsHeapHintAllocated;
HANDLE	hMPHeapGlobal;

#ifdef MEM_CHECK

//	MAI hash table

DWORD_PTR cmai;
struct MAI;
MAI** rgpmai;

DWORD ccsmai;
CRITICAL_SECTION* rgcsmai;

COSMemoryMap		*g_posmm;		//	list of COSMemoryMap objects
CRITICAL_SECTION	g_csosmm;		//	protection for COSMemoryMap list
BOOL				g_fcsosmmInit;	//	is the above critical section init

#endif  //  MEM_CHECK

//  multi-map capability

BOOL fCanMultiMap;


//  post-terminates the memory subsystem

void OSMemoryPostterm()
	{
	//  free page residence bitmap

	delete psbm;
	psbm = NULL;

	//  terminate Win9x stats

	if ( hkeyWin9xStats )
		{
		HKEY hkeyWin9xStatsStop;
		if ( RegOpenKeyEx(	HKEY_DYN_DATA,
							"PerfStats\\StopStat",
							0,
							KEY_READ,
							&hkeyWin9xStatsStop ) == ERROR_SUCCESS )
			{
			DWORD	cbData;
			DWORD	cbDiskcache;
			DWORD	cbDiskcacheMin;
			DWORD	cDiscards;

			cbDiskcache		= 0;
			cbData			= sizeof( cbDiskcache );
			(void)RegQueryValueEx(	hkeyWin9xStatsStop,
									"VMM\\cpgDiskcache",
									NULL,
									NULL,
									(BYTE*)&cbDiskcache,
									&cbData );

			cbDiskcacheMin	= 0;
			cbData			= sizeof( cbDiskcacheMin );
			(void)RegQueryValueEx(	hkeyWin9xStatsStop,
									"VMM\\cpgDiskcacheMin",
									NULL,
									NULL,
									(BYTE*)&cbDiskcacheMin,
									&cbData );

			cDiscards		= 0;
			cbData			= sizeof( cDiscards );
			(void)RegQueryValueEx(	hkeyWin9xStatsStop,
									"VMM\\cDiscards",
									NULL,
									NULL,
									(BYTE*)&cDiscards,
									&cbData );

			RegCloseKey( hkeyWin9xStatsStop );
			hkeyWin9xStatsStop = NULL;
			}

		RegCloseKey( hkeyWin9xStats );
		hkeyWin9xStats = NULL;
		}

	//  verify that there are no memory leaks

#ifdef MEM_CHECK
	if ( !FUtilProcessAbort() && g_posmm )
		{
		if ( g_fMemCheck )
			{
			COSMemoryMap::OSMMDumpAlloc( _T( "Assert.TXT" ) );
			}

		AssertSzRTL( fFalse, "Memory-Map Leak Detected" );
		}
#endif	//	MEM_CHECK

#ifdef DISABLE_PERF_COUNTERS
#else
	if ( !FUtilProcessAbort() && cbAllocHeap + cbReservePage > 0 )	//	+ cbCommitPage > 0 )
		{
#ifdef MEM_CHECK
		if ( g_fMemCheck )
			{
			OSMemoryIDumpAlloc( _T( "Assert.TXT" ) );
			}

#endif  //  MEM_CHECK

		AssertSzRTL( fFalse, "Memory Leak Detected" );
		}
#endif	//	DISABLE_PERF_COUNTERS

#ifdef MEM_CHECK

	//	free COSMemoryMap critical section

	if( g_fcsosmmInit )
		{
		DeleteCriticalSection( &g_csosmm );
		g_fcsosmmInit = fFalse;
		}

	//  free MAI hash table critical section pool

	if ( rgcsmai )
		{
		int icsmai;
		for ( icsmai = 0; icsmai < ccsmai; icsmai++ )
			{
			DeleteCriticalSection( rgcsmai + icsmai );
			}
		BOOL fFreedCSPool = !LocalFree( rgcsmai );
		Assert( fFreedCSPool );
		rgcsmai = NULL;
		}

	//  free MAI hash table

	if ( rgpmai )
		{
		BOOL fMAIHashFreed = VirtualFree( rgpmai, 0, MEM_RELEASE );
		Assert( fMAIHashFreed );
		rgpmai = NULL;
		}

#endif  //  MEM_CHECK

	//  terminate global MP heap

	if ( hMPHeapGlobal )
		{
		BOOL fHeapDestroyed = MpHeapDestroy( hMPHeapGlobal );
		Assert( fHeapDestroyed );
		hMPHeapGlobal = NULL;
		}

	if ( fTlsHeapHintAllocated )
		{
		Assert( dwTlsInvalid != tlsiHeapHint );

		const BOOL	fTLSFreed = TlsFree( tlsiHeapHint );
		Assert( fTLSFreed );		//	leak the TLS entry if we fail

		tlsiHeapHint = dwTlsInvalid;
		fTlsHeapHintAllocated = fFalse;
		}
	}


//  pre-initialize the memory subsystem

BOOL FOSMemoryPreinit()
	{
	//  initialize all pointers

	fTlsHeapHintAllocated = fFalse;
	tlsiHeapHint	= dwTlsInvalid;
	hMPHeapGlobal	= NULL;

#ifdef MEM_CHECK

	cmai			= 0;
	rgpmai			= NULL;
	ccsmai			= 0;
	rgcsmai			= NULL;

	g_posmm = NULL;
	InitializeCriticalSection( &g_csosmm );
	g_fcsosmmInit = fTrue;

#endif  //  MEM_CHECK

	hkeyWin9xStats	= NULL;

	psbm			= NULL;

	//  initialize all counters

	fEvictStatsInit	= fFalse;
	cAllocHeap		= 0;
	cFreeHeap		= 0;
	cbAllocHeap		= 0;
	cbReservePage	= 0;
	cbCommitPage	= 0;

	//  initialize global MP heap

	tlsiHeapHint = TlsAlloc();
	if ( dwTlsInvalid == tlsiHeapHint )
		{
		goto HandleError;
		}
	fTlsHeapHintAllocated = fTrue;

	hMPHeapGlobal = MpHeapCreate( 0, 0, 4 * CUtilProcessProcessor() );
	if ( !hMPHeapGlobal )
		{
		goto HandleError;
		}

#ifdef MEM_CHECK

	char sz[10];

	if ( FOSConfigGet( "DEBUG", "Mem Check", sz, 9 ) )
		{
		g_fMemCheck = !!atoi( sz );
		}

	//  allocate MAI hash table

	MEMORYSTATUS ms;
	ms.dwLength = sizeof( MEMORYSTATUS );
	GlobalMemoryStatus( &ms );
	for ( cmai = 0; ms.dwTotalPhys; ms.dwTotalPhys /= 2, cmai++ );
	cmai = ( 1 << max( 10, cmai - 12 ) ) - 1;

	rgpmai = (MAI**) VirtualAlloc( NULL, cmai * sizeof( MAI* ), MEM_COMMIT, PAGE_READWRITE );
	if ( !rgpmai )
		{
		goto HandleError;
		}

	//  initialize MAI hash table critical section pool

	ccsmai = 8 * CUtilProcessProcessor();
	rgcsmai = (CRITICAL_SECTION*) LocalAlloc( 0, ccsmai * sizeof( CRITICAL_SECTION ) );
	if ( !rgcsmai )
		{
		goto HandleError;
		}
	int icsmai;
	for ( icsmai = 0; icsmai < ccsmai; icsmai++ )
		{
		InitializeCriticalSection( rgcsmai + icsmai );
		}

#endif  //  MEM_CHECK

	//  get page commit and reserve granularity

	SYSTEM_INFO sinf;
	GetSystemInfo( &sinf );
	dwPageReserveGran = sinf.dwAllocationGranularity;
	dwPageCommitGran = sinf.dwPageSize;

	//  get total physical memory

	MEMORYSTATUS ms2;
	ms2.dwLength = sizeof( MEMORYSTATUS );
	GlobalMemoryStatus( &ms2 );
	cbMemoryTotal		= ms2.dwTotalPhys;
	cbPageReserveTotal	= ms2.dwTotalVirtual;

	//  initialize Win9x / WinNT stats

	OSVERSIONINFO osvi;
	memset( &osvi, 0, sizeof( osvi ) );
	osvi.dwOSVersionInfoSize = sizeof( osvi );
	if ( !GetVersionEx( &osvi ) )
		{
		goto HandleError;
		}

	if (	osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS &&
			RegOpenKeyEx(	HKEY_DYN_DATA,
							"PerfStats\\StatData",
							0,
							KEY_READ,
							&hkeyWin9xStats ) == ERROR_SUCCESS )
		{
		HKEY hkeyWin9xStatsStart;
		if ( RegOpenKeyEx(	HKEY_DYN_DATA,
							"PerfStats\\StartStat",
							0,
							KEY_READ,
							&hkeyWin9xStatsStart ) == ERROR_SUCCESS )
			{
			DWORD	cbData;
			DWORD	cbDiskcache;
			DWORD	cbDiskcacheMin;
			DWORD	cDiscards;

			cbDiskcache		= 0;
			cbData			= sizeof( cbDiskcache );
			(void)RegQueryValueEx(	hkeyWin9xStatsStart,
									"VMM\\cpgDiskcache",
									NULL,
									NULL,
									(BYTE*)&cbDiskcache,
									&cbData );

			cbDiskcacheMin	= 0;
			cbData			= sizeof( cbDiskcacheMin );
			(void)RegQueryValueEx(	hkeyWin9xStatsStart,
									"VMM\\cpgDiskcacheMin",
									NULL,
									NULL,
									(BYTE*)&cbDiskcacheMin,
									&cbData );

			cDiscards		= 0;
			cbData			= sizeof( cDiscards );
			(void)RegQueryValueEx(	hkeyWin9xStatsStart,
									"VMM\\cDiscards",
									NULL,
									NULL,
									(BYTE*)&cDiscards,
									&cbData );

			RegCloseKey( hkeyWin9xStatsStart );
			hkeyWin9xStatsStart = NULL;
			}
		else
			{
			RegCloseKey( hkeyWin9xStats );
			hkeyWin9xStats = NULL;
			}
		}

	else
		{
		if ( !( pfnNtQuerySystemInformation = (PFNNtQuerySystemInformation*)GetProcAddress(	GetModuleHandle( _T( "ntdll.dll" ) ),
																							_T( "NtQuerySystemInformation" ) ) ) )
			{
			goto HandleError;
			}
		if ( !( pfnNtQueryVirtualMemory = (PFNNtQueryVirtualMemory*)GetProcAddress(	GetModuleHandle( _T( "ntdll.dll" ) ),
																					_T( "NtQueryVirtualMemory" ) ) ) )
			{
			goto HandleError;
			}
		if ( !( pfnNtQueryInformationProcess = (PFNNtQueryInformationProcess*)GetProcAddress(	GetModuleHandle( _T( "ntdll.dll" ) ),
																								_T( "NtQueryInformationProcess" ) ) ) )
			{
			goto HandleError;
			}
		}

	//  determine multi-map capability

	fCanMultiMap = osvi.dwPlatformId == VER_PLATFORM_WIN32_NT;

	return fTrue;

HandleError:
	OSMemoryPostterm();
	return fFalse;
	}


//  terminate memory subsystem

void OSMemoryTerm()
	{
	//  nop
	}


//  init memory subsystem

ERR ErrOSMemoryInit()
	{
	//  nop

	return JET_errSuccess;
	}


#ifdef MEM_CHECK

int fNewMemCheck_( const _TCHAR* const szFileName, const unsigned long ulLine )
	{
	TLS *pTLS = Ptls();
	if ( !pTLS )
		{
		return 0;
		}
	pTLS->szNewFile = szFileName;
	pTLS->ulNewLine = ulLine;
	return 1;
	}

struct MAI
	{
	MAI*			pmaiNext;

	void*			pv;
	size_t			cb;
	DWORD			lLine;
	const _TCHAR*	szFile;
	};

INLINE int ImaiHashPv( void* const pv )
	{
	return (int)(( DWORD_PTR( pv ) / sizeof( int ) ) % cmai);
	}

void OSMemoryIInsertHeapAlloc( void* const pv, const size_t cb, const _TCHAR* szFile, long lLine )
	{
	//  we should not see any failed allocations

	Assert( pv );

	//  use the first chunk of the memory for the MAI

	MAI* pmai = (MAI*)pv;

	//  initialize the MAI

	pmai->pv = pv;
	pmai->cb = cb;
	pmai->szFile = szFile;
	pmai->lLine = lLine;

	//  insert the MAI into the hash table

	const int imai = ImaiHashPv( pv );
	CRITICAL_SECTION* pcsmai = rgcsmai + imai % ccsmai;

	EnterCriticalSection( pcsmai );

	pmai->pmaiNext = rgpmai[imai];
	rgpmai[imai] = pmai;

	LeaveCriticalSection( pcsmai );
	}

void OSMemoryIDeleteHeapAlloc( void* const pv, size_t cb )
	{
	//  we should not see any failed allocations

	Assert( pv );

	//  find the specified allocation in the hash table

	const int imai = ImaiHashPv( pv );
	CRITICAL_SECTION* pcsmai = rgcsmai + imai % ccsmai;

	EnterCriticalSection( pcsmai );

	MAI** ppmai = &rgpmai[imai];
	while ( *ppmai && (*ppmai)->pv != pv )
		{
		ppmai = &(*ppmai)->pmaiNext;
		}

	EnforceSz( *ppmai, "An attempt to free unallocated memory has been made" );

	//  remove the MAI from the hash table

	MAI* pmai = *ppmai;
	*ppmai = pmai->pmaiNext;

	AssertSz( pmai->cb == cb + sizeof( MAI ), "Difference between allocated and current size of heap chunk" );

	LeaveCriticalSection( pcsmai );
	}

void OSMemoryIInsertPageAlloc( void* const pv, const size_t cb, const _TCHAR* szFile, long lLine )
	{
	//  we should not see any failed allocations

	Assert( pv );

	//  allocate an MAI for this new allocation

	MAI* pmai = (MAI*)MpHeapAlloc( hMPHeapGlobal, 0, sizeof( MAI ) );
	EnforceSz( pmai, "MEM_CHECK only allocation failed!" );

	//  initialize the MAI

	pmai->pv = pv;
	pmai->cb = cb;
	pmai->szFile = szFile;
	pmai->lLine = lLine;

	//  insert the MAI into the hash table

	const int imai = ImaiHashPv( pv );
	CRITICAL_SECTION* pcsmai = rgcsmai + imai % ccsmai;

	EnterCriticalSection( pcsmai );

	pmai->pmaiNext = rgpmai[imai];
	rgpmai[imai] = pmai;

	LeaveCriticalSection( pcsmai );
	}

void OSMemoryIDeletePageAlloc( void* pv, const size_t cb )
	{
	//  we should not see any failed allocations

	Assert( pv );

	//  find the specified allocation in the hash table

	const int imai = ImaiHashPv( pv );
	CRITICAL_SECTION* pcsmai = rgcsmai + imai % ccsmai;

	EnterCriticalSection( pcsmai );

	MAI** ppmai = &rgpmai[imai];
	while ( *ppmai && (*ppmai)->pv != pv )
		{
		ppmai = &(*ppmai)->pmaiNext;
		}

	EnforceSz( *ppmai, "An attempt to free unallocated memory has been made" );

	//  remove the MAI from the hash table

	MAI* pmai = *ppmai;
	*ppmai = pmai->pmaiNext;

	AssertSz( pmai->cb == cb, "Difference between allocated 0x%016X and current size (pointer: 0x%p ) of page chunk" );

	LeaveCriticalSection( pcsmai );

	//  free allocation record

	MpHeapFree( hMPHeapGlobal, pmai );
	}

void OSMemoryIDumpAlloc( const _TCHAR* szDumpFile, const BOOL fMemDump )
	{
	HANDLE hFile = CreateFile(
		szDumpFile,
		GENERIC_WRITE,
		0,
		NULL,
		OPEN_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL
		);

	if ( INVALID_HANDLE_VALUE != hFile )
		{
		_TCHAR	szMessage[512];
		DWORD cchActual;

		(void)SetFilePointer( hFile, 0, NULL, FILE_END );

		_stprintf( szMessage, _T( "\r\nMemory Leak Statistics\r\n\r\n" ) );
		Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

		_stprintf( szMessage, _T( "cAllocHeap - cFreeHeap = 0x%016I64x\r\n" ), (QWORD)cAllocHeap - cFreeHeap );
		Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

		_stprintf( szMessage, _T( "cbAllocHeap            = 0x%016I64x bytes\r\n" ), (QWORD)cbAllocHeap );
		Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

		_stprintf( szMessage, _T( "cbReservePage          = 0x%016I64x pages (0x%016I64x bytes)\r\n" ), (QWORD)cbReservePage / OSMemoryPageCommitGranularity(), (QWORD)cbReservePage );
		Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

		_stprintf( szMessage, _T( "cbCommitPage           = 0x%016I64x pages (0x%016I64x bytes)\r\n\r\n" ), (QWORD)cbCommitPage / OSMemoryPageCommitGranularity(), (QWORD)cbCommitPage );
		Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

		_stprintf( szMessage, _T( "Address             Size                Type  File(Line)\r\n" ) );
		Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

		_stprintf( szMessage, _T( "==================  ==================  ====  ==========================================\r\n" ) );
		Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

		DWORD imai;
		SIZE_T cbAlloc;
		DWORD_PTR cbReserve;
		DWORD cAlloc, cPages;
		cbAlloc = 0;
		cbReserve = 0;
		cAlloc = 0;
		cPages = 0;
		for ( imai = 0; imai < cmai; imai++ )
			{
			MAI* pmai = rgpmai[imai];
			while ( pmai )
				{
				size_t ib;
				size_t cb;
				BYTE *pb;

				cb = pmai->cb;
				pb = (BYTE*)pmai->pv;
				if ( pmai->pv == (void*)pmai )
					{
					pb += sizeof( MAI );	//	skip the MAI for heap allocations
					cb = ( cb > sizeof( MAI ) ? cb - sizeof( MAI ) : 0 );	//	should never be 0
					}

				_stprintf(	szMessage,
							_T( "0x%016I64X  0x%016I64X  %-4s  %s(%d)\r\n" ),
							QWORD( pb ),
							QWORD( cb ),
							pmai->pv == (void*)pmai ? _T( "Heap" ) : _T( "Page" ),
							pmai->szFile,
							pmai->lLine );
				Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
				(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
				if ( pmai->pv == pmai )
					{
					cAlloc++;
					cbAlloc += cb;
					}
				else
					{
					cPages++;
					cbReserve += cb;
					}

				if ( 512 < cb )
					{
					cb = 512;
					}
				if ( fMemDump )
					{
					//	dump up to 512 bytes

					if ( pmai->pv != (void*)pmai )
						{
						BOOL						fReadable	= fTrue;
						MEMORY_BASIC_INFORMATION	mbi;
						const size_t				iVQ			= VirtualQuery( pb, &mbi, cb );

						if ( iVQ >= sizeof( mbi ) )
							{
							if ( mbi.RegionSize < cb )
								{
								fReadable = fFalse;	//	should never happen -- we're too lazy to query again
								}
							if ( mbi.State != MEM_COMMIT )
								{
								fReadable = fFalse;
								}
							if ( !( mbi.AllocationProtect &
									( PAGE_READONLY |
									  PAGE_READWRITE |
									  PAGE_EXECUTE_READ |
									  PAGE_EXECUTE_READWRITE ) ) )
								{
								fReadable = fFalse;
								}
							}
						else
							{
							fReadable = fFalse;
							}
						if ( !fReadable )
							{
							_stprintf( szMessage, _T( "\t<< block is not dumpable (not committed) >>\r\n" ) );
							Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
							(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
							goto NextMAI;
							}
						}

					ib = 0;
					while ( ib < cb )
						{
						if ( cb - ib >= 16 )
							{
							_stprintf(	szMessage,
										_T( "\t%04X: %02X %02X %02X %02X %02X %02X %02X %02X-%02X %02X %02X %02X %02X %02X %02X %02X\r\n" ),
										ib,
										pb[ib+0], pb[ib+1], pb[ib+2], pb[ib+3],
										pb[ib+4], pb[ib+5], pb[ib+6], pb[ib+7],
										pb[ib+8], pb[ib+9], pb[ib+10], pb[ib+11],
										pb[ib+12], pb[ib+13], pb[ib+14], pb[ib+15] );
							Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
							ib += 16;
							}
						else
							{
							_stprintf(	szMessage,
										_T( "\t%04X: %02X" ),
										ib,
										pb[ib] );
							Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
							ib++;
							while ( ib < cb )
								{
								_TCHAR szT[10];
								_stprintf(	szT,
											_T( " %02X" ),
											pb[ib] );
								Assert( _tcslen( szT ) < sizeof( szT ) / sizeof( _TCHAR ) );

								ib++;
								_tcscat( szMessage, szT );
								}
							_tcscat( szMessage, "\r\n" );
							}
						Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
						(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
						}
					}

NextMAI:
				pmai = pmai->pmaiNext;
				}
			}
		_stprintf( szMessage, _T( "Calculated mem stats\r\n====================\r\n" ) );
		Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
		_stprintf( szMessage, _T( "cAllocHeap - cFreeHeap = 0x%016I64x\r\n" ), (QWORD)cAlloc );
		Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
		_stprintf( szMessage, _T( "cbAllocHeap            = 0x%016I64x bytes\r\n" ), (QWORD)cbAlloc );
		Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
		_stprintf( szMessage, _T( "cbReservePage          = 0x%016I64x pages (0x%016I64x bytes)\r\n" ), (QWORD)cbReserve / OSMemoryPageCommitGranularity(), (QWORD)cbReserve );
		Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

		(void)CloseHandle( hFile );
		}
	}

#endif  //  MEM_CHECK


//  Heap Memory Allocation

//	calculate the address of the aligned block and store its offset (for free)

INLINE void* PvOSMemoryHeapIAlign( void* const pv, const size_t cbAlign )
	{

	//	round up to the nearest cache line
	//	NOTE: this formula always forces an offset of atleast 1 byte

	const ULONG_PTR ulp			= ULONG_PTR( pv );
	const ULONG_PTR ulpAligned	= ( ( ulp + cbAlign ) / cbAlign ) * cbAlign;
	const ULONG_PTR ulpOffset	= ulpAligned - ulp;

	Assert( ulpOffset > 0 );
	Assert( ulpOffset <= cbAlign );
	Assert( ulpOffset == BYTE( ulpOffset ) );	//	must fit into a single BYTE

	//	store the offset

	BYTE *const pbAligned	= (BYTE*)ulpAligned;
	pbAligned[ -1 ]			= BYTE( ulpOffset );

	//	return the aligned block

	return (void*)pbAligned;
	}


//	retrieve the offset of the real block being freed

INLINE void* PvOSMemoryHeapIUnalign( void* const pv )
	{

	//	read the offset of the real block

	BYTE *const pbAligned	= (BYTE*)pv;
	const BYTE bOffset		= pbAligned[ -1 ];

	Assert( bOffset > 0 );

	//	return the real unaligned block

	return (void*)( pbAligned - bOffset );
	}


//  allocate a chunk of memory from the process heap of the specifed size,
//  returning NULL if there is insufficient heap memory available to satisfy
//  the request.  "aligned" memory will always start at the beginning of a
//	cache line.

#ifdef MEM_CHECK

void* PvOSMemoryHeapAlloc_( const size_t cbSize, const _TCHAR* szFile, long lLine )
	{
	if ( !g_fMemCheck )
		{
		return PvOSMemoryHeapAlloc__( cbSize );
		}

	//  check for RFS

	if ( !RFSAlloc( OSMemoryHeap ) )
		{
		return NULL;
		}

	//	calculate the size of the block

	const size_t cbSizeT = sizeof( MAI ) + cbSize;

	//  allocate memory from the process global heap

	void* const pv = MpHeapAlloc( hMPHeapGlobal, 0, cbSizeT );
	if ( !pv )
		{
		return pv;
		}

#ifdef ENABLE_MEM_COUNTERS

	//	get the true size of the block (heap may allocate a few extra bytes)

	size_t cbAllocSize = MpHeapSize( hMPHeapGlobal, 0, pv );

	AtomicIncrement( (long *)&cAllocHeap );
	AtomicExchangeAdd( (long *)&cbAllocHeap, DWORD( cbAllocSize - sizeof( MAI ) ) );

#endif  //  ENABLE_MEM_COUNTERS

	//  insert allocation record for this memory

	OSMemoryIInsertHeapAlloc( pv, cbAllocSize, szFile, lLine );

	//  fill memory to detect illegal use of uninit data

	memset( (BYTE*)pv + sizeof( MAI ), chGlobalAllocFill, cbAllocSize - sizeof( MAI ) );

	//	return the block

	return (void*)( (BYTE*)pv + sizeof( MAI ) );
	}


void* PvOSMemoryHeapAllocAlign_( const size_t cbSize, const size_t cbAlign, const _TCHAR* szFile, long lLine )
	{
	if ( !g_fMemCheck )
		{
		return PvOSMemoryHeapAllocAlign__( cbSize, cbAlign );
		}

	void* const pv = PvOSMemoryHeapAlloc_( cbSize + cbAlign, szFile, lLine );
	if ( pv )
		{
		return PvOSMemoryHeapIAlign( pv, cbAlign );
		}
	return NULL;
	}


#endif  //  !MEM_CHECK


void* PvOSMemoryHeapAlloc__( const size_t cbSize )
	{
	//  check for RFS

	if ( !RFSAlloc( OSMemoryHeap ) )
		{
		return NULL;
		}

	//  allocate and return memory from the process global heap

	void* const pv = MpHeapAlloc( hMPHeapGlobal, 0, cbSize );
	if ( !pv )
		{
		return pv;
		}

#ifdef ENABLE_MEM_COUNTERS

	//	get the true size of the block (heap may allocate a few extra bytes)

	size_t cbAllocSize = MpHeapSize( hMPHeapGlobal, 0, pv );

	AtomicIncrement( (long *)&cAllocHeap );
	AtomicExchangeAdd( (long *)&cbAllocHeap, DWORD( cbAllocSize ) );

#endif  //  ENABLE_MEM_COUNTERS

	//	return the block

	return pv;
	}

void* PvOSMemoryHeapAllocAlign__( const size_t cbSize, const size_t cbAlign )
	{
	void* const pv = PvOSMemoryHeapAlloc( cbSize + cbAlign );
	if ( pv )
		{
		return PvOSMemoryHeapIAlign( pv, cbAlign );
		}
	return NULL;
	}

//  free the specified chunk of memory back to the process heap

void OSMemoryHeapFree( void* const pv )
	{
	if ( pv )
		{
		//  recover true allocation pointer

#ifdef MEM_CHECK
		void* pvTrue = (BYTE*)pv - ( g_fMemCheck ? sizeof( MAI ) : 0 );
#else // MEM_CHECK
		void* pvTrue = pv;
#endif  //  MEM_CHECK

#ifdef ENABLE_MEM_COUNTERS

		//  recover the true allocation size

		size_t cbAllocSize = MpHeapSize( hMPHeapGlobal, 0, pvTrue );

#ifdef MEM_CHECK

		if ( g_fMemCheck )
			{

			//  fix true allocation size

			cbAllocSize -= sizeof( MAI );

			//  remove allocation record for this memory

			OSMemoryIDeleteHeapAlloc( pvTrue, cbAllocSize );

			//  fill memory to detect illegal use after free

			memset( pv, chGlobalFreeFill, cbAllocSize );
			}

#endif  //  MEM_CHECK

		//  free memory to the process global heap

		AtomicIncrement( (long *)&cFreeHeap );
		AtomicExchangeAdd( (long *)&cbAllocHeap, DWORD( -cbAllocSize ) );

#endif  //  ENABLE_MEM_COUNTERS

		BOOL fMemFreed = MpHeapFree( hMPHeapGlobal, pvTrue );
		Assert( fMemFreed );
		}
	}


void OSMemoryHeapFreeAlign( void* const pv )
	{
	if ( pv )
		{
		OSMemoryHeapFree( PvOSMemoryHeapIUnalign( pv ) );
		}
	}



//  Page Memory Allocation Support

//  returns information about the page memory allocation unit containing the
//  specified pointer including the base address of the region, the size of the
//  region, and the amount of the region committed

void OSMemoryPageIGetAlloc( void* const pv, size_t* const pcbAllocReserve, size_t* const pcbAllocCommit )
	{
	//  get pointer to the base of the allocation region

	MEMORY_BASIC_INFORMATION	mbi;
	const size_t				cbRet			= VirtualQuery( pv, &mbi, sizeof( mbi ) );
	Assert( cbRet >= sizeof( mbi ) );

	void*						pvAllocBase		= mbi.AllocationBase;
	void*						pvScan			= pvAllocBase;

	//  scan the entire allocation region to determine its size and committed bytes

	*pcbAllocReserve = 0;
	*pcbAllocCommit = 0;
	for ( ; ; )
		{
		//  get this region's attributes

		const size_t	cbT		= VirtualQuery( pvScan, &mbi, sizeof( mbi ) );
		Assert( cbT >= sizeof( mbi ) );

		//  this region is part of the allocation

		if ( mbi.AllocationBase == pvAllocBase )
			{
			Assert( mbi.State == MEM_COMMIT || mbi.State == MEM_RESERVE );

			//  add this region's size to our reserve total

			*pcbAllocReserve += mbi.RegionSize;

			//  this region is committed

			if ( mbi.State == MEM_COMMIT )
				{
				//  add this region's size to our commit total

				*pcbAllocCommit += mbi.RegionSize;
				}

			//  advance to the next region

			pvScan = (void*)( (BYTE*)mbi.BaseAddress + mbi.RegionSize );
			}

		//  this region is not part of the allocation

		else
			{
			//  we're done

			break;
			}
		}
	}

//  returns the total size and committed bytes of the specified region, rounding
//  to the nearest page commit granularity on the high and low end of the region

void OSMemoryPageIGetCommit( void* const pv, const size_t cbSize, size_t* const pcbCommit, size_t* const pcbTotal )
	{
	//  compute region boundaries, accounting for page commit granularity

	void* pvStart = (BYTE*)pv - DWORD_PTR( pv ) % OSMemoryPageCommitGranularity();
	void* pvEnd = (BYTE*)pv + cbSize + OSMemoryPageCommitGranularity() - 1;
	pvEnd = (BYTE*)pvEnd - DWORD_PTR( pvEnd ) % OSMemoryPageCommitGranularity();

	//  compute total region size

	*pcbTotal = (BYTE*)pvEnd - (BYTE*)pvStart;

	//  scan region of memory looking for committed memory

	void* pvScan = pvStart;
	*pcbCommit = 0;
	do
		{
		//  get the attributes of the current region

		MEMORY_BASIC_INFORMATION	mbi;
		const size_t				cbRet	= VirtualQuery( pvScan, &mbi, sizeof( mbi ) );
		Assert( cbRet >= sizeof( mbi ) );
		Assert( mbi.State == MEM_COMMIT || mbi.State == MEM_RESERVE );

		//  this region is committed

		if ( mbi.State == MEM_COMMIT )
			{
			//  add its size to the total committed bytes count

			*pcbCommit += min( mbi.RegionSize, (BYTE*)pvEnd - (BYTE*)mbi.BaseAddress );
			}

		//  advance to the next region

		pvScan = (void*)( (BYTE*)mbi.BaseAddress + mbi.RegionSize );
		}
	while ( pvScan < pvEnd );
	}


//  Page Memory Control

//  reserves and commits a range of virtual addresses of the specifed size,
//  returning NULL if there is insufficient address space or backing store to
//  satisfy the request.  Note that the page reserve granularity applies to
//  this range

#ifdef MEM_CHECK

void* PvOSMemoryPageAlloc_( const size_t cbSize, void* const pv, const _TCHAR* szFile, long lLine )
	{
	if ( !g_fMemCheck )
		{
		return PvOSMemoryPageAlloc__( cbSize, pv );
		}

	//  check for RFS

	if (	!RFSAlloc( OSMemoryPageAddressSpace ) ||
			!RFSAlloc( OSMemoryPageBackingStore ) )
		{
		return NULL;
		}

	//  allocate address space and backing store of the specified size

	void* const pvRet = VirtualAlloc( pv, cbSize, MEM_COMMIT, PAGE_READWRITE );
	if ( !pvRet )
		{
		return pvRet;
		}
	Assert( !pv || pvRet == pv );

#ifdef ENABLE_MEM_COUNTERS
	//	query the state of the address range

	size_t cbAllocReserve;
	size_t cbAllocCommit;
	OSMemoryPageIGetAlloc( pvRet, &cbAllocReserve, &cbAllocCommit );

	//	memory should be fully reserved and committed

	Enforce( cbAllocReserve >= cbSize );
	Enforce( cbAllocCommit >= cbSize );

	//	update the counters

	AtomicExchangeAddPointer( (void**)&cbReservePage, (void*)cbAllocReserve );
	AtomicExchangeAddPointer( (void**)&cbCommitPage, (void*)cbAllocCommit );

	//  insert allocation record for this memory

	OSMemoryIInsertPageAlloc( pvRet, cbAllocReserve, szFile, lLine );
#endif // ENABLE_MEM_COUNTERS

	return pvRet;
	}

#endif  //  !MEM_CHECK

void* PvOSMemoryPageAlloc__( const size_t cbSize, void* const pv )
	{
	//  check for RFS

	if (	!RFSAlloc( OSMemoryPageAddressSpace ) ||
			!RFSAlloc( OSMemoryPageBackingStore ) )
		{
		return NULL;
		}

	//  allocate address space and backing store of the specified size

	void* const pvRet = VirtualAlloc( pv, cbSize, MEM_COMMIT, PAGE_READWRITE );
	if ( !pvRet )
		{
		return pvRet;
		}
	Assert( !pv || pvRet == pv );

#ifdef ENABLE_MEM_COUNTERS
	//	query the state of the address range

	size_t cbAllocReserve;
	size_t cbAllocCommit;
	OSMemoryPageIGetAlloc( pvRet, &cbAllocReserve, &cbAllocCommit );

	//	memory should be fully reserved and committed

	Enforce( cbAllocReserve >= cbSize );
	Enforce( cbAllocCommit >= cbSize );

	//	update the counters

	AtomicExchangeAddPointer( (void**)&cbReservePage, (void*)cbAllocReserve );
	AtomicExchangeAddPointer( (void**)&cbCommitPage, (void*)cbAllocCommit );
#endif // ENABLE_MEM_COUNTERS

	return pvRet;
	}


//  free the reserved range of virtual addresses starting at the specified
//  address, freeing any backing store committed to this range

void OSMemoryPageFree( void* const pv )
	{
	if ( pv )
		{
#ifdef ENABLE_MEM_COUNTERS
		//	query the state of the address range

		size_t cbAllocReserve;
		size_t cbAllocCommit;
		OSMemoryPageIGetAlloc( pv, &cbAllocReserve, &cbAllocCommit );

		//	the state should be reflected in the counters

		Enforce( cbReservePage >= cbAllocReserve );
		Enforce( cbCommitPage >= cbAllocCommit );

		//	update the counters

		AtomicExchangeAddPointer( (void**)&cbReservePage, (void*)-cbAllocReserve );
		AtomicExchangeAddPointer( (void**)&cbCommitPage, (void*)-cbAllocCommit );

#ifdef MEM_CHECK

		if ( g_fMemCheck )
			{

			//  verify that the entire allocated range will be freed

			EnforceSz(	cbAllocCommit == 0 || cbAllocCommit == cbAllocReserve,
						"An attempt to free mixed-attribute page memory has been made" );

			//  remove allocation record for this memory

			OSMemoryIDeletePageAlloc( pv, cbAllocReserve );
			}

#endif  //  MEM_CHECK
#endif // ENABLE_MEM_COUNTERS

		BOOL fMemFreed = VirtualFree( pv, 0, MEM_RELEASE );
		Assert( fMemFreed );
		}
	}


//  reserve a range of virtual addresses of the specified size, returning NULL
//  if there is insufficient address space to satisfy the request.  Note that
//  the page reserve granularity applies to this range

#ifdef MEM_CHECK

void* PvOSMemoryPageReserve_( const size_t cbSize, void* const pv, const _TCHAR* szFile, long lLine )
	{
	if ( !g_fMemCheck )
		{
		return PvOSMemoryPageReserve__( cbSize, pv );
		}

	//  check for RFS

	if ( !RFSAlloc( OSMemoryPageAddressSpace ) )
		{
		return NULL;
		}

	//  allocate address space of the specified size

	void* const pvRet = VirtualAlloc( pv, cbSize, MEM_RESERVE, PAGE_READWRITE );
	if ( !pvRet )
		{
		return pvRet;
		}
	Assert( !pv || pvRet == pv );

#ifdef ENABLE_MEM_COUNTERS
	//	query the current state of the address range

	size_t cbAllocReserve;
	size_t cbAllocCommit;
	OSMemoryPageIGetAlloc( pvRet, &cbAllocReserve, &cbAllocCommit );

	//	memory should be reserved, not committed

	Enforce( cbAllocReserve >= cbSize );
	Enforce( 0 == cbAllocCommit );

	//	update the counters

	AtomicExchangeAddPointer( (void**)&cbReservePage, (void*)cbAllocReserve );

	//  insert allocation record for this memory

	OSMemoryIInsertPageAlloc( pvRet, cbAllocReserve, szFile, lLine );
#endif // ENABLE_MEM_COUNTERS

	return pvRet;
	}

#endif  //  !MEM_CHECK

void* PvOSMemoryPageReserve__( const size_t cbSize, void* const pv )
	{
	//  check for RFS

	if ( !RFSAlloc( OSMemoryPageAddressSpace ) )
		{
		return NULL;
		}

	//  allocate address space of the specified size

	void* const pvRet = VirtualAlloc( pv, cbSize, MEM_RESERVE, PAGE_READWRITE );
	if ( !pvRet )
		{
		return pvRet;
		}
	Assert( !pv || pvRet == pv );

#ifdef ENABLE_MEM_COUNTERS
	//	query the current state of the address range

	size_t cbAllocReserve;
	size_t cbAllocCommit;
	OSMemoryPageIGetAlloc( pvRet, &cbAllocReserve, &cbAllocCommit );

	//	memory should be reserved, not committed

	Enforce( cbAllocReserve >= cbSize );
	Enforce( 0 == cbAllocCommit );

	//	update the counters

	AtomicExchangeAddPointer( (void**)&cbReservePage, (void*)cbAllocReserve );
#endif // ENABLE_MEM_COUNTERS

	return pvRet;
	}


//  reset the dirty bit for the specified range of virtual addresses.  this
//  results in the contents of the memory being thrown away instead of paged
//  to disk if the OS needs its physical memory for another process.  a value
//  of fTrue for fToss results in a hint to the OS to throw the specified
//  memory out of our working set.  Note that the page commit granularity
//  applies to this range

void OSMemoryPageReset( void* const pv, const size_t cbSize, const BOOL fToss )
	{

	//  reset the dirty bit for these vmem pages if set

	(void)VirtualAlloc( pv, cbSize, MEM_RESET, PAGE_READWRITE );

	//  this memory has been selected to be thrown out of our working set

	if ( fToss )
		{
		//  VirtualUnlock() hints the OS to put this memory on the avail list

		(void)VirtualUnlock( pv, cbSize );
		}
	}


//  set the specified range of virtual addresses as read only.  Note that the
//  page commit granularity applies to this range

void OSMemoryPageProtect( void* const pv, const size_t cbSize )
	{
	DWORD flOldProtect;
	BOOL fSetRO = VirtualProtect( pv, cbSize, PAGE_READONLY, &flOldProtect );
	Assert( fSetRO );
	}


//  set the specified range of virtual addresses as read / write.  Note that
//  the page commit granularity applies to this range

void OSMemoryPageUnprotect( void* const pv, const size_t cbSize )
	{
	DWORD flOldProtect;
	BOOL fSetRW = VirtualProtect( pv, cbSize, PAGE_READWRITE, &flOldProtect );
	Assert( fSetRW );
	}


//  commit the specified range of virtual addresses, returning fFalse if there
//  is insufficient backing store to satisfy the request.  Note that the page
//  commit granularity applies to this range

BOOL FOSMemoryPageCommit( void* const pv, const size_t cb )
	{

	//  check for RFS

	if ( !RFSAlloc( OSMemoryPageBackingStore ) )
		{
		return fFalse;
		}

	//	verify input

	if ( !pv )
		{
		return fFalse;
		}

	//	query the state of the space we are committing

#ifdef ENABLE_MEM_COUNTERS
	size_t cbCommitT;
	size_t cbTotalT;
	OSMemoryPageIGetCommit( pv, cb, &cbCommitT, &cbTotalT );

	//	calculate the amount of memory we will be committing

	const size_t cbToCommitT = cbTotalT - cbCommitT;

	//	we cannot commit more than we have reserved

///	Enforce( cbCommitPage + cbToCommitT <= cbReservePage );
#endif // ENABLE_MEM_COUNTERS

	//	commit the memory

	const BOOL fAllocOK = VirtualAlloc(	pv, cb, MEM_COMMIT, PAGE_READWRITE ) != NULL;

#ifdef ENABLE_MEM_COUNTERS
	if ( fAllocOK )
		{

		//	update the global counters

		AtomicExchangeAddPointer( (void**)&cbCommitPage, (void*)cbToCommitT );
		}
#endif // ENABLE_MEM_COUNTERS

	return fAllocOK;
	}


//  decommit the specified range of virtual addresses, freeing any backing
//  store committed to this range.  Note that the page commit granularity
//  applies to this range

void OSMemoryPageDecommit( void* const pv, const size_t cb )
	{

	//	verify input

	if ( !pv )
		{
		return;
		}

#ifdef ENABLE_MEM_COUNTERS
	//	query the state of the space we are decommitting

	size_t cbCommitT;
	size_t cbTotalT;
	OSMemoryPageIGetCommit( pv, cb, &cbCommitT, &cbTotalT );

	//	we cannot decommit more than we have reserved or committed

	Enforce( cbCommitT <= cbCommitPage );
	Enforce( cbCommitT <= cbReservePage );

	//	update the global counter

	AtomicExchangeAddPointer( (void**)&cbCommitPage, (void*)-cbCommitT );
#endif // ENABLE_MEM_COUNTERS

	//  free backing store for the specified range

	const BOOL fFreeOK = VirtualFree( pv, cb, MEM_DECOMMIT );
	Assert( fFreeOK );
	}




//	Memory Mapping


//	COSMemoryMap -- the basic object used in all memory mapping

//	ctor

COSMemoryMap::COSMemoryMap()
	{
	m_pvMap = NULL;
	m_cbMap = 0;
	m_cMap = 0;

	m_cbReserve = 0;
	m_cbCommit = 0;

#ifdef MEM_CHECK

	m_posmmNext = NULL;
	m_fInList = fFalse;
	m_szFile = NULL;
	m_lLine = 0;

#endif	//	MEM_CHECK
	}


//	dtor

COSMemoryMap::~COSMemoryMap()
	{
	}


//	init

COSMemoryMap::ERR
COSMemoryMap::ErrOSMMInit()
	{
	m_pvMap = NULL;
	m_cbMap = 0;
	m_cMap = 0;

	m_cbReserve = 0;
	m_cbCommit = 0;

#ifdef MEM_CHECK

	m_posmmNext = NULL;
	m_fInList = fFalse;
	m_szFile = NULL;
	m_lLine = 0;

	if ( g_fMemCheck )
		{

		//	insert this COSMemoryMap object into the global list

		EnterCriticalSection( &g_csosmm );
		m_posmmNext = g_posmm;
		g_posmm = this;
		m_fInList = fTrue;
		LeaveCriticalSection( &g_csosmm );
		}

#endif	//	MEM_CHECK

	return errSuccess;
	}


//	term

VOID COSMemoryMap::OSMMTerm()
	{
	//	make sure all resources have been released

	Enforce( 0 == m_cbReserve );
	Enforce( 0 == m_cbCommit );

#ifdef MEM_CHECK

	if ( g_fMemCheck && m_fInList )
		{

		//	remove this object from the list

		EnterCriticalSection( &g_csosmm );
		COSMemoryMap *posmmCur;
		COSMemoryMap *posmmPrev;

		posmmCur = g_posmm;
		posmmPrev = NULL;
		while ( posmmCur && posmmCur != this )
			{
			posmmPrev = posmmCur;
			posmmCur = posmmCur->m_posmmNext;
			}
		if ( posmmCur )
			{
			if ( posmmPrev )
				{
				posmmPrev->m_posmmNext = m_posmmNext;
				}
			else
				{
				g_posmm = m_posmmNext;
				}
			}
		else
			{
			EnforceSz( fFalse, "memory-map list corrupt" );
			}
		LeaveCriticalSection( &g_csosmm );

		m_fInList = fFalse;
		}

#endif	//	MEM_CHECK
	}

//  returns fTrue if we can map the same chunk of backing store into more than
//  one address range

BOOL COSMemoryMap::FCanMultiMap()
	{
	return fCanMultiMap;
	}

//	reserve a chunk of backing store and map it to the given address(es).
//	if any of the given addresses in rgpvMap[] are NULL, a suitable address
//	will be chosen automatically.  on success, the location of each mapping
//	will be returned in rgpvMap[].  on failure, the state of rgpvMap[] is
//	undefined.
//
//	NOTE: backing store it not actually allocated until commit time
//	NOTE: page reserve granularity applies to this range


COSMemoryMap::ERR
COSMemoryMap::ErrOSMMReserve__(	const size_t		cbMap,
								const size_t		cMap,
								void** const		rgpvMap,
								const BOOL* const	rgfProtect )
	{
	ERR err;

	//  check for RFS

	if ( !RFSAlloc( OSMemoryPageBackingStore ) )
		{
		return errOutOfBackingStore;
		}
	if ( !RFSAlloc( OSMemoryPageAddressSpace ) )
		{
		return errMappingFailed;
		}

	size_t	cbMapT;
	HANDLE	hBackingStore	= NULL;
	size_t	iMap			= 0;

#ifdef ENABLE_MEM_COUNTERS
	//	verify our state (should not already have a mapping setup)

	Assert( !m_pvMap );
	Assert( 0 == m_cbMap );
	Assert( 0 == m_cMap );
#endif // ENABLE_MEM_COUNTERS

	//	verify input

	Assert( cbMap > 0 );
	Assert( cMap > 0 );
	Assert( rgpvMap );
	Assert( rgfProtect );

	//	round to the nearest reservation granularity

	cbMapT =	(	( cbMap + OSMemoryPageReserveGranularity() - 1 ) /
					OSMemoryPageReserveGranularity() ) *
				OSMemoryPageReserveGranularity();

	//	allocate the backing store

	hBackingStore = CreateFileMapping(	INVALID_HANDLE_VALUE,
										NULL,
										PAGE_READWRITE | SEC_RESERVE,
										sizeof( cbMapT ) > sizeof( DWORD ) ? cbMapT >> 32 : 0,
										DWORD( cbMapT ),
										NULL );
	if ( !hBackingStore )
		{
		return errOutOfBackingStore;
		}

	//	map the backing store to given location(s)

	while ( iMap < cMap )
		{
		void* const pvMap = MapViewOfFileEx(	hBackingStore,
												rgfProtect[iMap] ? FILE_MAP_READ : FILE_MAP_WRITE,
												0,
												0,
												0,
												rgpvMap[iMap] );
		if ( !pvMap )
			{
			err = errMappingFailed;
			goto HandleError;
			}

		//	record the result of the mapping

		Assert( !rgpvMap[iMap] || pvMap == rgpvMap[iMap] );
		rgpvMap[iMap] = pvMap;

		//	move to the next mapping

		iMap++;
		}

	BOOL fCloseOK;
	fCloseOK = CloseHandle( hBackingStore );
	Assert( fCloseOK );

	//	record the state of the entire mapping

	m_pvMap = rgpvMap[0];
	m_cbMap = cbMapT;
	m_cMap = cMap;

#ifdef ENABLE_MEM_COUNTERS
	//	update our counters

	m_cbReserve = cMap * cbMapT;
	m_cbCommit = 0;

	//	update the global counters

	AtomicExchangeAddPointer( (void**)&cbReservePage, (void*)m_cbReserve );
#endif // ENABLE_MEM_COUNTERS

	return errSuccess;

HandleError:

	//	cleanup any leftover mappings

	while ( iMap-- > 0 )
		{
		const BOOL fUnmapOK = UnmapViewOfFile( rgpvMap[iMap] );
		Assert( fUnmapOK );
		}

	//	cleanup the backing store

	Assert( hBackingStore );
	fCloseOK = CloseHandle( hBackingStore );
	Assert( fCloseOK );

	return err;
	}

#ifdef MEM_CHECK

COSMemoryMap::ERR
COSMemoryMap::ErrOSMMReserve_(	const size_t		cbMap,
								const size_t		cMap,
								void** const		rgpvMap,
								const BOOL* const	rgfProtect,
								const _TCHAR* 		szFile,
								long 				lLine )
	{

	//	do the reservation

	const ERR err = ErrOSMMReserve__( cbMap, cMap, rgpvMap, rgfProtect );

	if ( errSuccess == err && g_fMemCheck )
		{

		//  record the file/line responsible for this reservation

		Assert( !m_szFile );
		Assert( 0 == m_lLine );
		m_szFile = (_TCHAR*)szFile;
		m_lLine = lLine;
		}

	return err;
	}

#endif	//	MEM_CHECK


//	commit a chunk of the reservation.  this forces the backing store to be
//	allocated and assigned to the appropriate address range.  on success,
//	the specified region within each mapping will be committed.
//
//	NOTE: page commit granularity applies to this range

BOOL COSMemoryMap::FOSMMCommit( const size_t ibOffset, const size_t cbCommit )
	{

	//  check for RFS

	if ( !RFSAlloc( OSMemoryPageBackingStore ) )
		{
		return fFalse;
		}

	//	verify our state (should have a mapping setup)

	Assert( m_pvMap );
	Assert( m_cbMap > 0 );
	Assert( m_cMap > 0 );

	//	verify input

	Assert( ibOffset + cbCommit <= m_cbMap );

	//	calculate the address we are committing

	void *const pvCommit = (BYTE*)m_pvMap + ibOffset;

	//	query the state of the space we are committing

#ifdef ENABLE_MEM_COUNTERS
	size_t cbCommitT;
	size_t cbTotalT;
	OSMemoryPageIGetCommit( pvCommit, cbCommit, &cbCommitT, &cbTotalT );

	//	calculate the amount of memory we will be committing

	const size_t cbToCommitT = ( cbTotalT - cbCommitT ) * m_cMap;

	//	we cannot commit more than we have reserved

	Enforce( m_cbCommit + cbToCommitT <= m_cbReserve );
#endif // ENABLE_MEM_COUNTERS

	//	commit the memory

	const BOOL fAllocOK = VirtualAlloc( pvCommit, cbCommit, MEM_COMMIT, PAGE_READWRITE ) != NULL;

#ifdef ENABLE_MEM_COUNTERS
	if ( fAllocOK )
		{

		//	update our counters

		AtomicExchangeAddPointer( (void**)&m_cbCommit, (void*)cbToCommitT );

		//	update the global counters

		AtomicExchangeAddPointer( (void**)&cbCommitPage, (void*)cbToCommitT );
		}
#endif // ENABLE_MEM_COUNTERS

	return fAllocOK;
	}


//  decommit and unreserve the address range

VOID COSMemoryMap::OSMMFree( void *const pv )
	{

	//	verify our state (should have a mapping setup)

	Assert( m_pvMap );
	Assert( m_cbMap > 0 );
	Assert( m_cMap > 0 );

	//	make sure we have a valid address

	if ( !pv )
		{
		return;
		}

#ifdef ENABLE_MEM_COUNTERS
	//	query the current state of the allocated block

	size_t cbAllocReserve;
	size_t cbAllocCommit;
	OSMemoryPageIGetAlloc( pv, &cbAllocReserve, &cbAllocCommit );

	//	verify the amount of reserved and committed memory

	Enforce( cbAllocReserve <= m_cbMap );
	Enforce( cbAllocCommit <= m_cbMap );

	//	verify that the counters reflect the reserved/committed sizes

	Enforce( cbReservePage >= cbAllocReserve );
	Enforce( cbCommitPage >= cbAllocCommit );
	Enforce( m_cbReserve >= cbAllocReserve );
	Enforce( m_cbCommit >= cbAllocCommit );

	//	update our counters

	AtomicExchangeAddPointer( (void**)&m_cbReserve, (void*)-cbAllocReserve );
	AtomicExchangeAddPointer( (void**)&m_cbCommit, (void*)-cbAllocCommit );

	//	update the global counters

	AtomicExchangeAddPointer( (void**)&cbReservePage, (void*)-cbAllocReserve );
	AtomicExchangeAddPointer( (void**)&cbCommitPage, (void*)-cbAllocCommit );

#ifdef DEBUG

	if ( 0 == m_cbReserve )
		{

		//	we are about to free that last portion of this mapping

		Assert( 0 == m_cbCommit );

		//	reset the rest of the object so it can be used again

		m_pvMap = NULL;
		m_cbMap = 0;
		m_cMap = 0;

#ifdef MEM_CHECK

		m_szFile = NULL;
		m_lLine = NULL;

#endif	//	MEM_CHECK
		}

#endif	//	DEBUG
#endif // ENABLE_MEM_COUNTERS

	//  free the specified range

	const BOOL fUnmapOK = UnmapViewOfFile( pv );
	Assert( fUnmapOK );
	}


//	reserve and commit a series of mappings to create a large contiguous
//	pattern (e.g. zero-filled block)
//
//	NOTE: page reserve granularity applies here

#ifdef MEM_CHECK

COSMemoryMap::ERR
COSMemoryMap::ErrOSMMPatternAlloc_(	const size_t	cbPattern,
									const size_t	cbSize,
									void** const 	ppvPattern,
									const _TCHAR*	szFile,
									long 			lLine )
	{
	if ( !g_fMemCheck )
		{
		return ErrOSMMPatternAlloc__( cbPattern, cbSize, ppvPattern );
		}

	ERR err;

#ifdef ENABLE_MEM_COUNTERS
	//	verify our state (should not have a mapping setup)

	Assert( !m_pvMap );
	Assert( 0 == m_cbMap );
	Assert( 0 == m_cMap );
#endif // ENABLE_MEM_COUNTERS

	//	verify input

	Assert( cbPattern > 0 );
	Assert( cbSize >= cbPattern );
	Assert( ppvPattern );

	//	reset output

	*ppvPattern = NULL;

	//	round to the nearest reservation granularity

	size_t cbPatternT;
	cbPatternT =	(	( cbPattern + OSMemoryPageReserveGranularity() - 1 ) /
						OSMemoryPageReserveGranularity() ) *
					OSMemoryPageReserveGranularity();

	size_t cbSizeT;
	cbSizeT = 		(	( cbSize + OSMemoryPageReserveGranularity() - 1 ) /
						OSMemoryPageReserveGranularity() ) *
					OSMemoryPageReserveGranularity();

	Assert( cbSizeT >= cbPatternT );
	Assert( 0 == cbSizeT % cbPatternT );

	//	allocate space to describe the mappings (for addresses and protection)

	size_t	cMap		= cbSizeT / cbPatternT;
	void	**rgpvMap	= (void**)( _alloca( cMap * ( sizeof( void* ) + sizeof( BOOL ) ) ) );
	BOOL	*rgfProtect	= (BOOL*)( (BYTE*)rgpvMap + cMap * sizeof( void* ) );

	Assert( cMap > 0 );

	while ( fTrue )
		{

		//	find a suitable address range

		BYTE* rgb;
		if ( !( rgb = (BYTE*)PvOSMemoryPageReserve_( size_t( cbSizeT ), NULL, szFile, lLine ) ) )
			{
			return errOutOfAddressSpace;
			}
		OSMemoryPageFree( rgb );

		//	setup each mapping

		size_t iMap;
		for ( iMap = 0; iMap < cMap; iMap++ )
			{
			rgpvMap[iMap]		= rgb + ( iMap * cbPatternT );
			rgfProtect[iMap]	= fFalse;
			}

		//	make the mapping

		err = ErrOSMMReserve_( cbPatternT, cMap, rgpvMap, rgfProtect, szFile, lLine );
		if ( errSuccess == err )
			{
			break;
			}
		else if ( errOutOfBackingStore == err )
			{
			return err;
			}
		else
			{
			Assert( errMappingFailed == err );
			}
		}

	//	we should have a valid pattern

	Assert( rgpvMap[0] );
	Assert( m_pvMap == rgpvMap[0] );
	Assert( m_cbMap == cbPatternT );
	Assert( m_cMap == cMap );

#ifdef ENABLE_MEM_COUNTERS
	Assert( m_cbReserve == cbSizeT );
#endif // ENABLE_MEM_COUNTERS
	Assert( m_cbCommit == 0 );

	//  commit the mapping

	if ( !FOSMMCommit( 0, cbPatternT ) )
		{

		//	free each mapping

		size_t iMap;
		for ( iMap = 0; iMap < cMap; iMap++ )
			{
			Assert( (BYTE*)m_pvMap + ( iMap * cbPatternT ) == rgpvMap[iMap] );
			OSMMFree( rgpvMap[iMap] );
			}

		return errOutOfMemory;
		}

#ifdef ENABLE_MEM_COUNTERS
	Assert( m_cbCommit == cbSizeT );
#endif // ENABLE_MEM_COUNTERS

	//	return the result

	*ppvPattern = rgpvMap[0];

	return errSuccess;
	}

#endif	//	MEM_CHECK

COSMemoryMap::ERR
COSMemoryMap::ErrOSMMPatternAlloc__(	const size_t	cbPattern,
										const size_t	cbSize,
										void** const 	ppvPattern )
	{
	ERR err;

#ifdef ENABLE_MEM_COUNTERS
	//	verify our state (should not have a mapping setup)

	Assert( !m_pvMap );
	Assert( 0 == m_cbMap );
	Assert( 0 == m_cMap );
#endif // ENABLE_MEM_COUNTERS

	//	verify input

	Assert( cbPattern > 0 );
	Assert( cbSize >= cbPattern );
	Assert( ppvPattern );

	//	reset output

	*ppvPattern = NULL;

	//	round to the nearest reservation granularity

	size_t cbPatternT;
	cbPatternT =	(	( cbPattern + OSMemoryPageReserveGranularity() - 1 ) /
						OSMemoryPageReserveGranularity() ) *
					OSMemoryPageReserveGranularity();

	size_t cbSizeT;
	cbSizeT = 		(	( cbSize + OSMemoryPageReserveGranularity() - 1 ) /
						OSMemoryPageReserveGranularity() ) *
					OSMemoryPageReserveGranularity();

	Assert( cbSizeT >= cbPatternT );
	Assert( 0 == cbSizeT % cbPatternT );

	//	allocate space to describe the mappings (for addresses and protection)

	size_t	cMap		= cbSizeT / cbPatternT;
	void	**rgpvMap	= (void**)( _alloca( cMap * ( sizeof( void* ) + sizeof( BOOL ) ) ) );
	BOOL	*rgfProtect	= (BOOL*)( (BYTE*)rgpvMap + cMap * sizeof( void* ) );

	Assert( cMap > 0 );

	while ( fTrue )
		{

		//	find a suitable address range

		BYTE* rgb;
		if ( !( rgb = (BYTE*)PvOSMemoryPageReserve__( size_t( cbSizeT ), NULL ) ) )
			{
			return errOutOfAddressSpace;
			}
		OSMemoryPageFree( rgb );

		//	setup each mapping

		size_t iMap;
		for ( iMap = 0; iMap < cMap; iMap++ )
			{
			rgpvMap[iMap]		= rgb + ( iMap * cbPatternT );
			rgfProtect[iMap]	= fFalse;
			}

		//	make the mapping

		err = ErrOSMMReserve__( cbPatternT, cMap, rgpvMap, rgfProtect );
		if ( errSuccess == err )
			{
			break;
			}
		else if ( errOutOfBackingStore == err )
			{
			return err;
			}
		else
			{
			Assert( errMappingFailed == err );
			}
		}

	//	we should have a valid pattern

	Assert( rgpvMap[0] );
	Assert( m_pvMap == rgpvMap[0] );
	Assert( m_cbMap == cbPatternT );
	Assert( m_cMap == cMap );

#ifdef ENABLE_MEM_COUNTERS
	Assert( m_cbReserve == cbSizeT );
#endif // ENABLE_MEM_COUNTERS
	Assert( m_cbCommit == 0 );

	//  commit the mapping

	if ( !FOSMMCommit( 0, cbPatternT ) )
		{

		//	free each mapping

		size_t iMap;
		for ( iMap = 0; iMap < cMap; iMap++ )
			{
			Assert( (BYTE*)m_pvMap + ( iMap * cbPatternT ) == rgpvMap[iMap] );
			OSMMFree( rgpvMap[iMap] );
			}

		return errOutOfMemory;
		}

#ifdef ENABLE_MEM_COUNTERS
	Assert( m_cbCommit == cbSizeT );
#endif // ENABLE_MEM_COUNTERS

	//	return the result

	*ppvPattern = rgpvMap[0];

	return errSuccess;
	}


//	free the series of mappings used to make a pattern

VOID COSMemoryMap::OSMMPatternFree()
	{

	//	verify our state (should have a mapping setup)

	if ( m_pvMap )
		{
		Assert( m_cbMap > 0 );
		Assert( m_cMap > 0 );

		//	free each mapping

		size_t iMap;
		for ( iMap = 0; iMap < m_cMap; iMap++ )
			{
			OSMMFree( (BYTE*)m_pvMap + ( iMap * m_cbMap ) );
			}
		}

#ifdef ENABLE_MEM_COUNTERS
	//	we should no longer have any mapping info

	Assert( !m_pvMap );
	Assert( 0 == m_cbMap );
	Assert( 0 == m_cMap );
#endif // ENABLE_MEM_COUNTERS
	}



#ifdef MEM_CHECK

//	dump stray COSMemoryMap objects

VOID COSMemoryMap::OSMMDumpAlloc( const _TCHAR* szFile )
	{
	HANDLE hFile = CreateFile(	szFile,
								GENERIC_WRITE,
								0,
								NULL,
								OPEN_ALWAYS,
								FILE_ATTRIBUTE_NORMAL,
								NULL );

	if ( INVALID_HANDLE_VALUE == hFile )
		{
		return;
		}

	_TCHAR			szMessage[512];
	DWORD			cchActual;
	COSMemoryMap	*posmm;

	(void)SetFilePointer( hFile, 0, NULL, FILE_END );

	_stprintf( szMessage, _T( "\r\nCOSMemoryMap Leak Statistics\r\n\r\n" ) );
	Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
	(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

	_stprintf( szMessage, _T( "cbReservePage = %I64d pages (0x%016I64x bytes)\r\n" ), cbReservePage / OSMemoryPageCommitGranularity(), cbReservePage );
	Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
	(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

	_stprintf( szMessage, _T( "cbCommitPage  = %I64d pages (0x%016I64x bytes)\r\n\r\n" ), cbCommitPage / OSMemoryPageCommitGranularity(), cbCommitPage );
	Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
	(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

	_stprintf( szMessage, _T( "First Mapping       Size                Count  Reserved            Committed           File(Line)\r\n" ) );
	Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
	(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

	_stprintf( szMessage, _T( "==================  ==================  =====  ==================  ==================  ==========================================\r\n" ) );
	Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
	(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

	EnterCriticalSection( &g_csosmm );

	//	dump each COSMemoryMap object in the list

	posmm = g_posmm;
	while ( posmm )
		{
		_stprintf(	szMessage,
					_T( "0x%016I64X  0x%016I64X  %-5d  0x%016I64X  0x%016I64X  %s(%d)\r\n" ),
					QWORD( posmm->m_pvMap ),
					QWORD( posmm->m_cbMap ),
					posmm->m_cMap,
					QWORD( posmm->m_cbReserve ),
					QWORD( posmm->m_cbCommit ),
					posmm->m_szFile,
					posmm->m_lLine );
		Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

		posmm = posmm->m_posmmNext;
		}
	if ( !g_posmm )
		{
		_stprintf( szMessage, _T( "<< no mappings >>\r\n" ) );
		Assert( _tcslen( szMessage ) < sizeof( szMessage ) / sizeof( _TCHAR ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
		}

	LeaveCriticalSection( &g_csosmm );

	CloseHandle( hFile );
	}

#endif	//	MEM_CHECK





//	checks whether pointer pv points to allocated memory ( not necessarly begin )
//	with at least cbSize bytes

#ifdef MEM_CHECK
void OSMemoryCheckPointer( void * const pv, const size_t cb )
	{
	if ( g_fMemCheck )
		{
		Assert( pv );
		Assert( (BYTE *)pv < (BYTE *)pv + cb );

		//  find the specified allocation in the hash table

		int imai;
		MAI *pmai;

		for ( imai = 0; imai < cmai; imai++ )
			{
			pmai = rgpmai[imai];
			while ( pmai && ( pmai->pv > pv || (BYTE *)pmai->pv + pmai->cb < (BYTE *)pv ) )
				{
				pmai = pmai->pmaiNext;
				}
			if ( pmai != NULL )
				{
				if ( (BYTE *)pmai->pv + pmai->cb < (BYTE *)pv + cb )
					{
					Assert( "Memory chunk is smaller than expected." );
					}
				break;
				}
			}

		if ( pmai == NULL )
			{
			Assert( "Pointer does not point to allocated memory or memory chunk is smaller than expected." );
			}

		}
	}
#endif // MEM_CHECK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\mpheap.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mpheap.c

Abstract:

    This DLL is a wrapper that sits on top of the Win32 Heap* api.  It
    provides multiple heaps and handles all the serialization itself.

    Many multithreaded applications that use the standard memory allocation
    routines (malloc/free, LocalAlloc/LocalFree, HeapAlloc/HeapFree) suffer
    a significant a significant performance penalty when running on a
    multi-processor machine.  This is due to the serialization used by the
    default heap package.  On a multiprocessor machine, more than one
    thread may simultaneously try to allocate memory.  One thread will
    block on the critical section guarding the heap.  The other thread must
    then signal the critical section when it is finished to unblock the
    waiting thread.  The additional codepath of blocking and signalling adds
    significant overhead to the frequent memory allocation path.

    By providing multiple heaps, this DLL allows simultaneous operations on
    each heap.  A thread on processor 0 can allocate memory from one heap
    at the same time that a thread on processor 1 is allocating from a
    different heap.  The additional overhead in this DLL is compensated by
    drastically reducing the number of times a thread must wait for heap
    access.

    The basic scheme is to attempt to lock each heap in turn with the new
    TryEnterCriticalSection API.  This will enter the critical section if
    it is unowned.  If the critical section is owned by a different thread,
    TryEnterCriticalSection returns failure instead of blocking until the
    other thread leaves the critical section.

    Another trick to increase performance is the use of a lookaside list to
    satisfy frequent allocations.  By using InterlockedExchange to remove
    lookaside list entries and InterlockedCompareExchange to add lookaside
    list entries, allocations and frees can be completed without needing a
    critical section lock.

    The final trick is the use of delayed frees.  If a chunk of memory is
    being freed, and the required lock is already held by a different
    thread, the free block is simply added to a delayed free list and the
    API completes immediately.  The next thread to acquire the heap lock
    will free everything on the list.

    Every application uses memory allocation routines in different ways.
    In order to allow better tuning of this package, MpHeapGetStatistics
    allows an application to monitor the amount of contention it is
    getting.  Increasing the number of heaps increases the potential
    concurrency, but also increases memory overhead.  Some experimentation
    is recommended to determine the optimal settings for a given number of
    processors.

    Some applications can benefit from additional techniques.  For example,
    per-thread lookaside lists for common allocation sizes can be very
    effective.  No locking is required for a per-thread structure, since no
    other thread will ever be accessing it.  Since each thread reuses the
    same memory, per-thread structures also improve locality of reference.

Revision History:

    [andygo] modified from the original version:  now uses sync.lib so that
    it will work as intended on Win9x.  Win9x does not provide support for
    InterlockedCompareExchange and TryEnterCriticalSection so all sync
    primitives used in mpheap are redirected into the sync library.

--*/
#include "osstd.hxx"
#include "mpheap.hxx"

#define MPHEAP_VALID_OPTIONS  (MPHEAP_GROWABLE                 | \
                               MPHEAP_REALLOC_IN_PLACE_ONLY    | \
                               MPHEAP_TAIL_CHECKING_ENABLED    | \
                               MPHEAP_FREE_CHECKING_ENABLED    | \
                               MPHEAP_DISABLE_COALESCE_ON_FREE | \
                               MPHEAP_ZERO_MEMORY              | \
                               MPHEAP_COLLECT_STATS)

//
// Flags that are not passed on to the Win32 heap package
//
#define MPHEAP_PRIVATE_FLAGS (MPHEAP_COLLECT_STATS | MPHEAP_ZERO_MEMORY);

//
// Define the heap header that gets tacked on the front of
// every allocation. Eight bytes is a lot, but we can't make
// it any smaller or else the allocation will not be properly
// aligned for 64-bit quantities.
//
typedef struct _MP_HEADER {
    union {
        struct _MP_HEAP_ENTRY *HeapEntry;
        PSINGLE_LIST_ENTRY Next;
    };
    SIZE_T MpSize;
} MP_HEADER, *PMP_HEADER;
//
// Definitions and structures for lookaside list
//
#define LIST_ENTRIES 128

typedef struct _MP_HEAP_LOOKASIDE {
    PMP_HEADER Entry;
} MP_HEAP_LOOKASIDE, *PMP_HEAP_LOOKASIDE;

#define NO_LOOKASIDE 0xffffffff
#define MaxLookasideSize (8*LIST_ENTRIES-7)
#define LookasideIndexFromSize(s) ((s < MaxLookasideSize) ? ((s) >> 3) : NO_LOOKASIDE)

//
// Define the structure that describes the entire MP heap.
//
// There is one MP_HEAP_ENTRY structure for each Win32 heap
// and a MP_HEAP structure that contains them all.
//
// Each MP_HEAP structure contains a lookaside list for quick
// lock-free alloc/free of various size blocks.
//

typedef struct _MP_HEAP_ENTRY {
	_MP_HEAP_ENTRY()
		:	Lock( CLockBasicInfo( CSyncBasicInfo( "_MP_HEAP_ENTRY::Lock" ), 0, 0 ) )
		{
		}
		
    HANDLE Heap;
    PSINGLE_LIST_ENTRY DelayedFreeList;
    CCriticalSection Lock;
    DWORD Allocations;
    DWORD Frees;
    DWORD LookasideAllocations;
    DWORD LookasideFrees;
    DWORD DelayedFrees;
    MP_HEAP_LOOKASIDE Lookaside[LIST_ENTRIES];
} MP_HEAP_ENTRY, *PMP_HEAP_ENTRY;


typedef struct _MP_HEAP {
    DWORD HeapCount;
    DWORD Flags;
    DWORD Hint;
    DWORD PadTo32Bytes;
    MP_HEAP_ENTRY Entry[1];     // variable size
} MP_HEAP, *PMP_HEAP;


VOID
ProcessDelayedFreeList(
    IN PMP_HEAP_ENTRY HeapEntry
    );

//
// HeapHint is a per-thread variable that offers a hint as to which heap to
// check first.  By giving each thread affinity towards a different heap,
// it is more likely that the first heap a thread picks for its allocation
// will be available.  It also improves a thread's locality of reference,
// which is very important for good MP performance
//
#define SetHeapHint(x)	TlsSetValue(tlsiHeapHint,(void*)(x))
#define GetHeapHint()	PtrToUlong(TlsGetValue(tlsiHeapHint))

HANDLE
WINAPI
MpHeapCreate(
    DWORD flOptions,
    SIZE_T dwInitialSize,
    DWORD dwParallelism
    )
/*++

Routine Description:

    This routine creates an MP-enhanced heap. An MP heap consists of a
    collection of standard Win32 heaps whose serialization is controlled
    by the routines in this module to allow multiple simultaneous allocations.

Arguments:

    flOptions - Supplies the options for this heap.

        Currently valid flags are:

            MPHEAP_GROWABLE
            MPHEAP_REALLOC_IN_PLACE_ONLY
            MPHEAP_TAIL_CHECKING_ENABLED
            MPHEAP_FREE_CHECKING_ENABLED
            MPHEAP_DISABLE_COALESCE_ON_FREE
            MPHEAP_ZERO_MEMORY
            MPHEAP_COLLECT_STATS

    dwInitialSize - Supplies the initial size of the combined heaps.

    dwParallelism - Supplies the number of Win32 heaps that will make up the
        MP heap. A value of zero defaults to three + # of processors.

Return Value:

    HANDLE - Returns a handle to the MP heap that can be passed to the
             other routines in this package.

    NULL - Failure, GetLastError() specifies the exact error code.

--*/
{
    DWORD Error;
    DWORD i;
    HANDLE Heap;
    PMP_HEAP MpHeap;
    SIZE_T HeapSize;
    DWORD PrivateFlags;

    if (flOptions & ~MPHEAP_VALID_OPTIONS) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    flOptions |= HEAP_NO_SERIALIZE;

    PrivateFlags = flOptions & MPHEAP_PRIVATE_FLAGS;

    flOptions &= ~MPHEAP_PRIVATE_FLAGS;

    if (dwParallelism == 0) {
        SYSTEM_INFO SystemInfo;

        GetSystemInfo(&SystemInfo);
        dwParallelism = 3 + SystemInfo.dwNumberOfProcessors;
    }

    HeapSize = dwInitialSize / dwParallelism;

    //
    // The first heap is special, since the MP_HEAP structure itself
    // is allocated from there.
    //
    Heap = HeapCreate(flOptions,HeapSize,0);
    if (Heap == NULL) {
        //
        // HeapCreate has already set last error appropriately.
        //
        return(NULL);
    }

    MpHeap = (PMP_HEAP)HeapAlloc(Heap,0,sizeof(MP_HEAP) +
                              (dwParallelism-1)*sizeof(MP_HEAP_ENTRY));
    if (MpHeap==NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        HeapDestroy(Heap);
        return(NULL);
    }

    //
    // Initialize the MP heap structure
    //
    MpHeap->HeapCount = 1;
    MpHeap->Flags = PrivateFlags;
    MpHeap->Hint = 0;

    //
    // Initialize the first heap
    //
    ZeroMemory(&MpHeap->Entry[0], sizeof(MpHeap->Entry[0]));
    new( &MpHeap->Entry[0] ) _MP_HEAP_ENTRY;
    MpHeap->Entry[0].Heap = Heap;
    MpHeap->Entry[0].DelayedFreeList = NULL;

    //
    // Initialize the remaining heaps. Note that the heap has been
    // sufficiently initialized to use MpHeapDestroy for cleanup
    // if something bad happens.
    //
    for (i=1; i<dwParallelism; i++) {
        ZeroMemory(&MpHeap->Entry[i], sizeof(MpHeap->Entry[i]));
	    new( &MpHeap->Entry[i] ) _MP_HEAP_ENTRY;
        MpHeap->Entry[i].Heap = HeapCreate(flOptions, HeapSize, 0);
        if (MpHeap->Entry[i].Heap == NULL) {
            Error = GetLastError();
            MpHeapDestroy((HANDLE)MpHeap);
            SetLastError(Error);
            return(NULL);
        }
        MpHeap->Entry[i].DelayedFreeList = NULL;
        ++MpHeap->HeapCount;
    }

    return((HANDLE)MpHeap);
}

BOOL
WINAPI
MpHeapDestroy(
    HANDLE hMpHeap
    )
{
    DWORD i;
    DWORD HeapCount;
    PMP_HEAP MpHeap;
    BOOL Success = TRUE;
    HANDLE Heap;

    MpHeap = (PMP_HEAP)hMpHeap;
    HeapCount = MpHeap->HeapCount;

	if (HeapCount)
	{

		//
		// Lock down all the heaps so we don't end up hosing people
		// who may be allocating things while we are deleting the heaps.
		// By setting MpHeap->HeapCount = 0 we also attempt to prevent
		// people from getting hosed as soon as we delete the critical
		// sections and heaps.
		// We will not try to enter critical sesction if the process is 
		// aborted because (1) we are the only thread running in the
		// process and (2) one of the killed threads might be the legal
		// owner of the crirical section and we will wait forever on
		// that critical section.
		//
		MpHeap->HeapCount = 0;
		if ( !FUtilProcessAbort() ) {
			for (i=0; i<HeapCount; i++) {
				CLockDeadlockDetectionInfo::DisableOwnershipTracking();
				MpHeap->Entry[i].Lock.Enter();
				CLockDeadlockDetectionInfo::EnableOwnershipTracking();
			}
		}

		//
		// Delete the heaps and their associated critical sections.
		// Note that the order is important here. Since the MpHeap
		// structure was allocated from MpHeap->Heap[0] we must
		// delete that last.
		//
		for (i=HeapCount-1; i>0; i--) {
			Heap = MpHeap->Entry[i].Heap;
			MpHeap->Entry[i].~_MP_HEAP_ENTRY();
			if (!HeapDestroy(Heap)) {
				Success = FALSE;
			}
		}

		Heap = MpHeap->Entry[0].Heap;
		MpHeap->Entry[0].~_MP_HEAP_ENTRY();
		Success = HeapDestroy(Heap);
	}
    return(Success);
}

BOOL
WINAPI
MpHeapValidate(
    HANDLE hMpHeap,
    LPVOID lpMem
    )
{
    PMP_HEAP MpHeap;
    DWORD i;
    BOOL Success;
    PMP_HEADER Header;
    PMP_HEAP_ENTRY Entry;

    MpHeap = (PMP_HEAP)hMpHeap;

    if (lpMem == NULL) {

        //
        // Lock and validate each heap in turn.
        //
        for (i=0; i < MpHeap->HeapCount; i++) {
            Entry = &MpHeap->Entry[i];
            __try {
                Entry->Lock.Enter();
                Success = HeapValidate(Entry->Heap, 0, NULL);
                Entry->Lock.Leave();
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                return(FALSE);
            }

            if (!Success) {
                return(FALSE);
            }
        }
        return(TRUE);
    } else {

        //
        // Lock and validate the given heap entry
        //
        Header = ((PMP_HEADER)lpMem) - 1;
        __try {
            Header->HeapEntry->Lock.Enter();
            Success = HeapValidate(Header->HeapEntry->Heap, 0, Header);
            Header->HeapEntry->Lock.Leave();
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            return(FALSE);
        }

        return(Success);
    }
}

SIZE_T
WINAPI
MpHeapCompact(
    HANDLE hMpHeap
    )
{
    PMP_HEAP MpHeap;
    DWORD i;
    SIZE_T LargestFreeSize=0;
    SIZE_T FreeSize;
    PMP_HEAP_ENTRY Entry;

    MpHeap = (PMP_HEAP)hMpHeap;

    //
    // Lock and compact each heap in turn.
    //
    for (i=0; i < MpHeap->HeapCount; i++) {
        Entry = &MpHeap->Entry[i];
        Entry->Lock.Enter();
        FreeSize = HeapCompact(Entry->Heap, 0);
        Entry->Lock.Leave();

        if (FreeSize > LargestFreeSize) {
            LargestFreeSize = FreeSize;
        }
    }

    return(LargestFreeSize);

}


LPVOID
WINAPI
MpHeapAlloc(
    HANDLE hMpHeap,
    DWORD flOptions,
    SIZE_T dwBytes
    )
{
    PMP_HEADER Header;
    PMP_HEAP MpHeap;
    DWORD_PTR i;
    PMP_HEAP_ENTRY Entry;
    SIZE_T Index;
    SIZE_T Size;

    MpHeap = (PMP_HEAP)hMpHeap;

    flOptions |= MpHeap->Flags;

    Size = ((dwBytes + 7) & (ULONG)~7) + sizeof(MP_HEADER);
    Index=LookasideIndexFromSize(Size);

    //
    // Iterate through the heap locks looking for one
    // that is not owned.
    //
    i=GetHeapHint();
    if (i>=MpHeap->HeapCount) {
        i=0;
        SetHeapHint(0);
    }
    Entry = &MpHeap->Entry[i];
    do {
        //
        // Check the lookaside list for a suitable allocation.
        //
        if ((Index != NO_LOOKASIDE) &&
            (Entry->Lookaside[Index].Entry != NULL)) {
            if ((Header = (PMP_HEADER)AtomicExchangePointer((void**)&Entry->Lookaside[Index].Entry,
                                                          NULL)) != NULL) {
                //
                // We have a lookaside hit, return it immediately.
                //
                ++Entry->LookasideAllocations;
                Header->HeapEntry = Entry;
                if (flOptions & MPHEAP_ZERO_MEMORY) {
                    ZeroMemory(Header + 1, dwBytes);
				}
                SetHeapHint(i);
                return(Header + 1);
            }
        }

        //
        // Attempt to lock this heap without blocking.
        //
        if (Entry->Lock.FTryEnter()) {
            //
            // success, go allocate immediately
            //
            goto LockAcquired;
        }

        //
        // This heap is owned by another thread, try
        // the next one.
        //
        i++;
        Entry++;
        if (i==MpHeap->HeapCount) {
            i=0;
            Entry=&MpHeap->Entry[0];
        }
    } while ( i != GetHeapHint());

    //
    // All of the critical sections were owned by someone else,
    // so we have no choice but to wait for a critical section.
    //
    Entry->Lock.Enter();

LockAcquired:
    ++Entry->Allocations;
    if (Entry->DelayedFreeList != NULL) {
        ProcessDelayedFreeList(Entry);
    }
    Header = (PMP_HEADER)HeapAlloc(Entry->Heap, 0, Size);
    Entry->Lock.Leave();
    if (Header != NULL) {
        Header->HeapEntry = Entry;
        Header->MpSize = Size;
        if (flOptions & MPHEAP_ZERO_MEMORY) {
            ZeroMemory(Header + 1, dwBytes);
        }
        SetHeapHint(i);
        return(Header + 1);
    } else {
        return(NULL);
    }
}

BOOL
WINAPI
MpHeapFree(
    HANDLE hMpHeap,
    LPVOID lpMem
    )
{
    PMP_HEADER Header;
    CCriticalSection* Lock;
    BOOL Success;
    PMP_HEAP_ENTRY HeapEntry;
    PSINGLE_LIST_ENTRY Next;
    PMP_HEAP MpHeap;
    SIZE_T Index;

    Header = ((PMP_HEADER)lpMem) - 1;
    HeapEntry = Header->HeapEntry;
    MpHeap = (PMP_HEAP)hMpHeap;

    SetHeapHint(HeapEntry - &MpHeap->Entry[0]);

    Index = LookasideIndexFromSize(Header->MpSize);

    if (Index != NO_LOOKASIDE) {
        //
        // Try and put this back on the lookaside list
        //
        if (AtomicCompareExchangePointer((void**)&HeapEntry->Lookaside[Index],
                                       NULL,
                                       Header) == NULL) {
            //
            // Successfully freed to lookaside list.
            //
            ++HeapEntry->LookasideFrees;
            return(TRUE);
        }
    }
    Lock = &HeapEntry->Lock;

    if (Lock->FTryEnter()) {
        ++HeapEntry->Frees;
        if (HeapEntry->DelayedFreeList != NULL) {
        	ProcessDelayedFreeList(HeapEntry);
        }
        Success = HeapFree(HeapEntry->Heap, 0, Header);
        Lock->Leave();
        return(Success);
    }
    //
    // The necessary heap critical section could not be immediately
    // acquired. Post this free onto the Delayed free list and let
    // whoever has the lock process it.
    //
    do {
        Next = HeapEntry->DelayedFreeList;
        Header->Next = Next;
    } while ( AtomicCompareExchangePointer((void**)&HeapEntry->DelayedFreeList,
                                         Next,
                                         &Header->Next) != Next);
    return(TRUE);
}


SIZE_T
WINAPI
MpHeapSize(
		   HANDLE hMpHeap,
		   DWORD ulFlags,
		   LPVOID lpMem
		  )
{
	PMP_HEADER Header;

	Header = ((PMP_HEADER)lpMem) - 1;
	return Header->MpSize - sizeof(MP_HEADER);
}


VOID
ProcessDelayedFreeList(
    IN PMP_HEAP_ENTRY HeapEntry
    )
{
    PSINGLE_LIST_ENTRY FreeList;
    PSINGLE_LIST_ENTRY Next;
    PMP_HEADER Header;

    //
    // Capture the entire delayed free list with a single interlocked exchange.
    // Once we have removed the entire list, free each entry in turn.
    //
    FreeList = (PSINGLE_LIST_ENTRY)AtomicExchangePointer((void**)&HeapEntry->DelayedFreeList, NULL);
    while (FreeList != NULL) {
        Next = FreeList->Next;
        Header = CONTAINING_RECORD(FreeList, MP_HEADER, Next);
        ++HeapEntry->DelayedFrees;
        HeapFree(HeapEntry->Heap, 0, Header);
        FreeList = Next;
    }
}

DWORD
MpHeapGetStatistics(
    HANDLE hMpHeap,
    LPDWORD lpdwSize,
    MPHEAP_STATISTICS Stats[]
    )
{
    PMP_HEAP MpHeap;
    PMP_HEAP_ENTRY Entry;
    DWORD i;
    DWORD RequiredSize;

    MpHeap = (PMP_HEAP)hMpHeap;
    RequiredSize = MpHeap->HeapCount * sizeof(MPHEAP_STATISTICS);
    if (*lpdwSize < RequiredSize) {
        *lpdwSize = RequiredSize;
        return(ERROR_MORE_DATA);
    }
    ZeroMemory(Stats, MpHeap->HeapCount * sizeof(MPHEAP_STATISTICS));
    for (i=0; i < MpHeap->HeapCount; i++) {
        Entry = &MpHeap->Entry[i];

        Stats[i].Contention = -1;  //  sync.lib doesn't provide this statistic
        Stats[i].TotalAllocates = (Entry->Allocations + Entry->LookasideAllocations);
        Stats[i].TotalFrees = (Entry->Frees + Entry->LookasideFrees + Entry->DelayedFrees);
        Stats[i].LookasideAllocates = Entry->LookasideAllocations;
        Stats[i].LookasideFrees = Entry->LookasideFrees;
        Stats[i].DelayedFrees = Entry->DelayedFrees;
    }
    *lpdwSize = RequiredSize;
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\os.cxx ===
#include "osstd.hxx"


//  post-terminate OS subsystem

extern void OSEdbgPostterm();
extern void OSPerfmonPostterm();
extern void OSNormPostterm();
extern void OSCprintfPostterm();
extern void OSSLVPostterm();
extern void OSFilePostterm();
extern void OSTaskPostterm();
extern void OSThreadPostterm();
extern void OSMemoryPostterm();
extern void OSErrorPostterm();
extern void OSEventPostterm();
extern void OSTracePostterm();
extern void OSConfigPostterm();
extern void OSTimePostterm();
extern void OSSysinfoPostterm();
extern void OSLibraryPostterm();

void OSPostterm()
	{
	//  terminate all OS subsystems in reverse dependency order

	OSEdbgPostterm();
	OSPerfmonPostterm();
	OSNormPostterm();
	OSCprintfPostterm();
	OSSLVPostterm();
	OSFilePostterm();
	OSTaskPostterm();
	OSThreadPostterm();
	OSMemoryPostterm();
	OSSyncPostterm();
	OSErrorPostterm();
	OSEventPostterm();
	OSTracePostterm();
	OSConfigPostterm();
	OSTimePostterm();
	OSSysinfoPostterm();
	OSLibraryPostterm();
	}

//  pre-init OS subsystem

extern BOOL FOSLibraryPreinit();
extern BOOL FOSSysinfoPreinit();
extern BOOL FOSTimePreinit();
extern BOOL FOSConfigPreinit();
extern BOOL FOSTracePreinit();
extern BOOL FOSEventPreinit();
extern BOOL FOSErrorPreinit();
extern BOOL FOSMemoryPreinit();
extern BOOL FOSThreadPreinit();
extern BOOL FOSTaskPreinit();
extern BOOL FOSFilePreinit();
extern BOOL FOSSLVPreinit();
extern BOOL FOSCprintfPreinit();
extern BOOL FOSNormPreinit();
extern BOOL FOSPerfmonPreinit();
extern BOOL FOSEdbgPreinit();

#ifdef RTM
#define PREINIT_FAILURE_POINT 0
#define InitFailurePointsFromRegistry()
#else

//	Need to test error-handling for DLL load failures
//	cFailurePoints should be a negative number, indicating
//	the failure point that we should stop at
//
//	The failure point count will be loaded from the registry
//
//	To test this, write a test that increments the failure point
//	until the DLL loads successfully
//

LOCAL INT cFailurePoints;

#define PREINIT_FAILURE_POINT (!(++cFailurePoints))

//	this is called before anything is init
//	so we can't use any of the wrapper functions
LOCAL VOID InitFailurePointsFromRegistry()
	{
	cFailurePoints = 0;
	
	//  open registry key with this path

	HKEY hkeyPath;
	DWORD dw = RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
								_T( "SOFTWARE\\Microsoft\\" SZVERSIONNAME "\\Global" ),
								0,
								KEY_READ,
								&hkeyPath );
	
	if ( dw != ERROR_SUCCESS )
		{
		//  we failed to open the key. do nothing
		}
	else
		{
		DWORD dwType;
		CHAR szBuf[32];
		DWORD cbValue = sizeof( szBuf );
		
		dw = RegQueryValueEx(	hkeyPath,
								_T( "DLLInitFailurePoint" ),
								0,
								&dwType,
								(LPBYTE)szBuf,
								&cbValue );

		const DWORD dwClosedKey = RegCloseKey( hkeyPath );

		if ( ERROR_SUCCESS == dw && REG_SZ == dwType )
			{
			cFailurePoints = 0 - atol( szBuf );
			}
		}
	
	return;
	}

#endif

BOOL FOSPreinit()
	{

	InitFailurePointsFromRegistry();
	
	//  initialize all OS subsystems in dependency order

	if (	
			PREINIT_FAILURE_POINT ||
			!FOSLibraryPreinit() ||
			PREINIT_FAILURE_POINT ||			
			!FOSSysinfoPreinit() ||
			PREINIT_FAILURE_POINT ||			
			!FOSTimePreinit() ||
			PREINIT_FAILURE_POINT ||			
			!FOSConfigPreinit() ||
			PREINIT_FAILURE_POINT ||			
			!FOSTracePreinit() ||
			PREINIT_FAILURE_POINT ||			
			!FOSEventPreinit() ||
			PREINIT_FAILURE_POINT ||			
			!FOSErrorPreinit() ||
			PREINIT_FAILURE_POINT ||			
			!FOSSyncPreinit() ||
			PREINIT_FAILURE_POINT ||			
			!FOSMemoryPreinit() ||
			PREINIT_FAILURE_POINT ||			
			!FOSThreadPreinit() ||
			PREINIT_FAILURE_POINT ||			
			!FOSTaskPreinit() ||
			PREINIT_FAILURE_POINT ||			
			!FOSFilePreinit() ||
			PREINIT_FAILURE_POINT ||			
			!FOSSLVPreinit() ||
			PREINIT_FAILURE_POINT ||			
			!FOSCprintfPreinit() ||
			PREINIT_FAILURE_POINT ||			
			!FOSNormPreinit() ||
			PREINIT_FAILURE_POINT ||			
			!FOSPerfmonPreinit() ||
			PREINIT_FAILURE_POINT ||			
			!FOSEdbgPreinit() ||
			PREINIT_FAILURE_POINT
			)
		{
		goto HandleError;
		}

	return fTrue;

HandleError:
	OSPostterm();
	return fFalse;
	}


//  init OS subsystem

extern ERR ErrOSLibraryInit();
extern ERR ErrOSSysinfoInit();
extern ERR ErrOSTimeInit();
extern ERR ErrOSConfigInit();
extern ERR ErrOSTraceInit();
extern ERR ErrOSEventInit();
extern ERR ErrOSErrorInit();
extern ERR ErrOSMemoryInit();
extern ERR ErrOSThreadInit();
extern ERR ErrOSTaskInit();
extern ERR ErrOSFileInit();
extern ERR ErrOSSLVInit();
extern ERR ErrOSCprintfInit();
extern ERR ErrOSNormInit();
extern ERR ErrOSPerfmonInit();
extern ERR ErrOSEdbgInit();

ERR ErrOSInit()
	{
	ERR err;
	
	//  initialize all OS subsystems in dependency order

	Call( ErrOSLibraryInit() );
	Call( ErrOSSysinfoInit() );
	Call( ErrOSTimeInit() );
	Call( ErrOSConfigInit() );
	Call( ErrOSTraceInit() );
	Call( ErrOSEventInit() );
	Call( ErrOSErrorInit() );
	Call( ErrOSMemoryInit() );
	Call( ErrOSThreadInit() );
	Call( ErrOSTaskInit() );
	Call( ErrOSFileInit() );
	Call( ErrOSSLVInit() );
	Call( ErrOSCprintfInit() );
	Call( ErrOSNormInit() );
	Call( ErrOSPerfmonInit() );
	Call( ErrOSEdbgInit() );

	return JET_errSuccess;

HandleError:
	OSTerm();
	return err;
	}

//  terminate OS subsystem

extern void OSEdbgTerm();
extern void OSPerfmonTerm();
extern void OSNormTerm();
extern void OSCprintfTerm();
extern void OSSLVTerm();
extern void OSFileTerm();
extern void OSTaskTerm();
extern void OSThreadTerm();
extern void OSMemoryTerm();
extern void OSErrorTerm();
extern void OSEventTerm();
extern void OSTraceTerm();
extern void OSConfigTerm();
extern void OSTimeTerm();
extern void OSSysinfoTerm();
extern void OSLibraryTerm();

void OSTerm()
	{
	//  terminate all OS subsystems in reverse dependency order

	OSEdbgTerm();
	OSPerfmonTerm();
	OSNormTerm();
	OSCprintfTerm();
	OSSLVTerm();
	OSFileTerm();
	OSTaskTerm();
	OSThreadTerm();
	OSMemoryTerm();
	OSErrorTerm();
	OSEventTerm();
	OSTraceTerm();
	OSConfigTerm();
	OSTimeTerm();
	OSSysinfoTerm();
	OSLibraryTerm();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\osfs.cxx ===
#include "osstd.hxx"


LOCAL VOID OSFSReportDiskError(
	COSFileSystem * const	posfs,
	const MessageId			msgid,
	const _TCHAR * const	szPath,
	const _TCHAR *			szAbsRootPath,
	JET_ERR					err,
	const DWORD				error )
	{
	const _TCHAR*			rgpsz[ 5 ];
	DWORD					irgpsz						= 0;
	_TCHAR					szAbsPath[ IFileSystemAPI::cchPathMax ];
	_TCHAR					szError[ 64 ];
	_TCHAR					szSystemError[ 64 ];
	_TCHAR*					szSystemErrorDescription	= NULL;

	if ( posfs->ErrPathComplete( szPath, szAbsPath ) < JET_errSuccess )
		{
		_tcscpy( szAbsPath, szPath );
		}
	
	_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
	Assert( _tcslen( szError ) < sizeof( szError ) / sizeof( _TCHAR ) );
	
	_stprintf( szSystemError, _T( "%u (0x%08x)" ), error, error );
	Assert( _tcslen( szSystemError ) < sizeof( szSystemError ) / sizeof( _TCHAR ) );
	
	FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
						FORMAT_MESSAGE_FROM_SYSTEM |
						FORMAT_MESSAGE_MAX_WIDTH_MASK ),
					NULL,
					error,
					MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
					LPTSTR( &szSystemErrorDescription ),
					0,
					NULL );

	rgpsz[ irgpsz++ ]	= szAbsRootPath;
	rgpsz[ irgpsz++ ]	= szAbsPath;
	rgpsz[ irgpsz++ ]	= szError;
	rgpsz[ irgpsz++ ]	= szSystemError;
	rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );

	UtilReportEvent(
			eventError,
			GENERAL_CATEGORY,
			msgid,
			irgpsz,
			rgpsz,
			0,
			NULL,
			posfs->Pinst() );

	LocalFree( szSystemErrorDescription );
	}


COSFileSystem::COSFileSystem( INST * const pinst )
	:	IFileSystemAPI( pinst ),
		m_hmodKernel32( NULL )
	{
	}

ERR COSFileSystem::ErrInit()
	{
	const _TCHAR	szKernel32[] 			= _T( "kernel32.dll" );
#ifdef UNICODE
	const _TCHAR	szGetVolumePathName[]	= _T( "GetVolumePathNameW" );
#else  //  !UNICODE
	const _TCHAR	szGetVolumePathName[]	= _T( "GetVolumePathNameA" );
#endif  //  UNICODE

	ERR				err						= JET_errSuccess;

	//  load OS version

	OSVERSIONINFO osvi;
	memset( &osvi, 0, sizeof( osvi ) );
	osvi.dwOSVersionInfoSize = sizeof( osvi );
	if ( !GetVersionEx( &osvi ) )
		{
		Call( ErrGetLastError() );
		}

	//  remember if we are running on Win9x
	
	m_fWin9x = osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS;
	
	//  load GetVolumePathName if on NT 5+

	m_pfnGetVolumePathName = NULL;
	if ( m_hmodKernel32 = LoadLibrary( szKernel32 ) )
		{
		m_pfnGetVolumePathName = (PfnGetVolumePathName*)GetProcAddress( m_hmodKernel32, szGetVolumePathName );
		}
	if (	!m_pfnGetVolumePathName &&
			osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
			osvi.dwMajorVersion >= 5 )
		{
		Call( ErrERRCheck( JET_errFileAccessDenied ) );
		}

	return JET_errSuccess;

HandleError:
	return err;
	}

ERR COSFileSystem::ErrGetLastError( const DWORD error )
	{
	//  map Win32 errors to JET API errors

	switch ( error )
		{
		case NO_ERROR:
			return JET_errSuccess;

		case ERROR_DISK_FULL:
			return ErrERRCheck( JET_errDiskFull );

		case ERROR_HANDLE_EOF:
		case ERROR_VC_DISCONNECTED:
		case ERROR_IO_DEVICE:
		case ERROR_DEVICE_NOT_CONNECTED:
		case ERROR_NOT_READY:
			return ErrERRCheck( JET_errDiskIO );

		case ERROR_NO_MORE_FILES:
		case ERROR_FILE_NOT_FOUND:
			return ErrERRCheck( JET_errFileNotFound );

		case ERROR_PATH_NOT_FOUND:
			return ErrERRCheck( JET_errInvalidPath );

		case ERROR_ACCESS_DENIED:
		case ERROR_SHARING_VIOLATION:
		case ERROR_LOCK_VIOLATION:
		case ERROR_WRITE_PROTECT:
			return ErrERRCheck( JET_errFileAccessDenied );

		case ERROR_TOO_MANY_OPEN_FILES:
			return ErrERRCheck( JET_errOutOfFileHandles );
			break;

		case ERROR_NO_SYSTEM_RESOURCES:
		case ERROR_NOT_ENOUGH_MEMORY:
		case ERROR_WORKING_SET_QUOTA:
			return ErrERRCheck( JET_errOutOfMemory );

		default:
			return ErrERRCheck( JET_errDiskIO );
		}
	}


ERR COSFileSystem::ErrPathRoot(	const _TCHAR* const	szPath,	
								_TCHAR* const		szAbsRootPath )
	{
	ERR		err			= JET_errSuccess;
	_TCHAR	szAbsPath[ IFileSystemAPI::cchPathMax ];
	_TCHAR	szRootPath[ IFileSystemAPI::cchPathMax ];

	//  get the absolute path for the given path

	Call( ErrPathComplete( szPath, szAbsPath ) );

	//  the GetVolumePathName Win32 API is available

	if ( m_pfnGetVolumePathName )
		{
		//  compute the root path in this absolute path
		
		if ( !m_pfnGetVolumePathName( szAbsPath, szRootPath, IFileSystemAPI::cchPathMax ) )
			{
			Call( ErrGetLastError() );
			}
		}

	//  the GetVolumePathName Win32 API is available

	else
		{
		//  setup the root path to be the simple DOS device root from this path
		
		_tsplitpath( szAbsPath, szRootPath, NULL, NULL, NULL );
		if ( _tcslen( szRootPath ) >= IFileSystemAPI::cchPathMax - 1 )
			{
			Call( ErrERRCheck( JET_errInvalidPath )  );
			}
		_tcscat( szRootPath, _T( "/" ) );
		}

	//  compute the absolute path for the root path

	Call( ErrPathComplete( szRootPath, szAbsRootPath ) );
	return JET_errSuccess;

HandleError:
	_tcscpy( szAbsRootPath, _T( "" ) );
	return err;
	}

COSFileSystem::~COSFileSystem()
	{
	if ( m_hmodKernel32 )
		{
		FreeLibrary( m_hmodKernel32 );
		m_hmodKernel32 = NULL;
		}
	}

ERR COSFileSystem::ErrDiskSpace(
	const _TCHAR * const	szPath,
	QWORD * const			pcbFreeForUser,
	QWORD * const			pcbTotalForUser,
	QWORD * const			pcbFreeOnDisk )

	{
	ERR		err		= JET_errSuccess;
	DWORD	error	= ERROR_SUCCESS;
	_TCHAR	szAbsRootPath[ IFileSystemAPI::cchPathMax ];

	//  get the root path for the specified path

	Call( ErrPathRoot( szPath, szAbsRootPath ) );

	//  RFS:  bad path

	if ( !RFSAlloc( OSFileDiskSpace ) )
		{
		error = ERROR_PATH_NOT_FOUND;
		CallJ( ErrGetLastError( error ), HandleWin32Error );
		}

	//  get the sector size for the root path

	if ( !GetDiskFreeSpaceEx( szAbsRootPath, (PULARGE_INTEGER)pcbFreeForUser, (PULARGE_INTEGER)pcbTotalForUser, (PULARGE_INTEGER)pcbFreeOnDisk ) )
		{
		error = GetLastError();
		CallJ( ErrGetLastError( error ), HandleWin32Error );
		}

HandleWin32Error:
	if ( err < JET_errSuccess )
		{
		OSFSReportDiskError( this, OSFS_DISK_SPACE_ERROR_ID, szPath, szAbsRootPath, err, error );
		}

HandleError:
	if ( err < JET_errSuccess )
		{
		if ( NULL != pcbFreeForUser )
			*pcbFreeForUser = 0;
		if ( NULL != pcbTotalForUser )
			*pcbTotalForUser = 0;
		if ( NULL != pcbFreeOnDisk )
			*pcbFreeOnDisk = 0;
		}
	return err;
	}

ERR COSFileSystem::ErrFileAtomicWriteSize(	const _TCHAR* const	szPath,
											DWORD* const		pcbSize )
	{
	ERR		err		= JET_errSuccess;
	DWORD	error	= ERROR_SUCCESS;
	_TCHAR	szAbsRootPath[ IFileSystemAPI::cchPathMax ];
	DWORD	dwT;

	//  get the root path for the specified path

	Call( ErrPathRoot( szPath, szAbsRootPath ) );

	//  RFS:  bad path

	if ( !RFSAlloc( OSFileISectorSize ) )
		{
		error = ERROR_PATH_NOT_FOUND;
		CallJ( ErrGetLastError( error ), HandleWin32Error );
		}

	//  get the sector size for the root path

	if ( !GetDiskFreeSpace( szAbsRootPath, &dwT, pcbSize, &dwT, &dwT ) )
		{
		error = GetLastError();
		CallJ( ErrGetLastError( error ), HandleWin32Error );
		}

HandleWin32Error:
	if ( err < JET_errSuccess )
		{
		OSFSReportDiskError( this, OSFS_SECTOR_SIZE_ERROR_ID, szPath, szAbsRootPath, err, error );
		}

HandleError:
	if ( err < JET_errSuccess )
		{
		*pcbSize = 0;
		}
	return err;
	}

ERR COSFileSystem::ErrPathComplete(	const _TCHAR* const	szPath,	
									_TCHAR* const		szAbsPath )
	{
	ERR err = JET_errSuccess;

	//  RFS:  bad path

	if ( !RFSAlloc( OSFilePathComplete ) )
		{
		Call( ErrERRCheck( JET_errInvalidPath ) );
		}
	
	if ( !_tfullpath( szAbsPath, szPath, IFileSystemAPI::cchPathMax ) )
		{
		Call( ErrERRCheck( JET_errInvalidPath ) );
		}

	return JET_errSuccess;

HandleError:
	return err;
	}

ERR COSFileSystem::ErrPathParse(	const _TCHAR* const	szPath,
									_TCHAR* const		szFolder,
									_TCHAR* const		szFileBase,
									_TCHAR* const		szFileExt )
	{
	_TCHAR szFolderT[ IFileSystemAPI::cchPathMax ];

	*szFolder	= _T( '\0' );
	*szFileBase	= _T( '\0' );
	*szFileExt	= _T( '\0' );
	
	_tsplitpath( szPath, szFolder, szFolderT, szFileBase, szFileExt );

	//	szFolder already contains the drive, so just append
	//	the directory to form the complete folder location
	_tcscat( szFolder, szFolderT );
	Assert( _tcslen( szFolder ) < IFileSystemAPI::cchPathMax );

	return JET_errSuccess;
	}

ERR COSFileSystem::ErrPathBuild(	const _TCHAR* const	szFolder,
									const _TCHAR* const	szFileBase,
									const _TCHAR* const	szFileExt,
									_TCHAR* const		szPath )
	{
	*szPath = _T( '\0' );

	_tmakepath( szPath, NULL, szFolder, szFileBase, szFileExt );

	return JET_errSuccess;
	}

ERR COSFileSystem::ErrFolderCreate( const _TCHAR* const szPath )
	{
	ERR		err		= JET_errSuccess;
	DWORD	error	= ERROR_SUCCESS;

	//  RFS:  access denied

	if ( !RFSAlloc( OSFileCreateDirectory ) )
		{
		error = ERROR_ACCESS_DENIED;
		Call( ErrGetLastError( error ) );
		}
	
	if ( !CreateDirectory( szPath, NULL ) )
		{
		error = GetLastError();
		Call( ErrGetLastError( error ) );
		}

HandleError:
	if ( err < JET_errSuccess )
		{
		const _TCHAR*	rgpsz[ 4 ];
		DWORD			irgpsz						= 0;
		_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szError[ 64 ];
		_TCHAR			szSystemError[ 64 ];
		_TCHAR*			szSystemErrorDescription	= NULL;

		if ( ErrPathComplete( szPath, szAbsPath ) < JET_errSuccess )
			{
			_tcscpy( szAbsPath, szPath );
			}
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
		Assert( _tcslen( szError ) < sizeof( szError ) / sizeof (_TCHAR) );
		
		_stprintf( szSystemError, _T( "%u (0x%08x)" ), error, error );
		Assert( _tcslen( szSystemError ) < sizeof( szSystemError ) / sizeof (_TCHAR) );
		
		FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_MAX_WIDTH_MASK ),
						NULL,
						error,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
						LPTSTR( &szSystemErrorDescription ),
						0,
						NULL );

		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szError;
		rgpsz[ irgpsz++ ]	= szSystemError;
		rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );

		UtilReportEvent(
				eventError,
				GENERAL_CATEGORY,
				OSFS_CREATE_FOLDER_ERROR_ID,
				irgpsz,
				rgpsz,
				0,
				NULL,
				Pinst() );

		LocalFree( szSystemErrorDescription );
		}
	return err;
	}

ERR COSFileSystem::ErrFolderRemove( const _TCHAR* const szPath )
	{
	ERR		err		= JET_errSuccess;
	DWORD	error	= ERROR_SUCCESS;

	//  RFS:  access denied

	if ( !RFSAlloc( OSFileRemoveDirectory ) )
		{
		error = ERROR_ACCESS_DENIED;
		Call( ErrGetLastError( error ) );
		}
	
	if ( !RemoveDirectory( szPath ) )
		{
		error = GetLastError();
		Call( ErrGetLastError( error ) );
		}

HandleError:
	if ( err == JET_errFileNotFound )
		{
		err = JET_errInvalidPath;
		}
	if (	err < JET_errSuccess &&
			error != ERROR_FILE_NOT_FOUND )
		{
		const _TCHAR*	rgpsz[ 4 ];
		DWORD			irgpsz						= 0;
		_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szError[ 64 ];
		_TCHAR			szSystemError[ 64 ];
		_TCHAR*			szSystemErrorDescription	= NULL;

		if ( ErrPathComplete( szPath, szAbsPath ) < JET_errSuccess )
			{
			_tcscpy( szAbsPath, szPath );
			}
		
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
		Assert( _tcslen( szError ) < sizeof( szError ) / sizeof( _TCHAR ) );
		
		_stprintf( szSystemError, _T( "%u (0x%08x)" ), error, error );
		Assert( _tcslen( szSystemError ) < sizeof( szSystemError ) / sizeof( _TCHAR ) );
		
		FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_MAX_WIDTH_MASK ),
						NULL,
						error,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
						LPTSTR( &szSystemErrorDescription ),
						0,
						NULL );

		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szError;
		rgpsz[ irgpsz++ ]	= szSystemError;
		rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );

		UtilReportEvent(
				eventError,
				GENERAL_CATEGORY,
				OSFS_REMOVE_FOLDER_ERROR_ID,
				irgpsz,
				rgpsz,
				0,
				NULL,
				Pinst() );

		LocalFree( szSystemErrorDescription );
		}
	return err;
	}

ERR COSFileSystem::ErrFileFind(	const _TCHAR* const		szFind,
								IFileFindAPI** const	ppffapi )
	{
	ERR				err		= JET_errSuccess;
	COSFileFind*	posff	= NULL;

	//  allocate the file find iterator
	
	if ( !( posff = new COSFileFind ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  initialize the file find iterator

	Call( posff->ErrInit( this, szFind ) );

	//  return the interface to our file find iterator

	*ppffapi = posff;
	return JET_errSuccess;

HandleError:
	delete posff;
	*ppffapi = NULL;
	return err;
	}

ERR COSFileSystem::ErrFileDelete( const _TCHAR* const szPath )
	{
	ERR		err		= JET_errSuccess;
	DWORD	error	= ERROR_SUCCESS;
	
	//  RFS:  access denied
	
	if ( !RFSAlloc( OSFileDelete ) )
		{
		error = ERROR_ACCESS_DENIED;
		Call( ErrGetLastError( error ) );
		}
	
	if ( !DeleteFile( szPath ) )
		{
		error = GetLastError();
		Call( ErrGetLastError( error ) );
		}

HandleError:
	if (	err < JET_errSuccess &&
			error != ERROR_FILE_NOT_FOUND )
		{
		const _TCHAR*	rgpsz[ 4 ];
		DWORD			irgpsz						= 0;
		_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szError[ 64 ];
		_TCHAR			szSystemError[ 64 ];
		_TCHAR*			szSystemErrorDescription	= NULL;

		if ( ErrPathComplete( szPath, szAbsPath ) < JET_errSuccess )
			{
			_tcscpy( szAbsPath, szPath );
			}
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
		Assert( _tcslen( szError ) < sizeof( szError ) / sizeof( _TCHAR ) );
		
		_stprintf( szSystemError, _T( "%u (0x%08x)" ), error, error );
		Assert( _tcslen( szSystemError ) < sizeof( szSystemError ) / sizeof( _TCHAR ) );
		
		FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_MAX_WIDTH_MASK ),
						NULL,
						error,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
						LPTSTR( &szSystemErrorDescription ),
						0,
						NULL );

		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szError;
		rgpsz[ irgpsz++ ]	= szSystemError;
		rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );

		UtilReportEvent(
				eventError,
				GENERAL_CATEGORY,
				OSFS_DELETE_FILE_ERROR_ID,
				irgpsz,
				rgpsz,
				0,
				NULL,
				Pinst() );

		LocalFree( szSystemErrorDescription );
		}
	return err;
	}

ERR COSFileSystem::ErrFileMove(	const _TCHAR* const	szPathSource,
								const _TCHAR* const	szPathDest,
								const BOOL			fOverwriteExisting )
	{
	ERR			err				= JET_errSuccess;
	DWORD		error			= ERROR_SUCCESS;
	const DWORD	dtickTimeout	= cmsecAccessDeniedRetryPeriod;
	DWORD		tickStart		= GetTickCount();	
	
	//  RFS:  pre-move error
	
	if ( !RFSAlloc( OSFileMove ) )
		{
		error = ERROR_ACCESS_DENIED;
		Call( ErrGetLastError( error ) );
		}

	if ( m_fWin9x )
		{
		if ( fOverwriteExisting )
			{
			do
				{
				err		= JET_errSuccess;
				error	= ERROR_SUCCESS;
				
				if ( !DeleteFile( szPathDest ) )
					{
					error	= GetLastError();
					if ( error == ERROR_FILE_NOT_FOUND )
						{
						error = ERROR_SUCCESS;
						}
					err		= ErrGetLastError( error );

					if ( err == JET_errFileAccessDenied )
						{
						Sleep( 1 );
						}
					}
				}
			while ( err == JET_errFileAccessDenied && GetTickCount() - tickStart < dtickTimeout );
			Call( err );
			}

		do
			{
			err		= JET_errSuccess;
			error	= ERROR_SUCCESS;
			
			if ( !MoveFile(	szPathSource, szPathDest ) )
				{
				error	= GetLastError();
				err		= ErrGetLastError();

				if ( err == JET_errFileAccessDenied )
					{
					Sleep( 1 );
					}
				}
			}
		while ( err == JET_errFileAccessDenied && GetTickCount() - tickStart < dtickTimeout );
		Call( err );

		HANDLE	hFileDest = INVALID_HANDLE_VALUE;

		do
			{
			err		= JET_errSuccess;
			error	= ERROR_SUCCESS;
			
			hFileDest = CreateFile(	szPathDest,
									GENERIC_READ | GENERIC_WRITE,
									0,
									NULL,
									OPEN_EXISTING,
									(	FILE_ATTRIBUTE_NORMAL |
										FILE_FLAG_WRITE_THROUGH |
										FILE_FLAG_NO_BUFFERING ),
									NULL );
			if ( hFileDest == INVALID_HANDLE_VALUE )
				{
				error	= GetLastError();
				err		= ErrGetLastError();

				if ( err == JET_errFileAccessDenied )
					{
					Sleep( 1 );
					}
				}
			}
		while ( err == JET_errFileAccessDenied && GetTickCount() - tickStart < dtickTimeout );
		Call( err );
		
		if ( !FlushFileBuffers( hFileDest ) )
			{
			CloseHandle( hFileDest );
			Call( ErrGetLastError() );
			}
		CloseHandle( hFileDest );
		}
	else
		{
		do
			{
			err		= JET_errSuccess;
			error	= ERROR_SUCCESS;
			
			if ( !MoveFileEx(	szPathSource,
								szPathDest,
								(	MOVEFILE_COPY_ALLOWED |
									MOVEFILE_WRITE_THROUGH |
									( fOverwriteExisting ? MOVEFILE_REPLACE_EXISTING : 0 ) ) ) )
				{
				error	= GetLastError();
				err		= ErrGetLastError( error );

				if ( err == JET_errFileAccessDenied )
					{
					Sleep( 1 );
					}
				}
			}
		while ( err == JET_errFileAccessDenied && GetTickCount() - tickStart < dtickTimeout );
		Call( err );
		}
	
	//  RFS:  post-move error
	
	if ( !RFSAlloc( OSFileMove ) )
		{
		error = ERROR_IO_DEVICE;
		Call( ErrGetLastError( error ) );
		}

HandleError:
	if ( err < JET_errSuccess )
		{
		const _TCHAR*	rgpsz[ 5 ];
		DWORD			irgpsz						= 0;
		_TCHAR			szAbsPathSrc[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szAbsPathDest[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szError[ 64 ];
		_TCHAR			szSystemError[ 64 ];
		_TCHAR*			szSystemErrorDescription	= NULL;

		if ( ErrPathComplete( szPathSource, szAbsPathSrc ) < JET_errSuccess )
			{
			_tcscpy( szAbsPathSrc, szPathSource );
			}
		if ( ErrPathComplete( szPathDest, szAbsPathDest ) < JET_errSuccess )
			{
			_tcscpy( szAbsPathDest, szPathDest );
			}
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
		Assert( _tcslen( szError ) < sizeof( szError ) / sizeof( _TCHAR ) );
		
		_stprintf( szSystemError, _T( "%u (0x%08x)" ), error, error );
		Assert( _tcslen( szSystemError ) < sizeof( szSystemError ) / sizeof( _TCHAR ) );
		
		FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_MAX_WIDTH_MASK ),
						NULL,
						error,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
						LPTSTR( &szSystemErrorDescription ),
						0,
						NULL );

		rgpsz[ irgpsz++ ]	= szAbsPathSrc;
		rgpsz[ irgpsz++ ]	= szAbsPathDest;
		rgpsz[ irgpsz++ ]	= szError;
		rgpsz[ irgpsz++ ]	= szSystemError;
		rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );

		UtilReportEvent(
				eventError,
				GENERAL_CATEGORY,
				OSFS_MOVE_FILE_ERROR_ID,
				irgpsz,
				rgpsz,
				0,
				NULL,
				Pinst() );

		LocalFree( szSystemErrorDescription );
		}
	return err;
	}

ERR COSFileSystem::ErrFileCopy(	const _TCHAR* const	szPathSource,
								const _TCHAR* const	szPathDest,
								const BOOL			fOverwriteExisting )
	{
	ERR		err		= JET_errSuccess;
	DWORD	error	= ERROR_SUCCESS;
	
	//  RFS:  pre-copy error
	
	if ( !RFSAlloc( OSFileCopy ) )
		{
		error = ERROR_ACCESS_DENIED;
		Call( ErrGetLastError( error ) );
		}
	
	if ( !CopyFile( szPathSource, szPathDest, !fOverwriteExisting ) )
		{
		error = GetLastError();
		Call( ErrGetLastError( error ) );
		}

	if ( m_fWin9x )
		{
		HANDLE hFileDest = CreateFile(	szPathDest,
										GENERIC_READ | GENERIC_WRITE,
										0,
										NULL,
										OPEN_EXISTING,
										(	FILE_ATTRIBUTE_NORMAL |
											FILE_FLAG_WRITE_THROUGH |
											FILE_FLAG_NO_BUFFERING ),
										NULL );
		if ( hFileDest == INVALID_HANDLE_VALUE )
			{
			error = GetLastError();
			Call( ErrGetLastError( error ) );
			}
		if ( !FlushFileBuffers( hFileDest ) )
			{
			CloseHandle( hFileDest );
			Call( ErrGetLastError() );
			}
		CloseHandle( hFileDest );
		}
	
	//  RFS:  post-copy error
	
	if ( !RFSAlloc( OSFileCopy ) )
		{
		error = ERROR_IO_DEVICE;
		Call( ErrGetLastError( error ) );
		}

HandleError:
	if ( err < JET_errSuccess )
		{
		const _TCHAR*	rgpsz[ 5 ];
		DWORD			irgpsz						= 0;
		_TCHAR			szAbsPathSrc[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szAbsPathDest[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szError[ 64 ];
		_TCHAR			szSystemError[ 64 ];
		_TCHAR*			szSystemErrorDescription	= NULL;

		if ( ErrPathComplete( szPathSource, szAbsPathSrc ) < JET_errSuccess )
			{
			_tcscpy( szAbsPathSrc, szPathSource );
			}
		if ( ErrPathComplete( szPathDest, szAbsPathDest ) < JET_errSuccess )
			{
			_tcscpy( szAbsPathDest, szPathDest );
			}
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
		_stprintf( szSystemError, _T( "%u (0x%08x)" ), error, error );
		FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_MAX_WIDTH_MASK ),
						NULL,
						error,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
						LPTSTR( &szSystemErrorDescription ),
						0,
						NULL );

		rgpsz[ irgpsz++ ]	= szAbsPathSrc;
		rgpsz[ irgpsz++ ]	= szAbsPathDest;
		rgpsz[ irgpsz++ ]	= szError;
		rgpsz[ irgpsz++ ]	= szSystemError;
		rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );

		UtilReportEvent(
				eventError,
				GENERAL_CATEGORY,
				OSFS_COPY_FILE_ERROR_ID,
				irgpsz,
				rgpsz,
				0,
				NULL,
				Pinst() );

		LocalFree( szSystemErrorDescription );
		}
	return err;
	}

ERR COSFileSystem::ErrFileCreate(	const _TCHAR* const	szPath,
									IFileAPI** const	ppfapi,
									const BOOL			fAtomic,
									const BOOL			fTemporary,
									const BOOL			fOverwriteExisting,
									const BOOL			fLockFile )
	{
	ERR							err				= JET_errSuccess;
	DWORD						error			= ERROR_SUCCESS;
	COSFile*					posf			= NULL;
	_TCHAR						szAbsPath[ IFileSystemAPI::cchPathMax ];
	DWORD						dtickTimeout	= cmsecAccessDeniedRetryPeriod;
	DWORD						tickStart		= GetTickCount();	
	HANDLE						hFile			= INVALID_HANDLE_VALUE;
	DWORD						cbIOSize;
	BY_HANDLE_FILE_INFORMATION	bhfi;
	QWORD						cbFileSize;
	BOOL						fIsCompressed;
	HANDLE						hEvent			= NULL;

	//  allocate the file object
	
	if ( !( posf = new COSFile( Pinst() ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

#ifdef LOGPATCH_UNIT_TEST

	hFile			= NULL;
	cbFileSize		= 5 * 1024 * 1024;
	cbIOSize		= 512;

#else	//	!LOGPATCH_UNIT_TEST

	//  RFS:  pre-creation error
	
	if ( !RFSAlloc( OSFileCreate ) )
		{
		error = ERROR_ACCESS_DENIED;
		CallJ( ErrGetLastError( error ), HandleWin32Error );
		}

	//  create the file, retrying for a limited time on access denied

	do
		{
		err		= JET_errSuccess;
		error	= ERROR_SUCCESS;
		
		hFile = CreateFile(	szPath,
							GENERIC_READ | GENERIC_WRITE,
							fLockFile ? 0 : FILE_SHARE_READ | FILE_SHARE_WRITE,
							NULL,
							fOverwriteExisting ? CREATE_ALWAYS : CREATE_NEW,
							(	FILE_ATTRIBUTE_NORMAL |
								( m_fWin9x ? 0 : FILE_FLAG_OVERLAPPED ) |
								( fTemporary ? FILE_FLAG_DELETE_ON_CLOSE : 0 ) |
								FILE_FLAG_WRITE_THROUGH |
								FILE_FLAG_NO_BUFFERING ),
							NULL );

		if ( hFile == INVALID_HANDLE_VALUE )
			{
			error	= GetLastError();
			err		= ErrGetLastError( error );

			if ( err == JET_errFileAccessDenied )
				{
				Sleep( 1 );
				}
			}
		}
	while ( err == JET_errFileAccessDenied && GetTickCount() - tickStart < dtickTimeout );
	CallJ( err, HandleWin32Error );

	SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	
	//  RFS:  post-creation error
	
	if ( !RFSAlloc( OSFileCreate ) )
		{
		error = ERROR_IO_DEVICE;
		CallJ( ErrGetLastError( error ), HandleWin32Error );
		}

	//  get the file's properties

	Call( ErrPathComplete( szPath, szAbsPath ) );

	if ( !GetFileInformationByHandle( hFile, &bhfi ) )
		{
		error = GetLastError();
		CallJ( ErrGetLastError( error ), HandleWin32Error );
		}
	cbFileSize		= ( QWORD( bhfi.nFileSizeHigh ) << 32 ) + bhfi.nFileSizeLow;
	fIsCompressed	= !!( bhfi.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED );

	Call( ErrFileAtomicWriteSize( szAbsPath, &cbIOSize ) );

	//  if the file is compressed then the kernel forces caching on so we can
	//  not perform atomic writes.  for our purposes, this is not acceptable so
	//  we will immediately decompress the file if it was created as compressed

	if ( !fTemporary && fIsCompressed )
		{
		USHORT		usCompressionState	= COMPRESSION_FORMAT_NONE;
		OVERLAPPED	overlapped			= { 0 };
		DWORD		cbTransferred		= 0;

		//  decompress the newly created, zero-length file
		
		Alloc( hEvent = CreateEvent( NULL, FALSE, FALSE, NULL ) );
		overlapped.hEvent = hEvent;
		if (	(	!DeviceIoControl(	hFile,
										FSCTL_SET_COMPRESSION,
										&usCompressionState,
										sizeof( usCompressionState ),
										NULL,
										0,
										&cbTransferred,
										m_fWin9x ? NULL : &overlapped ) &&
					GetLastError() != ERROR_IO_PENDING ) ||
				(	!m_fWin9x &&
					!GetOverlappedResult(	hFile,
											&overlapped,
											&cbTransferred,
											TRUE ) ) )
			{
			error = GetLastError();
			CallJ( ErrGetLastError( error ), HandleWin32Error );
			}

		//  reopen the file to ensure caching is disabled

		SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hFile );
		delete posf;
		CloseHandle( hEvent );

		if ( ( err = ErrFileOpen( szPath, ppfapi, fFalse, fLockFile ) ) < JET_errSuccess )
			{
			DeleteFile( szPath );
			}
		return err;
		}

#endif	//	LOGPATCH_UNIT_TEST

	//  initialize the file object

	Call( posf->ErrInit( szAbsPath, hFile, cbFileSize, fFalse, cbIOSize ) );
	hFile = INVALID_HANDLE_VALUE;

	//  return the interface to our file object

	*ppfapi = posf;

#ifndef LOGPATCH_UNIT_TEST

HandleWin32Error:
	if ( err < JET_errSuccess )
		{
		const _TCHAR*	rgpsz[ 4 ];
		DWORD			irgpsz						= 0;
		_TCHAR			szError[ 64 ];
		_TCHAR			szSystemError[ 64 ];
		_TCHAR*			szSystemErrorDescription	= NULL;

		if ( ErrPathComplete( szPath, szAbsPath ) < JET_errSuccess )
			{
			_tcscpy( szAbsPath, szPath );
			}
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
		_stprintf( szSystemError, _T( "%u (0x%08x)" ), error, error );
		FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_MAX_WIDTH_MASK ),
						NULL,
						error,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
						LPTSTR( &szSystemErrorDescription ),
						0,
						NULL );

		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szError;
		rgpsz[ irgpsz++ ]	= szSystemError;
		rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );

		UtilReportEvent(
				eventError,
				GENERAL_CATEGORY,
				OSFS_CREATE_FILE_ERROR_ID,
				irgpsz,
				rgpsz,
				0,
				NULL,
				Pinst() );

		LocalFree( szSystemErrorDescription );
		}

#endif	//	!LOGPATCH_UNIT_TEST

HandleError:
	if ( err < JET_errSuccess )
		{

#ifndef LOGPATCH_UNIT_TEST

		if ( hFile != INVALID_HANDLE_VALUE )
			{
			SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
			CloseHandle( hFile );
			DeleteFile( szPath );
			}

#endif	//	!LOGPATCH_UNIT_TEST

		delete posf;
		*ppfapi = NULL;
		}
	if ( hEvent )
		{
		CloseHandle( hEvent );
		}
	return err;
	}

ERR COSFileSystem::ErrFileOpen(	const _TCHAR* const	szPath,
								IFileAPI** const	ppfapi,
								const BOOL			fReadOnly,
								const BOOL			fLockFile )
	{
	ERR							err				= JET_errSuccess;
	DWORD						error			= ERROR_SUCCESS;
	COSFile*					posf			= NULL;
	_TCHAR						szAbsPath[ IFileSystemAPI::cchPathMax ];
	DWORD						dtickTimeout	= cmsecAccessDeniedRetryPeriod;
	DWORD						tickStart		= GetTickCount();	
	HANDLE						hFile			= INVALID_HANDLE_VALUE;
	DWORD						cbIOSize;
	BY_HANDLE_FILE_INFORMATION	bhfi;
	QWORD						cbFileSize;
	BOOL						fIsCompressed;
	HANDLE						hEvent			= NULL;

	//  allocate the file object
	
	if ( !( posf = new COSFile( Pinst() ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

#ifdef LOGPATCH_UNIT_TEST

	hFile			= NULL;
	cbFileSize		= 5 * 1024 * 1024;
	cbIOSize		= 512;

#else	//	!LOGPATCH_UNIT_TEST

	//  RFS:  access denied
	
	if ( !RFSAlloc( OSFileOpen ) )
		{
		error = ERROR_ACCESS_DENIED;
		CallJ( ErrGetLastError( error ), HandleWin32Error );
		}

	//  create the file, retrying for a limited time on access denied

	do
		{
		err		= JET_errSuccess;
		error	= ERROR_SUCCESS;
		
		hFile = CreateFile(	szPath,
							GENERIC_READ | ( fReadOnly ? 0 : GENERIC_WRITE ),
							(	fLockFile ?
								( fReadOnly ? FILE_SHARE_READ : 0 ) :
								FILE_SHARE_READ | FILE_SHARE_WRITE ),
							NULL,
							OPEN_EXISTING,
							(	FILE_ATTRIBUTE_NORMAL |
								( m_fWin9x ? 0 : FILE_FLAG_OVERLAPPED ) |
								FILE_FLAG_WRITE_THROUGH |
								FILE_FLAG_NO_BUFFERING ),
							NULL );

		if ( hFile == INVALID_HANDLE_VALUE )
			{
			error	= GetLastError();
			err		= ErrGetLastError( error );

			if ( err == JET_errFileAccessDenied )
				{
				Sleep( 1 );
				}
			}
		}
	while ( err == JET_errFileAccessDenied && GetTickCount() - tickStart < dtickTimeout );
	CallJ( err, HandleWin32Error );

	SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	//  get the file's properties

	Call( ErrPathComplete( szPath, szAbsPath ) );

	if ( !GetFileInformationByHandle( hFile, &bhfi ) )
		{
		error = GetLastError();
		CallJ( ErrGetLastError( error ), HandleWin32Error );
		}
	cbFileSize		= ( QWORD( bhfi.nFileSizeHigh ) << 32 ) + bhfi.nFileSizeLow;
	fIsCompressed	= !!( bhfi.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED );

	Call( ErrFileAtomicWriteSize( szAbsPath, &cbIOSize ) );

	//  if the file is compressed then the kernel forces caching on so we can
	//  not perform atomic writes.  for our purposes, this is not acceptable so
	//  we will immediately decompress the file if it is currently compressed.
	//  if the file is too big to convert then we will simply fail the open.
	//
	//	If this operation is being performed during setup, then no decompression
	//	will be attempted.  Instead, decompression will happen the next time
	//	the OS is cycled.
	//
	const QWORD cbFileSizeDecompressMax = 128 * 1024 * 1024;

	if ( !fReadOnly && fIsCompressed && !FOSSetupRunning() )
		{
		USHORT		usCompressionState	= COMPRESSION_FORMAT_NONE;
		OVERLAPPED	overlapped			= { 0 };
		DWORD		cbTransferred		= 0;

		//  decompress the file
		
		Alloc( hEvent = CreateEvent( NULL, FALSE, FALSE, NULL ) );
		overlapped.hEvent = hEvent;
		if (	cbFileSize >= cbFileSizeDecompressMax || 
				(	!DeviceIoControl(	hFile,
										FSCTL_SET_COMPRESSION,
										&usCompressionState,
										sizeof( usCompressionState ),
										NULL,
										0,
										&cbTransferred,
										m_fWin9x ? NULL : &overlapped ) &&
					GetLastError() != ERROR_IO_PENDING ) ||
				(	!m_fWin9x &&
					!GetOverlappedResult(	hFile,
											&overlapped,
											&cbTransferred,
											TRUE ) ) )
			{
			const _TCHAR*	rgpsz[ 2 ];
			DWORD			irgpsz						= 0;
			_TCHAR			szError[ 64 ];

			_stprintf( szError, _T( "%i (0x%08x)" ), JET_errFileCompressed, JET_errFileCompressed );

			rgpsz[ irgpsz++ ]	= szAbsPath;
			rgpsz[ irgpsz++ ]	= szError;

			UtilReportEvent(
					eventError,
					GENERAL_CATEGORY,
					OSFS_OPEN_COMPRESSED_FILE_RW_ERROR_ID,
					irgpsz,
					rgpsz,
					0,
					NULL,
					Pinst() );

			Call( ErrERRCheck( JET_errFileCompressed ) );
			}

		//  reopen the file to ensure caching is disabled

		SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hFile );
		delete posf;
		CloseHandle( hEvent );

		return ErrFileOpen( szPath, ppfapi, fReadOnly, fLockFile );
		}

#endif	//	LOGPATCH_UNIT_TEST

	//  initialize the file object

	Call( posf->ErrInit( szAbsPath, hFile, cbFileSize, fReadOnly, cbIOSize ) );
	hFile = INVALID_HANDLE_VALUE;

	//  return the interface to our file object

	*ppfapi = posf;

#ifndef LOGPATCH_UNIT_TEST

HandleWin32Error:
	if (	err < JET_errSuccess &&
			error != ERROR_FILE_NOT_FOUND )
		{
		const _TCHAR*	rgpsz[ 4 ];
		DWORD			irgpsz						= 0;
		_TCHAR			szError[ 64 ];
		_TCHAR			szSystemError[ 64 ];
		_TCHAR*			szSystemErrorDescription	= NULL;

		if ( ErrPathComplete( szPath, szAbsPath ) < JET_errSuccess )
			{
			_tcscpy( szAbsPath, szPath );
			}
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
		_stprintf( szSystemError, _T( "%u (0x%08x)" ), error, error );
		FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_MAX_WIDTH_MASK ),
						NULL,
						error,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
						LPTSTR( &szSystemErrorDescription ),
						0,
						NULL );

		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szError;
		rgpsz[ irgpsz++ ]	= szSystemError;
		rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );

		UtilReportEvent(
				eventError,
				GENERAL_CATEGORY,
				( fReadOnly ? OSFS_OPEN_FILE_RO_ERROR_ID : OSFS_OPEN_FILE_RW_ERROR_ID ),
				irgpsz,
				rgpsz,
				0,
				NULL,
				Pinst() );

		LocalFree( szSystemErrorDescription );
		}

#endif	//	!LOGPATCH_UNIT_TEST

HandleError:
	if ( err < JET_errSuccess )
		{

#ifndef LOGPATCH_UNIT_TEST

		if ( hFile != INVALID_HANDLE_VALUE )
			{
			SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
			CloseHandle( hFile );
			}

#endif	//	!LOGPATCH_UNIT_TEST

		delete posf;
		*ppfapi = NULL;
		}
	if ( hEvent )
		{
		CloseHandle( hEvent );
		}
	return err;
	}


COSFileFind::COSFileFind()
	:	m_posfs( NULL ),
		m_hFileFind( INVALID_HANDLE_VALUE ),
		m_fBeforeFirst( fTrue ),
		m_errFirst( JET_errFileNotFound ),
		m_errCurrent( JET_errFileNotFound )
	{
	}

ERR COSFileFind::ErrInit(	COSFileSystem* const	posfs,
							const _TCHAR* const		szFindPath )
	{
	ERR		err				= JET_errSuccess;
	_TCHAR	szAbsFindPath[ IFileSystemAPI::cchPathMax ];
	_TCHAR	szT[ IFileSystemAPI::cchPathMax ];
	_TCHAR*	pchEnd;
	BOOL	fExpectFolder	= fFalse;

	//  reference the file system object that created this File Find iterator
	
	m_posfs = posfs;

	//  copy our original search criteria
	
	_tcscpy( m_szFindPath, szFindPath );

	//  compute the full path of our search criteria

	CallJ( m_posfs->ErrPathComplete( szFindPath, szAbsFindPath ), DeferredInvalidPath )

	//  we are searching for a specific folder

	pchEnd = szAbsFindPath + _tcslen( szAbsFindPath ) - 1;
	if (	pchEnd > szAbsFindPath &&
			( *pchEnd == _T( '\\' ) || *pchEnd == _T( '/' ) ) )
		{
		//  strip the trailing delimiter from the path

		*pchEnd = _T( '\0' );

		//  remember that we expect to see a folder

		fExpectFolder = fTrue;
		}

	//  compute the absolute path of the folder we are searching

	CallJ( m_posfs->ErrPathParse( szAbsFindPath, m_szAbsFindPath, szT, szT ), DeferredInvalidPath );

	//  look for the first file or folder that matches our search criteria

	WIN32_FIND_DATA wfd;
	m_hFileFind = FindFirstFile( szAbsFindPath, &wfd );

	//  we found something
	
	if ( m_hFileFind != INVALID_HANDLE_VALUE )
		{

		//  setup the iterator to move first on the file or folder that
		//  we found

		_TCHAR	szFile[ IFileSystemAPI::cchPathMax ];
		_TCHAR	szExt[ IFileSystemAPI::cchPathMax ];

		m_fFolder	= !!( wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY );
		CallJ( m_posfs->ErrPathParse( wfd.cFileName, szT, szFile, szExt ), DeferredInvalidPath );
		CallJ( m_posfs->ErrPathBuild( m_szAbsFindPath, szFile, szExt, m_szAbsFoundPath ), DeferredInvalidPath );
		m_cbSize	= ( QWORD( wfd.nFileSizeHigh ) << 32 ) + wfd.nFileSizeLow;
		m_fReadOnly	= !!( wfd.dwFileAttributes & FILE_ATTRIBUTE_READONLY );
		
		m_errFirst = JET_errSuccess;

		//  if we should have found a folder but did not then setup the
		//  iterator to find nothing and return invalid path

		if ( fExpectFolder && !m_fFolder )
			{
			m_errFirst = JET_errInvalidPath;
			}
		}

	//  we didn't find something
	
	else
		{
		//  setup the iterator to move first onto the resulting error
		
		m_errFirst = m_posfs->ErrGetLastError();

		//  if the path was invalid then we did not find any files

		if ( m_errFirst == JET_errInvalidPath )
			{
			m_errFirst = JET_errFileNotFound;
			}

		//  if we failed for some reason other than not finding a file or
		//  folder that match our search criteria then fail the creation
		//  of the File Find iterator with that error
		
		if ( m_errFirst != JET_errFileNotFound )
			{
			Call( ErrERRCheck( m_errFirst ) );
			}

		//  the search criteria exactly matches the root of a volume

		_TCHAR *	szAbsRootPath	= szT;
		if (	m_posfs->ErrPathRoot( szAbsFindPath, szAbsRootPath ) == JET_errSuccess &&
				!_tcsnicmp(	szAbsFindPath,
							szAbsRootPath,
							max( _tcslen( szAbsFindPath ), _tcslen( szAbsRootPath ) - 1 ) ) )
			{
			//  get the attributes of the root

			const DWORD dwFileAttributes = GetFileAttributes( szAbsFindPath );

			//  we got the attributes of the root
			
			if ( dwFileAttributes != -1 )
				{
				//  setup the iterator to move first onto this root
				
				m_fFolder	= !!( dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY );
				_tcscpy( m_szAbsFoundPath, szAbsFindPath );
				m_cbSize	= 0;
				m_fReadOnly	= !!( dwFileAttributes & FILE_ATTRIBUTE_READONLY );
				
				m_errFirst	= JET_errSuccess;
				}

			//  we failed to get the attributes of the root
			
			else
				{
				//  setup the iterator to move first onto the resulting error
				
				m_errFirst = m_posfs->ErrGetLastError();
				}
			}
		}

	return JET_errSuccess;

HandleError:
	return err;

DeferredInvalidPath:
	//  if the path was invalid then we did not find any files
	m_errFirst = err == JET_errInvalidPath ? JET_errFileNotFound : err;
	return JET_errSuccess;
	}

COSFileFind::~COSFileFind()
	{
	if ( m_posfs )
		{
		//  unreference our file system object

		m_posfs = NULL;
		}
	if ( m_hFileFind != INVALID_HANDLE_VALUE )
		{
		FindClose( m_hFileFind );
		m_hFileFind = INVALID_HANDLE_VALUE;
		}
	m_fBeforeFirst	= fTrue;
	m_errFirst		= JET_errFileNotFound;
	m_errCurrent	= JET_errFileNotFound;
	}

ERR COSFileFind::ErrNext()
	{
	ERR err = JET_errSuccess;

	//  we have yet to move first

	if ( m_fBeforeFirst )
		{
		m_fBeforeFirst = fFalse;

		//  setup the iterator to be on the results of the move first that we
		//  did in ErrInit()
		
		m_errCurrent = m_errFirst;
		}

	//  we can potentially see more files or folders
	
	else if ( m_hFileFind != INVALID_HANDLE_VALUE )
		{
		WIN32_FIND_DATA wfd;

		//  we found another file or folder
		
		if ( FindNextFile( m_hFileFind, &wfd ) )
			{
			//  setup the iterator to be on the file or folder that we found
			
			_TCHAR	szT[ IFileSystemAPI::cchPathMax ];
			_TCHAR	szFile[ IFileSystemAPI::cchPathMax ];
			_TCHAR	szExt[ IFileSystemAPI::cchPathMax ];
			
			m_fFolder	= !!( wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY );
			Call( m_posfs->ErrPathParse( wfd.cFileName, szT, szFile, szExt ) );
			Call( m_posfs->ErrPathBuild( m_szAbsFindPath, szFile, szExt, m_szAbsFoundPath ) );
			m_cbSize	= ( QWORD( wfd.nFileSizeHigh ) << 32 ) + wfd.nFileSizeLow;
			m_fReadOnly	= !!( wfd.dwFileAttributes & FILE_ATTRIBUTE_READONLY );
			
			m_errCurrent = JET_errSuccess;
			}

		//  we didn't find another file or folder
		
		else
			{
			//  setup the iterator to be on the resulting error
			
			m_errCurrent = m_posfs->ErrGetLastError();
			}
		}

	//  we cannot potentially see any more files or folders

	else
		{
		//  setup the iterator to be after last

		m_errCurrent = JET_errFileNotFound;
		}

	//  RFS:  file not found

	if ( !RFSAlloc( OSFileFindNext ) )
		{
		m_errCurrent = JET_errFileNotFound;
		}

	//  check the error state of the iterator's current entry

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}
	
	return JET_errSuccess;

HandleError:
	m_errCurrent = err;
	return err;
	}

ERR COSFileFind::ErrIsFolder( BOOL* const pfFolder )
	{
	ERR err = JET_errSuccess;

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}

	*pfFolder = m_fFolder;
	return JET_errSuccess;

HandleError:
	*pfFolder = fFalse;
	return err;
	}
	
ERR COSFileFind::ErrPath( _TCHAR* const szAbsFoundPath )
	{
	ERR err = JET_errSuccess;

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}

	_tcscpy( szAbsFoundPath, m_szAbsFoundPath );
	return JET_errSuccess;

HandleError:
	_tcscpy( szAbsFoundPath, _T( "" ) );
	return err;
	}
	
ERR COSFileFind::ErrSize( QWORD* const pcbSize )
	{
	ERR err = JET_errSuccess;

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}

	*pcbSize = m_cbSize;
	return JET_errSuccess;

HandleError:
	*pcbSize = 0;
	return err;
	}
	
ERR COSFileFind::ErrIsReadOnly( BOOL* const pfReadOnly )
	{
	ERR err = JET_errSuccess;

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}

	*pfReadOnly = m_fReadOnly;
	return JET_errSuccess;

HandleError:
	*pfReadOnly = fFalse;
	return err;
	}


//  initializes an interface to the default OS File System

ERR ErrOSFSCreate( INST * const pinst, IFileSystemAPI** const ppfsapi )
	{
	ERR				err		= JET_errSuccess;
	COSFileSystem*	posfs	= NULL;

	//  allocate the file system object
	
	if ( !( posfs = new COSFileSystem( pinst ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  initialize the file system object

	Call( posfs->ErrInit() );

	//  return the interface to our file system object

	*ppfsapi = posfs;
	return JET_errSuccess;

HandleError:
	delete posfs;
	*ppfsapi = NULL;
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\osfile.cxx ===
#include "osstd.hxx"

#include "collection.hxx"

#include < malloc.h >


const TICK	dtickOSFileDiskFullEvent				= 60 * 1000;
const TICK	dtickOSFileAbnormalIOLatencyEvent		= 60 * 1000;
TICK		dtickOSFileAbnormalIOLatencyThreshold	= 60 * 1000;

LONG		cOSFileAbnormalReadIOLatency;
PM_CEF_PROC	LOSFileAbnormalReadIOLatencyCEFLPv;
LONG LOSFileAbnormalReadIOLatencyCEFLPv( LONG iInstance, VOID * pvBuf )
	{	
	if ( pvBuf )
		{		
		*( (ULONG *)pvBuf ) = cOSFileAbnormalReadIOLatency;
		}
	return 0;
	}

LONG		cOSFileAbnormalWriteIOLatency;
PM_CEF_PROC	LOSFileAbnormalWriteIOLatencyCEFLPv;
LONG LOSFileAbnormalWriteIOLatencyCEFLPv( LONG iInstance, VOID * pvBuf )
	{	
	if ( pvBuf )
		{		
		*( (ULONG *)pvBuf ) = cOSFileAbnormalWriteIOLatency;
		}
	return 0;
	}


////////////////////////////////////////
//  Support Functions

//  converts the last Win32 error code into an OSFile error code for return via
//  the OSFile API

ERR ErrOSFileIGetLastError( DWORD error = GetLastError() )
	{
	switch ( error )
		{
		case NO_ERROR:
		case ERROR_IO_PENDING:
			return JET_errSuccess;

		case ERROR_INVALID_PARAMETER:
		case ERROR_CALL_NOT_IMPLEMENTED:
			return ErrERRCheck( JET_errInvalidParameter );

		case ERROR_DISK_FULL:
			return ErrERRCheck( JET_errDiskFull );

		case ERROR_HANDLE_EOF:
			return ErrERRCheck( JET_errFileIOBeyondEOF );

		case ERROR_VC_DISCONNECTED:
		case ERROR_IO_DEVICE:
		case ERROR_DEVICE_NOT_CONNECTED:
		case ERROR_NOT_READY:
			return ErrERRCheck( JET_errDiskIO );

		case ERROR_NO_MORE_FILES:
		case ERROR_FILE_NOT_FOUND:
			return ErrERRCheck( JET_errFileNotFound );

		case ERROR_PATH_NOT_FOUND:
			return ErrERRCheck( JET_errInvalidPath );

		case ERROR_ACCESS_DENIED:
		case ERROR_SHARING_VIOLATION:
		case ERROR_LOCK_VIOLATION:
		case ERROR_WRITE_PROTECT:
			return ErrERRCheck( JET_errFileAccessDenied );

		case ERROR_TOO_MANY_OPEN_FILES:
			return ErrERRCheck( JET_errOutOfFileHandles );

		case ERROR_INVALID_USER_BUFFER:
		case ERROR_NOT_ENOUGH_MEMORY:
		case ERROR_WORKING_SET_QUOTA:
		case ERROR_NO_SYSTEM_RESOURCES:
			return ErrERRCheck( JET_errOutOfMemory );

		default:
			return ErrERRCheck( JET_errDiskIO );
		}
	}

//  returns the integer result of subtracting iFile1/ibOffset1 from iFile2/ibOffset2

INLINE __int64 IOSFileICmpIFileIbIFileIb( QWORD iFile1, QWORD ibOffset1, QWORD iFile2, QWORD ibOffset2 )
	{
	if ( iFile1 - iFile2 )
		{
		return iFile1 - iFile2;
		}
	else
		{
		return ibOffset1 - ibOffset2;
		}
	}


////////////////////////////////////////
//  Internal OSFile handle

class IOREQ;

class _OSFILE  //  _osf
	{
	public:

		enum IOMETHOD
			{
			iomethodSync,
			iomethodAsync,
			iomethodScatterGather
			};

		typedef void (*PfnFileIOComplete)(	const IOREQ* const		pioreq,
											const ERR				err,
											const DWORD_PTR			keyFileIOComplete );

	public:

		_OSFILE()
			:	semFilePointer( CSyncBasicInfo( _T( "_OSFILE::semFilePointer" ) ) )
			{
			semFilePointer.Release();
			}

	public:

		HANDLE				hFile;				//  Win32 file handle
		PfnFileIOComplete	pfnFileIOComplete;	//  Per-file I/O completion function
		DWORD_PTR			keyFileIOComplete;	//  Per-file I/O completion key

		INST *              pinst;				//	JET_INSTANCE assoicated with this file

		QWORD				iFile;				//  File Index (for I/O Heap)
		IOMETHOD			iomethodMost;		//  I/O capability
		CSemaphore			semFilePointer;		//  Semaphore Protecting the file pointer
		TICK				tickLastDiskFull;	//  last time we reported disk full

		TICK				tickLastAbnormalIOLatencyEvent;		//	last time we reported abnormal I/O latency
		TICK				dtickLastAbnormalIOLatency;			//	actual latency of I/O last time abnormal I/O latency event was reported
		LONG				cAbnormalIOLatencySinceLastEvent;	//	number of I/O's with abnormal latency since last abnormal I/O latency event was reported
	};

typedef _OSFILE* P_OSFILE;


////////////////////////////////////////
//  I/O Request Pool

//  I/O request

class IOREQ
	{
	public:
		static SIZE_T OffsetOfAPIC()		{ return OffsetOf( IOREQ, rgbAPIC ); }

		IOREQ& operator=( const IOREQ& ioreq )
			{
			memcpy( this, &ioreq, sizeof( IOREQ ) );

			return *this;
			}

	public:
		OVERLAPPED										ovlp;				//  must be first

	public:
		union
			{
			//	only used if IOREQ is in free pool
			//
			BYTE										rgbAPIC[ sizeof( CPool< IOREQ, OffsetOfAPIC >::CInvasiveContext	) ];

			//	only used if IOREQ is undergoing I/O
			//
			IOREQ*										pioreqNext;

			//	only used if IOREQ is in I/O heap
			//
			long										ipioreqHeap;
			};

		P_OSFILE										p_osf;
		TICK											tickIOStart;
		BOOL											fWrite:1;
		INT												group:2;
		QWORD											ibOffset;
		DWORD											cbData;
		const BYTE *									pbData;
		DWORD_PTR										dwCompletionKey;
		PFN												pfnCompletion;
	};


//  IOREQ pool

typedef CPool< IOREQ, IOREQ::OffsetOfAPIC > IOREQPool;

IOREQ*			rgioreq;
DWORD			cioreq;
volatile DWORD	cioreqInUse;
IOREQPool*		pioreqpool;

//  frees an IOREQ

INLINE void OSFileIIOREQFree( IOREQ* pioreq )
	{
	//	HACK: invasive context is unionised with other
	//	members of IOREQ, so must ensure, it is
	//	initialised properly before returning it to
	//	the pool
	//
	new( pioreq->rgbAPIC ) CPool< IOREQ, IOREQ::OffsetOfAPIC >::CInvasiveContext;

	//  free the IOREQ to the pool

	pioreqpool->Insert( pioreq );
	}

//  attemps to create a new IOREQ and, if successful, frees it to the IOREQ
//  pool

INLINE ERR ErrOSFileIIOREQCreate()
	{
	ERR		err				= JET_errSuccess;
	HANDLE	hEvent			= NULL;
	DWORD	cioreqInUseBI	= 0;

	//  pre-allocate all resources we will need to grow the pool

	Alloc( hEvent = CreateEvent( NULL, TRUE, FALSE, NULL ) );

	//  try to allocate space in the pool for the new IOREQ.  if there is no
	//  more room then just return success

	if ( !FAtomicIncrementMax( &cioreqInUse, &cioreqInUseBI, cioreq ) )
		{
		CloseHandle( hEvent );
		return JET_errSuccess;
		}

	//  add the new IOREQ to the pool

	new( rgioreq + cioreqInUseBI ) IOREQ;
	rgioreq[ cioreqInUseBI ].ovlp.hEvent = hEvent;
	SetHandleInformation( rgioreq[ cioreqInUseBI ].ovlp.hEvent, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	OSFileIIOREQFree( rgioreq + cioreqInUseBI );

HandleError:
	return err;
	}

//  allocates an IOREQ, waiting for a free IOREQ if necessary

INLINE IOREQ* PioreqOSFileIIOREQAlloc()
	{
	IOREQ *		pioreq;

	//  we have a cached IOREQ available

	if ( Ptls()->pioreqCache )
		{
		//  return the cached IOREQ

		pioreq = Ptls()->pioreqCache;
		Ptls()->pioreqCache = NULL;
		}

	//  we don't have a cached IOREQ available

	else
		{
		//  allocate an IOREQ from the IOREQ pool, waiting forever if necessary

		IOREQPool::ERR errIOREQ = pioreqpool->ErrRemove( &pioreq );
		Assert( errIOREQ == IOREQPool::errSuccess );

		//  there are no free IOREQs

		if ( !pioreqpool->Cobject() )
			{
			//  try to grow the IOREQ pool

			(void)ErrOSFileIIOREQCreate();

			//  start issuing I/O to produce more free IOREQs

			void OSFileIIOThreadStartIssue( const P_OSFILE p_osf );

			OSFileIIOThreadStartIssue( NULL );
			}
		}

	//	initialise I/O timer to ensure it's got a sane value
	//
	pioreq->tickIOStart = GetTickCount();

	//  return the allocated IOREQ

	return pioreq;
	}

//  frees an IOREQ to the IOREQ cache

INLINE void OSFileIIOREQFreeToCache( IOREQ* pioreq )
	{
	//  purge any IOREQs currently in the TLS cache

	if ( Ptls()->pioreqCache )
		{
		OSFileIIOREQFree( Ptls()->pioreqCache );
		}

	//  put the IOREQ in the TLS cache

	Ptls()->pioreqCache = pioreq;
	}

//  allocates an IOREQ from the IOREQ cache, returning NULL if empty

INLINE IOREQ* PioreqOSFileIIOREQAllocFromCache()
	{
	//  get IOREQ from cache, if any

	IOREQ* pioreq = Ptls()->pioreqCache;

	//  clear cache

	Ptls()->pioreqCache = NULL;

	//  return cached IOREQ, if any

	return pioreq;
	}

//  terminates the IOREQ pool

void OSFileIIOREQTerm()
	{
	//  term IOREQ pool

	if ( pioreqpool )
		{
		pioreqpool->Term();
		pioreqpool->IOREQPool::~IOREQPool();
		OSMemoryHeapFreeAlign( pioreqpool );
		pioreqpool = NULL;
		}

	//  free IOREQ storage if allocated

	if ( rgioreq )
		{
		for ( DWORD iioreq = 0; iioreq < cioreqInUse; iioreq++ )
			{
			if ( rgioreq[iioreq].ovlp.hEvent )
				{
				SetHandleInformation( rgioreq[iioreq].ovlp.hEvent, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
				CloseHandle( rgioreq[iioreq].ovlp.hEvent );
				}
			rgioreq[iioreq].~IOREQ();
			}
		OSMemoryPageFree( rgioreq );
		rgioreq = NULL;
		}
	}

//  initializes the IOREQ pool, or returns JET_errOutOfMemory

ERR ErrOSFileIIOREQInit()
	{
	ERR		err;

	//  reset all pointers

	rgioreq		= NULL;
	cioreqInUse	= 0;
	pioreqpool	= NULL;

	//  select arbitrary and capricious constants for IOREQ Pool
	//  CONSIDER:  expose these settings

#ifdef DEBUG
	cioreq = 64;
#else  //  !DEBUG
	//	on 32-bit, allocate one page-reserve-granularity's worth of IOREQ's,
	//	and allocate more on 64-bit (or greater) architectures
	//
	cioreq = ( OSMemoryPageReserveGranularity() * ( sizeof(ULONG_PTR) / sizeof(ULONG) ) ) / sizeof( IOREQ );
#endif  //  DEBUG

	//  allocate IOREQ storage

	if ( !( rgioreq = (IOREQ*)PvOSMemoryPageAlloc( cioreq * sizeof( IOREQ ), NULL ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  allocate IOREQ pool (we must do this as CRT is not yet init)

	BYTE *rgbIOREQPool;
	rgbIOREQPool = (BYTE*)PvOSMemoryHeapAllocAlign( sizeof( IOREQPool ), cbCacheLine );
	if ( !rgbIOREQPool )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	pioreqpool = new( rgbIOREQPool ) IOREQPool();

	//  init IOREQ pool

	switch ( pioreqpool->ErrInit( 0.0 ) )
		{
		default:
			AssertSz( fFalse, "Unexpected error initializing IOREQ Pool" );
		case IOREQPool::errOutOfMemory:
			Call( ErrERRCheck( JET_errOutOfMemory ) );
		case IOREQPool::errSuccess:
			break;
		}

	//  free an initial IOREQ to the pool

	Call( ErrOSFileIIOREQCreate() );

	return JET_errSuccess;

HandleError:
	OSFileIIOREQTerm();
	return err;
	}


////////////////////////
//  I/O Ascending Heap

//  critical section protecting the I/O Heap

extern CCriticalSection critIO;

//  I/O Ascending Heap

IOREQ* volatile *	rgpioreqIOAHeap;
long				ipioreqIOAHeapMax;
volatile long		ipioreqIOAHeapMac;

//  I/O Ascending Heap Functions

ERR ErrOSFileIIOAHeapInit();
void OSFileIIOAHeapTerm();
BOOL FOSFileIIOAHeapEmpty();
long CioreqOSFileIIOAHeap();
IOREQ* PioreqOSFileIIOAHeapTop();
void OSFileIIOAHeapAdd( IOREQ* pioreq );
void OSFileIIOAHeapRemove( IOREQ* pioreq );
BOOL FOSFileIIOAHeapIGreater( IOREQ* pioreq1, IOREQ* pioreq2 );
long IpioreqOSFileIIOAHeapIParent( long ipioreq );
long IpioreqOSFileIIOAHeapILeftChild( long ipioreq );
long IpioreqOSFileIIOAHeapIRightChild( long ipioreq );
void OSFileIIOAHeapIUpdate( IOREQ* pioreq );

//  initializes the I/O Ascending Heap, or returns JET_errOutOfMemory

ERR ErrOSFileIIOAHeapInit()
	{
	ERR err;

	//  reset all pointers

	rgpioreqIOAHeap = NULL;

	//  select arbitrary and capricious constants for I/O Ascending Heap
	//  CONSIDER:  expose these settings

	ipioreqIOAHeapMax = cioreq;

	//  allocate storage for the I/O Ascending Heap

	if ( !( rgpioreqIOAHeap = (IOREQ**) PvOSMemoryPageAlloc( ipioreqIOAHeapMax * sizeof( IOREQ* ), NULL ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  initialize the I/O Ascending Heap to be empty

	ipioreqIOAHeapMac = 0;

	return JET_errSuccess;

HandleError:
	OSFileIIOAHeapTerm();
	return err;
	}

//  terminates the I/O Ascending Heap

void OSFileIIOAHeapTerm()
	{
	//  free I/O Ascending Heap storage

	if ( rgpioreqIOAHeap != NULL )
		{
		OSMemoryPageFree( (void*)rgpioreqIOAHeap );
		rgpioreqIOAHeap = NULL;
		}
	}

//  returns fTrue if the I/O Ascending Heap is empty

INLINE BOOL FOSFileIIOAHeapEmpty()
	{
	Assert( critIO.FOwner() );
	return !ipioreqIOAHeapMac;
	}

//  returns the count of IOREQs in the I/O Ascending Heap

INLINE long CioreqOSFileIIOAHeap()
	{
	return ipioreqIOAHeapMac;
	}

//  returns IOREQ at the top of the I/O Ascending Heap, or NULL if empty

INLINE IOREQ* PioreqOSFileIIOAHeapTop()
	{
	Assert( critIO.FOwner() );
	Assert( !FOSFileIIOAHeapEmpty() );
	return rgpioreqIOAHeap[0];
	}

//  adds a IOREQ to the I/O Ascending Heap

INLINE void OSFileIIOAHeapAdd( IOREQ* pioreq )
	{
	//  critical section

	Assert( critIO.FOwner() );

	//  new value starts at bottom of heap

	long ipioreq = ipioreqIOAHeapMac++;

	//  percolate new value up the heap

	while (	ipioreq > 0 &&
			FOSFileIIOAHeapIGreater( pioreq, rgpioreqIOAHeap[IpioreqOSFileIIOAHeapIParent( ipioreq )] ) )
		{
		Assert(	rgpioreqIOAHeap[IpioreqOSFileIIOAHeapIParent( ipioreq )]->ipioreqHeap == IpioreqOSFileIIOAHeapIParent( ipioreq ) );
		rgpioreqIOAHeap[ipioreq] = rgpioreqIOAHeap[IpioreqOSFileIIOAHeapIParent( ipioreq )];
		rgpioreqIOAHeap[ipioreq]->ipioreqHeap = ipioreq;
		ipioreq = IpioreqOSFileIIOAHeapIParent( ipioreq );
		}

	//  put new value in its designated spot

	rgpioreqIOAHeap[ipioreq] = pioreq;
	pioreq->ipioreqHeap = ipioreq;
	}

//  removes a IOREQ from the I/O Ascending Heap

INLINE void OSFileIIOAHeapRemove( IOREQ* pioreq )
	{
	//  critical section

	Assert( critIO.FOwner() );

	//  remove the specified IOREQ from the heap

	long ipioreq = pioreq->ipioreqHeap;

	//  if this IOREQ was at the end of the heap, we're done

	if ( ipioreq == ipioreqIOAHeapMac - 1 )
		{
#ifdef DEBUG
		rgpioreqIOAHeap[ipioreqIOAHeapMac - 1] = (IOREQ*) 0xBAADF00DBAADF00D;
#endif  //  DEBUG
		ipioreqIOAHeapMac--;
		return;
		}

	//  copy IOREQ from tend of heap to fill removed IOREQ's vacancy

	rgpioreqIOAHeap[ipioreq] = rgpioreqIOAHeap[ipioreqIOAHeapMac - 1];
	rgpioreqIOAHeap[ipioreq]->ipioreqHeap = ipioreq;
#ifdef DEBUG
	rgpioreqIOAHeap[ipioreqIOAHeapMac - 1] = (IOREQ*) 0xBAADF00DBAADF00D;
#endif  //  DEBUG
	ipioreqIOAHeapMac--;

	//  update filler OSFiles position

	OSFileIIOAHeapIUpdate( rgpioreqIOAHeap[ipioreq] );
	}

//  updates a IOREQ's position in the I/O Ascending Heap if its weight has changed

void OSFileIIOAHeapIUpdate( IOREQ* pioreq )
	{
	//  critical section

	Assert( critIO.FOwner() );

	//  get the specified IOREQ's position

	long ipioreq = pioreq->ipioreqHeap;
	Assert( rgpioreqIOAHeap[ipioreq] == pioreq );

	//  percolate IOREQ up the heap

	while (	ipioreq > 0 &&
			FOSFileIIOAHeapIGreater( pioreq, rgpioreqIOAHeap[IpioreqOSFileIIOAHeapIParent( ipioreq )] ) )
		{
		Assert( rgpioreqIOAHeap[IpioreqOSFileIIOAHeapIParent( ipioreq )]->ipioreqHeap == IpioreqOSFileIIOAHeapIParent( ipioreq ) );
		rgpioreqIOAHeap[ipioreq] = rgpioreqIOAHeap[IpioreqOSFileIIOAHeapIParent( ipioreq )];
		rgpioreqIOAHeap[ipioreq]->ipioreqHeap = ipioreq;
		ipioreq = IpioreqOSFileIIOAHeapIParent( ipioreq );
		}

	//  percolate IOREQ down the heap

	while ( ipioreq < ipioreqIOAHeapMac )
		{
		//  if we have no children, stop here

		if ( IpioreqOSFileIIOAHeapILeftChild( ipioreq ) >= ipioreqIOAHeapMac )
			break;

		//  set child to greater child

		long ipioreqChild;
		if (	IpioreqOSFileIIOAHeapIRightChild( ipioreq ) < ipioreqIOAHeapMac &&
				FOSFileIIOAHeapIGreater(	rgpioreqIOAHeap[IpioreqOSFileIIOAHeapIRightChild( ipioreq )],
										rgpioreqIOAHeap[IpioreqOSFileIIOAHeapILeftChild( ipioreq )] ) )
			{
			ipioreqChild = IpioreqOSFileIIOAHeapIRightChild( ipioreq );
			}
		else
			{
			ipioreqChild = IpioreqOSFileIIOAHeapILeftChild( ipioreq );
			}

		//  if we are greater than the greatest child, stop here

		if ( FOSFileIIOAHeapIGreater( pioreq, rgpioreqIOAHeap[ipioreqChild] ) )
			break;

		//  trade places with greatest child and continue down

		Assert( rgpioreqIOAHeap[ipioreqChild]->ipioreqHeap == ipioreqChild );
		rgpioreqIOAHeap[ipioreq] = rgpioreqIOAHeap[ipioreqChild];
		rgpioreqIOAHeap[ipioreq]->ipioreqHeap = ipioreq;
		ipioreq = ipioreqChild;
		}
	Assert( ipioreq < ipioreqIOAHeapMac );

	//  put IOREQ in its designated spot

	rgpioreqIOAHeap[ipioreq] = pioreq;
	pioreq->ipioreqHeap = ipioreq;
	}

//  returns fTrue if the first IOREQ is greater than the second IOREQ

INLINE BOOL FOSFileIIOAHeapIGreater( IOREQ* pioreq1, IOREQ* pioreq2 )
	{
	return IOSFileICmpIFileIbIFileIb(	pioreq1->p_osf->iFile,
										pioreq1->ibOffset,
										pioreq2->p_osf->iFile,
										pioreq2->ibOffset ) < 0;
	}

//  returns the index to the parent of the given child

INLINE long IpioreqOSFileIIOAHeapIParent( long ipioreq )
	{
	return ( ipioreq - 1 ) / 2;
	}

//  returns the index to the left child of the given parent

INLINE long IpioreqOSFileIIOAHeapILeftChild( long ipioreq )
	{
	return 2 * ipioreq + 1;
	}

//  returns the index to the right child of the given parent

INLINE long IpioreqOSFileIIOAHeapIRightChild( long ipioreq )
	{
	return 2 * ipioreq + 2;
	}


/////////////////////////
//  I/O Descending Heap

//  critical section protecting the I/O Heap

extern CCriticalSection critIO;

//  I/O Descending Heap

IOREQ* volatile *	rgpioreqIODHeap;
long				ipioreqIODHeapMax;
volatile long		ipioreqIODHeapMic;

//  I/O Descending Heap Functions

ERR ErrOSFileIIODHeapInit();
void OSFileIIODHeapTerm();
BOOL FOSFileIIODHeapEmpty();
long CioreqOSFileIIODHeap();
IOREQ* PioreqOSFileIIODHeapTop();
void OSFileIIODHeapAdd( IOREQ* pioreq );
void OSFileIIODHeapRemove( IOREQ* pioreq );
BOOL FOSFileIIODHeapIGreater( IOREQ* pioreq1, IOREQ* pioreq2 );
long IpioreqOSFileIIODHeapIParent( long ipioreq );
long IpioreqOSFileIIODHeapILeftChild( long ipioreq );
long IpioreqOSFileIIODHeapIRightChild( long ipioreq );
void OSFileIIODHeapIUpdate( IOREQ* pioreq );


//  initializes the I/O Descending Heap, or returns JET_errOutOfMemory

ERR ErrOSFileIIODHeapInit()
	{
	//  I/O Descending Heap uses the heap memory that is not used by the
	//  I/O Ascending Heap, and therefore must be initialized second

	Assert( rgpioreqIOAHeap );

	rgpioreqIODHeap = rgpioreqIOAHeap;
	ipioreqIODHeapMax = ipioreqIOAHeapMax;

	//  initialize the I/O Descending Heap to be empty

	ipioreqIODHeapMic = ipioreqIODHeapMax;

	return JET_errSuccess;
	}

//  terminates the I/O Descending Heap

void OSFileIIODHeapTerm()
	{
	//  nop
	}

//  returns fTrue if the I/O Descending Heap is empty

INLINE BOOL FOSFileIIODHeapEmpty()
	{
	Assert( critIO.FOwner() );
	return ipioreqIODHeapMic == ipioreqIODHeapMax;
	}

//  returns the count of IOREQs in the I/O Descending Heap

INLINE long CioreqOSFileIIODHeap()
	{
	return long( ipioreqIODHeapMax - ipioreqIODHeapMic );
	}

//  returns IOREQ at the top of the I/O Descending Heap, or NULL if empty

INLINE IOREQ* PioreqOSFileIIODHeapTop()
	{
	Assert( critIO.FOwner() );
	Assert( !FOSFileIIODHeapEmpty() );
	return rgpioreqIODHeap[ipioreqIODHeapMax - 1];
	}

//  adds a IOREQ to the I/O Descending Heap

INLINE void OSFileIIODHeapAdd( IOREQ* pioreq )
	{
	//  critical section

	Assert( critIO.FOwner() );

	//  new value starts at bottom of heap

	long ipioreq = --ipioreqIODHeapMic;

	//  percolate new value up the heap

	while (	ipioreq < ipioreqIODHeapMax - 1 &&
			FOSFileIIODHeapIGreater( pioreq, rgpioreqIODHeap[IpioreqOSFileIIODHeapIParent( ipioreq )] ) )
		{
		Assert(	rgpioreqIODHeap[IpioreqOSFileIIODHeapIParent( ipioreq )]->ipioreqHeap == IpioreqOSFileIIODHeapIParent( ipioreq ) );
		rgpioreqIODHeap[ipioreq] = rgpioreqIODHeap[IpioreqOSFileIIODHeapIParent( ipioreq )];
		rgpioreqIODHeap[ipioreq]->ipioreqHeap = ipioreq;
		ipioreq = IpioreqOSFileIIODHeapIParent( ipioreq );
		}

	//  put new value in its designated spot

	rgpioreqIODHeap[ipioreq] = pioreq;
	pioreq->ipioreqHeap = ipioreq;
	}

//  removes a IOREQ from the I/O Descending Heap

INLINE void OSFileIIODHeapRemove( IOREQ* pioreq )
	{
	//  critical section

	Assert( critIO.FOwner() );

	//  remove the specified IOREQ from the heap

	long ipioreq = pioreq->ipioreqHeap;

	//  if this IOREQ was at the end of the heap, we're done

	if ( ipioreq == ipioreqIODHeapMic )
		{
#ifdef DEBUG
		rgpioreqIODHeap[ipioreqIODHeapMic] = (IOREQ*)0xBAADF00DBAADF00D;
#endif  //  DEBUG
		ipioreqIODHeapMic++;
		return;
		}

	//  copy IOREQ from end of heap to fill removed IOREQ's vacancy

	rgpioreqIODHeap[ipioreq] = rgpioreqIODHeap[ipioreqIODHeapMic];
	rgpioreqIODHeap[ipioreq]->ipioreqHeap = ipioreq;
#ifdef DEBUG
	rgpioreqIODHeap[ipioreqIODHeapMic] = (IOREQ*)0xBAADF00DBAADF00D;
#endif  //  DEBUG
	ipioreqIODHeapMic++;

	//  update filler IOREQs position

	OSFileIIODHeapIUpdate( rgpioreqIODHeap[ipioreq] );
	}

//  returns fTrue if the first IOREQ is greater than the second IOREQ

INLINE BOOL FOSFileIIODHeapIGreater( IOREQ* pioreq1, IOREQ* pioreq2 )
	{
	return IOSFileICmpIFileIbIFileIb(	pioreq1->p_osf->iFile,
										pioreq1->ibOffset,
										pioreq2->p_osf->iFile,
										pioreq2->ibOffset ) >= 0;
	}

//  returns the index to the parent of the given child

INLINE long IpioreqOSFileIIODHeapIParent( long ipioreq )
	{
	return ipioreqIODHeapMax - 1 - ( ipioreqIODHeapMax - 1 - ipioreq - 1 ) / 2;
	}

//  returns the index to the left child of the given parent

INLINE long IpioreqOSFileIIODHeapILeftChild( long ipioreq )
	{
	return ipioreqIODHeapMax - 1 - ( 2 * ( ipioreqIODHeapMax - 1 - ipioreq ) + 1 );
	}

//  returns the index to the right child of the given parent

INLINE long IpioreqOSFileIIODHeapIRightChild( long ipioreq )
	{
	return ipioreqIODHeapMax - 1 - ( 2 * ( ipioreqIODHeapMax - 1 - ipioreq ) + 2 );
	}

//  updates a IOREQ's position in the I/O Descending Heap if its weight has changed

void OSFileIIODHeapIUpdate( IOREQ* pioreq )
	{
	//  get the specified IOREQ's position

	long ipioreq = pioreq->ipioreqHeap;
	Assert( rgpioreqIODHeap[ipioreq] == pioreq );

	//  percolate IOREQ up the heap

	while (	ipioreq < ipioreqIODHeapMax - 1 &&
			FOSFileIIODHeapIGreater( pioreq, rgpioreqIODHeap[IpioreqOSFileIIODHeapIParent( ipioreq )] ) )
		{
		Assert( rgpioreqIODHeap[IpioreqOSFileIIODHeapIParent( ipioreq )]->ipioreqHeap == IpioreqOSFileIIODHeapIParent( ipioreq ) );
		rgpioreqIODHeap[ipioreq] = rgpioreqIODHeap[IpioreqOSFileIIODHeapIParent( ipioreq )];
		rgpioreqIODHeap[ipioreq]->ipioreqHeap = ipioreq;
		ipioreq = IpioreqOSFileIIODHeapIParent( ipioreq );
		}

	//  percolate IOREQ down the heap

	while ( ipioreq >= ipioreqIODHeapMic )
		{
		//  if we have no children, stop here

		if ( IpioreqOSFileIIODHeapILeftChild( ipioreq ) < ipioreqIODHeapMic )
			break;

		//  set child to greater child

		long ipioreqChild;
		if (	IpioreqOSFileIIODHeapIRightChild( ipioreq ) >= ipioreqIODHeapMic &&
				FOSFileIIODHeapIGreater(	rgpioreqIODHeap[IpioreqOSFileIIODHeapIRightChild( ipioreq )],
									rgpioreqIODHeap[IpioreqOSFileIIODHeapILeftChild( ipioreq )] ) )
			{
			ipioreqChild = IpioreqOSFileIIODHeapIRightChild( ipioreq );
			}
		else
			{
			ipioreqChild = IpioreqOSFileIIODHeapILeftChild( ipioreq );
			}

		//  if we are greater than the greatest child, stop here

		if ( FOSFileIIODHeapIGreater( pioreq, rgpioreqIODHeap[ipioreqChild] ) )
			break;

		//  trade places with greatest child and continue down

		Assert( rgpioreqIODHeap[ipioreqChild]->ipioreqHeap == ipioreqChild );
		rgpioreqIODHeap[ipioreq] = rgpioreqIODHeap[ipioreqChild];
		rgpioreqIODHeap[ipioreq]->ipioreqHeap = ipioreq;
		ipioreq = ipioreqChild;
		}
	Assert( ipioreq >= ipioreqIODHeapMic );

	//  put IOREQ in its designated spot

	rgpioreqIODHeap[ipioreq] = pioreq;
	pioreq->ipioreqHeap = ipioreq;
	}


//////////////
//  I/O Heap

//  critical section protecting the I/O Heap

CCriticalSection critIO( CLockBasicInfo( CSyncBasicInfo( "critIO" ), 0, 0 ) );

//  I/O Heap stats

BOOL	fAscending;

QWORD	iFileCurrent;
QWORD	ibOffsetCurrent;

//  terminates the I/O Heap

void OSFileIIOHeapTerm()
	{
	//  terminate sub-heaps

	OSFileIIODHeapTerm();
	OSFileIIOAHeapTerm();
	}

//  initializes the I/O Heap, or returns JET_errOutOfMemory

ERR ErrOSFileIIOHeapInit()
	{
	ERR err;

	//  init sub-heaps

	Call( ErrOSFileIIOAHeapInit() );
	Call( ErrOSFileIIODHeapInit() );

	//  reset current I/O stats

	fAscending		= fTrue;

	iFileCurrent	= 0;
	ibOffsetCurrent	= 0;

	return JET_errSuccess;

HandleError:
	OSFileIIOHeapTerm();
	return err;
	}

//  returns fTrue if the I/O Heap is empty

INLINE BOOL FOSFileIIOHeapEmpty()
	{
	Assert( critIO.FOwner() );
	return FOSFileIIOAHeapEmpty() && FOSFileIIODHeapEmpty();
	}

//  returns the count of IOREQs in the I/O Heap

INLINE long CioreqOSFileIIOHeap()
	{
	return CioreqOSFileIIOAHeap() + CioreqOSFileIIODHeap();
	}

//  returns IOREQ at the top of the I/O Heap, or NULL if empty

INLINE IOREQ* PioreqOSFileIIOHeapTop()
	{
	//  critical section

	Assert( critIO.FOwner() );

	//  the I/O Ascending Heap is empty

	if ( FOSFileIIOAHeapEmpty() )
		{
		//  the I/O Descending Heap is empty

		if ( FOSFileIIODHeapEmpty() )
			{
			//  the I/O Heap is empty

			return NULL;
			}

		//  the I/O Descending Heap is not empty

		else
			{
			//  return the top of the I/O Descending Heap

			return PioreqOSFileIIODHeapTop();
			}
		}

	//  the I/O Ascending Heap is not empty

	else
		{
		//  the I/O Descending Heap is empty

		if ( FOSFileIIODHeapEmpty() )
			{
			//  return the top of the I/O Ascending Heap

			return PioreqOSFileIIOAHeapTop();
			}

		//  the I/O Descending Heap is not empty

		else
			{
			//  select the IOREQ on top of the I/O Heap in our issue direction

			if ( fAscending )
				{
				return PioreqOSFileIIOAHeapTop();
				}
			else
				{
				return PioreqOSFileIIODHeapTop();
				}
			}
		}
	}

//  adds a IOREQ to the I/O Heap

INLINE void OSFileIIOHeapAdd( IOREQ* pioreq )
	{
	//  critical section

	Assert( critIO.FOwner() );

	//  this IOREQ should go in the I/O Ascending Heap

	if ( IOSFileICmpIFileIbIFileIb(	pioreq->p_osf->iFile,
									pioreq->ibOffset,
									iFileCurrent,
									ibOffsetCurrent ) >= 0 )
		{
		OSFileIIOAHeapAdd( pioreq );
		}

	//  this IOREQ should go in the I/O Descending Heap

	else
		{
		OSFileIIODHeapAdd( pioreq );
		}
	}

//  removes a IOREQ from the I/O Heap

INLINE void OSFileIIOHeapRemove( IOREQ* pioreq )
	{
	//  critical section

	Assert( critIO.FOwner() );

	//  this IOREQ is in the I/O Ascending Heap

	if ( pioreq->ipioreqHeap < ipioreqIOAHeapMac )
		{
		OSFileIIOAHeapRemove( pioreq );
		fAscending = fTrue;
		}

	//  this IOREQ is in the I/O Descending Heap

	else
		{
		OSFileIIODHeapRemove( pioreq );
		fAscending = fFalse;
		}

	//  remember the iFile/ibOffset of the last IOREQ removed from the I/O Heap

	iFileCurrent	= pioreq->p_osf->iFile;
	ibOffsetCurrent	= pioreq->ibOffset;
	}


////////////////
//  I/O Thread

DWORD  				cbIOMax;
BOOL				fTooManyIOs;
CTaskManager*		postaskmgrFile;
long				cIOPending;
HMODULE				hmodKernel32;

typedef
WINBASEAPI
BOOL
WINAPI
PFNReadFileScatter(
	IN HANDLE hFile,
	IN FILE_SEGMENT_ELEMENT aSegmentArray[],
	IN DWORD nNumberOfBytesToRead,
	IN LPDWORD lpReserved,
	IN LPOVERLAPPED lpOverlapped
	);

typedef
WINBASEAPI
BOOL
WINAPI
PFNWriteFileGather(
	IN HANDLE hFile,
	OUT FILE_SEGMENT_ELEMENT aSegmentArray[],
	IN DWORD nNumberOfBytesToWrite,
	IN LPDWORD lpReserved,
	IN LPOVERLAPPED lpOverlapped
	);

PFNReadFileScatter*	pfnReadFileScatter;
PFNWriteFileGather*	pfnWriteFileGather;

//  dummy stubs for ReadFileScatter / WriteFileGather

BOOL
WINAPI
ReadFileScatterNotSupported(
	IN HANDLE hFile,
	IN FILE_SEGMENT_ELEMENT aSegmentArray[],
	IN DWORD nNumberOfBytesToRead,
	IN LPDWORD lpReserved,
	IN LPOVERLAPPED lpOverlapped
	)
	{
	SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
	return FALSE;
	}

BOOL
WINAPI
WriteFileGatherNotSupported(
	IN HANDLE hFile,
	OUT FILE_SEGMENT_ELEMENT aSegmentArray[],
	IN DWORD nNumberOfBytesToWrite,
	IN LPDWORD lpReserved,
	IN LPOVERLAPPED lpOverlapped
	)
	{
	SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
	return FALSE;
	}

//  returns fTrue if the specified IOREQ can be processed using SGIO

INLINE BOOL FOSFileICanUseSGIO( IOREQ* pioreq )
	{
	return	pioreq->p_osf->iomethodMost >= _OSFILE::iomethodScatterGather &&		//  SGIO enabled for this file
			pioreq->cbData % OSMemoryPageCommitGranularity() == 0 &&				//  data is vmem page sized
			DWORD_PTR( pioreq->pbData ) % OSMemoryPageCommitGranularity() == 0;		//  data is vmem page aligned
	}

//  process I/O Thread Issue command

void OSFileIIOThreadCompleteWithErr( DWORD error, DWORD cbTransfer, IOREQ* pioreqHead );

#pragma optimize( "y", off )

void OSFileIIOThreadIIssue( const DWORD_PTR dwReserved1,
							const DWORD		dwReserved2,
							const DWORD_PTR	dwReserved3 )
	{
	//  allocate worst case storage for Scatter/Gather I/O list from the stack,
	//  allocating one extra for NULL terminating the list and another extra for
	//  aligning the list properly

	const DWORD cfse = cbIOMax / OSMemoryPageCommitGranularity() + 2;
	BYTE* rgbFSE = (BYTE*)_alloca( cfse * sizeof( FILE_SEGMENT_ELEMENT ) );
	rgbFSE = rgbFSE + sizeof( FILE_SEGMENT_ELEMENT ) - 1;
	rgbFSE = rgbFSE - DWORD_PTR( rgbFSE ) % sizeof( FILE_SEGMENT_ELEMENT );
	PFILE_SEGMENT_ELEMENT rgfse = PFILE_SEGMENT_ELEMENT( rgbFSE );

	//  issue as many I/Os as possible

	fTooManyIOs = fFalse;
	while ( !fTooManyIOs && CioreqOSFileIIOHeap() )
		{
		//  collect a run of IOREQs with continuous p_osf/ibs that are the same
		//  I/O type (read vs write)

		DWORD cbRun = 0;
		IOREQ* pioreqHead = NULL;
		IOREQ* pioreqTail = NULL;

		critIO.Enter();

		BOOL fMember = fTrue;
		while ( fMember && CioreqOSFileIIOHeap() )
			{
			//  get top of I/O heap

			IOREQ* pioreq = PioreqOSFileIIOHeapTop();

			//  determine if this IOREQ is a member of the current run

			fMember =	!pioreqTail ||																//  start of run (single IOREQs always OK)
						(	pioreq->fWrite == pioreqTail->fWrite &&									//  run for same I/O type (Read vs Write)
						 	(	pioreqTail->ibOffset + pioreqTail->cbData == pioreq->ibOffset ||	//  run is contiguous
								pioreq->ibOffset + pioreq->cbData == pioreqTail->ibOffset ) &&
							pioreq->p_osf == pioreqTail->p_osf &&									//  run in same file
							cbRun + pioreq->cbData <= cbIOMax &&									//  run no larger than max run size
							pioreq->ibOffset % cbIOMax &&											//  run aligned to max run size
							FOSFileICanUseSGIO( pioreqHead ) && FOSFileICanUseSGIO( pioreq ) );		//  run can use SGIO

			//  this IOREQ is a member of the current run

			if ( fMember )
				{
				//  take IOREQ out of I/O Heap

				OSFileIIOHeapRemove( pioreq );

				//  add IOREQ to run

				if ( !pioreqTail )
					{
					pioreqHead = pioreq;
					}
				else
					{
					pioreqTail->pioreqNext = pioreq;
					}
				pioreqTail = pioreq;
				pioreqTail->pioreqNext = NULL;
				cbRun += pioreq->cbData;
				}
			}

		critIO.Leave();

		//  determine I/O method for this run

		_OSFILE::IOMETHOD iomethod;

		iomethod	= (	pioreqHead == pioreqTail ?
							_OSFILE::iomethodAsync :
							_OSFILE::iomethodScatterGather );
		iomethod	= _OSFILE::IOMETHOD( min( pioreqHead->p_osf->iomethodMost, iomethod ) );

		//  prepare all IOREQs for I/O

		IOREQ* pioreq = pioreqHead;
		DWORD cbLast;
		for ( DWORD cb = 0; cb < cbRun; cb += cbLast )
			{
			//  setup for each I/O method

			switch ( iomethod )
				{
				case _OSFILE::iomethodSync:
				case _OSFILE::iomethodAsync:
					break;

				case _OSFILE::iomethodScatterGather:

					//  setup Scatter/Gather I/O source array for this buffer

					DWORD ipageRun = cb / OSMemoryPageCommitGranularity();
					DWORD cpageIOREQ = pioreq->cbData / OSMemoryPageCommitGranularity();
					DWORD cpageRun = cbRun / OSMemoryPageCommitGranularity();
					DWORD ipageStart;

					if ( pioreqHead->ibOffset < pioreqTail->ibOffset )
						{
						ipageStart = ipageRun;
						}
					else
						{
						ipageStart = cpageRun - ipageRun - cpageIOREQ;
						}

					//  copy data pointers into Scatter/Gather I/O list

					DWORD ipage;
					DWORD cbIOREQ;
					for (	ipage = ipageStart, cbIOREQ = 0;
							ipage < ipageStart + cpageIOREQ;
							ipage++, cbIOREQ += OSMemoryPageCommitGranularity() )
						{
						rgfse[ipage].Alignment	= 0;
						rgfse[ipage].Buffer		= (BYTE*)pioreq->pbData + cbIOREQ;
						}
					break;
				}

			cbLast = pioreq->cbData;
			pioreq = pioreq->pioreqNext;
			}

		//  setup embedded OVERLAPPED structure in the head IOREQ for the I/O

		QWORD ibOffset = min( pioreqHead->ibOffset, pioreqTail->ibOffset );
		pioreqHead->ovlp.Offset		= ULONG( ibOffset );
		pioreqHead->ovlp.OffsetHigh = ULONG( ibOffset >> 32 );

		//  null terminate the scatter list

		if ( iomethod == _OSFILE::iomethodScatterGather )
			{
			DWORD cpageRun = cbRun / OSMemoryPageCommitGranularity();

			rgfse[cpageRun].Alignment	= 0;
			rgfse[cpageRun].Buffer		= NULL;
			}

		//  RFS:  pre-completion error

		DWORD	cbTransfer		= 0;
		BOOL	fIOSucceeded	= RFSAlloc( pioreqHead->fWrite ? OSFileWrite : OSFileRead );
		DWORD	error			= fIOSucceeded ? ERROR_SUCCESS : ERROR_IO_DEVICE;

		//  issue the I/O

		switch ( iomethod )
			{
			case _OSFILE::iomethodSync:
				pioreqHead->p_osf->semFilePointer.Acquire();
				fIOSucceeded = (	fIOSucceeded &&
									(	SetFilePointer(	pioreqHead->p_osf->hFile,
														pioreqHead->ovlp.Offset,
														(long*)&pioreqHead->ovlp.OffsetHigh,
														FILE_BEGIN ) != INVALID_SET_FILE_POINTER ||
										GetLastError() == NO_ERROR ) );
				fIOSucceeded = (	fIOSucceeded &&
									(	pioreqHead->fWrite ?
											WriteFile(	pioreqHead->p_osf->hFile,
														pioreqHead->pbData,
														cbRun,
														&cbTransfer,
														NULL ) :
											ReadFile(	pioreqHead->p_osf->hFile,
														(BYTE*)pioreqHead->pbData,
														cbRun,
														&cbTransfer,
														NULL ) ) );
				pioreqHead->p_osf->semFilePointer.Release();
				break;

			case _OSFILE::iomethodAsync:
				fIOSucceeded = (	fIOSucceeded &&
									(	pioreqHead->fWrite ?
											WriteFile(	pioreqHead->p_osf->hFile,
														pioreqHead->pbData,
														cbRun,
														NULL,
														LPOVERLAPPED( pioreqHead ) ) :
											ReadFile(	pioreqHead->p_osf->hFile,
														(BYTE*)pioreqHead->pbData,
														cbRun,
														NULL,
														LPOVERLAPPED( pioreqHead ) ) ) );
				break;

			case _OSFILE::iomethodScatterGather:
				fIOSucceeded = (	fIOSucceeded &&
									(	pioreqHead->fWrite ?
											pfnWriteFileGather(	pioreqHead->p_osf->hFile,
																rgfse,
																cbRun,
																NULL,
																LPOVERLAPPED( pioreqHead ) ) :
											pfnReadFileScatter(	pioreqHead->p_osf->hFile,
																rgfse,
																cbRun,
																NULL,
																LPOVERLAPPED( pioreqHead ) ) ) );
				break;
			}
		error = error != ERROR_SUCCESS ? error : GetLastError();

		//  the issue succeeded and completed immediately

		if ( fIOSucceeded )
			{
			//  this was a sync I/O

			if ( iomethod == _OSFILE::iomethodSync )
				{
				//  complete the I/O

				OSFileIIOThreadCompleteWithErr( ERROR_SUCCESS, cbTransfer, pioreqHead );
				}

			//  this was not a sync I/O

			else
				{
				//  increment our pending I/O count

				AtomicIncrement( &cIOPending );

				//  the I/O completion has been posted to this thread so we
				//  will use it to complete the I/O
				}
			}

		//  the issue failed or did not complete immediately

		else
			{
			//  the I/O is pending

			const ERR errIO = ErrOSFileIGetLastError( error );

			if ( errIO >= 0 )
				{
				//  increment our pending I/O count

				AtomicIncrement( &cIOPending );

				//  the I/O completion will be posted to this thread later
				}

			//  we either issued too many I/Os or this I/O method does not work
			//  on this file

			else if (	errIO == JET_errOutOfMemory ||
					(	errIO == JET_errInvalidParameter &&
						iomethod > _OSFILE::iomethodSync ) )
				{
				//  we issued too many I/Os

				if ( errIO == JET_errOutOfMemory )
					{
					//  stop issuing I/O

					fTooManyIOs = fTrue;
					}

				//  this I/O method does not work on this file

				else
					{
					//  reduce I/O capability for this file

					pioreqHead->p_osf->iomethodMost = _OSFILE::IOMETHOD( pioreqHead->p_osf->iomethodMost - 1 );
					}

				//  return run to the I/O Heap so that we can try issuing it
				//  again later

				critIO.Enter();

				while ( pioreqHead )
					{
					IOREQ* const pioreqNext = pioreqHead->pioreqNext;
					OSFileIIOHeapAdd( pioreqHead );
					pioreqHead = pioreqNext;
					}

				critIO.Leave();
				}

			//  some other fatal error occurred

			else
				{
				//  complete the I/O with the error

				OSFileIIOThreadCompleteWithErr( error, 0, pioreqHead );
				}
			}
		}
	}

#pragma optimize( "", on )

//	report I/O errors encountered on completion

VOID OSFileIIOReportError(
	IOREQ * const	pioreqHead,
	const ERR		err,
	const DWORD		errSystem,
	const TICK		tickIOElapsed,
	const BOOL		fIOTookTooLong )
	{
	IFileAPI *		pfapi		= (IFileAPI*)pioreqHead->p_osf->keyFileIOComplete;  //  HACK!
	QWORD			ibOffset	= (	QWORD( pioreqHead->ovlp.Offset ) +
								( QWORD( pioreqHead->ovlp.OffsetHigh ) << 32 ) );
	DWORD			cbLength	= 0;
	const ULONG		csz			= 7;
	const _TCHAR *	rgpsz[ csz ];
	DWORD			irgpsz						= 0;
	_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
	_TCHAR			szOffset[ 64 ];
	_TCHAR			szLength[ 64 ];
	_TCHAR			szTimeElapsed[ 64 ];

	for ( IOREQ * pioreqT = pioreqHead; pioreqT; pioreqT = pioreqT->pioreqNext )
		{
		cbLength += pioreqT->cbData;
		}

	CallS( pfapi->ErrPath( szAbsPath ) );
	_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset, ibOffset );
	_stprintf( szLength, _T( "%u (0x%08x)" ), cbLength, cbLength );
	_stprintf( szTimeElapsed, _T( "%d" ), tickIOElapsed / 1000 );

	rgpsz[ irgpsz++ ]	= szAbsPath;
	rgpsz[ irgpsz++ ]	= szOffset;
	rgpsz[ irgpsz++ ]	= szLength;

	if ( fIOTookTooLong && err >= JET_errSuccess )
		{
		_TCHAR		szPreviousAbnormalIOs[ 64 ];
		_TCHAR		szPreviousAbnormalIOEvent[ 64 ];
		MessageId	msgid;
		const TICK	tickNow		= TickOSTimeCurrent();

		//	caused problems with BVT hardware 
		//
		//	AssertSz( fFalse, "I/O's are taking an abnormally long time to complete. The hardware on this machine is flaky!" );

		rgpsz[ irgpsz++ ] = szTimeElapsed;

		if ( 0 == pioreqHead->p_osf->tickLastAbnormalIOLatencyEvent )
			{
			//	first time this error has been encountered
			//	(well, there's actually the pathological case
			//	where the last time this error was encountered
			//	the tick counter had wrapped back to exactly
			//	zero, but we won't worry about it, you just end
			//	up getting the original eventlog message instead
			//	of the "AGAIN" eventlog message)
			//
			msgid = ( pioreqHead->fWrite ? OSFILE_WRITE_TOO_LONG_ID : OSFILE_READ_TOO_LONG_ID );
			}
		else
			{
			//	we've encountered this error before
			//
			_stprintf( szPreviousAbnormalIOs, _T( "%d" ), pioreqHead->p_osf->cAbnormalIOLatencySinceLastEvent );
			_stprintf( szPreviousAbnormalIOEvent, _T( "%d" ), ( tickNow - pioreqHead->p_osf->tickLastAbnormalIOLatencyEvent ) / 1000 );

			rgpsz[ irgpsz++ ] = szPreviousAbnormalIOs;
			rgpsz[ irgpsz++ ] = szPreviousAbnormalIOEvent;

			msgid = ( pioreqHead->fWrite ? OSFILE_WRITE_TOO_LONG_AGAIN_ID : OSFILE_READ_TOO_LONG_AGAIN_ID );
			}

		pioreqHead->p_osf->tickLastAbnormalIOLatencyEvent = tickNow;
		pioreqHead->p_osf->dtickLastAbnormalIOLatency = tickIOElapsed;
		pioreqHead->p_osf->cAbnormalIOLatencySinceLastEvent = 0;

		Assert( irgpsz <= csz );
		UtilReportEvent(
				eventWarning,
				PERFORMANCE_CATEGORY,
				msgid,
				irgpsz,
				rgpsz,
				0,
				NULL,
				pioreqHead->p_osf->pinst );
		}
	else
		{
		_TCHAR		szError[ 64 ];
		_TCHAR		szSystemError[ 64 ];
		_TCHAR *	szSystemErrorDescription	= NULL;

		Assert( err < JET_errSuccess );

		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
		_stprintf( szSystemError, _T( "%u (0x%08x)" ), errSystem, errSystem );
		FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_MAX_WIDTH_MASK ),
						NULL,
						errSystem,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
						LPTSTR( &szSystemErrorDescription ),
						0,
						NULL );

		rgpsz[ irgpsz++ ]	= szError;
		rgpsz[ irgpsz++ ]	= szSystemError;
		rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );
		rgpsz[ irgpsz++ ]	= szTimeElapsed;

		Assert( irgpsz <= csz );
		UtilReportEvent(
				eventError,
				GENERAL_CATEGORY,
				pioreqHead->fWrite ? OSFILE_WRITE_ERROR_ID : OSFILE_READ_ERROR_ID,
				irgpsz,
				rgpsz,
				0,
				NULL,
				pioreqHead->p_osf->pinst );

		LocalFree( szSystemErrorDescription );
		}
	}

//  process I/O completions

void OSFileIIOThreadCompleteWithErr( DWORD error, DWORD cbTransfer, IOREQ* pioreqHead )
	{
	const TICK	tickIOEnd		= TickOSTimeCurrent();
	const TICK	tickIOElapsed	= tickIOEnd - pioreqHead->tickIOStart;
	const BOOL	fIOTookTooLong	= ( tickIOElapsed > dtickOSFileAbnormalIOLatencyThreshold );

	//  RFS:  post-completion error

	if ( !RFSAlloc( pioreqHead->fWrite ? OSFileWrite : OSFileRead ) )
		{
		error = error != ERROR_SUCCESS ? error : ERROR_IO_DEVICE;
		}

	//  if this I/O failed then report it to the event log
	//
	//  exceptions:
	//
	//  -  we do not report ERROR_HANDLE_EOF
	//  -  we limit the frequency of ERROR_DISK_FULL reports

	const ERR	err				= ErrOSFileIGetLastError( error );
	BOOL		fReportError	= fIOTookTooLong;

	if ( fIOTookTooLong )
		{
		//	update stats
		//
		AtomicIncrement( pioreqHead->fWrite ? &cOSFileAbnormalWriteIOLatency : &cOSFileAbnormalReadIOLatency );

		//	if we're planning on reporting this abnormal I/O latency,
		//	verify we're not spamming the eventlog excessively with
		//	the same error
		//
		if ( ( tickIOEnd - pioreqHead->p_osf->tickLastAbnormalIOLatencyEvent ) < dtickOSFileAbnormalIOLatencyEvent
			&& tickIOElapsed < pioreqHead->p_osf->dtickLastAbnormalIOLatency * 3 / 2 )
			{
			//	if we recently reported an abnormal I/O latency and the current
			//	abnormal I/O latency is not significantly more than the previous one,,
			//	then don't bother reporting again
			//
			fReportError = fFalse;

			//	decided not to report this event, so just keep a count of
			//	how many we've skipped
			//
			AtomicIncrement( &pioreqHead->p_osf->cAbnormalIOLatencySinceLastEvent );
			}
		}

	if ( ERROR_HANDLE_EOF == error )
		{
		//	don't report error unless the I/O took too long
		//
		//	UNDONE: we will not track the last time we
		//	generated an eventlog for an ERROR_HANDLE_EOF
		//	that took too long, so we may end up spamming
		//	the eventlog
		//
		Assert( JET_errFileIOBeyondEOF == err );
		}
	else if ( ERROR_DISK_FULL == error )
		{
		//	only report DiskFull if we haven't done so in a while
		//
		Assert( JET_errDiskFull == err );
		fReportError = ( ( tickIOEnd - pioreqHead->p_osf->tickLastDiskFull ) > dtickOSFileDiskFullEvent );
		if ( fReportError )
			{
			pioreqHead->p_osf->tickLastDiskFull = TickOSTimeCurrent();
			}
		}
	else if ( err < JET_errSuccess )
		{
		fReportError = fTrue;
		}

	if ( fReportError )
		{
		OSFileIIOReportError( pioreqHead, err, error, tickIOElapsed, fIOTookTooLong );
		}

	//  process callback for each IOREQ

	const QWORD ibOffsetHead =	QWORD( pioreqHead->ovlp.Offset ) +
								( QWORD( pioreqHead->ovlp.OffsetHigh ) << 32 );

	IOREQ* pioreqUnused = NULL;
	IOREQ* pioreqNext;
	for ( IOREQ* pioreq = pioreqHead; pioreq; pioreq = pioreqNext )
		{
		//  fetch next IOREQ

		pioreqNext = pioreq->pioreqNext;

		//  get the error for this IOREQ, specifically with respect to reading
		//  past the end of file.  it is possible to get a run of IOREQs where
		//  some are before the EOF and some are after the EOF.  each must be
		//  passed or failed accordingly

		const DWORD	errorIOREQ	= (	error != ERROR_SUCCESS ?
										error :
										(	pioreq->ibOffset + pioreq->cbData <= ibOffsetHead + cbTransfer ?
												ERROR_SUCCESS :
												ERROR_HANDLE_EOF ) );

		//  backup the status of this IOREQ before we free it

		IOREQ const ioreq = *pioreq;

		//  free IOREQ for possible reuse by an I/O issued by this callback

		OSFileIIOREQFreeToCache( pioreq );

		//  perform per-file I/O completion callback

		ioreq.p_osf->pfnFileIOComplete(	&ioreq,
										ErrOSFileIGetLastError( errorIOREQ ),
										ioreq.p_osf->keyFileIOComplete );

		//  get IOREQ back from cache (if unused) and add to used IOREQ list

		pioreq = PioreqOSFileIIOREQAllocFromCache();
		if ( pioreq )
			{
			pioreq->pioreqNext = pioreqUnused;
			pioreqUnused = pioreq;
			}
		}

	//  free any unused IOREQs

	while ( pioreqUnused )
		{
		pioreqNext = pioreqUnused->pioreqNext;
		OSFileIIOREQFree( pioreqUnused );
		pioreqUnused = pioreqNext;
		}

	//  there are still I/Os that need to be issued

	if ( fTooManyIOs )
		{
		//  try to issue some more

		void OSFileIIOThreadStartIssue( const P_OSFILE p_osf );

		OSFileIIOThreadStartIssue( NULL );
		}
	}

void OSFileIIOThreadIComplete(	const DWORD_PTR	dwThreadContext,
								DWORD			cbTransfer,
								IOREQ			*pioreqHead )
	{
	//  this is a completion packet caused by our I/O functions

	if ( pioreqHead >= rgioreq && pioreqHead < rgioreq + cioreq )
		{
		//  decrement our pending I/O count

		AtomicDecrement( &cIOPending );

		//  call completion function with error

		OSFileIIOThreadCompleteWithErr( GetLastError(), cbTransfer, pioreqHead );
		}

	//  this is a completion packet caused by some other I/O

	else
		{
		//  ignore this I/O packet
		}
	}

void OSFileIIOThreadIIdle(	const DWORD_PTR dwReserved1,
							const DWORD		dwReserved2,
							const DWORD_PTR	dwReserved3 )
	{
	//  our init packet has completed

	if ( Ptls()->fIOThread )
		{
		//  there are queued I/Os and there are no pending I/Os

		if ( CioreqOSFileIIOHeap() && !cIOPending )
			{
			//  start issuing I/Os

			OSFileIIOThreadIIssue( 0, 0, 0 );
			}
		}
	}

void OSFileIIOThreadIInit(	const DWORD_PTR dwReserved1,
							const DWORD		dwReserved2,
							const DWORD_PTR	dwReserved3 )
	{
	//  mark this thread as part of the I/O pool

	Ptls()->fIOThread = fTrue;
	}

//  terminates the I/O Thread

void OSFileIIOThreadTerm( void )
	{
	//	term the task manager

	if ( postaskmgrFile )
		{
		postaskmgrFile->TMTerm();
		delete postaskmgrFile;
		postaskmgrFile = NULL;
		}

	//  unload SGIO

	if ( hmodKernel32 )
		{
		FreeLibrary( hmodKernel32 );
		hmodKernel32 = NULL;
		}
	}

//  initializes the I/O Thread, or returns either JET_errOutOfMemory or
//  JET_errOutOfThreads

ERR ErrOSFileIIOThreadInit( void )
	{
	ERR err;

	//  reset all pointers

	fTooManyIOs		= fFalse;
	postaskmgrFile	= NULL;
	cIOPending		= 0;
	hmodKernel32	= NULL;

	//  select arbitrary and capricious constants for I/O
	//  CONSIDER:  expose these settings

	cbIOMax = 1024 * 1024;

	//	initialize our task manager (1 thread, no local contexts)
	//  NOTE:  1 thread required to serialize I/O on Win9x

	postaskmgrFile = new CTaskManager;
	if ( !postaskmgrFile )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}
	Call( postaskmgrFile->ErrTMInit(	1,
										NULL,
										30000,
										OSFileIIOThreadIIdle ) );

	//  load SGIO

	if (	!( hmodKernel32 = LoadLibrary( _T( "kernel32.dll" ) ) ) ||
			!( pfnReadFileScatter = (PFNReadFileScatter*)GetProcAddress( hmodKernel32, _T( "ReadFileScatter" ) ) ) ||
			!( pfnWriteFileGather = (PFNWriteFileGather*)GetProcAddress( hmodKernel32, _T( "WriteFileGather" ) ) ) )
		{
		pfnReadFileScatter	= ReadFileScatterNotSupported;
		pfnWriteFileGather	= WriteFileGatherNotSupported;
		}

	//  post an init task

	Call( postaskmgrFile->ErrTMPost( OSFileIIOThreadIInit, 0, 0 ) );

	return JET_errSuccess;

HandleError:
	OSFileIIOThreadTerm();
	return err;
	}

//  tells I/O Thread to start issuing scheduled I/O

void OSFileIIOThreadStartIssue( const P_OSFILE p_osf )
	{
		const ERR err =	postaskmgrFile->ErrTMPost( OSFileIIOThreadIIssue, 0, 0 );
		Assert( JET_errSuccess == err );
	}

//  registers the given file for use with the I/O thread

INLINE ERR ErrOSFileIIOThreadRegisterFile( const P_OSFILE p_osf )
	{
	ERR err;

	//  attach the thread to the completion port

	if ( !postaskmgrFile->FTMRegisterFile(	p_osf->hFile,
											CTaskManager::PfnCompletion( OSFileIIOThreadIComplete ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  initially enable Scatter/Gather I/O.  we will disable it later if it
	//  is not permitted on this file

	p_osf->iomethodMost = _OSFILE::iomethodScatterGather;

	//  get File Index for I/O Heap

	p_osf->iFile = QWORD( DWORD_PTR( p_osf->hFile ) );

	//  init stats

	p_osf->tickLastDiskFull = TickOSTimeCurrent() - dtickOSFileDiskFullEvent;
	p_osf->tickLastAbnormalIOLatencyEvent = 0;
	p_osf->dtickLastAbnormalIOLatency = 0;
	p_osf->cAbnormalIOLatencySinceLastEvent = 0;

	return JET_errSuccess;

HandleError:
	return err;
	}


//  post-terminate file subsystem

void OSFilePostterm()
	{
	//  nop
	}

//  pre-init file subsystem

BOOL FOSFilePreinit()
	{
	const int	cbBuf			= 256;
	_TCHAR		szBuf[ cbBuf ];
	
	if ( FOSConfigGet( _T( "OS/IO" ), _T( "Abnormal I/O Latency Threshold" ), szBuf, cbBuf )
		&& szBuf[0] )
		{
		dtickOSFileAbnormalIOLatencyThreshold = max( 1, _ttol( szBuf ) ) * 1000;
		}

	return fTrue;
	}


//  pre-zeroed buffer used to extend files

QWORD			cbZero;
BYTE*			rgbZero;
COSMemoryMap*	posmmZero;


//  parameters

BOOL			fUseDirectIO;
QWORD			cbMMSize;


//  support for SetFileValidData

typedef
WINBASEAPI
BOOL
WINAPI
PFNSetFileValidData(
	IN HANDLE hFile,
	IN LONGLONG ValidDataLength
	);

HMODULE					hmodKernel;
PFNSetFileValidData*	pfnSetFileValidData;

//  dummy stub for SetFileValidData

BOOL
WINAPI
SetFileValidDataNotSupported(
	IN HANDLE hFile,
	IN LONGLONG ValidDataLength
	)
	{
	SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
	return FALSE;
	}

typedef
WINADVAPI
BOOL
WINAPI
PFNOpenProcessToken (
    IN HANDLE ProcessHandle,
    IN DWORD DesiredAccess,
    OUT PHANDLE TokenHandle
    );
typedef
WINADVAPI
BOOL
WINAPI
PFNLookupPrivilegeValue(
    IN LPCTSTR lpSystemName,
    IN LPCTSTR lpName,
    OUT PLUID lpLuid
    );
typedef
WINADVAPI
BOOL
WINAPI
PFNAdjustTokenPrivileges (
    IN HANDLE TokenHandle,
    IN BOOL DisableAllPrivileges,
    IN PTOKEN_PRIVILEGES NewState,
    IN DWORD BufferLength,
    OUT PTOKEN_PRIVILEGES PreviousState,
    OUT PDWORD ReturnLength
    );

HMODULE						hmodAdvapi;
PFNOpenProcessToken*		pfnOpenProcessToken;
PFNLookupPrivilegeValue*	pfnLookupPrivilegeValue;
PFNAdjustTokenPrivileges*	pfnAdjustTokenPrivileges;

//  enables process privileges

BOOL FOSFileIEnablePrivilege(	const _TCHAR*	szPriv,
								const BOOL		fEnable )
	{
	TOKEN_PRIVILEGES	tp;
	HANDLE				hToken		= NULL;

	tp.PrivilegeCount				= 1;
	tp.Privileges[ 0 ].Attributes	= fEnable ? SE_PRIVILEGE_ENABLED : 0;

	if (	!pfnOpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken ) ||
			!pfnLookupPrivilegeValue( NULL, szPriv, &tp.Privileges[ 0 ].Luid ) ||
			!pfnAdjustTokenPrivileges( hToken, FALSE, &tp, sizeof( tp ), NULL, NULL ) )
		{
		if ( hToken )
			{
			CloseHandle( hToken );
			}
		}

	return !GetLastError();
	}

//  terminate file subsystem

void OSFileTerm()
	{
	//  terminate all service threads

	OSFileIIOThreadTerm();

	//  terminate all components

	OSFileIIOHeapTerm();
	OSFileIIOREQTerm();

	if ( posmmZero )
		{
		//  free file extension buffer

		if ( rgbZero )
			{
			posmmZero->OSMMPatternFree();
			rgbZero = NULL;
			}

		//	term the memory map

		posmmZero->OSMMTerm();
		delete posmmZero;
		posmmZero = NULL;
		}
	else
		{
		//  free file extension buffer

		if ( rgbZero )
			{
			OSMemoryPageFree( rgbZero );
			rgbZero = NULL;
			}
		}

	//  unload SetFileValidData

	if ( hmodAdvapi )
		{
		FreeLibrary( hmodAdvapi );
		hmodAdvapi = NULL;
		}
	if ( hmodKernel )
		{
		FreeLibrary( hmodKernel );
		hmodKernel = NULL;
		}
	pfnSetFileValidData = SetFileValidDataNotSupported;
	}


//  init file subsystem

ERR ErrOSFileInit()
	{
	ERR				err							= JET_errSuccess;
#ifdef UNICODE
	const _TCHAR	szLookupPrivilegeValue[]	= _T( "LookupPrivilegeValueW" );
#else  //  !UNICODE
	const _TCHAR	szLookupPrivilegeValue[]	= _T( "LookupPrivilegeValueA" );
#endif  //  UNICODE

	//  reset all pointers

	rgbZero				= NULL;
	posmmZero			= NULL;
	hmodKernel			= NULL;
	pfnSetFileValidData	= SetFileValidDataNotSupported;
	hmodAdvapi			= NULL;

	//  load SetFileValidData

	if (	!( hmodKernel = LoadLibrary( _T( "kernel32.dll" ) ) ) ||
			!( pfnSetFileValidData = (PFNSetFileValidData*)GetProcAddress( hmodKernel, _T( "SetFileValidData" ) ) ) ||
			!( hmodAdvapi = LoadLibrary( _T( "advapi32.dll" ) ) ) ||
			!( pfnOpenProcessToken = (PFNOpenProcessToken*)GetProcAddress( hmodAdvapi, _T( "OpenProcessToken" ) ) ) ||
			!( pfnLookupPrivilegeValue = (PFNLookupPrivilegeValue*)GetProcAddress( hmodAdvapi, szLookupPrivilegeValue ) ) ||
			!( pfnAdjustTokenPrivileges = (PFNAdjustTokenPrivileges*)GetProcAddress( hmodAdvapi, _T( "AdjustTokenPrivileges" ) ) ) ||
			!FOSFileIEnablePrivilege( SE_MANAGE_VOLUME_NAME, fTrue ) )
		{
		pfnSetFileValidData = SetFileValidDataNotSupported;
		}

	//  load OS version

	OSVERSIONINFO osvi;
	memset( &osvi, 0, sizeof( osvi ) );
	osvi.dwOSVersionInfoSize = sizeof( osvi );
	if ( !GetVersionEx( &osvi ) )
		{
		Call( ErrOSFileIGetLastError() );
		}

	//  use direct I/O if we are not on Win9x

	fUseDirectIO = osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS;

	//  fetch our MM block size

	SYSTEM_INFO sinf;
	GetSystemInfo( &sinf );
	cbMMSize = sinf.dwAllocationGranularity;

	//  perform Win9x / non-Win9x init

	if ( osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS )
		{
		//  set all configuration defaults

		cbZero = 1 * 1024 * 1024;

		Assert( cbZero == size_t( cbZero ) );

		//  allocate file extension buffer by allocating the smallest chunk of page
		//  store possible and remapping it consecutively in memory until we hit the
		//  desired chunk size

		//	allocate the memory map object

		posmmZero = new COSMemoryMap();
		if ( !posmmZero )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		//	init the memory map

		COSMemoryMap::ERR errOSMM;
		errOSMM = posmmZero->ErrOSMMInit();
		if ( COSMemoryMap::errSuccess != errOSMM )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		//	allocate the pattern

		errOSMM = posmmZero->ErrOSMMPatternAlloc(	size_t( OSMemoryPageReserveGranularity() ),
													size_t( cbZero ),
													(void**)&rgbZero );
		if ( COSMemoryMap::errSuccess != errOSMM )
			{
			AssertSz(	COSMemoryMap::errOutOfBackingStore == errOSMM ||
						COSMemoryMap::errOutOfAddressSpace == errOSMM ||
						COSMemoryMap::errOutOfMemory == errOSMM,
						"unexpected error while allocating memory pattern" );
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		}
	else
		{
		//  set all configuration defaults

		cbZero = 64 * 1024;

		//  allocate the file extension buffer

		if ( !( rgbZero = (BYTE*)PvOSMemoryPageAlloc( size_t( cbZero ), NULL ) ) )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		}

	//  init performance counters

	cOSFileAbnormalReadIOLatency = 0;
	cOSFileAbnormalWriteIOLatency = 0;

	//  init all components

	Call( ErrOSFileIIOREQInit() );
	Call( ErrOSFileIIOHeapInit() );

	//  start all service threads

	Call( ErrOSFileIIOThreadInit() );

	return JET_errSuccess;

HandleError:
	OSFileTerm();
	return err;
	}


////////////////////////////////////////
//  API Implementation

COSFile::COSFile( INST * const pinst )
	:	IFileAPI( pinst ),
		m_hFile( INVALID_HANDLE_VALUE ),
		m_p_osf( NULL ),
		m_semChangeFileSize( CSyncBasicInfo( _T( "COSFile::m_semChangeFileSize" ) ) ),
		m_fDisableFastExt( pfnSetFileValidData == SetFileValidDataNotSupported ),
		m_critDefer( CLockBasicInfo( CSyncBasicInfo( _T( "COSFile::m_critDefer" ) ), 0, 0 ) )
	{
#ifdef LOGPATCH_UNIT_TEST

	m_cbData	= 0;
	m_rgbData	= NULL;

#endif	//	LOGPATCH_UNIT_TEST
	}

ERR COSFile::ErrInit(	_TCHAR* const	szAbsPath,
						const HANDLE	hFile,
						const QWORD		cbFileSize,
						const BOOL		fReadOnly,
						const DWORD		cbIOSize )
	{
	ERR err = JET_errSuccess;

	//  copy our arguments

	_tcscpy( m_szAbsPath, szAbsPath );
	m_hFile			= hFile;
	m_cbFileSize	= cbFileSize;
	m_fReadOnly		= fReadOnly;
	m_cbIOSize		= cbIOSize;
	m_cbMMSize		= cbMMSize;

	//  set our initial file size

	m_rgcbFileSize[ 0 ] = m_cbFileSize;
	m_semChangeFileSize.Release();

	//  set our initial layout update callbacks

	m_pfnEndUpdate		= PfnEndUpdate( EndUpdateSink_ );
	m_keyEndUpdate		= DWORD_PTR( NULL );

	m_pfnBeginUpdate	= PfnBeginUpdate( BeginUpdateSink_ );
	m_keyBeginUpdate	= DWORD_PTR( NULL );

	//  init our I/O context

	if ( !( m_p_osf = new _OSFILE ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	m_p_osf->hFile				= m_hFile;
	m_p_osf->pfnFileIOComplete	= _OSFILE::PfnFileIOComplete( IOComplete_ );
	m_p_osf->keyFileIOComplete	= DWORD_PTR( this );
	m_p_osf->pinst				= Pinst();

#ifndef LOGPATCH_UNIT_TEST

	Call( ErrOSFileIIOThreadRegisterFile( m_p_osf ) );

#else	//	LOGPATCH_UNIT_TEST

	m_cbData = DWORD( cbFileSize );
	m_rgbData = (BYTE*)PvOSMemoryPageAlloc( size_t( m_cbData ), NULL );
	if ( !m_rgbData )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

#endif	//	!LOGPATCH_UNIT_TEST

	return JET_errSuccess;

HandleError:
	m_hFile = INVALID_HANDLE_VALUE;
	return err;
	}

HANDLE COSFile::Handle()
	{
	return m_hFile;
	}

void COSFile::ForbidLayoutChanges()
	{
	}

void COSFile::PermitLayoutChanges()
	{
	}

COSFile::~COSFile()
	{
	//  we should stop layout updates before we start destruction

	if ( m_hFile != INVALID_HANDLE_VALUE )
		{
		SetHandleInformation( m_hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( m_hFile );
		m_hFile = INVALID_HANDLE_VALUE;
		}

	delete m_p_osf;
	m_p_osf = NULL;

#ifdef LOGPATCH_UNIT_TEST

	if ( m_rgbData )
		{
		OSMemoryPageFree( m_rgbData );
		}
	m_rgbData	= NULL;
	m_cbData	= 0;

#endif	//	LOGPATCH_UNIT_TEST
	}

ERR COSFile::ErrPath( _TCHAR* const szAbsPath )
	{
	_tcscpy( szAbsPath, m_szAbsPath );
	return JET_errSuccess;
	}

ERR COSFile::ErrSize( QWORD* const pcbSize )
	{
	const int group = m_msFileSize.Enter();
	*pcbSize = m_rgcbFileSize[ group ];
	m_msFileSize.Leave( group );
	return JET_errSuccess;
	}

ERR COSFile::ErrIsReadOnly( BOOL* const pfReadOnly )
	{
	*pfReadOnly = m_fReadOnly;
	return JET_errSuccess;
	}

ERR COSFile::ErrSetSize( const QWORD cbSize, const BOOL fGarbageAllowed )
	{
	CIOComplete iocomplete;

	//  allocate an extending write request

	CExtendingWriteRequest* const pewreq = new CExtendingWriteRequest;
	if ( !pewreq )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	//  allocate an I/O request structure

	IOREQ* const pioreq = PioreqOSFileIIOREQAlloc();

	//  wait until we can change the file size

	m_semChangeFileSize.Acquire();
	const int group = m_msFileSize.ActiveGroup();

	//  if we are extending the file and we are not required to zero out the
	//  new area of the file then try to directly set the size of the file.  if
	//  this doesn't work then we will simply fallback on the standard method

	BOOL fZeroFile = fTrue;

	if ( m_rgcbFileSize[ group ] < cbSize && fGarbageAllowed && !m_fDisableFastExt )
		{
		const DWORD	cbSizeLow	= DWORD( cbSize );
		DWORD	cbSizeHigh		= DWORD( cbSize >> 32 );

		m_p_osf->semFilePointer.Acquire();

		if ( (	SetFilePointer(	m_hFile,
								cbSizeLow,
								(long*)&cbSizeHigh,
								FILE_BEGIN ) != INVALID_SET_FILE_POINTER ||
				GetLastError() == NO_ERROR ) &&
				SetEndOfFile( m_hFile ) )
			{
			if ( pfnSetFileValidData( m_hFile, cbSize ) )
				{
				fZeroFile = fFalse;
				OSTrace( ostlMedium, OSFormat( "SetFileValidData( \"%s\", %I64d ) succeeded!", m_szAbsPath, cbSize ) );
				}
			else
				{
				m_fDisableFastExt = fTrue;
				OSTrace( ostlMedium, OSFormat( "SetFileValidData( \"%s\", %I64d ) failed with error %dL!", m_szAbsPath, cbSize, GetLastError() ) );
				}
			}

		m_p_osf->semFilePointer.Release();
		}

	//  we are extending the file and zeroing the extended region

	if ( m_rgcbFileSize[ group ] < cbSize && fZeroFile )
		{
		//  setup an extending write request to grow the file from the current
		//  size to the desired size by zeroing that region of the file

		pioreq->p_osf			= m_p_osf;
		pioreq->fWrite			= fTrue;
		pioreq->group			= group;
		pioreq->ibOffset		= m_rgcbFileSize[ group ];
		pioreq->cbData			= 0;
		pioreq->pbData			= NULL;
		pioreq->dwCompletionKey	= DWORD_PTR( pewreq );
		pioreq->pfnCompletion	= PFN( IOZeroingWriteComplete_ );

		pioreq->ovlp.Offset		= (ULONG) ( pioreq->ibOffset );
		pioreq->ovlp.OffsetHigh	= (ULONG) ( pioreq->ibOffset >> 32 );
		pioreq->pioreqNext		= NULL;

		pewreq->m_posf			= this;
		pewreq->m_pioreq		= pioreq;
		pewreq->m_group			= group;
		pewreq->m_ibOffset		= cbSize;
		pewreq->m_cbData		= 0;
		pewreq->m_pbData		= NULL;
		pewreq->m_pfnIOComplete	= PfnIOComplete( IOSyncComplete_ );
		pewreq->m_keyIOComplete	= DWORD_PTR( &iocomplete );

		OSFileIIOThreadCompleteWithErr(	ERROR_SUCCESS,
										pioreq->cbData,
										pioreq );
		}

	//  we are otherwise changing the file size

	else
		{
		//  setup a null extending write request at the desired file size

		pioreq->p_osf			= m_p_osf;
		pioreq->fWrite			= fTrue;
		pioreq->group			= group;
		pioreq->ibOffset		= cbSize;
		pioreq->cbData			= 0;
		pioreq->pbData			= NULL;
		pioreq->dwCompletionKey	= DWORD_PTR( pewreq );
		pioreq->pfnCompletion	= PFN( IOZeroingWriteComplete_ );

		pioreq->ovlp.Offset		= (ULONG) ( pioreq->ibOffset );
		pioreq->ovlp.OffsetHigh	= (ULONG) ( pioreq->ibOffset >> 32 );
		pioreq->pioreqNext		= NULL;

		pewreq->m_posf			= this;
		pewreq->m_pioreq		= pioreq;
		pewreq->m_group			= group;
		pewreq->m_ibOffset		= cbSize;
		pewreq->m_cbData		= 0;
		pewreq->m_pbData		= NULL;
		pewreq->m_pfnIOComplete	= PfnIOComplete( IOSyncComplete_ );
		pewreq->m_keyIOComplete	= DWORD_PTR( &iocomplete );

		OSFileIIOThreadCompleteWithErr(	ERROR_SUCCESS,
										pioreq->cbData,
										pioreq );
		}

	//  wait for the I/O completion and return its result

	if ( !iocomplete.m_msig.FTryWait() )
		{
		CallS( ErrIOIssue() );
		iocomplete.m_msig.Wait();
		}
	return iocomplete.m_err;
	}

ERR COSFile::ErrIOSize( DWORD* const pcbSize )
	{
	*pcbSize = m_cbIOSize;
	return JET_errSuccess;
	}

ERR COSFile::ErrIORead(	const QWORD			ibOffset,
						const DWORD			cbData,
						BYTE* const			pbData,
						const PfnIOComplete	pfnIOComplete,
						const DWORD_PTR		keyIOComplete )
	{
	ERR err = JET_errSuccess;

	//  a completion routine was specified

	if ( pfnIOComplete )
		{
#ifdef LOGPATCH_UNIT_TEST

		Enforce( ibOffset + cbData <= m_cbData );
		memcpy( pbData, m_rgbData + ibOffset, cbData );
		pfnIOComplete( JET_errSuccess, this, ibOffset, cbData, pbData, keyIOComplete );

#else	//	!LOGPATCH_UNIT_TEST

		//  allocate an I/O request structure

		IOREQ* const pioreq = PioreqOSFileIIOREQAlloc();

		//  use it to perform the I/O asynchronously

		IOAsync(	pioreq,
					fFalse,
					0,
					ibOffset,
					cbData,
					pbData,
					pfnIOComplete,
					keyIOComplete );

#endif	//	LOGPATCH_UNIT_TEST
		}

	//  a completion routine was not specified

	else
		{
		CIOComplete iocomplete;

		//  perform the I/O asynchronously

		CallS( ErrIORead(	ibOffset,
							cbData,
							pbData,
							PfnIOComplete( IOSyncComplete_ ),
							DWORD_PTR( &iocomplete ) ) );

		//  wait for the I/O completion and return its result

		if ( !iocomplete.m_msig.FTryWait() )
			{
			CallS( ErrIOIssue() );
			iocomplete.m_msig.Wait();
			}
		Call( iocomplete.m_err );
		}

	return JET_errSuccess;

HandleError:
	return err;
	}

ERR COSFile::ErrIOWrite(	const QWORD			ibOffset,
							const DWORD			cbData,
							const BYTE* const	pbData,
							const PfnIOComplete	pfnIOComplete,
							const DWORD_PTR		keyIOComplete )
	{
	ERR err = JET_errSuccess;

	//  a completion routine was specified

	if ( pfnIOComplete )
		{
#ifdef LOGPATCH_UNIT_TEST

		Enforce( ibOffset + cbData <= m_cbData );
		memcpy( m_rgbData + ibOffset, pbData, cbData );
		pfnIOComplete( JET_errSuccess, this, ibOffset, cbData, pbData, keyIOComplete );

#else	//	!LOGPATCH_UNIT_TEST

		//  allocate an I/O request structure

		IOREQ* const pioreq = PioreqOSFileIIOREQAlloc();

		//  use it to perform the I/O asynchronously

		IOAsync(	pioreq,
					fTrue,
					m_msFileSize.Enter(),
					ibOffset,
					cbData,
					(BYTE* const)pbData,
					pfnIOComplete,
					keyIOComplete );

#endif	//	LOGPATCH_UNIT_TEST
		}

	//  a completion routine was not specified

	else
		{
		CIOComplete iocomplete;

		//  perform the I/O asynchronously

		CallS( ErrIOWrite(	ibOffset,
							cbData,
							pbData,
							PfnIOComplete( IOSyncComplete_ ),
							DWORD_PTR( &iocomplete ) ) );

		//  wait for the I/O completion and return its result

		if ( !iocomplete.m_msig.FTryWait() )
			{
			CallS( ErrIOIssue() );
			iocomplete.m_msig.Wait();
			}
		Call( iocomplete.m_err );
		}

	return JET_errSuccess;

HandleError:
	return err;
	}

ERR COSFile::ErrIOIssue()
	{
	OSFileIIOThreadStartIssue( m_p_osf );
	return JET_errSuccess;
	}

ERR COSFile::ErrMMSize( QWORD* const pcbSize )
	{
	*pcbSize = m_cbMMSize;
	return JET_errSuccess;
	}

ERR COSFile::ErrMMRead(	const QWORD		ibOffset,
						const QWORD		cbSize,
						void** const	ppvMap,
						void* const		pvMapRequested )
	{
	ERR		err			= JET_errSuccess;
	HANDLE	hFileMap	= NULL;

	if ( size_t( cbSize ) != cbSize )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	//  RFS:  out of address space

	if ( !RFSAlloc( OSMemoryPageAddressSpace ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	if ( !( hFileMap = CreateFileMapping(	m_hFile,
											NULL,
											PAGE_READONLY | SEC_COMMIT,
											0,
											0,
											NULL ) ) )
		{
		Call( ErrOSFileIGetLastError() );
		}

	if ( !( *ppvMap = MapViewOfFileEx(	hFileMap,
										FILE_MAP_READ,
										DWORD( ibOffset >> 32 ),
										DWORD( ibOffset ),
										size_t( cbSize ),
										pvMapRequested ) ) )
		{
		Call( ErrOSFileIGetLastError() );
		}

	CloseHandle( hFileMap );
	hFileMap = NULL;

	//  RFS:  in-page error

	if ( !RFSAlloc( OSFileRead ) )
		{
		DWORD flOldProtect;
		(void)VirtualProtect( *ppvMap, DWORD( cbSize ), PAGE_NOACCESS, &flOldProtect );
		}

	return JET_errSuccess;

HandleError:
	if ( hFileMap )
		{
		CloseHandle( hFileMap );
		}
	*ppvMap = NULL;
	return err;
	}

ERR COSFile::ErrMMWrite(	const QWORD		ibOffset,
							const QWORD		cbSize,
							void** const	ppvMap,
							void* const		pvMapRequested )
	{
	ERR		err			= JET_errSuccess;
	HANDLE	hFileMap	= NULL;

	if ( size_t( cbSize ) != cbSize )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	//  RFS:  out of address space

	if ( !RFSAlloc( OSMemoryPageAddressSpace ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	if ( !( hFileMap = CreateFileMapping(	m_hFile,
											NULL,
											PAGE_READWRITE | SEC_COMMIT,
											0,
											0,
											NULL ) ) )
		{
		Call( ErrOSFileIGetLastError() );
		}

	if ( !( *ppvMap = MapViewOfFileEx(	hFileMap,
										FILE_MAP_WRITE,
										DWORD( ibOffset >> 32 ),
										DWORD( ibOffset ),
										size_t( cbSize ),
										pvMapRequested ) ) )
		{
		Call( ErrOSFileIGetLastError() );
		}

	CloseHandle( hFileMap );
	hFileMap = NULL;

	//  RFS:  in-page error

	if ( !RFSAlloc( OSFileRead ) )
		{
		DWORD flOldProtect;
		(void)VirtualProtect( *ppvMap, DWORD( cbSize ), PAGE_NOACCESS, &flOldProtect );
		}

	return JET_errSuccess;

HandleError:
	if ( hFileMap )
		{
		CloseHandle( hFileMap );
		}
	*ppvMap = NULL;
	return err;
	}

ERR COSFile::ErrMMFlush( void* const pvMap, const QWORD cbSize )
	{
	ERR err = JET_errSuccess;

	if ( size_t( cbSize ) != cbSize )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	//  RFS:  cannot flush view

	if ( !RFSAlloc( OSFileWrite ) )
		{
		Call( ErrERRCheck( JET_errDiskIO ) );
		}

	if ( !FlushViewOfFile( pvMap, size_t( cbSize ) ) )
		{
		Call( ErrOSFileIGetLastError() );
		}

	return JET_errSuccess;

HandleError:
	return err;
	}

ERR COSFile::ErrMMFree( void* const pvMap )
	{
	ERR err = JET_errSuccess;

	if ( pvMap && !UnmapViewOfFile( pvMap ) )
		{
		Call( ErrOSFileIGetLastError() );
		}

	return JET_errSuccess;

HandleError:
	return err;
	}

ERR COSFile::ErrRequestLayoutUpdates(	const PfnEndUpdate		pfnEndUpdate,
										const DWORD_PTR			keyEndUpdate,
										const PfnBeginUpdate	pfnBeginUpdate,
										const DWORD_PTR			keyBeginUpdate )
	{
	//  freeze our layout while updating our callbacks to avoid confusing the
	//  client

	ForbidLayoutChanges();

	//  update the callbacks

	m_pfnEndUpdate		= pfnEndUpdate ? pfnEndUpdate : PfnEndUpdate( EndUpdateSink_ );
	m_keyEndUpdate		= pfnEndUpdate ? keyEndUpdate : DWORD_PTR( NULL );

	m_pfnBeginUpdate	= pfnBeginUpdate ? pfnBeginUpdate : PfnBeginUpdate( BeginUpdateSink_ );
	m_keyBeginUpdate	= pfnBeginUpdate ? keyBeginUpdate : DWORD_PTR( NULL );

	//  unfreeze our layout

	PermitLayoutChanges();
	return JET_errSuccess;
	}

ERR COSFile::ErrQueryLayout(	const QWORD				ibVirtual,
								const QWORD				cbSize,
 								IFileLayoutAPI** const	ppflapi )
	{
	ERR				err		= JET_errSuccess;
	COSFileLayout*	posfl	= NULL;

	//  allocate the file layout iterator

	if ( !( posfl = new COSFileLayout ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  initialize the file layout iterator

	Call( posfl->ErrInit( this, ibVirtual, cbSize ) );

	//  return the interface to our file layout iterator

	*ppflapi = posfl;
	return JET_errSuccess;

HandleError:
	delete posfl;
	*ppflapi = NULL;
	return err;
	}

void COSFile::EndUpdateSink_(	COSFile* const	posf,
								const DWORD_PTR	keyEndUpdate )
	{
	posf->EndUpdateSink( keyEndUpdate );
	}

void COSFile::EndUpdateSink( const DWORD_PTR keyEndUpdate )
	{
	//  nop
	}

void COSFile::BeginUpdateSink_(	COSFile* const	posf,
								const DWORD_PTR	keyBeginUpdate )
	{
	posf->BeginUpdateSink( keyBeginUpdate );
	}

void COSFile::BeginUpdateSink( const DWORD_PTR keyBeginUpdate )
	{
	//  nop
	}

void COSFile::IOComplete_(	IOREQ* const	pioreq,
							const ERR		err,
							COSFile* const	posf )
	{
	posf->IOComplete( pioreq, err );
	}

void COSFile::IOComplete( IOREQ* const pioreq, const ERR err )
	{
	//  if this is a normal write then release our lock on the file size

	if (	pioreq->fWrite &&
			pioreq->pfnCompletion != PFN( IOZeroingWriteComplete_ ) &&
			pioreq->pfnCompletion != PFN( IOExtendingWriteComplete_ ) )
		{
		m_msFileSize.Leave( pioreq->group );
		}

	//  perform I/O completion callback

	const PfnIOComplete	pfnIOComplete	= PfnIOComplete( pioreq->pfnCompletion );

	pfnIOComplete(	err,
					this,
					pioreq->ibOffset,
					pioreq->cbData,
					pioreq->pbData,
					pioreq->dwCompletionKey );
	}

void COSFile::IOSyncComplete_(	const ERR			err,
								COSFile* const		posf,
								const QWORD			ibOffset,
								const DWORD			cbData,
								BYTE* const			pbData,
								CIOComplete* const	piocomplete )
	{
	posf->IOSyncComplete(	err,
							ibOffset,
							cbData,
							pbData,
							piocomplete );
	}

void COSFile::IOSyncComplete(	const ERR			err,
								const QWORD			ibOffset,
								const DWORD			cbData,
								BYTE* const			pbData,
								CIOComplete* const	piocomplete )
	{
	//  save the error code

	piocomplete->m_err = err;

	//  signal completion of the I/O

	piocomplete->m_msig.Set();
	}


//  workaround the fact that the current implementation of GetOverlappedResult
//  has a race condition where it can return before the kernel sets the event
//  in the overlapped struct.  this can cause subsequent I/Os that use this
//  event to return from GetOverlappedResult before the I/O has been completed

BOOL GetOverlappedResult_(	HANDLE			hFile,
							LPOVERLAPPED	lpOverlapped,
							LPDWORD			lpNumberOfBytesTransferred,
							BOOL			bWait )
	{
	DWORD error;

	error = WaitForSingleObjectEx(	lpOverlapped->hEvent ? lpOverlapped->hEvent : hFile,
									bWait ? INFINITE : 0,
									FALSE );

	if ( error == WAIT_OBJECT_0 )
		{
		Assert( HasOverlappedIoCompleted( lpOverlapped ) );
		return GetOverlappedResult(	hFile,
									lpOverlapped,
									lpNumberOfBytesTransferred,
									FALSE );
		}
	else if ( error == WAIT_TIMEOUT )
		{
		SetLastError( ERROR_IO_INCOMPLETE );
		return FALSE;
		}
	else
		{
		//  return error from WaitForSingleObjectEx
		return FALSE;
		}
	}


void COSFile::IOAsync(	IOREQ* const		pioreq,
						const BOOL			fWrite,
						const int			group,
						const QWORD			ibOffset,
						const DWORD			cbData,
						BYTE* const			pbData,
						const PfnIOComplete	pfnIOComplete,
						const DWORD_PTR		keyIOComplete )
	{
	//  setup the I/O request

	pioreq->p_osf			= m_p_osf;
	pioreq->fWrite			= fWrite;
	pioreq->group			= group;
	pioreq->ibOffset		= ibOffset;
	pioreq->cbData			= cbData;
	pioreq->pbData			= pbData;
	pioreq->dwCompletionKey	= keyIOComplete;
	pioreq->pfnCompletion	= PFN( pfnIOComplete );

	pioreq->ovlp.Offset		= (ULONG) ( pioreq->ibOffset );
	pioreq->ovlp.OffsetHigh	= (ULONG) ( pioreq->ibOffset >> 32 );
	pioreq->pioreqNext		= NULL;

	pioreq->tickIOStart		= TickOSTimeCurrent();

	//  this is an extending write

	if (	pioreq->fWrite &&
			pioreq->ibOffset + pioreq->cbData > m_rgcbFileSize[ pioreq->group ] )
		{
		//  try to allocate an extending write request

		CExtendingWriteRequest* const pewreq = new CExtendingWriteRequest;

		//  we failed to allocate an extending write request

		if ( !pewreq )
			{
			//  fail the I/O with out of memory

			OSFileIIOThreadCompleteWithErr(	ERROR_NOT_ENOUGH_MEMORY,
											pioreq->cbData,
											pioreq );
			}

		//  we got an extending write request

		else
			{
			//  save the parameters for this write

			pewreq->m_posf			= this;
			pewreq->m_pioreq		= pioreq;
			pewreq->m_group			= group;
			pewreq->m_ibOffset		= ibOffset;
			pewreq->m_cbData		= cbData;
			pewreq->m_pbData		= pbData;
			pewreq->m_pfnIOComplete	= pfnIOComplete;
			pewreq->m_keyIOComplete	= keyIOComplete;

			//  we can initiate a change in the file size

			if ( m_semChangeFileSize.FTryAcquire() )
				{
				//  start file extension by completing a fake extension I/O up to
				//  the current file size

				pioreq->ibOffset		= m_rgcbFileSize[ pioreq->group ];
				pioreq->cbData			= 0;
				pioreq->pbData			= NULL;
				pioreq->dwCompletionKey	= DWORD_PTR( pewreq );
				pioreq->pfnCompletion	= PFN( IOZeroingWriteComplete_ );

				pioreq->ovlp.Offset		= (ULONG) ( pioreq->ibOffset );
				pioreq->ovlp.OffsetHigh	= (ULONG) ( pioreq->ibOffset >> 32 );

				m_msFileSize.Leave( pioreq->group );

				OSFileIIOThreadCompleteWithErr(	ERROR_SUCCESS,
												pioreq->cbData,
												pioreq );
				}

			//  we cannot initiate a change in the file size

			else
				{
				//  save our group number before we defer this write so that we
			    //  can leave the proper group number after posting it to the
			    //  deferred extending write queue

			    const int groupT = pioreq->group;

			    //  defer this extending write
			    m_critDefer.Enter();
			    m_ilDefer.InsertAsNextMost( pewreq );
			    m_critDefer.Leave();

			    // leave metered section after appending to list to ensure
			    // that IOChangeFileSizeComplete() will see the deferral.
			    m_msFileSize.Leave( groupT );
				}
			}
		}

	//  SPECIAL CASE:  this is a sync I/O and we can directly issue it on this
	//  thread

	else if (	pioreq->pfnCompletion == PFN( IOSyncComplete_ ) &&
				fUseDirectIO &&
				!Ptls()->fIOThread )
		{
		//  directly issue the I/O

		pioreq->ovlp.hEvent = HANDLE( DWORD_PTR( pioreq->ovlp.hEvent ) | DWORD_PTR( 1 ) );

		DWORD		cbTransfer;
		const BOOL	fIOSucceeded	= (	pioreq->fWrite ?
											WriteFile(	pioreq->p_osf->hFile,
														(BYTE*)pioreq->pbData,
														pioreq->cbData,
														&cbTransfer,
														LPOVERLAPPED( pioreq ) ) :
											ReadFile(	pioreq->p_osf->hFile,
														(BYTE*)pioreq->pbData,
														pioreq->cbData,
														&cbTransfer,
														LPOVERLAPPED( pioreq ) ) );
		const DWORD	error			= GetLastError();

		//  the issue succeeded and completed immediately

		if ( fIOSucceeded )
			{
			//  complete the I/O

			pioreq->ovlp.hEvent = HANDLE( DWORD_PTR( pioreq->ovlp.hEvent ) & ( ~DWORD_PTR( 1 ) ) );
			OSFileIIOThreadCompleteWithErr( ERROR_SUCCESS, cbTransfer, pioreq );
			}

		//  the issue failed or did not complete immediately

		else
			{
			//  the I/O is pending

			const ERR errIO = ErrOSFileIGetLastError( error );

			if ( errIO >= 0 )
				{
				//  wait for the I/O to complete and complete the I/O with the
				//  appropriate error code

				if ( GetOverlappedResult_(	pioreq->p_osf->hFile,
											LPOVERLAPPED( pioreq ),
											&cbTransfer,
											TRUE ) )
					{
					pioreq->ovlp.hEvent = HANDLE( DWORD_PTR( pioreq->ovlp.hEvent ) & ( ~DWORD_PTR( 1 ) ) );
					OSFileIIOThreadCompleteWithErr( ERROR_SUCCESS, cbTransfer, pioreq );
					}
				else
					{
					pioreq->ovlp.hEvent = HANDLE( DWORD_PTR( pioreq->ovlp.hEvent ) & ( ~DWORD_PTR( 1 ) ) );
					OSFileIIOThreadCompleteWithErr( GetLastError(), 0, pioreq );
					}
				}

			//  we issued too many I/Os

			else if ( JET_errOutOfMemory == errIO )
				{
				//  queue the I/O for async completion

				pioreq->ovlp.hEvent = HANDLE( DWORD_PTR( pioreq->ovlp.hEvent ) & ( ~DWORD_PTR( 1 ) ) );
				critIO.Enter();
				OSFileIIOHeapAdd( pioreq );
				critIO.Leave();
				}

			//  some other fatal error occurred

			else
				{
				//  complete the I/O with the error

				pioreq->ovlp.hEvent = HANDLE( DWORD_PTR( pioreq->ovlp.hEvent ) & ( ~DWORD_PTR( 1 ) ) );
				OSFileIIOThreadCompleteWithErr( error, 0, pioreq );
				}
			}
		}

	//  this is not an extending write and is not a special case I/O

	else
		{
		//  queue the I/O for async completion

		critIO.Enter();
		OSFileIIOHeapAdd( pioreq );
		critIO.Leave();
		}
	}

void COSFile::IOZeroingWriteComplete_(	const ERR						err,
										COSFile* const					posf,
										const QWORD						ibOffset,
										const DWORD						cbData,
										BYTE* const						pbData,
										CExtendingWriteRequest* const	pewreq )
	{
	posf->IOZeroingWriteComplete(	err,
									ibOffset,
									cbData,
									pbData,
									pewreq );
	}

void COSFile::IOZeroingWriteComplete(	const ERR						err,
										const QWORD						ibOffset,
										const DWORD						cbData,
										BYTE* const						pbData,
										CExtendingWriteRequest* const	pewreq )
	{
	//  save the current error

	pewreq->m_err = err;

	//	start file extension process of zeroing from current filesystem EOF
	//	(using as many zeroing I/Os as we need) up to any extending write
	//	that we need to complete. if we're going to be using more than 1 I/O
	//	to extend the file to its new size, we should call SetEndOfFile() ahead
	//	of time to give the filesystem more information up front. (and we
	//	don't want to always call SetEndOfFile() [even though it would be
	//	"correct"] because NTFS counterintuitively behaves worse then.)

	if ( pewreq->m_err >= JET_errSuccess &&
		//	start of extension process (also case of file size staying the same)
		ibOffset + cbData == m_rgcbFileSize[ pewreq->m_group ] &&
		//	if extending write is past EOF, this means that at least 1
		//	zeroing I/O will need to be done
		pewreq->m_ibOffset > m_rgcbFileSize[ pewreq->m_group ] &&
		//	if extending write has actual data to be written, that is an additional I/O,
		//	or if there will need to be more than 1 zeroing I/O.
		( pewreq->m_cbData > 0 || pewreq->m_ibOffset - m_rgcbFileSize[ pewreq->m_group ] > cbZero ) )
		{
		//	give the filesystem early notification of how much storage we require
		//	for this entire multi-I/O extension process

		const QWORD	cbSize		= pewreq->m_ibOffset + pewreq->m_cbData;
		const DWORD	cbSizeLow	= DWORD( cbSize );
		DWORD	cbSizeHigh		= DWORD( cbSize >> 32 );

		m_p_osf->semFilePointer.Acquire();

		if ( (	SetFilePointer(	m_hFile,
								cbSizeLow,
								(long*)&cbSizeHigh,
								FILE_BEGIN ) == INVALID_SET_FILE_POINTER &&
				GetLastError() != NO_ERROR ) ||
			!SetEndOfFile( m_hFile ) )
			{
			pewreq->m_err = (	pewreq->m_err < JET_errSuccess ?
								pewreq->m_err :
								ErrOSFileIGetLastError() );
			}

		m_p_osf->semFilePointer.Release();
		}

	//  this zeroing write succeeded

	if ( pewreq->m_err >= JET_errSuccess )
		{
		//  there is still more file to be zeroed between the original file size
		//  and the extending write

		if ( ibOffset + cbData < pewreq->m_ibOffset )
			{
			//  compute the offset of the current chunk to be zeroed

			const QWORD ibWrite = ibOffset + cbData;

			//	We used to chunk align our zeroing writes (for unknown
			//	reasons) by using "cbZero - ibWrite % cbZero" instead of
			//	"cbZero" in the min() below. Chunk aligning broke NTFS's
			//	secret automagic pre-allocation algorithms which increased
			//	file fragmentation.

			const QWORD cbWrite = min(	cbZero,
										pewreq->m_ibOffset - ibWrite );
			Assert( DWORD( cbWrite ) == cbWrite );

			//  set the new file size to the file size after extension

			m_rgcbFileSize[ 1 - pewreq->m_group ] = ibWrite + cbWrite;

			//  zero the next aligned chunk of the file

			const P_OSFILE p_osf = pewreq->m_posf->m_p_osf;

			IOREQ* const pioreq = PioreqOSFileIIOREQAlloc();

			IOAsync(	pioreq,
						fTrue,
						1 - pewreq->m_group,
						ibWrite,
						DWORD( cbWrite ),
						rgbZero,
						PfnIOComplete( IOZeroingWriteComplete_ ),
						DWORD_PTR( pewreq ) );

			OSFileIIOThreadStartIssue( p_osf );
			}

		//  there is no more file to be zeroed

		else
			{
			//  set the new file size to the file size after extension

			m_rgcbFileSize[ 1 - pewreq->m_group ] = pewreq->m_ibOffset + pewreq->m_cbData;

			//  perform the original extending write

			const P_OSFILE p_osf = pewreq->m_posf->m_p_osf;

			IOREQ* const pioreq = PioreqOSFileIIOREQAlloc();

			IOAsync(	pioreq,
						fTrue,
						1 - pewreq->m_group,
						pewreq->m_ibOffset,
						pewreq->m_cbData,
						pewreq->m_pbData,
						PfnIOComplete( IOExtendingWriteComplete_ ),
						DWORD_PTR( pewreq ) );

			OSFileIIOThreadStartIssue( p_osf );
			}
		}

	//  this zeroing write failed

	else
		{
		//  set the file size back to the original file size

		m_rgcbFileSize[ 1 - pewreq->m_group ] = m_rgcbFileSize[ pewreq->m_group ];

		//  change over to the new file size

		m_msFileSize.Partition( CMeteredSection::PFNPARTITIONCOMPLETE( IOChangeFileSizeComplete_ ),
								DWORD_PTR( pewreq ) );
		}
	}

void COSFile::IOExtendingWriteComplete_(	const ERR						err,
											COSFile* const					posf,
											const QWORD						ibOffset,
											const DWORD						cbData,
											BYTE* const						pbData,
											CExtendingWriteRequest* const	pewreq )
	{
	posf->IOExtendingWriteComplete(	err,
									ibOffset,
									cbData,
									pbData,
									pewreq );
	}

void COSFile::IOExtendingWriteComplete(	const ERR						err,
										const QWORD						ibOffset,
										const DWORD						cbData,
										BYTE* const						pbData,
										CExtendingWriteRequest* const	pewreq )
	{
	//  save the current error

	pewreq->m_err = err;

	//  this extending write succeeded

	if ( err >= JET_errSuccess )
		{
		//  change over to the new file size

		m_msFileSize.Partition( CMeteredSection::PFNPARTITIONCOMPLETE( IOChangeFileSizeComplete_ ),
								DWORD_PTR( pewreq ) );
		}

	//  this extending write failed

	else
		{
		//  set the file size back to the original file size

		m_rgcbFileSize[ 1 - pewreq->m_group ] = m_rgcbFileSize[ pewreq->m_group ];

		//  change over to the new file size

		m_msFileSize.Partition( CMeteredSection::PFNPARTITIONCOMPLETE( IOChangeFileSizeComplete_ ),
								DWORD_PTR( pewreq ) );
		}
	}

void COSFile::IOChangeFileSizeComplete_( CExtendingWriteRequest* const pewreq )
	{
	pewreq->m_posf->IOChangeFileSizeComplete( pewreq );
	}

void COSFile::IOChangeFileSizeComplete( CExtendingWriteRequest* const pewreq )
	{
	const QWORD	cbSize		= m_rgcbFileSize[ 1 - pewreq->m_group ];
	const DWORD	cbSizeLow	= DWORD( cbSize );
	DWORD	cbSizeHigh		= DWORD( cbSize >> 32 );

	//	Shrinking file (user requested, or because we enlarged it, but
	//	subsequently encountered an I/O error and now want to shrink
	//	it back), so we need to explicitly set the file size.

	if ( cbSize < m_rgcbFileSize[ pewreq->m_group ] ||
		pewreq->m_err < JET_errSuccess )
		{
		//  set the end of file pointer to the new file size

		m_p_osf->semFilePointer.Acquire();

		if ( (	SetFilePointer(	m_hFile,
								cbSizeLow,
								(long*)&cbSizeHigh,
								FILE_BEGIN ) == INVALID_SET_FILE_POINTER &&
				GetLastError() != NO_ERROR ) ||
			!SetEndOfFile( m_hFile ) )
			{
			pewreq->m_err = (	pewreq->m_err < JET_errSuccess ?
								pewreq->m_err :
								ErrOSFileIGetLastError() );
			}

		m_p_osf->semFilePointer.Release();
		}

	//	When enlarging the file, we wrote into the newly allocated portion
	//	of the file so we should already be set

	else
		{
#ifdef DEBUG
		BY_HANDLE_FILE_INFORMATION	bhfi;

		if ( GetFileInformationByHandle( m_hFile, &bhfi ) )
			{
			Assert( cbSizeLow == bhfi.nFileSizeLow );
			Assert( cbSizeHigh == bhfi.nFileSizeHigh );
			}
#endif
		}

	//	Note that we could implement this by always calling SetEndOfFile(),
	//	but that causes NTFS to give up pre-allocated space it has reserved
	//	for us -- thus creating highly fragmented files.

	//	NT bug requires SetEndOfFile() or FlushFileBuffers() for other apps to
	//	see our updated file size.

	if ( !FlushFileBuffers( m_hFile ) )
		{
		pewreq->m_err = (	pewreq->m_err < JET_errSuccess ?
							pewreq->m_err :
							ErrOSFileIGetLastError() );
		}

	//  we have completed changing the file size so allow others to change it

	m_semChangeFileSize.Release();

	//  grab the list of deferred extending writes.  we must do this before we
	//  complete this extending write because the completion of the write might
	//  delete this file object if the list is empty!

	m_critDefer.Enter();
	CDeferList ilDefer = m_ilDefer;
	m_ilDefer.Empty();
	m_critDefer.Leave();

	//  fire the completion for the extending write

	pewreq->m_pfnIOComplete(	pewreq->m_err,
								this,
								pewreq->m_ibOffset,
								pewreq->m_cbData,
								pewreq->m_pbData,
								pewreq->m_keyIOComplete );

	delete pewreq;

	//  reissue all deferred extending writes
	//
	//  NOTE:  we start with the deferred extending write with the highest
	//  offset to minimize the number of times we extend the file.  this little
	//  trick makes a HUGE difference when appending to the file

	P_OSFILE p_osf = NULL;

	CExtendingWriteRequest* pewreqT;
	CExtendingWriteRequest* pewreqEOF;
	for ( pewreqT = pewreqEOF = ilDefer.PrevMost(); pewreqT; pewreqT = ilDefer.Next( pewreqT ) )
		{
		if ( pewreqT->m_ibOffset > pewreqEOF->m_ibOffset )
			{
			pewreqEOF = pewreqT;
			}
		}

	if ( pewreqEOF )
		{
		ilDefer.Remove( pewreqEOF );

		p_osf = pewreqEOF->m_posf->m_p_osf;

		IOAsync(	pewreqEOF->m_pioreq,
					fTrue,
					m_msFileSize.Enter(),
					pewreqEOF->m_ibOffset,
					pewreqEOF->m_cbData,
					pewreqEOF->m_pbData,
					pewreqEOF->m_pfnIOComplete,
					pewreqEOF->m_keyIOComplete );

		delete pewreqEOF;
		}

	while ( ilDefer.PrevMost() )
		{
		CExtendingWriteRequest* const pewreqDefer = ilDefer.PrevMost();
		ilDefer.Remove( pewreqDefer );

		p_osf = pewreqDefer->m_posf->m_p_osf;

		IOAsync(	pewreqDefer->m_pioreq,
					fTrue,
					m_msFileSize.Enter(),
					pewreqDefer->m_ibOffset,
					pewreqDefer->m_cbData,
					pewreqDefer->m_pbData,
					pewreqDefer->m_pfnIOComplete,
					pewreqDefer->m_keyIOComplete );

		delete pewreqDefer;
		}

	if ( p_osf )
		{
		OSFileIIOThreadStartIssue( p_osf );
		}
	}


COSFileLayout::COSFileLayout()
	:	m_posf( NULL ),
		m_fBeforeFirst( fTrue ),
		m_errFirst( JET_errNoCurrentRecord ),
		m_errCurrent( JET_errNoCurrentRecord )
	{
	}

ERR COSFileLayout::ErrInit(	COSFile* const	posf,
							QWORD const		ibVirtual,
							QWORD const		cbSize )
	{
	ERR err = JET_errSuccess;

	//  reference the file object that created this File Layout iterator and
	//  freeze its layout for the lifetime of this iterator

	m_posf = posf;
	m_posf->ForbidLayoutChanges();

	//  copy our original search criteria

	m_ibVirtualFind	= ibVirtual;
	m_cbSizeFind	= cbSize;

	//  get the size of the referenced file.  remember that this cannot change
	//  while this iterator exists

	QWORD cbFileSize;
	Call( m_posf->ErrSize( &cbFileSize ) );

	//  the queried offset range begins before the end of our file

	if ( m_ibVirtualFind < cbFileSize )
		{
		//  setup the iterator to move first to a single dummy run that
		//  represents the range of the file in the queried offset range

		Call( m_posf->ErrPath( m_szAbsVirtualPath ) );
		m_ibVirtual	= m_ibVirtualFind;
		m_cbSize	= min( cbFileSize - m_ibVirtualFind, m_cbSizeFind );
		Call( m_posf->ErrPath( m_szAbsLogicalPath ) );
		m_ibLogical	= m_ibVirtualFind;

		m_errFirst = JET_errSuccess;
		}

	return JET_errSuccess;

HandleError:
	return err;
	}

COSFileLayout::~COSFileLayout()
	{
	if ( m_posf )
		{
		//  unreference our file object

		m_posf->PermitLayoutChanges();
		m_posf = NULL;
		}
	m_fBeforeFirst	= fTrue;
	m_errFirst		= JET_errNoCurrentRecord;
	m_errCurrent	= JET_errNoCurrentRecord;
	}

ERR COSFileLayout::ErrNext()
	{
	ERR err = JET_errSuccess;

	//  we have yet to move first

	if ( m_fBeforeFirst )
		{
		m_fBeforeFirst = fFalse;

		//  setup the iterator to be on the results of the move first that we
		//  did in ErrInit()

		m_errCurrent = m_errFirst;
		}

	//  we cannot potentially see any more runs

	else
		{
		//  setup the iterator to be after last

		m_errCurrent = JET_errNoCurrentRecord;
		}

	//  check the error state of the iterator's current entry

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}

	return JET_errSuccess;

HandleError:
	m_errCurrent = err;
	return err;
	}

ERR COSFileLayout::ErrVirtualPath( _TCHAR* const szAbsVirtualPath )
	{
	ERR err = JET_errSuccess;

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}

	_tcscpy( szAbsVirtualPath, m_szAbsVirtualPath );
	return JET_errSuccess;

HandleError:
	_tcscpy( szAbsVirtualPath, _T( "" ) );
	return err;
	}

ERR COSFileLayout::ErrVirtualOffsetRange(	QWORD* const	pibVirtual,
											QWORD* const	pcbSize )
	{
	ERR err = JET_errSuccess;

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}

	*pibVirtual	= m_ibVirtual;
	*pcbSize	= m_cbSize;
	return JET_errSuccess;

HandleError:
	*pibVirtual	= 0;
	*pcbSize	= 0;
	return err;
	}

ERR COSFileLayout::ErrLogicalPath( _TCHAR* const szAbsLogicalPath )
	{
	ERR err = JET_errSuccess;

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}

	_tcscpy( szAbsLogicalPath, m_szAbsLogicalPath );
	return JET_errSuccess;

HandleError:
	_tcscpy( szAbsLogicalPath, _T( "" ) );
	return err;
	}

ERR COSFileLayout::ErrLogicalOffsetRange(	QWORD* const	pibLogical,
											QWORD* const	pcbSize )
	{
	ERR err = JET_errSuccess;

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}

	*pibLogical	= m_ibLogical;
	*pcbSize	= m_cbSize;
	return JET_errSuccess;

HandleError:
	*pibLogical	= 0;
	*pcbSize	= 0;
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\osstd.cxx ===
#include "osstd.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\osslv.cxx ===
#include "osstd.hxx"


long cOSSLVFileTableInsert;
PM_CEF_PROC LOSSLVFileTableInsertsCEFLPv;
long LOSSLVFileTableInsertsCEFLPv( long iInstance, void* pvBuf )
	{	
	if ( pvBuf )
		{		
		*( (unsigned long*) pvBuf ) = cOSSLVFileTableInsert;
		}
	return 0;
	}

long cOSSLVFileTableDelete;
PM_CEF_PROC LOSSLVFileTableDeletesCEFLPv;
long LOSSLVFileTableDeletesCEFLPv( long iInstance, void* pvBuf )
	{	
	if ( pvBuf )
		{		
		*( (unsigned long*) pvBuf ) = cOSSLVFileTableDelete;
		}
	return 0;
	}

long cOSSLVFileTableClean;
PM_CEF_PROC LOSSLVFileTableCleansCEFLPv;
long LOSSLVFileTableCleansCEFLPv( long iInstance, void* pvBuf )
	{	
	if ( pvBuf )
		{		
		*( (unsigned long*) pvBuf ) = cOSSLVFileTableClean;
		}
	return 0;
	}

PM_CEF_PROC LOSSLVFileTableEntriesCEFLPv;
long LOSSLVFileTableEntriesCEFLPv( long iInstance, void* pvBuf )
	{	
	if ( pvBuf )
		{		
		*( (unsigned long*) pvBuf ) = cOSSLVFileTableInsert - cOSSLVFileTableDelete;
		}
	return 0;
	}


#ifdef DISABLE_SLV

void OSSLVPostterm()	{}
BOOL FOSSLVPreinit()	{ return fTrue; }
void OSSLVTerm()		{}
ERR ErrOSSLVInit()		{ return JET_errSuccess; }

#else


#include "std.hxx"
#include "_osslv.hxx"


TICK tickOSSLVInstanceID;


long 	cbOSSLVReserve;

TICK 	cmsecOSSLVSpaceFreeDelay;
TICK 	cmsecOSSLVFileOpenDelay;
TICK 	cmsecOSSLVTTL;
TICK 	cmsecOSSLVTTLSafety;
TICK 	cmsecOSSLVTTLInfinite;

QWORD	cbBackingFileSizeMax;


PFNRtlInitUnicodeString*		pfnRtlInitUnicodeString;
PFNNtCreateFile*				pfnNtCreateFile;

BOOL	fUseRelativeOpen;
HMODULE	hmodNtdll;


PFNIfsGetFirstCursor*			pfnIfsGetFirstCursor;
PFNIfsConsumeCursor*			pfnIfsConsumeCursor;
PFNIfsGetNextCursor*			pfnIfsGetNextCursor;
PFNIfsFinishCursor*				pfnIfsFinishCursor;
PFNIfsCreateNewBuffer*			pfnIfsCreateNewBuffer;
PFNIfsCopyBufferToReference*	pfnIfsCopyBufferToReference;
PFNIfsCopyReferenceToBuffer*	pfnIfsCopyReferenceToBuffer;
PFNIfsCloseBuffer*				pfnIfsCloseBuffer;
PFNIfsInitializeProvider*		pfnIfsInitializeProvider;
PFNIfsCloseProvider*			pfnIfsCloseProvider;
PFNIfsCreateFileProv*			pfnIfsCreateFile;
PFNIfsInitializeRoot*			pfnIfsInitializeRoot;
PFNIfsSpaceGrantRoot*			pfnIfsSpaceGrantRoot;
PFNIfsSetEndOfFileRoot*			pfnIfsSetEndOfFileRoot;
PFNIfsSpaceRequestRoot*			pfnIfsSpaceRequestRoot;
PFNIfsQueryEaFile*				pfnIfsQueryEaFile;
PFNIfsTerminateRoot*			pfnIfsTerminateRoot;
PFNIfsSetRootMap*				pfnIfsSetRootMap;
PFNIfsResetRootMap*				pfnIfsResetRootMap;
PFNIfsFlushHandle*				pfnIfsFlushHandle;

HMODULE	hmodIfsProxy;
ERR		errSLVProvider;


#pragma warning( disable: 4307 )

INLINE ULONG_PTR IbOSSLVQwordAlign( const ULONG_PTR ib )
	{
	return (ULONG_PTR)( ( ib + sizeof( QWORD ) - 1 ) & ( ULONG_PTR( ~( LONG_PTR( 0 ) ) ) * sizeof( QWORD ) ) );
	}

#pragma warning( default : 4307 )

INLINE void* PvOSSLVQwordAlign( const void* const pv )
	{
	return (void*) IbOSSLVQwordAlign( ULONG_PTR( pv ) );
	}

#pragma warning( disable: 4307 )

INLINE ULONG_PTR IbOSSLVLongAlign( const ULONG_PTR ib )
	{
	return (ULONG_PTR)( ( ib + sizeof( DWORD ) - 1 ) & ( ULONG_PTR( ~( LONG_PTR( 0 ) ) ) * sizeof( DWORD ) ) );
	}

#pragma warning( default : 4307 )

INLINE void* PvOSSLVLongAlign( const void* const pv )
	{
	return (void*) IbOSSLVLongAlign( ULONG_PTR( pv ) );
	}


//  converts the last Win32 error code into an OSSLVRoot error code for return
//  via the OSSLVRoot API

ERR ErrOSSLVRootIGetLastError( const DWORD error = GetLastError() )
	{
	_TCHAR			szT[64];
	const _TCHAR*	rgszT[1]	= { szT };
	
	switch ( error )
		{
		case NO_ERROR:
		case ERROR_IO_PENDING:
		case EXSTATUS_ROOT_NEEDS_SPACE:
			return JET_errSuccess;

		case ERROR_INVALID_USER_BUFFER:
		case ERROR_NOT_ENOUGH_MEMORY:
		case ERROR_WORKING_SET_QUOTA:
			return ErrERRCheck( JET_errTooManyIO );

		case ERROR_DISK_FULL:
			return ErrERRCheck( JET_errDiskFull );

		case ERROR_HANDLE_EOF:
		case ERROR_VC_DISCONNECTED:
		case ERROR_IO_DEVICE:
			return ErrERRCheck( JET_errDiskIO );

		case ERROR_NO_MORE_FILES:
		case ERROR_FILE_NOT_FOUND:
			return ErrERRCheck( JET_errFileNotFound );
		
		case ERROR_PATH_NOT_FOUND:
			return ErrERRCheck( JET_errInvalidPath );

		case ERROR_ACCESS_DENIED:
		case ERROR_SHARING_VIOLATION:
		case ERROR_LOCK_VIOLATION:
		case ERROR_WRITE_PROTECT:
			return ErrERRCheck( JET_errFileAccessDenied );

		case ERROR_TOO_MANY_OPEN_FILES:
			return ErrERRCheck( JET_errOutOfFileHandles );
			break;

		case ERROR_NO_SYSTEM_RESOURCES:
			return ErrERRCheck( JET_errOutOfMemory );

		//  unexpected error code
		
		default:
			_stprintf( szT, _T( "Unexpected Win32 error:  %dL" ), error );
			AssertSz( fFalse, szT );
			UtilReportEvent( eventError, PERFORMANCE_CATEGORY, PLAIN_TEXT_ID, 1, rgszT );
			return ErrERRCheck( JET_errDiskIO );
		}
	}


//  converts the last Win32 error code into an OSSLVFile error code for return
//  via the OSSLVFile API

ERR ErrOSSLVFileIGetLastError( const DWORD error = GetLastError() )
	{
	_TCHAR			szT[64];
	const _TCHAR*	rgszT[1]	= { szT };
	
	switch ( error )
		{
		case NO_ERROR:
		case ERROR_IO_PENDING:
		case EXSTATUS_ROOT_NEEDS_SPACE:
			return JET_errSuccess;

		case ERROR_INVALID_USER_BUFFER:
		case ERROR_NOT_ENOUGH_MEMORY:
		case ERROR_WORKING_SET_QUOTA:
			return ErrERRCheck( JET_errTooManyIO );

		case ERROR_DISK_FULL:
			return ErrERRCheck( JET_errSLVStreamingFileFull );

		case ERROR_HANDLE_EOF:
		case ERROR_VC_DISCONNECTED:
		case ERROR_IO_DEVICE:
			return ErrERRCheck( JET_errSLVFileIO );

		case ERROR_NO_MORE_FILES:
		case ERROR_FILE_NOT_FOUND:
			return ErrERRCheck( JET_errSLVFileNotFound );
		
		case ERROR_PATH_NOT_FOUND:
			return ErrERRCheck( JET_errSLVFileInvalidPath );

		case ERROR_ACCESS_DENIED:
		case ERROR_SHARING_VIOLATION:
		case ERROR_LOCK_VIOLATION:
		case ERROR_WRITE_PROTECT:
			return ErrERRCheck( JET_errSLVFileAccessDenied );

		case ERROR_TOO_MANY_OPEN_FILES:
			return ErrERRCheck( JET_errOutOfFileHandles );
			break;

		case ERROR_NO_SYSTEM_RESOURCES:
			return ErrERRCheck( JET_errOutOfMemory );

		case ERROR_INVALID_EA_NAME:
		case ERROR_EA_LIST_INCONSISTENT:
		case ERROR_EAS_DIDNT_FIT:
		case ERROR_EA_FILE_CORRUPT:
		case ERROR_EA_TABLE_FULL:
		case ERROR_INVALID_EA_HANDLE:
		case ERROR_EAS_NOT_SUPPORTED:
		case ERROR_EA_ACCESS_DENIED:
			return ErrERRCheck( JET_errSLVEAListCorrupt );

		case ERROR_MORE_DATA:
			return ErrERRCheck( JET_errSLVBufferTooSmall );

		//  unexpected error code
		
		default:
			_stprintf( szT, _T( "Unexpected Win32 error:  %dL" ), error );
			AssertSz( fFalse, szT );
			UtilReportEvent( eventError, PERFORMANCE_CATEGORY, PLAIN_TEXT_ID, 1, rgszT );
			return ErrERRCheck( JET_errSLVFileUnknown );
		}
	}


//  converts the last NT API status code into an OSSLVRoot error code for return
//  via the OSSLVRoot API

ERR ErrOSSLVRootINTStatus( NTSTATUS ntstatus )
	{
	_TCHAR			szT[64];
	const _TCHAR*	rgszT[1]	= { szT };
		
	switch ( ntstatus )
		{
		case STATUS_SUCCESS:
		case STATUS_PENDING:
		case EXSTATUS_ROOT_NEEDS_SPACE:
			return JET_errSuccess;

		case STATUS_INVALID_USER_BUFFER:
		case STATUS_NO_MEMORY:
		case STATUS_WORKING_SET_QUOTA:
			return ErrERRCheck( JET_errTooManyIO );

		case STATUS_DISK_FULL:
			return ErrERRCheck( JET_errDiskFull );

		case STATUS_END_OF_FILE:
		case STATUS_VIRTUAL_CIRCUIT_CLOSED:
		case STATUS_IO_DEVICE_ERROR:
			return ErrERRCheck( JET_errDiskIO );

		case STATUS_NO_MORE_FILES:
		case STATUS_NO_SUCH_FILE:
		case EXSTATUS_NO_SUCH_FILE:
			return ErrERRCheck( JET_errFileNotFound );
		
		case STATUS_ACCESS_DENIED:
		case STATUS_SHARING_VIOLATION:
		case STATUS_MEDIA_WRITE_PROTECTED:
			return ErrERRCheck( JET_errFileAccessDenied );

		case STATUS_TOO_MANY_OPENED_FILES:
			return ErrERRCheck( JET_errOutOfFileHandles );
			break;

		case STATUS_INSUFFICIENT_RESOURCES:
			return ErrERRCheck( JET_errOutOfMemory );

		case EXSTATUS_ROOT_ABANDONED:
			return ErrERRCheck( JET_errSLVRootStillOpen );

		case STATUS_OBJECT_PATH_NOT_FOUND:
			return ErrERRCheck( JET_errSLVProviderNotLoaded );

		case STATUS_OBJECT_NAME_INVALID:
		case STATUS_OBJECT_PATH_INVALID:
		case STATUS_OBJECT_PATH_SYNTAX_BAD:
			return ErrERRCheck( JET_errSLVRootPathInvalid );

		//  unexpected error code
		
		default:
			_stprintf( szT, _T( "Unexpected NT API error:  0x%08X" ), ntstatus );
			AssertSz( fFalse, szT );
			UtilReportEvent( eventError, PERFORMANCE_CATEGORY, PLAIN_TEXT_ID, 1, rgszT );
			return ErrERRCheck( JET_errDiskIO );
		}
	}

//  converts the last NT API status code into an OSSLVFile error code for return
//  via the OSSLVFile API

ERR ErrOSSLVFileINTStatus( NTSTATUS ntstatus )
	{
	_TCHAR			szT[64];
	const _TCHAR*	rgszT[1]	= { szT };
		
	switch ( ntstatus )
		{
		case STATUS_SUCCESS:
		case STATUS_PENDING:
		case EXSTATUS_ROOT_NEEDS_SPACE:
			return JET_errSuccess;

		case STATUS_INVALID_USER_BUFFER:
		case STATUS_NO_MEMORY:
		case STATUS_WORKING_SET_QUOTA:
			return ErrERRCheck( JET_errTooManyIO );

		case STATUS_DISK_FULL:
			return ErrERRCheck( JET_errSLVStreamingFileFull );

		case STATUS_END_OF_FILE:
		case STATUS_VIRTUAL_CIRCUIT_CLOSED:
		case STATUS_IO_DEVICE_ERROR:
			return ErrERRCheck( JET_errSLVFileIO );

		case STATUS_NO_MORE_FILES:
		case STATUS_NO_SUCH_FILE:
		case EXSTATUS_NO_SUCH_FILE:
		case STATUS_OBJECT_NAME_NOT_FOUND:
			return ErrERRCheck( JET_errSLVFileNotFound );
		
		case STATUS_ACCESS_DENIED:
		case STATUS_SHARING_VIOLATION:
		case STATUS_MEDIA_WRITE_PROTECTED:
			return ErrERRCheck( JET_errSLVFileAccessDenied );

		case STATUS_TOO_MANY_OPENED_FILES:
			return ErrERRCheck( JET_errOutOfFileHandles );
			break;

		case STATUS_INSUFFICIENT_RESOURCES:
			return ErrERRCheck( JET_errOutOfMemory );

		case STATUS_OBJECT_PATH_NOT_FOUND:
			return ErrERRCheck( JET_errSLVProviderNotLoaded );

		case STATUS_OBJECT_NAME_INVALID:
		case STATUS_OBJECT_PATH_INVALID:
		case STATUS_OBJECT_PATH_SYNTAX_BAD:
			return ErrERRCheck( JET_errSLVRootPathInvalid );

		case STATUS_INVALID_EA_NAME:
		case STATUS_EA_LIST_INCONSISTENT:
		case STATUS_INVALID_EA_FLAG:
		case STATUS_EAS_NOT_SUPPORTED:
		case STATUS_EA_TOO_LARGE:
		case STATUS_NONEXISTENT_EA_ENTRY:
		case STATUS_NO_EAS_ON_FILE:
		case STATUS_EA_CORRUPT_ERROR:
		case EXSTATUS_SPACE_UNCOMMITTED:
		case EXSTATUS_INVALID_CHECKSUM:
		case EXSTATUS_OPEN_DEADLINE_EXPIRED:
			return ErrERRCheck( JET_errSLVEAListCorrupt );

		case EXSTATUS_FILE_DOUBLE_COMMIT:
			return ErrERRCheck( JET_errSLVEAListCorrupt );
			
		case EXSTATUS_INSTANCE_ID_MISMATCH:
			return ErrERRCheck( JET_errSLVEAListCorrupt );

		case EXSTATUS_STALE_HANDLE:
			return ErrERRCheck( JET_errSLVFileStale );
		
		//  unexpected error code
		
		default:
			_stprintf( szT, _T( "Unexpected NT API error:  0x%08X" ), ntstatus );
			AssertSz( fFalse, szT );
			UtilReportEvent( eventError, PERFORMANCE_CATEGORY, PLAIN_TEXT_ID, 1, rgszT );
			return ErrERRCheck( JET_errSLVFileUnknown );
		}
	}


//  SLV File Table

inline CSLVFileTable::CEntryTable::NativeCounter HashFileid( const CSLVInfo::FILEID& fileid ) 
	{
	return CSLVFileTable::CEntryTable::NativeCounter( fileid / SLVPAGE_SIZE );
	}

inline CSLVFileTable::CEntryTable::NativeCounter CSLVFileTable::CEntryTable::CKeyEntry::Hash( const CSLVInfo::FILEID& fileid )
	{
	return HashFileid( fileid );
	}

inline CSLVFileTable::CEntryTable::NativeCounter CSLVFileTable::CEntryTable::CKeyEntry::Hash() const
	{
	return HashFileid( m_entry.m_fileid );
	}

inline BOOL CSLVFileTable::CEntryTable::CKeyEntry::FEntryMatchesKey( const CSLVInfo::FILEID& fileid ) const
	{
	return fileid == m_entry.m_fileid;
	}

inline void CSLVFileTable::CEntryTable::CKeyEntry::SetEntry( const CSLVFileTable::CEntry& entry )
	{
	m_entry = entry;
	}

inline void CSLVFileTable::CEntryTable::CKeyEntry::GetEntry( CSLVFileTable::CEntry* const pentry ) const
	{
	*pentry = m_entry;
	}

ERR CSLVFileTable::ErrInit( P_SLVROOT pslvroot )
	{
	ERR err = JET_errSuccess;

	//  save the _SLVROOT for use by cleanup

	m_pslvroot = pslvroot;

	//  initialize cleanup variables

	m_cDeferredCleanup	= 0;
	m_semCleanup.Release();
	m_fileidNextCleanup	= 0;

	//  reset our stats

	m_cbReserved	= 0;
	m_cbDeleted		= 0;
	m_centryInsert	= 0;
	m_centryDelete	= 0;
	m_centryClean	= 0;

	//  initialize the entry table

	if ( m_et.ErrInit( 2.0, 1.0 ) != CEntryTable::errSuccess )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  init successful

	m_fInit = fTrue;

	return JET_errSuccess;

HandleError:
	Term();
	return err;
	}
	
void CSLVFileTable::Term()
	{
	//  free all memory pointed to by entries in the entry table
	
	if ( m_fInit )
		{
		CEntryTable::CLock	lockET;
		CEntryTable::ERR	errET;

		m_et.BeginHashScan( &lockET );

		while ( ( errET = m_et.ErrMoveNext( &lockET ) ) == CEntryTable::errSuccess )
			{
			CEntry entry;
			errET = m_et.ErrRetrieveEntry( &lockET, &entry );

			if ( entry.m_pextentry )
				{
				while ( !entry.m_pextentry->m_ilRunReserved.FEmpty() )
					{
					CExtendedEntry::CRun* prun = entry.m_pextentry->m_ilRunReserved.PrevMost();
					entry.m_pextentry->m_ilRunReserved.Remove( prun );
					delete prun;
					}
				while ( !entry.m_pextentry->m_ilRunDeleted.FEmpty() )
					{
					CExtendedEntry::CRun* prun = entry.m_pextentry->m_ilRunDeleted.PrevMost();
					entry.m_pextentry->m_ilRunDeleted.Remove( prun );
					delete prun;
					}
				delete entry.m_pextentry->m_wszFileName;
				delete entry.m_pextentry;
				}
				
			AtomicIncrement( (long*)&cOSSLVFileTableDelete );
			AtomicIncrement( (long*)&m_centryDelete );
			}
		Assert( errET == CEntryTable::errNoCurrentEntry );

		m_et.EndHashScan( &lockET );
		}
	
	//  terminate the entry table

	m_et.Term();

	//  term successful

	m_fInit = fFalse;
	}
	
ERR CSLVFileTable::ErrCreate( CSLVInfo* const pslvinfo )
	{
	ERR					err			= JET_errSuccess;
	CEntry				entry;
	CExtendedEntry*		pextentry	= NULL;
	CEntryTable::CLock	lockET;
	CEntryTable::ERR	errET;
	BOOL				fLocked		= fFalse;
	BOOL				fInserted	= fFalse;
	
	//  create a new entry and extended entry for this SLV File

	if ( !( pextentry = new CExtendedEntry ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  initialize the entry with the SLV File's FILEID and an extended entry
	
	Call( pslvinfo->ErrGetFileID( &entry.m_fileid ) );
	entry.m_pextentry = pextentry;

	//  store the SLV File's current file name in the extended entry

	Call( pslvinfo->ErrGetFileNameLength( &pextentry->m_cwchFileName ) );
	if ( !( pextentry->m_wszFileName = new wchar_t[ pextentry->m_cwchFileName + 1 ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	Call( pslvinfo->ErrGetFileName( pextentry->m_wszFileName ) );

	//  store all the reserved space owned by this SLV File in the extended entry

	CallS( pslvinfo->ErrMoveBeforeFirst() );
	while ( ( err = pslvinfo->ErrMoveNext() ) >= JET_errSuccess )
		{
		CSLVInfo::RUN run;
		Call( pslvinfo->ErrGetCurrentRun( &run ) );

		CExtendedEntry::CRun* prun;
		if ( !( prun = new CExtendedEntry::CRun ) )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
			
		prun->m_ibLogical	= run.ibLogical;
		prun->m_cbSize		= run.cbSize;
		
		pextentry->m_ilRunReserved.InsertAsNextMost( prun );
		AtomicAdd( &m_cbReserved, prun->m_cbSize );
		}
	if ( err == JET_errNoCurrentRecord )
		{
		err = JET_errSuccess;
		}
	Call( err );

	//  store the allocation size for this SLV File in the extended entry

	Call( pslvinfo->ErrGetFileAlloc( &pextentry->m_cbAlloc ) );
	Call( pslvinfo->ErrGetFileAlloc( &pextentry->m_cbSpace ) );

	//  insert the new entry in the table
	
	m_et.WriteLockKey( entry.m_fileid, &lockET );
	fLocked = fTrue;
	if ( ( errET = m_et.ErrInsertEntry( &lockET, entry ) ) != CEntryTable::errSuccess )
		{
		Assert(	errET == CEntryTable::errOutOfMemory ||
				errET == CEntryTable::errKeyDuplicate );

		if ( errET == CEntryTable::errOutOfMemory )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		else
			{
			Call( ErrERRCheck( JET_errSLVSpaceCorrupted ) );
			}
		}
	fInserted = fTrue;
	AtomicIncrement( (long*)&cOSSLVFileTableInsert );
	AtomicIncrement( (long*)&m_centryInsert );
	m_et.WriteUnlockKey( &lockET );
	fLocked = fFalse;

	//  if we inserted an entry into the table then perform some cleanup

	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		fInserted = fFalse;
		}

	return JET_errSuccess;

HandleError:
	if ( fLocked )
		{
		m_et.WriteUnlockKey( &lockET );
		}
	if ( pextentry )
		{
		while ( !pextentry->m_ilRunReserved.FEmpty() )
			{
			CExtendedEntry::CRun* prun = pextentry->m_ilRunReserved.PrevMost();
			pextentry->m_ilRunReserved.Remove( prun );
			AtomicAdd( &m_cbReserved, -prun->m_cbSize );
			delete prun;
			}
		delete pextentry->m_wszFileName;
		delete pextentry;
		}
	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		}
	return err;
	}

ERR CSLVFileTable::ErrOpen(	CSLVInfo* const	pslvinfo,
							const BOOL		fSetExpiration,
							size_t* const	pcwchFileName,
							wchar_t* const	wszFileName,
							TICK* const		ptickExpiration )
	{
	ERR		err			= JET_errSuccess;
	TICK	cmsecTTL	= cmsecOSSLVTTL;

	//  retry the open with ever increasing open deadlines until we succeed in
	//  opening the file with enough time to spare.  this is to allow the
	//  common case to be fast while handling the pathological case where the
	//  server load is so high that we occasionally get huge delays when
	//  performing amortized cleanup of the table
	
	do
		{
		Call( _ErrOpen(	pslvinfo,
						fSetExpiration,
						cmsecTTL,
						pcwchFileName,
						wszFileName,
						ptickExpiration ) );

		cmsecTTL = min( cmsecTTL * 2, cmsecOSSLVTTLInfinite );
		}
	while ( TickCmp( TickOSTimeCurrent() + cmsecOSSLVTTL / 2, *ptickExpiration ) > 0 );

HandleError:
	return err;
	}
	
ERR CSLVFileTable::_ErrOpen(	CSLVInfo* const	pslvinfo,
								const BOOL		fSetExpiration,
								const TICK		cmsecTTL,
								size_t* const	pcwchFileName,
								wchar_t* const	wszFileName,
								TICK* const		ptickExpiration )
	{
	ERR					err			= JET_errSuccess;
	CEntry				entry;
	CEntryTable::CLock	lockET;
	CEntryTable::ERR	errET;
	BOOL				fLocked		= fFalse;
	BOOL				fInserted	= fFalse;
	
	//  fetch the entry for this SLV File from the table if it exists.  if
	//  it doesn't exist, the entry will start out initialized to have the
	//  correct FILEID and no other attributes

	Call( pslvinfo->ErrGetFileID( &entry.m_fileid ) );
	entry.m_tickExpiration	= TickOSTimeCurrent() + cmsecOSSLVTTLInfinite;  //  expires far in the future
	entry.m_pextentry		= NULL;

	m_et.WriteLockKey( entry.m_fileid, &lockET );
	fLocked = fTrue;
	(void)m_et.ErrRetrieveEntry( &lockET, &entry );

	//  this SLV File's contents was moved

	if ( entry.m_pextentry && entry.m_pextentry->m_fDependent )
		{
		//  remember the source contents pointer from this entry

		const CSLVInfo::FILEID	fileidSource		= entry.m_pextentry->m_fileidSource;
		const QWORD				idContentsSource	= entry.m_pextentry->m_idContentsSource;

		//  fetch the source's entry

		m_et.WriteUnlockKey( &lockET );
		fLocked = fFalse;

		m_et.WriteLockKey( fileidSource, &lockET );
		fLocked = fTrue;
		errET = m_et.ErrRetrieveEntry( &lockET, &entry );
		Assert(	errET == CEntryTable::errSuccess ||
				errET == CEntryTable::errEntryNotFound );

		//  the source's entry doesn't exist or doesn't have a matching idContents

		if (	errET != CEntryTable::errSuccess ||
				!entry.m_pextentry ||
				entry.m_pextentry->m_idContents != idContentsSource )
			{
			//  the source has been closed so we can safely use the entry for
			//  this SLV File.  re-fetch the entry for this SLV File as before
			
			m_et.WriteUnlockKey( &lockET );
			fLocked = fFalse;

			Call( pslvinfo->ErrGetFileID( &entry.m_fileid ) );
			entry.m_tickExpiration	= TickOSTimeCurrent() + cmsecOSSLVTTLInfinite;  //  expires far in the future
			entry.m_pextentry		= NULL;

			m_et.WriteLockKey( entry.m_fileid, &lockET );
			fLocked = fTrue;
			(void)m_et.ErrRetrieveEntry( &lockET, &entry );
			}
		}

	//  we were asked to set a new expiration time

	if ( fSetExpiration )
		{
		//  set the new expiration time for the entry if requested

		entry.m_tickExpiration	= TickOSTimeCurrent() + cmsecTTL;

		//  try to update the entry in the entry table

		if ( ( errET = m_et.ErrReplaceEntry( &lockET, entry ) ) != CEntryTable::errSuccess )
			{
			Assert( errET == CEntryTable::errNoCurrentEntry );

			//  the entry does not yet exist, so try to insert it in the entry table

			if ( ( errET = m_et.ErrInsertEntry( &lockET, entry ) ) != CEntryTable::errSuccess )
				{
				Assert( errET == CEntryTable::errOutOfMemory );
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			fInserted = fTrue;
			AtomicIncrement( (long*)&cOSSLVFileTableInsert );
			AtomicIncrement( (long*)&m_centryInsert );
			}
		}

	//  we were asked to not set a new expiration time

	else
		{
		//  set a time far in the future

		entry.m_tickExpiration	= TickOSTimeCurrent() + cmsecOSSLVTTLInfinite;
		}

	//  copy the requested information into the user's buffers

	if ( entry.m_pextentry )
		{
		if ( *pcwchFileName < entry.m_pextentry->m_cwchFileName + 1 )
			{
			Call( ErrERRCheck( JET_errSLVBufferTooSmall ) );
			}
		*pcwchFileName		= entry.m_pextentry->m_cwchFileName;
		wcscpy( wszFileName, entry.m_pextentry->m_wszFileName );
		*ptickExpiration	= entry.m_tickExpiration;
		}
	else
		{
		size_t cwchFileName = *pcwchFileName;
		Call( pslvinfo->ErrGetFileNameLength( pcwchFileName ) );
		if ( cwchFileName < *pcwchFileName )
			{
			Call( ErrERRCheck( JET_errSLVBufferTooSmall ) );
			}
		Call( pslvinfo->ErrGetFileName( wszFileName ) );
		*ptickExpiration = entry.m_tickExpiration;
		}

	m_et.WriteUnlockKey( &lockET );
	fLocked = fFalse;

	//  if we inserted an entry in the table then perform some cleanup

	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		fInserted = fFalse;
		}

	return JET_errSuccess;

HandleError:
	if ( fLocked )
		{
		m_et.WriteUnlockKey( &lockET );
		}
	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		}
	return err;
	}
	
ERR CSLVFileTable::ErrCopy(	CSLVInfo* const	pslvinfoSrc,
							CSLVInfo* const	pslvinfoDest,
							const QWORD		idContents )
	{
	//  we don't need to do anything here right now
	
	return JET_errSuccess;
	}
	
ERR CSLVFileTable::ErrMove(	CSLVInfo* const	pslvinfoSrc,
							CSLVInfo* const	pslvinfoDest,
							const QWORD		idContents )
	{
	ERR					err					= JET_errSuccess;
	CEntry				entry;
	CExtendedEntry*		pextentrySrc		= NULL;
	CExtendedEntry*		pextentryDest		= NULL;
	CEntryTable::CLock	lockET;
	CEntryTable::ERR	errET;
	BOOL				fLocked				= fFalse;
	BOOL				fInserted			= fFalse;
	BOOL				fSyncFree			= fFalse;
	
	//  fetch the entry for the source SLV File from the table if it exists.
	//  if it doesn't exist, the entry will start out initialized to have the
	//  correct FILEID, file name, and no other attributes

	if ( !( pextentrySrc = new CExtendedEntry ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	Call( pslvinfoSrc->ErrGetFileID( &entry.m_fileid ) );
	entry.m_pextentry = pextentrySrc;

	Call( pslvinfoSrc->ErrGetFileNameLength( &pextentrySrc->m_cwchFileName ) );
	if ( !( pextentrySrc->m_wszFileName = new wchar_t[ pextentrySrc->m_cwchFileName + 1 ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	Call( pslvinfoSrc->ErrGetFileName( pextentrySrc->m_wszFileName ) );

	m_et.WriteLockKey( entry.m_fileid, &lockET );
	fLocked = fTrue;
	(void)m_et.ErrRetrieveEntry( &lockET, &entry );

	if ( !entry.m_pextentry )
		{
		entry.m_pextentry = pextentrySrc;
		}

	//  this SLV File's contents was moved

	if ( entry.m_pextentry && entry.m_pextentry->m_fDependent )
		{
		//  remember the source contents pointer from this entry

		const CSLVInfo::FILEID	fileidSource		= entry.m_pextentry->m_fileidSource;
		const QWORD				idContentsSource	= entry.m_pextentry->m_idContentsSource;

		//  fetch the source's entry

		m_et.WriteUnlockKey( &lockET );
		fLocked = fFalse;

		m_et.WriteLockKey( fileidSource, &lockET );
		fLocked = fTrue;
		errET = m_et.ErrRetrieveEntry( &lockET, &entry );
		Assert(	errET == CEntryTable::errSuccess ||
				errET == CEntryTable::errEntryNotFound );

		//  the source's entry doesn't exist or doesn't have a matching idContents

		if (	errET != CEntryTable::errSuccess ||
				!entry.m_pextentry ||
				entry.m_pextentry->m_idContents != idContentsSource )
			{
			//  the source has been closed so we can safely use the entry for
			//  this SLV File.  re-fetch the entry for this SLV File as before
			
			m_et.WriteUnlockKey( &lockET );
			fLocked = fFalse;

			Call( pslvinfoSrc->ErrGetFileID( &entry.m_fileid ) );
			entry.m_pextentry = pextentrySrc;

			Call( pslvinfoSrc->ErrGetFileNameLength( &pextentrySrc->m_cwchFileName ) );
			if ( !( pextentrySrc->m_wszFileName = new wchar_t[ pextentrySrc->m_cwchFileName + 1 ] ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			Call( pslvinfoSrc->ErrGetFileName( pextentrySrc->m_wszFileName ) );

			m_et.WriteLockKey( entry.m_fileid, &lockET );
			fLocked = fTrue;
			(void)m_et.ErrRetrieveEntry( &lockET, &entry );

			if ( !entry.m_pextentry )
				{
				entry.m_pextentry = pextentrySrc;
				}
			}
		}
		
	//  flag the source SLV File with the specified contents ID so that the
	//  contents of this file can be looked up in the SLV File Table.  only flag
	//  an SLV File that doesn't already have a contents ID so that if the same
	//  contents are moved more than once, we don't break any entry's contents
	//  source pointer
	//
	//  NOTE:  we will use the extended entry pointer in the entry which is not
	//  necessarily the extended entry we allocated

	if ( entry.m_pextentry->m_idContents == CSLVInfo::fileidNil )
		{
		entry.m_pextentry->m_idContents = idContents;
		}

	//  build an extended entry for the destination SLV File and link it into
	//  the source SLV File as a dependent.  this will enable the source SLV
	//  File to notify the destination SLV File when it has been removed
	//
	//  NOTE:  we will use the contents ID in the extended entry which is not
	//  necessarily the contents ID specified for this move (see above)

	if ( !( pextentryDest = new CExtendedEntry ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	Call( pslvinfoDest->ErrGetFileNameLength( &pextentryDest->m_cwchFileName ) );
	if ( !( pextentryDest->m_wszFileName = new wchar_t[ pextentryDest->m_cwchFileName + 1 ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	Call( pslvinfoDest->ErrGetFileName( pextentryDest->m_wszFileName ) );

	AtomicExchange( (long*)&pextentryDest->m_fDependent, long( fTrue ) );
	entry.m_pextentry->m_ilDependents.InsertAsNextMost( pextentryDest );

	pextentryDest->m_fileidSource		= entry.m_fileid;
	pextentryDest->m_idContentsSource	= entry.m_pextentry->m_idContents;

	//  try to update the entry in the entry table

	if ( ( errET = m_et.ErrReplaceEntry( &lockET, entry ) ) != CEntryTable::errSuccess )
		{
		Assert( errET == CEntryTable::errNoCurrentEntry );

		//  the entry does not yet exist, so try to insert it in the entry table

		if ( ( errET = m_et.ErrInsertEntry( &lockET, entry ) ) != CEntryTable::errSuccess )
			{
			Assert( errET == CEntryTable::errOutOfMemory );
			entry.m_pextentry->m_ilDependents.Remove( pextentryDest );
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		fInserted = fTrue;
		AtomicIncrement( (long*)&cOSSLVFileTableInsert );
		AtomicIncrement( (long*)&m_centryInsert );
		}

	m_et.WriteUnlockKey( &lockET );
	fLocked = fFalse;
	fSyncFree = fTrue;

	//  if we didn't use the allocated extended entry then free it

	if ( pextentrySrc != entry.m_pextentry )
		{
		Assert( pextentrySrc->m_ilDependents.FEmpty() );
		delete pextentrySrc->m_wszFileName;
		delete pextentrySrc;
		}
	pextentrySrc = NULL;

	//  if we inserted an entry in the table then perform some cleanup

	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		fInserted = fFalse;
		}

	//  create a new entry and extended entry for the dest SLV File.  we should
	//  never see an existing entry because the space would have to be deleted
	//  and cleaned up before an attempt can be made to move a file here.  this
	//  will happen even if the same move is reattempted after a failure.
	//  initialize the entry with the extended entry we created above
	
	Call( pslvinfoDest->ErrGetFileID( &entry.m_fileid ) );
	entry.m_pextentry = pextentryDest;

	//  insert the new entry in the table
	
	m_et.WriteLockKey( entry.m_fileid, &lockET );
	fLocked = fTrue;
	if ( ( errET = m_et.ErrInsertEntry( &lockET, entry ) ) != CEntryTable::errSuccess )
		{
		Assert(	errET == CEntryTable::errOutOfMemory ||
				errET == CEntryTable::errKeyDuplicate );

		if ( errET == CEntryTable::errOutOfMemory )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		else
			{
			Call( ErrERRCheck( JET_errSLVSpaceCorrupted ) );
			}
		}
	fInserted = fTrue;
	AtomicIncrement( (long*)&cOSSLVFileTableInsert );
	AtomicIncrement( (long*)&m_centryInsert );
	m_et.WriteUnlockKey( &lockET );
	fLocked = fFalse;
	pextentryDest = NULL;

	//  if we inserted an entry into the table then perform some cleanup

	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		fInserted = fFalse;
		}

	return JET_errSuccess;

HandleError:
	if ( fLocked )
		{
		m_et.WriteUnlockKey( &lockET );
		}
	if ( pextentrySrc )
		{
		delete pextentrySrc->m_wszFileName;
		delete pextentrySrc;
		}
	if (	pextentryDest &&
			(	!fSyncFree ||
				!BOOL( AtomicExchange( (long*)&pextentryDest->m_fDependent, long( fFalse ) ) ) ) )
		{
		delete pextentryDest->m_wszFileName;
		delete pextentryDest;
		}
	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		}
	return err;
	}

ERR CSLVFileTable::ErrCommitSpace( CSLVInfo* const pslvinfo )
	{
	ERR					err			= JET_errSuccess;
	CEntry				entry;
	CEntryTable::CLock	lockET;
	CEntryTable::ERR	errET;
	BOOL				fLocked		= fFalse;
	BOOL				fUpdate		= fFalse;
	QWORD				cbCommit	= 0;
	
	//  fetch the entry for this SLV File from the table

	Call( pslvinfo->ErrGetFileID( &entry.m_fileid ) );

	m_et.WriteLockKey( entry.m_fileid, &lockET );
	fLocked = fTrue;
	if ( ( errET = m_et.ErrRetrieveEntry( &lockET, &entry ) ) != CEntryTable::errSuccess )
		{
		Assert( errET == CEntryTable::errEntryNotFound );
		Call( ErrERRCheck( JET_errSLVSpaceCorrupted ) );
		}

	//  remove all the (partial) space owned by this SLV File from the reserved
	//  space in the extended entry

	CallS( pslvinfo->ErrMoveBeforeFirst() );
	while ( ( err = pslvinfo->ErrMoveNext() ) >= JET_errSuccess )
		{
		CSLVInfo::RUN run;
		Call( pslvinfo->ErrGetCurrentRun( &run ) );

		CExtendedEntry::CRun* prun = entry.m_pextentry->m_ilRunReserved.PrevMost();
		while ( prun )
			{
			CExtendedEntry::CRun* prunNext = entry.m_pextentry->m_ilRunReserved.Next( prun );
			
			if ( prun->m_ibLogical == run.ibLogical )
				{
				prun->m_ibLogical	+= run.cbSize;
				prun->m_cbSize		-= run.cbSize;

				cbCommit += run.cbSize;
				run.cbSize = 0;
				fUpdate = fTrue;
				}
			else if ( prun->m_ibLogical + prun->m_cbSize == run.ibLogical + run.cbSize )
				{
				prun->m_cbSize		-= run.cbSize;

				cbCommit += run.cbSize;
				run.cbSize = 0;
				fUpdate = fTrue;
				}

			if ( !prun->m_cbSize )
				{
				entry.m_pextentry->m_ilRunReserved.Remove( prun );
				delete prun;
				fUpdate = fTrue;
				}

			prun = prunNext;
			}

		if ( run.cbSize )
			{
			Call( ErrERRCheck( JET_errSLVSpaceCorrupted ) );
			}
		}
	if ( err == JET_errNoCurrentRecord )
		{
		err = JET_errSuccess;
		}
	Call( err );

	if ( fUpdate )
		{
		entry.m_pextentry->m_cbSpace -= cbCommit;
		errET = m_et.ErrReplaceEntry( &lockET, entry );
		Assert( errET == CEntryTable::errSuccess );
		if ( errET == CEntryTable::errSuccess )
			{
			AtomicAdd( &m_cbReserved, -cbCommit );
			}
		fUpdate = fFalse;
		}

	m_et.WriteUnlockKey( &lockET );
	fLocked = fFalse;

	return JET_errSuccess;

HandleError:
	if ( fUpdate )
		{
		entry.m_pextentry->m_cbSpace -= cbCommit;
		errET = m_et.ErrReplaceEntry( &lockET, entry );
		Assert( errET == CEntryTable::errSuccess );
		if ( errET == CEntryTable::errSuccess )
			{
			AtomicAdd( &m_cbReserved, -cbCommit );
			}
		}
	if ( fLocked )
		{
		m_et.WriteUnlockKey( &lockET );
		}
	return err;
	}
	
ERR CSLVFileTable::ErrDeleteSpace( CSLVInfo* const pslvinfo )
	{
	ERR						err			= JET_errSuccess;
	CEntry					entry;
	CExtendedEntry*			pextentry	= NULL;
	CEntryTable::CLock		lockET;
	CEntryTable::ERR		errET;
	BOOL					fLocked		= fFalse;
	BOOL					fInserted	= fFalse;
	CExtendedEntry::CRun*	prunPrev	= NULL;
	
	//  fetch the entry for this SLV File from the table if it exists.  if
	//  it doesn't exist, the entry will start out initialized to have the
	//  correct FILEID, allocation size, file name, and no other attributes

	if ( !( pextentry = new CExtendedEntry ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	Call( pslvinfo->ErrGetFileID( &entry.m_fileid ) );
	entry.m_pextentry = pextentry;

	Call( pslvinfo->ErrGetFileAlloc( &pextentry->m_cbAlloc ) );

	Call( pslvinfo->ErrGetFileNameLength( &pextentry->m_cwchFileName ) );
	if ( !( pextentry->m_wszFileName = new wchar_t[ pextentry->m_cwchFileName + 1 ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	Call( pslvinfo->ErrGetFileName( pextentry->m_wszFileName ) );

	m_et.WriteLockKey( entry.m_fileid, &lockET );
	fLocked = fTrue;
	(void)m_et.ErrRetrieveEntry( &lockET, &entry );

	if ( !entry.m_pextentry )
		{
		entry.m_pextentry = pextentry;
		}

	//  add the (partial) space owned by this SLV File to the deleted space in
	//  the extended entry
	//
	//  NOTE:  we will use the extended entry pointer in the entry which is not
	//  necessarily the extended entry we allocated

	prunPrev = entry.m_pextentry->m_ilRunDeleted.NextMost();

	CallS( pslvinfo->ErrMoveBeforeFirst() );
	while ( ( err = pslvinfo->ErrMoveNext() ) >= JET_errSuccess )
		{
		CSLVInfo::RUN run;
		Call( pslvinfo->ErrGetCurrentRun( &run ) );

		CExtendedEntry::CRun* prun;
		if ( !( prun = new CExtendedEntry::CRun ) )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
			
		prun->m_ibLogical	= run.ibLogical;
		prun->m_cbSize		= run.cbSize;
		
		entry.m_pextentry->m_ilRunDeleted.InsertAsNextMost( prun );
		AtomicAdd( &m_cbDeleted, prun->m_cbSize );
		entry.m_pextentry->m_cbSpace += prun->m_cbSize;
		}
	if ( err == JET_errNoCurrentRecord )
		{
		err = JET_errSuccess;
		}
	Call( err );

	//  try to update the entry in the entry table

	if ( ( errET = m_et.ErrReplaceEntry( &lockET, entry ) ) != CEntryTable::errSuccess )
		{
		Assert( errET == CEntryTable::errNoCurrentEntry );

		//  the entry does not yet exist, so try to insert it in the entry table

		if ( ( errET = m_et.ErrInsertEntry( &lockET, entry ) ) != CEntryTable::errSuccess )
			{
			Assert( errET == CEntryTable::errOutOfMemory );
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		fInserted = fTrue;
		AtomicIncrement( (long*)&cOSSLVFileTableInsert );
		AtomicIncrement( (long*)&m_centryInsert );
		}

	m_et.WriteUnlockKey( &lockET );
	fLocked = fFalse;

	//  if we didn't use the allocated extended entry then free it

	if ( pextentry != entry.m_pextentry )
		{
		Assert( pextentry->m_ilRunDeleted.FEmpty() );
		delete pextentry->m_wszFileName;
		delete pextentry;
		}
	pextentry = NULL;

	//  if we inserted an entry in the table then perform some cleanup

	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		fInserted = fFalse;
		}

	return JET_errSuccess;

HandleError:
	if ( prunPrev )
		{
		while ( entry.m_pextentry->m_ilRunDeleted.Next( prunPrev ) )
			{
			CExtendedEntry::CRun* prun = entry.m_pextentry->m_ilRunDeleted.Next( prunPrev );
			entry.m_pextentry->m_ilRunDeleted.Remove( prun );
			AtomicAdd( &m_cbDeleted, -prun->m_cbSize );
			entry.m_pextentry->m_cbSpace -= prun->m_cbSize;
			delete prun;
			}
		}
	if ( fLocked )
		{
		m_et.WriteUnlockKey( &lockET );
		}
	if ( pextentry )
		{
		while ( !pextentry->m_ilRunDeleted.FEmpty() )
			{
			CExtendedEntry::CRun* prun = pextentry->m_ilRunDeleted.PrevMost();
			pextentry->m_ilRunDeleted.Remove( prun );
			AtomicAdd( &m_cbDeleted, -prun->m_cbSize );
			entry.m_pextentry->m_cbSpace -= prun->m_cbSize;
			delete prun;
			}
		delete pextentry->m_wszFileName;
		delete pextentry;
		}
	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		}
	return err;
	}

ERR CSLVFileTable::ErrRename(	CSLVInfo* const	pslvinfo,
								wchar_t* const	wszFileNameDest )
	{
	ERR					err				= JET_errSuccess;
	CEntry				entry;
	CEntryTable::CLock	lockET;
	CEntryTable::ERR	errET;
	BOOL				fLocked			= fFalse;
	size_t				cwchFileName;
	wchar_t*			wszFileName		= NULL;
	
	//  fetch the entry for this SLV File from the table

	Call( pslvinfo->ErrGetFileID( &entry.m_fileid ) );

	m_et.WriteLockKey( entry.m_fileid, &lockET );
	fLocked = fTrue;
	if ( ( errET = m_et.ErrRetrieveEntry( &lockET, &entry ) ) != CEntryTable::errSuccess )
		{
		Assert( errET == CEntryTable::errEntryNotFound );
		Call( ErrERRCheck( JET_errSLVSpaceCorrupted ) );
		}

	//  this SLV File's contents was moved

	if ( entry.m_pextentry && entry.m_pextentry->m_fDependent )
		{
		//  remember the source contents pointer from this entry

		const CSLVInfo::FILEID	fileidSource		= entry.m_pextentry->m_fileidSource;
		const QWORD				idContentsSource	= entry.m_pextentry->m_idContentsSource;

		//  fetch the source's entry

		m_et.WriteUnlockKey( &lockET );
		fLocked = fFalse;

		m_et.WriteLockKey( fileidSource, &lockET );
		fLocked = fTrue;
		errET = m_et.ErrRetrieveEntry( &lockET, &entry );
		Assert(	errET == CEntryTable::errSuccess ||
				errET == CEntryTable::errEntryNotFound );

		//  the source's entry doesn't exist or doesn't have a matching idContents

		if (	errET != CEntryTable::errSuccess ||
				!entry.m_pextentry ||
				entry.m_pextentry->m_idContents != idContentsSource )
			{
			//  the source has been closed so we can safely use the entry for
			//  this SLV File.  re-fetch the entry for this SLV File as before
			
			m_et.WriteUnlockKey( &lockET );
			fLocked = fFalse;

			Call( pslvinfo->ErrGetFileID( &entry.m_fileid ) );

			m_et.WriteLockKey( entry.m_fileid, &lockET );
			fLocked = fTrue;
			if ( ( errET = m_et.ErrRetrieveEntry( &lockET, &entry ) ) != CEntryTable::errSuccess )
				{
				Assert( errET == CEntryTable::errEntryNotFound );
				Call( ErrERRCheck( JET_errSLVSpaceCorrupted ) );
				}
			}
		}

	//  store the SLV File's new file name in the extended entry

	cwchFileName = wcslen( wszFileNameDest );
	if ( !( wszFileName = new wchar_t[ cwchFileName + 1 ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	wcscpy( wszFileName, wszFileNameDest );

	delete entry.m_pextentry->m_wszFileName;
	entry.m_pextentry->m_cwchFileName	= cwchFileName;
	entry.m_pextentry->m_wszFileName	= wszFileName;
	wszFileName = NULL;

	m_et.WriteUnlockKey( &lockET );
	fLocked = fFalse;

	return JET_errSuccess;

HandleError:
	if ( fLocked )
		{
		m_et.WriteUnlockKey( &lockET );
		}
	delete[] wszFileName;
	return err;
	}

void CSLVFileTable::_PerformAmortizedCleanup()
	{
	//  increment the deferred cleanup count.  if we are not elected to perform
	//  cleanup, this will cause someone who is to cleanup the table on behalf
	//  of our table insertion

	AtomicExchangeAdd( (long*)&m_cDeferredCleanup, 2 );

	//  we are elected to perform the amortized cleanup

	if ( m_semCleanup.FTryAcquire() )
		{
		//  get the current cleanup count.  this number can be zero or negative
		//  if someone else has already done our cleanup or did more cleanup
		//  than necessary due to the entry distribution in the hash table

		const long cCleanup = m_cDeferredCleanup;

		//  we have some cleanup work to do

		if ( cCleanup > 0 )
			{
			//  perform our share of the amortized table cleanup rounded up to the
			//  next bucket plus one more.  we use this additional entry to set the
			//  starting fileid for our next pass

			CEntryTable::CLock	lockET;
			CEntryTable::ERR	errET;
			
			m_et.BeginHashScanFromKey( m_fileidNextCleanup, &lockET );

			BOOL fFinishedBucket = fFalse;
			for ( DWORD iCleanup = 0; iCleanup <= cCleanup || !fFinishedBucket; iCleanup++ )
				{
				//  get the next entry in the entry table

				BOOL fLeftBucket;
				if ( ( errET = m_et.ErrMoveNext( &lockET, &fLeftBucket ) ) != CEntryTable::errSuccess )
					{
					//  we have hit the end of the entry table
					
					Assert( errET == CEntryTable::errNoCurrentEntry );

					//  restart our scan at the beginning of the entry table
					
					m_et.EndHashScan( &lockET );
					m_et.BeginHashScan( &lockET );

					//  get the first entry in the entry table

					if ( ( errET = m_et.ErrMoveNext( &lockET ) ) != CEntryTable::errSuccess )
						{
						//  the table is empty so we are done

						Assert( errET == CEntryTable::errNoCurrentEntry );

						m_fileidNextCleanup	= 0;
						AtomicExchangeAdd( (long*)&m_cDeferredCleanup, long( cCleanup - iCleanup ) );
						break;
						}

					fLeftBucket = fTrue;
					}
				fFinishedBucket = fFinishedBucket || fLeftBucket && iCleanup > 0;

				//  get the current entry

				CEntry entry;
				errET = m_et.ErrRetrieveEntry( &lockET, &entry );
				Assert( errET == CEntryTable::errSuccess );

				//  we are done cleaning

				if ( iCleanup >= cCleanup && fFinishedBucket )
					{
					//  save this entry's fileid as the starting point for the next
					//  cleanup

					m_fileidNextCleanup = entry.m_fileid;
					}

				//  we are not done cleaning

				else
					{
					//  this entry's expiration has passed (including a safety margin
					//  to avoid race conditions) and we are not dependent on another
					//  entry

					AtomicDecrement( (long*)&m_cDeferredCleanup );
					AtomicIncrement( (long*)&cOSSLVFileTableClean );
					AtomicIncrement( (long*)&m_centryClean );

					if (	TickCmp( entry.m_tickExpiration + cmsecOSSLVTTLSafety, TickOSTimeCurrent() ) < 0 &&
							( !entry.m_pextentry || !entry.m_pextentry->m_fDependent ) )
						{
						//  there is space or a file name stored in this entry

						if (	entry.m_pextentry &&
								(	entry.m_pextentry->m_wszFileName ||
									!entry.m_pextentry->m_ilRunReserved.FEmpty() ||
									!entry.m_pextentry->m_ilRunDeleted.FEmpty() ) )
							{
							//  attempt to open the SLV File if and only if it exists

							WCHAR	Buffer[ IFileSystemAPI::cchPathMax ];
							HANDLE	hFile				= NULL;
							ERR		errOpen				= JET_errSuccess;

							wcscpy( Buffer, m_pslvroot->wszRootName );
							wcscat( Buffer, L"\\" );
							wcscat( Buffer, entry.m_pextentry->m_wszFileName );

							hFile = pfnIfsCreateFile(	Buffer,
														0, 
														0,
														NULL,
														OPEN_EXISTING,
														FILE_ATTRIBUTE_NORMAL,
														NULL,
														0 );
							if ( hFile == INVALID_HANDLE_VALUE )
								{
								errOpen = ErrOSSLVFileIGetLastError();
								}

							//  if we can't find the file and either all or none
							//  of the file's space is present then that means
							//  that no one is using the file and all space in
							//  the file is in a consistent state so we can
							//  therefore cleanup this table entry

							if (	errOpen == JET_errSLVFileNotFound &&
									(	!entry.m_pextentry->m_cbSpace ||
										entry.m_pextentry->m_cbSpace == entry.m_pextentry->m_cbAlloc ) )
								{
								//  free any space owned by this entry

								while (	!entry.m_pextentry->m_ilRunReserved.FEmpty() ||
										!entry.m_pextentry->m_ilRunDeleted.FEmpty() )
									{
									//  get the current space entry.  if the current space
									//  entry contains the first run (which determines the
									//  File ID) and there are other entries, save this
									//  entry until last.  we must do this so that we can
									//  maintain ownership of this File ID until the file
									//  is entirely cleaned up.  if we free this run too
									//  soon, it can be reallocated and used as the File ID
									//  for another file.  this, of course, would be bad

									CInvasiveList< CExtendedEntry::CRun, CExtendedEntry::CRun::OffsetOfILE >*	pilRun	= NULL;
									CExtendedEntry::CRun*														prun	= NULL;

									if ( !prun )
										{
										pilRun = &entry.m_pextentry->m_ilRunReserved;
										prun = pilRun->PrevMost();
										}

									if ( prun && CSLVInfo::FILEID( prun->m_ibLogical ) == entry.m_fileid )
										{
										prun = pilRun->Next( prun );
										}

									if ( !prun )
										{
										pilRun = &entry.m_pextentry->m_ilRunDeleted;
										prun = pilRun->PrevMost();
										}

									if ( prun && CSLVInfo::FILEID( prun->m_ibLogical ) == entry.m_fileid )
										{
										prun = pilRun->Next( prun );
										}

									if ( !prun )
										{
										pilRun = &entry.m_pextentry->m_ilRunReserved;
										prun = pilRun->PrevMost();
										}

									if ( !prun )
										{
										pilRun = &entry.m_pextentry->m_ilRunDeleted;
										prun = pilRun->PrevMost();
										}

									Assert( pilRun );
									Assert( prun );
									Assert(	CSLVInfo::FILEID( prun->m_ibLogical ) != entry.m_fileid ||
											!pilRun->Prev( prun ) &&
											!pilRun->Next( prun ) &&
											(	entry.m_pextentry->m_ilRunReserved.FEmpty() ^
												entry.m_pextentry->m_ilRunDeleted.FEmpty() ) );

									//  we successfully cleaned up the space

									if (	m_pslvroot->pfnSpaceFree(	m_pslvroot->dwSpaceFreeKey,
																		prun->m_ibLogical,
																		prun->m_cbSize,
																		pilRun == &entry.m_pextentry->m_ilRunDeleted ) >= JET_errSuccess )
										{
										//  remove this space from the entry

										pilRun->Remove( prun );
										if ( pilRun == &entry.m_pextentry->m_ilRunDeleted )
											{
											AtomicAdd( &m_cbDeleted, -prun->m_cbSize );
											}
										else
											{
											AtomicAdd( &m_cbReserved, -prun->m_cbSize );
											}
										delete prun;
										}

									//  we failed to clean up the space

									else
										{
										//  reset the expiration on this file to sometime
										//  in the future to optimize cleanup of the table

										entry.m_tickExpiration = TickOSTimeCurrent() + cmsecOSSLVSpaceFreeDelay;

										//  stop cleaning this entry

										break;
										}
									}
									
								//  there is no space left in this entry

								if (	entry.m_pextentry->m_ilRunReserved.FEmpty() &&
										entry.m_pextentry->m_ilRunDeleted.FEmpty() )
									{
									//  remove any dependents we may have
									//
									//  NOTE:  if we see a dependent with its dependent
									//  flag reset then that means that the dependency
									//  was never setup and the extended entry has been
									//  orphaned so we must free this extended entry

									while ( entry.m_pextentry->m_ilDependents.PrevMost() )
										{
										CSLVFileTable::CExtendedEntry* pextentry;
										pextentry = entry.m_pextentry->m_ilDependents.PrevMost();

										entry.m_pextentry->m_ilDependents.Remove( pextentry );

										if ( !BOOL( AtomicExchange( (long*)&pextentry->m_fDependent, long( fFalse ) ) ) )
											{
											delete pextentry->m_wszFileName;
											delete pextentry;
											}
										}
									
									//  delete this entry in the table

									delete entry.m_pextentry->m_wszFileName;
									delete entry.m_pextentry;
									
									errET = m_et.ErrDeleteEntry( &lockET );
									Assert( errET == CEntryTable::errSuccess );
									AtomicIncrement( (long*)&cOSSLVFileTableDelete );
									AtomicIncrement( (long*)&m_centryDelete );
									}

								//  there is space left in this entry

								else
									{
									//  update this entry in the table
									
									errET = m_et.ErrReplaceEntry( &lockET, entry );
									Assert( errET == CEntryTable::errSuccess );
									}
								}

							//  the SLV File is still in use

							else
								{
								//  close the file if opened

								if ( hFile )
									{
									CloseHandle( hFile );
									}
								
								//  reset the expiration on this file to sometime in the
								//  future to optimize cleanup of the table

								entry.m_tickExpiration = TickOSTimeCurrent() + cmsecOSSLVFileOpenDelay;
								
								errET = m_et.ErrReplaceEntry( &lockET, entry );
								Assert( errET == CEntryTable::errSuccess );
								}
							}

						//  there is neither space nor a file name stored in this entry

						else
							{
							//  remove any dependents we may have
							//
							//  NOTE:  if we see a dependent with its dependent
							//  flag reset then that means that the dependency
							//  was never setup and the extended entry has been
							//  orphaned so we must free this extended entry

							while ( entry.m_pextentry && entry.m_pextentry->m_ilDependents.PrevMost() )
								{
								CSLVFileTable::CExtendedEntry* pextentry;
								pextentry = entry.m_pextentry->m_ilDependents.PrevMost();

								entry.m_pextentry->m_ilDependents.Remove( pextentry );

								if ( !BOOL( AtomicExchange( (long*)&pextentry->m_fDependent, long( fFalse ) ) ) )
									{
									delete pextentry->m_wszFileName;
									delete pextentry;
									}
								}
							
							//  delete this entry in the table

							if ( entry.m_pextentry )
								{
								delete entry.m_pextentry->m_wszFileName;
								delete entry.m_pextentry;
								}
									
							errET = m_et.ErrDeleteEntry( &lockET );
							Assert( errET == CEntryTable::errSuccess );
							AtomicIncrement( (long*)&cOSSLVFileTableDelete );
							AtomicIncrement( (long*)&m_centryDelete );
							}
						}
					}
				}

			m_et.EndHashScan( &lockET );
			}

		//  we're done with our share of the amortized cleanup so let someone
		//  else take a crack at it

		m_semCleanup.Release();
		}
	}

CSLVFileInfo::CSLVFileInfo()
	{
	m_fFreeCache	= fFalse;
	m_fCloseBuffer	= fFalse;
	m_fCloseCursor	= fFalse;
	}
	
CSLVFileInfo::~CSLVFileInfo()
	{
	Assert( !m_fFreeCache );
	Assert( !m_fCloseBuffer );
	Assert( !m_fCloseCursor );
	}
	
ERR CSLVFileInfo::ErrCreate()
	{
	PFILE_FULL_EA_INFORMATION	pffeainfCur;
	BYTE*						pbNameStart;
	BYTE*						pbNameEnd;
	BYTE*						pbValueStart;
	BYTE*						pbValueEnd;
	PFILE_FULL_EA_INFORMATION	pffeainfNext;

	//  init the cache
	
	m_fFreeCache		= fFalse;
	m_fUpdateChecksum	= fFalse;
	m_fUpdateSlist		= fFalse;
	m_rgbCache			= (BYTE*) _PvAlign( m_rgbLocalCache );
	m_cbCache			= cbLocalCache;

#ifdef DEBUG
	memset( m_rgbCache, 0xEA, m_cbCache );
#endif  //  DEBUG

	//  build an empty EA List in the buffer and initialize all property
	//  pointers to point to the correct places in that EA List
	
	m_pffeainf	= PFILE_FULL_EA_INFORMATION( m_rgbCache );
	m_cbffeainf	=	EXIFS_EA_LEN_FILENAME( sizeof( L"" ) ) +
					EXIFS_EA_LEN_COMMIT +
					EXIFS_EA_LEN_INSTANCE_ID +
					EXIFS_EA_LEN_CHECKSUM +
					EXIFS_EA_LEN_OPEN_DEADLINE +
					EXIFS_EA_LEN_SCATTER_LIST( m_fUpdateSlist );  //  don't ask

	Assert( m_cbffeainf <= m_cbCache );
	
	pffeainfNext = m_pffeainf;
	
	//  add an empty file name to the EA List

	pffeainfCur		= pffeainfNext;
	pbNameStart		= (BYTE*)pffeainfCur->EaName;
	pbNameEnd		= pbNameStart + sizeof( EXIFS_EA_NAME_FILENAME );
	pbValueStart	= (BYTE*)_PvAlign( pbNameEnd );
	pbValueEnd		= pbValueStart + sizeof( L"" );
	pffeainfNext	= (FILE_FULL_EA_INFORMATION*)_PvAlign( pbValueEnd );

	pffeainfCur->NextEntryOffset	= (ULONG)((BYTE*)pffeainfNext - (BYTE*)pffeainfCur);
	pffeainfCur->Flags				= 0;
	pffeainfCur->EaNameLength		= BYTE( pbNameEnd - pbNameStart - 1 );
	pffeainfCur->EaValueLength		= WORD( (BYTE*)pffeainfNext - pbNameEnd );
	
	strcpy( (char*)pbNameStart, EXIFS_EA_NAME_FILENAME );
	
	m_wszFileName		= (wchar_t*)pbValueStart;

	wcscpy( m_wszFileName, L"" );
	m_cwchFileName = wcslen( L"" );
	
	//  add the commit status to the EA List, indicating that this space is either
	//  committed or reserved

	pffeainfCur		= pffeainfNext;
	pbNameStart		= (BYTE*)pffeainfCur->EaName;
	pbNameEnd		= pbNameStart + sizeof( EXIFS_EA_NAME_COMMIT );
	pbValueStart	= (BYTE*)_PvAlign( pbNameEnd );
	pbValueEnd		= pbValueStart + sizeof( NTSTATUS );
	pffeainfNext	= (FILE_FULL_EA_INFORMATION*)_PvAlign( pbValueEnd );

	pffeainfCur->NextEntryOffset	= (ULONG)((BYTE*)pffeainfNext - (BYTE*)pffeainfCur);
	pffeainfCur->Flags				= 0;
	pffeainfCur->EaNameLength		= BYTE( pbNameEnd - pbNameStart - 1 );
	pffeainfCur->EaValueLength		= WORD( (BYTE*)pffeainfNext - pbNameEnd );
	
	strcpy( (char*)pbNameStart, EXIFS_EA_NAME_COMMIT );
	
	m_pstatusCommit		= (NTSTATUS*) pbValueStart;

	*m_pstatusCommit	= STATUS_EA_CORRUPT_ERROR;

	//  add the instance ID to the EA List

	pffeainfCur		= pffeainfNext;
	pbNameStart		= (BYTE*)pffeainfCur->EaName;
	pbNameEnd		= pbNameStart + sizeof( EXIFS_EA_NAME_INSTANCE_ID );
	pbValueStart	= (BYTE*)_PvAlign( pbNameEnd );
	pbValueEnd		= pbValueStart + sizeof( DWORD );
	pffeainfNext	= (FILE_FULL_EA_INFORMATION*)_PvAlign( pbValueEnd );

	pffeainfCur->NextEntryOffset	= (ULONG)((BYTE*)pffeainfNext - (BYTE*)pffeainfCur);
	pffeainfCur->Flags				= 0;
	pffeainfCur->EaNameLength		= BYTE( pbNameEnd - pbNameStart - 1 );
	pffeainfCur->EaValueLength		= WORD( (BYTE*)pffeainfNext - pbNameEnd );
	
	strcpy( (char*)pbNameStart, EXIFS_EA_NAME_INSTANCE_ID );

	m_pdwInstanceID		= (DWORD*) pbValueStart;
	
	*m_pdwInstanceID	= EXIFS_INVALID_INSTANCE_ID;

	//  add the EA List checksum to the EA List and set it to 0 initially.  we
	//  will come back and set it to the correct value once the entire EA List
	//  is constructed

	pffeainfCur		= pffeainfNext;
	pbNameStart		= (BYTE*)pffeainfCur->EaName;
	pbNameEnd		= pbNameStart + sizeof( EXIFS_EA_NAME_CHECKSUM );
	pbValueStart	= (BYTE*)_PvAlign( pbNameEnd );
	pbValueEnd		= pbValueStart + sizeof( DWORD );
	pffeainfNext	= (FILE_FULL_EA_INFORMATION*)_PvAlign( pbValueEnd );

	pffeainfCur->NextEntryOffset	= (ULONG)((BYTE*)pffeainfNext - (BYTE*)pffeainfCur);
	pffeainfCur->Flags				= 0;
	pffeainfCur->EaNameLength		= BYTE( pbNameEnd - pbNameStart - 1 );
	pffeainfCur->EaValueLength		= WORD( (BYTE*)pffeainfNext - pbNameEnd );
	
	strcpy( (char*)pbNameStart, EXIFS_EA_NAME_CHECKSUM );
	
	m_pdwChecksum	= (DWORD*) pbValueStart;

	*m_pdwChecksum	= EXIFS_CHECKSUM_SEED;

	//  add the open deadline to the EA List

	pffeainfCur		= pffeainfNext;
	pbNameStart		= (BYTE*)pffeainfCur->EaName;
	pbNameEnd		= pbNameStart + sizeof( EXIFS_EA_NAME_OPEN_DEADLINE );
	pbValueStart	= (BYTE*)_PvAlign( pbNameEnd );
	pbValueEnd		= pbValueStart + sizeof( TICK );
	pffeainfNext	= (FILE_FULL_EA_INFORMATION*)_PvAlign( pbValueEnd );

	pffeainfCur->NextEntryOffset	= (ULONG)((BYTE*)pffeainfNext - (BYTE*)pffeainfCur);
	pffeainfCur->Flags				= 0;
	pffeainfCur->EaNameLength		= BYTE( pbNameEnd - pbNameStart - 1 );
	pffeainfCur->EaValueLength		= WORD( (BYTE*)pffeainfNext - pbNameEnd );
	
	strcpy( (char*)pbNameStart, EXIFS_EA_NAME_OPEN_DEADLINE );

	m_ptickOpenDeadline		= (TICK*) pbValueStart;
	
	*m_ptickOpenDeadline	= TickOSTimeCurrent() - cmsecOSSLVTTLSafety;

	//  add an empty scatter list as the last entry in the EA List

	pffeainfCur		= pffeainfNext;
	pbNameStart		= (BYTE*)pffeainfCur->EaName;
	pbNameEnd		= pbNameStart + sizeof( EXIFS_EA_NAME_SCATTER_LIST );
	pbValueStart	= (BYTE*)_PvAlign( pbNameEnd );
	pbValueEnd		= pbValueStart + _SizeofScatterList( 0 );
	pffeainfNext	= (FILE_FULL_EA_INFORMATION*)_PvAlign( pbValueEnd );

	pffeainfCur->NextEntryOffset	= 0;
	pffeainfCur->Flags				= 0;
	pffeainfCur->EaNameLength		= BYTE( pbNameEnd - pbNameStart - 1 );
	pffeainfCur->EaValueLength		= WORD( (BYTE*)pffeainfNext - pbNameEnd );
	
	strcpy( (char*)pbNameStart, EXIFS_EA_NAME_SCATTER_LIST );

	m_pslist	= PSCATTER_LIST( pbValueStart );
	m_cbslist	= _SizeofScatterList( 0 );

	m_pslist->Signature				= SCATTER_LIST_SIGNATURE;
	m_pslist->NumFragments			= 0;
	m_pslist->TotalBytes.QuadPart	= 0;
	m_pslist->OverflowOffset		= (ULONG)m_cbslist;
	m_pslist->OverflowLen			= 0;
	m_pslist->Flags					= 0;

	//  verify that the generated EA List is of the expected size

	Assert( m_cbffeainf == (BYTE*)pffeainfNext - (BYTE*)m_pffeainf );

	//  set our currency to before the first run

	MoveBeforeFirstRun();

	//  init the large scatter list buffer

	m_fCloseBuffer	= fFalse;
	m_fCloseCursor	= fFalse;

	return JET_errSuccess;
	}
	
ERR CSLVFileInfo::ErrLoad( const void* const pv, const size_t cb, const BOOL fCommit )
	{
	ERR							err			= JET_errSuccess;
	PFILE_FULL_EA_INFORMATION	pffeainfCur;
	
	//  init the cache
	
	m_fFreeCache		= fFalse;
	m_fUpdateChecksum	= fFalse;
	m_fUpdateSlist		= fFalse;
	m_rgbCache			= (BYTE*) pv;
	m_cbCache			= cb;

	//  load the EA List from the provided buffer

	m_pffeainf	= PFILE_FULL_EA_INFORMATION( m_rgbCache );
	m_cbffeainf	= cb;

	//  verify the checksum of the EA list

	if ( LOG::UlChecksumBytes(	(BYTE*)m_pffeainf,
								(BYTE*)m_pffeainf + m_cbffeainf,
								EXIFS_CHECKSUM_SEED ) )
		{
		Call( ErrERRCheck( JET_errSLVEAListCorrupt ) );
		}

	//  TODO:  validate EA list structure

	//  extract each EA from the EA list

	pffeainfCur			= m_pffeainf;
	m_wszFileName		= (wchar_t*)_PvAlign( pffeainfCur->EaName + pffeainfCur->EaNameLength + 1 );
	m_cwchFileName		= wcslen( m_wszFileName );

	pffeainfCur			= PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainfCur + pffeainfCur->NextEntryOffset );
	m_pstatusCommit		= (NTSTATUS*)_PvAlign( pffeainfCur->EaName + pffeainfCur->EaNameLength + 1 );

	pffeainfCur			= PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainfCur + pffeainfCur->NextEntryOffset );
	m_pdwInstanceID		= (DWORD*)_PvAlign( pffeainfCur->EaName + pffeainfCur->EaNameLength + 1 );

	pffeainfCur			= PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainfCur + pffeainfCur->NextEntryOffset );
	m_pdwChecksum		= (DWORD*)_PvAlign( pffeainfCur->EaName + pffeainfCur->EaNameLength + 1 );

	pffeainfCur			= PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainfCur + pffeainfCur->NextEntryOffset );
	m_ptickOpenDeadline	= (TICK*)_PvAlign( pffeainfCur->EaName + pffeainfCur->EaNameLength + 1 );

	pffeainfCur			= PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainfCur + pffeainfCur->NextEntryOffset );
	m_pslist			= PSCATTER_LIST( _PvAlign( pffeainfCur->EaName + pffeainfCur->EaNameLength + 1 ) );
	m_cbslist			= _SizeofScatterList( m_pslist->NumFragments, ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) );

	//  validate EAs
	//
	//  TODO:  validate ALL EAs

	if ( fCommit )
		{
		Call( ErrOSSLVFileINTStatus( *m_pstatusCommit ) );
		}

	if ( m_pslist->OverflowOffset != sizeof( SCATTER_LIST ) )
		{
		Call( ErrERRCheck( JET_errSLVProviderVersionMismatch ) );
		}

	//  init the large scatter list buffer

	if ( ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) )
		{
		Call( ErrOSSLVFileIGetLastError( pfnIfsCopyReferenceToBuffer(	PIFS_LARGE_BUFFER( (BYTE*)m_pslist + m_pslist->OverflowOffset ),
																		NULL,
																		&m_buffer ) ) );
		m_fCloseBuffer	= fTrue;
		
		m_fCloseCursor	= fFalse;
		}
	else
		{
		m_fCloseBuffer	= fFalse;
		m_fCloseCursor	= fFalse;
		}

	//  set our currency to before the first run

	MoveBeforeFirstRun();

	return JET_errSuccess;

HandleError:
	Unload();
	return err;
	}
	
INLINE void CSLVFileInfo::Unload()
	{
	if ( m_fCloseCursor )
		{
		pfnIfsFinishCursor( &m_cursor );
		m_fCloseCursor = fFalse;
		}
	if ( m_fCloseBuffer )
		{
		pfnIfsCloseBuffer( &m_buffer );
		m_fCloseBuffer = fFalse;
		}
	if ( m_fFreeCache )
		{
		OSMemoryHeapFree( m_rgbCache );
		m_fFreeCache = fFalse;
		}
	}
	
INLINE ERR CSLVFileInfo::ErrGetFileName( wchar_t** const pwszFileName, size_t* const pcwchFileName )
	{
	*pwszFileName	= m_wszFileName;
	*pcwchFileName	= m_cwchFileName;

	return JET_errSuccess;
	}
	
ERR CSLVFileInfo::ErrSetFileName( const wchar_t* const wszFileName )
	{
	ERR err = JET_errSuccess;
	
	//  get the change in size of the EA List

	size_t	cwchFileNameNew	= wcslen( wszFileName );
	size_t	cbFileNameNew	= _IbAlign( ( cwchFileNameNew + 1 ) * sizeof( wchar_t ) );
	size_t	cbFileName		= _IbAlign( ( m_cwchFileName + 1 ) * sizeof( wchar_t ) );

	size_t	dcbffeainf		= cbFileNameNew - cbFileName;

	//  make the cache large enough to hold the new EA List

	CallR( _ErrCheckCacheSize( m_cbffeainf + dcbffeainf ) );

	//  move the EA List data after the new file name

	memmove(	(BYTE*)m_pffeainf + m_pffeainf->NextEntryOffset + dcbffeainf,
				(BYTE*)m_pffeainf + m_pffeainf->NextEntryOffset,
				m_cbffeainf - m_pffeainf->NextEntryOffset );

	//  fix up the EA List pointers for the new file name

	m_pffeainf->NextEntryOffset	= (ULONG)(m_pffeainf->NextEntryOffset + dcbffeainf);
	m_pffeainf->EaValueLength	= WORD( m_pffeainf->EaValueLength + dcbffeainf );
	m_cbffeainf					= m_cbffeainf + dcbffeainf;

	//  move all property pointers after the new file name

	m_pstatusCommit		= (NTSTATUS*)( DWORD_PTR( m_pstatusCommit ) + dcbffeainf );
	m_pdwInstanceID		= (DWORD*)( DWORD_PTR( m_pdwInstanceID ) + dcbffeainf );
	m_pdwChecksum		= (DWORD*)( DWORD_PTR( m_pdwChecksum ) + dcbffeainf );
	m_ptickOpenDeadline	= (TICK*)( DWORD_PTR( m_ptickOpenDeadline ) + dcbffeainf );
	m_pslist			= PSCATTER_LIST( DWORD_PTR( m_pslist ) + dcbffeainf );

	//  copy in the new file name

	wcscpy( m_wszFileName, wszFileName );
	m_cwchFileName = cwchFileNameNew;

	m_fUpdateChecksum = fTrue;
	
	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrGetCommitStatus( NTSTATUS* const pstatusCommit )
	{
	*pstatusCommit = *m_pstatusCommit;

	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrSetCommitStatus( const NTSTATUS statusCommit )
	{
	*m_pstatusCommit = statusCommit;
	
	m_fUpdateChecksum = fTrue;
	
	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrGetInstanceID( DWORD* const pdwInstanceID )
	{
	*pdwInstanceID = *m_pdwInstanceID;

	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrSetInstanceID( const DWORD dwInstanceID )
	{
	*m_pdwInstanceID = dwInstanceID;
	
	m_fUpdateChecksum = fTrue;
	
	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrGetOpenDeadline( TICK* const ptickOpenDeadline )
	{
	*ptickOpenDeadline = *m_ptickOpenDeadline;

	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrSetOpenDeadline( const TICK tickOpenDeadline )
	{
	*m_ptickOpenDeadline = tickOpenDeadline;
	
	m_fUpdateChecksum = fTrue;
	
	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrGetRunCount( DWORD* const pcrun )
	{
	*pcrun = m_pslist->NumFragments;

	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrGetFileSize( QWORD* const pcbSize )
	{
	*pcbSize = m_pslist->TotalBytes.QuadPart;

	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrSetFileSize( const QWORD cbSize )
	{
	m_pslist->TotalBytes.QuadPart = cbSize;
	
	m_fUpdateChecksum = fTrue;
	
	return JET_errSuccess;
	}
	
INLINE void CSLVFileInfo::MoveBeforeFirstRun()
	{
	m_irun	= -1;
	m_psle	= NULL;
	
	if ( m_fCloseCursor )
		{
		pfnIfsFinishCursor( &m_cursor );
		m_fCloseCursor = fFalse;
		}

	if ( ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) )
		{
		m_psle = PSCATTER_LIST_ENTRY( pfnIfsGetFirstCursor(	&m_buffer,
															&m_cursor,
															0,
															0,
															OSMemoryPageReserveGranularity(),
															fTrue ) );
		m_fCloseCursor = !!m_psle;
		}
	}
	
INLINE ERR CSLVFileInfo::ErrMoveNextRun()
	{
	m_irun++;
	
	if ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER )
		{
		if ( !m_fCloseCursor )
			{
			return ErrERRCheck( JET_errOutOfMemory );
			}

		if (	m_irun >= MAX_FRAGMENTS + 1 && m_irun <= m_pslist->NumFragments &&
				!( m_psle = PSCATTER_LIST_ENTRY( pfnIfsConsumeCursor( &m_cursor, sizeof( SCATTER_LIST_ENTRY ) ) ) ) &&
				!( m_psle = PSCATTER_LIST_ENTRY( pfnIfsGetNextCursor( &m_cursor, OSMemoryPageReserveGranularity() ) ) ) &&
				m_irun < m_pslist->NumFragments )
			{
			return ErrERRCheck( JET_errSLVEAListCorrupt );
			}
		}
		
	if ( m_irun >= m_pslist->NumFragments )
		{
		m_irun = m_pslist->NumFragments;
		return ErrERRCheck( JET_errNoCurrentRecord );
		}

	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrGetCurrentRun( CRun* const prun )
	{
	ERR					err		= JET_errSuccess;
	PSCATTER_LIST_ENTRY	psle	= NULL;
		
	if ( m_irun < 0 )
		{
		Assert( m_irun == -1 );
		}
	else if ( m_irun < MAX_FRAGMENTS )
		{
		psle = m_pslist->sle + m_irun;
		}
	else if ( m_irun < m_pslist->NumFragments )
		{
		if ( ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) )
			{
			psle = m_psle;
			}
		else
			{
			psle = PSCATTER_LIST_ENTRY( (BYTE*)m_pslist + m_pslist->OverflowOffset ) + m_irun - MAX_FRAGMENTS;
			}
		}
	else
		{
		Assert( m_irun == m_pslist->NumFragments );
		}

	if ( psle )
		{
		TRY
			{
			prun->m_ibLogical	= psle->Offset.QuadPart;
			prun->m_cbSize		= psle->Length;
			}
		EXCEPT( efaExecuteHandler )
			{
			err = ErrERRCheck( JET_errOutOfMemory );
			}
		ENDEXCEPT
		}
	else
		{
		err = ErrERRCheck( JET_errNoCurrentRecord );
		}

	return err;
	}
	
ERR CSLVFileInfo::ErrSetCurrentRun( const CRun& run )
	{
	ERR					err		= JET_errSuccess;
	PSCATTER_LIST_ENTRY	psle	= NULL;
	
	if ( m_irun == m_pslist->NumFragments )
		{
		//  get the change in size of the EA List

		size_t	cbslistNew	= _IbAlign( _SizeofScatterList( m_pslist->NumFragments + 1, ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) ) );
		size_t	cbslist		= _IbAlign( _SizeofScatterList( m_pslist->NumFragments, ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) ) );

		size_t	dcbffeainf	= cbslistNew - cbslist;

		//  make the cache large enough to hold the new EA List

		CallR( _ErrCheckCacheSize( m_cbffeainf + dcbffeainf ) );

		//  recompute the change in size of the EA List in case the scatter list
		//  was pushed into the large buffer format

		cbslistNew	= _IbAlign( _SizeofScatterList( m_pslist->NumFragments + 1, ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) ) );
		cbslist		= _IbAlign( _SizeofScatterList( m_pslist->NumFragments, ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) ) );

		dcbffeainf	= cbslistNew - cbslist;

		//  fix up the EA List pointers for the new scatter list

		PFILE_FULL_EA_INFORMATION pffeainf;
		pffeainf = m_pffeainf;
		pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );
		pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );
		pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );
		pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );
		pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );

		pffeainf->EaValueLength		= WORD( pffeainf->EaValueLength + dcbffeainf );
		m_cbffeainf					= m_cbffeainf + dcbffeainf;

		//  fix up the Scatter List to contain the new run

		m_pslist->NumFragments	= m_pslist->NumFragments + 1;
		m_cbslist				= _SizeofScatterList( m_pslist->NumFragments, ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) );

		//  fall through to the below cases to set the current run now that our
		//  currency is on an actual run
		}
	else if ( m_irun < 0 )
		{
		Assert( m_irun == -1 );
		}
	if ( m_irun < MAX_FRAGMENTS )
		{
		psle = m_pslist->sle + m_irun;
		}
	else
		{
		Assert( m_irun < m_pslist->NumFragments );
		
		if ( ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) )
			{
			psle = m_psle;
			}
		else
			{
			psle = PSCATTER_LIST_ENTRY( (BYTE*)m_pslist + m_pslist->OverflowOffset ) + m_irun - MAX_FRAGMENTS;
			}
		}

	if ( psle )
		{
		Assert( DWORD( run.m_cbSize ) == run.m_cbSize );
		
		TRY
			{
			psle->Offset.QuadPart	= run.m_ibLogical;
			psle->Length			= DWORD(run.m_cbSize );
			psle->ulReserved		= 0;
			}
		EXCEPT( efaExecuteHandler )
			{
			err = ErrERRCheck( JET_errOutOfMemory );
			}
		ENDEXCEPT

		m_fUpdateChecksum	= fTrue;
		m_fUpdateSlist		= m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER;
		}
	else
		{
		err = ErrERRCheck( JET_errNoCurrentRecord );
		}

	return err;
	}

INLINE BOOL CSLVFileInfo::FEAListIsSelfDescribing()
	{
	return FScatterListIsSelfDescribing();
	}

INLINE ERR CSLVFileInfo::ErrGetEAList( void** const ppv, size_t* const pcb )
	{
	if ( m_fUpdateSlist )
		{
		Assert(	m_irun == m_pslist->NumFragments - 1 ||
				m_irun == m_pslist->NumFragments );

		ERR err = ErrMoveNextRun();
		Assert( err == JET_errNoCurrentRecord );
				
		pfnIfsCopyBufferToReference(	&m_buffer,
										PIFS_LARGE_BUFFER( (BYTE*)m_pslist + m_pslist->OverflowOffset ) );

		m_fUpdateChecksum	= fTrue;
		m_fUpdateSlist		= fFalse;
		}
	
	if ( m_fUpdateChecksum )
		{
		*m_pdwChecksum = 0;
		*m_pdwChecksum = LOG::UlChecksumBytes(	(BYTE*)m_pffeainf,
												(BYTE*)m_pffeainf + m_cbffeainf,
												EXIFS_CHECKSUM_SEED );

		m_fUpdateChecksum = fFalse;
		}

	Assert( !LOG::UlChecksumBytes(	(BYTE*)m_pffeainf,
									(BYTE*)m_pffeainf + m_cbffeainf,
									EXIFS_CHECKSUM_SEED ) );
	
	*ppv = m_pffeainf;
	*pcb = m_cbffeainf;

	return JET_errSuccess;
	}

INLINE BOOL CSLVFileInfo::FScatterListIsSelfDescribing()
	{
	return !( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER );
	}

INLINE ERR CSLVFileInfo::ErrGetScatterList( void** const ppv, size_t* const pcb )
	{
	if ( m_fUpdateSlist )
		{
		Assert(	m_irun == m_pslist->NumFragments - 1 ||
				m_irun == m_pslist->NumFragments );

		ERR err = ErrMoveNextRun();
		Assert( err == JET_errNoCurrentRecord );
				
		pfnIfsCopyBufferToReference(	&m_buffer,
										PIFS_LARGE_BUFFER( (BYTE*)m_pslist + m_pslist->OverflowOffset ) );

		m_fUpdateChecksum	= fTrue;
		m_fUpdateSlist		= fFalse;
		}
	
	*ppv = m_pslist;
	*pcb = m_cbslist;

	return JET_errSuccess;
	}

INLINE DWORD_PTR CSLVFileInfo::_IbAlign( const DWORD_PTR ib )
	{
	return (ULONG_PTR)( ( ib + cbEAAlign - 1 ) & ( ( ~( (LONG_PTR)0 ) ) * cbEAAlign ) );
	}

INLINE void* CSLVFileInfo::_PvAlign( const void* const pv )
	{
	return (void*)_IbAlign( DWORD_PTR( pv ) );
	}

INLINE size_t CSLVFileInfo::_SizeofScatterList( const size_t crun, const BOOL fLarge )
	{
	return	sizeof( SCATTER_LIST ) +
			(	fLarge ?
				sizeof( IFS_LARGE_BUFFER ) :
				(	crun < MAX_FRAGMENTS ?
						0 :
						( crun - MAX_FRAGMENTS ) * sizeof( SCATTER_LIST_ENTRY ) ) );
	}

ERR CSLVFileInfo::_ErrCheckCacheSize( const size_t cbCacheNew )
	{
	ERR err = JET_errSuccess;
	
	//  the new EA List will overflow the buffer

	if ( cbCacheNew > m_cbCache )
		{
		//  we are already using an allocated cache
		
		if ( m_fFreeCache )
			{
			//  we are already using the large scatter list buffer

			if ( m_fCloseBuffer )
				{
				//  fail the change with OOM

				return ErrERRCheck( JET_errOutOfMemory );
				}

			//  we are not already using the large scatter list buffer

			else
				{
				//  create a new large buffer

				CallR( ErrOSSLVFileIGetLastError( pfnIfsCreateNewBuffer( &m_buffer, 0, 0, NULL ) ) );

				//  move all our extended runs into the large buffer

				if ( !( m_psle = PSCATTER_LIST_ENTRY( pfnIfsGetFirstCursor(	&m_buffer,
																			&m_cursor,
																			0,
																			0,
																			OSMemoryPageReserveGranularity(),
																			fTrue ) ) ) )
					{
					pfnIfsCloseBuffer( &m_buffer );
					return ErrERRCheck( JET_errOutOfMemory );
					}

				PSCATTER_LIST_ENTRY	psleSrc;
				LONG				irun;

				err		= JET_errSuccess;
				psleSrc	= PSCATTER_LIST_ENTRY( (BYTE*)m_pslist + m_pslist->OverflowOffset );
				
				for ( irun = MAX_FRAGMENTS; irun < m_pslist->NumFragments; irun++ )
					{
					Assert( !psleSrc->ulReserved );
					
					TRY
						{
						m_psle->Offset.QuadPart	= psleSrc->Offset.QuadPart;
						m_psle->Length			= psleSrc->Length;
						m_psle->ulReserved		= 0;
						}
					EXCEPT( efaExecuteHandler )
						{
						err = ErrERRCheck( JET_errOutOfMemory );
						}
					ENDEXCEPT

					psleSrc++;
					if (	!( m_psle = PSCATTER_LIST_ENTRY( pfnIfsConsumeCursor( &m_cursor, sizeof( SCATTER_LIST_ENTRY ) ) ) ) &&
							!( m_psle = PSCATTER_LIST_ENTRY( pfnIfsGetNextCursor( &m_cursor, OSMemoryPageReserveGranularity() ) ) ) )
						{
						err = ErrERRCheck( JET_errOutOfMemory );
						break;
						}
					}

				if ( err < JET_errSuccess )
					{
					m_psle = NULL;
					pfnIfsFinishCursor( &m_cursor );
					pfnIfsCloseBuffer( &m_buffer );
					return err;
					}

				//  fixup the EA List to account for the new large buffer format

				size_t dcbffeainf =	_SizeofScatterList( m_pslist->NumFragments, fTrue ) -
									_SizeofScatterList( m_pslist->NumFragments, fFalse );

				PFILE_FULL_EA_INFORMATION pffeainf;
				pffeainf = m_pffeainf;
				pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );
				pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );
				pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );
				pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );
				pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );

				pffeainf->EaValueLength		= WORD( pffeainf->EaValueLength + dcbffeainf );
				m_cbffeainf					= m_cbffeainf + dcbffeainf;
				
				//  fixup the Scatter List to use the new large buffer

				m_fCloseBuffer		= fTrue;
				m_fCloseCursor		= fTrue;
				m_pslist->Flags		= IFS_SLIST_FLAGS_LARGE_BUFFER;
				m_cbslist			= _SizeofScatterList( m_pslist->NumFragments, fTrue );

				m_fUpdateChecksum	= fTrue;
				m_fUpdateSlist		= fTrue;

				//  NOCODE:  move our cursor back to the current record
				//
				//  NOTE:  this will magically work for appending runs

				Assert( m_irun == m_pslist->NumFragments );
				}
			}

		//  we are not already using an allocated cache

		else
			{
			//  allocate a new cache

			BYTE* rgbCacheNew;
			if ( !( rgbCacheNew = (BYTE*)PvOSMemoryHeapAlloc( cbEAListMax ) ) )
				{
				return ErrERRCheck( JET_errOutOfMemory );
				}

			//  move our data to the new cache

			m_fFreeCache	= fTrue;
			m_rgbCache		= rgbCacheNew;
			m_cbCache		= cbEAListMax;

#ifdef DEBUG
			memset( m_rgbCache, 0xEA, m_cbCache );
#endif  //  DEBUG

			memcpy( m_rgbCache, m_pffeainf, m_cbffeainf );

			//  update all property pointers to point to the new cache

			DWORD_PTR dwOffset;
			dwOffset = DWORD_PTR( m_rgbCache ) - DWORD_PTR( m_pffeainf );

			m_pffeainf			= PFILE_FULL_EA_INFORMATION( DWORD_PTR( m_pffeainf ) + dwOffset );
			m_wszFileName		= (wchar_t*)( DWORD_PTR( m_wszFileName ) + dwOffset );
			m_pstatusCommit		= (NTSTATUS*)( DWORD_PTR( m_pstatusCommit ) + dwOffset );
			m_pdwInstanceID		= (DWORD*)( DWORD_PTR( m_pdwInstanceID ) + dwOffset );
			m_pdwChecksum		= (DWORD*)( DWORD_PTR( m_pdwChecksum ) + dwOffset );
			m_ptickOpenDeadline	= (TICK*)( DWORD_PTR( m_ptickOpenDeadline ) + dwOffset );
			m_pslist			= PSCATTER_LIST( DWORD_PTR( m_pslist ) + dwOffset );

			m_fUpdateChecksum	= fTrue;
			}
		}

	return JET_errSuccess;
	}


//  validates and converts the given SLV File Info into SLV Info

void OSSLVRootSpaceIConsume( SLVROOT slvroot, QWORD cbSize );

ERR ErrOSSLVFileIConvertSLVFileInfoToSLVInfo(	const SLVROOT		slvroot,
												CSLVFileInfo&		slvfileinfo,
												CSLVInfo* const		pslvinfo )
	{
	ERR					err				= JET_errSuccess;
	DWORD				crun;
	CSLVFileInfo::CRun	runSrc;
	size_t				cwchFileName;
	wchar_t*			wszFileName;
	QWORD				cbSize			= 0;
	CSLVInfo::HEADER	header;
	CSLVInfo::RUN		runDest;

	//  this SLV File has no runs

	Call( slvfileinfo.ErrGetRunCount( &crun ) );

	if ( !crun )
		{
		//  fail the conversion because we need at least one run per SLV File
		//  to provide us with its File ID

		Call( ErrERRCheck( JET_errSLVEAListZeroAllocation ) );
		}

	//  note the amount of reserved space we have successfully committed to the
	//  SLV Provider

	slvfileinfo.MoveBeforeFirstRun();
	while ( ( err = slvfileinfo.ErrMoveNextRun() ) >= JET_errSuccess )
		{
		Call( slvfileinfo.ErrGetCurrentRun( &runSrc ) );
		cbSize += runSrc.m_cbSize;
		}
	Call( err == JET_errNoCurrentRecord ? JET_errSuccess : err );
		
	OSSLVRootSpaceIConsume( slvroot, cbSize );

	//  set the file name for this SLV relative to the SLV Root

	Call( slvfileinfo.ErrGetFileName( &wszFileName, &cwchFileName ) );

#ifdef OSSLV_VOLATILE_FILENAMES
	Call( pslvinfo->ErrSetFileNameVolatile() );
#endif  //  OSSLV_VOLATILE_FILENAMES
	Call( pslvinfo->ErrSetFileName( wszFileName ) );

	//  copy over all the runs, concatenating any contiguous runs

	CallS( pslvinfo->ErrGetHeader( &header ) );
	Assert( !header.cbSize );
	Assert( !header.cRun );
	Call( slvfileinfo.ErrGetFileSize( &cbSize ) );
	header.cbSize = cbSize;

	memset( &runDest, 0, sizeof( runDest ) );

	slvfileinfo.MoveBeforeFirstRun();
	while ( ( err = slvfileinfo.ErrMoveNextRun() ) >= JET_errSuccess )
		{
		//  fetch the current source run
		
		Call( slvfileinfo.ErrGetCurrentRun( &runSrc ) );

		//  this run can be appended to the current destination run

		if ( runSrc.m_ibLogical == runDest.ibLogicalNext )
			{
			//  append the source run to the destination run
			
			runDest.ibVirtualNext	+= runSrc.m_cbSize;
			runDest.cbSize			+= runSrc.m_cbSize;
			runDest.ibLogicalNext	+= runSrc.m_cbSize;
			}

		//  this run cannot be appended to the current destination run

		else
			{
			//  save the current ending virtual offset in the SLV
			
			const QWORD ibVirtual = runDest.ibVirtualNext;

			//  save our changes to the current destination run

			if ( runDest.ibVirtualNext )
				{
				CallS( pslvinfo->ErrMoveAfterLast() );
				Call( pslvinfo->ErrSetCurrentRun( runDest ) );
				}

			//  add a run to the header

			header.cRun++;
			
			//  set the destination run to include the source run

			runDest.ibVirtualNext	= ibVirtual + runSrc.m_cbSize;
			runDest.ibLogical		= runSrc.m_ibLogical;
			runDest.qwReserved		= 0;
			runDest.ibVirtual		= ibVirtual;
			runDest.cbSize			= runSrc.m_cbSize;
			runDest.ibLogicalNext	= runSrc.m_ibLogical + runSrc.m_cbSize;
			}
		}
	Call( err == JET_errNoCurrentRecord ? JET_errSuccess : err );

	//  save our changes to the current destination run

	if ( runDest.ibVirtualNext )
		{
		CallS( pslvinfo->ErrMoveAfterLast() );
		Call( pslvinfo->ErrSetCurrentRun( runDest ) );
		}
	
	//  save our changes to the header

	CallS( pslvinfo->ErrSetHeader( header ) );

	//  there should be enough space to back this file

	if ( header.cbSize > cbSize )
		{
		AssertSzRTL( fFalse, "139131:  Entire SLV File is not backed by pages from the streaming file!" );
		Call( ErrERRCheck( JET_errSLVEAListCorrupt ) );
		}

	//  register this new SLV File with the SLV File Table

	Call( P_SLVROOT( slvroot )->pslvft->ErrCreate( pslvinfo ) );

	//  return the generated SLV Info

	return JET_errSuccess;

HandleError:
	return err;
	}

//  converts the given SLV Info into SLV File Info

ERR ErrOSSLVFileIConvertSLVInfoToSLVFileInfo(	const SLVROOT		slvroot,
												CSLVInfo&			slvinfo,
												CSLVFileInfo* const	pslvfileinfo,
												const BOOL			fSetOpenDeadline	= fFalse,
												const NTSTATUS		statusCommit		= STATUS_SUCCESS )
	{
	ERR					err							= JET_errSuccess;
	QWORD				cbSize						= 0;
	CSLVInfo::HEADER	header;
	CSLVInfo::RUN		runSrc;
	CSLVFileInfo::CRun	runDest;
	size_t				cwchFileName				= IFileSystemAPI::cchPathMax;
	wchar_t				wszFileName[ IFileSystemAPI::cchPathMax ];
	TICK				tickOpenDeadline;
	
	//  copy all runs
	//
	//  NOTE:  we do this before getting the open deadline as this can be costly!

	CallS( slvinfo.ErrMoveBeforeFirst() );
	while ( ( err = slvinfo.ErrMoveNext() ) >= JET_errSuccess )
		{
		Call( slvinfo.ErrGetCurrentRun( &runSrc ) );

		cbSize += runSrc.cbSize;

		const QWORD LengthMax = 0x80000000;
		QWORD ibRun;
		for ( ibRun = 0; ibRun < runSrc.cbSize; ibRun += LengthMax )
			{
			runDest.m_ibLogical	= runSrc.ibLogical + ibRun;
			runDest.m_cbSize	= min( LengthMax, runSrc.cbSize - ibRun );

			err = pslvfileinfo->ErrMoveNextRun();
			Assert( err == JET_errNoCurrentRecord );
			Call( pslvfileinfo->ErrSetCurrentRun( runDest ) );
			}
		}
	Call( err == JET_errNoCurrentRecord ? JET_errSuccess : err );
	
	//  get the current file name and the open deadline for this SLV File from
	//  the SLV File Table
	//
	//  NOTE:  only use the SLV File Table for normal SLV Files, i.e. ones that
	//  are opened for external use

	if ( statusCommit == STATUS_SUCCESS )
		{
		Call( P_SLVROOT( slvroot )->pslvft->ErrOpen(	&slvinfo,
														fSetOpenDeadline,
														&cwchFileName,
														wszFileName,
														&tickOpenDeadline ) );
		}
	else if ( statusCommit == EXSTATUS_SPACE_UNCOMMITTED )
		{
		cwchFileName		= 0;
		wszFileName[ 0 ]	= 0;
		tickOpenDeadline	= 0;
		}
	else
		{
		Call( slvinfo.ErrGetFileNameLength( &cwchFileName ) );
		if ( IFileSystemAPI::cchPathMax < cwchFileName )
			{
			Call( ErrERRCheck( JET_errSLVBufferTooSmall ) );
			}
		Call( slvinfo.ErrGetFileName( wszFileName ) );
		if ( fSetOpenDeadline )
			{
			tickOpenDeadline = TickOSTimeCurrent() + cmsecOSSLVTTL;
			}
		else
			{
			tickOpenDeadline = TickOSTimeCurrent() + cmsecOSSLVTTLInfinite;
			}
		}

	//  set all SLV File Info properties

	Call( pslvfileinfo->ErrSetFileName( wszFileName ) );
	
	Call( pslvfileinfo->ErrSetCommitStatus( statusCommit ) );
	
	Call( pslvfileinfo->ErrSetInstanceID( P_SLVROOT( slvroot )->dwInstanceID ) );
	
	Call( pslvfileinfo->ErrSetOpenDeadline( tickOpenDeadline ) );
	
	CallS( slvinfo.ErrGetHeader( &header ) );
	Call( pslvfileinfo->ErrSetFileSize( header.cbSize ) );

	//  there should be enough space to back this file

	if ( header.cbSize > cbSize )
		{
		AssertSzRTL( fFalse, "139131:  Entire SLV File is not backed by pages from the streaming file!" );
		Call( ErrERRCheck( JET_errSLVCorrupted ) );
		}

	//  return the generated SLV File Info

	err = JET_errSuccess;

HandleError:
	return err;
	}

//  validates and converts the given EA list into SLV Info

ERR ErrOSSLVFileConvertEAToSLVInfo(	const SLVROOT		slvroot,
									const void* const	pffeainf,
									const DWORD			cbffeainf,
									CSLVInfo* const		pslvinfo )
	{
	ERR				err			= JET_errSuccess;
	CSLVFileInfo	slvfileinfo;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  validate IN args

	Assert( slvroot != slvrootNil );
	Assert( pffeainf );
	Assert( cbffeainf );
	Assert( pslvinfo );

	//  load the given EA List into an SLV File Info iterator.  the iterator
	//  will validate the EA List on load

	Call( slvfileinfo.ErrLoad( pffeainf, cbffeainf ) );

	//  convert the SLV File Info into SLV Info

	Call( ErrOSSLVFileIConvertSLVFileInfoToSLVInfo( slvroot, slvfileinfo, pslvinfo ) );

	//  return the generated SLV Info

	slvfileinfo.Unload();
	return JET_errSuccess;

HandleError:
	slvfileinfo.Unload();
	return err;
	}

//  converts the given SLV Info into an EA list

ERR ErrOSSLVFileConvertSLVInfoToEA(	const SLVROOT	slvroot,
									CSLVInfo&		slvinfo,
									const DWORD		ibOffset,
									void* const		pffeainf,
									const DWORD		cbffeainfMax,
									DWORD* const	pcbffeainfActual )
	{
	ERR				err			= JET_errSuccess;
	CSLVFileInfo	slvfileinfo;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  create an empty SLV File Info to receive the converted data

	Call( slvfileinfo.ErrCreate() );

	//  convert the given SLV Info into SLV File Info, give the SLV File Info
	//  an expiration time, and enable copy-on-write

	Call( ErrOSSLVFileIConvertSLVInfoToSLVFileInfo(	slvroot,
													slvinfo,
													&slvfileinfo,
													fTrue ) );

	//  if we can't perform a simple copy of the EA List data into the user's
	//  buffer then fail the transfer with EA List too big.  this will force
	//  them to refetch the SLV File as a handle.  in that case, we will be
	//  able to handle the retrieval because we will still have the SLV File
	//  Info when the handle is created

	if ( !slvfileinfo.FEAListIsSelfDescribing() )
		{
		Call( ErrERRCheck( JET_errSLVEAListTooBig ) );
		}

	//  copy the requested chunk of the EA List into the user's buffer according
	//  to JetRetrieveColumn() rules for LVs

	size_t	cbffeainfBuf;
	void*	pffeainfBuf;
	Call( slvfileinfo.ErrGetEAList( &pffeainfBuf, &cbffeainfBuf ) );

	if ( ibOffset > cbffeainfBuf )
		{
		if ( pcbffeainfActual )
			{
			*pcbffeainfActual = 0;
			}
		}
	else
		{
		if ( pcbffeainfActual )
			{
			*pcbffeainfActual = DWORD( cbffeainfBuf - ibOffset );
			}
		if ( cbffeainfBuf - ibOffset > cbffeainfMax )
			{
			err = ErrERRCheck( JET_wrnBufferTruncated );
			}

		if ( pffeainfBuf != pffeainf )
			{
			UtilMemCpy(	pffeainf,
						(BYTE*)pffeainfBuf + ibOffset,
						min( cbffeainfMax, cbffeainfBuf - ibOffset ) );
			}
		else
			{
			Assert( !ibOffset );
			}
		}

HandleError:
	slvfileinfo.Unload();
	return err;
	}

//  converts the given SLV Info into an SLV File

ERR ErrOSSLVFileConvertSLVInfoToFile(	const SLVROOT	slvroot,
										CSLVInfo&		slvinfo,
										const DWORD		ibOffset,
										void* const		pfile,
										const DWORD		cbfileMax,
										DWORD* const	pcbfileActual )
	{
	ERR				err			= JET_errSuccess;
	CSLVFileInfo	slvfileinfo;
	size_t			cwchRelPath;
	wchar_t*		wszRelPath;
	size_t			cbffeainf;
	void*			pffeainf;
	WCHAR			wszAbsPath[ IFileSystemAPI::cchPathMax ];
	HANDLE			hFile		= INVALID_HANDLE_VALUE;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  validate the input buffer

	if ( ibOffset || !pfile || cbfileMax < sizeof( HANDLE ) )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	//  create an empty SLV File Info to receive the converted data

	Call( slvfileinfo.ErrCreate() );

	//  convert the given SLV Info into SLV File Info, give the SLV File Info
	//  no expiration time, and enable copy-on-write

	Call( ErrOSSLVFileIConvertSLVInfoToSLVFileInfo(	slvroot,
													slvinfo,
													&slvfileinfo ) );

	//  get the file name and EA List for this SLV File

	Call( slvfileinfo.ErrGetFileName( &wszRelPath, &cwchRelPath ) );
	Call( slvfileinfo.ErrGetEAList( &pffeainf, &cbffeainf ) );

	//  get the absolute path for the file to create

	wcscpy( wszAbsPath, P_SLVROOT( slvroot )->wszRootName );
	wcscat( wszAbsPath, L"\\" );
	wcscat( wszAbsPath, wszRelPath );

	//  create the file handle from the EA List
	
	hFile = pfnIfsCreateFile(	wszAbsPath,
								GENERIC_READ,
								FILE_SHARE_READ | FILE_SHARE_WRITE,
								NULL,
								OPEN_ALWAYS,
								(	FILE_ATTRIBUTE_NORMAL |
									FILE_FLAG_WRITE_THROUGH |
									FILE_FLAG_OVERLAPPED ), 
								(PVOID) pffeainf,
								cbffeainf );
	if ( hFile == INVALID_HANDLE_VALUE )
		{
		Call( ErrOSSLVFileIGetLastError() );
		}

	//  return the file handle

	memcpy( (BYTE*)pfile, (BYTE*)&hFile, sizeof( HANDLE ) );
	if ( pcbfileActual )
		{
		*pcbfileActual = sizeof( HANDLE );
		}
	hFile = INVALID_HANDLE_VALUE;

HandleError:
	if ( hFile != INVALID_HANDLE_VALUE )
		{
		CloseHandle( hFile );
		}
	slvfileinfo.Unload();
	return err;
	}


//	WARNING!!	This function may allocate a new buffer if the one passed in
//				is not large enough.
INLINE ERR ErrOSSLVFileIQueryEaFile(
	const SLVROOT	slvroot,
	IFileAPI* const pfapi,
	BYTE**			pEaOutBuffer,
	DWORD			EaOutLength,
	DWORD*			pActualLength,
	const BOOL		fCommit )
	{
	ERR				err;
	COSFile* const	posf				= (COSFile*)pfapi;
	BYTE*			EaOutBuffer			= *pEaOutBuffer;
	DWORD			RequiredLength		= 0;
	UINT			cAttempts			= 0;

	forever
		{
		err = JET_errSuccess;

		//	this loop should converge pretty quickly
		AssertRTL( ++cAttempts < 10 );

#ifdef DEBUG
		memset( EaOutBuffer, 0xEA, EaOutLength );
#endif

		if ( !pfnIfsQueryEaFile(
					posf->Handle(),
					NULL,
					P_SLVROOT( slvroot )->wszRootName,
					( fCommit ? &P_SLVROOT( slvroot )->fgeainf : NULL ),
					( fCommit ? P_SLVROOT( slvroot )->cbfgeainf : 0 ),
					EaOutBuffer,
					EaOutLength,
					&RequiredLength ) )
			{
			err = ErrOSSLVFileIGetLastError();
			}

		if ( err >= JET_errSuccess )	//	not expecting any warnings, but better to be safe than sorry
			{
			CallS( err );
			break;
			}

		//	free current buffer (after which we will either retry or err out)
		if ( EaOutBuffer != *pEaOutBuffer )
			{
			OSMemoryHeapFree( EaOutBuffer );
			}

		if ( JET_errSLVBufferTooSmall == err )
			{
			//  Allocate a larger buffer and try again.
			//	We add a fudge factor to the new buffer size for two reasons:
			//		1) In case the EA list changes between the previous call to
			//		   QueryEAFile() and the next one
			//		2) BUGFIX #151178: size returned by previous call to QueryEAFile
			//		   may not be accurate
			EaOutLength = RequiredLength * 3 / 2 ;
			if ( !( EaOutBuffer = (BYTE*)PvOSMemoryHeapAlloc( EaOutLength ) ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			}
		else
			{
			//	on any other error (warnings not expected), bail out
			Assert( err < 0 );
			goto HandleError;
			}
		}

	CallS( err );
	*pEaOutBuffer = EaOutBuffer;
	*pActualLength = RequiredLength;

HandleError:
	return err;
	}

ERR ErrOSSLVFileIGetSLVInfo(	const SLVROOT		slvroot,
								IFileAPI* const		pfapi,
								CSLVInfo* const		pslvinfo )
	{
	ERR				err					= JET_errSuccess;
	COSFile* const	posf				= (COSFile*)pfapi;
	const DWORD		_EaOutLength		= 1024;
	QWORD			_AlignedEaOutBuffer[ _EaOutLength / sizeof( QWORD ) + 1 ];
	BYTE*			_EaOutBuffer		= (BYTE*)PvOSSLVQwordAlign( _AlignedEaOutBuffer );
	BYTE*			EaOutBuffer			= _EaOutBuffer;
	DWORD			ActualLength		= 0;
	CSLVFileInfo	slvfileinfo;

	//  try to fetch EA list with a buffer large enough to catch most cases

	Call( ErrOSSLVFileIQueryEaFile(
					slvroot,
					pfapi,
					&EaOutBuffer,
					_EaOutLength,
					&ActualLength,
					fTrue ) );

	//  load the given EA List into an SLV File Info iterator.  the iterator
	//  will validate the EA List on load

	Call( slvfileinfo.ErrLoad( EaOutBuffer, ActualLength ) );

	//  convert the SLV File Info into SLV Info

	Call( ErrOSSLVFileIConvertSLVFileInfoToSLVInfo( slvroot, slvfileinfo, pslvinfo ) );

HandleError:
	if ( EaOutBuffer != _EaOutBuffer )	
		{
		OSMemoryHeapFree( EaOutBuffer );
		}
	slvfileinfo.Unload();
	return err;
	}

ERR ErrOSSLVFileIGetEAFileName(	const SLVROOT		slvroot,
								IFileAPI* const		pfapi,
								wchar_t* const		wszFileName )
	{
	ERR				err					= JET_errSuccess;
	COSFile* const	posf				= (COSFile*)pfapi;
	const DWORD		_EaOutLength		= 1024;
	QWORD			_AlignedEaOutBuffer[ _EaOutLength / sizeof( QWORD ) + 1 ];
	BYTE*			_EaOutBuffer		= (BYTE*)PvOSSLVQwordAlign( _AlignedEaOutBuffer );
	BYTE*			EaOutBuffer			= _EaOutBuffer;
	DWORD			ActualLength		= 0;
	CSLVFileInfo	slvfileinfo;
	wchar_t*		wszEAFileName		= NULL;
	size_t			cwchEAFileName		= 0;

	//  try to fetch EA list with a buffer large enough to catch most cases

	Call( ErrOSSLVFileIQueryEaFile(
					slvroot,
					pfapi,
					&EaOutBuffer,
					_EaOutLength,
					&ActualLength,
					fFalse ) );

	//  load the given EA List into an SLV File Info iterator.  the iterator
	//  will validate the EA List on load

	Call( slvfileinfo.ErrLoad( EaOutBuffer, ActualLength, fFalse ) );

	//  retrieve the EA filename

	Call( slvfileinfo.ErrGetFileName( &wszEAFileName, &cwchEAFileName ) );
	wcscpy( wszFileName, wszEAFileName );

HandleError:
	if ( EaOutBuffer != _EaOutBuffer )	
		{
		OSMemoryHeapFree( EaOutBuffer );
		}
	slvfileinfo.Unload();
	return err;
	}

//  retrieves the SLV Info of the specified SLV file into the given buffer.
//  any space returned will be considered reserved by the SLV Provider.  this
//  space must be committed via ErrOSSLVRootSpaceCommit() or it will eventually
//  be freed when it is safe via the PSLVROOT_SPACEFREE callback

ERR ErrOSSLVFileGetSLVInfo(	const SLVROOT		slvroot,
							IFileAPI* const		pfapi,
							CSLVInfo* const		pslvinfo )
	{
	ERR					err			= JET_errSuccess;
	static long			cSpace		= 0;
	wchar_t				wszSpace[ IFileSystemAPI::cchPathMax ];
	IFileAPI*			pfapiSpace	= NULL;
	CSLVInfo::HEADER	header;
	wchar_t				wszFileName[ IFileSystemAPI::cchPathMax ];

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  try to get the SLV Info for the specified SLV File

	err = ErrOSSLVFileIGetSLVInfo( slvroot, pfapi, pslvinfo );

	//  we couldn't get the SLV Info because this file has no allocated space

	if ( err == JET_errSLVEAListZeroAllocation )
		{
		//  get the EA filename for this SLV File

		Call( ErrOSSLVFileIGetEAFileName( slvroot, pfapi, wszFileName ) );
		
		//  create a SLV File with the minimum amount of space

		swprintf( wszSpace, L"$Space%08X$", AtomicIncrement( &cSpace ) );
		Call( ErrOSSLVFileCreate( slvroot, wszSpace, SLVPAGE_SIZE, &pfapiSpace ) );

		//  get the SLV Info for the temporary SLV File
		
		Call( ErrOSSLVFileIGetSLVInfo( slvroot, pfapiSpace, pslvinfo ) );

		//  change the temporary SLV File to be a zero-length SLV File to
		//  match the original SLV File
		
		CallS( pslvinfo->ErrGetHeader( &header ) );
		header.cbSize = 0;
		CallS( pslvinfo->ErrSetHeader( header ) );

		//  rename the zero-length SLV File to the EA filename of the original
		//  SLV File in the SLV File Table to associate its space with the
		//  original SLV File

		Call( P_SLVROOT( slvroot )->pslvft->ErrRename( pslvinfo, wszFileName ) );

		//  set the filename in the SLV Info for the zero-length SLV File to
		//  the EA filename of the original SLV File and return that as the
		//  SLV Info for the original SLV File
		
		Call( pslvinfo->ErrSetFileName( wszFileName ) );
		}

	//  if we failed to retrieve the SLV Info, fail the operation

	Call( err );

HandleError:
	delete pfapiSpace;
	return err;
	}

//  creates a new SLV file with the specified path relative to the specified
//  SLV root and returns its handle.  if the file cannot be created,
//  JET_errSLVFileAccessDenied will be returned

ERR ErrOSSLVFileCreate(	const SLVROOT			slvroot,
						const wchar_t* const	wszRelPath,
						const QWORD				cbFileSize,
						IFileAPI** const		ppfapi,
						const BOOL				fCache )
	{
	ERR			err			= JET_errSuccess;
	COSFile*	posf		= NULL;
	WCHAR		wszAbsPath[ IFileSystemAPI::cchPathMax ];
	_TCHAR		szAbsPath[ IFileSystemAPI::cchPathMax ];
	HANDLE		hFile		= INVALID_HANDLE_VALUE;
	DWORD		cbIOSize;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  allocate the file object
	
	if ( !( posf = new COSFile ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  get the absolute path for the file to create

	wcscpy( wszAbsPath, P_SLVROOT( slvroot )->wszRootName );
	wcscat( wszAbsPath, L"\\" );
	wcscat( wszAbsPath, wszRelPath );

	Call( ErrOSSTRUnicodeToTchar( wszAbsPath, szAbsPath, IFileSystemAPI::cchPathMax ) );

	//  create the file, passing an empty EA List to the SLV Provider to indicate
	//  that this is a new SLV file
	
	hFile = pfnIfsCreateFile(	wszAbsPath,
								GENERIC_READ | GENERIC_WRITE, 
								FILE_SHARE_READ | FILE_SHARE_WRITE,
								NULL,
								CREATE_NEW,
								(	FILE_ATTRIBUTE_NORMAL |
									FILE_FLAG_WRITE_THROUGH |
									( fCache ? FILE_FLAG_SEQUENTIAL_SCAN : FILE_FLAG_NO_BUFFERING ) |
									FILE_FLAG_OVERLAPPED ), 
								NULL,
								0 );
	if ( hFile == INVALID_HANDLE_VALUE )
		{
		Call( ErrOSSLVFileIGetLastError() );
		}

	SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	//  set the initial file size.  this will force the SLV Provider to allocate
	//  enough space to back the file.  it is optimal to do it this way because
	//  we do not want to set the file size via the file object because the file
	//  object will zero the new offset range in the file

	if ( cbFileSize > 0 )
		{
		DWORD	cbSizeLow	= DWORD( cbFileSize );
		DWORD	cbSizeHigh	= DWORD( cbFileSize >> 32 );
		
		if (	(	SetFilePointer(	hFile,
									cbSizeLow,
									(long*)&cbSizeHigh,
									FILE_BEGIN ) == INVALID_SET_FILE_POINTER &&
					GetLastError() != NO_ERROR ) ||
				!SetEndOfFile( hFile ) )
			{
			Call( ErrOSSLVFileIGetLastError() );
			}
		}

	//  get the file I/O size

	if ( fCache )
		{
		cbIOSize = 1;
		}
	else
		{
		Call( P_SLVROOT( slvroot )->pfapiBackingFile->ErrIOSize( &cbIOSize ) );
		}

	//  initialize the file object

	Call( posf->ErrInit( szAbsPath, hFile, cbFileSize, fFalse, cbIOSize ) );
	hFile = INVALID_HANDLE_VALUE;

	//  return the interface to our file object

	*ppfapi = posf;
	return JET_errSuccess;

HandleError:
	if ( hFile != INVALID_HANDLE_VALUE )
		{
		SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hFile );
		}
	delete posf;
	*ppfapi = NULL;
	return err;
	}

//  opens the SLV file corresponding to the given SLV Info with the specified
//  access privileges and returns its handle.  if the file cannot be opened,
//  JET_errSLVFileAccessDenied is returned

ERR ErrOSSLVFileOpen(	const SLVROOT		slvroot,
						CSLVInfo&			slvinfo,
						IFileAPI** const	ppfapi,
						const BOOL			fCache,
						const BOOL			fReadOnly )
	{
	ERR				err			= JET_errSuccess;
	CSLVFileInfo	slvfileinfo;
	size_t			cwchRelPath;
	wchar_t*		wszRelPath;
	size_t			cbffeainf;
	void*			pffeainf;
	COSFile*		posf		= NULL;
	WCHAR			wszAbsPath[ IFileSystemAPI::cchPathMax ];
	_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
	HANDLE			hFile		= INVALID_HANDLE_VALUE;
	QWORD			cbFileSize;
	DWORD			cbIOSize;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  allocate the file object
	
	if ( !( posf = new COSFile ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  create an empty SLV File Info to receive the converted data

	Call( slvfileinfo.ErrCreate() );

	//  convert the given SLV Info into SLV File Info, give the SLV File Info
	//  no expiration time, and disable copy-on-write

	Call( ErrOSSLVFileIConvertSLVInfoToSLVFileInfo(	slvroot,
													slvinfo,
													&slvfileinfo,
													fFalse,
													EXSTATUS_PRIVILEGED_HANDLE ) );

	//  get the file name and EA List for this SLV File

	Call( slvfileinfo.ErrGetFileName( &wszRelPath, &cwchRelPath ) );
	Call( slvfileinfo.ErrGetEAList( &pffeainf, &cbffeainf ) );

	//  get the absolute path for the file to create

	wcscpy( wszAbsPath, P_SLVROOT( slvroot )->wszRootName );
	wcscat( wszAbsPath, L"\\" );
	wcscat( wszAbsPath, wszRelPath );

	Call( ErrOSSTRUnicodeToTchar( wszAbsPath, szAbsPath, IFileSystemAPI::cchPathMax ) );

	//  create the file, passing the generated EA List to the SLV Provider
	
	hFile = pfnIfsCreateFile(	wszAbsPath,
								GENERIC_READ | ( fReadOnly ? 0 : GENERIC_WRITE ),
								FILE_SHARE_READ | FILE_SHARE_WRITE,
								NULL,
								OPEN_ALWAYS,
								(	FILE_ATTRIBUTE_NORMAL |
									FILE_FLAG_WRITE_THROUGH |
									( fCache ? FILE_FLAG_SEQUENTIAL_SCAN : FILE_FLAG_NO_BUFFERING ) |
									FILE_FLAG_OVERLAPPED ), 
								(PVOID) pffeainf,
								cbffeainf );
	if ( hFile == INVALID_HANDLE_VALUE )
		{
		Call( ErrOSSLVFileIGetLastError() );
		}

	SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	//  get the file size

	Call( slvfileinfo.ErrGetFileSize( &cbFileSize ) );

	//  get the file I/O size

	if ( fCache )
		{
		cbIOSize = 1;
		}
	else
		{
		Call( P_SLVROOT( slvroot )->pfapiBackingFile->ErrIOSize( &cbIOSize ) );
		}

	//  initialize the file object

	Call( posf->ErrInit( szAbsPath, hFile, cbFileSize, fFalse, cbIOSize ) );
	hFile = INVALID_HANDLE_VALUE;

	//  return the interface to our file object

	*ppfapi = posf;
	slvfileinfo.Unload();
	return JET_errSuccess;

HandleError:
	if ( hFile != INVALID_HANDLE_VALUE )
		{
		SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hFile );
		}
	delete posf;
	*ppfapi = NULL;
	slvfileinfo.Unload();
	return err;
	}

ERR ErrOSSLVFileOpen(	const SLVROOT		slvroot,
						const void* const	pfile,
						const size_t		cbfile,
						IFileAPI** const	ppfapi,
						const BOOL			fReadOnly )
	{
	ERR			err					= JET_errSuccess;
	COSFile*	posf				= NULL;
	WCHAR		wszAbsPath[ IFileSystemAPI::cchPathMax ];
	_TCHAR		szAbsPath[ IFileSystemAPI::cchPathMax ];
	HANDLE		hFileSrc			= INVALID_HANDLE_VALUE;
	HANDLE		hFile				= INVALID_HANDLE_VALUE;
	DWORD		cbFileSizeLow;
	DWORD		cbFileSizeHigh;
	QWORD		cbFileSize;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  get the source file handle from the input buffer

	if ( !pfile || cbfile != sizeof( HANDLE ) )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	memcpy( (BYTE*)&hFileSrc, pfile, sizeof( HANDLE ) );

	//  allocate the file object
	
	if ( !( posf = new COSFile ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  get the absolute path for the file to create
	//
	//  NOTE:  we actually don't know this so make one up

	wcscpy( wszAbsPath, P_SLVROOT( slvroot )->wszRootName );
	wcscat( wszAbsPath, L"\\" );
	wcscat( wszAbsPath, L"$Unknown$" );

	Call( ErrOSSTRUnicodeToTchar( wszAbsPath, szAbsPath, IFileSystemAPI::cchPathMax ) );

	//  duplicate the file handle to preserve open / close semantics

	if ( !DuplicateHandle(	GetCurrentProcess(),
							hFileSrc,
							GetCurrentProcess(),
							&hFile,
							GENERIC_READ | ( fReadOnly ? 0 : GENERIC_WRITE ),
							FALSE,
							0 ) )
		{
		hFile = INVALID_HANDLE_VALUE;
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	//  get the file size and attributes

	if (	( cbFileSizeLow = GetFileSize(	hFile,
											&cbFileSizeHigh ) ) == -1 &&
			GetLastError() != NO_ERROR )
		{
		Call( ErrERRCheck( ErrOSSLVFileIGetLastError() ) );
		}
	cbFileSize	= ( QWORD( cbFileSizeHigh ) << 32 ) + cbFileSizeLow;

	//  initialize the file object

	err = posf->ErrInit( szAbsPath, hFile, cbFileSize, fReadOnly );

	//  we successfully inited the file object

	if ( err >= JET_errSuccess )
		{
		//  the file object owns the handle now
		
		hFile = INVALID_HANDLE_VALUE;
		}

	//  we failed to init the file object

	else
		{
		//  we will guess that the init failed because the file was already
		//  associated with a completion port.  we will try again with a new
		//  file handle that we get by doing a relative open on the existing
		//  file handle (required as we don't know its file name)

		if ( fUseRelativeOpen )
			{
			SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
			CloseHandle( hFile );
			hFile = INVALID_HANDLE_VALUE;
			
			delete posf;  //  remember, we cannot reuse the file object!!!
			posf = NULL;

			if ( !( posf = new COSFile ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}

			UNICODE_STRING FileName;
		    pfnRtlInitUnicodeString( &FileName, L"" );
		    
			OBJECT_ATTRIBUTES ObjectAttributes;
		    InitializeObjectAttributes(	&ObjectAttributes,
									    &FileName,
									    OBJ_CASE_INSENSITIVE,
									    hFileSrc,
									    NULL );

			IO_STATUS_BLOCK IoStatusBlock;
			NTSTATUS Status;
		    Status = pfnNtCreateFile(	&hFile,
										GENERIC_READ | ( fReadOnly ? 0 : GENERIC_WRITE ),
										&ObjectAttributes,
										&IoStatusBlock,
										NULL,
										FILE_ATTRIBUTE_NORMAL,
										FILE_SHARE_READ | FILE_SHARE_WRITE,
										FILE_OPEN,
										FILE_WRITE_THROUGH | FILE_SEQUENTIAL_ONLY,
										NULL,
										0 );

			if ( !NT_SUCCESS( Status ) )
				{
				Call( ErrOSSLVFileINTStatus( Status ) );
				}

			SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

			if (	( cbFileSizeLow = GetFileSize(	hFile,
													&cbFileSizeHigh ) ) == -1 &&
					GetLastError() != NO_ERROR )
				{
				Call( ErrERRCheck( ErrOSSLVFileIGetLastError() ) );
				}
			cbFileSize	= ( QWORD( cbFileSizeHigh ) << 32 ) + cbFileSizeLow;

			Call( posf->ErrInit( szAbsPath, hFile, cbFileSize, fReadOnly ) );
			hFile = INVALID_HANDLE_VALUE;
			}

		//  we cannot use relative open to resolve this error so fail

		else
			{
			Call( err );
			}
		}

	//  return the interface to our file object

	*ppfapi = posf;
	return JET_errSuccess;

HandleError:
	if ( hFile != INVALID_HANDLE_VALUE )
		{
		SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hFile );
		}
	delete posf;
	*ppfapi = NULL;
	return err;
	}

//  logically copies the contents of one SLV File to another SLV File.  the
//  contents are tracked using the specified unique identifier

ERR ErrOSSLVRootCopyFile(	const SLVROOT	slvroot,
							IFileAPI* const	pfapiSrc,
							CSLVInfo&		slvinfoSrc,
							IFileAPI* const	pfapiDest,
							CSLVInfo&		slvinfoDest,
							const QWORD		idContents )
	{
	ERR				err			= JET_errSuccess;
	CSLVFileInfo	slvfileinfo;
	size_t			cwchRelPath;
	wchar_t*		wszRelPath;
	size_t			cbffeainf;
	void*			pffeainf;
	WCHAR			wszAbsPath[ IFileSystemAPI::cchPathMax ];
	COSFile* const	posfDest	= (COSFile*)pfapiDest;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  perform the logical copy via the SLV File Table

	Call( P_SLVROOT( slvroot )->pslvft->ErrCopy( &slvinfoSrc, &slvinfoDest, idContents ) );

	//  create an empty SLV File Info to receive the converted data

	Call( slvfileinfo.ErrCreate() );

	//  convert the given SLV Info into SLV File Info, give the SLV File Info
	//  no expiration time, and enable copy-on-write

	Call( ErrOSSLVFileIConvertSLVInfoToSLVFileInfo(	slvroot,
													slvinfoDest,
													&slvfileinfo ) );

	//  get the file name and EA List for this SLV File

	Call( slvfileinfo.ErrGetFileName( &wszRelPath, &cwchRelPath ) );
	Call( slvfileinfo.ErrGetEAList( &pffeainf, &cbffeainf ) );

	//  get the absolute path for the file

	wcscpy( wszAbsPath, P_SLVROOT( slvroot )->wszRootName );
	wcscat( wszAbsPath, L"\\" );
	wcscat( wszAbsPath, wszRelPath );

	//  notify the SLV Provider of the copy

	if ( !pfnIfsFlushHandle(	posfDest->Handle(),
								wszAbsPath,
								P_SLVROOT( slvroot )->wszRootName,
								pffeainf,
								DWORD( cbffeainf ) ) )
		{
		Call( ErrOSSLVFileIGetLastError() );
		}

HandleError:
	slvfileinfo.Unload();
	return err;
	}

//  logically moves the contents of one SLV File to another SLV File.  the
//  contents are tracked using the specified unique identifier

ERR ErrOSSLVRootMoveFile(	const SLVROOT	slvroot,
							IFileAPI* const	pfapiSrc,
							CSLVInfo&		slvinfoSrc,
							IFileAPI* const	pfapiDest,
							CSLVInfo&		slvinfoDest,
							const QWORD		idContents )
	{
	ERR				err			= JET_errSuccess;
	CSLVFileInfo	slvfileinfo;
	size_t			cwchRelPath;
	wchar_t*		wszRelPath;
	size_t			cbffeainf;
	void*			pffeainf;
	WCHAR			wszAbsPath[ IFileSystemAPI::cchPathMax ];
	COSFile* const	posfDest	= (COSFile*)pfapiDest;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  perform the logical move via the SLV File Table

	Call( P_SLVROOT( slvroot )->pslvft->ErrMove( &slvinfoSrc, &slvinfoDest, idContents ) );

	//  create an empty SLV File Info to receive the converted data

	Call( slvfileinfo.ErrCreate() );

	//  convert the given SLV Info into SLV File Info, give the SLV File Info
	//  no expiration time, and enable copy-on-write

	Call( ErrOSSLVFileIConvertSLVInfoToSLVFileInfo(	slvroot,
													slvinfoDest,
													&slvfileinfo ) );

	//  get the file name and EA List for this SLV File

	Call( slvfileinfo.ErrGetFileName( &wszRelPath, &cwchRelPath ) );
	Call( slvfileinfo.ErrGetEAList( &pffeainf, &cbffeainf ) );

	//  get the absolute path for the file

	wcscpy( wszAbsPath, P_SLVROOT( slvroot )->wszRootName );
	wcscat( wszAbsPath, L"\\" );
	wcscat( wszAbsPath, wszRelPath );

	//  notify the SLV Provider of the move

	if ( !pfnIfsFlushHandle(	posfDest->Handle(),
								wszAbsPath,
								P_SLVROOT( slvroot )->wszRootName,
								pffeainf,
								DWORD( cbffeainf ) ) )
		{
		Call( ErrOSSLVFileIGetLastError() );
		}

HandleError:
	slvfileinfo.Unload();
	return err;
	}

//  callback indicating that the current layout changes to the backing file
//  have ended and that the root map needs to be updated

void OSSLVRootSpaceIEndRemap( IFileAPI* const pfapi, const SLVROOT slvroot )
	{
	ERR					err			= JET_errSuccess;
	CSLVFileInfo		slvfileinfo;
	IFileLayoutAPI*		pflapi		= NULL;
	size_t				cbslist;
	SCATTER_LIST*		pslist;

	//  create an empty SLV File Info to receive the converted data

	Call( slvfileinfo.ErrCreate() );

	//  fill the SLV File Info with the layout of the backing file

	Call( pfapi->ErrQueryLayout( 0, -1, &pflapi ) );
	while ( ( err = pflapi->ErrNext() ) >= JET_errSuccess )
		{
		QWORD				ibVirtual;
		QWORD				cbVirtualSize;
		QWORD				ibLogical;
		QWORD				cbLogicalSize;
		QWORD				ibRun;
		const QWORD			LengthMax	= 0x80000000;
		CSLVFileInfo::CRun	runDest;
		
		Call( pflapi->ErrVirtualOffsetRange( &ibVirtual, &cbVirtualSize ) );
		Call( pflapi->ErrLogicalOffsetRange( &ibLogical, &cbLogicalSize ) );

		if ( cbVirtualSize != cbLogicalSize && cbLogicalSize != 0 )
			{
			Call( ErrERRCheck( JET_errSLVCorrupted ) );
			}

		for ( ibRun = 0; ibRun < cbVirtualSize; ibRun += LengthMax )
			{
			runDest.m_ibLogical	= (	cbLogicalSize ?
										ibLogical + ibRun :
										0xABAD1DEA00000000 );
			runDest.m_cbSize	= min( LengthMax, cbVirtualSize - ibRun );

			err = slvfileinfo.ErrMoveNextRun();
			Assert( err == JET_errNoCurrentRecord );
			Call( slvfileinfo.ErrSetCurrentRun( runDest ) );
			}
		}
	Call( err == JET_errNoCurrentRecord ? JET_errSuccess : err );

	delete pflapi;
	pflapi = NULL;

	//  get the Scatter List for the backing file for this root
	
	Call( slvfileinfo.ErrGetScatterList( (void**)&pslist, &cbslist ) );

	//  send the backing file layout to the SLV Provider and unfreeze I/O to
	//  the backing file

	if ( !pfnIfsSetRootMap(	P_SLVROOT( slvroot )->hFileRoot,
							P_SLVROOT( slvroot )->wszRootName,
							pslist,
							cbslist ) )
		{
		Call( ErrOSSLVRootIGetLastError() );
		}

HandleError:
	//  UNDONE:  what do we do on an error?
	slvfileinfo.Unload();
	delete pflapi;
	}

//  callback indicating that the current layout of the backing file is about
//  to change

void OSSLVRootSpaceIBeginRemap( IFileAPI* const pfapi, const SLVROOT slvroot )
	{
	ERR err = JET_errSuccess;
	
	//  freeze I/O to the backing file and invalidate its layout

	if ( !pfnIfsResetRootMap(	P_SLVROOT( slvroot )->hFileRoot,
								P_SLVROOT( slvroot )->wszRootName ) )
		{
		Call( ErrOSSLVRootIGetLastError() );
		}

HandleError:
	//  UNDONE:  what do we do on an error?
	;
	}

//  issues a space request from the SLV Provider

void WINAPI OSSLVRootSpaceIRequest( SLVROOT slvroot )
	{
	//  BUGBUG:  the SLV Provider should specify the amount of space requested

	const QWORD cbReserve = cbOSSLVReserve;
	
	//  we are not terminating the space request loop

	if ( !P_SLVROOT( slvroot )->msigTerm.FTryWait() )
		{
		//  we do not already have a space request pending

		if ( P_SLVROOT( slvroot )->semSpaceReq.FTryAcquire() )
			{
			//  allow one space request completion to match this space request

			P_SLVROOT( slvroot )->semSpaceReqComp.Release();
			
			//  fire the space request callback

			P_SLVROOT( slvroot )->pfnSpaceReq(	P_SLVROOT( slvroot )->dwSpaceReqKey,
												cbReserve );
			}
		}

	//  we are terminating the space request loop

	else
		{
		//  signal that the space request loop has stopped

		P_SLVROOT( slvroot )->msigTermAck.Set();
		}
	}

//  completes a space request from the SLV Provider

void OSSLVRootSpaceIRequestComplete( SLVROOT slvroot )
	{
	//  we are not terming the SLV Root

	if ( !P_SLVROOT( slvroot )->msigTerm.FTryWait() )
		{
		//  we do not already have a space request completion pending

		if ( P_SLVROOT( slvroot )->semSpaceReqComp.FTryAcquire() )
			{
			//  allow one space request to match this space request completion

			P_SLVROOT( slvroot )->semSpaceReq.Release();
			
			//  pend another space request
			
			pfnIfsSpaceRequestRoot(	P_SLVROOT( slvroot )->hFileRoot,
									P_SLVROOT( slvroot )->wszRootName, 
									PFN_IFSCALLBACK( OSSLVRootSpaceIRequest ),
									PVOID( slvroot ), 
									NULL );
			}
		}
	}

//  notes the amount of reserved space granted to the SLV Provider

void OSSLVRootSpaceIProduce( SLVROOT slvroot, QWORD cbSize )
	{
	AtomicAdd( (QWORD*)&P_SLVROOT( slvroot )->cbGrant, cbSize );
	}

//  notes the amount of reserved space committed to the SLV Provider

void OSSLVRootSpaceIConsume( SLVROOT slvroot, QWORD cbSize )
	{
	AtomicAdd( (QWORD*)&P_SLVROOT( slvroot )->cbCommit, cbSize );
	}

//  reserves the space in the given SLV Info for an SLV Root

ERR ErrOSSLVRootSpaceReserve( const SLVROOT slvroot, CSLVInfo& slvinfo )
	{
	ERR					err			= JET_errSuccess;
	CSLVFileInfo		slvfileinfo;
	CSLVFileInfo::CRun	runSrc;
	size_t				cbslist;
	SCATTER_LIST*		pslist;
	QWORD				cbSize		= 0;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  create an empty SLV File Info to receive the converted data

	Call( slvfileinfo.ErrCreate() );

	//  convert the SLV Info into SLV File Info, giving it no open deadline and
	//  flagging all the space as reserved

	Call( ErrOSSLVFileIConvertSLVInfoToSLVFileInfo(	slvroot,
													slvinfo,
													&slvfileinfo,
													fFalse,
													EXSTATUS_SPACE_UNCOMMITTED ) );

	//  get the Scatter List for this SLV File
	
	Call( slvfileinfo.ErrGetScatterList( (void**)&pslist, &cbslist ) );

	//  send the reserved space to the SLV Provider

	if ( !pfnIfsSpaceGrantRoot(	P_SLVROOT( slvroot )->hFileRoot,
								P_SLVROOT( slvroot )->wszRootName,
								pslist,
								cbslist ) )
		{
		Call( ErrOSSLVRootIGetLastError() );
		}

	//  note the amount of reserved space we have successfully granted to the
	//  SLV Provider

	slvfileinfo.MoveBeforeFirstRun();
	while ( ( err = slvfileinfo.ErrMoveNextRun() ) >= JET_errSuccess )
		{
		Call( slvfileinfo.ErrGetCurrentRun( &runSrc ) );
		cbSize += runSrc.m_cbSize;
		}
	Call( err == JET_errNoCurrentRecord ? JET_errSuccess : err );
		
HandleError:
	OSSLVRootSpaceIProduce( slvroot, cbSize );
	OSSLVRootSpaceIRequestComplete( slvroot );
	slvfileinfo.Unload();
	return err;
	}
	
//  commits the space in the given SLV Info for an SLV Root.  only space that
//  is reserved for a particular SLV File may be committed in this way.  SLV File
//  space MUST be committed in this way or it will later be freed when it is safe
//  via the PSLVROOT_SPACEFREE callback

ERR ErrOSSLVRootSpaceCommit( const SLVROOT slvroot, CSLVInfo& slvinfo )
	{
	ERR err = JET_errSuccess;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  commit the space in this SLV Info for the associated SLV File

	Call( P_SLVROOT( slvroot )->pslvft->ErrCommitSpace( &slvinfo ) );

	return JET_errSuccess;

HandleError:
	return err;
	}

//  deletes the space in the given SLV Info from an SLV Root.  this space will
//  later be freed when it is safe via the PSLVROOT_SPACEFREE callback

ERR ErrOSSLVRootSpaceDelete( const SLVROOT slvroot, CSLVInfo& slvinfo )
	{
	ERR err = JET_errSuccess;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  delete the space in this SLV Info for the associated SLV File

	Call( P_SLVROOT( slvroot )->pslvft->ErrDeleteSpace( &slvinfo ) );

	return JET_errSuccess;

HandleError:
	return err;
	}


CSLVBackingFile::CSLVBackingFile()
	:	m_semSetSize( CSyncBasicInfo( "CSLVBackingFile::m_semSetSize" ) )
	{
	//  nop
	}

ERR CSLVBackingFile::ErrInit(	_TCHAR* const	szAbsPath,
								const HANDLE	hFile,
								const QWORD		cbFileSize,
								const BOOL		fReadOnly,
								const DWORD		cbIOSize,
								const SLVROOT	slvroot,
								_TCHAR* const	szAbsPathSLV )
	{
	ERR err = JET_errSuccess;

	//  init underlying OS File object
	
	Call( COSFile::ErrInit(	szAbsPath,
							hFile,
							cbFileSize,
							fReadOnly,
							cbIOSize ) );

	//  remember our associated SLV Root

	m_slvroot = slvroot;

	//  remember the true OS path for the streaming file
	
	_tcscpy( m_szAbsPathSLV, szAbsPathSLV );

	//  allow updates to the backing file size

	m_semSetSize.Release();

	return JET_errSuccess;

HandleError:
	return err;
	}

CSLVBackingFile::~CSLVBackingFile()
	{
	//  nop
	}

ERR CSLVBackingFile::ErrPath( _TCHAR* const szAbsPath )
	{
	//  return the true path of the backing file
	
	_tcscpy( szAbsPath, m_szAbsPathSLV );
	return JET_errSuccess;
	}

ERR CSLVBackingFile::ErrSetSize( const QWORD cbSize, const BOOL fGarbageAllowed )
	{
	ERR err = JET_errSuccess;

	//  set the file size for the underlying OS File object
	
	m_semSetSize.Acquire();
	Call( COSFile::ErrSetSize( cbSize, fGarbageAllowed ) );

	//  update the backing file size on the SLV Root

	if ( !pfnIfsSetEndOfFileRoot(	P_SLVROOT( m_slvroot )->hFileRoot,
									P_SLVROOT( m_slvroot )->wszRootName,
									cbSize ) )
		{
		Call( ErrOSSLVRootIGetLastError() );
		}
	m_semSetSize.Release();

	return JET_errSuccess;

HandleError:
	m_semSetSize.Release();
	return err;
	}


ERR ErrOSSLVRootIOpenRaw(	const SLVROOT			slvroot,
							IFileSystemAPI* const	pfsapi,
							const wchar_t* const	wszBackingFile,
							IFileAPI** const		ppfapiBackingFile )
	{
	ERR					err						= JET_errSuccess;
	_TCHAR				szBackingFile[ IFileSystemAPI::cchPathMax ];
	_TCHAR				szAbsPathBackingFile[ IFileSystemAPI::cchPathMax ];
	IFileFindAPI*		pffapi					= NULL;
	QWORD				cbBackingFileSize;
	DWORD				cbBackingFileIOSize;
	CSLVInfo			slvinfo;
	CSLVInfo::HEADER	header;
	CSLVInfo::RUN		run;
	CSLVFileInfo		slvfileinfo;
	size_t				cwchRelPath;
	wchar_t*			wszRelPath;
	size_t				cbffeainf;
	void*				pffeainf;
	CSLVBackingFile*	pslvbf					= NULL;
	WCHAR				wszAbsPath[ IFileSystemAPI::cchPathMax ];
	_TCHAR				szAbsPath[ IFileSystemAPI::cchPathMax ];
	HANDLE				hFile					= INVALID_HANDLE_VALUE;

	//  get the current properties of the backing file

	Call( ErrOSSTRUnicodeToTchar(	wszBackingFile,
									szBackingFile,
									IFileSystemAPI::cchPathMax ) );

	Call( pfsapi->ErrFileFind( szBackingFile, &pffapi ) );
	Call( pffapi->ErrNext() );
	Call( pffapi->ErrPath( szAbsPathBackingFile ) );
	Call( pffapi->ErrSize( &cbBackingFileSize ) );
	delete pffapi;
	pffapi = NULL;

	Call( pfsapi->ErrFileAtomicWriteSize(	szBackingFile,
											&cbBackingFileIOSize ) );

	//  describe a HUGE SLV File that covers all possible offsets of the
	//  backing file.  this SLV File will be used for raw access to the
	//  backing file via the SLV Provider and is called $Raw$
	
	Call( slvinfo.ErrCreateVolatile() );

	header.cbSize			= cbBackingFileSizeMax;
	header.cRun				= 1;
	header.fDataRecoverable	= fFalse;
	header.rgbitReserved_31	= 0;
	header.rgbitReserved_32	= 0;
	Call( slvinfo.ErrSetHeader( header ) );

	Call( slvinfo.ErrSetFileName( L"$Raw$" ) );

	run.ibVirtualNext	= cbBackingFileSizeMax;
	run.ibLogical		= 0;
	run.qwReserved		= 0;
	run.ibVirtual		= 0;
	run.cbSize			= cbBackingFileSizeMax;
	run.ibLogicalNext	= cbBackingFileSizeMax;
	Call( slvinfo.ErrMoveAfterLast() );
	Call( slvinfo.ErrSetCurrentRun( run ) );

	//  allocate the file object
	
	if ( !( pslvbf = new CSLVBackingFile ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  create an empty SLV File Info to receive the converted data

	Call( slvfileinfo.ErrCreate() );

	//  convert the given SLV Info into SLV File Info, give the SLV File Info
	//  no expiration time, and disable copy-on-write

	Call( ErrOSSLVFileIConvertSLVInfoToSLVFileInfo(	slvroot,
													slvinfo,
													&slvfileinfo,
													fFalse,
													EXSTATUS_PRIVILEGED_HANDLE ) );

	//  get the file name and EA List for this SLV File

	Call( slvfileinfo.ErrGetFileName( &wszRelPath, &cwchRelPath ) );
	Call( slvfileinfo.ErrGetEAList( &pffeainf, &cbffeainf ) );

	//  get the absolute path for the file to create

	wcscpy( wszAbsPath, P_SLVROOT( slvroot )->wszRootName );
	wcscat( wszAbsPath, L"\\" );
	wcscat( wszAbsPath, wszRelPath );

	Call( ErrOSSTRUnicodeToTchar( wszAbsPath, szAbsPath, IFileSystemAPI::cchPathMax ) );

	//  create the file, passing the generated EA List to the SLV Provider
	
	hFile = pfnIfsCreateFile(	wszAbsPath,
								GENERIC_READ | GENERIC_WRITE,
								FILE_SHARE_READ | FILE_SHARE_WRITE,
								NULL,
								OPEN_ALWAYS,
								(	FILE_ATTRIBUTE_NORMAL |
									FILE_FLAG_WRITE_THROUGH |
									FILE_FLAG_NO_BUFFERING |
									FILE_FLAG_OVERLAPPED ), 
								(PVOID) pffeainf,
								cbffeainf );
	if ( hFile == INVALID_HANDLE_VALUE )
		{
		Call( ErrOSSLVFileIGetLastError() );
		}

	SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	//  reduce the file size to match the size of the backing file.  this will
	//  not change our scatter list but it will allow the file object to extend
	//  and shrink the file normally

	DWORD	cbSizeLow;
	DWORD	cbSizeHigh;
	
	cbSizeLow	= DWORD( cbBackingFileSize );
	cbSizeHigh	= DWORD( cbBackingFileSize >> 32 );
	if (	(	SetFilePointer(	hFile,
								cbSizeLow,
								(long*)&cbSizeHigh,
								FILE_BEGIN ) == INVALID_SET_FILE_POINTER &&
				GetLastError() != NO_ERROR ) ||
			!SetEndOfFile( hFile ) )
		{
		Call( ErrOSSLVFileIGetLastError() );
		}

	//  initialize the file object

	Call( pslvbf->ErrInit(	szAbsPath,
							hFile,
							cbBackingFileSize,
							fFalse,
							cbBackingFileIOSize,
							slvroot,
							szAbsPathBackingFile ) );
	hFile = INVALID_HANDLE_VALUE;

	//  return the interface to our file object

	*ppfapiBackingFile = pslvbf;
	slvfileinfo.Unload();
	slvinfo.Unload();
	return JET_errSuccess;

HandleError:
	delete pffapi;
	if ( hFile != INVALID_HANDLE_VALUE )
		{
		SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hFile );
		}
	delete pslvbf;
	*ppfapiBackingFile = NULL;
	slvfileinfo.Unload();
	slvinfo.Unload();
	return err;
	}

//  creates an SLV Root with the specified relative root path in the SLV name
//  space backed by the specified file.  the provided completions will be
//  notified when more space is needed for the SLV Root for creating SLV
//  files or when space used by the SLV Root can safely be freed.  if the root
//  cannot be created, JET_errFileAccessDenied will be returned.  if the
//  backing file does not exist, JET_errFileNotFound will be returned

ERR ErrOSSLVRootCreate(	const wchar_t* const		wszRootPath,
						IFileSystemAPI* const		pfsapi,
						const wchar_t* const		wszBackingFile,
						const PSLVROOT_SPACEREQ		pfnSpaceReq,
						const DWORD_PTR				dwSpaceReqKey,
						const PSLVROOT_SPACEFREE	pfnSpaceFree,
						const DWORD_PTR				dwSpaceFreeKey,
						SLVROOT* const				pslvroot,
						IFileAPI** const			ppfapiBackingFile )
	{
	ERR					err					= JET_errSuccess;
	IFileAPI*			pfapiBackingFile	= NULL;
	IFileLayoutAPI*		pflapi				= NULL;
	wchar_t				wszBackingFilePhys[ IFileSystemAPI::cchPathMax ];
	DWORD				Error				= 0;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  setup the SLV Root for open

	if ( !( *PP_SLVROOT( pslvroot ) = new _SLVROOT ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	P_SLVROOT( *pslvroot )->hFileRoot			= NULL;
	P_SLVROOT( *pslvroot )->dwInstanceID		= AtomicExchangeAdd( (long*)&tickOSSLVInstanceID, 2 );

	P_SLVROOT( *pslvroot )->pfapiBackingFile	= NULL;

	P_SLVROOT( *pslvroot )->pslvft				= NULL;

	P_SLVROOT( *pslvroot )->pfnSpaceReq			= pfnSpaceReq;
	P_SLVROOT( *pslvroot )->dwSpaceReqKey		= dwSpaceReqKey;

	P_SLVROOT( *pslvroot )->msigTerm.Reset();
	P_SLVROOT( *pslvroot )->msigTermAck.Set();

	P_SLVROOT( *pslvroot )->cbGrant				= 0;
	P_SLVROOT( *pslvroot )->cbCommit			= 0;

	P_SLVROOT( *pslvroot )->pfnSpaceFree		= pfnSpaceFree;
	P_SLVROOT( *pslvroot )->dwSpaceFreeKey		= dwSpaceFreeKey;

	wcscpy( P_SLVROOT( *pslvroot )->wszRootName, wszRootPath );

	PFILE_GET_EA_INFORMATION	pfgeainfCur;
	BYTE*						pbNameStart;
	BYTE*						pbNameEnd;
	PFILE_GET_EA_INFORMATION	pfgeainfNext;

	pfgeainfNext = &P_SLVROOT( *pslvroot )->fgeainf;
	
	pfgeainfCur		= pfgeainfNext;
	pbNameStart		= (BYTE*)pfgeainfCur->EaName;
	pbNameEnd		= pbNameStart + sizeof( EXIFS_EA_NAME_COMMIT );
	pfgeainfNext	= (FILE_GET_EA_INFORMATION*)PvOSSLVLongAlign( pbNameEnd );

	pfgeainfCur->NextEntryOffset	= (ULONG)((BYTE*)pfgeainfNext - (BYTE*)pfgeainfCur);
	pfgeainfCur->EaNameLength		= BYTE( pbNameEnd - pbNameStart - 1 );
	
	strcpy( (char*)pbNameStart, EXIFS_EA_NAME_COMMIT );
	
	pfgeainfCur		= pfgeainfNext;
	pbNameStart		= (BYTE*)pfgeainfCur->EaName;
	pbNameEnd		= pbNameStart + sizeof( "0000000000" );
	pfgeainfNext	= (FILE_GET_EA_INFORMATION*)PvOSSLVLongAlign( pbNameEnd );

	pfgeainfCur->NextEntryOffset	= 0;
	pfgeainfCur->EaNameLength		= BYTE( pbNameEnd - pbNameStart - 1 );
	
	sprintf( (char*)pbNameStart, "%010u", P_SLVROOT( *pslvroot )->dwInstanceID );

	P_SLVROOT( *pslvroot )->cbfgeainf = (DWORD)((BYTE*)pfgeainfNext - (BYTE*)( &P_SLVROOT( *pslvroot )->fgeainf ));
	Assert( P_SLVROOT( *pslvroot )->cbfgeainf <= sizeof( P_SLVROOT( *pslvroot )->rgbEA ) );
	Assert( P_SLVROOT( *pslvroot )->cbfgeainf == EXIFS_GET_EA_LEN_COMMIT + EXIFS_GET_EA_LEN_INSTANCE_ID );

	//  initialize the SLV File Table

	BYTE* rgbSLVFileTable;
	rgbSLVFileTable = (BYTE*)PvOSMemoryHeapAllocAlign( sizeof( CSLVFileTable ), cbCacheLine );
	if ( !rgbSLVFileTable )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	P_SLVROOT( *pslvroot )->pslvft = new( rgbSLVFileTable ) CSLVFileTable();
	Call( P_SLVROOT( *pslvroot )->pslvft->ErrInit( P_SLVROOT( *pslvroot ) ) );

	//  the specified backing file path is the physical backing file path

	wcscpy( wszBackingFilePhys, wszBackingFile );

	//  save the backing file handle in the SLV Root
	
	P_SLVROOT( *pslvroot )->pfapiBackingFile = pfapiBackingFile;
	pfapiBackingFile = NULL;

	//  open the SLV Root path exclusively to ensure that no one else is currently
	//  attached to this SLV Root

	do
		{
		P_SLVROOT( *pslvroot )->hFileRoot = pfnIfsCreateFile(	(WCHAR*)wszRootPath,
																GENERIC_READ | GENERIC_WRITE,
																0,
																NULL,
																CREATE_NEW,
																(	FILE_ATTRIBUTE_NORMAL |
																	FILE_FLAG_WRITE_THROUGH |
																	FILE_FLAG_OVERLAPPED ), 
																NULL,
																0 );
		if ( P_SLVROOT( *pslvroot )->hFileRoot == INVALID_HANDLE_VALUE )
			{
			Error = GetLastError();
			if ( Error == ERROR_DEVICE_IN_USE )
				{
				Sleep( 100 );
				}
			}
		}
	while ( Error == ERROR_DEVICE_IN_USE );

	if ( Error != NO_ERROR )
        {
		P_SLVROOT( *pslvroot )->hFileRoot = NULL;
		err = ErrOSSLVRootIGetLastError( Error );
		if ( err == JET_errInvalidPath )
			{
			err = ErrERRCheck( JET_errSLVProviderNotLoaded );
			}
		Call( err );
        }

	SetHandleInformation( P_SLVROOT( *pslvroot )->hFileRoot, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	
	if ( !pfnIfsInitializeRoot(	P_SLVROOT( *pslvroot )->hFileRoot,
								(WCHAR*)wszRootPath,
								(WCHAR*)wszBackingFilePhys,
								P_SLVROOT( *pslvroot )->dwInstanceID, 
								SLVPAGE_SIZE,
								(	FILE_WRITE_THROUGH |
									FILE_RANDOM_ACCESS ) ) )
		{
		Call( ErrOSSLVRootIGetLastError() );
		}

	//  create the special $Raw$ SLV File and use that as the backing file

	Call( ErrOSSLVRootIOpenRaw(	*pslvroot,
								pfsapi,
								wszBackingFile,
								&pfapiBackingFile ) );

	//  save the backing file handle in the SLV Root
	
	P_SLVROOT( *pslvroot )->pfapiBackingFile = pfapiBackingFile;
	pfapiBackingFile = NULL;

	//  start the space request loop to allow the SLV Provider to tell us
	//  when it needs space

	P_SLVROOT( *pslvroot )->msigTermAck.Reset();
	P_SLVROOT( *pslvroot )->semSpaceReqComp.Release();
	OSSLVRootSpaceIRequestComplete( *pslvroot );

	//  return the SLV Root and its backing file handle

	*ppfapiBackingFile = P_SLVROOT( *pslvroot )->pfapiBackingFile;
	return JET_errSuccess;

HandleError:
	OSSLVRootClose( *pslvroot );
	delete pfapiBackingFile;
	delete pflapi;
	*pslvroot			= slvrootNil;
	*ppfapiBackingFile	= NULL;
	return err;
	}

//  closes an SLV Root

void OSSLVRootClose( const SLVROOT slvroot )
	{
	//  we have an SLV Root pointer

	if ( slvroot && slvroot != slvrootNil )
		{
		//  close the backing file

		delete P_SLVROOT( slvroot )->pfapiBackingFile;

		//  we opened the SLV Root handle

		if ( P_SLVROOT( slvroot )->hFileRoot )
			{
			//  shut down the SLV Root and the space request loop

			P_SLVROOT( slvroot )->msigTerm.Set();
			pfnIfsTerminateRoot( P_SLVROOT( slvroot )->hFileRoot, P_SLVROOT( slvroot )->wszRootName, 0 );
			P_SLVROOT( slvroot )->msigTermAck.Wait();

			//  close the SLV Root

			SetHandleInformation( P_SLVROOT( slvroot )->hFileRoot, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
			BOOL fCloseOK = CloseHandle( P_SLVROOT( slvroot )->hFileRoot );
			Assert( fCloseOK );
			}

		//  terminate the SLV File Table

		if ( P_SLVROOT( slvroot )->pslvft )
			{
			P_SLVROOT( slvroot )->pslvft->Term();
			P_SLVROOT( slvroot )->pslvft->CSLVFileTable::~CSLVFileTable();
			OSMemoryHeapFreeAlign( P_SLVROOT( slvroot )->pslvft );
			}

		//  delete the SLV Root info

		OSMemoryHeapFree( P_SLVROOT( slvroot ) );
		}
	}

	
//  post-terminate SLV subsystem

void OSSLVPostterm()
	{
	//  nop
	}

//  pre-init SLV subsystem

BOOL FOSSLVPreinit()
	{
	//  get our init time which we will use later to generate Instance IDs

	tickOSSLVInstanceID = GetTickCount() & 0xFFFFFFFE;
	return fTrue;
	}


//  term SLV subsystem

void OSSLVTerm()
	{
	//  free ifsproxy.dll

	if ( hmodIfsProxy )
		{
		if ( pfnIfsCloseProvider )
			{
			pfnIfsCloseProvider();
			}

		FreeLibrary( hmodIfsProxy );
		hmodIfsProxy = NULL;
		}

	//  free ntdll

	if ( hmodNtdll )
		{
		FreeLibrary( hmodNtdll );
		hmodNtdll = NULL;
		}
	}

//  init SLV subsystem

ERR ErrOSSLVInit()
	{
	ERR			err				= JET_errSuccess;
	const int	cbBuf			= 256;
	_TCHAR		szBuf[ cbBuf ];
	
	//  reset all pointers

	hmodNtdll			= NULL;
	fUseRelativeOpen	= fFalse;
	hmodIfsProxy		= NULL;
	errSLVProvider		= JET_errSuccess;

	//  load OS version

	OSVERSIONINFO osvi;
	memset( &osvi, 0, sizeof( osvi ) );
	osvi.dwOSVersionInfoSize = sizeof( osvi );
	if ( !GetVersionEx( &osvi ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  set all configuration defaults

	cbOSSLVReserve				= 2 * 1024 * 1024;

	cmsecOSSLVSpaceFreeDelay	= 60 * 1000;
	cmsecOSSLVFileOpenDelay		= 60 * 1000;
	cmsecOSSLVTTL				= 5 * 1000;
	cmsecOSSLVTTLSafety			= 100;
	cmsecOSSLVTTLInfinite		= 1 << 30;

	cbBackingFileSizeMax		= (	osvi.dwPlatformId == VER_PLATFORM_WIN32_NT ?
										SLVSIZE_MAX :
										0x100000000 - SLVPAGE_SIZE );

	//  load configuration from the registry
	
	if (	FOSConfigGet( _T( "OS/SLV" ), _T( "Space Grant Size (B)" ), szBuf, cbBuf ) &&
			szBuf[ 0 ] )
		{
		cbOSSLVReserve = _ttol( szBuf );
		}
	
	if (	FOSConfigGet( _T( "OS/SLV" ), _T( "EA List Time-To-Live (ms)" ), szBuf, cbBuf ) &&
			szBuf[ 0 ] )
		{
		cmsecOSSLVTTL = _ttol( szBuf );
		}

	//  init performance counters

	cOSSLVFileTableInsert	= 0;
	cOSSLVFileTableClean	= 0;
	cOSSLVFileTableDelete	= 0;

	//  load ntdll.dll

	fUseRelativeOpen = (	( hmodNtdll = LoadLibrary( _T( "ntdll.dll" ) ) ) &&
							( pfnRtlInitUnicodeString = (PFNRtlInitUnicodeString*)GetProcAddress( hmodNtdll, _T( "RtlInitUnicodeString" ) ) ) &&
							( pfnNtCreateFile = (PFNNtCreateFile*)GetProcAddress( hmodNtdll, _T( "NtCreateFile" ) ) ) );
		
	//  load ifsproxy.dll

	if ( !( hmodIfsProxy = LoadLibrary( _T( "ifsproxy.dll" ) ) ) )
		{
		goto NoIfsProxy;
		}
	if ( !( pfnIfsGetFirstCursor = (PFNIfsGetFirstCursor*)GetProcAddress( hmodIfsProxy, _T( "IfsGetFirstCursor" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsConsumeCursor = (PFNIfsConsumeCursor*)GetProcAddress( hmodIfsProxy, _T( "IfsConsumeCursor" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsGetNextCursor = (PFNIfsGetNextCursor*)GetProcAddress( hmodIfsProxy, _T( "IfsGetNextCursor" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsFinishCursor = (PFNIfsFinishCursor*)GetProcAddress( hmodIfsProxy, _T( "IfsFinishCursor" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsCreateNewBuffer = (PFNIfsCreateNewBuffer*)GetProcAddress( hmodIfsProxy, _T( "IfsCreateNewBuffer" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsCopyBufferToReference = (PFNIfsCopyBufferToReference*)GetProcAddress( hmodIfsProxy, _T( "IfsCopyBufferToReference" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsCopyReferenceToBuffer = (PFNIfsCopyReferenceToBuffer*)GetProcAddress( hmodIfsProxy, _T( "IfsCopyReferenceToBuffer" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsCloseBuffer = (PFNIfsCloseBuffer*)GetProcAddress( hmodIfsProxy, _T( "IfsCloseBuffer" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsInitializeProvider = (PFNIfsInitializeProvider*)GetProcAddress( hmodIfsProxy, _T( "IfsInitializeProvider" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsCloseProvider = (PFNIfsCloseProvider*)GetProcAddress( hmodIfsProxy, _T( "IfsCloseProvider" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsCreateFile = (PFNIfsCreateFileProv*)GetProcAddress( hmodIfsProxy, _T( "IfsCreateFileProv" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsInitializeRoot = (PFNIfsInitializeRoot*)GetProcAddress( hmodIfsProxy, _T( "IfsInitializeRoot" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsSpaceGrantRoot = (PFNIfsSpaceGrantRoot*)GetProcAddress( hmodIfsProxy, _T( "IfsSpaceGrantRoot" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsSetEndOfFileRoot = (PFNIfsSetEndOfFileRoot*)GetProcAddress( hmodIfsProxy, _T( "IfsSetEndOfFileRoot" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsSpaceRequestRoot = (PFNIfsSpaceRequestRoot*)GetProcAddress( hmodIfsProxy, _T( "IfsSpaceRequestRoot" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsQueryEaFile = (PFNIfsQueryEaFile*)GetProcAddress( hmodIfsProxy, _T( "IfsQueryEaFile" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsTerminateRoot = (PFNIfsTerminateRoot*)GetProcAddress( hmodIfsProxy, _T( "IfsTerminateRoot" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsSetRootMap = (PFNIfsSetRootMap*)GetProcAddress( hmodIfsProxy, _T( "IfsSetRootMap" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsResetRootMap = (PFNIfsResetRootMap*)GetProcAddress( hmodIfsProxy, _T( "IfsResetRootMap" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsFlushHandle = (PFNIfsFlushHandle*)GetProcAddress( hmodIfsProxy, "IfsFlushHandle" ) ) )
		{
		goto WrongIfsProxy;
		}

	if ( !pfnIfsInitializeProvider( 0 ) )
		{
		errSLVProvider = ErrOSSLVRootIGetLastError();
		goto HandleError;
		}

	return JET_errSuccess;

WrongIfsProxy:
	errSLVProvider = ErrERRCheck( JET_errSLVProviderVersionMismatch );
	goto HandleError;
	
NoIfsProxy:
	errSLVProvider = ErrERRCheck( JET_errSLVProviderNotLoaded );
	goto HandleError;

HandleError:
	OSSLVTerm();
	return JET_errSuccess;
	}

#endif	//	DISABLE_SLV
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\time.cxx ===
#include "osstd.hxx"


//  Low Resolution Timer

//  returns the current timer count (1 Hz)

ULONG_PTR UlUtilGetSeconds()
	{
	return time( NULL );
	}


//  Medium Resolution Timer

//  returns the current timer count (1000 Hz)

TICK TickOSTimeCurrent()
	{
	return TICK( GetTickCount() );
	}


//  High Resolution Timer

//    High Resolution Timer Type

enum HRTType
	{
	hrttNone,
	hrttWin32,
#ifdef TIME_USE_X86_ASM
	hrttPentium,
#endif  //  TIME_USE_X86_ASM
	} hrtt;

//    HRT Frequency

QWORD qwHRTFreq;

#ifdef TIME_USE_X86_ASM

//    Pentium Time Stamp Counter Fetch

#define rdtsc __asm _emit 0x0f __asm _emit 0x31

#endif  //  TIME_USE_X86_ASM

//  returns fTrue if we are allowed to use RDTSC

BOOL IsRDTSCAvailable()
	{
	typedef WINBASEAPI BOOL WINAPI PFNIsProcessorFeaturePresent( IN DWORD ProcessorFeature );

	HMODULE							hmodKernel32					= NULL;
	PFNIsProcessorFeaturePresent*	pfnIsProcessorFeaturePresent	= NULL;
	BOOL							fRDTSCAvailable					= fFalse;

	if ( !( hmodKernel32 = GetModuleHandle( _T( "kernel32.dll" ) ) ) )
		{
		goto NoIsProcessorFeaturePresent;
		}
	if ( !( pfnIsProcessorFeaturePresent = (PFNIsProcessorFeaturePresent*)GetProcAddress( hmodKernel32, _T( "IsProcessorFeaturePresent" ) ) ) )
		{
		goto NoIsProcessorFeaturePresent;
		}

	fRDTSCAvailable = pfnIsProcessorFeaturePresent( PF_RDTSC_INSTRUCTION_AVAILABLE );

NoIsProcessorFeaturePresent:
	return fRDTSCAvailable;
	}

//  initializes the HRT subsystem

void UtilHRTInit()
	{
	//  if we have already been initialized, we're done

	if ( qwHRTFreq )
		{
		return;
		}

#ifdef _M_ALPHA
#else  //  !_M_ALPHA

	//  Win32 high resolution counter is available

	if ( QueryPerformanceFrequency( (LARGE_INTEGER *) &qwHRTFreq ) )
		{
		hrtt = hrttWin32;
		}

	//  Win32 high resolution counter is not available
	
	else
	
#endif  //  _M_ALPHA

		{
		//  fall back on GetTickCount() (ms since Windows has started)
		
		QWORDX qwx;
		qwx.SetDwLow( 1000 );
		qwx.SetDwHigh( 0 );
		qwHRTFreq = qwx.Qw();

		hrtt = hrttNone;
		}

#ifdef TIME_USE_X86_ASM

	//  can we use the TSC?
	
	if ( IsRDTSCAvailable() )
		{
		//  use pentium TSC register, but first find clock frequency experimentally
		
		QWORDX qwxTime1a;
		QWORDX qwxTime1b;
		QWORDX qwxTime2a;
		QWORDX qwxTime2b;
		if ( hrtt == hrttWin32 )
			{
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime1a.m_l,eax	//lint !e530
			__asm mov		qwxTime1a.m_h,edx	//lint !e530
			QueryPerformanceCounter( (LARGE_INTEGER*) qwxTime1b.Pqw() );
			Sleep( 50 );
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime2a.m_l,eax	//lint !e530
			__asm mov		qwxTime2a.m_h,edx	//lint !e530
			QueryPerformanceCounter( (LARGE_INTEGER*) qwxTime2b.Pqw() );
			qwHRTFreq =	( qwHRTFreq * ( qwxTime2a.Qw() - qwxTime1a.Qw() ) ) /
						( qwxTime2b.Qw() - qwxTime1b.Qw() );
			qwHRTFreq = ( ( qwHRTFreq + 50000 ) / 100000 ) * 100000;
			}
		else
			{
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime1a.m_l,eax
			__asm mov		qwxTime1a.m_h,edx
			qwxTime1b.SetDwLow( GetTickCount() );
			qwxTime1b.SetDwHigh( 0 );
			Sleep( 2000 );
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime2a.m_l,eax
			__asm mov		qwxTime2a.m_h,edx
			qwxTime2b.SetDwLow( GetTickCount() );
			qwxTime2b.SetDwHigh( 0 );
			qwHRTFreq =	( qwHRTFreq * ( qwxTime2a.Qw() - qwxTime1a.Qw() ) ) /
						( qwxTime2b.Qw() - qwxTime1b.Qw() );
			qwHRTFreq = ( ( qwHRTFreq + 500000 ) / 1000000 ) * 1000000;
			}

		hrtt = hrttPentium;
		}
		
#endif  //  TIME_USE_X86_ASM

	}

//  returns the current HRT frequency

QWORD QwUtilHRTFreq()
	{
	return qwHRTFreq;
	}

//  returns the current HRT count

QWORD QwUtilHRTCount()
	{
	QWORDX qwx;

	switch ( hrtt )
		{
		case hrttNone:
			qwx.SetDwLow( GetTickCount() );
			qwx.SetDwHigh( 0 );
			break;

		case hrttWin32:
			QueryPerformanceCounter( (LARGE_INTEGER*) qwx.Pqw() );
			break;

#ifdef TIME_USE_X86_ASM

		case hrttPentium:
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwx.m_l,eax
			__asm mov		qwx.m_h,edx
			break;
			
#endif  //  TIME_USE_X86_ASM

		}

	return qwx.Qw();
	}


//  returns the current system date and time

void UtilGetCurrentDateTime( DATETIME *pdate )
	{
	SYSTEMTIME              systemtime;
	
	GetLocalTime( &systemtime );

	pdate->month	= systemtime.wMonth;
	pdate->day		= systemtime.wDay;
	pdate->year		= systemtime.wYear;
	pdate->hour		= systemtime.wHour;
	pdate->minute	= systemtime.wMinute;
	pdate->second	= systemtime.wSecond;
	}
	

// post- terminate time subsystem

void OSTimePostterm()
	{
	//  nop
	}

//  pre-init time subsystem

BOOL FOSTimePreinit()
	{
	//  iniitalize the HRT

	UtilHRTInit();

	return fTrue;
	}


//  terminate time subsystem

void OSTimeTerm()
	{
	//  nop
	}

//  init time subsystem

ERR ErrOSTimeInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\uuid.cxx ===
#ifdef MINIMAL_FUNCTIONALITY
#else

#include "osstd.hxx"


//	create a new UUID

void OSUUIDCreate( OSUUID* const posuuid )
	{

	//	call the RPC library

	(void)UuidCreate( (UUID*)posuuid );
	}


//	compare two UUIDs for equality

BOOL FOSUUIDEqual( const OSUUID* const posuuid1, const OSUUID* const posuuid2 )
	{

	//	compare the bytes directly

	return BOOL( 0 == memcmp( (void*)posuuid1, (void*)posuuid2, sizeof( OSUUID ) ) );
	}

#endif	//	MINIMAL_FUNCTIONALITY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\sysinfo.cxx ===
#include "osstd.hxx"

#include "ntverp.h"

#ifndef RTM
LOCAL VOID GetSystemVersionOverridesFromRegistry();
#else
#define GetSystemVersionOverridesFromRegistry()
#endif

//  Process Attributes

//  returns the current process' name

LOCAL _TCHAR szProcessName[_MAX_FNAME];

const _TCHAR* SzUtilProcessName()
	{
	return szProcessName;
	}

//  returns the current process' path

LOCAL _TCHAR szProcessPath[_MAX_FNAME];

const _TCHAR* SzUtilProcessPath()
	{
	return szProcessPath;
	}

//  returns the current process ID

LOCAL DWORD dwProcessId;

const DWORD DwUtilProcessId()
	{
	return dwProcessId;
	}

//  returns the number of system processors on which the current process can execute

LOCAL DWORD cProcessProcessor;

const DWORD CUtilProcessProcessor()
	{
	return cProcessProcessor;
	}

//  returns fTrue if the current process is terminating abnormally

volatile BOOL fProcessAbort;

const BOOL FUtilProcessAbort()
	{
	return fProcessAbort;
	}


//  System Attributes

//  retrieves system major version

LOCAL DWORD dwSystemVersionMajor;

DWORD DwUtilSystemVersionMajor()
	{
	GetSystemVersionOverridesFromRegistry();
	return dwSystemVersionMajor;
	}

//  retrieves system minor version

LOCAL DWORD dwSystemVersionMinor;

DWORD DwUtilSystemVersionMinor()
	{
	GetSystemVersionOverridesFromRegistry();
	return dwSystemVersionMinor;
	}

//  retrieves system major build number

LOCAL DWORD dwSystemBuildNumber;

DWORD DwUtilSystemBuildNumber()
	{
	GetSystemVersionOverridesFromRegistry();
	return dwSystemBuildNumber;
	}

//  retrieves system service pack number

LOCAL DWORD dwSystemServicePackNumber;

DWORD DwUtilSystemServicePackNumber()
	{
	GetSystemVersionOverridesFromRegistry();
	return dwSystemServicePackNumber;
	}

//  returns fTrue if idle activity should be avoided

BOOL FUtilSystemRestrictIdleActivity()
	{
	const DWORD			dtickCheck		= 60 * 1000;
	static DWORD		tickLastCheck	= GetTickCount() - dtickCheck;
	static BOOL			fLastResult		= fTrue;

	if ( GetTickCount() - tickLastCheck >= dtickCheck )
		{
		SYSTEM_POWER_STATUS	sps;

		fLastResult		= !GetSystemPowerStatus( &sps ) || sps.ACLineStatus != 1;
		tickLastCheck	= GetTickCount();
		}

	return fLastResult;
	}


//  Image Attributes

//  retrieves image base address

VOID * pvImageBaseAddress;

const VOID * PvUtilImageBaseAddress()
	{
	return pvImageBaseAddress;
	}

//  retrieves image name

LOCAL _TCHAR szImageName[_MAX_FNAME];

const _TCHAR* SzUtilImageName()
	{
	return szImageName;
	}

//  retrieves image path

LOCAL _TCHAR szImagePath[_MAX_PATH];

const _TCHAR* SzUtilImagePath()
	{
	return szImagePath;
	}

//  retrieves image version name

LOCAL _TCHAR szImageVersionName[_MAX_FNAME];

const _TCHAR* SzUtilImageVersionName()
	{
	return szImageVersionName;
	}

//  retrieves image major version

LOCAL DWORD dwImageVersionMajor;

DWORD DwUtilImageVersionMajor()
	{
	return dwImageVersionMajor;
	}

//  retrieves image minor version

LOCAL DWORD dwImageVersionMinor;

DWORD DwUtilImageVersionMinor()
	{
	return dwImageVersionMinor;
	}

//  retrieves image major build number

LOCAL DWORD dwImageBuildNumberMajor;

DWORD DwUtilImageBuildNumberMajor()
	{
	return dwImageBuildNumberMajor;
	}

//  retrieves image minor build number

LOCAL DWORD dwImageBuildNumberMinor;

DWORD DwUtilImageBuildNumberMinor()
	{
	return dwImageBuildNumberMinor;
	}

//  retrieves image build class

LOCAL _TCHAR szImageBuildClass[_MAX_FNAME];

const _TCHAR* SzUtilImageBuildClass()
	{
	return szImageBuildClass;
	}


//  ^C and ^Break handler for process termination

BOOL WINAPI UtilSysinfoICtrlHandler( DWORD dwCtrlType )
	{
	//  set process to aborting status

	fProcessAbort = fTrue;
	return FALSE;
	}


//	do all processors in the system have the PrefetchNTA capability?

LOCAL BOOL fHardwareCanPrefetch;

BOOL FHardwareCanPrefetch()
	{
	return fHardwareCanPrefetch;
	}

LOCAL BOOL FDeterminePrefetchCapability()
	{
	BOOL fCanPrefetch = FALSE;
	
#ifdef _X86_
    ULONG    Features;
    ULONG    i;
    DWORD    OriginalAffinity;

 	SYSTEM_INFO system_inf;
 	GetSystemInfo( &system_inf );
 
    //
    // First check to see that I have at least Intel Pentium.  This simplifies
    // the cpuid
    //
    if (system_inf.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL ||
        system_inf.wProcessorLevel < 5)
	 	{
		return fCanPrefetch;
		}
	
	fCanPrefetch = TRUE;
 
    //
    // Affinity thread to boot processor
    //
 
	OriginalAffinity = SetThreadAffinityMask(GetCurrentThread(), 1);
 
	// Here we want to go through each CPU, so use the systeminfo # of
	// processors instead of gdwSchedulerCount
	//
	for ( i = 0; i < system_inf.dwNumberOfProcessors && fCanPrefetch; i++ )
		{
		if ( i != 0 )
			{
			SetThreadAffinityMask(GetCurrentThread(), 1 << i);
			}
 
		_asm
			{
			push   ebx
            mov    eax, 1	; cpuid
            _emit  0fh
            _emit  0a2h
 
            mov    Features, edx
            pop    ebx
			}
 
        //
        // Check for Prefetch Present
        //
        if (!(Features & 0x02000000))
			{
 
            //
            // All processors must have prefetch before we can use it.
            // We start with it enabled, if any processor does not have
            // it, we clear it and bail
 
            fCanPrefetch = FALSE;
			}
		}
		SetThreadAffinityMask(GetCurrentThread(), OriginalAffinity);		
#endif
	return fCanPrefetch;
	}


//  process module name to friendly name translation tables

LOCAL const _TCHAR* rglpszProcName[] =
	{
	_T( "dsamain" ),
	_T( "store" ),
	NULL
	};

//  UNDONE:  these should be localized

LOCAL const _TCHAR* rglpszFriendlyName[] =
	{
	_T( "Directory" ),
	_T( "Information Store" ),
	NULL
	};


//  post-terminate sysinfo subsystem

void OSSysinfoPostterm()
	{
	(void)SetConsoleCtrlHandler( UtilSysinfoICtrlHandler, FALSE );
	}


#ifndef RTM

//  provide a registry override so we can fake the version of the OS we are running on

LOCAL BOOL fSystemVersionOverridesTried = fFalse;

struct OSOVERRIDE
	{
	const char * szRegistry;
	DWORD * pdw;
	};

LOCAL OSOVERRIDE rgoverrides[] =
	{
		{ "MajorVersion", &dwSystemVersionMajor },
		{ "MinorVersion", &dwSystemVersionMinor },
		{ "BuildNumber", &dwSystemBuildNumber },
		{ "ServicePack", &dwSystemServicePackNumber },
	};
		
VOID GetSystemVersionOverridesFromRegistry()
	{
	if( fSystemVersionOverridesTried )
		{
		return;
		}
	
	BOOL fChangedVersion = fFalse;
	_TCHAR sz[10];

	INT i;
	for( i = 0; i < ( sizeof( rgoverrides ) / sizeof( rgoverrides[0] )); ++i )
		{
		if ( FOSConfigGet( "OS", rgoverrides[i].szRegistry, sz, sizeof( sz ) - 1 ) && sz[0] )
			{
			*(rgoverrides[i].pdw) 	= atoi( sz );
			fChangedVersion 		= fTrue;
			}
		}

	if( fChangedVersion )
		{
		_TCHAR			szMessage[256];
		const _TCHAR *	rgszT[1]	= { szMessage };

		_stprintf(
				szMessage, 
				_T( "OS version changed through the registry to %d.%d.%d (service pack %d)" ), 
				dwSystemVersionMajor,
				dwSystemVersionMinor,
				dwSystemBuildNumber,
				dwSystemServicePackNumber );
		UtilReportEvent(
				eventWarning,
				GENERAL_CATEGORY,
				PLAIN_TEXT_ID,
				1,
				rgszT );
		}

	fSystemVersionOverridesTried = fTrue;
	}

#endif


//  determine which version of windows we are on

BOOL FGetSystemVersion()
	{

	//  cache system attributes

	OSVERSIONINFO ovi;
	ovi.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
	if ( !GetVersionEx( &ovi ) )
		{
		goto HandleError;
        }

    dwSystemVersionMajor = ovi.dwMajorVersion;
    dwSystemVersionMinor = ovi.dwMinorVersion;
    dwSystemBuildNumber = ovi.dwBuildNumber;
    //  string of format "Service Pack %d"
    _TCHAR* szN;
    szN = _tcspbrk( ovi.szCSDVersion, _T( "0123456789" ) );
    dwSystemServicePackNumber = szN ? _ttol( szN ) : 0;
	
	return fTrue;

HandleError:
	return fFalse;
	}


//  pre-init sysinfo subsystem

BOOL FOSSysinfoPreinit()
	{
	//  cache process name and path

	GetModuleFileName( NULL, szProcessPath, sizeof( szProcessPath )/sizeof(szProcessPath[0]) );
	_tsplitpath( (const _TCHAR *)szProcessPath, NULL, NULL, szProcessName, NULL );

	long iprocname;
	for ( iprocname = 0; rglpszProcName[iprocname]; iprocname++ )
		{
		if ( !_tcsicmp( szProcessName, rglpszProcName[iprocname] ) )
			{
			_tcscpy( szProcessName, rglpszFriendlyName[iprocname] );
			}
		}

	//  cache process id

	dwProcessId = GetCurrentProcessId();

	//  cache process processor count

	DWORD_PTR maskProcess;
	DWORD_PTR maskSystem;
	BOOL fGotAffinityMask;
	fGotAffinityMask = GetProcessAffinityMask(	GetCurrentProcess(),
												&maskProcess,
												&maskSystem );
	Assert( fGotAffinityMask );

	for ( cProcessProcessor = 0; maskProcess != 0; maskProcess >>= 1 )
		{
		if ( maskProcess & 1 )
			{
			cProcessProcessor++;
			}
		}

	//	cache the version of the OS we are running on
	
	if( !FGetSystemVersion() )
		{
		goto HandleError;
		}

    //  cache image name and path

	MEMORY_BASIC_INFORMATION mbi;
	if ( !VirtualQueryEx( GetCurrentProcess(), FOSSysinfoPreinit, &mbi, sizeof( mbi ) ) )
		{
		goto HandleError;
		}
	if ( !GetModuleFileName( HINSTANCE( mbi.AllocationBase ), szImagePath, sizeof( szImagePath )/sizeof(szImagePath[0] )  ) )
		{
		goto HandleError;
		}
	_tsplitpath( (const _TCHAR *)szImagePath, NULL, NULL, szImageName, NULL );
	pvImageBaseAddress = mbi.AllocationBase;

	//  cache image attributes

    _tcscpy( szImageVersionName, _T( SZVERSIONNAME ) );

	//	these constants come from ntverp.h
	dwImageVersionMajor = VER_PRODUCTMAJORVERSION;
	dwImageVersionMinor = VER_PRODUCTMINORVERSION;
	dwImageBuildNumberMajor = VER_PRODUCTBUILD;
	dwImageBuildNumberMinor = VER_PRODUCTBUILD_QFE;

	szImageBuildClass[0] = 0;
#ifdef DEBUG
	_tcscat( szImageBuildClass, _T( "DEBUG" ) );
#else  //  !DEBUG
	_tcscat( szImageBuildClass, _T( "RETAIL" ) );
#endif  //  DEBUG
#ifdef PROFILE
	_tcscat( szImageBuildClass, _T( " PROFILE" ) );
#endif  //  DEBUG
#ifdef RTM
	_tcscat( szImageBuildClass, _T( " RTM" ) );
#endif  //  RTM
#ifdef _UNICODE
	_tcscat( szImageBuildClass, _T( " UNICODE" ) );
#else  //  !_UNICODE
#ifdef _MBCS
	_tcscat( szImageBuildClass, _T( " MBCS" ) );
#else  //  !_MBCS
	_tcscat( szImageBuildClass, _T( " ASCII" ) );
#endif  //  _MBCS
#endif  //  _UNICODE

	//  setup ^C and ^Break handler for process termination if in console mode

	(void)SetConsoleCtrlHandler( UtilSysinfoICtrlHandler, TRUE );

	//	determine processor prefetch capability
	
	fHardwareCanPrefetch = FDeterminePrefetchCapability();
	
	return fTrue;

HandleError:
	OSSysinfoPostterm();
	return fFalse;
	}


//	FOSSetupRunning is used to determine if esent.dll is being used during setup.
//
static const char c_szSysSetupKey[] ="System\\Setup";
static const char c_szSysSetupValue[] ="SystemSetupInProgress";

BOOL FOSSetupRunning( void )
	{
	LONG	lError;
	HKEY	hKey ;

	//	Open the registry Key and read the setup running value
	//
	lError = RegOpenKeyEx(
					HKEY_LOCAL_MACHINE,
					c_szSysSetupKey,
					0,
					KEY_READ,
					&hKey );

	if ( ERROR_SUCCESS == lError )
		{
		DWORD	dwAnswer	= 0 ;	//	assume setup is not running
		DWORD	dwSize		= sizeof( dwAnswer );
		DWORD	dwType;

		lError = RegQueryValueEx(
						hKey,
						c_szSysSetupValue,
						NULL,
						&dwType,
						(LPBYTE)&dwAnswer,
						&dwSize );
		RegCloseKey( hKey );

		if ( ERROR_SUCCESS == lError )
			{
			return( dwAnswer != 0 );
			}
		}

	return( FALSE );
	}


//  terminate sysinfo subsystem

void OSSysinfoTerm()
	{
	//  nop
	}

//  init sysinfo subsystem

ERR ErrOSSysinfoInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\perfmon.cxx ===
#include "osstd.hxx"


#ifdef MINIMAL_FUNCTIONALITY

void OSPerfmonPostterm()	{}
BOOL FOSPerfmonPreinit()	{ return fTrue; }
void OSPerfmonTerm()		{}
ERR ErrOSPerfmonInit()		{ return JET_errSuccess; }

#else


#include <wchar.h>
#include <winperf.h>
#include <aclapi.h>


	/*  Init/Term routines for performance monitoring
	/**/

HANDLE	hPERFGDAMMF				= NULL;
PGDA	pgdaPERFGDA				= NULL;

HANDLE	hPERFInstanceMutex		= NULL;
HANDLE	hPERFIDAMMF				= NULL;
PIDA	pidaPERFIDA				= NULL;
PIDA	pida					= NULL;
HANDLE	hPERFGoEvent			= NULL;
HANDLE	hPERFReadyEvent			= NULL;
DWORD	cbMaxCounterBlockSize	= 0;
DWORD	cbInstanceSize			= 0;

HANDLE	hPERFEndDataThread		= NULL;
THREAD	threadPERFData			= NULL;

extern DWORD UtilPerfThread( DWORD_PTR dw );

void UtilPerfTerm(void)
	{
	DWORD	dwCurObj;
	DWORD	dwCurCtr;

	/*  end the performance data thread
	/**/
	if ( threadPERFData )
		{
		SetEvent( hPERFEndDataThread );
		UtilThreadEnd( threadPERFData );
		threadPERFData = NULL;
		}
	if ( hPERFEndDataThread )
		{
		CloseHandle( hPERFEndDataThread );
		hPERFEndDataThread = NULL;
		}

	/*  terminate all counters/objects
	/**/
	if ( cbInstanceSize )
		{
		for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
			(void)rgpicfPERFICF[dwCurObj](ICFTerm,NULL);
		for (dwCurCtr = 0; dwCurCtr < dwPERFNumCounters; dwCurCtr++)
			(void)rgpcefPERFCEF[dwCurCtr](CEFTerm,NULL);

		cbInstanceSize = 0;
		cbMaxCounterBlockSize = 0;
		}
	}

INLINE _TCHAR* SzPerfGlobal()
	{
	OSVERSIONINFO osverinfo;
	osverinfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
	if ( !GetVersionEx( &osverinfo ) )
		{
		return _T("");
		}
	//	Under Win2000 terminal server object names must be preceded by Global\
	//	to share the same name space
	return ( VER_PLATFORM_WIN32_NT == osverinfo.dwPlatformId && 5 <= osverinfo.dwMajorVersion )? _T("Global\\"): _T("");
	}

ERR ErrUtilPerfInit(void)
	{
	ERR							err;
	DWORD						dwCurObj;
	DWORD						dwCurCtr;
	DWORD						dwOffset;
	PPERF_OBJECT_TYPE			ppotObjectSrc;
	PPERF_INSTANCE_DEFINITION	ppidInstanceSrc;
	PPERF_COUNTER_DEFINITION	ppcdCounterSrc;

	/*  initialize all objects/counters
	/**/
	for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
		{
		if (rgpicfPERFICF[dwCurObj](ICFInit,NULL))
			{
			for (dwCurObj--; long( dwCurObj ) >= 0; dwCurObj--)
				rgpicfPERFICF[dwCurObj](ICFTerm,NULL);

			Call( ErrERRCheck( JET_errPermissionDenied ) );
			}
		}

	for (dwCurCtr = 0; dwCurCtr < dwPERFNumCounters; dwCurCtr++)
		{
		if (rgpcefPERFCEF[dwCurCtr](CEFInit,NULL))
			{
			for (dwCurCtr--; long( dwCurCtr ) >= 0; dwCurCtr--)
				rgpcefPERFCEF[dwCurCtr](CEFTerm,NULL);
			for (dwCurObj = dwPERFNumObjects-1; long( dwCurObj ) >= 0; dwCurObj--)
				rgpicfPERFICF[dwCurObj](ICFTerm,NULL);

			Call( ErrERRCheck( JET_errPermissionDenied ) );
			}
		}

	/*  initialize counter offsets and calculate instance size from template data
	/**/
	ppotObjectSrc = (PPERF_OBJECT_TYPE)pvPERFDataTemplate;
	ppidInstanceSrc = (PPERF_INSTANCE_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->DefinitionLength);
	cbMaxCounterBlockSize = QWORD_MULTIPLE( sizeof(PERF_COUNTER_BLOCK) );
	for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
		{
		ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->HeaderLength);
		dwOffset = QWORD_MULTIPLE( sizeof(PERF_COUNTER_BLOCK) );
		for (dwCurCtr = 0; dwCurCtr < ppotObjectSrc->NumCounters; dwCurCtr++)
			{
			ppcdCounterSrc->CounterOffset = dwOffset;
			dwOffset += QWORD_MULTIPLE( ppcdCounterSrc->CounterSize );

			ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppcdCounterSrc + ppcdCounterSrc->ByteLength);
			}

		cbMaxCounterBlockSize = max(cbMaxCounterBlockSize,dwOffset);

		ppotObjectSrc = (PPERF_OBJECT_TYPE)((char *)ppotObjectSrc + ppotObjectSrc->TotalByteLength);
		}
	cbInstanceSize = ppidInstanceSrc->ByteLength + cbMaxCounterBlockSize;

	/*  create our performance data thread
	/**/
	if ( !( hPERFEndDataThread = CreateEvent( NULL, FALSE, FALSE, NULL ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	Call( ErrUtilThreadCreate(	UtilPerfThread,
								OSMemoryPageReserveGranularity(),
								priorityTimeCritical,
								&threadPERFData,
								NULL ) );

	return JET_errSuccess;

HandleError:
	UtilPerfTerm();
	return err;
	}

void UtilPerfThreadTerm(void)
	{
	/*  terminate all resources
	/**/
	if ( hPERFReadyEvent )
		{
		SetHandleInformation( hPERFReadyEvent, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hPERFReadyEvent );
		hPERFReadyEvent = NULL;
		}

	if ( hPERFGoEvent )
		{
		SetHandleInformation( hPERFGoEvent, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hPERFGoEvent );
		hPERFGoEvent = NULL;
		}

	if ( pida )
		{
		VirtualFree( pida, 0, MEM_RELEASE );
		pida = NULL;
		}

	if ( pidaPERFIDA )
		{
		UnmapViewOfFile( pidaPERFIDA );
		pidaPERFIDA = NULL;
		}

	if ( hPERFIDAMMF )
		{
		SetHandleInformation( hPERFIDAMMF, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hPERFIDAMMF );
		hPERFIDAMMF = NULL;
		}

	if ( hPERFInstanceMutex )
		{
		ReleaseMutex( hPERFInstanceMutex );
		SetHandleInformation( hPERFInstanceMutex, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hPERFInstanceMutex );
		hPERFInstanceMutex = NULL;
		}

	if ( pgdaPERFGDA )
		{
		UnmapViewOfFile( pgdaPERFGDA );
		pgdaPERFGDA = NULL;
		}

	if ( hPERFGDAMMF )
		{
		SetHandleInformation( hPERFGDAMMF, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hPERFGDAMMF );
		hPERFGDAMMF = NULL;
		}
	}


ERR ErrUtilPerfThreadInit(void)
	{
	ERR							err							= JET_errSuccess;
	PSECURITY_DESCRIPTOR		pSD							= NULL;
	DWORD						cbSD;
	SECURITY_ATTRIBUTES			sa							= { 0 };
	_TCHAR						szT[ 256 ];

	//	generic read, write and execute granted to System, Built-in Administrators
	//	and Authenticated Users.  Authenticated users do also need write
	//	access to performance counter objects.
	//
    //	D:(A;;GA;;;SY)(A;;GA;;;BA)(A;;GA;;;AU)
    //
	if ( !ConvertStringSecurityDescriptorToSecurityDescriptor(
		"D:(A;;GA;;;SY)(A;;GA;;;BA)(A;;GA;;;AU)",
					SDDL_REVISION_1,
					&pSD,
					&cbSD) )
		{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	sa.nLength = cbSD;
    sa.bInheritHandle = FALSE;
    sa.lpSecurityDescriptor = pSD;

	/*  open/create the shared global data area
	/**/
	_stprintf( szT, _T( "%sGDA:  %s" ), SzPerfGlobal(), szPERFVersion );
	if ( !( hPERFGDAMMF = CreateFileMapping(	INVALID_HANDLE_VALUE,
												&sa,
												PAGE_READWRITE | SEC_COMMIT,
												0,
												PERF_SIZEOF_GLOBAL_DATA,
												szT ) ) )
		{
#ifdef DEBUG
		DWORD dw = GetLastError();
#endif

		Call( ErrERRCheck( JET_errPermissionDenied ) );
		}
	SetHandleInformation( hPERFGDAMMF, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	if ( !( pgdaPERFGDA = PGDA( MapViewOfFile(	hPERFGDAMMF,
												FILE_MAP_WRITE,
												0,
												0,
												0 ) ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	/*  find an instance number for which we can successfully gain ownership of
	/*  the instance mutex
	/**/
	DWORD iInstance;
	for ( iInstance = 0; iInstance < 256; iInstance++ )
		{
		_stprintf( szT, _T( "%sInstance%d:  %s" ), SzPerfGlobal(), iInstance, szPERFVersion );
		if ( !( hPERFInstanceMutex = CreateMutex( &sa, FALSE, szT ) ) )
			{
			Call( ErrERRCheck( JET_errPermissionDenied ) );
			}

		DWORD errWin;
		errWin = WaitForSingleObject( hPERFInstanceMutex, 0 );

		if ( errWin == WAIT_OBJECT_0 || errWin == WAIT_ABANDONED )
			{
			break;
			}

		CloseHandle( hPERFInstanceMutex );
		hPERFInstanceMutex = NULL;
		}
	if ( !hPERFInstanceMutex )
		{
		Call( ErrERRCheck( JET_errPermissionDenied ) );
		}

	SetHandleInformation( hPERFInstanceMutex, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	/*  open/create the shared instance data area
	/**/
	_stprintf( szT, _T( "%sIDA%d:  %s" ), SzPerfGlobal(), iInstance, szPERFVersion );
	if ( !( hPERFIDAMMF = CreateFileMapping(	INVALID_HANDLE_VALUE,
												&sa,
												PAGE_READWRITE | SEC_COMMIT,
												0,
												PERF_SIZEOF_INSTANCE_DATA,
												szT ) ) )
		{
		Call( ErrERRCheck( JET_errPermissionDenied ) );
		}
	SetHandleInformation( hPERFIDAMMF, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	if ( !( pidaPERFIDA = PIDA( MapViewOfFile(	hPERFIDAMMF,
												FILE_MAP_ALL_ACCESS,
												0,
												0,
												0 ) ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	/*  allocate our temp instance data area
	/**/
	if ( !( pida = PIDA( VirtualAlloc(	NULL,
										PERF_SIZEOF_INSTANCE_DATA,
										MEM_COMMIT,
										PAGE_READWRITE ) ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	/*	open/create the go event
	/**/
	_stprintf( szT, _T( "%sGo%d:  %s" ), SzPerfGlobal(), iInstance, szPERFVersion );
	if ( !( hPERFGoEvent = CreateEvent( &sa, TRUE, FALSE, szT ) ) )
		{
		Call( ErrERRCheck( JET_errPermissionDenied ) );
		}
	SetHandleInformation( hPERFGoEvent, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	/*	open/create the ready event
	/**/
	_stprintf( szT, _T( "%sReady%d:  %s" ), SzPerfGlobal(), iInstance, szPERFVersion );
	if ( !( hPERFReadyEvent = CreateEvent( &sa, TRUE, FALSE, szT ) ) )
		{
		Call( ErrERRCheck( JET_errPermissionDenied ) );
		}
	SetHandleInformation( hPERFReadyEvent, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	/*  make sure that the performance DLL will check this instance index
	/*
	/*  NOTE:  protect ourselves from corruption of the GDA
	/**/
	__try
		{
		size_t cAttempt		= 0;
		size_t cAttemptMax	= 1024;

		OSSYNC_FOREVER
			{
			unsigned long ulBIExpected;
			unsigned long ulAI;
			unsigned long ulBI;

			ulBIExpected	= pgdaPERFGDA->iInstanceMax;
			ulAI			= max( iInstance + 1, ulBIExpected );
			ulBI			= AtomicCompareExchange(	(long*)&pgdaPERFGDA->iInstanceMax,
														ulBIExpected,
														ulAI );

			if ( ulBI == ulBIExpected || iInstance < ulBI )
				{
				break;
				}
			if ( ++cAttempt > cAttemptMax )
				{
				err = ErrERRCheck( JET_errPermissionDenied );
				break;
				}
			}
		}
	__except( EXCEPTION_EXECUTE_HANDLER )
		{
		err = ErrERRCheck( JET_errPermissionDenied );
		}
	Call( err );

	/*  set our connect time
	/**/
	pida->tickConnect = GetTickCount();
	if ( !pida->tickConnect )
		{
		pida->tickConnect = 1;
		}

HandleError:
	LocalFree( pSD );
	if ( err < JET_errSuccess )
		{
		UtilPerfThreadTerm();
		}
	return err;
	}


/*  Performance Data thread  */

DWORD UtilPerfThread( DWORD_PTR parm )
	{
	DWORD						dwCurObj;
	DWORD						dwCurInst;
	DWORD						dwCurCtr;
	DWORD						dwCollectCtr;
	PPERF_OBJECT_TYPE			ppotObjectSrc;
	PPERF_INSTANCE_DEFINITION	ppidInstanceSrc;
	PPERF_INSTANCE_DEFINITION	ppidInstanceDest;
	PPERF_COUNTER_DEFINITION	ppcdCounterSrc;
	PPERF_COUNTER_BLOCK			ppcbCounterBlockDest;
	DWORD						cInstances;
	DWORD						cbSpaceNeeded;
	LPVOID						pvBlock;
	LPWSTR						lpwszInstName;
	LPWSTR						wszName;
	DWORD						cwchName;
	DWORD						cwchNameMax;

	if ( ErrUtilPerfThreadInit() < JET_errSuccess )
		{
		return 0;
		}

	for ( ; ; )
		{
		/*  set our ready event to indicate we are done collecting data and / or
		/*  we are ready to collect more data
		/**/
		SetEvent( hPERFReadyEvent );

		/*  wait to either be killed or to be told to collect data
		/**/
		const size_t	chWait				= 2;
		HANDLE			rghWait[ chWait ]	= { hPERFEndDataThread, hPERFGoEvent };
		if ( WaitForMultipleObjectsEx( chWait, rghWait, FALSE, INFINITE, FALSE ) == WAIT_OBJECT_0 )
			{
			break;
			}
		ResetEvent( hPERFGoEvent );

		/*  collect instances for all objects
		/**/
		for ( dwCurObj = 0, cInstances = 0; dwCurObj < dwPERFNumObjects; dwCurObj++ )
			{
			rglPERFNumInstances[dwCurObj] = rgpicfPERFICF[dwCurObj](ICFData,
												(const void **)( &rgwszPERFInstanceList[dwCurObj] ) );
			cInstances += rglPERFNumInstances[dwCurObj];
			}

		/*  calculate space needed to store instance data
		/*
		/*  Instance data for all objects is stored in our data block
		/*  in the following format:
		/*
		/*      //  Object 1
		/*      DWORD_PTR cInstances;
		/*      PERF_INSTANCE_DEFINITION rgpidInstances[cInstances];
		/*
		/*      . . .
		/*
		/*      //  Object n
		/*      DWORD_PTR cInstances;
		/*      PERF_INSTANCE_DEFINITION rgpidInstances[cInstances];
		/*
		/*  The performance DLL can read this structure because it also
		/*  knows how many objects we have and it can also check for the
		/*  end of our data block.
		/*
		/*  NOTE:  If an object has 0 instances, it only has cInstances
		/*      for its data.  No PIDs are produced.
		/**/
		cbSpaceNeeded = cInstances * cbInstanceSize + sizeof( DWORD_PTR ) * dwPERFNumObjects;
		pida->cbPerformanceData = cbSpaceNeeded;

		/*  verify that we have sufficient store to collect our data
		/**/
		Enforce( PERF_SIZEOF_INSTANCE_DATA - FIELD_OFFSET( IDA, rgbPerformanceData ) >= cbSpaceNeeded );

		/*	get a pointer to our data block
		/**/
		pvBlock = pida->rgbPerformanceData;

		/*	loop through all objects, filling our block with instance data
		/**/
		dwCurCtr = 0;
		ppotObjectSrc = (PPERF_OBJECT_TYPE)pvPERFDataTemplate;
		ppidInstanceSrc = (PPERF_INSTANCE_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->DefinitionLength);
		for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
			{
			/*	write the number of instances for this object to the block
			/**/
			*((DWORD_PTR *)pvBlock) = rglPERFNumInstances[dwCurObj];

			/*  get current instance name list
			/**/
			lpwszInstName = rgwszPERFInstanceList[dwCurObj];

			/*  loop through each instance
			/**/
			ppidInstanceDest = (PPERF_INSTANCE_DEFINITION)((char *)pvBlock + sizeof(DWORD_PTR));
			for ( dwCurInst = 0; dwCurInst < (DWORD)rglPERFNumInstances[dwCurObj]; dwCurInst++ )
				{
				/*	initialize instance/counter block from template data
				/**/
				UtilMemCpy((void *)ppidInstanceDest,(void *)ppidInstanceSrc,ppidInstanceSrc->ByteLength);
				ppcbCounterBlockDest = (PPERF_COUNTER_BLOCK)((char *)ppidInstanceDest + ppidInstanceDest->ByteLength);
				memset((void *)ppcbCounterBlockDest,0,cbMaxCounterBlockSize);
				ppcbCounterBlockDest->ByteLength = cbMaxCounterBlockSize;

				/*	no unique instance ID
				/**/
				ppidInstanceDest->UniqueID = PERF_NO_UNIQUE_ID;

				/*  NOTE:  performance DLL sets object hierarchy information  */

				/*	write instance name to buffer, avoiding overflow and illegal
				/*  characters ('#' and '/' in Win2k)
				/**/
				wszName = (wchar_t *)((char*)ppidInstanceDest + ppidInstanceDest->NameOffset);
				cwchNameMax = (ppidInstanceDest->ByteLength - ppidInstanceDest->NameOffset) / sizeof(wchar_t);
				for (cwchName = 0; cwchName < cwchNameMax && lpwszInstName[cwchName]; cwchName++)
					{
					switch ( lpwszInstName[cwchName] )
						{
						case L'#':
						case L'/':
							wszName[cwchName] = L'?';
							break;

						default:
							wszName[cwchName] = lpwszInstName[cwchName];
							break;
						}
					}
				wszName[cwchNameMax-1] = L'\0';
				ppidInstanceDest->NameLength = (ULONG)(wcslen(wszName)+1)*sizeof(wchar_t);
				lpwszInstName += wcslen(lpwszInstName)+1;

				/*  collect counter data for this instance
				/**/
				ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->HeaderLength);
				for (dwCollectCtr = 0; dwCollectCtr < ppotObjectSrc->NumCounters; dwCollectCtr++)
					{
					rgpcefPERFCEF[dwCollectCtr + dwCurCtr](dwCurInst,(void *)((char *)ppcbCounterBlockDest + ppcdCounterSrc->CounterOffset));
					ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppcdCounterSrc + ppcdCounterSrc->ByteLength);
					}
				ppidInstanceDest = (PPERF_INSTANCE_DEFINITION)((char *)ppidInstanceDest + cbInstanceSize);
				}
			dwCurCtr += ppotObjectSrc->NumCounters;
			ppotObjectSrc = (PPERF_OBJECT_TYPE)((char *)ppotObjectSrc + ppotObjectSrc->TotalByteLength);
			pvBlock = (void *)((char *)pvBlock + sizeof(DWORD_PTR) + cbInstanceSize * rglPERFNumInstances[dwCurObj]);
			}

		/*  copy our generated performance data into the IDA
		/*
		/*  NOTE:  protect ourselves from corruption of the IDA
		/**/
		__try
			{
			memcpy( pidaPERFIDA, pida, sizeof( IDA ) + pida->cbPerformanceData );
			}
		__except( EXCEPTION_EXECUTE_HANDLER )
			{
			}
		}

	UtilPerfThreadTerm();
	return 0;
	}


//  post-terminate perfmon subsystem

void OSPerfmonPostterm()
	{
	//  nop
	}

//  pre-init perfmon subsystem

BOOL FOSPerfmonPreinit()
	{
	//  nop

	return fTrue;
	}


//  terminate perfmon subsystem

void OSPerfmonTerm()
	{
	UtilPerfTerm();
	}

//  init perfmon subsystem

ERR ErrOSPerfmonInit()
	{
	ERR err = JET_errSuccess;

	//  start perfmon thread if we are on NT

	OSVERSIONINFO osvi;
	memset( &osvi, 0, sizeof( osvi ) );
	osvi.dwOSVersionInfoSize = sizeof( osvi );
	if ( GetVersionEx( &osvi ) && osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
		{
		Call( ErrUtilPerfInit() );
		}

HandleError:
	return err;
	}

#endif	//	MINIMAL_FUNCTIONALITY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\thread.cxx ===
#include "osstd.hxx"

#include <process.h>


//  Thread Local Storage

//  Internal TLS structure

#include "_tls.hxx"


//  Global TLS List

BOOL fcsTlsGlobalInit;
CRITICAL_SECTION csTlsGlobal;
_TLS* ptlsGlobal;

//  Allocated TLS Entry

//NOTE:	Cannot initialise this variable because the code that allocates
//		TLS and uses this variable to store the index executes before
//		CRTInit, which would subsequently re-initialise the variable
//		with the value specified here
//DWORD dwTlsIndex	= dwTlsInvalid;
DWORD dwTlsIndex;

//  registers the given Internal TLS structure as the TLS for this context

static BOOL FOSThreadITlsRegister( _TLS* ptls )
	{
	BOOL	fAllocatedTls	= fFalse;

	//  we are the first to register TLS

	EnterCriticalSection( &csTlsGlobal );

	if ( NULL == ptlsGlobal )
		{
		//  allocate a new TLS entry

		dwTlsIndex = TlsAlloc();
		if ( dwTlsInvalid == dwTlsIndex )
			{
			LeaveCriticalSection( &csTlsGlobal );
			return fFalse;
			}

		fAllocatedTls = fTrue;
		}

	Assert( dwTlsInvalid != dwTlsIndex );

	//  save the pointer to the given TLS
	const BOOL	fTLSPointerSet	= TlsSetValue( dwTlsIndex, ptls );
	if ( !fTLSPointerSet )
		{
		//	free TLS entry if we allocated one
		if ( fAllocatedTls )
			{
			Assert( NULL == ptlsGlobal );

			const BOOL	fTLSFreed	= TlsFree( dwTlsIndex );
			Assert( fTLSFreed );		//	leak the TLS entry if we fail

			dwTlsIndex = dwTlsInvalid;
			}

		LeaveCriticalSection( &csTlsGlobal );
		return fFalse;
		}

	//  add this TLS into the global list

	ptls->ptlsNext = ptlsGlobal;
	if ( ptls->ptlsNext )
		{
		ptls->ptlsNext->pptlsNext = &ptls->ptlsNext;
		}
	ptls->pptlsNext = &ptlsGlobal;
	ptlsGlobal = ptls;
	LeaveCriticalSection( &csTlsGlobal );

	return fTrue;
	}

//  unregisters the given Internal TLS structure as the TLS for this context

static void OSThreadITlsUnregister( _TLS* ptls )
	{
	//  there should be TLSs registered

	EnterCriticalSection( &csTlsGlobal );
	Assert( ptlsGlobal != NULL );
	
	//  remove our TLS from the global TLS list
	
	if( ptls->ptlsNext )
		{
		ptls->ptlsNext->pptlsNext = ptls->pptlsNext;
		}
	*( ptls->pptlsNext ) = ptls->ptlsNext;

	//  we are the last to unregister our TLS

	if ( ptlsGlobal == NULL )
		{
		//  deallocate TLS entry

		Assert( dwTlsInvalid != dwTlsIndex );

		const BOOL	fTLSFreed = TlsFree( dwTlsIndex );
		Assert( fTLSFreed );	//	leak the TLS entry if we fail

		dwTlsIndex = dwTlsInvalid;
		}

	LeaveCriticalSection( &csTlsGlobal );
	}


//  returns the pointer to the current context's local storage.  if the thread
//  does not yet have TLS, allocate it.

TLS* const Ptls()
	{
	_TLS* ptls	= ( NULL != ptlsGlobal ?
						reinterpret_cast<_TLS *>( TlsGetValue( dwTlsIndex ) ) :
						NULL );

	if ( NULL == ptls )
		{
		while ( !FOSThreadAttach() )
			{
			Sleep( 1000 );
			}

		Assert( dwTlsInvalid != dwTlsIndex );
		ptls = reinterpret_cast<_TLS *>( TlsGetValue( dwTlsIndex ) );
		}

	AssertPREFIX( NULL != ptls );
	return &( ptls->tls );
	}


//  Thread Management

//  suspends execution of the current context for the specified interval

void UtilSleep( const DWORD cmsec )
	{
	//  we should never sleep more than this arbitrary interval

	const DWORD cmsecWait = min( cmsec, 60 * 1000 );

	//  sleep

	SleepEx( cmsecWait, FALSE );
	}

//  thread base function (used by ErrUtilThreadCreate)

struct _THREAD
	{
	PUTIL_THREAD_PROC	pfnStart;
	DWORD_PTR			dwParam;
	const _TCHAR*		szStart;
	HANDLE				hThread;
	DWORD				idThread;
	BOOL				fFinish;
	BOOL				fEndSelf;
	};

DWORD WINAPI UtilThreadIThreadBase( _THREAD* const p_thread )
	{
	DWORD	dwExitCode;
	//  call thread function, catching any exceptions that might happen
	//  if requested

	extern BOOL g_fCatchExceptions;
	if ( g_fCatchExceptions )
		{
		TRY
			{
			dwExitCode = ( p_thread->pfnStart )( p_thread->dwParam );
			}
		EXCEPT( ExceptionFail( p_thread->szStart ) )
			{
			}
		ENDEXCEPT
		}
	else
		{
		dwExitCode = ( p_thread->pfnStart )( p_thread->dwParam );
		}

	//  declare this thread as done

	p_thread->fFinish = fTrue;

	//  cleanup our context if we are ending ourself

	if ( p_thread->fEndSelf )
		{
		UtilThreadEnd( THREAD( p_thread ) );
		}

	//  exit with code from thread function

	return dwExitCode;
	}

//  thread priority table

const DWORD rgthreadpriority[] =
	{
	THREAD_PRIORITY_IDLE,
	THREAD_PRIORITY_LOWEST,
	THREAD_PRIORITY_BELOW_NORMAL,
	THREAD_PRIORITY_NORMAL,
	THREAD_PRIORITY_ABOVE_NORMAL,
	THREAD_PRIORITY_HIGHEST,
	THREAD_PRIORITY_TIME_CRITICAL
	};

//  creates a thread with the specified attributes

const ERR ErrUtilThreadICreate(
	const PUTIL_THREAD_PROC		pfnStart,
	const DWORD					cbStack,
	const EThreadPriority		priority,
	THREAD* const				pThread,
	const DWORD_PTR				dwParam,
	const _TCHAR* const			szStart )
	{
	ERR err;
	
	//  allocate memory to pass thread args

	_THREAD* const p_thread = (_THREAD*)LocalAlloc( 0, sizeof( _THREAD ) );
	if ( p_thread == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  setup thread args

	p_thread->pfnStart		= pfnStart;
	p_thread->dwParam		= dwParam;
	p_thread->szStart		= szStart;
	p_thread->hThread		= NULL;
	p_thread->idThread		= 0;
	p_thread->fFinish		= fFalse;
	p_thread->fEndSelf		= fFalse;

	//  create the thread in suspended animation

	p_thread->hThread = HANDLE( CreateThread(	NULL,
												cbStack,
												LPTHREAD_START_ROUTINE( UtilThreadIThreadBase ),
												(void*) p_thread,
												CREATE_SUSPENDED,
												&p_thread->idThread ) );

	if ( !p_thread->hThread )
		{
		Call( ErrERRCheck( JET_errOutOfThreads ) );
		}
	SetHandleInformation( p_thread->hThread, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	
	//  set the thread priority, ignoring any errors encountered because we may
	//  not be allowed to set the priority for a legitimate reason (e.g. quotas)

	SetThreadPriority( p_thread->hThread, rgthreadpriority[ priority ] );

	//  activate the thread

	ResumeThread( p_thread->hThread );

	//  return the handle to the thread

	*pThread = THREAD( p_thread );
	return JET_errSuccess;

HandleError:
	UtilThreadEnd( THREAD( p_thread ) );
	*pThread = THREAD( NULL );
	return err;
	}

//  waits for the specified thread to exit and returns its return value

const DWORD UtilThreadEnd( const THREAD Thread )
	{
	DWORD dwExitCode = 0;
	
	//  we have a thread object
	
	_THREAD* const p_thread = (_THREAD*)Thread;

	if ( p_thread )
		{
		//  the thread was created successfully

		if ( p_thread->hThread )
			{
			//  we are trying to end ourself

			if ( p_thread->idThread == GetCurrentThreadId() )
				{
				//  indicate that we are ending ourself

				p_thread->fEndSelf = fTrue;

				//  do not actually end the thread until it has finished

				if ( !p_thread->fFinish )
					{
					return 0;
					}
				}

			//  we are trying to end another thread

			else
				{
				//  wait for the specified thread to either finish or terminate

				WaitForSingleObjectEx( p_thread->hThread, INFINITE, FALSE );

				//  fetch the thread's exit code

				GetExitCodeThread( p_thread->hThread, &dwExitCode );
				}

			//  cleanup the thread's context

			SetHandleInformation( p_thread->hThread, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
			CloseHandle( p_thread->hThread );
			}
		LocalFree( p_thread );
		}

	//  return the thread's exit code

	return dwExitCode;
	}

//  attaches to the current thread, returning fFalse on failure

const BOOL FOSThreadAttach()
	{
	//  allocate memory for this thread's TLS

	_TLS* const ptls = (_TLS*) LocalAlloc( LMEM_ZEROINIT, sizeof( _TLS ) );
	if ( !ptls )
		{
		return fFalse;
		}

	//  initialize internal TLS fields

	ptls->dwThreadId = GetCurrentThreadId();

	//  register our TLS

	if ( !FOSThreadITlsRegister( ptls ) )
		{
		//	free the entry and fail

		LocalFree( ptls );
		return fFalse;
		}

	return fTrue;
	}

//  detaches from the current thread

static void OSThreadIDetach( _TLS * const ptls )
	{
	//  unregister our TLS

	OSThreadITlsUnregister( ptls );

	//  free our TLS storage

	BOOL fFreedTLSOK = !LocalFree( ptls );
	Assert( fFreedTLSOK );	//	leak the TLS block if we fail
	}

void OSThreadDetach()
	{
	//  retrieve our TLS

	_TLS * const ptls	= ( NULL != ptlsGlobal ?
								reinterpret_cast<_TLS *>( TlsGetValue( dwTlsIndex ) ) :
								NULL );

	if ( NULL != ptls )
		{
		//  clear our TLS pointer from our TLS entry

		const BOOL	fTLSPointerSet	= TlsSetValue( dwTlsIndex, NULL );
		OSSYNCAssert( fTLSPointerSet );

		//	detach using this TLS pointer

		OSThreadIDetach( ptls );
		}
	}


//  returns the current thread's ID
//
//  CONSIDER:  remove our use Ptls()

const DWORD DwUtilThreadId()
	{
	return GetCurrentThreadId();
	}


//  post-terminate thread subsystem

void OSThreadPostterm()
	{
	//	remove any remaining TLS allocated by NT thread pool threads,
	//	which don't seem to perform a DLL_THREAD_DETACH when the
	//	process dies (this will also free any other TLS that got
	//	orphaned for whatever unknown reason)

	while ( ptlsGlobal )
		{
		OSThreadIDetach( ptlsGlobal );
		}

	if( fcsTlsGlobalInit )
		{
		DeleteCriticalSection( &csTlsGlobal );
		fcsTlsGlobalInit = fFalse;
		}
	}

//  pre-init thread subsystem

BOOL FOSThreadPreinit()
	{
	//  reset global TLS list

	InitializeCriticalSection( &csTlsGlobal );
	fcsTlsGlobalInit = fTrue;
	ptlsGlobal = NULL;
	dwTlsIndex = dwTlsInvalid;

	return fTrue;
	}


//  terminate thread subsystem

void OSThreadTerm()
	{
	//  nop
	}

//  init thread subsystem

ERR ErrOSThreadInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\trace.cxx ===
#include "osstd.hxx"


#ifdef MINIMAL_FUNCTIONALITY

VOID OSTracePostterm()		{}
BOOL FOSTracePreinit()		{ return fTrue; }
void OSTraceTerm()			{}
ERR ErrOSTraceInit()		{ return JET_errSuccess; }

#else


#include < stdio.h >


//  Info Strings

class COSInfoString
	{
	public:

		COSInfoString( const size_t cch ) { memset( m_szInfo + cch, 0, sizeof( COSInfoString ) - offsetof( COSInfoString, m_szInfo ) ); }
		~COSInfoString() {}

		char* String() { return m_szInfo; }

	public:

		static SIZE_T OffsetOfILE() { return offsetof( COSInfoString, m_ile ); }

	private:

		CInvasiveList< COSInfoString, OffsetOfILE >::CElement	m_ile;
		char													m_szInfo[ 1 ];
	};

class COSThreadContext
	{
	public:

		COSThreadContext();
		~COSThreadContext();

		char* AllocInfoString( const size_t cch );
		void FreeInfoStrings();

		void Indent( const int dLevel );
		int Indent();

	private:

		friend class COSThreadInfo;

		ULONG	m_cref;

	private:

		CInvasiveList< COSInfoString, COSInfoString::OffsetOfILE >	m_listInfoString;
		int															m_cIndent;
	};

inline COSThreadContext::COSThreadContext()
	:	m_cref( 0 ),
		m_cIndent( 0 )
	{
	}

inline COSThreadContext::~COSThreadContext()
	{
	FreeInfoStrings();
	}

inline char* COSThreadContext::AllocInfoString( const size_t cch )
	{
	const size_t			cbAlloc		= sizeof( COSInfoString ) + cch;
	COSInfoString* const	pinfostr	= reinterpret_cast< COSInfoString* >( new char[ cbAlloc ] );

	if ( pinfostr )
		{
		new( pinfostr ) COSInfoString( cch );
		m_listInfoString.InsertAsNextMost( pinfostr );
		}

	return pinfostr->String();
	}

inline void COSThreadContext::FreeInfoStrings()
	{
	while ( m_listInfoString.PrevMost() )
		{
		COSInfoString* const pinfostr = m_listInfoString.PrevMost();
		m_listInfoString.Remove( pinfostr );

		pinfostr->~COSInfoString();
		delete [] (char*)pinfostr;
		}
	}

inline void COSThreadContext::Indent( const int dLevel )
	{
	m_cIndent = dLevel ? m_cIndent + dLevel : 0;
	}

inline int COSThreadContext::Indent()
	{
	return m_cIndent;
	}


class COSThreadInfo
	{
	public:

		COSThreadInfo()
			{
			m_tid	= -1;
			m_ptc	= NULL;
			}

		COSThreadInfo(	const DWORD&			tid,
						COSThreadContext* const	ptc )
			{
			m_tid	= tid;
			m_ptc	= ptc;

			if ( m_ptc )
				{
				m_ptc->m_cref++;
				}
			}

		~COSThreadInfo()
			{
			if ( m_ptc && !( --( m_ptc->m_cref ) ) )
				{
				delete m_ptc;
				}

			m_tid	= -1;
			m_ptc	= NULL;
			}

		COSThreadInfo& operator=( const COSThreadInfo& threadinfo )
			{
			if ( m_ptc && !( --( m_ptc->m_cref ) ) )
				{
				delete m_ptc;
				}

			m_tid	= threadinfo.m_tid;
			m_ptc	= threadinfo.m_ptc;

			if ( m_ptc )
				{
				m_ptc->m_cref++;
				}

			return *this;
			}

	public:

		DWORD				m_tid;
		COSThreadContext*	m_ptc;
	};

typedef CTable< DWORD, COSThreadInfo > COSThreadTable;

inline int COSThreadTable::CKeyEntry:: Cmp( const DWORD& tid ) const
	{
	return m_tid - tid;
	}

inline int COSThreadTable::CKeyEntry:: Cmp( const COSThreadTable::CKeyEntry& keyentry ) const
	{
	return Cmp( keyentry.m_tid );
	}

CReaderWriterLock	g_rwlThreadTable( CLockBasicInfo( CSyncBasicInfo( "g_rwlThreadTable" ), -1000, 0 ) );
COSThreadTable		g_threadtable;

// rlanser:  01/30/2001: VisualStudio7#206324; NTBUG#301132
//#if defined(_M_IX86) && (_MSC_FULL_VER <= 13009037)
//#pragma optimize("g",off)
//#elif defined(_M_IA64) && (_MSC_FULL_VER <= 13009076)
//#pragma optimize("t",on)
//#endif
// rlanser:  01/31/2001:  less aggressive fix for the above problem
#if (defined(_M_IX86) && (_MSC_FULL_VER <= 13009037)) || (defined(_M_IA64) && (_MSC_FULL_VER <= 13009076))
#pragma inline_recursion(off)
#endif

COSThreadContext* OSThreadContext()
	{
	ERR err = JET_errSuccess;

	g_rwlThreadTable.EnterAsReader();
	const COSThreadInfo* pthreadinfo = g_threadtable.SeekEQ( GetCurrentThreadId() );
	g_rwlThreadTable.LeaveAsReader();

	if ( !pthreadinfo )
		{
		COSThreadInfo threadinfo( GetCurrentThreadId(), new COSThreadContext );
		Alloc( threadinfo.m_ptc );

		g_rwlThreadTable.EnterAsWriter();
		(void)g_threadtable.ErrLoad( 1, &threadinfo );

		pthreadinfo = g_threadtable.SeekEQ( GetCurrentThreadId() );
		g_rwlThreadTable.LeaveAsWriter();
		}

HandleError:
	return pthreadinfo ? pthreadinfo->m_ptc : NULL;
	}


char* OSAllocInfoString( const size_t cch )
	{
	COSThreadContext* const ptc = OSThreadContext();

	return ptc ? ptc->AllocInfoString( cch ) : NULL;
	}

void OSFreeInfoStrings()
	{
	__try
		{
		COSThreadContext* const ptc = OSThreadContext();

		if ( ptc )
			{
			ptc->FreeInfoStrings();
			}
		}
	__except( EXCEPTION_EXECUTE_HANDLER )
		{
		}
	}


//  Tracing

ERR ErrOSTraceDeferInit();

OSTraceLevel	g_ostlEffective		= ostlLow;

const char		g_mpostlsz[ ostlMax ][ 16 ] =
	{
	"None",
	"Low",
	"Medium",
	"High",
	"Very High",
	"Full",
	};

WCHAR			g_wszMutexTrace[]	= L"Global\\{5E5C36C0-5E7C-471f-84D7-110FDC1AFD0D}";
HANDLE			g_hMutexTrace		= NULL;
WCHAR			g_wszFileTrace[]	= L"\\Debug\\ESE.TXT";
HANDLE			g_hFileTrace		= NULL;

void OSTraceEmit( const char* const szRawTrace )
	{
	const size_t	cchPrefixMax				= 127;
	char			szPrefix[ cchPrefixMax + 1 ];
					szPrefix[ cchPrefixMax ]	= 0;
	size_t			cchPrefix					= 0;
	int				cchConsumed					= 0;

	const size_t	cchLocalMax					= 255;
	char			szLocal[ cchLocalMax + 1 ];
					szLocal[ cchLocalMax ]		= 0;
	char			szEOL[]						= "\r\n";

	size_t			cchTraceMax					= cchLocalMax;
	char*			szTrace						= szLocal;
	size_t			cchTrace					= 0;

	__try
		{
		//	get the current indent level for this trace on this thread

		COSThreadContext* const	ptc 			= OSThreadContext();
		const int				cIndentMin		= 0;
		const int				cIndentMax		= 16;
		const int				cchIndent		= 2;
		const int				cIndentThread	= ptc ? ptc->Indent() : 0;

		//  build the prefix string

		SYSTEMTIME systemtime;
		GetLocalTime( &systemtime );

		cchConsumed = _snprintf(	szPrefix + cchPrefix,
									cchPrefixMax - cchPrefix,
									"[%s %03x.%03x %04d/%02d/%02d-%02d:%02d:%02d]  ",
									SzUtilImageVersionName(),
									GetCurrentProcessId(),
									GetCurrentThreadId(),
									systemtime.wYear,
									systemtime.wMonth,
									systemtime.wDay,
									systemtime.wHour,
									systemtime.wMinute,
									systemtime.wSecond );
		cchPrefix = cchConsumed < 0 ? cchPrefixMax : cchPrefix + cchConsumed;

		//  try building the trace string in memory until it all fits

		do	{
			//  build the trace string

			cchTrace				= 0;
			szTrace[ cchTrace ]		= 0;

			const char*	szLast			= NULL;
			const char*	szCurr			= szRawTrace ? szRawTrace : "{null}";
			BOOL		fBOL			= TRUE;
			int 		cIndentTrace	= 0;

			while ( *szCurr )
				{
				if ( szCurr[ 0 ] == '\r' && szCurr[ 1 ] == '\r' )
					{
					if ( szCurr[ 2 ] == '+' && szCurr[ 3 ] == '\r' )
						{
						cIndentTrace++;
						szCurr += 4;
						continue;
						}
					else if ( szCurr[ 2 ] == '-' && szCurr[ 3 ] == '\r' )
						{
						cIndentTrace--;
						szCurr += 4;
						continue;
						}
					else
						{
						szCurr += 2;
						continue;
						}
					}

				if ( fBOL )
					{
					const int cIndent = min( cIndentMax, max( cIndentMin, cIndentThread + cIndentTrace ) );

					cchConsumed = _snprintf(	szTrace + cchTrace,
												cchTraceMax - cchTrace,
												"%-*.*s",
												min( cchPrefixMax, cchPrefix + cchIndent * cIndent ),
												cchPrefixMax,
												szPrefix );
					cchTrace = cchConsumed < 0 ? cchTraceMax : cchTrace + cchConsumed;

					fBOL = FALSE;
					}

				szLast = szCurr;
				szCurr = szCurr + strcspn( szLast, "\r\n" );

				cchConsumed = _snprintf(	szTrace + cchTrace,
											cchTraceMax - cchTrace,
											"%.*s%s",
											szCurr - szLast,
											szLast,
											szEOL );
				cchTrace = cchConsumed < 0 ? cchTraceMax : cchTrace + cchConsumed;

				if ( szCurr[ 0 ] == '\r' && szCurr[ 1 ] != '\r' )
					{
					szCurr++;
					}
				if ( szCurr[ 0 ] == '\n' )
					{
					fBOL = TRUE;
					szCurr++;
					}
				}

			if ( cchTrace == cchTraceMax )
				{
				if ( szTrace != szLocal )
					{
					LocalFree( szTrace );
					}

				cchTraceMax	= 2 * cchTraceMax;
				szTrace		= (char*)LocalAlloc( 0, cchTraceMax + 1 );
				if ( szTrace )
					{
					szTrace[ cchTraceMax ] = 0;
					}
				cchTrace	= cchTraceMax;
				}
			}
		while ( cchTrace == cchTraceMax && szTrace );

		//  emit the trace

		if ( szTrace )
			{
			OutputDebugStringA( szTrace );

			DWORD cbT;
			WaitForSingleObjectEx( g_hMutexTrace, INFINITE, FALSE );
			if ( SetFilePointer( g_hFileTrace, 0, NULL, FILE_END ) != INVALID_SET_FILE_POINTER )
				{
				WriteFile( g_hFileTrace, szTrace, min( DWORD( -1 ), cchTrace ), &cbT, NULL );
				}
			ReleaseMutex( g_hMutexTrace );
			}

		if ( szTrace != szLocal )
			{
			LocalFree( szTrace );
			}
		}
	__except( EXCEPTION_EXECUTE_HANDLER )
		{
		__try
			{
			if ( szTrace != szLocal )
				{
				LocalFree( szTrace );
				}
			}
		__except( EXCEPTION_EXECUTE_HANDLER )
			{
			}
		}
	}

void OSTrace_( const char* const szTrace )
	{
	__try
		{
		//  emit the trace

		if ( ErrOSTraceDeferInit() >= JET_errSuccess )
			{
			OSTraceEmit( szTrace );
			}

		//  garbage-collect info strings.  note that we must always do this if
		//  this function is called because info strings may have been created
		//  when computing the variable argument list

		OSFreeInfoStrings();
		}
	__except( EXCEPTION_EXECUTE_HANDLER )
		{
		__try
			{
			OSFreeInfoStrings();
			}
		__except( EXCEPTION_EXECUTE_HANDLER )
			{
			}
		}
	}

void OSTraceIndent_( const int dLevel )
	{
	__try
		{
		//  change our indent level

		COSThreadContext* const ptc = OSThreadContext();

		if ( ptc )
			{
			ptc->Indent( dLevel );
			}
		}
	__except( EXCEPTION_EXECUTE_HANDLER )
		{
		}
	}


//  Trace Formatting

const char* OSFormat_( const char* const szFormat, va_list arglist )
	{
	const size_t	cchLocalMax					= 256;
	char			szLocal[ cchLocalMax ];

	size_t			cchBufferMax				= cchLocalMax;
	char*			szBuffer					= szLocal;

	char*			szInfoString				= NULL;

	__try
		{
		//  try formatting the string in memory until it all fits

		size_t	cchRawMax;
		char*	szRaw;
		size_t	cchRaw;
		int		cchConsumed;

		do	{
			cchRawMax				= cchBufferMax - 1;
			szRaw					= szBuffer;
			szRaw[ cchRawMax ]		= 0;
			cchRaw					= 0;

			cchConsumed = _vsnprintf(	szRaw + cchRaw,
										cchRawMax - cchRaw,
										szFormat,
										arglist );
			cchRaw = cchConsumed < 0 ? cchRawMax : cchRaw + cchConsumed;

			if ( cchRaw == cchRawMax )
				{
				if ( szBuffer != szLocal )
					{
					LocalFree( szBuffer );
					}

				cchBufferMax	= 2 * cchBufferMax;
				szBuffer		= (char*)LocalAlloc( 0, cchBufferMax );
				}
			}
		while ( cchRaw == cchRawMax && szBuffer );

		//  copy the finished string into an Info String for return

		if ( szBuffer )
			{
			szInfoString = OSAllocInfoString( cchRaw );
			if ( szInfoString )
				{
				memcpy( szInfoString, szRaw, cchRaw );
				}
			}

		if ( szBuffer != szLocal )
			{
			LocalFree( szBuffer );
			}
		}
	__except( EXCEPTION_EXECUTE_HANDLER )
		{
		__try
			{
			if ( szBuffer != szLocal )
				{
				LocalFree( szBuffer );
				}
			}
		__except( EXCEPTION_EXECUTE_HANDLER )
			{
			}
		}

	return szInfoString;
	}

const char* __cdecl OSFormat( const char* const szFormat, ... )
	{
	va_list arglist;
	va_start( arglist, szFormat );

	return OSFormat_( szFormat, arglist );
	}

const char* OSFormatFileLine( const char* const szFile, const int iLine )
	{
	const char*	szFilename1	= strrchr( szFile, '/' );
	const char*	szFilename2	= strrchr( szFile, '\\' );
	const char*	szFilename	= (	szFilename1 ?
									(	szFilename2 ?
											max( szFilename1, szFilename2 ) + 1 :
											szFilename1 + 1 ) :
									(	szFilename2 ?
											szFilename2 + 1 :
											szFile ) );

	return OSFormat( "%s(%i)", szFilename, iLine );
	}

const char* OSFormatImageVersion()
	{
	return OSFormat(	"%s version %d.%02d.%04d.%04d (%s)",
						SzUtilImageVersionName(),
						DwUtilImageVersionMajor(),
						DwUtilImageVersionMinor(),
						DwUtilImageBuildNumberMajor(),
						DwUtilImageBuildNumberMinor(),
						SzUtilImageBuildClass() );
	}

const char* OSFormatBoolean( const BOOL f )
	{
	return f ? "True" : "False";
	}

const char* OSFormatPointer( const void* const pv )
	{
	return pv ? OSFormat( "%0*I64X", 2 * sizeof( pv ), __int64( pv ) ) : "NULL";
	}

const char* OSFormatError( const ERR err )
	{
	extern VOID JetErrorToString( JET_ERR err, const char** szError, const char** szErrorText );

	const char* 	szError			= NULL;
	const char*		szErrorText		= NULL;

	JetErrorToString( err, &szError, &szErrorText );

	return szError ? szError : OSFormat( "JET API error %dL", err );
	}

const char* OSFormatSigned( const LONG_PTR l )
	{
	return OSFormat( "%I64d", __int64( l ) );
	}

const char* OSFormatUnsigned( const ULONG_PTR ul )
	{
	return OSFormat( "%I64u", __int64( ul ) );
	}

const char* OSFormatRawData(	const BYTE* const	rgbData,
								const size_t		cbData,
								const size_t		cbAddr,
								const size_t		cbLine,
								const size_t		cbWord,
								const size_t		ibData )
	{
	//  00000000:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

	const size_t	cchAddr	= 2 * cbAddr + ( cbAddr ? 1 : 0 );
	const size_t	cchHex	= 2 * cbLine + ( cbLine + cbWord - 1 ) / cbWord - 1;
	const size_t	cchChar	= cbLine;
	const size_t	cchLine	= cchAddr + ( cchAddr ? 2 : 0 ) + cchHex + 2 + cchChar + 1;

	char* const		szLine	= OSAllocInfoString( cchLine );
	char* const		szAddr	= szLine;
	char* const		szHex	= szLine + cchAddr + ( cchAddr ? 2 : 0 );
	char* const		szChar	= szLine + cchAddr + ( cchAddr ? 2 : 0 ) + cchHex + 2;

	//  build line

	static const char rgchHex[] = "0123456789abcdef";

	memset( szLine, ' ', cchLine );

	for ( size_t ibAddr = 0; ibAddr < cbAddr; ibAddr++ )
		{
		szAddr[ 2 * ibAddr ]		= rgchHex[ ( ibData >> ( 8 * ( cbAddr - ibAddr - 1 ) + 4 ) ) & 0xf ];
		szAddr[ 2 * ibAddr + 1 ]	= rgchHex[ ( ibData >> ( 8 * ( cbAddr - ibAddr - 1 ) ) ) & 0xf ];
		}
	if ( cbAddr )
		{
		szAddr[ 2 * cbAddr ] = ':';
		}

	for ( size_t ibLine = 0; ibLine < cbLine && ibData + ibLine < cbData; ibLine += cbWord )
		{
		for ( size_t ibWord = 0; ibWord < cbWord; ibWord++ )
			{
			const size_t	ibDataRead	= ibData + ibLine + cbWord - ibWord - 1;
			BOOL			fVisible	= ibDataRead < cbData;
			char			bDataRead	= '\0';
			const size_t	ichHex		= 2 * ( ibLine + ibWord ) + ibLine / cbWord;
			const size_t	ichChar		= ibLine + cbWord - ibWord - 1;

			__try
				{
				bDataRead = rgbData[ ibDataRead ];
				}
			__except( EXCEPTION_EXECUTE_HANDLER )
				{
				fVisible = fFalse;
				}

			szHex[ ichHex ]		= !fVisible ? '?' : rgchHex[ ( bDataRead >> 4 ) & 0xf ];
			szHex[ ichHex + 1 ]	= !fVisible ? '?' : rgchHex[ bDataRead & 0xf ];
			szChar[ ichChar ]	= !fVisible ? '?' : ( isprint( bDataRead ) && bDataRead != '\t' ? bDataRead : '.' );
			}
		}

	szLine[ cchLine - 1 ] = '\n';

	//  build stream of lines

	if ( ibData + cbLine >= cbData )
		{
		return szLine;
		}
	else
		{
		const char*	szSuffix	= OSFormatRawData(	rgbData,
													cbData,
													cbAddr,
													cbLine,
													cbWord,
													ibData + cbLine );
		char* const	szTotal		= OSAllocInfoString( strlen( szLine ) + strlen( szSuffix ) );

		strcpy( szTotal, szLine );
		strcat( szTotal, szSuffix );

		return szTotal;
		}
	}


//  Trace Init / Term

void OSTracePostterm()
	{
	//  nop
	}

BOOL FOSTracePreinit()
	{
	const int		cbBuf			= 256;
	_TCHAR			szBuf[ cbBuf ];

	if (	FOSConfigGet( _T( "DEBUG" ), _T( "Trace Level" ), szBuf, cbBuf ) &&
			szBuf[ 0 ] )
		{
		_TCHAR*			szT	= NULL;
		const DWORD		dw	= _tcstoul( szBuf, &szT, 0 );
		if ( !( *szT ) )
			{
			g_ostlEffective = OSTraceLevel( min( ostlMax - 1, dw ) );
			}
		}

	return fTrue;
	}

void OSTraceTerm()
	{
	//  nop
	}

ERR ErrOSTraceInit()
	{
	//  nop

	return JET_errSuccess;
	}

ERR ErrOSTraceIGetSystemWindowsDirectory( LPWSTR lpBuffer, UINT uSize )
	{
	typedef WINBASEAPI UINT WINAPI PFNGetSystemWindowsDirectoryW( LPWSTR, UINT );

	ERR								err								= JET_errSuccess;
	HMODULE							hmodKernel32					= NULL;
	PFNGetSystemWindowsDirectoryW*	pfnGetSystemWindowsDirectoryW	= NULL;

	if (	( hmodKernel32 = LoadLibrary( "kernel32.dll" ) ) &&
			( pfnGetSystemWindowsDirectoryW = (PFNGetSystemWindowsDirectoryW*)GetProcAddress( hmodKernel32, "GetSystemWindowsDirectoryW" ) ) )
		{
		if ( !pfnGetSystemWindowsDirectoryW( lpBuffer, uSize ) )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		}
	else
		{
		if ( !GetWindowsDirectoryW( lpBuffer, uSize ) )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		}

HandleError:
	if ( hmodKernel32 )
		{
		FreeLibrary( hmodKernel32 );
		}
	return err;
	}

void OSTraceITerm()
	{
	OSTrace(	ostlMedium,
				OSFormat(	"%s unloaded.",
							OSFormatImageVersion() ) );
	g_threadtable.~COSThreadTable();

	if ( g_hFileTrace )
		{
		CloseHandle( g_hFileTrace );
		g_hFileTrace = NULL;
		}
	if ( g_hMutexTrace )
		{
		CloseHandle( g_hMutexTrace );
		g_hMutexTrace = NULL;
		}
	}

ERR ErrOSTraceIInit()
	{
	ERR				err				= JET_errSuccess;
	const size_t	cchPathTrace	= 2 * _MAX_PATH;
	WCHAR			wszPathTrace[ cchPathTrace ];

	if (	!( g_hMutexTrace = CreateMutexW( NULL, FALSE, g_wszMutexTrace ) ) &&
			!( g_hMutexTrace = CreateMutexW( NULL, FALSE, wcsrchr( g_wszMutexTrace, L'\\' ) + 1 ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	Call( ErrOSTraceIGetSystemWindowsDirectory( wszPathTrace, cchPathTrace * sizeof( WCHAR ) ) );
	wcscat( wszPathTrace, g_wszFileTrace );

	if ( ( g_hFileTrace = CreateFileW(	wszPathTrace,
										GENERIC_WRITE,
										FILE_SHARE_READ | FILE_SHARE_WRITE,
										NULL,
										OPEN_ALWAYS,
										FILE_ATTRIBUTE_NORMAL,
										NULL ) ) == INVALID_HANDLE_VALUE )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

HandleError:
	OSTrace(	ostlMedium,
				OSFormat(	"%s loaded.\r\n"
							OSTRACEINDENTSZ
							"Image:              \"%s\"\r\n"
							"Process:            \"%s\"\r\n"
							"Trace File:         \"%S\"%s\r\n"
							"Trace Level:        %s\r\n"
							OSTRACEUNINDENTSZ,
							OSFormatImageVersion(),
							SzUtilImagePath(),
							SzUtilProcessPath(),
							wszPathTrace,
 							g_hFileTrace ? "" : " (open failed)",
							g_mpostlsz[ g_ostlEffective ] ) );

	if ( err < JET_errSuccess )
		{
		if ( g_hFileTrace )
			{
			CloseHandle( g_hFileTrace );
			g_hFileTrace = NULL;
			}
		if ( g_hMutexTrace )
			{
			CloseHandle( g_hMutexTrace );
			g_hMutexTrace = NULL;
			}
		}
	return err;
	}


class COSTraceDeferInit
	{
	public:

		COSTraceDeferInit();
		~COSTraceDeferInit();

		ERR ErrInit();
		void Term();

	private:

		BOOL						m_fInit;
		CNestableCriticalSection	m_ncritInit;
		BOOL						m_fInitInProgress;
		ERR							m_errInit;
	};

COSTraceDeferInit::COSTraceDeferInit()
	:	m_fInit( fFalse ),
		m_ncritInit( CLockBasicInfo( CSyncBasicInfo( "COSTraceDeferInit::m_ncritInit" ), 0, 0 ) ),
		m_fInitInProgress( fFalse ),
		m_errInit( JET_errSuccess )
	{
	}

COSTraceDeferInit::~COSTraceDeferInit()
	{
	Term();
	}

ERR COSTraceDeferInit::ErrInit()
	{
	if ( !m_fInit )
		{
		m_ncritInit.Enter();
		if ( !m_fInit )
			{
			if ( !m_fInitInProgress )
				{
				m_fInitInProgress	= fTrue;
				m_errInit			= ErrOSTraceIInit();
				m_fInitInProgress	= fFalse;
				m_fInit				= fTrue;
				}
			}
		m_ncritInit.Leave();
		}

	return m_errInit;
	}

void COSTraceDeferInit::Term()
	{
	OSTraceITerm();
	}

COSTraceDeferInit g_ostracedeferinit;

ERR ErrOSTraceDeferInit()
	{
	return g_ostracedeferinit.ErrInit();
	}

#endif	//	MINIMAL_FUNCTIONALITY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\task.cxx ===
#include "osstd.hxx"


LOCAL BOOL			fCanUseIOCP;

LOCAL const CHAR *	szCritTaskList		= "CTaskManager::m_critTask";
LOCAL const CHAR *	szCritActiveThread	= "CTaskManager::m_critActiveThread";
LOCAL const INT		rankCritTaskList	= 0;

LOCAL const CHAR *	szSemTaskDispatch	= "CTaskManager::m_semTaskDispatch";

LOCAL const CHAR *	szAsigAllDone		= "CGPTaskManager::m_asigAllDone";

LOCAL const CHAR *	szRwlPostTasks		= "CGPTaskManager::m_rwlPostTasks";
LOCAL const INT		rankRwlPostTasks	= 10;


////////////////////////////////////////////////
//
//	Generic Task Manager
//

//	ctor

CTaskManager::CTaskManager()
	:	m_critTask( CLockBasicInfo( CSyncBasicInfo( szCritTaskList ), rankCritTaskList, 0 ) ),
		m_critActivateThread( CLockBasicInfo( CSyncBasicInfo( szCritTaskList ), rankCritTaskList, 0 ) ),
		m_semTaskDispatch( CSyncBasicInfo( szSemTaskDispatch ) )
	{
	m_cThread			= 0;
	m_cThreadMax		= 0;
	m_cPostedTasks		= 0;
	m_cmsLastActivateThreadTime	= 0;
	m_cTasksThreshold	= 0;

#ifdef DEBUG
	m_fIgnoreTasksAmountAsserts	= fFalse;
#endif // DEBUG
	m_rgThreadContext	= NULL;

	m_rgpTaskNode		= NULL;

	m_hIOCPTaskDispatch	= NULL;

	m_dtickTimeout		= 0;
	m_pfnTimeout		= NULL;
	}


//	dtor

CTaskManager::~CTaskManager()
	{
	}


//	initialize the task manager
//	NOTE: this is not thread-safe with respect to TMTerm or itself

ERR CTaskManager::ErrTMInit(	const ULONG						cThread,
								const DWORD_PTR *const			rgThreadContext,
								const TICK						dtickTimeout,
								CTaskManager::PfnCompletion		pfnTimeout,
								const BOOL						fForceMaxThreads )
	{
	ERR err;

	Assert( 0 == m_cThread );
	Assert( !m_rgThreadContext );
	Assert( m_ilTask.FEmpty() );
	Assert( 0 == m_semTaskDispatch.CAvail() );
	Assert( !m_rgpTaskNode );
	Assert( !m_hIOCPTaskDispatch );

	m_dtickTimeout	= dtickTimeout;
	m_pfnTimeout	= pfnTimeout;

	if ( !fCanUseIOCP )
		{
		ULONG iThread;

		//	allocate extra task-nodes for TMTerm (prevents out-of-memory)
		//	NOTE: they must be allocated separately so they can be freed separately

		m_rgpTaskNode = new CTaskNode*[cThread];
		if ( !m_rgpTaskNode )
			{
			Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
			}
		memset( m_rgpTaskNode, 0, cThread * sizeof( CTaskNode * ) );
		for ( iThread = 0; iThread < cThread; iThread++ )
			{
			m_rgpTaskNode[iThread] = new CTaskNode();
			if ( !m_rgpTaskNode[iThread] )
				{
				Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
				}
			}
		}

	//	allocate THREAD handles

	m_cThread = 0;
	m_rgThreadContext = new THREADCONTEXT[cThread];
	if ( !m_rgThreadContext )
		{
		Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
		}
	memset( m_rgThreadContext, 0, sizeof( THREADCONTEXT ) * cThread );

	//	initialize dispatcher

	if ( fCanUseIOCP )
		{

		//	create an I/O completion port for posting tasks

		m_hIOCPTaskDispatch = CreateIoCompletionPort( INVALID_HANDLE_VALUE, NULL, 0, 0 );
		if ( !m_hIOCPTaskDispatch )
			{
			Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
			}
		}
	else
		{

		//	setup the task-node list

		//	nop (done by ctor)
		}

	Assert( cThread < 1000 );
	m_cThreadMax = cThread;

	//	prepare the thread context

	if ( rgThreadContext )
		{
		
		for ( m_cThread = 0; m_cThread < cThread; m_cThread++ )
			{
			m_rgThreadContext[m_cThread].dwThreadContext = rgThreadContext[m_cThread];
			}
		}
	for ( m_cThread = 0; m_cThread < cThread; m_cThread++ )
		{
		m_rgThreadContext[m_cThread].ptm = this;
		}
	m_cThread = 0;

	//  one fake posted task to initialize thread checker

	m_cPostedTasks = 1;
	Call( ErrAddThreadCheck( fForceMaxThreads ) );
	m_cPostedTasks = 0;

	Assert( fForceMaxThreads ? cThread == m_cThread : 1 == m_cThread );

	return JET_errSuccess;

HandleError:

	//	cleanup

	TMTerm();

	return err;
	}


//	cleanup the task manager
//	NOTE: this is not thread-safe with respect to ErrTMInit or itself

VOID CTaskManager::TMTerm()
	{
	ULONG iThread;
	ULONG cThread;

	// stop eventual growing of the threads' number in the thread pool

	m_critActivateThread.Enter();
	m_cTasksThreshold = -1;
	m_cThreadMax = 0;
	m_critActivateThread.Leave();

	//	capture the number of active threads

	cThread = m_cThread;

	if ( NULL != m_rgThreadContext )
		{
		//	post a set of fake tasks that will cause the worker threads to exit gracefully

		for ( iThread = 0; iThread < cThread; iThread++ )
			{
			if ( fCanUseIOCP )
				{
				ERR		errPost;

				//	try to post a task to the I/O completion port

				Assert( m_hIOCPTaskDispatch );
				while ( ( errPost = ErrTMPost( TMITermTask, 0, 0 ) ) != JET_errSuccess )
					{
					//	if we couldn't post the task, something must be
					//	horribly wrong (kernel has exhausted paged pool?),
					//	but we need this to succeed in order to terminate
					//	properly, so no choice but to keep retrying forever
					//
					CallS( errPost );					
					UtilSleep( 1000 );
					}
				}
			else
				{
				//	verify the extra task-node

				Assert( m_rgpTaskNode );
				Assert( m_rgpTaskNode[iThread] );

				//	initialize the extra task-node

				m_rgpTaskNode[iThread]->m_pfnCompletion = TMITermTask;

				//	post the task

				m_critTask.Enter();
				m_ilTask.InsertAsNextMost( m_rgpTaskNode[iThread] );
				m_critTask.Leave();
				m_semTaskDispatch.Release();

				//	prevent cleanup from freeing the extra task-node

				m_rgpTaskNode[iThread] = NULL;
				}
			}

		//	wait for each thread to exit

		for ( iThread = 0; iThread < cThread; iThread++ )
			{
			if ( m_rgThreadContext[iThread].thread )
				{
				UtilThreadEnd( m_rgThreadContext[iThread].thread );
				}
			}

		//	cleanup the thread array

		delete m_rgThreadContext;
		}
	m_rgThreadContext = NULL;
	m_cThread = 0;
	m_cTasksThreshold = 0;
	m_cmsLastActivateThreadTime = 0;

	//	term the task-list (it should be empty at this point)

	Assert( m_ilTask.FEmpty() );
	if ( !m_ilTask.FEmpty() )
		{
		//	lock the task list

		m_critTask.Enter();
		
		while ( !m_ilTask.FEmpty() )
			{
			CTaskNode *ptn = m_ilTask.PrevMost();
			m_ilTask.Remove( ptn );
			delete ptn;
			}

		m_critTask.Leave();
		}

	Assert( 0 == m_semTaskDispatch.CAvail() );
	while ( m_semTaskDispatch.FTryAcquire() )
		{
		}

	//	cleanup the extra task-nodes

	if ( m_rgpTaskNode )
		{
		for ( iThread = 0; iThread < m_cThread; iThread++ )
			{
			delete m_rgpTaskNode[iThread];
			}
		delete [] m_rgpTaskNode;
		}
	m_rgpTaskNode = NULL;

	//	cleanup the I/O completion port

	if ( m_hIOCPTaskDispatch )
		{
		const BOOL fCloseOk = CloseHandle( m_hIOCPTaskDispatch );
		Assert( fCloseOk );
		}
	m_hIOCPTaskDispatch = NULL;
	}


//	post a task

ERR CTaskManager::ErrTMPost(	CTaskManager::PfnCompletion	pfnCompletion,
								const DWORD					dwCompletionKey1,
								const DWORD_PTR				dwCompletionKey2 )
	{

	//	verify input

	Assert( pfnCompletion );

	Assert( m_cThread > 0 );

	//	Increment the number of eventually posted tasks

	AtomicIncrement( (LONG *)&m_cPostedTasks );
	(VOID)ErrAddThreadCheck( fFalse );

	if ( fCanUseIOCP )
		{

		//	we will be posting a task to the I/O completion port

		Assert( m_hIOCPTaskDispatch );

		//	post the task to the I/O completion port

		BOOL fPostedOk = PostQueuedCompletionStatus(	m_hIOCPTaskDispatch,
														dwCompletionKey1,
														DWORD_PTR( pfnCompletion ),
														(OVERLAPPED*)dwCompletionKey2 );
		if ( !fPostedOk )
			{

			//	correct the number of posted tasks
			
			AtomicDecrement( (LONG *)&m_cPostedTasks );
			return ErrERRCheck( JET_errOutOfMemory );
			}
		}
	else
		{

		//	allocate a task-list node using the given context

		CTaskNode *ptn = new CTaskNode();
		if ( !ptn )
			{

			//	correct the number of posted tasks
			
			AtomicDecrement( (LONG *)&m_cPostedTasks );
			return ErrERRCheck( JET_errOutOfMemory );
			}
		ptn->m_pfnCompletion = pfnCompletion;
		ptn->m_dwCompletionKey1 = dwCompletionKey1;
		ptn->m_dwCompletionKey2 = dwCompletionKey2;

		//	post the task

		m_critTask.Enter();
		m_ilTask.InsertAsNextMost( ptn );
		m_critTask.Leave();
		m_semTaskDispatch.Release();
		}

	return JET_errSuccess;
	}


//	special API to allow files to register with the task manager's I/O completion port

BOOL CTaskManager::FTMRegisterFile( VOID *hFile, CTaskManager::PfnCompletion pfnCompletion )
	{
	HANDLE hIOCP;

	//	verify input

	Assert( hFile );
	Assert( pfnCompletion );

	//  if we can't use I/O completion ports then we don't need to do anything

	if ( !fCanUseIOCP )
		{
		return fTrue;
		}

	//	we should have an I/O completion port allocated

	Assert( m_hIOCPTaskDispatch );

	//	register the file handle with the I/O completion port
	//
	//	notes on how this works:
	//
	//		When async-file-I/O completes, it will post a completion packet which will wake up a 
	//		CTaskManager thread.  The thread will interpret the parameters of the completion
	//		as if they came from ErrTMPost via PostQueuedCompletionStatus.  Therefore, we must
	//		make sure that the I/O completion looks and acts like one from ErrTMPost.
	//
	//		ErrTMPost interprets the completion packet like this:
	//
	//			number of bytes transferred ==> dwCompletionKey1 (DWORD)
	//			completion key              ==> pfnCompletion    (DWORD_PTR)
	//			ptr to overlapped structure ==> dwCompletionKey2 (DWORD_PTR)
	//
	//		We make the "completion key" a function pointer by passing in the address of the
	//		specified I/O handler (pfnCompletion).  The number of bytes transferred and the
	//		overlapped ptr are specified at I/O-issue time.

	hIOCP = CreateIoCompletionPort( hFile, m_hIOCPTaskDispatch, DWORD_PTR( pfnCompletion ), 0 );
	Assert( NULL == hIOCP || hIOCP == m_hIOCPTaskDispatch );
	if ( NULL != hIOCP && m_cThread < m_cThreadMax )
		{
		//	We are not able to perform gracefully growing of the threads number
		//	because the task can be issued without using ErrTMPost
		//	and we have no control over real number of posted tasks
		//	Thus we will try to create Max number of threads
		ERR err = JET_errSuccess;
		m_critActivateThread.Enter();
		for ( ; m_cThread < m_cThreadMax && JET_errSuccess <= err; m_cThread ++ )
			{
			//	create the thread
			
			err = ErrUtilThreadCreate(	PUTIL_THREAD_PROC( TMDispatch ),
										OSMemoryPageReserveGranularity(),
										priorityNormal,
										&m_rgThreadContext[m_cThread].thread,
										DWORD_PTR( m_rgThreadContext + m_cThread ) );
			}
		AtomicExchange( (LONG *)&m_cTasksThreshold, -1 );
#ifdef DEBUG
		m_fIgnoreTasksAmountAsserts = fTrue;
#endif // DEBUG
		m_critActivateThread.Leave();
		}

	return BOOL( NULL != hIOCP );
	}


//	dispatch a task (wrapper for TMIDispatch)

DWORD CTaskManager::TMDispatch( DWORD_PTR dwContext )
	{
	THREADCONTEXT *ptc;
	
	//	extract the context

	Assert( 0 != dwContext );
	ptc = (THREADCONTEXT *)dwContext;

	//	run the internal dispatcher

	ptc->ptm->TMIDispatch( ptc->dwThreadContext );

	return 0;
	}


//	main task dispatcher (thread-body for workers)

VOID CTaskManager::TMIDispatch( const DWORD_PTR dwThreadContext )
	{
	PfnCompletion	pfnCompletion;
	DWORD			dwCompletionKey1;
	DWORD_PTR		dwCompletionKey2;

	//	we should be a task thread

	Assert( !Ptls()->fIsTaskThread );
	Ptls()->fIsTaskThread = fTrue;

	//	task loop

	while ( Ptls()->fIsTaskThread )
		{
		if ( fCanUseIOCP )
			{

			//	wait for a task to appear on the I/O completion port

			BOOL fSuccess = GetQueuedCompletionStatus(	m_hIOCPTaskDispatch,
														&dwCompletionKey1,
														(DWORD_PTR*)&pfnCompletion,
														(OVERLAPPED**)&dwCompletionKey2,
														m_dtickTimeout ? m_dtickTimeout : INFINITE );
			if ( fSuccess )
				{
				SetLastError( ERROR_SUCCESS );
				}
			if ( GetLastError() == WAIT_TIMEOUT )
				{
				//  fire a timeout event

				pfnCompletion		= m_pfnTimeout;
				dwCompletionKey1	= 0;
				dwCompletionKey2	= 0;

				//	correct the number of posted tasks
				
				AtomicIncrement( (LONG *)&m_cPostedTasks );
				}
			}
		else
			{
			CTaskNode *ptn;

			//	wait for a task to be posted (disable deadlock timeout)

			if ( m_semTaskDispatch.FAcquire( m_dtickTimeout ? m_dtickTimeout : cmsecInfiniteNoDeadlock ) )
				{
				//	get the next task-node

				m_critTask.Enter();
				ptn = m_ilTask.PrevMost();
				Assert( ptn );
				m_ilTask.Remove( ptn );
				m_critTask.Leave();

				//	extract the task node's parameters

				pfnCompletion		= ptn->m_pfnCompletion;
				dwCompletionKey1	= ptn->m_dwCompletionKey1;
				dwCompletionKey2	= ptn->m_dwCompletionKey2;

				//	cleanup up the task node

				delete ptn;
				}
			else
				{
				//  fire a timeout event

				pfnCompletion		= m_pfnTimeout;
				dwCompletionKey1	= 0;
				dwCompletionKey2	= 0;

				//	correct the number of posted tasks
				
				AtomicIncrement( (LONG *)&m_cPostedTasks );
				}
			}

		//	run the task

		Assert( pfnCompletion );
		pfnCompletion( dwThreadContext, dwCompletionKey1, dwCompletionKey2 );

			//	correct the number of posted tasks
			
		LONG count = AtomicDecrement( (LONG *)&m_cPostedTasks );
		Assert( !m_fIgnoreTasksAmountAsserts || 0 <= count );
		}
	}


//	used a bogus completion to pop threads off of the I/O completion port

VOID CTaskManager::TMITermTask(	const DWORD_PTR	dwThreadContext,
								const DWORD		dwCompletionKey1,
								const DWORD_PTR	dwCompletionKey2 )
	{

	//	this thread is no longer processing tasks

	Assert( Ptls()->fIsTaskThread );
	Ptls()->fIsTaskThread = fFalse;
	}


//	Check if need to activate one more thread in the thread pool

ERR CTaskManager::ErrAddThreadCheck( const BOOL fForceMaxThreads )
	{
	ERR err = JET_errSuccess;

	//	should we ignore the check?
	if ( m_cPostedTasks <= m_cTasksThreshold )
		{
		//	do nothing
		}
		
	else if ( m_cmsLastActivateThreadTime + m_cThread * 500 / CUtilProcessProcessor() > TickOSTimeCurrent() )
		{
		//	do nothing except check if the Win timer is overflowed
		if ( m_cmsLastActivateThreadTime > TickOSTimeCurrent() )
			{
			ULONG cmsLastActivateThreadTime = m_cmsLastActivateThreadTime;
			if ( m_critActivateThread.FTryEnter() )
				{
				//	correct last activate time
				AtomicCompareExchange( (LONG *)&m_cmsLastActivateThreadTime, cmsLastActivateThreadTime, TickOSTimeCurrent() );
				m_critActivateThread.Leave();
				}
			}
		}
	
	//	Try to enter the critical section to update the thread information
	else if ( m_critActivateThread.FTryEnter() )
		{
		//	verify the time again. Just in case if somebody is updated the information meanwhile
		if ( m_cmsLastActivateThreadTime + m_cThread * 500 / CUtilProcessProcessor() <= TickOSTimeCurrent() 
			&& m_cThread < m_cThreadMax 
			&& m_cPostedTasks > m_cTasksThreshold )
			{
			do
				{
				//	create the thread
				//
				err = ErrUtilThreadCreate(
								PUTIL_THREAD_PROC( TMDispatch ),
								OSMemoryPageReserveGranularity(),
								priorityNormal,
								&m_rgThreadContext[m_cThread].thread,
								DWORD_PTR( m_rgThreadContext + m_cThread ) );
				if ( err < JET_errSuccess )
					break;
				
				//	increase the thread count AFTER we have successfully created the thread
				AtomicIncrement( (LONG *)&m_cThread );
				//	if we have reached the max number of threads 
				if ( m_cThread == m_cThreadMax )
					{
					//	disable further attempts to activate threads
					m_cTasksThreshold = -1;
					}
				else
					{
					//	set new activate, time & threshold
					Assert( m_cThread < m_cThreadMax );
					m_cmsLastActivateThreadTime = TickOSTimeCurrent();
					m_cTasksThreshold = m_cThread * 8;
					}
				}
			while ( m_cThread < m_cThreadMax && fForceMaxThreads );
			}

		//	Leave the critical section
		m_critActivateThread.Leave();
		}
	return err;
	}


////////////////////////////////////////////////
//
//	Task Manager for Win2000
//

LONG volatile CGPTaskManager::m_cRef = 0;
CTaskManager CGPTaskManager::m_taskmanager;
CGPTaskManager *g_pGPTaskMgr = NULL;

typedef BOOL (__stdcall *PfnQueueUserWorkItem)(
  LPTHREAD_START_ROUTINE Function,  // starting address
  VOID *Context,                    // function data
  ULONG Flags                       // worker options
);

LOCAL PfnQueueUserWorkItem pfnQueueUserWorkItem = NULL;

//	ctor

CGPTaskManager::CGPTaskManager() :
	m_fInit( fFalse ),
	m_cPostedTasks( 0 ),
	m_asigAllDone( CSyncBasicInfo( szAsigAllDone ) ),
	m_rwlPostTasks( CLockBasicInfo( CSyncBasicInfo( szRwlPostTasks ), rankRwlPostTasks, 0 ) )
	{
	}

CGPTaskManager::~CGPTaskManager()
	{
	Assert( 0 == m_cPostedTasks );
	}

ERR CGPTaskManager::ErrTMInit( const ULONG cThread )
	{
	ERR err = JET_errSuccess;

	//	see if this is Init for the first time
	//
	if ( 1 == AtomicIncrement( (LONG *)&m_cRef ) )
		{
		Assert( cThread > 0 );

		//	If QueueUserWorkItem is not supported use CTaskManager with 
		//	advised cThread number of threads.
		//
		if ( NULL == pfnQueueUserWorkItem )
			{
			err = m_taskmanager.ErrTMInit( cThread );
			if ( err < JET_errSuccess )
				{
				//	UNDONE: if we end up failing and other
				//	instances of this class were concurrently
				//	initialising, what happens to them??
				//	Fortunately, we don't currently concurrently
				//	initialise other instances of this class
				//
				Enforce( 0 == AtomicDecrement( (LONG *)&m_cRef ) );
				}
			}
		}

	if ( err >= JET_errSuccess )
		{
		m_fInit = fTrue;

		//	initialise with a dummy refcount (allows
		//	term code to determine whether it has to
		//	wait for outstanding tasks or not)
		//
		Assert( 0 == m_cPostedTasks );
		m_cPostedTasks = ctaskPlaceholder;
		}

	return err;
	}

VOID CGPTaskManager::TMTerm()
	{
	//	block anyone from posting more tasks
	//
	m_rwlPostTasks.EnterAsWriter();

	Assert( m_fInit );
	m_fInit = fFalse;

	m_rwlPostTasks.LeaveAsWriter();

	//	remove the dummy refcount
	//
	const LONG	cTasks	= AtomicDecrement( (LONG *)&m_cPostedTasks );

	if ( cTasks > 0 )
		{
		//	Wait until all outstanding tasks have completed
		//
		m_asigAllDone.Wait();
		}
	else
		{
		//	no tasks outstanding, so no need to wait
		//
		Assert( 0 == cTasks );
		}

	m_asigAllDone.Reset();
	Assert( 0 == m_cPostedTasks );

	// decrement the reference counter
	const LONG	cRef	= AtomicDecrement( (LONG *)&m_cRef );
	Assert( cRef >= 0 );

	//	If it is the last instance free the resources
	if ( 0 == cRef )
		{
		//	If we use CTaskManager terminate it.
		if ( NULL == pfnQueueUserWorkItem )
			{
			m_taskmanager.TMTerm();
			}
		}
	}

ERR CGPTaskManager::ErrTMPost( PfnCompletion	 pfnCompletion, VOID *pvParam, DWORD dwFlags )
	{
	ERR			err			= JET_errSuccess;
	PTMCallWrap	ptmCallWrap	= NULL;

	//	Enter post task lock
	//
	m_rwlPostTasks.EnterAsReader();

	if ( m_fInit )
		{
		//	Increment the number of eventually posted tasks
		//
		const LONG	cTasksOutstanding	= AtomicIncrement( (LONG *)&m_cPostedTasks );

		//	must be at least a dummy refcount and a refcount for this task
		//
		Assert( cTasksOutstanding > ctaskPlaceholder );

		//  wrap the Call
		ptmCallWrap = new TMCallWrap;
		if ( NULL != ptmCallWrap )
			{
			ptmCallWrap->pfnCompletion	= pfnCompletion;
			ptmCallWrap->pvParam		= pvParam;
			ptmCallWrap->pThis			= this;

			//	choose the proper dispatch function based on used thread pool manager
			if ( NULL == pfnQueueUserWorkItem )
				{
				err = m_taskmanager.ErrTMPost( TMIDispatch, 0, DWORD_PTR( ptmCallWrap ) );
				}
			else if ( !pfnQueueUserWorkItem( CGPTaskManager::TMIDispatchGP, ptmCallWrap, dwFlags ) )
				{
				err = ErrERRCheck( JET_errOutOfMemory );
				}
			}
		else
			{
			err = ErrERRCheck( JET_errOutOfMemory );
			}

		if ( err < JET_errSuccess )
			{
			//	couldn't post task, update task count accordingly
			//
			const LONG	cTasksRemaining		= AtomicDecrement( (LONG *)&m_cPostedTasks );

			//	must still be a dummy refcount remaining
			//
			Assert( cTasksRemaining >= ctaskPlaceholder );
			}
		}
	else
		{

		//	the task manager is not initialized so the task must be dropped

		err = ErrERRCheck( JET_errTaskDropped );
		AssertTracking();	//	this shouldn't happen; trap it because caller may not handle this case well
		}

	// leave post task lock
	//
	m_rwlPostTasks.LeaveAsReader();

	return err;
	}

DWORD __stdcall CGPTaskManager::TMIDispatchGP( VOID *pvParam )
	{
	PTMCallWrap		ptmCallWrap		= PTMCallWrap( pvParam );	
	const BOOL		fIsTaskThread	= Ptls()->fIsTaskThread;

	//	All tasks must be executed in TaskThread environment
	if ( !fIsTaskThread )
		{
		Ptls()->fIsTaskThread = fTrue;
		}

	// check input parameters
	Assert( NULL != ptmCallWrap );

	extern BOOL g_fCatchExceptions;
	if ( g_fCatchExceptions && NULL != pfnQueueUserWorkItem )
		{
		TRY 
			{
			ptmCallWrap->pfnCompletion( ptmCallWrap->pvParam );
			} 
		EXCEPT( ExceptionFail( "In worker thread." ) ) 
			{ 
			}
		ENDEXCEPT
		}
	else
		{
		ptmCallWrap->pfnCompletion( ptmCallWrap->pvParam );
		}

	if ( !fIsTaskThread )
		{
		Ptls()->fIsTaskThread = fFalse;
		}

	CGPTaskManager * const	pThis			= ptmCallWrap->pThis;

	//	must free PTMCallWrap before decrementing refcount, otherwise
	//	the process may terminate and kill this task before we can finish
	//
	delete ptmCallWrap;

	const LONG				cTasks			= AtomicDecrement( (LONG *)&( pThis->m_cPostedTasks ) );

	if ( 0 == cTasks )
		{
		//	the terminating thread is waiting
		//	for us to finish
		//
		Assert( !pThis->m_fInit );
		pThis->m_asigAllDone.Set();
		}
	else
		{
		//	must still be a dummy refcount remaining
		//
		Assert( cTasks >= ctaskPlaceholder );
		}

	return 0;
	}

VOID CGPTaskManager::TMIDispatch( const DWORD_PTR	dwThreadContext,
										const DWORD		dwCompletionKey1,
										const DWORD_PTR	dwCompletionKey2 )
	{
	// check input parameters
	Assert( NULL == dwThreadContext );
	Assert( 0 == dwCompletionKey1 );
	TMIDispatchGP( (VOID *)dwCompletionKey2 );
	}

//  post-terminate task subsystem

void OSTaskPostterm()
	{
	//  nop
	}

//  pre-init task subsystem

BOOL FOSTaskPreinit()
	{
	//  determine IOCP availability

	OSVERSIONINFO osvi;
	memset( &osvi, 0, sizeof( osvi ) );
	osvi.dwOSVersionInfoSize = sizeof( osvi );
	if ( !GetVersionEx( &osvi ) )
		{
		goto HandleError;
		}

	fCanUseIOCP = osvi.dwPlatformId == VER_PLATFORM_WIN32_NT;

	return fTrue;

HandleError:
	OSTaskPostterm();
	return fFalse;
	}


//  terminates the task subsystem

void OSTaskTerm()
	{
	if ( NULL != g_pGPTaskMgr )
		{
		g_pGPTaskMgr->TMTerm();
		delete g_pGPTaskMgr;
		g_pGPTaskMgr = NULL;
		}
	}

//  init task subsystem

ERR ErrOSTaskInit()
	{
	ERR err = JET_errSuccess;
	Assert( NULL == g_pGPTaskMgr );
	HMODULE hmodKernel32 = NULL;
	hmodKernel32 = LoadLibrary( _T("Kernel32.dll") );
	if ( NULL != hmodKernel32 )
		{
		pfnQueueUserWorkItem = (PfnQueueUserWorkItem)GetProcAddress( hmodKernel32, "QueueUserWorkItem" );
		FreeLibrary( hmodKernel32 );
		}
	g_pGPTaskMgr = new CGPTaskManager;
	if ( NULL == g_pGPTaskMgr )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		}
	else
		{
		err = g_pGPTaskMgr->ErrTMInit( min( 8 * CUtilProcessProcessor(), 100 ) );
		if ( err < JET_errSuccess )
			{
			delete g_pGPTaskMgr;
			g_pGPTaskMgr = NULL;
			}
		}
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\_oswinnt\string.cxx ===
#include "osstd.hxx"


//	get the length of the string

LONG LOSSTRLengthA( const char *const psz )
	{
	return lstrlenA( psz );
	}
LONG LOSSTRLengthW( const wchar_t *const pwsz )
	{
	return lstrlenW( pwsz );
	}


//	copy a string

VOID OSSTRCopyA( char *const pszDst, const char *const pszSrc )
	{
	(VOID)lstrcpyA( pszDst, pszSrc );
	}
VOID OSSTRCopyW( wchar_t *const pwszDst, const wchar_t *const pwszSrc )
	{
	(VOID)lstrcpyW( pwszDst, pwszSrc );
	}


//	append a string

VOID OSSTRAppendA( char *const pszDst, const char* const pszSrc )
	{
	const ULONG cch = LOSSTRLengthA( pszDst );
	OSSTRCopyA( pszDst + cch, pszSrc );
	}
VOID OSSTRAppendW( wchar_t *const pwszDst, const wchar_t *const pwszSrc )
	{
	const ULONG cch = LOSSTRLengthW( pwszDst );
	OSSTRCopyW( pwszDst + cch, pwszSrc );
	}



//	compare the strings (up to the given maximum length).  if the first string 
//	is "less than" the second string, -1 is returned.  if the strings are "equal", 
//	0 is returned.  if the first string is "greater than" the second string, +1 is returned.

LONG LOSSTRCompareA( const char *const pszStr1, const char *const pszStr2, const ULONG cchMax )
	{
	ULONG cch1 = lstrlenA( pszStr1 );
	ULONG cch2 = lstrlenA( pszStr2 );
	ULONG ich;

	//	limit the lengths

	if ( cch1 > cchMax )
		{
		cch1 = cchMax;
		}
	if ( cch2 > cchMax )
		{
		cch2 = cchMax;
		}

	//	compare the lengths

	if ( cch1 < cch2 )
		{
		return -1;
		}
	else if ( cch1 > cch2 )
		{
		return +1;
		}

	//	compare the strings

	ich = 0;
	while ( ich < cch1 )
		{
		if ( pszStr1[ich] == pszStr2[ich] )
			{
			ich++;
			}
		else if ( pszStr1[ich] < pszStr2[ich] )
			{
			return -1;
			}
		else
			{
			return +1;
			}
		}

	return 0;
	}


LONG LOSSTRCompareW( const wchar_t *const pwszStr1, const wchar_t *const pwszStr2, const ULONG cchMax )
	{
	ULONG cch1 = lstrlenW( pwszStr1 );
	ULONG cch2 = lstrlenW( pwszStr2 );
	ULONG ich;

	//	limit the lengths

	if ( cch1 > cchMax )
		{
		cch1 = cchMax;
		}
	if ( cch2 > cchMax )
		{
		cch2 = cchMax;
		}

	//	compare the lengths

	if ( cch1 < cch2 )
		{
		return -1;
		}
	else if ( cch1 > cch2 )
		{
		return +1;
		}

	//	compare the strings

	ich = 0;
	while ( ich < cch1 )
		{
		if ( pwszStr1[ich] == pwszStr2[ich] )
			{
			ich++;
			}
		else if ( pwszStr1[ich] < pwszStr2[ich] )
			{
			return -1;
			}
		else
			{
			return +1;
			}
		}

	return 0;
	}



//	create a formatted string in a given buffer

LONG __cdecl LOSSTRFormatA( char *const pszBuffer, const char *const pszFormat, ... )
	{
	va_list alist;
	va_start( alist, pszFormat );
	const int i = vsprintf( pszBuffer, pszFormat, alist );
	va_end( alist );
	return LONG( i );
	}
LONG __cdecl LOSSTRFormatW( wchar_t *const pwszBuffer, const wchar_t *const pwszFormat, ... )
	{
	va_list alist;
	va_start( alist, pwszFormat );
	const int i = vswprintf( pwszBuffer, pwszFormat, alist );
	va_end( alist );
	return LONG( i );
	}


//	returns a pointer to the next character in the string.  when no more
//	characters are left, the given ptr is returned.

VOID OSSTRCharNextA( const char *const psz, char **const ppszNext )
	{
	*ppszNext = const_cast< char *const >( '\0' != *psz ? psz + 1 : psz );
	}
VOID OSSTRCharNextW( const wchar_t *const pwsz, wchar_t **const ppwszNext )
	{
	*ppwszNext = const_cast< wchar_t *const >( L'\0' != *pwsz ? pwsz + 1 : pwsz );
	}


//	returns a pointer to the previous character in the string.  when the first
//	character is reached, the given ptr is returned.

VOID OSSTRCharPrevA( const char *const pszBase, const char *const psz, char **const ppszPrev )
	{
	*ppszPrev = const_cast< char *const >( psz > pszBase ? psz - 1 : psz );
	}
VOID OSSTRCharPrevW( const wchar_t *const pwszBase, const wchar_t *const pwsz, wchar_t **const ppwszPrev )
	{
	*ppwszPrev = const_cast< wchar_t *const >( pwsz > pwszBase ? pwsz - 1 : pwsz );
	}


//	find the first occurrence of the given character in the given string and
//	return a pointer to that character.  NULL is returned when the character 
//	is not found.

VOID OSSTRCharFindA( const char *const pszStr, const char ch, char **const ppszFound )
	{
	*ppszFound = strchr( pszStr, ch );
	}
VOID OSSTRCharFindW( const wchar_t *const pwszStr, const wchar_t wch, wchar_t **const ppwszFound )
	{
	const wchar_t *pwszFound = pwszStr;
	while ( L'\0' != *pwszFound && wch != *pwszFound )
		{
		pwszFound++;
		}
	*ppwszFound = const_cast< wchar_t *const >( wch == *pwszFound ? pwszFound : NULL );
	}


//	find the last occurrence of the given character in the given string and
//	return a pointer to that character.  NULL is returned when the character
//	is not found.

VOID OSSTRCharFindReverseA( const char *const pszStr, const char ch, char **const ppszFound )
	{
	Assert( '\0' != ch );
	*ppszFound = strrchr( pszStr, ch );
	}
VOID OSSTRCharFindReverseW( const wchar_t *const pwszStr, const wchar_t wch, wchar_t **const ppwszFound )
	{
	ULONG	ich;
	ULONG	cch;

	Assert( L'\0' != wch );

	*ppwszFound = NULL;

	cch = LOSSTRLengthW( pwszStr );
	ich = cch;

	while ( ich-- > 0 )
		{
		if ( wch == pwszStr[ich] )
			{
			*ppwszFound = const_cast< wchar_t* const >( pwszStr + ich );
			return;
			}
		}
	}


//	check for a trailing path-delimeter

BOOL FOSSTRTrailingPathDelimiterA( const char *const pszPath )
	{
	const DWORD cchPath = lstrlenA( pszPath );

	if ( cchPath > 0 )
		{
		return BOOL( '\\' == pszPath[cchPath - 1] || '/' == pszPath[cchPath - 1] );
		}
	return fFalse;
	}
BOOL FOSSTRTrailingPathDelimiterW( const wchar_t *const pwszPath )
	{
	const DWORD cchPath = lstrlenW( pwszPath );

	if ( cchPath > 0 )
		{
		return BOOL( L'\\' == pwszPath[cchPath - 1] || L'/' == pwszPath[cchPath - 1] );
		}
	return fFalse;
	}


//	conditionally append a path delimiter to a path.  if fCheckExist is true,
//	the path delimiter will only be appended if one is not already present.

VOID OSSTRAppendPathDelimiterA( char *const pszPath, const BOOL fCheckExist )
	{
	if ( !fCheckExist || !FOSSTRTrailingPathDelimiterA( pszPath ) )
		{
		const UINT cch = lstrlenA( pszPath );
		pszPath[ cch ] = bPathDelimiter;
		pszPath[ cch + 1 ] = '\0';
		}
	}
VOID OSSTRAppendPathDelimiterW( wchar_t *const pwszPath, const BOOL fCheckExist )
	{
	if ( !fCheckExist || !FOSSTRTrailingPathDelimiterW( pwszPath ) )
		{
		const UINT cch = lstrlenW( pwszPath );
		pwszPath[ cch ] = wchPathDelimiter;
		pwszPath[ cch + 1 ] = L'\0';
		}
	}


//	convert a byte string to a wide-char string

ERR ErrOSSTRAsciiToUnicode(	const char *const	pszIn,
							wchar_t *const		pwszOut,
							const int			cwchOut,	//	pass in 0 to only return output buffer size in pcwchActual
							int* const			pcwchActual )
	{
	//	check the input buffer against the output buffer

	const int cchIn = lstrlenA( pszIn ) + 1;
	if ( cwchOut < cchIn
		&& ( 0 != cwchOut || NULL == pcwchActual ) )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}


	//	do the conversion

	const int cwchActual = MultiByteToWideChar(	CP_ACP,
												MB_ERR_INVALID_CHARS,
												pszIn,
												cchIn,
												pwszOut,
												cwchOut );
	if ( NULL != pcwchActual )
		*pcwchActual = cwchActual;

	if ( 0 != cwchActual )
		{
		if ( 0 != cwchOut )
			{
			Assert( cwchActual <= cwchOut );
			Assert( L'\0' == pwszOut[cwchActual - 1] );
			}
		return JET_errSuccess;
		}

	//	handle the error

	const DWORD dwError = GetLastError();

	if ( ERROR_INSUFFICIENT_BUFFER == dwError )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}
	else if ( ERROR_INVALID_PARAMETER == dwError )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}
	else if ( ERROR_NO_UNICODE_TRANSLATION == dwError )
		{
		return ErrERRCheck( JET_errUnicodeTranslationFail );
		}
	else
		{
		//	unexpected error

		_TCHAR			szT[128];
		const _TCHAR *	rgszT[1]	= { szT };

		_stprintf(	szT,
					_T( "Unexpected Win32 error in ErrOSSTRAsciiToUnicode: %dL (0x%08X)" ),
					dwError,
					dwError );
		AssertSz( fFalse, szT );
		UtilReportEvent(
				eventError,
				PERFORMANCE_CATEGORY,
				PLAIN_TEXT_ID,
				1,
				rgszT );

		return ErrERRCheck( JET_errUnicodeTranslationFail );
		}
	}

//	convert a wide-char string to a byte string

ERR ErrOSSTRUnicodeToAscii(	const wchar_t *const	pwszIn,
							char *const				pszOut,
							const int				cchOut,		//	pass in 0 to only return output buffer size in pcchActual
							int* const				pcchActual )
	{
	//	check the input buffer against the output buffer

	const int cwchIn = lstrlenW( pwszIn ) + 1;
	if ( cchOut < cwchIn
		&& ( 0 != cchOut || NULL == pcchActual ) )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}


	//	do the conversion

	const int cchActual = WideCharToMultiByte(	CP_ACP,
												0,
												pwszIn,
												cwchIn,
												pszOut,
												cchOut,
												NULL,
												NULL );
	if ( NULL != pcchActual )
		*pcchActual = cchActual;

	if ( 0 != cchActual )
		{
		if ( 0 != cchOut )
			{
			Assert( cchActual <= cchOut );
			Assert( '\0' == pszOut[cchActual - 1] );
			}
		return JET_errSuccess;
		}

	//	handle the error

	const DWORD dwError = GetLastError();

	if ( ERROR_INSUFFICIENT_BUFFER == dwError )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}
	else if ( ERROR_INVALID_PARAMETER == dwError )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}
	else
		{
		//	unexpected error

		_TCHAR			szT[128];
		const _TCHAR *	rgszT[1]	= { szT };

		_stprintf(	szT,
					_T( "Unexpected Win32 error in ErrOSSTRUnicodeToAscii: %dL (0x%08X)" ),
					dwError,
					dwError );
		AssertSz( fFalse, szT );
		UtilReportEvent(
				eventError,
				PERFORMANCE_CATEGORY,
				PLAIN_TEXT_ID,
				1,
				rgszT );

		return ErrERRCheck( JET_errUnicodeTranslationFail );
		}
	}


//  convert a _TCHAR string to a WCHAR string

ERR ErrOSSTRTcharToUnicode(	const _TCHAR *const	ptszIn, 
							wchar_t *const		pwszOut, 
							const int			cwchOut )
	{
#ifdef UNICODE

	//	check the input buffer against the output buffer

	const size_t ctchIn = wcslen( ptszIn ) + 1;
	if ( cwchOut < ctchIn )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}
	Assert( cwchOut > 0 );

	//  copy the string

	wcsncpy( pwszOut, ptszIn, cwchOut );
	return JET_errSuccess;
	
#else  //  !UNICODE

	return ErrOSSTRAsciiToUnicode( ptszIn, pwszOut, cwchOut );

#endif  //  UNICODE
	}

//  convert a WCHAR string to a _TCHAR string

ERR ErrOSSTRUnicodeToTchar(	const wchar_t *const	pwszIn, 
							_TCHAR *const			ptszOut, 
							const int				ctchOut )
	{
#ifdef UNICODE

	//	check the input buffer against the output buffer

	const wchar_t cwchIn = wcslen( pwszIn ) + 1;
	if ( ctchOut < cwchIn )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}
	Assert( ctchOut > 0 );

	//  copy the string

	wcsncpy( ptszOut, pwszIn, ctchOut );
	return JET_errSuccess;
	
#else  //  !UNICODE

	return ErrOSSTRUnicodeToAscii( pwszIn, ptszOut, ctchOut );

#endif  //  UNICODE
	}


//  convert a byte string to a _TCHAR string

ERR ErrOSSTRAsciiToTchar(	const char *const	pszIn, 
							_TCHAR *const		ptszOut, 
							const int			ctchOut )
	{
#ifdef UNICODE

	return ErrOSSTRAsciiToUnicode( pszIn, ptszOut, ctchOut );
	
#else  //  !UNICODE

	//	check the input buffer against the output buffer

	const int cchIn = (INT)strlen( pszIn ) + 1;
	if ( ctchOut < cchIn )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}
	Assert( ctchOut > 0 );

	//  copy the string

	strncpy( ptszOut, pszIn, ctchOut );
	return JET_errSuccess;

#endif  //  UNICODE
	}

//  convert a _TCHAR string to a byte string

ERR ErrOSSTRTcharToAscii(	const _TCHAR *const	ptszIn, 
							char *const			pszOut, 
							const int			cchOut )
	{
#ifdef UNICODE

	return ErrOSSTRUnicodeToAscii( ptszIn, pszOut, cchOut );
	
#else  //  !UNICODE

	//	check the input buffer against the output buffer

	const size_t ctchIn = strlen( ptszIn ) + 1;
	if ( cchOut < ctchIn )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}
	Assert( cchOut > 0 );

	//  copy the string

	strncpy( pszOut, ptszIn, cchOut );
	return JET_errSuccess;

#endif  //  UNICODE
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\esetest\bug1.cxx ===
#include "unittest.hxx"

//  ================================================================
class BUG1 : public UNITTEST
//  ================================================================
	{
	private:
		static BUG1 s_instance;

	protected:
		BUG1() {}

	public:
		~BUG1() {}

	public:
		const char * SzName() const;
		const char * SzDescription() const;

		bool FRunUnderESE98() const;
		bool FRunUnderESENT() const;
		bool FRunUnderESE97() const;

		JET_ERR ErrTest(
				const JET_INSTANCE instance,
				const JET_SESID sesid,
				JET_DBID& dbid );
	};

BUG1 BUG1::s_instance;


//  ================================================================
const char * BUG1::SzName() const
//  ================================================================
	{
	return "bug1";
	}


//  ================================================================
const char * BUG1::SzDescription() const
//  ================================================================
	{
	return	"Testing rolling back an index when another session has created a RCE with\r\n"
			"deferred undo info on the index. This exposes a bug in critical section ranking.";
	}


//  ================================================================
bool BUG1::FRunUnderESE98() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool BUG1::FRunUnderESENT() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool BUG1::FRunUnderESE97() const
//  ================================================================
	{
	return 1;
	}

static JET_COLUMNCREATE	rgcolumncreate[] = {
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"long",							// name of column
	JET_coltypLong,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"long2",						// name of column
	JET_coltypLong,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
};

static const char szIndex1Name[]	= "BUG1::primary-index";
static const char szIndex1Key[]		= "+long\0";

static const char szIndex2Name[]	= "BUG1::secondary-index";
static const char szIndex2Key[]		= "+long2\0";

static JET_INDEXCREATE rgindexcreate[] = {
	{
	sizeof( JET_INDEXCREATE ),		// size of this structure (for future expansion)
	const_cast<char *>( szIndex1Name ),				// index name
	const_cast<char *>( szIndex1Key ),				// index key
	sizeof( szIndex1Key ),			// length of key
	JET_bitIndexPrimary,			// index options
	100,							// index density
	0,								// lcid for the index
	0,								// maximum length of variable length columns in index key
	NULL,							// pointer to conditional column structure
	0,								// number of conditional columns
	JET_errSuccess					// returned error code
	},
};

static JET_INDEXCREATE rgindexcreateSec[] = {
	{
	sizeof( JET_INDEXCREATE ),		// size of this structure (for future expansion)
	const_cast<char *>( szIndex2Name ),				// index name
	const_cast<char *>( szIndex2Key ),				// index key
	sizeof( szIndex2Key ),			// length of key
	JET_bitIndexUnique,				// index options
	100,							// index density
	0,								// lcid for the index
	0,								// maximum length of variable length columns in index key
	NULL,							// pointer to conditional column structure
	0,								// number of conditional columns
	JET_errSuccess					// returned error code
	},
};

const char * const szMyTable = "BUG1::table";

static JET_TABLECREATE tablecreate = {
	sizeof( JET_TABLECREATE ),				// size of this structure
	const_cast<char *>( szMyTable ),		// name of table
	NULL,									// name of base table
	16,										// initial pages
	100,									// density
	rgcolumncreate,							// columns to create
	sizeof( rgcolumncreate ) / sizeof( JET_COLUMNCREATE ),	// number of columns to create
	rgindexcreate,							// array of index creation info
	sizeof( rgindexcreate ) / sizeof( JET_INDEXCREATE ),		// number of indexes to create
	0,										// grbit
	0,										// returned tableid
	0										// returned count of objects created
};


static long l;
static long l2;

static JET_SETCOLUMN rgsetcolumn[] = {
	{
	0,						//  columnid
	&l,						//  pvData
	sizeof( long ),			//  cbData
	0,						//  grbit
	0,						//  ibLongValue
	1,						//  itag sequence
	0						//  err
	},
	{
	0,						//  columnid
	&l2,					//  pvData
	sizeof( long ),			//  cbData
	0,						//  grbit
	0,						//  ibLongValue
	1,						//  itag sequence
	0						//  err
	},
};

//  ================================================================
JET_ERR BUG1::ErrTest(
	const JET_INSTANCE instance,
	const JET_SESID sesid,
	JET_DBID& dbid )
//  ================================================================
	{
	JET_ERR					err			= 0;
	JET_SESID				sesid2		= 0;
	JET_DBID				dbid2		= 0;
	JET_TABLEID 			tableid;
	JET_TABLEID 			tableid2;

	Call( JetBeginSession( instance, &sesid2, NULL, NULL ) );
	Call( JetOpenDatabase( sesid2, szDB, NULL, &dbid2, 0 ) );

	Call( JetBeginTransaction( sesid ) );
	Call( JetCreateTableColumnIndex( sesid, dbid, &tablecreate ) );
	Call( JetCommitTransaction( sesid, 0 ) );
	Call( JetCloseTable( sesid, tablecreate.tableid ) );

	rgsetcolumn[0].columnid = tablecreate.rgcolumncreate[0].columnid;
	rgsetcolumn[1].columnid = tablecreate.rgcolumncreate[1].columnid;

	Call( JetOpenTable( sesid, dbid, szMyTable, NULL, 0, 0, &tableid ) );
	Call( JetOpenTable( sesid2, dbid2, szMyTable, NULL, 0, 0, &tableid2 ) );

	Call( JetBeginTransaction( sesid ) );
	Call( JetCreateIndex2(
			sesid,
			tableid,
			rgindexcreateSec,
			sizeof( rgindexcreateSec ) / sizeof( JET_INDEXCREATE ) ) );

	Call( JetBeginTransaction( sesid2 ) );
	Call( JetPrepareUpdate( sesid2, tableid2, JET_prepInsert ) );
	l	= 1;
	l2	= 1;
	Call( JetSetColumns(
		sesid2,
		tableid2,
		rgsetcolumn,
		sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid2, tableid2, NULL, 0, NULL ) );

	Call( JetMakeKey( sesid2, tableid2, &l, sizeof( l ), JET_bitNewKey ) );
	Call( JetSeek( sesid2, tableid2, JET_bitSeekEQ ) );
	Call( JetDelete( sesid2, tableid2 ) );

	Call( JetPrepareUpdate( sesid2, tableid2, JET_prepInsert ) );
	l	= 2;
	l2	= 1;
	Call( JetSetColumns(
		sesid2,
		tableid2,
		rgsetcolumn,
		sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid2, tableid2, NULL, 0, NULL ) );

	Call( JetRollback( sesid, 0 ) );
	Call( JetRollback( sesid2, 0 ) );

	Call( JetCloseTable( sesid2, tableid2 ) );
	Call( JetCloseTable( sesid, tableid ) );
	Call( JetEndSession( sesid2, NO_GRBIT ) );

HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\eseperf\eseperf.cxx ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <tchar.h>
#include <aclapi.h>

	/*  Performance Monitoring support
	/*
	/*  Status information is reported to the Event Log in the PERFORMANCE_CATEGORY
	/**/

#include "perfutil.hxx"
#include "perfmon.hxx"

#include "jetmsg.h"

typedef unsigned long MessageId;

#define fTrue	1
#define fFalse	0


///#define DEBUG_PERFMON
#define PERF_TIMEOUT 100
#define PERF_PERFINST_MAX 256


struct PERFINST
	{
	BOOL	fInitialized;
	HANDLE	hInstanceMutex;
	HANDLE	hReadyEvent;
	HANDLE	hGoEvent;
	HANDLE	hIDAMMF;
	IDA*	pida;
	IDA*	pidaBackup;
	BYTE	rgbReserved[8];
	};

PERFINST rgperfinst[PERF_PERFINST_MAX] = { 0 };


void ReleaseInstance( DWORD iInstance )
	{
	PERFINST* const			pperfinst	= rgperfinst + iInstance;
	pperfinst->fInitialized = fFalse;
	if ( pperfinst->pidaBackup )
		{
		VirtualFree( pperfinst->pidaBackup, 0, MEM_RELEASE );
		pperfinst->pidaBackup = NULL;
		}
	if ( pperfinst->pida )
		{
		UnmapViewOfFile( pperfinst->pida );
		pperfinst->pida = NULL;
		}
	if ( pperfinst->hIDAMMF )
		{
		CloseHandle( pperfinst->hIDAMMF );
		pperfinst->hIDAMMF = NULL;
		}
	if ( pperfinst->hGoEvent )
		{
		CloseHandle( pperfinst->hGoEvent );
		pperfinst->hGoEvent = NULL;
		}
	if ( pperfinst->hReadyEvent )
		{
		CloseHandle( pperfinst->hReadyEvent );
		pperfinst->hReadyEvent = NULL;
		}
	if ( pperfinst->hInstanceMutex )
		{
		CloseHandle( pperfinst->hInstanceMutex );
		pperfinst->hInstanceMutex = NULL;
		}	
	}

void ReleaseInstances()
	{

	//	all the PERFINST structures are zero-initialized so we can try to free them all
	
	DWORD iInstance;
	for (	iInstance = 0;
			iInstance < PERF_PERFINST_MAX;
			iInstance++ )
		{
		ReleaseInstance( iInstance );
		}
	}

inline _TCHAR* SzPerfGlobal()
	{
	OSVERSIONINFO osverinfo;
	osverinfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
	if ( !GetVersionEx( &osverinfo ) ) 
		{
		return _T("");
		}
	//	Under Win2000 terminal server object names must be preceded by Global\
	//	to share the same name space
	return ( VER_PLATFORM_WIN32_NT == osverinfo.dwPlatformId && 5 <= osverinfo.dwMajorVersion )? _T("Global\\"): _T("");
	}

BOOL AccessInstance( DWORD iInstance, PERFINST** ppperfinst )
	{
	PERFINST*	pperfinst	= rgperfinst + iInstance;
	_TCHAR		szT[ 256 ];
#ifdef DEBUG_PERFMON
	CHAR 		szDescr[512];
#endif

	*ppperfinst = NULL;

	if ( !pperfinst->fInitialized )
		{
		/*  open the instance mutex
		/**/
		_stprintf( szT, _T( "%sInstance%d:  %s" ), SzPerfGlobal(), iInstance, szPERFVersion );
		if ( !( pperfinst->hInstanceMutex = OpenMutex( SYNCHRONIZE, FALSE, szT ) ) )
			{
#ifdef DEBUG_PERFMON
			sprintf( szDescr,"Failed to access %s.", szT );
			PerfUtilLogEvent( PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE, szDescr );
#endif
			goto fail;
			}

		/*	open the ready event
		/**/
		_stprintf( szT, _T( "%sReady%d:  %s" ), SzPerfGlobal(), iInstance, szPERFVersion );
		if ( !( pperfinst->hReadyEvent = OpenEvent( EVENT_MODIFY_STATE | SYNCHRONIZE, FALSE, szT ) ) )
			{
#ifdef DEBUG_PERFMON
			sprintf( szDescr,"Failed to access %s.", szT );
			PerfUtilLogEvent( PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE, szDescr );
#endif
			goto fail;
			}

		/*	open the go event
		/**/
		_stprintf( szT, _T( "%sGo%d:  %s" ), SzPerfGlobal(), iInstance, szPERFVersion );
		if ( !( pperfinst->hGoEvent = OpenEvent( EVENT_MODIFY_STATE, FALSE, szT ) ) )
			{
#ifdef DEBUG_PERFMON
			sprintf( szDescr,"Failed to access %s.", szT );
			PerfUtilLogEvent( PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE, szDescr );
#endif
			goto fail;
			}

		/*  open the shared instance data area
		/**/
		_stprintf( szT, _T( "%sIDA%d:  %s" ), SzPerfGlobal(), iInstance, szPERFVersion );
		if ( !( pperfinst->hIDAMMF = OpenFileMapping( FILE_MAP_READ, FALSE, szT ) ) )
			{
#ifdef DEBUG_PERFMON
			sprintf( szDescr,"Failed to access %s.", szT );
			PerfUtilLogEvent( PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE, szDescr );
#endif
			goto fail;
			}
		
		if ( !( pperfinst->pida = PIDA( MapViewOfFile(	pperfinst->hIDAMMF,
														FILE_MAP_READ,
														0,
														0,
														0 ) ) ) )
			{
#ifdef DEBUG_PERFMON
			sprintf( szDescr,"Failed in MapViewOfFile." );
			PerfUtilLogEvent( PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE, szDescr );
#endif
			goto fail;
			}

		if ( !( pperfinst->pidaBackup = PIDA( VirtualAlloc( NULL, PERF_SIZEOF_INSTANCE_DATA, MEM_COMMIT, PAGE_READWRITE ) ) ) )
			{
#ifdef DEBUG_PERFMON
			sprintf( szDescr,"Failed in VirtualAlloc." );
			PerfUtilLogEvent( PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE, szDescr );
#endif
			goto fail;
			}

		/*  we are now initialized
		/**/
		pperfinst->fInitialized = fTrue;
		}

	*ppperfinst = pperfinst;
	return TRUE;

fail:

#ifdef DEBUG_PERFMON
	sprintf( szDescr,"Failed to access instance %d.", iInstance );
	PerfUtilLogEvent( PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE, szDescr );
#endif

	ReleaseInstance( iInstance );
	return FALSE;
	}


struct ODA
	{
	DWORD	iNextBlock;		//  Index of next free block
	DWORD	cbAvail;		//  Available bytes
	BYTE*	pbTop;			//  Top of the allocation stack
	BYTE*	pbBlock[];		//  Pointer to each block
	};


extern "C" {

	/*  function prototypes (to keep __stdcall happy)  */
	
DWORD APIENTRY OpenPerformanceData(LPWSTR);
DWORD APIENTRY CollectPerformanceData(LPWSTR, LPVOID *, LPDWORD, LPDWORD);
DWORD APIENTRY ClosePerformanceData(void);

	/*  OpenPerformanceData() is an export that is called when another application
	/*  wishes to start fetching performance data from this DLL.  Any initializations
	/*  that need to be done on the first or subsequent opens are done here.
	/*
	/**/

DWORD dwOpenCount = 0;
DWORD dwFirstCounter;
DWORD dwFirstHelp;
BOOL fTemplateDataInitialized = fFalse;
DWORD cbMaxCounterBlockSize;
DWORD cbInstanceSize;

DWORD APIENTRY OpenPerformanceData(LPWSTR lpwszDeviceNames)
{
	HKEY hkeyPerf = (HKEY)(-1);
	DWORD err = ERROR_SUCCESS;
	DWORD Type;
	LPBYTE lpbData;
	PPERF_OBJECT_TYPE ppotObjectSrc;
	PPERF_INSTANCE_DEFINITION ppidInstanceSrc;
	PPERF_COUNTER_DEFINITION ppcdCounterSrc;
	DWORD dwCurObj;
	DWORD dwCurCtr;
#ifdef DEBUG_PERFMON
	CHAR szDescr[256];
#endif  //  DEBUG_PERFMON
	BOOL fDisplayDevOnly;
	DWORD dwMinDetailLevel;
	DWORD dwOffset;

	if (!dwOpenCount)
	{
			/*  perform first open initializations  */

			/*  initialize system layer  */

		if ((err = DwPerfUtilInit()) != ERROR_SUCCESS)
			goto HandleFirstOpenError;

			/*  initialize template data if not initialized  */

		if (!fTemplateDataInitialized)
		{
				/*  retrieve counter/help ordinals from the registry  */

			if ((err = DwPerfUtilRegOpenKeyEx(
					HKEY_LOCAL_MACHINE,
					"SYSTEM\\CurrentControlSet\\Services\\" SZVERSIONNAME "\\Performance",
					&hkeyPerf)) != ERROR_SUCCESS)
			{
#ifdef DEBUG_PERFMON
				PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE,"Not installed.");
#endif
				goto HandleFirstOpenError;
			}

			err = DwPerfUtilRegQueryValueEx(hkeyPerf,"First Counter",&Type,&lpbData);
			if (err != ERROR_SUCCESS || Type != REG_DWORD) 
			{
#ifdef DEBUG_PERFMON
				PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE,"Installation corrupt.");
#endif
				goto HandleFirstOpenError;

			}
			else
			{
				dwFirstCounter = *((DWORD *)lpbData);
				free(lpbData);
			}

			err = DwPerfUtilRegQueryValueEx(hkeyPerf,"First Help",&Type,&lpbData);
			if (err != ERROR_SUCCESS || Type != REG_DWORD) 
			{
#ifdef DEBUG_PERFMON
				PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE,"Installation corrupt.");
#endif
				goto HandleFirstOpenError;
			}
			else
			{
				dwFirstHelp = *((DWORD *)lpbData);
				free(lpbData);
			}

#ifdef RTM
			err = DwPerfUtilRegQueryValueEx(hkeyPerf,(char*)"Show Advanced Counters",&Type,&lpbData);
			if (err != ERROR_SUCCESS || Type != REG_DWORD) 
			{
				//  deprecated name (yes, we are ending the insanity)
				err = DwPerfUtilRegQueryValueEx(hkeyPerf,(char*)"Squeaky Lobster",&Type,&lpbData);
				if (err != ERROR_SUCCESS || Type != REG_DWORD) 
				{
					fDisplayDevOnly = fFalse;
				}
				else
				{
					fDisplayDevOnly = *((DWORD *)lpbData) ? fTrue : fFalse;
					free(lpbData);
				}
			}
			else
			{
				fDisplayDevOnly = *((DWORD *)lpbData) ? fTrue : fFalse;
				free(lpbData);
			}
#else  //  !RTM
			fDisplayDevOnly = fTrue;
#endif  //  RTM

			(VOID)DwPerfUtilRegCloseKeyEx(hkeyPerf);
			hkeyPerf = (HKEY)(-1);

				/*  initialize template data  */
				
			ppotObjectSrc = (PPERF_OBJECT_TYPE)pvPERFDataTemplate;
			ppidInstanceSrc = (PPERF_INSTANCE_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->DefinitionLength);
			cbMaxCounterBlockSize = QWORD_MULTIPLE( sizeof(PERF_COUNTER_BLOCK) );
			for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
			{
					/*  update name/help ordinals for object  */
					
				ppotObjectSrc->ObjectNameTitleIndex += dwFirstCounter;
				ppotObjectSrc->ObjectHelpTitleIndex += dwFirstHelp;

				ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->HeaderLength);
				dwMinDetailLevel = PERF_DETAIL_WIZARD;
				dwOffset = QWORD_MULTIPLE( sizeof(PERF_COUNTER_BLOCK) );
				for (dwCurCtr = 0; dwCurCtr < ppotObjectSrc->NumCounters; dwCurCtr++)
				{
						/*  update name/help ordinals for counter  */
						
					ppcdCounterSrc->CounterNameTitleIndex += dwFirstCounter;
					ppcdCounterSrc->CounterHelpTitleIndex += dwFirstHelp;

						/*  this counter is marked as PERF_DETAIL_DEVONLY  */

					if ( ppcdCounterSrc->DetailLevel & PERF_DETAIL_DEVONLY )
					{
							/*  restore true display detail  */
							
						ppcdCounterSrc->DetailLevel &= ~PERF_DETAIL_DEVONLY;

							/*  the counter has not been selected for display  */

						if ( !fDisplayDevOnly )
						{
								/*  conceal the counter  */
								
							ppcdCounterSrc->CounterType = PERF_COUNTER_NODATA;
						}
					}

						/*  get minimum detail level of counters  */

					dwMinDetailLevel = min(dwMinDetailLevel,ppcdCounterSrc->DetailLevel);

						/*  update counter's data offset value  */

					ppcdCounterSrc->CounterOffset = dwOffset;
					dwOffset += QWORD_MULTIPLE( ppcdCounterSrc->CounterSize );
					
					ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppcdCounterSrc + ppcdCounterSrc->ByteLength);
				}

					/*  set object's detail level as the minimum of all its counter's detail levels  */

				ppotObjectSrc->DetailLevel = dwMinDetailLevel;

					/*  keep track of the max counter block size  */

				cbMaxCounterBlockSize = max(cbMaxCounterBlockSize,dwOffset);
				
				ppotObjectSrc = (PPERF_OBJECT_TYPE)((char *)ppotObjectSrc + ppotObjectSrc->TotalByteLength);
			}
			cbInstanceSize = ppidInstanceSrc->ByteLength + cbMaxCounterBlockSize;

			fTemplateDataInitialized = fTrue;
		}
	}

		/*  perform per open initializations  */

	;

		/*  all initialization succeeded  */

	dwOpenCount++;
	
#ifdef DEBUG_PERFMON
	sprintf(szDescr,"Opened successfully.  Open Count = %ld.",dwOpenCount);
	PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_INFORMATION_TYPE,szDescr);
#endif
	
	return ERROR_SUCCESS;

		/*  Error Handlers  */

/*HandlePerOpenError:*/

HandleFirstOpenError:

	if (hkeyPerf != (HKEY)(-1))
		(VOID)DwPerfUtilRegCloseKeyEx(hkeyPerf);

#ifdef DEBUG_PERFMON
	sprintf(szDescr,"Open attempt failed!  Open Count = %ld.",dwOpenCount);
	PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE,szDescr);
#endif
	
	PerfUtilTerm();

	return err;
}


	/*  CollectPerformanceData() is an export that is called by another application to
	/*  collect performance data from this DLL.  A list of the desired data is passed in
	/*  and the requested data is returned ASAP in the caller's buffer.
	/*
	/*  NOTE:  because we are multithreaded, locks must be used in order to update or
	/*  read any performance information in order to avoid reporting bad results.
	/*
	/**/

WCHAR wszDelim[] = L"\n\r\t\v ";
WCHAR wszForeign[] = L"Foreign";
WCHAR wszGlobal[] = L"Global";
WCHAR wszCostly[] = L"Costly";

DWORD APIENTRY CollectPerformanceData(
	LPWSTR  lpwszValueName,
	LPVOID  *lppData,
	LPDWORD lpcbTotalBytes,
	LPDWORD lpNumObjectTypes)
{
	LPWSTR lpwszValue = NULL;
	LPWSTR lpwszTok;
	BOOL fNoObjFound;
	DWORD dwIndex;
	DWORD cbBufferSize;
	PPERF_OBJECT_TYPE ppotObjectSrc;
	PPERF_OBJECT_TYPE ppotObjectDest;
	PPERF_INSTANCE_DEFINITION ppidInstanceSrc;
	PPERF_INSTANCE_DEFINITION ppidInstanceDest;
	PPERF_COUNTER_BLOCK ppcbCounterBlockDest;
	DWORD dwCurObj;
	DWORD dwCurInst;
	DWORD cInstances;
	ODA* poda = NULL;
	long iBlock;

#ifdef DEBUG_PERFMON
	char *rgsz[3];
	char szT[256];
#endif  //  DEBUG_PERFMON

	memset( *lppData, 0xFF, *lpcbTotalBytes );

	/*  grab instance mutex to lock out other instances of this dll
	/**/
	WaitForSingleObject( hPERFInstanceMutex, INFINITE );

		/*  no data if OpenPerformanceData() was never called  */

	if ( !lpwszValueName || !dwOpenCount)
		{
		goto ReturnNoData;
		}
		
		/*  make our own copy of the value string for tokenization and
		/*  get the first token
		/**/

	if (!(lpwszValue = static_cast<WCHAR *>( malloc((wcslen(lpwszValueName)+1)*sizeof(WCHAR)))) )
		goto ReturnNoData;
	lpwszTok = wcstok(wcscpy(lpwszValue,lpwszValueName),wszDelim);
	if ( !lpwszTok )
		{
		goto ReturnNoData;
		}

		/*  we don't support foreign computer data requests  */

	if (!wcscmp(lpwszTok,wszForeign))  /*  lpwszTok == wszForeign  */
		goto ReturnNoData;

		/*  if none of our objects are in the value list, return no data  */

	if (wcscmp(lpwszTok,wszGlobal) && wcscmp(lpwszTok,wszCostly))  /*  lpwszTok != wszGlobal || lpwszTok != wszCostly  */
	{
		fNoObjFound = fTrue;
		do
		{
			dwIndex = (DWORD)wcstoul(lpwszTok,NULL,10)-dwFirstCounter;
			if (dwIndex <= dwPERFMaxIndex)
			{
				fNoObjFound = fFalse;
				break;
			}
		}
		while (lpwszTok = wcstok(NULL,wszDelim));

		if (fNoObjFound)
			goto ReturnNoData;
	}

	/*  initialize output data area
	/**/
	if ( !( poda = (ODA*)VirtualAlloc( NULL, *lpcbTotalBytes + sizeof( ODA ), MEM_COMMIT, PAGE_READWRITE ) ) )
		{
		goto ReturnNoData;
		}
	poda->iNextBlock	= 0;	
	poda->cbAvail		= *lpcbTotalBytes;
	poda->pbTop			= (BYTE*)poda + *lpcbTotalBytes;

	/*  fetch the maximum number of instances currently in use
	/*
	/*  NOTE:  protect ourselves from corruption of the GDA
	/**/
	DWORD iInstanceMax;
	__try
		{
		iInstanceMax = min( PERF_PERFINST_MAX, pgdaPERFGDA->iInstanceMax );
		}
	__except( EXCEPTION_EXECUTE_HANDLER )
		{
		iInstanceMax = 0;
		}

	/*  collect performance data from any instances we can find
	/**/
	DWORD iInstance;
	for ( iInstance = 0; iInstance < iInstanceMax; iInstance++ )
		{
		/*  access the current instance
		/**/
		PERFINST* pperfinst;
		if ( !AccessInstance( iInstance, &pperfinst ) )
			{
			continue;
			}

		/*  this instance is alive (NOTE:  can detect instance crashes via WAIT_ABANDONED)
		/**/
		if ( WaitForSingleObject( pperfinst->hInstanceMutex, 0 ) == WAIT_TIMEOUT )
			{
			/*  this instance is ready to collect data
			/**/
			if ( WaitForSingleObject( pperfinst->hReadyEvent, 0 ) == WAIT_OBJECT_0 )
				{
				/*  reset the ready event for this instance
				/**/
				ResetEvent( pperfinst->hReadyEvent );

				/*  set the go event for this instance to start data collection
				/**/
				SetEvent( pperfinst->hGoEvent );

				/*  we did not time out waiting for the ready event to be set
				/*  for this instance indicating data collection is complete
				/**/
				if ( WaitForSingleObject( pperfinst->hReadyEvent, PERF_TIMEOUT ) == WAIT_OBJECT_0 )
					{
					/*  copy the new data to the backup data for this instance
					/*
					/*  NOTE:  protect ourselves from corruption of the IDA
					/**/
					__try
						{
						memcpy(	pperfinst->pidaBackup,
								pperfinst->pida,
								min(	PERF_SIZEOF_INSTANCE_DATA,
										sizeof( IDA ) + pperfinst->pida->cbPerformanceData ) );
						}
					__except( EXCEPTION_EXECUTE_HANDLER )
						{
						}

					/*  invalidate the new data if it is corrupt in any way
					/*
					/*  NOTE:  we do this so that no one can create an app that
					/*  can permanently disable our performance counters by
					/*  tripping the validation checks in the perfmon code
					/**/
					if ( pperfinst->pidaBackup->cbPerformanceData > PERF_SIZEOF_INSTANCE_DATA - sizeof( IDA ) )
						{
						pperfinst->pidaBackup->tickConnect = 0;
						}
					
					BYTE* pbData;
					pbData = pperfinst->pidaBackup->rgbPerformanceData;
					BYTE* pbDataMax;
					pbDataMax = pbData + pperfinst->pidaBackup->cbPerformanceData;
					for (dwCurObj = 0; pperfinst->pidaBackup->tickConnect && dwCurObj < dwPERFNumObjects; dwCurObj++)
						{
						if ( pbData + sizeof( DWORD_PTR ) > pbDataMax )
							{
							pperfinst->pidaBackup->tickConnect = 0;
							break;
							}
						
						cInstances = DWORD( *((DWORD_PTR *)pbData) );
						pbData += sizeof( DWORD_PTR );
						if ( pbData + cInstances * cbInstanceSize > pbDataMax )
							{
							pperfinst->pidaBackup->tickConnect = 0;
							break;
							}

						for (dwCurInst = 0; pperfinst->pidaBackup->tickConnect && dwCurInst < cInstances; dwCurInst++)
							{
							PPERF_INSTANCE_DEFINITION ppid;
							ppid = (PPERF_INSTANCE_DEFINITION)( pbData + dwCurInst * cbInstanceSize );
							if (	ppid->ByteLength < sizeof( PERF_INSTANCE_DEFINITION ) ||
									ppid->ByteLength > cbInstanceSize ||
									ppid->ByteLength % sizeof( DWORD_PTR ) )
								{
								pperfinst->pidaBackup->tickConnect = 0;
								break;
								}
							if (	ppid->NameOffset != sizeof( PERF_INSTANCE_DEFINITION ) ||
									ppid->NameLength % sizeof( WCHAR ) ||
									ppid->NameOffset + ppid->NameLength > cbInstanceSize )
								{
								pperfinst->pidaBackup->tickConnect = 0;
								break;
								}

							WCHAR* wszName;
							wszName = (WCHAR*)( (BYTE*)ppid + ppid->NameOffset );
							size_t iwch;
							for ( iwch = 0; wszName[ iwch ] && iwch < ppid->NameLength; iwch++ )
								{
								switch ( wszName[ iwch ] )
									{
									case L'#':
									case L'/':
										pperfinst->pidaBackup->tickConnect = 0;
										break;

									default:
										break;
									}
								}
							if ( ppid->NameLength && ( iwch + 1 ) * sizeof( WCHAR ) != ppid->NameLength )
								{
								pperfinst->pidaBackup->tickConnect = 0;
								break;
								}
							
							PPERF_COUNTER_BLOCK ppcb;
							ppcb = (PPERF_COUNTER_BLOCK)( (BYTE*)ppid + ppid->ByteLength );
							if (	ppcb->ByteLength < sizeof( PERF_COUNTER_BLOCK ) ||
									ppcb->ByteLength > cbMaxCounterBlockSize ||
									ppcb->ByteLength % sizeof( DWORD_PTR ) )
								{
								pperfinst->pidaBackup->tickConnect = 0;
								break;
								}
							}

						pbData += cInstances * cbInstanceSize;
						}
					}
				}

			/*  the backup data for this instance is valid
			/**/
			if (	pperfinst->pidaBackup->tickConnect &&
					pperfinst->pidaBackup->tickConnect == pperfinst->pida->tickConnect )
				{
				/*  add the backup data for this instance to the output data area
				/**/
				if ( poda->cbAvail >= sizeof( DWORD_PTR ) + pperfinst->pidaBackup->cbPerformanceData )
					{
					poda->cbAvail	-= sizeof( DWORD_PTR ) + pperfinst->pidaBackup->cbPerformanceData;
					poda->pbTop		-= pperfinst->pidaBackup->cbPerformanceData;
					poda->pbBlock[ poda->iNextBlock++ ] = poda->pbTop;

					memcpy(	poda->pbTop,
							pperfinst->pidaBackup->rgbPerformanceData,
							pperfinst->pidaBackup->cbPerformanceData );
					}
				else
					{
					goto NeedMoreData;
					}
				}
			}

		/*  this instance is not alive
		/**/
		else
			{
			/*  invalidate any backup data for this instance
			/**/
			pperfinst->pidaBackup->tickConnect = 0;
			
			/*  release the mutex to permit connection to this instance number
			/**/
			ReleaseMutex( pperfinst->hInstanceMutex );
			}
		}

	/*****************************************************************************************
	/*
	/*  NOTE!  This has been designed so that if NO instances of the main DLL are found, the
	/*  buffer filling routines will fill the buffer correctly as if each object has ZERO
	/*  instances (which is permitted).  This is mainly done by having each of the instance
	/*  loops fail on entry because poda->iNextBlock will be ZERO.
	/*
	/****************************************************************************************/
	
    	/*  all data has been collected, so fill the buffer with it and return it.
    	/*  if we happen to run out of space along the way, we will stop building
    	/*  and request more buffer space for next time.
    	/**/

	ppotObjectSrc = (PPERF_OBJECT_TYPE)pvPERFDataTemplate;
	ppotObjectDest = (PPERF_OBJECT_TYPE)*lppData;
	for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
	{
			/*  if the end of this object goes past the buffer, we're out of space  */

		if (((char *)ppotObjectDest - (char *)*lppData) + ppotObjectSrc->DefinitionLength > *lpcbTotalBytes)
			goto NeedMoreData;

			/*  copy current object's template data to buffer  */

		memcpy((void *)ppotObjectDest,(void *)ppotObjectSrc,ppotObjectSrc->DefinitionLength);
	
			/*  update the object's TotalByteLength and NumInstances to include instances  */

		for (iBlock = (long)poda->iNextBlock-1; iBlock >= 0; iBlock--)
			ppotObjectDest->NumInstances += DWORD( *((DWORD_PTR *)poda->pbBlock[iBlock]) );
		ppotObjectDest->TotalByteLength += cbMaxCounterBlockSize + (ppotObjectDest->NumInstances-1)*cbInstanceSize;

			/*  if there are no instances, append a counter block to the object definition  */
		
		if (!ppotObjectDest->NumInstances)
			ppotObjectDest->TotalByteLength += cbMaxCounterBlockSize;

			/*  if the end of this object goes past the buffer, we're out of space  */

		if (((char *)ppotObjectDest - (char *)*lppData) + ppotObjectDest->TotalByteLength > *lpcbTotalBytes)
			goto NeedMoreData;
	
			/*  collect all instances for all processes  */

		ppidInstanceDest = (PPERF_INSTANCE_DEFINITION)((char *)ppotObjectDest + ppotObjectDest->DefinitionLength);
		for (iBlock = (long)poda->iNextBlock-1; iBlock >= 0; iBlock--)
		{
				/*  copy all instance data for the current object for this process  */

			cInstances = DWORD( *((DWORD_PTR *)poda->pbBlock[iBlock]) );
			ppidInstanceSrc = (PPERF_INSTANCE_DEFINITION)(poda->pbBlock[iBlock] + sizeof(DWORD_PTR));
			memcpy((void *)ppidInstanceDest,(void *)ppidInstanceSrc,cbInstanceSize * cInstances);

				/*  update the instance's data fields  */

			for (dwCurInst = 0; dwCurInst < cInstances; dwCurInst++)
			{
					/*  if this is not the root object, setup instance hierarchy information  */
					
				if (dwCurObj)
				{
					ppidInstanceDest->ParentObjectTitleIndex = ((PPERF_OBJECT_TYPE)pvPERFDataTemplate)->ObjectNameTitleIndex;
					ppidInstanceDest->ParentObjectInstance = (long)poda->iNextBlock-1-iBlock;
				}
					
				ppidInstanceDest = (PPERF_INSTANCE_DEFINITION)((char *)ppidInstanceDest+cbInstanceSize);
			}

				/*  increment block offset past used instances  */

			poda->pbBlock[iBlock] += sizeof(DWORD_PTR) + cbInstanceSize * cInstances;
		}

			/*  if there are no instances, zero the counter block  */

		if (!ppotObjectDest->NumInstances)
		{
			ppcbCounterBlockDest = (PPERF_COUNTER_BLOCK)((char *)ppotObjectDest + ppotObjectDest->DefinitionLength);
			memset((void *)ppcbCounterBlockDest,0,cbMaxCounterBlockSize);
			ppcbCounterBlockDest->ByteLength = cbMaxCounterBlockSize;
		}
		
		ppotObjectDest = (PPERF_OBJECT_TYPE)((char *)ppotObjectDest+ppotObjectDest->TotalByteLength);
		ppotObjectSrc = (PPERF_OBJECT_TYPE)((char *)ppotObjectSrc+ppotObjectSrc->TotalByteLength);
	}

	cbBufferSize = DWORD( (char *)ppotObjectDest - (char *)*lppData );
//	Assert( cbBufferSize <= *lpcbTotalBytes );

#ifdef DEBUG_PERFMON
	sprintf(	szT,
				"Data collected starting at 0x%lX with length 0x%lX (0x100 bytes after our data are displayed).  "
				"We were given 0x%lX bytes of buffer.",
				*lppData,
				cbBufferSize,
				*lpcbTotalBytes );
	
	rgsz[0]	= "";
	rgsz[1] = "";
	rgsz[2]	= szT;
	
	ReportEvent(
		hOurEventSource,
		EVENTLOG_ERROR_TYPE,
		(WORD)PERFORMANCE_CATEGORY,
		PLAIN_TEXT_ID,
		0,
		3,
		cbBufferSize + 256,
		(const char **)rgsz,
		*lppData );
#endif  //  DEBUG_PERFMON
			
	free( lpwszValue );
	VirtualFree( poda, 0, MEM_RELEASE );
	*lppData = (void *)ppotObjectDest;
	*lpcbTotalBytes = cbBufferSize;
	*lpNumObjectTypes = dwPERFNumObjects;
	
	ReleaseMutex( hPERFInstanceMutex );
	return ERROR_SUCCESS;

NeedMoreData:
	free( lpwszValue );
	VirtualFree( poda, 0, MEM_RELEASE );
    *lpcbTotalBytes = 0;
    *lpNumObjectTypes = 0;
    
	ReleaseMutex( hPERFInstanceMutex );
	return ERROR_MORE_DATA;

ReturnNoData:
	free( lpwszValue );
	VirtualFree( poda, 0, MEM_RELEASE );
	*lpcbTotalBytes = 0;
	*lpNumObjectTypes = 0;

	ReleaseMutex( hPERFInstanceMutex );
	return ERROR_SUCCESS;
}


	/*  ClosePerformanceData() is an export that is called by another application when
	/*  it no longer desires performance data.  Per application or final termination
	/*  code for the performance routines can be performed here.
	/*
	/**/

DWORD APIENTRY ClosePerformanceData(void)
{
#ifdef DEBUG_PERFMON
	CHAR szDescr[256];
#endif  //  DEBUG_PERFMON

	if (!dwOpenCount)
		return ERROR_SUCCESS;

	dwOpenCount--;
	
		/*  perform per close termination  */

	;

		/*  log closing  */
	
#ifdef DEBUG_PERFMON
	sprintf(szDescr,"Closed successfully.  Open Count = %ld.",dwOpenCount);
	PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_INFORMATION_TYPE,szDescr);
#endif

		/*  perform final close termination  */

	if (!dwOpenCount)
	{

			/* free per-instance handles and memory */
			
		ReleaseInstances();
	
			/*  shut down system layer  */

		PerfUtilTerm();
	}

	return ERROR_SUCCESS;
}


}  //  extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\eseperf\perfutil.cxx ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <sddl.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <tchar.h>
#include <aclapi.h>

#include "perfutil.hxx"
#include "perfmon.hxx"

#include <overflow.h>


	/*  DLL entry point for JETPERF.DLL  */

extern "C"
	{
	BOOL WINAPI DLLEntryPoint( HINSTANCE, DWORD, LPVOID )
		{
		return( TRUE );
		}
	}


	/*  Registry support functions  */

DWORD DwPerfUtilRegOpenKeyEx(HKEY hkeyRoot,LPCTSTR lpszSubKey,PHKEY phkResult)
{
	return RegOpenKeyEx(hkeyRoot,lpszSubKey,0,KEY_QUERY_VALUE,phkResult);
}


DWORD DwPerfUtilRegCloseKeyEx(HKEY hkey)
{
	return RegCloseKey(hkey);
}


DWORD DwPerfUtilRegCreateKeyEx(HKEY hkeyRoot,LPCTSTR lpszSubKey,PHKEY phkResult,LPDWORD lpdwDisposition)
{
	return RegCreateKeyEx(hkeyRoot,lpszSubKey,0,NULL,REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS,NULL,phkResult,lpdwDisposition);
}


DWORD DwPerfUtilRegDeleteKeyEx(HKEY hkeyRoot,LPCTSTR lpszSubKey)
{
	return RegDeleteKey(hkeyRoot,lpszSubKey);
}


DWORD DwPerfUtilRegDeleteValueEx(HKEY hkey,LPTSTR lpszValue)
{
	return RegDeleteValue(hkey,lpszValue);
}


DWORD DwPerfUtilRegSetValueEx(HKEY hkey,LPCTSTR lpszValue,DWORD fdwType,CONST BYTE *lpbData,DWORD cbData)
{
		/*  make sure type is set correctly by deleting value first  */

	(VOID)DwPerfUtilRegDeleteValueEx(hkey,(LPTSTR)lpszValue);
	return RegSetValueEx(hkey,lpszValue,0,fdwType,lpbData,cbData);
}


	/*  DwPerfUtilRegQueryValueEx() adds to the functionality of RegQueryValueEx() by returning
	/*  the data in callee malloc()ed memory and automatically converting REG_EXPAND_SZ
	/*  strings using ExpandEnvironmentStrings() to REG_SZ strings.
	/*
	/*  NOTE:  references to nonexistent env vbles will be left unexpanded :-(  (Ex.  %UNDEFD% => %UNDEFD%)
	/**/

DWORD DwPerfUtilRegQueryValueEx(HKEY hkey,LPTSTR lpszValue,LPDWORD lpdwType,LPBYTE *lplpbData)
{
	DWORD cbData;
	LPBYTE lpbData;
	DWORD errWin;
	DWORD cbDataExpanded;
	LPBYTE lpbDataExpanded;

	*lplpbData = NULL;
	if ((errWin = RegQueryValueEx(hkey,lpszValue,0,lpdwType,NULL,&cbData)) != ERROR_SUCCESS)
		return errWin;

	if ((lpbData = reinterpret_cast<LPBYTE>(malloc(cbData))) == NULL)
		return ERROR_OUTOFMEMORY;
	if ((errWin = RegQueryValueEx(hkey,lpszValue,0,lpdwType,lpbData,&cbData)) != ERROR_SUCCESS)
	{
		free(lpbData);
		return errWin;
	}

	if (*lpdwType == REG_EXPAND_SZ)
	{
		cbDataExpanded = ExpandEnvironmentStrings((const char *)lpbData,NULL,0);
		if ((lpbDataExpanded = reinterpret_cast<LPBYTE>(malloc(cbDataExpanded))) == NULL)
		{
			free(lpbData);
			return ERROR_OUTOFMEMORY;
		}
		if (!ExpandEnvironmentStrings((const char *)lpbData,(char *)lpbDataExpanded,cbDataExpanded))
		{
			free(lpbData);
			free(lpbDataExpanded);
			return GetLastError();
		}
		free(lpbData);
		*lplpbData = lpbDataExpanded;
		*lpdwType = REG_SZ;
	}
	else  /*  lpdwType != REG_EXPAND_SZ  */
	{
		*lplpbData = lpbData;
	}

	return ERROR_SUCCESS;
}


	/*  shared performance data area resources  */

HANDLE	hPERFInstanceMutex	= NULL;
HANDLE	hPERFGDAMMF			= NULL;
PGDA	pgdaPERFGDA			= NULL;


	/*  Event Logging support  */

HANDLE hOurEventSource = NULL;

void PerfUtilLogEvent( DWORD evncat, WORD evntyp, const char *szDescription )
{
    const char *rgsz[3];

    	/*  convert args from internal types to event log types  */

	rgsz[0]	= "";
	rgsz[1] = "";
	rgsz[2] = (char *)szDescription;

		/*  write to our event log, if it has been opened  */

	if (hOurEventSource)
	{
		ReportEvent(
			hOurEventSource,
			(WORD)evntyp,
			(WORD)evncat,
			0,
			0,
			3,
			0,
			rgsz,
			0 );
	}

	return;
}


	/*  Init/Term routines for system indirection layer  */

DWORD dwInitCount = 0;

inline _TCHAR* SzPerfGlobal()
	{
	OSVERSIONINFO osverinfo;
	osverinfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
	if ( !GetVersionEx( &osverinfo ) ) 
		{
		return _T("");
		}
	//	Under Win2000 terminal server object names must be preceded by Global\
	//	to share the same name space
	return ( VER_PLATFORM_WIN32_NT == osverinfo.dwPlatformId && 5 <= osverinfo.dwMajorVersion )? _T("Global\\"): _T("");
	}

DWORD DwPerfUtilInit( VOID )
{
	DWORD						err							= ERROR_SUCCESS;
	PSECURITY_DESCRIPTOR		pSD							= NULL;
	DWORD						cbSD;
	SECURITY_ATTRIBUTES			sa							= { 0 };
	_TCHAR						szT[ 256 ];

			/*  if we haven't been initialized already, perform init  */

	if (!dwInitCount)
	{
			/*  open the event log  */

	    if (!(hOurEventSource = RegisterEventSource( NULL, SZVERSIONNAME )))
	    	return GetLastError();


		//	generic read, write and execute granted to System, Built-in Administrators
		//	and Authenticated Users.  Authenticated users do also need write
		//	access to performance counter objects.
		//
	    //	D:(A;;GA;;;SY)(A;;GA;;;BA)(A;;GA;;;AU)
	    //
		if ( !ConvertStringSecurityDescriptorToSecurityDescriptor(
						"D:(A;;GA;;;SY)(A;;GA;;;BA)(A;;GA;;;AU)",
						SDDL_REVISION_1,
						&pSD,
						&cbSD) )
			{
				err = GetLastError();
				goto CloseEventLog;
			}

		sa.nLength = cbSD;
	    sa.bInheritHandle = FALSE;
	    sa.lpSecurityDescriptor = pSD;

		/*  create/open the instance mutex, but do not acquire
		/**/
		_stprintf( szT, _T( "%sInstance:  %s" ), SzPerfGlobal(), szPERFVersion );
		if ( !( hPERFInstanceMutex = CreateMutex( &sa, FALSE, szT ) ) )
			{
			err = GetLastError();
			goto CloseEventLog;
			}

		/*  open/create the shared global data area
		/**/
		_stprintf( szT, _T( "%sGDA:  %s" ), SzPerfGlobal(), szPERFVersion );
		if ( !( hPERFGDAMMF = CreateFileMapping(	INVALID_HANDLE_VALUE,
													&sa,
													PAGE_READWRITE | SEC_COMMIT,
													0,
													PERF_SIZEOF_GLOBAL_DATA,
													szT ) ) )
			{
			err = GetLastError();
			goto FreeInstanceMutex;
			}
		if ( !( pgdaPERFGDA = PGDA( MapViewOfFile(	hPERFGDAMMF,
													FILE_MAP_READ,
													0,
													0,
													0 ) ) ) )
			{
			err = GetLastError();
			goto CloseFileMap;
			}

	}

		/*  init succeeded   */

	dwInitCount++;

	if ( err != ERROR_SUCCESS )
		{
CloseFileMap:
		CloseHandle( hPERFGDAMMF );
		hPERFGDAMMF = NULL;
FreeInstanceMutex:
		CloseHandle( hPERFInstanceMutex );
		hPERFInstanceMutex = NULL;
CloseEventLog:
		DeregisterEventSource( hOurEventSource );
		hOurEventSource = NULL;
		}

	LocalFree( pSD );
	return err;
}


VOID PerfUtilTerm( VOID )
{
		/*  last one out, turn out the lights!  */

	if (!dwInitCount)
		return;
	dwInitCount--;
	if (!dwInitCount)
	{
		UnmapViewOfFile( pgdaPERFGDA );
		pgdaPERFGDA = NULL;

		CloseHandle( hPERFGDAMMF );
		hPERFGDAMMF = NULL;

		CloseHandle( hPERFInstanceMutex );
		hPERFInstanceMutex = NULL;

		DeregisterEventSource( hOurEventSource );
		hOurEventSource = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\esetest\lvrollback.cxx ===
#include "unittest.hxx"

//  ================================================================
class LVROLLBACK : public UNITTEST
//  ================================================================
	{
	private:
		static LVROLLBACK s_instance;

	protected:
		LVROLLBACK() {}

	public:
		~LVROLLBACK() {}

	public:
		const char * SzName() const;
		const char * SzDescription() const;

		bool FRunUnderESE98() const;
		bool FRunUnderESENT() const;
		bool FRunUnderESE97() const;

		JET_ERR ErrTest(
				const JET_INSTANCE instance,
				const JET_SESID sesid,
				JET_DBID& dbid );
	};

LVROLLBACK LVROLLBACK::s_instance;


//  ================================================================
const char * LVROLLBACK::SzName() const
//  ================================================================
	{
	return "lvrollback";
	}


//  ================================================================
const char * LVROLLBACK::SzDescription() const
//  ================================================================
	{
	return	"Rollsback the creation of a LV tree that someone else has inserted into";
	}


//  ================================================================
bool LVROLLBACK::FRunUnderESE98() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool LVROLLBACK::FRunUnderESENT() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool LVROLLBACK::FRunUnderESE97() const
//  ================================================================
	{
	return 1;
	}


static const char szMyTable[]		= "LVROLLBACK::table";

static JET_COLUMNCREATE	rgcolumncreate[] = {
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"lv",							// name of column
	JET_coltypLongText,				// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
};

static JET_TABLECREATE tablecreate = {
	sizeof( JET_TABLECREATE ),				// size of this structure
	const_cast<char *>( szMyTable ),			// name of table
	NULL,									// name of base table
	16,										// initial pages
	100,									// density
	rgcolumncreate,							// columns to create
	sizeof( rgcolumncreate ) / sizeof( JET_COLUMNCREATE ),	// number of columns to create
	NULL,									// array of index creation info
	0,										// number of indexes to create
	0,										// grbit
	0,										// returned tableid
	0										// returned count of objects created
};

static char rgbBuf[8192];

static JET_SETCOLUMN rgsetcolumn[] = {
	{
	0,						//  columnid
	rgbBuf,					//  pvData
	sizeof( rgbBuf ),		//  cbData
	0,						//  grbit
	0,						//  ibLongValue
	1,						//  itag sequence
	0						//  err
	},
};

//  ================================================================
JET_ERR LVROLLBACK::ErrTest(
	const JET_INSTANCE instance,
	const JET_SESID sesid,
	JET_DBID& dbid )
//  ================================================================
	{
	JET_ERR					err			= 0;

	JET_TABLEID 			tableid;

	JET_SESID				sesid2		= 0;
	JET_DBID				dbid2		= 0;
	JET_TABLEID 			tableid2;

	Call( JetBeginTransaction( sesid ) );
	Call( JetCreateTableColumnIndex( sesid, dbid, &tablecreate ) );
	Call( JetCommitTransaction( sesid, 0 ) );
	Call( JetCloseTable( sesid, tablecreate.tableid ) );
       
	Call( JetBeginSession( instance, &sesid2, NULL, NULL ) );
	Call( JetOpenDatabase( sesid2, szDB, NULL, &dbid2, 0 ) );
	Call( JetOpenTable( sesid2, dbid2, szMyTable, NULL, 0, 0, &tableid2 ) );

	rgsetcolumn[0].columnid = tablecreate.rgcolumncreate[0].columnid;

	Call( JetOpenTable( sesid, dbid, szMyTable, NULL, 0, 0, &tableid ) );

	//	Create the LV tree. This should be done by ppibLV

	Call( JetBeginTransaction( sesid ) );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Call( JetSetColumns( sesid, tableid, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

	//	insert into the LV tree with a second session

	Call( JetBeginTransaction( sesid2 ) );
	Call( JetPrepareUpdate( sesid2, tableid2, JET_prepInsert ) );
	Call( JetSetColumns( sesid2, tableid2, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid2, tableid2, NULL, 0, NULL ) );
	Call( JetCommitTransaction( sesid2, 0 ) );

	//	

	Call( JetRollback( sesid, NO_GRBIT ) );

	//

	Call( JetCloseTable( sesid, tableid ) );
	Call( JetCloseTable( sesid2, tableid2 ) );
	
	Call( JetEndSession( sesid2, NO_GRBIT ) );

HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\esetest\lvcopybuf.cxx ===
#include "unittest.hxx"

//  ================================================================
class LVCOPYBUF : public UNITTEST
//  ================================================================
	{
	private:
		static LVCOPYBUF s_instance;

	protected:
		LVCOPYBUF() {}

	public:
		~LVCOPYBUF() {}

	public:
		const char * SzName() const;
		const char * SzDescription() const;

		bool FRunUnderESE98() const;
		bool FRunUnderESENT() const;
		bool FRunUnderESE97() const;

		JET_ERR ErrTest(
				const JET_INSTANCE instance,
				const JET_SESID sesid,
				JET_DBID& dbid );
	};

LVCOPYBUF LVCOPYBUF::s_instance;


//  ================================================================
const char * LVCOPYBUF::SzName() const
//  ================================================================
	{
	return "lvcopybuf";
	}


//  ================================================================
const char * LVCOPYBUF::SzDescription() const
//  ================================================================
	{
	return	"Retrieve a long-value from the copy buffer after separating it.";
	}


//  ================================================================
bool LVCOPYBUF::FRunUnderESE98() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool LVCOPYBUF::FRunUnderESENT() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool LVCOPYBUF::FRunUnderESE97() const
//  ================================================================
	{
	return 1;
	}


static const int cbLV			= 10000;
static const int ibLVOffset		= 5000;
static const int cbBefore		= 8000;
static const char chBefore		= 'a';
static const int cbAfter		= 9000;
static const char chAfter		= 'z';


//  ================================================================
static JET_ERR ErrRetrieveColumnsAndCheckLV(	
								const JET_SESID sesid,
								const JET_TABLEID tableid,
								const JET_COLUMNID columnid,
								const unsigned long ibLongValue,
								const unsigned long cbExpected,
								const char chExpected,
								const JET_GRBIT grbit )
//  ================================================================
	{
	JET_ERR err;
	JET_RETRIEVECOLUMN retcol;

	unsigned long	ib;
	unsigned char	rgbRetrieve[cbLV];

	memset( &retcol, 0, sizeof( JET_RETRIEVECOLUMN ) );
	retcol.pvData		= rgbRetrieve;
	retcol.cbData		= cbLV;
	retcol.grbit		= grbit;
	retcol.ibLongValue	= ibLongValue;
	retcol.itagSequence	= 1;

	printf( "\tJetRetrieveColumns( %d, %s )\n",
			ibLongValue,
			( ( grbit & JET_bitRetrieveCopy ) ? "JET_bitRetrieveCopy" : "NO_GRBIT " ) );

	Call( JetRetrieveColumns( sesid, tableid, &retcol, 1 ) );
	if( retcol.cbActual != cbExpected )
		{
		printf( "ERROR: retrieving LV returns wrong size. Got %d bytes, expected %d\n", retcol.cbActual, cbExpected );
		return -1;
		}
	for( ib = 0; ib < retcol.cbActual; ++ib  )
		{
		if( rgbRetrieve[ib] != chExpected )
			{
			printf( "ERROR: retrieving LV returns wrong data. Byte %d differs (%c,%c)\n", ib, rgbRetrieve[ib], chExpected );
			return -1;
			}
		}

HandleError:
	return err;
	}


//  ================================================================
static JET_ERR ErrRetrieveColumnAndCheckLV(	
								const JET_SESID sesid,
								const JET_TABLEID tableid,
								const JET_COLUMNID columnid,
								const unsigned long ibLongValue,
								const unsigned long cbExpected,
								const char chExpected,
								const JET_GRBIT grbit )
//  ================================================================
	{
	JET_ERR err;
	JET_RETINFO retinfo;

	unsigned long	ib;
	unsigned long	cbActual;
	unsigned char	rgbRetrieve[cbLV];

	memset( &retinfo, 0, sizeof( JET_RETINFO ) );
	retinfo.cbStruct		= sizeof( JET_RETINFO );
	retinfo.ibLongValue		= ibLongValue;
	retinfo.itagSequence	= 1;

	printf( "\tJetRetrieveColumn( %d, %s )\n",
			ibLongValue,
			( ( grbit & JET_bitRetrieveCopy ) ? "JET_bitRetrieveCopy" : "NO_GRBIT " ) );

	err = JetRetrieveColumn( sesid, tableid, columnid, rgbRetrieve, cbLV, &cbActual, grbit, &retinfo );
	if( JET_wrnColumnNull == err )
		{
		if( 0 != cbExpected )
			{
			printf( "ERROR: retrieving LV returns wrong size. Got a NULL column. Expected %d bytes\n", cbActual );
			return -1;
			}
		err = JET_errSuccess;
		}
	else
		{
		Call( err );
		if( cbActual != cbExpected )
			{
			printf( "ERROR: retrieving LV returns wrong size. Got %d bytes, expected %d\n", cbActual, cbExpected );
			return -1;
			}
		for( ib = 0; ib < cbActual; ++ib  )
			{
			if( rgbRetrieve[ib] != chExpected )
				{
				printf( "ERROR: retrieving LV returns wrong data. Byte %d differs (%c,%c)\n", ib, rgbRetrieve[ib], chExpected );
				return -1;
				}
			}
		}

HandleError:
	return err;
	}


//  ================================================================
static JET_ERR ErrRetrieveAndCheckLV(	
								const JET_SESID sesid,
								const JET_TABLEID tableid,
								const JET_COLUMNID columnid,
								const unsigned long ibLongValue,
								const unsigned long cbExpected,
								const char chExpected,
								const JET_GRBIT grbit )
//  ================================================================
	{
	JET_ERR err;

	Call( ErrRetrieveColumnAndCheckLV( sesid, tableid, columnid, ibLongValue, cbExpected, chExpected, grbit ) );
	Call( ErrRetrieveColumnsAndCheckLV( sesid, tableid, columnid, ibLongValue, cbExpected, chExpected, grbit ) );

HandleError:
	return err;
	}


//  ================================================================
JET_ERR LVCOPYBUF::ErrTest(
	const JET_INSTANCE instance,
	const JET_SESID sesid,
	JET_DBID& dbid )
//  ================================================================
	{
	JET_ERR					err			= 0;
	JET_TABLEID				tableid		= 0;
	JET_COLUMNID			columnidLV	= 0;

	unsigned char	rgbSet[cbLV];

	Call( JetOpenTable( sesid, dbid, szTable, NULL, 0, NO_GRBIT, &tableid ) );
	Call( ErrGetColumnid( sesid, tableid, "lv", &columnidLV ) );

	printf( "\tinserting a record\n" );

	Call( JetBeginTransaction( sesid ) );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );

	memset( rgbSet, chBefore, cbLV );
	Call( JetSetColumn( sesid, tableid, columnidLV, rgbSet, cbBefore, NO_GRBIT, NULL ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );
	Call( JetCommitTransaction( sesid, NO_GRBIT ) );

	printf( "\tmoving to record\n" );
	Call( JetMove( sesid, tableid, JET_MoveFirst, NO_GRBIT ) );

	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, 0, cbBefore, chBefore, NO_GRBIT ) );
	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, 0, cbBefore, chBefore, JET_bitRetrieveCopy ) );
	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, ibLVOffset, cbBefore - ibLVOffset, chBefore, NO_GRBIT ) );
	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, ibLVOffset, cbBefore - ibLVOffset, chBefore, JET_bitRetrieveCopy ) );

	printf( "\tbeginning update\n" );
	Call( JetBeginTransaction( sesid ) );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReplace ) );

	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, 0, cbBefore, chBefore, NO_GRBIT ) );
	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, 0, cbBefore, chBefore, JET_bitRetrieveCopy ) );
	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, ibLVOffset, cbBefore - ibLVOffset, chBefore, NO_GRBIT ) );
	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, ibLVOffset, cbBefore - ibLVOffset, chBefore, JET_bitRetrieveCopy ) );

	printf( "\tsetting column\n" );
	memset( rgbSet, chAfter, cbLV );
	Call( JetSetColumn( sesid, tableid, columnidLV, rgbSet, cbAfter, JET_bitSetOverwriteLV | JET_bitSetSizeLV, NULL ) );

	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, 0, cbBefore, chBefore, NO_GRBIT ) );
	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, 0, cbAfter, chAfter, JET_bitRetrieveCopy ) );
	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, ibLVOffset, cbBefore - ibLVOffset, chBefore, NO_GRBIT ) );
	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, ibLVOffset, cbAfter - ibLVOffset, chAfter, JET_bitRetrieveCopy ) );

	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );
	Call( JetCommitTransaction( sesid, NO_GRBIT ) );

	printf( "\tupdate\n" );

	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, 0, cbAfter, chAfter, NO_GRBIT ) );
	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, 0, cbAfter, chAfter, JET_bitRetrieveCopy ) );
	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, ibLVOffset, cbAfter - ibLVOffset, chAfter, NO_GRBIT ) );
	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, ibLVOffset, cbAfter - ibLVOffset, chAfter, JET_bitRetrieveCopy ) );

	printf( "\tbeginning update\n" );
	Call( JetBeginTransaction( sesid ) );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReplace ) );

	printf( "\tsetting column\n" );
	Call( JetSetColumn( sesid, tableid, columnidLV, NULL, 0, NO_GRBIT, NULL ) );
	
	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, 0, 0, chAfter, JET_bitRetrieveCopy ) );
	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, 0, cbAfter, chAfter, NO_GRBIT ) );
	Call( ErrRetrieveAndCheckLV( sesid, tableid, columnidLV, ibLVOffset, cbAfter - ibLVOffset, chAfter, NO_GRBIT ) );
	
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );
	Call( JetCommitTransaction( sesid, NO_GRBIT ) );

	printf( "\tupdate\n" );

	Call( JetCloseTable( sesid, tableid ) );

HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\esetest\bug2.cxx ===
#include "unittest.hxx"

//  ================================================================
class BUG2 : public UNITTEST
//  ================================================================
	{
	private:
		static BUG2 s_instance;

	protected:
		BUG2() {}

	public:
		~BUG2() {}

	public:
		const char * SzName() const;
		const char * SzDescription() const;

		bool FRunUnderESE98() const;
		bool FRunUnderESENT() const;
		bool FRunUnderESE97() const;

		JET_ERR ErrTest(
				const JET_INSTANCE instance,
				const JET_SESID sesid,
				JET_DBID& dbid );
	};

BUG2 BUG2::s_instance;


//  ================================================================
const char * BUG2::SzName() const
//  ================================================================
	{
	return "bug2";
	}


//  ================================================================
const char * BUG2::SzDescription() const
//  ================================================================
	{
	return	"X5:42716. ConcurrentCreateIndex. This test modifies an LV\r\n"
			"that belongs to an index that is being created.";
	}


//  ================================================================
bool BUG2::FRunUnderESE98() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool BUG2::FRunUnderESENT() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool BUG2::FRunUnderESE97() const
//  ================================================================
	{
	return 1;
	}

static const char szMyTable[]		= "BUG2::table";

static JET_COLUMNCREATE	rgcolumncreate[] = {
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"long",							// name of column
	JET_coltypLong,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"lv",							// name of column
	JET_coltypLongBinary,			// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
};

static const char szIndex1Name[]	= "primary-index";
static const char szIndex1Key[]	= "+long\0";

static const char szIndex2Name[]	= "secondary-index";
static const char szIndex2Key[]	= "+lv\0";

static JET_INDEXCREATE rgindexcreate[] = {
	{
	sizeof( JET_INDEXCREATE ),		// size of this structure (for future expansion)
	const_cast<char *>( szIndex1Name ),				// index name
	const_cast<char *>( szIndex1Key ),				// index key
	sizeof( szIndex1Key ),			// length of key
	JET_bitIndexPrimary,			// index options
	100,							// index density
	0,								// lcid for the index
	0,								// maximum length of variable length columns in index key
	NULL,							// pointer to conditional column structure
	0,								// number of conditional columns
	JET_errSuccess					// returned error code
	},
};


static JET_INDEXCREATE rgindexcreateSec[] = {
	{
	sizeof( JET_INDEXCREATE ),		// size of this structure (for future expansion)
	const_cast<char *>( szIndex2Name ),				// index name
	const_cast<char *>( szIndex2Key ),				// index key
	sizeof( szIndex2Key ),			// length of key
	0,								// index options
	100,							// index density
	0,								// lcid for the index
	0,								// maximum length of variable length columns in index key
	NULL,							// pointer to conditional column structure
	0,								// number of conditional columns
	JET_errSuccess					// returned error code
	},
};


static JET_TABLECREATE tablecreate = {
	sizeof( JET_TABLECREATE ),				// size of this structure
	const_cast<char *>( szMyTable ),			// name of table
	NULL,									// name of base table
	16,										// initial pages
	100,									// density
	rgcolumncreate,							// columns to create
	sizeof( rgcolumncreate ) / sizeof( JET_COLUMNCREATE ),	// number of columns to create
	rgindexcreate,							// array of index creation info
	sizeof( rgindexcreate ) / sizeof( JET_INDEXCREATE ),		// number of indexes to create
	0,										// grbit
	0,										// returned tableid
	0										// returned count of objects created
};

static long l;
static unsigned char rgb[4000];

static JET_SETCOLUMN rgsetcolumn[] = {
	{
	0,						//  columnid
	&l,						//  pvData
	sizeof( long ),			//  cbData
	0,						//  grbit
	0,						//  ibLongValue
	1,						//  itag sequence
	0						//  err
	},
	{
	0,						//  columnid
	rgb,					//  pvData
	sizeof( rgb ),			//  cbData
	0,						//  grbit
	0,						//  ibLongValue
	1,						//  itag sequence
	0						//  err
	},
};

//  ================================================================
JET_ERR BUG2::ErrTest(
	const JET_INSTANCE instance,
	const JET_SESID sesid,
	JET_DBID& dbid )
//  ================================================================
	{
	JET_ERR					err			= 0;
	JET_TABLEID 			tableid		= 0;

	JET_SESID				sesid2		= 0;
	JET_DBID				dbid2		= 0;
	JET_TABLEID 			tableid2;

	Call( JetBeginTransaction( sesid ) );
	Call( JetCreateTableColumnIndex( sesid, dbid, &tablecreate ) );
	Call( JetCommitTransaction( sesid, 0 ) );
	Call( JetCloseTable( sesid, tablecreate.tableid ) );

	rgsetcolumn[0].columnid = tablecreate.rgcolumncreate[0].columnid;
	rgsetcolumn[1].columnid = tablecreate.rgcolumncreate[1].columnid;

	Call( JetOpenTable( sesid, dbid, szMyTable, NULL, 0, 0, &tableid ) );

	Call( JetBeginTransaction( sesid ) );

	l	= 1;
	printf( "\t[1] Insert record %d...\r\n", l );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Call( JetSetColumns( sesid, tableid, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

	Call( JetCommitTransaction( sesid, 0 ) );

	Call( JetBeginTransaction( sesid ) );

	printf( "\t[1] Replacing record 1...\r\n" );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReplaceNoLock ) );

	JET_SETINFO setinfo;
	setinfo.cbStruct		= sizeof( JET_SETINFO );
	setinfo.ibLongValue		= 0;
	setinfo.itagSequence	= 1;

	Call( JetSetColumn( sesid, tableid, rgsetcolumn[1].columnid, rgb, sizeof( rgb ), 0, &setinfo ) );
///	Call( JetSetColumn( sesid, tableid, rgsetcolumn[1].columnid, rgb, sizeof( rgb ), JET_bitSetOverwriteLV, &setinfo ) );

	Call( JetBeginSession( instance, &sesid2, NULL, NULL ) );
	Call( JetOpenDatabase( sesid2, szDB, NULL, &dbid2, 0 ) );
	Call( JetOpenTable( sesid2, dbid2, szMyTable, NULL, 0, 0, &tableid2 ) );

	printf( "\t[2] Creating index...\n" );
	Call( JetBeginTransaction( sesid2 ) );
	Call( JetCreateIndex2(
			sesid2,
			tableid2,
			rgindexcreateSec,
			sizeof( rgindexcreateSec ) / sizeof( JET_INDEXCREATE ) ) );
	Call( JetCommitTransaction( sesid2, 0 ) );

	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

	printf( "\t[1] Committing...\n" );
	Call( JetCommitTransaction( sesid, 0 ) );

	Call( JetEndSession( sesid2, NO_GRBIT ) );

HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\esetest\coltypbit.cxx ===
#include "unittest.hxx"

//  ================================================================
class COLTYPBIT : public UNITTEST
//  ================================================================
	{
	private:
		static COLTYPBIT s_instance;

	protected:
		COLTYPBIT() {}

	public:
		~COLTYPBIT() {}

	public:
		const char * SzName() const;
		const char * SzDescription() const;

		bool FRunUnderESE98() const;
		bool FRunUnderESENT() const;
		bool FRunUnderESE97() const;

		JET_ERR ErrTest(
				const JET_INSTANCE instance,
				const JET_SESID sesid,
				JET_DBID& dbid );
	};

COLTYPBIT COLTYPBIT::s_instance;


//  ================================================================
const char * COLTYPBIT::SzName() const
//  ================================================================
	{
	return "coltypbit";
	}


//  ================================================================
const char * COLTYPBIT::SzDescription() const
//  ================================================================
	{
	return "Retrieves a bit column from an index";
	}


//  ================================================================
bool COLTYPBIT::FRunUnderESE98() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool COLTYPBIT::FRunUnderESENT() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool COLTYPBIT::FRunUnderESE97() const
//  ================================================================
	{
	return 1;
	}


static const char szBitTable[] = "COLTYPBIT::table";

static JET_COLUMNCREATE	rgcolumncreate[] = {
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"bit",							// name of column
	JET_coltypBit,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
};

static const char szIndex1Name[]	= "primary-index";
static const char szIndex1Key[]	= "+bit\0";

static const char szIndex2Name[]	= "secondary-index";
static const char szIndex2Key[]	= "-bit\0";

static JET_INDEXCREATE rgindexcreate[] = {
	{
	sizeof( JET_INDEXCREATE ),		// size of this structure (for future expansion)
	const_cast<char *>( szIndex1Name ),				// index name
	const_cast<char *>( szIndex1Key ),				// index key
	sizeof( szIndex1Key ),			// length of key
	JET_bitIndexPrimary,			// index options
	100,							// index density
	0,								// lcid for the index
	0,								// maximum length of variable length columns in index key
	NULL,							// pointer to conditional column structure
	0,								// number of conditional columns
	JET_errSuccess					// returned error code
	},
	{
	sizeof( JET_INDEXCREATE ),		// size of this structure (for future expansion)
	const_cast<char *>( szIndex2Name ),				// index name
	const_cast<char *>( szIndex2Key ),				// index key
	sizeof( szIndex2Key ),			// length of key
	0,								// index options
	100,							// index density
	0,								// lcid for the index
	0,								// maximum length of variable length columns in index key
	NULL,							// pointer to conditional column structure
	0,								// number of conditional columns
	JET_errSuccess					// returned error code
	},
};

static JET_TABLECREATE tablecreate = {
	sizeof( JET_TABLECREATE ),				// size of this structure
	const_cast<char *>( szBitTable ),		// name of table
	NULL,									// name of base table
	16,										// initial pages
	100,									// density
	rgcolumncreate,							// columns to create
	sizeof( rgcolumncreate ) / sizeof( JET_COLUMNCREATE ),	// number of columns to create
	rgindexcreate,							// array of index creation info
	sizeof( rgindexcreate ) / sizeof( JET_INDEXCREATE ),		// number of indexes to create
	0,										// grbit
	0,										// returned tableid
	0										// returned count of objects created
};


static JET_ERR ErrInsertRecordAndRetrieve(
			const JET_SESID sesid,
			const JET_TABLEID tableid,
			const JET_COLUMNID columnid,
			const unsigned char bBit )
	{
	JET_ERR err;

	unsigned char rgbBookmark[255];
	unsigned long cbBookmark;
	unsigned long cbActual;
	unsigned char bBitRetrieved;

	printf( "\tinserting record\n" );
	Call( JetBeginTransaction( sesid ) );
	Call( JetPrepareUpdate( sesid, tablecreate.tableid, JET_prepInsert ) );
	Call( JetSetColumn( sesid, tableid, columnid, &bBit, 1, 0, NULL ) );
	Call( JetUpdate( sesid, tablecreate.tableid, rgbBookmark, sizeof( rgbBookmark ), &cbBookmark ) );
	Call( JetCommitTransaction( sesid, 0 ) );

	Call( JetGotoBookmark( sesid, tableid, rgbBookmark, cbBookmark ) );

	//  primary index
	printf( "\tprimary index\n" );
	Call( JetSetCurrentIndex2( sesid, tableid, szIndex1Name, JET_bitNoMove ) );

	printf( "\t\tNO_GRBIT\n" );
	Call( JetRetrieveColumn( sesid, tableid, columnid, &bBitRetrieved, 1, &cbActual, NO_GRBIT, NULL ) );
	if( !bBitRetrieved != !bBit )
		{
		printf( "\t\tERROR: set 0x%2.2x, got 0x%2.2x\n", bBit, bBitRetrieved );
		}
	printf( "\t\tJET_bitRetrieveFromIndex\n" );
	Call( JetRetrieveColumn( sesid, tableid, columnid, &bBitRetrieved, 1, &cbActual, JET_bitRetrieveFromIndex, NULL ) );
	if( !bBitRetrieved != !bBit )
		{
		printf( "\t\tERROR: set 0x%2.2x, got 0x%2.2x\n", bBit, bBitRetrieved );
		}

	//  secondary index
	printf( "\tindex \"%s\"\n", szIndex2Name );
	Call( JetSetCurrentIndex2( sesid, tableid, szIndex2Name, JET_bitNoMove ) );

	printf( "\t\tNO_GRBIT\n" );
	Call( JetRetrieveColumn( sesid, tableid, columnid, &bBitRetrieved, 1, &cbActual, NO_GRBIT, NULL ) );
	if( !bBitRetrieved != !bBit )
		{
		printf( "\t\tERROR: set 0x%2.2x, got 0x%2.2x\n", bBit, bBitRetrieved );
		}
	printf( "\t\tJET_bitRetrieveFromIndex\n" );
	Call( JetRetrieveColumn( sesid, tableid, columnid, &bBitRetrieved, 1, &cbActual, JET_bitRetrieveFromIndex, NULL ) );
	if( !bBitRetrieved != !bBit )
		{
		printf( "\t\tERROR: set 0x%2.2x, got 0x%2.2x\n", bBit, bBitRetrieved );
		}
	printf( "\t\tJET_bitRetrieveFromPrimaryBookmark\n" );
	Call( JetRetrieveColumn( sesid, tableid, columnid, &bBitRetrieved, 1, &cbActual, JET_bitRetrieveFromPrimaryBookmark, NULL ) );
	if( !bBitRetrieved != !bBit )
		{
		printf( "\t\tERROR: set 0x%2.2x, got 0x%2.2x\n", bBit, bBitRetrieved );
		}

HandleError:
	return err;
	}

//  ================================================================
JET_ERR COLTYPBIT::ErrTest(
	const JET_INSTANCE instance,
	const JET_SESID sesid,
	JET_DBID& dbid )
//  ================================================================
	{
	JET_ERR					err			= 0;
	JET_TABLEID 			tableid;
	JET_COLUMNID			columnid;

	Call( JetBeginTransaction( sesid ) );
	Call( JetCreateTableColumnIndex( sesid, dbid, &tablecreate ) );
	Call( JetCommitTransaction( sesid, 0 ) );

	columnid = tablecreate.rgcolumncreate[0].columnid;
	tableid = tablecreate.tableid;

	printf( "\ttesting with 0x00...\n" );
	Call( ErrInsertRecordAndRetrieve( sesid, tableid, columnid, 0x00 ) );
	printf( "\ttesting with 0xff...\n" );
	Call( ErrInsertRecordAndRetrieve( sesid, tableid, columnid, 0xff ) );

HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\esetest\cbvarsegmac.cxx ===
#include "unittest.hxx"

//  ================================================================
class CBVARSEGMAC : public UNITTEST
//  ================================================================
	{
	private:
		static CBVARSEGMAC s_instance;

	protected:
		CBVARSEGMAC() {}

	public:
		~CBVARSEGMAC() {}

	public:
		const char * SzName() const;
		const char * SzDescription() const;

		bool FRunUnderESE98() const;
		bool FRunUnderESENT() const;
		bool FRunUnderESE97() const;

		JET_ERR ErrTest(
				const JET_INSTANCE instance,
				const JET_SESID sesid,
				JET_DBID& dbid );
	private:
		static const char s_szIndex1Name[];
		static const char s_szIndex1Key[];

		static const char s_szIndex2Name[];
		static const char s_szIndex2Key[];

		static JET_INDEXCREATE s_rgindexcreate[];

	};

CBVARSEGMAC CBVARSEGMAC::s_instance;

const char CBVARSEGMAC::s_szIndex1Name[]= "cbvarsegmac-index-1";
const char CBVARSEGMAC::s_szIndex1Key[]	= "-long\0";

const char CBVARSEGMAC::s_szIndex2Name[]= "cbvarsegmac-index-2";
const char CBVARSEGMAC::s_szIndex2Key[]	= "-long\0";


JET_INDEXCREATE CBVARSEGMAC::s_rgindexcreate[] = {
	{
	sizeof( JET_INDEXCREATE ),		// size of this structure (for future expansion)
	const_cast<char *>( s_szIndex1Name ),				// index name
	const_cast<char *>( s_szIndex1Key ),				// index key
	sizeof( s_szIndex1Key ),		// length of key
	NO_GRBIT,						// index options
	100,							// index density
	0,								// lcid for the index
	10,								// maximum length of variable length columns in index key
	NULL,							// pointer to conditional column structure
	0,								// number of conditional columns
	JET_errSuccess					// returned error code
	},
	{
	sizeof( JET_INDEXCREATE ),		// size of this structure (for future expansion)
	const_cast<char *>( s_szIndex2Name ),				// index name
	const_cast<char *>( s_szIndex2Key ),				// index key
	sizeof( s_szIndex2Key ),		// length of key
	NO_GRBIT,						// index options
	100,							// index density
	0,								// lcid for the index
	128,							// maximum length of variable length columns in index key
	NULL,							// pointer to conditional column structure
	0,								// number of conditional columns
	JET_errSuccess					// returned error code
	},
};

//  ================================================================
const char * CBVARSEGMAC::SzName() const
//  ================================================================
	{
	return "cbvarsegmac";
	}


//  ================================================================
const char * CBVARSEGMAC::SzDescription() const
//  ================================================================
	{
	return "Specify cbvarsegmac in the JET_CREATEINDEX, not in the key string";
	}


//  ================================================================
bool CBVARSEGMAC::FRunUnderESE98() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool CBVARSEGMAC::FRunUnderESENT() const
//  ================================================================
	{
	return 0;
	}


//  ================================================================
bool CBVARSEGMAC::FRunUnderESE97() const
//  ================================================================
	{
	return 0;
	}


//  ================================================================
JET_ERR CBVARSEGMAC::ErrTest(
	const JET_INSTANCE instance,
	const JET_SESID sesid, 
	JET_DBID& dbid )
//  ================================================================
	{
	JET_ERR err = JET_errSuccess;
	JET_TABLEID tableid = 0;
	const int cIndexes = sizeof( s_rgindexcreate ) / sizeof( s_rgindexcreate[0] );

	Call( JetOpenTable( sesid, dbid, szTable, NULL, 0, JET_bitTableDenyRead, &tableid ) );

	Call( JetCreateIndex2(
			sesid,
			tableid,
			s_rgindexcreate,
			cIndexes ) );

	int iIndex;
	for( iIndex = 0; iIndex < cIndexes; ++iIndex )
		{
		Call( JetDeleteIndex( sesid, tableid, s_rgindexcreate[iIndex].szIndexName ) );
		}

	Call( JetCloseTable( sesid, tableid ) );

HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\esetest\main.cxx ===
#include "unittest.hxx"

//  ================================================================
JET_COLUMNCREATE	rgcolumncreate[] = {
//  ================================================================
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"bit",							// name of column
	JET_coltypBit,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"bit2",							// name of column
	JET_coltypBit,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"long",							// name of column
	JET_coltypLong,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"long2",						// name of column
	JET_coltypLong,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"text",							// name of column
	JET_coltypText,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"text2",						// name of column
	JET_coltypText,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"binary",						// name of column
	JET_coltypBinary,				// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"binary2",						// name of column
	JET_coltypBinary,				// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"lv",							// name of column
	JET_coltypLongBinary,			// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"lv2",							// name of column
	JET_coltypLongBinary,			// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"longtext",						// name of column
	JET_coltypLongText,				// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"longtext2",					// name of column
	JET_coltypLongText,				// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
};


//  ================================================================
JET_COLUMNCREATE	rgcolumncreateTemplate[] = {
//  ================================================================
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"bit",							// name of column
	JET_coltypBit,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"long",							// name of column
	JET_coltypLong,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"text",							// name of column
	JET_coltypText,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"binary",						// name of column
	JET_coltypBinary,				// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"lv",							// name of column
	JET_coltypLongBinary,			// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"longtext",					// name of column
	JET_coltypLongText,				// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
};


//  ================================================================
JET_COLUMNCREATE	rgcolumncreateDerived[] = {
//  ================================================================
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"bit2",							// name of column
	JET_coltypBit,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"long2",						// name of column
	JET_coltypLong,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"text2",						// name of column
	JET_coltypText,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"binary2",						// name of column
	JET_coltypBinary,				// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"lv2",							// name of column
	JET_coltypLongBinary,			// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"longtext2",					// name of column
	JET_coltypLongText,				// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
};


//  ================================================================
JET_TABLECREATE2 tablecreate = {
//  ================================================================
	sizeof( JET_TABLECREATE2 ),				// size of this structure
	const_cast<char *>( szTable ),			// name of table
	NULL,									// name of base table
	16,										// initial pages
	100,									// density
	rgcolumncreate,							// columns to create
	sizeof( rgcolumncreate ) / sizeof( JET_COLUMNCREATE ),	// number of columns to create
	NULL,									// array of index creation info
	0,										// number of indexes to create
	NULL,									// callback to use
	NO_GRBIT,								// when to issue callback
	NO_GRBIT,								// grbit
	0,										// returned tableid
	0										// returned count of objects created
};


//  ================================================================
JET_TABLECREATE2 tablecreateTemplate = {
//  ================================================================
	sizeof( JET_TABLECREATE2 ),				// size of this structure
	const_cast<char *>( szTemplate ),		// name of table
	NULL,									// name of base table
	16,										// initial pages
	100,									// density
	rgcolumncreateTemplate,					// columns to create
	sizeof( rgcolumncreateTemplate ) / sizeof( JET_COLUMNCREATE ),	// number of columns to create
	NULL,									// array of index creation info
	0,										// number of indexes to create
	NULL,									// callback to use
	NO_GRBIT,								// when to issue callback
	JET_bitTableCreateFixedDDL,				// grbit
	0,										// returned tableid
	0										// returned count of objects created
};


//  ================================================================
JET_TABLECREATE2 tablecreateDerived = {
//  ================================================================
	sizeof( JET_TABLECREATE2 ),				// size of this structure
	const_cast<char *>( szDerived ),		// name of table
	NULL,									// name of base table
	16,										// initial pages
	100,									// density
	rgcolumncreateDerived,					// columns to create
	sizeof( rgcolumncreateDerived ) / sizeof( JET_COLUMNCREATE ),	// number of columns to create
	NULL,									// array of index creation info
	0,										// number of indexes to create
	NULL,									// callback to use
	NO_GRBIT,								// when to issue callback
	JET_bitTableCreateFixedDDL,				// grbit
	0,										// returned tableid
	0										// returned count of objects created
};


//  ================================================================
static void PrintTests()
//  ================================================================
	{
	const UNITTEST * punittest = UNITTEST::s_punittestHead;
	while( punittest )
		{
		fprintf( stderr, "==> %s\r\n%s\r\n\r\n", punittest->SzName(), punittest->SzDescription() );
		punittest = punittest->m_punittestNext;
		}
	}


//  ================================================================
static void PrintHelp( const char * const szApplication )
//  ================================================================
	{
	fprintf( stderr, "Usage: %s [tests]\r\n", szApplication );
	fprintf( stderr, "\tNo arguments runs all tests.\r\n" );
	fprintf( stderr, "\tAvailable tests are:\r\n\r\n" );
	PrintTests();
	}


//  ================================================================
static JET_ERR ErrRunTest(
		const JET_INSTANCE instance,
		JET_SESID& sesid,
		JET_DBID& dbid, 
		UNITTEST * const punittest )
//  ================================================================
	{
	printf( "==> %s\r\n", punittest->SzName() );
	const unsigned int cMsecStart = GetTickCount();
	JET_ERR err = punittest->ErrTest( instance, sesid, dbid );
	const unsigned int cMsecElapsed = GetTickCount() - cMsecStart;
	if( JET_errSuccess == err )
		{
		printf( "==> %s finishes in %d milliseconds\r\n", punittest->SzName(), cMsecElapsed );

		//	cleanup

		Call( ErrDeleteAllRecords( sesid, dbid, szTable ) );
		Call( ErrDeleteAllRecords( sesid, dbid, szTemplate ) );
		Call( ErrDeleteAllRecords( sesid, dbid, szDerived ) );
		Call( JetEndSession( sesid, NO_GRBIT ) );
		Call( JetBeginSession( instance, &sesid, NULL, NULL ) );
		Call( JetOpenDatabase( sesid, szDB, NULL, &dbid, 0 ) );

		}
	else
		{
		printf( "==> %s completes with err %d after %d milliseconds\r\n", punittest->SzName(), err, cMsecElapsed );
		}

HandleError:
	return err;
	}

//  ================================================================
static JET_ERR ErrRunAllTests( const JET_INSTANCE instance, JET_SESID& sesid, JET_DBID& dbid )
//  ================================================================
	{
	JET_ERR err = JET_errSuccess;

	UNITTEST * punittest = UNITTEST::s_punittestHead;
	while( punittest )
		{
		Call( ErrRunTest( instance, sesid, dbid, punittest ) );
		punittest = punittest->m_punittestNext;
		}

HandleError:
	return err;
	}


//  ================================================================
static JET_ERR ErrRunOneTest( const JET_INSTANCE instance, JET_SESID& sesid, JET_DBID& dbid, const char * const szTest )
//  ================================================================
	{
	UNITTEST * punittest = UNITTEST::s_punittestHead;
	while( punittest )
		{
		if( 0 == _stricmp( szTest, punittest->SzName() ) )
			{
			return ErrRunTest( instance, sesid, dbid, punittest );
			}
		punittest = punittest->m_punittestNext;
		}

	fprintf( stderr, "test '%s' was not found!\r\n", szTest );
	fprintf( stderr, "Available tests are:\r\n\r\n" );
	PrintTests();
	return JET_errInvalidParameter;
	}


//  ================================================================
static JET_ERR ErrCreateTable( const JET_SESID sesid, const JET_DBID dbid, JET_TABLECREATE2 * const ptablecreate )
//  ================================================================
	{
	JET_ERR					err			= 0;

	JET_INDEXCREATE	* rgindexcreate = new JET_INDEXCREATE[ptablecreate->cColumns];
	char ** rgszIndexKeys = new char *[ptablecreate->cColumns];

	unsigned int isz;
	for( isz = 0; isz < ptablecreate->cColumns; ++isz )
		{
		rgszIndexKeys[isz] = new char[JET_cbNameMost+4];
		memset( rgszIndexKeys[isz], 0, JET_cbNameMost+4 );
		}

	unsigned int iIndex;
	for( iIndex = 0; iIndex < ptablecreate->cColumns; ++iIndex )
		{
		char * const szColumn = const_cast<char *>( ptablecreate->rgcolumncreate[iIndex].szColumnName );
		rgindexcreate[iIndex].cbStruct				= sizeof( JET_INDEXCREATE );
		rgindexcreate[iIndex].szIndexName			= szColumn;
		rgindexcreate[iIndex].szKey					= rgszIndexKeys[iIndex];
		rgindexcreate[iIndex].cbKey					= sprintf( rgszIndexKeys[iIndex], "+%s%c", szColumn, '\0' ) + 1;
		rgindexcreate[iIndex].grbit					= NO_GRBIT;
		rgindexcreate[iIndex].ulDensity				= 100;
		rgindexcreate[iIndex].lcid					= 0;
		rgindexcreate[iIndex].cbVarSegMac			= 0;
		rgindexcreate[iIndex].rgconditionalcolumn	= NULL;
		rgindexcreate[iIndex].cConditionalColumn	= 0;
		rgindexcreate[iIndex].err					= JET_errSuccess;
		}

	ptablecreate->rgindexcreate = rgindexcreate;
	ptablecreate->cIndexes		= ptablecreate->cColumns;

	printf( "creating %s\r\n", ptablecreate->szTableName );
	Call( JetCreateTableColumnIndex2( sesid, dbid, ptablecreate ) );
	Call( JetCloseTable( sesid, ptablecreate->tableid ) );

HandleError:

	delete [] rgindexcreate;

	for( isz = 0; isz < ptablecreate->cColumns; ++isz )
		{
		delete [] rgszIndexKeys[isz];
		}

	delete [] rgszIndexKeys;

	return err;
	}


//  ================================================================
static bool FRunTests( const int argc, const char * const argv[] )
//  ================================================================
	{
	JET_INSTANCE			instance	= 0;
	JET_ERR					err			= 0;
	JET_SESID				sesid		= 0;
	JET_DBID				dbid		= 0;

	const unsigned int cMsecStart = GetTickCount();

	Call( JetSetSystemParameter( &instance, 0, JET_paramDatabasePageSize, 8192, NULL ) );
	Call( JetSetSystemParameter( &instance, 0, JET_paramEnableOnlineDefrag, 0, NULL ) );
	Call( JetSetSystemParameter( &instance, 0, JET_paramIndexTuplesLengthMin, 4, NULL ) );
	Call( JetSetSystemParameter( &instance, 0, JET_paramIndexTuplesLengthMax, 10, NULL ) );
	Call( JetSetSystemParameter( &instance, 0, JET_paramIndexTuplesToIndexMax, 32767, NULL ) );
	Call( JetInit( &instance ) );

	Call( JetBeginSession( instance, &sesid, NULL, NULL ) );

	printf( "creating database\r\n" );

	Call( JetCreateDatabase2( sesid, szDB, 0, &dbid, NO_GRBIT ) );
	Call( JetCloseDatabase( sesid, dbid, 0 ) );
	Call( JetOpenDatabase( sesid, szDB, NULL, &dbid, 0 ) );

	Call( ErrCreateTable( sesid, dbid, &tablecreateTemplate ) );
	Call( ErrCreateTable( sesid, dbid, &tablecreateDerived ) );
	Call( ErrCreateTable( sesid, dbid, &tablecreate ) );

	if( 1 == argc )
		{
		Call( ErrRunAllTests( instance, sesid, dbid ) );
		}
	else
		{
		int isz;
		for( isz = 1; isz < argc; ++isz )
			{
			Call( ErrRunOneTest( instance, sesid, dbid, argv[isz] ) );
			}
		}

	Call( JetTerm( instance ) );

HandleError:
	const unsigned int cMsecElapsed = GetTickCount() - cMsecStart;
	if ( err >= 0 )
		{
		printf( "%s completes successfully in %d milliseconds.\r\n", argv[0], cMsecElapsed );
		}
	else
		{
		printf( "%s completes with err = %d after %d milliseconds\r\n", argv[0], err, cMsecElapsed );
		}

	return ( JET_errSuccess != err );
	}


//  ================================================================
int _cdecl main( int argc, char * argv[] )
//  ================================================================
	{
	if( argc == 2
		&& ( 0 == _stricmp( argv[1], "-h" )
			|| 0 == _stricmp( argv[1], "/h" )
			|| 0 == _stricmp( argv[1], "/?" ) ) )
		{
		PrintHelp( argv[0] );
		return 0;
		}
	return FRunTests( argc, argv );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\esetest\readonlycopy.cxx ===
#include "unittest.hxx"

//  ================================================================
class READONLYCOPY : public UNITTEST
//  ================================================================
	{
	private:
		static READONLYCOPY s_instance;

	protected:
		READONLYCOPY() {}

	public:
		~READONLYCOPY() {}

	public:
		const char * SzName() const;
		const char * SzDescription() const;

		bool FRunUnderESE98() const;
		bool FRunUnderESENT() const;
		bool FRunUnderESE97() const;

		JET_ERR ErrTest(
				const JET_INSTANCE instance,
				const JET_SESID sesid,
				JET_DBID& dbid );

	private:
		JET_ERR ErrGetColumnids( const JET_SESID sesid, const JET_TABLEID tableid );
		JET_ERR ErrCreateRecords( const JET_SESID sesid, const JET_DBID dbid, const char * const szTable );
		JET_ERR ErrErrorCases( const JET_SESID sesid, const JET_DBID dbid, const char * const szTable );
		JET_ERR ErrRetrieveColumns( const JET_SESID sesid, const JET_TABLEID tableid, const int i );
		JET_ERR ErrReadOnlyCases( const JET_SESID sesid, const JET_DBID dbid, const char * const szTable );
		JET_ERR ErrNavigationCases( const JET_SESID sesid, const JET_DBID dbid, const char * const szTable );
		JET_ERR ErrMultiSessionCases( const JET_INSTANCE instance, const char * const szDB, const JET_SESID sesid, const JET_DBID dbid, const char * const szTable );
		JET_ERR ErrMultiTableidCases( const JET_SESID sesid, const JET_DBID dbid, const char * const szTable );
		JET_ERR ErrTimedCases( const JET_SESID sesid, const JET_DBID dbid, const char * const szTable );

	private:
		JET_COLUMNID m_columnidLong;
		JET_COLUMNID m_columnidText;

		enum { m_cbBuf = 8192 };
		unsigned char m_rgbBuf[m_cbBuf];

		enum { m_recordFirst	= 1 };
		enum { m_recordLast	= 100 };
	};

READONLYCOPY READONLYCOPY::s_instance;


//  ================================================================
const char * READONLYCOPY::SzName() const
//  ================================================================
	{
	return "readonlycopy";
	}


//  ================================================================
const char * READONLYCOPY::SzDescription() const
//  ================================================================
	{
	return "Tests JetPrepareUpdate() with the JET_prepReadOnlyCopy grbit";
	}


//  ================================================================
bool READONLYCOPY::FRunUnderESE98() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool READONLYCOPY::FRunUnderESENT() const
//  ================================================================
	{
	return 0;
	}


//  ================================================================
bool READONLYCOPY::FRunUnderESE97() const
//  ================================================================
	{
	return 0;
	}


//  ================================================================
JET_ERR READONLYCOPY::ErrTest(
	const JET_INSTANCE instance,
	const JET_SESID sesid,
	JET_DBID& dbid )
//  ================================================================
	{
	JET_ERR err = JET_errSuccess;

	Call( ErrCreateRecords( sesid, dbid, szTable ) );

	Call( ErrErrorCases( sesid, dbid, szTable ) );
	Call( ErrReadOnlyCases( sesid, dbid, szTable ) );
	Call( ErrNavigationCases( sesid, dbid, szTable ) );
	Call( ErrMultiSessionCases( instance, szDB, sesid, dbid, szTable ) );
	Call( ErrMultiTableidCases( sesid, dbid, szTable ) );
	Call( ErrTimedCases( sesid, dbid, szTable ) );

	printf( "\tdetaching and re-attaching read-only\r\n" );

	Call( JetCloseDatabase( sesid, dbid, 0 ) );
	Call( JetDetachDatabase( sesid, szDB ) );

	Call( JetAttachDatabase( sesid, szDB, JET_bitDbReadOnly ) );
	Call( JetOpenDatabase( sesid, szDB, NULL, &dbid, JET_bitDbReadOnly ) );

	Call( JetCloseDatabase( sesid, dbid, 0 ) );
	Call( JetDetachDatabase( sesid, szDB ) );

	Call( JetAttachDatabase( sesid, szDB, NO_GRBIT ) );
	Call( JetOpenDatabase( sesid, szDB, NULL, &dbid, NO_GRBIT ) );

	Call( ErrDeleteAllRecords( sesid, dbid, szTable ) );

HandleError:
	return err;
	}


//  ================================================================
JET_ERR READONLYCOPY::ErrGetColumnids( const JET_SESID sesid, const JET_TABLEID tableid )
//  ================================================================
	{
	JET_ERR err = JET_errSuccess;
	JET_COLUMNDEF columndef;

	Call( JetGetTableColumnInfo(
		sesid,
		tableid,
		"long",
		&columndef,
		sizeof( JET_COLUMNDEF ),
		JET_ColInfo ) );	
	m_columnidLong = columndef.columnid;

	Call( JetGetTableColumnInfo(
		sesid,
		tableid,
		"longtext",
		&columndef,
		sizeof( JET_COLUMNDEF ),
		JET_ColInfo ) );	
	m_columnidText = columndef.columnid;

HandleError:
	return err;
	}


//  ================================================================
JET_ERR READONLYCOPY::ErrCreateRecords( const JET_SESID sesid, const JET_DBID dbid, const char * const szTable )
//  ================================================================
	{
	JET_ERR err = JET_errSuccess;
	JET_TABLEID tableid = 0;

	Call( JetOpenTable( sesid, dbid, szTable, NULL, 0, NO_GRBIT, &tableid ) );

	Call( ErrGetColumnids( sesid, tableid ) );

	Call( JetBeginTransaction2( sesid, NO_GRBIT ) );

	long i;
	for( i = m_recordFirst; i <= m_recordLast; ++i )
		{
		memset( m_rgbBuf, i, sizeof( m_rgbBuf ) );

		Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );

		Call( JetSetColumn( sesid, tableid, m_columnidLong, &i, sizeof(i), NO_GRBIT, NULL ) );
		Call( JetSetColumn( sesid, tableid, m_columnidText, m_rgbBuf, m_cbBuf, NO_GRBIT, NULL ) );

		Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );
		}

	Call( JetCommitTransaction( sesid, JET_bitCommitLazyFlush ) );
	Call( JetCloseTable( sesid, tableid ) );

HandleError:
	return err;
	}


//  ================================================================
JET_ERR READONLYCOPY::ErrErrorCases( const JET_SESID sesid, const JET_DBID dbid, const char * const szTable )
//  ================================================================
	{
	JET_ERR		err		= JET_errSuccess;
	JET_TABLEID tableid = 0;

	printf( "\terror cases\r\n" );

	Call( JetOpenTable( sesid, dbid, szTable, NULL, 0, NO_GRBIT, &tableid ) );

	//	not currently in a transaction

	printf( "\t\tpreparing an update at level 0 (failure)\r\n" );
	Fail( JetPrepareUpdate( sesid, tableid, JET_prepReadOnlyCopy ), JET_errNotInTransaction );
	
	//	(begin a transaction)

	Call( JetBeginTransaction2( sesid, NO_GRBIT ) );

	//	not currently on a record
	
	printf( "\t\tpreparing an update not on a record (failure)\r\n" );
	Fail( JetMove( sesid, tableid, JET_MovePrevious, NO_GRBIT ), JET_errNoCurrentRecord );
	Fail( JetPrepareUpdate( sesid, tableid, JET_prepReadOnlyCopy ), JET_errNoCurrentRecord );

	//	(move to a record)

	Call( JetMove( sesid, tableid, JET_MoveFirst, NO_GRBIT ) );

	//	already in an update

	printf( "\t\tpreparing an update while in an update (failure)\r\n" );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Fail( JetPrepareUpdate( sesid, tableid, JET_prepReadOnlyCopy ), JET_errAlreadyPrepared );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepCancel ) );

	//	already in an update

	printf( "\t\tpreparing an update while in an update (failure)\r\n" );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReadOnlyCopy ) );
	Fail( JetPrepareUpdate( sesid, tableid, JET_prepReadOnlyCopy ), JET_errAlreadyPrepared );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepCancel ) );

	//	calling JetUpdate

	printf( "\t\tcalling JetUpdate with a ReadOnlyCopy prepared (failure)\r\n" );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReadOnlyCopy ) );
	Fail( JetUpdate( sesid, tableid, NULL, 0, NULL ), JET_errUpdateNotPrepared );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepCancel ) );

	//	calling JetSetColumn(s)

	printf( "\t\tcalling JetSetColumn(s) with a ReadOnlyCopy prepared (failure)\r\n" );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReadOnlyCopy ) );
	Fail( JetSetColumn( sesid, tableid, m_columnidText, m_rgbBuf, m_cbBuf, NO_GRBIT, NULL ), JET_errUpdateNotPrepared );

	JET_SETCOLUMN setcolumn;
	setcolumn.columnid		= m_columnidText;
	setcolumn.pvData		= m_rgbBuf;
	setcolumn.cbData		= m_cbBuf;
	setcolumn.grbit			= NO_GRBIT;
	setcolumn.ibLongValue	= 0;
	setcolumn.itagSequence	= 1;
	setcolumn.err			= JET_errSuccess;
	Fail( JetSetColumns( sesid, tableid, &setcolumn, 1 ), JET_errUpdateNotPrepared );

	Call( JetPrepareUpdate( sesid, tableid, JET_prepCancel ) );

	Call( JetCommitTransaction( sesid, NO_GRBIT ) );
	Call( JetCloseTable( sesid, tableid ) );

HandleError:
	return err;
	}


//  ================================================================
JET_ERR READONLYCOPY::ErrRetrieveColumns( const JET_SESID sesid, const JET_TABLEID tableid, const int i )
//  ================================================================
	{
	JET_ERR err = JET_errSuccess;

	long l;
	unsigned long cbActual;

	Call( JetRetrieveColumn( sesid, tableid, m_columnidLong, &l, sizeof( l ), &cbActual, NO_GRBIT, NULL ) );
	if( sizeof( l ) != cbActual )
		{
		fprintf( stderr, "cbActual is wrong. expected %d bytes, got %d\r\n", sizeof( l ), cbActual );
		Call( -1 );
		}
	if( i != l )
		{
		fprintf( stderr, "columnidLong is wrong. expected %d, got %d\r\n", i, l );
		Call( -1 );
		}

	Call( JetRetrieveColumn( sesid, tableid, m_columnidText, m_rgbBuf, m_cbBuf, &cbActual, NO_GRBIT, NULL ) );
	if( m_cbBuf != cbActual )
		{
		fprintf( stderr, "cbActual is wrong. expected %d bytes, got %d\r\n", m_cbBuf, cbActual );
		Call( -1 );
		}
	int ib;
	for( ib = 0; ib < m_cbBuf; ++ib )
		{
		if( m_rgbBuf[ib] != (char)i )
			{
			fprintf( stderr, "columnidText is wrong at byted %d. expected %d, got %d\r\n", ib, i, m_rgbBuf[ib] );
			Call( -1 );
			}
		}

HandleError:
	return err;
	}


//  ================================================================
JET_ERR READONLYCOPY::ErrReadOnlyCases( const JET_SESID sesid, const JET_DBID dbid, const char * const szTable )
//  ================================================================
	{
	JET_ERR		err		= JET_errSuccess;
	JET_TABLEID tableid = 0;

	printf( "\tread-only tests\r\n" );

	//	read-only transaction

	printf( "\t\tpreparing an update in a read-only transaction\r\n" );
	Call( JetOpenTable( sesid, dbid, szTable, NULL, 0, NO_GRBIT, &tableid ) );
	Call( JetBeginTransaction2( sesid, JET_bitTransactionReadOnly ) );
	Call( JetMove( sesid, tableid, JET_MoveFirst, NO_GRBIT ) );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReadOnlyCopy ) );
	Call( ErrRetrieveColumns( sesid, tableid, m_recordFirst ) );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepCancel ) );
	Call( JetCommitTransaction( sesid, NO_GRBIT ) );
	Call( JetCloseTable( sesid, tableid ) );

	//	read-only table

	printf( "\t\tpreparing an update on a read-only table\r\n" );
	Call( JetOpenTable( sesid, dbid, szTable, NULL, 0, JET_bitTableReadOnly, &tableid ) );
	Call( JetBeginTransaction2( sesid, NO_GRBIT ) );
	Call( JetMove( sesid, tableid, JET_MoveLast, NO_GRBIT ) );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReadOnlyCopy ) );
	Call( ErrRetrieveColumns( sesid, tableid, m_recordLast ) );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepCancel ) );
	Call( JetCommitTransaction( sesid, NO_GRBIT ) );
	Call( JetCloseTable( sesid, tableid ) );

HandleError:
	return err;
	}


//  ================================================================
JET_ERR READONLYCOPY::ErrNavigationCases( const JET_SESID sesid, const JET_DBID dbid, const char * const szTable )
//  ================================================================
//
//	Navigation should cancel the update
//
//-
	{
	JET_ERR		err		= JET_errSuccess;
	JET_TABLEID tableid = 0;

	int i = m_recordFirst;

	printf( "\tnaviagation tests\r\n" );

	Call( JetOpenTable( sesid, dbid, szTable, NULL, 0, NO_GRBIT, &tableid ) );
	Call( JetSetCurrentIndex( sesid, tableid, "long" ) );

	Call( JetBeginTransaction2( sesid, NO_GRBIT ) );

	Call( JetMove( sesid, tableid, JET_MoveFirst, NO_GRBIT ) );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReadOnlyCopy ) );
	Call( ErrRetrieveColumns( sesid, tableid, i ) );

	printf( "\t\tMoveNext\r\n" );
	Call( JetMove( sesid, tableid, JET_MoveNext, NO_GRBIT ) );
	++i;
	Call( ErrRetrieveColumns( sesid, tableid, i ) );
	Fail( JetPrepareUpdate( sesid, tableid, JET_prepCancel ), JET_errUpdateNotPrepared );

	printf( "\t\tMovePrev\r\n" );
	Call( JetMove( sesid, tableid, JET_MoveNext, NO_GRBIT ) );
	++i;
	Call( JetMove( sesid, tableid, JET_MoveNext, NO_GRBIT ) );
	++i;
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReadOnlyCopy ) );
	Call( ErrRetrieveColumns( sesid, tableid, i ) );
	Call( JetMove( sesid, tableid, JET_MovePrevious, NO_GRBIT ) );
	--i;
	Call( ErrRetrieveColumns( sesid, tableid, i ) );
	Fail( JetPrepareUpdate( sesid, tableid, JET_prepCancel ), JET_errUpdateNotPrepared );

	printf( "\t\tMoveFirst\r\n" );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReadOnlyCopy ) );
	Call( ErrRetrieveColumns( sesid, tableid, i ) );
	Call( JetMove( sesid, tableid, JET_MoveFirst, NO_GRBIT ) );
	i = m_recordFirst;
	Call( ErrRetrieveColumns( sesid, tableid, i ) );
	Fail( JetPrepareUpdate( sesid, tableid, JET_prepCancel ), JET_errUpdateNotPrepared );

	printf( "\t\tMoveLast\r\n" );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReadOnlyCopy ) );
	Call( ErrRetrieveColumns( sesid, tableid, i ) );
	Call( JetMove( sesid, tableid, JET_MoveLast, NO_GRBIT ) );
	i = m_recordLast;
	Call( ErrRetrieveColumns( sesid, tableid, i ) );
	Fail( JetPrepareUpdate( sesid, tableid, JET_prepCancel ), JET_errUpdateNotPrepared );

	printf( "\t\tSeek\r\n" );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReadOnlyCopy ) );
	Call( ErrRetrieveColumns( sesid, tableid, i ) );
	i = 75;
	Call( JetMakeKey( sesid, tableid, &i, sizeof( i ), JET_bitNewKey ) );
	Call( JetSeek( sesid, tableid, JET_bitSeekEQ ) );
	Call( ErrRetrieveColumns( sesid, tableid, i ) );
	Fail( JetPrepareUpdate( sesid, tableid, JET_prepCancel ), JET_errUpdateNotPrepared );

	Call( JetCommitTransaction( sesid, NO_GRBIT ) );
	Call( JetCloseTable( sesid, tableid ) );

HandleError:
	return err;
	}


//  ================================================================
JET_ERR READONLYCOPY::ErrMultiSessionCases( const JET_INSTANCE instance, const char * const szDB, const JET_SESID sesid, const JET_DBID dbid, const char * const szTable )

//  ================================================================
//
//	Multiple sessions on the same record
//
//-
	{
	JET_ERR		err		= JET_errSuccess;
	JET_TABLEID tableid = 0;

	JET_SESID sesid2;
	JET_DBID dbid2;
	JET_TABLEID tableid2;

	int i = m_recordFirst;

	printf( "\tmulti-session tests\r\n" );

	Call( JetBeginSession( instance, &sesid2, NULL, NULL ) );
	Call( JetOpenDatabase( sesid2, szDB, NULL, &dbid2, 0 ) );

	Call( JetOpenTable( sesid, dbid, szTable, NULL, 0, NO_GRBIT, &tableid ) );
	Call( JetOpenTable( sesid2, dbid2, szTable, NULL, 0, NO_GRBIT, &tableid2 ) );

	Call( JetBeginTransaction2( sesid, NO_GRBIT ) );
	Call( JetBeginTransaction2( sesid2, NO_GRBIT ) );

	Call( JetMove( sesid, tableid, JET_MoveFirst, NO_GRBIT ) );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReadOnlyCopy ) );
	Call( ErrRetrieveColumns( sesid, tableid, i ) );

	Call( JetMove( sesid2, tableid2, JET_MoveFirst, NO_GRBIT ) );
	Call( JetPrepareUpdate( sesid2, tableid2, JET_prepReadOnlyCopy ) );
	Call( ErrRetrieveColumns( sesid2, tableid2, i ) );

	Call( JetPrepareUpdate( sesid, tableid, JET_prepCancel ) );
	Call( JetPrepareUpdate( sesid2, tableid2, JET_prepCancel ) );

	Call( JetCommitTransaction( sesid, NO_GRBIT ) );
	Call( JetCommitTransaction( sesid2, NO_GRBIT ) );

	Call( JetCloseTable( sesid, tableid ) );
	Call( JetCloseTable( sesid2, tableid2 ) );

	Call( JetCloseDatabase( sesid2, dbid2, 0 ) );
	Call( JetEndSession( sesid2, NO_GRBIT ) );

HandleError:
	return err;
	}


//  ================================================================
JET_ERR READONLYCOPY::ErrMultiTableidCases( const JET_SESID sesid, const JET_DBID dbid, const char * const szTable )
//  ================================================================
//
//	Multiple sessions on the same record
//
//-
	{
	JET_ERR		err		= JET_errSuccess;
	JET_TABLEID tableid = 0;
	JET_TABLEID tableid2;

	int i = m_recordFirst;

	printf( "\tmulti-tableid tests\r\n" );

	Call( JetOpenTable( sesid, dbid, szTable, NULL, 0, NO_GRBIT, &tableid ) );
	Call( JetOpenTable( sesid, dbid, szTable, NULL, 0, NO_GRBIT, &tableid2 ) );

	Call( JetBeginTransaction2( sesid, NO_GRBIT ) );

	Call( JetMove( sesid, tableid, JET_MoveFirst, NO_GRBIT ) );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReadOnlyCopy ) );
	Call( ErrRetrieveColumns( sesid, tableid, i ) );

	Call( JetMove( sesid, tableid2, JET_MoveFirst, NO_GRBIT ) );
	Call( JetPrepareUpdate( sesid, tableid2, JET_prepReadOnlyCopy ) );
	Call( ErrRetrieveColumns( sesid, tableid2, i ) );

	Call( JetMove( sesid, tableid2, JET_MoveLast, NO_GRBIT ) );
	Call( ErrRetrieveColumns( sesid, tableid2, m_recordLast ) );
	Call( JetPrepareUpdate( sesid, tableid2, JET_prepReadOnlyCopy ) );
	Call( ErrRetrieveColumns( sesid, tableid2, m_recordLast ) );

	//	make sure the first tableid still works

	Call( ErrRetrieveColumns( sesid, tableid, i ) );

	Call( JetPrepareUpdate( sesid, tableid, JET_prepCancel ) );
	Call( JetPrepareUpdate( sesid, tableid2, JET_prepCancel ) );

	Call( JetCommitTransaction( sesid, NO_GRBIT ) );

	Call( JetCloseTable( sesid, tableid ) );
	Call( JetCloseTable( sesid, tableid2 ) );

HandleError:
	return err;
	}


//  ================================================================
JET_ERR READONLYCOPY::ErrTimedCases( const JET_SESID sesid, const JET_DBID dbid, const char * const szTable )
//  ================================================================
	{
	JET_ERR		err		= JET_errSuccess;
	JET_TABLEID tableid = 0;
	long l;
	unsigned long cbActual;
	int i;
#ifdef DEBUG
	const int reps = 20000;
#else  //  !DEBUG
	const int reps = 1000000;
#endif  //  DEBUG
	const int record = 51;

	unsigned int cMsecStart;
	unsigned int cMsecNormal;
	unsigned int cMsecPrepCopyReadOnly;

	printf( "\ttimed tests\r\n" );

	Call( JetBeginTransaction2( sesid, NO_GRBIT ) );

	Call( JetOpenTable( sesid, dbid, szTable, NULL, 0, NO_GRBIT, &tableid ) );
	Call( JetSetCurrentIndex( sesid, tableid, "long" ) );

	l = record;
	Call( JetMakeKey( sesid, tableid, &l, sizeof( l ), JET_bitNewKey ) );
	Call( JetSeek( sesid, tableid, JET_bitSeekEQ ) );

	//	make sure everything is cached

	Call( JetRetrieveColumn( sesid, tableid, m_columnidLong, &l, sizeof( l ), &cbActual, NO_GRBIT, NULL ) );
	if( sizeof( l ) != cbActual )
		{
		fprintf( stderr, "cbActual is wrong. expected %d bytes, got %d\r\n", sizeof( l ), cbActual );
		Call( -1 );
		}
	if( record != l )
		{
		fprintf( stderr, "columnidLong is wrong. expected %d, got %d\r\n", record, l );
		Call( -1 );
		}

	//	normal retrieve column

	cMsecStart = GetTickCount();

	for( i = 0; i < reps; ++i )
		{
		Call( JetRetrieveColumn( sesid, tableid, m_columnidLong, &l, sizeof( l ), &cbActual, NO_GRBIT, NULL ) );
		}

	cMsecNormal = GetTickCount() - cMsecStart;

	//	with JET_prepReadOnlyCopy

	Call( JetPrepareUpdate( sesid, tableid, JET_prepReadOnlyCopy ) );
	Call( JetRetrieveColumn( sesid, tableid, m_columnidLong, &l, sizeof( l ), &cbActual, NO_GRBIT, NULL ) );
	if( sizeof( l ) != cbActual )
		{
		fprintf( stderr, "cbActual is wrong. expected %d bytes, got %d\r\n", sizeof( l ), cbActual );
		Call( -1 );
		}
	if( record != l )
		{
		fprintf( stderr, "columnidLong is wrong. expected %d, got %d\r\n", record, l );
		Call( -1 );
		}

	cMsecStart = GetTickCount();

	for( i = 0; i < reps; ++i )
		{
		Call( JetRetrieveColumn( sesid, tableid, m_columnidLong, &l, sizeof( l ), &cbActual, NO_GRBIT, NULL ) );
		}

	cMsecPrepCopyReadOnly = GetTickCount() - cMsecStart;

	Call( JetPrepareUpdate( sesid, tableid, JET_prepCancel ) );

	Call( JetCommitTransaction( sesid, NO_GRBIT ) );
	Call( JetCloseTable( sesid, tableid ) );

	printf( "\t\t%d reps\r\n", reps );
	printf( "\t\tnormal: %d milliseconds\r\n", cMsecNormal );
	printf( "\t\tJET_prepReadOnlyCopy: %d milliseconds\r\n", cMsecPrepCopyReadOnly );

	if( cMsecNormal <= cMsecPrepCopyReadOnly )
		{
		fprintf( stderr, "JET_prepInsertReadOnly is too slow!\r\n" );
		Call( -1 );
		}

HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\esetest\tuple.cxx ===
#include "unittest.hxx"

//#define	LOTSOFTUPLES	1

//  ================================================================
class TUPLEINDEX : public UNITTEST
//  ================================================================
	{
	private:
		static TUPLEINDEX s_instance;

	protected:
		TUPLEINDEX() {}

	public:
		~TUPLEINDEX() {}

	public:
		const char * SzName() const;
		const char * SzDescription() const;

		bool FRunUnderESE98() const;
		bool FRunUnderESENT() const;
		bool FRunUnderESE97() const;

		JET_ERR ErrTest(
				const JET_INSTANCE instance,
				const JET_SESID sesid,
				JET_DBID& dbid );
	};

TUPLEINDEX TUPLEINDEX::s_instance;


//  ================================================================
const char * TUPLEINDEX::SzName() const
//  ================================================================
	{
	return "tupleindex";
	}


//  ================================================================
const char * TUPLEINDEX::SzDescription() const
//  ================================================================
	{
	return	"Test tuple index and optimized update.";
	}


//  ================================================================
bool TUPLEINDEX::FRunUnderESE98() const
//  ================================================================
	{
	return 0;
	}


//  ================================================================
bool TUPLEINDEX::FRunUnderESENT() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool TUPLEINDEX::FRunUnderESE97() const
//  ================================================================
	{
	return 0;
	}

static const char szMyTable[]		= "TUPLEINDEX::table";

static JET_COLUMNCREATE	rgcolumncreate[] = {
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"long",							// name of column
	JET_coltypLong,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
//	{
//	sizeof( JET_COLUMNCREATE ),		// size of structure
//	"fixedtext",						// name of column
//	JET_coltypText,					// type of column
//	10,								// cbMax
//	JET_bitColumnFixed,				// grbit
//	NULL,							// pvDefault
//	0,								// cbDefault
//	0,								// code page
//	0,								// returned columnid
//	JET_errSuccess					// returned err	
//	},
//	{
//	sizeof( JET_COLUMNCREATE ),		// size of structure
//	"shorttext",						// name of column
//	JET_coltypText,					// type of column
//	0,								// cbMax
//	0,								// grbit
//	NULL,							// pvDefault
//	0,								// cbDefault
//	0,								// code page
//	0,								// returned columnid
//	JET_errSuccess					// returned err	
//	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"longtext",						// name of column
	JET_coltypLongText,				// type of column
	0,								// cbMax
	JET_bitColumnMultiValued,			// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
};

static const char szIndex1Name[]	= "primary-index";
static const char szIndex1Key[]	= "+long\0";


static JET_INDEXCREATE rgindexcreate[] = {
	{
	sizeof( JET_INDEXCREATE ),			// size of this structure (for future expansion)
	const_cast<char *>( szIndex1Name ),// index name
	const_cast<char *>( szIndex1Key ),	// index key
	sizeof( szIndex1Key ),				// length of key
	JET_bitIndexPrimary,				// index options
	100,								// index density
	0,								// lcid for the index
	0,								// maximum length of variable length columns in index key
	NULL,							// pointer to conditional column structure
	0,								// number of conditional columns
	JET_errSuccess					// returned error code
	},
};

static const char szIndex2Name[]	= "secondary-index";
static const char szIndex2Key[]	= "+longtext\0";

static JET_INDEXCREATE rgindexcreateSec[] = {
	{
	sizeof( JET_INDEXCREATE ),			// size of this structure (for future expansion)
	const_cast<char *>( szIndex2Name ), // index name
	const_cast<char *>( szIndex2Key ),	// index key
	sizeof( szIndex2Key ),				// length of key
	JET_bitIndexTuples,				// index options
	100,								// index density
	0,								// lcid for the index
	0,								// maximum length of variable length columns in index key
	NULL,							// pointer to conditional column structure
	0,								// number of conditional columns
	JET_errSuccess					// returned error code
	},
};

static JET_TABLECREATE tablecreate = {
	sizeof( JET_TABLECREATE ),				// size of this structure
	const_cast<char *>( szMyTable ),		// name of table
	NULL,								// name of base table
	16,									// initial pages
	100,									// density
	rgcolumncreate,						// columns to create
	sizeof( rgcolumncreate ) / sizeof( JET_COLUMNCREATE ), // number of columns to create
	rgindexcreate,						// array of index creation info
	sizeof( rgindexcreate ) / sizeof( JET_INDEXCREATE ), // number of indexes to create
	0,									// grbit
	0,									// returned tableid
	0									// returned count of objects created
};

static long l;
#ifdef LOTSOFTUPLES
static unsigned char rgb[4000];
#else
static unsigned char rgb[12];
#endif

static JET_SETCOLUMN rgsetcolumn[] = {
	{
	0,						//  columnid
	&l,						//  pvData
	sizeof( long ),				//  cbData
	0,						//  grbit
	0,						//  ibLongValue
	1,						//  itag sequence
	0						//  err
	},
	{
	0,						//  columnid
	rgb,						//  pvData
	sizeof( rgb ),				//  cbData
	0,						//  grbit
	0,						//  ibLongValue
	1,						//  itag sequence
	0						//  err
	},
};

//  ================================================================
JET_ERR TUPLEINDEX::ErrTest(
	const JET_INSTANCE instance,
	const JET_SESID sesid,
	JET_DBID& dbid )
//  ================================================================
	{
	JET_ERR				err			= 0;
	JET_TABLEID 			tableid		= 0;


	Call( JetBeginTransaction( sesid ) );
	Call( JetCreateTableColumnIndex( sesid, dbid, &tablecreate ) );
	Call( JetCloseTable( sesid, tablecreate.tableid ) );
	Call( JetCommitTransaction( sesid, 0 ) );


	Call( JetBeginTransaction( sesid ) );
	rgsetcolumn[0].columnid = tablecreate.rgcolumncreate[0].columnid;
	rgsetcolumn[1].columnid = tablecreate.rgcolumncreate[1].columnid;
	Call( JetOpenTable( sesid, dbid, szMyTable, NULL, 0, 0, &tableid ) );
	printf( "\t[2] Creating index...\n" );
	Call( JetCreateIndex2(
			sesid,
			tableid,
			rgindexcreateSec,
			sizeof( rgindexcreateSec ) / sizeof( JET_INDEXCREATE ) ) );
	Call( JetCommitTransaction( sesid, 0 ) );


	Call( JetBeginTransaction( sesid ) );
	l	= 1;
#ifdef LOTSOFTUPLES
	memset( rgb, 'a', sizeof(rgb) );
#else
	rgb[0] = 'a';
	rgb[1] = 'a';
	rgb[2] = 'a';
	rgb[3] = 'a';
	rgb[4] = 'a';
	rgb[5] = 'a';
	rgb[6] = 'a';
	rgb[7] = 'a';
	rgb[8] = 'a';
	rgb[9] = 'a';
	rgb[10] = 'a';
	rgb[11] = 'a';
#endif
	printf( "\t[1] Insert record %d...\r\n", l );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Call( JetSetColumns( sesid, tableid, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );
	Call( JetCommitTransaction( sesid, 0 ) );


	Call( JetBeginTransaction( sesid ) );
	printf( "\t[1] Replacing record 1...\r\n" );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReplaceNoLock ) );
	JET_SETINFO setinfo;
	setinfo.cbStruct		= sizeof( JET_SETINFO );
	setinfo.ibLongValue		= 0;
	setinfo.itagSequence	= 1;
#ifdef LOTSOFTUPLES
	memset( rgb, 'b', sizeof(rgb) );
#else
	rgb[0] = 'b';
	rgb[1] = 'b';
	rgb[2] = 'b';
	rgb[3] = 'b';
	rgb[4] = 'b';
	rgb[5] = 'b';
	rgb[6] = 'b';
	rgb[7] = 'b';
	rgb[8] = 'b';
	rgb[9] = 'b';
	rgb[10] = 'b';
	rgb[11] = 'b';	
#endif
	Call( JetSetColumn( sesid, tableid, rgsetcolumn[1].columnid, rgb, sizeof( rgb ), 0, &setinfo ) );
	//	Call( JetSetColumn( sesid, tableid, rgsetcolumn[1].columnid, rgb, sizeof( rgb ), JET_bitSetOverwriteLV, &setinfo ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );
	printf( "\t[1] Committing...\n" );
	Call( JetCommitTransaction( sesid, 0 ) );

	
HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\esetest\rcecache.cxx ===
#include "unittest.hxx"

//  ================================================================
class RCECACHE : public UNITTEST
//  ================================================================
	{
	private:
		static RCECACHE s_instance;

	protected:
		RCECACHE() {}

	public:
		~RCECACHE() {}

	public:
		const char * SzName() const;
		const char * SzDescription() const;

		bool FRunUnderESE98() const;
		bool FRunUnderESENT() const;
		bool FRunUnderESE97() const;

		JET_ERR ErrTest(
				const JET_INSTANCE instance,
				const JET_SESID sesid,
				JET_DBID& dbid );
	};

RCECACHE RCECACHE::s_instance;


//  ================================================================
const char * RCECACHE::SzName() const
//  ================================================================
	{
	return "rcecache";
	}


//  ================================================================
const char * RCECACHE::SzDescription() const
//  ================================================================
	{
	return	"X5:35305. We Need to cache the bookmark we are searching for in ErrBTDown if we are at level 0\r\n"
			"Caching the RCE before-image in the bookmark buffer can give unexpected results when we use\r\n"
			"the bookmark afterwards. In addition RCE before images were being calculated incorrectly.\r\n"
			"The fix added a separate pvRCEBuffer to the FUCB, store the RCE before-image in it.";
	}


//  ================================================================
bool RCECACHE::FRunUnderESE98() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool RCECACHE::FRunUnderESENT() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool RCECACHE::FRunUnderESE97() const
//  ================================================================
	{
	return 1;
	}


static const char szMyTable[]		= "RCECACHE::table";

static JET_COLUMNCREATE	rgcolumncreate[] = {
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"long",							// name of column
	JET_coltypLong,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"long2",						// name of column
	JET_coltypLong,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
};

static const char szIndex1Name[]	= "primary-index";
static const char szIndex1Key[]		= "+long\0";

static const char szIndex2Name[]	= "secondary-index";
static const char szIndex2Key[]		= "+long2\0";

static JET_INDEXCREATE rgindexcreate[] = {
	{
	sizeof( JET_INDEXCREATE ),		// size of this structure (for future expansion)
	const_cast<char *>( szIndex1Name ),				// index name
	const_cast<char *>( szIndex1Key ),				// index key
	sizeof( szIndex1Key ),			// length of key
	JET_bitIndexPrimary,			// index options
	100,							// index density
	0,								// lcid for the index
	0,								// maximum length of variable length columns in index key
	NULL,							// pointer to conditional column structure
	0,								// number of conditional columns
	JET_errSuccess					// returned error code
	},
};

static JET_INDEXCREATE rgindexcreateSec[] = {
	{
	sizeof( JET_INDEXCREATE ),		// size of this structure (for future expansion)
	const_cast<char *>( szIndex2Name ),				// index name
	const_cast<char *>( szIndex2Key ),				// index key
	sizeof( szIndex2Key ),			// length of key
	JET_bitIndexUnique,				// index options
	100,							// index density
	0,								// lcid for the index
	0,								// maximum length of variable length columns in index key
	NULL,							// pointer to conditional column structure
	0,								// number of conditional columns
	JET_errSuccess					// returned error code
	},
};

static JET_TABLECREATE tablecreate = {
	sizeof( JET_TABLECREATE ),				// size of this structure
	const_cast<char *>( szMyTable ),			// name of table
	NULL,									// name of base table
	16,										// initial pages
	100,									// density
	rgcolumncreate,							// columns to create
	sizeof( rgcolumncreate ) / sizeof( JET_COLUMNCREATE ),	// number of columns to create
	rgindexcreate,							// array of index creation info
	sizeof( rgindexcreate ) / sizeof( JET_INDEXCREATE ),		// number of indexes to create
	0,										// grbit
	0,										// returned tableid
	0										// returned count of objects created
};

static long l;
static long l2;

static JET_SETCOLUMN rgsetcolumn[] = {
	{
	0,						//  columnid
	&l,						//  pvData
	sizeof( long ),			//  cbData
	0,						//  grbit
	0,						//  ibLongValue
	1,						//  itag sequence
	0						//  err
	},
	{
	0,						//  columnid
	&l2,					//  pvData
	sizeof( long ),			//  cbData
	0,						//  grbit
	0,						//  ibLongValue
	1,						//  itag sequence
	0						//  err
	},
};

//  ================================================================
JET_ERR RCECACHE::ErrTest(
	const JET_INSTANCE instance,
	const JET_SESID sesid,
	JET_DBID& dbid )
//  ================================================================
	{
	JET_ERR					err			= 0;
	JET_TABLEID 			tableid;
	JET_SESID				sesid2		= 0;
	JET_DBID				dbid2		= 0;
	JET_TABLEID 			tableid2;

	unsigned long cbActual;

	unsigned char rgbBookmark[512];
	unsigned long cbBookmark;

	Call( JetBeginTransaction( sesid ) );
	Call( JetCreateTableColumnIndex( sesid, dbid, &tablecreate ) );
	Call( JetCommitTransaction( sesid, 0 ) );
	Call( JetCloseTable( sesid, tablecreate.tableid ) );

	rgsetcolumn[0].columnid = tablecreate.rgcolumncreate[0].columnid;
	rgsetcolumn[1].columnid = tablecreate.rgcolumncreate[1].columnid;

	Call( JetOpenTable( sesid, dbid, szMyTable, NULL, 0, 0, &tableid ) );

	Call( JetBeginTransaction( sesid ) );
	Call( JetCreateIndex2(
			sesid,
			tableid,
			rgindexcreateSec,
			sizeof( rgindexcreateSec ) / sizeof( JET_INDEXCREATE ) ) );
	Call( JetCommitTransaction( sesid, 0 ) );

	// insert records
	l	= 1;
	l2	= 1;
	printf( "\t[1] Insert record %d/%d...\r\n", l, l2 );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Call( JetSetColumns( sesid, tableid, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

	l	= 2;
	l2	= 2;
	printf( "\t[1] Insert record %d/%d...\r\n", l, l2 );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Call( JetSetColumns( sesid, tableid, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

	l	= 3;
	l2	= 3;
	printf( "\t[1] Insert record %d/%d...\r\n", l, l2 );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Call( JetSetColumns( sesid, tableid, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

	l	= 4;
	l2	= 4;
	printf( "\t[1] Insert record %d/%d...\r\n", l, l2 );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Call( JetSetColumns( sesid, tableid, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

	l	= 5;
	l2	= 5;
	printf( "\t[1] Insert record %d/%d...\r\n", l, l2 );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Call( JetSetColumns( sesid, tableid, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

	l	= 6;
	l2	= 6;
	printf( "\t[1] Insert record %d/%d...\r\n", l, l2 );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Call( JetSetColumns( sesid, tableid, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

	l	= 7;
	l2	= 7;
	printf( "\t[1] Insert record %d/%d...\r\n", l, l2 );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Call( JetSetColumns( sesid, tableid, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

	l = 7;
	printf( "\t[1] Seek to record %d...\r\n", l );
	Call( JetMakeKey( sesid, tableid, &l, sizeof( l ), JET_bitNewKey ) );
	Call( JetSeek( sesid, tableid, JET_bitSeekEQ ) );

	printf( "\t[1] Get bookmark\r\n" );
	Call( JetGetBookmark( sesid, tableid, rgbBookmark, sizeof( rgbBookmark ), &cbBookmark ) );

	l	= 8;
	l2	= 8;
	printf( "\t[1] Insert record %d/%d...\r\n", l, l2 );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Call( JetSetColumns( sesid, tableid, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

	l	= 9;
	l2	= 9;
	printf( "\t[1] Insert record %d/%d...\r\n", l, l2 );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Call( JetSetColumns( sesid, tableid, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

	l	= 0;
	l2	= 0;
	printf( "\t[1] Insert record %d/%d...\r\n", l, l2 );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Call( JetSetColumns( sesid, tableid, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

	// replace 4 in another session to force a before image in the version store
	Call( JetBeginSession( instance, &sesid2, NULL, NULL ) );
	Call( JetOpenDatabase( sesid2, szDB, NULL, &dbid2, 0 ) );
	Call( JetOpenTable( sesid2, dbid2, szMyTable, NULL, 0, 0, &tableid2 ) );
	Call( JetSetCurrentIndex( sesid2, tableid2, szIndex2Name ) );
	Call( JetBeginTransaction( sesid2 ) );

	l = 4;
	printf( "\t[2] Seek to record %d...\r\n", l );
	Call( JetMakeKey( sesid2, tableid2, &l, sizeof( l ), JET_bitNewKey ) );
	Call( JetSeek( sesid2, tableid2, JET_bitSeekEQ ) );

	printf( "\t[2] Deleting record...\r\n" );
	Call( JetDelete( sesid2, tableid2 ) );

	l	= 99;
	l2	= 4;
	printf( "\t[2] Insert record %d/%d...\r\n", l, l2 );
	Call( JetPrepareUpdate( sesid2, tableid2, JET_prepInsert ) );
	Call( JetSetColumns( sesid2, tableid2, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid2, tableid2, NULL, 0, NULL ) );

	l = 7;
	printf( "\t[2] Seek to record %d...\r\n", l );;
	Call( JetMakeKey( sesid2, tableid2, &l, sizeof( l ), JET_bitNewKey ) );
	Call( JetSeek( sesid2, tableid2, JET_bitSeekEQ ) );

	l	= 7;
	l2	= 666;
	printf( "\t[2] Replacing record...\r\n" );
	Call( JetPrepareUpdate( sesid2, tableid2, JET_prepReplace ) );
	Call( JetSetColumns( sesid2, tableid2, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid2, tableid2, NULL, 0, NULL ) );

	//  make sure we see the correct before images
	Call( JetSetCurrentIndex( sesid, tableid, szIndex2Name ) );

	l = 3;
	printf( "\t[1] Seek to record %d...\r\n", l );
	Call( JetMakeKey( sesid, tableid, &l, sizeof( l ), JET_bitNewKey ) );
	Call( JetSeek( sesid, tableid, JET_bitSeekEQ ) );

	printf( "\t[1] Deleting record...\r\n" );
	Call( JetDelete( sesid, tableid ) );

	printf( "\t[1] Moving to the next record...\r\n" );
	Call( JetMove( sesid, tableid, JET_MoveNext, 0 ) );

	//  we should now be on record 4
	Call( JetRetrieveColumn(
		sesid,
		tableid,
		rgsetcolumn[0].columnid,
		&l,
		sizeof( l ),
		&cbActual,
		0,
		NULL ) );
	if( 4 != l )
		{
		printf( "\t[1] Expecting to be on record 4/4. Actually on record %d\r\n", l );
		return -1;
		}

	printf( "\t[1] Going to bookmark...\r\n" );
	Call( JetGotoBookmark( sesid, tableid, rgbBookmark, cbBookmark ) );

	printf( "\t[1] Moving to the last record...\r\n" );
	Call( JetMove( sesid, tableid, JET_MoveLast, 0 ) );

	Call( JetRetrieveColumn(
		sesid,
		tableid,
		rgsetcolumn[0].columnid,
		&l,
		sizeof( l ),
		&cbActual,
		0,
		NULL ) );
	if( 9 != l )
		{
		printf( "\t[1] Expecting to be on record 9/9. Actually on record %d\r\n", l );
		return -1;
		}

	// make sure we can't see this record, even if we do a flag insert and replace data
	l	= 1000;
	l2	= 1000;
	printf( "\t[2] Insert record %d/%d...\r\n", l, l2 );
	Call( JetPrepareUpdate( sesid2, tableid2, JET_prepInsert ) );
	Call( JetSetColumns( sesid2, tableid2, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid2, tableid2, NULL, 0, NULL ) );
	
	l = 1000;
	printf( "\t[2] Seek to record %d...\r\n", l );
	Call( JetMakeKey( sesid2, tableid2, &l, sizeof( l ), JET_bitNewKey ) );
	Call( JetSeek( sesid2, tableid2, JET_bitSeekEQ ) );

	printf( "\t[2] Deleting record...\r\n" );
	Call( JetDelete( sesid2, tableid2 ) );

	l	= 1001;
	l2	= 1000;
	printf( "\t[2] Insert record %d/%d...\r\n", l, l2 );
	Call( JetPrepareUpdate( sesid2, tableid2, JET_prepInsert ) );
	Call( JetSetColumns( sesid2, tableid2, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid2, tableid2, NULL, 0, NULL ) );

	printf( "\t[1] Move to next record\r\n" );
	err = JetMove( sesid, tableid, JET_MoveNext, 0 );
	if( JET_errNoCurrentRecord != err )
		{
		printf( "\tERROR: expected JET_errNoCurrentRecord. got %d\r\n", err );
		}

	Call( JetCommitTransaction( sesid2, 0 ) );

	Call( JetCloseTable( sesid2, tableid2 ) );
	Call( JetCloseTable( sesid, tableid ) );
	Call( JetEndSession( sesid2, NO_GRBIT ) );

HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\esetest\util.cxx ===
#include "unittest.hxx"

void ReportErr( long err, unsigned long ulLine, const char *szFileName )
	{
	printf( "error %d at line %d of %s \r\n", err, ulLine, szFileName );
	}

UNITTEST * UNITTEST::s_punittestHead;

UNITTEST::UNITTEST()
	{
	m_punittestNext = s_punittestHead;
	s_punittestHead = this;
	}

UNITTEST::~UNITTEST()
	{
	}


JET_ERR ErrDeleteAllRecords( const JET_SESID sesid, const JET_DBID dbid, const char * const szTable )
	{
	JET_ERR err = JET_errSuccess;
	long lMove	= JET_MoveFirst;
	JET_TABLEID tableid = 0;

	Call( JetOpenTable( sesid, dbid, szTable, NULL, 0, NO_GRBIT, &tableid ) );

	Call( JetBeginTransaction( sesid ) );
	while( JetMove( sesid, tableid, lMove, NO_GRBIT ) == JET_errSuccess )
		{
		Call( JetDelete( sesid, tableid ) );
		lMove = JET_MoveNext;
		}
	Call( JetCommitTransaction( sesid, JET_bitCommitLazyFlush ) );
	Call( JetCloseTable( sesid, tableid ) );

HandleError:
	return err;
	}

JET_ERR ErrGetColumnid(
			const JET_SESID sesid,
			const JET_TABLEID tableid,
			const char * const szColumn,
			JET_COLUMNID * const pcolumnid )
	{
	JET_ERR err = JET_errSuccess;
	JET_COLUMNDEF columndef;
	columndef.cbStruct = sizeof( columndef );

	err = JetGetTableColumnInfo( sesid, tableid, szColumn, &columndef, sizeof( columndef ), JET_ColInfo );
	*pcolumnid = columndef.columnid;
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\esetest\readonlytransaction.cxx ===
#include "unittest.hxx"

//  ================================================================
class READONLYTRANSACTION : public UNITTEST
//  ================================================================
	{
	private:
		static READONLYTRANSACTION s_instance;

	protected:
		READONLYTRANSACTION() {}

	public:
		~READONLYTRANSACTION() {}

	public:
		const char * SzName() const;
		const char * SzDescription() const;

		bool FRunUnderESE98() const;
		bool FRunUnderESENT() const;
		bool FRunUnderESE97() const;

		JET_ERR ErrTest(
				const JET_INSTANCE instance,
				const JET_SESID sesid,
				JET_DBID& dbid );
	};

READONLYTRANSACTION READONLYTRANSACTION::s_instance;


//  ================================================================
const char * READONLYTRANSACTION::SzName() const
//  ================================================================
	{
	return "readonlytransaction";
	}


//  ================================================================
const char * READONLYTRANSACTION::SzDescription() const
//  ================================================================
	{
	return "Tests JetBeginTransaction2 and JET_bitTransactionReadOnly";
	}


//  ================================================================
bool READONLYTRANSACTION::FRunUnderESE98() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool READONLYTRANSACTION::FRunUnderESENT() const
//  ================================================================
	{
	return 0;
	}


//  ================================================================
bool READONLYTRANSACTION::FRunUnderESE97() const
//  ================================================================
	{
	return 0;
	}


static long l;
static long l2;

static JET_SETCOLUMN rgsetcolumn[] = {
	{
	0,						//  columnid
	&l,						//  pvData
	sizeof( long ),			//  cbData
	0,						//  grbit
	0,						//  ibLongValue
	1,						//  itag sequence
	0						//  err
	},
	{
	0,						//  columnid
	&l2,					//  pvData
	sizeof( long ),			//  cbData
	0,						//  grbit
	0,						//  ibLongValue
	1,						//  itag sequence
	0						//  err
	},
};

//  ================================================================
JET_ERR READONLYTRANSACTION::ErrTest(
	const JET_INSTANCE instance,
	const JET_SESID sesid,
	JET_DBID& dbid )
//  ================================================================
	{
	JET_ERR					err			= 0;
	JET_TABLEID 			tableid;

	unsigned long cbActual;

	unsigned char rgbBookmark[512];
	unsigned long cbBookmark;

	Call( JetOpenTable( sesid, dbid, szTable, NULL, 0, 0, &tableid ) );

	Call( ErrGetColumnid( sesid, tableid, "long", &rgsetcolumn[0].columnid ) );
	Call( ErrGetColumnid( sesid, tableid, "long2", &rgsetcolumn[1].columnid ) );

	// insert records

	Call( JetBeginTransaction2( sesid, 0 ) );
	Call( JetBeginTransaction2( sesid, JET_bitTransactionReadOnly ) );

	l	= 1;
	l2	= 1;
	printf( "\t[1] Insert record %d/%d...\r\n", l, l2 );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Call( JetSetColumns( sesid, tableid, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

	l	= 2;
	l2	= 2;
	printf( "\t[1] Insert record %d/%d...\r\n", l, l2 );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Call( JetSetColumns( sesid, tableid, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

	Call( JetCommitTransaction( sesid, 0 ) );
	Call( JetCommitTransaction( sesid, 0 ) );

	//	read the table inside a read-only transaction

	Call( JetBeginTransaction2( sesid, JET_bitTransactionReadOnly ) );
	l = 1;
	printf( "\t[1] Seek to record %d...\r\n", l );
	Call( JetSetCurrentIndex( sesid, tableid, "long" ) );
	Call( JetMakeKey( sesid, tableid, &l, sizeof( l ), JET_bitNewKey ) );
	Call( JetSeek( sesid, tableid, JET_bitSeekEQ ) );

	printf( "\t[1] Get bookmark\n" );
	Call( JetGetBookmark( sesid, tableid, rgbBookmark, sizeof( rgbBookmark ), &cbBookmark ) );

	printf( "\t[1] Moving to the next record...\n" );
	Call( JetMove( sesid, tableid, JET_MoveNext, 0 ) );

	//  we should now be on record 2

	Call( JetRetrieveColumn(
		sesid,
		tableid,
		rgsetcolumn[0].columnid,
		&l,
		sizeof( l ),
		&cbActual,
		0,
		NULL ) );
	if( 2 != l )
		{
		printf( "\t[1] Expecting to be on record 2/2. Actually on record %d\r\n", l );
		return -1;
		}

	Call( JetCommitTransaction( sesid, 0 ) );

	//  make sure we can do this now we have left the RO xaction

	l	= 3;
	l2	= 3;
	printf( "\t[1] Insert record %d/%d...\r\n", l, l2 );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Call( JetSetColumns( sesid, tableid, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

	//	make sure we can't modify the database

	Call( JetBeginTransaction2( sesid, JET_bitTransactionReadOnly ) );
	Call( JetBeginTransaction2( sesid, 0 ) );

	printf( "\t[1] Moving to the first record...\n" );
	Call( JetMove( sesid, tableid, JET_MoveFirst, 0 ) );

	printf( "\t[1] Trying to delete the record...\n" );
	err = JetDelete( sesid, tableid );
	if( JET_errTransReadOnly != err )
		{
		printf( "Unexpected error. expected JET_errTransReadOnly, received: %d\r\n", err );
		}

	printf( "\t[1] Trying to insert a record...\n" );
	err = JetPrepareUpdate( sesid, tableid, JET_prepInsert );
	if( JET_errTransReadOnly != err )
		{
		printf( "Unexpected error. expected JET_errTransReadOnly, received: %d\r\n", err );
		}

	printf( "\t[1] Trying to replace a record...\n" );
	err = JetPrepareUpdate( sesid, tableid, JET_prepReplace );
	if( JET_errTransReadOnly != err )
		{
		printf( "Unexpected error. expected JET_errTransReadOnly, received: %d\r\n", err );
		}

	Call( JetRollback( sesid, 0 ) );
	Call( JetRollback( sesid, 0 ) );

	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	Call( JetBeginTransaction2( sesid, JET_bitTransactionReadOnly ) );
	printf( "\t[1] Trying to set a column...\n" );
	err = JetSetColumns( sesid, tableid, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( JET_SETCOLUMN ) );
	if( JET_errTransReadOnly != err )
		{
		printf( "Unexpected error. expected JET_errTransReadOnly, received: %d\r\n", err );
		}
	Call( JetCommitTransaction( sesid, 0 ) );

	Call( JetCloseTable( sesid, tableid ) );

HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\esetest\tagfld.cxx ===
#include "unittest.hxx"

//  ================================================================
class TAGFLD : public UNITTEST
//  ================================================================
	{
	private:
		static TAGFLD s_instance;

	protected:
		TAGFLD() {}

	public:
		~TAGFLD() {}

	public:
		const char * SzName() const;
		const char * SzDescription() const;

		bool FRunUnderESE98() const;
		bool FRunUnderESENT() const;
		bool FRunUnderESE97() const;

		JET_ERR ErrTest(
				const JET_INSTANCE instance,
				const JET_SESID sesid,
				JET_DBID& dbid );
	};

TAGFLD TAGFLD::s_instance;


//  ================================================================
const char * TAGFLD::SzName() const
//  ================================================================
	{
	return "tagfld";
	}


//  ================================================================
const char * TAGFLD::SzDescription() const
//  ================================================================
	{
	return	"test cases for SORTED_TAGGED_COLUMNS. Exercises the NULL,\r\n"
			"TWOVALUES and MULTIVALUES code.";
	}


//  ================================================================
bool TAGFLD::FRunUnderESE98() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool TAGFLD::FRunUnderESENT() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool TAGFLD::FRunUnderESE97() const
//  ================================================================
	{
	return 1;
	}


static const char szMyTable[]		= "TAGFLD::table";

static const char szDefault[]		= "default";
static const int cbDefault			= sizeof( szDefault );

static JET_COLUMNCREATE	rgcolumncreate[] = {
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"null-default",					// name of column
	JET_coltypText,					// type of column
	0,								// cbMax
	JET_bitColumnTagged,			// grbit
	const_cast<char *>( szDefault ),// pvDefault
	cbDefault,						// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"null",							// name of column
	JET_coltypText,					// type of column
	0,								// cbMax
	JET_bitColumnTagged,			// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"null-lv",							// name of column
	JET_coltypLongText,				// type of column
	0,								// cbMax
	JET_bitColumnTagged,			// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"null-lv-default",				// name of column
	JET_coltypLongText,				// type of column
	0,								// cbMax
	JET_bitColumnTagged,			// grbit
	const_cast<char *>( szDefault ),// pvDefault
	cbDefault,						// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"zero-length",					// name of column
	JET_coltypText,					// type of column
	0,								// cbMax
	JET_bitColumnTagged,			// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"normal",						// name of column
	JET_coltypText,					// type of column
	0,								// cbMax
	JET_bitColumnTagged,			// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"normal-intrinsic",				// name of column
	JET_coltypLongText,				// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"normal-separated",				// name of column
	JET_coltypLongText,				// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"twovalues",						// name of column
	JET_coltypText,					// type of column
	0,								// cbMax
	JET_bitColumnTagged,			// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"twovalues-intrinsic-intrinsic",// name of column
	JET_coltypLongText,				// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"twovalues-separated-intrinsic",// name of column
	JET_coltypLongText,				// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"twovalues-intrinsic-separated",// name of column
	JET_coltypLongText,				// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"twovalues-separated-separated",// name of column
	JET_coltypLongText,				// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"multivalues",					// name of column
	JET_coltypText,					// type of column
	0,								// cbMax
	JET_bitColumnTagged,			// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"multivalues-intrinsic",		// name of column
	JET_coltypText,					// type of column
	0,								// cbMax
	JET_bitColumnTagged,			// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"multivalues-separated",		// name of column
	JET_coltypLongText,				// type of column
	0,								// cbMax
	JET_bitColumnTagged,			// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"multivalues-mixed",			// name of column
	JET_coltypLongText,				// type of column
	0,								// cbMax
	JET_bitColumnTagged,			// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
};

static JET_TABLECREATE tablecreate = {
	sizeof( JET_TABLECREATE ),				// size of this structure
	const_cast<char *>( szMyTable ),			// name of table
	NULL,									// name of base table
	16,										// initial pages
	100,									// density
	rgcolumncreate,							// columns to create
	sizeof( rgcolumncreate ) / sizeof( JET_COLUMNCREATE ),	// number of columns to create
	NULL,									// array of index creation info
	0,										// number of indexes to create
	0,										// grbit
	0,										// returned tableid
	0										// returned count of objects created
};

static char rgbRetrieve[4096];
static char rgbBuf[4096];
static const int cbIntrinsic = 4;
static const int cbSeparated = sizeof( rgbBuf ) - 16;

//  ================================================================
static JET_ERR SetColumn(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	const void		*pvData,
	unsigned long	cbData,
	JET_GRBIT		grbit,
	const int		itagSequence,
	const int		itagSequenceExpected = 0 )
//  ================================================================
	{
	JET_ERR err = JET_errSuccess;

	JET_SETINFO setinfo;
	setinfo.cbStruct		= sizeof( setinfo );
	setinfo.ibLongValue		= 0;
	setinfo.itagSequence	= itagSequence;

	JET_RETINFO retinfo;
	retinfo.cbStruct			= sizeof( retinfo );
	retinfo.ibLongValue			= 0;
	retinfo.itagSequence		= ( 0 == itagSequenceExpected ) ? itagSequence : itagSequenceExpected;
	retinfo.columnidNextTagged	= 0;

	Call( JetSetColumn( sesid, tableid, columnid, pvData, cbData, grbit, &setinfo ) );

	//	if we are setting a multi-value to NULL we are changing the itags so we can't retrieve

	if( 0 != cbData || ( grbit & JET_bitSetZeroLength ) )
		{
		unsigned long cbActual;
		Call( JetRetrieveColumn( sesid, tableid, columnid, rgbRetrieve, sizeof( rgbRetrieve ), &cbActual, JET_bitRetrieveCopy, &retinfo ) );
		if( cbActual != cbData )
			{
			printf( "\tERROR: data size mismatch: expected %d bytes, got %d\r\n", cbData, cbActual );
			Call( -1 );
			}
		if( memcmp( rgbRetrieve, pvData, cbActual ) != 0 )
			{
			printf( "\tERROR: data mismatch\r\n" );
			Call( -1 );
			}
		if( JET_wrnColumnNull == err && ( grbit & JET_bitSetZeroLength ) )
			{
			printf( "\tERROR: got back NULL when using JET_bitSetZeroLength\r\n" );
			Call( -1 );
			}
		}

HandleError:
	return err;
	}


//  ================================================================
static JET_ERR CheckColumnForNULL(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid )
//  ================================================================
	{
	JET_ERR err = JET_errSuccess;

	JET_RETINFO retinfo;
	retinfo.cbStruct			= sizeof( retinfo );
	retinfo.ibLongValue			= 0;
	retinfo.itagSequence		= 1;
	retinfo.columnidNextTagged	= 0;

	unsigned long cbActual;
	err = JetRetrieveColumn( sesid, tableid, columnid, rgbRetrieve, sizeof( rgbRetrieve ), &cbActual, JET_bitRetrieveCopy, &retinfo );
	if( JET_wrnColumnNull != err )
		{
		printf( "\tERROR: column is not NULL\r\n" );
		Call( -1 );
		}
	else if( JET_wrnColumnNull == err )
		{
		err = JET_errSuccess;
		}
	else
		{
		Call( err );
		}
	
HandleError:
	return err;
	}


//  ================================================================
JET_ERR TAGFLD::ErrTest(
	const JET_INSTANCE instance,
	const JET_SESID sesid,
	JET_DBID& dbid )
//  ================================================================
	{
	JET_ERR					err			= 0;

	JET_TABLEID 			tableid;

	INT icolumn = 0;
	CHAR chFill = 'a';

	unsigned long cbActual;

	//  ================================================================
	//	init
	//  ================================================================

	Call( JetBeginTransaction( sesid ) );
	Call( JetCreateTableColumnIndex( sesid, dbid, &tablecreate ) );
	Call( JetCommitTransaction( sesid, 0 ) );
	Call( JetCloseTable( sesid, tablecreate.tableid ) );

	Call( JetOpenTable( sesid, dbid, szMyTable, NULL, 0, 0, &tableid ) );

	Call( JetBeginTransaction( sesid ) );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepInsert ) );

	//  ================================================================
	//	NULL with default value
	//  ================================================================

	printf( "\t%s (%d) (\'%c\')\r\n", rgcolumncreate[icolumn].szColumnName, rgcolumncreate[icolumn].columnid, chFill );
	memset( rgbBuf, chFill++, sizeof( rgbBuf ) );

	//	set the column to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	set the column to zero length and then to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, JET_bitSetZeroLength, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	set the column to non-NULL and then to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	create two values and then set them to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( JetRetrieveColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbRetrieve, sizeof( rgbRetrieve ), &cbActual, JET_bitRetrieveCopy, NULL ) );
	if( cbActual != cbIntrinsic )
		{
		printf( "\tDATA size mismatch: expected %d bytes, got %d\r\n", cbIntrinsic, cbActual );
		Call( -1 );
		}
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	create multiple values and set them to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic * 2, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic * 3, NO_GRBIT, 0, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic * 4, NO_GRBIT, 0, 3 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic * 5, NO_GRBIT, 0, 4 ) );

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 2 ) );

	Call( JetRetrieveColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbRetrieve, sizeof( rgbRetrieve ), &cbActual, JET_bitRetrieveCopy, NULL ) );
	if( cbActual != cbIntrinsic * 2 )
		{
		printf( "\tDATA size mismatch: expected %d bytes, got %d\r\n", cbIntrinsic, cbActual );
		Call( -1 );
		}
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	icolumn++;

	//  ================================================================
	//	NULL
	//  ================================================================

	printf( "\t%s (%d) (\'%c\')\r\n", rgcolumncreate[icolumn].szColumnName, rgcolumncreate[icolumn].columnid, chFill );
	memset( rgbBuf, chFill++, sizeof( rgbBuf ) );

	//	set the column to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	set the column to zero length and then to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, JET_bitSetZeroLength, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	set the column to non-NULL and then to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	create two values and then set them to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 0, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( JetRetrieveColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbRetrieve, sizeof( rgbRetrieve ), &cbActual, JET_bitRetrieveCopy, NULL ) );
	if( cbActual != cbIntrinsic )
		{
		printf( "\tDATA size mismatch: expected %d bytes, got %d\r\n", cbIntrinsic, cbActual );
		Call( -1 );
		}
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	create multiple values and set them to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic * 2, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic * 3, NO_GRBIT, 0, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic * 4, NO_GRBIT, 0, 3 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic * 5, NO_GRBIT, 0, 4 ) );

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 2 ) );

	Call( JetRetrieveColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbRetrieve, sizeof( rgbRetrieve ), &cbActual, JET_bitRetrieveCopy, NULL ) );
	if( cbActual != cbIntrinsic * 2 )
		{
		printf( "\tDATA size mismatch: expected %d bytes, got %d\r\n", cbIntrinsic, cbActual );
		Call( -1 );
		}
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	icolumn++;

	//  ================================================================
	//	NULL long-value
	//  ================================================================

	printf( "\t%s (%d) (\'%c\')\r\n", rgcolumncreate[icolumn].szColumnName, rgcolumncreate[icolumn].columnid, chFill );
	memset( rgbBuf, chFill++, sizeof( rgbBuf ) );

	//	set the column to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	set the column to zero length and then to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, JET_bitSetZeroLength, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	set the column to non-NULL and then to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	separate the column and then set to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	create two intrinsic values and then set them to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+1, NO_GRBIT, 0, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( JetRetrieveColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbRetrieve, sizeof( rgbRetrieve ), &cbActual, JET_bitRetrieveCopy, NULL ) );
	if( cbActual != cbIntrinsic+1 )
		{
		printf( "\tDATA size mismatch: expected %d bytes, got %d\r\n", cbIntrinsic+1, cbActual );
		Call( -1 );
		}
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	create two separated values and then set them to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic*4, JET_bitSetSeparateLV, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic*5, JET_bitSetSeparateLV, 0, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( JetRetrieveColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbRetrieve, sizeof( rgbRetrieve ), &cbActual, JET_bitRetrieveCopy, NULL ) );
	if( cbActual != cbIntrinsic*5 )
		{
		printf( "\tDATA size mismatch: expected %d bytes, got %d\r\n", cbIntrinsic*5, cbActual );
		Call( -1 );
		}
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	create multiple values and set them to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic * 2, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic * 3, NO_GRBIT, 0, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic * 4, NO_GRBIT, 0, 3 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic * 5, NO_GRBIT, 0, 4 ) );

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 2 ) );

	Call( JetRetrieveColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbRetrieve, sizeof( rgbRetrieve ), &cbActual, JET_bitRetrieveCopy, NULL ) );
	if( cbActual != cbIntrinsic * 2 )
		{
		printf( "\tDATA size mismatch: expected %d bytes, got %d\r\n", cbIntrinsic, cbActual );
		Call( -1 );
		}
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	icolumn++;

	//  ================================================================
	//	NULL long-value with default value
	//  ================================================================

	printf( "\t%s (%d) (\'%c\')\r\n", rgcolumncreate[icolumn].szColumnName, rgcolumncreate[icolumn].columnid, chFill );
	memset( rgbBuf, chFill++, sizeof( rgbBuf ) );

	//	set the column to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	set the column to zero length and then to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, JET_bitSetZeroLength, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	set the column to non-NULL and then to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	separate the column and then set to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	create two values and then set them to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 0, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( JetRetrieveColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbRetrieve, sizeof( rgbRetrieve ), &cbActual, JET_bitRetrieveCopy, NULL ) );
	if( cbActual != cbIntrinsic )
		{
		printf( "\tDATA size mismatch: expected %d bytes, got %d\r\n", cbIntrinsic, cbActual );
		Call( -1 );
		}
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	//	create multiple values and set them to NULL

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic * 2, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic * 3, NO_GRBIT, 0, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic * 4, NO_GRBIT, 0, 3 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic * 5, NO_GRBIT, 0, 4 ) );

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 2 ) );

	Call( JetRetrieveColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbRetrieve, sizeof( rgbRetrieve ), &cbActual, JET_bitRetrieveCopy, NULL ) );
	if( cbActual != cbIntrinsic * 2 )
		{
		printf( "\tDATA size mismatch: expected %d bytes, got %d\r\n", cbIntrinsic, cbActual );
		Call( -1 );
		}
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, NO_GRBIT, 1 ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );

	icolumn++;

	//  ================================================================
	//	zero-length
	//  ================================================================

	printf( "\t%s (%d) (\'%c\')\r\n", rgcolumncreate[icolumn].szColumnName, rgcolumncreate[icolumn].columnid, chFill );
	memset( rgbBuf, chFill++, sizeof( rgbBuf ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, JET_bitSetZeroLength, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, JET_bitSetZeroLength, 1 ) );
	icolumn++;

	//  ================================================================
	//	normal tagged column
	//  ================================================================

	printf( "\t%s (%d) (\'%c\')\r\n", rgcolumncreate[icolumn].szColumnName, rgcolumncreate[icolumn].columnid, chFill );
	memset( rgbBuf, chFill++, sizeof( rgbBuf ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic*2, NO_GRBIT, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 1 ) );
	icolumn++;

	//  ================================================================
	//	normal intrinsic lv
	//  ================================================================

	printf( "\t%s (%d) (\'%c\')\r\n", rgcolumncreate[icolumn].szColumnName, rgcolumncreate[icolumn].columnid, chFill );
	memset( rgbBuf, chFill++, sizeof( rgbBuf ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic*2, NO_GRBIT, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 1 ) );
	icolumn++;

	//  ================================================================
	//	normal separated lv
	//  ================================================================

	printf( "\t%s (%d) (\'%c\')\r\n", rgcolumncreate[icolumn].szColumnName, rgcolumncreate[icolumn].columnid, chFill );
	memset( rgbBuf, chFill++, sizeof( rgbBuf ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated, NO_GRBIT, 0, 1 ) );
	icolumn++;

	//  ================================================================
	//	two tagged columns
	//  ================================================================

	printf( "\t%s (%d) (\'%c\')\r\n", rgcolumncreate[icolumn].szColumnName, rgcolumncreate[icolumn].columnid, chFill );
	memset( rgbBuf, chFill++, sizeof( rgbBuf ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+1, NO_GRBIT, 0, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic*2, NO_GRBIT, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic*2, NO_GRBIT, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 1 ) );
	icolumn++;

	//  ================================================================
	//	two intrinsic lvs
	//  ================================================================

	printf( "\t%s (%d) (\'%c\')\r\n", rgcolumncreate[icolumn].szColumnName, rgcolumncreate[icolumn].columnid, chFill );
	memset( rgbBuf, chFill++, sizeof( rgbBuf ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+1, NO_GRBIT, 0, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic*2, NO_GRBIT, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic*2, NO_GRBIT, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 2 ) );
	icolumn++;

	//  ================================================================
	//	one separated, one intrinsic lv
	//  ================================================================

	printf( "\t%s (%d) (\'%c\')\r\n", rgcolumncreate[icolumn].szColumnName, rgcolumncreate[icolumn].columnid, chFill );
	memset( rgbBuf, chFill++, sizeof( rgbBuf ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 0, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic*2, NO_GRBIT, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic*4, NO_GRBIT, 2 ) );
	icolumn++;

	//  ================================================================
	//	one intrinsic, one separated lv
	//  ================================================================

	printf( "\t%s (%d) (\'%c\')\r\n", rgcolumncreate[icolumn].szColumnName, rgcolumncreate[icolumn].columnid, chFill );
	memset( rgbBuf, chFill++, sizeof( rgbBuf ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated, NO_GRBIT, 0, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic*4, NO_GRBIT, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic, NO_GRBIT, 1 ) );
	icolumn++;

	//  ================================================================
	//	two separated lvs
	//  ================================================================

	printf( "\t%s (%d) (\'%c\')\r\n", rgcolumncreate[icolumn].szColumnName, rgcolumncreate[icolumn].columnid, chFill );
	memset( rgbBuf, chFill++, sizeof( rgbBuf ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated+1, NO_GRBIT, 0, 2 ) );
	icolumn++;

	//  ================================================================
	//	several tagged columns
	//  ================================================================

	printf( "\t%s (%d) (\'%c\')\r\n", rgcolumncreate[icolumn].szColumnName, rgcolumncreate[icolumn].columnid, chFill );
	memset( rgbBuf, chFill++, sizeof( rgbBuf ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+1, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+2, NO_GRBIT, 0, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, JET_bitSetZeroLength, 0, 3 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+3, NO_GRBIT, 0, 4 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+4, NO_GRBIT, 0, 5 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+5, NO_GRBIT, 0, 6 ) );
	icolumn++;

	//  ================================================================
	//	several intrinsic lvs
	//  ================================================================

	printf( "\t%s (%d) (\'%c\')\r\n", rgcolumncreate[icolumn].szColumnName, rgcolumncreate[icolumn].columnid, chFill );
	memset( rgbBuf, chFill++, sizeof( rgbBuf ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+6, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+5, NO_GRBIT, 0, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+4, NO_GRBIT, 0, 3 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, JET_bitSetZeroLength, 0, 4 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+7, NO_GRBIT, 0, 5 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+9, NO_GRBIT, 0, 6 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+8, NO_GRBIT, 0, 7 ) );
	icolumn++;

	//  ================================================================
	//	several separated lvs
	//  ================================================================

	printf( "\t%s (%d) (\'%c\')\r\n", rgcolumncreate[icolumn].szColumnName, rgcolumncreate[icolumn].columnid, chFill );
	memset( rgbBuf, chFill++, sizeof( rgbBuf ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic*2, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic*3, NO_GRBIT, 0, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic*4, NO_GRBIT, 0, 3 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic*5, NO_GRBIT, 0, 4 ) );

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated-1, NO_GRBIT, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated-2, NO_GRBIT, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated+1, NO_GRBIT, 3 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated+2, NO_GRBIT, 4 ) );

	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated+0, NO_GRBIT, 0, 5 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated+1, NO_GRBIT, 0, 6 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated+2, NO_GRBIT, 0, 7 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated+3, NO_GRBIT, 0, 8 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated+4, NO_GRBIT, 0, 9 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated+5, NO_GRBIT, 0, 10 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated+6, NO_GRBIT, 0, 11 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated+7, NO_GRBIT, 0, 12 ) );
	icolumn++;

	//  ================================================================
	//	several mixed lvs
	//  ================================================================

	printf( "\t%s (%d) (\'%c\')\r\n", rgcolumncreate[icolumn].szColumnName, rgcolumncreate[icolumn].columnid, chFill );
	memset( rgbBuf, chFill++, sizeof( rgbBuf ) );
	Call( CheckColumnForNULL( sesid, tableid, rgcolumncreate[icolumn].columnid ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated+0, NO_GRBIT, 0, 1 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+0, NO_GRBIT, 0, 2 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, JET_bitSetZeroLength, 0, 3 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated+1, NO_GRBIT, 0, 4 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+1, NO_GRBIT, 0, 5 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated+2, NO_GRBIT, 0, 6 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+2, NO_GRBIT, 0, 7 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+3, NO_GRBIT, 0, 8 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated+3, NO_GRBIT, 0, 9 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated+4, NO_GRBIT, 0, 10 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, NULL, 0, JET_bitSetZeroLength, 0, 11 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbSeparated+5, NO_GRBIT, 0, 12 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+6, NO_GRBIT, 0, 13 ) );
	Call( SetColumn( sesid, tableid, rgcolumncreate[icolumn].columnid, rgbBuf, cbIntrinsic+7, NO_GRBIT, 0, 14 ) );
	icolumn++;

	//  ================================================================
	//	create the record
	//  ================================================================

	Call( JetUpdate2( sesid, tableid, NULL, 0, NULL, JET_bitUpdateCheckESE97Compatibility ) );
	Call( JetCommitTransaction( sesid, 0 ) );

	//  ================================================================
	//	JetRetrieveTaggedColumnList
	//  ================================================================

	Call( JetBeginTransaction( sesid ) );
	printf( "\tJetRetrieveTaggedColumnList\r\n" );
	Call( JetMove( sesid, tableid, JET_MoveFirst, NO_GRBIT ) );
	unsigned long cColumns;
	Call( JetRetrieveTaggedColumnList(
			sesid,
			tableid,
			&cColumns,
			rgbRetrieve,
			sizeof( rgbRetrieve ),
			rgcolumncreate[0].columnid,
			NO_GRBIT ) );
	Call( JetCommitTransaction( sesid, 0 ) );

	Call( JetCloseTable( sesid, tableid ) );

HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\esetest\renametablecolumn.cxx ===
#include "unittest.hxx"

//  ================================================================
class RENAMETABLECOLUMN : public UNITTEST
//  ================================================================
	{
	private:
		static RENAMETABLECOLUMN s_instance;

	protected:
		RENAMETABLECOLUMN() {}

	public:
		~RENAMETABLECOLUMN() {}

	public:
		const char * SzName() const;
		const char * SzDescription() const;

		bool FRunUnderESE98() const;
		bool FRunUnderESENT() const;
		bool FRunUnderESE97() const;

		JET_ERR ErrTest(
				const JET_INSTANCE instance,
				const JET_SESID sesid,
				JET_DBID& dbid );
	};

RENAMETABLECOLUMN RENAMETABLECOLUMN::s_instance;


//  ================================================================
const char * RENAMETABLECOLUMN::SzName() const
//  ================================================================
	{
	return "renametablecolumn";
	}


//  ================================================================
const char * RENAMETABLECOLUMN::SzDescription() const
//  ================================================================
	{
	return	"Tests JetRenameTable() and JetRenameColumn() APIs";
	}


//  ================================================================
bool RENAMETABLECOLUMN::FRunUnderESE98() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool RENAMETABLECOLUMN::FRunUnderESENT() const
//  ================================================================
	{
	return 1;
	}


//  ================================================================
bool RENAMETABLECOLUMN::FRunUnderESE97() const
//  ================================================================
	{
	return 1;
	}

static const char szTable1[]		= "RENAMETABLECOLUMN::table1";
static const char szTable2[]		= "RENAMETABLECOLUMN::table2";
static const char szTable3[]		= "RENAMETABLECOLUMN::table3";
static const char szTable4[]		= "RENAMETABLECOLUMN::table4";
static const char szTable5[]		= "RENAMETABLECOLUMN::table5";
static const char szTable6[]		= "RENAMETABLECOLUMN::table6";

static const char szTable1New[]	= "RENAMETABLECOLUMN::foo";
static const char szTable2New[]	= "RENAMETABLECOLUMN::bar";
static const char szTable3New[]	= "RENAMETABLECOLUMN::baz";
//  test the longest name allowable -- JET_cbNameMost(64)
static const char szTable4New[]	=	"0123456789"
								"0123456789"
								"0123456789"
								"0123456789"
								"0123456789"
								"0123456789"
								"1234";
static const char szTable5New[]	=	"RENAMETABLECOLUMN::fail";
static const char szTable6New[]	=	"RENAMETABLECOLUMN::D";

//  six columns. column 6 is in the template table

static const char szColumn1[]		= "column1";
static const char szColumn2[]		= "column2";
static const char szColumn3[]		= "column3";
static const char szColumn4[]		= "column4";
static const char szColumn5[]		= "column5";
static const char szColumn6[]		= "column6";
static const char szColumn7[]		= "column7";

static const char szColumn1New[]	= "foo";
static const char szColumn2New[]	= "bar";
static const char szColumn3New[]	= "baz";
//  test the longest name allowable -- JET_cbNameMost(64)
static const char szColumn4New[]	=	"0123456789"
								"0123456789"
								"0123456789"
								"0123456789"
								"0123456789"
								"0123456789"
								"1234";
static const char szColumn5New[]	=	"new";
static const char szColumn6New[]	=	"D";
static const char szColumn7New[]	=	"removed";

static JET_COLUMNCREATE	rgcolumncreateTemplate[] = {
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	const_cast<char *>( szColumn7 ),// name of column
	JET_coltypBit,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"long_T",						// name of column
	JET_coltypLong,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"lv_T",							// name of column
	JET_coltypLongBinary,			// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	const_cast<char *>( szColumn6 ),// name of column
	JET_coltypText,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
};


static JET_COLUMNCREATE	rgcolumncreate[] = {
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"long",							// name of column
	JET_coltypLong,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	"lv",							// name of column
	JET_coltypLongBinary,			// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	const_cast<char *>( szColumn1 ),// name of column
	JET_coltypText,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	const_cast<char *>( szColumn2 ),// name of column
	JET_coltypLongText,				// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	const_cast<char *>( szColumn3 ),// name of column
	JET_coltypBinary,				// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	const_cast<char *>( szColumn4 ),// name of column
	JET_coltypLongBinary,			// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
	{
	sizeof( JET_COLUMNCREATE ),		// size of structure
	const_cast<char *>( szColumn5 ),// name of column
	JET_coltypLong,					// type of column
	0,								// cbMax
	0,								// grbit
	NULL,							// pvDefault
	0,								// cbDefault
	0,								// code page
	0,								// returned columnid
	JET_errSuccess					// returned err	
	},
};

static const char szIndex1Name[]	= "primary-index";
static const char szIndex1Key[]		= "+long\0";

static const char szIndex2Name[]	= "secondary-index";
static const char szIndex2Key[]		= "+long\0+lv\0+column1\0";

static const char szTemplateIndex1Name[]	= "primary-index";
static const char szTemplateIndex1Key[]		= "+column7\0+long_T\0";

static JET_INDEXCREATE rgindexcreate[] = {
	{
	sizeof( JET_INDEXCREATE ),		// size of this structure (for future expansion)
	const_cast<char *>( szIndex1Name ),				// index name
	const_cast<char *>( szIndex1Key ),				// index key
	sizeof( szIndex1Key ),			// length of key
	0,								// index options
	100,							// index density
	0,								// lcid for the index
	0,								// maximum length of variable length columns in index key
	NULL,							// pointer to conditional column structure
	0,								// number of conditional columns
	JET_errSuccess					// returned error code
	},
	{
	sizeof( JET_INDEXCREATE ),		// size of this structure (for future expansion)
	const_cast<char *>( szIndex2Name ),				// index name
	const_cast<char *>( szIndex2Key ),				// index key
	sizeof( szIndex2Key ),			// length of key
	0,								// index options
	100,							// index density
	0,								// lcid for the index
	0,								// maximum length of variable length columns in index key
	NULL,							// pointer to conditional column structure
	0,								// number of conditional columns
	JET_errSuccess					// returned error code
	},
};


static JET_INDEXCREATE rgindexcreateTemplate[] = {
	{
	sizeof( JET_INDEXCREATE ),		// size of this structure (for future expansion)
	const_cast<char *>( szTemplateIndex1Name ),				// index name
	const_cast<char *>( szTemplateIndex1Key ),				// index key
	sizeof( szTemplateIndex1Key ),	// length of key
	JET_bitIndexPrimary,			// index options
	100,							// index density
	0,								// lcid for the index
	0,								// maximum length of variable length columns in index key
	NULL,							// pointer to conditional column structure
	0,								// number of conditional columns
	JET_errSuccess					// returned error code
	},
};


//  Six tables. Tables 1 and 3 have indexes. 2 and 4 do not. Table 5 is a template table
//  Table 6 is derived from table 5

static JET_TABLECREATE tablecreate1 = {
	sizeof( JET_TABLECREATE ),				// size of this structure
	const_cast<char *>( szTable1 ),			// name of table
	NULL,									// name of base table
	16,										// initial pages
	100,									// density
	rgcolumncreate,							// columns to create
	sizeof( rgcolumncreate ) / sizeof( JET_COLUMNCREATE ),	// number of columns to create
	rgindexcreate,							// array of index creation info
	sizeof( rgindexcreate ) / sizeof( JET_INDEXCREATE ),		// number of indexes to create
	0,										// grbit
	0,										// returned tableid
	0										// returned count of objects created
};
static JET_TABLECREATE tablecreate2 = {
	sizeof( JET_TABLECREATE ),				// size of this structure
	const_cast<char *>( szTable2 ),			// name of table
	NULL,									// name of base table
	16,										// initial pages
	100,									// density
	rgcolumncreate,							// columns to create
	sizeof( rgcolumncreate ) / sizeof( JET_COLUMNCREATE ),	// number of columns to create
	NULL,									// array of index creation info
	0,										// number of indexes to create
	0,										// grbit
	0,										// returned tableid
	0										// returned count of objects created
};
static JET_TABLECREATE tablecreate3 = {
	sizeof( JET_TABLECREATE ),				// size of this structure
	const_cast<char *>( szTable3 ),			// name of table
	NULL,									// name of base table
	16,										// initial pages
	100,									// density
	rgcolumncreate,							// columns to create
	sizeof( rgcolumncreate ) / sizeof( JET_COLUMNCREATE ),	// number of columns to create
	rgindexcreate,							// array of index creation info
	sizeof( rgindexcreate ) / sizeof( JET_INDEXCREATE ),		// number of indexes to create
	0,										// grbit
	0,										// returned tableid
	0										// returned count of objects created
};
static JET_TABLECREATE tablecreate4 = {
	sizeof( JET_TABLECREATE ),				// size of this structure
	const_cast<char *>( szTable4 ),			// name of table
	NULL,									// name of base table
	16,										// initial pages
	100,									// density
	rgcolumncreate,							// columns to create
	sizeof( rgcolumncreate ) / sizeof( JET_COLUMNCREATE ),	// number of columns to create
	NULL,									// array of index creation info
	0,										// number of indexes to create
	0,										// grbit
	0,										// returned tableid
	0										// returned count of objects created
};
static JET_TABLECREATE tablecreate5 = {
	sizeof( JET_TABLECREATE ),				// size of this structure
	const_cast<char *>( szTable5 ),			// name of table
	NULL,									// name of base table
	16,										// initial pages
	100,									// density
	rgcolumncreateTemplate,					// columns to create
	sizeof( rgcolumncreateTemplate ) / sizeof( JET_COLUMNCREATE ),	// number of columns to create
	rgindexcreateTemplate,					// array of index creation info
	sizeof( rgindexcreateTemplate ) / sizeof( JET_INDEXCREATE ),		// number of indexes to create
	JET_bitTableCreateTemplateTable,		// grbit
	0,										// returned tableid
	0										// returned count of objects created
};
static JET_TABLECREATE tablecreate6 = {
	sizeof( JET_TABLECREATE ),				// size of this structure
	const_cast<char *>( szTable6 ),			// name of table
	const_cast<char *>( szTable5 ),			// name of base table
	16,										// initial pages
	100,									// density
	rgcolumncreate,							// columns to create
	sizeof( rgcolumncreate ) / sizeof( JET_COLUMNCREATE ),	// number of columns to create
	NULL,									// array of index creation info
	0,										// number of indexes to create
	0,										// grbit
	0,										// returned tableid
	0										// returned count of objects created
};


//  ================================================================
static JET_ERR ErrCheckOpenAllOldTables( JET_SESID sesid, JET_DBID dbid )
//  ================================================================
//
//  Make sure we can't open any of the old tables
//
//-
	{
	JET_ERR err;
	JET_TABLEID tableid;

	//  Make sure we can't open the old tables
	err = JetOpenTable( sesid, dbid, szTable1, NULL, 0, 0, &tableid );
	if( JET_errSuccess == err )
		{
		printf( "ERROR:  still able to open table %s at line %d of %d\n",
				szTable1, __LINE__, __FILE__ );
		Call( JET_errDatabaseCorrupted );
		}
	err = JetOpenTable( sesid, dbid, szTable2, NULL, 0, 0, &tableid );
	if( JET_errSuccess == err )
		{
		printf( "ERROR:  still able to open table %s at line %d of %d\n",
				szTable2, __LINE__, __FILE__ );		
		Call( JET_errDatabaseCorrupted );
		}
	err = JetOpenTable( sesid, dbid, szTable3, NULL, 0, 0, &tableid );
	if( JET_errSuccess == err )
		{
		printf( "ERROR:  still able to open table %s at line %d of %d\n",
				szTable3, __LINE__, __FILE__ );		
		Call( JET_errDatabaseCorrupted );
		}
	err = JetOpenTable( sesid, dbid, szTable4, NULL, 0, 0, &tableid );
	if( JET_errSuccess == err )
		{
		printf( "ERROR:  still able to open table %s at line %d of %d\n",
				szTable4, __LINE__, __FILE__ );		
		Call( JET_errDatabaseCorrupted );
		}
	err = JetOpenTable( sesid, dbid, szTable6, NULL, 0, 0, &tableid );
	if( JET_errSuccess == err )
		{
		printf( "ERROR:  still able to open table %s at line %d of %d\n",
				szTable6, __LINE__, __FILE__ );		
		Call( JET_errDatabaseCorrupted );
		}


	err = JET_errSuccess;

HandleError:
	return err;
	}


//  ================================================================
static JET_ERR ErrOpenAllNewTables( JET_SESID sesid, JET_DBID dbid )
//  ================================================================
//
//  Make sure we can open all the new tables
//
//-
	{
	JET_ERR err;
	JET_TABLEID tableid;
	char szName[JET_cbNameMost+1];

	//  Table 1

	Call( JetOpenTable( sesid, dbid, szTable1New, NULL, 0, 0, &tableid ) );	
	Call( JetGetTableInfo( sesid, tableid, szName, sizeof( szName ), JET_TblInfoName ) );
	if( 0 != _stricmp( szName, szTable1New ) )
		{
		printf( "ERROR:  JetGetTableInfo returns %s at line %d of %s\n",
				szName, __LINE__, __FILE__ );
		Call( JET_errDatabaseCorrupted );
		}
	Call( JetCloseTable( sesid, tableid ) );

	//	Table 2

	Call( JetOpenTable( sesid, dbid, szTable2New, NULL, 0, 0, &tableid ) );
	Call( JetGetTableInfo( sesid, tableid, szName, sizeof( szName ), JET_TblInfoName ) );
	if( 0 != _stricmp( szName, szTable2New ) )
		{
		printf( "ERROR:  JetGetTableInfo returns %s at line %d of %s\n",
				szName, __LINE__, __FILE__ );
		Call( JET_errDatabaseCorrupted );
		}
	Call( JetCloseTable( sesid, tableid ) );

	//	Table 3

	Call( JetOpenTable( sesid, dbid, szTable3New, NULL, 0, 0, &tableid ) );
	Call( JetGetTableInfo( sesid, tableid, szName, sizeof( szName ), JET_TblInfoName ) );
	if( 0 != _stricmp( szName, szTable3New ) )
		{
		printf( "ERROR:  JetGetTableInfo returns %s at line %d of %s\n",
				szName, __LINE__, __FILE__ );
		Call( JET_errDatabaseCorrupted );
		}
	Call( JetCloseTable( sesid, tableid ) );

	//	Table 4

	Call( JetOpenTable( sesid, dbid, szTable4New, NULL, 0, 0, &tableid ) );
	Call( JetGetTableInfo( sesid, tableid, szName, sizeof( szName ), JET_TblInfoName ) );
	if( 0 != _stricmp( szName, szTable4New ) )
		{
		printf( "ERROR:  JetGetTableInfo returns %s at line %d of %s\n",
				szName, __LINE__, __FILE__ );
		Call( JET_errDatabaseCorrupted );
		}
	Call( JetCloseTable( sesid, tableid ) );

	//  Table 5 cannot be renamed

	Call( JetOpenTable( sesid, dbid, szTable5, NULL, 0, 0, &tableid ) );
	Call( JetGetTableInfo( sesid, tableid, szName, sizeof( szName ), JET_TblInfoName ) );
	if( 0 != _stricmp( szName, szTable5 ) )
		{
		printf( "ERROR:  JetGetTableInfo returns %s at line %d of %s\n",
				szName, __LINE__, __FILE__ );
		Call( JET_errDatabaseCorrupted );
		}
	Call( JetCloseTable( sesid, tableid ) );

	//  Table 6

	Call( JetOpenTable( sesid, dbid, szTable5, NULL, 0, 0, &tableid ) );
	Call( JetGetTableInfo( sesid, tableid, szName, sizeof( szName ), JET_TblInfoName ) );
	if( 0 != _stricmp( szName, szTable5 ) )
		{
		printf( "ERROR:  JetGetTableInfo returns %s at line %d of %s\n",
				szName, __LINE__, __FILE__ );
		Call( JET_errDatabaseCorrupted );
		}
	Call( JetCloseTable( sesid, tableid ) );

HandleError:
	return err;
	}


//  ================================================================
static JET_ERR ErrTestRenameTableErrorCases( const JET_SESID sesid, const JET_DBID dbid )
//  ================================================================
	{
	JET_ERR err;

	//  Invalid destination table

	printf( "\t  renaming to NULL (expecting failure)\n" );
	err = JetRenameTable( sesid, dbid, szTable1, NULL );
	if( JET_errSuccess == err )
		{
		printf( "ERROR:  unexpected success at line %d of %s\n",
				__LINE__, __FILE__ );
		Call( JET_errDatabaseCorrupted );
		}

	//  Invalid source table

	printf( "\t  renaming NULL table (expecting failure)\n" );
	err = JetRenameTable( sesid, dbid, NULL, szTable1New );
	if( JET_errSuccess == err )
		{
		printf( "ERROR:  unexpected success at line %d of %s\n",
				__LINE__, __FILE__ );
		Call( JET_errDatabaseCorrupted );
		}

	//  Source table does not exist

	printf( "\t  renaming a non-existant table (expecting failure)\n" );
	err = JetRenameTable( sesid, dbid, szTable1New, szTable1New );
	if( JET_errSuccess == err )
		{
		printf( "ERROR:  unexpected success at line %d of %s\n",
				__LINE__, __FILE__ );
		Call( JET_errDatabaseCorrupted );
		}

	//  Try to rename a template table

	printf( "\t  renaming a template table (expecting failure)\n" );
	err = JetRenameTable( sesid, dbid, szTable5, szTable5New );
	if( JET_errSuccess == err )
		{
		printf( "ERROR:  unexpected success at line %d of %s\n",
				__LINE__, __FILE__ );
		Call( JET_errDatabaseCorrupted );
		}

	//  Rename a table to a table that already exists

	printf( "\t  renaming %s to %s (expecting failure)\n",
			szTable1, szTable2 );
	err = JetRenameTable( sesid, dbid, szTable1, szTable2 );
	if( JET_errSuccess == err )
		{
		printf( "ERROR:  unexpected success at line %d of %s\n",
				__LINE__, __FILE__ );
		Call( JET_errDatabaseCorrupted );
		}

	err = JET_errSuccess;

HandleError:
	return err;
	}


//  ================================================================
static JET_ERR ErrCloseAndOpenDB( const JET_SESID sesid, JET_DBID * const pdbid )
//  ================================================================
	{
	JET_ERR err;

	//  Close, Detach, Attach and Open

	Call( JetCloseDatabase( sesid, *pdbid, 0 ) );
	Call( JetDetachDatabase( sesid, szDB ) );
	Call( JetAttachDatabase( sesid, szDB, 0 ) );
	Call( JetOpenDatabase( sesid, szDB, NULL, pdbid, 0 ) );

HandleError:
	return err;
	}


//  ================================================================
static JET_ERR ErrTestRenameTable( const JET_SESID sesid, JET_DBID * const pdbid )
//  ================================================================
	{
	JET_ERR err;
	JET_TABLEID tableid;

	//  Error handling cases

	printf( "\t Error Handling\n" );
	Call( ErrTestRenameTableErrorCases( sesid, *pdbid ) );	

	//  Ordinary Cases

	printf( "\t Rename\n" );

	//  Rename with the table closed (Table 1)

	printf( "\t  renaming %s to %s\n",
			szTable1, szTable1New );
	Call( JetRenameTable( sesid, *pdbid, szTable1, szTable1New ) );

	//  Open the table and then close it to force the FCB into memory (Table 2)

	Call( JetOpenTable( sesid, *pdbid, szTable2, NULL, 0, 0, &tableid ) );
	Call( JetCloseTable( sesid, tableid ) );
	printf( "\t  renaming %s to %s\n",
			szTable2, szTable2New );
	Call( JetRenameTable( sesid, *pdbid, szTable2, szTable2New ) );

	//  Open the table and keep it open for the rename (Table 3)

	Call( JetOpenTable( sesid, *pdbid, szTable3, NULL, 0, 0, &tableid ) );
	printf( "\t  renaming %s to %s\n",
			szTable3, szTable3New );
	Call( JetRenameTable( sesid, *pdbid, szTable3, szTable3New ) );
	Call( JetCloseTable( sesid, tableid ) );

	//  Open, Close, Open again (Table 4)

	Call( JetOpenTable( sesid, *pdbid, szTable4, NULL, 0, 0, &tableid ) );
	Call( JetCloseTable( sesid, tableid ) );
	Call( JetOpenTable( sesid, *pdbid, szTable4, NULL, 0, 0, &tableid ) );
	printf( "\t  renaming %s to %s\n",
			szTable4, szTable4New );
	Call( JetRenameTable( sesid, *pdbid, szTable4, szTable4New ) );
	Call( JetCloseTable( sesid, tableid ) );

	//  Rename with the table closed (Table 6)

	printf( "\t  renaming %s to %s\n",
			szTable6, szTable6New );
	Call( JetRenameTable( sesid, *pdbid, szTable6, szTable6New ) );

	//  Open the tables

	printf( "\t Opening tables\n" );
	Call( ErrCheckOpenAllOldTables( sesid, *pdbid ) );
	Call( ErrOpenAllNewTables( sesid, *pdbid ) );

	//  Rename a table to itself

	printf( "\t  renaming %s to %s\n",
			szTable2New, szTable2New );
	Call( JetRenameTable( sesid, *pdbid, szTable2New, szTable2New ) );

	//  Rename a table multiple times

	printf( "\t  renaming a table multiple times\n" );
	Call( JetRenameTable( sesid, *pdbid, szTable3New, szTable3 ) );
	Call( JetRenameTable( sesid, *pdbid, szTable3, szTable3New ) );

	//  Open the tables

	printf( "\t Opening tables\n" );
	Call( ErrCheckOpenAllOldTables( sesid, *pdbid ) );
	Call( ErrOpenAllNewTables( sesid, *pdbid ) );

	//  Purge all the FCB's again to make sure the changes are persistant

	printf( "\t Closing and re-opening database\n" );
	Call( ErrCloseAndOpenDB( sesid, pdbid ) );

	//  Open the tables

	printf( "\t Opening tables\n" );
	Call( ErrCheckOpenAllOldTables( sesid, *pdbid ) );
	Call( ErrOpenAllNewTables( sesid, *pdbid ) );

HandleError:
	return err;
	}


//  ================================================================
static JET_ERR ErrTestRenameColumnErrorCases( const JET_SESID sesid, const JET_DBID dbid )
//  ================================================================
	{
	JET_ERR err;
	JET_TABLEID tableid;

	Call( JetOpenTable( sesid, dbid, szTable1New, NULL, 0, 0, &tableid ) );	

	//  Invalid destination table

	printf( "\t  renaming to NULL (expecting failure)\n" );
	err = JetRenameColumn( sesid, tableid, szColumn1, NULL, NO_GRBIT );
	if( JET_errSuccess == err )
		{
		printf( "ERROR:  unexpected success at line %d of %s\n",
				__LINE__, __FILE__ );
		Call( JET_errDatabaseCorrupted );
		}

	//  Invalid source table

	printf( "\t  renaming NULL column (expecting failure)\n" );
	err = JetRenameColumn( sesid, tableid, NULL, szColumn1New, NO_GRBIT );
	if( JET_errSuccess == err )
		{
		printf( "ERROR:  unexpected success at line %d of %s\n",
				__LINE__, __FILE__ );
		Call( JET_errDatabaseCorrupted );
		}

	//  Source table does not exist

	printf( "\t  renaming a non-existant column (expecting failure)\n" );
	err = JetRenameColumn( sesid, tableid, szColumn1New, szColumn1New, NO_GRBIT );
	if( JET_errSuccess == err )
		{
		printf( "ERROR:  unexpected success at line %d of %s\n",
				__LINE__, __FILE__ );
		Call( JET_errDatabaseCorrupted );
		}

	//  Rename a column to a column that already exists

	printf( "\t  renaming %s to %s (expecting failure)\n", szColumn1, szColumn2 );
	err = JetRenameColumn( sesid, tableid, szColumn1, szColumn2, NO_GRBIT );
	if( JET_errSuccess == err )
		{
		printf( "ERROR:  unexpected success at line %d of %s\n",
				__LINE__, __FILE__ );
		Call( JET_errDatabaseCorrupted );
		}

	Call( JetCloseTable( sesid, tableid ) );

HandleError:
	return err;
	}


//  ================================================================
static JET_ERR RenameColumn( 
				const JET_SESID sesid, 
				const JET_TABLEID tableid,
				const char * const szColumn,
				const char * const szColumnNew,
				const JET_GRBIT grbit ) 
//  ================================================================
	{
	JET_ERR err = JET_errSuccess;

	JET_COLUMNDEF columndef;
	JET_COLUMNID columnidOld;
	JET_COLUMNID columnidNew;

	printf( "\t  renaming %s to %s\n", szColumn, szColumnNew );

	Call( JetGetTableColumnInfo(
				sesid,
				tableid,
				szColumn,
				&columndef,
				sizeof( JET_COLUMNDEF ),
				JET_ColInfo ) );	

	columnidOld = columndef.columnid;

	Call( JetRenameColumn( sesid, tableid, szColumn, szColumnNew, grbit ) );

	err = JetGetTableColumnInfo(
				sesid,
				tableid,
				szColumn,
				&columndef,
				sizeof( JET_COLUMNDEF ),
				JET_ColInfo );	
	if( JET_errSuccess == err )
		{
		printf( "ERROR:  column %s is still visible\n", szColumn );
		err = JET_errDatabaseCorrupted;
		Call( err );
		}

	Call( JetGetTableColumnInfo(
				sesid,
				tableid,
				szColumnNew,
				&columndef,
				sizeof( JET_COLUMNDEF ),
				JET_ColInfo ) );	

	columnidNew = columndef.columnid;

	if( columnidNew != columnidOld )
		{
		printf( "ERROR:  columnid changed from %d to %d after a rename\n",
				columnidOld, columnidNew );
		err = JET_errDatabaseCorrupted;
		Call( err );
		}

HandleError:
	return err;
	}


//  ================================================================
static JET_ERR ErrTestRenameColumn( const JET_SESID sesid, JET_DBID * const pdbid )
//  ================================================================
	{
	JET_ERR err = JET_errSuccess;
	JET_TABLEID tableid;

	//  Error Cases

	printf( "\t Error Handling\n" );
	Call( ErrTestRenameColumnErrorCases( sesid, *pdbid ) );	

	//  Ordinary Table wo/indexes

	printf( "\t Renaming columns in an ordinary table (%s)\n", szTable2New );

	Call( JetOpenTable( sesid, *pdbid, szTable2New, NULL, 0, 0, &tableid ) );	
	Call( RenameColumn( sesid, tableid, szColumn1, szColumn1New, NO_GRBIT ) );
	Call( RenameColumn( sesid, tableid, szColumn2, szColumn2New, NO_GRBIT ) );
	Call( RenameColumn( sesid, tableid, szColumn3, szColumn3New, NO_GRBIT ) );
	Call( RenameColumn( sesid, tableid, szColumn4, szColumn4New, NO_GRBIT ) );
	Call( RenameColumn( sesid, tableid, szColumn5, szColumn5New, NO_GRBIT ) );
	Call( JetCloseTable( sesid, tableid ) );

	//  Ordinary Table w/indexes

	printf( "\t Renaming columns in an ordinary table with indexes (%s)\n",
			szTable2New );

	Call( JetOpenTable( sesid, *pdbid, szTable1New, NULL, 0, 0, &tableid ) );	
	Call( RenameColumn( sesid, tableid, szColumn1, szColumn1New, NO_GRBIT ) );
	Call( RenameColumn( sesid, tableid, szColumn2, szColumn2New, NO_GRBIT ) );
	Call( RenameColumn( sesid, tableid, szColumn3, szColumn3New, NO_GRBIT ) );
	Call( RenameColumn( sesid, tableid, szColumn4, szColumn4New, NO_GRBIT ) );
	Call( RenameColumn( sesid, tableid, szColumn5, szColumn5New, NO_GRBIT ) );
	Call( JetCloseTable( sesid, tableid ) );

	//  Derived Table

	printf( "\t Renaming columns in a derived table (%s)\n", szTable6New );

	Call( JetOpenTable( sesid, *pdbid, szTable6New, NULL, 0, 0, &tableid ) );	
	Call( RenameColumn( sesid, tableid, szColumn1, szColumn1New, NO_GRBIT ) );
	Call( RenameColumn( sesid, tableid, szColumn2, szColumn2New, NO_GRBIT ) );
	Call( RenameColumn( sesid, tableid, szColumn3, szColumn3New, NO_GRBIT ) );
	Call( RenameColumn( sesid, tableid, szColumn4, szColumn4New, NO_GRBIT ) );
	Call( RenameColumn( sesid, tableid, szColumn5, szColumn5New, NO_GRBIT ) );
	Call( JetCloseTable( sesid, tableid ) );

	//  Template Table

	printf( "\t Renaming columns in a template table (%s)\n",
			szTable5 );

	Call( JetOpenTable( sesid, *pdbid, szTable5, NULL, 0, 0, &tableid ) );	
	Call( RenameColumn( sesid, tableid, szColumn6, szColumn6New, NO_GRBIT ) );
	Call( JetCloseTable( sesid, tableid ) );

	//  JET_bitColumnRenameConvertToPrimaryIndexPlaceholder

	printf( " Renaming columns in a template table (%s) with JET_bitColumnRenameConvertToPrimaryIndexPlaceholder\n",
			szTable5 );

	Call( JetOpenTable( sesid, *pdbid, szTable5, NULL, 0, 0, &tableid ) );	
	Call( RenameColumn( sesid, tableid, szColumn7, szColumn7New, JET_bitColumnRenameConvertToPrimaryIndexPlaceholder ) );
	Call( JetCloseTable( sesid, tableid ) );

	//  Open the tables again

	printf( "\t Opening tables\n" );
	Call( ErrOpenAllNewTables( sesid, *pdbid ) );

	printf( "\t Closing and re-opening database\n" );
	Call( ErrCloseAndOpenDB( sesid, pdbid ) );

	printf( "\t Opening tables\n" );
	Call( ErrOpenAllNewTables( sesid, *pdbid ) );

HandleError:
	return err;
	}


//  ================================================================
JET_ERR RENAMETABLECOLUMN::ErrTest(
	const JET_INSTANCE instance,
	const JET_SESID sesid,
	JET_DBID& dbid )
//  ================================================================
	{
	JET_ERR					err			= 0;
	JET_COLUMNID			columnidlv	= 0;
	JET_TABLEID				tableid		= 0;

	printf( "\tcreating tables\n" );

	Call( JetBeginTransaction( sesid ) );
	Call( JetCreateTableColumnIndex( sesid, dbid, &tablecreate1 ) );
	Call( JetCreateTableColumnIndex( sesid, dbid, &tablecreate2 ) );
	Call( JetCreateTableColumnIndex( sesid, dbid, &tablecreate3 ) );
	Call( JetCreateTableColumnIndex( sesid, dbid, &tablecreate4 ) );
	Call( JetCreateTableColumnIndex( sesid, dbid, &tablecreate5 ) );
	Call( JetCreateTableColumnIndex( sesid, dbid, &tablecreate6 ) );
	Call( JetCommitTransaction( sesid, 0 ) );

	//  Flush cached meta-data (FCB's, TDB's)

	printf( "\tclosing and re-opening database\n" );
	Call( ErrCloseAndOpenDB( sesid, &dbid ) );

	//  Test JetRenameTable

	printf( "\tJetRenameTable...\n" );
	Call( ErrTestRenameTable( sesid, &dbid ) );

	//  Test JetRenameColumn

	printf( "\tJetRenameColumn...\n" );
	Call( ErrTestRenameColumn( sesid, &dbid ) );

HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\_perfctrs\makefile.inc ===
$(O)\esentprf.hxx $(O)\esentprf.ini: perfdata.txt
        copy perfdata.pl $(O)
        copy perfdata.txt $(O)
        cd $(O)
        perl .\perfdata.pl perfdata.txt
        cd ..\..

clean:
        -del $(O)\esentprf.hxx $(O)\esentprf.ini
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\_errstr\makefile.inc ===
$(O)\err.cxx: ..\..\export\jet.h .\err.pl
        perl .\err.pl < ..\..\export\jet.h > $(O)\err.cxx
        
clean:
        -del $(O)\err.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\sync\sync.cxx ===
#include "sync.hxx"

//  Performance Monitoring Support

#ifdef DISABLE_PERF_COUNTERS
#define AtomicIncOSSYNCCounter( pcounter )
#else
#define AtomicIncOSSYNCCounter( pcounter )		AtomicIncrement( pcounter )
#endif

long cOSSYNCThreadBlock;
long LOSSYNCThreadBlockCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = cOSSYNCThreadBlock;
		}
		
	return 0;
	}

long cOSSYNCThreadResume;
long LOSSYNCThreadsBlockedCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = cOSSYNCThreadBlock - cOSSYNCThreadResume;
		}
		
	return 0;
	}


namespace OSSYNC {


//  system max spin count

int cSpinMax;


//  Page Memory Allocation

void* PvPageAlloc( const size_t cbSize, void* const pv );
void PageFree( void* const pv );


//  Performance Data Dump

void OSSyncStatsDump(	const char*			szTypeName,
						const char*			szInstanceName,
						const CSyncObject*	psyncobj,
						DWORD				group,
						QWORD				cWait,
						double				csecWaitElapsed,
						QWORD				cAcquire,
						QWORD				cContend,
						QWORD				cHold,
						double				csecHoldElapsed );


//  Kernel Semaphore Pool

//  ctor

CKernelSemaphorePool::CKernelSemaphorePool()
	{
	}

//  dtor

CKernelSemaphorePool::~CKernelSemaphorePool()
	{
	}

//  init

const BOOL CKernelSemaphorePool::FInit()
	{
	//  semaphore pool should be terminated

	OSSYNCAssert( !FInitialized() );

	//  reset members

	m_mpirksemrksem	= NULL;
	m_cksem			= 0;
	
	//  allocate kernel semaphore array

	if ( !( m_mpirksemrksem = (CReferencedKernelSemaphore*)PvPageAlloc( sizeof( CReferencedKernelSemaphore ) * 65536, NULL ) ) )
		{
		Term();
		return fFalse;
		}

	//  init successful

	return fTrue;
	}

//  term

void CKernelSemaphorePool::Term()
	{
	//  the kernel semaphore array is allocated

	if ( m_mpirksemrksem )
		{
		//  terminate all initialized kernel semaphores

		for ( m_cksem-- ; m_cksem >= 0; m_cksem-- )
			{
			m_mpirksemrksem[m_cksem].Term();
			m_mpirksemrksem[m_cksem].~CReferencedKernelSemaphore();
			}

		//  delete the kernel semaphore array
		
		PageFree( m_mpirksemrksem );
		}
	
	//  reset data members

	m_mpirksemrksem	= 0;
	m_cksem			= 0;
	}

//  Referenced Kernel Semaphore

//  ctor

CKernelSemaphorePool::CReferencedKernelSemaphore::CReferencedKernelSemaphore()
	:	CKernelSemaphore( CSyncBasicInfo( "CKernelSemaphorePool::CReferencedKernelSemaphore" ) )
	{
	//  reset data members

	m_cReference	= 0;
	m_fInUse		= 0;
	m_fAvailable	= 0;
#ifdef SYNC_VALIDATE_IRKSEM_USAGE
	m_psyncobjUser	= 0;
#endif  //  SYNC_VALIDATE_IRKSEM_USAGE
	}

//  dtor

CKernelSemaphorePool::CReferencedKernelSemaphore::~CReferencedKernelSemaphore()
	{
	}

//  init

const BOOL CKernelSemaphorePool::CReferencedKernelSemaphore::FInit()
	{
	//  reset data members

	m_cReference	= 0;
	m_fInUse		= 0;
	m_fAvailable	= 0;
#ifdef SYNC_VALIDATE_IRKSEM_USAGE
	m_psyncobjUser	= 0;
#endif  //  SYNC_VALIDATE_IRKSEM_USAGE

	//  initialize the kernel semaphore
	
	return CKernelSemaphore::FInit();
	}

//  term

void CKernelSemaphorePool::CReferencedKernelSemaphore::Term()
	{
	//  terminate the kernel semaphore

	CKernelSemaphore::Term();
	
	//  reset data members

	m_cReference	= 0;
	m_fInUse		= 0;
	m_fAvailable	= 0;
#ifdef SYNC_VALIDATE_IRKSEM_USAGE
	m_psyncobjUser	= 0;
#endif  //  SYNC_VALIDATE_IRKSEM_USAGE
	}


//  Global Kernel Semaphore Pool

CKernelSemaphorePool ksempoolGlobal;


//  Synchronization Object Performance:  Acquisition

//  ctor

CSyncPerfAcquire::CSyncPerfAcquire()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	m_cAcquire = 0;
	m_cContend = 0;

#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  dtor

CSyncPerfAcquire::~CSyncPerfAcquire()
	{
	}


//  Semaphore

//  ctor

CSemaphore::CSemaphore( const CSyncBasicInfo& sbi )
	:	CEnhancedStateContainer< CSemaphoreState, CSyncStateInitNull, CSemaphoreInfo, CSyncBasicInfo >( syncstateNull, sbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CSemaphore" );
	State().SetInstance( (CSyncObject*)this );
	}

//  dtor

CSemaphore::~CSemaphore()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	OSSyncStatsDump(	State().SzTypeName(),
						State().SzInstanceName(),
						State().Instance(),
						-1,
						State().CWaitTotal(),
						State().CsecWaitElapsed(),
						State().CAcquireTotal(),
						State().CContendTotal(),
						0,
						0 );

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  attempts to acquire a count from the semaphore, returning fFalse if unsuccessful
//  in the time permitted.  Infinite and Test-Only timeouts are supported.

const BOOL CSemaphore::_FAcquire( const int cmsecTimeout )
	{
	//  if we spin, we will spin for the full amount recommended by the OS
	
	int cSpin = cSpinMax;

	//  we start with no kernel semaphore allocated
	
	CKernelSemaphorePool::IRKSEM irksemAlloc = CKernelSemaphorePool::irksemNil;

	//  try forever until we successfully change the state of the semaphore
	
	OSSYNC_FOREVER
		{
		//  read the current state of the semaphore
		
		const CSemaphoreState stateCur = (CSemaphoreState&) State();

		//  there is an available count

		if ( stateCur.FAvail() )
			{
			//  we successfully took a count
			
			if ( State().FChange( stateCur, CSemaphoreState( stateCur.CAvail() - 1 ) ) )
				{
				//  if we allocated a kernel semaphore, release it
				
				if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
					{
					ksempoolGlobal.Unreference( irksemAlloc );
					}

				//  return success

				State().SetAcquire();
				return fTrue;
				}
			}

		//  there is no available count and we still have spins left
		
		else if ( cSpin )
			{
			//  spin once and try again
			
			cSpin--;
			continue;
			}

		//  there are no waiters and no available counts
		
		else if ( stateCur.FNoWaitAndNoAvail() )
			{
			//  allocate and reference a kernel semaphore if we haven't already
			
			if ( irksemAlloc == CKernelSemaphorePool::irksemNil )
				{
				irksemAlloc = ksempoolGlobal.Allocate( this );
				}

			//  we successfully installed ourselves as the first waiter
				
			if ( State().FChange( stateCur, CSemaphoreState( 1, irksemAlloc ) ) )
				{
				//  wait for next available count on semaphore

				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( irksemAlloc, this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
					
					ksempoolGlobal.Unreference( irksemAlloc );

					//  we successfully acquired a count

					State().SetAcquire();
					return fTrue;
					}

				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the semaphore

					OSSYNC_FOREVER
						{
						//  read the current state of the semaphore
						
						const CSemaphoreState stateAfterWait = (CSemaphoreState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the semaphore is not the same as the one we allocated

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != irksemAlloc )
							{
							//  the kernel semaphore we allocated is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( irksemAlloc, this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( irksemAlloc );

							//  we successfully acquired a count

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the semaphore is the same as the one we allocated

						else if ( stateAfterWait.CWait() == 1 )
							{
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully changed the semaphore to have no
							//  available counts and no waiters
							
							if ( State().FChange( stateAfterWait, CSemaphoreState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully acquire a count

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the semaphore is the same as the one we allocated

						else
							{
							OSSYNCAssert( stateAfterWait.CWait() > 1 );
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully reduced the number of waiters on the
							//  semaphore by one
							
							if ( State().FChange( stateAfterWait, CSemaphoreState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully acquire a count

								return fFalse;
								}
							}
						}
					}
				}
			}

		//  there are waiters
		
		else
			{
			OSSYNCAssert( stateCur.FWait() );

			//  reference the kernel semaphore already in use

			ksempoolGlobal.Reference( stateCur.Irksem() );

			//  we successfully added ourself as another waiter
			
			if ( State().FChange( stateCur, CSemaphoreState( stateCur.CWait() + 1, stateCur.Irksem() ) ) )
				{
				//  if we allocated a kernel semaphore, unreference it

				if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
					{
					ksempoolGlobal.Unreference( irksemAlloc );
					}

				//  wait for next available count on semaphore
				
				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( stateCur.Irksem(), this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
				
					ksempoolGlobal.Unreference( stateCur.Irksem() );

					//  we successfully acquired a count
					
					State().SetAcquire();
					return fTrue;
					}
					
				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the semaphore

					OSSYNC_FOREVER
						{
						//  read the current state of the semaphore
						
						const CSemaphoreState stateAfterWait = (CSemaphoreState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the semaphore is not the same as the one we waited on

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != stateCur.Irksem() )
							{
							//  the kernel semaphore we waited on is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( stateCur.Irksem() );

							//  we successfully acquired a count

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the semaphore is the same as the one we waited on

						else if ( stateAfterWait.CWait() == 1 )
							{
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully changed the semaphore to have no
							//  available counts and no waiters
							
							if ( State().FChange( stateAfterWait, CSemaphoreState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully acquire a count

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the semaphore is the same as the one we waited on

						else
							{
							OSSYNCAssert( stateAfterWait.CWait() > 1 );
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully reduced the number of waiters on the
							//  semaphore by one
							
							if ( State().FChange( stateAfterWait, CSemaphoreState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully acquire a count

								return fFalse;
								}
							}
						}
					}
				}

			//  unreference the kernel semaphore
				
			ksempoolGlobal.Unreference( stateCur.Irksem() );
			}
		}
	}

//  releases the given number of counts to the semaphore, waking the appropriate
//  number of waiters

void CSemaphore::_Release( const int cToRelease )
	{
	//  try forever until we successfully change the state of the semaphore
	
	OSSYNC_FOREVER
		{
		//  read the current state of the semaphore
		
		const CSemaphoreState stateCur = State();

		//  there are no waiters

		if ( stateCur.FNoWait() )
			{
			//  we successfully added the count to the semaphore
			
			if ( State().FChange( stateCur, CSemaphoreState( stateCur.CAvail() + cToRelease ) ) )
				{
				//  we're done
				
				return;
				}
			}

		//  there are waiters
		
		else
			{
			OSSYNCAssert( stateCur.FWait() );

			//  we are releasing more counts than waiters (or equal to)

			if ( stateCur.CWait() <= cToRelease )
				{
				//  we successfully changed the semaphore to have an available count
				//  that is equal to the specified release count minus the number of
				//  waiters to release
				
				if ( State().FChange( stateCur, CSemaphoreState( cToRelease - stateCur.CWait() ) ) )
					{
					//  release all waiters
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release( stateCur.CWait() );

					//  we're done
					
					return;
					}
				}

			//  we are releasing less counts than waiters
			
			else
				{
				OSSYNCAssert( stateCur.CWait() > cToRelease );

				//  we successfully reduced the number of waiters on the semaphore by
				//  the number specified
				
				if ( State().FChange( stateCur, CSemaphoreState( stateCur.CWait() - cToRelease, stateCur.Irksem() ) ) )
					{
					//  release the specified number of waiters
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release( cToRelease );

					//  we're done
					
					return;
					}
				}
			}
		}
	}


//  Auto-Reset Signal

//  ctor

CAutoResetSignal::CAutoResetSignal( const CSyncBasicInfo& sbi )
	:	CEnhancedStateContainer< CAutoResetSignalState, CSyncStateInitNull, CAutoResetSignalInfo, CSyncBasicInfo >( syncstateNull, sbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CAutoResetSignal" );
	State().SetInstance( (CSyncObject*)this );
	}

//  dtor

CAutoResetSignal::~CAutoResetSignal()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	OSSyncStatsDump(	State().SzTypeName(),
						State().SzInstanceName(),
						State().Instance(),
						-1,
						State().CWaitTotal(),
						State().CsecWaitElapsed(),
						State().CAcquireTotal(),
						State().CContendTotal(),
						0,
						0 );

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  waits for the signal to be set, returning fFalse if unsuccessful in the time
//  permitted.  Infinite and Test-Only timeouts are supported.

const BOOL CAutoResetSignal::_FWait( const int cmsecTimeout )
	{
	//  if we spin, we will spin for the full amount recommended by the OS
	
	int cSpin = cSpinMax;

	//  we start with no kernel semaphore allocated
	
	CKernelSemaphorePool::IRKSEM irksemAlloc = CKernelSemaphorePool::irksemNil;

	//  try forever until we successfully change the state of the signal
	
	OSSYNC_FOREVER
		{
		//  read the current state of the signal
		
		const CAutoResetSignalState stateCur = (CAutoResetSignalState&) State();

		//  the signal is set

		if ( stateCur.FNoWaitAndSet() )
			{
			//  we successfully changed the signal state to reset with no waiters
			
			if ( State().FChange( stateCur, CAutoResetSignalState( 0 ) ) )
				{
				//  if we allocated a kernel semaphore, release it
				
				if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
					{
					ksempoolGlobal.Unreference( irksemAlloc );
					}

				//  return success

				State().SetAcquire();
				return fTrue;
				}
			}

		//  the signal is not set and we still have spins left
		
		else if ( cSpin )
			{
			//  spin once and try again
			
			cSpin--;
			continue;
			}

		//  the signal is not set and there are no waiters
		
		else if ( stateCur.FNoWaitAndNotSet() )
			{
			//  allocate and reference a kernel semaphore if we haven't already
			
			if ( irksemAlloc == CKernelSemaphorePool::irksemNil )
				{
				irksemAlloc = ksempoolGlobal.Allocate( this );
				}

			//  we successfully installed ourselves as the first waiter
				
			if ( State().FChange( stateCur, CAutoResetSignalState( 1, irksemAlloc ) ) )
				{
				//  wait for signal to be set
				
				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( irksemAlloc, this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
					
					ksempoolGlobal.Unreference( irksemAlloc );

					//  we successfully waited for the signal

					State().SetAcquire();
					return fTrue;
					}

				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the signal

					OSSYNC_FOREVER
						{
						//  read the current state of the signal
						
						const CAutoResetSignalState stateAfterWait = (CAutoResetSignalState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the signal is not the same as the one we allocated

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != irksemAlloc )
							{
							//  the kernel semaphore we allocated is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( irksemAlloc, this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( irksemAlloc );

							//  we successfully waited for the signal

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the signal is the same as the one we allocated

						else if ( stateAfterWait.CWait() == 1 )
							{
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully changed the signal to the reset with
							//  no waiters state
							
							if ( State().FChange( stateAfterWait, CAutoResetSignalState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the signal is the same as the one we allocated

						else
							{
							OSSYNCAssert( stateAfterWait.CWait() > 1 );
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully reduced the number of waiters on the
							//  signal by one
							
							if ( State().FChange( stateAfterWait, CAutoResetSignalState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}
						}
					}
				}
			}

		//  there are waiters
		
		else
			{
			OSSYNCAssert( stateCur.FWait() );

			//  reference the kernel semaphore already in use

			ksempoolGlobal.Reference( stateCur.Irksem() );

			//  we successfully added ourself as another waiter
			
			if ( State().FChange( stateCur, CAutoResetSignalState( stateCur.CWait() + 1, stateCur.Irksem() ) ) )
				{
				//  if we allocated a kernel semaphore, unreference it

				if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
					{
					ksempoolGlobal.Unreference( irksemAlloc );
					}

				//  wait for signal to be set
				
				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( stateCur.Irksem(), this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
				
					ksempoolGlobal.Unreference( stateCur.Irksem() );

					//  we successfully waited for the signal
					
					State().SetAcquire();
					return fTrue;
					}
					
				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the signal

					OSSYNC_FOREVER
						{
						//  read the current state of the signal
						
						const CAutoResetSignalState stateAfterWait = (CAutoResetSignalState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the signal is not the same as the one we waited on

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != stateCur.Irksem() )
							{
							//  the kernel semaphore we waited on is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( stateCur.Irksem() );

							//  we successfully waited for the signal

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the signal is the same as the one we waited on

						else if ( stateAfterWait.CWait() == 1 )
							{
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully changed the signal to the reset with
							//  no waiters state
							
							if ( State().FChange( stateAfterWait, CAutoResetSignalState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the signal is the same as the one we waited on

						else
							{
							OSSYNCAssert( stateAfterWait.CWait() > 1 );
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully reduced the number of waiters on the
							//  signal by one
							
							if ( State().FChange( stateAfterWait, CAutoResetSignalState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}
						}
					}
				}

			//  unreference the kernel semaphore
				
			ksempoolGlobal.Unreference( stateCur.Irksem() );
			}
		}
	}

//  sets the signal, releasing up to one waiter.  if a waiter is released, then
//  the signal will be reset.  if a waiter is not released, the signal will
//  remain set

void CAutoResetSignal::_Set()
	{
	//  try forever until we successfully change the state of the signal
	
	OSSYNC_FOREVER
		{
		//  read the current state of the signal
		
		const CAutoResetSignalState stateCur = (CAutoResetSignalState&) State();

		//  there are no waiters

		if ( stateCur.FNoWait() )
			{
			//  we successfully changed the signal state from reset with no
			//  waiters to set or from set to set (a nop)
			
			if ( State().FSimpleSet() )
				{
				//  we're done
				
				return;
				}
			}

		//  there are waiters
		
		else
			{
			OSSYNCAssert( stateCur.FWait() );

			//  there is only one waiter

			if ( stateCur.CWait() == 1 )
				{
				//  we successfully changed the signal to the reset with no waiters state
				
				if ( State().FChange( stateCur, CAutoResetSignalState( 0 ) ) )
					{
					//  release the lone waiter
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release();

					//  we're done
					
					return;
					}
				}

			//  there is more than one waiter
			
			else
				{
				OSSYNCAssert( stateCur.CWait() > 1 );

				//  we successfully reduced the number of waiters on the signal by one
				
				if ( State().FChange( stateCur, CAutoResetSignalState( stateCur.CWait() - 1, stateCur.Irksem() ) ) )
					{
					//  release one waiter
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release();

					//  we're done
					
					return;
					}
				}
			}
		}
	}

//  resets the signal, releasing up to one waiter

void CAutoResetSignal::_Pulse()
	{
	//  try forever until we successfully change the state of the signal
	
	OSSYNC_FOREVER
		{
		//  read the current state of the signal
		
		const CAutoResetSignalState stateCur = (CAutoResetSignalState&) State();

		//  there are no waiters

		if ( stateCur.FNoWait() )
			{
			//  we successfully changed the signal state from set to reset with
			//  no waiters or from reset with no waiters to reset with no
			//  waiters (a nop)
			
			if ( State().FSimpleReset() )
				{
				//  we're done
				
				return;
				}
			}

		//  there are waiters
		
		else
			{
			OSSYNCAssert( stateCur.FWait() );

			//  there is only one waiter

			if ( stateCur.CWait() == 1 )
				{
				//  we successfully changed the signal to the reset with no waiters state
				
				if ( State().FChange( stateCur, CAutoResetSignalState( 0 ) ) )
					{
					//  release the lone waiter
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release();

					//  we're done
					
					return;
					}
				}

			//  there is more than one waiter
			
			else
				{
				OSSYNCAssert( stateCur.CWait() > 1 );

				//  we successfully reduced the number of waiters on the signal by one
				
				if ( State().FChange( stateCur, CAutoResetSignalState( stateCur.CWait() - 1, stateCur.Irksem() ) ) )
					{
					//  release one waiter
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release();

					//  we're done
					
					return;
					}
				}
			}
		}
	}


//  Manual-Reset Signal

//  ctor

CManualResetSignal::CManualResetSignal( const CSyncBasicInfo& sbi )
	:	CEnhancedStateContainer< CManualResetSignalState, CSyncStateInitNull, CManualResetSignalInfo, CSyncBasicInfo >( syncstateNull, sbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CManualResetSignal" );
	State().SetInstance( (CSyncObject*)this );
	}

//  dtor

CManualResetSignal::~CManualResetSignal()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	OSSyncStatsDump(	State().SzTypeName(),
						State().SzInstanceName(),
						State().Instance(),
						-1,
						State().CWaitTotal(),
						State().CsecWaitElapsed(),
						State().CAcquireTotal(),
						State().CContendTotal(),
						0,
						0 );

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  waits for the signal to be set, returning fFalse if unsuccessful in the time
//  permitted.  Infinite and Test-Only timeouts are supported.

const BOOL CManualResetSignal::_FWait( const int cmsecTimeout )
	{
	//  if we spin, we will spin for the full amount recommended by the OS
	
	int cSpin = cSpinMax;

	//  we start with no kernel semaphore allocated
	
	CKernelSemaphorePool::IRKSEM irksemAlloc = CKernelSemaphorePool::irksemNil;

	//  try forever until we successfully change the state of the signal
	
	OSSYNC_FOREVER
		{
		//  read the current state of the signal
		
		const CManualResetSignalState stateCur = (CManualResetSignalState&) State();

		//  the signal is set

		if ( stateCur.FNoWaitAndSet() )
			{
			//  if we allocated a kernel semaphore, release it
			
			if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
				{
				ksempoolGlobal.Unreference( irksemAlloc );
				}

			//  we successfully waited for the signal

			State().SetAcquire();
			return fTrue;
			}

		//  the signal is not set and we still have spins left
		
		else if ( cSpin )
			{
			//  spin once and try again
			
			cSpin--;
			continue;
			}

		//  the signal is not set and there are no waiters
		
		else if ( stateCur.FNoWaitAndNotSet() )
			{
			//  allocate and reference a kernel semaphore if we haven't already
			
			if ( irksemAlloc == CKernelSemaphorePool::irksemNil )
				{
				irksemAlloc = ksempoolGlobal.Allocate( this );
				}

			//  we successfully installed ourselves as the first waiter
				
			if ( State().FChange( stateCur, CManualResetSignalState( 1, irksemAlloc ) ) )
				{
				//  wait for signal to be set
				
				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( irksemAlloc, this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
					
					ksempoolGlobal.Unreference( irksemAlloc );

					//  we successfully waited for the signal

					State().SetAcquire();
					return fTrue;
					}

				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the signal

					OSSYNC_FOREVER
						{
						//  read the current state of the signal
						
						const CManualResetSignalState stateAfterWait = (CManualResetSignalState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the signal is not the same as the one we allocated

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != irksemAlloc )
							{
							//  the kernel semaphore we allocated is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( irksemAlloc, this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( irksemAlloc );

							//  we successfully waited for the signal

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the signal is the same as the one we allocated

						else if ( stateAfterWait.CWait() == 1 )
							{
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully changed the signal to the reset with
							//  no waiters state
							
							if ( State().FChange( stateAfterWait, CManualResetSignalState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the signal is the same as the one we allocated

						else
							{
							OSSYNCAssert( stateAfterWait.CWait() > 1 );
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully reduced the number of waiters on the
							//  signal by one
							
							if ( State().FChange( stateAfterWait, CManualResetSignalState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}
						}
					}
				}
			}

		//  there are waiters
		
		else
			{
			OSSYNCAssert( stateCur.FWait() );

			//  reference the kernel semaphore already in use

			ksempoolGlobal.Reference( stateCur.Irksem() );

			//  we successfully added ourself as another waiter
			
			if ( State().FChange( stateCur, CManualResetSignalState( stateCur.CWait() + 1, stateCur.Irksem() ) ) )
				{
				//  if we allocated a kernel semaphore, unreference it

				if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
					{
					ksempoolGlobal.Unreference( irksemAlloc );
					}

				//  wait for signal to be set
				
				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( stateCur.Irksem(), this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
				
					ksempoolGlobal.Unreference( stateCur.Irksem() );

					//  we successfully waited for the signal
					
					State().SetAcquire();
					return fTrue;
					}
					
				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the signal

					OSSYNC_FOREVER
						{
						//  read the current state of the signal
						
						const CManualResetSignalState stateAfterWait = (CManualResetSignalState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the signal is not the same as the one we waited on

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != stateCur.Irksem() )
							{
							//  the kernel semaphore we waited on is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( stateCur.Irksem() );

							//  we successfully waited for the signal

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the signal is the same as the one we waited on

						else if ( stateAfterWait.CWait() == 1 )
							{
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully changed the signal to the reset with
							//  no waiters state
							
							if ( State().FChange( stateAfterWait, CManualResetSignalState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the signal is the same as the one we waited on

						else
							{
							OSSYNCAssert( stateAfterWait.CWait() > 1 );
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully reduced the number of waiters on the
							//  signal by one
							
							if ( State().FChange( stateAfterWait, CManualResetSignalState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}
						}
					}
				}

			//  unreference the kernel semaphore
				
			ksempoolGlobal.Unreference( stateCur.Irksem() );
			}
		}
	}


//  Lock Object Basic Information

//  ctor

CLockBasicInfo::CLockBasicInfo( const CSyncBasicInfo& sbi, const int rank, const int subrank )
	:	CSyncBasicInfo( sbi )
	{
#ifdef SYNC_DEADLOCK_DETECTION

	m_rank			= rank;
	m_subrank		= subrank;

#endif  //  SYNC_DEADLOCK_DETECTION
	}

//  dtor

CLockBasicInfo::~CLockBasicInfo()
	{
	}
	

//  Lock Object Performance:  Hold

//  ctor

CLockPerfHold::CLockPerfHold()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	m_cHold = 0;
	m_qwHRTHoldElapsed = 0;

#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  dtor

CLockPerfHold::~CLockPerfHold()
	{
	}


//  Lock Owner Record

//  ctor

COwner::COwner()
	{
#ifdef SYNC_DEADLOCK_DETECTION

	m_pclsOwner			= NULL;
	m_pownerContextNext	= NULL;
	m_plddiOwned		= NULL;
	m_pownerLockNext	= NULL;
	m_group				= 0;
	
#endif  //  SYNC_DEADLOCK_DETECTION
	}

//  dtor

COwner::~COwner()
	{
	}


//  Lock Object Deadlock Detection Information

//  ctor

#ifdef SYNC_DEADLOCK_DETECTION

CLockDeadlockDetectionInfo::CLockDeadlockDetectionInfo( const CLockBasicInfo& lbi )
	:	m_semOwnerList( CSyncBasicInfo( "CLockDeadlockDetectionInfo::m_semOwnerList" ) )
	{
	m_plbiParent = &lbi;
	m_semOwnerList.Release();
	}

#else  //  !SYNC_DEADLOCK_DETECTION

CLockDeadlockDetectionInfo::CLockDeadlockDetectionInfo( const CLockBasicInfo& lbi )
	{
	}

#endif  //  SYNC_DEADLOCK_DETECTION

//  dtor

CLockDeadlockDetectionInfo::~CLockDeadlockDetectionInfo()
	{
	}


//  Critical Section (non-nestable) State

//  ctor

CCriticalSectionState::CCriticalSectionState( const CSyncBasicInfo& sbi )
	:	m_sem( sbi )
	{
	}

//  dtor

CCriticalSectionState::~CCriticalSectionState()
	{
	}


//  Critical Section (non-nestable)

//  ctor

CCriticalSection::CCriticalSection( const CLockBasicInfo& lbi )
	:	CEnhancedStateContainer< CCriticalSectionState, CSyncBasicInfo, CCriticalSectionInfo, CLockBasicInfo >( (CSyncBasicInfo&) lbi, lbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CCriticalSection" );
	State().SetInstance( (CSyncObject*)this );
	
	//  release semaphore

	State().Semaphore().Release();
	}

//  dtor

CCriticalSection::~CCriticalSection()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	OSSyncStatsDump(	State().SzTypeName(),
						State().SzInstanceName(),
						State().Instance(),
						-1,
						0,
						0,
						0,
						0,
						State().CHoldTotal(),
						State().CsecHoldElapsed() );

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}


//  Nestable Critical Section State

//  ctor

CNestableCriticalSectionState::CNestableCriticalSectionState( const CSyncBasicInfo& sbi )
	:	m_sem( sbi ),
		m_pclsOwner( 0 ),
		m_cEntry( 0 )
	{
	}

//  dtor

CNestableCriticalSectionState::~CNestableCriticalSectionState()
	{
	}


//  Nestable Critical Section

//  ctor

CNestableCriticalSection::CNestableCriticalSection( const CLockBasicInfo& lbi )
	:	CEnhancedStateContainer< CNestableCriticalSectionState, CSyncBasicInfo, CNestableCriticalSectionInfo, CLockBasicInfo >( (CSyncBasicInfo&) lbi, lbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CNestableCriticalSection" );
	State().SetInstance( (CSyncObject*)this );
	
	//  release semaphore

	State().Semaphore().Release();
	}

//  dtor

CNestableCriticalSection::~CNestableCriticalSection()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	OSSyncStatsDump(	State().SzTypeName(),
						State().SzInstanceName(),
						State().Instance(),
						-1,
						0,
						0,
						0,
						0,
						State().CHoldTotal(),
						State().CsecHoldElapsed() );

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}


//  Gate State

//  ctor

CGateState::CGateState( const int cWait, const int irksem )
	{
	//  validate IN args
	
	OSSYNCAssert( cWait >= 0 );
	OSSYNCAssert( cWait <= 0x7FFF );
	OSSYNCAssert( irksem >= 0 );
	OSSYNCAssert( irksem <= 0xFFFE );

	//  set waiter count
	
	m_cWait = (unsigned short) cWait;

	//  set semaphore
	
	m_irksem = (unsigned short) irksem;
	}


//  Gate

//  ctor

CGate::CGate( const CSyncBasicInfo& sbi )
	:	CEnhancedStateContainer< CGateState, CSyncStateInitNull, CGateInfo, CSyncBasicInfo >( syncstateNull, sbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CGate" );
	State().SetInstance( (CSyncObject*)this );
	}

//  dtor

CGate::~CGate()
	{
	//  no one should be waiting

	// if a thread waiting is killed, the CWait() can be != 0
	// OSSYNCAssert( State().CWait() == 0 );
	
	//OSSYNCAssert( State().Irksem() == CKernelSemaphorePool::irksemNil );

#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	OSSyncStatsDump(	State().SzTypeName(),
						State().SzInstanceName(),
						State().Instance(),
						-1,
						State().CWaitTotal(),
						State().CsecWaitElapsed(),
						0,
						0,
						0,
						0 );

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  waits forever on the gate until released by someone else.  this function
//  expects to be called while in the specified critical section.  when the
//  function returns, the caller will NOT be in the critical section

void CGate::Wait( CCriticalSection& crit )
	{
	//  we must be in the specified critical section

	OSSYNCAssert( crit.FOwner() );

	//  there can not be too many waiters on the gate

	OSSYNCAssert( State().CWait() < 0x7FFF );
	
	//  add ourselves as a waiter

	const int cWait = State().CWait() + 1;
	State().SetWaitCount( cWait );

	//  we are the first waiter

	CKernelSemaphorePool::IRKSEM irksem;
#ifdef DEBUG
	irksem = CKernelSemaphorePool::irksemNil;
#endif  //  DEBUG
	if ( cWait == 1 )
		{
		//  allocate a semaphore for the gate and remember it before leaving
		//  the critical section

		OSSYNCAssert( State().Irksem() == CKernelSemaphorePool::irksemNil );
		irksem = ksempoolGlobal.Allocate( this );
		State().SetIrksem( irksem );
		}

	//  we are not the first waiter

	else
		{
		//  reference the semaphore already in the gate and remember it before
		//  leaving the critical section

		OSSYNCAssert( State().Irksem() != CKernelSemaphorePool::irksemNil );
		irksem = State().Irksem();
		ksempoolGlobal.Reference( irksem );
		}
	OSSYNCAssert( irksem != CKernelSemaphorePool::irksemNil );

	//  leave critical section, never to return

	crit.Leave();

	//  wait to be released

	State().StartWait();
	ksempoolGlobal.Ksem( irksem, this ).Acquire();
	State().StopWait();

	//  unreference the semaphore

	ksempoolGlobal.Unreference( irksem );
	}

//  releases the specified number of waiters from the gate.  this function
//  expects to be called while in the specified critical section.  when the
//  function returns, the caller will NOT be in the critical section
//
//  NOTE:  it is illegal to release more waiters than are waiting on the gate
//         and it is also illegal to release less than one waiter

void CGate::Release( CCriticalSection& crit, const int cToRelease )
	{
	//  we must be in the specified critical section

	OSSYNCAssert( crit.FOwner() );

	//  you must release at least one waiter

	OSSYNCAssert( cToRelease > 0 );
	
	//  we cannot release more waiters than are waiting on the gate

	OSSYNCAssert( cToRelease <= State().CWait() );

	//  reduce the waiter count

	State().SetWaitCount( State().CWait() - cToRelease );

	//  remember semaphore to release before leaving the critical section

	const CKernelSemaphorePool::IRKSEM irksem = State().Irksem();

#ifdef DEBUG

	//  we released all the waiters

	if ( State().CWait() == 0 )
		{
		//  set the semaphore to nil

		State().SetIrksem( CKernelSemaphorePool::irksemNil );
		}

#endif  //  DEBUG

	//  leave critical section, never to return

	crit.Leave();

	//  release the specified number of waiters

	ksempoolGlobal.Ksem( irksem, this ).Release( cToRelease );
	}

//  releases the specified number of waiters from the gate.  this function
//  expects to be called while in the specified critical section.  it is
//  guaranteed that the caller will remain in the critical section at all times
//
//  NOTE:  it is illegal to release more waiters than are waiting on the gate
//         and it is also illegal to release less than one waiter

void CGate::ReleaseAndHold( CCriticalSection& crit, const int cToRelease )
	{
	//  we must be in the specified critical section

	OSSYNCAssert( crit.FOwner() );

	//  you must release at least one waiter

	OSSYNCAssert( cToRelease > 0 );
	
	//  we cannot release more waiters than are waiting on the gate

	OSSYNCAssert( cToRelease <= State().CWait() );

	//  reduce the waiter count

	State().SetWaitCount( State().CWait() - cToRelease );

	//  remember semaphore to release before leaving the critical section

	const CKernelSemaphorePool::IRKSEM irksem = State().Irksem();

#ifdef DEBUG

	//  we released all the waiters

	if ( State().CWait() == 0 )
		{
		//  set the semaphore to nil

		State().SetIrksem( CKernelSemaphorePool::irksemNil );
		}

#endif  //  DEBUG

	//  release the specified number of waiters

	ksempoolGlobal.Ksem( irksem, this ).Release( cToRelease );
	}


//  Null Lock Object State Initializer

const CLockStateInitNull lockstateNull;


//  Binary Lock State

//  ctor

CBinaryLockState::CBinaryLockState( const CSyncBasicInfo& sbi )
	:	m_cw( 0 ),
		m_cOwner( 0 ),
		m_sem1( sbi ),
		m_sem2( sbi )
	{
	}

//  dtor

CBinaryLockState::~CBinaryLockState()
	{
	}


//  Binary Lock

//  ctor

CBinaryLock::CBinaryLock( const CLockBasicInfo& lbi )
	:	CEnhancedStateContainer< CBinaryLockState, CSyncBasicInfo, CBinaryLockInfo, CLockBasicInfo >( (CSyncBasicInfo&) lbi, lbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CBinaryLock" );
	State().SetInstance( (CSyncObject*)this );
	}

//  dtor
	
CBinaryLock::~CBinaryLock()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	for ( int iGroup = 0; iGroup < 2; iGroup++ )
		{
		OSSyncStatsDump(	State().SzTypeName(),
							State().SzInstanceName(),
							State().Instance(),
							iGroup,
							State().CWaitTotal( iGroup ),
							State().CsecWaitElapsed( iGroup ),
							State().CAcquireTotal( iGroup ),
							State().CContendTotal( iGroup ),
							State().CHoldTotal( iGroup ),
							State().CsecHoldElapsed( iGroup ) );
		}

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  maps an arbitrary combination of zero and non-zero components into a
//  valid state number of the invalid state number (-1)

const int mpindexstate[16] =
	{
	 0, -1, -1, -1,
	-1, -1,  1, -1,
	-1,  2, -1,  3,
	-1, -1,  4,  5,
	};

//  returns the state number of the specified control word or -1 if it is not
//  a legal state

int CBinaryLock::_StateFromControlWord( const ControlWord cw )
	{
	//  convert the control word into a state index

	int index = 0;
	index = index | ( ( cw & 0x80000000 ) ? 8 : 0 );
	index = index | ( ( cw & 0x7FFF0000 ) ? 4 : 0 );
	index = index | ( ( cw & 0x00008000 ) ? 2 : 0 );
	index = index | ( ( cw & 0x00007FFF ) ? 1 : 0 );

	//  convert the state index into a state number

	const int state = mpindexstate[index];

	//  return the computed state number

	return state;
	}

//  state transition reachability matrix (starting state is the major axis)
//
//  each entry contains bits representing valid reasons for making the
//  transition (made by oring together the valid TransitionReasons)

#define NO	CBinaryLock::trIllegal
#define E1	CBinaryLock::trEnter1
#define L1	CBinaryLock::trLeave1
#define E2	CBinaryLock::trEnter2
#define L2	CBinaryLock::trLeave2

const DWORD mpstatestatetrmask[6][6] =
	{
		{ NO, E2, E1, NO, NO, NO, },
		{ L2, E2 | L2, NO, E1, NO, NO, },
		{ L1, NO, E1 | L1, NO, E2, NO, },
		{ NO, NO, L2, E1 | L2, NO, E2, },
		{ NO, L1, NO, NO, L1 | E2, E1, },
		{ NO, NO, NO, L1, L2, E1 | L1 | E2 | L2, },
	};

#undef NO
#undef E1
#undef L1
#undef E2
#undef L2

//  returns fTrue if the specified control word is in a legal state

BOOL CBinaryLock::_FValidStateTransition( const ControlWord cwBI, const ControlWord cwAI, const TransitionReason tr )
	{
	//  convert the specified control words into state numbers

	const int stateBI = _StateFromControlWord( cwBI );
	const int stateAI = _StateFromControlWord( cwAI );

	//  if either state is invalid, the transition is invalid

	if ( stateBI < 0 || stateAI < 0 )
		{
		return fFalse;
		}

	//  verify that cOOW2 and cOOW1 only change by +1, 0, -1, or go to 0

	const long dcOOW2 = ( ( cwAI & 0x7FFF0000 ) >> 16 ) - ( ( cwBI & 0x7FFF0000 ) >> 16 );
	if ( ( dcOOW2 < -1 || dcOOW2 > 1 ) && ( cwAI & 0x7FFF0000 ) != 0 )
		{
		return fFalse;
		}

	const long dcOOW1 = ( cwAI & 0x00007FFF ) - ( cwBI & 0x00007FFF );
	if ( ( dcOOW1 < -1 || dcOOW1 > 1 ) && ( cwAI & 0x00007FFF ) != 0 )
		{
		return fFalse;
		}

	//  return the reachability of stateAI from stateBI

	OSSYNCAssert( tr == trEnter1 || tr == trLeave1 || tr == trEnter2 || tr == trLeave2 );
	return ( mpstatestatetrmask[stateBI][stateAI] & tr ) != 0;
	}

//  wait for ownership of the lock as a member of Group 1

void CBinaryLock::_Enter1( const ControlWord cwBIOld )
	{
	//  we just jumped from state 1 to state 3

	if ( ( cwBIOld & 0x80008000 ) == 0x00008000 )
		{
		//  update the quiesced owner count with the owner count that we displaced from
		//  the control word, possibly releasing waiters.  we update the count as if we
		//  were a member of Group 2 as members of Group 1 can be released

		_UpdateQuiescedOwnerCountAsGroup2( ( cwBIOld & 0x7FFF0000 ) >> 16 );
		}

	//  wait for ownership of the lock on our semaphore

	State().AddAsWaiter( 0 );
	State().StartWait( 0 );
	
	State().m_sem1.Acquire();
	
	State().StopWait( 0 );
	State().RemoveAsWaiter( 0 );
	}

//  wait for ownership of the lock as a member of Group 2

void CBinaryLock::_Enter2( const ControlWord cwBIOld )
	{
	//  we just jumped from state 2 to state 4

	if ( ( cwBIOld & 0x80008000 ) == 0x80000000 )
		{
		//  update the quiesced owner count with the owner count that we displaced from
		//  the control word, possibly releasing waiters.  we update the count as if we
		//  were a member of Group 1 as members of Group 2 can be released

		_UpdateQuiescedOwnerCountAsGroup1( cwBIOld & 0x00007FFF );
		}

	//  wait for ownership of the lock on our semaphore

	State().AddAsWaiter( 1 );
	State().StartWait( 1 );
	
	State().m_sem2.Acquire();
	
	State().StopWait( 1 );
	State().RemoveAsWaiter( 1 );
	}

//  updates the quiesced owner count as a member of Group 1

void CBinaryLock::_UpdateQuiescedOwnerCountAsGroup1( const DWORD cOwnerDelta )
	{
	//  update the quiesced owner count using the provided delta

	const DWORD cOwnerBI = AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
	const DWORD cOwnerAI = cOwnerBI + cOwnerDelta;

	//  our update resulted in a zero quiesced owner count

	if ( !cOwnerAI )
		{
		//  we must release the waiters for Group 2 because we removed the last
		//  quiesced owner count

		//  try forever until we successfully change the lock state

		ControlWord cwBI;
		OSSYNC_FOREVER
			{
			//  read the current state of the control word as our expected before image

			const ControlWord cwBIExpected = State().m_cw;

			//  compute the after image of the control word such that we jump from state
			//  state 4 to state 1 or from state 5 to state 3, whichever is appropriate

			const ControlWord cwAI =	ControlWord( cwBIExpected &
										( ( ( LONG_PTR( long( ( cwBIExpected + 0xFFFF7FFF ) << 16 ) ) >> 31 ) &
										0xFFFF0000 ) ^ 0x8000FFFF ) );

			//  validate the transaction

			OSSYNCAssert( _FValidStateTransition( cwBIExpected, cwAI, trLeave1 ) );

			//  attempt to perform the transacted state transition on the control word

			cwBI = AtomicCompareExchange( (long*)&State().m_cw, cwBIExpected, cwAI );

			//  the transaction failed because another context changed the control word

			if ( cwBI != cwBIExpected )
				{
				//  try again

				continue;
				}

			//  the transaction succeeded

			else
				{
				//  we're done

				break;
				}
			}

		//  we just jumped from state 5 to state 3

		if ( cwBI & 0x00007FFF )
			{
			//  update the quiesced owner count with the owner count that we displaced
			//  from the control word
			//
			//  NOTE:  we do not have to worry about releasing any more waiters because
			//  either this context owns one of the owner counts or at least one context
			//  that owns an owner count are currently blocked on the semaphore

			const DWORD cOwnerDeltaT = ( cwBI & 0x7FFF0000 ) >> 16;
			AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDeltaT );
			}

		//  release the waiters for Group 2 that we removed from the lock state

		State().m_sem2.Release( ( cwBI & 0x7FFF0000 ) >> 16 );
		}
	}

//  updates the quiesced owner count as a member of Group 2

void CBinaryLock::_UpdateQuiescedOwnerCountAsGroup2( const DWORD cOwnerDelta )
	{
	//  update the quiesced owner count using the provided delta

	const DWORD cOwnerBI = AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
	const DWORD cOwnerAI = cOwnerBI + cOwnerDelta;

	//  our update resulted in a zero quiesced owner count

	if ( !cOwnerAI )
		{
		//  we must release the waiters for Group 1 because we removed the last
		//  quiesced owner count

		//  try forever until we successfully change the lock state

		ControlWord cwBI;
		OSSYNC_FOREVER
			{
			//  read the current state of the control word as our expected before image

			const ControlWord cwBIExpected = State().m_cw;

			//  compute the after image of the control word such that we jump from state
			//  state 3 to state 2 or from state 5 to state 4, whichever is appropriate

			const ControlWord cwAI =	ControlWord( cwBIExpected &
										( ( ( LONG_PTR( long( cwBIExpected + 0x7FFF0000 ) ) >> 31 ) &
										0x0000FFFF ) ^ 0xFFFF8000 ) );

			//  validate the transaction

			OSSYNCAssert( _FValidStateTransition( cwBIExpected, cwAI, trLeave2 ) );

			//  attempt to perform the transacted state transition on the control word

			cwBI = AtomicCompareExchange( (long*)&State().m_cw, cwBIExpected, cwAI );

			//  the transaction failed because another context changed the control word

			if ( cwBI != cwBIExpected )
				{
				//  try again

				continue;
				}

			//  the transaction succeeded

			else
				{
				//  we're done

				break;
				}
			}

		//  we just jumped from state 5 to state 4

		if ( cwBI & 0x7FFF0000 )
			{
			//  update the quiesced owner count with the owner count that we displaced
			//  from the control word
			//
			//  NOTE:  we do not have to worry about releasing any more waiters because
			//  either this context owns one of the owner counts or at least one context
			//  that owns an owner count are currently blocked on the semaphore

			const DWORD cOwnerDeltaT = cwBI & 0x00007FFF;
			AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDeltaT );
			}

		//  release the waiters for Group 1 that we removed from the lock state

		State().m_sem1.Release( cwBI & 0x00007FFF );
		}
	}


//  Reader / Writer Lock State

//  ctor

CReaderWriterLockState::CReaderWriterLockState( const CSyncBasicInfo& sbi )
	:	m_cw( 0 ),
		m_cOwner( 0 ),
		m_semWriter( sbi ),
		m_semReader( sbi )
	{
	}

//  dtor

CReaderWriterLockState::~CReaderWriterLockState()
	{
	}


//  Reader / Writer Lock


//  ctor

CReaderWriterLock::CReaderWriterLock( const CLockBasicInfo& lbi )
	:	CEnhancedStateContainer< CReaderWriterLockState, CSyncBasicInfo, CReaderWriterLockInfo, CLockBasicInfo >( (CSyncBasicInfo&) lbi, lbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CReaderWriterLock" );
	State().SetInstance( (CSyncObject*)this );
	}

//  dtor
	
CReaderWriterLock::~CReaderWriterLock()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	for ( int iGroup = 0; iGroup < 2; iGroup++ )
		{
		OSSyncStatsDump(	State().SzTypeName(),
							State().SzInstanceName(),
							State().Instance(),
							iGroup,
							State().CWaitTotal( iGroup ),
							State().CsecWaitElapsed( iGroup ),
							State().CAcquireTotal( iGroup ),
							State().CContendTotal( iGroup ),
							State().CHoldTotal( iGroup ),
							State().CsecHoldElapsed( iGroup ) );
		}

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  maps an arbitrary combination of zero and non-zero components into a
//  valid state number of the invalid state number (-1)

const int mpindexstateRW[16] =
	{
	 0, -1, -1, -1,
	-1, -1,  1, -1,
	-1,  2, -1,  3,
	-1, -1,  4,  5,
	};

//  returns the state number of the specified control word or -1 if it is not
//  a legal state

int CReaderWriterLock::_StateFromControlWord( const ControlWord cw )
	{
	//  convert the control word into a state index

	int index = 0;
	index = index | ( ( cw & 0x80000000 ) ? 8 : 0 );
	index = index | ( ( cw & 0x7FFF0000 ) ? 4 : 0 );
	index = index | ( ( cw & 0x00008000 ) ? 2 : 0 );
	index = index | ( ( cw & 0x00007FFF ) ? 1 : 0 );

	//  convert the state index into a state number

	const int state = mpindexstateRW[index];

	//  return the computed state number

	return state;
	}

//  state transition reachability matrix (starting state is the major axis)
//
//  each entry contains bits representing valid reasons for making the
//  transition (made by oring together the valid TransitionReasons)

#define NO	CReaderWriterLock::trIllegal
#define EW	CReaderWriterLock::trEnterAsWriter
#define LW	CReaderWriterLock::trLeaveAsWriter
#define ER	CReaderWriterLock::trEnterAsReader
#define LR	CReaderWriterLock::trLeaveAsReader

const DWORD mpstatestatetrmaskRW[6][6] =
	{
		{ NO, ER, EW, NO, NO, NO, },
		{ LR, ER | LR, NO, EW, NO, NO, },
		{ LW, NO, EW | LW, NO, ER, ER, },
		{ NO, NO, LR, EW | LR, NO, ER, },
		{ NO, LW, NO, NO, ER, EW, },
		{ NO, NO, NO, LW, LR, EW | ER | LR, },
	};

#undef NO
#undef EW
#undef LW
#undef ER
#undef LR

//  returns fTrue if the specified control word is in a legal state

BOOL CReaderWriterLock::_FValidStateTransition( const ControlWord cwBI, const ControlWord cwAI, const TransitionReason tr )
	{
	//  convert the specified control words into state numbers

	const int stateBI = _StateFromControlWord( cwBI );
	const int stateAI = _StateFromControlWord( cwAI );

	//  if either state is invalid, the transition is invalid

	if ( stateBI < 0 || stateAI < 0 )
		{
		return fFalse;
		}

	//  verify that cOOW2 and cOOW1 only change by +1, 0, -1, or cOOW2 can go to 0

	const long dcOOW2 = ( ( cwAI & 0x7FFF0000 ) >> 16 ) - ( ( cwBI & 0x7FFF0000 ) >> 16 );
	if ( ( dcOOW2 < -1 || dcOOW2 > 1 ) && ( cwAI & 0x7FFF0000 ) != 0 )
		{
		return fFalse;
		}

	const long dcOOW1 = ( cwAI & 0x00007FFF ) - ( cwBI & 0x00007FFF );
	if ( dcOOW1 < -1 || dcOOW1 > 1 )
		{
		return fFalse;
		}

	//  return the reachability of stateAI from stateBI

	OSSYNCAssert(	tr == trEnterAsWriter ||
			tr == trLeaveAsWriter ||
			tr == trEnterAsReader ||
			tr == trLeaveAsReader );
	return ( mpstatestatetrmaskRW[stateBI][stateAI] & tr ) != 0;
	}

//  wait for ownership of the lock as a writer

void CReaderWriterLock::_EnterAsWriter( const ControlWord cwBIOld )
	{
	//  we just jumped from state 1 to state 3

	if ( ( cwBIOld & 0x80008000 ) == 0x00008000 )
		{
		//  update the quiesced owner count with the owner count that we displaced from
		//  the control word, possibly releasing a waiter.  we update the count as if we
		//  were a reader as a writer can be released

		_UpdateQuiescedOwnerCountAsReader( ( cwBIOld & 0x7FFF0000 ) >> 16 );
		}

	//  wait for ownership of the lock on our semaphore

	State().AddAsWaiter( 0 );
	State().StartWait( 0 );
	
	State().m_semWriter.Acquire();
	
	State().StopWait( 0 );
	State().RemoveAsWaiter( 0 );
	}

//  wait for ownership of the lock as a reader

void CReaderWriterLock::_EnterAsReader( const ControlWord cwBIOld )
	{
	//  we just jumped from state 2 to state 4 or from state 2 to state 5

	if ( ( cwBIOld & 0x80008000 ) == 0x80000000 )
		{
		//  update the quiesced owner count with the owner count that we displaced from
		//  the control word, possibly releasing waiters.  we update the count as if we
		//  were a writer as readers can be released

		_UpdateQuiescedOwnerCountAsWriter( 0x00000001 );
		}

	//  wait for ownership of the lock on our semaphore

	State().AddAsWaiter( 1 );
	State().StartWait( 1 );
	
	State().m_semReader.Acquire();
	
	State().StopWait( 1 );
	State().RemoveAsWaiter( 1 );
	}

//  updates the quiesced owner count as a writer

void CReaderWriterLock::_UpdateQuiescedOwnerCountAsWriter( const DWORD cOwnerDelta )
	{
	//  update the quiesced owner count using the provided delta

	const DWORD cOwnerBI = AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
	const DWORD cOwnerAI = cOwnerBI + cOwnerDelta;

	//  our update resulted in a zero quiesced owner count

	if ( !cOwnerAI )
		{
		//  we must release the waiting readers because we removed the last
		//  quiesced owner count

		//  try forever until we successfully change the lock state

		ControlWord cwBI;
		OSSYNC_FOREVER
			{
			//  read the current state of the control word as our expected before image

			const ControlWord cwBIExpected = State().m_cw;

			//  compute the after image of the control word such that we jump from state
			//  state 4 to state 1 or from state 5 to state 3, whichever is appropriate

			const ControlWord cwAI =	ControlWord( cwBIExpected &
										( ( ( LONG_PTR( long( ( cwBIExpected + 0xFFFF7FFF ) << 16 ) ) >> 31 ) &
										0xFFFF0000 ) ^ 0x8000FFFF ) );

			//  validate the transaction

			OSSYNCAssert( _FValidStateTransition( cwBIExpected, cwAI, trLeaveAsWriter ) );

			//  attempt to perform the transacted state transition on the control word

			cwBI = AtomicCompareExchange( (long*)&State().m_cw, cwBIExpected, cwAI );

			//  the transaction failed because another context changed the control word

			if ( cwBI != cwBIExpected )
				{
				//  try again

				continue;
				}

			//  the transaction succeeded

			else
				{
				//  we're done

				break;
				}
			}

		//  we just jumped from state 5 to state 3

		if ( cwBI & 0x00007FFF )
			{
			//  update the quiesced owner count with the owner count that we displaced
			//  from the control word
			//
			//  NOTE:  we do not have to worry about releasing any more waiters because
			//  either this context owns one of the owner counts or at least one context
			//  that owns an owner count are currently blocked on the semaphore

			const DWORD cOwnerDeltaT = ( cwBI & 0x7FFF0000 ) >> 16;
			AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDeltaT );
			}

		//  release the waiting readers that we removed from the lock state

		State().m_semReader.Release( ( cwBI & 0x7FFF0000 ) >> 16 );
		}
	}

//  updates the quiesced owner count as a reader

void CReaderWriterLock::_UpdateQuiescedOwnerCountAsReader( const DWORD cOwnerDelta )
	{
	//  update the quiesced owner count using the provided delta

	const DWORD cOwnerBI = AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
	const DWORD cOwnerAI = cOwnerBI + cOwnerDelta;

	//  our update resulted in a zero quiesced owner count

	if ( !cOwnerAI )
		{
		//  we must release a waiting writer because we removed the last
		//  quiesced owner count

		//  try forever until we successfully change the lock state

		ControlWord cwBI;
		OSSYNC_FOREVER
			{
			//  read the current state of the control word as our expected before image

			const ControlWord cwBIExpected = State().m_cw;

			//  compute the after image of the control word such that we jump from state
			//  state 3 to state 2, from state 5 to state 4, or from state 5 to state 5,
			//  whichever is appropriate

			const ControlWord cwAI =	cwBIExpected + ( ( cwBIExpected & 0x7FFF0000 ) ?
											0xFFFFFFFF :
											0xFFFF8000 );

			//  validate the transaction

			OSSYNCAssert( _FValidStateTransition( cwBIExpected, cwAI, trLeaveAsReader ) );

			//  attempt to perform the transacted state transition on the control word

			cwBI = AtomicCompareExchange( (long*)&State().m_cw, cwBIExpected, cwAI );

			//  the transaction failed because another context changed the control word

			if ( cwBI != cwBIExpected )
				{
				//  try again

				continue;
				}

			//  the transaction succeeded

			else
				{
				//  we're done

				break;
				}
			}

		//  we just jumped from state 5 to state 4 or from state 5 to state 5

		if ( cwBI & 0x7FFF0000 )
			{
			//  update the quiesced owner count with the owner count that we displaced
			//  from the control word
			//
			//  NOTE:  we do not have to worry about releasing any more waiters because
			//  either this context owns one of the owner counts or at least one context
			//  that owns an owner count are currently blocked on the semaphore

			AtomicExchangeAdd( (long*)&State().m_cOwner, 1 );
			}

		//  release the waiting writer that we removed from the lock state

		State().m_semWriter.Release();
		}
	}


//  S / X / W Latch State

//  ctor

CSXWLatchState::CSXWLatchState( const CSyncBasicInfo& sbi )
	:	m_cw( 0 ),
		m_cQS( 0 ),
		m_semS( sbi ),
		m_semX( sbi ),
		m_semW( sbi )
	{
	}

//  dtor

CSXWLatchState::~CSXWLatchState()
	{
	}


//  S / X / W Latch


//  ctor

CSXWLatch::CSXWLatch( const CLockBasicInfo& lbi )
	:	CEnhancedStateContainer< CSXWLatchState, CSyncBasicInfo, CSXWLatchInfo, CLockBasicInfo >( (CSyncBasicInfo&) lbi, lbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CSXWLatch" );
	State().SetInstance( (CSyncObject*)this );
	}

//  dtor
	
CSXWLatch::~CSXWLatch()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	for ( int iGroup = 0; iGroup < 3; iGroup++ )
		{
		OSSyncStatsDump(	State().SzTypeName(),
							State().SzInstanceName(),
							State().Instance(),
							iGroup,
							State().CWaitTotal( iGroup ),
							State().CsecWaitElapsed( iGroup ),
							State().CAcquireTotal( iGroup ),
							State().CContendTotal( iGroup ),
							State().CHoldTotal( iGroup ),
							State().CsecHoldElapsed( iGroup ) );
		}

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}


};  //  namespace OSSYNC


//////////////////////////////////////////////////
//  Everything below this line is OS dependent


#include <nt.h>
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif  //  WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <imagehlp.h>
#include <wdbgexts.h>

#include <math.h>
#include <process.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <tchar.h>

namespace OSSYNC {


//  Global Synchronization Constants

//    wait time used for testing the state of the kernel object

const int cmsecTest = 0;

//    wait time used for infinite wait on a kernel object

const int cmsecInfinite = INFINITE;

//    maximum wait time on a kernel object before a deadlock is suspected

const int cmsecDeadlock = 600000;

//    wait time used for infinite wait on a kernel object without deadlock

const int cmsecInfiniteNoDeadlock = INFINITE - 1;

//    cache line size
//
//		the following chart describes cache-line configurations for each supported
//		architecture.
//
//		cache line size			= read size (prefetch)
//		cache line sector size	= write size (flush)
//
//
//		Pocessor	Cache Line Size		Cache Line Sector Size
//
//		Pentium			16B					16B
//		PPro			32B					32B
//		PII				32B					32B
//		PIII			32B					32B
//		AXP				64B					64B
//		Willamette		128B				64B
//		Merced			128B?				128B?
//
//		NOTE:	when changing this, you must fix all structures/classes whose definitions
//			 	are based on its present value
//				(e.g. the object has space rsvd as filler for the rest of the cache line)

const int cbCacheLine = 32;


//  Page Memory Allocation

//  reserves and commits a range of virtual addresses of the specifed size,
//  returning NULL if there is insufficient address space or backing store to
//  satisfy the request.  Note that the page reserve granularity applies to
//  this range

void* PvPageAlloc( const size_t cbSize, void* const pv )
	{
	//  allocate address space and backing store of the specified size

	void* const pvRet = VirtualAlloc( pv, cbSize, MEM_COMMIT, PAGE_READWRITE );
	if ( !pvRet )
		{
		return pvRet;
		}
	OSSYNCAssert( !pv || pvRet == pv );

	return pvRet;
	}

//  free the reserved range of virtual addresses starting at the specified
//  address, freeing any backing store committed to this range

void PageFree( void* const pv )
	{
	if ( pv )
		{
		//  free backing store and address space for the specified range

		BOOL fMemFreed = VirtualFree( pv, 0, MEM_RELEASE );
		OSSYNCAssert( fMemFreed );
		}
	}


//  Context Local Storage

//  Internal CLS structure

struct _CLS
	{
	DWORD				cAttach;		//  context attach refcount
	DWORD				dwContextId;	//  context ID
	HANDLE				hContext;		//  context handle

	_CLS*				pclsNext;		//  next CLS in global list
	_CLS**				ppclsNext;		//  pointer to the pointer to this CLS

	CLS					cls;			//  external CLS structure
	};

//  Global CLS List

CRITICAL_SECTION csClsSyncGlobal;
_CLS* pclsSyncGlobal;
_CLS* pclsSyncCleanGlobal;
DWORD cclsSyncGlobal;

//  Allocated CLS Entries

//NOTE:	Cannot initialise this variable because the code that allocates
//		TLS and uses this variable to store the index executes before
//		CRTInit, which would subsequently re-initialise the variable
//		with the value specified here
//DWORD dwClsSyncIndex		= dwClsInvalid;
//DWORD dwClsProcIndex		= dwClsInvalid;
DWORD		dwClsSyncIndex;
DWORD		dwClsProcIndex;

const DWORD	dwClsInvalid			= 0xFFFFFFFF;		//	this is the value returned by TlsAlloc() on error

const long	lOSSyncUnlocked			= 0x7fffffff;
const long	lOSSyncLocked			= 0x80000000;
const long	lOSSyncLockedForInit	= 0x80000001;
const long	lOSSyncLockedForTerm	= 0x80000000;

static BOOL	FOSSyncIInit();
static void	OSSyncITerm();
static void	OSSyncIDetach( _CLS* pcls );

//  registers the given CLS structure as the CLS for this context

BOOL FOSSyncIClsRegister( _CLS* pcls )
	{
	BOOL	fAllocatedCls	= fFalse;

	//  we are the first to register CLS

	EnterCriticalSection( &csClsSyncGlobal );

	if ( NULL == pclsSyncGlobal )
		{
		//  allocate our CLS entries
		
		dwClsSyncIndex = TlsAlloc();
		if ( dwClsInvalid == dwClsSyncIndex )
			{
			LeaveCriticalSection( &csClsSyncGlobal );
			return fFalse;
			}
			
		dwClsProcIndex = TlsAlloc();
		if ( dwClsInvalid == dwClsProcIndex )
			{
			const BOOL	fTLSFreed	= TlsFree( dwClsSyncIndex );
			OSSYNCAssert( fTLSFreed );		//	leak the TLS entries if we fail
			dwClsSyncIndex = dwClsInvalid;

			LeaveCriticalSection( &csClsSyncGlobal );
			return fFalse;
			}

		fAllocatedCls = fTrue;
		}

	OSSYNCAssert( dwClsInvalid != dwClsSyncIndex );
	OSSYNCAssert( dwClsInvalid != dwClsProcIndex );

	//  save the pointer to the given CLS

	const BOOL	fTLSPointerSet	= TlsSetValue( dwClsSyncIndex, pcls );
	if ( !fTLSPointerSet )
		{
		if ( fAllocatedCls )
			{
			OSSYNCAssert( NULL == pclsSyncGlobal );

			const BOOL	fTLSFreed1	= TlsFree( dwClsSyncIndex );
			const BOOL	fTLSFreed2	= TlsFree( dwClsProcIndex );

			OSSYNCAssert( fTLSFreed1 );		//	leak the TLS entries if we fail
			OSSYNCAssert( fTLSFreed2 );

			dwClsSyncIndex = dwClsInvalid;
			dwClsProcIndex = dwClsInvalid;
			}

		LeaveCriticalSection( &csClsSyncGlobal );
		return fFalse;
		}

	//  add this CLS into the global list

	pcls->pclsNext = pclsSyncGlobal;
	if ( pcls->pclsNext )
		{
		pcls->pclsNext->ppclsNext = &pcls->pclsNext;
		}
	pcls->ppclsNext = &pclsSyncGlobal;
	pclsSyncGlobal = pcls;
	cclsSyncGlobal++;
	OSSYNCEnforceSz(	cclsSyncGlobal <= 32768,
				"Too many threads are attached to the Synchronization Library!" );

	//  try to cleanup two entries in the global CLS list

	for ( int i = 0; i < 2; i++ )
		{
		//  we have a CLS to clean

		_CLS* pclsClean = pclsSyncCleanGlobal ? pclsSyncCleanGlobal : pclsSyncGlobal;

		if ( pclsClean )
			{
			//  set the next CLS to clean

			pclsSyncCleanGlobal = pclsClean->pclsNext;

			//  we can cleanup this CLS if the thread has exited
			
			DWORD dwExitCode;
            if (	pclsClean->hContext &&
            		GetExitCodeThread( pclsClean->hContext, &dwExitCode ) &&
            		dwExitCode != STILL_ACTIVE )
				{
				//  detach this CLS

				OSSyncIDetach( pclsClean );
				}
			}
		}

	LeaveCriticalSection( &csClsSyncGlobal );
	return fTrue;
	}

//  unregisters the given CLS structure as the CLS for this context

void OSSyncIClsUnregister( _CLS* pcls )
	{
	//  there should be CLSs registered

	EnterCriticalSection( &csClsSyncGlobal );
	OSSYNCAssert( pclsSyncGlobal != NULL );

	//  make sure that the clean pointer is not pointing at this CLS

	if ( pclsSyncCleanGlobal == pcls )
		{
		pclsSyncCleanGlobal = pcls->pclsNext;
		}
	
	//  remove our CLS from the global CLS list
	
	if( pcls->pclsNext )
		{
		pcls->pclsNext->ppclsNext = pcls->ppclsNext;
		}
	*( pcls->ppclsNext ) = pcls->pclsNext;
	cclsSyncGlobal--;

	//  we are the last to unregister our CLS

	if ( pclsSyncGlobal == NULL )
		{
		//  deallocate CLS entries

		OSSYNCAssert( dwClsInvalid != dwClsSyncIndex );
		OSSYNCAssert( dwClsInvalid != dwClsProcIndex );

		const BOOL	fTLSFreed1	= TlsFree( dwClsSyncIndex );
		const BOOL	fTLSFreed2	= TlsFree( dwClsProcIndex );

		OSSYNCAssert( fTLSFreed1 );		//	leak the TLS entries if we fail
		OSSYNCAssert( fTLSFreed2 );

		dwClsSyncIndex = dwClsInvalid;
		dwClsProcIndex = dwClsInvalid;
		}

	LeaveCriticalSection( &csClsSyncGlobal );
	}
	
//  attaches to the current context, returning fFalse on failure

static BOOL OSSYNCAPI FOSSyncIAttach()
	{
	//  we don't yet have any CLS

	_CLS* pcls = ( NULL != pclsSyncGlobal ?
						reinterpret_cast<_CLS *>( TlsGetValue( dwClsSyncIndex ) ) :
						NULL );
	if ( NULL == pcls )
		{
		//  allocate memory for this context's CLS

		if ( !( pcls = (_CLS*) LocalAlloc( LMEM_ZEROINIT, sizeof( _CLS ) ) ) )
			{
			return fFalse;
			}

		//  initialize internal CLS fields

		pcls->dwContextId	= GetCurrentThreadId();
		if ( DuplicateHandle(	GetCurrentProcess(),
								GetCurrentThread(),
								GetCurrentProcess(),
								&pcls->hContext,
								THREAD_QUERY_INFORMATION,
								FALSE,
								0 ) )
			{
			SetHandleInformation( pcls->hContext, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
			}


		//  register our CLS

		if ( !FOSSyncIClsRegister( pcls ) )
			{
			if ( pcls->hContext )
				{
				SetHandleInformation( pcls->hContext, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
				CloseHandle( pcls->hContext );
				}
			LocalFree( (void*) pcls );
			return fFalse;
			}

		//  set our initial processor number to be defer init

		OSSyncSetCurrentProcessor( -1 );
		}

	//	UNDONE: this refcount is currently not correctly maintained/respected
	pcls->cAttach++;

	return fTrue;
	}

BOOL OSSYNCAPI FOSSyncAttach()
	{
	//  make sure we are initialized
	//	add add ref for this thread
	if ( FOSSyncIInit() )
		{
		if ( FOSSyncIAttach() )
			{
			return fTrue;
			}
		else
			{
			//	deref this thread
			OSSyncITerm();
			}
		}

	return fFalse;
	}

//  detaches from the specified context

static void OSSyncIDetach( _CLS* pcls )
	{
#ifdef SYNC_DEADLOCK_DETECTION
	//	UNDONE: detect if we're trying to detach
	//	when this context is holding locks
#endif	

	//  unregister our CLS

	OSSyncIClsUnregister( pcls );

	//  close our context handle

	if ( pcls->hContext )
		{
		SetHandleInformation( pcls->hContext, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		const BOOL	fCloseOK	= CloseHandle( pcls->hContext );
		OSSYNCAssert( fCloseOK );
		}

	//  free our CLS

	const BOOL	fFreedCLSOK	= !LocalFree( pcls );
	OSSYNCAssert( fFreedCLSOK );

	//	deref this thread
	OSSyncITerm();
	}

//  detaches from the current context

void OSSYNCAPI OSSyncDetach()
	{
    //  save our CLS pointer

    _CLS* pcls = ( NULL != pclsSyncGlobal ?
    					reinterpret_cast<_CLS *>( TlsGetValue( dwClsSyncIndex ) ) :
    					NULL );

	//  deref our CLS

	if ( pcls )
		{
		//  clear our CLS pointer from our TLS entry

		const BOOL	fTLSPointerSet	= TlsSetValue( dwClsSyncIndex, NULL );
		OSSYNCAssert( fTLSPointerSet );

		//  detech using this CLS pointer

		OSSyncIDetach( pcls );
		}
	}


//  returns the pointer to the current context's local storage.  if the context
//  does not yet have CLS, allocate it.

CLS* const OSSYNCAPI Pcls()
	{
	_CLS* pcls = ( NULL != pclsSyncGlobal ?
						reinterpret_cast<_CLS *>( TlsGetValue( dwClsSyncIndex ) ) :
						NULL );
	if ( NULL == pcls )
		{
		while ( !FOSSyncAttach() )
			{
			Sleep( 1000 );
			}

		OSSYNCAssert( dwClsInvalid != dwClsSyncIndex );
		pcls = reinterpret_cast<_CLS *>( TlsGetValue( dwClsSyncIndex ) );
		}

	OSSYNCAssert( NULL != pcls );
	return &( pcls->cls );
	}


//  Processor Information

//  returns the maximum number of processors this process can utilize

DWORD g_cProcessorMax;

int OSSYNCAPI OSSyncGetProcessorCountMax()
	{
	return g_cProcessorMax;
	}

//  returns the current number of processors this process can utilize

DWORD g_cProcessor;

int OSSYNCAPI OSSyncGetProcessorCount()
	{
	return g_cProcessor;
	}

//  returns the processor number that the current context _MAY_ be executing on
//
//  NOTE:  the current context may change processors at any time

BOOL g_fGetCurrentProcFromTEB;

int OSSYNCAPI OSSyncGetCurrentProcessor()
	{
	//  HACK:  we cannot currently determine the current processor that this
	//  HACK:  thread is executing on in user mode so we must fake it for
	//  HACK:  now with a realistic number.  hopefully, NT will give us this
	//  HACK:  number some day.  in the mean time, we will use either the value
	//  HACK:  set via OSSyncSetCurrentProcessor(), the thread's existing soft/
	//  HACK:  hard affinity, or a random number

//	NT:338172: Silence the following assert, because it's possible
//	to have an invalid dwClsProcIndex in the init code path if the
//	thread initialising Jet was present before ESENT.DLL was
//	LoadLibrary()'d (in which case DLL_THREAD_ATTACH is not
//	called for the thread).  For such a case, TlsGetValue()
//	will return 0, which is fine (we'll just use that as
//	the iProc to use).
///	OSSYNCAssert( dwClsInvalid != dwClsProcIndex );

	int iProc = (	g_fGetCurrentProcFromTEB ?
						NtCurrentTeb()->IdealProcessor:
						int( INT_PTR( TlsGetValue( dwClsProcIndex ) ) ) );

	//  we don't know what number to return yet

	if ( iProc == -1 )
		{
		//  get the current thread's soft affinity via a destructive read

		iProc = SetThreadIdealProcessor( GetCurrentThread(), MAXIMUM_PROCESSORS );
		SetThreadIdealProcessor( GetCurrentThread(), iProc );

		//  if there is no soft affinity then choose a random soft affinity
		
		if ( iProc == -1 || iProc == MAXIMUM_PROCESSORS )
			{
			iProc = abs( ( _rotr( GetCurrentThreadId(), 8 ) % 997 ) % OSSyncGetProcessorCount() );
			}

		//  get the current process' hard affinity

		DWORD_PTR	dwMaskProc;
		DWORD_PTR	dwMaskSys;
		GetProcessAffinityMask( GetCurrentProcess(), &dwMaskProc, &dwMaskSys );

		//  get the current thread's hard affinity via a destructive read

		DWORD_PTR	dwMask;
		dwMask = SetThreadAffinityMask( GetCurrentThread(), dwMaskProc );
		SetThreadAffinityMask( GetCurrentThread(), dwMask );
		dwMask = dwMask ? dwMask : dwMaskProc;

		//  compute the processor number to conform first to the hard affinity
		//  and then to the soft affinity.  if the soft affinity is to a proc
		//  that the thread cannot use due to its hard affinity then use
		//  the soft affinity to hash across the processors that it can run on

		int ibit;
		int cbitSet;
		for ( ibit = 0, cbitSet = 0; ibit < sizeof( dwMask ) * 8; ibit++ )
			{
			if ( dwMask & ( 1 << ibit ) )
				{
				cbitSet++;
				}
			}
		int ibitSet;
		int ibitBest;
		for ( ibit = 0, ibitSet = 0, ibitBest = 0; ibit < sizeof( dwMask ) * 8; ibit++ )
			{
			if ( dwMask & ( 1 << ibit ) )
				{
				if ( ibitSet == iProc % cbitSet )
					{
					ibitBest = ibit;
					}
				ibitSet++;
				}
			}
		if ( dwMask & ( 1 << iProc ) )
			{
			ibitBest = iProc;
			}
		iProc = ibitBest;
		
		//  remember our newly computed processor number
		
		OSSyncSetCurrentProcessor( iProc );
		}

	return iProc;
	}

//  sets the processor number returned by OSSyncGetCurrentProcessor()

void OSSYNCAPI OSSyncSetCurrentProcessor( const int iProc )
	{
	OSSYNCAssert( dwClsInvalid != dwClsProcIndex );
	TlsSetValue( dwClsProcIndex, (void*) INT_PTR( iProc == -1 ? -1 : iProc % OSSyncGetProcessorCount() ) );
	}


//  Processor Local Storage

void* g_rgPLS[ MAXIMUM_PROCESSORS ];

//  configures the size of processor local storage

BOOL OSSYNCAPI FOSSyncConfigureProcessorLocalStorage( const size_t cbPLS )
	{
	//  PLS is aligned on very large boundaries to make darn sure its isolated
	
	const size_t	cbAlign		= 256;
	const size_t	cbPLSAlign	= ( ( cbPLS + cbAlign - 1 ) / cbAlign ) * cbAlign;

	//  if PLS already exists then release it

	if ( g_rgPLS[ 0 ] )
		{
		VirtualFree( g_rgPLS[ 0 ], 0, MEM_RELEASE );
		memset( g_rgPLS, 0, sizeof( g_rgPLS ) );
		}

	//  allocate room for the new PLS, if requested

	if ( cbPLS )
		{
		if ( g_rgPLS[ 0 ] = VirtualAlloc( NULL, g_cProcessorMax * cbPLSAlign, MEM_COMMIT, PAGE_READWRITE ) )
			{
			for ( size_t iPLS = 1; iPLS < g_cProcessorMax; iPLS++ )
				{
				g_rgPLS[ iPLS ] = (BYTE*)g_rgPLS[ 0 ] + cbPLSAlign * iPLS;
				}
			}
		}

	return cbPLS == 0 || g_rgPLS[ 0 ] != NULL;
	}

//  retrieves a pointer to the current context's processor local storage

void* OSSYNCAPI OSSyncGetProcessorLocalStorage()
	{
	if ( g_fGetCurrentProcFromTEB )
		{
		return g_rgPLS[ NtCurrentTeb()->IdealProcessor ];
		}
	else
		{
		return g_rgPLS[ OSSyncGetCurrentProcessor() ];
		}
	}

//  retrieves a pointer to a given processor's local storage

void* OSSYNCAPI OSSyncGetProcessorLocalStorage( const size_t iProc )
	{
	return iProc < g_cProcessorMax ? g_rgPLS[ iProc ] : NULL;
	}


//  High Resolution Timer

#if defined( _M_IX86 ) && defined( SYNC_USE_X86_ASM )

//    QWORDX - used for 32 bit access to a 64 bit integer
//	  For intel pentium only

union QWORDX {
		QWORD	qw;
		struct
			{
			DWORD l;
			DWORD h;
			};
		};
#endif

//    High Resolution Timer Type

enum HRTType
	{
	hrttNone,
	hrttWin32,
#if defined( _M_IX86 ) && defined( SYNC_USE_X86_ASM )
	hrttPentium,
#endif  //  _M_IX86 && SYNC_USE_X86_ASM
	} hrttSync;

//    HRT Frequency

QWORD qwSyncHRTFreq;

#if defined( _M_IX86 ) && defined( SYNC_USE_X86_ASM )

//    Pentium Time Stamp Counter Fetch

#define rdtsc __asm _emit 0x0f __asm _emit 0x31

#endif  //  _MM_IX86 && SYNC_USE_X86_ASM

//  returns fTrue if we are allowed to use RDTSC

BOOL IsRDTSCAvailable()
	{
	typedef WINBASEAPI BOOL WINAPI PFNIsProcessorFeaturePresent( IN DWORD ProcessorFeature );

	HMODULE							hmodKernel32					= NULL;
	PFNIsProcessorFeaturePresent*	pfnIsProcessorFeaturePresent	= NULL;
	BOOL							fRDTSCAvailable					= fFalse;

	if ( !( hmodKernel32 = GetModuleHandle( _T( "kernel32.dll" ) ) ) )
		{
		goto NoIsProcessorFeaturePresent;
		}
	if ( !( pfnIsProcessorFeaturePresent = (PFNIsProcessorFeaturePresent*)GetProcAddress( hmodKernel32, _T( "IsProcessorFeaturePresent" ) ) ) )
		{
		goto NoIsProcessorFeaturePresent;
		}

	fRDTSCAvailable = pfnIsProcessorFeaturePresent( PF_RDTSC_INSTRUCTION_AVAILABLE );

NoIsProcessorFeaturePresent:
	return fRDTSCAvailable;
	}

//  initializes the HRT subsystem

void OSTimeHRTInit()
	{
	//  if we have already been initialized, we're done

	if ( qwSyncHRTFreq )
		{
		return;
		}

	//  Win32 high resolution counter is available

	if ( QueryPerformanceFrequency( (LARGE_INTEGER *) &qwSyncHRTFreq ) )
		{
		hrttSync = hrttWin32;
		}

	//  Win32 high resolution counter is not available
	
	else

		{
		//  fall back on GetTickCount() (ms since Windows has started)
		
		qwSyncHRTFreq = 1000;
		hrttSync = hrttNone;
		}

#if defined( _M_IX86 ) && defined( SYNC_USE_X86_ASM )

	//  can we use the TSC?
	
	if ( IsRDTSCAvailable() )
		{
		//  use pentium TSC register, but first find clock frequency experimentally
		
		QWORDX qwxTime1a;
		QWORDX qwxTime1b;
		QWORDX qwxTime2a;
		QWORDX qwxTime2b;
		if ( hrttSync == hrttWin32 )
			{
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime1a.l,eax	//lint !e530
			__asm mov		qwxTime1a.h,edx	//lint !e530
			QueryPerformanceCounter( (LARGE_INTEGER*) &qwxTime1b.qw );
			Sleep( 50 );
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime2a.l,eax	//lint !e530
			__asm mov		qwxTime2a.h,edx	//lint !e530
			QueryPerformanceCounter( (LARGE_INTEGER*) &qwxTime2b.qw );
			qwSyncHRTFreq =	( qwSyncHRTFreq * ( qwxTime2a.qw - qwxTime1a.qw ) ) /
						( qwxTime2b.qw - qwxTime1b.qw );
			qwSyncHRTFreq = ( ( qwSyncHRTFreq + 50000 ) / 100000 ) * 100000;
			}
		else
			{
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime1a.l,eax
			__asm mov		qwxTime1a.h,edx
			qwxTime1b.l = GetTickCount();
			qwxTime1b.h = 0;
			Sleep( 2000 );
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime2a.l,eax
			__asm mov		qwxTime2a.h,edx
			qwxTime2b.l = GetTickCount();
			qwxTime2b.h = 0;
			qwSyncHRTFreq =	( qwSyncHRTFreq * ( qwxTime2a.qw - qwxTime1a.qw ) ) /
						( qwxTime2b.qw - qwxTime1b.qw );
			qwSyncHRTFreq = ( ( qwSyncHRTFreq + 500000 ) / 1000000 ) * 1000000;
			}

		hrttSync = hrttPentium;
		}
		
#endif  //  _M_IX86 && SYNC_USE_X86_ASM

	}

//  returns the current HRT frequency

QWORD OSSYNCAPI QwOSTimeHRTFreq()
	{
	return qwSyncHRTFreq;
	}

//  returns the current HRT count

QWORD OSSYNCAPI QwOSTimeHRTCount()
	{
	QWORD qw;

	switch ( hrttSync )
		{
		case hrttNone:
			qw = GetTickCount();
			break;

		case hrttWin32:
			QueryPerformanceCounter( (LARGE_INTEGER*) &qw );
			break;

#if defined( _M_IX86 ) && defined( SYNC_USE_X86_ASM )

		case hrttPentium:
			{
			QWORDX qwx;
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwx.l,eax
			__asm mov		qwx.h,edx

			qw = qwx.qw;
			}
			break;
			
#endif  //  _M_IX86 && SYNC_USE_X86_ASM

		}

	return qw;
	}


//  Timer

//  returns the current tick count where one tick is one millisecond

DWORD OSSYNCAPI DwOSTimeGetTickCount()
	{
	return GetTickCount();
	}


//  Atomic Memory Manipulations

#if defined( _M_IX86 ) && defined( SYNC_USE_X86_ASM )
#elif defined( _M_AMD64 ) || defined( _M_IA64 )
#else

//  atomically compares the current value of the target with the specified
//  initial value and if equal sets the target to the specified final value.
//  the initial value of the target is returned.  the exchange is successful
//  if the value returned equals the specified initial value.  the target
//  must be aligned to a four byte boundary

long OSSYNCAPI AtomicCompareExchange( long* const plTarget, const long lInitial, const long lFinal )
	{
	OSSYNCAssert( IsAtomicallyModifiable( plTarget ) );
	
	return InterlockedCompareExchange( plTarget, lFinal, lInitial );
	}
	
void* OSSYNCAPI AtomicCompareExchangePointer( void** const ppvTarget, void* const pvInitial, void* const pvFinal )
	{
	OSSYNCAssert( IsAtomicallyModifiablePointer( ppvTarget ) );
	
	return (void*) InterlockedCompareExchange( (long*) ppvTarget, (long) pvFinal, (long) pvInitial );
	}

//  atomically sets the target to the specified value, returning the target's
//  initial value.  the target must be aligned to a four byte boundary

long OSSYNCAPI AtomicExchange( long* const plTarget, const long lValue )
	{
	OSSYNCAssert( IsAtomicallyModifiable( plTarget ) );
	
	return InterlockedExchange( plTarget, lValue );
	}
	
void* OSSYNCAPI AtomicExchangePointer( void* const * ppvTarget, void* const pvValue )
	{
	OSSYNCAssert( IsAtomicallyModifiablePointer( ppvTarget ) );
	
	return (void*)InterlockedExchange( (long*) ppvTarget, (long) pvValue );
	}

//  atomically adds the specified value to the target, returning the target's
//  initial value.  the target must be aligned to a four byte boundary

long OSSYNCAPI AtomicExchangeAdd( long* const plTarget, const long lValue )
	{
	OSSYNCAssert( IsAtomicallyModifiable( plTarget ) );
	
	return InterlockedExchangeAdd( plTarget, lValue );
	}

#endif
//  Enhanced Synchronization Object State Container

struct MemoryBlock
	{
	MemoryBlock*	pmbNext;
	MemoryBlock**	ppmbNext;
	SIZE_T			cAlloc;
	SIZE_T			ibFreeMic;
	};

SIZE_T				g_cbMemoryBlock;
MemoryBlock*		g_pmbRoot;
MemoryBlock			g_mbSentry;
MemoryBlock*		g_pmbRootFree;
MemoryBlock			g_mbSentryFree;
CRITICAL_SECTION	g_csESMemory;

void* OSSYNCAPI ESMemoryNew( size_t cb )
	{
	if ( !FOSSyncInitForES() )
		{
		return NULL;
		}
		
	cb += sizeof( QWORD ) - 1;
	cb -= cb % sizeof( QWORD );
	
	EnterCriticalSection( &g_csESMemory );
	
	MemoryBlock* pmb = g_pmbRoot;

	if ( pmb->ibFreeMic + cb > g_cbMemoryBlock )
		{
		if ( g_pmbRootFree != &g_mbSentryFree )
			{
			pmb = g_pmbRootFree;
			
			*pmb->ppmbNext			= pmb->pmbNext;
			pmb->pmbNext->ppmbNext	= pmb->ppmbNext;
			}
		
		else if ( !( pmb = (MemoryBlock*) VirtualAlloc( NULL, g_cbMemoryBlock, MEM_COMMIT, PAGE_READWRITE ) ) )
			{
			LeaveCriticalSection( &g_csESMemory );
			OSSyncTermForES();
			return pmb;
			}
			
		pmb->pmbNext	= g_pmbRoot;
		pmb->ppmbNext	= &g_pmbRoot;
		pmb->cAlloc		= 0;
		pmb->ibFreeMic	= sizeof( MemoryBlock );

		g_pmbRoot->ppmbNext	= &pmb->pmbNext;
		g_pmbRoot			= pmb;
		}

	void* pv = (BYTE*)pmb + pmb->ibFreeMic;
	pmb->cAlloc++;
	pmb->ibFreeMic += cb;

	LeaveCriticalSection( &g_csESMemory );
	return pv;
	}
	
void OSSYNCAPI ESMemoryDelete( void* pv )
	{
	if ( pv )
		{
		EnterCriticalSection( &g_csESMemory );
		
		MemoryBlock* const pmb = (MemoryBlock*) ( UINT_PTR( pv ) - UINT_PTR( pv ) % g_cbMemoryBlock );
		
		if ( !( --pmb->cAlloc ) )
			{
			*pmb->ppmbNext = pmb->pmbNext;
			pmb->pmbNext->ppmbNext = pmb->ppmbNext;

			pmb->pmbNext	= g_pmbRootFree;
			pmb->ppmbNext	= &g_pmbRootFree;
			
			g_pmbRootFree->ppmbNext	= &pmb->pmbNext;
			g_pmbRootFree			= pmb;
			}

		LeaveCriticalSection( &g_csESMemory );

		OSSyncTermForES();
		}
	}


//  Synchronization Object Basic Information

//  ctor

CSyncBasicInfo::CSyncBasicInfo( const char* szInstanceName )
	{
#ifdef SYNC_ENHANCED_STATE

	m_szInstanceName	= szInstanceName;
	m_szTypeName		= NULL;
	m_psyncobj			= NULL;

#endif  //  SYNC_ENHANCED_STATE
	}

//  dtor

CSyncBasicInfo::~CSyncBasicInfo()
	{
	}
	

//  Synchronization Object Performance:  Wait Times

//  ctor

CSyncPerfWait::CSyncPerfWait()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	m_cWait = 0;
	m_qwHRTWaitElapsed = 0;

#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  dtor

CSyncPerfWait::~CSyncPerfWait()
	{
	}


//  Null Synchronization Object State Initializer

const CSyncStateInitNull syncstateNull;


//  Kernel Semaphore

//  ctor

CKernelSemaphore::CKernelSemaphore( const CSyncBasicInfo& sbi )
	:	CEnhancedStateContainer< CKernelSemaphoreState, CSyncStateInitNull, CKernelSemaphoreInfo, CSyncBasicInfo >( syncstateNull, sbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CKernelSemaphore" );
	State().SetInstance( (CSyncObject*)this );
	}

//  dtor

CKernelSemaphore::~CKernelSemaphore()
	{
	//  semaphore should not be initialized
	
	OSSYNCAssert( !FInitialized() );

#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	OSSyncStatsDump(	State().SzTypeName(),
						State().SzInstanceName(),
						State().Instance(),
						-1,
						State().CWaitTotal(),
						State().CsecWaitElapsed(),
						0,
						0,
						0,
						0 );

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  initialize the semaphore, returning 0 on failure

const BOOL CKernelSemaphore::FInit()
	{
	//  semaphore should not be initialized
	
	OSSYNCAssert( !FInitialized() );
	
	//  allocate kernel semaphore object

	State().SetHandle( CreateSemaphore( 0, 0, 0x7FFFFFFFL, 0 ) );

	if ( State().Handle() )
		{
		SetHandleInformation( State().Handle(), HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
		}
	
	//  semaphore should have no available counts, if allocated

	OSSYNCAssert( State().Handle() == 0 || FReset() );

	//  return result of init

	return State().Handle() != 0;
	}

//  terminate the semaphore

void CKernelSemaphore::Term()
	{
	//  semaphore should be initialized

	OSSYNCAssert( FInitialized() );
	
	//  semaphore should have no available counts

	OSSYNCAssert( FReset() );

	//  deallocate kernel semaphore object

	SetHandleInformation( State().Handle(), HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
	int fSuccess = CloseHandle( State().Handle() );
	OSSYNCAssert( fSuccess );

	//  reset state

	State().SetHandle( 0 );
	}

//  acquire one count of the semaphore, waiting only for the specified interval.
//  returns 0 if the wait timed out before a count could be acquired

const BOOL CKernelSemaphore::FAcquire( const int cmsecTimeout )
	{
	//  semaphore should be initialized

	OSSYNCAssert( FInitialized() );

	//  wait for semaphore

	BOOL fSuccess;

	if ( cmsecTimeout != cmsecTest )
		{
		AtomicIncOSSYNCCounter( (long *)&cOSSYNCThreadBlock );
		}
	State().StartWait();
	
#ifdef SYNC_DEADLOCK_DETECTION

	if ( cmsecTimeout == cmsecInfinite || cmsecTimeout > cmsecDeadlock )
		{
		fSuccess = WaitForSingleObjectEx( State().Handle(), cmsecDeadlock, FALSE ) == WAIT_OBJECT_0;
		
		OSSYNCAssertSzRTL( fSuccess, "Potential Deadlock Detected (Timeout)" );

		if ( !fSuccess )
			{
			const int cmsecWait =	cmsecTimeout == cmsecInfinite ?
										cmsecInfinite :
										cmsecTimeout - cmsecDeadlock;

			fSuccess = WaitForSingleObjectEx( State().Handle(), cmsecWait, FALSE ) == WAIT_OBJECT_0;
			}
		}
	else
		{
		OSSYNCAssert(	cmsecTimeout == cmsecInfiniteNoDeadlock ||
				cmsecTimeout <= cmsecDeadlock );

		const int cmsecWait =	cmsecTimeout == cmsecInfiniteNoDeadlock ?
									cmsecInfinite :
									cmsecTimeout;

		fSuccess = WaitForSingleObjectEx( State().Handle(), cmsecWait, FALSE ) == WAIT_OBJECT_0;
		}

#else  //  !SYNC_DEADLOCK_DETECTION

	const int cmsecWait =	cmsecTimeout == cmsecInfiniteNoDeadlock ?
								cmsecInfinite :
								cmsecTimeout;
	
	fSuccess = WaitForSingleObjectEx( State().Handle(), cmsecWait, FALSE ) == WAIT_OBJECT_0;
	
#endif  //  SYNC_DEADLOCK_DETECTION

	State().StopWait();
	if ( cmsecTimeout != cmsecTest )
		{
		AtomicIncOSSYNCCounter( (long *)&cOSSYNCThreadResume );
		}
	
	return fSuccess;
	}

//  releases the given number of counts to the semaphore, waking the appropriate
//  number of waiters

void CKernelSemaphore::Release( const int cToRelease )
	{
	//  semaphore should be initialized

	OSSYNCAssert( FInitialized() );

	//  release semaphore
	
	const BOOL fSuccess = ReleaseSemaphore( HANDLE( State().Handle() ), cToRelease, 0 );
	OSSYNCAssert( fSuccess );
	}


//  performance data dumping

#include<stdarg.h>
#include<stdio.h>
#include<tchar.h>

//  ================================================================
class CPrintF
//  ================================================================
	{
	public:
		CPrintF() {}
		virtual ~CPrintF() {}

	public:
		virtual void __cdecl operator()( const _TCHAR* szFormat, ... ) = 0;
	};

//  ================================================================
class CIPrintF : public CPrintF
//  ================================================================
	{
	public:
		CIPrintF( CPrintF* pprintf );
	
		void __cdecl operator()( const _TCHAR* szFormat, ... );

		virtual void Indent();
		virtual void Unindent();
		
	protected:
		CIPrintF();
		
	private:
		CPrintF* const		m_pprintf;
		int					m_cindent;
		BOOL				m_fBOL;
	};

//  ================================================================
inline CIPrintF::CIPrintF( CPrintF* pprintf ) :
//  ================================================================
	m_cindent( 0 ),
	m_pprintf( pprintf ),
	m_fBOL( fTrue )
	{
	}
	
//  ================================================================
inline void __cdecl CIPrintF::operator()( const _TCHAR* szFormat, ... )
//  ================================================================
	{
	_TCHAR szT[ 1024 ];
	va_list arg_ptr;
	va_start( arg_ptr, szFormat );
	_vstprintf( szT, szFormat, arg_ptr );
	va_end( arg_ptr );

	_TCHAR*	szLast	= szT;
	_TCHAR*	szCurr	= szT;
	while ( *szCurr )
		{
		if ( m_fBOL )
			{
			for ( int i = 0; i < m_cindent; i++ )
				{
				(*m_pprintf)( _T( "\t" ) );
				}
			m_fBOL = fFalse;
			}

		szCurr = szLast + _tcscspn( szLast, _T( "\r\n" ) );
		while ( *szCurr == _T( '\r' ) )
			{
			szCurr++;
			m_fBOL = fTrue;
			}
		if ( *szCurr == _T( '\n' ) )
			{
			szCurr++;
			m_fBOL = fTrue;
			}

		(*m_pprintf)( _T( "%.*s" ), szCurr - szLast, szLast );

		szLast = szCurr;
		}
	}

//  ================================================================
inline void CIPrintF::Indent()
//  ================================================================
	{
	++m_cindent;
	}

//  ================================================================
inline void CIPrintF::Unindent()
//  ================================================================
	{
	if ( m_cindent > 0 )
		{
		--m_cindent;
		}
	}

//  ================================================================
inline CIPrintF::CIPrintF( ) :
//  ================================================================
	m_cindent( 0 ),
	m_pprintf( 0 ),
	m_fBOL( fTrue )
	{
	}

//  ================================================================
class CFPrintF : public CPrintF
//  ================================================================
	{
	public:
		CFPrintF( const char* szFile );
		~CFPrintF();
		
		void __cdecl operator()( const char* szFormat, ... );
			
	private:
		void* m_hFile;
		void* m_hMutex;
	};

CFPrintF::CFPrintF( const char* szFile )
	{
	//  open the file for append

	if ( ( m_hFile = (void*)CreateFile( szFile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ) ) == INVALID_HANDLE_VALUE )
		{
		return;
		}
	SetHandleInformation( HANDLE( m_hFile ), HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	if ( !( m_hMutex = (void*)CreateMutex( NULL, FALSE, NULL ) ) )
		{
		SetHandleInformation( HANDLE( m_hFile ), HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( HANDLE( m_hFile ) );
		m_hFile = INVALID_HANDLE_VALUE;
		return;
		}
	SetHandleInformation( HANDLE( m_hMutex ), HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	}

CFPrintF::~CFPrintF()
	{
	//  close the file

	if ( m_hMutex )
		{
		SetHandleInformation( HANDLE( m_hMutex ), HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( HANDLE( m_hMutex ) );
		m_hMutex = NULL;
		}

	if ( m_hFile != INVALID_HANDLE_VALUE )
		{
		SetHandleInformation( HANDLE( m_hFile ), HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( HANDLE( m_hFile ) );
		m_hFile = INVALID_HANDLE_VALUE;
		}
	}

//  ================================================================
void __cdecl CFPrintF::operator()( const char* szFormat, ... )
//  ================================================================
	{
	if ( HANDLE( m_hFile ) != INVALID_HANDLE_VALUE )
		{
		const SIZE_T cchBuf = 1024;
		char szBuf[ cchBuf ];

		//  print into a temp buffer, truncating the string if too large
		
		va_list arg_ptr;
		va_start( arg_ptr, szFormat );
		_vsnprintf( szBuf, cchBuf - 1, szFormat, arg_ptr );
		szBuf[ cchBuf - 1 ] = 0;
		va_end( arg_ptr );
		
		//  append the string to the file

		WaitForSingleObject( HANDLE( m_hMutex ), INFINITE );

		SetFilePointer( HANDLE( m_hFile ), 0, NULL, FILE_END );

		DWORD cbWritten;
		WriteFile( HANDLE( m_hFile ), szBuf, DWORD( strlen( szBuf ) * sizeof( char ) ), &cbWritten, NULL );

		ReleaseMutex( HANDLE( m_hMutex ) );
		}
	}


#ifdef DEBUGGER_EXTENSION

#define LOCAL static


namespace OSSYM {

#include <imagehlp.h>
#include <psapi.h>


typedef DWORD IMAGEAPI WINAPI PFNUnDecorateSymbolName( PCSTR, PSTR, DWORD, DWORD );
typedef DWORD IMAGEAPI PFNSymSetOptions( DWORD );
typedef BOOL IMAGEAPI PFNSymCleanup( HANDLE );
typedef BOOL IMAGEAPI PFNSymInitialize( HANDLE, PSTR, BOOL );
typedef BOOL IMAGEAPI PFNSymGetSymFromAddr( HANDLE, DWORD_PTR, DWORD_PTR*, PIMAGEHLP_SYMBOL );
typedef BOOL IMAGEAPI PFNSymGetSymFromName( HANDLE, PSTR, PIMAGEHLP_SYMBOL );
typedef BOOL IMAGEAPI PFNSymGetSearchPath( HANDLE, PSTR, DWORD );
typedef BOOL IMAGEAPI PFNSymSetSearchPath( HANDLE, PSTR );
typedef BOOL IMAGEAPI PFNSymGetModuleInfo( HANDLE, DWORD_PTR, PIMAGEHLP_MODULE );
typedef DWORD IMAGEAPI PFNSymLoadModule( HANDLE, HANDLE, PSTR, PSTR, DWORD_PTR, DWORD );
typedef PIMAGE_NT_HEADERS IMAGEAPI PFNImageNtHeader( PVOID );

PFNUnDecorateSymbolName*	pfnUnDecorateSymbolName;
PFNSymSetOptions*			pfnSymSetOptions;
PFNSymCleanup*				pfnSymCleanup;
PFNSymInitialize*			pfnSymInitialize;
PFNSymGetSymFromAddr*		pfnSymGetSymFromAddr;
PFNSymGetSymFromName*		pfnSymGetSymFromName;
PFNSymGetSearchPath*		pfnSymGetSearchPath;
PFNSymSetSearchPath*		pfnSymSetSearchPath;
PFNSymGetModuleInfo*		pfnSymGetModuleInfo;
PFNSymLoadModule*			pfnSymLoadModule;
PFNImageNtHeader*			pfnImageNtHeader;

HMODULE hmodImagehlp;

typedef BOOL WINAPI PFNEnumProcessModules( HANDLE, HMODULE*, DWORD, LPDWORD );
typedef DWORD WINAPI PFNGetModuleFileNameExA( HANDLE, HMODULE, LPSTR, DWORD );
typedef DWORD WINAPI PFNGetModuleBaseNameA( HANDLE, HMODULE, LPSTR, DWORD );
typedef BOOL WINAPI PFNGetModuleInformation( HANDLE, HMODULE, LPMODULEINFO, DWORD );

PFNEnumProcessModules*		pfnEnumProcessModules;
PFNGetModuleFileNameExA*	pfnGetModuleFileNameExA;
PFNGetModuleBaseNameA*		pfnGetModuleBaseNameA;
PFNGetModuleInformation*	pfnGetModuleInformation;

HMODULE hmodPsapi;

LOCAL const DWORD symopt =	SYMOPT_CASE_INSENSITIVE |
							SYMOPT_UNDNAME |
							SYMOPT_OMAP_FIND_NEAREST |
							SYMOPT_DEFERRED_LOADS;
LOCAL CHAR szParentImageName[_MAX_FNAME];
LOCAL HANDLE ghDbgProcess;


//  ================================================================
LOCAL BOOL SymLoadAllModules( HANDLE hProcess )
//  ================================================================
	{
	HMODULE* rghmodDebuggee = NULL;

	//  fetch all modules in the debuggee process and manually load their symbols.
	//  we do this because telling imagehlp to invade the debugee process doesn't
	//  work when we are already running in the context of a debugger
	//
	DWORD cbNeeded;
	if ( !pfnEnumProcessModules( hProcess, NULL, 0, &cbNeeded ) )
		{
		goto HandleError;
		}

	DWORD cbActual;
	do	{
		cbActual = cbNeeded;
		rghmodDebuggee = (HMODULE*)LocalAlloc( 0, cbActual );
		if ( NULL == rghmodDebuggee )
			{
			goto HandleError;
			}

		if ( !pfnEnumProcessModules( hProcess, rghmodDebuggee, cbActual, &cbNeeded ) )
			{
			goto HandleError;
			}
		}
	while ( cbNeeded > cbActual );

	SIZE_T ihmod;
	SIZE_T ihmodLim;

	ihmodLim = cbNeeded / sizeof( HMODULE );
	for ( ihmod = 0; ihmod < ihmodLim; ihmod++ )
		{
		char szModuleImageName[ _MAX_PATH ];
		if ( !pfnGetModuleFileNameExA( hProcess, rghmodDebuggee[ ihmod ], szModuleImageName, _MAX_PATH ) )
			{
			goto HandleError;
			}

		char szModuleBaseName[ _MAX_FNAME ];
		if ( !pfnGetModuleBaseNameA( hProcess, rghmodDebuggee[ ihmod ], szModuleBaseName, _MAX_FNAME ) )
			{
			goto HandleError;
			}

		MODULEINFO mi;
		if ( !pfnGetModuleInformation( hProcess, rghmodDebuggee[ ihmod ], &mi, sizeof( mi ) ) )
			{
			goto HandleError;
			}
			
		if ( !pfnSymLoadModule(	hProcess,
								NULL,
								szModuleImageName,
								szModuleBaseName,
								DWORD_PTR( mi.lpBaseOfDll ),
								mi.SizeOfImage ) )
			{
			goto HandleError;
			}

		IMAGEHLP_MODULE im;
		im.SizeOfStruct = sizeof( IMAGEHLP_MODULE );

		if ( !pfnSymGetModuleInfo( hProcess, DWORD_PTR( mi.lpBaseOfDll ), &im ) )
			{
			goto HandleError;
			}
		}

	return fTrue;

HandleError:
	LocalFree( (void*)rghmodDebuggee );
	return fFalse;
	}

//  ================================================================
LOCAL BOOL SymInitializeEx(	HANDLE hProcess, HANDLE* phProcess )
//  ================================================================
	{
	//  init our out param

	*phProcess = NULL;

	//  duplicate the given debuggee process handle so that we have our own
	//  sandbox in imagehlp

	if ( !DuplicateHandle(	GetCurrentProcess(),
							hProcess,
							GetCurrentProcess(),
							phProcess,
							0,
							FALSE,
							DUPLICATE_SAME_ACCESS ) )
		{
		goto HandleError;
		}
	SetHandleInformation( *phProcess, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	//  init imagehlp for the debuggee process

	if ( !pfnSymInitialize( *phProcess, NULL, FALSE ) )
		{
		goto HandleError;
		}

	//  we're done

	return fTrue;

HandleError:
	if ( *phProcess )
		{
		SetHandleInformation( *phProcess, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( *phProcess );
		*phProcess = NULL;
		}
	return fFalse;
	}

//  ================================================================
LOCAL void SymTerm()
//  ================================================================
	{
	//  shut down imagehlp
	
	if ( pfnSymCleanup )
		{
		if ( ghDbgProcess )
			{
			pfnSymCleanup( ghDbgProcess );
			}
		pfnSymCleanup = NULL;
		}

	//  free psapi

	if ( hmodPsapi )
		{
		FreeLibrary( hmodPsapi );
		hmodPsapi = NULL;
		}

	//  free imagehlp

	if ( hmodImagehlp )
		{
		FreeLibrary( hmodImagehlp );
		hmodImagehlp = NULL;
		}

	//  close our process handle

	if ( ghDbgProcess )
		{
		SetHandleInformation( ghDbgProcess, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( ghDbgProcess );
		ghDbgProcess = NULL;
		}
	}

//  ================================================================
LOCAL BOOL FSymInit( HANDLE hProc )
//  ================================================================
	{
	HANDLE hThisProcess = NULL;
	
	//  reset all pointers
	
	ghDbgProcess	= NULL;
	hmodImagehlp	= NULL;
	pfnSymCleanup	= NULL;
	hmodPsapi		= NULL;

	//  load all calls in imagehlp
	
	if ( !( hmodImagehlp = LoadLibrary( "imagehlp.dll" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetSymFromAddr = (PFNSymGetSymFromAddr*)GetProcAddress( hmodImagehlp, "SymGetSymFromAddr" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetSymFromName = (PFNSymGetSymFromName*)GetProcAddress( hmodImagehlp, "SymGetSymFromName" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymInitialize = (PFNSymInitialize*)GetProcAddress( hmodImagehlp, "SymInitialize" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymCleanup = (PFNSymCleanup*)GetProcAddress( hmodImagehlp, "SymCleanup" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymSetOptions = (PFNSymSetOptions*)GetProcAddress( hmodImagehlp, "SymSetOptions" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnUnDecorateSymbolName = (PFNUnDecorateSymbolName*)GetProcAddress( hmodImagehlp, "UnDecorateSymbolName" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetSearchPath = (PFNSymGetSearchPath*)GetProcAddress( hmodImagehlp, "SymGetSearchPath" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymSetSearchPath = (PFNSymSetSearchPath*)GetProcAddress( hmodImagehlp, "SymSetSearchPath" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetModuleInfo = (PFNSymGetModuleInfo*)GetProcAddress( hmodImagehlp, "SymGetModuleInfo" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymLoadModule = (PFNSymLoadModule*)GetProcAddress( hmodImagehlp, "SymLoadModule" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnImageNtHeader = (PFNImageNtHeader*)GetProcAddress( hmodImagehlp, "ImageNtHeader" ) ) )
		{
		goto HandleError;
		}

	//  load all calls in psapi

	if ( !( hmodPsapi = LoadLibrary( "psapi.dll" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnEnumProcessModules = (PFNEnumProcessModules*)GetProcAddress( hmodPsapi, "EnumProcessModules" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnGetModuleFileNameExA = (PFNGetModuleFileNameExA*)GetProcAddress( hmodPsapi, "GetModuleFileNameExA" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnGetModuleBaseNameA = (PFNGetModuleBaseNameA*)GetProcAddress( hmodPsapi, "GetModuleBaseNameA" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnGetModuleInformation = (PFNGetModuleInformation*)GetProcAddress( hmodPsapi, "GetModuleInformation" ) ) )
		{
		goto HandleError;
		}

	//  get the name of our parent image in THIS process.  we need this name so
	//  that we can prefix symbols with the default module name and so that we
	//  can add the image path to the symbol path

	MEMORY_BASIC_INFORMATION mbi;
	if ( !VirtualQueryEx( GetCurrentProcess(), FSymInit, &mbi, sizeof( mbi ) ) )
		{
		goto HandleError;
		}
	char szImage[_MAX_PATH];
	if ( !GetModuleFileNameA( HINSTANCE( mbi.AllocationBase ), szImage, sizeof( szImage ) ) )
		{
		goto HandleError;
		}
	_splitpath( (const _TCHAR *)szImage, NULL, NULL, szParentImageName, NULL );

	//  init imagehlp for the debuggee process

	if ( !SymInitializeEx( hProc, &ghDbgProcess ) )
		{
		goto HandleError;
		}

	//  set our symbol path to include the path of this image and the process
	//  executable

	char szOldPath[ 4 * _MAX_PATH ];
	if ( pfnSymGetSearchPath( ghDbgProcess, szOldPath, sizeof( szOldPath ) ) )
		{
		char szNewPath[ 6 * _MAX_PATH ];
		char szDrive[ _MAX_DRIVE ];
		char szDir[ _MAX_DIR ];
		char szPath[ _MAX_PATH ];

		szNewPath[ 0 ] = 0;
		
		strcat( szNewPath, szOldPath );
		strcat( szNewPath, ";" );
		
		HMODULE hImage = GetModuleHandle( szParentImageName );
		GetModuleFileName( hImage, szPath, _MAX_PATH );
		_splitpath( szPath, szDrive, szDir, NULL, NULL );
		_makepath( szPath, szDrive, szDir, NULL, NULL );
		strcat( szNewPath, szPath );
		strcat( szNewPath, ";" );
		
		GetModuleFileName( NULL, szPath, _MAX_PATH );
		_splitpath( szPath, szDrive, szDir, NULL, NULL );
		_makepath( szPath, szDrive, szDir, NULL, NULL );
		strcat( szNewPath, szPath );
		
		pfnSymSetSearchPath( ghDbgProcess, szNewPath );
		}

	//  set our default symbol options
	
	pfnSymSetOptions( symopt );

	//  prepare symbols for the debuggee process

	if ( !SymLoadAllModules( ghDbgProcess ) )
		{
		goto HandleError;
		}

	return fTrue;

HandleError:
	if ( hThisProcess )
		{
		SetHandleInformation( hThisProcess, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hThisProcess );
		}
	SymTerm();
	return fFalse;
	}

//  ================================================================
LOCAL BOOL FUlFromSz( const char* const sz, ULONG* const pul, const int base = 16 )
//  ================================================================
	{
	if( sz && *sz )
		{
		char* pchEnd;
		*pul = strtoul( sz, &pchEnd, base );
		return !( *pchEnd );
		}
	return fFalse;
	}

//  ================================================================
template< class T >
LOCAL BOOL FAddressFromSz( const char* const sz, T** const ppt )
//  ================================================================
	{
	if ( sz && *sz )
		{
		int		n;
		QWORD	first;
		DWORD	second;
		int		cchRead;
		BOOL	f;

		n = sscanf( sz, "%I64x%n%*[` ]%8lx%n", &first, &cchRead, &second, &cchRead );

		switch ( n )
			{
			case 2:
				*ppt = (T*)( ( first << 32 ) | second );
				f = fTrue;
				break;

			case 1:
				*ppt = (T*)( first );
				f = fTrue;
				break;

			default:
				f = fFalse;
				break;
			};
		if ( cchRead != int( strlen( sz ) ) )
			{
			f = fFalse;
			}

		return f;
		}
	return fFalse;
	}

//  ================================================================
template< class T >
LOCAL BOOL FAddressFromGlobal( const char* const szGlobal, T** const ppt )
//  ================================================================
	{
	//  add the module prefix to the global name to form the symbol
	
	SIZE_T	cchSymbol	= strlen( szParentImageName ) + 1 + strlen( szGlobal );
	char*	szSymbol	= (char*)LocalAlloc( 0, ( cchSymbol + 1 ) * sizeof( char ) );
	if ( !szSymbol )
		{
		return fFalse;
		}
	szSymbol[ 0 ] = 0;
	if ( !strchr( szGlobal, '!' ) )
		{
		strcat( szSymbol, szParentImageName );
		strcat( szSymbol, "!" );
		}
	strcat( szSymbol, szGlobal );

	//  try forever until we manage to retrieve the entire undecorated symbol
	//  and address corresponding to this symbol

	SIZE_T cbBuf = 1024;
	BYTE* rgbBuf = (BYTE*)LocalAlloc( 0, cbBuf );
	if ( !rgbBuf )
		{
		LocalFree( (void*)szSymbol );
		return fFalse;
		}

	IMAGEHLP_SYMBOL* pis;
	do	{
		pis							= (IMAGEHLP_SYMBOL*)rgbBuf;
		pis->SizeOfStruct			= sizeof( IMAGEHLP_SYMBOL );
		pis->MaxNameLength			= DWORD( ( cbBuf - sizeof( IMAGEHLP_SYMBOL ) ) / sizeof( char ) );

		DWORD	symoptOld	= pfnSymSetOptions( symopt );
		BOOL	fSuccess	= pfnSymGetSymFromName( ghDbgProcess, PSTR( szSymbol ), pis );
		DWORD	symoptNew	= pfnSymSetOptions( symoptOld );
		
		if ( !fSuccess )
			{
			LocalFree( (void*)szSymbol );
			LocalFree( (void*)rgbBuf );
			return fFalse;
			}

		if ( strlen( pis->Name ) == cbBuf - 1 )
			{
			LocalFree( (void*)rgbBuf );
			cbBuf *= 2;
			if ( !( rgbBuf = (BYTE*)LocalAlloc( 0, cbBuf ) ) )
				{
				LocalFree( (void*)szSymbol );
				return fFalse;
				}
			}
		}
	while ( strlen( pis->Name ) == cbBuf - 1 );

	//  validate the symbols for the image containing this address

	IMAGEHLP_MODULE		im	= { sizeof( IMAGEHLP_MODULE ) };
	IMAGE_NT_HEADERS*	pnh;
	
	if (	!pfnSymGetModuleInfo( ghDbgProcess, pis->Address, &im ) ||
			!( pnh = pfnImageNtHeader( (void*)im.BaseOfImage ) ) ||
			pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
			pnh->FileHeader.SizeOfOptionalHeader >= IMAGE_SIZEOF_NT_OPTIONAL_HEADER &&
			pnh->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC &&
			pnh->OptionalHeader.CheckSum != im.CheckSum &&
			(	pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
				_stricmp( im.ModuleName, "kernel32" ) &&
				_stricmp( im.ModuleName, "ntdll" ) ) )
		{
		LocalFree( (void*)szSymbol );
		LocalFree( (void*)rgbBuf );
		return fFalse;
		}

	//  return the address of the symbol

	*ppt = (T*)pis->Address;

	LocalFree( (void*)szSymbol );
	LocalFree( (void*)rgbBuf );
	return fTrue;
	}

//  ================================================================
template< class T >
LOCAL BOOL FGlobalFromAddress( T* const pt, char* szGlobal, const SIZE_T cchMax, DWORD_PTR* const pdwOffset = NULL )
//  ================================================================
	{
	//  validate the symbols for the image containing this address

	IMAGEHLP_MODULE		im	= { sizeof( IMAGEHLP_MODULE ) };
	IMAGE_NT_HEADERS*	pnh;
	
	if (	!pfnSymGetModuleInfo( ghDbgProcess, DWORD_PTR( pt ), &im ) ||
			!( pnh = pfnImageNtHeader( (void*)im.BaseOfImage ) ) ||
			pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
			pnh->FileHeader.SizeOfOptionalHeader >= IMAGE_SIZEOF_NT_OPTIONAL_HEADER &&
			pnh->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC &&
			pnh->OptionalHeader.CheckSum != im.CheckSum &&
			(	pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
				_stricmp( im.ModuleName, "kernel32" ) &&
				_stricmp( im.ModuleName, "ntdll" ) ) )
		{
		return fFalse;
		}

	//  try forever until we manage to retrieve the entire undecorated symbol
	//  corresponding to this address

	SIZE_T cbBuf = 1024;
	BYTE* rgbBuf = (BYTE*)LocalAlloc( 0, cbBuf );
	if ( !rgbBuf )
		{
		return fFalse;
		}

	IMAGEHLP_SYMBOL* pis;
	do	{
		DWORD_PTR	dwT;
		DWORD_PTR*	pdwDisp	= pdwOffset ? pdwOffset : &dwT;

		pis							= (IMAGEHLP_SYMBOL*)rgbBuf;
		pis->SizeOfStruct			= sizeof( IMAGEHLP_SYMBOL );
		pis->MaxNameLength			= DWORD( cbBuf - sizeof( IMAGEHLP_SYMBOL ) );

		DWORD	symoptOld	= pfnSymSetOptions( symopt );
		BOOL	fSuccess	= pfnSymGetSymFromAddr( ghDbgProcess, DWORD_PTR( pt ), pdwDisp, pis );
		DWORD	symoptNew	= pfnSymSetOptions( symoptOld );
		
		if ( !fSuccess )
			{
			LocalFree( (void*)rgbBuf );
			return fFalse;
			}

		if ( strlen( pis->Name ) == cbBuf - 1 )
			{
			LocalFree( (void*)rgbBuf );
			cbBuf *= 2;
			if ( !( rgbBuf = (BYTE*)LocalAlloc( 0, cbBuf ) ) )
				{
				return fFalse;
				}
			}
		}
	while ( strlen( pis->Name ) == cbBuf - 1 );

	//  undecorate the symbol (if possible).  if not, use the decorated symbol

	char* szSymbol = (char*)LocalAlloc( 0, cchMax );
	if ( !szSymbol )
		{
		LocalFree( (void*)rgbBuf );
		return fFalse;
		}

	if ( !pfnUnDecorateSymbolName( pis->Name, szSymbol, DWORD( cchMax ), UNDNAME_COMPLETE ) )
		{
		strncpy( szSymbol, pis->Name, size_t( cchMax ) );
		szGlobal[ cchMax - 1 ] = 0;
		}

	//  write the module!symbol into the user's buffer

	_snprintf( szGlobal, size_t( cchMax ), "%s!%s", im.ModuleName, szSymbol );

	LocalFree( (void*)szSymbol );
	LocalFree( (void*)rgbBuf );
	return fTrue;
	}

//  ================================================================
template< class T >
LOCAL BOOL FFetchVariable( T* const rgtDebuggee, T** const prgt, SIZE_T ct = 1 )
//  ================================================================
	{
	//  allocate enough storage to retrieve the requested type array

	const SIZE_T cbrgt = sizeof( T ) * ct;

	if ( !( *prgt = (T*)LocalAlloc( 0, cbrgt ) ) )
		{
		return fFalse;
		}

	//  retrieve the requested type array

	if ( !ExtensionApis.lpReadProcessMemoryRoutine( (ULONG_PTR)rgtDebuggee, (void*)*prgt, DWORD( cbrgt ), NULL ) )
		{
		LocalFree( (void*)*prgt );
		return fFalse;
		}

	return fTrue;
	}

//  ================================================================
template< class T >
LOCAL BOOL FFetchGlobal( const char* const szGlobal, T** const prgt, SIZE_T ct = 1 )
//  ================================================================
	{
	//  get the address of the global in the debuggee and fetch it

	T*	rgtDebuggee;

	if ( FAddressFromGlobal( szGlobal, &rgtDebuggee )
		&& FFetchVariable( rgtDebuggee, prgt, ct ) )
		return fTrue;
	else
		{
		dprintf( "Error: Could not fetch global variable '%s'.\n", szGlobal );
		return fFalse;
		}
	}

//  ================================================================
template< class T >
LOCAL BOOL FFetchSz( T* const szDebuggee, T** const psz )
//  ================================================================
	{
	//  scan for the null terminator in the debuggee starting at the given
	//  address to get the size of the string

	const SIZE_T	ctScan				= 256;
	const SIZE_T	cbScan				= ctScan * sizeof( T );
	BYTE			rgbScan[ cbScan ];
	T*				rgtScan				= (T*)rgbScan;  //  because T can be const
	SIZE_T			itScan				= -1;
	SIZE_T			itScanLim			= 0;

	do	{
		if ( !( ++itScan % ctScan ) )
			{
			ULONG	cbRead;
			ExtensionApis.lpReadProcessMemoryRoutine(
								ULONG_PTR( szDebuggee + itScan ),
								(void*)rgbScan,
								cbScan,
								&cbRead );
				
			itScanLim = itScan + cbRead / sizeof( T );
			}
		}
	while ( itScan < itScanLim && rgtScan[ itScan % ctScan ] );

	//  we found a null terminator

	if ( itScan < itScanLim )
		{
		//  fetch the string using the determined string length

		return FFetchVariable( szDebuggee, psz, itScan + 1 );
		}

	//  we did not find a null terminator

	else
		{
		//  fail the operation

		return fFalse;
		}
	}

//  ================================================================
template< class T >
LOCAL void Unfetch( T* const rgt )
//  ================================================================
	{
	LocalFree( (void*)rgt );
	}

}  //  namespace OSSYM


using namespace OSSYM;


//  member dumping functions

class CDumpContext
	{
	public:

		CDumpContext(	CIPrintF&		iprintf,
						const DWORD_PTR	dwOffset,
						const int		cLevel )
			:	m_iprintf( iprintf ),
				m_dwOffset( dwOffset ),
				m_cLevel( cLevel )
			{
			}
	
		void* operator new( size_t cb ) { return LocalAlloc( 0, cb ); }
		void operator delete( void* pv ) { LocalFree( pv ); }

	public:

		CIPrintF&		m_iprintf;
		const DWORD_PTR	m_dwOffset;
		const int		m_cLevel;
	};

#define SYMBOL_LEN_MAX		24
#define VOID_CB_DUMP		8

//  ================================================================
LOCAL VOID SprintHex(
	CHAR * const 		szDest,
	const BYTE * const 	rgbSrc,
	const INT 			cbSrc,
	const INT 			cbWidth,
	const INT 			cbChunk,
	const INT			cbAddress,
	const INT			cbStart)
//  ================================================================
	{
	static const CHAR rgchConvert[] =	{ '0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f' };
			
	const BYTE * const pbMax = rgbSrc + cbSrc;
	const INT cchHexWidth = ( cbWidth * 2 ) + (  cbWidth / cbChunk );

	const BYTE * pb = rgbSrc;
	CHAR * sz = szDest;
	while( pbMax != pb )
		{
		sz += ( 0 == cbAddress ) ? 0 : sprintf( sz, "%*.*lx    ", cbAddress, cbAddress, pb - rgbSrc + cbStart );
		CHAR * szHex	= sz;
		CHAR * szText	= sz + cchHexWidth;
		do
			{
			for( INT cb = 0; cbChunk > cb && pbMax != pb; ++cb, ++pb )
				{
				*szHex++ 	= rgchConvert[ *pb >> 4 ];
				*szHex++ 	= rgchConvert[ *pb & 0x0F ];
				*szText++ 	= isprint( *pb ) ? *pb : '.';
				}
			*szHex++ = ' ';
			} while( ( ( pb - rgbSrc ) % cbWidth ) && pbMax > pb );
		while( szHex != sz + cchHexWidth )
			{
			*szHex++ = ' ';
			}
		*szText++ = '\n';
		*szText = '\0';
		sz = szText;
		}
	}

template< class M >
inline void DumpMemberValue(	CDumpContext&	dc,
								const M&		m )
	{
	char szHex[ 1024 ] = "\n";
	
	SprintHex(	szHex,
				(BYTE *)&m,
				min( sizeof( M ), VOID_CB_DUMP ),
				min( sizeof( M ), VOID_CB_DUMP ) + 1,
				4,
				0,
				0 );

	dc.m_iprintf( _T( "%s" ), szHex );
	}

template< class M >
inline void DumpMember_(	CDumpContext&		dc,
							const M&			m,
							const _TCHAR* const	szM )
	{
	if ( dc.m_cLevel > 0 )
		{
		dc.m_iprintf.Indent();
		
		dc.m_iprintf(	_T( "%*.*s <0x%0*I64x,%3i>:  " ),
						SYMBOL_LEN_MAX,
						SYMBOL_LEN_MAX,
						szM,
						sizeof( void* ) * 2,
						QWORD( (char*)&m + dc.m_dwOffset ),
						sizeof( M ) );
		DumpMemberValue( CDumpContext( dc.m_iprintf, dc.m_dwOffset, dc.m_cLevel - 1 ), m );

		dc.m_iprintf.Unindent();
		}
	}

#define DumpMember( dc, member ) ( DumpMember_( dc, member, #member ) )

template< class M >
inline void DumpMemberValueBF(	CDumpContext&	dc,
								const M			m )
	{
	if ( M( 0 ) - M( 1 ) < M( 0 ) )
		{
		dc.m_iprintf(	_T( "%I64i (0x%0*I64x)\n" ),
						QWORD( m ),
						sizeof( m ) * 2,
						QWORD( m ) & ( ( QWORD( 1 ) << ( sizeof( m ) * 8 ) ) - 1 ) );
		}
	else
		{
		dc.m_iprintf(	_T( "%I64u (0x%0*I64x)\n" ),
						QWORD( m ),
						sizeof( m ) * 2,
						QWORD( m ) & ( ( QWORD( 1 ) << ( sizeof( m ) * 8 ) ) - 1 ) );
		}
	}

template< class M >
inline void DumpMemberBF_(	CDumpContext&		dc,
							const M				m,
							const _TCHAR* const	szM )
	{
	if ( dc.m_cLevel > 0 )
		{
		dc.m_iprintf.Indent();

		dc.m_iprintf(	_T( "%*.*s <%-*.*s>:  " ),
						SYMBOL_LEN_MAX,
						SYMBOL_LEN_MAX,
						szM,
						2 + sizeof( void* ) * 2 + 1 + 3,
						2 + sizeof( void* ) * 2 + 1 + 3,
						_T( "Bit-Field" ) );
		DumpMemberValueBF( CDumpContext( dc.m_iprintf, dc.m_dwOffset, dc.m_cLevel - 1 ), m );

		dc.m_iprintf.Unindent();
		}
	}

#define DumpMemberBF( dc, member ) ( DumpMemberBF_( dc, member, #member ) )


LOCAL WINDBG_EXTENSION_APIS ExtensionApis;

LOCAL BOOL fInit 		= fFalse;	//	debugger extensions have geen initialized

//  ================================================================
class CDPrintF : public CPrintF
//  ================================================================
	{
	public:
		VOID __cdecl operator()( const char * szFormat, ... )
			{
			va_list arg_ptr;
			va_start( arg_ptr, szFormat );
			_vsnprintf( szBuf, sizeof( szBuf ), szFormat, arg_ptr );
			va_end( arg_ptr );
			szBuf[ sizeof( szBuf ) - 1 ] = 0;
			(ExtensionApis.lpOutputRoutine)( "%s", szBuf );
			}

		static CPrintF& PrintfInstance();
		
		~CDPrintF() {}

	private:
		CDPrintF() {}
		static CHAR szBuf[1024];	//  WARNING: not multi-threaded safe!
	};

CHAR CDPrintF::szBuf[1024];

//  ================================================================
CPrintF& CDPrintF::PrintfInstance()
//  ================================================================
	{
	static CDPrintF s_dprintf;
	return s_dprintf;
	}

CIPrintF g_idprintf( &CDPrintF::PrintfInstance() );


//  ================================================================
class CDUMP
//  ================================================================
	{
	public:
		CDUMP() {}
		virtual ~CDUMP() {}
		
		virtual VOID Dump( HANDLE, HANDLE, DWORD, PWINDBG_EXTENSION_APIS, INT, const CHAR * const [] ) = 0;
	};
	

//  ================================================================
template< class _STRUCT>
class CDUMPA : public CDUMP
//  ================================================================
	{
	public:		
		VOID Dump(
			    HANDLE hCurrentProcess,
			    HANDLE hCurrentThread,
			    DWORD dwCurrentPc,
			    PWINDBG_EXTENSION_APIS lpExtensionApis,
			    INT argc,
			    const CHAR * const argv[] );
		static CDUMPA	instance;
	};

template< class _STRUCT>
CDUMPA<_STRUCT> CDUMPA<_STRUCT>::instance;


//  ****************************************************************
//  PROTOTYPES
//  ****************************************************************

#define DEBUG_EXT( name )					\
	LOCAL VOID name(						\
		const HANDLE hCurrentProcess,		\
		const HANDLE hCurrentThread,		\
		const DWORD dwCurrentPc,			\
	    const PWINDBG_EXTENSION_APIS lpExtensionApis,	\
	    const INT argc,						\
	    const CHAR * const argv[]  )

DEBUG_EXT( EDBGDump );
DEBUG_EXT( EDBGTest );
#ifdef SYNC_DEADLOCK_DETECTION
DEBUG_EXT( EDBGLocks );
#endif  //  SYNC_DEADLOCK_DETECTION
DEBUG_EXT( EDBGHelp );
DEBUG_EXT( EDBGHelpDump );


//  ****************************************************************
//  COMMAND DISPATCH
//  ****************************************************************


typedef VOID (*EDBGFUNC)(
	const HANDLE hCurrentProcess,
	const HANDLE hCurrentThread,
	const DWORD dwCurrentPc,
    const PWINDBG_EXTENSION_APIS lpExtensionApis,
    const INT argc,
    const CHAR * const argv[]
    );


//  ================================================================
struct EDBGFUNCMAP
//  ================================================================
	{
	const char * 	szCommand;
	EDBGFUNC		function;
	const char * 	szHelp;
	};


//  ================================================================
struct CDUMPMAP
//  ================================================================
	{
	const char * 	szCommand;
	CDUMP 	   *	pcdump;
	const char * 	szHelp;
	};


//  ================================================================
LOCAL EDBGFUNCMAP rgfuncmap[] = {
//  ================================================================

	{
		"Help",		EDBGHelp,
		"Help                   - Print this help message"
	},
	{
		"Dump",		EDBGDump,
		"Dump <Object> <Address> [<Depth>|*]\n\t"
		"                       - Dump a given synchronization object's state"
	},
#ifdef SYNC_DEADLOCK_DETECTION
	{
		"Locks",		EDBGLocks,
		"Locks [<tid>|* [<OSSYNC::pclsSyncGlobal>]]\n\t"
		"                       - List all locks owned by the specified thread or by all threads"
	},
#endif  //  SYNC_DEADLOCK_DETECTION
	{
		"Test",		EDBGTest,
		"Test                   - Test function"
	},
	};

LOCAL const int cfuncmap = sizeof( rgfuncmap ) / sizeof( EDBGFUNCMAP );


#define DUMPA(_struct)	{ #_struct, &(CDUMPA<_struct>::instance), #_struct " <Address> [<Depth>|*]" }

//  ================================================================
LOCAL CDUMPMAP rgcdumpmap[] = {
//  ================================================================

	DUMPA( CAutoResetSignal ),
	DUMPA( CBinaryLock ),
	DUMPA( CCriticalSection ),
	DUMPA( CGate ),
	DUMPA( CKernelSemaphore ),
	DUMPA( CManualResetSignal ),
	DUMPA( CMeteredSection ),
	DUMPA( CNestableCriticalSection ),
	DUMPA( CReaderWriterLock ),
	DUMPA( CSemaphore ),
	DUMPA( CSXWLatch )
	};

LOCAL const int ccdumpmap = sizeof( rgcdumpmap ) / sizeof( CDUMPMAP );


//  ================================================================
LOCAL BOOL FArgumentMatch( const CHAR * const sz, const CHAR * const szCommand )
//  ================================================================
	{
	const BOOL fMatch = ( ( strlen( sz ) == strlen( szCommand ) )
			&& !( _strnicmp( sz, szCommand, strlen( szCommand ) ) ) );
	return fMatch;
	}


//  ================================================================
DEBUG_EXT( EDBGDump )
//  ================================================================
	{
	if( argc < 2 )
		{
		EDBGHelpDump( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, argv );
		return;
		}
		
	for( int icdumpmap = 0; icdumpmap < ccdumpmap; ++icdumpmap )
		{
		if( FArgumentMatch( argv[0], rgcdumpmap[icdumpmap].szCommand ) )
			{
			(rgcdumpmap[icdumpmap].pcdump)->Dump(
				hCurrentProcess,
				hCurrentThread,
				dwCurrentPc,
				lpExtensionApis,
				argc - 1, argv + 1 );
			return;
			}
		}
	EDBGHelpDump( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, argv );
	}


//  ================================================================
DEBUG_EXT( EDBGHelp )
//  ================================================================
	{
	for( int ifuncmap = 0; ifuncmap < cfuncmap; ifuncmap++ )
		{
		dprintf( "\t%s\n", rgfuncmap[ifuncmap].szHelp );
		}
	dprintf( "\n--------------------\n\n" );
	}


//  ================================================================
DEBUG_EXT( EDBGHelpDump )
//  ================================================================
	{
	dprintf( "Supported objects:\n\n" );
	for( int icdumpmap = 0; icdumpmap < ccdumpmap; icdumpmap++ )
		{
		dprintf( "\t%s\n", rgcdumpmap[icdumpmap].szHelp );
		}
	dprintf( "\n--------------------\n\n" );
	}


//  ================================================================
DEBUG_EXT( EDBGTest )
//  ================================================================
	{
	if ( argc >= 1 )
		{
		void* pv;
		if ( FAddressFromGlobal( argv[ 0 ], &pv ) )
			{
			dprintf(	"The address of %s is 0x%0*I64X.\n",
						argv[ 0 ],
						sizeof( void* ) * 2,
						QWORD( pv ) );
			}
		else
			{
			dprintf( "Could not find the symbol.\n" );
			}
		}
	if ( argc >= 2 )
		{
		void* pv;
		if ( FAddressFromSz( argv[ 1 ], &pv ) )
			{
			char		szGlobal[ 1024 ];
			DWORD_PTR	dwOffset;
			if ( FGlobalFromAddress( pv, szGlobal, sizeof( szGlobal ), &dwOffset ) )
				{
				dprintf(	"The symbol closest to 0x%0*I64X is %s+0x%I64X.\n",
							sizeof( void* ) * 2,
							QWORD( pv ),
							szGlobal,
							QWORD( dwOffset ) );
				}
			else
				{
				dprintf( "Could not map this address to a symbol.\n" );
				}
			}
		else
			{
			dprintf( "That is not a valid address.\n" );
			}
		}

	dprintf( "\n--------------------\n\n" );
	}


#ifdef SYNC_DEADLOCK_DETECTION

//  ================================================================
DEBUG_EXT( EDBGLocks )
//  ================================================================
	{
	//  load default arguments

	_CLS*	pclsDebuggee				= NULL;
	DWORD	tid							= 0;
	BOOL	fFoundLock					= fFalse;
	BOOL	fValidUsage;

	//  load actual arguments

	switch ( argc )
		{
		case 0:
			//	use defaults
			fValidUsage = fTrue;
			break;
		case 1:
			//	thread-id only
			fValidUsage = ( FUlFromSz( argv[0], &tid )
							|| '*' == argv[0][0] );
			break;
		case 2:
			//	thread-id followed by <pclsSyncGlobal>
			fValidUsage = ( ( FUlFromSz( argv[0], &tid ) || '*' == argv[0][0] )
							&& FAddressFromSz( argv[1], &pclsDebuggee ) );
			break;
		default:
			fValidUsage = fFalse;
			break;
			}

	if ( !fValidUsage )
		{
		dprintf( "Usage: Locks [<tid>|* [<OSSYNC::pclsSyncGlobal>]]\n" );
		return;
		}

	if ( NULL == pclsDebuggee )
		{
		_CLS**	ppclsDebuggee	= NULL;
		if ( FFetchGlobal( "OSSYNC::pclsSyncGlobal", &ppclsDebuggee ) )
			{
			pclsDebuggee = *ppclsDebuggee;
			Unfetch( ppclsDebuggee );
			}
		else
			{
			dprintf( "Error: Could not find the global TLS list in the debuggee.\n" );
			return;
			}
		}

	while ( pclsDebuggee )
		{
		_CLS* pcls;
		if ( !FFetchVariable( pclsDebuggee, &pcls ) )
			{
			dprintf( "An error occurred while scanning Thread IDs.\n" );
			break;
			}

		if ( !tid || pcls->dwContextId == tid )
			{
			if ( pcls->cls.plddiLockWait )
				{
				CLockDeadlockDetectionInfo*	plddi			= NULL;
				const CLockBasicInfo*		plbi			= NULL;
				const char*					pszTypeName		= NULL;
				const char*					pszInstanceName	= NULL;
				
				if (	FFetchVariable( pcls->cls.plddiLockWait, &plddi ) &&
						FFetchVariable( &plddi->Info(), &plbi ) &&
						FFetchSz( plbi->SzTypeName(), &pszTypeName ) &&
						FFetchSz( plbi->SzInstanceName(), &pszInstanceName ) )
					{
					fFoundLock = fTrue;

					dprintf(	"TID %d is a waiter for %s 0x%0*I64X ( \"%s\", %d, %d )",
								pcls->dwContextId,
								pszTypeName,
								sizeof( void* ) * 2,
								QWORD( plbi->Instance() ),
								pszInstanceName,
								plbi->Rank(),
								plbi->SubRank() );
					if ( pcls->cls.groupLockWait != -1 )
						{
						dprintf( " as Group %d", pcls->cls.groupLockWait );
						}
					dprintf( ".\n" );
					}
				else
					{
					dprintf(	"An error occurred while reading TLS for Thread ID %d.\n",
								pcls->dwContextId );
					}

				Unfetch( pszInstanceName );
				Unfetch( pszTypeName );
				Unfetch( plbi );
				Unfetch( plddi );
				}
					
			COwner* pownerDebuggee;
			pownerDebuggee = pcls->cls.pownerLockHead;
			
			while ( pownerDebuggee )
				{
				COwner*						powner			= NULL;
				CLockDeadlockDetectionInfo*	plddi			= NULL;
				const CLockBasicInfo*		plbi			= NULL;
				const char*					pszTypeName		= NULL;
				const char*					pszInstanceName	= NULL;
				
				if (	FFetchVariable( pownerDebuggee, &powner ) &&
						FFetchVariable( powner->m_plddiOwned, &plddi ) &&
						FFetchVariable( &plddi->Info(), &plbi ) &&
						FFetchSz( plbi->SzTypeName(), &pszTypeName ) &&
						FFetchSz( plbi->SzInstanceName(), &pszInstanceName ) )
						
					{
					fFoundLock = fTrue;

					dprintf(	"TID %d is an owner of %s 0x%0*I64X ( \"%s\", %d, %d )",
								pcls->dwContextId,
								pszTypeName,
								sizeof( void* ) * 2,
								QWORD( plbi->Instance() ),
								pszInstanceName,
								plbi->Rank(),
								plbi->SubRank() );
					if ( powner->m_group != -1 )
						{
						dprintf( " as Group %d", powner->m_group );
						}
					dprintf( ".\n" );
					}
				else
					{
					dprintf(	"An error occurred while scanning the lock chain for Thread ID %d.\n",
								pcls->dwContextId );
					}

				pownerDebuggee = powner ? powner->m_pownerLockNext : NULL;

				Unfetch( pszInstanceName );
				Unfetch( pszTypeName );
				Unfetch( plbi );
				Unfetch( plddi );
				Unfetch( powner );
				}
			}

		pclsDebuggee = pcls ? pcls->pclsNext : NULL;
			
		Unfetch( pcls );
		}

	if ( fFoundLock )
		{
		dprintf( "\n--------------------\n\n" );
		}
	else if ( !tid )
		{
		dprintf( "No thread owns or is waiting for any locks.\n" );
		}
	else
		{
		dprintf( "This thread does not own and is not waiting for any locks.\n" );
		}
	}

#endif  //  SYNC_DEADLOCK_DETECTION

//  ================================================================
template< class _STRUCT>
VOID CDUMPA<_STRUCT>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[]
    )
//  ================================================================
	{
	_STRUCT*	ptDebuggee;
	ULONG		cLevelInput;
	if (	argc < 1 ||
			argc > 2 ||
			!FAddressFromSz( argv[ 0 ], &ptDebuggee ) ||
			argc == 2 && !FUlFromSz( argv[ 1 ], &cLevelInput, 10 ) && strcmp( argv[ 1 ], "*" ) )
		{
		dprintf( "Usage: Dump <Object> <Address> [<Depth>|*]\n" );
		return;
		}

	int cLevel;
	if ( argc == 2 )
		{
		if ( FUlFromSz( argv[ 1 ], &cLevelInput, 10 ) )
			{
			cLevel = int( cLevelInput );
			}
		else
			{
			cLevel = INT_MAX;
			}
		}
	else
		{
		cLevel = 1;
		}

	_STRUCT* pt;
	if ( FFetchVariable( ptDebuggee, &pt ) )
		{
		dprintf(	"0x%0*I64X bytes @ 0x%0*I64X\n",
					sizeof( size_t ) * 2,
					QWORD( sizeof( _STRUCT ) ),
					sizeof( _STRUCT* ) * 2,
					QWORD( ptDebuggee ) );

		pt->Dump( CDumpContext( g_idprintf, (BYTE*)ptDebuggee - (BYTE*)pt, cLevel ) );
			
		Unfetch( pt );
		}
	else
		{
		dprintf( "Error: Could not fetch the requested object.\n" );
		}
	}


VOID OSSYNCAPI OSSyncDebuggerExtension(	HANDLE hCurrentProcess,
										HANDLE hCurrentThread,
										DWORD dwCurrentPc,
										PWINDBG_EXTENSION_APIS lpExtensionApis,
										const INT argc,
										const CHAR * const argv[] )
	{
    ExtensionApis 	= *lpExtensionApis;

	if ( !fInit )
		{
		//  get our containing image name so that we can look up our variables

		if ( !FSymInit( hCurrentProcess ) )
			{
			return;
			}
		
		fInit = fTrue;
		}

	if( argc < 1 )
		{
		EDBGHelp( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, (const CHAR **)argv );
		return;
		}

	INT ifuncmap;
	for( ifuncmap = 0; ifuncmap < cfuncmap; ifuncmap++ )
		{
		if( FArgumentMatch( argv[0], rgfuncmap[ifuncmap].szCommand ) )
			{
			(rgfuncmap[ifuncmap].function)(
				hCurrentProcess,
				hCurrentThread,
				dwCurrentPc,
				lpExtensionApis,
				argc - 1, (const CHAR **)( argv + 1 ) );
			return;
			}
		}
	EDBGHelp( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, (const CHAR **)argv );
	}


//  custom member dump functions

template<>
inline void DumpMemberValue< const char* >(	CDumpContext&		dc,
											const char* const &	sz )
	{
	const char* szFetch = NULL;
	
	dc.m_iprintf( "0x%0*I64x ", sizeof( sz ) * 2, QWORD( sz ) );
	if ( FFetchSz( sz, &szFetch ) )
		{
		dc.m_iprintf( "\"%s\"", szFetch );
		}
	dc.m_iprintf( "\n" );
		
	Unfetch( szFetch );
	}

template<>
inline void DumpMemberValue< CSemaphore >(	CDumpContext&		dc,
											const CSemaphore&	sem )
	{
	dc.m_iprintf( "\n" );
	sem.Dump( dc );
	}


//  Enhanced Synchronization Object State Container Dump Support

template< class CState, class CStateInit, class CInformation, class CInformationInit >
void CEnhancedStateContainer< CState, CStateInit, CInformation, CInformationInit >::
Dump( CDumpContext& dc ) const
	{
#ifdef SYNC_ENHANCED_STATE

	CEnhancedState* pes = NULL;

	if ( FFetchVariable( m_pes, &pes ) )
		{
		CDumpContext dcES( dc.m_iprintf, (BYTE*)m_pes - (BYTE*)pes, dc.m_cLevel );
		
		pes->CState::Dump( dcES );
		pes->CInformation::Dump( dcES );
		}
	else
		{
		dprintf( "Error: Could not fetch the enhanced state of the requested object.\n" );
		}

	Unfetch( pes );

#else  //  !SYNC_ENHANCED_STATE

	CEnhancedState* pes = (CEnhancedState*) m_rgbState;

	pes->CState::Dump( dc );
	pes->CInformation::Dump( dc );

#endif  //  SYNC_ENHANCED_STATE
	}


//  Synchronization Object Basic Information Dump Support

void CSyncBasicInfo::Dump( CDumpContext& dc ) const
	{
#ifdef SYNC_ENHANCED_STATE

	DumpMember( dc, m_szInstanceName );
	DumpMember( dc, m_szTypeName );
	DumpMember( dc, m_psyncobj );

#endif  //  SYNC_ENHANCED_STATE
	}


//  Synchronization Object Performance Dump Support

void CSyncPerfWait::Dump( CDumpContext& dc ) const
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	DumpMember( dc, m_cWait );
	DumpMember( dc, m_qwHRTWaitElapsed );

#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

void CSyncPerfAcquire::Dump( CDumpContext& dc ) const
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	DumpMember( dc, m_cAcquire );
	DumpMember( dc, m_cContend );

#endif  //  SYNC_ANALYZE_PERFORMANCE
	}


//  Lock Object Basic Information Dump Support

void CLockBasicInfo::Dump( CDumpContext& dc ) const
	{
	CSyncBasicInfo::Dump( dc );

#ifdef SYNC_DEADLOCK_DETECTION

	DumpMember( dc, m_rank );
	DumpMember( dc, m_subrank );

#endif  //  SYNC_DEADLOCK_DETECTION
	}


//  Lock Object Performance Dump Support

void CLockPerfHold::Dump( CDumpContext& dc ) const
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	DumpMember( dc, m_cHold );
	DumpMember( dc, m_qwHRTHoldElapsed );

#endif  //  SYNC_ANALYZE_PERFORMANCE
	}


//  Lock Object Deadlock Detection Information Dump Support

void CLockDeadlockDetectionInfo::Dump( CDumpContext& dc ) const
	{
#ifdef SYNC_DEADLOCK_DETECTION

	DumpMember( dc, m_plbiParent );
	DumpMember( dc, m_semOwnerList );
	DumpMember( dc, m_ownerHead );

#endif  //  SYNC_DEADLOCK_DETECTION
	}


//  Kernel Semaphore Dump Support

void CKernelSemaphoreState::Dump( CDumpContext& dc ) const
	{
	DumpMember( dc, m_handle );
	}

void CKernelSemaphoreInfo::Dump( CDumpContext& dc ) const
	{
	CSyncBasicInfo::Dump( dc );
	CSyncPerfWait::Dump( dc );
	}

void CKernelSemaphore::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CKernelSemaphoreState, CSyncStateInitNull, CKernelSemaphoreInfo, CSyncBasicInfo >::Dump( dc );
	}


//  Semaphore Dump Support

void CSemaphoreState::Dump( CDumpContext& dc ) const
	{
	if ( FNoWait() )
		{
		DumpMember( dc, m_cAvail );
		}
	else
		{
		DumpMember( dc, m_irksem );
		DumpMember( dc, m_cWaitNeg );
		}
	}

void CSemaphoreInfo::Dump( CDumpContext& dc ) const
	{
	CSyncBasicInfo::Dump( dc );
	CSyncPerfWait::Dump( dc );
	CSyncPerfAcquire::Dump( dc );
	}

void CSemaphore::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CSemaphoreState, CSyncStateInitNull, CSemaphoreInfo, CSyncBasicInfo >::Dump( dc );
	}


//  Auto-Reset Signal Dump Support

void CAutoResetSignalState::Dump( CDumpContext& dc ) const
	{
	if ( FNoWait() )
		{
		DumpMember( dc, m_fSet );
		}
	else
		{
		DumpMember( dc, m_irksem );
		DumpMember( dc, m_cWaitNeg );
		}
	}

void CAutoResetSignalInfo::Dump( CDumpContext& dc ) const
	{
	CSyncBasicInfo::Dump( dc );
	CSyncPerfWait::Dump( dc );
	CSyncPerfAcquire::Dump( dc );
	}

void CAutoResetSignal::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CAutoResetSignalState, CSyncStateInitNull, CAutoResetSignalInfo, CSyncBasicInfo >::Dump( dc );
	}


//  Manual-Reset Signal Dump Support

void CManualResetSignalState::Dump( CDumpContext& dc ) const
	{
	if ( FNoWait() )
		{
		DumpMember( dc, m_fSet );
		}
	else
		{
		DumpMember( dc, m_irksem );
		DumpMember( dc, m_cWaitNeg );
		}
	}

void CManualResetSignalInfo::Dump( CDumpContext& dc ) const
	{
	CSyncBasicInfo::Dump( dc );
	CSyncPerfWait::Dump( dc );
	CSyncPerfAcquire::Dump( dc );
	}

void CManualResetSignal::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CManualResetSignalState, CSyncStateInitNull, CManualResetSignalInfo, CSyncBasicInfo >::Dump( dc );
	}


//  Critical Section (non-nestable) Dump Support

void CCriticalSectionState::Dump( CDumpContext& dc ) const
	{
	DumpMember( dc, m_sem );
	}

void CCriticalSectionInfo::Dump( CDumpContext& dc ) const
	{
	CLockBasicInfo::Dump( dc );
	CLockPerfHold::Dump( dc );
	CLockDeadlockDetectionInfo::Dump( dc );
	}

void CCriticalSection::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CCriticalSectionState, CSyncBasicInfo, CCriticalSectionInfo, CLockBasicInfo >::Dump( dc );
	}


//  Nestable Critical Section Dump Support

void CNestableCriticalSectionState::Dump( CDumpContext& dc ) const
	{
	DumpMember( dc, m_sem );
	DumpMember( dc, m_pclsOwner );
	DumpMember( dc, m_cEntry );
	}

void CNestableCriticalSectionInfo::Dump( CDumpContext& dc ) const
	{
	CLockBasicInfo::Dump( dc );
	CLockPerfHold::Dump( dc );
	CLockDeadlockDetectionInfo::Dump( dc );
	}
	
void CNestableCriticalSection::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CNestableCriticalSectionState, CSyncBasicInfo, CNestableCriticalSectionInfo, CLockBasicInfo >::Dump( dc );
	}


//  Gate Dump Support

void CGateState::Dump( CDumpContext& dc ) const
	{
	DumpMember( dc, m_cWait );
	DumpMember( dc, m_irksem );
	}

void CGateInfo::Dump( CDumpContext& dc ) const
	{
	CSyncBasicInfo::Dump( dc );
	CSyncPerfWait::Dump( dc );
	}
	
void CGate::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CGateState, CSyncStateInitNull, CGateInfo, CSyncBasicInfo >::Dump( dc );
	}


//  Binary Lock Dump Support

void CBinaryLockState::Dump( CDumpContext& dc ) const
	{
	DumpMember( dc, m_cw );
	DumpMemberBF( dc, m_cOOW1 );
	DumpMemberBF( dc, m_fQ1 );
	DumpMemberBF( dc, m_cOOW2 );
	DumpMemberBF( dc, m_fQ2 );
	DumpMember( dc, m_cOwner );
	DumpMember( dc, m_sem1 );
	DumpMember( dc, m_sem2 );
	}

void CBinaryLockPerfInfo::Dump( CDumpContext& dc ) const
	{
	CSyncPerfWait::Dump( dc );
	CSyncPerfAcquire::Dump( dc );
	CLockPerfHold::Dump( dc );
	}

void CBinaryLockGroupInfo::Dump( CDumpContext& dc ) const
	{
	for ( int iGroup = 0; iGroup < 2; iGroup++ )
		{
		m_rginfo[iGroup].Dump( dc );
		}
	}

void CBinaryLockInfo::Dump( CDumpContext& dc ) const
	{
	CLockBasicInfo::Dump( dc );
	CBinaryLockGroupInfo::Dump( dc );
	CLockDeadlockDetectionInfo::Dump( dc );
	}

void CBinaryLock::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CBinaryLockState, CSyncBasicInfo, CBinaryLockInfo, CLockBasicInfo >::Dump( dc );
	}


//  Reader / Writer Lock Dump Support

void CReaderWriterLockState::Dump( CDumpContext& dc ) const
	{
	DumpMember( dc, m_cw );
	DumpMemberBF( dc, m_cOAOWW );
	DumpMemberBF( dc, m_fQW );
	DumpMemberBF( dc, m_cOOWR );
	DumpMemberBF( dc, m_fQR );
	DumpMember( dc, m_cOwner );
	DumpMember( dc, m_semWriter );
	DumpMember( dc, m_semReader );
	}

void CReaderWriterLockPerfInfo::Dump( CDumpContext& dc ) const
	{
	CSyncPerfWait::Dump( dc );
	CSyncPerfAcquire::Dump( dc );
	CLockPerfHold::Dump( dc );
	}

void CReaderWriterLockGroupInfo::Dump( CDumpContext& dc ) const
	{
	for ( int iGroup = 0; iGroup < 2; iGroup++ )
		{
		m_rginfo[iGroup].Dump( dc );
		}
	}

void CReaderWriterLockInfo::Dump( CDumpContext& dc ) const
	{
	CLockBasicInfo::Dump( dc );
	CReaderWriterLockGroupInfo::Dump( dc );
	CLockDeadlockDetectionInfo::Dump( dc );
	}

void CReaderWriterLock::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CReaderWriterLockState, CSyncBasicInfo, CReaderWriterLockInfo, CLockBasicInfo >::Dump( dc );
	}


//  Metered Section Dump Support

void CMeteredSection::Dump( CDumpContext& dc ) const
	{
	DumpMember( dc, m_pfnPartitionComplete );
	DumpMember( dc, m_dwPartitionCompleteKey );

	DumpMember( dc, m_cw );
	DumpMemberBF( dc, m_cCurrent );
	DumpMemberBF( dc, m_groupCurrent );
	DumpMemberBF( dc, m_cQuiesced );
	DumpMemberBF( dc, m_groupQuiesced );
	}


//  S / X / W Latch Dump Support

void CSXWLatchState::Dump( CDumpContext& dc ) const
	{
	DumpMember( dc, m_cw );
	DumpMemberBF( dc, m_cOAWX );
	DumpMemberBF( dc, m_cOOWS );
	DumpMemberBF( dc, m_fQS );
	DumpMemberBF( dc, m_cQS );
	DumpMember( dc, m_semS );
	DumpMember( dc, m_semX );
	DumpMember( dc, m_semW );
	}

void CSXWLatchPerfInfo::Dump( CDumpContext& dc ) const
	{
	CSyncPerfWait::Dump( dc );
	CSyncPerfAcquire::Dump( dc );
	CLockPerfHold::Dump( dc );
	}

void CSXWLatchGroupInfo::Dump( CDumpContext& dc ) const
	{
	for ( int iGroup = 0; iGroup < 3; iGroup++ )
		{
		m_rginfo[iGroup].Dump( dc );
		}
	}

void CSXWLatchInfo::Dump( CDumpContext& dc ) const
	{
	CLockBasicInfo::Dump( dc );
	CSXWLatchGroupInfo::Dump( dc );
	CLockDeadlockDetectionInfo::Dump( dc );
	}

void CSXWLatch::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CSXWLatchState, CSyncBasicInfo, CSXWLatchInfo, CLockBasicInfo >::Dump( dc );
	}

#endif  //  DEBUGGER_EXTENSION

//  Sync Stats support

CIPrintF*		piprintfPerfData;
CFPrintF*		pfprintfPerfData;

//  dump column descriptors

void OSSyncStatsDumpColumns()
	{
	(*piprintfPerfData)(	"Type Name\t"
							"Instance Name\t"
							"Instance ID\t"
							"Group ID\t"
							"Wait Count\t"
							"Wait Time Elapsed\t"
							"Acquire Count\t"
							"Contention Count\t"
							"Hold Count\t"
							"Hold Time Elapsed\r\n" );
	}

//  dump cooked stats from provided raw stats

void OSSyncStatsDump(	const char*			szTypeName,
						const char*			szInstanceName,
						const CSyncObject*	psyncobj,
						DWORD				group,
						QWORD				cWait,
						double				csecWaitElapsed,
						QWORD				cAcquire,
						QWORD				cContend,
						QWORD				cHold,
						double				csecHoldElapsed )
	{
	//  dump data, if interesting
		
	if ( cWait || cAcquire || cContend || cHold )
		{
		(*piprintfPerfData)(	"\"%s\"\t"
								"\"%s\"\t"
								"\"0x%0*I64X\"\t"
								"%d\t"
								"%I64d\t"
								"%f\t"
								"%I64d\t"
								"%I64d\t"
								"%I64d\t"
								"%f\r\n",
								szTypeName,
								szInstanceName,
								sizeof(LONG_PTR) * 2,			//	need 2 hex digits for each byte
								QWORD( LONG_PTR( psyncobj ) ),	//	assumes QWORD is largest pointer size we'll ever use
								group,
								cWait,
								csecWaitElapsed,
								cAcquire,
								cContend,
								cHold,
								csecHoldElapsed );
		}
	}


volatile DWORD cOSSyncInit;  //  assumed init to 0 by the loader

//	cleanup sync subsystem for term (or error on init)

static void OSSYNCAPI OSSyncICleanup()
	{
	OSSYNCAssert( (long)cOSSyncInit == lOSSyncLockedForTerm
				|| (long)cOSSyncInit == lOSSyncLockedForInit );

	//  free PLS

	FOSSyncConfigureProcessorLocalStorage( 0 );

#ifdef SYNC_DUMP_PERF_DATA

	//  terminate performance data dump context

	if ( NULL != piprintfPerfData )
		{
		((CIPrintF*)piprintfPerfData)->~CIPrintF();
		LocalFree( piprintfPerfData );
		piprintfPerfData = NULL;
		}

	if ( NULL != piprintfPerfData )
		{
		((CFPrintF*)pfprintfPerfData)->~CFPrintF();
		LocalFree( pfprintfPerfData );
		pfprintfPerfData = NULL;
		}

#endif  //  SYNC_DUMP_PERF_DATA

	//  terminate the Kernel Semaphore Pool

	if ( ksempoolGlobal.FInitialized() )
		{
		ksempoolGlobal.Term();
		}

	//  terminate the CEnhancedState allocator

	OSSYNCAssert( g_pmbRoot == &g_mbSentry );
	while ( g_pmbRootFree != &g_mbSentryFree )
		{
		MemoryBlock* const pmb = g_pmbRootFree;

		*pmb->ppmbNext = pmb->pmbNext;
		pmb->pmbNext->ppmbNext = pmb->ppmbNext;
		
		BOOL fMemFreed = VirtualFree( pmb, 0, MEM_RELEASE );
		OSSYNCAssert( fMemFreed );
		}
	DeleteCriticalSection( &g_csESMemory );
	
	DeleteCriticalSection( &csClsSyncGlobal );

#ifdef DEBUGGER_EXTENSION
	//  term OSSYM

	SymTerm();
#endif

	//	unlock sync subsystem

	OSSYNCAssert( (long)cOSSyncInit == lOSSyncLockedForTerm
				|| (long)cOSSyncInit == lOSSyncLockedForInit );
	AtomicExchange( (long*)&cOSSyncInit, 0 );
	}


//  init sync subsystem

static BOOL FOSSyncIInit()
	{
	BOOL	fInitRequired	= fFalse;

	OSSYNC_FOREVER
		{
		const long	lInitial	= ( cOSSyncInit & lOSSyncUnlocked );
		const long	lFinal		= ( 0 == lInitial ? lOSSyncLockedForInit : lInitial + 1 );

		//	if multiple threads try to init/term simultaneously, one will win
		//	and the others will loop until he's done

		if ( lInitial == AtomicCompareExchange( (long*)&cOSSyncInit, lInitial, lFinal ) )
			{
			fInitRequired = ( 0 == lInitial );
			break;
			}
		else if ( cOSSyncInit & lOSSyncLocked )
			{
			//	our AtomicCompareExchange() appears to have failed because
			//	the sync subsystem is locked for init/term, so sleep a bit
			//	to allow time for the init/term to complete
			Sleep( 1 );
			}
		}

	if ( fInitRequired )
		{
		//  reset all pointers

		piprintfPerfData	= NULL;
		pfprintfPerfData	= NULL;
		
		//  reset global CLS list

		InitializeCriticalSection( &csClsSyncGlobal );
		pclsSyncGlobal		= NULL;
		pclsSyncCleanGlobal	= NULL;
		cclsSyncGlobal		= 0;
		dwClsSyncIndex		= dwClsInvalid;
		dwClsProcIndex		= dwClsInvalid;
		
		//  iniitalize the HRT

		OSTimeHRTInit();
		
		//  initialize the CEnhancedState allocator

		SYSTEM_INFO sinf;
		GetSystemInfo( &sinf );
		g_cbMemoryBlock = sinf.dwAllocationGranularity;
		g_pmbRoot = &g_mbSentry;
		g_mbSentry.pmbNext = NULL;
		g_mbSentry.ppmbNext = &g_pmbRoot;
		g_mbSentry.cAlloc = 1;
		g_mbSentry.ibFreeMic = g_cbMemoryBlock;
		g_pmbRootFree = &g_mbSentryFree;
		g_mbSentryFree.pmbNext = NULL;
		g_mbSentryFree.ppmbNext = &g_pmbRootFree;
		g_mbSentryFree.cAlloc = 0;
		g_mbSentryFree.ibFreeMic = 0;
		InitializeCriticalSection( &g_csESMemory );

		//  initialize the Kernel Semaphore Pool

		if ( !ksempoolGlobal.FInit() )
			{
			goto HandleError;
			}

		//  cache the processor count

		DWORD_PTR maskProcess;
		DWORD_PTR maskSystem;
		BOOL fGotAffinityMask;
		fGotAffinityMask = GetProcessAffinityMask(	GetCurrentProcess(),
													&maskProcess,
													&maskSystem );
		OSSYNCAssert( fGotAffinityMask );

		for ( g_cProcessor = 0; maskProcess != 0; maskProcess >>= 1 )
			{
			if ( maskProcess & 1 )
				{
				g_cProcessor++;
				}
			}

		for ( g_cProcessorMax = 0; maskSystem != 0; maskSystem >>= 1 )
			{
			if ( maskSystem & 1 )
				{
				g_cProcessorMax++;
				}
			}

	    //  cache system max spin count
	    //
	    //  NOTE:  spins heavily as WaitForSingleObject() is extremely expensive
	    //
	    //  CONSIDER:  get spin count from persistent configuration

	    cSpinMax = g_cProcessor == 1 ? 0 : 256;

	    //  if we are running on NT build 2463 and later then we can read the
	    //  current processor from the TEB

		OSVERSIONINFO osvi;
		memset( &osvi, 0, sizeof( osvi ) );
		osvi.dwOSVersionInfoSize = sizeof( osvi );
		if ( !GetVersionEx( &osvi ) )
			{
			goto HandleError;
			}

	    g_fGetCurrentProcFromTEB = (	osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
	    								osvi.dwBuildNumber >= 2463 );

#ifdef SYNC_DUMP_PERF_DATA

		//  initialize performance data dump context

		char szTempPath[_MAX_PATH];
		if ( !GetTempPath( _MAX_PATH, szTempPath ) )
			{
			goto HandleError;
			}

		char szProcessPath[_MAX_PATH];
		char szProcess[_MAX_PATH];
		if ( !GetModuleFileName( NULL, szProcessPath, _MAX_PATH ) )
			{
			goto HandleError;
			}
		_splitpath( szProcessPath, NULL, NULL, szProcess, NULL );

		MEMORY_BASIC_INFORMATION mbi;
		if ( !VirtualQueryEx( GetCurrentProcess(), FOSSyncIInit, &mbi, sizeof( mbi ) ) )
			{
			goto HandleError;
			}
		char szModulePath[_MAX_PATH];
		char szModule[_MAX_PATH];
		if ( !GetModuleFileName( HINSTANCE( mbi.AllocationBase ), szModulePath, sizeof( szModulePath )/sizeof( szModulePath[0]  ) )
			{
			goto HandleError;
			}
		_splitpath( szModulePath, NULL, NULL, szModule, NULL );

		SYSTEMTIME systemtime;
		GetLocalTime( &systemtime );

		char szPerfData[_MAX_PATH];
		sprintf(	szPerfData,
					"%s%s %s Sync Stats %04d%02d%02d%02d%02d%02d.TXT",
					szTempPath,
					szProcess,
					szModule,
					systemtime.wYear,
					systemtime.wMonth,
					systemtime.wDay,
					systemtime.wHour,
					systemtime.wMinute,
					systemtime.wSecond );

		if ( !( pfprintfPerfData = (CFPrintF*)LocalAlloc( 0, sizeof( CFPrintF ) ) ) )
			{
			goto HandleError;
			}
		new( (CFPrintF*)pfprintfPerfData ) CFPrintF( szPerfData );

		if ( !( piprintfPerfData = (CIPrintF*)LocalAlloc( 0, sizeof( CIPrintF ) ) ) )
			{
			goto HandleError;
			}
		new( (CIPrintF*)piprintfPerfData ) CIPrintF( pfprintfPerfData );

		OSSyncStatsDumpColumns();

#endif  //  SYNC_DUMP_PERF_DATA


		//	unlock sync subsystem

		OSSYNCAssert( (long)cOSSyncInit == lOSSyncLockedForInit );
		AtomicExchange( (long*)&cOSSyncInit, 1 );
		}

	return fTrue;

HandleError:
	OSSyncICleanup();
	return fFalse;
	}

const BOOL OSSYNCAPI FOSSyncPreinit()
	{
	//  make sure we are initialized and
	//	add an initial ref for the process
	return FOSSyncIInit();
	}


//  terminate sync subsystem

static void OSSyncITerm()
	{
	OSSYNC_FOREVER
		{
		const long	lInitial		= ( cOSSyncInit & lOSSyncUnlocked );
		if ( 0 == lInitial )
			{
			//	sync subsystem not initialised
			//	(or someone else is already
			//	terminating it)
			break;
			}

#ifdef SYNC_ENHANCED_STATE
		const BOOL	fTermRequired	= ( ksempoolGlobal.CksemAlloc() + 1 == lInitial );
#else
		const BOOL	fTermRequired	= ( 1 == lInitial );
#endif
		const long	lFinal			= ( fTermRequired ? lOSSyncLockedForTerm : lInitial - 1 );

		//	if multiple threads try to init/term simultaneously, one will win
		//	and the others will loop until he's done

		if ( lInitial == AtomicCompareExchange( (long*)&cOSSyncInit, lInitial, lFinal ) )
			{
			if ( fTermRequired )
				OSSyncICleanup();
			break;
			}
		else if ( cOSSyncInit & lOSSyncLocked )
			{
			//	our AtomicCompareExchange() appears to have failed because
			//	the sync subsystem is locked for init/term, so sleep a bit
			//	to allow time for the init/term to complete
			Sleep( 1 );
			}
		}
	}

void OSSYNCAPI OSSyncPostterm()
	{
	//	remove any remaining CLS allocated by NT thread pool threads,
	//	which don't seem to perform a DLL_THREAD_DETACH when the
	//	process dies (this will also free any other CLS that got
	//	orphaned for whatever unknown reason)

	while ( NULL != pclsSyncGlobal )
		{
		OSSyncIDetach( pclsSyncGlobal );
		}

	//	on a normal shutdown, there should be exactly 1 refcount left,
	//	but there may also be none if this is being called as
	//	part of error-handling during init
#ifdef SYNC_ENHANCED_STATE
#else  //  !SYNC_ENHANCED_STATE
	OSSYNCAssert( 0 == cOSSyncInit || 1 == cOSSyncInit );
#endif  //  SYNC_ENHANCED_STATE
	OSSyncITerm();
	}



const BOOL OSSYNCAPI FOSSyncInitForES()
	{
#ifdef SYNC_ENHANCED_STATE
	return FOSSyncIInit();
#else
	return fTrue;
#endif
	}

void OSSYNCAPI OSSyncTermForES()
	{
#ifdef SYNC_ENHANCED_STATE
	if ( lOSSyncLockedForTerm == cOSSyncInit )
		{
		//	SPECIAL CASE: we're in the middle of
		//	terminating the subsystem and end up
		//	recursively calling OSSyncTermForES
		//	when we clean up ksempoolGlobal
		return;
		}

	OSSyncITerm();
#endif
	}

};  //  namespace OSSYNC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\eseutil\eseutil.cxx ===
#include <windows.h>

#ifdef DEBUG
#undef NDEBUG		//	enable asserts
#endif

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <conio.h>
#include <tchar.h>

#include "jet.h"
#include "ntverp.h"

#include "_edbutil.hxx"
#include "utilmsg.h"		// UNDONE: Header file generated by MC, which currently only generates .h files.

#include "esefile.hxx"
#undef UNICODE				//	esefile.hxx enables UNICODE


#include <esebcli2.h>
#define ESEBCLI2_DLL_NAME	"ESEBCLI2.DLL"

// the sever simulation functionality will be available in
// both debug and retail but the help will be DEBUG only
// (like an unsupported functionality)
#define RESTORE_SERVER_SIMULATION

#ifdef DEBUG
#define RESTORE_SERVER_SIMULATION_HELP
#endif

#ifdef RESTORE_SERVER_SIMULATION
#include <eseback2.h>
#define ESEBACK2_DLL_NAME	"ESEBACK2.DLL"
#endif // RESTORE_SERVER_SIMULATION

#ifdef DEBUG
#define RECORD_FORMAT_UPGRADE
#endif

//#define LOG_SHIPPING


//	use this to protect invalid code paths that PREfix complains about

#ifdef _PREFIX_
#define AssertPREFIX( exp )			( ( exp ) ? (void)0 : exit(-1) )
#else
#define AssertPREFIX( exp )			assert( exp )
#endif


LOCAL const char	* const szUser			= "user";
LOCAL const char	* const szPassword		= "";


// UNDONE:  Must still be localised, but centralising all the localisable strings
// here makes my job easier.

LOCAL const char	* const	szCurrDir					= ".";

LOCAL const char	* const szStreamingFileExt			= "STM";

LOCAL const char	* const szDefaultTempDBFormat		= "TEMP%d.EDB";
LOCAL const char	* const szDefaultDefragDBFormat		= "TEMPDFRG%d.EDB";
LOCAL const char	* const szDefaultUpgradeDBFormat	= "TEMPUPGD%d.EDB";
LOCAL const char	* const szDefaultRepairDBFormat		= "TEMPREPAIR%d.EDB";
LOCAL const char	* const szDefaultIntegDBFormat		= "TEMPINTEG%d.EDB";
LOCAL const char	* const szDefaultScrubDBFormat		= "TEMPSCRUB%d.EDB";

LOCAL char szDefaultTempDB[64];
LOCAL char szDefaultDefragDB[64];
LOCAL char szDefaultUpgradeDB[64];
LOCAL char szDefaultRepairDB[64];
LOCAL char szDefaultIntegDB[64];
LOCAL char szDefaultScrubDB[64];

LOCAL char szSourceStreamFileName[ _MAX_PATH + 1 ];
LOCAL char szTempStreamFileName[ _MAX_PATH + 1 ];

LOCAL const char	* const szDefrag				= "Defragmentation";
LOCAL const char	* const szUpgrade				= "Upgrade";
LOCAL const char	* const szRestore				= "Restore";
LOCAL const char	* const szRepair				= "Scanning";
LOCAL const char	* const szScrub					= "Securing";
LOCAL const char	* const szUpgradeRecordFormat	= "Upgrading Record Format";
LOCAL const char	* const szIntegrity				= "Integrity";
LOCAL const char	* const szChecksum				= "Checksum";

LOCAL const char	* const szStatusMsg		= " Status (% complete)";

LOCAL const char	* const szMoveFile		= "\nMoving '%s' to '%s'...";
LOCAL const char	* const szMoveDone		= " DONE!";
LOCAL const char	* const szMoveFailed	= " FAILED!";
LOCAL const char	* const szCopyFile		= " Copying...";
LOCAL const char	* const szCopyFileStatus= "File Copy";

LOCAL const char	cNewLine				= '\n';

LOCAL const char	* const szSwitches		= "-/";

LOCAL const char	* const szRegistryMsg	= "Using Registry environment...";

LOCAL const char	* const szErr1			= "Error: Source database specification '%s' is invalid.";
LOCAL const char	* const szErr2			= "Error: Temporary database specification '%s' is invalid.";
LOCAL const char	* const szErr3			= "Error: Source database '%s' cannot be the same as the temporary database.";
LOCAL const char	* const szErr4			= "Error: Could not backup to '%s'.";
LOCAL const char	* const szErr5			= "Error: Could not re-instate '%s'. It may be manually re-instated by manually copying '%s' to '%s' (this will overwrite the original copy of the file with the defragmented copy).";
LOCAL const char	* const szErr6			= "Error: Failed loading Registry Environment.";

LOCAL const _TCHAR	* const szErr7			= _T( "Error: Failed to load DLL %s.\r\n" );
LOCAL const _TCHAR	* const szErr8			= _T( "Error: Failed to load function %s from DLL.\r\n" );

LOCAL const char	* const szUsageErr1		= "Usage Error: Missing %s specification.";
LOCAL const char	* const szUsageErr2		= "Usage Error: Duplicate %s specification.";
LOCAL const char	* const szUsageErr3		= "Usage Error: Only one type of recovery allowed.";
LOCAL const char	* const szUsageErr4		= "Usage Error: Invalid option '%s'.";
LOCAL const char	* const szUsageErr5		= "Usage Error: Invalid argument '%s'. Options must be preceded by '-' or '/'.";
LOCAL const char	* const szUsageErr6		= "Usage Error: Invalid buffer cache size.";
LOCAL const char	* const szUsageErr7		= "Usage Error: Invalid batch I/O size.";
LOCAL const char	* const szUsageErr8		= "Usage Error: Invalid database extension size.";
LOCAL const char	* const szUsageErr9		= "Usage Error: No mode specified.";
LOCAL const char	* const szUsageErr10	= "Usage Error: Mode selection must be preceded by '-' or '/'.";
LOCAL const char	* const szUsageErr11	= "Usage Error: Old .DLL required in order to upgrade.";
LOCAL const char	* const szUsageErr12	= "Usage Error: Invalid mode.";
LOCAL const char	* const szUsageErr13	= "Usage Error: Invalid node/lgpos specification.";
LOCAL const char	* const szUsageErr14	= "Usage Error: Invalid logfile size: %s kbytes.";

#ifdef ESENT
LOCAL const char	* const szHelpDesc1		= "DESCRIPTION:  Maintenance utilities for Microsoft(R) Windows(R) databases.";
#else  //  !ESENT
LOCAL const char	* const szHelpDesc1		= "DESCRIPTION:  Maintenance utilities for Microsoft(R) Exchange Server databases.";
#endif  //  ESENT
LOCAL const char	* const szHelpSyntax	= "MODES OF OPERATION:";
LOCAL const char	* const szHelpModes1	= "      Defragmentation:  %s /d <database name> [options]";
LOCAL const char	* const szHelpModes2	= "             Recovery:  %s /r <logfile base name> [options]";
LOCAL const char	* const szHelpModes3	= "            Integrity:  %s /g <database name> [options]";
LOCAL const char	* const szHelpModes4	= "             Checksum:  %s /k <database name> [options]";
LOCAL const char	* const szHelpModes5	= "               Repair:  %s /p <database name> [options]";
LOCAL const char	* const szHelpModes6	= "            File Dump:  %s /m[mode-modifier] <filename>";
LOCAL const char	* const szHelpModes7	= "              Restore:  %s /c[mode-modifier] <path name> [options]";
LOCAL const char	* const szHelpModes8	= "               Backup:  %s /b <backup path> [options]";
LOCAL const char	* const szHelpModes9	= "             SLV Move:  %s /s <database name> /p<page>";
LOCAL const char	* const szHelpModes10	= "Record format Upgrade:  %s /f <database name>";
LOCAL const char	* const szHelpModes11	= "              Upgrade:  %s /u <database name> [options]";
LOCAL const char	* const	szHelpModes12	= "               Secure:  %s /z <database name> [options]";

LOCAL const char	* const szHelpPrompt1	= "<<<<<  Press a key for more help  >>>>>";
LOCAL const char	* const szHelpPrompt2	= "D=Defragmentation, R=Recovery, G=inteGrity, K=checKsum, P=rePair, M=file duMp";
#ifdef DEBUG
LOCAL const char	* const szHelpPrompt3	= "C=restore, B=Backup, S=Slv move, F=record Format upgrade, U=upgrade, Z=secure";
#endif
LOCAL const char	* const szHelpPromptCursor	= "=> ";

LOCAL const char	szRepairMessage[]		=
	"You should only run Repair on damaged or corrupted databases. Repair will not apply information in the "
	"transaction log files to the database, and may cause information to be lost. Do you wish to proceed?";

LOCAL const char	szRepairCaption[]		= "Warning";

LOCAL const char * const	szOperSuccess			= "Operation completed successfully in %d.%d seconds.";
LOCAL const char * const	szOperWarn				= "Operation completed successfully with %d (%s) after %d.%d seconds.";
LOCAL const char * const	szOperFailWithError		= "Operation terminated with error %d (%s) after %d.%d seconds.";
LOCAL const char * const	szOperFailUnknownError	= "Operation terminated unsuccessfully after %d.%d seconds.";

#define cbMsgBufMax	256

extern void JetErrorToString( JET_ERR err, const char **szError, const char **szErrorText );

typedef JET_ERR (__stdcall FNJETINIT)( JET_INSTANCE *pinstance );               
typedef JET_ERR (__stdcall FNJETINIT2)( JET_INSTANCE *pinstance, JET_GRBIT grbit );               
typedef JET_ERR (__stdcall FNJETTERM2)( JET_INSTANCE instance, JET_GRBIT grbit );
typedef JET_ERR (__stdcall FNJETSETSYSTEMPARAMETER)(                          
                                        JET_INSTANCE *pinstance,              
                                        JET_SESID sesid,                      
                                        unsigned long paramid,                
                                        JET_API_PTR lParam,                 
                                        const char *sz );                      
typedef JET_ERR (__stdcall FNJETGETSYSTEMPARAMETER)(
										JET_INSTANCE	instance,
										JET_SESID		sesid,
										unsigned long	paramid,
										JET_API_PTR		*plParam,
										char			*sz,
										unsigned long	cbMax );
typedef JET_ERR (__stdcall FNJETCOMPACT)(
										JET_SESID		sesid,
										const char		*szDatabaseSrc,
										const char		*szDatabaseDest,
										JET_PFNSTATUS	pfnStatus,
										JET_CONVERT		*pconvert,
										JET_GRBIT		grbit );
typedef JET_ERR (__stdcall FNJETBEGINSESSION)(
										JET_INSTANCE	instance,
										JET_SESID		*psesid,
										const char		*szUsername,
										const char		*szPassword );
typedef JET_ERR (__stdcall FNJETDETACHDATABASE)(
										JET_SESID sesid,
										const char *szFilename );
typedef JET_ERR (__stdcall FNJETENDSESSION)( JET_SESID sesid, JET_GRBIT grbit );
typedef JET_ERR (__stdcall FNJETRESTORE2)(
										const char *sz,
										const char *szDest,
										JET_PFNSTATUS pfn );
typedef JET_ERR (__stdcall FNJETBACKUP)(
										const char		*szBackupPath,
										JET_GRBIT		grbit,
										JET_PFNSTATUS	pfnStatus );
typedef JET_ERR (__stdcall FNJETDBUTILITIES)( JET_DBUTIL *pdbutil );

LOCAL HMODULE					g_hmod 	= NULL;

LOCAL FNJETINIT					* g_pfnJetInit 				= JetInit;
LOCAL FNJETINIT2   				* g_pfnJetInit2				= JetInit2;
LOCAL FNJETTERM2				* g_pfnJetTerm2				= JetTerm2;
LOCAL FNJETSETSYSTEMPARAMETER	* g_pfnJetSetSystemParameter= JetSetSystemParameter;
LOCAL FNJETGETSYSTEMPARAMETER	* g_pfnJetGetSystemParameter= JetGetSystemParameter;
LOCAL FNJETCOMPACT				* g_pfnJetCompact			= JetCompact;
LOCAL FNJETBEGINSESSION			* g_pfnJetBeginSession		= JetBeginSession;
LOCAL FNJETDETACHDATABASE		* g_pfnJetDetachDatabase	= JetDetachDatabase;
LOCAL FNJETENDSESSION			* g_pfnJetEndSession		= JetEndSession;
LOCAL FNJETRESTORE2				* g_pfnJetRestore2			= JetRestore2;
LOCAL FNJETBACKUP				* g_pfnJetBackup			= JetBackup;
LOCAL FNJETDBUTILITIES			* g_pfnJetDBUtilities		= JetDBUtilities;

#define JetInit (*g_pfnJetInit)
#define JetInit2 (*g_pfnJetInit2)
#define JetTerm2 (*g_pfnJetTerm2)
#define JetSetSystemParameter (*g_pfnJetSetSystemParameter)
#define JetGetSystemParameter (*g_pfnJetGetSystemParameter)
#define JetCompact (*g_pfnJetCompact)
#define JetBeginSession (*g_pfnJetBeginSession)
#define JetDetachDatabase (*g_pfnJetDetachDatabase)
#define JetEndSession (*g_pfnJetEndSession)
#define JetRestore2 (*g_pfnJetRestore2)
#define JetBackup (*g_pfnJetBackup)
#define JetDBUtilities (*g_pfnJetDBUtilities)

const _TCHAR * const szJetInit 					= _T( "JetInit");
const _TCHAR * const szJetInit2 				= _T( "JetInit2");
const _TCHAR * const szJetTerm2 				= _T( "JetTerm2");
const _TCHAR * const szJetSetSystemParameter	= _T( "JetSetSystemParameter");
const _TCHAR * const szJetGetSystemParameter	= _T( "JetGetSystemParameter");
const _TCHAR * const szJetCompact				= _T( "JetCompact");
const _TCHAR * const szJetBeginSession			= _T( "JetBeginSession");
const _TCHAR * const szJetDetachDatabase		= _T( "JetDetachDatabase");
const _TCHAR * const szJetEndSession			= _T( "JetEndSession");
const _TCHAR * const szJetRestore2				= _T( "JetRestore2");
const _TCHAR * const szJetBackup				= _T( "JetBackup");
const _TCHAR * const szJetDBUtilities			= _T( "JetDBUtilities");

//  ================================================================
JET_ERR ErrGetProcAddress(
			const HMODULE hmod,
			const _TCHAR * const szFunc,
			VOID ** const pvPfn )
//  ================================================================
	{
	if( NULL == ( (*pvPfn) = GetProcAddress( hmod, szFunc ) ) )
		{
		_tprintf( szErr8, szFunc );
		return JET_errCallbackNotResolved;
		}
	return JET_errSuccess;
	}

//  ================================================================
JET_ERR ErrUseDifferentDLL(	const _TCHAR * const szLibrary )
//  ================================================================
	{
	JET_ERR 		err;

	assert( NULL == g_hmod );

	_tprintf( "Loading %s...\r\n", szLibrary );
	
	g_hmod = LoadLibraryEx( szLibrary, NULL, 0 );
	if( NULL == g_hmod )
		{
		_tprintf( szErr7, szLibrary );
		Call( JET_errCallbackNotResolved );
		}

	Call( ErrGetProcAddress( g_hmod, szJetInit, (VOID **)&g_pfnJetInit ) );
///	Call( ErrGetProcAddress( g_hmod, szJetInit2, (VOID **)&g_pfnJetInit2 ) );
	Call( ErrGetProcAddress( g_hmod, szJetTerm2, (VOID **)&g_pfnJetTerm2 ) );
	Call( ErrGetProcAddress( g_hmod, szJetSetSystemParameter, (VOID **)&g_pfnJetSetSystemParameter ) );
	Call( ErrGetProcAddress( g_hmod, szJetGetSystemParameter, (VOID **)&g_pfnJetGetSystemParameter ) );
	Call( ErrGetProcAddress( g_hmod, szJetCompact, (VOID **)&g_pfnJetCompact ) );
	Call( ErrGetProcAddress( g_hmod, szJetBeginSession, (VOID **)&g_pfnJetBeginSession ) );
	Call( ErrGetProcAddress( g_hmod, szJetDetachDatabase, (VOID **)&g_pfnJetDetachDatabase ) );
	Call( ErrGetProcAddress( g_hmod, szJetEndSession, (VOID **)&g_pfnJetEndSession ) );
	Call( ErrGetProcAddress( g_hmod, szJetRestore2, (VOID **)&g_pfnJetRestore2 ) );
	Call( ErrGetProcAddress( g_hmod, szJetBackup, (VOID **)&g_pfnJetBackup ) );
	Call( ErrGetProcAddress( g_hmod, szJetDBUtilities, (VOID **)&g_pfnJetDBUtilities ) );

HandleError:
	return err;
	}
	
LOCAL CHAR	*GetNextArg();
LOCAL CHAR	*GetPrevArg();
LOCAL VOID	SetCurArgID( const INT id );
LOCAL INT	GetArgCount();
LOCAL INT	GetCurArgID();
LOCAL CHAR	*GetCurArg();

INLINE VOID EDBUTLFormatMessage( ULONG ulMsgId, CHAR *szMsgBuf, CHAR *szMsgArg )
	{
	DWORD	err;
	CHAR	*rgszMsgArgs[1] = { szMsgArg };		// Currently only support one argument.
	
	if ( szMsgArg )
		{
		err = FormatMessage(
			FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_ARGUMENT_ARRAY,
			NULL,
			ulMsgId,
			LANG_USER_DEFAULT,
			szMsgBuf,
			cbMsgBufMax,
			reinterpret_cast<va_list *>( rgszMsgArgs )  );
		}
	else
		{
		err = FormatMessage(
			FORMAT_MESSAGE_FROM_HMODULE,
			NULL,
			ulMsgId,
			LANG_USER_DEFAULT,
			szMsgBuf,
			cbMsgBufMax,
			NULL );
		}
	if ( err == 0 )
		{
		// Format message failed.  No choice but to dump the error message
		// in English, then bail out.
		printf( "Unexpected Win32 error: %dL\n\n", GetLastError() );
		exit(1);
		}
	}
	

// Allocates a local buffer for the message, retrieves the message, and prints it out.
LOCAL VOID EDBUTLPrintMessage( ULONG ulMsgId, CHAR *szMsgArg )
	{
	CHAR	szMsgBuf[cbMsgBufMax];

	EDBUTLFormatMessage( ulMsgId, szMsgBuf, szMsgArg );
	printf( "%s", szMsgBuf );
	}
		

LOCAL VOID EDBUTLPrintLogo( void )
	{
	CHAR	szVersion[8];

	sprintf( szVersion, "%d.%d", VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION );
	
#ifdef ESENT
	EDBUTLPrintMessage( NTPRODUCTNAME_ID, NULL );
#else  //  !ESENT
	EDBUTLPrintMessage( PRODUCTNAME_ID, NULL );
#endif  //  ESENT
	EDBUTLPrintMessage( VERSION_ID, szVersion );
	EDBUTLPrintMessage( COPYRIGHT_ID, NULL );
	}

LOCAL VOID EDBUTLHelpDefrag( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "DEFRAGMENTATION/COMPACTION:%c", cNewLine );
	printf( "    DESCRIPTION:  Performs off-line compaction of a database.%c", cNewLine );
	printf( "         SYNTAX:  %s /d <database name> [options]%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name> - filename of database to compact%c", cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /s<file>   - set streaming file name (default: NONE)%c", cNewLine );
	printf( "                  /t<db>     - set temp. database name (default: TEMPDFRG*.EDB)%c", cNewLine );
	printf( "                  /f<file>   - set temp. streaming file name%c", cNewLine );
	printf( "                               (default: TEMPDFRG*.STM)%c", cNewLine );
	printf( "                  /i         - do not defragment streaming file%c", cNewLine );
	printf( "                  /p         - preserve temporary database (ie. don't instate)%c", cNewLine );
	printf( "                  /b<db>     - make backup copy under the specified name%c", cNewLine );
#ifdef DEBUG	// Undocumented switches.
	printf( "                  /n         - dump defragmentation information to DFRGINFO.TXT%c", cNewLine );
	printf( "                  /x<#>      - database extension size, in pages (default: 256)%c", cNewLine );
	printf( "                  /w         - set batch IO size%c", cNewLine );
#endif	
	printf( "                  /8         - set 8k database page size (default: auto-detect)%c", cNewLine );
	printf( "                  /o         - suppress logo%c", cNewLine );
	printf( "          NOTES:  1) If instating is disabled (ie. /p), the original database%c", cNewLine );
	printf( "                     is preserved uncompacted, and the temporary database will%c", cNewLine );
	printf( "                     contain the defragmented version of the database.%c", cNewLine );
	}

LOCAL VOID EDBUTLHelpRecovery( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "RECOVERY:%c", cNewLine );
	printf( "    DESCRIPTION:  Performs recovery, bringing all databases to a%c", cNewLine );
	printf( "                  consistent state.%c", cNewLine );
	printf( "         SYNTAX:  %s /r <3-character logfile base name> [options]%c", szAppName, cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /l<path>   - location of log files%c", cNewLine );
	printf( "                               (default: current directory)%c", cNewLine );
	printf( "                  /s<path>   - location of system files (eg. checkpoint file)%c", cNewLine );
	printf( "                               (default: current directory)%c", cNewLine );
#ifdef LOG_SHIPPING	
	printf( "                  /f         - replaying replicated log files%c", cNewLine );
#endif	
	printf( "                  /i         - ignore mismatched/missing database attachments%c", cNewLine );
	printf( "                  /d[path]   - location of database files, or current directory%c", cNewLine );
	printf( "                               if [path] not specified (default: directory%c", cNewLine );
	printf( "                               originally logged in log files)%c", cNewLine ); 
#ifdef DEBUG
	printf( "                  /b<path>   - restore from backup (ie. hard recovery) from the%c", cNewLine );
	printf( "                               specified location%c", cNewLine );
	printf( "                  /r<path>   - restore to specified location (only valid when%c", cNewLine );
	printf( "                               the /b switch is also specified)%c", cNewLine );
#endif
	printf( "                  /8         - set 8k database page size (default: 4k)%c", cNewLine );
	printf( "                  /o         - suppress logo%c", cNewLine );
#ifdef DEBUG
	printf( "          NOTES:  1) Soft recovery is always performed unless the /b switch is%c", cNewLine );
	printf( "                     specified, in which case hard recovery is performed.%c", cNewLine );
#endif
	}

LOCAL VOID EDBUTLHelpIntegrity( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "INTEGRITY:%c", cNewLine );
	printf( "    DESCRIPTION:  Verifies integrity of a database.%c", cNewLine );
	printf( "         SYNTAX:  %s /g <database name> [options]%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name> - filename of database to verify%c", cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /s<file>  - set streaming file name (default: NONE)%c", cNewLine );
	printf( "                  /t<db>    - set temp. database name (default: TEMPINTEG*.EDB)%c", cNewLine );
	printf( "                  /f<name>  - set prefix to use for name of report files%c", cNewLine );
	printf( "                              (default: <database>.integ.raw)%c", cNewLine );
#ifdef DEBUG	// Undocumented switches.
	printf( "                  /b        - don't rebuild and compare indexes%c", cNewLine );
	printf( "                  /n        - dump table statistics to INTGINFO.TXT%c", cNewLine );
#endif	//	DEBUG
	printf( "                  /8        - set 8k database page size (default: auto-detect)%c", cNewLine );
	printf( "                  /o        - suppress logo%c", cNewLine );
	printf( "          NOTES:  1) Integrity-check does not run database recovery. If a%c", cNewLine );
	printf( "                     database is in a \"Dirty Shutdown\" state it is strongly%c", cNewLine );
	printf( "                     recommended that before proceeding with an integrity-%c", cNewLine );
	printf( "                     check, recovery is first run to properly complete%c", cNewLine );
	printf( "                     database operations for the previous shutdown.%c", cNewLine );
	}

LOCAL VOID EDBUTLHelpChecksum( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "CHECKSUM:%c", cNewLine );
	printf( "    DESCRIPTION:  Verifies the individual checksum of each page of a database.%c", cNewLine );
	printf( "         SYNTAX:  %s /k <database name> [options]%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name> - filename of database to verify%c", cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /8   - set 8k database page size (default: auto-detect)%c", cNewLine );
	printf( "                  /o   - suppress logo%c", cNewLine );
	}

LOCAL VOID EDBUTLHelpRepair( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "REPAIR:%c", cNewLine );
	printf( "    DESCRIPTION:  Repairs a corrupted or damaged database.%c", cNewLine );
	printf( "         SYNTAX:  %s /p <database name> [options]%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name> - filename of database to repair%c", cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /s<file>   - set streaming file name (default: NONE)%c", cNewLine );
	printf( "                  /t<db>     - set temp. database name%c", cNewLine );
	printf( "                               (default: TEMPREPAIR*.EDB)%c", cNewLine );
	printf( "                  /f<name>   - set prefix to use for name of report files%c", cNewLine );
	printf( "                               (default: <database>.integ.raw)%c", cNewLine );
#ifdef DEBUG	// Undocumented switches.
	printf( "                  /n         - dump table statistics to INTGINFO.TXT%c", cNewLine );
#endif	//	DEBUG
	printf( "                  /8         - set 8k database page size (default: auto-detect)%c", cNewLine );
	printf( "                  /o         - suppress logo%c", cNewLine );
	printf( "          NOTES:  1) Repair does not run database recovery. If a database%c", cNewLine );
	printf( "                     is in a \"Dirty Shutdown\" state it is strongly%c", cNewLine );
	printf( "                     recommended that before proceeding with repair,%c", cNewLine );
	printf( "                     recovery is first run to properly complete database%c", cNewLine );
	printf( "                     operations for the previous shutdown.%c", cNewLine );
	}

LOCAL VOID EDBUTLHelpDump( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "FILE DUMP:%c", cNewLine );
	printf( "    DESCRIPTION:  Generates formatted output of various database file types.%c", cNewLine );
	printf( "         SYNTAX:  %s /m[mode-modifier] <filename> [options]%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  [mode-modifier] - an optional letter designating the type of%c", cNewLine );
	printf( "                                    file dump to perform. Valid values are:%c", cNewLine );
	printf( "                                    h - dump database header (default)%c", cNewLine );
	printf( "                                    k - dump checkpoint file%c", cNewLine );
	printf( "                                    l - dump log file or set of logs%c", cNewLine );
#ifdef DEBUG
	printf( "                                    f - force database to a consistent state%c", cNewLine );
#endif
	printf( "                                    m - dump meta-data%c", cNewLine );
	printf( "                                    s - dump space usage%c", cNewLine );
	printf( "                                    u - dump undefined codepoint fixup table%c", cNewLine );
#ifdef DEBUG	
	printf( "                                    n - dump nodes%c", cNewLine );
#endif	
	printf( "                  <filename>      - name of file to dump. The type of the%c", cNewLine );
	printf( "                                    specified file should match the dump type%c", cNewLine );
	printf( "                                    being requested (eg. if using /mh, then%c", cNewLine );
	printf( "                                    <filename> must be the name of a database).%c", cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
#ifdef DEBUG
#if 0
	printf( "                  /k<node>@<lgpos>%c", cNewLine );
	printf( "                             - track a specific node in the logfile%c", cNewLine );
	printf( "                               starting from the given lgpos%c", cNewLine );
#endif	
	printf( "                  /p<pgno> [/k<key> [/d<data>]]%c", cNewLine );
	printf( "                             - dump the specified page from the database, or if%c", cNewLine );
	printf( "                               an optional bookmark (key plus optional data) is%c", cNewLine );
	printf( "                               specified, seek to the bookmark starting at the%c", cNewLine );
	printf( "                               specified page, then dump the leaf page where%c", cNewLine );
	printf( "                               the seek ended up%c", cNewLine );
	printf( "                  /n<node>   - dump the specified node from the database%c", cNewLine );
#else	
	printf( "                  /p<pgno>   - dump the specified page from the database%c", cNewLine );
#endif	//	DEBUG
	printf( "                  /s<file>   - set streaming file name (default: NONE)%c", cNewLine );
	printf( "                  /t<table>  - perform dump for specified table only%c", cNewLine );
#ifdef DEBUG	
	printf( "                  /a         - dump all nodes including deleted ones%c", cNewLine );
	printf( "                               (dump-nodes mode only)%c", cNewLine );
#endif
	printf( "                  /v         - verbose%c", cNewLine );
	printf( "                  /8         - set 8k database page size (default: auto-detect)%c", cNewLine );
	printf( "                  /o         - suppress logo%c", cNewLine );
	}

#ifdef DEBUG

LOCAL VOID EDBUTLHelpHardRecovery( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "RESTORE:%c", cNewLine );
	printf( "    DESCRIPTION:  Restore information and completion.%c", cNewLine );
#ifdef RESTORE_SERVER_SIMULATION_HELP
	printf( "         SYNTAX:  %s /c[mode-modifier] <path name|file name> [options]%c", szAppName, cNewLine );
#else // RESTORE_SERVER_SIMULATION_HELP
	printf( "         SYNTAX:  %s /c[mode-modifier] <path name> [options]%c", szAppName, cNewLine );
#endif // RESTORE_SERVER_SIMULATION_HELP
	printf( "     PARAMETERS:  [mode-modifier] - a letter designating the type of operation%c", cNewLine );
	printf( "                                    to be done%c", cNewLine );
	printf( "                                    m - dump Restore.Env %c", cNewLine );
	printf( "                                    c - start recovery for a Restore.Env%c", cNewLine );
#ifdef RESTORE_SERVER_SIMULATION_HELP
	printf( "                                    s - simulate server based on description%c", cNewLine );
 	printf( "                  <path name>     - (/cm and /cc) directory of the restore%c", cNewLine );
 	printf( "                                    (Restore.Env location)%c", cNewLine );
	printf( "                                  OR%c", cNewLine );
	printf( "                  <file name>     - (/cs) name of the server description file%c", cNewLine );
#else // RESTORE_SERVER_SIMULATION_HELP
	printf( "                  <path name>     - directory of the restore%c", cNewLine );
	printf( "                                    (Restore.Env location)%c", cNewLine );
#endif // RESTORE_SERVER_SIMULATION_HELP
 	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /t<Instance>    - name of the instance where the play forward%c", cNewLine );
	printf( "                                    log file (default: from backup)%c", cNewLine );
	printf( "                                    If <Instance> is blank, don't play forward%c", cNewLine );
	printf( "                                    any log files.%c", cNewLine );
	printf( "                  /k              - preserves the log files used for recovery%c", cNewLine );
	printf( "                  /8              - set 8k database page size (default: 4k)%c", cNewLine );
	printf( "                  /o              - suppress logo%c", cNewLine );
	}

LOCAL VOID EDBUTLHelpBackup( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "BACKUP:%c", cNewLine );
	printf( "    DESCRIPTION:  Performs backup, bringing all databases to a%c", cNewLine );
	printf( "                  consistent state.%c", cNewLine );
	printf( "         SYNTAX:  %s /b <backup path> [options]%c", szAppName, cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /l<path>   - location of log files%c", cNewLine );
	printf( "                               (default: current directory)%c", cNewLine );
	printf( "                  /s<path>   - location of system files (eg. checkpoint file)%c", cNewLine );
	printf( "                               (default: current directory)%c", cNewLine );
	printf( "                  /c<path>   - incremental backup%c", cNewLine );
	printf( "                  /8         - set 8k database page size (default: 4k)%c", cNewLine );
	printf( "                  /o         - suppress logo%c", cNewLine );
	}

LOCAL VOID EDBUTLHelpSLVMove( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "SLV MOVE:%c", cNewLine );
	printf( "    DESCRIPTION:  Moves a SLV run that contains a certain SLV file page.%c", cNewLine );
	printf( "         SYNTAX:  %s /s <database name> /p<page>%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name> - filename of database to use%c", cNewLine );
	printf( "                  <page>          - page number from the SLV file%c", cNewLine );
	}

#endif // DEBUG

#ifdef RECORD_FORMAT_UPGRADE
LOCAL VOID EDBUTLHelpUpgradeRecordFormat( const char * const szAppName )
	{
	printf( "%c", cNewLine );
	printf( "RECORD UPGRADE:%c", cNewLine );
	printf( "    DESCRIPTION:  Upgrades the record format for all pages in the database.%c", cNewLine );
	printf( "         SYNTAX:  %s /f <database name>%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name> - filename of database to convert%c", cNewLine );
	}
#endif	

LOCAL VOID EDBUTLHelpUpgrade( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "UPGRADE:%c", cNewLine );
	printf( "    DESCRIPTION:  Upgrades a database (created using a previous release of%c", cNewLine );
	printf( "                  Microsoft(R) Windows NT) to the current version.%c", cNewLine );
	printf( "         SYNTAX:  %s /u <database name> /d<previous .DLL> [options]%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name>   - filename of the database to upgrade.%c", cNewLine );
	printf( "                  /d<previous .DLL> - pathed filename of the .DLL that came%c", cNewLine );
	printf( "                                      with the release of Microsoft(R)%c", cNewLine );
	printf( "                                      Windows NT from which you are upgrading.%c", cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /b<db>  - make backup copy under the specified name%c", cNewLine );
	printf( "                  /t<db>  - set temporary database name (default: TEMPUPGD.EDB)%c", cNewLine );
	printf( "                  /p      - preserve temporary database (ie. don't instate)%c", cNewLine );
#ifdef DEBUG	// Undocumented switches.
	printf( "                  /n      - dump upgrade information to UPGDINFO.TXT%c", cNewLine );
	printf( "                  /x<#>   - database extension size, in 4k pages (default: 256)%c", cNewLine );
	printf( "                  /a      - perform an in-place upgrade%c", cNewLine );
#endif	//	DEBUG
	printf( "                  /8      - set 8k database page size (default: auto-detect)%c", cNewLine );
	printf( "                  /o      - suppress logo%c", cNewLine );
	printf( "          NOTES:  1) This utility should only be used to upgrade a database%c", cNewLine );
	printf( "                     after an internal database format change has taken place.%c", cNewLine );
	printf( "                     If necessary, this will usually only coincide with the%c", cNewLine );
	printf( "                     release of a major, new revision of Microsoft(R)%c", cNewLine );
	printf( "                     Windows NT.%c", cNewLine );
	printf( "                  2) Before upgrading, the database should be in a consistent%c", cNewLine );
	printf( "                     state. An error will be returned if otherwise.%c", cNewLine );
	printf( "                  3) If instating is disabled (ie. /p), the original database%c", cNewLine );
	printf( "                     is preserved unchanged, and the temporary database will%c", cNewLine );
	printf( "                     contain the upgraded version of the database.%c", cNewLine );
	}

LOCAL VOID EDBUTLHelpScrub( const char * const szAppName )
	{
	printf( "%c", cNewLine );
	printf( "SECURE:%c", cNewLine );
	printf( "    DESCRIPTION:  Removes all deleted records from database.%c", cNewLine );
	printf( "         SYNTAX:  %s /z <database name>%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name> - filename of database to secure%c", cNewLine );
	printf( "                  /8   - set 8k database page size (default: auto-detect)%c", cNewLine );
	printf( "                  /o   - suppress logo%c", cNewLine );
	}


LOCAL VOID EDBUTLHelp( char *szAppName )
	{
	char c;

	EDBUTLPrintLogo();
	printf( "%s%c%c", szHelpDesc1, cNewLine, cNewLine );
	printf( "%s%c", szHelpSyntax, cNewLine );
	printf( szHelpModes1, szAppName );
	printf( "%c", cNewLine );
	printf( szHelpModes2, szAppName );
	printf( "%c", cNewLine );
	printf( szHelpModes3, szAppName );
	printf( "%c", cNewLine );
	printf( szHelpModes4, szAppName );
	printf( "%c", cNewLine );
	printf( szHelpModes5, szAppName );
	printf( "%c", cNewLine );
	printf( szHelpModes6, szAppName );
	printf( "%c", cNewLine );
#ifdef DEBUG
	printf( szHelpModes7, szAppName );	//	mode 7 is Restore
	printf( "%c", cNewLine );

	printf( szHelpModes8, szAppName );	//	mode 8 is Backup
	printf( "%c", cNewLine );

	printf( szHelpModes9, szAppName );	//	mode 9 is OLDSLV
	printf( "%c", cNewLine );

#ifdef RECORD_FORMAT_UPGRADE
	printf( szHelpModes10, szAppName );	//	mode 10 is Record Format Upgrade
	printf( "%c", cNewLine );
#endif

	printf( szHelpModes11, szAppName );	//	mode 11 is Upgrade (undocumented in RETAIL)
	printf( "%c", cNewLine );

	printf( szHelpModes12, szAppName );	//	mode 12 is Scrub (undocumented in RETAIL )
	printf( "%c", cNewLine );
#endif	//	DEBUG

	printf( "%c", cNewLine );
	printf( "%s%c", szHelpPrompt1, cNewLine );
#ifdef DEBUG	
	printf( "%s,%c", szHelpPrompt2, cNewLine );
	printf( "%s%c", szHelpPrompt3, cNewLine );
#else
	printf( "%s%c", szHelpPrompt2, cNewLine );
#endif	
	printf( "%s", szHelpPromptCursor );
	c = (char)_getch();

	printf( "%c%c", cNewLine, cNewLine );

	switch ( c )
		{
		case 'd':
		case 'D':
			EDBUTLHelpDefrag( szAppName );
			break;
		case 'r':
		case 'R':
			EDBUTLHelpRecovery( szAppName );
			break;
		case 'g':
		case 'G':
			EDBUTLHelpIntegrity( szAppName );
			break;
		case 'k':
		case 'K':
			EDBUTLHelpChecksum( szAppName );
			break;			
		case 'p':
		case 'P':
			EDBUTLHelpRepair( szAppName );
			break;
		case 'm':
		case 'M':
			EDBUTLHelpDump( szAppName );
			break;

#ifdef DEBUG
		case 'c':
		case 'C':
			EDBUTLHelpHardRecovery( szAppName );
			break;			
		case 'b':
		case 'B':
			EDBUTLHelpBackup( szAppName );
			break;
		case 's':
		case 'S':
			EDBUTLHelpSLVMove( szAppName );
			break;
#endif

#ifdef RECORD_FORMAT_UPGRADE
		case 'f':
		case 'F':
			EDBUTLHelpUpgradeRecordFormat( szAppName );
			break;
#endif

		//	NOTE: Upgrade is undocumented in RETAIL
		case 'u':
		case 'U':
			EDBUTLHelpUpgrade( szAppName );
			break;

		//	NOTE: Scrub is undocumented in RETAIL
		case 'z':
		case 'Z':
			EDBUTLHelpScrub( szAppName );
			break;
		}
	}


#ifdef ESENT
//	Easter eggs are a fireable offense.
#else
static void EDBUTLSplash()
	{
	static const char foo[] =
	"..................................................."
	"                                                   "
	;
	
	static const char bar[] =
	"..................................................."
	"Laurion.Burchall"
	"....."
	"Adam.Foxman"
	"....."
	"Andrew.Goodsell"
	"....."
	"Adam.Green"
	"....."
	"Phillip.Hupf"
	"....."
	"Stephen.Jiang"
	"....."
	"Chris.Larson"
	"....."
	"Jonathan.Liem"
	"....."
	"Andrei.Marinescu"
	"....."	
	"Stuart.Padley"
	"....."
	"Michael.Rorke"
	"....."
	"Ivan.Trindev"
	"....."
	"Mark.Wistrom"
	"..................................................."
	;
	
	static const char baz[] =
	"                                                   "
	"..................................................."
	;

	const int cchWidth = 51;
	
	_cprintf( "\r\n                  Defragmentation Status (%% complete)\r\n\r\n" );
	_cprintf( "          0    10   20   30   40   50   60   70   80   90  100\r\n" );
	_cprintf( "          |----|----|----|----|----|----|----|----|----|----|\r\n" );
	_cprintf( "          " );

	int i;
	
	for( i = sizeof( foo ) - cchWidth - 1; i >= 0; --i )
		{
		_cprintf( "\r          %*.*s", cchWidth, cchWidth, foo + i );
		Sleep( 75 );
		}

	for( i = 0; i <= sizeof( bar ) - cchWidth - 1; ++i )
		{
		_cprintf( "\r          %*.*s", cchWidth, cchWidth, bar + i );
		Sleep( 75 );
		}

	for( i = sizeof( baz ) - cchWidth - 1; i >= 0; --i )
		{
		_cprintf( "\r          %*.*s", cchWidth, cchWidth, baz + i );
		Sleep( 75 );
		}

	_cprintf( "\r\n\r\n" );
	}
#endif	//	ESENT	


LOCAL VOID EDBUTLGetTime( ULONG timerStart, INT *piSec, INT *piMSec )
	{
	ULONG	timerEnd;

	timerEnd = GetTickCount();
	
	*piSec = ( timerEnd - timerStart ) / 1000;
	*piMSec = ( timerEnd - timerStart ) % 1000;
	}

LOCAL JET_ERR __stdcall PrintStatus( JET_SESID sesid, JET_SNP snp, JET_SNT snt, void *pv )
	{
	static int	iLastPercentage;
	int 		iPercentage;
	int			dPercentage;

	switch ( snp )
		{
		case -1:				// during Begin pv will point ot szOperation
		case JET_snpCompact:
		case JET_snpUpgrade:
		case JET_snpRestore:
		case JET_snpRepair:
		case JET_snpScrub:
		case JET_snpUpgradeRecordFormat:
			switch( snt )
				{
				case JET_sntProgress:
					assert( pv );
					iPercentage = static_cast< int >( ( __int64( reinterpret_cast< JET_SNPROG* >( pv )->cunitDone ) * __int64( 100 ) ) / __int64( reinterpret_cast< JET_SNPROG* >( pv )->cunitTotal ) );
					dPercentage = iPercentage - iLastPercentage;
					assert( dPercentage >= 0 );
					while ( dPercentage >= 2 )
						{
						printf( "." );
						iLastPercentage += 2;
						dPercentage -= 2;
						}
					break;

				case JET_sntBegin:
					{
					const char*	szOperation;
					SIZE_T		cbPadding, cbOper;

					switch ( snp )
						{
						default:
							szOperation = szDefrag;
							break;
						case JET_snpUpgrade:
							szOperation = szUpgrade;
							break;
						case JET_snpRestore:
							szOperation = szRestore;
							break;
						case JET_snpRepair:
							szOperation = szRepair;
							break;
						case JET_snpScrub:
							szOperation = szScrub;
							break;
						case JET_snpUpgradeRecordFormat:
							szOperation = szUpgradeRecordFormat;
							break;
						case -1:
							assert( NULL != pv );
							szOperation = (char *)pv;
						}

					printf( "%c", cNewLine );

					// Center the status message above the status bar.
					// Formula is: ( length of status bar - length of message ) / 2
					cbOper = strlen( szOperation );
					assert( cbOper + (ULONG)strlen( szStatusMsg ) <= 51 );
					cbPadding = ( 51 - ( cbOper + (ULONG)strlen( szStatusMsg ) ) ) / 2;

					printf( "          %*s%s%c%c", cbPadding+cbOper, szOperation, szStatusMsg, cNewLine, cNewLine );
					printf( "          0    10   20   30   40   50   60   70   80   90  100\n" );
					printf( "          |----|----|----|----|----|----|----|----|----|----|\n" );
					printf( "          " );

					iLastPercentage = 0;
					break;
					}

				case JET_sntComplete:
					dPercentage = 100 - iLastPercentage;
					assert( dPercentage >= 0 );
					while ( dPercentage >= 2 )
						{
						printf( "." );
						iLastPercentage += 2;
						dPercentage -= 2;
						}

					printf( ".%c%c", cNewLine, cNewLine );
					break;
				}
			break;				
		}

	return JET_errSuccess;
	}

const EDBUTL_errInvalidPath = 1;	//	Does not form right path. param1 = file type
const EDBUTL_errSharedName	= 2;	//	Two file types share one file name. param1, param2 - files types
const EDBUTL_errInvalidDB	= 3;	//	cannot read source database header. param1 - error code
const EDBUTL_errNoSLVFile	= 4;	//	Source database does not have SLV file but such is specified

const EDBUTL_paramSrcDB		= 1;
const EDBUTL_paramSrcSLV	= 2;
const EDBUTL_paramTempDB	= 3;
const EDBUTL_paramTempSLV	= 4;
const EDBUTL_paramLast		= 5;

LOCAL VOID PrintErrorMessage( int const err, const UTILOPTS * const popts, int param1 = 0, int param2 = 0 )
	{
	assert( NULL != popts );
	
	static const char * const szObjectName[2*EDBUTL_paramLast] = 
		{
		"",
		"Source database",
		"Source streaming file",
		"Temporary database",
		"Temporary streaming file",
		"",
		"source database",
		"source streaming file",
		"temporary database",
		"temporary streaming file",
		};

	const char *const szObjectData[EDBUTL_paramLast] = 
		{
		"",
		popts->szSourceDB,
		popts->szSourceSLV,
		popts->szTempDB,
		popts->szTempSLV
		};
		
	switch ( err )
		{
		case EDBUTL_errInvalidPath:
			assert( 0 < param1 );
			assert( EDBUTL_paramLast > param1 );
			printf( "Error: %s specification '%s' is invalid.", 
				szObjectName[param1], szObjectData[param1] );
			break;
		case EDBUTL_errSharedName:
			assert( 0 < param1 );
			assert( EDBUTL_paramLast > param1 );
			assert( 0 < param2 );
			assert( EDBUTL_paramLast > param2 );
			printf( "Error: %s '%s' cannot be the same as %s.", 
				szObjectName[param1], szObjectData[param1], szObjectName[param2+EDBUTL_paramLast] );
			break;
		case EDBUTL_errInvalidDB:
			printf( "Error: Access to source database '%s' failed with Jet error %i.", 
				szObjectData[EDBUTL_paramSrcDB], param1 );
			break;
		case EDBUTL_errNoSLVFile:
			assert( 0 < param1 );
			assert( EDBUTL_paramLast > param1 );
			printf( "Usage Error: Source database has no streaming file but %s '%s' was specified.",
				szObjectName[param1+EDBUTL_paramLast], szObjectData[param1] );
			break;
		default:
			assert( 0 );
			return;
		}
	printf( "%c%c", cNewLine, cNewLine );
	}

LOCAL VOID EDBUTLGetSLVNameFromDbName( const CHAR *const szDbName, CHAR *const szSLVName )
	{
	CHAR	szDbDrive[_MAX_DRIVE+1];
	CHAR	szDbDir[_MAX_DIR+1];
	CHAR	szDbBaseName[_MAX_FNAME+1];

	assert( szSLVName != NULL );
	
	_tsplitpath( szDbName, szDbDrive, szDbDir, szDbBaseName, NULL );

	_tmakepath( szSLVName, szDbDrive, szDbDir, szDbBaseName, szStreamingFileExt );
	}

//	Check database and streaming file:
LOCAL JET_ERR ErrEDBUTLCheckDBSLVNames( 
	UTILOPTS*			popts, 
	const char * const	szTempDB, 
	char*				szSrcSLV		= NULL, 
	char*				szTempSLV		= NULL )
//	Parameters:
//		options structure
//		default temporaty database name
//		space to store names of SrcSLV & TempSLV
//			if NULL is passed they will not be retrieved at all
	{
	assert( NULL != popts );
	assert( NULL != szTempDB );
	assert( NULL == szTempSLV || NULL != szSrcSLV );

	CHAR	szFullpathSrcDB[ _MAX_PATH + 1] = "";
	CHAR	szFullpathTempDB[ _MAX_PATH + 1 ] = "";
	CHAR	szFullpathSrcSLV[ _MAX_PATH + 1] = "";
	CHAR	szFullpathTempSLV[ _MAX_PATH + 1 ] = "";

	//	if TempDB is not defined
	if ( NULL == popts->szTempDB )
		{ 
		//	set TempDB to DefaultTempDB
		popts->szTempDB = (char *)szTempDB;
		}

	//  if temp db is not valid path then ERROR
	if ( NULL == _fullpath( szFullpathTempDB, popts->szTempDB, _MAX_PATH ) )
		{
		PrintErrorMessage( EDBUTL_errInvalidPath, popts, EDBUTL_paramTempDB );
		return JET_errInvalidPath;
		}

	//	if SrcDB is not defined or is invalid path then ERROR
	if ( NULL == popts->szSourceDB )
		{
		printf( szUsageErr1, "source database" );
		printf( "%c%c", cNewLine, cNewLine );
		return JET_errInvalidParameter;
		}
	if ( NULL == _fullpath( szFullpathSrcDB, popts->szSourceDB, _MAX_PATH ) )
		{
		PrintErrorMessage( EDBUTL_errInvalidPath, popts, EDBUTL_paramSrcDB );
		return JET_errInvalidPath;
		}

	//	if 8k pages NOT specified, try to consult the database header
	//	to see if the database actually uses 8k pages
	//	WARNING: if a database uses 4k pages and this code erroneously
	//	(due to a bug, corruption, etc.) detects 8k pages, there is
	//	currently no way to override this code and force 4k pages
	ULONG	cbPageSize	= 0;
	if ( !FUTILOPTS8KPage( popts->fUTILOPTSFlags )
		&& JET_errSuccess == JetGetDatabaseFileInfo( popts->szSourceDB, &cbPageSize, sizeof(cbPageSize), JET_DbInfoPageSize )
		&& cbPageSize == 8192 )
		{
		const ERR	err		= JetSetSystemParameter( NULL, 0, JET_paramDatabasePageSize, 8192, NULL );
		if ( err < JET_errSuccess )
			return err;
		UTILOPTSSet8KPage( popts->fUTILOPTSFlags );
		}

	//	if need SrcSTM and SrcDB has a SLV file
	BOOL fDBHasSLV = fFalse;
	if ( szSrcSLV )
		{
		const ERR	err		= JetGetDatabaseFileInfo( popts->szSourceDB, &fDBHasSLV, sizeof( fDBHasSLV ), JET_DbInfoHasSLVFile );
		if ( err < JET_errSuccess )
			{
			PrintErrorMessage( EDBUTL_errInvalidDB, popts, err );
			return err;
			}
		}
	if ( fDBHasSLV )
		{
		//	if SrcSLV is not defined
		if ( NULL == popts->szSourceSLV )
			{
			assert( szSrcSLV != NULL );
			//	retrieve SrcSLV from SrcDB
			EDBUTLGetSLVNameFromDbName( popts->szSourceDB, szSrcSLV );
			popts->szSourceSLV = szSrcSLV;
			}
		//	if SrcSLV is not valid path ERROR
		if ( NULL == _fullpath( szFullpathSrcSLV, popts->szSourceSLV, _MAX_PATH ) )
			{
			PrintErrorMessage( EDBUTL_errInvalidPath, popts, EDBUTL_paramSrcSLV );
			return JET_errInvalidPath;
			}			
		//	if SrcSLV is the same as SrcDB then ERROR
		if ( 0 == _strcmpi( szFullpathSrcDB, szFullpathSrcSLV ) )
			{
			PrintErrorMessage( EDBUTL_errSharedName, popts, EDBUTL_paramSrcDB, EDBUTL_paramSrcSLV );
			return JET_errInvalidDatabase;
			}
		}
	//	if SrcSLV is defined but not expected then ERROR
	else if ( NULL != popts->szSourceSLV )
		{
		PrintErrorMessage( EDBUTL_errNoSLVFile, popts, EDBUTL_paramSrcSLV );
		return JET_errInvalidParameter;
		}

	//	if TempDB is the same as SrcDB or as SrcSLV then ERROR
	if ( 0 == _strcmpi( szFullpathSrcDB, szFullpathTempDB ) )
		{
		PrintErrorMessage( EDBUTL_errSharedName, popts, EDBUTL_paramSrcDB, EDBUTL_paramTempDB );
		return JET_errInvalidDatabase;
		}
	if ( 0 == _strcmpi( szFullpathSrcSLV, szFullpathTempDB ) )
		{
		PrintErrorMessage( EDBUTL_errSharedName, popts, EDBUTL_paramSrcSLV, EDBUTL_paramTempDB );
		return JET_errInvalidDatabase;
		}

	//	if SrcDB has SLV file and need tempSLV
	if ( fDBHasSLV && NULL != szTempSLV )
		{
		//	if TempSLV is not defined
		if ( NULL == popts->szTempSLV )
			{
			//	retrieve TempSLV from TempDB
			EDBUTLGetSLVNameFromDbName( popts->szTempDB, szTempSLV );
			popts->szTempSLV = szTempSLV;
			}
		//	if TempSLV is not valid path then ERROR
		if ( NULL == _fullpath( szFullpathTempSLV, popts->szTempSLV, _MAX_PATH ) )
			{
			PrintErrorMessage( EDBUTL_errInvalidPath, popts, EDBUTL_paramTempSLV );
			return JET_errInvalidPath;
			}			
		//	if TempSLV is the same as TempDB or as SrcDB or as SrcSLV then ERROR
		if ( 0 == _strcmpi( szFullpathSrcDB, szFullpathTempSLV ) )
			{
			PrintErrorMessage( EDBUTL_errSharedName, popts, EDBUTL_paramSrcDB, EDBUTL_paramTempSLV );
			return JET_errInvalidDatabase;
			}
		if ( 0 == _strcmpi( szFullpathSrcSLV, szFullpathTempSLV ) )
			{
			PrintErrorMessage( EDBUTL_errSharedName, popts, EDBUTL_paramSrcSLV, EDBUTL_paramTempSLV );
			return JET_errInvalidDatabase;
			}
		if ( 0 == _strcmpi( szFullpathTempDB, szFullpathTempSLV ) )
			{
			PrintErrorMessage( EDBUTL_errSharedName, popts, EDBUTL_paramTempDB, EDBUTL_paramTempSLV );
			return JET_errInvalidDatabase;
			}
		}
	//	else if TempSLV is defined but not expected then ERROR
	else if ( NULL != popts->szTempSLV )
		{
		PrintErrorMessage( EDBUTL_errNoSLVFile, popts, EDBUTL_paramSrcSLV );
		return JET_errInvalidParameter;
		}
	return JET_errSuccess;
	}

#ifdef DEBUG
LOCAL JET_ERR ErrEDBUTLCheckBackupPath( UTILOPTS *popts )
	{
	CHAR	szFullpathBackup[ _MAX_PATH + 1];

	if ( popts->szBackup == NULL )
		{
		printf( szUsageErr1, "backup path" );
		printf( "%c%c", cNewLine, cNewLine );
		return JET_errInvalidParameter;
		}
	
	if ( _fullpath( szFullpathBackup, popts->szBackup, _MAX_PATH ) == NULL )
		{
		printf( szErr1, popts->szBackup );
		printf( "%c%c", cNewLine, cNewLine );
		return JET_errInvalidPath;
		}

	return JET_errSuccess;
	}
#endif

LOCAL BOOL FEDBUTLParsePath( char *arg, char **pszParam, char *szParamDesc, BOOL fAllowEmpty = fFalse )
	{
	BOOL	fResult = fTrue;

	// if the argument is empty try to read next one argument
	if ( '\0' == *arg )
		{
		char *argT = arg;
		arg = GetNextArg();
		// if it was last argument or option follows it means we passed empty argument
		if ( NULL == arg || NULL != strchr( szSwitches, *arg ) )
			{
			arg = argT;
			SetCurArgID( GetCurArgID() - 1 );
			}
		}

	// no path should contain leading ':'(s)
	while ( ':' == *arg )
		{
		arg++;
		}

	
	if ( '\0' == *arg && !fAllowEmpty )
		{
		printf( szUsageErr1, szParamDesc );			// Missing spec.
		printf( "%c%c", cNewLine, cNewLine );
		fResult = fFalse;
		}
	else if ( NULL == *pszParam )
		{
		*pszParam = arg;
		}
	else
		{
		printf( szUsageErr2, szParamDesc );			// Duplicate spec.
		printf( "%c%c", cNewLine, cNewLine );
		fResult = fFalse;
		}
		
	return fResult;
	}


LOCAL BOOL FEDBUTLParseDefragment( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fTrue;

	switch( arg[1] )
		{
		case 'b':
		case 'B':
			fResult = FEDBUTLParsePath( arg+2, &popts->szBackup, "backup database" );
			break;

		case 'n':		
		case 'N':
			UTILOPTSSetDefragInfo( popts->fUTILOPTSFlags );
			break;
			
		case 'p':
		case 'P':
			UTILOPTSSetPreserveTempDB( popts->fUTILOPTSFlags );
			break;
			
		case 't':
		case 'T':
			fResult = FEDBUTLParsePath( arg+2, &popts->szTempDB, "temporary database" );
			break;

		case 'w':
		case 'W':				
			popts->cpageBatchIO = atol( arg + 2 );
			if ( popts->cpageBatchIO <= 0 )
				{
				printf( "%s%c%c", szUsageErr7, cNewLine, cNewLine );
				fResult = fFalse;
				}
			break;

		case 'x':
		case 'X':
			popts->cpageDbExtension = atol( arg + 2 );
			if ( popts->cpageDbExtension <= 0 )
				{
				printf( "%s%c%c", szUsageErr8, cNewLine, cNewLine );
				fResult = fFalse;
				}
			break;

		case 'i':
		case 'I':
			UTILOPTSSetDefragSLVDontCopy( popts->fUTILOPTSFlags );
			break;

		case 's':
		case 'S':
			fResult = FEDBUTLParsePath( arg+2, &popts->szSourceSLV, "streaming file" );
			break;

		case 'f':
		case 'F':
			fResult = FEDBUTLParsePath( arg+2, &popts->szTempSLV, "temp. streaming file" );
			break;

		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}

LOCAL BOOL FEDBUTLParseRecovery( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fTrue;

	switch( arg[1] )
		{
#ifdef LOG_SHIPPING		
		case 'f':
		case 'F':
			popts->grbitInit |= JET_bitReplayReplicatedLogFiles;
			break;
#endif			

		case 'i':
		case 'I':
			popts->grbitInit |= JET_bitReplayIgnoreMissingDB;
			break;

		case 'l':
		case 'L':
			fResult = FEDBUTLParsePath( arg+2, &popts->szLogfilePath, "logfile path" );
			break;

		case 's':
		case 'S':
			fResult = FEDBUTLParsePath( arg+2, &popts->szSystemPath, "system path" );
			break;

		case 't':
		case 'T':
			popts->pageTempDBMin = atol( arg + 2 );
			fResult = fTrue;
			break;

		case 'd':
		case 'D':
			if ( NULL != popts->szBackup || NULL != popts->szRestore )
				{
				printf( "%s%c%c", szUsageErr3, cNewLine, cNewLine );
				fResult = fFalse;
				}
			else
				{
				//	if no directory specified, use current directory
				fResult = FEDBUTLParsePath( arg+2, &popts->szSourceDB, "database directory", fTrue );
				if ( fResult && '\0' == popts->szSourceDB[0] )
					popts->szSourceDB = (CHAR *)szCurrDir;
				}
			break;

#ifdef DEBUG
		case 'b':
		case 'B':
			if ( NULL != popts->szSourceDB )
				{
				printf( szUsageErr3 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				}
			else
				{
				fResult = FEDBUTLParsePath( arg+2, &popts->szBackup, "backup directory" );
				}
			break;

		case 'r':
		case 'R':
			if ( NULL != popts->szSourceDB )
				{
				printf( szUsageErr3 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				}
			else
				{
				fResult = FEDBUTLParsePath( arg+2, &popts->szRestore, "destination directory" );
				}
			break;
#endif

		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}	

LOCAL BOOL FEDBUTLParseIntegrity( char *arg, UTILOPTS *popts )
	{
	BOOL		fResult = fTrue;

	switch( arg[1] )
		{
		case 'b':
		case 'B':
			UTILOPTSSetDontBuildIndexes( popts->fUTILOPTSFlags );
			break;

		case 'n':
		case 'N':
			UTILOPTSSetDumpStats( popts->fUTILOPTSFlags );
			break;

		case 't':
		case 'T':
			fResult = FEDBUTLParsePath( arg+2, &popts->szTempDB, "temporary database" );
			break;

		case 's':
		case 'S':
			fResult = FEDBUTLParsePath( arg+2, &popts->szSourceSLV, "streaming file" );
			break;

		case 'f':
		case 'F':
			fResult = FEDBUTLParsePath( arg+2, &popts->szIntegPrefix, "report file name prefix" );
			break;
			
		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}

LOCAL BOOL FEDBUTLParseRepair( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fTrue;

	switch( arg[1] )
		{
		case 't':
		case 'T':
			fResult = FEDBUTLParsePath( arg+2, &popts->szTempDB, "temporary database" );
			break;

		case 'n':
		case 'N':
			UTILOPTSSetDumpStats( popts->fUTILOPTSFlags );
			break;

		case 's':
		case 'S':
			fResult = FEDBUTLParsePath( arg+2, &popts->szSourceSLV, "streaming file" );
			break;

		case 'f':
		case 'F':
			fResult = FEDBUTLParsePath( arg+2, &popts->szIntegPrefix, "report file name prefix" );
			break;
			
		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}

LOCAL VOID EDBUTLGetBaseName( const CHAR * const szLogfile, CHAR * const szBaseName )
	{
	CHAR	szNameT[_MAX_FNAME+1];

	assert( szBaseName != NULL );
	
	_tsplitpath( szLogfile, NULL, NULL, szNameT, NULL );
	_tcsncpy( szBaseName, szNameT, 3 );
	szBaseName[ 3 ] = 0;
	}

LOCAL BOOL FEDBUTLParseDump( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fFalse;

	switch( arg[1] )
		{
		case 'a':
		case 'A':
			{
			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );
			
			if (pdbutil->op != opDBUTILDumpData)
				fResult = fFalse;
			else
				{	
				pdbutil->grbitOptions |= JET_bitDBUtilOptionAllNodes;
				fResult	= fTrue;
				}
			}
			break;

		case 'v':
		case 'V':
			{
			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );

			pdbutil->grbitOptions |= JET_bitDBUtilOptionDumpVerbose;
			fResult = fTrue;
			}
			break;

		case 's':
		case 'S':
			fResult = FEDBUTLParsePath( arg+2, &popts->szSourceSLV, "streaming file" );
			break;
			
		case 't':
		case 'T':
			{
			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );

			switch ( pdbutil->op )
				{
				case opDBUTILDumpData:
				case opDBUTILDumpMetaData:
				case opDBUTILDumpSpace:
					pdbutil->szTable = arg+2;
					fResult = fTrue;
					break;
				default:
					fResult = fFalse;
				}
			}
			break;

		case 'p':
		case 'P':
			{
			char 	szPage[256];
			strcpy( szPage, arg+2 );

			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );

			pdbutil->op = opDBUTILDumpPage;
			pdbutil->pgno = atoi( szPage );
			fResult = fTrue;
			}
			break;

#ifdef DEBUG
		case 'k':
		case 'K':
			{
			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );

			//	MUST specify /p before /k and /k before /d
			//
			if ( opDBUTILDumpPage == pdbutil->op
				&& NULL == pdbutil->szIndex
				&& NULL == pdbutil->szTable )
				{
				//	overload szIndex
				//
				pdbutil->szIndex = arg+2;
				fResult = fTrue;
				}
			else
				{
				printf( szUsageErr4, arg );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				}
			break;
			}

		case 'd':
		case 'D':
			{
			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );

			//	MUST specify /p and /k before /d
			//
			if ( opDBUTILDumpPage == pdbutil->op
				&& NULL != pdbutil->szIndex
				&& NULL == pdbutil->szTable )
				{
				//	overload szTable
				//
				pdbutil->szTable = arg+2;
				fResult = fTrue;
				}
			else
				{
				printf( szUsageErr4, arg );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				}
			break;
			}

#if 0
		// UNDONE: I don't think this functionality currently works
		case 'k':
		case 'K':
			{			
			const char * pchSep;
			if( NULL == ( pchSep = strchr( arg, '@' ) ) )
				{
				printf( "%s (1)", szUsageErr13 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				break;
				}

			char 	szNode[1024];
			char	szLgpos[1024];
			strncpy( szNode, arg+2, UINT( pchSep - arg + 1 ) );
			strcpy( szLgpos, pchSep + 1 );
			
			int 	dbid;
			int		pgno;
			int		iline;
			if( sscanf( szNode, "[%d:%d:%d]", &dbid, &pgno, &iline ) != 3 
				&& sscanf( szNode, "%d:%d:%d", &dbid, &pgno, &iline ) != 3 )
				{
				printf( "%s (2)", szUsageErr13 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				break;
				}

			long		lGeneration;
			long		isec;
			long		ib;
			if( sscanf( szLgpos, "%x,%x,%x", &lGeneration, &isec, &ib ) != 3 )
				{
				printf( "%s (3)", szUsageErr13 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				break;
				}

			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );

			pdbutil->op 	= opDBUTILDumpLogfileTrackNode;
			pdbutil->dbid	= dbid;
			pdbutil->pgno	= pgno;
			pdbutil->iline	= iline;
			pdbutil->lGeneration = lGeneration;
			pdbutil->isec	= isec;
			pdbutil->ib		= ib;
			
			fResult = fTrue;
			}
			break;

		case 's':
		case 'S':
			{
			char 	szPage[256];
			strcpy( szPage, arg+2 );

			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );

			pdbutil->op 	= opDBUTILSLVMove;
			pdbutil->pgno	= atoi( szPage );

			fResult			= fTrue;
			}
			break;
#endif	//	0


		case 'n':
		case 'N':
			{
			char 	szNode[256];
			strcpy( szNode, arg+2 );

			int 	dbid 	= 0;
			int		pgno	= 0;
			int		iline	= 0;
			if(
				sscanf( szNode, "[%d:%d:%d]", &dbid, &pgno, &iline ) != 3 
				&& sscanf( szNode, "%d:%d:%d", &dbid, &pgno, &iline ) != 3
				&& sscanf( szNode, "[%d:%d]", &pgno, &iline ) != 2
				&& sscanf( szNode, "%d:%d", &pgno, &iline ) != 2
				)
				{
				printf( "%s (2)", szUsageErr13 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				break;
				}

			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );

			pdbutil->op 	= opDBUTILDumpNode;
			pdbutil->dbid	= dbid;
			pdbutil->pgno	= pgno;
			pdbutil->iline	= iline;

			fResult			= fTrue;
			}
			break;

#endif	//	DEBUG

#ifdef ESENT
#else  //  !ESENT			
		case 'e':
		case 'E':
			if ( 0 == _stricmp( arg+1, "exslv" ) )
				{
				JET_DBUTIL * const	pdbutil		= reinterpret_cast<JET_DBUTIL *>( popts->pv );

				pdbutil->op = opDBUTILDumpExchangeSLVInfo;
				fResult = fTrue;
				break;
				}
#endif  //  ESENT

		//	FALL THROUGH

		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}	

#ifdef DEBUG

LOCAL BOOL FEDBUTLParseHardRecovery( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fTrue;

	switch( arg[1] )
		{
		case 'k':
		case 'K':
			if ( !FUTILOPTSDumpRestoreEnv(popts->fUTILOPTSFlags) )
				{
				UTILOPTSSetPreserveTempDB( popts->fUTILOPTSFlags );
				break;
				}
			// no /t allowed if dump mode specified
		case 't':
		case 'T':
			if ( !FUTILOPTSDumpRestoreEnv(popts->fUTILOPTSFlags) )
				{
				// allow NULL target name. It means : no play forward
				fResult = FEDBUTLParsePath( arg+2, &popts->szRestore, "Target Instance", fTrue );
				break;
				}
			// no /t allowed if dump mode specified
		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}	
				
LOCAL BOOL FEDBUTLParseBackup( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fFalse;	// backup directory must be set at least.

	switch( arg[1] )
		{
		case 'l':
		case 'L':
			fResult = FEDBUTLParsePath( arg+2, &popts->szLogfilePath, "logfile path" );
			break;

		case 's':
		case 'S':
			fResult = FEDBUTLParsePath( arg+2, &popts->szSystemPath, "system path" );
			break;

		case 'c':
		case 'C':
			UTILOPTSSetIncrBackup( popts->fUTILOPTSFlags );
			break;

		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}

LOCAL BOOL FEDBUTLParseSLVMove( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fFalse;

	switch( arg[1] )
		{
		case 'p':
		case 'P':
			{
			char 	szPage[256];
			strcpy( szPage, arg+2 );

			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );

			pdbutil->op 	= opDBUTILDumpPage;
			pdbutil->pgno	= atoi( szPage );

			fResult			= fTrue;
			}
			break;

		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	if ( NULL == popts->szSourceDB )
		{
		fResult = fFalse;
		}
		
	return fResult;
	}	
	
#endif	//	DEBUG

#ifdef RECORD_FORMAT_UPGRADE
LOCAL BOOL FEDBUTLParseUpgradeRecordFormat( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fTrue;

	switch( arg[1] )
		{
		case 'd':	//	add a non-default case to avoid compiler warnings
		case 'D':
			popts->lDirtyLevel = atol( arg + 2 );
			break;
			
		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}
#endif

LOCAL BOOL FEDBUTLParseUpgrade( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fTrue;

	switch( arg[1] )
		{
		case 'd':
		case 'D':
			fResult = FEDBUTLParsePath( arg+2, &((JET_CONVERT *)(popts->pv))->szOldDll, "old .DLL" );
			break;

		case 'b':
		case 'B':
			fResult = FEDBUTLParsePath( arg+2, &popts->szBackup, "backup database" );
			break;
			
		case 'n':
		case 'N':
			UTILOPTSSetDefragInfo( popts->fUTILOPTSFlags );
			break;
			
		case 'p':
		case 'P':
			UTILOPTSSetPreserveTempDB( popts->fUTILOPTSFlags );
			break;
			
		case 't':
		case 'T':
			fResult = FEDBUTLParsePath( arg+2, &popts->szTempDB, "temporary database" );
			break;
			
		case 'x':
		case 'X':
			popts->cpageDbExtension = atol( arg + 2 );
			if ( popts->cpageDbExtension <= 0 )
				{
				printf( "%s%c%c", szUsageErr8, cNewLine, cNewLine );
				fResult = fFalse;
				}
			break;

		case 'a':
		case 'A':
			UTILOPTSSetInPlaceUpgrade( popts->fUTILOPTSFlags );
			break;

		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
		}

	return fResult;
	}	

LOCAL BOOL FEDBUTLParseScrub( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fTrue;

	switch( arg[1] )
		{
		case 's':
		case 'S':
			fResult = FEDBUTLParsePath( arg+2, &popts->szSourceSLV, "streaming file" );
			break;

		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}


LOCAL CHAR **g_argv = NULL;
LOCAL INT	g_argMaxID = 0;
LOCAL INT	g_argCurID = -1;

//	initalizes argument index, and set to point before firts index
LOCAL VOID InitArg( int argc, char *argv[] )
	{
	AssertPREFIX( argc > 0 );
	AssertPREFIX( NULL != argv );

	g_argMaxID = argc;
	g_argv = argv;
	g_argCurID = -1;
	}

//	returns current argument index
//	returns -1 if is before first argument
//	return  ArgCount after last argument
LOCAL INT GetCurArgID()
	{
	AssertPREFIX( g_argCurID >= -1 );
	return g_argCurID;
	}

LOCAL INT GetArgCount()
	{
	AssertPREFIX( g_argMaxID >= 0 );
	return g_argMaxID;
	}

LOCAL VOID SetCurArgID( const INT id )
	{
	if ( id < -1 )
		{
		g_argCurID = -1;
		}
	else if ( id > g_argMaxID )
		{
		AssertPREFIX( g_argMaxID >= 0 );
		g_argCurID = g_argMaxID;
		}
	else
		{
		g_argCurID = id;
		}
	}

LOCAL CHAR *GetCurArg()
	{
	AssertPREFIX( g_argCurID >= -1 );
	AssertPREFIX( g_argMaxID >= 0 );
	AssertPREFIX( g_argMaxID >= g_argCurID );
	if ( -1 == g_argCurID || g_argMaxID == g_argCurID )
		{
		return NULL;
		}
	return g_argv[g_argCurID];
	}

LOCAL CHAR *GetNextArg()
	{
	SetCurArgID( GetCurArgID()+1 );
	return GetCurArg();
	}

LOCAL CHAR *GetPrevArg()
	{
	SetCurArgID( GetCurArgID()-1 );
	return GetCurArg();
	}

LOCAL BOOL FSetDumpModeModifier( char chMode, JET_DBUTIL *pdbutil )
	{
	switch( chMode )
		{
		case 0:
		case 'h':
		case 'H':
			pdbutil->op = opDBUTILDumpHeader;
			break;

		case 'k':
		case 'K':
			pdbutil->op = opDBUTILDumpCheckpoint;
			break;

		case 'm':
		case 'M':
			pdbutil->op = opDBUTILDumpMetaData;
			break;

		case 'u':
		case 'U':
			pdbutil->op = opDBUTILDumpUnicodeFixupTable;
			break;

#ifdef DEBUG
		case 'f':
		case 'F':
			pdbutil->op = opDBUTILSetHeaderState;
			break;

		case 'n':
		case 'N':
			pdbutil->op = opDBUTILDumpData;
			break;

#endif
			
		case 'l':
		case 'L':
			pdbutil->op = opDBUTILDumpLogfile;
			break;

		case 's':
		case 'S':
			pdbutil->op = opDBUTILDumpSpace;
			break;

		default:
			return fFalse;
		}
		return fTrue;
	}

LOCAL BOOL FSetHardRecoveryModeModifier( char chMode, UTILOPTS *popts )
	{
	switch( chMode )
		{
		case 'c':
		case 'C':
			break;
		case 'm':
		case 'M':
			UTILOPTSSetDumpRestoreEnv( popts->fUTILOPTSFlags );
			break;
#ifdef RESTORE_SERVER_SIMULATION
		case 's':
		case 'S':
			UTILOPTSSetServerSim ( popts->fUTILOPTSFlags );
			break;
#endif // RESTORE_SERVER_SIMULATION
		default:
			return fFalse;
		}
	return fTrue;
	}

LOCAL BOOL FEDBUTLParseOptions(
	UTILOPTS	*popts,
	BOOL		(*pFEDBUTLParseMode)( char *arg, UTILOPTS *popts ) )
	{
	BOOL		fResult = fTrue;
	char		*arg = GetCurArg();
	INT 		iSkipID = -1; // argument ID to skip. Related to dump and hard recovery hacks

	assert( NULL != arg );
	assert( NULL != strchr( szSwitches, *arg ) );
	assert( '\0' != *arg + 1 );

	//	HACK for dump 
	if ( modeDump == popts->mode ) 
		{
		// when we have only one char after mode it is mode modifier
		if ( '\0' != arg[2] && '\0' == arg[3] )
			{
			fResult = FSetDumpModeModifier( arg[2], (JET_DBUTIL *)popts->pv );
			arg++;
			}
		else	// run search to set mode specifier
			{
			INT curid = GetCurArgID();
			char *argT;
			fResult = fFalse;
			while ( !fResult && NULL != ( argT = GetNextArg() ) )
				{
				if ( NULL != strchr( szSwitches, *argT ) && '\0' != argT[1] && '\0' == argT[2] )
					{
					fResult = FSetDumpModeModifier( argT[1], (JET_DBUTIL *)popts->pv );
					}
				}
			if ( !fResult )
				{
				fResult = FSetDumpModeModifier( '\0', (JET_DBUTIL *)popts->pv );
				}
			iSkipID = GetCurArgID();
			SetCurArgID( curid );
			assert( GetCurArgID() == curid );
			}
		}
	//	HACK for hard recovery
	else if ( modeHardRecovery == popts->mode )
		{
		// when we have only one char afret mode it is mode modifier
		if ( '\0' != arg[2] && '\0' == arg[3] )
			{
			fResult = FSetHardRecoveryModeModifier( arg[2], popts );
			arg ++;	// ignore mode modifier
			}
		else	// run search to set mode specifier
			{
			INT curid = GetCurArgID();
			char *argT;
			fResult = fFalse;
			while ( !fResult && NULL != ( argT = GetNextArg() ) )
				{
				if ( NULL != strchr( szSwitches, *argT ) && '\0' != argT[1] && '\0' == argT[2] )
					{
					fResult = FSetHardRecoveryModeModifier( argT[1], popts );
					}
				}
			iSkipID = GetCurArgID();
			SetCurArgID( curid );
			assert( GetCurArgID() == curid );
			}
		}
		
	if ( !fResult )
		{
		printf( "%s%c%c", szUsageErr12, cNewLine, cNewLine );
		}
		
	arg += 2;
	if ( '\0' == *arg )
		{
		arg = GetNextArg();
		}

	// First option specifies the mode, so start with the second option.
	for ( ; fResult && NULL != arg; arg = GetNextArg() )
		{
		//	dump and hard recovery hack
		if ( GetCurArgID() == iSkipID )
			{
			continue;
			}
			
		if ( strchr( szSwitches, arg[0] ) == NULL )
			{
			// SPECIAL CASE: Backup mode does not DB specification.
			switch ( popts->mode )
				{
				case modeRecovery:
					if ( fResult = ( NULL == popts->szBase ) )
						{
						popts->szBase = arg;
						}
					break;
				case modeBackup:
					if ( fResult = ( NULL == popts->szBackup ) )
						{
						popts->szBackup = arg;
						}
					break;
				default:
					if ( fResult = ( NULL == popts->szSourceDB ) )
						{
						popts->szSourceDB = arg;
						}
					break;
				}

			if ( !fResult )
				{
				printf( szUsageErr5, arg );
				printf( "%c%c", cNewLine, cNewLine );
				}
			}

		else
			{
			// Parse options common to all modes.  Pass off unique options to the
			// custom parsers.
			switch ( arg[1] )
				{
				case '8':
					UTILOPTSSet8KPage( popts->fUTILOPTSFlags );
					break;

				case 'o':
				case 'O':
					UTILOPTSSetSuppressLogo( popts->fUTILOPTSFlags );
					break;

				case '!':
					//	logfile size param no longer needed (Jet now
					//	auto-detects logfile size when needed)
					break;

				default:
					if ( pFEDBUTLParseMode )
						{
						fResult = (*pFEDBUTLParseMode)( arg, popts );
						}
					else
						{
						printf( szUsageErr4, arg );
						printf( "%c%c", cNewLine, cNewLine );
						fResult = fFalse;
						}
					break;
				}
			}
		}

	return fResult;		
	}


//  ================================================================
LOCAL JET_ERR ErrEDBUTLRepair(
	const JET_SESID	sesid,
	const char * const szDatabase,
	const char * const szSLV,
	const char * const szBackup,
	const char * const szTable,
	const char * const szIntegPrefix,
	const JET_PFNSTATUS pfnStatus,
	const JET_GRBIT grbit
	)
//  ================================================================
	{
	JET_DBUTIL dbutil;
	memset( &dbutil, 0, sizeof( dbutil ) );

	dbutil.cbStruct			= sizeof( JET_DBUTIL );
	dbutil.op				= opDBUTILEDBRepair;
	dbutil.szDatabase 		= const_cast<char *>( szDatabase );
	dbutil.szSLV 			= const_cast<char *>( szSLV );
	dbutil.szBackup			= const_cast<char *>( szBackup );
	dbutil.szTable			= const_cast<char *>( szTable );
	dbutil.szIntegPrefix	= const_cast<char *>( szIntegPrefix );
	dbutil.sesid			= sesid;
	dbutil.grbitOptions		= grbit;	
	dbutil.pfnCallback		= pfnStatus;

	const JET_ERR err = JetDBUtilities( &dbutil );
	return err;
	}


//  ================================================================
LOCAL JET_ERR ErrEDBUTLScrub(
	JET_SESID	sesid,
	const char * const szDatabase,
	const char * const szSLV,
	JET_PFNSTATUS pfnStatus,
	JET_GRBIT grbit
	)
//  ================================================================
	{
	JET_DBUTIL dbutil;
	memset( &dbutil, 0, sizeof( dbutil ) );

	dbutil.cbStruct			= sizeof( JET_DBUTIL );
	dbutil.op				= opDBUTILEDBScrub;
	dbutil.szDatabase 		= const_cast<char *>( szDatabase );
	dbutil.szSLV 			= const_cast<char *>( szSLV );
	dbutil.sesid			= sesid;
	dbutil.grbitOptions		= grbit;	
	dbutil.pfnCallback		= pfnStatus;

	const JET_ERR err = JetDBUtilities( &dbutil );
	return err;
	}


#ifdef RECORD_FORMAT_UPGRADE
//  ================================================================
LOCAL JET_ERR ErrEDBUTLUpgradeRecordFormat(
	JET_SESID	sesid,
	const char * const szDatabase,
	JET_PFNSTATUS pfnStatus,
	JET_GRBIT grbit
	)
//  ================================================================
	{
	JET_DBUTIL dbutil;
	memset( &dbutil, 0, sizeof( dbutil ) );

	dbutil.cbStruct			= sizeof( JET_DBUTIL );
	dbutil.op				= opDBUTILDBConvertRecords;
	dbutil.szDatabase 		= const_cast<char *>( szDatabase );
	dbutil.szSLV 			= NULL;
	dbutil.sesid			= sesid;
	dbutil.grbitOptions		= grbit;	
	dbutil.pfnCallback		= pfnStatus;

	const JET_ERR err = JetDBUtilities( &dbutil );
	return err;
	}
#endif


//	callback function used by CopyFileEx
LOCAL DWORD CALLBACK DwEDBUTILCopyProgressRoutine(
	LARGE_INTEGER	cTotalFileSize,          // file size
	LARGE_INTEGER	cTotalBytesTransferred,  // bytes transferred
	LARGE_INTEGER	cStreamSize,             // bytes in stream
	LARGE_INTEGER	cStreamBytesTransferred, // bytes transferred for stream
	DWORD			dwStreamNumber,			// current stream
	DWORD			dwCallbackReason,		// callback reason
	HANDLE			hSourceFile,			// handle to source file
	HANDLE			hDestinationFile,		// handle to destination file
	INT				*pcShift				// from CopyFileEx. How much to shift file size to fit in INT value
)
	{
	enum { LITOI_LOW = 1, LITOI_HIGH, LITOI_SHIFT };
	//	zero sized file?
	if ( 0 == cTotalFileSize.QuadPart )
		{
		return PROGRESS_CONTINUE;
		}
	JET_SNPROG snpprog;
	assert( NULL != pcShift );
	if ( -1 == *pcShift )
		{ 
		PrintStatus( 0, -1, JET_sntBegin, (void *)szCopyFileStatus );
		assert( sizeof( ULONG ) == sizeof( INT ) );
		assert( sizeof( LARGE_INTEGER ) > sizeof( INT ) );
		//  if all data fits in INT value
		if ( 0 == (ULONG)cTotalFileSize.HighPart )
			{
			*pcShift = LITOI_LOW;
			}
		//  if High part can be used as 1% change detector
		else if ( 100 <= (ULONG)cTotalFileSize.HighPart )
			{
			*pcShift = LITOI_HIGH;
			}
		else
			{
			*pcShift = LITOI_SHIFT;
			}
		}
	snpprog.cbStruct = sizeof( snpprog );
	switch ( *pcShift )
		{
		//  if all data fits in INT value
		case LITOI_LOW:
			assert( 0 == cTotalFileSize.HighPart );
			snpprog.cunitTotal = cTotalFileSize.LowPart;
			snpprog.cunitDone = cTotalBytesTransferred.LowPart;
			break;
		//  if High part can be used as 1% change detector
		case LITOI_HIGH:
			assert( 100 <= cTotalFileSize.HighPart );
			snpprog.cunitTotal = cTotalFileSize.HighPart;
			snpprog.cunitDone = cTotalBytesTransferred.HighPart;
			break;
		//  if none of the above shift it 7 times because 2^7 > 100 and it will move 
		//	all High Part data to Low Part
		case LITOI_SHIFT:
			assert( 100 > cTotalFileSize.HighPart && 0 < cTotalFileSize.HighPart );
			snpprog.cunitTotal = (INT)( cTotalFileSize.QuadPart >> 7 );
			snpprog.cunitDone = (INT)( cTotalBytesTransferred.QuadPart >> 7 );
			break;
		default:
			assert( fFalse );
		}
	if ( cTotalBytesTransferred.QuadPart == cTotalFileSize.QuadPart )
		{
		PrintStatus( 0, -1, JET_sntComplete, &snpprog );
		}
	else
		{
		PrintStatus( 0, -1, JET_sntProgress, &snpprog );
		}
	return PROGRESS_CONTINUE;
	}

LOCAL JET_ERR ErrEDBUTLMoveFile(
	const char * const szExistingFileName,  // file name
	const char * const szNewFileName,       // new file name
	const DWORD dwFlags )
	{
	printf( szMoveFile, szExistingFileName, szNewFileName );
	if ( !MoveFileEx( szExistingFileName, szNewFileName, dwFlags ) )
		{
		DWORD dw = GetLastError();
		
		if ( ( dwFlags & ~MOVEFILE_REPLACE_EXISTING ) != 0 )
			{
			// unsupported move flag
			assert( fFalse );
			printf( "%s%c", szMoveFailed, cNewLine );
			return JET_errFileAccessDenied;
			}

		if ( dw == ERROR_CALL_NOT_IMPLEMENTED )
			{
			//	MoveFileEx is not implemented in Win9x
			dw = 0;
			if ( dwFlags & MOVEFILE_REPLACE_EXISTING )
				{
				DeleteFile( szNewFileName );
				}
			if ( !MoveFile( szExistingFileName, szNewFileName ) )
				{
				dw = GetLastError();
				if ( dw == ERROR_NOT_SAME_DEVICE )
					{
					//	the source file is on a different device -- we must copy it instead
					dw = 0;
					printf( "%s", szCopyFile );
					if ( !CopyFile( szExistingFileName, szNewFileName, ( dwFlags & MOVEFILE_REPLACE_EXISTING ? FALSE : TRUE ) ) )
						{
						dw = GetLastError();
						}
					}
				}
			}
		else if ( dw == ERROR_NOT_SAME_DEVICE )
			{
			typedef WINBASEAPI BOOL WINAPI PFNCopyFileEx( LPCTSTR, LPCTSTR, LPPROGRESS_ROUTINE, LPVOID, LPBOOL, DWORD );

#ifdef UNICODE
			PFNCopyFileEx*	pfnCopyFileEx = (PFNCopyFileEx*)GetProcAddress( GetModuleHandle( _T( "kernel32.dll" ) ), _T( "CopyFileExW" ) );
#else  //  !UNICODE
			PFNCopyFileEx*	pfnCopyFileEx = (PFNCopyFileEx*)GetProcAddress( GetModuleHandle( _T( "kernel32.dll" ) ), _T( "CopyFileExA" ) );
#endif  //  UNICODE

			//	the source file is on a different device -- we must copy it instead
			BOOL		fCancel		= fFalse;
			INT			cShift		= -1;		// used from progress routine
			const BOOL	fSuccess	= (	pfnCopyFileEx &&
										pfnCopyFileEx(	szExistingFileName,
														szNewFileName,
														LPPROGRESS_ROUTINE( DwEDBUTILCopyProgressRoutine ),
														&cShift,
														&fCancel,
														(	dwFlags & MOVEFILE_REPLACE_EXISTING ?
																0 :
																COPY_FILE_FAIL_IF_EXISTS ) ) );
			return ( fSuccess ? JET_errSuccess : JET_errFileAccessDenied );
			}
			
		if ( dw != 0 )
			{
			printf( "%s%c", szMoveFailed, cNewLine );
			return JET_errFileAccessDenied;
			}
		}

	printf( "%s%c", szMoveDone, cNewLine );
	return JET_errSuccess;
	}


LOCAL VOID EDBUTLDeleteTemp( const UTILOPTS * const popts )
	{
	assert( NULL != popts->szTempDB );
	DeleteFile( popts->szTempDB);
	if ( NULL != popts->szTempSLV )
		{
		DeleteFile( popts->szTempSLV );
		}
	}

// Backs up source database if required, then copies temporary database over
// source database if required.  Should be called after Jet has terminated.	
LOCAL JET_ERR ErrEDBUTLBackupAndInstateDB(
	JET_SESID	sesid,
	UTILOPTS	*popts )
	{
	JET_ERR		err = JET_errSuccess;;

	assert( popts->szSourceDB != NULL );
	assert( popts->szTempDB != NULL );

	// backup/instate cannot be respected on in-place upgrade.

	if ( FUTILOPTSInPlaceUpgrade( popts->fUTILOPTSFlags ) )
		{
		return JET_errSuccess;
		}

	//	BUGFIX (X5:123014): upgrade from 8.3 to full filename
	
	_TCHAR	szSourceDB[_MAX_PATH+1];
	_TCHAR	szSourceSLV[_MAX_PATH+1];

	WIN32_FIND_DATA wfd;
	HANDLE 			hFind;
		
	hFind = FindFirstFile( popts->szSourceDB, &wfd );
	if( INVALID_HANDLE_VALUE != hFind )
		{
		_TCHAR	szDrive[_MAX_PATH+1];
		_TCHAR	szDir[_MAX_PATH+1];
		
		_tsplitpath( popts->szSourceDB, szDrive, szDir, NULL, NULL );
		_makepath( szSourceDB, szDrive, szDir, NULL, NULL );
		_tcscat( szSourceDB, wfd.cFileName );
		FindClose( hFind );
		}
	else
		{
		_tcscpy( szSourceDB, popts->szSourceDB );
		}

	if ( !FUTILOPTSDefragSLVDontCopy( popts->fUTILOPTSFlags ) )
		{
		assert( NULL != popts->szSourceSLV );
		assert( NULL != popts->szTempSLV );
		
		hFind = FindFirstFile( popts->szSourceSLV, &wfd );
		if( INVALID_HANDLE_VALUE != hFind )
			{
			_TCHAR	szDrive[_MAX_PATH+1];
			_TCHAR	szDir[_MAX_PATH+1];
		
			_tsplitpath( popts->szSourceSLV, szDrive, szDir, NULL, NULL );
			_makepath( szSourceSLV, szDrive, szDir, NULL, NULL );
			_tcscat( szSourceSLV, wfd.cFileName );
			FindClose( hFind );
			}
		else
			{
			_tcscpy( szSourceSLV, popts->szSourceSLV );
			}
		}


	// Make backup before instating, if requested.

	if ( popts->szBackup != NULL )
		{
		err = ErrEDBUTLMoveFile( szSourceDB, popts->szBackup, 0 );
		if ( err < 0 )
			{
			printf( szErr4, popts->szBackup );
			printf( "%c%c", cNewLine, cNewLine );
			Call( err );
			}
		if ( !FUTILOPTSDefragSLVDontCopy( popts->fUTILOPTSFlags ) )
			{
			_TCHAR	szBackupSLV[_MAX_PATH+1];

			EDBUTLGetSLVNameFromDbName( popts->szBackup, szBackupSLV );
			err = ErrEDBUTLMoveFile( szSourceSLV, szBackupSLV, 0 );
			if ( err < 0 )
				{
				printf( szErr4, popts->szBackup );
				printf( "%c%c", cNewLine, cNewLine );
				Call( err );
				}
			}
		}

	if ( !FUTILOPTSPreserveTempDB( popts->fUTILOPTSFlags ) )
		{
		err = ErrEDBUTLMoveFile( popts->szTempDB, szSourceDB, MOVEFILE_REPLACE_EXISTING );
		if ( err < 0 )
			{
			printf( szErr5, szSourceDB, popts->szTempDB, szSourceDB );
			printf( "%c%c", cNewLine, cNewLine );
			Call( err );
			}
		if ( !FUTILOPTSDefragSLVDontCopy( popts->fUTILOPTSFlags ) )
			{
			err = ErrEDBUTLMoveFile( popts->szTempSLV, szSourceSLV, MOVEFILE_REPLACE_EXISTING );
			if ( err < 0 )
				{
				printf( szErr5, szSourceSLV, popts->szTempSLV, szSourceSLV );
				printf( "%c%c", cNewLine, cNewLine );
				Call( err );
				}
			}
		// Delete temporary database only if everything was successful.			
		EDBUTLDeleteTemp( popts );
		}

HandleError:
	return err;
	}


// Load registry environment, if enabled.  Then load command-line overrides.
LOCAL JET_ERR ErrEDBUTLUserSystemParameters( JET_INSTANCE *pinstance, UTILOPTS *popts )
	{
	JET_ERR	err;

	// Facilitate debugging.
	Call( JetSetSystemParameter( pinstance, 0, JET_paramAssertAction, JET_AssertMsgBox, NULL ) );

	// Command-line parameters override all default and registry values.
	if ( popts->szLogfilePath != NULL )
		{
		Call( JetSetSystemParameter( pinstance, 0, JET_paramLogFilePath, 0, popts->szLogfilePath ) );
		}
	if ( popts->szSystemPath != NULL )
		{
		Call( JetSetSystemParameter( pinstance, 0, JET_paramSystemPath, 0, popts->szSystemPath ) );
		}
	if ( popts->cpageBuffers != 0 )
		{
#if 0	// no longer needed because of DBA
		unsigned long ulCacheSizeMax;
		Call( JetGetSystemParameter( *pinstance, 0, JET_paramCacheSizeMax, &ulCacheSizeMax, NULL, 0 ) );
		if ( (long)ulCacheSizeMax < popts->cpageBuffers )
			{
			Call( JetSetSystemParameter( pinstance, 0, JET_paramCacheSizeMax, popts->cpageBuffers, NULL ) );
			Call( JetSetSystemParameter( pinstance, 0, JET_paramStopFlushThreshold, popts->cpageBuffers, NULL ) );
			Call( JetSetSystemParameter( pinstance, 0, JET_paramStartFlushThreshold, popts->cpageBuffers * 1 / 100, NULL ) );
			Call( JetSetSystemParameter( pinstance, 0, JET_paramStopFlushThreshold, popts->cpageBuffers * 10 / 100, NULL ) );
			}
		else
			{
			Call( JetSetSystemParameter( pinstance, 0, JET_paramStartFlushThreshold, 1, NULL ) );
			Call( JetSetSystemParameter( pinstance, 0, JET_paramStopFlushThreshold, popts->cpageBuffers * 10 / 100, NULL ) );
			Call( JetSetSystemParameter( pinstance, 0, JET_paramStartFlushThreshold, popts->cpageBuffers * 1 / 100, NULL ) );
			Call( JetSetSystemParameter( pinstance, 0, JET_paramCacheSizeMax, popts->cpageBuffers, NULL ) );
			}
#endif	//	0
		}
	if ( popts->cpageBatchIO != 0 )
		{
		Call( JetSetSystemParameter( pinstance, 0, JET_paramBatchIOBufferMax, popts->cpageBatchIO * 4, NULL ) );
		}
	if ( popts->cpageDbExtension != 0 )
		{
		Call( JetSetSystemParameter( pinstance, 0, JET_paramDbExtensionSize, popts->cpageDbExtension, NULL ) );
		}

	if ( NULL != popts->szBase )
		{
		Call( JetSetSystemParameter( pinstance, 0, JET_paramBaseName, NULL, popts->szBase ) );
		}
HandleError:
	return err;
	}


// Teminate Jet, either normally or abnormally.
LOCAL JET_ERR ErrEDBUTLCleanup( JET_INSTANCE instance, JET_SESID sesid, JET_ERR err )
	{
	if ( 0 != sesid && JET_sesidNil != sesid )
		{
		JET_ERR	errT = JetEndSession( sesid, 0 );

		if ( err >= 0 )
			err = errT;
		}

	if ( err < 0 ) 
		{
		// On error, terminate abruptly and throw out return code from JetTerm2().
		JetTerm2( instance, JET_bitTermAbrupt );
		}
	else 
		{
		err = JetTerm2( instance, JET_bitTermComplete );
		}

	return err;
	}


LOCAL BOOL FAquireBackupRestoreRights()
{

   BOOL		ret_val = TRUE ;
   HANDLE 	ProcessHandle;
   DWORD  	DesiredAccess;
   HANDLE 	TokenHandle;
   LUID   	BackupValue;
   LUID   	RestoreValue;
   TOKEN_PRIVILEGES NewState;


   // get process handle

   ProcessHandle = GetCurrentProcess();

   // open process token

   DesiredAccess = MAXIMUM_ALLOWED;

   if ( ! OpenProcessToken( ProcessHandle, DesiredAccess, &TokenHandle ) ) {
      return FALSE;
   }

   // adjust backup token privileges
   if ( ! LookupPrivilegeValue( NULL, TEXT("SeRestorePrivilege"), &RestoreValue ) ) {
      ret_val = FALSE;
   }

   if ( ! LookupPrivilegeValue( NULL, TEXT("SeBackupPrivilege"), &BackupValue ) ) {
      ret_val = FALSE;
   }

   // Enable backup privilege for this process

   NewState.PrivilegeCount = 1;
   NewState.Privileges[0].Luid = BackupValue;
   NewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

   if ( ! AdjustTokenPrivileges( TokenHandle, FALSE, &NewState, (DWORD)0, NULL, NULL ) ) {
      ret_val = FALSE;
   }


   NewState.PrivilegeCount = 1;
   NewState.Privileges[0].Luid = RestoreValue;
   NewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

   if ( ! AdjustTokenPrivileges( TokenHandle, FALSE, &NewState, (DWORD)0, NULL, NULL ) ) {
      ret_val = FALSE;
   }
// AdjustTokenPriv always returns SUCCESS, call GetLast to see if it worked.

   if ( GetLastError() != ERROR_SUCCESS ) {
      ret_val = FALSE;
   }

   // close process token

   CloseHandle( TokenHandle );
   return( ret_val );
}

#define JET_errReturnedForESEBCLI2		JET_errInternalError
#define JET_errReturnedForESEBACK2		JET_errInternalError

#define CallHr( func )									\
	{ 													\
	hr = func; 											\
	hrGLE = GetLastError(); 							\
	if ( hrNone != hr ) 								\
		{												\
		goto HandleError;								\
		}												\
	}

unsigned long WszFromSzGetSize( const char * sz )
	{
	return MultiByteToWideChar(CP_OEMCP, 0, sz, -1, NULL, 0);
	}

WCHAR * WszFromSz( const char *  sz )
	{
	WCHAR *  wsz;
	long cw;

	if ( 0 == ( cw = WszFromSzGetSize(sz) ) )
		return(NULL);

	if ( ( wsz = (WCHAR *) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, cw * sizeof(WCHAR) ) ) == NULL )
		return(NULL);

	if ( MultiByteToWideChar(CP_OEMCP, 0, sz, -1, wsz, cw ) == 0 )
		{
		LocalFree(wsz);
		return(NULL);
		}

	return(wsz);
	}

WCHAR * WszCopy( const WCHAR *  wsz )
	{
	WCHAR *  wszCopy;
	long cw;

	assert ( wsz );
	cw = (ULONG)wcslen( wsz ) + 1;

	if ( ( wszCopy = (WCHAR *) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, cw * sizeof(WCHAR) ) ) == NULL )
		return(NULL);

	wcscpy ( wszCopy, wsz );
	return( wszCopy );
	}


void PrintESEBCLI2Error ( HRESULT hr, HRESULT hrGLE, HMODULE hESEBCLI2 )
	{		
	LPVOID 		lpMsgBuf 				= NULL;
	char *		szFinalMsg 				= NULL;

	if ( hrNone == hr )
		return;
		
	if ( 0 == FormatMessage( 
			    FORMAT_MESSAGE_FROM_HMODULE | 
			    FORMAT_MESSAGE_FROM_SYSTEM | 
			    FORMAT_MESSAGE_IGNORE_INSERTS |
		    	FORMAT_MESSAGE_ALLOCATE_BUFFER,
			    hESEBCLI2,
			    hr,
			    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			    (LPTSTR) &lpMsgBuf,
		    	0,
			    NULL ) )
	    {
		lpMsgBuf = NULL;
	    }

	if ( lpMsgBuf )
		{
		if ( hr == hrErrorFromESECall || hr == hrErrorFromCallbackCall )
			{
			szFinalMsg = (char *) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,	sizeof( char ) * ( strlen( (char *)lpMsgBuf ) + 1 ) + 32 );
			if ( szFinalMsg )						
				{
				sprintf( szFinalMsg, (char *) lpMsgBuf, hrGLE );
				LocalFree( lpMsgBuf );	
				}
			else
				{
				// print the message without error number
				szFinalMsg = (char *)lpMsgBuf;
				}				
			}
		else
			{
			szFinalMsg = (char *)lpMsgBuf;
			}
			
		printf( "%s", szFinalMsg );
		LocalFree ( szFinalMsg );		
		}
	}

typedef HRESULT (ESEBACK_API * PfnHrESERestoreReopen)(
	IN  WCHAR *					wszServerName,
	IN  WCHAR *					wszServiceAnnotation,
	IN  WCHAR *		 			wszRestoreLogPath,
	OUT HCCX *					phccxRestoreContext);
	
typedef HRESULT (ESEBACK_API * PfnHrESERestoreClose)(
	IN HCCX hccxRestoreContext,
	IN unsigned long fRestoreAbort);

typedef HRESULT (ESEBACK_API * PfnHrESERestoreComplete)(
	IN  HCCX 				hccxRestoreContext,
	IN  WCHAR *				wszRestoreInstanceSystemPath,
	IN  WCHAR *				wszRestoreInstanceLogPath,
	IN  WCHAR *				wszTargetInstanceName,
	IN  unsigned long 		fFlags);

typedef HRESULT (ESEBACK_API * PfnHrESERestoreLoadEnvironment)(
	IN	WCHAR *				wszServerName,
	IN	WCHAR *				wszRestoreLogPath,
	OUT RESTORE_ENVIRONMENT ** 	ppRestoreEnvironment);

typedef HRESULT (ESEBACK_API * PfnHrESERestoreGetEnvironment)(
	IN  HCCX 					hccxRestoreContext,
	OUT RESTORE_ENVIRONMENT ** 	ppRestoreEnvironment);

typedef void (ESEBACK_API * PfnESERestoreFreeEnvironment)(
	IN  RESTORE_ENVIRONMENT * 	pRestoreEnvironment);

LOCAL void PrintField( const WCHAR * wszDesc, int cDesc, const WCHAR * wszData, const BOOL fNewLine = TRUE )
	{
	wprintf( L"%*s %s%s", cDesc, wszDesc, wszData?wszData:L"", fNewLine?L"\n":L"" );
	}

WCHAR * rwszRecoverStatus[] = { 
	L"recoverInvalid",
	L"recoverNotStarted",
	L"recoverStarted",
	L"recoverEnded"
	};


LOCAL BOOL FDBUTLLoadLibrary( const _TCHAR* szLibrary, HMODULE *plibrary )
	{
	while ( NULL == ( *plibrary = LoadLibrary( (LPTSTR)szLibrary ) ) )
		{		
		_TCHAR szMessage[256];
		(void)_stprintf(
			szMessage,
			_T( 	"Unable to find the callback library %s (or one of its dependencies).\r\n"
					"Copy in the file and hit OK to retry, or hit Cancel to abort.\r\n" ),
			szLibrary );

		const int id = MessageBox(
							NULL,
							szMessage,
							_T( "Callback DLL not found" ),
							MB_SERVICE_NOTIFICATION | MB_SYSTEMMODAL | MB_ICONSTOP |
							MB_OKCANCEL );

		if ( IDOK != id )
			{
			break;
			}
		}
		
	return ( NULL != *plibrary );
	}


LOCAL JET_ERR ErrDBUTLDumpRestoreEnv( const char * szRestorePath )
	{
	JET_ERR			err 				= JET_errSuccess;
	HRESULT 		hr 					= hrNone;
	HRESULT 		hrGLE 				= hrNone;
	WCHAR * 		wszRestorePath 		= NULL;
	HMODULE 		hESEBCLI2 			= NULL;	
	int 			cDesc 				= 30;

	RESTORE_ENVIRONMENT * 				pREnv 					= NULL;
	PfnHrESERestoreLoadEnvironment 		pfnHrESERestoreLoadEnv 	= NULL;
	PfnESERestoreFreeEnvironment 		pfnESERestoreFreeEnv 	= NULL;

	unsigned long 	iDb;

	assert ( szRestorePath );

	if ( !FDBUTLLoadLibrary( ESEBCLI2_DLL_NAME, &hESEBCLI2 ) )
		{
		Call ( JET_errCallbackNotResolved );
		}

	pfnHrESERestoreLoadEnv = (PfnHrESERestoreLoadEnvironment) GetProcAddress( hESEBCLI2, "HrESERestoreLoadEnvironment" );
	pfnESERestoreFreeEnv = (PfnESERestoreFreeEnvironment) GetProcAddress( hESEBCLI2, "ESERestoreFreeEnvironment" );

	if ( !pfnESERestoreFreeEnv || !pfnHrESERestoreLoadEnv )
		{
		Call ( JET_errCallbackNotResolved );
		}
			
	wszRestorePath = WszFromSz( szRestorePath );
	if ( !wszRestorePath )
		{
		Call ( JET_errOutOfMemory );
		}
		
	PrintField( L"Restore log file:", cDesc, wszRestorePath );
	PrintField( L"", cDesc, NULL );

	assert ( pfnHrESERestoreLoadEnv );
	CallHr ( (*pfnHrESERestoreLoadEnv)( 	NULL,
											wszRestorePath,
											&pREnv ) );

	// dump Restore.Env
	assert ( pREnv );

	PrintField( L"Restore Path:", cDesc, pREnv->m_wszRestoreLogPath );
	PrintField( L"Annotation:", cDesc, pREnv->m_wszAnnotation );	

	PrintField( L"Backup Instance:", cDesc, pREnv->m_wszSrcInstanceName );
	PrintField( L"Target Instance:", cDesc, pREnv->m_wszTargetInstanceName );

	PrintField( L"Restore Instance System Path:", cDesc, pREnv->m_wszRestoreInstanceSystemPath );
	PrintField( L"Restore Instance Log Path:", cDesc, pREnv->m_wszRestoreInstanceLogPath );

	PrintField( L"", cDesc, NULL );

	{
	WCHAR wszBuffer[32];
	swprintf( wszBuffer, L"%d database(s)", pREnv->m_cDatabases );
	PrintField( L"Databases:", cDesc, wszBuffer );
	}

	assert ( pREnv->m_wszDatabaseDisplayName || 0 == pREnv->m_cDatabases);
	assert ( pREnv->m_rguidDatabase || 0 == pREnv->m_cDatabases);
	assert ( pREnv->m_wszDatabaseStreamsS || 0 == pREnv->m_cDatabases);
	assert ( pREnv->m_wszDatabaseStreamsD || 0 == pREnv->m_cDatabases);

	cDesc += 8;
	for (iDb = 0; iDb < pREnv->m_cDatabases; iDb++)
		{		
		assert ( pREnv->m_wszDatabaseDisplayName[iDb] );
		assert ( pREnv->m_wszDatabaseStreamsS[iDb] );
		assert ( pREnv->m_wszDatabaseStreamsS[iDb] );

		WCHAR guidStr[256];
		WCHAR * wszStreams;
		GUID guid = pREnv->m_rguidDatabase[iDb];
		
		PrintField( L"Database Name:", cDesc, pREnv->m_wszDatabaseDisplayName[iDb] );
		// like: 6B29FC40-CA47-1067-B31D-00DD010662DA
		swprintf(	guidStr,
					L"%08X-%04X-%04X-%08X%08X",
					guid.Data1, guid.Data2, guid.Data3,
					*(DWORD *)&guid.Data3,*( 1 + (DWORD *)&guid.Data3 ) );

		PrintField( L"GUID:", cDesc, guidStr );

		wszStreams = pREnv->m_wszDatabaseStreamsS[iDb];
		PrintField( L"Source Files:", cDesc, NULL, FALSE );
		while ( L'\0' != wszStreams[0] )
			{
			wprintf( L"%s ", wszStreams );
			wszStreams += wcslen( wszStreams ) + 1;
			}
		wprintf( L"\n" );
		wszStreams = pREnv->m_wszDatabaseStreamsD[iDb];
		PrintField( L"Destination Files:", cDesc, NULL, FALSE );
		while ( L'\0' != wszStreams[0] )
			{
			wprintf( L"%s ", wszStreams );
			wszStreams += wcslen( wszStreams ) + 1;
			}
		PrintField( L"", cDesc, NULL );
		PrintField( L"", cDesc, NULL );
		}
		
	cDesc -= 8;
	PrintField( L"", cDesc, NULL );
	PrintField( L"", cDesc, NULL );
		
	{
	WCHAR wszBuffer[32];
	
	if ( pREnv->m_wszLogBaseName )
		{
		assert ( 0 != pREnv->m_ulGenLow );
		assert ( 0 != pREnv->m_ulGenHigh );
		assert ( pREnv->m_ulGenLow <= pREnv->m_ulGenHigh );
		swprintf( wszBuffer, L"%s%05X.log - %s%05X.log", 
			pREnv->m_wszLogBaseName,
			pREnv->m_ulGenLow,
			pREnv->m_wszLogBaseName,
			pREnv->m_ulGenHigh);
		}
	else
		{
		assert ( 0 == pREnv->m_ulGenLow );
		assert ( 0 == pREnv->m_ulGenHigh );
		swprintf( wszBuffer, L"no log files restored");
		}
	PrintField( L"Log files range:", cDesc, wszBuffer );
	
	PrintField( L"Last Restore Time:", cDesc, _wctime ( &pREnv->m_timeLastRestore) );

	RECOVER_STATUS status = pREnv->m_statusLastRecover;

	if ( status >= sizeof(rwszRecoverStatus)/ sizeof(rwszRecoverStatus[0] ) )
		status = recoverInvalid;
		
	PrintField( L"Recover Status:", cDesc, rwszRecoverStatus [ status ] );

	swprintf( wszBuffer, L"0x%08X", pREnv->m_hrLastRecover);
	PrintField( L"Recover Error:", cDesc, wszBuffer );
	
	PrintField( L"Recover Time:", cDesc, _wctime ( &pREnv->m_timeLastRecover ) );
	}

											
HandleError:

	LocalFree ( wszRestorePath );

	if ( pREnv )
		{
		assert ( pfnESERestoreFreeEnv );
		(*pfnESERestoreFreeEnv)( pREnv );
		pREnv = NULL;
		}

	if ( hrNone != hr )
		{
		assert ( hESEBCLI2 );
		PrintESEBCLI2Error ( hr, hrGLE, hESEBCLI2 );
		err = JET_errReturnedForESEBCLI2;
		}
	
	if ( NULL != hESEBCLI2 )
		{
		FreeLibrary( hESEBCLI2 );
		hESEBCLI2 = NULL;
		}

	return err;	
	}

LOCAL JET_ERR ErrDBUTLRestoreComplete( const char * szFullRestorePath, const char * szTargetInstance, BOOL fKeepLogs )
	{
	JET_ERR			err 				= JET_errSuccess;
	HRESULT 		hr 					= hrNone;
	HRESULT 		hrGLE;

	WCHAR * 		wszRestorePath 		= NULL;
	WCHAR * 		wszTargetInstance 	= NULL;
	WCHAR * 		wszComputerName 	= NULL;
	
	DWORD 			nSize ;
	char 			szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	
	HCCX 			hccxRestoreContext 	= NULL;	

	HMODULE 		hESEBCLI2 = NULL;
	
	PfnHrESERestoreReopen 				pfnErrESERestoreReopen =	 NULL;
	PfnHrESERestoreClose 				pfnErrESERestoreClose 		= NULL;
	PfnHrESERestoreComplete 			pfnErrESERestoreComplete 	= NULL;

	RESTORE_ENVIRONMENT * 				pREnv 						= NULL;
	PfnHrESERestoreGetEnvironment 		pfnHrESERestoreGetEnv 		= NULL;
	PfnESERestoreFreeEnvironment 		pfnESERestoreFreeEnv 		= NULL;

	assert ( szFullRestorePath );
	
	if ( !FDBUTLLoadLibrary( ESEBCLI2_DLL_NAME, &hESEBCLI2 ) )
		{
		Call ( JET_errCallbackNotResolved );
		}

	pfnErrESERestoreReopen = (PfnHrESERestoreReopen) GetProcAddress( hESEBCLI2, "HrESERestoreReopen" );
	pfnErrESERestoreClose = (PfnHrESERestoreClose) GetProcAddress( hESEBCLI2, "HrESERestoreClose" );
	pfnErrESERestoreComplete = (PfnHrESERestoreComplete) GetProcAddress( hESEBCLI2, "HrESERestoreComplete" );
	pfnHrESERestoreGetEnv = (PfnHrESERestoreGetEnvironment) GetProcAddress( hESEBCLI2, "HrESERestoreGetEnvironment" );
	pfnESERestoreFreeEnv = (PfnESERestoreFreeEnvironment) GetProcAddress( hESEBCLI2, "ESERestoreFreeEnvironment" );

	if ( 	!pfnErrESERestoreReopen || !pfnErrESERestoreClose || !pfnErrESERestoreComplete ||
			!pfnHrESERestoreGetEnv || !pfnESERestoreFreeEnv)
		{
		Call ( JET_errCallbackNotResolved );
		}

	if ( !FAquireBackupRestoreRights() )
		{
		Call ( JET_errReturnedForESEBCLI2 ); 
		}

	nSize = sizeof(szComputerName);		
	if ( !GetComputerName ( szComputerName, &nSize ) )
		{
		Call ( JET_errNTSystemCallFailed );
		}
	
	wszRestorePath = WszFromSz( szFullRestorePath );
	wszComputerName = WszFromSz( szComputerName );

	if ( !wszRestorePath || !wszComputerName )
		{
		Call ( JET_errOutOfMemory );
		}
		
	printf( "Restore log files: %s\n", szFullRestorePath );

	assert ( pfnErrESERestoreReopen );
	CallHr ( (*pfnErrESERestoreReopen)( 	wszComputerName,
											NULL,
											wszRestorePath,
											&hccxRestoreContext ) );
	
	if ( szTargetInstance )
		{
		if ( szTargetInstance[0] == '\0' )
			{
			// no play forward 
			wszTargetInstance = NULL;
			}
		else
			{
			wszTargetInstance = WszFromSz( szTargetInstance );
			if ( !wszTargetInstance )
				{
				Call ( JET_errOutOfMemory );
				}
			}
		}
	else
		{
		// get the instance form the Restore.Env, as the Source Instance Name
		assert ( pfnHrESERestoreGetEnv );
		CallHr ( (*pfnHrESERestoreGetEnv)( 	hccxRestoreContext,
											&pREnv ) );

		// dump Restore.Env
		assert ( pREnv );
		assert ( pREnv->m_wszSrcInstanceName );
		wszTargetInstance = WszCopy( pREnv->m_wszSrcInstanceName );

		assert ( pfnESERestoreFreeEnv );
		(*pfnESERestoreFreeEnv)( pREnv );
		pREnv = NULL;

		if ( !wszTargetInstance )
			{
			Call ( JET_errOutOfMemory );
			}
		}
		
	wprintf( L"  Target Instance: %s\n", wszTargetInstance?wszTargetInstance:L"" );
	
	assert ( pfnErrESERestoreComplete );
	CallHr ( (*pfnErrESERestoreComplete)( 	hccxRestoreContext,
									wszRestorePath,
									wszRestorePath,
									wszTargetInstance,
									fKeepLogs?ESE_RESTORE_KEEP_LOG_FILES:0 // no db mount, wait restore complete
									) );	
									
HandleError:

	LocalFree ( wszRestorePath );
	LocalFree ( wszTargetInstance );
	LocalFree ( wszComputerName );

	if ( pREnv )
		{
		assert ( pfnESERestoreFreeEnv );
		(*pfnESERestoreFreeEnv)( pREnv );
		pREnv = NULL;
		}

	if ( hccxRestoreContext )
		{
		assert ( pfnErrESERestoreClose );
		(void) (*pfnErrESERestoreClose)( hccxRestoreContext, (hrNone == hr) ? RESTORE_CLOSE_NORMAL:RESTORE_CLOSE_ABORT );
		hccxRestoreContext = NULL;
		}

	if ( hrNone != hr )
		{
		assert ( hESEBCLI2 );
		PrintESEBCLI2Error ( hr, hrGLE, hESEBCLI2 );
		err = JET_errReturnedForESEBCLI2;
		}
	
	if ( NULL != hESEBCLI2 )
		{
		FreeLibrary( hESEBCLI2 );
		hESEBCLI2 = NULL;
		}

	return err;
	}

#ifdef RESTORE_SERVER_SIMULATION

// must match the definition from ESEBACK2\srvsim.cxx
typedef HRESULT (__stdcall * PfnServerSim)( const char * szFileDef );

LOCAL JET_ERR ErrDBUTLServerSim( const char * szSimulationDef )
	{
	JET_ERR			err 			= JET_errSuccess;
	HRESULT 		hr 				= hrNone;
	HRESULT 		hrGLE;
	HMODULE 		hESEBACK2 		= NULL;
	PfnServerSim 	pfnServerSim 	= NULL;

	if ( !FDBUTLLoadLibrary( ESEBACK2_DLL_NAME, &hESEBACK2 ) )
		{
		Call ( JET_errCallbackNotResolved );
		}

	pfnServerSim = (PfnServerSim) GetProcAddress( hESEBACK2, "ServerSim" );
	if ( !pfnServerSim )
		{
		Call ( JET_errCallbackNotResolved );
		}

	CallHr ( (*pfnServerSim)( szSimulationDef ) );
	
HandleError:

	if ( hrNone != hr )
		{
		assert ( hESEBACK2 );
		PrintESEBCLI2Error ( hr, hrGLE, hESEBACK2 );
		err = JET_errReturnedForESEBACK2;
		}

	if ( NULL != hESEBACK2 )
		{
		FreeLibrary( hESEBACK2 );
		hESEBACK2 = NULL;
		}

	return err;
	
	}

#endif // RESTORE_SERVER_SIMULATION

/*
typedef struct {
	JET_COLUMNID		columnid;
	void 				*pvData;
	unsigned long 		cbData;
	unsigned long 		cbActual;
	JET_GRBIT			grbit;
	unsigned long		ibLongValue;
	unsigned long		itagSequence;
	JET_COLUMNID		columnidNextTagged;
	JET_ERR				err;
} JET_RETRIEVECOLUMN;
*/

struct DUMPCOLUMN
	{
	JET_COLUMNID 	columnid;
	JET_COLTYP		coltyp;
	int				cbMax;
	int				cchPrint;
	char  			szColumnName[JET_cbNameMost+1];
	};


//  ================================================================
LOCAL int CchPrintForColtyp( IN const JET_COLTYP coltyp, IN const int cchColumnName, IN const int cbMax )
//  ================================================================
	{
	int cchPrint = 0;

	switch( coltyp )
		{
		case JET_coltypBit:
			cchPrint = 1; // 0 => 1
			break;
		case JET_coltypUnsignedByte:
			cchPrint = 2; // 00 => ff
			break;
		case JET_coltypShort:
			cchPrint = 6; // -32768 => 32767
			break;
		case JET_coltypLong:
			cchPrint = 10; // -2147483649 => 2147483648
			break;
		case JET_coltypCurrency:
			cchPrint = 20;
			break;
		case JET_coltypIEEESingle:
			cchPrint = 10;
			break;
		case JET_coltypIEEEDouble:
			cchPrint = 10;
			break;
		case JET_coltypDateTime:
			cchPrint = 16;
			break;
		case JET_coltypBinary:
		case JET_coltypText:
		case JET_coltypLongBinary:
		case JET_coltypLongText:
		case JET_coltypSLV:
			cchPrint = min( cbMax, 32 );
			break;
		default:
			assert( 0 );
			cchPrint = 16;
			break;
		}

	cchPrint = max( cchPrint, cchColumnName );
	cchPrint = min( 32, cchPrint );
	
	return cchPrint;
	}


//  ================================================================
LOCAL void PrintColumn( IN const JET_COLTYP coltyp, IN const int cchMax, IN const void * const pv, IN const int cb )
//  ================================================================
	{
	switch( coltyp )
		{
		case JET_coltypBit:
			{
			const BYTE b = *((BYTE *)pv);
			printf( "%c", b ? '1' : '0' );
			break;
			}
		case JET_coltypUnsignedByte:
			{
			const BYTE b = *((BYTE *)pv);
			printf( "%2.2x", b );
			break;
			}
		case JET_coltypShort:
			{
			const short s = *((short *)pv);
			printf( "% *.*d", cchMax-1, cchMax-1, s );
			break;
			}
		case JET_coltypLong:
			{
			const long l = *((long *)pv);
			printf( "% *.*d", cchMax-1, cchMax-1, l );
			break;
			}
		case JET_coltypCurrency:
			{
			const __int64 q = *((__int64 *)pv);
			printf( "% *.*I64d", cchMax-1, cchMax-1, q );
			break;
			}
		case JET_coltypIEEESingle:
			{
			const float f = *((float *)pv);
			printf( "% *.4g", cchMax - 6, f );	//	precision = 4, decimal = 1, minus = 1
			break;
			}
		case JET_coltypIEEEDouble:
			{
			const double d = *((double *)pv);
			printf( "% *.4g", cchMax - 6, d ); //	precision = 4, decimal = 1, minus = 1
			break;
			}
		case JET_coltypText:
		case JET_coltypLongText:
			{
			const char * const sz = (char *)pv;
			const int cch = min( cchMax, cb );
			printf( "%-*.*s", cch, cch, sz );
			break;
			}

		default:
			assert( 0 );	//	missed case			
		case JET_coltypDateTime:
		case JET_coltypBinary:
		case JET_coltypLongBinary:
		case JET_coltypSLV:
			{
			const BYTE * pb = (BYTE *)pv;
			const int cchMaxT = min( cchMax, cb * 2 );
			for( int cch = 0; cch < cchMaxT; )
				{
				cch += printf( "%2.2X", *pb );
				++pb;
				}
			while( cch < cchMax )
				{
				cch += printf( " " );
				}
			break;
			}
		}
	}


//  ================================================================
LOCAL JET_ERR ErrDumpcolumnFromColumnlist(
	IN const JET_SESID			sesid,
	IN const JET_COLUMNLIST&	columnlist,
	OUT DUMPCOLUMN * const		rgdumpcolumn,
	IN const unsigned long		cdumpcolumnMax,
	OUT unsigned long&			cdumpcolumn )
//  ================================================================
	{
	JET_ERR err		= JET_errSuccess;
	const JET_TABLEID tableid = columnlist.tableid;

	cdumpcolumn	= 0;
	
	//	need to know the name, columnid, coltyp, cbMax

	enum {
		iretcolName = 0,
		iretcolColumnid,
		iretcolColtyp,
		iretcolCbMax,
		cretcol 
		};
	
	JET_RETRIEVECOLUMN	rgretrievecolumn[cretcol];
	
	for( int iretcol = 0; iretcol < cretcol; ++iretcol )
		{
		rgretrievecolumn[iretcol].grbit 				= 0;
		rgretrievecolumn[iretcol].ibLongValue 			= 0;
		rgretrievecolumn[iretcol].itagSequence 			= 1;
		rgretrievecolumn[iretcol].columnidNextTagged 	= 0;
		rgretrievecolumn[iretcol].err 					= JET_errSuccess;
		}

	rgretrievecolumn[iretcolName].columnid 		= columnlist.columnidcolumnname;
	rgretrievecolumn[iretcolName].cbData 		= sizeof( rgdumpcolumn[0].szColumnName );
	rgretrievecolumn[iretcolColumnid].columnid 	= columnlist.columnidcolumnid;
	rgretrievecolumn[iretcolColumnid].cbData 	= sizeof( rgdumpcolumn[0].columnid );
	rgretrievecolumn[iretcolColtyp].columnid 	= columnlist.columnidcoltyp;
	rgretrievecolumn[iretcolColtyp].cbData 		= sizeof( rgdumpcolumn[0].coltyp );
	rgretrievecolumn[iretcolCbMax].columnid 	= columnlist.columnidcbMax;
	rgretrievecolumn[iretcolCbMax].cbData	 	= sizeof( rgdumpcolumn[0].cbMax );

	Call( JetMove( sesid, tableid, JET_MoveFirst, 0 ) );

	//	there are three ways to leave this loop
	//		- an error from a Jet call
	//		- getting JET_errNoCurrentRecord from JetMove( MoveNext )
	//		- retrieving the maximum number of columns allowed
	
	while( 1 )
		{
		if( cdumpcolumn >= cdumpcolumnMax )
			{
			//	we have hit the maximum number of columns to dump
			break;
			}

		rgretrievecolumn[iretcolName].pvData		= (void *)(rgdumpcolumn[cdumpcolumn].szColumnName);
		rgretrievecolumn[iretcolColumnid].pvData	= (void *)(&(rgdumpcolumn[cdumpcolumn].columnid));
		rgretrievecolumn[iretcolColtyp].pvData		= (void *)(&(rgdumpcolumn[cdumpcolumn].coltyp));
		rgretrievecolumn[iretcolCbMax].pvData		= (void *)(&(rgdumpcolumn[cdumpcolumn].cbMax));

		Call( JetRetrieveColumns( sesid, tableid, rgretrievecolumn, cretcol ) );

		rgdumpcolumn[cdumpcolumn].cchPrint 			= CchPrintForColtyp(
															rgdumpcolumn[cdumpcolumn].coltyp,
															strlen( rgdumpcolumn[cdumpcolumn].szColumnName ),
															rgdumpcolumn[cdumpcolumn].cbMax );
		
		++cdumpcolumn;

		err = JetMove( sesid, tableid, JET_MoveNext, 0 );
		if( JET_errNoCurrentRecord == err )
			{
			assert( columnlist.cRecord == cdumpcolumn );
			//	we have hit the end of the table
			err = JET_errSuccess;
			break;
			}
		Call( err );

		assert( cdumpcolumn <= columnlist.cRecord );	
		}
	
HandleError:
	return err;
	}


//  ================================================================
LOCAL void DBUTLDumpTableRecordsHeader( 
	IN const DUMPCOLUMN * const	rgdumpcolumn,
	IN const int ccolumns )
//  ================================================================
//
//	Print the name of each column, followed by a space
//	Keep track of the number of characters and print a line of '-'s
//
//-
	{
	int icolumn;
	int ich;
	int cchTotal = 0;

	for( icolumn = 0; icolumn < ccolumns; ++icolumn )
		{
		const int cchPrint = rgdumpcolumn[icolumn].cchPrint;
		cchTotal += printf( "%-*.*s ", cchPrint, cchPrint, rgdumpcolumn[icolumn].szColumnName );
		}
	printf( "%c", cNewLine );

	for( ich = 0; ich < cchTotal; ++ich )
		{
		printf( "-" );
		}
	printf( "%c", cNewLine );	
	}


//  ================================================================
LOCAL VOID EDBUTLPrintOneTableRecord( 
	IN const DUMPCOLUMN * const		rgdumpcolumn,
	IN JET_RETRIEVECOLUMN * const	rgretcol,
	IN const int					ccolumns )
//  ================================================================
	{
	int icolumn;
	for( icolumn = 0; icolumn < ccolumns; ++icolumn )
		{
		const JET_COLTYP coltyp = rgdumpcolumn[icolumn].coltyp;
		const int cchMax		= rgdumpcolumn[icolumn].cchPrint;
		const void * const pv	= rgretcol[icolumn].pvData;
		const int cb			= rgretcol[icolumn].cbActual;
		
		PrintColumn( coltyp, cchMax, pv, cb );
		printf( " " );
		}
	printf( "%c", cNewLine );
	}


//  ================================================================
LOCAL JET_ERR ErrEDBUTLDumpOneTableRecord( 
	IN const JET_SESID				sesid,
	IN const JET_TABLEID			tableid,
	IN const DUMPCOLUMN * const		rgdumpcolumn,
	IN JET_RETRIEVECOLUMN * const	rgretcol,
	IN const int					ccolumns )
//  ================================================================
	{
	JET_ERR					err 		= JET_errSuccess;

	Call( JetRetrieveColumns( sesid, tableid, rgretcol, ccolumns ) );
 	EDBUTLPrintOneTableRecord( rgdumpcolumn, rgretcol, ccolumns );

HandleError:
	return err;
	}


//  ================================================================
LOCAL JET_ERR ErrEDBUTLDumpTableRecords( 
	IN const JET_SESID			sesid,
	IN const JET_TABLEID		tableid,
	IN const DUMPCOLUMN * const	rgdumpcolumn,
	IN const int				ccolumns,
	IN const int 				crecordsMax )
//  ================================================================
	{
	JET_ERR					err 		= JET_errSuccess;
	JET_RETRIEVECOLUMN 	*	rgretcol	= NULL;
	BYTE				*	pb			= NULL;
	int						iretcol;
	const int				cbPerColumn	= 256;
	int						crecordsDumped;

	DBUTLDumpTableRecordsHeader( rgdumpcolumn, ccolumns );

	pb 			= new BYTE[ccolumns*cbPerColumn];
	rgretcol 	= new JET_RETRIEVECOLUMN[ccolumns];
	if( NULL == rgretcol || NULL == pb )
		{
		Call( JET_errOutOfMemory );
		}

	for( iretcol = 0; iretcol < ccolumns; ++iretcol )
		{
		rgretcol[iretcol].columnid 		= rgdumpcolumn[iretcol].columnid;
		rgretcol[iretcol].pvData		= pb + (iretcol * cbPerColumn );
		rgretcol[iretcol].cbData		= cbPerColumn;
		rgretcol[iretcol].grbit			= 0;
		rgretcol[iretcol].ibLongValue	= 0;
		rgretcol[iretcol].itagSequence	= 1;
		}

	for( err = JetMove( sesid, tableid, JET_MoveFirst, 0 ), crecordsDumped = 0;
		 err >= JET_errSuccess && ( crecordsDumped < crecordsMax );
		 err = JetMove( sesid, tableid, JET_MoveNext, 0 ), ++crecordsDumped )
	 	{
	 	Call( ErrEDBUTLDumpOneTableRecord( sesid, tableid, rgdumpcolumn, rgretcol, ccolumns ) );
	 	}

	if( JET_errNoCurrentRecord == err )
		{
		err = JET_errSuccess;
		}
	
HandleError:	
	if( NULL != pb )
		{
		delete [] pb;
		}
	if( rgretcol )
		{
		delete [] rgretcol;
		}
	
	return err;
	}


//  ================================================================
LOCAL JET_ERR ErrEDBUTLDumpTable( 
	IN const JET_INSTANCE 	instance,
	IN const JET_SESID		sesid,
	IN const JET_DBID		dbid,
	IN const char * const	szTable,
	IN const int 			crecordsMax )
//  ================================================================
	{
	JET_ERR			err 		= JET_errSuccess;
	JET_TABLEID		tableid		= JET_tableidNil;
	JET_COLUMNLIST	columnlist;

	int 					ccolumns		= 0;
	DUMPCOLUMN			*	rgdumpcolumn	= NULL;

	columnlist.cbStruct = sizeof( columnlist );
	columnlist.tableid	= JET_tableidNil;

	Call( JetOpenTable( sesid, dbid, szTable, NULL, 0, JET_bitTableReadOnly, &tableid ) );

	Call( JetGetTableColumnInfo(
			sesid,
			tableid,
			NULL,
			&columnlist,
			sizeof( columnlist ),
			JET_ColInfoList ) );

	ccolumns = columnlist.cRecord;
	rgdumpcolumn = new DUMPCOLUMN[ccolumns];

	if( NULL == rgdumpcolumn )
		{
		Call( JET_errOutOfMemory );
		}

	unsigned long ccolumnsT;
	Call( ErrDumpcolumnFromColumnlist(
			sesid,
			columnlist,
			rgdumpcolumn,
			ccolumns,
			ccolumnsT ) );
	assert( ccolumnsT == ccolumns );

	Call( ErrEDBUTLDumpTableRecords( 
			sesid,
			tableid,
			rgdumpcolumn,
			ccolumns,
			crecordsMax ) );
	
HandleError:
	if( rgdumpcolumn )
		{
		delete [] rgdumpcolumn;
		}
	if( JET_tableidNil != columnlist.tableid )
		{
		(void)JetCloseTable( sesid, columnlist.tableid );
		}
	if( JET_tableidNil != tableid )
		{
		(void)JetCloseTable( sesid, tableid );
		}
	return err;
	}


//  ================================================================
LOCAL JET_ERR ErrEDBUTLDumpUnicodeFixupTable( IN const CHAR * const szDB, IN const CHAR * const szSLV )
//  ================================================================
	{	
	JET_ERR			err 		= JET_errSuccess;
	JET_INSTANCE	instance 	= JET_instanceNil;
	JET_SESID		sesid 		= JET_sesidNil;
	JET_DBID		dbid 		= JET_dbidNil;

	Call( JetSetSystemParameter( &instance, 0, JET_paramMaxTemporaryTables, 16, NULL ) );
	Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexChecking, 0, NULL ) );
	Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexCleanup, 0, NULL ) );

	Call( JetInit( &instance ) );
	Call( JetBeginSession( instance, &sesid, NULL, NULL ) );
	Call( JetAttachDatabaseWithStreaming( sesid, szDB, szSLV, NULL, 0, JET_bitDbReadOnly ) );
	Call( JetOpenDatabase( sesid, szDB, NULL, &dbid, JET_bitDbReadOnly ) );

	Call( ErrEDBUTLDumpTable( instance, sesid, dbid, "MSysUnicodeFixupVer1", 0x7fffffff ) );
	
HandleError:
	if( JET_dbidNil != dbid )
		{
		(void)JetCloseDatabase( sesid, dbid, 0 );
		}
	if( JET_sesidNil != sesid )
		{
		(void)JetEndSession( sesid, 0 );
		}
	if( JET_instanceNil != instance )
		{
		(void)JetTerm( instance );
		}
	return err;
	}


int _cdecl main( int argc, char *argv[] )
	{
	JET_INSTANCE	instance			= 0;
	JET_SESID		sesid				= JET_sesidNil;
	JET_ERR			err					= JET_errSuccess;
	JET_ERR			errRepaired			= JET_errSuccess;
	BOOL			fResult				= fTrue;
	UTILOPTS		opts;
	JET_CONVERT		convert;
	JET_DBUTIL		dbutil;
	ULONG			timer				= GetTickCount();
	INT				iSec, iMSec;
	BOOL			fWhitespaceOnErr	= fFalse;
	BOOL			fUnknownError		= fFalse;

	InitArg( argc, argv );
	memset( &opts, 0, sizeof(UTILOPTS) );
	opts.lDirtyLevel = 2;
	memset( &dbutil, 0, sizeof(JET_DBUTIL) );
	dbutil.cbStruct	= sizeof( dbutil );
	
	printf( "%c", cNewLine );

	const INT pid = GetCurrentProcessId();
	
	if ( GetArgCount() < 2 )
		{
		printf( "%s%c%c", szUsageErr9, cNewLine, cNewLine );
		goto Usage;
		}

	SetCurArgID(1);
	assert( GetCurArgID() == 1 );
	if ( strchr( szSwitches, GetCurArg()[0] ) == NULL )
		{
		printf( "%s%c%c", szUsageErr10, cNewLine, cNewLine );
		goto Usage;
		}

	sprintf( szDefaultTempDB, szDefaultTempDBFormat, pid );
	sprintf( szDefaultDefragDB, szDefaultDefragDBFormat, pid );
	sprintf( szDefaultUpgradeDB, szDefaultUpgradeDBFormat, pid );
	sprintf( szDefaultRepairDB, szDefaultRepairDBFormat, pid );
	sprintf( szDefaultIntegDB, szDefaultIntegDBFormat, pid );
	sprintf( szDefaultScrubDB, szDefaultScrubDBFormat, pid );

	assert( NULL == opts.pv );

	switch( GetCurArg()[1] )
		{
		case 'd':		// Defragment
		case 'D':
			opts.mode	= modeDefragment;
			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseDefragment );
			break;

		case 'r':		// Recovery
		case 'R':
			opts.mode = modeRecovery;
			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseRecovery );
			break;

		case 'g':		// inteGrity
		case 'G':
			opts.mode = modeIntegrity;
			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseIntegrity );
			break;

		case 'k':		// esefile - checksum
		case 'K':
			opts.mode = modeChecksum;
			fResult = FEDBUTLParseOptions( &opts, NULL );
			break;

		case 'p':		// rePair
		case 'P':
			opts.mode 	= modeRepair;
			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseRepair );
			break;

		case 'm':		// file duMp.
		case 'M':
			opts.mode = modeDump;
			opts.pv = &dbutil;

			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseDump );
			break;

#ifdef DEBUG
		case 'c':		// Hard Recovery (dump Restore.Env or/and RestoreComplete)
		case 'C':
			opts.mode = modeHardRecovery;
			opts.pv = &dbutil;

			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseHardRecovery );
			break;

		case 'b':		// Backup
		case 'B':
			opts.mode = modeBackup;
			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseBackup );
			break;

		case 's':
		case 'S':
			opts.mode 	= modeSLVMove;
			opts.pv 	= &dbutil;

			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseSLVMove );
			// db name and pgno are mandatory
			if ( NULL == opts.szSourceDB || 0 == dbutil.pgno )
				{
				fResult = fFalse;
				}
			dbutil.op = opDBUTILSLVMove;
			break;
#endif

#ifdef RECORD_FORMAT_UPGRADE
		case 'f':		// upgrade record Format
		case 'F':
			opts.mode 	= modeUpgradeRecordFormat;
			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseUpgradeRecordFormat );
			break;
#endif			

		case 'u':		// Upgrade/convert
		case 'U':
			opts.mode = modeUpgrade;
			memset( &convert, 0, sizeof(JET_CONVERT) );
			opts.pv = &convert;
			UTILOPTSSetDefragSLVDontCopy( opts.fUTILOPTSFlags );
			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseUpgrade );
			if ( fResult  &&  convert.szOldDll == NULL )
				{
				printf( "%s%c%c", szUsageErr11, cNewLine, cNewLine );
				fResult = fFalse;					
				}				
			break;		

		case 'z':		// Zero out deleted portions of the database
		case 'Z':
			opts.mode 	= modeScrub;
			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseScrub );
			break;

		case '?':
			goto Usage;			

#ifdef ESENT
#else
		case 'e':
		case 'E':
			if( !_strcmpi( argv[1]+1, "ese" ) )
				{
				opts.mode = modeSplash;
				break;
				}
#endif				

			//  else FALLTHRU
		default:
			printf( "%s%c%c", szUsageErr12, cNewLine, cNewLine );
			fResult = fFalse;
		}
		
	if ( !fResult )
		goto Usage;


	if( modeUpgrade == opts.mode ) 
		{
		Call( ErrUseDifferentDLL( _T( "ESENT97.DLL" ) ) );
		}

	Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "ESEUTIL" ) );

	//	generate a new temporary database name
	//	this may be overwritten later
	
	Call( JetSetSystemParameter( &instance, 0, JET_paramTempPath, 0, szDefaultTempDB ) );
	
	if ( !FUTILOPTSSuppressLogo( opts.fUTILOPTSFlags ) )
		{
		EDBUTLPrintLogo();
		}

	if ( FUTILOPTS8KPage( opts.fUTILOPTSFlags ) )
		{
		Call( JetSetSystemParameter( &instance, 0, JET_paramDatabasePageSize, 8192, NULL ) );
		}

	// Lights, cameras, action...
	timer = GetTickCount();

	switch ( opts.mode )
		{
		case modeRecovery:
			if ( NULL == opts.szBase )
				{
				printf( szUsageErr1, "logfile base name" );
				printf( "%c%c", cNewLine, cNewLine );
				Call( JET_errInvalidParameter );
				}

			printf( "Initiating RECOVERY mode...%c", cNewLine );
			printf( "    Logfile base name: %s%c", opts.szBase, cNewLine );

			if( 0 != opts.pageTempDBMin )
				{
				printf( "   Temp database size: %d%c", opts.pageTempDBMin, cNewLine );
				Call( JetSetSystemParameter( &instance, 0, JET_paramPageTempDBMin , opts.pageTempDBMin, NULL ) );
				}
			
			printf( "            Log files: %s%c", opts.szLogfilePath ? opts.szLogfilePath : "<current directory>", cNewLine );
			printf( "         System files: %s%c", opts.szSystemPath ? opts.szSystemPath : "<current directory>", cNewLine );

			if ( NULL != opts.szSourceDB )
				{
				printf( "   Database Directory: %s%c", opts.szSourceDB != szCurrDir ? opts.szSourceDB : "<current directory>", cNewLine );
				Call( JetSetSystemParameter( &instance, 0, JET_paramAlternateDatabaseRecoveryPath, 0, opts.szSourceDB ) );
				}

			Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "on" ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramCacheSizeMax, 500, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTables, 10000, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxCursors, 10000, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxSessions, 16, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxVerPages, 128, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxTemporaryTables, 10000, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramLogBuffers, 41, NULL ) );
			printf( "%c", cNewLine );

			// Set user overrides.
			Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

			if ( opts.szBackup == NULL )
				{
				
				// Soft recovery.
				fWhitespaceOnErr = fTrue;
				printf( "Performing soft recovery..." );
				err = JetInit2( &instance, opts.grbitInit );
				Call( ErrEDBUTLCleanup( instance, 0, err ) );
				printf( "%c%c", cNewLine, cNewLine );
				}
			else
				{

				// Hard recovery.

				if ( opts.szRestore )
					{
					printf( "Restoring to '%s' from '%s'...", opts.szRestore, opts.szBackup );
					}
				else
					{
					printf( "Restoring to <current directory> from '%s'...", opts.szBackup );
					}
				err = JetRestore2( opts.szBackup, opts.szRestore, PrintStatus );
				printf( "%c%c", cNewLine, cNewLine );
				Call( err );
				}
			break;
	
#ifdef DEBUG
		case modeBackup:

			Call( ErrEDBUTLCheckBackupPath( &opts ) );
			printf( "Initiating BACKUP mode...%c", cNewLine );
			printf( "       Log files: %s%c", opts.szLogfilePath ? opts.szLogfilePath : "<current directory>", cNewLine );
			printf( "    System files: %s%c%c", opts.szSystemPath ? opts.szSystemPath : "<current directory>", cNewLine, cNewLine );

			Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "on" ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramCacheSizeMax, 500, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTables, 10000, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxCursors, 10000, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxSessions, 16, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxVerPages, 128, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxTemporaryTables, 10000, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramLogBuffers, 41, NULL ) );

			// Set user overrides.
			Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

			fWhitespaceOnErr = fTrue;
			if ( FUTILOPTSIncrBackup( opts.fUTILOPTSFlags ) )
				{
				printf( "Performing incremental backup..." );
				Call( JetInit( &instance ) );
				CallJ( JetBackup( opts.szBackup, JET_bitBackupIncremental | JET_bitBackupAtomic, NULL ), Cleanup );
				}
			else
				{
				printf( "Performing full backup..." );
				Call( JetInit( &instance ) );
				CallJ( JetBackup( opts.szBackup, JET_bitBackupAtomic, NULL ), Cleanup );
				}
			fWhitespaceOnErr = fFalse;

			printf( "%c%c", cNewLine, cNewLine );
			Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );
			break;
#endif

		case modeDefragment:
				{
				JET_GRBIT	grbitDefrag = 0;
				if( FUTILOPTSDefragInfo( opts.fUTILOPTSFlags ) )
					grbitDefrag |= JET_bitCompactStats;
				if( FUTILOPTSDefragRepair( opts.fUTILOPTSFlags ) )
					grbitDefrag |= JET_bitCompactRepair;
				if ( !FUTILOPTSDefragSLVDontCopy( opts.fUTILOPTSFlags ) )
					grbitDefrag |= JET_bitCompactSLVCopy;
				
				CallJ( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultDefragDB, szSourceStreamFileName, szTempStreamFileName ), Cleanup );

				//	there is no streaming file attached to database
				if ( NULL == opts.szSourceSLV )
					{
					UTILOPTSSetDefragSLVDontCopy( opts.fUTILOPTSFlags );
					grbitDefrag &= ~JET_bitCompactSLVCopy;
					}
				
				printf( "Initiating DEFRAGMENTATION mode...%c", cNewLine );
				printf( "            Database: %s%c", opts.szSourceDB, cNewLine );
				if( opts.szSourceSLV )
					{
					printf( "      Streaming File: %s%c", opts.szSourceSLV, cNewLine );
					}
				printf( "      Temp. Database: %s%c", opts.szTempDB, cNewLine );
				if( opts.szTempSLV )
					{
					printf( "Temp. Streaming File: %s%c", opts.szTempSLV, cNewLine );
					}

				fWhitespaceOnErr = fTrue;

				// Restart with logging/recovery disabled.
				Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "off" ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableOnlineDefrag, 0, NULL ) );
				ULONG_PTR cbfCacheMax;
				Call( JetGetSystemParameter( instance, 0, JET_paramCacheSizeMax, &cbfCacheMax, NULL, 0 ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramStopFlushThreshold, 10 * cbfCacheMax / 100, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramStartFlushThreshold, 1 * cbfCacheMax / 100, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDbExtensionSize, 256, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableTempTableVersioning, fFalse, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexChecking, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexCleanup, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTables, 10000, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramPreferredMaxOpenTables, 10000, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxTemporaryTables, 10000, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDisableCallbacks, fTrue, NULL ) );

				// Set user overrides.
				Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

				Call( JetInit( &instance ) );
				CallJ( JetBeginSession( instance, &sesid, szUser, szPassword ), Cleanup );

				// Detach temporary database and delete file if present (ignore errors).
				EDBUTLDeleteTemp( &opts );

				dbutil.sesid		= sesid;
				dbutil.op			= opDBUTILDBDefragment;
				dbutil.szDatabase	= opts.szSourceDB;
				dbutil.szSLV 		= opts.szSourceSLV;
				dbutil.szTable		= opts.szTempDB;
				dbutil.szIndex		= opts.szTempSLV;
				dbutil.grbitOptions	= grbitDefrag;
				dbutil.pfnCallback	= PrintStatus;
				
				CallJ( JetDBUtilities( &dbutil ), Cleanup );
				
				Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );

				Call( ErrEDBUTLBackupAndInstateDB( sesid, &opts ) );

				printf( "%cNote:%c", cNewLine, cNewLine );
				printf( "  It is recommended that you immediately perform a full backup%c", cNewLine );
				printf( "  of this database. If you restore a backup made before the%c", cNewLine );
				printf( "  defragmentation, the database will be rolled back to the state%c", cNewLine );
				printf( "  it was in at the time of that backup.%c%c", cNewLine, cNewLine );
				}
			break;

		case modeRepair:
				{			
				if( !FUTILOPTSSuppressLogo( opts.fUTILOPTSFlags ) )
					{
					const int id = MessageBox(
								NULL,
								szRepairMessage,
								szRepairCaption,
								MB_ICONSTOP | MB_OKCANCEL );
					if ( IDCANCEL == id )
						{
						err = JET_errInvalidParameter;
						Call( err );
						}
					}

				Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultRepairDB, szSourceStreamFileName ) );

				printf( "Initiating REPAIR mode...%c", cNewLine );
				printf( "        Database: %s%c", opts.szSourceDB, cNewLine );
				if( opts.szSourceSLV )
					{
					printf( "  Streaming File: %s%c", opts.szSourceSLV, cNewLine );
					}
				printf( "  Temp. Database: %s%c", opts.szTempDB, cNewLine );

				fWhitespaceOnErr = fTrue;

				Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "repair_off" ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramTempPath, 0, opts.szTempDB ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableTempTableVersioning, fFalse, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableOnlineDefrag, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDbExtensionSize, 256, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexChecking, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexCleanup, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTables, 10000, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramPreferredMaxOpenTables, 10000, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDisableCallbacks, fTrue, NULL ) );
				//  create plenty of sessions for multi-threaded integrity/repair
				//  need to have plenty of pages to have that many sessions
				Call( JetSetSystemParameter( &instance, 0, JET_paramCacheSizeMin, 4096, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxSessions, 128, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxTemporaryTables, 10000, NULL ) );

				// Set user overrides.
				Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

				Call( JetInit( &instance ) );
				CallJ( JetBeginSession( instance, &sesid, szUser, szPassword ), Cleanup );
				
				JET_GRBIT grbit;
				grbit = 0;
				if( FUTILOPTSDontRepair( opts.fUTILOPTSFlags ) )
					{
					grbit |= JET_bitDBUtilOptionDontRepair;
					}
				if( FUTILOPTSDumpStats( opts.fUTILOPTSFlags ) )
					{
					grbit |= JET_bitDBUtilOptionStats;
					}

				CallJ( ErrEDBUTLRepair(
					sesid,
					opts.szSourceDB,
					opts.szSourceSLV,
					opts.szBackup,
					(char *)(opts.pv),
					opts.szIntegPrefix,
					PrintStatus,
					grbit ), Cleanup );

				errRepaired = err;
				
				Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );
				
				printf( "Note:%c", cNewLine );
				printf( "  It is recommended that you immediately perform a full backup%c", cNewLine );
				printf( "  of this database. If you restore a backup made before the%c", cNewLine );
				printf( "  repair, the database will be rolled back to the state%c", cNewLine );
				printf( "  it was in at the time of that backup.%c%c", cNewLine, cNewLine );
				}			
			break;
			
		case modeChecksum:
				{
				BOOL	fBadChecksumDetected	= fFalse;
				wchar_t	szFile[_MAX_PATH+1];	//	UNDONE: don't know if +1 is really needed, but add it to be safe

				Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultTempDB ) );

				if ( !MultiByteToWideChar(
						CP_ACP,
						0,
						opts.szSourceDB,
						-1,
						szFile,
						_MAX_PATH ) )
					{
					Call( JET_errUnicodeTranslationFail );
					}
					
				printf( "Initiating CHECKSUM mode...%c%c", cNewLine, cNewLine );

				if ( FChecksumFile( szFile, FUTILOPTS8KPage( opts.fUTILOPTSFlags ), &fBadChecksumDetected ) )
					{
					printf( "%c", cNewLine );
					if ( fBadChecksumDetected )
						{
						Call( JET_errDatabaseCorrupted );
						}
					err = JET_errSuccess;
					}
				else
					{
					fWhitespaceOnErr = fTrue;
					fUnknownError = fTrue;
					goto HandleError;
					}
				}			
			break;

		case modeSLVMove:
				{
				printf( "Initiating SLV Move mode...%c", cNewLine );
				printf( "        Database: %s%c", opts.szSourceDB, cNewLine );

				fWhitespaceOnErr = fTrue;

				Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "on" ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableOnlineDefrag, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexChecking, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexCleanup, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDisableCallbacks, fTrue, NULL ) );
				//  create enough sessions for multi-threadeding
				//  need to have plenty of pages to have that many sessions
				Call( JetSetSystemParameter( &instance, 0, JET_paramCacheSizeMin, 16 * 4, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxSessions, 16, NULL ) );
				ULONG_PTR cbfCacheMax;
				Call( JetGetSystemParameter( instance, 0, JET_paramCacheSizeMax, &cbfCacheMax, NULL, 0 ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramStopFlushThreshold, 30 * cbfCacheMax / 100, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramStartFlushThreshold, 20 * cbfCacheMax / 100, NULL ) );

				// Set user overrides.
				Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

				dbutil.szDatabase = opts.szSourceDB;
 
				Call( JetDBUtilities( &dbutil ) );
				printf( "%c", cNewLine );		
				}		
			break;

		case modeScrub:
				{			

				Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultScrubDB, szSourceStreamFileName ) );

				printf( "Initiating SECURE mode...%c", cNewLine );
				printf( "        Database: %s%c", opts.szSourceDB, cNewLine );
				if( opts.szSourceSLV )
					{
					printf( "  Streaming File: %s%c", opts.szSourceSLV, cNewLine );
					}

				fWhitespaceOnErr = fTrue;

				Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "scrub_off" ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableOnlineDefrag, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexChecking, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexCleanup, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDisableCallbacks, fTrue, NULL ) );
				//  create enough sessions for multi-threadeding
				//  need to have plenty of pages to have that many sessions
				Call( JetSetSystemParameter( &instance, 0, JET_paramCacheSizeMin, 16 * 4, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxSessions, 16, NULL ) );
				ULONG_PTR cbfCacheMax;
				Call( JetGetSystemParameter( instance, 0, JET_paramCacheSizeMax, &cbfCacheMax, NULL, 0 ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramStopFlushThreshold, 30 * cbfCacheMax / 100, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramStartFlushThreshold, 20 * cbfCacheMax / 100, NULL ) );

				// Set user overrides.
				Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

				Call( JetInit( &instance ) );
				CallJ( JetBeginSession( instance, &sesid, szUser, szPassword ), Cleanup );
									
				CallJ( ErrEDBUTLScrub(
					sesid,
					opts.szSourceDB,
					opts.szSourceSLV,
					PrintStatus,
					0 ), Cleanup );
				
				Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );

				printf( "Warning:%c", cNewLine );
				printf( "  You MUST delete the logfiles for this database%c%c", cNewLine, cNewLine );
				
				printf( "Note:%c", cNewLine );
				printf( "  It is recommended that you immediately perform a full backup%c", cNewLine );
				printf( "  of this database. If you restore a backup made before the%c", cNewLine );
				printf( "  repair, the database will be rolled back to the state%c", cNewLine );
				printf( "  it was in at the time of that backup.%c%c", cNewLine, cNewLine );				
				}			
			break;

#ifdef RECORD_FORMAT_UPGRADE
		case modeUpgradeRecordFormat:
				{
				Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultScrubDB ) );

				printf( "Initiating RECORD UPGRADE mode...%c", cNewLine );
				printf( "        Database: %s%c", opts.szSourceDB, cNewLine );
				printf( "     Dirty Level: %d%c", opts.lDirtyLevel, cNewLine );

				fWhitespaceOnErr = fTrue;

				Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "record_upgrade_off" ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableOnlineDefrag, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexChecking, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexCleanup, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDisableCallbacks, fTrue, NULL ) );
				//  create enough sessions for multi-threadeding
				//  need to have plenty of pages to have that many sessions
				Call( JetSetSystemParameter( &instance, 0, JET_paramCacheSizeMin, 16 * 4, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxSessions, 16, NULL ) );
				ULONG_PTR cbfCacheMax;
				Call( JetGetSystemParameter( instance, 0, JET_paramCacheSizeMax, &cbfCacheMax, NULL, 0 ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramStopFlushThreshold, 30 * cbfCacheMax / 100, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramStartFlushThreshold, 20 * cbfCacheMax / 100, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramRecordUpgradeDirtyLevel, opts.lDirtyLevel, NULL ) );

				// Set user overrides.
				
				Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

				Call( JetInit( &instance ) );
				CallJ( JetBeginSession( instance, &sesid, szUser, szPassword ), Cleanup );

				CallJ( ErrEDBUTLUpgradeRecordFormat(
					sesid,
					opts.szSourceDB,
					PrintStatus,
					0 ), Cleanup );
				
				Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );
				}			
			break;
#endif	//	RECORD_FORMAT_UPGRADE

		case modeIntegrity:
				{		
				Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultIntegDB, szSourceStreamFileName ) );

				printf( "Initiating INTEGRITY mode...%c", cNewLine );
				printf( "        Database: %s%c", opts.szSourceDB, cNewLine );
				if( opts.szSourceSLV )
					{
					printf( "  Streaming File: %s%c", opts.szSourceSLV, cNewLine );
					}
				printf( "  Temp. Database: %s%c", opts.szTempDB, cNewLine );
				if( NULL != opts.pv )
					{
					printf( "           Table: %s%c", (char *)opts.pv, cNewLine );
					}

				fWhitespaceOnErr = fTrue;

				Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "off" ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramTempPath, 0, opts.szTempDB ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableOnlineDefrag, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableTempTableVersioning, fFalse, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexChecking, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexCleanup, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTables, 10000, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramPreferredMaxOpenTables, 10000, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDisableCallbacks, fTrue, NULL ) );
				//  create plenty of sessions for multi-threaded integrity/repair
				//  need to have plenty of pages to have that many sessions
				Call( JetSetSystemParameter( &instance, 0, JET_paramCacheSizeMin, 128 * 4, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxSessions, 128, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxTemporaryTables, 10000, NULL ) );

				// Set user overrides.
				Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

				Call( JetInit( &instance ) );
				CallJ( JetBeginSession( instance, &sesid, szUser, szPassword ), Cleanup );
				
				JET_GRBIT grbit;
				grbit = JET_bitDBUtilOptionDontRepair;
				if( FUTILOPTSDumpStats( opts.fUTILOPTSFlags ) )
					{
					grbit |= JET_bitDBUtilOptionStats;
					}	
				if( FUTILOPTSDontBuildIndexes( opts.fUTILOPTSFlags ) )
					{
					grbit |= JET_bitDBUtilOptionDontBuildIndexes;
					}	
				assert( grbit & JET_bitDBUtilOptionDontRepair );

				CallJ( ErrEDBUTLRepair(
					sesid,
					opts.szSourceDB,
					opts.szSourceSLV,
					opts.szBackup,
					(char *)(opts.pv),
					opts.szIntegPrefix,
					PrintStatus,
					grbit ), Cleanup );
				
				Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );
				}
			break;

		case modeUpgrade:		
			Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultUpgradeDB ) );

			Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "off" ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramEnableOnlineDefrag, 0, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramDbExtensionSize, 256, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramEnableTempTableVersioning, fFalse, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTables, 10000, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramPreferredMaxOpenTables, 10000, NULL ) );

			fWhitespaceOnErr = fTrue;

			// Set user overrides.
			Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

			Call( JetInit( &instance ) );
			CallJ( JetBeginSession( instance, &sesid, szUser, szPassword ), Cleanup );

			// Detach temporary database and delete file if present (ignore errors).
			JetDetachDatabase( sesid, opts.szTempDB );
			DeleteFile( opts.szTempDB );

			assert( opts.pv == &convert );
			CallJ( JetCompact(
				sesid,
				opts.szSourceDB,
				FUTILOPTSInPlaceUpgrade( opts.fUTILOPTSFlags ) ? opts.szSourceDB : opts.szTempDB,
				PrintStatus,
				&convert,
				FUTILOPTSDefragInfo( opts.fUTILOPTSFlags ) ? JET_bitCompactStats : 0 ), Cleanup );

			Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );

			Call( ErrEDBUTLBackupAndInstateDB( sesid, &opts ) );
			
			break;

#ifdef ESENT
#else
		case modeSplash:
			EDBUTLSplash();
			break;
#endif			

		case modeHardRecovery:
			{
			char * 	szTargetInstance = opts.szRestore;
			char 	szFullRestorePath[_MAX_PATH + 1];

			// if missing, get current directory
			if ( _fullpath( szFullRestorePath, opts.szSourceDB?opts.szSourceDB:".", _MAX_PATH ) == NULL )
				{
				Call ( JET_errInvalidPath );
				}

			if ( FUTILOPTSServerSim ( opts.fUTILOPTSFlags ) )
				{
#ifdef RESTORE_SERVER_SIMULATION
				// if no definition file was provided, call with NULL and
				// it will print a sample of such a file
				Call ( ErrDBUTLServerSim( opts.szSourceDB?szFullRestorePath:NULL ) );
#else // RESTORE_SERVER_SIMULATION
				// FUTILOPTSServerSim() set only with RESTORE_SERVER_SIMULATION 
				// defined, check command line parsing above
				assert ( fFalse );
#endif // RESTORE_SERVER_SIMULATION
				}
			else if ( FUTILOPTSDumpRestoreEnv( opts.fUTILOPTSFlags ) )
				{
				Call ( ErrDBUTLDumpRestoreEnv(szFullRestorePath) );
				}
			else
				{
				Call ( ErrDBUTLRestoreComplete( szFullRestorePath, szTargetInstance, FUTILOPTSPreserveTempDB( opts.fUTILOPTSFlags ) ) );
				}
			}
			break;				

		case modeDump:
		default:
			{
			char	szBaseName[4];

			// Make the most innocuous operation the fall-through (to cover
			// ourselves in the unlikely event we messed up the modes).
			assert( opts.mode == modeDump );
			assert( opts.pv == &dbutil );

			if ( opts.mode == modeDump )
				{
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexChecking, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexCleanup, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDisableCallbacks, fTrue, NULL ) );

				if ( opts.szSourceDB == NULL )
					{
					printf( szUsageErr1, "database/filename" );			// Missing spec.
					printf( "%c%c", cNewLine, cNewLine );
					Call( JET_errInvalidParameter );
					}

				printf( "Initiating FILE DUMP mode...%c", cNewLine );

				switch( dbutil.op )	//lint !e644
					{
					case opDBUTILDumpLogfile:
						opts.szBase = szBaseName;
						EDBUTLGetBaseName( opts.szSourceDB, opts.szBase );
						break;
					case opDBUTILDumpLogfileTrackNode:
						printf( "      Log file: %s%c", opts.szSourceDB, cNewLine );
						printf( "          Node: %d:%d:%d%c", dbutil.dbid, dbutil.pgno, dbutil.iline, cNewLine );
						printf( "         Lgpos: %06X,%04X,%04X%c", dbutil.lGeneration, dbutil.isec, dbutil.ib, cNewLine );
						break;
					case opDBUTILDumpCheckpoint:
						printf( "      Checkpoint file: %s%c", opts.szSourceDB, cNewLine );
						break;
					case opDBUTILSetHeaderState:
						Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultTempDB ) );
						printf( "      Database %s will be forced to a consistent state.%c",
							opts.szSourceDB, cNewLine );
						break;

					case opDBUTILSLVMove:
					case opDBUTILDumpPage:
						Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultTempDB ) );
						printf( "      Database: %s%c", opts.szSourceDB, cNewLine );
						if ( NULL == dbutil.szIndex )
							{
							printf( "          Page: %d%c", dbutil.pgno, cNewLine );
							}
						else
							{
							//	non-NULL szTable means we'll be seeking down
							//	the btree searching for a specified key
							}
						break;
					case opDBUTILDumpNode:
						Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultTempDB ) );
						printf( "      Database: %s%c", opts.szSourceDB, cNewLine );
						printf( "          Node: %d:%d%c", dbutil.pgno, dbutil.iline, cNewLine );
						break;
					case opDBUTILDumpHeader:
					case opDBUTILDumpMetaData:
					case opDBUTILDumpSpace:
					case opDBUTILDumpData:
					case opDBUTILDumpExchangeSLVInfo:
						Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultTempDB ) );
						printf( "      Database: %s%c", opts.szSourceDB, cNewLine );
						if( opts.szSourceSLV )
							{
							printf( " Streaming File: %s%c", opts.szSourceSLV, cNewLine );
							}

						break;					

					case opDBUTILDumpUnicodeFixupTable:
						Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultTempDB ) );
						printf( "      Database: %s%c", opts.szSourceDB, cNewLine );
						if( opts.szSourceSLV )
							{
							printf( " Streaming File: %s%c", opts.szSourceSLV, cNewLine );
							}
						
						break;
						
					default:
						assert( 0 );
					}
				}

			printf( "%c", cNewLine );

			Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "off" ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramEnableOnlineDefrag, 0, NULL ) );

			//	set temp table size to be 0 so that no temp db will be created
			
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxTemporaryTables, 0, NULL ) );

			//	set user overrides.
			
			Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

			if( opDBUTILDumpUnicodeFixupTable == dbutil.op )
				{
				Call( ErrEDBUTLDumpUnicodeFixupTable( opts.szSourceDB, opts.szSourceSLV ) );
				}
			else
				{
				dbutil.szDatabase = opts.szSourceDB;
				dbutil.szSLV = opts.szSourceSLV;
				Call( JetDBUtilities( &dbutil ) );
				}
			
			printf( "%c", cNewLine );
			break;
			}
		}
		
	EDBUTLGetTime( timer, &iSec, &iMSec );

	if( JET_errSuccess != errRepaired ) //db is repaired
		{
		ULONG_PTR	ulWarn		= errRepaired;
		CHAR		szWarn[512];
		szWarn[0] = 0;
		(void)JetGetSystemParameter(
			instance,
			JET_sesidNil,
			JET_paramErrorToString,
			(ULONG_PTR *)&ulWarn,
			szWarn,
			sizeof( szWarn ) );
		if ( fWhitespaceOnErr )
			printf( "%c%c", cNewLine, cNewLine );
		printf( szOperWarn, errRepaired, szWarn, iSec, iMSec );
		}	
	else // JET_errSuccess == err 
		{ 
		printf( szOperSuccess, iSec, iMSec );
		}
	printf( "%c%c", cNewLine, cNewLine );
	return 0;
	

Cleanup:
	ErrEDBUTLCleanup( instance, sesid, err );

HandleError:
	EDBUTLGetTime( timer, &iSec, &iMSec );

	if ( fWhitespaceOnErr )
		printf( "%c%c", cNewLine, cNewLine );

	if ( fUnknownError )
		{
		printf( szOperFailUnknownError, iSec, iMSec );
		}
	else
		{
		ULONG_PTR	ulErr		= err;
		CHAR		szError[512];

		assert( err < 0 );

		szError[0] = 0;
		(void)JetGetSystemParameter(
			instance,
			JET_sesidNil,
			JET_paramErrorToString,
			(ULONG_PTR *)&ulErr,
			szError,
			sizeof( szError ) );

		printf( szOperFailWithError, err, szError, iSec, iMSec );
		}	

	printf( "%c%c", cNewLine, cNewLine );
	return err;


Usage:
	SetCurArgID( 0 );
	assert( GetCurArgID() == 0 );
	EDBUTLHelp( _strupr( GetCurArg() ) );
	return -1;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\_esefile\status.cxx ===
#include "esefile.hxx"

static int iLastPercentage;

//  ================================================================
void PrintWindowsError( const wchar_t * const szMessage )
//  ================================================================
	{
	LPVOID lpMsgBuf = NULL;
	if( FormatMessage( 
		    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		    NULL,
		    GetLastError(),
		    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		    (LPTSTR) &lpMsgBuf,
		    0,
		    NULL ) )
		{
		(void)fwprintf( stderr, L"%ls%ls", szMessage, (wchar_t *)lpMsgBuf );
		}

	LocalFree( lpMsgBuf );
	}

void InitStatus( const wchar_t * const szOperation )
	{
	const SIZE_T	cbOper		= wcslen( szOperation );
	const SIZE_T	cbPadding	= ( 51 - cbOper ) / 2;

	wprintf( L"          %*ls\r\n\r\n", cbPadding+cbOper, szOperation );
	wprintf( L"          0    10   20   30   40   50   60   70   80   90  100\r\n" );
	wprintf( L"          |----|----|----|----|----|----|----|----|----|----|\r\n" );
	wprintf( L"          " );

	iLastPercentage = 0;
	}


void UpdateStatus( const int iPercentage )
	{
	int dPercentage = min( iPercentage, 100 ) - iLastPercentage;
	while ( dPercentage >= 2 )
		{
		wprintf( L"." );
		iLastPercentage += 2;
		dPercentage -= 2;
		}
	}


void TermStatus()
	{
	UpdateStatus( 100 );
	wprintf( L".\r\n" );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\atq.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1997           **/
/**********************************************************************/

/*
    atq.h

    This module contains async thread queue (atq) for async IO and thread
    pool sharing among various services.

    Brief Description of ATQ:
      For description, please see iis\spec\isatq.doc

*/

#ifndef _ATQ_H_
#define _ATQ_H_


#ifdef __cplusplus
extern "C" {
#endif


// Include Standard headers

# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>
# include <winsock2.h>
# include <mswsock.h>


#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif


/*++
  ATQ API Overview:

  Global per module:
     AtqInitialize()
     AtqTerminate()

     AtqGetInfo()
     AtqSetInfo()

  ATQ Endpoint functions:
     AtqCreateEndpoint()
        AtqStartEndpoint()
        AtqEndpointGetInfo()
        AtqEndpointSetInfo()
        AtqStopCloseEndpoint()
     AtqCloseCloseEndpoint()

     AtqStopAndCloseEndpoint()  <-- soon to be killed
  Per ATQ Context Functions:
     AtqAddAsyncHandle()  <-- for non AcceptEx() sockets

     AtqGetAcceptExAddrs()       <-- for AcceptEx() sockets

     AtqContextSetInfo()

     AtqCloseFileHandle()
     AtqCloseSocket()
     AtqFreeContext()

  Bandwidth Throttler Functions:
     AtqCreateBandwidthInfo()
     AtqFreeBandwidthInfo()
     AtqBandwidthSetInfo()
     AtqBandwidthGetInfo()

  IO Functions:

     AtqReadFile()
     AtqWriteFile()
     AtqReadSocket()
     AtqWriteSocket()
     AtqTransmitFile()
     AtqTransmitFileAndRecv()
     AtqSendAndRecv()

  Utility Functions:

     AtqCreateFileW()
     AtqOplockAcknowledge()
     AtqSpudInitialized()
     AtqReadDirChanges()
     AtqPostCompletionStatus()


--*/


/*----------------------------------------------------------
  Registry Parameters used by ATQ during AtqInitialize()
  ATQ loads some of the parameters from
  HKLM\System\CurrentControlSet\Services\InetInfo\Parameters

  Most of these parameters are for INTERNAL ANALYSIS and
   development/testing. Setup should not install values
   for the same. Setup can include values for items marked SETUP.
------------------------------------------------------------*/

// Names

#define ATQ_REG_PER_PROCESSOR_ATQ_THREADS TEXT("MaxPoolThreads")
#define ATQ_REG_POOL_THREAD_LIMIT         TEXT("PoolThreadLimit") // SETUP
#define ATQ_REG_PER_PROCESSOR_CONCURRENCY TEXT("MaxConcurrency")
#define ATQ_REG_THREAD_TIMEOUT            TEXT("ThreadTimeout")
#define ATQ_REG_USE_ACCEPTEX              TEXT("UseAcceptEx")
#define ATQ_REG_MIN_KB_SEC                TEXT("MinFileKbSec")    // SETUP
#define ATQ_REG_LISTEN_BACKLOG            TEXT("ListenBacklog")   // SETUP

// Default Values

#define ATQ_REG_DEF_PER_PROCESSOR_ATQ_THREADS         (4)
#define ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY         (0)
// special value of 0 means that system will determine this dynamically.

//
// thread limit settings
//

#define ATQ_REG_MIN_POOL_THREAD_LIMIT                 (64)
#define ATQ_REG_DEF_POOL_THREAD_LIMIT                 (128)
#define ATQ_REG_MAX_POOL_THREAD_LIMIT                 (256)

//
// How often to check for thread progress.
//
#define ATQ_THREAD_MONITOR_PERIOD                     (2*60) // 2 Minutes

//
// How many IO's a temp thread should handle before 
// exiting
//

#define ATQ_TEMP_THREAD_IO_COUNT                      (100)

//
// THREAD_TIMEOUTs are high to prevent async ios from being cancelled
//  when the thread goes away.
//

#define ATQ_REG_DEF_THREAD_TIMEOUT                    (12*60*60) // 12 hours
#define ATQ_REG_DEF_USE_ACCEPTEX                      (TRUE)
#define ATQ_REG_DEF_MIN_KB_SEC                        (1000)  // 1000 bytes
#define ATQ_REG_DEF_LISTEN_BACKLOG                    (25)

//
// fake xmit file buffer size
//

#define ATQ_REG_DEF_NONTF_BUFFER_SIZE                 (4096)


/*----------------------------------------------------------
  Global Functions of ATQ module
-----------------------------------------------------------*/

// Flags for AtqInitialize()
# define ATQ_INIT_SPUD_FLAG          (0x00000001)

BOOL
AtqInitialize(
    IN DWORD dwFlags
    );

BOOL
AtqTerminate(
    VOID
    );

/*
 *  Sets various context information in Atq Module for global modifications
 *
 *
 *  Bandwidth Throttle:   Sets the throttle level in Bytes/Second.
 *        If INFINITE, then it is assumed that
 *                      there is no throttle value (default)
 *
 *  Max Pool Threads: Sets the maximum number of pool threads Atq will allow
 *        to be created per processor
 *
 *  MaxConcurrency: tells how many threads to permit per processor
 *
 *  Thread Timeout: Indicates how long a thread should be kep alive
 *        waiting on GetQueuedCompletionStatus() before commiting suicide
 *        (in seconds)
 *
 *  Inc/Dec max pool threads: If a server will be doing extended processing
 *        in an ATQ pool thread, they should increase the max pool threads
 *        while the extended processing is occurring.  This prevents starvation
 *        of other requests
 *
 *  AtqMinKbSec: set the assumed minimum KB per second for AtqTransmitFile()
 *        This value is used in calculating the timeout for file transfer
 *        operation
 *
 */

typedef enum _ATQ_INFO {

    AtqBandwidthThrottle = 0,
    AtqExitThreadCallback,
    AtqMaxPoolThreads,    // per processor values
    AtqMaxConcurrency,    // per processor concurrency value
    AtqThreadTimeout,
    AtqUseAcceptEx,       // Use AcceptEx if available
    AtqIncMaxPoolThreads, // Up the max thread count
    AtqDecMaxPoolThreads, // Decrease the max thread count
    AtqMinKbSec,          // Minimum assumed transfer rate for AtqTransmitFile
    AtqBandwidthThrottleMaxBlocked,  // Max number of blocked requests
    AtqUpdatePerfCounterCallback,
    AtqMaxDGramSend       // Max bytes in a single datagram send

} ATQ_INFO;

//
// ATQ_THREAD_EXIT_CALLBACK
// Type of callback function to be called when an ATQ thread exits so
// that the user of ATQ may clen up thread specific data.
//

typedef
VOID
(*ATQ_THREAD_EXIT_CALLBACK) ( VOID );

//
// ATQ_PERF_UPDATE_CALLBACK
// Type of callback function to be called when ATQ needs to update
// PerfMon counters that do no reside within ATQ.
//

typedef
VOID
(*ATQ_UPDATE_PERF_CALLBACK) (
    IN DWORD            dwStat,
    IN DWORD            dwOperation,
    IN DWORD            dwChange
);


dllexp
DWORD_PTR
AtqSetInfo(
    IN ATQ_INFO atqInfo,
    IN DWORD_PTR Data
    );

dllexp
DWORD_PTR
AtqGetInfo(
    IN ATQ_INFO atqInfo
    );



typedef struct _ATQ_STATISTICS {

    DWORD  cAllowedRequests;
    DWORD  cBlockedRequests;
    DWORD  cRejectedRequests;
    DWORD  cCurrentBlockedRequests;
    DWORD  MeasuredBandwidth;

} ATQ_STATISTICS;


dllexp
BOOL AtqGetStatistics( IN OUT ATQ_STATISTICS * pAtqStats);

dllexp
BOOL AtqClearStatistics(VOID);




/*----------------------------------------------------------
  ATQ Endpoint functions
-----------------------------------------------------------*/

//
//  endpoint data
//

typedef enum _ATQ_ENDPOINT_INFO {

    EndpointInfoListenPort,
    EndpointInfoListenSocket,
    EndpointInfoAcceptExOutstanding,
    EndpointInfoConsumerType

}  ATQ_ENDPOINT_INFO;



//
//  ATQ_COMPLETION
//  This is the routine that is called upon IO completion (on
//  error or success).
//
//  Context is the context passed to AtqAddAsyncHandle
//  BytesWritten is the number of bytes written to the file or
//      bytes written to the client's buffer
//  CompletionStatus is the WinError completion code
//  lpOverLapped is the filled in overlap structure
//
//  If the timeout thread times out an IO request, the completion routine
//  will be called by the timeout thread with IOCompletion FALSE and
//  CompletionStatus == ERROR_SEM_TIMEOUT.  The IO request is *still*
//  outstanding in this instance.  Generally it will be completed when
//  the file handle is closed.
//

typedef
VOID
(*ATQ_COMPLETION)(
            IN PVOID        Context,
            IN DWORD        BytesWritten,
            IN DWORD        CompletionStatus,  // Win32 Error code
            IN OVERLAPPED * lpo
            );

//
// Type of callback function to be called when a new connection is established.
//  This function should be defined before including conninfo.hxx
//

typedef
VOID
(*ATQ_CONNECT_CALLBACK) (
                IN SOCKET sNew,
                IN LPSOCKADDR_IN pSockAddr,
                IN PVOID EndpointContext,
                IN PVOID EndpointObject
                );



typedef struct _ATQ_ENDPOINT_CONFIGURATION {

    //
    // Port to listen on.  If 0, system will assign
    //

    USHORT ListenPort;

    //
    // Is connectionless
    //

    BOOL  fDatagram;
    
    // The next two are datagram only.
    BOOL  fReverseQueuing;     // If set then winsock will drop the oldest rather
                               // than the newest datagram buffers when winsock buffers 
                               // overflow.

    INT   cbDatagramWSBufSize; // How much buffer space to tell winsock to reserve
                               // for this datagram socket.
    
    //
    // Prevent others from using this?
    //

    BOOL  fLockDownPort;

    //
    // IP address to bind to. 0 (INADDR_ANY) == wildcard.
    //

    DWORD IpAddress;

    DWORD cbAcceptExRecvBuffer;
    DWORD nAcceptExOutstanding;
    DWORD AcceptExTimeout;

    //
    // Callbacks
    //

    ATQ_CONNECT_CALLBACK pfnConnect;
    ATQ_COMPLETION pfnConnectEx;
    ATQ_COMPLETION pfnIoCompletion;

} ATQ_ENDPOINT_CONFIGURATION, *PATQ_ENDPOINT_CONFIGURATION;

dllexp
PVOID
AtqCreateEndpoint(
    IN PATQ_ENDPOINT_CONFIGURATION Configuration,
    IN PVOID EndpointContext
    );

dllexp
BOOL
AtqStartEndpoint(
    IN PVOID Endpoint
    );

dllexp
DWORD_PTR
AtqEndpointGetInfo(
    IN PVOID Endpoint,
    IN ATQ_ENDPOINT_INFO EndpointInfo
    );

dllexp
DWORD_PTR
AtqEndpointSetInfo(
    IN PVOID Endpoint,
    IN ATQ_ENDPOINT_INFO EndpointInfo,
    IN DWORD_PTR dwInfo
    );

dllexp
BOOL
AtqStopEndpoint(
    IN PVOID Endpoint
    );

dllexp
BOOL
AtqCloseEndpoint(
    IN PVOID Endpoint
    );

dllexp
BOOL
AtqStopAndCloseEndpoint(
    IN PVOID Endpoint,
    IN LPTHREAD_START_ROUTINE lpCompletion,
    IN PVOID lpCompletionContext
    );



/*----------------------------------------------------------
  ATQ CONTEXT functions
-----------------------------------------------------------*/

//
//  This is the public portion of an ATQ Context.  It should be treated
//  as read only
//
//  !!! Changes made to this structure should also be made to
//  ATQ_CONTEXT in atqtypes.hxx !!!
//

typedef struct _ATQ_CONTEXT_PUBLIC {

    HANDLE         hAsyncIO;       // handle for async i/o object: socket/file
    OVERLAPPED     Overlapped;     // Overlapped structure used for IO

} ATQ_CONTEXT_PUBLIC, *PATQ_CONTEXT;


dllexp
BOOL
AtqAddAsyncHandle(
    OUT PATQ_CONTEXT * ppatqContext,
    IN  PVOID          EndpointObject,
    IN  PVOID          ClientContext,
    IN  ATQ_COMPLETION pfnCompletion,
    IN  DWORD          TimeOut,
    IN  HANDLE         hAsyncIO
    );


dllexp
VOID
AtqGetAcceptExAddrs(
    IN  PATQ_CONTEXT patqContext,
    OUT SOCKET *     pSock,
    OUT PVOID *      ppvBuff,
    OUT PVOID *      pEndpointContext,
    OUT SOCKADDR * * ppsockaddrLocal,
    OUT SOCKADDR * * ppsockaddrRemote
    );


/*++
  AtqCloseSocket()

  Routine Description:

    Closes the socket in this atq structure if it wasn't
    closed by transmitfile. This function should be called only
    if the embedded handle in AtqContext is a Socket.

  Arguments:

    patqContext - Context whose socket should be closed.
    fShutdown - If TRUE, means we call shutdown and always close the socket.
        Note that if TransmitFile closed the socket, it will have done the
        shutdown for us

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
dllexp
BOOL
AtqCloseSocket(
    PATQ_CONTEXT patqContext,
    BOOL         fShutdown
    );

/*++
  AtqCloseFileHandle()

  Routine Description:

    Closes the file handle in this atq structure.
    This function should be called only if the embedded handle
    in AtqContext is a file handle.

  Arguments:

  patqContext - Context whose file handle should be closed.

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
dllexp
BOOL
AtqCloseFileHandle(
    PATQ_CONTEXT patqContext
    );


/*++

   AtqFreeContext()

   Routine Description:

     Frees the context created in AtqAddAsyncHandle.
     Call this after the async handle has been closed and all outstanding
     IO operations have been completed. The context is invalid after this call.
     Call AtqFreeContext() for same context only ONCE.

   Arguments:

    patqContext - Context to free
    fReuseContext - TRUE if this can context can be reused in the context of
        the calling thread.  Should be FALSE if the calling thread will exit
        soon (i.e., isn't an AtqPoolThread).

   Returns:
    None
--*/
dllexp
VOID
AtqFreeContext(
    IN PATQ_CONTEXT   patqContext,
    BOOL              fReuseContext
    );




enum ATQ_CONTEXT_INFO
{
    ATQ_INFO_TIMEOUT = 0,       // Timeout rounded up to ATQ timeout interval
    ATQ_INFO_RESUME_IO,         // resumes IO as is after Timeout
    ATQ_INFO_COMPLETION,        // Completion routine
    ATQ_INFO_COMPLETION_CONTEXT,// Completion context
    ATQ_INFO_BANDWIDTH_INFO,    // Bandwidth Throttling Descriptor
    ATQ_INFO_ABORTIVE_CLOSE,    // do abortive close on closesocket
    ATQ_INFO_NEXT_TIMEOUT
};

enum ATQ_CONSUMER_TYPE
{
    AtqConsumerLDAP = 0,
    AtqConsumerOther,
    AtqConsumerAtq,
    AtqConsumerMax
};


/*++

  AtqContextSetInfo()

  Routine Description:

    Sets various bits of information for this context

  Arguments:

    patqContext - pointer to ATQ context
    atqInfo     - Data item to set
    data        - New value for item

  Return Value:

    The old value of the parameter

--*/

dllexp
DWORD_PTR
AtqContextSetInfo(
    IN PATQ_CONTEXT   patqContext,
    IN enum ATQ_CONTEXT_INFO  atqInfo,
    IN DWORD_PTR      data
    );

dllexp
DWORD_PTR
AtqContextSetInfo2(
    IN PATQ_CONTEXT   patqContext,
    IN enum ATQ_CONTEXT_INFO  atqInfo,
    IN DWORD_PTR      data
    );

VOID
AtqUpdatePerfStats(
    IN ATQ_CONSUMER_TYPE        ConsumerType,
    IN DWORD                    dwOperation,
    IN DWORD                    dwVal
    );

dllexp
DWORD_PTR
AtqEndpointSetInfo2(
    IN PVOID                Endpoint,
    IN ATQ_ENDPOINT_INFO    EndpointInfo,
    IN DWORD_PTR            dwInfo
    );

dllexp
DWORD_PTR
AtqSetInfo2(
    IN ATQ_INFO         atqInfo,
    IN DWORD_PTR        Data
    );


/*----------------------------------------------------------
  ATQ Context IO functions
-----------------------------------------------------------*/

/*++

Routine Description:

    Atq<Operation><Target>()

    <Operation> :=  Read | Write | Transmit
    <Target>    :=  File | Socket

    These functions just setup ATQ context and then call the corresponding
    Win32/WinSock function for submitting an asynchronous IO operation. By
    default the Socket functions support scatter/gather using WSABUF

    These functions are wrappers and should be called instead of the
     correpsonding Win32 API.  The one difference from the Win32 API is TRUE
     is returned if the error ERROR_IO_PENDING occurred, thus clients do not
     need to check for this case.

   The timeout time for the request is calculated by taking the maximum of
     the context's timeout time and bytes transferred based on 1k/second.

Arguments:

    patqContext - pointer to ATQ context
    Everything else as in the Win32 API/WinSock APIs

    NOTES: AtqTransmitFile takes an additional DWORD flags which may contain
        the winsock constants TF_DISCONNECT and TF_REUSE_SOCKET

    AtqReadFile and AtqWriteFile take an optional overlapped structure if
    clients want to have multiple outstanding reads or writes.  If the value
    is NULL, then the overlapped structure from the Atq context is used.

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)
    sets ERROR_NETWORK_BUSY as error when the request needs to be rejected.

--*/

dllexp
BOOL
AtqReadFile(
    IN  PATQ_CONTEXT patqContext,
    IN  LPVOID       lpBuffer,
    IN  DWORD        BytesToRead,
    IN  OVERLAPPED * lpo OPTIONAL
    );

dllexp
BOOL
AtqReadSocket(
    IN  PATQ_CONTEXT patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    IN  OVERLAPPED * lpo  OPTIONAL
    );

/*
 *  Code for reading into single buffer will look like the following.
 * {
 *   WSABUF wsaBuf = { (BytesToRead), (lpBuffer)};
 *   fRet = AtqReadSocket( patqContext, &wsaBuf, 1, lpo);
 * }
 */

dllexp
BOOL
AtqWriteFile(
    IN  PATQ_CONTEXT patqContext,
    IN  LPCVOID      lpBuffer,
    IN  DWORD        BytesToWrite,
    IN  OVERLAPPED * lpo OPTIONAL
    );

dllexp
BOOL
AtqWriteSocket(
    IN  PATQ_CONTEXT patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    IN  OVERLAPPED * lpo OPTIONAL
    );


dllexp
BOOL
AtqSyncWsaSend(
    IN PATQ_CONTEXT  patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    OUT LPDWORD      pcbWritten
    );

// Note: This API always causes the complete file to be sent.
// If you want to change the behaviour store the appropriate offsets
//   in the ATQ_CONTEXT::Overlapped object.
dllexp
BOOL
AtqTransmitFile(
    IN  PATQ_CONTEXT            patqContext,
    IN  HANDLE                  hFile,         // File data comes from
    IN  DWORD                   dwBytesInFile, // what is the size of file?
    IN  LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN  DWORD                   dwFlags      // TF_DISCONNECT, TF_REUSE_SOCKET
    );

dllexp
BOOL
AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    );

dllexp
BOOL
AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    );


/*----------------------------------------------------------
  ATQ Utility Functions
-----------------------------------------------------------*/

#define OPLOCK_BREAK_NO_OPLOCK  0x00000001
#define OPLOCK_BREAK_OPEN       0x00000007
#define OPLOCK_BREAK_CLOSE      0x00000008

typedef
VOID
(*ATQ_OPLOCK_COMPLETION)(
            IN PVOID        Context,
            IN DWORD        Status
            );

dllexp
HANDLE
AtqCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlagsAndAttributes,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR sd,
    ULONG Length,
    PULONG LengthNeeded,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
    );

dllexp
BOOL
AtqOplockAcknowledge(
    IN HANDLE   FileHandle,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
);

dllexp
BOOL
AtqSpudInitialized(
    VOID
);

dllexp
BOOL
AtqReadDirChanges(PATQ_CONTEXT patqContext,
                  LPVOID       lpBuffer,
                  DWORD        BytesToRead,
                  BOOL         fWatchSubDir,
                  DWORD        dwNotifyFilter,
                  OVERLAPPED * lpo );



/*++

  AtqPostCompletionStatus()

  Routine Description:

    Posts a completion status on the completion port queue

    An IO pending error code is treated as a success error code

  Arguments:

    patqContext - pointer to ATQ context
    Everything else as in the Win32 API

    NOTES:

  Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/

dllexp
BOOL
AtqPostCompletionStatus(
    IN     PATQ_CONTEXT patqContext,
    IN     DWORD        BytesTransferred
    );




/*----------------------------------------------------------
  ATQ Utility Functions
-----------------------------------------------------------*/

/*++

   Bandwidth Throttling Support

   The following items are used in the support for bandwidth throttling
--*/

enum ATQ_BANDWIDTH_INFO
{
    ATQ_BW_BANDWIDTH_LEVEL = 0,
    ATQ_BW_MAX_BLOCKED,
    ATQ_BW_STATISTICS,
    ATQ_BW_DESCRIPTION,
};

/*++

  AtqCreateBandwidthInfo()

  Routine Description:

    Allocate and opaque bandwidth descriptor

  Arguments:

    None

  Return Value:

    Pointer to descriptor.  NULL if failed.

--*/
dllexp
PVOID
AtqCreateBandwidthInfo(
    VOID
    );

/*++

  AtqFreeBandwidthInfo()

  Routine Description:

    Triggers the destruction of a bandwidth descriptor

  Arguments:

    pvBandwidthInfo - pointer to valid descriptor

  Return Value:

    TRUE if successful, else FALSE

--*/
dllexp
BOOL
AtqFreeBandwidthInfo(
    IN     PVOID               pvBandwidthInfo
    );

/*++

  AtqBandwidthSetInfo()

  Routine Description:

    Set properties of bandwidth descriptor

  Arguments:

    pvBandwidthInfo - pointer to descriptor
    BWInfo - property to change
    Data - value of property

  Return Value:

    Old value of property

--*/
dllexp
DWORD_PTR
AtqBandwidthSetInfo(
    IN     PVOID               pvBandwidthInfo,
    IN     ATQ_BANDWIDTH_INFO  BwInfo,
    IN     DWORD_PTR           Data
    );

/*++

  AtqBandwidthGetInfo()

  Routine Description:

    Get properties of bandwidth descriptor

  Arguments:

    pvBandwidthInfo - pointer to descriptor
    BWInfo - property to change
    pdwData - filled in with value of property

  Return Value:

    TRUE if successful, else FALSE

--*/
dllexp
BOOL
AtqBandwidthGetInfo(
    IN     PVOID               pvBandwidthInfo,
    IN     ATQ_BANDWIDTH_INFO  BwInfo,
    OUT    DWORD_PTR *         pdwData
    );

#include "atq2.h"

#ifdef __cplusplus
}
#endif

#endif // !_ATQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\_esefile\checksum.cxx ===
#include "esefile.hxx"

//  Checksum a file in ESE format
//
//  For optimal performance the file is read in 64K chunks. As each
//	read completes it is posted to a completion port. Threads take
//	reads off the completion port, checksum the data and issue a
//	new read (if there is more data to read).
//
//	The basic unit of a read is the BLOCKIO. When it is no longer
//	possible to read from a file a signal is set in the BLOCKIO.
//	When all BLOCKIO's are signalled the checksum has completed.
//
//	The status of the checksum is kept is global variables and updated
//	with interlocked operations.
//	OPTIMISATION: In order to eliminate cache-sloshing, this is no
//	longer done.  Stats are maintained in the individual BLOCKIO
//	structures and then aggregated at the end.
//
//	The main thread starts reading the files and creates the threads
//	which pull completed reads off the completion port. The main thread
//	wakes up periodically to update the status bar
//

int g_cbPage;
int g_shfCbLower;
int g_shfCbUpper;
int g_cpagesPerBlock;

static const int cblocks			= g_cbBufferTotal / g_cbReadBuffer;	//	number of read chunks
static const int cthreads			= 8;


struct CHECKSUM_STATS
	{
	//	progress variables

	DWORD				cpagesSeen;
	DWORD				cpagesBadChecksum;
	DWORD				cpagesUninit;
	DWORD				cpagesWrongPgno;
	unsigned __int64	dbtimeHighest;
	DWORD				pgnoDbtimeHighest;
	DWORD				dwFiller;

	//	I/O latency timing

	DWORD				cIOs;			//	total number of read IOs that were performed
	DWORD				dwTickTotal;	//	total tickcount for all IOs
	DWORD				dwTickMax;		//	maximum tickcount (slowest IO)
	DWORD				dwTickMin;		//	minimum elapsed tickcount (fastest IO)
	};
	

static long cpageMax;
static long cblockMax;
static long cblockCurr;

static HANDLE rghThreads[cthreads];

typedef DWORD (*PFNCHECKSUM)( const BYTE * const, const DWORD );


//  ================================================================
struct JETPAGE
//  ================================================================
	{
	DWORD				dwChecksum;
	DWORD				pgno;
	unsigned __int64	dbtime;
//	BYTE				rgbRestOfPage[];
	};


//  ================================================================
struct BLOCKIO
//  ================================================================
	{
	OVERLAPPED		overlapped;		//  overlapped must be the first member
	JETPAGE *		rgpage;
	DWORD			cbRead;
	DWORD 			cpage;
	DWORD 			ipage;
	DWORD			dwTickStart;
	CHECKSUM_STATS	checksumstats;
	HANDLE			hEvent;
	HANDLE			hFile;
	};


static BLOCKIO rgblockio[cblocks];


//  ================================================================
static void PrintChecksumStats(
	const DWORD						dwTickElapsed,
	const CHECKSUM_STATS * const	pchecksumstats )
//  ================================================================
	{
	(void)wprintf( L"\r\n\r\n" );
	(void)wprintf( L"%d pages seen\r\n", pchecksumstats->cpagesSeen );
	(void)wprintf( L"%d bad checksums\r\n", pchecksumstats->cpagesBadChecksum );
	(void)wprintf( L"%d uninitialized pages\r\n", pchecksumstats->cpagesUninit );
	(void)wprintf( L"%d wrong page numbers\r\n", pchecksumstats->cpagesWrongPgno );
	(void)wprintf( L"0x%I64x highest dbtime (pgno 0x%x)\r\n", pchecksumstats->dbtimeHighest, pchecksumstats->pgnoDbtimeHighest );
	(void)wprintf( L"\r\n" );
	(void)wprintf( L"%d reads performed\r\n", pchecksumstats->cIOs );

	const DWORD mbRead 			= pchecksumstats->cpagesSeen / ( ( 1024 * 1024 ) / g_cbPage );
	const DWORD csecElapsed		= max( dwTickElapsed / 1000, 1 );
	const DWORD mbPerSec		= mbRead / csecElapsed;
	
	(void)wprintf( L"%d MB read\r\n", mbRead );
	(void)wprintf( L"%d seconds taken\r\n", csecElapsed );
	(void)wprintf( L"%d MB/second\r\n", mbPerSec );
	(void)wprintf( L"%d milliseconds used\r\n", pchecksumstats->dwTickTotal );
	(void)wprintf( L"%d milliseconds per read\r\n", pchecksumstats->dwTickTotal / pchecksumstats->cIOs );
	(void)wprintf( L"%d milliseconds for the slowest read\r\n", pchecksumstats->dwTickMax );
	(void)wprintf( L"%d milliseconds for the fastest read\r\n", pchecksumstats->dwTickMin );
	(void)wprintf( L"\r\n" );
	}


//  ================================================================
static BOOL FChecksumCorrect( const CHECKSUM_STATS * const pchecksumstats )
//  ================================================================
	{
	return ( 0 == pchecksumstats->cpagesBadChecksum && 0 == pchecksumstats->cpagesWrongPgno );
	}


//  ================================================================
static void IssueNextIO( BLOCKIO * const pblockio )
//  ================================================================
	{
	const long cblock 	= InterlockedIncrement( &cblockCurr ) - 1;
	if( cblock >= cblockMax )
		{
		if( !SetEvent( pblockio->hEvent ) )
			{
			PrintWindowsError( L"FAILURE: SetEvent: " );
			}
		return;
		}

	pblockio->cpage 	= min( g_cpagesPerBlock, cpageMax - ( cblock * g_cpagesPerBlock ) );
	pblockio->ipage 	= cblock * g_cpagesPerBlock;
	pblockio->cbRead	= pblockio->cpage * g_cbPage;

	pblockio->overlapped.Offset		= pblockio->ipage << g_shfCbLower;
	pblockio->overlapped.OffsetHigh	= pblockio->ipage >> g_shfCbUpper;

	pblockio->dwTickStart			= GetTickCount();

	if( !ReadFile( pblockio->hFile, pblockio->rgpage, pblockio->cbRead, NULL, &(pblockio->overlapped) )
		&& ERROR_IO_PENDING != GetLastError() )
		{
		PrintWindowsError( L"FAILURE: ReadFile: " );
		if( !SetEvent( pblockio->hEvent ) )
			{
			PrintWindowsError( L"FAILURE: SetEvent: " );
			}
		return;
		}

	return;
	}


//  ================================================================
inline void CachePrefetch ( const void * const p )
//  ================================================================
	{
#ifdef _X86_
	  _asm
	  {
	   mov  eax,p
 
	   _emit 0x0f  // PrefetchNTA
	   _emit 0x18
	   _emit 0x00
	  }
#endif
	}
 

//  ================================================================
static BOOL FHardwareCanPrefetch()
//  ================================================================
	{
	BOOL fCanPrefetch = FALSE;
	
#ifdef _X86_
    ULONG    Features;
    ULONG    i;
    DWORD    OriginalAffinity;

 	SYSTEM_INFO system_inf;
 	GetSystemInfo( &system_inf );
 
    //
    // First check to see that I have at least Intel Pentium.  This simplifies
    // the cpuid
    //
    if (system_inf.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL ||
        system_inf.wProcessorLevel < 5)
 	{
	return fCanPrefetch;
	}
	
	fCanPrefetch = TRUE;
 
    //
    // Affinity thread to boot processor
    //
 
	OriginalAffinity = SetThreadAffinityMask(GetCurrentThread(), 1);
 
	// Here we want to go through each CPU, so use the systeminfo # of
	// processors instead of gdwSchedulerCount
	//
	for ( i = 0; i < system_inf.dwNumberOfProcessors && fCanPrefetch; i++ )
		{
		if ( i != 0 )
			{
			SetThreadAffinityMask(GetCurrentThread(), 1 << i);
			}
 
		_asm
			{
			push   ebx
            mov    eax, 1	; cpuid
            _emit  0fh
            _emit  0a2h
 
            mov    Features, edx
            pop    ebx
			}
 
        //
        // Check for Prefetch Present
        //
        if (!(Features & 0x02000000))
			{
 
            //
            // All processors must have prefetch before we can use it.
            // We start with it enabled, if any processor does not have
            // it, we clear it and bail
 
            fCanPrefetch = FALSE;
			}
		}
		SetThreadAffinityMask(GetCurrentThread(), OriginalAffinity);		
#endif

	return fCanPrefetch;
	}


//  ================================================================
static DWORD DwChecksumESEPrefetch( const BYTE * const pb, const DWORD cb )
//  ================================================================
	{
	PFNCHECKSUM pfn = DwChecksumESEPrefetch;
	
	const DWORD	* pdw 			= (DWORD *)pb;
	INT cbT						= cb;

	//	touching this memory puts the page in the processor TLB (needed
	//	for prefetch) and brings in the first cacheline (cacheline 0)
	
	DWORD	dwChecksum = 0x89abcdef ^ pdw[0];

	do
		{
		CachePrefetch ( pdw + 16 );	
		dwChecksum 	^= pdw[0]
					^ pdw[1]
					^ pdw[2]
					^ pdw[3]
					^ pdw[4]
					^ pdw[5]
					^ pdw[6]
					^ pdw[7];
		cbT -= 32;
		pdw += 8;
		} while ( cbT );

	return dwChecksum;
	}


//  ================================================================
static DWORD DwChecksumESENoPrefetch( const BYTE * const pb, const DWORD cb )
//  ================================================================
	{
	PFNCHECKSUM pfn = DwChecksumESENoPrefetch;
	
	const DWORD	* pdw 			= (DWORD *)pb;
	INT cbT						= cb;
	
	DWORD	dwChecksum = 0x89abcdef ^ pdw[0];

	do
		{
		dwChecksum 	^= pdw[0]
					^ pdw[1]
					^ pdw[2]
					^ pdw[3]
					^ pdw[4]
					^ pdw[5]
					^ pdw[6]
					^ pdw[7];
		cbT -= 32;
		pdw += 8;
		} while ( cbT );

	return dwChecksum;
	}


//  ================================================================
static DWORD DwChecksumESE64Bit( const BYTE * const pb, const DWORD cb )
//  ================================================================
	{
	const unsigned __int64	* pqw 	= (unsigned __int64 *)pb;
	unsigned __int64	qwChecksum	= 0;
	DWORD cbT						= cb;
	
	//	checksum the first four bytes twice to remove the checksum
	
	qwChecksum ^= pqw[0] & 0x00000000FFFFFFFF;
		
	do
		{
		qwChecksum ^= pqw[0];
		qwChecksum ^= pqw[1];
		qwChecksum ^= pqw[2];
		qwChecksum ^= pqw[3];
		cbT -= ( 4 * sizeof( unsigned __int64 ) );
		pqw += 4;
		} while ( cbT );

	const unsigned __int64 qwUpper = ( qwChecksum >> ( sizeof( DWORD ) * 8 ) );
	const unsigned __int64 qwLower = qwChecksum & 0x00000000FFFFFFFF;
	qwChecksum = qwUpper ^ qwLower;
	
	const DWORD ulChecksum = static_cast<DWORD>( qwChecksum ) ^ 0x89abcdef;
	return ulChecksum;
	}


//  ================================================================
DWORD DwChecksumESE( const BYTE * const pb, const DWORD cb )
//  ================================================================
	{
	static PFNCHECKSUM pfnChecksumESE = NULL;
	
	if( NULL == pfnChecksumESE )
		{
		if( sizeof( DWORD_PTR ) == sizeof( DWORD ) * 2 )
			{
			pfnChecksumESE = DwChecksumESE64Bit;
			}
		else if( FHardwareCanPrefetch() )
			{
			pfnChecksumESE = DwChecksumESEPrefetch;
			}
		else
			{
			pfnChecksumESE = DwChecksumESENoPrefetch;
			}
		}
	return (*pfnChecksumESE)( pb, cb );
	}


//  ================================================================
static void ProcessESEPages( BLOCKIO * const pblockio )
//  ================================================================
	{
	const JETPAGE * const	rgpage			= pblockio->rgpage;
	const DWORD				cpage			= pblockio->cpage;
	const DWORD				ipageStart		= pblockio->ipage;
	CHECKSUM_STATS * const	pchecksumstats	= &pblockio->checksumstats;

	for( DWORD ipage = 0; ipage < cpage; ++ipage )
		{
		pchecksumstats->cpagesSeen++;

		const JETPAGE * const	ppageCurr	= (JETPAGE *)( (BYTE *)rgpage + ( ipage * g_cbPage ) );
		const DWORD * const		pdwUninit	= (DWORD *)ppageCurr + 1;	//	first DWORD is the checksum

		if ( 0 == *pdwUninit
			&& 0 == *( pdwUninit + 1 )
			&& 0 == *( pdwUninit + 2 )
			&& 0 == *( pdwUninit + 3 ) )
			{
			pchecksumstats->cpagesUninit++;
			}
		else
			{
			const DWORD	pgno			= ppageCurr->pgno;
			const DWORD	pgnoPhysical	= ipageStart + ipage + 1;
			const long	fHeaderPage		= ( pgnoPhysical <= g_cpgDBReserved );
			const DWORD	pgnoReal		= ( fHeaderPage ? 0 : pgnoPhysical - g_cpgDBReserved );

			//	pgnoReal==-1 for db header and 0 for shadow
			if( pgno != pgnoReal && !fHeaderPage )
				{
				(void)fwprintf( stderr, L"ERROR: page %d returned page %d\r\n", pgnoReal, pgno );
				pchecksumstats->cpagesWrongPgno++;
				}
			const DWORD dwChecksum = DwChecksumESE( (BYTE *)ppageCurr, g_cbPage );
			if( dwChecksum != ppageCurr->dwChecksum )
				{
				(void)fwprintf( stderr, L"ERROR: page %d checksum failed ( 0x%x / 0x%x )\r\n", (int)pgnoReal, dwChecksum, ppageCurr->dwChecksum );
				pchecksumstats->cpagesBadChecksum++;
				}
			else if ( !fHeaderPage )
				{
				if ( ppageCurr->dbtime > pchecksumstats->dbtimeHighest )
					{
					pchecksumstats->dbtimeHighest = ppageCurr->dbtime;
					pchecksumstats->pgnoDbtimeHighest = pgnoReal;
					}
				}
			}
		}
	}


//  ================================================================
static void CollectTimingInfo(
	const DWORD				dwTickCompleted,
	BLOCKIO * const			pblockio )
//  ================================================================
	{
	CHECKSUM_STATS * const	pchecksumstats	= &pblockio->checksumstats;
	const DWORD 			dwTickElapsed	= dwTickCompleted - pblockio->dwTickStart;

	pchecksumstats->cIOs++;
	pchecksumstats->dwTickTotal += dwTickElapsed;

	if ( dwTickElapsed > pchecksumstats->dwTickMax )
		{
		pchecksumstats->dwTickMax = dwTickElapsed;
		}
	if ( dwTickElapsed < pchecksumstats->dwTickMin )
		{
		pchecksumstats->dwTickMin = dwTickElapsed;
		}
	}


//  ================================================================
static DWORD WINAPI ESEThreadProc( LPVOID lpParam )
//  ================================================================
	{
	const HANDLE	hIOCP	= (HANDLE)lpParam;

	// Raid 137809
	SetThreadPriorityBoost( GetCurrentThread(), TRUE );

	while ( 1 )
		{
		DWORD 			dwBytesTransferred;
		DWORD_PTR		dwCompletionKey;
		OVERLAPPED *	poverlapped			= NULL;

		if ( !GetQueuedCompletionStatus(
					hIOCP,
					&dwBytesTransferred,
					&dwCompletionKey,
					&poverlapped,
					INFINITE ) )
			{
			PrintWindowsError( L"FAILURE: GetQueuedCompletionsStatus: " );
			break;
			}

		const DWORD			dwTickCompleted		= GetTickCount();			//	get this as soon as possible
		BLOCKIO * const		pblockio			= (BLOCKIO *)poverlapped;	//	overlapped is the first structure

		if ( NULL == pblockio )
			{
			PrintWindowsError( L"FAILURE: GetQueuedCompletionsStatus didn't return an OVERLAPPED structure: " );
			break;
			}
		else if ( dwBytesTransferred != pblockio->cbRead )
			{
			PrintWindowsError( L"FAILURE: GetQueuedCompletionsStatus got the wrong number of bytes: " );
			break;
			}

		CollectTimingInfo( dwTickCompleted, pblockio );
		ProcessESEPages( pblockio );
		IssueNextIO( pblockio );
		}

	return 0;
	}


//  ================================================================
BOOL FChecksumFile(
	const wchar_t * const	szFile,
	const BOOL				f8kPages,
	BOOL * const			pfBadPagesDetected )
//  ================================================================
	{	
	BOOL	fSuccess = FALSE;

	HANDLE	hFile = INVALID_HANDLE_VALUE;
	HANDLE	hIOCP = NULL;

	int		iblockio;
	int		ithread;

	DWORD	cbSizeLow;
	DWORD	cbSizeHigh;

	DWORD	dwTickFirstIO;	//	the time the first IO started
	DWORD	dwTickLastIO;	//	the time the last IO finished


	wprintf( L"File: %.64ls", ( iswascii( szFile[0] ) ? szFile : L"<unprintable>" ) );
	wprintf( L"\r\n\r\n" );

	//	init

	InitPageSize( f8kPages );

	cpageMax			= 0;
	cblockMax			= 0;
	cblockCurr			= 0;

	for( ithread = 0; ithread < cthreads; ++ithread )
		{
		rghThreads[ithread] = NULL;
		}

	memset( rgblockio, 0, sizeof(rgblockio) );
	for( iblockio = 0; iblockio < cblocks; ++iblockio )
		{
		//	initialise minimum I/O time to an artificially
		//	high number
		//
		rgblockio[iblockio].checksumstats.dwTickMin = 0x10000000;
		}

	//  open the file
	
	hFile = CreateFile(					
						szFile,
						GENERIC_READ,
						FILE_SHARE_READ | FILE_SHARE_WRITE,
						NULL,
						OPEN_EXISTING,
						FILE_FLAG_OVERLAPPED | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_NO_BUFFERING,
						NULL );
	if( INVALID_HANDLE_VALUE == hFile )
		{
		PrintWindowsError( L"FAILURE: CreateFile: " );
		goto LHandleError;
		}

	//  create the I/O completion port
	
	hIOCP = CreateIoCompletionPort (
		hFile,
		NULL,
		0,
		0 );
	if( NULL == hIOCP )
		{
		PrintWindowsError( L"FAILURE: CreateIoCompletionPort: " );
		goto LHandleError;
		}

	//  start the threads running

	for( ithread = 0; ithread < cthreads; ++ithread )
		{
		rghThreads[ithread] = CreateThread( 
											NULL,
											0,
											ESEThreadProc,
											(LPVOID)hIOCP,
											0,
											NULL );

		if( NULL == rghThreads[ithread] )
			{
			PrintWindowsError( L"FAILURE: CreateThread: " );
			goto LHandleError;
			}
	  	}

  	//  get the size of the file
	
	cbSizeLow = GetFileSize (hFile, &cbSizeHigh) ;
	if ( 0xFFFFFFFF == cbSizeLow && GetLastError() != NO_ERROR )
		{ 
		PrintWindowsError( L"FAILURE: GetFileSize: " );
		goto LHandleError;
		}

	cpageMax 	= ( cbSizeHigh << g_shfCbUpper ) + ( cbSizeLow >> g_shfCbLower );
	cblockMax 	= ( cpageMax + g_cpagesPerBlock - 1 ) / g_cpagesPerBlock;

	//  setup the BLOCKIO structures and start the IOs

	dwTickFirstIO	= GetTickCount();
	for( iblockio = 0; iblockio < cblocks; ++iblockio )
		{
		rgblockio[iblockio].hFile	 			= hFile;
		rgblockio[iblockio].rgpage 				= (JETPAGE *)VirtualAlloc( NULL, g_cbPage * g_cpagesPerBlock, MEM_COMMIT, PAGE_READWRITE );
		if( NULL == rgblockio[iblockio].rgpage )
			{
			PrintWindowsError( L"FAILURE: VirtualAlloc: " );
			goto LHandleError;
			}
		rgblockio[iblockio].hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
		if( NULL == rgblockio[iblockio].hEvent )
			{
			PrintWindowsError( L"FAILURE: CreateEvent: " );
			goto LHandleError;
			}

		IssueNextIO( rgblockio + iblockio );
		}

	InitStatus( L"Checksum Status (% complete)" );

	//  wait until the first block is done
	//  wake up to update the status bar

	while( 1 )
		{
		const DWORD dw = WaitForSingleObjectEx( rgblockio[0].hEvent, 200, FALSE );
		if( WAIT_TIMEOUT == dw )
			{
			const int  iPercentage	= ( cblockCurr * 100 ) / cblockMax;
			UpdateStatus( iPercentage );
			}
		else if( WAIT_OBJECT_0 == dw )
			{
			break;
			}
		else
			{
			PrintWindowsError( L"FAILURE: WaitForSingleObjectEx: " );
			goto LHandleError;
			}
		}

	//  do the other blocks 
	
	for( iblockio = 1; iblockio < cblocks; ++iblockio )
		{
		if( WAIT_OBJECT_0 != WaitForSingleObjectEx( rgblockio[iblockio].hEvent, INFINITE, FALSE ) )
			{
			PrintWindowsError( L"FAILURE: WaitForSingleObjectEx: " );
			goto LHandleError;
			}

		//	use the checksum stats in the first IO block to store the final totals
		rgblockio[0].checksumstats.cpagesSeen += rgblockio[iblockio].checksumstats.cpagesSeen;
		rgblockio[0].checksumstats.cpagesBadChecksum += rgblockio[iblockio].checksumstats.cpagesBadChecksum;
		rgblockio[0].checksumstats.cpagesUninit += rgblockio[iblockio].checksumstats.cpagesUninit;
		rgblockio[0].checksumstats.cpagesWrongPgno += rgblockio[iblockio].checksumstats.cpagesWrongPgno;
		if ( rgblockio[0].checksumstats.dbtimeHighest < rgblockio[iblockio].checksumstats.dbtimeHighest )
			{
			rgblockio[0].checksumstats.dbtimeHighest = rgblockio[iblockio].checksumstats.dbtimeHighest;
			rgblockio[0].checksumstats.pgnoDbtimeHighest = rgblockio[iblockio].checksumstats.pgnoDbtimeHighest;
			}

		rgblockio[0].checksumstats.cIOs += rgblockio[iblockio].checksumstats.cIOs;
		rgblockio[0].checksumstats.dwTickTotal += rgblockio[iblockio].checksumstats.dwTickTotal;
		if ( rgblockio[0].checksumstats.dwTickMax < rgblockio[iblockio].checksumstats.dwTickMax )
			{
			rgblockio[0].checksumstats.dwTickMax = rgblockio[iblockio].checksumstats.dwTickMax;
			}
		if ( rgblockio[0].checksumstats.dwTickMin > rgblockio[iblockio].checksumstats.dwTickMin )
			{
			rgblockio[0].checksumstats.dwTickMin = rgblockio[iblockio].checksumstats.dwTickMin;
			}
	  	}

	dwTickLastIO = GetTickCount();

	TermStatus();
	PrintChecksumStats( dwTickLastIO - dwTickFirstIO, &rgblockio[0].checksumstats );

	fSuccess = FChecksumCorrect( &rgblockio[0].checksumstats );

	//	by default we return FALSE if a checksum mismatch was detected,
	//	but if a separate flag was passed in to detect checksum
	//	mismatches, then always return TRUE if we got this far,
	//	and report checksum mismatches in the flag
	//
	if ( NULL != pfBadPagesDetected )
		{
		*pfBadPagesDetected = !fSuccess;
		fSuccess = TRUE;
		}

LHandleError:

	if( INVALID_HANDLE_VALUE != hFile )
		{
		CloseHandle( hFile );
		}
		
	if( NULL != hIOCP )
		{
		CloseHandle( hIOCP );
		}

	for( iblockio = 0; iblockio < cblocks; ++iblockio )
		{
		if( NULL != rgblockio[iblockio].rgpage )
			{
			VirtualFree( (void *)rgblockio[iblockio].rgpage, 0, MEM_RELEASE );
			}
		if( NULL != rgblockio[iblockio].hEvent )
			{
			CloseHandle( rgblockio[iblockio].hEvent );
			}
		}

	for( ithread = 0; ithread < cthreads; ++ithread )
		{
		if( NULL != rghThreads[ithread] )
			{
			CloseHandle( rghThreads[ithread] );
			}
		}

	return fSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\atq2.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1997           **/
/**********************************************************************/

/*
    atq.h

    This module contains async thread queue (atq) for async IO and thread
    pool sharing among various services.

    Brief Description of ATQ:
      For description, please see iis\spec\isatq.doc

*/

#ifndef _ATQ2_H_
#define _ATQ2_H_

typedef enum _AtqShutdownFlag {
    ATQSD_SEND    = SD_SEND,
    ATQSD_RECEIVE = SD_RECEIVE,
    ATQSD_BOTH    = SD_BOTH
} AtqShutdownFlag;

dllexp
VOID
AtqGetDatagramAddrs(
    IN  PATQ_CONTEXT patqContext,
    OUT SOCKET *     pSock,
    OUT PVOID *      ppvBuff,
    OUT PVOID *      pEndpointContext,
    OUT SOCKADDR * * ppsockaddrRemote,
    OUT INT *        pcbsockaddrRemote
    );

dllexp
DWORD_PTR
AtqContextGetInfo(
    PATQ_CONTEXT           patqContext,
    enum ATQ_CONTEXT_INFO  atqInfo
    );

dllexp
BOOL
AtqWriteDatagramSocket(
    IN PATQ_CONTEXT  patqContext,
    IN LPWSABUF     pwsaBuffers,
    IN DWORD        dwBufferCount,
    IN OVERLAPPED *  lpo OPTIONAL
    );

dllexp
BOOL
AtqShutdownSocket(
    IN PATQ_CONTEXT patqContext,
    IN AtqShutdownFlag  flags
    );

#endif // !_ATQ2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\crc32.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    crc32.h

Abstract:

    CRC-32 alogorithm prototypes and constants

Author:

    MikeSw

Revision History:

    ChandanS  25-Jul-96      Stolen from net\svcdlls\ntlmssp\client\crc32.h
--*/



//////////////////////////////////////////////////////////////
//
// Function prototypes for CRC-32
//
//////////////////////////////////////////////////////////////


#ifdef __cplusplus
extern "C"
{
#endif

void
Crc32(  unsigned long crc,
        unsigned long cbBuffer,
        void * pvBuffer,
        unsigned long * pNewCrc);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\config.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    Config.h

Abstract:

    This header file defines the function prototypes of the temporary
    helper routines to get configuration information from the NT
    configuration files.

Author:

    Rita Wong (ritaw) 22-May-1991

Environment:

    Only runs under NT.

Notes:

    You must include the following before this file:

            windef.h OR windows.h  // Win32 type definitions

Revision History:

    22-May-1991 RitaW
        Created.
    27-Nov-1991 JohnRo
        Prepare for revised config handlers.  Added revision history.
    08-Jan-1992 JohnRo
        Added SECT_NT_REPLICATOR.
    13-Feb-1992 JohnRo
        Moved section name equates to <confname.h>.
        Include <netdebug.h> and <lmcons.h> here instead of everywhere else.
        Added NetpDbgDisplayConfigSection().
        Added NetpDeleteConfigKeyword() and NetpNumberOfConfigKeywords().
        Added Netp{Get,Set}Config{Bool,Dword}.
    14-Mar-1992 JohnRo
        Get rid of old config helper callers.
    23-Mar-1992 JohnRo
        Get rid of old config helpers.
    08-May-1992 JohnRo
        Add LPTSTR array routines.
    08-Jul-1992 JohnRo
        RAID 10503: srv mgr: repl dialog doesn't come up.
    25-Feb-1993 JohnRo
        RAID 12914: avoid double close and free mem in NetpCloseConfigData().
    07-Apr-1993 JohnRo
        RAID 5483: server manager: wrong path given in repl dialog.

--*/


#ifndef CONFIG_H
#define CONFIG_H


#include <lmcons.h>     // NET_API_STATUS.
#include <netdebug.h>   // LPDEBUG_STRING.
#include <strarray.h>   // LPTSTR_ARRAY.


//
// Opaque pointer for net config handles.  (The real structure is in ConfigP.h,
// and should only be used by NetLib routines.)
//
typedef LPVOID LPNET_CONFIG_HANDLE;


//
// Note that the routines in this file only accept the SECT_NT_ versions.
// See <confname.h> for more details.
//


// NetpOpenConfigData opens the Paramaters section of a given service.
NET_API_STATUS
NetpOpenConfigData(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN BOOL ReadOnly
    );

// NetpOpenConfigDataEx opens any area of a given service.
NET_API_STATUS
NetpOpenConfigDataEx(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN LPTSTR AreaUnderSection OPTIONAL,
    IN BOOL ReadOnly
    );

// NetpOpenConfigData opens the Paramaters section of a given service.
NET_API_STATUS
NetpOpenConfigDataWithPath(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN BOOL ReadOnly
    );

// NetpOpenConfigDataEx opens any area of a given service.
NET_API_STATUS
NetpOpenConfigDataWithPathEx(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN LPTSTR AreaUnderSection OPTIONAL,
    IN BOOL ReadOnly
    );

// Delete a keyword and its value.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpDeleteConfigKeyword (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword
    );

NET_API_STATUS
NetpExpandConfigString(
    IN  LPCTSTR  UncServerName OPTIONAL,
    IN  LPCTSTR  UnexpandedString,
    OUT LPTSTR * ValueBufferPtr         // Must be freed by NetApiBufferFree().
    );

// If NetpOpenConfigData fails, try calling NetpHandleConfigFailure to decide
// what to do about it.
NET_API_STATUS
NetpHandleConfigFailure(
    IN LPDEBUG_STRING DebugName,        // Name of routine.
    IN NET_API_STATUS ApiStatus,        // NetpOpenConfigData's error code.
    IN LPTSTR ServerNameValue OPTIONAL,
    OUT LPBOOL TryDownlevel
    );

// Get a boolean value.  Return ERROR_INVALID_DATA if value isn't boolean.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpGetConfigBool (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN BOOL DefaultValue,
    OUT LPBOOL ValueBuffer
    );

// Get an unsigned numeric value.  Return ERROR_INVALID_DATA if value isn't
// numeric.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpGetConfigDword (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN DWORD DefaultValue,
    OUT LPDWORD ValueBuffer
    );

// Return null-null array of strings.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpGetConfigTStrArray(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    OUT LPTSTR_ARRAY * ValueBuffer      // Must be freed by NetApiBufferFree().
    );

// Return string value for a given keyword.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpGetConfigValue (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    OUT LPTSTR * ValueBuffer            // Must be freed by NetApiBufferFree().
    );

NET_API_STATUS
NetpEnumConfigSectionValues(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    OUT LPTSTR * KeywordBuffer,         // Must be freed by NetApiBufferFree().
    OUT LPTSTR * ValueBuffer,           // Must be freed by NetApiBufferFree().
    IN BOOL FirstTime
    );

NET_API_STATUS
NetpNumberOfConfigKeywords (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    OUT LPDWORD Count
    );

NET_API_STATUS
NetpSetConfigValue(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN LPTSTR Value
    );

NET_API_STATUS
NetpCloseConfigData(
    IN OUT LPNET_CONFIG_HANDLE ConfigHandle
    );


#endif // ndef CONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\kerbcli.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1999
//
// File:        kerbcli.h
//
// Contents:    exported functions from kerbcli.lib
//
//
// History:     24-May-1999     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __KERBCLI_H__
#define __KERBCLI_H__

#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS
KerbChangePasswordUser(
    IN LPWSTR DomainName,
    IN LPWSTR UserName,
    IN LPWSTR OldPassword,
    IN LPWSTR NewPassword
    );


NTSTATUS
KerbSetPasswordUser(
    IN LPWSTR DomainName,
    IN LPWSTR UserName,
    IN LPWSTR NewPassword,
    IN OPTIONAL PCredHandle CredentialsHandle
    );

NTSTATUS
KerbSetPasswordUserEx(
    IN LPWSTR DomainName,
    IN LPWSTR UserName,
    IN LPWSTR NewPassword,
    IN OPTIONAL PCredHandle CredentialsHandle,
    IN OPTIONAL LPWSTR  KdcAddress
    );


#ifdef __cplusplus
}
#endif

#endif // __KERBCLI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\ldap.h ===
/******************************************************************/
/* Copyright (C) 1998 Microsoft Corporation.  All rights reserved.*/
/******************************************************************/
/* Abstract syntax: ldap */
/* Created: Tue Jan 27 10:27:59 1998 */
/* ASN.1 compiler version: 4.2 Beta B */
/* Target operating system: Windows NT 3.5 or later/Windows 95 */
/* Target machine type: Intel x86 */
/* C compiler options required: -Zp8 (Microsoft) or equivalent */
/* ASN.1 compiler options specified:
 * -noshortennames -nouniquepdu -c++ -noconstraints -ber -gendirectives
 * ldapnew.gen
 */

#ifndef OSS_ldap
#define OSS_ldap

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include "asn1hdr.h"
#include "asn1code.h"

#define          ObjectID_PDU 1
#define          DistinguishedName_PDU 2
#define          LDAPMsg_PDU 3
#define          Attribute_PDU 4
#define          PagedResultsSearchControlValue_PDU 5
#define          ReplicationSearchControlValue_PDU 6
#define          SecurityDescriptorSearchControlValue_PDU 7
#define          SearchResultFull_PDU 8
#define          ProtectedPassword_PDU 9
#define          StrongCredentials_PDU 10
#define          SortKeyList_PDU 11
#define          SortResult_PDU 12

typedef struct ObjectID_ {
    struct ObjectID_ *next;
    unsigned short  value;
} *ObjectID;

typedef struct TYPE_IDENTIFIER {
    struct ObjectID_ *id;
    unsigned short  Type;
} TYPE_IDENTIFIER;

typedef struct ObjectID_ *ID;

typedef struct UniqueIdentifier {
    unsigned int    length;  /* number of significant bits */
    unsigned char   *value;
} UniqueIdentifier;

typedef struct AlgorithmIdentifier {
    unsigned char   bit_mask;
#       define      parameters_present 0x80
    struct ObjectID_ *algorithm;
    OpenType        parameters;  /* optional */
} AlgorithmIdentifier;

typedef struct RDNSequence_ *DistinguishedName;

typedef struct Token {
    struct {
        AlgorithmIdentifier algorithm;
        struct RDNSequence_ *name;
        UTCTime         time;
        struct {
            unsigned int    length;  /* number of significant bits */
            unsigned char   *value;
        } random;
    } toBeSigned;
    AlgorithmIdentifier algorithmIdentifier;
    struct {
        unsigned int    length;  /* number of significant bits */
        unsigned char   *value;
    } encrypted;
} Token;

typedef int             Version;
#define                     v1 0
#define                     v2 1

typedef int             CertificateSerialNumber;

typedef struct Name {
    unsigned short  choice;
#       define      rdnSequence_chosen 1
    union _union {
        struct RDNSequence_ *rdnSequence;
    } u;
} Name;

typedef struct Validity {
    UTCTime         notBefore;
    UTCTime         notAfter;
} Validity;

typedef struct SubjectPublicKeyInfo {
    AlgorithmIdentifier algorithm;
    struct _bit1 {
        unsigned int    length;  /* number of significant bits */
        unsigned char   *value;
    } subjectPublicKey;
} SubjectPublicKeyInfo;

typedef struct Certificate {
    struct {
        unsigned char   bit_mask;
#           define      version_present 0x80
#           define      issuerUniqueIdentifier_present 0x40
#           define      subjectUniqueIdentifier_present 0x20
        Version         version;  /* default assumed if omitted */
        CertificateSerialNumber serialNumber;
        AlgorithmIdentifier signature;
        Name            issuer;
        Validity        validity;
        Name            subject;
        SubjectPublicKeyInfo subjectPublicKeyInfo;
        UniqueIdentifier issuerUniqueIdentifier;  /* optional */
        UniqueIdentifier subjectUniqueIdentifier;  /* optional */
    } toBeSigned;
    AlgorithmIdentifier algorithmIdentifier;
    struct {
        unsigned int    length;  /* number of significant bits */
        unsigned char   *value;
    } encrypted;
} Certificate;

typedef TYPE_IDENTIFIER ALGORITHM;

typedef struct CertificatePair {
    unsigned char   bit_mask;
#       define      forward_present 0x80
#       define      reverse_present 0x40
    Certificate     forward;  /* optional */
    Certificate     reverse;  /* optional */
} CertificatePair;

typedef struct CertificationPath {
    unsigned char   bit_mask;
#       define      theCACertificates_present 0x80
    Certificate     userCertificate;
    struct _seqof1 {
        struct _seqof1  *next;
        CertificatePair value;
    } *theCACertificates;  /* optional */
} CertificationPath;

typedef struct AttributeTypeAndValue {
    struct ObjectID_ *type;
    OpenType        value;
} AttributeTypeAndValue;

typedef struct RDNSequence_ {
    struct RDNSequence_ *next;
    struct RelativeDistinguishedName_ *value;
} *RDNSequence;

typedef struct RelativeDistinguishedName_ {
    struct RelativeDistinguishedName_ *next;
    AttributeTypeAndValue value;
} *RelativeDistinguishedName;

typedef enum AttributeUsage {
    userApplications = 0,
    directoryOperation = 1,
    distributedOperation = 2,
    dSAOperation = 3
} AttributeUsage;

typedef struct ATTRIBUTE {
    unsigned char   bit_mask;
#       define      Type_present 0x80
#       define      single_valued_present 0x40
#       define      collective_present 0x20
#       define      no_user_modification_present 0x10
#       define      usage_present 0x08
    struct ATTRIBUTE *derivation;  /* NULL for not present */
    unsigned short  Type;  /* optional */
    struct MATCHING_RULE *equality_match;  /* NULL for not present */
    struct MATCHING_RULE *ordering_match;  /* NULL for not present */
    struct MATCHING_RULE *substrings_match;  /* NULL for not present */
    ossBoolean      single_valued;  /* default assumed if omitted */
    ossBoolean      collective;  /* default assumed if omitted */
    ossBoolean      no_user_modification;  /* default assumed if omitted */
    AttributeUsage  usage;  /* default assumed if omitted */
    struct ObjectID_ *id;
} ATTRIBUTE;

typedef struct MATCHING_RULE {
    unsigned char   bit_mask;
#       define      AssertionType_present 0x80
    unsigned short  AssertionType;  /* optional */
    struct ObjectID_ *id;
} MATCHING_RULE;

typedef unsigned int    MessageID;

typedef struct LDAPString {
    unsigned int    length;
    unsigned char   *value;
} LDAPString;

typedef LDAPString      LDAPDN;

typedef struct SaslCredentials {
    LDAPString      mechanism;
    struct _octet1 {
        unsigned int    length;
        unsigned char   *value;
    } credentials;
} SaslCredentials;

typedef struct AuthenticationChoice {
    unsigned short  choice;
#       define      simple_chosen 1
#       define      sasl_chosen 2
#       define      sicilyNegotiate_chosen 3
#       define      sicilyInitial_chosen 4
#       define      sicilySubsequent_chosen 5
#       define      sasl_v3response_chosen 1001
    union _union {
        struct _octet2 {
            unsigned int    length;
            unsigned char   *value;
        } simple;
        SaslCredentials sasl;
        struct _octet1 {
            unsigned int    length;
            unsigned char   *value;
        } sicilyNegotiate;
        struct _octet2_2 {
            unsigned int    length;
            unsigned char   *value;
        } sicilyInitial;
        struct _octet3 {
            unsigned int    length;
            unsigned char   *value;
        } sicilySubsequent;
    } u;
} AuthenticationChoice;

typedef struct BindRequest {
    unsigned short  version;
    LDAPDN          name;
    AuthenticationChoice authentication;
} BindRequest;

typedef enum _enum1 {
    success = 0,
    operationsError = 1,
    protocolError = 2,
    timeLimitExceeded = 3,
    sizeLimitExceeded = 4,
    compareFalse = 5,
    compareTrue = 6,
    authMethodNotSupported = 7,
    strongAuthRequired = 8,
    referralv2 = 9,
    referral = 10,
    adminLimitExceeded = 11,
    unavailableCriticalExtension = 12,
    confidentialityRequired = 13,
    saslBindInProgress = 14,
    noSuchAttribute = 16,
    undefinedAttributeType = 17,
    inappropriateMatching = 18,
    constraintViolation = 19,
    attributeOrValueExists = 20,
    invalidAttributeSyntax = 21,
    noSuchObject = 32,
    aliasProblem = 33,
    invalidDNSyntax = 34,
    aliasDereferencingProblem = 36,
    inappropriateAuthentication = 48,
    invalidCredentials = 49,
    insufficientAccessRights = 50,
    busy = 51,
    unavailable = 52,
    unwillingToPerform = 53,
    loopDetect = 54,

    sortControlMissing = 60,
    indexRangeError = 61,

    namingViolation = 64,
    objectClassViolation = 65,
    notAllowedOnNonLeaf = 66,
    notAllowedOnRDN = 67,
    entryAlreadyExists = 68,
    objectClassModsProhibited = 69,
    resultsTooLarge = 70,
    affectsMultipleDSAs = 71,
    virtualListViewError = 76,    
    other = 80
} _enum1;

typedef struct BindResponse {
    unsigned char   bit_mask;
#       define      BindResponse_referral_present 0x80
#       define      serverCreds_present 0x40
#       define      BindResponse_ldapv3 0x20
    _enum1          resultCode;
    LDAPDN          matchedDN;
    LDAPString      errorMessage;
    struct Referral_ *BindResponse_referral;  /* optional */
    AuthenticationChoice serverCreds;  /* optional */
} BindResponse;

typedef Nulltype        UnbindRequest;

typedef LDAPString      AttributeDescription;

typedef struct AssertionValue {
    unsigned int    length;
    unsigned char   *value;
} AssertionValue;

typedef struct AttributeValueAssertion {
    AttributeDescription attributeDesc;
    AssertionValue  assertionValue;
} AttributeValueAssertion;

typedef struct SubstringFilter {
    AttributeDescription type;
    struct SubstringFilterList_ *substrings;
} SubstringFilter;

typedef LDAPString      AttributeType;

typedef LDAPString      MatchingRuleId;

typedef struct MatchingRuleAssertion {
    unsigned char   bit_mask;
#       define      matchingRule_present 0x80
#       define      type_present 0x40
#       define      dnAttributes_present 0x20
    MatchingRuleId  matchingRule;  /* optional */
    AttributeDescription type;  /* optional */
    AssertionValue  matchValue;
    ossBoolean      dnAttributes;  /* default assumed if omitted */
} MatchingRuleAssertion;

typedef struct Filter {
    unsigned short  choice;
#       define      and_chosen 1
#       define      or_chosen 2
#       define      not_chosen 3
#       define      equalityMatch_chosen 4
#       define      substrings_chosen 5
#       define      greaterOrEqual_chosen 6
#       define      lessOrEqual_chosen 7
#       define      present_chosen 8
#       define      approxMatch_chosen 9
#       define      extensibleMatch_chosen 10
    union _union {
        struct _setof3_ *and;
        struct _setof4_ *or;
        struct Filter   *not;
        AttributeValueAssertion equalityMatch;
        SubstringFilter substrings;
        AttributeValueAssertion greaterOrEqual;
        AttributeValueAssertion lessOrEqual;
        AttributeType   present;
        AttributeValueAssertion approxMatch;
        MatchingRuleAssertion extensibleMatch;
    } u;
} Filter;

typedef struct _setof3_ {
    struct _setof3_ *next;
    Filter          value;
} *_setof3;

typedef struct _setof4_ {
    struct _setof4_ *next;
    Filter          value;
} *_setof4;

typedef enum _enum2 {
    baseObject = 0,
    singleLevel = 1,
    wholeSubtree = 2
} _enum2;

typedef enum _enum3 {
    neverDerefAliases = 0,
    derefInSearching = 1,
    derefFindingBaseObj = 2,
    derefAlways = 3
} _enum3;

typedef struct SearchRequest {
    LDAPDN          baseObject;
    _enum2          scope;
    _enum3          derefAliases;
    unsigned int    sizeLimit;
    unsigned int    timeLimit;
    ossBoolean      typesOnly;
    Filter          filter;
    struct AttributeDescriptionList_ *attributes;
} SearchRequest;

typedef struct SearchResultEntry {
    LDAPDN          objectName;
    struct PartialAttributeList_ *attributes;
} SearchResultEntry;

typedef struct LDAPResult {
    unsigned char   bit_mask;
#       define      LDAPResult_referral_present 0x80
    _enum1          resultCode;
    LDAPDN          matchedDN;
    LDAPString      errorMessage;
    struct Referral_ *LDAPResult_referral;  /* optional */
} LDAPResult;

typedef LDAPResult      SearchResultDone;

typedef struct ModifyRequest {
    LDAPDN          object;
    struct ModificationList_ *modification;
} ModifyRequest;

typedef LDAPResult      ModifyResponse;

typedef struct AddRequest {
    LDAPDN          entry;
    struct AttributeList_ *attributes;
} AddRequest;

typedef LDAPResult      AddResponse;

typedef LDAPDN          DelRequest;

typedef LDAPResult      DelResponse;

typedef LDAPString      RelativeLDAPDN;

typedef struct ModifyDNRequest {
    unsigned char   bit_mask;
#       define      newSuperior_present 0x80
    LDAPDN          entry;
    RelativeLDAPDN  newrdn;
    ossBoolean      deleteoldrdn;
    LDAPDN          newSuperior;  /* optional */
} ModifyDNRequest;

typedef LDAPResult      ModifyDNResponse;

typedef struct CompareRequest {
    LDAPDN          entry;
    AttributeValueAssertion ava;
} CompareRequest;

typedef LDAPResult      CompareResponse;

typedef MessageID       AbandonRequest;

typedef struct LDAPOID {
    unsigned int    length;
    unsigned char   *value;
} LDAPOID;

typedef struct ExtendedRequest {
    LDAPOID         requestName;
    struct {
        unsigned int    length;
        unsigned char   *value;
    } requestValue;
} ExtendedRequest;

typedef struct ExtendedResponse {
    unsigned char   bit_mask;
#       define      ExtendedResponse_referral_present 0x80
#       define      responseName_present 0x40
#       define      response_present 0x20
    _enum1          resultCode;
    LDAPDN          matchedDN;
    LDAPString      errorMessage;
    struct Referral_ *ExtendedResponse_referral;  /* optional */
    LDAPOID         responseName;  /* optional */
    struct {
        unsigned int    length;
        unsigned char   *value;
    } response;  /* optional */
} ExtendedResponse;

typedef struct _choice1_1 {
    unsigned short  choice;
#       define      bindRequest_chosen 1
#       define      bindResponse_chosen 2
#       define      unbindRequest_chosen 3
#       define      searchRequest_chosen 4
#       define      searchResEntry_chosen 5
#       define      searchResDone_chosen 6
#       define      searchResRef_chosen 7
#       define      modifyRequest_chosen 8
#       define      modifyResponse_chosen 9
#       define      addRequest_chosen 10
#       define      addResponse_chosen 11
#       define      delRequest_chosen 12
#       define      delResponse_chosen 13
#       define      modDNRequest_chosen 14
#       define      modDNResponse_chosen 15
#       define      compareRequest_chosen 16
#       define      compareResponse_chosen 17
#       define      abandonRequest_chosen 18
#       define      extendedReq_chosen 19
#       define      extendedResp_chosen 20
    union _union {
        BindRequest     bindRequest;
        BindResponse    bindResponse;
        UnbindRequest   unbindRequest;
        SearchRequest   searchRequest;
        SearchResultEntry searchResEntry;
        SearchResultDone searchResDone;
        struct SearchResultReference_ *searchResRef;
        ModifyRequest   modifyRequest;
        ModifyResponse  modifyResponse;
        AddRequest      addRequest;
        AddResponse     addResponse;
        DelRequest      delRequest;
        DelResponse     delResponse;
        ModifyDNRequest modDNRequest;
        ModifyDNResponse modDNResponse;
        CompareRequest  compareRequest;
        CompareResponse compareResponse;
        AbandonRequest  abandonRequest;
        ExtendedRequest extendedReq;
        ExtendedResponse extendedResp;
    } u;
} _choice1_1;

typedef struct LDAPMsg {
    unsigned char   bit_mask;
#       define      controls_present 0x80
    MessageID       messageID;
    _choice1_1      protocolOp;
    struct Controls_ *controls;  /* optional */
} LDAPMsg;

typedef struct AttributeDescriptionList_ {
    struct AttributeDescriptionList_ *next;
    AttributeDescription value;
} *AttributeDescriptionList;

typedef struct AttributeValue {
    unsigned int    length;
    unsigned char   *value;
} AttributeValue;

typedef struct AttributeVals_ {
    struct AttributeVals_ *next;
    AttributeValue  value;
} *AttributeVals;

typedef struct Attribute {
    AttributeDescription type;
    struct AttributeVals_ *vals;
} Attribute;

typedef LDAPString      LDAPURL;

typedef struct Referral_ {
    struct Referral_ *next;
    LDAPURL         value;
} *Referral;

typedef struct Control {
    unsigned char   bit_mask;
#       define      criticality_present 0x80
    LDAPOID         controlType;
    ossBoolean      criticality;  /* default assumed if omitted */
    struct _octet4 {
        unsigned int    length;
        unsigned char   *value;
    } controlValue;
} Control;

typedef struct Controls_ {
    struct Controls_ *next;
    Control         value;
} *Controls;

typedef struct _choice1 {
    unsigned short  choice;
#       define      initial_chosen 1
#       define      any_chosen 2
#       define      final_chosen 3
    union _union {
        LDAPString      initial;
        LDAPString      any;
        LDAPString      final;
    } u;
} _choice1;

typedef struct SubstringFilterList_ {
    struct SubstringFilterList_ *next;
    _choice1        value;
} *SubstringFilterList;

typedef struct PagedResultsSearchControlValue {
    unsigned int    size;
    struct _octet4 {
        unsigned int    length;
        unsigned char   *value;
    } cookie;
} PagedResultsSearchControlValue;

typedef struct ReplicationSearchControlValue {
    unsigned int    flag;
    unsigned int    size;
    struct _octet4 {
        unsigned int    length;
        unsigned char   *value;
    } cookie;
} ReplicationSearchControlValue;

typedef struct SecurityDescriptorSearchControlValue {
    unsigned int    flags;
} SecurityDescriptorSearchControlValue;

typedef struct AttributeListElement {
    AttributeDescription type;
    struct AttributeVals_ *vals;
} AttributeListElement;

typedef struct PartialAttributeList_ {
    struct PartialAttributeList_ *next;
    AttributeListElement value;
} *PartialAttributeList;

typedef struct SearchResultReference_ {
    struct SearchResultReference_ *next;
    LDAPURL         value;
} *SearchResultReference;

typedef struct _choice3 {
    unsigned short  choice;
#       define      entry_chosen 1
#       define      reference_chosen 2
#       define      resultCode_chosen 3
    union _union {
        SearchResultEntry entry;
        struct SearchResultReference_ *reference;
        SearchResultDone resultCode;
    } u;
} _choice3;

typedef struct SearchResultFull_ {
    struct SearchResultFull_ *next;
    _choice3        value;
} *SearchResultFull;

typedef struct AttributeTypeAndValues {
    AttributeDescription type;
    struct _setof1 {
        struct _setof1  *next;
        AttributeValue  value;
    } *vals;
} AttributeTypeAndValues;

typedef enum _enum1_2 {
    add = 0,
    operation_delete = 1,
    replace = 2
} _enum1_2;

typedef struct ModificationList_ {
    struct ModificationList_ *next;
    struct {
        _enum1_2        operation;
        AttributeTypeAndValues modification;
    } value;
} *ModificationList;

typedef struct AttributeList_ {
    struct AttributeList_ *next;
    AttributeListElement value;
} *AttributeList;

typedef struct ProtectedPassword {
    unsigned char   bit_mask;
#       define      time1_present 0x80
#       define      time2_present 0x40
#       define      random1_present 0x20
#       define      random2_present 0x10
    UTCTime         time1;  /* optional */
    UTCTime         time2;  /* optional */
    struct {
        unsigned int    length;  /* number of significant bits */
        unsigned char   *value;
    } random1;  /* optional */
    struct {
        unsigned int    length;  /* number of significant bits */
        unsigned char   *value;
    } random2;  /* optional */
    LDAPOID         algorithmIdentifier;
    struct {
        unsigned int    length;  /* number of significant bits */
        unsigned char   *value;
    } encipheredPassword;
} ProtectedPassword;

typedef struct StrongCredentials {
    unsigned char   bit_mask;
#       define      certification_path_present 0x80
    CertificationPath certification_path;  /* optional */
    Token           bind_token;
} StrongCredentials;

typedef struct SortKeyList_ {
    struct SortKeyList_ *next;
    struct {
        unsigned char   bit_mask;
#           define      orderingRule_present 0x80
#           define      reverseOrder_present 0x40
        AttributeType   attributeType;
        MatchingRuleId  orderingRule;  /* optional */
        ossBoolean      reverseOrder;  /* default assumed if omitted */
    } value;
} *SortKeyList;

typedef enum _enum1_4 {
    sortSuccess = 0,
    sortOperationsError = 1,
    sortTimeLimitExceeded = 2,
    sortStrongAuthRequired = 8,
    sortAdminLimitExceeded = 11,
    sortNoSuchAttribute = 16,
    sortInappropriateMatching = 18,
    sortInsufficientAccessRights = 50,
    sortBusy = 51,
    sortUnwillingToPerform = 53,
    sortOther = 80
} _enum1_4;

typedef struct SortResult {
    unsigned char   bit_mask;
#       define      attributeType_present 0x80
    _enum1_4        sortResult;
    AttributeType   attributeType;  /* optional */
} SortResult;

extern ID ds;

extern ID attributeType;

extern ID matchingRule;

extern ID id_at;

extern ID id_mr;

extern ATTRIBUTE objectClass;

extern ATTRIBUTE aliasedEntryName;

extern MATCHING_RULE objectIdentifierMatch;

extern MATCHING_RULE distinguishedNameMatch;

extern ObjectID id_at_objectClass;

extern ObjectID id_at_aliasedEntryName;

extern ObjectID id_mr_objectIdentifierMatch;

extern ObjectID id_mr_distinguishedNameMatch;

extern int maxInt;


extern void *ldap;    /* encoder-decoder control table */
#ifdef __cplusplus
}	/* extern "C" */
#endif /* __cplusplus */
#endif /* OSS_ldap */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\cryptdll.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        cryptdll.h
//
// Contents:    How to use the crypt support dll
//
//
// History:     04 Jun 92   RichardW    Created
//
//------------------------------------------------------------------------

#ifndef __CRYPTDLL_H__
#define __CRYPTDLL_H__

typedef PVOID   PCRYPT_STATE_BUFFER;

typedef NTSTATUS (NTAPI * PCRYPT_INITIALIZE_FN)(
    PUCHAR,
    ULONG,
    ULONG,
    PCRYPT_STATE_BUFFER *
    );

typedef NTSTATUS (NTAPI * PCRYPT_ENCRYPT_FN)(
    PCRYPT_STATE_BUFFER StateBuffer,
    PUCHAR InputBuffer,
    ULONG InputBufferSize,
    PUCHAR OutputBuffer,
    PULONG OutputBufferSize
    );

typedef NTSTATUS (NTAPI * PCRYPT_DECRYPT_FN)(
    PCRYPT_STATE_BUFFER StateBuffer,
    PUCHAR InputBuffer,
    ULONG InputBufferSize,
    PUCHAR OutputBuffer,
    PULONG OutputBufferSize
    );

typedef NTSTATUS (NTAPI * PCRYPT_DISCARD_FN)(
    PCRYPT_STATE_BUFFER *
    );

typedef NTSTATUS (NTAPI * PCRYPT_HASH_STRING_FN)(
    PUNICODE_STRING String,
    PUCHAR Buffer
    );
typedef NTSTATUS (NTAPI * PCRYPT_RANDOM_KEY_FN)(
    OPTIONAL PUCHAR Seed,
    OPTIONAL ULONG SeedLength,
    PUCHAR Key
    );

typedef NTSTATUS (NTAPI * PCRYPT_CONTROL_FN)(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    );

//
// functions for CryptControl
#define CRYPT_CONTROL_SET_INIT_VECT     0x1


typedef struct _CRYPTO_SYSTEM {
    ULONG EncryptionType;
    ULONG BlockSize;
    ULONG ExportableEncryptionType;
    ULONG KeySize;
    ULONG HeaderSize;
    ULONG PreferredCheckSum;
    ULONG Attributes;
    PWSTR Name;
    PCRYPT_INITIALIZE_FN Initialize;
    PCRYPT_ENCRYPT_FN Encrypt;
    PCRYPT_DECRYPT_FN Decrypt;
    PCRYPT_DISCARD_FN Discard;
    PCRYPT_HASH_STRING_FN HashString;
    PCRYPT_RANDOM_KEY_FN RandomKey;
    PCRYPT_CONTROL_FN Control;
} CRYPTO_SYSTEM, *PCRYPTO_SYSTEM;

#define CSYSTEM_USE_PRINCIPAL_NAME      0x01
#define CSYSTEM_EXPORT_STRENGTH         0x02
#define CSYSTEM_INTEGRITY_PROTECTED     0x04

NTSTATUS NTAPI
CDRegisterCSystem(PCRYPTO_SYSTEM);

NTSTATUS NTAPI
CDBuildVect(
    PULONG EncryptionTypesAvailable,
    PULONG EncryptionTypes
    );

NTSTATUS NTAPI
CDBuildIntegrityVect(
    PULONG      pcCSystems,
    PULONG      pdwEtypes
    );


NTSTATUS NTAPI
CDLocateCSystem(
    ULONG EncryptionType,
    PCRYPTO_SYSTEM * CryptoSystem
    );


NTSTATUS NTAPI
CDFindCommonCSystem(
    ULONG EncryptionTypeCount,
    PULONG EncryptionTypes,
    PULONG CommonEncryptionType
    );

NTSTATUS NTAPI
CDFindCommonCSystemWithKey(
    IN ULONG EncryptionEntries,
    IN PULONG EncryptionTypes,
    IN ULONG KeyTypeCount,
    IN PULONG KeyTypes,
    OUT PULONG CommonEtype
    );



////////////////////////////////////////////////////////////////////

typedef PVOID PCHECKSUM_BUFFER;

typedef NTSTATUS (NTAPI * PCHECKSUM_INITIALIZE_FN)(ULONG, PCHECKSUM_BUFFER *);
typedef NTSTATUS (NTAPI * PCHECKSUM_INITIALIZEEX_FN)(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);
// add the ex2 function to allow the checksum to be passed in for verification
// this is passed in the 4th parameter
// this is necessary for checksums which use confounders, where the confounder must
// be pulled from the checksum in order to calculate a new checksum when verifying
typedef NTSTATUS (NTAPI * PCHECKSUM_INITIALIZEEX2_FN)(PUCHAR, ULONG, PUCHAR, ULONG, PCHECKSUM_BUFFER *);
typedef NTSTATUS (NTAPI * PCHECKSUM_SUM_FN)(PCHECKSUM_BUFFER, ULONG, PUCHAR);
typedef NTSTATUS (NTAPI * PCHECKSUM_FINALIZE_FN)(PCHECKSUM_BUFFER, PUCHAR);
typedef NTSTATUS (NTAPI * PCHECKSUM_FINISH_FN)(PCHECKSUM_BUFFER *);

typedef struct _CHECKSUM_FUNCTION {
    ULONG CheckSumType;
    ULONG CheckSumSize;
    ULONG Attributes;
    PCHECKSUM_INITIALIZE_FN Initialize;
    PCHECKSUM_SUM_FN Sum;
    PCHECKSUM_FINALIZE_FN Finalize;
    PCHECKSUM_FINISH_FN Finish;
    PCHECKSUM_INITIALIZEEX_FN InitializeEx;
    PCHECKSUM_INITIALIZEEX2_FN InitializeEx2;  // allows passing in the checksum on intialization for verification 
} CHECKSUM_FUNCTION, *PCHECKSUM_FUNCTION;

#define CKSUM_COLLISION     0x00000001
#define CKSUM_KEYED         0x00000002


#define CHECKSUM_SHA1       131

NTSTATUS NTAPI
CDRegisterCheckSum( PCHECKSUM_FUNCTION);


NTSTATUS NTAPI
CDLocateCheckSum( ULONG, PCHECKSUM_FUNCTION *);



//////////////////////////////////////////////////////////////



typedef BOOLEAN (NTAPI * PRANDOM_NUMBER_GENERATOR_FN)(PUCHAR, ULONG);


typedef struct _RANDOM_NUMBER_GENERATOR {
    ULONG GeneratorId;
    ULONG Attributes;
    ULONG Seed;
    PRANDOM_NUMBER_GENERATOR_FN GenerateBitstream;
} RANDOM_NUMBER_GENERATOR, *PRANDOM_NUMBER_GENERATOR;

#define RNG_PSEUDO_RANDOM   0x00000001  // Pseudo-random function
#define RNG_NOISE_CIRCUIT   0x00000002  // Noise circuit (ZNR diode, eg)
#define RNG_NATURAL_PHENOM  0x00000004  // Natural sampler (geiger counter)

BOOLEAN NTAPI
CDGenerateRandomBits(PUCHAR pBuffer,
                     ULONG  cbBuffer);

BOOLEAN NTAPI
CDRegisterRng(PRANDOM_NUMBER_GENERATOR    pRng);

BOOLEAN NTAPI
CDLocateRng(ULONG                       Id,
            PRANDOM_NUMBER_GENERATOR *    ppRng);

#define CD_BUILTIN_RNG  1


///////////////////////////////////////////////////////////
//
// Error codes
//
///////////////////////////////////////////////////////////


#define SEC_E_ETYPE_NOT_SUPP            0x80080341
#define SEC_E_CHECKSUM_NOT_SUPP         0x80080342
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\lhmatch.h ===
/*******************************************************************************
 *
 * LHMatch: A library to compute 'LH Matchings', a generalization of ordinary
 * bipartite matchings.
 *
 * Authors: Nicholas Harvey and Laszlo Lovasz
 * 
 * Developed: Nov 2000 - July 2001
 *
 * Problem Description:
 *
 * Let G=(U \union V, E) be a bipartite graph. We define an assignment
 * to be a set of edges, M \subset E, such that every u \member U has
 * deg_M(u)=1. For v \member V, deg_M(v) is unrestricted. An LH Matching is 
 * an assignment for which the variance of {deg_M(v):v \member V} is
 * minimized.
 *
 * Note that it is easy to compute an ordinary maximum cardinality bipartite
 * matching from a optimum relaxed matching: at each RHS-vertex, throw away
 * all of its matching edges but one.
 * 
 *******************************************************************************/


/***** Type Definitions *****/
typedef void* LHGRAPH;


/***** Graph Statistics *****/
typedef struct {
    /* numEdges: The total number of edges in the graph */
    int     numEdges;

    /* numMatchingEdges: The total number of matching edges */
    int     numMatchingEdges;

    /* matchingCost: The total cost of the current matching. The total cost
     * is defined to be the sum of the load of the matching on each of the
     * right-hand vertices. If a right-hand vertex has c matching partners,
     * the load at this vertex is c*(c+1)/2. */
    int     matchingCost;

    /* bipMatchingSize: If the current LH Matching were converted into a
     * bipartite matching, this would be the size of the bipartite matching. */
    int     bipMatchingSize;
} LHSTATS;


/***** Error Codes *****/
#define LH_SUCCESS           0
#define LH_INTERNAL_ERR      -1
#define LH_PARAM_ERR         -2
#define LH_MEM_ERR           -3
#define LH_MATCHING_ERR      -4
#define LH_EDGE_EXISTS       -5


/***** Algorithm Types *****/
/* The LHMatch library actually includes two algorithms to compute
 * LH Matchings: LHOnline, LHBFS.
 *
 * LHOnline is the simpler algorithm and also the slower one. It cannot 
 * incrementally improve an initial matching. Instead, it computes an optimal
 * matching from scratch each time it runs.
 *
 * LHBFS is faster than LHOnline but the implementation is more
 * complicated. It can take an existing matching as input and incrementally
 * improve it until it becomes optimal.
 */
typedef enum {
    LH_ALG_ONLINE,
    LH_ALG_BFS
} LHALGTYPE;
#define LH_ALG_DEFAULT       LH_ALG_BFS


/***** LHCreateGraph *****/
/*
 * Description:
 *
 *      Create a graph structure on which which to compute the matching.
 * 
 * Parameters:
 *
 *      IN  numLHSVtx   The number of vertices on the left-hand side of
 *                      the bipartite graph.
 *
 *      IN  numRHSVtx   The number of vertices on the right-hand side of
 *                      the bipartite graph.
 *
 *      OUT pGraph      On successful completion, pGraph will contain a
 *                      valid graph structure.
 *
 * Return Value:
 *
 *      Error Code
 */
int LHCreateGraph( int numLHSVtx, int numRHSVtx, LHGRAPH* pGraph );


/***** LHAddEdge *****/
/*
 * Description:
 *
 *      Add an edge to the graph connecting lhsVtx and rhsVtx
 *
 * Parameters:
 *
 *      IN  graph       A graph successfully created by LHGraphCreate.
 *      
 *      IN  lhsVtx      The ID of the left-hand vertex. Legal values are
 *                      0 <= lhsVtx < numLHSVtx
 *
 *      IN  rhsVtx      The ID of the right-hand vertex. Legal values are
 *                      0 <= rhsVtx < numRHSVtx
 *
 *  Return Value:
 *
 *      Error Code
 */
int LHAddEdge( LHGRAPH graph, int lhsVtx, int rhsVtx );


/***** LHSetMatchingEdge *****/
/*
 * Description:
 *
 *      Set the edge connecting lhsVtx and rhsVtx in the graph to be
 *      a matching edge. The edge (lhsVtx,rhsVtx) must have already been
 *      created with a call to LHVtxAddEdge.
 *
 *      Left-hand vertices may only have one matching edge. If lhsVtx
 *      already has a matching edge, that edge will be demoted from a
 *      matching edge to a normal edge. Right-hand vertices may have
 *      multiple matching edges.
 *      
 * Parameters:
 *
 *      IN  graph       A graph successfully created by LHGraphCreate.
 *      
 *      IN  lhsVtx      The ID of the left-hand vertex. Legal values are
 *                      0 <= lhsVtx < numLHSVtx
 *
 *      IN  rhsVtx      The ID of the right-hand vertex. Legal values are
 *                      0 <= rhsVtx < numRHSVtx
 *
 *  Return Value:
 *
 *      Error Code
 */
int LHSetMatchingEdge( LHGRAPH graph, int lhsVtx, int rhsVtx );


/***** LHGetDegree *****/
/*
 * Description:
 *
 *      Get the degree (number of neighbours) of a vertex.
 *      
 * Parameters:
 *
 *      IN  graph       A graph successfully created by LHGraphCreate.
 *      
 *      IN  vtxID       The ID of the vertex to examine.
 *
 *      IN  left        If the vertex to examine is a left-vertex, this
 *                      parameter should be TRUE. If the vertex is a right-
 *                      vertex, this parameter should be FALSE.
 *
 * Return Value:
 *
 *      >=0             The number of neighbours
 *
 *      <0              Error Code
 */
int LHGetDegree( LHGRAPH graph, int vtxID, char left );


/***** LHGetMatchedDegree *****/
/*
 * Description:
 *
 *      Get the matched degree (number of matched neighbours) of a
 *      right-hand vertex.
 *        
 * Parameters:
 *
 *      IN  graph           A graph successfully created by LHGraphCreate.
 *        
 *      IN  vtxID           The ID of the right hand vertex to examine.
 *
 * Return Value:
 *
 *      >=0                 The number of neighbours
 *
 *      <0                  Error Code
 */
int LHGetMatchedDegree( LHGRAPH graph, int vtxID );


/***** LHGetNeighbour *****/
/*
 * Description:
 *
 *      Get the n'th neighbour of the vertex specified by vtxID.
 *      
 * Parameters:
 *
 *      IN  graph       A graph successfully created by LHGraphCreate.
 *      
 *      IN  vtxID       The ID of the vertex to examine.
 *
 *      IN  left        If the vertex to examine is a left-vertex, this
 *                      parameter should be TRUE. If the vertex is a right-
 *                      vertex, this parameter should be FALSE.
 *
 *      IN  n           The index of the neighbour to retrieve. Legal values
 *                      are 0 <= n < Degree(vtxID).
 *
 *  Return Value:
 *
 *      >=0             The vertex ID of the n'th neighbour. If 'left' is TRUE,
 *                      this ID refers to a right-hand vertex. Conversely, if
 *                      'left' is FALSE, this ID refers to a left-hand vertex.
 *
 *      <0              Error Code
 */
int LHGetNeighbour( LHGRAPH graph, int vtxID, char left, int n );


/***** LHFindLHMatching *****/
/*
 * Description:
 *
 *      Find an optimal matching in the graph.
 *      
 * Parameters:
 *
 *      IN  graph       A graph successfully created by LHGraphCreate,
 *                      to which edges have been added using LHAddEdge.
 *
 *      IN  alg         Specifies which algorithm to use. For most purposes,
 *                      LH_ALG_DEFAULT is fine.
 *
 *  Return Value:
 *
 *      Error Code
 */
int LHFindLHMatching( LHGRAPH graph, LHALGTYPE alg );


/***** LHGetMatchedVtx *****/
/*
 * Description:
 *
 *      Determine which vertex on the right-hand side is matched to a
 *      given vertex on the left-hand side.
 *      
 * Parameters:
 *
 *      IN  graph       A graph successfully created by LHGraphCreate,
 *                      to which edges have been added using LHAddEdge.
 *
 *      IN  lhsVtx      The left-hand vertex to query.
 *
 *  Return Value:
 *
 *      >=0             The index of the right-hand vertex that is matched
 *                      with lhsVtx.
 *
 *      <0              Error Code. If LH_MATCHING_ERR is returned, then
 *                      lhsVtx is not matched with any right-hand vertex.
 */
int LHGetMatchedVtx( LHGRAPH graph, int lhsVtx );


/***** LHGetStatistics *****/
/*
 * Description:
 *
 *      Obtain statistics about the current matching.
 *      
 * Parameters:
 *
 *      IN  graph       A graph for which an LH Matching has been
 *                      computed using LHFindLHMatching().
 *
 *  Return Value:
 *
 *      Error Code
 */
int LHGetStatistics( LHGRAPH graph, LHSTATS *stats );


/***** LHClearMatching *****/
/*
 * Description:
 *
 *      Clear the current matching. All edges are demoted to normal edges.
 *      
 * Parameters:
 *
 *      IN  graph       A graph successfully created by LHGraphCreate,
 *                      to which edges have been added using LHAddEdge.
 *
 *  Return Value:
 *
 *      Error Code
 */
int LHClearMatching( LHGRAPH graph );


/***** LHDestroyGraph *****/
/*
 * Description:
 *
 *      Destroy the current graph.
 *      
 * Parameters:
 *
 *      IN  graph       A graph successfully created by LHGraphCreate.
 *
 *  Return Value:
 *
 *      Error Code
 */
int LHDestroyGraph( LHGRAPH graph );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\names.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    Names.h

Abstract:

    This module contains routines for dealing with network-related names.

Author:

    John Rogers (JohnRo) 15-Feb-1991

Revision History:

    19-Aug-1991 JohnRo
        Allow UNICODE use.
        Got rid of tabs in source file.
    20-Oct-1992 JohnRo
        RAID 9020: setup: PortUas fails ("prompt on conflicts" version).
    26-Jan-1993 JohnRo
        RAID 8683: PortUAS should set primary group from Mac parms.
    15-Apr-1993 JohnRo
        RAID 6167: avoid access violation or assert with WFW print server.

--*/

#ifndef _NAMES_
#define _NAMES_


#include <windef.h>             // BOOL, IN, LPTSTR, OUT, etc.


NET_API_STATUS
NetpGetPrimaryGroupFromMacField(
    IN  LPCTSTR   MacPrimaryField,      // name in "mGroup:" format.
    OUT LPCTSTR * GroupNamePtr          // alloc and set ptr.
    );

// This checks for "server" format (not "\\server").
BOOL
NetpIsComputerNameValid(
    IN LPTSTR ComputerName
    );

BOOL
NetpIsDomainNameValid(
    IN LPWSTR DomainName
    );

BOOL
NetpIsShareNameValid(
    IN LPTSTR ShareName
    );

BOOL
NetpIsGroupNameValid(
    IN LPTSTR GroupName
    );

// This checks for "mGroup:" format.
BOOL
NetpIsMacPrimaryGroupFieldValid(
    IN LPCTSTR MacPrimaryField
    );

BOOL
NetpIsPrintQueueNameValid(
    IN LPCTSTR QueueName
    );

// This checks for "\\server\share" format.
BOOL
NetpIsRemoteNameValid(
    IN LPTSTR RemoteName
    );

// This checks for "\\server" format.
BOOL
NetpIsUncComputerNameValid(
    IN LPTSTR ComputerName
    );

BOOL
NetpIsUserNameValid(
    IN LPTSTR UserName
    );

#endif // ndef _NAMES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\ndsclass.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NdsClass.h

Abstract:

    This module defines the NDS Class names supported by
    the NDS object manipulation API found in Nds32.h.

Author:

    Glenn Curtis    [GlennC]    15-Dec-1995

--*/

#ifndef __NDSCLASS_H
#define __NDSCLASS_H

/***********************************************/
/* Supported NetWare Directory Service Classes */
/***********************************************/

#define NDS_CLASS_AFP_SERVER         L"AFP Server"            /* Effective */
#define NDS_CLASS_ALIAS              L"Alias"                 /* Effective */
#define NDS_CLASS_BINDERY_OBJECT     L"Bindery Object"        /* Effective */
#define NDS_CLASS_BINDERY_QUEUE      L"Bindery Queue"         /* Effective */
#define NDS_CLASS_COMPUTER           L"Computer"              /* Effective */
#define NDS_CLASS_COUNTRY            L"Country"               /* Effective */
#define NDS_CLASS_DEVICE             L"Device"                /* Noneffective */
#define NDS_CLASS_DIRECTORY_MAP      L"Directory Map"         /* Effective */
#define NDS_CLASS_EXTERNAL_ENTITY    L"External Entity"       /* Effective */
#define NDS_CLASS_GROUP              L"Group"                 /* Effective */
#define NDS_CLASS_LIST               L"List"                  /* Effective */
#define NDS_CLASS_LOCALITY           L"Locality"              /* Effective */
#define NDS_CLASS_MESSAGE_ROUT_GROUP L"Message Routing Group" /* Effective */
#define NDS_CLASS_MESSAGING_SERVER   L"Messaging Server"      /* Effective */
#define NDS_CLASS_NCP_SERVER         L"NCP Server"            /* Effective */
#define NDS_CLASS_ORGANIZATION       L"Organization"          /* Effective */
#define NDS_CLASS_ORG_PERSON         L"Organizational Person" /* Noneffective */
#define NDS_CLASS_ORG_ROLE           L"Organizational Role"   /* Effective */
#define NDS_CLASS_ORG_UNIT           L"Organizational Unit"   /* Effective */
#define NDS_CLASS_PARTITION          L"Partition"             /* Noneffective */
#define NDS_CLASS_PERSON             L"Person"                /* Noneffective */
#define NDS_CLASS_PRINT_SERVER       L"Print Server"          /* Effective */
#define NDS_CLASS_PRINTER            L"Printer"               /* Effective */
#define NDS_CLASS_PROFILE            L"Profile"               /* Effective */
#define NDS_CLASS_QUEUE              L"Queue"                 /* Effective */
#define NDS_CLASS_RESOURCE           L"Resource"              /* Noneffective */
#define NDS_CLASS_SERVER             L"Server"                /* Noneffective */
#define NDS_CLASS_TOP                L"Top"                   /* Effective */
#define NDS_CLASS_UNKNOWN            L"Unknown"               /* Effective */
#define NDS_CLASS_USER               L"User"                  /* Effective */
#define NDS_CLASS_VOLUME             L"Volume"                /* Effective */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\nds32.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Nds32.h

Abstract:

    This module defines functions to access and manage Novell NDS Directory
    objects and attributes using the Microsoft NT Netware redirector.


    ---- NDS Object functions ----

    NwNdsAddObject
    NwNdsCloseObject
    NwNdsGetEffectiveRights
    NwNdsListSubObjects
    NwNdsModifyObject
    NwNdsMoveObject
    NwNdsOpenObject
    NwNdsReadObject
    NwNdsRemoveObject
    NwNdsRenameObject


    ---- NDS Buffer functions ----

    NwNdsCreateBuffer
    NwNdsFreeBuffer


    ---- NDS Marshaling functions to prepare or read data buffers ----

    NwNdsGetAttrDefListFromBuffer
    NwNdsGetAttrListFromBuffer
    NwNdsGetClassDefListFromBuffer
    NwNdsGetObjectListFromBuffer
    NwNdsPutInBuffer


    ---- NDS Schema functions ----

    NwNdsAddAttributeToClass
    NwNdsDefineAttribute
    NwNdsDefineClass
    NwNdsDeleteAttrDef
    NwNdsDeleteClassDef
    NwNdsGetSyntaxID
    NwNdsReadAttrDef
    NwNdsReadClassDef


    ---- NDS Schema functions under investigation ----

    NwNdsListContainableClasses(IN ParentObjectHandle,OUT ListOfClassNames);


    ---- NDS Search functions ----

    NwNdsCreateQueryNode
    NwNdsDeleteQueryNode
    NwNdsDeleteQueryTree
    NwNdsSearch


    ---- NDS Special functions ----

    NwNdsChangeUserPassword


    ---- NDS File functions under investigation ----

    NwNdsAddTrusteeToFile
    NwNdsAllocateFileHandle
    NwNdsDeallocateFileHandle
    NwNdsGetEffectiveDirectoryRights
    NwNdsGetObjectEffectiveRights
    NwNdsRemoveTrusteeFromFile


Author:

    Glenn Curtis    [GlennC]    15-Dec-1995
    Glenn Curtis    [GlennC]    04-Apr-1996 - Added Schema APIs

--*/

#ifndef __NDSOBJ32_H
#define __NDSOBJ32_H

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include "ndssntx.h"
#include "ndsattr.h"
#include "ndsclass.h"


/* Netware NDS general definitions */

#define NDS_MAX_NAME_CHARS           256
#define NDS_MAX_NAME_SIZE            ( NDS_MAX_NAME_CHARS * 2 )
#define NDS_MAX_SCHEMA_NAME_CHARS    32
#define NDS_MAX_SCHEMA_NAME_BYTES    ( 2 * ( NDS_MAX_SCHEMA_NAME_CHARS + 1 ) )
#define NDS_MAX_TREE_NAME_LEN        32
#define NDS_MAX_ASN1_NAME_LEN        32
#define NDS_NO_MORE_ITERATIONS       0xFFFFFFFF
#define NDS_INITIAL_SEARCH           0xFFFFFFFF


/* Netware NDS create buffer operations */

#define NDS_OBJECT_ADD               0
#define NDS_OBJECT_MODIFY            1
#define NDS_OBJECT_READ              2
#define NDS_OBJECT_LIST_SUBORDINATES 3
#define NDS_SCHEMA_DEFINE_CLASS      4
#define NDS_SCHEMA_READ_ATTR_DEF     5
#define NDS_SCHEMA_READ_CLASS_DEF    6
#define NDS_SEARCH                   7


/* Netware NDS attribute modification operations */

#define NDS_ATTR_ADD              0 /* Add first value to an attribute,
                                       error if it already exists */
#define NDS_ATTR_REMOVE           1 /* Remove all values from an attribute,
                                       error if attribute doesn't exist */
#define NDS_ATTR_ADD_VALUE        2 /* Add first or additional value to
                                       an attribute, error if duplicate */
#define NDS_ATTR_REMOVE_VALUE     3 /* Remove a value from an attribute,
                                       error if it doesn't exist */
#define NDS_ATTR_ADDITIONAL_VALUE 4 /* Add additional value to an attribute,
                                       error if duplicate or first value */
#define NDS_ATTR_OVERWRITE_VALUE  5 /* Add first or additional value to an
                                       attribute, overwrite if duplicate */
#define NDS_ATTR_CLEAR            6 /* Remove all values from an attribute,
                                       no error if attribute doesn't exist */
#define NDS_ATTR_CLEAR_VALUE      7 /* Remove a value from an attribute,
                                       no error if it doesn't exist */


/* Netware NDS schema attribute definition flags */

#define NDS_SINGLE_VALUED_ATTR      0x0001
#define NDS_SIZED_ATTR              0x0002
#define NDS_NONREMOVABLE_ATTR       0x0004 // Only for NwNDSReadAttributeDef
#define NDS_READ_ONLY_ATTR          0x0008 // Only for NwNDSReadAttributeDef
#define NDS_HIDDEN_ATTR             0x0010 // Only for NwNDSReadAttributeDef
#define NDS_STRING_ATTR             0x0020 // Only for NwNDSReadAttributeDef
#define NDS_SYNC_IMMEDIATE          0x0040
#define NDS_PUBLIC_READ             0x0080
#define NDS_SERVER_READ             0x0100 // Only for NwNDSReadAttributeDef
#define NDS_WRITE_MANAGED           0x0200
#define NDS_PER_REPLICA             0x0400


/* Netware NDS schema class definition flags */

#define NDS_CONTAINER_CLASS               0x01
#define NDS_EFFECTIVE_CLASS               0x02
#define NDS_NONREMOVABLE_CLASS            0x04
#define NDS_AMBIGUOUS_NAMING              0x08
#define NDS_AMBIGUOUS_CONTAINMENT         0x10


/* Netware NDS information flags */

#define NDS_INFO_NAMES                     0 // Search and Read operations
#define NDS_INFO_ATTR_NAMES_VALUES         1 // Search operations
#define NDS_INFO_NAMES_DEFS                1 // Read operations
#define NDS_CLASS_INFO_EXPANDED_DEFS       2 // Schema class definition only


/* Netware NDS information flags - NOT YET SUPPORTED */

#define NDS_CLASS_INFO                     3 // Schema class definition only


/* Netware NDS attribute right definitions */

#define NDS_RIGHT_COMPARE_ATTR             0x00000001L
#define NDS_RIGHT_READ_ATTR                0x00000002L
#define NDS_RIGHT_WRITE_ATTR               0x00000004L
#define NDS_RIGHT_ADD_SELF_ATTR            0x00000008L
#define NDS_RIGHT_SUPERVISE_ATTR           0x00000020L


/* Netware NDS object right definitions */

#define NDS_RIGHT_BROWSE_OBJECT            0x00000001L
#define NDS_RIGHT_CREATE_OBJECT            0x00000002L
#define NDS_RIGHT_DELETE_OBJECT            0x00000004L
#define NDS_RIGHT_RENAME_OBJECT            0x00000008L
#define NDS_RIGHT_SUPERVISE_OBJECT         0x00000010L


/* Netware file right definitions */

#define NW_RIGHTS WORD

#define NW_RIGHT_NONE                     0x0000
#define NW_RIGHT_READ_FROM_FILE           0x0001
#define NW_RIGHT_WRITE_TO_FILE            0x0002
#define NW_RIGHT_CREATE_DIR_OR_FILE       0x0008
#define NW_RIGHT_ERASE_DIR_OR_FILE        0x0010
#define NW_RIGHT_ACCESS_CONTROL           0x0020
#define NW_RIGHT_FILE_SCAN                0x0040
#define NW_RIGHT_MODIFY_DIR_OR_FILE       0x0080
#define NW_RIGHT_SUPERVISOR               0x0100
#define NW_RIGHT_ALL                      NW_RIGHT_READ_FROM_FILE     | \
                                          NW_RIGHT_WRITE_TO_FILE      | \
                                          NW_RIGHT_CREATE_DIR_OR_FILE | \
                                          NW_RIGHT_ERASE_DIR_OR_FILE  | \
                                          NW_RIGHT_ACCESS_CONTROL     | \
                                          NW_RIGHT_FILE_SCAN          | \
                                          NW_RIGHT_MODIFY_DIR_OR_FILE


/* Netware NDS query node operations for building a search query */

#define NDS_QUERY_OR                       0x00000001L
#define NDS_QUERY_AND                      0x00000002L
#define NDS_QUERY_NOT                      0x00000003L
#define NDS_QUERY_EQUAL                    0x00000007L
#define NDS_QUERY_GE                       0x00000008L
#define NDS_QUERY_LE                       0x00000009L
#define NDS_QUERY_APPROX                   0x0000000AL
#define NDS_QUERY_PRESENT                  0x0000000FL


/* Netware NDS search query scopes */

#define NDS_SCOPE_ONE_LEVEL                0x00000000L
#define NDS_SCOPE_SUB_TREE                 0x00000001L
#define NDS_SCOPE_BASE_LEVEL               0x00000002L


/* Netware NDS function return codes */

#define NDS_ERR_SUCCESS                     0x00000000
#define NDS_ERR_NO_SUCH_ENTRY               0xFFFFFDA7
#define NDS_ERR_NO_SUCH_VALUE               0xFFFFFDA6
#define NDS_ERR_NO_SUCH_ATTRIBUTE           0xFFFFFDA5
#define NDS_ERR_NO_SUCH_CLASS               0xFFFFFDA4
#define NDS_ERR_NO_SUCH_PARTITION           0xFFFFFDA3
#define NDS_ERR_ENTRY_ALREADY_EXISTS        0xFFFFFDA2
#define NDS_ERR_NOT_EFFECTIVE_CLASS         0xFFFFFDA1
#define NDS_ERR_ILLEGAL_ATTRIBUTE           0xFFFFFDA0
#define NDS_ERR_MISSING_MANDATORY           0xFFFFFD9F
#define NDS_ERR_ILLEGAL_DS_NAME             0xFFFFFD9E
#define NDS_ERR_ILLEGAL_CONTAINMENT         0xFFFFFD9D
#define NDS_ERR_CANT_HAVE_MULTIPLE_VALUES   0xFFFFFD9C
#define NDS_ERR_SYNTAX_VIOLATION            0xFFFFFD9B
#define NDS_ERR_DUPLICATE_VALUE             0xFFFFFD9A
#define NDS_ERR_ATTRIBUTE_ALREADY_EXISTS    0xFFFFFD99
#define NDS_ERR_MAXIMUM_ENTRIES_EXIST       0xFFFFFD98
#define NDS_ERR_DATABASE_FORMAT             0xFFFFFD97
#define NDS_ERR_INCONSISTANT_DATABASE       0xFFFFFD96
#define NDS_ERR_INVALID_COMPARISON          0xFFFFFD95
#define NDS_ERR_COMPARISON_FAILED           0xFFFFFD94
#define NDS_ERR_TRANSACTIONS_DISABLED       0xFFFFFD93
#define NDS_ERR_INVALID_TRANSPORT           0xFFFFFD92
#define NDS_ERR_SYNTAX_INVALID_IN_NAME      0xFFFFFD91
#define NDS_ERR_REPLICA_ALREADY_EXISTS      0xFFFFFD90
#define NDS_ERR_TRANSPORT_FAILURE           0xFFFFFD8F
#define NDS_ERR_ALL_REFERRALS_FAILED        0xFFFFFD8E
#define NDS_ERR_CANT_REMOVE_NAMING_VALUE    0xFFFFFD8D
#define NDS_ERR_OBJECT_CLASS_VIOLATION      0xFFFFFD8C
#define NDS_ERR_ENTRY_IS_NOT_LEAF           0xFFFFFD8B
#define NDS_ERR_DIFFERENT_TREE              0xFFFFFD8A
#define NDS_ERR_ILLEGAL_REPLICA_TYPE        0xFFFFFD89
#define NDS_ERR_SYSTEM_FAILURE              0xFFFFFD88
#define NDS_ERR_INVALID_ENTRY_FOR_ROOT      0xFFFFFD87
#define NDS_ERR_NO_REFERRALS                0xFFFFFD86
#define NDS_ERR_REMOTE_FAILURE              0xFFFFFD85
#define NDS_ERR_PREVIOUS_MOVE_IN_PROGRESS   0xFFFFFD83
#define NDS_ERR_INVALID_REQUEST             0xFFFFFD7F
#define NDS_ERR_INVALID_ITERATION           0xFFFFFD7E
#define NDS_ERR_SCHEMA_IS_NONREMOVABLE      0xFFFFFD7D
#define NDS_ERR_SCHEMA_IS_IN_USE            0xFFFFFD7C
#define NDS_ERR_CLASS_ALREADY_EXISTS        0xFFFFFD7B
#define NDS_ERR_BAD_NAMING_ATTRIBUTES       0xFFFFFD7A
#define NDS_ERR_NOT_ROOT_PARTITION          0xFFFFFD79
#define NDS_ERR_INSUFFICIENT_STACK          0xFFFFFD78
#define NDS_ERR_INSUFFICIENT_BUFFER         0xFFFFFD77
#define NDS_ERR_AMBIGUOUS_CONTAINMENT       0xFFFFFD76
#define NDS_ERR_AMBIGUOUS_NAMING            0xFFFFFD75
#define NDS_ERR_DUPLICATE_MANDATORY         0xFFFFFD74
#define NDS_ERR_DUPLICATE_OPTIONAL          0xFFFFFD73
#define NDS_ERR_MULTIPLE_REPLICAS           0xFFFFFD71
#define NDS_ERR_CRUCIAL_REPLICA             0xFFFFFD70
#define NDS_ERR_SCHEMA_SYNC_IN_PROGRESS     0xFFFFFD6F
#define NDS_ERR_SKULK_IN_PROGRESS           0xFFFFFD6E
#define NDS_ERR_TIME_NOT_SYNCRONIZED        0xFFFFFD6D
#define NDS_ERR_RECORD_IN_USE               0xFFFFFD6C
#define NDS_ERR_DS_VOLUME_NOT_MOUNTED       0xFFFFFD6B
#define NDS_ERR_DS_VOLUME_IO_FAILURE        0xFFFFFD6A
#define NDS_ERR_DS_LOCKED                   0xFFFFFD69
#define NDS_ERR_OLD_EPOCH                   0xFFFFFD68
#define NDS_ERR_NEW_EPOCH                   0xFFFFFD67
#define NDS_ERR_PARTITION_ROOT              0xFFFFFD65
#define NDS_ERR_ENTRY_NOT_CONTAINER         0xFFFFFD64
#define NDS_ERR_FAILED_AUTHENTICATION       0xFFFFFD63
#define NDS_ERR_NO_SUCH_PARENT              0xFFFFFD61
#define NDS_ERR_NO_ACCESS                   0xFFFFFD60
#define NDS_ERR_REPLICA_NOT_ON              0xFFFFFD5F
#define NDS_ERR_DUPLICATE_ACL               0xFFFFFD5A
#define NDS_ERR_PARTITION_ALREADY_EXISTS    0xFFFFFD59
#define NDS_ERR_NOT_SUBREF                  0xFFFFFD58
#define NDS_ERR_ALIAS_OF_AN_ALIAS           0xFFFFFD57
#define NDS_ERR_AUDITING_FAILED             0xFFFFFD56
#define NDS_ERR_INVALID_API_VERSION         0xFFFFFD55
#define NDS_ERR_SECURE_NCP_VIOLATION        0xFFFFFD54
#define NDS_ERR_FATAL                       0xFFFFFD45


/* Structure definitions used */

typedef struct _WSTR_LIST_ELEM
{
    struct _WSTR_LIST_ELEM * Next;
    LPWSTR                   szString;

} WSTR_LIST_ELEM, * LPWSTR_LIST;

typedef struct
{
    DWORD length;
    BYTE  data[NDS_MAX_ASN1_NAME_LEN];

} ASN1_ID, * LPASN1_ID;

//
// NDS Attribute Definition structure
//
typedef struct
{
    LPWSTR  szAttributeName;
    DWORD   dwFlags;
    DWORD   dwSyntaxID;
    DWORD   dwLowerLimit;
    DWORD   dwUpperLimit;
    ASN1_ID asn1ID;

} NDS_ATTR_DEF, * LPNDS_ATTR_DEF;

//
// NDS Class Definition structure
//
typedef struct
{
    LPWSTR  szClassName;
    DWORD   dwFlags;
    ASN1_ID asn1ID;
    DWORD   dwNumberOfSuperClasses;
    LPWSTR_LIST lpSuperClasses;
    DWORD   dwNumberOfContainmentClasses;
    LPWSTR_LIST lpContainmentClasses;
    DWORD   dwNumberOfNamingAttributes;
    LPWSTR_LIST lpNamingAttributes;
    DWORD   dwNumberOfMandatoryAttributes;
    LPWSTR_LIST lpMandatoryAttributes;
    DWORD   dwNumberOfOptionalAttributes;
    LPWSTR_LIST lpOptionalAttributes;

} NDS_CLASS_DEF, * LPNDS_CLASS_DEF;

//
// If read results from NwNdsReadAttrDef, or NwNdsReadClassDef
// returned names only (no attribute or class definitions),
// then an array of these NDS_DEF_NAME_ONLY structures is returned.
//
typedef struct
{
    LPWSTR szName;

} NDS_NAME_ONLY, * LPNDS_NAME_ONLY;

//
// NDS Attribute Information structure
//
typedef struct
{
    LPWSTR szAttributeName;
    DWORD  dwSyntaxId;
    DWORD  dwNumberOfValues;
    LPBYTE lpValue;

} NDS_ATTR_INFO, * LPNDS_ATTR_INFO;

//
// NDS Object Information structure
//
typedef struct
{
    LPWSTR szObjectFullName;
    LPWSTR szObjectName;
    LPWSTR szObjectClass;
    DWORD  dwEntryId;
    DWORD  dwModificationTime;
    DWORD  dwSubordinateCount;
    DWORD  dwNumberOfAttributes; // Zero for NwNdsReadObject results.
    LPVOID lpAttribute;          // For NwNdsSearch results, cast this
                                 // to either LPNDS_ATTR_INFO or
                                 // LPNDS_NAME_ONLY, depending on value of
                                 // lpdwAttrInformationType from call to
                                 // NwNdsGetObjectListFromBuffer.

} NDS_OBJECT_INFO, * LPNDS_OBJECT_INFO;

//
// tommye MS bug 88021 / MCS 
//
//	Moved this structure here from nw/nwlib/nds32.c so it could be 
//	accessed by NwNdsObjectHandleToConnHandle() in nw/nwlib/nwapi32.c.
//  Renamed it from NDS_OBJECT to NDS_OBJECT_PRIV to avoid conflict
//	with other structure of the same name.
//

typedef struct
{
    DWORD      Signature;
    HANDLE     NdsTree;
    DWORD      ObjectId;
    DWORD      ResumeId;
    DWORD      NdsRawDataBuffer;
    DWORD      NdsRawDataSize;
    DWORD      NdsRawDataId;
    DWORD      NdsRawDataCount;
    WCHAR      szContainerName[NDS_MAX_NAME_CHARS+4]; // add room for slashes and terminating null
    WCHAR      szRelativeName[NDS_MAX_NAME_CHARS+4]; // add room for slashes and terminating null

} NDS_OBJECT_PRIV, * LPNDS_OBJECT_PRIV;

//
// List Subordinate Objects Search Filter structures
//
typedef struct
{
    LPWSTR szObjectClass;

} NDS_FILTER, * LPNDS_FILTER;

typedef struct
{
    DWORD      dwNumberOfFilters;
    NDS_FILTER Filters[1];

} NDS_FILTER_LIST, * LPNDS_FILTER_LIST;

//
// NDS Search Query Tree structure
//
typedef struct _QUERY_NODE
{
    DWORD dwOperation;
    DWORD dwSyntaxId;
    struct _QUERY_NODE * lpLVal;
    struct _QUERY_NODE * lpRVal;

} QUERY_NODE, * LPQUERY_NODE, * LPQUERY_TREE;

//
// Given an NDS object handle, provides the NDS object ID
//
#define NwNdsGetObjectId(hObject)  (((LPNDS_OBJECT_PRIV) hObject)->ObjectId)

/* API definitions */

DWORD
NwNdsAddObject(
    IN  HANDLE hParentObject,
    IN  LPWSTR szObjectName,
    IN  HANDLE hOperationData );
/*
   NwNdsAddObject()

   This function is used to add a leaf object to an NDS directory tree.

   Arguments:

       HANDLE           hParentObject - A handle to the parent object in
                        the directory tree to add a new leaf to. Handle is
                        obtained by calling NwNdsOpenObject.

       LPWSTR           szObjectName - The directory name that the new leaf
                        object will be known by.

       HANDLE           hOperationData - A buffer containing a list of
                        attributes and values to create the new object. This
                        buffer is manipulated by the following functions:
                            NwNdsCreateBuffer (NDS_OBJECT_ADD),
                            NwNdsPutInBuffer, and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsAddAttributeToClass(
    IN  HANDLE   hTree,
    IN  LPWSTR   szClassName,
    IN  LPWSTR   szAttributeName );
/*
   NwNdsAddAttributeToClass()

   This function is used to modify the schema definition of a class by adding
   an optional attribute to a particular class. Modification of existing NDS
   class defintions is limited to only adding additional optional attributes.

   NOTE: Currently this function only supports one attribute addition at a time.
         It is possible to provide a version of this function that can add more
         than one attribute at a time, although I don't think it will be
         neccessary. Schema manipulation is considered to be an uncommon event.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szClassName - The name of the class definition to be
                        modified.

       LPWSTR           szAttributeName - The name of the attribute to be added
                        as an optional attribute to the class defintion in the
                        schema.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsChangeUserPassword(
    IN  HANDLE hUserObject,
    IN  LPWSTR szOldPassword,
    IN  LPWSTR szNewPassword );
/*
   NwNdsChangeUserPassword()

   This function is used to change the password for a given user object
   in a NDS directory tree.

   Arguments:

       HANDLE           hUserObject - A handle to a specific user object in
                        the directory tree to change the password on. Handle
                        is obtained by calling NwNdsOpenObject.

       LPWSTR           szOldPassword - The current password set on the user
                        object hUserObject.

                          - OR -

                        If NwNdsChangeUserPassword is called from a client with
                        administrative priveleges to the specified user object
                        identified by hUserObject, then the szOldPassword
                        value can be blank (L""). This way resetting the user
                        password to szNewPassword.

       LPWSTR           szNewPassword - The new password to be set on the user
                        object hUserObject.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsCloseObject(
    IN  HANDLE hObject );
/*
   NwNdsCloseObject()

   This function is used to close the handle used to manipulate an object
   in an NDS directory tree. The handle must be one Opened by NwNdsOpenObject.

   Arguments:

       HANDLE           hObject - The handle of the object to be closed.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsCreateBuffer(
    IN  DWORD    dwOperation,
    OUT HANDLE * lphOperationData );
/*
   NwNdsCreateBuffer()

   This function is used to create a buffer used to describe object
   transactions to a specific object in an NDS directory tree. This routine
   allocates memory and is automatically resized as needed during calls
   to NwNdsPutInBuffer. This buffer must be freed with NwNdsFreeBuffer.

   Arguments:

       DWORD            dwOperation - Indicates how buffer is to be utilized.
                        Use defined values NDS_OBJECT_ADD, NDS_OBJECT_MODIFY,
                        NDS_OBJECT_READ, NDS_SCHEMA_DEFINE_CLASS,
                        NDS_SCHEMA_READ_ATTR_DEF, NDS_SCHEMA_READ_CLASS_DEF,
                        or NDS_SEARCH.

       HANDLE *         lphOperationData - Address of a HANDLE handle to
                        receive created buffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsCreateQueryNode(
    IN  DWORD          dwOperation,
    IN  LPVOID         lpLValue,
    IN  DWORD          dwSyntaxId,
    IN  LPVOID         lpRValue,
    OUT LPQUERY_NODE * lppQueryNode
);
/*
   NwNdsCreateQueryNode()

   This function is used to generate a tree node that is part of a query
   to be used with the function NwNdsSearch.

   Arguments:

       DWORD            dwOperation - Indicates the type of node to create
                        for a search query. Use one of the defined values
                        below:

                          NDS_QUERY_OR 
                          NDS_QUERY_AND :
                            These operations must have both lpLValue and
                            lpRValue pointing to a QUERY_NODE structure.
                            In this case the dwSyntaxId value is ignored.
                        
                          NDS_QUERY_NOT :
                            This operation must have lpLValue pointing to a
                            QUERY_NODE structure and lpRValue set to NULL.
                            In this case the dwSyntaxId value is ignored.

                          NDS_QUERY_EQUAL
                          NDS_QUERY_GE
                          NDS_QUERY_LE
                          NDS_QUERY_APPROX :
                            These operations must have lpLValue pointing to
                            a LPWSTR containing the name of an NDS attribute,
                            and lpRValue pointing to an ASN1 structure defined
                            in NdsSntx.h. dwSyntaxId must be set to the syntax
                            identifier of the ASN1 structure pointed to by
                            lpRValue.

                          NDS_QUERY_PRESENT :
                            This operation must have lpLValue pointing to a
                            LPWSTR containing the name of an NDS attribute,
                            and lpRValue set to NULL. In this case the
                            dwSyntaxId value is ignored.

       LPVOID           lpLValue - A pointer to either a QUERY_NODE structure
                        or a LPWSTR depending on the value for dwOperation.

       DWORD            dwSyntaxId - The syntax identifier of the ASN1
                        structure pointed to by lpRValue for the dwOperations
                        NDS_QUERY_EQUAL, NDS_QUERY_GE, NDS_QUERY_LE, or
                        NDS_QUERY_APPROX. For other dwOperation values, this
                        is ignored.

       LPVOID           lpRValue - A pointer to either a QUERY_NODE structure,
                        an ASN1 structure, or NULL, depending on the value for
                        dwOperation.

       LPQUERY_NODE *   lppQueryNode - Address of a LPQUERY_NODE to receive
                        a pointer to created node.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsDefineAttribute(
    IN  HANDLE   hTree,
    IN  LPWSTR   szAttributeName,
    IN  DWORD    dwFlags,
    IN  DWORD    dwSyntaxID,
    IN  DWORD    dwLowerLimit,
    IN  DWORD    dwUpperLimit,
    IN  ASN1_ID  asn1ID );
/*
   NwNdsDefineAttribute()

   This function is used to create an attribute definition in the schema of
   NDS tree hTree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szAttributeName - The name that the new attribute will
                        be referred to by.

       DWORD            dwFlags - Flags values to be set for new attribute
                        definition. Definitions for flag values are found at
                        the top of this file.

       DWORD            dwSyntaxID - The ID of the syntax structure to be use
                        for the new attribute. Syntax IDs and their associated
                        structures are defined in the file NdsSntx.h. According
                        to the NetWare NDS schema spec, there is and always will
                        be, only 28 (0..27) different syntaxes.

       DWORD            dwLowerLimit - The lower limit of a sized attribute
                        (dwFlags value set to NDS_SIZED_ATTR). Can be set to
                        zero if attribute is not sized.

       DWORD            dwUpperLimit - The upper limit of a sized attribute
                        (dwFlags value set to NDS_SIZED_ATTR). Can be set to
                        zero if attribute is not sized.

       ASN1_ID          asn1ID - The ASN.1 ID for the attribute. If no
                        attribute identifier has been registered, a
                        zero-length octet string is specified.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsDefineClass(
    IN  HANDLE   hTree,
    IN  LPWSTR   szClassName,
    IN  DWORD    dwFlags,
    IN  ASN1_ID  asn1ID,
    IN  HANDLE   hSuperClasses,
    IN  HANDLE   hContainmentClasses,
    IN  HANDLE   hNamingAttributes,
    IN  HANDLE   hMandatoryAttributes,
    IN  HANDLE   hOptionalAttributes );
/*
   NwNdsDefineClass()

   This function is used to create a class definition in the schema of
   NDS tree hTree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szClassName - The name that the new class will
                        be referred to by.

       DWORD            dwFlags - Flags values to be set for new class
                        definition. Definitions for flag values are found at
                        the top of this file.

       ASN1_ID          asn1ID - The ASN.1 ID for the class. If no
                        class identifier has been registered, a
                        zero-length octet string is specified.

       HANDLE(S)        hSuperClasses,
                        hContainmentClasses,
                        hNamingAttributes,
                        hMandatoryAttributes,
                        hOptionalAttributes -

                        Handle to buffers that contain class definition
                        information to create new class in schema.
                        These handles are manipulated by the following
                        functions:
                           NwNdsCreateBuffer (NDS_SCHEMA_DEFINE_CLASS),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                - OR -

                        Handles can be NULL to indicate that no list
                        is associated with the specific class defintion
                        item.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsDeleteAttrDef(
    IN  HANDLE   hTree,
    IN  LPWSTR   szAttributeName );
/*
   NwNdsDeleteAttrDef()

   This function is used to remove an attribute definition from the schema of
   NDS tree hTree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szAttributeName - The name of the attribute
                        defintion to remove.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsDeleteClassDef(
    IN  HANDLE   hTree,
    IN  LPWSTR   szClassName );
/*
   NwNdsDeleteClassDef()

   This function is used to remove a class definition from the schema of
   NDS tree hTree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szClassName - The name of the class defintion to remove.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


VOID
NwNdsDeleteQueryNode(
    IN  LPQUERY_NODE lpQueryNode
);
/*
   NwNdsDeleteQueryNode()

   This function is used to free a tree node that was part of a query
   used with the function NwNdsSearch.

   Arguments:

       LPQUERY_NODE     lpQueryNode - A pointer to a particular node of
                        a query tree that defines a search.

    Returns:

       Nothing
*/


DWORD
NwNdsDeleteQueryTree(
    IN  LPQUERY_TREE lpQueryTree
);
/*
   NwNdsDeleteQueryTree()

   This function is used to free a tree that describes a query that was
   used with the function NwNdsSearch.

   Arguments:

       LPQUERY_TREE     lpQueryTree - A pointer to the root of a query
                        tree that defines a search. The tree is created
                        manually by the user through the function
                        NwNdsCreateQueryNode.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsFreeBuffer(
    IN  HANDLE hOperationData );
/*
   NwNdsFreeBuffer()

   This function is used to free the buffer used to describe object
   operations to a specific object in an NDS directory tree. The buffer must
   be one created by NwNdsCreateBuffer, or returned by calling NwNdsReadObject.

   Arguments:

       HANDLE            hOperationData - Handle to buffer that is to be freed.

    Returns:

       NO_ERROR
       one of the error codes defined in the file winerror.h
*/


DWORD
NwNdsGetAttrDefListFromBuffer(
    IN  HANDLE   hOperationData,
    OUT LPDWORD  lpdwNumberOfEntries,
    OUT LPDWORD  lpdwInformationType,
    OUT LPVOID * lppEntries );
/*
   NwNdsGetAttrDefListFromBuffer()

   This function is used to retrieve an array of attribute definition entries
   for a schema that was read with a prior call to NwNdsReadAttrDef.

   Arguments:

       HANDLE           hOperationData - Buffer containing the read
                        response from calling NwNdsReadAttrDef.

       LPDWORD          lpdwNumberOfEntries - The address of a DWORD to
                        receive the number of array elements pointed to by
                        lppEntries.

       LPDWORD          lpdwInformationType - The address of a DWORD to
                        receive a value that indicates the type of information
                        returned by the call to NwNdsReadAttrDef.

       LPVOID *         lppEntries - The address of a pointer to the beginning
                        of an array of attribute schema structures. Each
                        structure contains the details of each attribute
                        definition read from a given schema by calling
                        NwNdsReadAttrDef. The lppEntries value should be
                        cast to either a LPNDS_ATTR_DEF or LPNDS_NAME_ONLY
                        structure depending on the value returned in
                        lpdwInformationType.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsGetAttrListFromBuffer(
    IN  HANDLE            hOperationData,
    OUT LPDWORD           lpdwNumberOfEntries,
    OUT LPNDS_ATTR_INFO * lppEntries );
/*
   NwNdsGetAttrListFromBuffer()

   This function is used to retrieve an array of attribute entries for an
   object that was read with a prior call to NwNdsReadObject.

   Arguments:

       HANDLE           hOperationData - Buffer containing the read
                        response from calling NwNdsReadObject.

       LPDWORD          lpdwNumberOfEntries - The address of a DWORD to
                        receive the number of array elements pointed to by
                        lppEntries.

       LPNDS_ATTR_INFO *
                        lppEntries - The address of a pointer to the beginning
                        of an array of NDS_ATTR_INFO structures. Each
                        structure contains the details of each attribute read
                        from a given object by calling NwNdsReadObject.
  
    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsGetClassDefListFromBuffer(
    IN  HANDLE   hOperationData,
    OUT LPDWORD  lpdwNumberOfEntries,
    OUT LPDWORD  lpdwInformationType,
    OUT LPVOID * lppEntries );
/*
   NwNdsGetClassDefListFromBuffer()

   This function is used to retrieve an array of class definition entries
   for a schema that was read with a prior call to NwNdsReadClassDef.

   Arguments:

       HANDLE           hOperationData - Buffer containing the read
                        response from calling NwNdsReadClassDef.

       LPDWORD          lpdwNumberOfEntries - The address of a DWORD to
                        receive the number of array elements pointed to by
                        lppEntries.

       LPDWORD          lpdwInformationType - The address of a DWORD to
                        receive a value that indicates the type of information
                        returned by the call to NwNdsReadClassDef.

       LPVOID *         lppEntries - The address of a pointer to the beginning
                        of an array of schema class structures. Each
                        structure contains the details of each class
                        definition read from a given schema by calling
                        NwNdsReadClassDef. The lppEntries value should be
                        cast to either a LPNDS_CLASS_DEF or LPNDS_NAME_ONLY
                        structure depending on the value returned in
                        lpdwInformationType.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsGetEffectiveRights(
    IN  HANDLE hObject,
    IN  LPWSTR szSubjectName,
    IN  LPWSTR szAttributeName,
    OUT LPDWORD lpdwRights );
/*
   NwNdsGetEffectiveRights()

   This function is used to determine the effective rights of a particular
   subject on a particular object in the NDS tree. The user needs to have
   appropriate priveleges to make the determination.

   Arguments:

       HANDLE           hObject - A handle to the object in the directory
                        tree to determine effective rights on. Handle is
                        obtained by calling NwNdsOpenObject.

       LPWSTR           szSubjectName - The distinguished name of user whose
                        rights we're interested in determining.

       LPWSTR           szAttributeName - Regular attribute name (i.e.
                        L"Surname" , L"CN" ) for reading a particular
                        attribute right, or L"[All Attributes Rights]" and
                        L"[Entry Rights]" can be used to determine the default
                        attribute rights and object rights respectively.

       LPDWORD          lpdwRights - A pointer to a DWORD to receive the
                        results. If the call is successful, lpdwRights will
                        contain a mask representing the subject's rights:

                           Attribute rights -  NDS_RIGHT_COMPARE_ATTR,
                              NDS_RIGHT_READ_ATTR, NDS_RIGHT_WRITE_ATTR,
                              NDS_RIGHT_ADD_SELF_ATTR, and
                              NDS_RIGHT_SUPERVISE_ATTR.

                           Object rights - NDS_RIGHT_BROWSE_OBJECT,
                              NDS_RIGHT_CREATE_OBJECT, NDS_RIGHT_DELETE_OBJECT,
                              NDS_RIGHT_RENAME_OBJECT, and
                              NDS_RIGHT_SUPERVISE_OBJECT.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsGetObjectListFromBuffer(
    IN  HANDLE              hOperationData,
    OUT LPDWORD             lpdwNumberOfEntries,
    OUT LPDWORD             lpdwAttrInformationType OPTIONAL,
    OUT LPNDS_OBJECT_INFO * lppEntries );
/*
   NwNdsGetObjectListFromBuffer()

   This function is used to retrieve an array of object entries for
   objects that were read with a prior call to either
   NwNdsListSubObjects or NwNdsSearch.

   Arguments:

       HANDLE           hOperationData - Buffer containing the read
                        response from calling NwNdsListSubObjects, or a
                        buffer containing the search results from a call
                        to NwNdsSearch.

       LPDWORD          lpdwNumberOfEntries - The address of a DWORD to
                        receive the number of array elements pointed to by
                        lppEntries.

       LPDWORD          lpdwAttrInformationType - The address of a DWORD to
                        receive a value that indicates the type of attribute
                        information returned by the call to NwNdsSearch.
                        This attribute information type determines which
                        buffer structure (LPNDS_ATTR_INFO or LPNDS_NAME_ONLY)
                        should be used for the lpAttribute field found in
                        each NDS_OBJECT_INFO structure below.

                        - or -

                        NULL to indicate that the callee is not interested,
                        especially when the object list is that from a call
                        to NwNdsListSubObjects.

       LPNDS_OBJECT_INFO *
                        lppEntries - The address of a pointer to the beginning
                        of an array of NDS_OBJECT_INFO structures. Each
                        structure contains the details of each object returned
                        from a call to NwNdsListSubObjects or NwNdsSearch.
  
    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsGetSyntaxID(
    IN  HANDLE  hTree,
    IN  LPWSTR  szAttributeName,
    OUT LPDWORD lpdwSyntaxID );
/*
   NwNdsGetObjListFromBuffer()

   This function is used to retrieve the Syntax ID of a given attribute name.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szAttributeName - The attribute name whose Syntax ID
                        is requested.

       LPDWORD          lpdwSyntaxID - The address of a DWORD to receive the
                        SyntaxID.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsListSubObjects(
    IN  HANDLE   hParentObject,
    IN  DWORD    dwEntriesRequested,
    OUT LPDWORD  lpdwEntriesReturned,
    IN  LPNDS_FILTER_LIST lpFilters OPTIONAL,
    OUT HANDLE * lphOperationData );
/*
   NwNdsListSubObjects()

   This function is used to enumerate the subordinate objects for a particular
   parent object. A filter can be passed in to restrict enumeration to a
   a specific class type or list of class types.

   Arguments:

       HANDLE           hParentObject - A handle to the object in the directory
                        tree whose subordinate objects (if any) will be
                        enumerated.

       DWORD            dwEntriesRequested - The number of subordinate objects
                        to list. A subsequent call to NwNdsListSubObjects will
                        continue enumeration following the last item returned.

       LPDWORD          lpdwEntriesReturned - A pointer to a DWORD that will 
                        contain the actual number of subobjects enumerated in 
                        the call.

       LPNDS_FILTER_LIST lpFilters - The caller can specify the object class
                         names for the kinds of objects that they would like
                         to enumerate. For example if just User and Group
                         object classes should be enumerated, then a filter
                         for class names NDS_CLASS_USER and NDS_CLASS_GROUP
                         should be pass in.

                                - or -

                         NULL to indicate that all objects should be returned
                         (no filter).

       HANDLE *         lphOperationData - Address of a HANDLE handle to
                        receive created buffer that contains the list of
                        subordinate objects read from the object
                        hParentObject. This handle is manipulated by the
                        following functions:
                           NwNdsGetObjListFromBuffer and NwNdsFreeBuffer.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsModifyObject(
    IN  HANDLE hObject,
    IN  HANDLE hOperationData );
/*
   NwNdsModifyObject()

   This function is used to modify a leaf object in an NDS directory tree.
   Modifying a leaf object means: changing, adding, removing, and clearing of
   specified attributes for a given object.

   Arguments:

       HANDLE           hObject - A handle to the object in the directory
                        tree to be manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       HANDLE           hOperationData - A handle to data containing a
                        list of attribute changes to be applied to the object.
                        This buffer is manipulated by the following functions:
                           NwNdsCreateBuffer (NDS_OBJECT_MODIFY),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsMoveObject(
    IN  HANDLE hObject,
    IN  LPWSTR szDestObjectParentDN );
/*
   NwNdsMoveObject()

   This function is used to move a leaf object in an NDS directory tree
   from one container to another.

   Arguments:

       HANDLE           hObject - A handle to the object in the directory
                        tree to be moved. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szDestObjectParentDN - The DN of the object's new
                        parent.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsOpenObject(
    IN  LPWSTR   szObjectDN,
    IN  LPWSTR   szUserName OPTIONAL,
    IN  LPWSTR   szPassword OPTIONAL,
    OUT HANDLE * lphObject,
    OUT LPWSTR   szObjectName OPTIONAL,
    OUT LPWSTR   szObjectFullName OPTIONAL,
    OUT LPWSTR   szObjectClassName OPTIONAL,
    OUT LPDWORD  lpdwModificationTime OPTIONAL,
    OUT LPDWORD  lpdwSubordinateCount OPTIONAL );
/*
   NwNdsOpenObject()

   Arguments:

       LPWSTR           szObjectDN - The distinguished name of the object
                        that we want resolved into an object handle.

       LPWSTR           szUserName - The name of the user account to create
                        connection to object with.
                            - OR -
                        NULL to use the base credentials of the callee's LUID.

       LPWSTR           szPassword - The password of the user account to create
                        connection to object with. If password is blank, callee
                        should pass "".
                            - OR -
                        NULL to use the base credentials of the callee's LUID.

       HANDLE *         lphObject - The address of a HANDLE to receive
                        the handle of the object specified by
                        szObjectDN.

       Optional arguments: ( Callee can pass NULL in for these parameters to
                             indicate ignore )

       LPWSTR           szObjectName - A LPWSTR buffer to receive
                        the object's relative NDS name, or NULL if not
                        interested. The buffer for this string must be
                        provided by the user. Buffer should be at least
                        NDS_MAX_NAME_SIZE

       LPWSTR           szObjectFullName - A LPWSTR buffer to receive
                        the object's full NDS name (DN). The buffer for this
                        string must be provided by the user. Buffer should
                        be at least: (NW_MAX_NDS_NAME_LEN + 1 ) * sizeof(WCHAR)

       LPWSTR           szObjectClassName - A LPWSTR buffer to receive
                        the class name of the object opened. The buffer for this
                        string must be provided by the user. Buffer should
                        be at least: (NW_MAX_NDS_NAME_LEN + 1 ) * sizeof(WCHAR)

       LPDWORD          lpdwModificationTime -  The address of a DWORD to
                        receive the last date/time the object was modified.

       LPDWORD          lpdwSubordinateCount -  The address of a DWORD to
                        receive the number of subordinate objects that may
                        be found under szObjectDN, if it is a container object.

                        If szObjectDN is not a container, then the value is set
                        to zero. Although a value of zero does not imply
                        that object is not a container, it could just be empty.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsPutInBuffer(
    IN     LPWSTR szAttributeName,
    IN     DWORD  dwSyntaxID,
    IN     LPVOID lpAttributeValues,
    IN     DWORD  dwValueCount,
    IN     DWORD  dwAttrModificationOperation,
    IN OUT HANDLE hOperationData );
/*
   NwNdsPutInBuffer()

   This function is used to add an entry to the buffer used to describe
   an object attribute or change to an object attribute. The buffer must
   be created using NwNdsCreateBuffer. If the buffer was created using the
   operations, NDS_OBJECT_ADD, NDS_SCHEMA_DEFINE_CLASS,
   NDS_SCHEMA_READ_ATTR_DEF, or NDS_SCHEMA_READ_CLASS_DEF, then
   dwAttrModificationOperation is ignored. If the buffer was created using
   either the operation NDS_OBJECT_READ or NDS_SEARCH, then
   dwAttrModificationOperation, puAttributeType, and lpAttributeValue are
   all ingnored.

   Arguments:
  
       LPWSTR           szAttributeName - A NULL terminated WCHAR string
                        that contains name of the attribute value to be
                        added to the buffer. It can be a user supplied
                        string, or one of the  many defined string macros
                        in NdsAttr.h.

       DWORD            dwSyntaxID - The ID of the syntax structure used to
                        represent the attribute value. Syntax IDs and their
                        associated structures are defined in the file
                        NdsSntx.h. According to the NetWare NDS schema spec,
                        there is and always will be, only 28 (0..27)
                        different syntaxes.

       LPVOID           lpAttributeValues - A pointer to the beginning of a
                        buffer containing the value(s) for a particular
                        object attribute with data syntax dwSyntaxID.

       DWORD            dwValueCount - The number of value entries found in
                        buffer pointed to by lpAttributeValues.

       DWORD            dwAttrModificationOperation - If the buffer was created
                        using the operation NDS_MODIFY_OBJECT, then this is
                        used to desribe which type of modification operation
                        to apply for a given attribute. These attribute 
                        modification operations are defined near the beginning
                        of this file.

       HANDLE           hOperationData - A handle to data created by
                        calling NwNdsCreateBuffer. The buffer stores the
                        attributes used to define transactions for
                        NwNdsAddObject, NwNdsModifyObject, NwNdsReadAttrDef,
                        NwNdsReadClassDef, NwNdsReadObject or NwNdsSearch.

    Returns:

       NO_ERROR
       ERROR_NOT_ENOUGH_MEMORY
       ERROR_INVALID_PARAMETER
*/
 

DWORD
NwNdsReadAttrDef(
    IN     HANDLE   hTree,
    IN     DWORD    dwInformationType, // NDS_INFO_NAMES
                                       // or NDS_INFO_NAMES_DEFS
    IN OUT HANDLE * lphOperationData OPTIONAL );
/*
   NwNdsReadAttrDef()

   This function is used to read attribute definitions in the schema of an
   NDS directory tree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       DWORD            dwInformationType - Indicates whether user chooses to
                        read only the defined attribute name(s) in the schema or
                        read both the attribute name(s) and definition(s)
                        from the schema.

       HANDLE *         lphOperationData - The address of a HANDLE to data
                        containing a list of attribute names to be read from
                        the schema. This handle is manipulated by the following
                        functions:
                           NwNdsCreateBuffer (NDS_SCHEMA_READ_ATTR_DEF),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                            - OR -

                        The address of a HANDLE set to NULL, which indicates
                        that all attributes should be read from the schema.

                        If these calls are successful, this handle will also
                        contain the read results from the call. In the later
                        case, a buffer will be created to contain the read
                        results. Attribute values can be retrieved from the
                        buffer with the functions:
                            NwNdsGetAttrDefListFromBuffer
                           
                        After the call to this function, this buffer is ONLY
                        manipulated by the functions: 
                        NwNdsGetAttrDefListFromBuffer and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsReadClassDef(
    IN     HANDLE   hTree,
    IN     DWORD    dwInformationType, // NDS_INFO_NAMES,
                                       // NDS_INFO_NAMES_DEFS,
                                       // NDS_CLASS_INFO_EXPANDED_DEFS,
                                       // or NDS_CLASS_INFO
    IN OUT HANDLE * lphOperationData OPTIONAL );
/*
   NwNdsReadClassDef()

   This function is used to read class definitions in the schema of an
   NDS directory tree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       DWORD            dwInformationType - Indicates whether user chooses to
                        read only the defined class name(s) in the schema or
                        read both the class name(s) and definition(s) 
                        from the schema.

       HANDLE *         lphOperationData - The address of a HANDLE to data
                        containing a list of class names to be read from
                        the schema. This handle is manipulated by the following
                        functions:
                           NwNdsCreateBuffer (NDS_SCHEMA_READ_CLASS_DEF),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                            - OR -

                        The address of a HANDLE set to NULL, which indicates
                        that all classes should be read from the schema.

                        If these calls are successful, this handle will also
                        contain the read results from the call. In the later
                        case, a buffer will be created to contain the read
                        results. Class read results can be retrieved from the
                        buffer with the functions:
                            NwNdsGetClassDefListFromBuffer
                           
                        After the call to this function, this buffer is ONLY
                        manipulated by the functions: 
                        NwNdsGetClassDefListFromBuffer and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsReadObject(
    IN     HANDLE   hObject,
    IN     DWORD    dwInformationType, // NDS_INFO_NAMES
                                       // or NDS_INFO_ATTR_NAMES_VALUES
    IN OUT HANDLE * lphOperationData );
/*
   NwNdsReadObject()

   This function is used to read attributes about an object of an NDS
   directory tree.

   Arguments:

       HANDLE           hObject - A handle to the object in the directory
                        tree to be manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       DWORD            dwInformationType - Indicates whether user chooses to
                        read only the attribute name(s) on the object or
                        read both the attribute name(s) and value(s)
                        from the object.

       HANDLE *         lphOperationData - The address of a HANDLE to data
                        containing a list of attributes to be read from the
                        object hObject. This handle is manipulated by the
                        following functions:
                           NwNdsCreateBuffer (NDS_OBJECT_READ),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                            - OR -

                        The address of a HANDLE set to NULL, which indicates
                        that all object attributes should be read from object
                        hObject.

                        If these calls are successful, this handle will also
                        contain the read results from the call. In the later
                        case, a buffer will be created to contain the read
                        results. Attribute values can be retrieved from the
                        buffer with the functions:
                           NwNdsGetAttrListFromBuffer.

                        After the call to this function, this buffer is ONLY
                        manipulated by the functions: 
                           NwNdsGetAttrListFromBuffer and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsRemoveObject(
    IN  HANDLE hParentObject,
    IN  LPWSTR szObjectName );
/*
   NwNdsRemoveObject()

   This function is used to remove a leaf object from an NDS directory tree.

   Arguments:

       HANDLE           hParentObject - A handle to the parent object container
                        in the directory tree to remove leaf object from.
                        Handle is obtained by calling NwNdsOpenObject.

       LPWSTR           szObjectName - The directory name of the leaf object
                        to be removed.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsRenameObject(
    IN  HANDLE hParentObject,
    IN  LPWSTR szObjectName,
    IN  LPWSTR szNewObjectName,
    IN  BOOL   fDeleteOldName );
/*
   NwNdsRenameObject()

   This function is used to rename an object in a NDS directory tree.

   Arguments:

       HANDLE           hParentObject - A handle to the parent object container
                        in the directory tree to rename leaf object in.
                        Handle is obtained by calling NwNdsOpenObject.

       LPWSTR           szObjectName - The directory name of the object to be
                        renamed.

       LPWSTR           szNewObjectName - The new directory name of the object.

       BOOL             fDeleteOldName - If true, the old name is discarded;
                        Otherwise, the old name is retained as an additional
                        attribute.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/


DWORD
NwNdsSearch(
    IN     HANDLE       hStartFromObject,
    IN     DWORD        dwInformationType, // NDS_INFO_NAMES
                                           // or NDS_INFO_ATTR_NAMES_VALUES
    IN     DWORD        dwScope,
    IN     BOOL         fDerefAliases,
    IN     LPQUERY_TREE lpQueryTree,
    IN OUT LPDWORD      lpdwIterHandle,
    IN OUT HANDLE *     lphOperationData );
/*
   NwNdsSearch()

   This function is used to query an NDS directory tree to find objects of
   a certain object type that match a specified search filter.

   Arguments:

       HANDLE           hStartFromObject - A HANDLE to an object in the
                        directory tree to start search from. Handle is
                        obtained by calling NwNdsOpenObject.

       DWORD            dwScope -
                        NDS_SCOPE_ONE_LEVEL - Search subordinates from given
                                              object, one level only
                        NDS_SCOPE_SUB_TREE - Search from given object on down
                        NDS_SCOPE_BASE_LEVEL - Applies search to an object

       BOOL             fDerefAliases - If TRUE the search will dereference
                        aliased objects to the real objects and continue
                        to search in the aliased objects subtree. If FALSE
                        the search will not dereference aliases.

       LPQUERY_TREE     lpQueryTree - A pointer to the root of a search
                        tree which defines a query. This tree is manipulated
                        by the following functions:
                           NwNdsCreateQueryNode, NwNdsDeleteQueryNode,
                           and NwNdsDeleteQueryTree.

       LPDWORD          lpdwIterHandle - A pointer to a DWORD that has the
                        iteration handle value. On input, the handle value
                        is set to NDS_INITIAL_SEARCH or to a value previously
                        returned from a prior call to NwNdsSearch. On ouput,
                        the handle value is set to NDS_NO_MORE_ITERATIONS if
                        search is complete, or to some other value otherwise.

       HANDLE *         lphOperationData - The address of a HANDLE to data
                        containing a list of attributes to be read from the
                        objects that meet the search query. This handle is
                        manipulated by the following functions:
                           NwNdsCreateBuffer (NDS_SEARCH),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                            - OR -

                        The address of a HANDLE set to NULL, which indicates
                        that all object attributes should be read from the
                        search objects found.

                        If these calls are successful, this handle will also
                        contain the read results from the call. In the later
                        case, a buffer will be created to contain the read
                        results. Object information with attribute information
                        can be retrieved from the buffer with the function:
                           NwNdsGetObjectListFromBuffer.

                        After the call to this function, this buffer is ONLY
                        manipulated by the functions:
                          NwNdsGetObjectListFromBuffer,
                          and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/

#ifndef NWCONN_HANDLE
#define NWCONN_HANDLE        HANDLE
#endif

NWCONN_HANDLE
NwNdsObjectHandleToConnHandle(
	IN HANDLE ObjectHandle);

/*
   NwNdsObjectHandleToConnHandle()

   This function is used to get the NWCONN_HANDLE for a ObjectHandle 
   (like that returned from NwNdsOpenObject).

   Arguments:

       HANDLE           ObjectHandle - the handle to use to retrieve the NWCONN_HANDLE.

    Returns:

       NULL			- Call GetLastError for Win32 error code.
	   Otherwise	- NWCONN_HANDLE - this MUST be freed by the caller by the 
						NwNdsConnHandleFree routine.
*/

VOID
NwNdsConnHandleFree(
	IN NWCONN_HANDLE hConn);

/*
   NwNdsConnHandleFree()

	Frees the NWCONN_HANDLE returned from NwNdsObjectHandleToConnHandle().

   Arguments:

       IN NWCONN_HANDLE		Handle to free.

    Returns:
	   Nothing
*/

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\ndsattr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NdsAttr.h

Abstract:

    This module defines NDS Class names and NDS Attributes supported by
    the NDS object manipulation API found in Nds32.h.

Author:

    Glenn Curtis    [GlennC]    15-Dec-1995

--*/

#ifndef __NDSATTR_H
#define __NDSATTR_H


/**************************************************/
/* Supported NetWare Directory Service Attributes */
/**************************************************/

/*
  Account Balance:
    Single valued, nonremovable, sync immediate (4.1)
    (Counter)
*/
#define ACCOUNT_BALANCE_name        L"Account Balance"
#define ACCOUNT_BALANCE_syntax      NDS_SYNTAX_ID_22
#define NDS_ACCOUNT_BALANCE         ACCOUNT_BALANCE_name,ACCOUNT_BALANCE_syntax

/*
  ACL:
    Multivalued, nonremovable, Sync Immediate (4.1)
    (Object ACL)
*/
#define ACL_name                    L"ACL"
#define ACL_syntax                  NDS_SYNTAX_ID_17
#define NDS_ACL                     ACL_name,ACL_syntax

/*
  Aliased Object Name:
    Single valued, nonremovable, sync immediate (4.1)
    (Distinguished Name)
*/
#define ALIASED_OBJECT_NAME_name    L"Aliased Object Name"
#define ALIASED_OBJECT_NAME_syntax  NDS_SYNTAX_ID_1
#define NDS_ALIASED_OBJECT_NAME     ALIASED_OBJECT_NAME_name,ALIASED_OBJECT_NAME_syntax

/*
  Allow Unlimited Credit:
    Single valued, nonremovable, sync immediate (4.1)
    (Boolean)
*/
#define ALLOW_UNLIMITED_CREDIT_name     L"Allow Unlimited Credit"
#define ALLOW_UNLIMITED_CREDIT_syntax   NDS_SYNTAX_ID_7
#define NDS_ALLOW_UNLIMITED_CREDIT  ALLOW_UNLIMITED_CREDIT_name,ALLOW_UNLIMITED_CREDIT_syntax

/*
  Authority Revocation:
    Single valued, nonremovable, read only, sync immediate (4.1)
    (Octet String)
*/
#define AUTHORITY_REVOCATION_name   L"Authority Revocation"
#define AUTHORITY_REVOCATION_syntax NDS_SYNTAX_ID_9
#define NDS_AUTHORITY_REVOCATION    AUTHORITY_REVOCATION_name,AUTHORITY_REVOCATION_syntax

/*
  Back Link:
    Single valued, nonremovable, read only
    (Back Link)
*/
#define BACK_LINK_name              L"Back Link"
#define BACK_LINK_syntax            NDS_SYNTAX_ID_23
#define NDS_BACK_LINK               BACK_LINK_name,BACK_LINK_syntax

/*
  Bindery Object Restriction:
    Single valued, nonremovable, read only
    (Integer)
*/
#define BINDERY_OBJECT_RESTRICTION_name     L"Bindery Object Restriction"
#define BINDERY_OBJECT_RESTRICTION_syntax   NDS_SYNTAX_ID_8
#define NDS_BINDERY_OBJECT_RESTRICTION  BINDERY_OBJECT_RESTRICTION_name,BINDERY_OBJECT_RESTRICTION_syntax

/*
  Bindery Property:
    Multivalued, nonremovable, read only
    (Octet String)
*/
#define BINDERY_PROPERTY_name       L"Bindery Property"
#define BINDERY_PROPERTY_syntax     NDS_SYNTAX_ID_9
#define NDS_BINDERY_PROPERTY        BINDERY_PROPERTY_name,BINDERY_PROPERTY_syntax

/*
  Bindery Type:
    Single valued, nonremovable, read only
    (Numeric String)
*/
#define BINDERY_TYPE_name           L"Bindery Type"
#define BINDERY_TYPE_syntax         NDS_SYNTAX_ID_5
#define NDS_BINDERY_TYPE            BINDERY_TYPE_name,BINDERY_TYPE_syntax

/*
  C (Country):
    Single valued, nonremovable, sized attr (2,2), sync immediate (4.1)
    (Case Ignore String)
*/
#define COUNTRY_NAME_name           L"C"
#define COUNTRY_NAME_syntax         NDS_SYNTAX_ID_3
#define NDS_COUNTRY_NAME            COUNTRY_NAME_name,COUNTRY_NAME_syntax

/*
  CA Private Key:
    Single valued, nonremovable, sync immediate, hidden, read only
    (Octet String)
*/
#define CA_PRIVATE_KEY_name         L"CA Private Key"
#define CA_PRIVATE_KEY_syntax       NDS_SYNTAX_ID_9
#define NDS_CA_PRIVATE_KEY          CA_PRIVATE_KEY_name,CA_PRIVATE_KEY_syntax

/*
  CA Public Key:
    Single valued, nonremovable, sync immediate, public read, read only
    (Octet String)
*/
#define CA_PUBLIC_KEY_name          L"CA Public Key"
#define CA_PUBLIC_KEY_syntax        NDS_SYNTAX_ID_9
#define NDS_CA_PUBLIC_KEY           CA_PUBLIC_KEY_name,CA_PUBLIC_KEY_syntax

/*
  Cartridge:
    Multivalued, nonremovable, sync immediate (4.1)
    (Case Ignore String)
*/
#define CARTRIDGE_name              L"Cartridge"
#define CARTRIDGE_syntax            NDS_SYNTAX_ID_3
#define NDS_CARTRIDGE               CARTRIDGE_name,CARTRIDGE_syntax

/*
  Certificate Revocation:
    Single valued, nonremovable, sync immediate (4.1), read only
    (Octet String)
*/
#define CERTIFICATE_REVOCATION_name     L"Certificate Revocation"
#define CERTIFICATE_REVOCATION_syntax   NDS_SYNTAX_ID_9
#define NDS_CERTIFICATE_REVOCATION  CERTIFICATE_REVOCATION_name,CERTIFICATE_REVOCATION_syntax

/*
  CN (Common Name):
    Multivalued, nonremovable, sized attr (1..64), sync immediate (4.1)
    (Case Ignore String)
*/
#define COMMON_NAME_name            L"CN"
#define COMMON_NAME_syntax          NDS_SYNTAX_ID_3
#define NDS_COMMON_NAME             COMMON_NAME_name,COMMON_NAME_syntax

/*
  Convergence:
    Single valued, nonremovable, sized attr (0,1), sync immediate (4.1)
    (Integer)
*/
#define CONVERGENCE_name            L"Convergence"
#define CONVERGENCE_syntax          NDS_SYNTAX_ID_8
#define NDS_CONVERGENCE             CONVERGENCE_name,CONVERGENCE_syntax

/*
  Cross Certificate Pair:
    Multivalued, nonremovable, sync immediate (4.1)
    (Octet String)
*/
#define CROSS_CERTIFICATE_PAIR_name     L"Cross Certificate Pair"
#define CROSS_CERTIFICATE_PAIR_syntax   NDS_SYNTAX_ID_9
#define NDS_CROSS_CERTIFICATE_PAIR  CROSS_CERTIFICATE_PAIR_name,CROSS_CERTIFICATE_PAIR_syntax

/*
  Default Queue:
    Single valued, nonremovable, server read, sync immediate (4.1)
    (Distinguished Name)
*/
#define DEFAULT_QUEUE_name          L"Default Queue"
#define DEFAULT_QUEUE_syntax        NDS_SYNTAX_ID_1
#define NDS_DEFAULT_QUEUE           DEFAULT_QUEUE_name,DEFAULT_QUEUE_syntax

/*
  Description:
    Multivalued, nonremovable, sized attr (1..1024), sync immediate (4.1)
    (Case Ignore String)
*/
#define DESCRIPTION_name            L"Description"
#define DESCRIPTION_syntax          NDS_SYNTAX_ID_3
#define NDS_DESCRIPTION             DESCRIPTION_name,DESCRIPTION_syntax

/*
  Detect Intruder:
    Single valued, nonremovable, sync immediate (4.1)
    (Boolean)
*/
#define DETECT_INTRUDER_name        L"Detect Intruder"
#define DETECT_INTRUDER_syntax      NDS_SYNTAX_ID_
#define NDS_DETECT_INTRUDER         DETECT_INTRUDER_name,DETECT_INTRUDER_syntax

/*
  Device:
    Multivalued, nonremovable, sync immediate (4.1)
    (Distinguished Name)
*/
#define DEVICE_name                 L"Device"
#define DEVICE_syntax               NDS_SYNTAX_ID_1
#define NDS_DEVICE                  DEVICE_name,DEVICE_syntax

/*
  EMail Address:
    Multivalued, nonremovable, public read, sync immediate (4.1)
    (EMail Address)
*/
#define EMAIL_ADDRESS_name          L"EMail Address"
#define EMAIL_ADDRESS_syntax        NDS_SYNTAX_ID_14
#define NDS_EMAIL_ADDRESS           EMAIL_ADDRESS_name,EMAIL_ADDRESS_syntax

/*
  Equivalent To Me:
    Multivalued, nonremovable, server read, sync immediate
    (Distinguished Name)
*/
#define EQUIVALENT_TO_ME_name       L"Equivelent To Me"
#define EQUIVALENT_TO_ME_syntax     NDS_SYNTAX_ID_1
#define NDS_EQUIVALENT_TO_ME        EQUIVALENT_TO_ME_name,EQUIVALENT_TO_ME_syntax

/*
  Facsimile Telephone Number:
    Multivalued, nonremovable, sync immediate (4.1)
    (Facsimile Telephone Number)
*/
#define FAX_NUMBER_name             L"Facsimile Telephone Number"
#define FAX_NUMBER_syntax           NDS_SYNTAX_ID_11
#define NDS_FAX_NUMBER              FAX_NUMBER_name,FAX_NUMBER_syntax

/*
  Full Name:
    Multivalued, nonremovable, sized attr (0..127), sync immediate (4.1)
    (Case Ignore String)
*/
#define FULL_NAME_name              L"Full Name"
#define FULL_NAME_syntax            NDS_SYNTAX_ID_3
#define NDS_FULL_NAME               FULL_NAME_name,FULL_NAME_syntax

/*
  Generational Qualifier:
    Single valued, nonremovable, public read, sized attr (1..8), sync immediate
    (Case Ignore String)
*/
#define GENERATIONAL_QUALIFIER_name     L"Generational Qualifier"
#define GENERATIONAL_QUALIFIER_syntax   NDS_SYNTAX_ID_3
#define NDS_GENERATIONAL_QUALIFIER  GENERATIONAL_QUALIFIER_name,GENERATIONAL_QUALIFIER_syntax

/*
  GID (Group ID):
    Single valued, nonremovable, sync immediate (4.1)
    (Integer)
*/
#define GROUP_ID_name                   L"GID"
#define GROUP_ID_syntax                 NDS_SYNTAX_ID_8
#define GROUP_ID                        GROUP_ID_name,GROUP_ID_syntax

/*
  Given Name:
    Single valued, nonremovable, public read (4.1), sized attr (1..32),
    sync immediate
    (Case Ignore String)
*/
#define GIVEN_NAME_name             L"Given Name"
#define GIVEN_NAME_syntax           NDS_SYNTAX_ID_3
#define NDS_GIVEN_NAME              GIVEN_NAME_name,GIVEN_NAME_syntax

/*
  Group Membership:
    Multivalued, nonremovable, sync immediate, write managed
    (Distinguished Name)
*/
#define GROUP_MEMBERSHIP_name       L"Group Membership"
#define GROUP_MEMBERSHIP_syntax     NDS_SYNTAX_ID_1
#define NDS_GROUP_MEMBERSHIP        GROUP_MEMBERSHIP_name,GROUP_MEMBERSHIP_syntax

/*
  High Convergence Sync Interval:
    Single valued, nonremovable, sync immediate (4.1)
    (Interval)
*/
#define HIGH_CON_SYNC_INTERVAL_name     L"High Convergence Sync Interval"
#define HIGH_CON_SYNC_INTERVAL_syntax   NDS_SYNTAX_ID_27
#define NDS_HIGH_CON_SYNC_INTERVAL  HIGH_CON_SYNC_INTERVAL_name,HIGH_CON_SYNC_INTERVAL_syntax

/*
  Higher Privileges:
    Multivalued, nonremovable, sync immediate, write managed
    (Distinguished Name)
*/
#define HIGHER_PRIVILEGES_name      L"Higher Privileges"
#define HIGHER_PRIVILEGES_syntax    NDS_SYNTAX_ID_1
#define NDS_HIGHER_PRIVILEGES       HIGHER_PRIVILEGES_name,HIGHER_PRIVILEGES_syntax

/*
  Home Directory:
    Single valued, nonremovable, sized attr (1..255), sync immediate (4.1)
    (Path)
*/
#define HOME_DIRECTORY_name         L"Home Directory"
#define HOME_DIRECTORY_syntax       NDS_SYNTAX_ID_15
#define NDS_HOME_DIRECTORY          HOME_DIRECTORY_name,HOME_DIRECTORY_syntax

/*
  Host Device:
    Single valued, nonremovable, sync immediate (4.1)
    (Distinguished Name)
*/
#define HOST_DEVICE_name            L"Host Device"
#define HOST_DEVICE_syntax          NDS_SYNTAX_ID_1
#define NDS_HOST_DEVICE             HOST_DEVICE_name,HOST_DEVICE_syntax

/*
  Host Resource Name:
    Single valued, nonremovable, sync immediate (4.1)
    (Case Ignore String)
*/
#define HOST_RESOURCE_NAME_name     L"Host Resource Name"
#define HOST_RESOURCE_NAME_syntax   NDS_SYNTAX_ID_3
#define NDS_HOST_RESOURCE_NAME      HOST_RESOURCE_NAME_name,HOST_RESOURCE_NAME_syntax

/*
  Host Server:
    Single valued, nonremovable, sync immediate (4.1)
    (Distinguished Name)
*/
#define HOST_SERVER_name            L"Host Server"
#define HOST_SERVER_syntax          NDS_SYNTAX_ID_1
#define NDS_HOST_SERVER             HOST_SERVER_name,HOST_SERVER_syntax

/*
  Inherited ACL:
    Multivalued, nonremovable, read only, sync immediate (4.1)
    (Object ACL)
*/
#define INHERITED_ACL_name          L"Inherited ACL"
#define INHERITED_ACL_syntax        NDS_SYNTAX_ID_17
#define NDS_INHERITED_ACL           INHERITED_ACL_name,INHERITED_ACL_syntax

/*
  Initials:
    Single valued, nonremovable, public read, sized attr (1..8), sync immediate
    (Case Ignore String)
*/
#define INITIALS_name               L"Initials"
#define INITIALS_syntax             NDS_SYNTAX_ID_3
#define NDS_INITIALS                INITIALS_name,INITIALS_syntax

/*
  Intruder Attempt Reset Interval:
    Single valued, nonremovable, sync immediate (4.1)
    (Interval)
*/
#define INTRUDER_ATTEMPT_RESET_INTERVAL_name L"Intruder Attempt Reset Interval"
#define INTRUDER_ATTEMPT_RESET_INTERVAL_syntax NDS_SYNTAX_ID_27
#define NDS_INTRUDER_ATTEMPT_RESET_INTERVAL INTRUDER_ATTEMPT_RESET_INTERVAL_name,INTRUDER_ATTEMPT_RESET_INTERVAL_syntax

/*
  Intruder Lockout Reset Interval:
    Single valued, nonremovable, sync immediate (4.1)
    (Interval)
*/
#define INTRUDER_LOCKOUT_RESET_INTERVAL_name L"Intruder Lockout Reset Interval"
#define INTRUDER_LOCKOUT_RESET_INTERVAL_syntax NDS_SYNTAX_ID_27
#define NDS_INTRUDER_LOCKOUT_RESET_INTERVAL INTRUDER_LOCKOUT_RESET_INTERVAL_name,INTRUDER_LOCKOUT_RESET_INTERVAL_syntax

/*
  L (Locality):
    Multi valued, nonremovable, sync immediate (4.1)
    (Case Ignore String)
*/
#define LOCALITY_NAME_name          L"L"
#define LOCALITY_NAME_syntax        NDS_SYNTAX_ID_3
#define NDS_LOCALITY_NAME           LOCALITY_NAME_name,LOCALITY_NAME_syntax

/*
  Language:
    Single valued, nonremovable, sync immediate (4.1)
    (Case Ignore List)
*/
#define LANGUAGE_name               L"Language"
#define LANGUAGE_syntax             NDS_SYNTAX_ID_6
#define NDS_LANGUAGE                LANGUAGE_name,LANGUAGE_syntax

/*
  Login Allowed Time Map:
    A 42 byte buffer (6 Time Intervals X 7 Days)
    1 Time Interval = 1 Byte = 4 Hours
    First Byte = Saturday, 4:00 PM
    If Byte = 0xFF, then access is allowed (4 hrs).
    If Byte = 0x00, then access is not allowed (4 hrs).
    Each bit represents a 1/2 hour time interval.
    Single valued, nonremovable, sized attr (42,42), sync immediate (4.1)
    (Octet String)
*/
#define LOGIN_ALLOWED_TIME_MAP_name     L"Login Allowed Time Map"
#define LOGIN_ALLOWED_TIME_MAP_syntax   NDS_SYNTAX_ID_9
#define NDS_LOGIN_ALLOWED_TIME_MAP  LOGIN_ALLOWED_TIME_MAP_name,LOGIN_ALLOWED_TIME_MAP_syntax

/*
  Login Disabled:
    Single valued, nonremovable, sync immediate (4.1)
    (Boolean)
*/
#define LOGIN_DISABLED_name         L"Login Disabled"
#define LOGIN_DISABLED_syntax       NDS_SYNTAX_ID_7
#define NDS_LOGIN_DISABLED          LOGIN_DISABLED_name,LOGIN_DISABLED_syntax

/*
  Login Expiration Time:
    Single valued, nonremovable, sync immediate (4.1)
    (Time)
*/
#define LOGIN_EXPIRATION_TIME_name      L"Login Expiration Time"
#define LOGIN_EXPIRATION_TIME_syntax    NDS_SYNTAX_ID_24
#define NDS_LOGIN_EXPIRATION_TIME   LOGIN_EXPIRATION_TIME_name,LOGIN_EXPIRATION_TIME_syntax

/*
  Login Grace Limit:
    Single valued, nonremovable, sync immediate (4.1)
    (Integer)
*/
#define LOGIN_GRACE_LIMIT_name      L"Login Grace Limit"
#define LOGIN_GRACE_LIMIT_syntax    NDS_SYNTAX_ID_8
#define NDS_LOGIN_GRACE_LIMIT       LOGIN_GRACE_LIMIT_name,LOGIN_GRACE_LIMIT_syntax

/*
  Login Grace Remaining:
    Single valued, nonremovable, sync immediate (4.1)
    (Counter)
*/
#define LOGIN_GRACE_REMAINING_name      L"Login Grace Remaining"
#define LOGIN_GRACE_REMAINING_syntax    NDS_SYNTAX_ID_22
#define NDS_LOGIN_GRACE_REMAINING   LOGIN_GRACE_REMAINING_name,LOGIN_GRACE_REMAINING_syntax

/*
  Login Maximum Simultaneous:
    Single valued, nonremovable, sync immediate (4.1)
    (Integer)
*/
#define LOGIN_MAXIMUM_SIMULTANEOUS_name     L"Login Maximum Simultaneous"
#define LOGIN_MAXIMUM_SIMULTANEOUS_syntax   NDS_SYNTAX_ID_8
#define NDS_LOGIN_MAXIMUM_SIMULTANEOUS  LOGIN_MAXIMUM_SIMULTANEOUS_name,LOGIN_MAXIMUM_SIMULTANEOUS_syntax

/*
  Mailbox Id:
    Single valued, nonremovable, public read, sized attr (1..8), sync immediate
    (Case Ignore String)
*/
#define MAILBOX_ID_name             L"Mailbox ID"
#define MAILBOX_ID_syntax           NDS_SYNTAX_ID_3
#define NDS_MAILBOX_ID              MAILBOX_ID_name,MAILBOX_ID_syntax

/*
  Member:
    Multivalued, nonremovable, sync immediate (4.1)
    (Distinguished Name)
*/
#define MEMBER_name                 L"Member"
#define MEMBER_syntax               NDS_SYNTAX_ID_1
#define NDS_MEMBER                  MEMBER_name,MEMBER_syntax

/*
  Messaging Server:
    Multivalued, nonremovable, sync immediate
    (Distinguished Name)
*/
#define MESSAGING_SERVER_name       L"Messaging Server"
#define MESSAGING_SERVER_syntax     NDS_SYNTAX_ID_1
#define NDS_MESSAGING_SERVER        MESSAGING_SERVER_name,MESSAGING_SERVER_syntax

/*
  Minimum Accout Balance:
    Single valued, nonremovable, sync immediate (4.1)
    (Integer)
*/
#define MINIMUM_ACCOUNT_BALANCE_name    L"Minimum Account Balance"
#define MINIMUM_ACCOUNT_BALANCE_syntax  NDS_SYNTAX_ID_8
#define NDS_MINIMUM_ACCOUNT_BALANCE MINIMUM_ACCOUNT_BALANCE_name,MINIMUM_ACCOUNT_BALANCE_syntax

/*
  O (Organization):
    Multivalued, nonremovable, sized attr (1..64), sync immediate (4.1)
    (Case Ignore String)
*/
#define ORGANIZATION_NAME_name      L"O"
#define ORGANIZATION_NAME_syntax    NDS_SYNTAX_ID_3
#define NDS_ORGANIZATION_NAME       ORGANIZATION_NAME_name,ORGANIZATION_NAME_syntax

/*
  Object Class:
    Multivalued, nonremovable, read only, sync immediate (4.1)
    (Class Name)
*/
#define OBJECT_CLASS_name           L"Object Class"
#define OBJECT_CLASS_syntax         NDS_SYNTAX_ID_20
#define NDS_OBJECT_CLASS            OBJECT_CLASS_name,OBJECT_CLASS_syntax

/*
  OU (Organizational Unit):
    Multivalued, nonremovable, sized attr (1..64), sync immediate (4.1)
    (Case Ignore String)
*/
#define ORGANIZATIONAL_UNIT_NAME_name   L"OU"
#define ORGANIZATIONAL_UNIT_NAME_syntax NDS_SYNTAX_ID_3
#define NDS_ORGANIZATIONAL_UNIT_NAME ORGANIZATIONAL_UNIT_NAME_name,ORGANIZATIONAL_UNIT_NAME_syntax

/*
  Owner:
    Multivalued, nonremovable, sync immediate (4.1)
    (Distinguished Name)
*/
#define OWNER_name                  L"Owner"
#define OWNER_syntax                NDS_SYNTAX_ID_1
#define NDS_OWNER                   OWNER_name,OWNER_syntax

/*
  Password Allow Change:
    Single valued, nonremovable, sync immediate (4.1)
    (Boolean)
*/
#define PASSWORD_ALLOW_CHANGE_name      L"Password Allow Change"
#define PASSWORD_ALLOW_CHANGE_syntax    NDS_SYNTAX_ID_7
#define NDS_PASSWORD_ALLOW_CHANGE   PASSWORD_ALLOW_CHANGE_name,PASSWORD_ALLOW_CHANGE_syntax

/*
  Password Expiration Interval:
    Single valued, nonremovable, sync immediate (4.1)
    (Interval)
*/
#define PASSWORD_EXPIRATION_INTERVAL_name   L"Password Expiration Interval"
#define PASSWORD_EXPIRATION_INTERVAL_syntax NDS_SYNTAX_ID_27
#define NDS_PASSWORD_EXPIRATION_INTERVAL    PASSWORD_EXPIRATION_INTERVAL_name,PASSWORD_EXPIRATION_INTERVAL_syntax

/*
  Password Expiration Time:
    Single valued, nonremovable, sync immediate (4.1)
    (Time)
*/
#define PASSWORD_EXPIRATION_TIME_name   L"Password Expiration Time"
#define PASSWORD_EXPIRATION_TIME_syntax NDS_SYNTAX_ID_24
#define NDS_PASSWORD_EXPIRATION_TIME     PASSWORD_EXPIRATION_TIME_name,PASSWORD_EXPIRATION_TIME_syntax

/*
  Password Minimun Length:
    Single valued, nonremovable, sync immediate (4.1)
    (Integer)
*/
#define PASSWORD_MINIMUM_LENGTH_name    L"Password Minimum Length"
#define PASSWORD_MINIMUM_LENGTH_syntax  NDS_SYNTAX_ID_8
#define NDS_PASSWORD_MINIMUM_LENGTH     PASSWORD_MINIMUM_LENGTH_name,PASSWORD_MINIMUM_LENGTH_syntax

/*
  Password Required:
    Single valued, nonremovable, sync immediate (4.1)
    (Boolean)
*/
#define PASSWORD_REQUIRED_name      L"Password Required"
#define PASSWORD_REQUIRED_syntax    NDS_SYNTAX_ID_7
#define NDS_PASSWORD_REQUIRED       PASSWORD_REQUIRED_name,PASSWORD_REQUIRED_syntax

/*
  Password Unique Required:
    Single valued, nonremovable, sync immediate (4.1)
    (Boolean)
*/
#define PASSWORD_UNIQUE_REQUIRED_name   L"Password Unique Required"
#define PASSWORD_UNIQUE_REQUIRED_syntax NDS_SYNTAX_ID_7
#define NDS_PASSWORD_UNIQUE_REQUIRED PASSWORD_UNIQUE_REQUIRED_name,PASSWORD_UNIQUE_REQUIRED_syntax

/*
  Physical Delivery Office Name:
    Multivalued, nonremovable, sized attr (1..128), sync immediate (4.1)
    (Case Ignore String)
*/
#define CITY_NAME_name                  L"Physical Delivery Office Name"
#define CITY_NAME_syntax                NDS_SYNTAX_ID_3
#define NDS_PHYSICAL_DELIVERY_OFFICE_NAME   CITY_NAME_name,CITY_NAME_syntax

/*
  Postal Address:
    Multivalued, nonremovable, sync immediate (4.1)
    (Postal Address)
*/
#define POSTAL_ADDRESS_name             L"Postal Address"
#define POSTAL_ADDRESS_syntax           NDS_SYNTAX_ID_18
#define NDS_POSTAL_ADDRESS              POSTAL_ADDRESS_name,POSTAL_ADDRESS_syntax

/*
  Postal Code:
    Multivalued, nonremovable, sized attr (0..40), sync immediate (4.1)
    (Case Ignore String)
*/
#define POSTAL_CODE_name                L"Postal Code"
#define POSTAL_CODE_syntax              NDS_SYNTAX_ID_3
#define NDS_POSTAL_CODE                 POSTAL_CODE_name,POSTAL_CODE_syntax

/*
  Postal Office Box:
    Multivalued, nonremovable, sized attr (0..40), sync immediate (4.1)
    (Case Ignore String)
*/
#define POSTAL_OFFICE_BOX_name          L"Postal Office Box"
#define POSTAL_OFFICE_BOX_syntax        NDS_SYNTAX_ID_3
#define NDS_POSTAL_OFFICE_BOX           POSTAL_OFFICE_BOX_name,POSTAL_OFFICE_BOX_syntax

/*
  Profile:
    Single valued, nonremovable, sync immediate (4.1)
    (Distinguished Name)
*/
#define PROFILE_name                    L"Profile"
#define PROFILE_syntax                  NDS_SYNTAX_ID_1
#define NDS_PROFILE                     PROFILE_name,PROFILE_syntax

/*
  S (State Or Province):
    Multivalued, nonremovable, sized attr (1..128), sync immediate (4.1)
    (Case Ignore String)
*/
#define STATE_OR_PROVINCE_NAME_name     L"S"
#define STATE_OR_PROVINCE_NAME_syntax   NDS_SYNTAX_ID_3
#define NDS_STATE_OR_PROVINCE_NAME      STATE_OR_PROVINCE_NAME_name,STATE_OR_PROVINCE_NAME_syntax

/*
  SA (Street Address):
    Multivalued, nonremovable, sized attr (1..128), sync immediate (4.1)
    (Case Ignore String)
*/
#define STREET_ADDRESS_name             L"SA"
#define STREET_ADDRESS_syntax           NDS_SYNTAX_ID_3
#define NDS_STREET_ADDRESS              STREET_ADDRESS_name,STREET_ADDRESS_syntax

/*
  Security Equals:
    Multivalued, nonremovable, server read, write managed, sync immediate
    (Distinguished Name)
*/
#define SECURITY_EQUALS_name            L"Security Equals"
#define SECURITY_EQUALS_syntax          NDS_SYNTAX_ID_1
#define NDS_SECURITY_EQUALS             SECURITY_EQUALS_name,SECURITY_EQUALS_syntax

/*
  See Also:
    Multivalued, nonremovable, sync immediate (4.1)
    (Distinguished Name)
*/
#define SEE_ALSO_name                   L"See Also"
#define SEE_ALSO_syntax                 NDS_SYNTAX_ID_1
#define NDS_SEE_ALSO                    SEE_ALSO_name,SEE_ALSO_syntax

/*
  Surname:
    Multivalued, nonremovable, sized attr (1..64), sync immediate (4.1)
    (Case Ignore String)
*/
#define SURNAME_name                    L"Surname"
#define SURNAME_syntax                  NDS_SYNTAX_ID_3
#define NDS_SURNAME                     SURNAME_name,SURNAME_syntax

/*
  Telephone Number:
    Multivalued, nonremovable, sync immediate (4.1)
    (Telephone Number)
*/
#define PHONE_NUMBER_name               L"Telephone Number"
#define PHONE_NUMBER_syntax             NDS_SYNTAX_ID_10
#define NDS_PHONE_NUMBER                PHONE_NUMBER_name,PHONE_NUMBER_syntax

/*
  Title:
    Multivalued, nonremovable, sized attr (1..64), sync immediate (4.1)
    (Case Ignore String)
*/
#define TITLE_name                      L"Title"
#define TITLE_syntax                    NDS_SYNTAX_ID_3
#define NDS_TITLE                       TITLE_name,TITLE_syntax


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\nwstatus.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwstatus.h

Abstract:

    This module defines NWRDR specific NTSTATUS

Author:

Revision History:

--*/

#ifndef _NWSTATUS_
#define _NWSTATUS_

#define FACILITY_NWRDR                    0x11

#define NWRDR_PASSWORD_HAS_EXPIRED        0x40110001

#endif // _NWSTATUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\netlogp.h ===
/*++

Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    netlogp.h

Abstract:

    Private interfaces to the Netlogon service.

Author:

    Cliff Van Dyke (cliffv) 10-Oct-1996

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


#ifndef _NETLOGP_H_
#define _NETLOGP_H_

NTSTATUS
NetLogonSetServiceBits(
    IN LPWSTR ServerName,
    IN DWORD ServiceBitsOfInterest,
    IN DWORD ServiceBits
    );

NET_API_STATUS NET_API_FUNCTION
I_NetlogonGetTrustRid(
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR DomainName OPTIONAL,
    OUT PULONG Rid
    );

#define NL_DIGEST_SIZE 16

NET_API_STATUS NET_API_FUNCTION
I_NetlogonComputeServerDigest(
    IN LPWSTR ServerName OPTIONAL,
    IN ULONG Rid,
    IN LPBYTE Message,
    IN ULONG MessageSize,
    OUT CHAR NewMessageDigest[NL_DIGEST_SIZE],
    OUT CHAR OldMessageDigest[NL_DIGEST_SIZE]
    );

NET_API_STATUS NET_API_FUNCTION
I_NetlogonComputeClientDigest(
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR DomainName OPTIONAL,
    IN LPBYTE Message,
    IN ULONG MessageSize,
    OUT CHAR NewMessageDigest[NL_DIGEST_SIZE],
    OUT CHAR OldMessageDigest[NL_DIGEST_SIZE]
    );

NET_API_STATUS
NetLogonGetTimeServiceParentDomain(
    IN LPWSTR ServerName OPTIONAL,
    OUT LPWSTR *DomainName,
    OUT PBOOL PdcSameSite
    );

#endif // _NETLOGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\ndssntx.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NdsSntx.h

Abstract:

    This module defines NDS Syntax IDs and Structures used in the NDS
    object API found in nds32.h.

Author:

    Glenn Curtis    [GlennC]    15-Dec-1995

--*/

#ifndef __NDSSNTX_H
#define __NDSSNTX_H


#define NDS_SYNTAX_ID_0      0 /* Unknown */
#define NDS_SYNTAX_ID_1      1 /* Distinguished Name */
#define NDS_SYNTAX_ID_2      2 /* Case Exact String */
#define NDS_SYNTAX_ID_3      3 /* Case Ignore String */
#define NDS_SYNTAX_ID_4      4 /* Printable String */
#define NDS_SYNTAX_ID_5      5 /* Numeric String */
#define NDS_SYNTAX_ID_6      6 /* Case Ignore List */
#define NDS_SYNTAX_ID_7      7 /* Boolean */
#define NDS_SYNTAX_ID_8      8 /* Integer */
#define NDS_SYNTAX_ID_9      9 /* Octet String */
#define NDS_SYNTAX_ID_10    10 /* Telephone Number */
#define NDS_SYNTAX_ID_11    11 /* Facsimile Telephone Number */
#define NDS_SYNTAX_ID_12    12 /* Net Address */
#define NDS_SYNTAX_ID_13    13 /* Octet List */
#define NDS_SYNTAX_ID_14    14 /* EMail Address */
#define NDS_SYNTAX_ID_15    15 /* Path */
#define NDS_SYNTAX_ID_16    16 /* Replica Pointer */
#define NDS_SYNTAX_ID_17    17 /* Object ACL */
#define NDS_SYNTAX_ID_18    18 /* Postal Address */
#define NDS_SYNTAX_ID_19    19 /* Timestamp */
#define NDS_SYNTAX_ID_20    20 /* Class Name */
#define NDS_SYNTAX_ID_21    21 /* Stream */
#define NDS_SYNTAX_ID_22    22 /* Counter */
#define NDS_SYNTAX_ID_23    23 /* Back Link */
#define NDS_SYNTAX_ID_24    24 /* Time */
#define NDS_SYNTAX_ID_25    25 /* Typed Name */
#define NDS_SYNTAX_ID_26    26 /* Hold */
#define NDS_SYNTAX_ID_27    27 /* Interval */


//
// NDS Distinguished Name
//
// Used in attributes: Alias Object Name, Default Queue, Device,
//                     Group Membership, Higher Privileges, Host Device,
//                     Host Server, Member, Message Server, Operator, Owner,
//                     Profile, Reference, Resource, Role Occupant,
//                     Security Equals, See Also, Server, User, Volume
//
typedef struct
{
    LPWSTR DNString;

} ASN1_TYPE_1, * LPASN1_TYPE_1;

//
// NDS Case Exact String syntax
//
// Used in attribute: Home Directory
//
typedef struct
{
    LPWSTR CaseExactString;

} ASN1_TYPE_2, * LPASN1_TYPE_2;

//
// NDS Case Ignore String syntax
//
// Used in attributes: Cartridge, CN (Common Name), C (Country Name),
//                     Description, Host Resource Name, L (Locality Name),
//                     O (Organization Name), OU (Organizational Unit Name),
//                     Physical Delivery Office Name, Postal Code,
//                     Postal Office Box, Queue Directory, SAP Name,
//                     S (State or Province Name), SA (Street Address),
//                     Supported Services, Supported Typefaces, Surname,
//                     Title, Unknown Base Class, Version
//
typedef struct
{
    LPWSTR CaseIgnoreString;

} ASN1_TYPE_3, * LPASN1_TYPE_3;

//
// NDS Printable String syntax
//
// Used in attributes: Page Description Language, Serial Number
//
typedef struct
{
    LPWSTR PrintableString;

} ASN1_TYPE_4, * LPASN1_TYPE_4;

//
// NDS Numeric String syntax
//
// Used in attributes: Bindery Type
//
typedef struct
{
    LPWSTR NumericString;

} ASN1_TYPE_5, * LPASN1_TYPE_5;

//
// NDS Case Ignore List syntax
//
// Used in attribute: Language
//
typedef struct _CI_LIST
{
    struct _CI_LIST * Next;
    LPWSTR            String;

} ASN1_TYPE_6, * LPASN1_TYPE_6;

//
// NDS Boolean syntax
//
// Used in attributes: Allow Unlimited Credit, Detect Intruder,
//                     Lockout After Detection, Locked By Intruder,
//                     Login Diabled, Password Allow Change, Password Required,
//                     Password Unique Required
//
typedef struct
{
    DWORD Boolean;

} ASN1_TYPE_7, * LPASN1_TYPE_7;

//
// Example: NDS Integer syntax
//
// Used in attributes: Bindery Object Restriction, Convergence, GID (Group ID),
//                     Login Grace Limit, Login Intruder Limit,
//                     Login Maximum Simultaneous, Memory,
//                     Minimum Account Balance, Password Minimum Length, Status,
//                     Supported Connections, UID (User ID)
//
typedef struct
{
    DWORD Integer;

} ASN1_TYPE_8, * LPASN1_TYPE_8;

//
// NDS Octet String syntax
//
// Used in attributes: Athority Revocation, Bindery Property, CA Private Key,
//                     CA Public Key, Certificate Revocation,
//                     Cross Certificate Pair, Login Allowed Time Map,
//                     Passwords Used, Printer Configuration, Private Key,
//                     Public Key
//
typedef struct
{
    DWORD  Length;
    LPBYTE OctetString;

} ASN1_TYPE_9, * LPASN1_TYPE_9;

//
// NDS Telephone Number syntax
//
// Used in attribute: Telephone Number
//
typedef struct
{
    LPWSTR TelephoneNumber;

} ASN1_TYPE_10, * LPASN1_TYPE_10;

//
// NDS Facsimile Telephone Number syntax
//
// Used in attribute: Facsimile Telephone Number
//
typedef struct
{
    LPWSTR TelephoneNumber;
    DWORD  NumberOfBits;
    LPBYTE Parameters;

} ASN1_TYPE_11, * LPASN1_TYPE_11;

//
// NDS Network Address syntax
//
// Used in attributes: Login Intruder Address, Network Address,
//                     Network Address Restriction
//
typedef struct
{
    DWORD  AddressType; // 0 = IPX,
    DWORD  AddressLength;
    BYTE * Address;

} ASN1_TYPE_12, * LPASN1_TYPE_12;

//
// NDS Octet List syntax
//
// Used in attribute: (none)
//
typedef struct _OCTET_LIST
{
    struct _OCTET_LIST * Next;
    DWORD  Length;
    BYTE * Data;

} ASN1_TYPE_13, * LPASN1_TYPE_13;

//
// NDS EMail Address syntax
//
// Used in attribute: EMail Address
//
typedef struct
{
    DWORD  Type;
    LPWSTR Address;

} ASN1_TYPE_14, * LPASN1_TYPE_14;

//
// NDS Path syntax
//
// Used in attribute: Path
//
typedef struct
{
    DWORD  Type;
    LPWSTR VolumeName;
    LPWSTR Path;

} ASN1_TYPE_15, * LPASN1_TYPE_15;

//
// NDS Replica Pointer syntax
//
// Used in attribute: Replica
//
typedef struct
{
    LPWSTR ServerName;
    DWORD  ReplicaType;
    DWORD  ReplicaNumber;
    DWORD  Count;
    ASN1_TYPE_12 ReplicaAddressHint[1]; // ReplicaAddressHint is variable and
                                        // can be calculated by Count * the
                                        // length of a ASN1_TYPE_12 ( that is
                                        // Count * 9).

} ASN1_TYPE_16, * LPASN1_TYPE_16;

//
// NDS Object ACL syntax
//
// Used in attributes: ACL, Inherited ACL
//
typedef struct
{
    LPWSTR ProtectedAttrName;
    LPWSTR SubjectName;
    DWORD  Privileges;

} ASN1_TYPE_17, * LPASN1_TYPE_17;

//
// NDS Postal Address syntax
//
// Used in attribute: Postal Address
//
typedef struct
{
    LPWSTR PostalAddress[6]; // Value is limited to 6 lines,
                             // 30 characters each.

} ASN1_TYPE_18, * LPASN1_TYPE_18;

//
// NDS Timestamp syntax
//
// Used in attribute: Obituary, Partition Creation Time, Received Up To,
//                    Syncronized Up To
//
typedef struct
{
    DWORD WholeSeconds; // Zero equals 12:00 midnight, January 1, 1970, UTC
    DWORD EventID;

} ASN1_TYPE_19, * LPASN1_TYPE_19;

//
// NDS Class Name syntax
//
// Used in attribute: Object Class
//
typedef struct
{
    LPWSTR ClassName;

} ASN1_TYPE_20, * LPASN1_TYPE_20;

//
// NDS Stream syntax
//
// Used in attribute: Login Script, Print Job Configuration, Printer Control,
//                    Type Creator Map
//
typedef struct
{
    DWORD  Length; // Always zero
    BYTE * Data; 

} ASN1_TYPE_21, * LPASN1_TYPE_21;

//
// NDS Count syntax
//
// Used in attributes: Account Balance, Login Grace Remaining,
//                     Login Intruder Attempts
//
typedef struct
{
    DWORD Counter;

} ASN1_TYPE_22, * LPASN1_TYPE_22;

//
// NDS Back Link syntax
//
// Used in attribute: Back Link
//
typedef struct
{
    DWORD  RemoteID;
    LPWSTR ObjectName;

} ASN1_TYPE_23, * LPASN1_TYPE_23;

//
// NDS Time syntax
//
// Used in attributes: Last Login Time, Login Expiration Time,
//                     Login Intruder Rest Time, Login Time,
//                     Low Convergence Reset Time, Password Expiration Time
//
typedef struct
{
    DWORD Time; // (in whole seconds) zero equals 12:00 midnight,
                // January 1, 1970, UTC

} ASN1_TYPE_24, * LPASN1_TYPE_24;

//
// NDS Typed Name syntax
//
// Used in attribute: Notify, Print Server, Printer, Queue
//
typedef struct
{
    LPWSTR ObjectName;
    DWORD  Level;
    DWORD  Interval;

} ASN1_TYPE_25, * LPASN1_TYPE_25;

//
// NDS Hold syntax
//
// Used in attribute: Server Holds
//
typedef struct
{
    LPWSTR ObjectName;
    DWORD  Amount;

} ASN1_TYPE_26, * LPASN1_TYPE_26;

//
// NDS Interval syntax
//
// Used in attribute: High Convergence Syncronization Interval,
//                    Intruder Attempt Reset Interval,
//                    Intruder Lockout Reset Interval,
//                    Low Convergence Syncronization Interval,
//                    Password Expiration Interval
//
typedef struct
{
    DWORD  Interval;

} ASN1_TYPE_27, * LPASN1_TYPE_27;

//
// rc.exe falls over because this macro gets way too long
//
#ifndef RC_INVOKED

#define SIZE_OF_ASN1_1  sizeof( ASN1_TYPE_1 )
#define SIZE_OF_ASN1_2  sizeof( ASN1_TYPE_2 )
#define SIZE_OF_ASN1_3  sizeof( ASN1_TYPE_3 )
#define SIZE_OF_ASN1_4  sizeof( ASN1_TYPE_4 )
#define SIZE_OF_ASN1_5  sizeof( ASN1_TYPE_5 )
#define SIZE_OF_ASN1_6  sizeof( ASN1_TYPE_6 )
#define SIZE_OF_ASN1_7  sizeof( ASN1_TYPE_7 )
#define SIZE_OF_ASN1_8  sizeof( ASN1_TYPE_8 )
#define SIZE_OF_ASN1_9  sizeof( ASN1_TYPE_9 )
#define SIZE_OF_ASN1_10 sizeof( ASN1_TYPE_10 )
#define SIZE_OF_ASN1_11 sizeof( ASN1_TYPE_11 )
#define SIZE_OF_ASN1_12 sizeof( ASN1_TYPE_12 )
#define SIZE_OF_ASN1_13 sizeof( ASN1_TYPE_13 )
#define SIZE_OF_ASN1_14 sizeof( ASN1_TYPE_14 )
#define SIZE_OF_ASN1_15 sizeof( ASN1_TYPE_15 )
#define SIZE_OF_ASN1_16 sizeof( ASN1_TYPE_16 )
#define SIZE_OF_ASN1_17 sizeof( ASN1_TYPE_17 )
#define SIZE_OF_ASN1_18 sizeof( ASN1_TYPE_18 )
#define SIZE_OF_ASN1_19 sizeof( ASN1_TYPE_19 )
#define SIZE_OF_ASN1_20 sizeof( ASN1_TYPE_20 )
#define SIZE_OF_ASN1_21 sizeof( ASN1_TYPE_21 )
#define SIZE_OF_ASN1_22 sizeof( ASN1_TYPE_22 )
#define SIZE_OF_ASN1_23 sizeof( ASN1_TYPE_23 )
#define SIZE_OF_ASN1_24 sizeof( ASN1_TYPE_24 )
#define SIZE_OF_ASN1_25 sizeof( ASN1_TYPE_25 )
#define SIZE_OF_ASN1_26 sizeof( ASN1_TYPE_26 )
#define SIZE_OF_ASN1_27 sizeof( ASN1_TYPE_27 )

#define MOD_OF_ASN1_1  (SIZE_OF_ASN1_1 % sizeof(DWORD))
#define MOD_OF_ASN1_2  (SIZE_OF_ASN1_2 % sizeof(DWORD))
#define MOD_OF_ASN1_3  (SIZE_OF_ASN1_3 % sizeof(DWORD))
#define MOD_OF_ASN1_4  (SIZE_OF_ASN1_4 % sizeof(DWORD))
#define MOD_OF_ASN1_5  (SIZE_OF_ASN1_5 % sizeof(DWORD))
#define MOD_OF_ASN1_6  (SIZE_OF_ASN1_6 % sizeof(DWORD))
#define MOD_OF_ASN1_7  (SIZE_OF_ASN1_7 % sizeof(DWORD))
#define MOD_OF_ASN1_8  (SIZE_OF_ASN1_8 % sizeof(DWORD))
#define MOD_OF_ASN1_9  (SIZE_OF_ASN1_9 % sizeof(DWORD))
#define MOD_OF_ASN1_10 (SIZE_OF_ASN1_10 % sizeof(DWORD))
#define MOD_OF_ASN1_11 (SIZE_OF_ASN1_11 % sizeof(DWORD))
#define MOD_OF_ASN1_12 (SIZE_OF_ASN1_12 % sizeof(DWORD))
#define MOD_OF_ASN1_13 (SIZE_OF_ASN1_13 % sizeof(DWORD))
#define MOD_OF_ASN1_14 (SIZE_OF_ASN1_14 % sizeof(DWORD))
#define MOD_OF_ASN1_15 (SIZE_OF_ASN1_15 % sizeof(DWORD))
#define MOD_OF_ASN1_16 (SIZE_OF_ASN1_16 % sizeof(DWORD))
#define MOD_OF_ASN1_17 (SIZE_OF_ASN1_17 % sizeof(DWORD))
#define MOD_OF_ASN1_18 (SIZE_OF_ASN1_18 % sizeof(DWORD))
#define MOD_OF_ASN1_19 (SIZE_OF_ASN1_19 % sizeof(DWORD))
#define MOD_OF_ASN1_20 (SIZE_OF_ASN1_20 % sizeof(DWORD))
#define MOD_OF_ASN1_21 (SIZE_OF_ASN1_21 % sizeof(DWORD))
#define MOD_OF_ASN1_22 (SIZE_OF_ASN1_22 % sizeof(DWORD))
#define MOD_OF_ASN1_23 (SIZE_OF_ASN1_23 % sizeof(DWORD))
#define MOD_OF_ASN1_24 (SIZE_OF_ASN1_24 % sizeof(DWORD))
#define MOD_OF_ASN1_25 (SIZE_OF_ASN1_25 % sizeof(DWORD))
#define MOD_OF_ASN1_26 (SIZE_OF_ASN1_26 % sizeof(DWORD))
#define MOD_OF_ASN1_27 (SIZE_OF_ASN1_27 % sizeof(DWORD))

#define SUM_OF_ASN1_MODS ( MOD_OF_ASN1_1  + MOD_OF_ASN1_2  + MOD_OF_ASN1_3  + \
                           MOD_OF_ASN1_4  + MOD_OF_ASN1_5  + MOD_OF_ASN1_6  + \
                           MOD_OF_ASN1_7  + MOD_OF_ASN1_8  + MOD_OF_ASN1_9  + \
                           MOD_OF_ASN1_10 + MOD_OF_ASN1_11 + MOD_OF_ASN1_12 + \
                           MOD_OF_ASN1_13 + MOD_OF_ASN1_14 + MOD_OF_ASN1_15 + \
                           MOD_OF_ASN1_16 + MOD_OF_ASN1_17 + MOD_OF_ASN1_18 + \
                           MOD_OF_ASN1_19 + MOD_OF_ASN1_20 + MOD_OF_ASN1_21 + \
                           MOD_OF_ASN1_22 + MOD_OF_ASN1_23 + MOD_OF_ASN1_24 + \
                           MOD_OF_ASN1_25 + MOD_OF_ASN1_26 + MOD_OF_ASN1_27 )

//
// If an error occurs here, then the structures found in this file are not
// DWORD aligned. They should be in order to run on RISC platforms.
//
static int x[1 - SUM_OF_ASN1_MODS] ;

#endif  // RC_INVOKED
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\nlrepl.h ===
/*++
Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    nlrepl.h

Abstract:

    Prototypes of the database replication functions called either from
    LSA OR SAM.

Author:

    Madan Appiah

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    14-Apr-1992 (madana)
        Created.

--*/

#ifndef _NLREPL_H_
#define _NLREPL_H_

//
// Don't require the DS to include every .h in the world
//

#include <lmcons.h>
#include <dsgetdc.h>

#ifndef _AVOID_REPL_API
NTSTATUS
I_NetNotifyDelta (
    IN SECURITY_DB_TYPE DbType,
    IN LARGE_INTEGER ModificationCount,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PSID ObjectSid,
    IN PUNICODE_STRING ObjectName,
    IN DWORD ReplicationImmediately,
    IN PSAM_DELTA_DATA DeltaData
    );

NTSTATUS
I_NetNotifyRole(
    IN POLICY_LSA_SERVER_ROLE Role
    );

NTSTATUS
I_NetNotifyMachineAccount (
    IN ULONG ObjectRid,
    IN PSID DomainSid,
    IN ULONG OldUserAccountControl,
    IN ULONG NewUserAccountControl,
    IN PUNICODE_STRING ObjectName
    );

NTSTATUS
I_NetNotifyTrustedDomain (
    IN PSID HostedDomainSid,
    IN PSID TrustedDomainSid,
    IN BOOLEAN IsDeletion
    );

typedef enum {
    //
    // Indicates that a subnet object has been added, deleted, renamed, or
    //  the site containing the subnet has changed.
    //

    NlSubnetObjectChanged,

    //
    // Indicates that a site object has been added, deleted or renamed.
    //

    NlSiteObjectChanged,

    //
    // Indicates that the site this DC is in has changed.
    //

    NlSiteChanged,

    //
    // Indicates that the org tree changed
    //

    NlOrgChanged,

    //
    // Indicate that the DC demotion is in progress
    //

    NlDcDemotionInProgress,

    //
    // Indicate that the DC demotion is completed
    //

    NlDcDemotionCompleted,

    //
    // Indicate that NDNC info has changed
    //

    NlNdncChanged,

    //
    // Indicate that DnsRootAlias has changed
    //

    NlDnsRootAliasChanged


} NL_DS_CHANGE_TYPE, *PNL_DS_CHANGE_TYPE;

NTSTATUS
I_NetNotifyDsChange(
    IN NL_DS_CHANGE_TYPE DsChangeType
    );

NTSTATUS
I_NetLogonGetSerialNumber (
    IN SECURITY_DB_TYPE DbType,
    IN PSID DomainSid,
    OUT PLARGE_INTEGER SerialNumber
    );

NTSTATUS
I_NetLogonReadChangeLog(
    IN PVOID InContext,
    IN ULONG InContextSize,
    IN ULONG ChangeBufferSize,
    OUT PVOID *ChangeBuffer,
    OUT PULONG BytesRead,
    OUT PVOID *OutContext,
    OUT PULONG OutContextSize
    );

NTSTATUS
I_NetLogonNewChangeLog(
    OUT HANDLE *ChangeLogHandle
    );

NTSTATUS
I_NetLogonAppendChangeLog(
    IN HANDLE ChangeLogHandle,
    IN PVOID ChangeBuffer,
    IN ULONG ChangeBufferSize
    );

NTSTATUS
I_NetLogonCloseChangeLog(
    IN HANDLE ChangeLogHandle,
    IN BOOLEAN Commit
    );

NTSTATUS
I_NetLogonSendToSamOnPdc(
    IN LPWSTR DomainName,
    IN LPBYTE OpaqueBuffer,
    IN ULONG OpaqueBufferSize
    );

#endif // _AVOID_REPL_API

NET_API_STATUS
I_DsGetDcCache(
    IN LPCWSTR NetbiosDomainName OPTIONAL,
    IN LPCWSTR DnsDomainName OPTIONAL,
    OUT PBOOLEAN InNt4Domain,
    OUT LPDWORD InNt4DomainTime
    );

NET_API_STATUS
DsrGetDcNameEx2(
        IN LPWSTR ComputerName OPTIONAL,
        IN LPWSTR AccountName OPTIONAL,
        IN ULONG AllowableAccountControlBits,
        IN LPWSTR DomainName OPTIONAL,
        IN GUID *DomainGuid OPTIONAL,
        IN LPWSTR SiteName OPTIONAL,
        IN ULONG Flags,
        OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
        );

NTSTATUS
I_NetLogonSetServiceBits(
    IN DWORD ServiceBitsOfInterest,
    IN DWORD ServiceBits
    );

NTSTATUS
I_NetLogonLdapLookupEx(
    IN PVOID Filter,
    IN PVOID SockAddr,
    OUT PVOID *Response,
    OUT PULONG ResponseSize
    );

NET_API_STATUS
I_NetLogonGetIpAddresses(
    OUT PULONG IpAddressCount,
    OUT LPBYTE *IpAddresses
    );

//
// OS verion number from I_NetLogonGetAuthDataEx
//

typedef enum _NL_OS_VERSION {
    NlNt35_or_older = 1,
    NlNt351,
    NlNt40,
    NlWin2000,  // NT 5.0
    NlWhistler  // NT 5.1
} NL_OS_VERSION, *PNL_OS_VERSION;
//
// Flags to I_NetLogonGetAuthDataEx
//
#define NL_DIRECT_TRUST_REQUIRED    0x01
#define NL_RETURN_CLOSEST_HOP       0x02
#define NL_ROLE_PRIMARY_OK          0x04
#define NL_REQUIRE_DOMAIN_IN_FOREST 0x08

NTSTATUS
I_NetLogonGetAuthDataEx(
    IN LPWSTR HostedDomainName OPTIONAL,
    IN LPWSTR TrustedDomainName,
    IN ULONG Flags,
    IN PLARGE_INTEGER FailedSessionSetupTime OPTIONAL,
    OUT LPWSTR *OurClientPrincipleName,
    OUT PVOID *ClientContext OPTIONAL,
    OUT LPWSTR *ServerName,
    OUT PNL_OS_VERSION ServerOsVersion,
    OUT PULONG AuthnLevel,
    OUT PLARGE_INTEGER SessionSetupTime
    );

NTSTATUS
I_NetNotifyNtdsDsaDeletion (
    IN LPWSTR DnsDomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN GUID *DsaGuid,
    IN LPWSTR DnsHostName
    );

VOID
I_NetLogonFree(
    IN PVOID Buffer
    );

NTSTATUS
I_NetLogonMixedDomain(
    OUT PBOOL MixedMode
    );

#ifdef _WINSOCK2API_

NET_API_STATUS
I_NetLogonAddressToSiteName(
    IN PSOCKET_ADDRESS SocketAddress,
    OUT LPWSTR *SiteName
    );

#endif

#endif // _NLREPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\nwstruct.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwstruct.h

Abstract:

    Contains data structures used by NCP Server APIs.

Author:

    Yi-Hsin Sung (yihsins)  11-Sept-1993

Revision History:

--*/

#ifndef _NWSTRUCT_H_
#define _NWSTRUCT_H_

#include <fpnwapi.h>

#ifdef __cplusplus
extern "C" {
#endif

//
//  Volume types : disk or printer
//

#define NWVOL_TYPE_DISKTREE             FPNWVOL_TYPE_DISKTREE
#define NWVOL_TYPE_CDROM                FPNWVOL_TYPE_CDROM
#define NWVOL_TYPE_REMOVABLE            FPNWVOL_TYPE_REMOVABLE

#define NWVOL_MAX_USES_UNLIMITED        ((ULONG)-1)

//
//  Permissions flags returned in structure FPNWFILEINFO
//

#define NWFILE_PERM_NONE                FPNWFILE_PERM_NONE
#define NWFILE_PERM_READ                FPNWFILE_PERM_READ
#define NWFILE_PERM_WRITE               FPNWFILE_PERM_WRITE
#define NWFILE_PERM_CREATE              FPNWFILE_PERM_CREATE
#define NWFILE_PERM_EXEC                FPNWFILE_PERM_EXEC
#define NWFILE_PERM_DELETE              FPNWFILE_PERM_DELETE
#define NWFILE_PERM_ATRIB               FPNWFILE_PERM_ATRIB
#define NWFILE_PERM_PERM                FPNWFILE_PERM_PERM

#define NWSERVERADDR                    FPNWSERVERADDR

typedef FPNWSERVERINFO  NWSERVERINFO, *PNWSERVERINFO;
typedef FPNWVOLUMEINFO  NWVOLUMEINFO, *PNWVOLUMEINFO;
typedef FPNWVOLUMEINFO_2  NWVOLUMEINFO_2, *PNWVOLUMEINFO_2;
typedef FPNWCONNECTIONINFO  NWCONNECTIONINFO, *PNWCONNECTIONINFO;
typedef FPNWVOLUMECONNINFO  NWVOLUMECONNINFO, *PNWVOLUMECONNINFO;
typedef FPNWFILEINFO  NWFILEINFO, *PNWFILEINFO;

//
//  Below are the APIs available to manipulate FPNW servers, volumes, etc.
//

DWORD
NwApiBufferFree(
    IN  LPVOID pBuffer
);

DWORD
NwServerGetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT PNWSERVERINFO *ppServerInfo
);

DWORD
NwServerSetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  PNWSERVERINFO pServerInfo
);

DWORD
NwVolumeAdd(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  PNWVOLUMEINFO pVolumeInfo
);

DWORD
NwVolumeDel(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName
);

DWORD
NwVolumeEnum(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT PNWVOLUMEINFO *ppVolumeInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
);

DWORD
NwVolumeGetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    OUT PNWVOLUMEINFO *ppVolumeInfo
);

DWORD
NwVolumeSetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    IN  PNWVOLUMEINFO pVolumeInfo
);

DWORD
NwConnectionEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    OUT PNWCONNECTIONINFO *ppConnectionInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
);

DWORD NwConnectionDel(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId
);

DWORD
NwVolumeConnEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD dwLevel,
    IN LPWSTR pVolumeName,
    IN DWORD  dwConnectionId,
    OUT PNWVOLUMECONNINFO *ppVolumeConnInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
);

DWORD
NwFileEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    IN LPWSTR pPathName OPTIONAL,
    OUT PNWFILEINFO *ppFileInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
);

DWORD
NwFileClose(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  nFileId
);

DWORD NwMessageBufferSend(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId,
    IN DWORD  fConsoleBroadcast,
    IN LPBYTE pbBuffer,
    IN DWORD  cbBuffer
);

DWORD NwSetDefaultQueue(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pQueueName
);

DWORD NwAddPServer(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pPServerName
);

DWORD NwRemovePServer(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pPServerName
);

#ifdef __cplusplus
}   /* extern "C" */
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\nwpapi32.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1993 Microsoft Corporation
//
//  Module Name:
//
//      nwapi32.h
//
//  Abstract:
//
//      This module contains the support to routines
//      into the CSNW that use NTSTATUS.
//
//  Author:
//
//      Chris Sandys    (a-chrisa)  09-Sep-1993
//
//  Revision History:
//      Chuck Y Chan    Feb 7, 1996    Spilt of NTSTATUS type calls 
//                                     from nwapi32.h
//
//////////////////////////////////////////////////////////////////////////////


#ifndef _NWPAPI32_H_
#define _NWPAPI32_H_

#include <nwapi32.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Versions of functions above, but return NTSTATUS. Keep around because     //
// existing DSMN code calls them. Do not extenf this set. The NWC* functions //
// are the ones to use.                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NWPAttachToFileServerW(
    const WCHAR             *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE           *phNewConn
    );

NTSTATUS
NWPDetachFromFileServer(
    NWCONN_HANDLE           hConn
    );

NTSTATUS
NWPGetFileServerVersionInfo(
    NWCONN_HANDLE           hConn,
    VERSION_INFO            *lpVerInfo
    );

DWORD
NWPLoginToFileServerW(
    NWCONN_HANDLE           hConn,
    LPWSTR                  pszUserName,
    NWOBJ_TYPE              wObType,
    LPWSTR                  pszPassword
    );

DWORD
NWPLogoutFromFileServer(
    NWCONN_HANDLE           hConn
    );

NTSTATUS
NWPDeleteObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType
    );

NTSTATUS
NWPCreateObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    NWFLAGS                 ucObjectFlags, 
    NWFLAGS                 ucObjSecurity
    );

NTSTATUS
NWPWritePropertyValue(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    NWSEGMENT_NUM           segmentNumber,
    NWSEGMENT_DATA          *segmentData,
    NWFLAGS                 moreSegments
    );

NTSTATUS
NWPChangeObjectPasswordEncrypted(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    BYTE                    *validationKey,
    BYTE                    *newKeyedPassword
    );

NTSTATUS
NWPGetObjectID(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    NWOBJ_ID                *objectID
    );

NTSTATUS
NWPAddObjectToSet( 
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    const char              *pszMemberName,
    NWOBJ_TYPE              memberType
    );

NTSTATUS
NWPDeleteObjectFromSet( 
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    const char              *pszMemberName,
    NWOBJ_TYPE              memberType
    );

NTSTATUS
NWPCreateProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    NWFLAGS                 ucObjectFlags, 
    NWFLAGS                 ucObjSecurity
    );

NTSTATUS
NWPDeleteProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName
    );

NTSTATUS
NWPGetChallengeKey(
    NWCONN_HANDLE           hConn,
    UCHAR                   *challengeKey
    );

NTSTATUS
NWPReadPropertyValue(
    NWCONN_HANDLE           hConn,
    const char              *pszObjName,
    NWOBJ_TYPE              wObjType,
    char                    *pszPropName,
    unsigned char           ucSegment,
    char                    *pValue,
    NWFLAGS                 *pucMoreFlag,
    NWFLAGS                 *pucPropFlag
    );


NTSTATUS
NWPCreateDirectory(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWACCESS_RIGHTS         accessMask
    );

NTSTATUS
NWPAddTrustee(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWOBJ_ID                dwTrusteeID,
    NWRIGHTS_MASK           rightsMask
    );

NTSTATUS
NWPRenameBinderyObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    const char              *pszNewObjectName,
    NWOBJ_TYPE              wObjType 
    );

NTSTATUS
NWPGetObjectName(
    NWCONN_HANDLE           hConn,
    NWOBJ_ID                dwObjectID,
    char                    *pszObjName,
    NWOBJ_TYPE              *pwObjType
    );

NTSTATUS
NWPScanObject(
    NWCONN_HANDLE           hConn,
    const char              *pszSearchName,
    NWOBJ_TYPE              wObjSearchType,
    NWOBJ_ID                *pdwObjectID,
    char                    *pszObjectName,
    NWOBJ_TYPE              *pwObjType,
    NWFLAGS                 *pucHasProperties,
    NWFLAGS                 *pucObjectFlags,
    NWFLAGS                 *pucObjSecurity
    );

NTSTATUS
NWPScanProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    char                    *pszSearchName,
    NWOBJ_ID                *pdwSequence,
    char                    *pszPropName,
    NWFLAGS                 *pucPropFlags,
    NWFLAGS                 *pucPropSecurity,
    NWFLAGS                 *pucHasValue,
    NWFLAGS                 *pucMore
    );

NTSTATUS
NWPScanForTrustees(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszsearchDirPath,
    NWSEQUENCE              *pucsequenceNumber,
    BYTE                    *numberOfEntries,
    TRUSTEE_INFO            *tl
    );

NTSTATUS
NWPScanDirectoryForTrustees2(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszsearchDirPath,
    NWSEQUENCE              *pucsequenceNumber,
    char                    *pszdirName,
    NWDATE_TIME             *dirDateTime,
    NWOBJ_ID                *ownerID,
    TRUSTEE_INFO            *trusteeList
    );

NTSTATUS
NWPGetBinderyAccessLevel(
    NWCONN_HANDLE           hConn,
    NWFLAGS                 *accessLevel,
    NWOBJ_ID                *objectID
    );

NTSTATUS
NWPGetFileServerDescription(
    NWCONN_HANDLE           hConn,
    char                    *pszCompany,
    char                    *pszVersion,
    char                    *pszRevision
);

NTSTATUS
NWPGetVolumeNumber(
    NWCONN_HANDLE           hConn,
    char                    *pszVolume,
    NWVOL_NUM               *VolumeNumber
);

NTSTATUS
NWPGetVolumeUsage(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               VolumeNumber,
    DWORD                   *TotalBlocks,
    DWORD                   *FreeBlocks,
    DWORD                   *PurgeableBlocks,
    DWORD                   *NotYetPurgeableBlocks,
    DWORD                   *TotalDirectoryEntries,
    DWORD                   *AvailableDirectoryEntries,
    BYTE                    *SectorsPerBlock
);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif //_NWPAPI32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\nwutil.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwutil.h

Abstract:

    Common header for Workstation client-side code.

Author:

    Yi-Hsin Sung    (yihsins)      25-Oct-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NWUTIL_H_
#define _NWUTIL_H_

#ifdef __cplusplus
extern "C" {
#endif

#define TREECHAR L'*'
#define TWO_KB   2048

BOOL
NwIsNdsSyntax(
    IN LPWSTR lpstrUnc
);

VOID
NwAbbreviateUserName(
    IN  LPWSTR pszFullName,
    OUT LPWSTR pszUserName
);

VOID
NwMakePrettyDisplayName(
    IN  LPWSTR pszName
);

VOID
NwExtractTreeName(
    IN  LPWSTR pszUNCPath,
    OUT LPWSTR pszTreeName
);


VOID
NwExtractServerName(
    IN  LPWSTR pszUNCPath,
    OUT LPWSTR pszServerName
);


VOID
NwExtractShareName(
    IN  LPWSTR pszUNCPath,
    OUT LPWSTR pszShareName
);

DWORD
NwIsServerInDefaultTree(
    IN  LPWSTR  pszFullServerName,
    OUT BOOL   *pfInDefaultTree
);

DWORD
NwIsServerOrTreeAttached(
    IN  LPWSTR  pszServerName,
    OUT BOOL   *pfAttached,
    OUT BOOL   *pfAuthenticated
);

DWORD
NwGetConnectionInformation(
    IN  LPWSTR  pszName,
    OUT LPBYTE  Buffer,
    IN  DWORD   BufferSize
);

DWORD
NwGetConnectionStatus(
    IN     LPWSTR  pszServerName,
    IN OUT PDWORD_PTR  ResumeKey,
    OUT    LPBYTE  *Buffer,
    OUT    PDWORD  EntriesRead
);

DWORD
NwGetNdsVolumeInfo(
    IN  LPWSTR pszName,
    OUT LPWSTR pszServerBuffer,
    IN  WORD   wServerBufferSize,    // in bytes
    OUT LPWSTR pszVolumeBuffer,
    IN  WORD   wVolumeBufferSize     // in bytes
);

DWORD
NwOpenAndGetTreeInfo(
    LPWSTR pszNdsUNCPath,
    HANDLE *phTreeConn,
    DWORD  *pdwOid
);

DWORD
NwGetConnectedTrees(
    IN  LPWSTR  pszNtUserName,
    OUT LPBYTE  Buffer,
    IN  DWORD   BufferSize,
    OUT LPDWORD lpEntriesRead,
    OUT LPDWORD lpUserLUID
);

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _NWUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\prefix.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Prefix.h

Abstract:

    This header file declares equates for debug print "prefix" strings.
    For the moment, these are of the form:

        #define PREFIX_NETLIB     "NETLIB: "

    These are collected into a header file in case someone decides to
    change the look of these strings, or internationalize them, or
    whatever.

Author:

    John Rogers (JohnRo) 08-May-1992

Environment:

    Portable to just about any computer I ever saw.  --JR

Revision History:

    08-May-1992 JohnRo
        Created.
    27-May-1992 JohnRo
        Added PREFIX_SC and PREFIX_SC_CLIENT for service controller.
        Added PREFIX_PORTUAS for PortUAS utility (run during setup).
    07-Aug-1992 JohnRo
        RAID 1895: Net APIs and svc should use OEM char set (not ANSI).
        (Added PREFIX_XACTSRV as part of support for that.)
    16-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.

--*/


#ifndef _PREFIX_H_INCLUDED_
#define _PREFIX_H_INCLUDED_


#define PREFIX_NETAPI       "NETAPI32: "
#define PREFIX_NETLIB       "NETLIB: "
#define PREFIX_NETLOGON     "NETLOGON: "
#define PREFIX_NETRAP       "NETRAP: "
#define PREFIX_PORTUAS      "PORTUAS: "
#define PREFIX_REPL         "REPL: "
#define PREFIX_REPL_CLIENT  "REPL-CLIENT: "
#define PREFIX_REPL_MASTER  "REPL-MASTER: "
#define PREFIX_SC           "SC: "
#define PREFIX_SC_CLIENT    "SC-CLIENT: "
#define PREFIX_WKSTA        "WKSTA: "
#define PREFIX_XACTSRV      "XACTSRV: "



#endif // ndef _PREFIX_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\spud.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    Spud.h

Abstract:

    Contains structures and declarations for SPUD.  SPUD stands for the
    Special Purpose Utility Driver.  This driver enhances the performance
    of IIS.

Author:

    John Ballard (jballard)    21-Oct-1996

Revision History:

--*/

#ifndef _SPUD_
#define _SPUD_

#define SPUD_VERSION     0x00010000

typedef enum {
    TransmitFileAndRecv,
    SendAndRecv,
} REQ_TYPE;

typedef struct _SPUD_REQ_CONTEXT {
    REQ_TYPE            ReqType;
    IO_STATUS_BLOCK     IoStatus1;
    IO_STATUS_BLOCK     IoStatus2;
    PVOID               KernelReqInfo;
} SPUD_REQ_CONTEXT, *PSPUD_REQ_CONTEXT;

typedef struct _SPUD_COUNTERS {
    ULONG       CtrTransmitfileAndRecv;
    ULONG       CtrTransRecvFastTrans;
    ULONG       CtrTransRecvFastRecv;
    ULONG       CtrTransRecvSlowTrans;
    ULONG       CtrTransRecvSlowRecv;
    ULONG       CtrSendAndRecv;
    ULONG       CtrSendRecvFastSend;
    ULONG       CtrSendRecvFastRecv;
    ULONG       CtrSendRecvSlowSend;
    ULONG       CtrSendRecvSlowRecv;
} SPUD_COUNTERS, *PSPUD_COUNTERS;

#if 0
typedef struct _SPUD_REQUEST_ITEM {
    HANDLE              Socket;
    DWORD               RequestIoctl;
    union {
        AFD_TRANSMIT_FILE_INFO  TransmitFileInfo;
        AFD_SEND_INFO           SendInfo;
        AFD_RECV_INFO           RecvInfo;
    } AfdRequest;
    IO_STATUS_BLOCK             StatusBlock;
} SPUD_REQUEST_ITEM, *PSPUD_REQUEST_ITEM;

typedef struct _SPUD_BATCH_REQUEST {
    ULONG               RequestCount;
    PSPUD_REQUEST_ITEM  RequestList;
} SPUD_BATCH_REQUEST, *PSPUD_BATCH_REQUEST;
#endif

#endif // ndef _SPUD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\wxlpc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       wxlpc.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-18-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __WXLPC_H__
#define __WXLPC_H__

#define SYSKEY_SIZE 16 //size in bytes

typedef enum _WX_AUTH_TYPE {
    WxNone = 0,
    WxStored,
    WxPrompt,
    WxDisk
    } WX_AUTH_TYPE ;

typedef struct _WXHASH {
    UCHAR Digest[16];
} WXHASH, *PWXHASH;

NTSTATUS
WxServerThread(
    PVOID Ignored
    );

NTSTATUS
WxConnect(
    OUT PHANDLE Handle
    );

NTSTATUS
WxGetKeyData(
    IN HANDLE Handle,
    IN WX_AUTH_TYPE ExpectedAuthSource,
    IN ULONG BufferSize,
    OUT PUCHAR Buffer,
    OUT PULONG BufferData
    );

NTSTATUS
WxReportResults(
    IN HANDLE Handle,
    IN NTSTATUS Status
    );

VOID
WxClientDisconnect(
    IN HANDLE Handle
    );

NTSTATUS
WxSaveSysKey(
    IN ULONG    Keylen,
    IN PVOID    Key
    );

NTSTATUS
WxReadSysKey(
    IN OUT PULONG BufferLength,
    OUT PVOID  Key
    );

NTSTATUS
WxReadSysKeyEx(
    IN HANDLE Handle,
    IN OUT PULONG BufferLength,
    OUT PVOID  Key
    );

NTSTATUS
WxLoadSysKeyFromDisk(
    OUT PVOID Key,
    IN OUT PULONG BufferLength
    );

NTSTATUS
WxHashKey(
    IN OUT LPWSTR Key,
    OUT PVOID  Syskey,
    IN OUT ULONG cbSyskey
    );

NTSTATUS
WxSaveBootOption( WX_AUTH_TYPE NewType );

#endif  // __WXLPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\lhmatch\lhbfs.c ===
/******************************************************************************
 *
 * LHMatch BFS
 *
 * Authors: Nicholas Harvey and Laszlo Lovasz
 *
 * Developed: Nov 2000 - June 2001
 *
 * Algorithm Description:
 *
 * The theoretical description of this algorithm is fairly complicated and
 * will not be given here.
 *
 * Runtime:
 *
 * Assume that the input graph is G=(U \union V, E) where U is the set of
 * left-hand vertices and V is the set of right-hand vertices. Then the
 * worst-case runtime of this algorithm is O(|V|^1.5 * |E|), but in practice
 * the algorithm is quite fast.
 *
 * Implementation details which improve performance:
 *
 *  - Right-hand vertices are stored in buckets containing doubly-linked lists
 *    for quick iteration and update.
 *  - After a full pass of the graph, only the Queue contents are unmarked.
 *  - Search from Low-load Vertices for High-load Vertices
 *  - Check the degree of RHS vertices when enqueuing them
 *  - After augmenting, continue searching among unmarked vertices.
 *  - When computing the greedy matching, consider LHS vertices in order of
 *    increasing degree.
 *  - Force inline of key functions in inner loop
 *  - Update gMaxRHSLoad after each iteration.
 *
 ******************************************************************************/

/***** Header Files *****/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "LHMatchInt.h"

/***** InitializeBFS *****/
/* Inititalize BFS: Clear parent pointers, allocate queue */
static int InitializeBFS(Graph *g) {
    int i;

    /* Clear the parent pointers */
    for(i=0;i<g->numLHSVtx;i++) g->lVtx[i].parent=NULL;
    for(i=0;i<g->numRHSVtx;i++) g->rVtx[i].parent=NULL;

    return InitializeQueue(g);
}

/***** AddVtxToTree *****/
/* Add vertex v to the queue and to the BFS tree with parent p */
static __forceinline void AddVtxToTree(Graph *g, Vertex *v, Vertex *p) {
    DPRINT( printf("Adding %d to queue with parent %d\n",v->id,p->id); )
    v->parent = p;
    g->Queue[g->Qsize++] = v;
}

/***** UpdateNegPath *****/
/* Found an neg-cost alternating path. Switch the matching edges
 * along it, causing the number of matching edges at the endpoints
 * to change. We update the endpoints' positions in the ordering. */
static void UpdateNegPath(Graph *g, Vertex *u, Vertex *v) {
    Vertex *p,*w;

    DPRINT( printf("Low  Endpoint: %d. Increase load to %d\n",
            u->id, u->numMatched+1 ); )
    DPRINT( printf("High Endpoint: %d. Decrease load to %d\n",
            v->id, v->numMatched-1 ); )
    assert( u->numMatched <= v->numMatched-2 );

    /* Switch along the path */
    w=v;
    do {
        assert( !IS_LHS_VTX(w) );
        p=w->parent;
        assert( IS_LHS_VTX(p) );
        w=p->parent;
        p->matchedWith=w;
        #ifdef STATS
            g->stats.TotalAugpathLen+=2;
        #endif
    } while(w!=u);

    /* Move vertex u into the next highest bucket */
    RemoveVtxFromBucket(g,u,u->numMatched);
    u->numMatched++;
    AddVtxToBucket(g,u,u->numMatched);

    /* Move vertex v into the next lowest bucket */
    RemoveVtxFromBucket(g,v,v->numMatched);
    v->numMatched--;
    AddVtxToBucket(g,v,v->numMatched);
}

/***** PrintStats *****/
static void PrintStats(Graph* g) {
    #ifdef STATS
        int i,m=0,vzd=0,mrv=0,trmd=0,cost=0;
        for(i=0;i<g->numLHSVtx;i++) {
            m+=g->lVtx[i].degree;
            if(g->lVtx[i].degree==0) vzd++;
        }
        for(i=0;i<g->numRHSVtx;i++) {
            if(g->rVtx[i].numMatched>0) mrv++;
            trmd+=g->rVtx[i].numMatched;
            cost+=g->rVtx[i].numMatched*(g->rVtx[i].numMatched+1)/2;
        }

        printf("##### GRAPH STATISTICS #####\n");
        printf("|LHS|=%d, |RHS|=%d\n",g->numLHSVtx,g->numRHSVtx);
        printf("Total # vertices: %d, Total # edges: %d\n",
            g->numLHSVtx+g->numRHSVtx, m);
        printf("# LHS vertices with degree 0: %d\n",vzd);
        printf("Total M-degree of RHS vertices (should = |LHS|): %d\n",trmd);
        printf("Total matching cost: %d\n",cost);
        printf("# RHS vertices with M-degree > 0 (Max Matching): %d\n",mrv);

        printf("\n##### ALGORITHM STATISTICS #####\n");
        printf("Total # Augmentations: %d\n", g->stats.TotalAugs);
        printf("Avg length of augmenting path: %.2lf\n",
            g->stats.TotalAugs
            ? ((double)g->stats.TotalAugpathLen)/(double)g->stats.TotalAugs
            : 0. );
        printf("Total number of BFS trees grown: %d\n", g->stats.TotalBFSTrees);
        printf("Avg Size of Augmenting BFS Tree: %.2lf\n",
            g->stats.TotalAugs
            ? ((double)g->stats.TotalAugBFSTreeSize)/(double)g->stats.TotalAugs
            : 0. );
        printf("Total number of restarts (passes over RHS): %d\n",
            g->stats.TotalRestarts);
    #endif
}

/***** DoBFS *****/
/* Add u to the queue and start a BFS from vertex u.
 * If an augmenting path was found return m, the end of the augmenting path.
 * If no path was found, return NULL. */
static __forceinline Vertex* DoBFS( Graph *g, Vertex *u ) {
    Vertex      *v, *n, *m;
    int         q, j;

    /* Start a BFS from u: add u to the queue */
    DPRINT( printf("Using as root\n"); )
    u->parent=u;
    q = g->Qsize;
    g->Queue[g->Qsize++]=u;

    #ifdef STATS
        g->stats.TotalBFSTrees++;
    #endif

    /* Process the vertices in the queue */
    for(; q<g->Qsize; q++ ) {

        v = g->Queue[q];
        DPRINT( printf("Dequeued %d\n",v->id); )
        if(IS_LHS_VTX(v)) {
            /* The LHS vertices are only in the queue so that we
             * can keep track of which vertices have been marked. */
            continue;
        }

        /* Examine each of v's neighbours */
        for( j=0; j<v->degree; j++ ) {

            /* Examine neighbour n */
            n = v->adjList[j];
            assert(IS_LHS_VTX(n));
            if(n->matchedWith==v) {
                continue;       /* Can't add flow to v along this edge */
            }
            if(n->parent!=NULL) {
                continue;       /* We've already visited n */
            }

            /* n is okay, let's look at its matched neighbour */
            AddVtxToTree( g, n, v );
            m = n->matchedWith;
        
            assert(!IS_LHS_VTX(m));
            if(m->parent!=NULL) {
                continue;       /* We've already visited m */
            }
            AddVtxToTree( g, m, n );
            if( m->numMatched >= u->numMatched+2 ) {
                return m;       /* Found an augmenting path */
            }
        }

    }

    return NULL;
}

/***** DoFullScan *****/
/* Iterate over all RHS vertices from low-load to high-load.
 * At each vertex, do a breadth-first search for a cost-reducing
 * path. If one is found, switch along the path to improve the cost.
 *
 * If any augmentations were made, returns TRUE.
 * If no augmentations were made, returns FALSE. */
char __forceinline DoFullScan( Graph *g ) {
    Vertex *u, *nextU, *m;
    int     b;
    char    fAugmentedSinceStart=FALSE;
    #ifdef STATS
        int qSizeAtBFSStart;
    #endif

    /* Iterate over all buckets of vertices */
    for( b=0; b<=g->maxRHSLoad-2; b++ ) {

        /* Examine the RHS vertices in this bucket */
        for( u=g->Buckets[b]; u; u=nextU ) {
            
            assert(u->numMatched==b);
            DPRINT( printf("Consider BFS Root %d (Load %d): ",u->id, b); )
            nextU=u->fLink;
            
            /* If this vertex has been visited, skip it */
            if(u->parent!=NULL) {
                DPRINT( printf("Skipping (Marked)\n"); )
                continue;
            }
            
            #ifdef STATS
                qSizeAtBFSStart = g->Qsize;
            #endif

            /* Do a breadth-first search from u for a cost-reducing path. */
            m = DoBFS(g,u);
            if( NULL!=m ) {
                /* A cost-reducing path from u to m exists. Switch along the path. */
                DPRINT( printf("Found augmenting path!\n"); )
                UpdateNegPath(g,u,m);
                
                #ifdef STATS
                    g->stats.TotalAugs++;
                    g->stats.TotalAugBFSTreeSize+=(g->Qsize-qSizeAtBFSStart);
                #endif
                
                fAugmentedSinceStart = TRUE;
            }
        }
    }

    /* Update maxRHSLoad */
    while(!g->Buckets[g->maxRHSLoad]) g->maxRHSLoad--;

    return fAugmentedSinceStart;
}

/***** MainLoop *****/
/* Repeatedly do full-scans of the graph until no more improvements are made. */
void MainLoop( Graph *g ) {
    char    fMadeImprovement;
    int     j;

    do {
    
        DPRINT( printf("** Restarting from first bucket **\n"); )
        #ifdef STATS
            g->stats.TotalRestarts++;
        #endif

        /* Reinitialize the queue */
        for(j=0;j<g->Qsize;j++) g->Queue[j]->parent=NULL;
        g->Qsize=0;

        fMadeImprovement = DoFullScan(g);

    } while( fMadeImprovement );

}

/***** LHAlgBFS *****/
/* Main function that implements the LHBFS algorithm for computing
 * LH Matchings. */
int LHAlgBFS(Graph *g) {
    int     err;

    DPRINT( printf("--- LHMatch BFS Started ---\n"); )
    #ifdef STATS
        memset( &g->stats, 0, sizeof(Stats) );
    #endif

    /* Compute an initial greedy assignment, which may or may not
     * have minimum cost. */
    err = OrderedGreedyAssignment(g);
    if( LH_SUCCESS!=err ) {
        return err;
    }
    #ifdef DUMP
        DumpGraph(g);
        DumpLoad(g);
    #endif

    /* Initialize structures needed for BFS: parent pointers and
     * queue. */
    err = InitializeBFS(g);
    if( LH_SUCCESS!=err ) {
        return err;
    }

    /* Insert all RHS vertices into buckets. The purpose of this is
     * to sort RHS vertices by matched-degree. */
    err = InitializeRHSBuckets(g);
    if( LH_SUCCESS!=err ) {
        return err;
    }

    /* Main loop: repeatedly search the graph for ways to improve the
     * current assignment */
    MainLoop(g);

    /* The assignment is now an LH Matching (i.e. optimal cost) */

    /* Cleanup */
    DestroyQueue(g);
    DestroyBuckets(g);
    #ifdef DUMP
        DumpGraph(g);
        DumpLoad(g);
    #endif
    PrintStats(g);
    DPRINT( printf("--- LHMatch BFS Finished ---\n"); )

    return LH_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\strarray.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    StrArray.h

Abstract:

    This is the a header file of handy functions and macros for TCHAR
    string arrays.

    These arrays are in the following format (spaces added for clarity):

       one \0 two \0 three \0 \0

    where \0 is a null character in the appropriate format.

    These functions are useful for the NetServerDiskEnum and NetConfigGetAll
    APIs, and possibly others.

Author:

    John Rogers (JohnRo) 03-Jan-1992

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    03-Jan-1992 JohnRo
        Created this file from bits and pieces in RxCommon and NetLib.
    01-Sep-1992 JohnRo
        RAID 5016: NetConfigGetAll heap trash.

--*/

#ifndef _STRARRAY_
#define _STRARRAY_


// These must be included first:

#include <windef.h>             // IN, LPTSTR, LPVOID, etc.

// These may be included in any order:

// (none)


//
//////////////////////////////// LPTSTR_ARRAY stuff //////////////////////////
//

typedef LPTSTR LPTSTR_ARRAY;


VOID
NetpAddTStrToTStrArray (
    IN OUT LPTSTR_ARRAY Dest,
    IN LPTSTR Src
    );


VOID
NetpCopyStrArrayToTStrArray (
    OUT LPTSTR_ARRAY Dest,  // string array: TCHARs
    IN  LPSTR  Src    // string array: 8-bit input in default codepage for LAN
    );


#if DBG

VOID
NetpDisplayTStrArray (
    IN LPTSTR_ARRAY Array
    );

#else // not DBG

#define NetpDisplayTStrArray(Array)     /* nothing */

#endif // not DBG


// BOOL
// NetpIsTStrArrayEmpty (
//     IN LPTSTR_ARRAY Array
//     );
#define NetpIsTStrArrayEmpty( Array )  \
    ( ( (*(Array)) == (TCHAR) '\0') ? TRUE : FALSE )


// LPTSTR_ARRAY
// NetpNextTStrArrayEntry (
//     IN LPTSTR_ARRAY Array
//     );
#define NetpNextTStrArrayEntry(Array) \
    ( ((LPTSTR)(Array)) + (STRLEN(Array) + 1) )


//
// Return number of entries in this string array.
//
DWORD
NetpTStrArrayEntryCount (
    IN LPTSTR_ARRAY Array
    );


//
// Return number of bytes to allocate for this string array.
// This includes the "extra" trailing null char.
//
DWORD
NetpTStrArraySize(
    IN LPTSTR_ARRAY Array
    );


//
//////////////////////////////// LPSTR_ARRAY stuff //////////////////////////
//

typedef LPSTR  LPSTR_ARRAY;

DWORD
NetpStrArraySize(
    IN LPSTR_ARRAY Array
    );


#endif // ndef _STRARRAY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\lhmatch\lhmatchint.h ===
/***** Header Files *****/
#include "LHMatch.h"


/***** Compilation Settings *****/
/* DBG: Debug build. Check assertions, etc. */
//#define DBG

/* STATS: Report graph statistics and performance counters after each run. */
//#define STATS

/* DUMP: Dump the graph at the beginning and end of each run. */
//#define DUMP

/* WORST_GREEDY: The BFS algorithm starts off by computing a greedy
 * matching. Usually, we want to find the best greedy matching that we can
 * so that the algorithm will run quickly. For testing purposes, we can define
 * this flag and the worst initial greedy matching will be found instead. */
//#define WORST_GREEDY


/***** Constants *****/
#define TRUE            1
#define FALSE           0
#ifndef NULL
    #define NULL        0L
#endif
#define MAX_INT         ((int)((~((unsigned int)0))>>1))
#define MAGIC1          0x50165315
#define MAGIC2          0x50165315


/***** Macros *****/
#ifdef DBG
    #define DPRINT(x)   if(gDebugPrint) x
#else
    #define DPRINT(x)
    #undef assert
    #define assert(x)
#endif
#define IS_LHS_VTX(v)   ((v)->id < g->numLHSVtx)
#define INTMIN(a,b)     ((a<b)?(a):(b))
#define INTMAX(a,b)     ((a)>(b)?(a):(b))


/***** Vertex Structure *****/
struct Vertex;
struct Vertex {

    /***** Input *****/
    /* The following members are input by the user of the library. */

    /* degree: How many vertices are adjacent to this vertex.
     * Equivalently, the length of the adjacency list. */
    int             degree;

    /* adjList: A list of vertex pointers indicating the vertices
     * that are adjacent to this vertex. */
    struct Vertex   **adjList;

    /* adjListSize: The allocated size of the adjacency list. */
    int             adjListSize;

    /* id: Used to identify a vertex, for debug purposes only. */
    int             id;             


    /***** Input / Output *****/
    /* The following members are used for both input and output. */

    /* matchedWith: This member is only used for left-hand vertices
     * and is ignored for right-hand vertices. This member may optionally
     * be passed as input from the user of the library to specify an initial
     * assignment. If this vertex is not initially assigned, this member
     * should be NULL. */
    struct Vertex   *matchedWith;


    /***** Output *****/
    /* The following members are used for output only. */

    /* numMatched: This member is only used for right-hand vertices
     * and is ignored for left-hand vertices. */
    int             numMatched;
    

    /***** Internal *****/
    /* The following members are used internally by the algorithms and
     * should not be examined by users of the library. */

    /* parent: Used by both the BFS algorithm to represent the
     * breadth-first search tree. */
    struct Vertex   *parent;

    /* fLink, bLink: Used by both the BFS algorithm to insert this
     * vertex into a bucket, which is stored as a doubly-linked list. */
    struct Vertex   *fLink, *bLink;
};
typedef struct Vertex Vertex;


/***** Stats Structure *****/
typedef struct {
    int     TotalAugs;
    int     TotalBFSTrees;
    int     TotalAugBFSTreeSize;
    int     TotalAugpathLen;
    int     TotalRestarts;
} Stats;


/***** Graph Structure *****/
typedef struct {
    /* magic1: A magic number to identify our graph structure. */
    int     magic1;

    /* numLHSVtx: The number of vertices on the left-hand side of the graph. */
    int     numLHSVtx;

    /* numRHSVtx: The number of vertices on the right-hand side of the graph. */
    int     numRHSVtx;

    /* lVtx: The array of left-hand vertices in the graph. */
    Vertex  *lVtx;

    /* rVtx: The array of right-hand vertices in the graph. */
    Vertex  *rVtx;

    /* maxRHSLoad: The maximum load of the right-hand vertices */
    int     maxRHSLoad;

    /* minRHSLoad: The minimum load of the right-hand vertices */
    int     minRHSLoad;

    /* Buckets: Used to organize vertices by degree / load */
    Vertex  **Buckets;

    /* Queue: For breadth-first search */
    Vertex  **Queue;
    int     Qsize;
    
    /* Counters for monitoring performance */
    #ifdef STATS
    Stats   stats;
    #endif

    /* magic2: A second magic number to identify our graph structure. */
    int     magic2;
} Graph;


/***** Function Prototypes *****/
int  LHAlgOnline(Graph *g);
int  LHAlgBFS(Graph *g);

void AddVtxToBucket(Graph *g, Vertex *v, int b);
void RemoveVtxFromBucket(Graph *g, Vertex *v, int b);
void DestroyBuckets(Graph *g);
int  OrderedGreedyAssignment(Graph *g);
int  InitializeRHSBuckets(Graph *g);
int  InitializeQueue(Graph *g);
void DestroyQueue(Graph *g);
void ClearAlgState(Graph *g);
void DumpGraph(Graph *g);
void DumpLoad(Graph *g);


/***** Globals *****/
#ifdef DBG
    extern int gDebugPrint;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\lhmatch\lhonline.c ===
/******************************************************************************
 *
 * LHMatch Online
 *
 * Authors: Nicholas Harvey and Laszlo Lovasz
 *
 * Developed: April 2001
 *
 * Algorithm Description:
 *
 * Let S be {}
 * Let M be {}
 * While S != U Do
 *    Assert( S is a subset of U )
 *    Assert( M is an optimal LH matching of G restricted to S \union V )
 *    Let x \member U \ S
 *    For each edge (u,v) in E
 *        If (u,v) \member M, orient this edge from v to u
 *        Else, orient this edge from u to v
 *    Build a directed breadth-first search tree rooted at x
 *    Let y be a vertex in the BFS tree \intersection V with minimum M-degree
 *    Alternate along the unique x->y dipath, increasing the size of M by one
 *    Add x to S
 * Repeat
 *
 * This algorithm is called online because the optimality of the matching is
 * maintained as the size increases.
 *
 * Runtime:
 *
 * The worst-case runtime is O(|U| * |E|), but in practice it is quite slow.
 *
 ******************************************************************************/

/***** Header Files *****/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "LHMatchInt.h"

/***** EnqueueNbr *****/
/* Enqueue all neigbours of this vertex which have not yet been visited.
 * If 'matchedOnly' is true, enqueue only the matched-neigbours. */
static void EnqueueNbr(Graph *g, Vertex *v, char matchedOnly) {
    Vertex  *n;
    int     i;

    for(i=0;i<v->degree;i++) {
        n=v->adjList[i];
        if( !matchedOnly || n->matchedWith==v ) {
            if( n->parent==NULL ) {
                DPRINT( printf("Adding %d to queue with parent %d\n",n->id,v->id); )
                g->Queue[g->Qsize++]=n;
                n->parent=v;
            } else {
                DPRINT( printf("Not adding %d to queue -- already there\n",n->id); )
            }
        }
    }
}

/***** UpdateMinRHSLoad *****/
static void UpdateMinRHSLoad(Graph *g) {
    int i;

    g->minRHSLoad = g->numLHSVtx;
    for(i=0;i<g->numRHSVtx;i++) {
        g->minRHSLoad = INTMIN(g->minRHSLoad,g->rVtx[i].numMatched);
    }
}

/***** AugmentPath *****/
/* Found an augmenting path. Switch the matching edges along it. */
static void AugmentPath(Graph *g, Vertex *u, Vertex *v) {
    Vertex  *w,*p;

    DPRINT( printf("V: %d. Increase load to %d\n", v->id, v->numMatched+1 ); )

    /* Switch along the path */
    w=v;
    w->numMatched++;
    do {
        p=w->parent;
        p->matchedWith=w;
        w=p->parent;
    } while(p!=u);
    assert(w==p);

    /* Update minRHSLoad */
    if( v->numMatched==g->minRHSLoad+1 ) {
        UpdateMinRHSLoad(g);
    }
}

/***** BFS *****/
/* Perform a breadth-first search rooted at node i. */
static Vertex* BFS(Graph *g,Vertex *u) {
    Vertex  *bestV,*v;
    int     q;

    /* Start a BFS from u */
    DPRINT( printf("Using %d as root\n",u->id); )
    u->parent=u;
    g->Queue[0]=u; g->Qsize=1;
    bestV=NULL;
        
    /* Process the vertices in the queue */
    for(q=0;q<g->Qsize;q++) {
        v = g->Queue[q];
        DPRINT( printf("Dequeued %d: ",v->id); )
        if(IS_LHS_VTX(v)) {
            /* Its a LHS-vertex; enqueue all neigbours */
            DPRINT( printf("LHS -> Enqueuing all nbrs\n"); )
            EnqueueNbr(g, v, FALSE);
        } else {
            /* Its a RHS-vertex; enqueue all matched-neighbours */
            DPRINT( printf("RHS -> Enqueuing all %d matched-nbrs\n",
                v->numMatched); )
            EnqueueNbr(g, v, TRUE);
            if( NULL==bestV || v->numMatched<bestV->numMatched ) {
                bestV=v;
                if( v->numMatched==g->minRHSLoad ) {
                    /* v has the minimum M-degree out of all RHS vertices.
                     * We can stop the BFS prematurely. */
                    break;
                }
            }
        }
    }

    return bestV;
}

/***** LHAlgOnline *****/
int LHAlgOnline(Graph *g) {
    Vertex  *bestV;
    int     i,j,err;

    DPRINT( printf("--- LHMatch Online Started ---\n"); )
    g->minRHSLoad=0;

    err = InitializeQueue(g);
    if( LH_SUCCESS!=err ) {
        return err;
    }

    UpdateMinRHSLoad(g);
    
    /* Examine every vtx on LHS */
    for(i=0;i<g->numLHSVtx;i++) {

        /* Build a BFS tree and find the best augmenting path */
        bestV = BFS(g,&(g->lVtx[i]));

        /* If bestV is null, lVtx[i] must have degree 0 */
        if( NULL!=bestV ) {
            DPRINT( printf("Best aug. path is from %d to %d\n",g->lVtx[i].id,bestV->id); )
            AugmentPath(g,&(g->lVtx[i]),bestV);
        }

        /* Clear the marks on all nodes in the BFS tree */
        for(j=0;j<g->Qsize;j++) {
            g->Queue[j]->parent=NULL;
        }
    }

    DestroyQueue(g);
    DPRINT( printf("--- LHMatch Online Finished ---\n"); )
    return LH_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\lhmatch\lhmain.c ===
/******************************************************************************
 *
 * LHMain.c
 *
 * Author: Nicholas Harvey
 *
 * Implements all LHMatch API functions and other functions that are common to
 * all LHMatch algorithms.
 *
 ******************************************************************************/

/***** Header Files *****/
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <assert.h>
#include "LHMatchInt.h"


/***** Constants *****/
/* MIN_ADJ_LIST: The minimum size of a Vertex's adjacency list */
#define MIN_ADJ_LIST    4


/***** Globals *****/
#ifdef DBG
    int        gDebugPrint=0;
#endif


/***** CheckGraph *****/
/* Verify that a graph structure we were passed is okay */
Graph* CheckGraph( LHGRAPH graph ) {
    Graph* g = (Graph*) graph;

    if( g==NULL || g->magic1!=MAGIC1 || g->magic2!=MAGIC2 ) {
        return NULL;
    }

    return g;
}

/***** AddVtxToBucket *****/
void AddVtxToBucket(Graph *g, Vertex *v, int b) {
    v->fLink = g->Buckets[b];
    v->bLink = NULL;
    if(g->Buckets[b]) g->Buckets[b]->bLink=v;
    g->Buckets[b] = v;
}

/***** RemoveVtxFromBucket *****/
void RemoveVtxFromBucket(Graph *g, Vertex *v, int b) {
    if(v->fLink) {
        v->fLink->bLink = v->bLink;
    }
    if(v->bLink) {
        v->bLink->fLink = v->fLink;
    } else {
        g->Buckets[b] = v->fLink;
    }
}

/***** DestroyBuckets *****/
void DestroyBuckets(Graph *g) {
    free(g->Buckets);
    g->Buckets = NULL;
}

/***** InitializeLHSBuckets *****/
static int InitializeLHSBuckets(Graph *g) {
    Vertex    *vtx=g->lVtx;
    int        i, maxLHSDegree, numLHSVtx=g->numLHSVtx;

    /* Find degree of LHS vertices */
    maxLHSDegree=0;
    for(i=0;i<numLHSVtx;i++) {
        maxLHSDegree = INTMAX(maxLHSDegree, vtx[i].degree);
    }

    /* Inititalize array of buckets */
    g->Buckets = (Vertex**) calloc(maxLHSDegree+1, sizeof(Vertex*));
    if( NULL==g->Buckets ) {
        return LH_MEM_ERR;
    }

    /* Add LHS vertices to their buckets */
    for(i=0;i<numLHSVtx;i++) {
        if( vtx[i].degree>0 ) {
            AddVtxToBucket(g, &vtx[i], vtx[i].degree);
        }
    }

    return maxLHSDegree;
}

/***** OrderedGreedyAssignment *****/
/* Use a greedy approach to find an initial assignment. Examine LHS
 * vertices in order of their degree. */
int OrderedGreedyAssignment(Graph *g) {
    int b,j, maxLHSDegree;
    Vertex *u, *r,*bestR;

    maxLHSDegree = InitializeLHSBuckets(g);
    if( maxLHSDegree<0 ) {
        /* Error occurred */
        return maxLHSDegree;
    }

    /* Examine each bucket */
    for(b=1;b<=maxLHSDegree;b++) {

        /* And each LHS vertex in the bucket */
        for( u=g->Buckets[b]; u; u=u->fLink ) {
            
            /* If u has already been matched, skip it */
            if( NULL!=u->matchedWith ) continue;

            /* Find right-hand neighbour with lowest matching-degree */
            bestR = u->adjList[0];
            for(j=1;j<u->degree;j++) {
                r=u->adjList[j];
                #ifdef WORST_GREEDY
                    if(r->numMatched>bestR->numMatched)
                        bestR=r;
                #else
                    if(r->numMatched<bestR->numMatched)
                        bestR=r;
                #endif
            }

            /* Assign LHS vertex to lowest matching-degree RHS vertex */
            u->matchedWith = bestR;
            u->numMatched = 1;
            bestR->numMatched++;
        }
    }

    DestroyBuckets(g);
    return LH_SUCCESS;
}

/***** GreedyAssignment *****/
/* Simple Greedy Assignment */
void GreedyAssignment(Graph *g) {
    int i,j;
    Vertex *r,*bestR,*vtx=g->lVtx;

    /* For each LHS vertex */
    for(i=0;i<g->numLHSVtx;i++) {

        /* Find right-hand neighbour with lowest matching-degree */
        bestR = vtx[i].adjList[0];
        for(j=1;j<vtx[i].degree;j++) {
            r=vtx[i].adjList[j];
            if(r->numMatched<bestR->numMatched)
                bestR=r;
        }

        /* Assign LHS vertex to lowest matching-degree RHS vertex */
        vtx[i].matchedWith = bestR;
        vtx[i].numMatched = 1;
        bestR->numMatched++;
    }
}

/***** InitializeRHSBuckets *****/
/* Insert all RHS vertices into buckets. Their matched-degree
 * (i.e. numMatched) determines what bucket they live in. */
int InitializeRHSBuckets(Graph *g) {
    Vertex    *vtx=g->rVtx;
    int        i, maxRHSLoad, numRHSVtx=g->numRHSVtx;

    /* Find maximum M-degree of RHS vertices */
    maxRHSLoad=0;
    for(i=0;i<numRHSVtx;i++) {
        maxRHSLoad = INTMAX(maxRHSLoad, vtx[i].numMatched);
    }
    g->maxRHSLoad = maxRHSLoad;

    /* Allocate array of buckets */
    g->Buckets = (Vertex**) calloc(maxRHSLoad+1, sizeof(Vertex*));
    if( NULL==g->Buckets ) {
        return LH_MEM_ERR;
    }

    /* Add RHS vertices to their buckets */
    for(i=0;i<numRHSVtx;i++) {
        if( vtx[i].degree>0 ) {
            AddVtxToBucket( g, &vtx[i], vtx[i].numMatched );
        }
    }

    return LH_SUCCESS;
}

/***** InitializeQueue *****/
int InitializeQueue(Graph *g) {
    g->Qsize=0;
    g->Queue=(Vertex**) malloc((g->numLHSVtx+g->numRHSVtx)*sizeof(Vertex*));
    if(NULL==g->Queue) {
        return LH_MEM_ERR;
    }
    return LH_SUCCESS;
}

/***** DestroyQueue *****/
void DestroyQueue(Graph *g) {
    free(g->Queue);
    g->Queue=NULL;
    g->Qsize=0;
}

/***** ClearVertex *****/
/* Clear one vertex */
static void ClearVertex(Vertex *v) {
    v->parent = NULL;
    v->fLink = NULL;
    v->bLink = NULL;
}

/***** ClearAlgState *****/
/* Clears all the internal algorithm state from the graph.
 * Note: Does not affect the edges or the matching */
void ClearAlgState(Graph *g) {
    int i;

    /* Clear state that is stored in the graph structure */
    g->maxRHSLoad = 0;
    g->minRHSLoad = 0;
    g->Qsize = 0;

    /* Clear state that is stored in the vertices */
    for(i=0;i<g->numLHSVtx;i++) {
        ClearVertex(&(g->lVtx[i]));
    }
    for(i=0;i<g->numRHSVtx;i++) {
        ClearVertex(&(g->rVtx[i]));
    }
}

/***** DumpGraph *****/
void DumpGraph(Graph *g) {
    int i,j,m=0;
    
    /* Count # edges */
    for(i=0;i<g->numLHSVtx;i++) {
        m+=g->lVtx[i].degree;
    }

    printf("--- Dumping graph---\n");
    printf("|lhs|=%d, |rhs|=%d |edge|=%d\n", g->numLHSVtx, g->numRHSVtx, m);
    
    /* Dump each LHS vertex and its list of neighbours */
    for(i=0;i<g->numLHSVtx;i++) {
        printf("LHS Vtx %02d: Match=%d, Deg=%d, Nbr=[ ",
            i,
            g->lVtx[i].matchedWith ? g->lVtx[i].matchedWith->id : -1,
            g->lVtx[i].degree );
        for(j=0;j<g->lVtx[i].degree;j++) {
            printf("%d ", g->lVtx[i].adjList[j]->id);
        }
        printf("]\n");
    }

    /* Dump each RHS vertex and its list of neighbours */
    for(i=0;i<g->numRHSVtx;i++) {
        printf("RHS Vtx %02d: NumMatch=%d, Deg=%d, Nbr=[ ",
            i+g->numLHSVtx, g->rVtx[i].numMatched, g->rVtx[i].degree );
        for(j=0;j<g->rVtx[i].degree;j++) {
            printf("%d ", g->rVtx[i].adjList[j]->id);
        }
        printf("]\n");
    }

    printf("--- Finished dumping graph---\n");
}

/***** DumpLoad *****/
void DumpLoad(Graph *g) {
    int i;

    printf("--- Dumping load ---\n");
    for(i=0;i<g->numRHSVtx;i++) {
        printf("RHS Vtx %02d: |M-nbrs|=%d\n",g->rVtx[i].id,g->rVtx[i].numMatched);
    }
    printf("--- Finished dumping load ---\n");
}

/***** LHCreateGraph *****/
/*
 * Description:
 *
 *        Create a graph structure on which which to compute the matching.
 * 
 * Parameters:
 *
 *        IN    numLHSVtx   The number of vertices on the left-hand side of
 *                          the bipartite graph. Must be > 0.
 *
 *        IN    numRHSVtx   The number of vertices on the right-hand side of
 *                          the bipartite graph. Must be > 0.
 *
 *        OUT    pGraph     On successful completion, pGraph will contain a
 *                          valid graph structure.
 *
 * Return Value:
 *
 *        Error Code
 */
int LHCreateGraph( int numLHSVtx, int numRHSVtx, LHGRAPH* pGraph ) {
    Graph     *g;
    int        i;

    /* Check parameters */
    if( numLHSVtx<=0 || numRHSVtx<=0 || NULL==pGraph) {
        return LH_PARAM_ERR;
    }

    /* Allocate the graph structure */
    g = (Graph*) calloc( 1, sizeof(Graph) );
    if( NULL==g ) {
        return LH_MEM_ERR;
    }

    /* Allocate the LHS vertices */
    g->lVtx = (Vertex*) calloc( numLHSVtx, sizeof(Vertex) );
    if( NULL==g->lVtx ) {
        free(g);
        return LH_MEM_ERR;
    }

    /* Allocate the RHS vertices */
    g->rVtx = (Vertex*) calloc( numRHSVtx, sizeof(Vertex) );
    if( NULL==g->rVtx ) {
        free(g->lVtx);
        free(g);
        return LH_MEM_ERR;
    }

    /* Initialize the vertices */
    for(i=0;i<numLHSVtx;i++) {
        g->lVtx[i].id = i;
    }
    for(i=0;i<numRHSVtx;i++) {
        g->rVtx[i].id = i+numLHSVtx;
    }

    /* Initialize the graph structure */
    g->numLHSVtx = numLHSVtx;
    g->numRHSVtx = numRHSVtx;
    g->magic1 = MAGIC1;
    g->magic2 = MAGIC2;

    /* Return the graph */
    *pGraph = g;
    return LH_SUCCESS;
}

/***** GrowAdjList *****/
int GrowAdjList( Vertex *v, int newSize ) {
    Vertex **newAdjList;

    /* If we have no list, make the initial allocation */
    if( 0==v->adjListSize ) {
        v->adjList = (Vertex**) malloc( sizeof(Vertex*)*MIN_ADJ_LIST );
        if( NULL==v->adjList ) {
            return LH_MEM_ERR;
        }
        v->adjListSize = MIN_ADJ_LIST;
    }
    
    /* Check to see if we already have enough space in the list */
    while( newSize>v->adjListSize ) {

        /* Not enough: double the size of the list */
        newAdjList = (Vertex**) realloc( v->adjList, sizeof(Vertex*)*(v->adjListSize*2) );
        if( NULL==newAdjList ) {
            return LH_MEM_ERR;
        }
        v->adjList = newAdjList;
        v->adjListSize *= 2;

    }
    
    return LH_SUCCESS;
}

/***** LHAddEdge *****/
/*
 * Description:
 *
 *        Add an edge to the graph connecting lhsVtx and rhsVtx
 *
 * Parameters:
 *
 *        IN  graph         A graph successfully created by LHGraphCreate.
 *        
 *        IN  lhsVtx        The ID of the left-hand vertex. Legal values are
 *                          0 <= lhsVtx < numLHSVtx
 *
 *        IN  rhsVtx        The ID of the right-hand vertex. Legal values are
 *                          0 <= rhsVtx < numRHSVtx
 *
 * Return Value:
 *
 *        Error Code
 */
int LHAddEdge( LHGRAPH graph, int lhsVtx, int rhsVtx ) {
    Graph     *g;
    Vertex    *lv, *rv;
    int        i;

    /* Check parameters */
    g = CheckGraph(graph);
    if( NULL==g ) {
        return LH_PARAM_ERR;
    }
    if( lhsVtx<0 || lhsVtx>=g->numLHSVtx ) {
        return LH_PARAM_ERR;
    }
    if( rhsVtx<0 || rhsVtx>=g->numRHSVtx ) {
        return LH_PARAM_ERR;
    }
    
    /* Get pointers to the two vertices */
    lv = &g->lVtx[lhsVtx];
    rv = &g->rVtx[rhsVtx];

    /* Check if edge already exists */
    for( i=0; i<lv->degree; i++ ) {
        if( lv->adjList[i]==rv ) {
            return LH_EDGE_EXISTS;
        }
    }

    /* Increase the size of the adjacency lists */
    if( LH_SUCCESS!=GrowAdjList(lv,lv->degree+1) ) {
        return LH_MEM_ERR;
    }
    if( LH_SUCCESS!=GrowAdjList(rv,rv->degree+1) ) {
        return LH_MEM_ERR;
    }
    
    /* Update the adjacency lists */
    lv->adjList[ lv->degree++ ] = rv;
    rv->adjList[ rv->degree++ ] = lv;

    return LH_SUCCESS;
}

/***** LHSetMatchingEdge *****/
/*
 * Description:
 *
 *        Set the edge connecting lhsVtx and rhsVtx in the graph to be
 *        a matching edge. The edge (lhsVtx,rhsVtx) must have already been
 *        created with a call to LHVtxAddEdge.
 *
 *        Left-hand vertices may only have one matching edge. If lhsVtx
 *        already has a matching edge, that edge will be demoted from a
 *        matching edge to a normal edge. Right-hand vertices may have
 *        multiple matching edges.
 *        
 * Parameters:
 *
 *        IN  graph        A graph successfully created by LHGraphCreate.
 *        
 *        IN  lhsVtx       The ID of the left-hand vertex. Legal values are
 *                         0 <= lhsVtx < numLHSVtx
 *
 *        IN  rhsVtx       The ID of the right-hand vertex. Legal values are
 *                         0 <= rhsVtx < numRHSVtx
 *
 * Return Value:
 *
 *        Error Code
 */
int LHSetMatchingEdge( LHGRAPH graph, int lhsVtx, int rhsVtx ) {
    Graph   *g;
    Vertex  *lv,*rv;
    int      i;

    /* Check parameters */
    g = CheckGraph(graph);
    if( NULL==g ) {
        return LH_PARAM_ERR;
    }
    if( lhsVtx<0 || lhsVtx>=g->numLHSVtx ) {
        return LH_PARAM_ERR;
    }
    if( rhsVtx<0 || rhsVtx>=g->numRHSVtx ) {
        return LH_PARAM_ERR;
    }
    
    /* Get pointers to the two vertices */
    lv = &g->lVtx[lhsVtx];
    rv = &g->rVtx[rhsVtx];

    /* Verify that the edge exists */
    for(i=0;i<lv->degree;i++) {
        if(lv->adjList[i]==rv) {
            break;
        }
    }
    if(i==lv->degree) {
        /* Edge does not exist */
        return LH_PARAM_ERR;
    }

    /* Check if the edge is already a matching edge */
    if( rv==lv->matchedWith ) {
        /* lv and rv are already matched */
        return LH_SUCCESS;
    }

    /* If lv is already matched with another vertex, that vertex must be updated */
    if( NULL!=lv->matchedWith ) {
        lv->matchedWith->numMatched--;
    }

    /* Match lv with rv */
    lv->matchedWith=rv;
    rv->numMatched++;

    return LH_SUCCESS;
}

/***** LHGetDegree *****/
/*
 * Description:
 *
 *        Get the degree (number of neighbours) of a vertex.
 *        
 * Parameters:
 *
 *        IN  graph         A graph successfully created by LHGraphCreate.
 *        
 *        IN  vtxID         The ID of the vertex to examine.
 *
 *        IN  left          If the vertex to examine is a left-vertex, this
 *                          parameter should be TRUE. If the vertex is a right-
 *                          vertex, this parameter should be FALSE.
 *
 * Return Value:
 *
 *        >=0               The number of neighbours
 *
 *        <0                Error Code
 */
int LHGetDegree( LHGRAPH graph, int vtxID, char left ) {
    Graph     *g;
    int        degree;

    /* Check parameters */
    g = CheckGraph(graph);
    if( NULL==g ) {
        return LH_PARAM_ERR;
    }
    if( vtxID<0 ) {
        return LH_PARAM_ERR;
    }
    if( left && vtxID>=g->numLHSVtx ) {
        return LH_PARAM_ERR;
    }
    if( !left && vtxID>=g->numRHSVtx ) {
        return LH_PARAM_ERR;
    }

    /* Find the degree of the specified vertex */
    if( left ) {
        degree = g->lVtx[vtxID].degree;
    } else {
        degree = g->rVtx[vtxID].degree;
    }

    assert( degree>=0 );
    return degree;
}

/***** LHGetMatchedDegree *****/
/*
 * Description:
 *
 *        Get the matched-degree (number of matched neighbours) of a
 *        right-hand vertex.
 *        
 * Parameters:
 *
 *        IN  graph         A graph successfully created by LHGraphCreate.
 *        
 *        IN  vtxID         The ID of the right hand vertex to examine.
 *
 * Return Value:
 *
 *        >=0               The number of neighbours
 *
 *        <0                Error Code
 */
int LHGetMatchedDegree( LHGRAPH graph, int vtxID) {
    Graph     *g;
    int        degree;

    /* Check parameters */
    g = CheckGraph(graph);
    if( NULL==g ) {
        return LH_PARAM_ERR;
    }
    if( vtxID<0 ) {
        return LH_PARAM_ERR;
    }
    if( vtxID>=g->numRHSVtx ) {
        return LH_PARAM_ERR;
    }

    /* Find the degree of the specified vertex */
    degree = g->rVtx[vtxID].numMatched;

    assert( degree>=0 );
    return degree;
}


/***** LHGetNeighbour *****/
/*
 * Description:
 *
 *        Get the n'th neighbour of the vertex specified by vtxID.
 *        
 * Parameters:
 *
 *        IN  graph         A graph successfully created by LHGraphCreate.
 *        
 *        IN  vtxID         The ID of the vertex to examine.
 *
 *        IN  left          If the vertex to examine is a left-vertex, this
 *                          parameter should be TRUE. If the vertex is a right-
 *                          vertex, this parameter should be FALSE.
 *
 *        IN  n             The index of the neighbour to retrieve. Legal values
 *                          are 0 <= n < Degree(vtxID).
 *
 * Return Value:
 *
 *        >=0               The vertex ID of the n'th neighbour. If 'left' is TRUE,
 *                          this ID refers to a right-hand vertex. Conversely, if
 *                          'left' is FALSE, this ID refers to a left-hand vertex.
 *
 *        <0                Error Code
 */
int LHGetNeighbour( LHGRAPH graph, int vtxID, char left, int n ) {
    Graph     *g;
    int        degree;
    Vertex*    v;

    /* Leverage the LHGetDegree function to do most of the input validation */
    g = CheckGraph(graph);
    degree = LHGetDegree( graph, vtxID, left );
    if( degree < 0 ) {
        return degree;
    }

    /* Check parameter n */
    if( n<0 || n>=degree ) {
        return LH_PARAM_ERR;
    }

    if( left ) {
        v = g->lVtx[vtxID].adjList[n];
        assert(v);
        /* Transform internal ID to external ID */
        return (v->id - g->numLHSVtx);
    } else {
        v = g->rVtx[vtxID].adjList[n];
        assert(v);
        return v->id;
    }
}

/***** LHFindLHMatching *****/
/*
 * Description:
 *
 *        Find an optimal matching in the graph.
 *        
 * Parameters:
 *
 *        IN  graph         A graph successfully created by LHGraphCreate,
 *                          to which edges have been added using LHAddEdge.
 *
 *        IN  alg           Specifies which algorithm to use. For most purposes,
 *                          LH_ALG_DEFAULT is fine.
 *
 * Return Value:
 *
 *        Error Code
 */
int LHFindLHMatching( LHGRAPH graph, LHALGTYPE alg ) {
    Graph    *g;

    g = CheckGraph(graph);
    if( NULL==g ) {
        return LH_PARAM_ERR;
    }

    ClearAlgState(g);

    switch( alg ) {
        case LH_ALG_ONLINE:
            return LHAlgOnline(g);
            break;

        case LH_ALG_BFS:
            return LHAlgBFS(g);
            break;

        default:
            /* Invalid algorithm selection */
            return LH_PARAM_ERR;
    }
}

/***** LHGetMatchedVtx *****/
/*
 * Description:
 *
 *        Determine which vertex on the right-hand side is matched to a
 *        given vertex on the left-hand side.
 *        
 * Parameters:
 *
 *        IN  graph         A graph successfully created by LHGraphCreate,
 *                          to which edges have been added using LHAddEdge.
 *
 *        IN  lhsVtx        The left-hand vertex to query.
 *
 * Return Value:
 *
 *        >=0               The index of the right-hand vertex that is matched
 *                          with lhsVtx.
 *
 *        <0                Error Code. If LH_MATCHING_ERR is returned, then
 *                          lhsVtx is not matched with any right-hand vertex.
 */
int LHGetMatchedVtx( LHGRAPH graph, int lhsVtx ) {
    Graph     *g;
    Vertex    *lv,*rv;

    /* Check parameters */
    g = CheckGraph(graph);
    if( NULL==g ) {
        return LH_PARAM_ERR;
    }
    if( lhsVtx<0 || lhsVtx>=g->numLHSVtx ) {
        return LH_PARAM_ERR;
    }
    
    /* Get pointer to left-hand vertex */
    lv = &(g->lVtx[lhsVtx]);

    /* Find matching partner */
    rv = lv->matchedWith;
    if( rv==NULL ) {
        return LH_MATCHING_ERR;
    }
    
    /* Transform internal ID to external ID */
    return (rv->id - g->numLHSVtx);
}

/***** LHGetStatistics *****/
/*
 * Description:
 *
 *        Obtain statistics about the current matching.
 *        
 * Parameters:
 *
 *        IN  graph         A graph for which an optimal LH Matching has
 *                          been computed using LHFindLHMatching().
 *
 * Return Value:
 *
 *        Error Code
 */
int LHGetStatistics( LHGRAPH graph, LHSTATS *stats ) {
    Graph     *g;
    int        i, m=0, mrv=0, trmd=0, cost=0;
    
    /* Check parameters */
    g = CheckGraph(graph);
    if( NULL==g || NULL==stats ) {
        return LH_PARAM_ERR;
    }
    
    /* Loop over all right-hand vertices */
    for(i=0;i<g->numRHSVtx;i++) {
        m+=g->rVtx[i].degree;
        if(g->rVtx[i].numMatched>0) mrv++;
        trmd+=g->rVtx[i].numMatched;
        cost+=g->rVtx[i].numMatched*(g->rVtx[i].numMatched+1)/2;
    }

    stats->numEdges = m;
    stats->numMatchingEdges = trmd;
    stats->matchingCost = cost;
    stats->bipMatchingSize = mrv;

    return LH_SUCCESS;
}

/***** LHClearMatching *****/
/*
 * Description:
 *
 *        Clear the current matching.
 *        
 * Parameters:
 *
 *        IN  graph         A graph successfully created by LHGraphCreate,
 *                          to which edges have been added using LHAddEdge.
 *
 * Return Value:
 *
 *        Error Code
 */
int LHClearMatching( LHGRAPH graph ) {
    Graph    *g;
    int       i;

    /* Check parameters */
    g = CheckGraph(graph);
    if( NULL==g ) {
        return LH_PARAM_ERR;
    }
    
    /* Clear left-hand vertices */
    for( i=0; i<g->numLHSVtx; i++ ) {
        g->lVtx[i].matchedWith=NULL;
    }
    
    /* Clear right-hand vertices */
    for( i=0; i<g->numRHSVtx; i++ ) {
        g->rVtx[i].numMatched=0;
    }

    return LH_SUCCESS;
}

/***** LHDestroyGraph *****/
/*
 * Description:
 *
 *        Destroy the current graph.
 *        
 * Parameters:
 *
 *        IN  graph        A graph successfully created by LHGraphCreate.
 *
 * Return Value:
 *
 *        Error Code
 */
int LHDestroyGraph( LHGRAPH graph ) {
    Graph    *g;
    int       i;

    /* Check parameters */
    g = CheckGraph(graph);
    if( NULL==g ) {
        return LH_PARAM_ERR;
    }
    
    /* Free each vertex's adjacency list */
    for(i=0;i<g->numLHSVtx;i++) {
        free( g->lVtx[i].adjList );
    }
    for(i=0;i<g->numRHSVtx;i++) {
        free( g->rVtx[i].adjList );
    }

    /* Free all other lists */
    if( g->lVtx )        free( g->lVtx );
    if( g->rVtx )        free( g->rVtx );
    if( g->Buckets )     free( g->Buckets );
    if( g->Queue )       free( g->Queue );

    /* Clear and free the graph itself */
    memset(graph,0,sizeof(Graph));
    free(graph);

    return LH_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\inc\xpress.h ===
#ifndef _XPRESS_H_
#define _XPRESS_H_

#ifdef _MSC_VER
#pragma once
#endif


/* ------------------------------------------------------------------------ */
/*                                                                          */
/*  Copyright (c) Microsoft Corporation, 2000-2001. All rights reserved.    */
/*  Copyright (c) Andrew Kadatch, 1991-2001. All rights reserved.           */
/*                                                                          */
/*  Microsoft Confidential -- do not redistribute.                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */


#ifdef __cplusplus
extern "C" {
#endif

/* ---------------------- Common declarations ------------------------- */
/*                        -------------------                           */

// max. size of input block
#define XPRESS_MAX_BLOCK_LOG    16
#define XPRESS_MAX_BLOCK        (1 << XPRESS_MAX_BLOCK_LOG)


// preferred data alignment to avoid misaligned accesses
#define XPRESS_ALIGNMENT        8

// declare default calling convention used in xpress
#if !defined (UNIX) && !defined (XPRESS_CALL)
#define XPRESS_CALL __stdcall
#endif


// user-supplied callback function that allocates memory
// if there is no memory available it shall return NULL
typedef
void *
XPRESS_CALL
  XpressAllocFn
  (
    void *context,      // user-defined context (as passed to XpressEncodeCreate)
    int size            // size of memory block to allocate
  );

// user-supplied callback function that releases memory
typedef
void
XPRESS_CALL
  XpressFreeFn
  (
    void *context,      // user-defined context (as passed to XpressEncodeClose)
    void *address       // pointer to the block to be freed
  );


/* ----------------------------- Encoder ------------------------------ */
/*                               -------                                */

// declare unique anonymous types for type safety
typedef struct {int XpressEncodeDummy;} *XpressEncodeStream;

// allocate and initialize encoder's data structures
// returns NULL if callback returned NULL (not enough memory)
XpressEncodeStream
XPRESS_CALL
  XpressEncodeCreate
  (
    int MaxOrigSize,                    // max size of original data block
    void *context,                      // user-defined context info (will  be passed to AllocFn)
    XpressAllocFn *AllocFn,             // memory allocation callback
    int CompressionLevel                // use 0 for speed, 9 for quality
  );


// callback function called by XpressEncode to indicate compression progress
typedef
void
XPRESS_CALL
  XpressProgressFn
  (
    void *context,                      // user-defined context
    int compressed                      // size of processed original data
  );
    

// returns size of compressed data
// if compression failed then compressed buffer is left as is, and
// original data should be saved instead
int
XPRESS_CALL
  XpressEncode
  (
    XpressEncodeStream stream,          // encoder's workspace
    void *CompAdr, int CompSize,        // compressed data region
    const void *OrigAdr, int OrigSize,  // input data block
    XpressProgressFn *ProgressFn,       // NULL or progress callback
    void *ProgressContext,              // user-defined context that will be passed to ProgressFn
    int ProgressSize                    // call ProgressFn each time ProgressSize bytes processed
  );

// invalidate input stream and release workspace memory
void
XPRESS_CALL
  XpressEncodeClose
  (
    XpressEncodeStream stream,          // encoder's workspace
    void *context, XpressFreeFn *FreeFn // memory releasing callback
  );


/* ----------------------------- Decoder ------------------------------ */
/*                               -------                                */

// declare unique anonymous types for type safety
typedef struct {int XpressDecodeDummy;} *XpressDecodeStream;

// allocate memory for decoder. Returns NULL if not enough memory.
XpressDecodeStream
XPRESS_CALL
  XpressDecodeCreate
  (
    void *context,                      // user-defined context info (will  be passed to AllocFn)
    XpressAllocFn *AllocFn              // memory allocation callback
  );

// decode compressed block. Returns # of decoded bytes or -1 otherwise
int
XPRESS_CALL
XpressDecode
  (
    XpressDecodeStream stream,          // decoder's workspace
    void *OrigAdr, int OrigSize,        // original data region
    int DecodeSize,                     // # of bytes to decode ( <= OrigSize)
    const void *CompAdr, int CompSize   // compressed data block
  );

void
XPRESS_CALL
  XpressDecodeClose
  (
    XpressDecodeStream stream,          // encoder's workspace
    void *context,                      // user-defined context info (will  be passed to FreeFn)
    XpressFreeFn *FreeFn                // callback that releases the memory
  );


/* ------------------------------ CRC32 ------------------------------- */
/*                                -----                                 */

int
XPRESS_CALL
  XpressCrc32
  (
    const void *data,                   // beginning of data block
    int bytes,                          // number of bytes
    int crc                             // initial value
  );


#ifdef __cplusplus
};
#endif

#endif /* _XPRESS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nameres\rnr\setup\install\install.c ===
#include <winsock2.h>
#include <ws2spi.h>
#include <stdio.h>
#include <stdlib.h>
#include "..\setup.h"


INT
InstallNT5Provider()
{
    INT   ReturnCode;
    BOOL  ReturnValue = FALSE;
    DWORD NameSpaceId;

    NameSpaceId = NS_NTDS;

    ReturnCode = WSCInstallNameSpace( gProviderName,
                                      gProviderPath,
                                      NameSpaceId,
                                      0,
                                      &gProviderId );

    return ReturnCode;
}


int __cdecl main(int argc, char**argv)
{
    DWORD NameSpaceId;
    WORD  ReturnCode;
    DWORD LastError;

    WORD    wVersionRequested;
    WSADATA wsaData;
    WORD    err;

    wVersionRequested = MAKEWORD( 1, 1 );
    err = WSAStartup( wVersionRequested, &wsaData );
    if ( err != 0 )
    {
        //
        // Tell the user that we couldn't find a useable WinSock DLL.
        //
        fprintf( stderr, "Winsock DLL couldn't be found\n" );
        return( -1 );
    }

    //
    // Confirm that the WinSock DLL supports 1.1.
    // Note that if the DLL supports versions greater
    // than 2.0 in addition to 1.1, it will still return
    // 2.0 in wVersion since that is the version we
    // requested.
    //
    if ( LOBYTE( wsaData.wVersion ) != 1 ||
             HIBYTE( wsaData.wVersion ) != 1 )
    {
        //
        // Tell the user that we couldn't find a useable WinSock DLL.
        //
        fprintf( stderr, "Winsock DLL couldn't be found\n" );
        WSACleanup();
        return( -1 );
    }

    //
    // Install the providers for this test
    //
    if( ( ReturnCode = InstallNT5Provider() ) != ERROR_SUCCESS )
    {
        fprintf( stderr,
                 "NT5 Uninstall failed; error code = %d \n",
                 ReturnCode);

        return( -1 );
    }

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nameres\rnr\winrnr.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    winrnr.c

Abstract:

    Rnr provider for ActiveDirectory.

Work items:

    1) Need to support the NTDS Global catalog on LUP_DEEP from Root searches.
    2) Need to add bind handle caching.

Author:

    GlennC      23-Jul-1996

Revision History:

    GlennC      Added support for LUP_CONTAINERS in NSP2LookupServiceXXX
                functions.

    jamesg      Jan 2001        cleanup, bug fixes, proper alignment
    jamesg      May 2001        rewrite
                                    - 64-bit completely broken because 32-bit
                                        structures used as bervals
                                    - leaks
                                    - duplicate code
                                    - simplify flat buffer building macros
                                    - allow for sockaddrs other than IP4

--*/


#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include <rpcdce.h>
#include <winsock2.h>
#include <ws2spi.h>
#include <wsipx.h>
#include <svcguid.h>
#include <rnraddrs.h>
#include <align.h>
#include <winldap.h>

#include <windns.h>     // alignment macro
#include <dnslib.h>     // flat buffer stuff, memory allocation


//
//  RnR context
//
//  Context we keep during a given RnR lookup session.
//

typedef struct
{
    PLDAP   pLdapServer;
    PLDAP   pLdapGlobalCatalog;
    PWSTR   DomainDN;
    PWSTR   WinsockServicesDN;
}
RNR_CONNECTION, *PRNR_CONNECTION;

typedef struct
{
    DWORD   Count;
    DWORD   CurrentIndex;
    PWSTR   Strings[0];
}
DN_ARRAY, *PDN_ARRAY;

typedef struct
{
    DWORD               Signature;
    DWORD               ControlFlags;
    DWORD               CurrentDN;
    DWORD               NumberOfProtocols;
    PWSTR               pwsServiceName;
    PRNR_CONNECTION     pRnrConnection;
    PDN_ARRAY           pDnArray;
    PWSTR               pwsContext;
    PAFPROTOCOLS        pafpProtocols;
    PWSAVERSION         pVersion;
    WSAVERSION          WsaVersion;
    GUID                ServiceClassGuid;
    GUID                ProviderGuid;
}
RNR_LOOKUP, *PRNR_LOOKUP;


//
//  WSANSCLASSINFO stored in berval
//
//  ClassInfo blobs read and written to directory with
//  pointers replaced by offsets.
//
//  Note:  need to explicitly make this structure, because
//  the WSANSCLASSINFO struct is different sizes for
//  32/64bit;   this structure will match the 32-bit
//  WSANSCLASSINFO which have already been written to
//  the directory in Win2K deployments
//

typedef struct _ClassInfoAsBerval
{
    DWORD   NameOffset;
    DWORD   dwNameSpace;
    DWORD   dwValueType;
    DWORD   dwValueSize;
    DWORD   ValueOffset;
}
CLASSINFO_BERVAL, *PCLASSINFO_BERVAL;

//
//  CSADDR stored in berval
//
//  CSADDRs read and written to directory with
//  pointers replaced by offsets.
//
//  Note:  as with WSANSCLASSINFO above CSADDR can not
//  be used directly in both 32 and 64 bit.  Make a structure
//  that explicitly uses offsets and matches the already
//  deployed 32-bit form.
//

typedef struct _CsaddrAsBerval
{
    DWORD       LocalZero;
    LONG        LocalLength;
    DWORD       RemoteZero;
    LONG        RemoteLength;
    LONG        iSocketType;
    LONG        iProtocol;
}
CSADDR_BERVAL, *PCSADDR_BERVAL;


//
//  RnR defines      
//

#define RNR_SIGNATURE           0x7364736e      //  "nsds"
#define RNR_SIGNATURE_FREE      0x65657266      //  "free"

#define LDAP_GLOBAL_CATALOG     3268

//
//  Standard out-of-mem rcode
//

#define ERROR_NO_MEMORY         WSA_NOT_ENOUGH_MEMORY

//
//  Defs to straight pointer
//

typedef LPGUID  PGUID;

typedef LPWSASERVICECLASSINFOW  PWSASERVICECLASSINFOW;

typedef DWORD   RNR_STATUS;

#define GuidEqual(x,y)          RtlEqualMemory( x, y, sizeof(GUID) )

//
//  Debug printing
//

#ifdef DBG
//#define WINRNR_PRINT( foo )     KdPrint( foo )
#define WINRNR_PRINT( foo )     DNS_PRINT( foo )
#else
#define WINRNR_PRINT( foo )
#endif

#ifdef DBG
#define DnsDbg_DnArray(h,p)         Print_DnArray( DnsPR, NULL, (h), (p) )
#define DnsDbg_RnrConnection(h,p)   Print_RnrConnection( DnsPR, NULL, (h), (p) )
#define DnsDbg_RnrLookup(h,p)       Print_RnrLookup( DnsPR, NULL, (h), (p) )
#else
#define DnsDbg_DnArray(h,p)
#define DnsDbg_RnrConnection(h,p)
#define DnsDbg_RnrLookup(h,p)
#endif

//
//  LDAP search stuff
//      - DN pieces
//      - attributes
//      - filters
//

WCHAR   g_NtdsContainer[]       = L"Container";
WCHAR   g_CommonName[]          = L"CN";
WCHAR   g_DisplayName[]         = L"displayName";
WCHAR   g_Comment[]             = L"description";
WCHAR   g_DefaultDn[]           = L"defaultNamingContext";
WCHAR   g_ObjectClass[]         = L"objectClass";
WCHAR   g_ObjectName[]          = L"name";
WCHAR   g_ServiceClass[]        = L"serviceClass";
WCHAR   g_ServiceClassId[]      = L"serviceClassID";
WCHAR   g_ServiceClassInfo[]    = L"serviceClassInfo";
WCHAR   g_ServiceInstance[]     = L"serviceInstance";
WCHAR   g_ServiceVersion[]      = L"serviceInstanceVersion";
WCHAR   g_WinsockAddresses[]    = L"winsockAddresses";
WCHAR   g_WinsockServicesDn[]   = L"CN=WinsockServices,CN=System,";

WCHAR   g_FilterObjectClass_ServiceClass[]      = L"(objectClass=serviceClass)";
WCHAR   g_FilterObjectClass_ServiceInstance[]   = L"(objectClass=serviceInstance)";
WCHAR   g_FilterObjectClass_Container[]         = L"(objectClass=Container)";
WCHAR   g_FilterObjectClass_Star[]              = L"(objectClass=*)";

WCHAR   g_FilterCnEquals[]                      = L"CN=";
WCHAR   g_FilterParenCnEquals[]                 = L"(CN=";
WCHAR   g_FilterParenServiceClassIdEquals[]     = L"(serviceClassId=";
WCHAR   g_FilterParenServiceVersionEquals[]     = L"(serviceVersion=";

//
//  Access with #defines
//

#define NTDS_CONTAINER          g_NtdsContainer
#define COMMON_NAME             g_CommonName
#define DEFAULT_DOMAIN_DN       g_DefaultDn
#define OBJECT_CLASS            g_ObjectClass
#define OBJECT_COMMENT          g_Comment
#define OBJECT_NAME             g_ObjectName
#define SERVICE_CLASS           g_ServiceClass
#define SERVICE_CLASS_ID        g_ServiceClassId
#define SERVICE_CLASS_INFO      g_ServiceClassInfo
#define SERVICE_CLASS_NAME      g_DisplayName
#define SERVICE_COMMENT         g_Comment
#define SERVICE_INSTANCE        g_ServiceInstance
#define SERVICE_INSTANCE_NAME   g_DisplayName
#define SERVICE_VERSION         g_ServiceVersion
#define WINSOCK_ADDRESSES       g_WinsockAddresses
#define WINSOCK_SERVICES        g_WinsockServicesDn

//  Filters

#define FILTER_OBJECT_CLASS_SERVICE_CLASS       g_FilterObjectClass_ServiceClass
#define FILTER_OBJECT_CLASS_SERVICE_INSTANCE    g_FilterObjectClass_ServiceInstance
#define FILTER_OBJECT_CLASS_NTDS_CONTAINER      g_FilterObjectClass_Container
#define FILTER_OBJECT_CLASS_STAR                g_FilterObjectClass_Star
                                                                                            
#define FILTER_CN_EQUALS                        g_FilterCnEquals
#define FILTER_PAREN_CN_EQUALS                  g_FilterParenCnEquals
#define FILTER_PAREN_SERVICE_CLASS_ID_EQUALS    g_FilterParenServiceClassIdEquals
#define FILTER_PAREN_SERVICE_VERSION_EQUALS     g_FilterParenServiceVersionEquals


//
//  GUID generated by uuidgen.exe for provider identifer,
//      (3b2637ee-e580-11cf-a555-00c04fd8d4ac)
//

GUID    g_NtdsProviderGuid =
{
    0x3b2637ee,
    0xe580,
    0x11cf,
    {0xa5, 0x55, 0x00, 0xc0, 0x4f, 0xd8, 0xd4, 0xac}
};

WCHAR   g_NtdsProviderName[] = L"NTDS";
WCHAR   g_NtdsProviderPath[] = L"%SystemRoot%\\System32\\winrnr.dll";

PWSTR   g_pHostName = NULL;
PWSTR   g_pFullName = NULL;

DWORD   g_TlsIndex;

GUID    HostAddrByInetStringGuid    = SVCID_INET_HOSTADDRBYINETSTRING;
GUID    ServiceByNameGuid           = SVCID_INET_SERVICEBYNAME;
GUID    HostAddrByNameGuid          = SVCID_INET_HOSTADDRBYNAME;
GUID    HostNameGuid                = SVCID_HOSTNAME;


//
//  Heap
//

#define ALLOC_HEAP_ZERO( size )     Dns_AllocZero( size )
#define ALLOC_HEAP( size )          Dns_Alloc( size )
#define FREE_HEAP( p )              Dns_Free( p )



#ifdef DBG
//
//  Debug print utils
//

VOID
Print_DnArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN      PPRINT_CONTEXT  PrintContext,
    IN      PSTR            pszHeader,
    IN      PDN_ARRAY       pDnArray
    )
/*++

Routine Description:

    Print DN array

Arguments:

    pDnArray -- DN array to free

Return Value:

    None

--*/
{
    DWORD   iter;

    if ( !pszHeader )
    {
        pszHeader = "DN Array:";
    }
    if ( !pDnArray )
    {
        PrintRoutine(
            PrintContext,
            "%s NULL DN Array!\n",
            pszHeader );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        PrintContext,
        "%s\n"
        "\tPtr      = %p\n"
        "\tCount    = %d\n"
        "\tStrings:\n",
        pszHeader,
        pDnArray,
        pDnArray->Count );

    for ( iter = 0; iter < pDnArray->Count; iter++ )
    {
        PrintRoutine(
            PrintContext,
            "\t\tDN[%d] %S\n",
            iter,
            pDnArray->Strings[iter] );
    }
    DnsPrint_Unlock();
}



VOID
Print_RnrConnection(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN      PPRINT_CONTEXT  PrintContext,
    IN      PSTR            pszHeader,
    IN      PRNR_CONNECTION pRnrCon
    )
/*++

Routine Description:

    Print RnR connection info.

Arguments:

    pRnrCon -- Rnr connection blob

Return Value:

    None

--*/
{
    if ( !pszHeader )
    {
        pszHeader = "RnR Connection:";
    }
    if ( !pRnrCon )
    {
        PrintRoutine(
            PrintContext,
            "%s NULL RnR Connection!\n",
            pszHeader );
        return;
    }

    PrintRoutine(
        PrintContext,
        "%s\n"
        "\tPtr              = %p\n"
        "\tpLdap            = %p\n"
        "\tpLdap GC         = %p\n"
        "\tDomain DN        = %S\n"
        "\tWsockServicesDN  = %S\n",
        pszHeader,
        pRnrCon, 
        pRnrCon->pLdapServer,
        pRnrCon->pLdapGlobalCatalog,
        pRnrCon->DomainDN,
        pRnrCon->WinsockServicesDN
        );
}



VOID
Print_RnrLookup(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN      PPRINT_CONTEXT  PrintContext,
    IN      PSTR            pszHeader,
    IN      PRNR_LOOKUP     pRnr
    )
/*++

Routine Description:

    Print RnR lookup blob.

Arguments:

    pRnr -- Rnr lookup blob

Return Value:

    None

--*/
{
    CHAR    serviceGuidBuffer[ GUID_STRING_BUFFER_LENGTH ];
    CHAR    providerGuidBuffer[ GUID_STRING_BUFFER_LENGTH ];


    if ( !pszHeader )
    {
        pszHeader = "RnR Lookup:";
    }
    if ( !pRnr )
    {
        PrintRoutine(
            PrintContext,
            "%s NULL RnR Lookup!\n",
            pszHeader );
        return;
    }

    //  convert GUIDs to strings

    DnsStringPrint_Guid(
        serviceGuidBuffer,
        &pRnr->ServiceClassGuid
        );
    DnsStringPrint_Guid(
        providerGuidBuffer,
        &pRnr->ProviderGuid
        );

    DnsPrint_Lock();

    PrintRoutine(
        PrintContext,
        "%s\n"
        "\tPtr              = %p\n"
        "\tSig              = %08x\n"
        "\tCntrl Flags      = %08x\n"
        "\tService Name     = %S\n"
        "\tpConnection      = %p\n"
        "\tpDnArray         = %p\n"
        "\tDN Index         = %d\n"
        "\tClass GUID       = %s\n"
        "\tProvider GUID    = %s\n"
        "\tpContext         = %S\n"
        "\tVersion          = %p %08x %d\n"
        "\tpProtocols       = %p\n"
        "\tNum Protocols    = %d\n",
        pszHeader,
        pRnr, 
        pRnr->Signature,        
        pRnr->ControlFlags,     
        pRnr->pwsServiceName,   
        pRnr->pRnrConnection,   
        pRnr->pDnArray,         
        pRnr->CurrentDN,        
        serviceGuidBuffer,
        providerGuidBuffer,
        pRnr->pwsContext,       
        pRnr->pVersion,
        pRnr->WsaVersion.dwVersion,
        pRnr->WsaVersion.ecHow,
        pRnr->pafpProtocols,
        pRnr->NumberOfProtocols
        );

    if ( pRnr->pRnrConnection )
    {
        Print_RnrConnection(
            PrintRoutine,
            PrintContext,
            NULL,
            pRnr->pRnrConnection );
    }

    if ( pRnr->pDnArray )
    {
        Print_DnArray(
            PrintRoutine,
            PrintContext,
            NULL,
            pRnr->pDnArray );
    }

    if ( pRnr->pafpProtocols )
    {
        DnsPrint_AfProtocolsArray(
            PrintRoutine,
            PrintContext,
            "\tProtocol array:",
            pRnr->pafpProtocols,
            pRnr->NumberOfProtocols );
    }
    PrintRoutine(
        PrintContext,
        "\n" );

    DnsPrint_Unlock();
}
#endif



//
//  Basic utils
//

PDN_ARRAY
AllocDnArray(
    IN      DWORD           Count
    )
/*++

Routine Description:

    Create DN array

Arguments:

    Count -- string count to handle

Return Value:

    None

--*/
{
    PDN_ARRAY   parray;

    //
    //  free strings in array
    //

    parray = (PDN_ARRAY) ALLOC_HEAP_ZERO(
                                sizeof(*parray) +
                                Count*sizeof(PSTR) );
    if ( parray )
    {
        parray->Count = Count;
    }
    return  parray;
}


VOID
FreeDnArray(
    IN OUT  PDN_ARRAY       pDnArray
    )
/*++

Routine Description:

    Free DN array

Arguments:

    pDnArray -- DN array to free

Return Value:

    None

--*/
{
    DWORD   iter;

    if ( !pDnArray )
    {
        return;
    }

    //
    //  free strings in array
    //

    for ( iter = 0; iter < pDnArray->Count; iter++ )
    {
        PWSTR   pstr = pDnArray->Strings[iter];
        if ( pstr )
        {
            FREE_HEAP( pstr );
        }
    }
    FREE_HEAP( pDnArray );
}



RNR_STATUS
BuildDnArrayFromResults(
    IN OUT  PLDAP           pLdap,
    IN      PLDAPMessage    pLdapResults,
    OUT     PDWORD          pdwCount,       OPTIONAL
    OUT     PDN_ARRAY *     ppDnArray       OPTIONAL
    )
/*++

Routine Description:

    Build DN array from LDAP results

Arguments:

    pLdap   -- LDAP connection

    pLdapResults -- LDAP results from search

    pdwCount -- addr to receive count if getting count

    ppDnArray -- addr to receive ptr to DN array
        if not given, no DN array built

Return Value:

    NO_ERROR if successful.
    ErrorCode on memory allocation failure.

--*/
{
    DWORD           status;
    DWORD           count;
    PDN_ARRAY       pdnArray = NULL;
    LDAPMessage *   pnext;
    DWORD           iter;


    DNSDBG( TRACE, (
        "BuildDnArrayFromResults()\n"
        "\tpLdap            = %p\n"
        "\tpResults         = %p\n"
        "\tpCount OUT       = %p\n"
        "\tpDnArray OUT     = %p\n",
        pLdap,
        pLdapResults,
        pdwCount,
        ppDnArray ));

    //
    //  count search hits
    //

    count = ldap_count_entries(
                    pLdap,
                    pLdapResults );

    if ( count == 0  ||  !ppDnArray )
    {
        status = NO_ERROR;
        goto Done;
    }

    //
    //  build DN array from ldap results
    //      - note that allocated strings are IN dnarray
    // 

    pdnArray = AllocDnArray( count );
    if ( !pdnArray )
    {
        status = ERROR_NO_MEMORY;
        goto Done;
    }

    for ( pnext = ldap_first_entry( pLdap, pLdapResults ), iter=0;
          pnext != NULL;
          pnext = ldap_next_entry( pLdap, pnext ), iter++ )
    {
        PWSTR   pnextDn = ldap_get_dn( pLdap, pnext );
        PWSTR   pdn;

        pdn = Dns_CreateStringCopy_W( pnextDn );

        ldap_memfree( pnextDn );

        if ( !pdn )
        {
            FREE_HEAP( pdnArray );
            pdnArray = NULL;
            status = ERROR_NO_MEMORY;
            goto Done;
        }
        if ( iter >= count )
        {
            DNS_ASSERT( FALSE );
            break;
        }
        pdnArray->Strings[iter] = pdn;
    }
    
    status = NO_ERROR;

Done:

    
    if ( ppDnArray )
    {
        *ppDnArray = pdnArray;
    }
    if ( pdwCount )
    {
        *pdwCount = count;
    }

    IF_DNSDBG( TRACE )
    {
        DnsDbg_Lock();
        DNS_PRINT((
            "Leave BuildDnArrayFromResults() => %d\n"
            "\tcount = %d\n",
            status,
            count ));
        DnsDbg_DnArray(
            NULL,
            pdnArray );
        DnsDbg_Unlock();
    }
    return  status;
}



PWSTR
CreateFilterElement(
    IN      PBYTE           pBlob,
    IN      DWORD           BlobLength
    )
/*++

Routine Description:

    Create filter element for flat blob.

Arguments:

    pBlob -- ptr to blob

    BlobLength -- length

Return Value:

    Ptr to allocated filter element.
    NULL on error.

--*/
{
    PWSTR   pfilter;
    DWORD   size;

    DNSDBG( TRACE, (
        "CreateFilterElement( %p, %d )\n",
        pBlob,
        BlobLength ));

    //
    //  get size of filter string
    //
    //  DCR:  hard to believe the size should go *WCHAR
    //      seems like that would be taken care of
    //

    size = ldap_escape_filter_element(
                pBlob,
                BlobLength,
                NULL,       // no buffer
                0 );

    size *= sizeof(WCHAR);

    pfilter = ALLOC_HEAP_ZERO( size );
    if ( !pfilter )
    {
        SetLastError( ERROR_NO_MEMORY );
        return  NULL;
    }

    ldap_escape_filter_element(
            pBlob,
            BlobLength,
            pfilter,
            size );

    DNSDBG( TRACE, (
        "Leave CreateFilterElement() => %S\n",
        pfilter ));

    return  pfilter;
}



RNR_STATUS
SetError(
    IN      RNR_STATUS      dwError
    )
/*++

Routine Description:

    Wraps SetLastError() and SOCKET_ERROR return.

Arguments:

    dwError -- error code

Return Value:

    NO_ERROR if dwError==NO_ERROR
    SOCKET_ERROR on any other error.

--*/
{
    if ( dwError )
    {
        SetLastError( dwError );
        return( (DWORD) SOCKET_ERROR );
    }
    else
    {
        return( NO_ERROR );
    }
}



BOOL
IsNameADn(
    IN      PWSTR           szName,
    OUT     PWSTR *         ppwsRdn,
    OUT     PWSTR *         ppwsContext
    )
{
#define  NTDS_MAX_DN_LEN 1024
    DWORD       status = NO_ERROR;
    WCHAR       szNameBuf[ NTDS_MAX_DN_LEN ];
    PWSTR       szTemp;
    PWSTR       szComma = NULL;
    DWORD       i;
    DWORD       nameLength;
    BOOL        fQuoted = FALSE;

    DNSDBG( TRACE, (
        "IsNameADn( %S )\n",
        szName ));

    nameLength = wcslen( szName );
    if ( nameLength >= NTDS_MAX_DN_LEN )
    {
        return  FALSE;
    }
    wcsncpy( szNameBuf, szName, NTDS_MAX_DN_LEN );
    szNameBuf[ NTDS_MAX_DN_LEN-1 ] = 0;

    szTemp = szNameBuf;
    nameLength = wcslen( szNameBuf );

    for ( i=0; i < nameLength; i++ )
    {
        if ( szTemp[i] == L',' )
        {
            if ( !fQuoted )
            {
                szComma = &szTemp[i];
                break;
            }
        }
        if ( szTemp[i] == L'\"' )
        {
#if 0
            //  this one is a classic ... saving for posterity

            if ( fQuoted )
                fQuoted = FALSE;
            else
                fQuoted = TRUE;
#endif
            fQuoted = !fQuoted;
        }
    }

    if ( i >= nameLength )
    {
        return FALSE;
    }

    szComma[0] = 0;
    szComma++;

    if ( szComma[0] == L' ' )
        szComma++;

    nameLength = wcslen( szComma );
    if ( nameLength == 0 )
    {
        return FALSE;
    }

    //
    //  copy context trailing comma
    //

    *ppwsContext = (LPWSTR) ALLOC_HEAP_ZERO( (nameLength + 1) * sizeof(WCHAR) );
    if ( *ppwsContext == NULL )
    {
        return FALSE;
    }
    wcscpy( *ppwsContext, szComma );

    //
    //  create\copy RDN
    //      - do not copy "cn=" portion
    //

    *ppwsRdn = (LPWSTR) ALLOC_HEAP_ZERO(
                            (wcslen(szNameBuf) + 1) * sizeof(WCHAR) );
    if ( *ppwsRdn == NULL )
    {
        FREE_HEAP( *ppwsContext );
        *ppwsContext = NULL;
        return FALSE;
    }

    if ( szNameBuf[0] == L'C' || szNameBuf[0] == L'c' &&
         szNameBuf[1] == L'N' || szNameBuf[1] == L'n' &&
         szNameBuf[2] == L'=' )
    {
        wcscpy( *ppwsRdn, szNameBuf + 3 );
    }
    else
    {
        wcscpy( *ppwsRdn, szNameBuf );
    }

    return TRUE;
}



//
//  Recursion locking
//
//  Idea here is to keep LDAP calls from recursing back
//  into these functions through ConnectToDefaultDirectory
//  Simply set TLS pointer to one when do LDAP search and
//  test in ConnectToDefaultDirectory(), quiting if already
//  set.
//

BOOL
GetRecurseLock(
    IN      PSTR            pszFunctionName
    )
{
    if ( TlsSetValue( g_TlsIndex, (LPVOID) 1 ) == FALSE )
    {
        WINRNR_PRINT((
            "WINRNR!%s - TlsSetValue( %d, 1 ) failed!\n"
            "\terror code: 0%x\n",
            pszFunctionName,
            g_TlsIndex,
            GetLastError() ));

        return( FALSE );
    }
    return( TRUE );
}

BOOL
ReleaseRecurseLock(
    IN      PSTR            pszFunctionName
    )
{
    if ( TlsSetValue( g_TlsIndex, NULL ) == FALSE )
    {
        WINRNR_PRINT((
            "WINRNR!%s - TlsSetValue( %d, NULL ) failed!\n"
            "\terror code: 0%x\n",
            pszFunctionName,
            g_TlsIndex,
            GetLastError() ));

        return( FALSE );
    }
    return( TRUE );
}

BOOL
IsRecurseLocked(
    VOID
    )
{
    return  TlsGetValue( g_TlsIndex ) ? TRUE : FALSE;
}






RNR_STATUS
DoLdapSearch(
    IN      PSTR                pszFunction,
    IN      BOOL                fLocked,
    IN      PLDAP               pLdap,
    IN      PWSTR               pwsDN,
    IN      DWORD               Flag,
    IN      PWSTR               pwsFilter,
    IN      PWSTR *             Attributes,
    OUT     PLDAPMessage *      ppResults
    )
/*++

Routine Description:

    Do ldap search.

    Wrapper function to do ldap search with recurse locking
    and debug print.

Arguments:

    pszFunction -- function calling in

    fLocked -- already recurse locked

    LDAP search params:

    pLdap -- LDAP connection

    pwsDN -- DN to search at

    Flag -- search flag

    pwsFilter -- filter

    Attributes -- attribute array

    ppResults -- addr to recv ptr to result message
        caller must free

Return Value:

    NO_ERROR if successful.
    WSAEFAULT if buffer too small.
    ErrorCode on failure.

--*/
{
    RNR_STATUS  status;

    IF_DNSDBG( TRACE )
    {
        DnsDbg_Lock();
        DNSDBG( TRACE, (
            "DoLdapSearch()\n"
            "\tFunction         = %s\n"
            "\tLocked           = %d\n"
            "\tLDAP search params:\n"
            "\tpLdap            = %p\n"
            "\tDN               = %S\n"
            "\tFlags            = %08x\n"
            "\tpFilter          = %S\n"
            "\tppResults        = %p\n",
            pszFunction,
            fLocked,
            pLdap,
            pwsDN,
            Flag,
            pwsFilter,
            ppResults ));

        DnsDbg_StringArray(
            "  Search Attributes:",
            (PSTR *) Attributes,
            0,          // count unknown, array NULL terminated
            TRUE        // in unicode
            );
        DnsDbg_Unlock();
    }

    //
    //  search
    //

    if ( !fLocked &&
         !GetRecurseLock( pszFunction ) )
    {
        status = ERROR_LOCK_FAILED;
        goto Exit;
    }

    status = ldap_search_s(
                    pLdap,
                    pwsDN,
                    Flag,
                    pwsFilter,
                    Attributes,
                    0,
                    ppResults );

    if ( !fLocked &&
         !ReleaseRecurseLock( pszFunction ) )
    {
        status = ERROR_LOCK_FAILED;
        goto Exit;
    }

    if ( status != NO_ERROR  &&  !*ppResults )
    {
        WINRNR_PRINT((
            "WINRNR!%s -- ldap_search_s() failed 0%x\n",
            pszFunction,
            status ));
    
        DNSDBG( ANY, (
            "ERROR:  ldap_search_s() Failed! => %d\n"
            "\tIn function  %s\n"
            "\tDN           %S\n"
            "\tFlag         %08x\n"
            "\tFilter       %S\n",
            status,
            pszFunction,
            pwsDN,
            Flag,
            pwsFilter ));
    }

Exit:

    DNSDBG( TRACE, (
        "Leave DoLdapSearch() => %d\n",
        status ));

    return  status;
}



VOID
DisconnectFromLDAPDirectory(
    IN OUT  PRNR_CONNECTION *  ppRnrConnection
    )
/*++

Routine Description:

    Disconnect and cleanup RnR connection to directory.

Arguments:

    pCsAddr -- ptr to CSADDR buffer to write

    pBerval -- ptr to berval

    NumberOfProtocols -- number of protocols in protocol array

    pafpProtocols -- protocol array

Return Value:

    None

--*/
{
    DNSDBG( TRACE, (
        "DisconnectFromLDAPDirectory( %p (%p) )\n",
        ppRnrConnection,
        (ppRnrConnection) ? *ppRnrConnection : NULL ));

    if ( ppRnrConnection )
    {
        PRNR_CONNECTION prnr = *ppRnrConnection;

        if ( prnr )
        {
            ldap_unbind( prnr->pLdapServer );
            ldap_unbind( prnr->pLdapGlobalCatalog );
            FREE_HEAP( prnr->WinsockServicesDN );
            FREE_HEAP( prnr->DomainDN );
            FREE_HEAP( prnr );
            *ppRnrConnection = NULL;
        }
    }
}



RNR_STATUS
ConnectToDefaultLDAPDirectory(
    IN      BOOL                fNeedGlobalCatalog,
    OUT     PRNR_CONNECTION *   ppRnrConnection
    )
/*++

Routine Description:

    Connect to directory.

Arguments:

    fNeedGlobalCatalog -- TRUE if need to connect to GC

    ppRnrConnection -- addr to recv connection blob

Return Value:

    NO_ERROR if successful.
    ErrorCode on failure.

--*/
{
    RNR_STATUS      status = NO_ERROR;
    PRNR_CONNECTION prnr = NULL;
    PLDAP           pldap = NULL;
    PWSTR           pstr;
    DWORD           count = 0;
    BOOL            frecurseLocked = FALSE;
    LDAPMessage *   results = NULL;
    LDAPMessage *   object;
    PWSTR *         ppvalue = NULL;
    PWSTR           stringArray[4];
    PWSTR           attrs[3] = {    COMMON_NAME,
                                    DEFAULT_DOMAIN_DN,
                                    NULL };

    DNSDBG( TRACE, (
        "ConnectToDefaultLDAPDirectory()\n"
        "\tNeed global catalog  = %d\n"
        "\tPtr to get Rnr conn  = %p\n",
        fNeedGlobalCatalog,
        ppRnrConnection ));

    //
    //  allocate blob of connection info
    //

    if ( ppRnrConnection == NULL )
    {
        return( WSA_INVALID_PARAMETER );
    }

    prnr = (PRNR_CONNECTION) ALLOC_HEAP_ZERO( sizeof(RNR_CONNECTION) );
    *ppRnrConnection = prnr;
    if ( !prnr )
    {
        return( WSA_NOT_ENOUGH_MEMORY );
    }

    //
    //  being called recursively -- bail
    //

    if ( IsRecurseLocked() )
    {
        status = WSAEFAULT;
        goto Exit;
    }
    if ( !GetRecurseLock( "ConnectToDefaultLDAPDirectory" ) )
    {
        status = WSAEFAULT;
        goto Exit;
    }
    frecurseLocked = TRUE;

    //
    //  We need to keep the TLS value non-zero not just on the open but also
    //  across the bind and any other ldap calls for that matter. This is
    //  because the LDAP bind may do a reverse name lookup, in which case
    //  we'd come looping through here.
    //

    pldap = ldap_open( NULL, LDAP_PORT );
    prnr->pLdapServer = pldap;

    if ( fNeedGlobalCatalog )
    {
        prnr->pLdapGlobalCatalog = ldap_open( NULL, LDAP_GLOBAL_CATALOG );
    }
    if ( !pldap )
    {
        DNSDBG( TRACE, ( "Failed ldap_open() of default directory!\n" ));
        status = WSAEHOSTUNREACH;
        goto Exit;
    }

    //
    // If fNeedGlobalCatalog was TRUE and ldap_open failed against the
    // GC server, don't bother about returning with error. We can still
    // use the  pldap handle.
    //
    // End of comment.
    //

    status = ldap_bind_s(
                    pldap,
                    NULL,
                    NULL,
                    LDAP_AUTH_SSPI );
    if ( status )
    {
        DNSDBG( TRACE, (
            "Failed ldap_bind_s() => %d\n",
            status ));
        status = WSAENOTCONN;
        goto Exit;
    }

    //
    //  for the server that we are connected to, get the DN of the Domain
    //
    //  need some general error code -- not WSAEFAULT
    //

    status = DoLdapSearch(
                    "ConnectToDefaultDirectory",
                    TRUE,       // already locked
                    pldap,
                    NULL,
                    LDAP_SCOPE_BASE,
                    FILTER_OBJECT_CLASS_STAR,
                    attrs,
                    &results );

    frecurseLocked = FALSE;
    if ( !ReleaseRecurseLock( "ConnectToDefaultLDAPDirectory" ) )
    {
        status = ERROR_LOCK_FAILED;
        goto Exit;
    }
    if ( status && !results )
    {
        status = WSAEFAULT;
        goto Exit;
    }

    //
    //  count results
    //      - searched with flag LDAP_OBJECT_BASE should have one object
    //
    count = ldap_count_entries(
                    pldap,
                    results );
    if ( count == 0 )
    {
        DNSDBG( TRACE, (
            "No entries found in base search()\n" ));
        status = WSATYPE_NOT_FOUND;
        goto Exit;
    }
    DNS_ASSERT( count == 1 );

    //
    //  get object from results
    //

    object = ldap_first_entry(
                    pldap,
                    results );
    if ( !object )
    {
        DNSDBG( TRACE, ( "Failed ldap_first_entry()\n" ));
        status = WSANO_DATA;
        goto Exit;
    }

    //
    //  read the defaultDomainDN base attribute
    //

    ppvalue = ldap_get_values(
                    pldap,
                    object,
                    DEFAULT_DOMAIN_DN );
    if ( !ppvalue )
    {
        DNSDBG( TRACE, ( "Failed ldap_get_values()\n" ));
        status = WSANO_DATA;
        goto Exit;
    }

    //
    //  create DNs
    //      - winsock services \ default domain
    //      - domain
    //

    stringArray[0] = WINSOCK_SERVICES;
    stringArray[1] = ppvalue[0];
    stringArray[2] = NULL;

    pstr = Dns_CreateConcatenatedString_W( stringArray );
    if ( !pstr )
    {
        status = WSA_NOT_ENOUGH_MEMORY;
        goto Exit;
    }
    prnr->WinsockServicesDN = pstr;


    pstr = Dns_CreateStringCopy_W( ppvalue[0] );
    if ( !pstr )
    {
        status = WSA_NOT_ENOUGH_MEMORY;
        goto Exit;
    }
    prnr->DomainDN = pstr;
    
    status = NO_ERROR;


Exit:

    if ( frecurseLocked )
    {
        ReleaseRecurseLock( "ConnectToDefaultLDAPDirectory" );
    }

    ldap_value_free( ppvalue );
    ldap_msgfree( results );

    if ( status != NO_ERROR )
    {
        DisconnectFromLDAPDirectory( ppRnrConnection );
        DNS_ASSERT( *ppRnrConnection == NULL );
    }

    DNSDBG( TRACE, (
        "Leaving ConnectToDefaultLDAPDirectory() => %d\n",
        status ));

    IF_DNSDBG( TRACE )
    {
        if ( status == NO_ERROR )
        {
            DnsDbg_RnrConnection(
                "New RnR connection:",
                *ppRnrConnection );
        }
    }
    return( status );
}



VOID
FreeRnrLookup(
    IN OUT  PRNR_LOOKUP     pRnr
    )
/*++

Routine Description:

    Free RnR lookup blob.

Arguments:

    pRnr -- ptr to Rnr lookup blob

Return Value:

    None

--*/
{
    DNSDBG( TRACE, (
        "FreeRnrLookup( %p )\n",
        pRnr ));

    if ( !pRnr )
    {
        return;
    }

    //  disconnect from directory

    if ( pRnr->pRnrConnection )
    {
        DisconnectFromLDAPDirectory( &pRnr->pRnrConnection );
    }

    //  free subfields

    FreeDnArray( pRnr->pDnArray );
    Dns_Free( pRnr->pwsServiceName );
    Dns_Free( pRnr->pwsContext );
    Dns_Free( pRnr->pafpProtocols );

    //  specifically invalidate sig to help catch
    //      multiple frees

    pRnr->Signature = RNR_SIGNATURE_FREE;

    FREE_HEAP( pRnr );
}



//
//  CSADDR read\write routines
//

RNR_STATUS
ModifyAddressInServiceInstance(
    IN      PRNR_CONNECTION pRnrConnection,
    IN      PWSTR           pwsDn,
    IN      PCSADDR_INFO    pCsAddr,
    IN      BOOL            fAdd
    )
/*++

Routine Description:

    Modify address (CSADDR) in service instance.

Arguments:

    pRnrConnection -- RnR connection

    pwsDn -- DN to make mod at

    pCsAddr -- CSADDR for mode

    fAdd -- TRUE for add, FALSE for delete

Return Value:

    NO_ERROR if successful.
    ErrorCode on failure.

--*/
{
    RNR_STATUS      status = NO_ERROR;
    LDAPMod *       modPtrArray[2];
    LDAPMod         mod;
    PLDAP_BERVAL    modBValues[2];
    LDAP_BERVAL     berval;

    DWORD           lenBerval;
    DWORD           lenLocal;
    DWORD           lenRemote;
    DWORD           offset;
    DWORD           op;
    PCSADDR_BERVAL  pcsaddrBerval;


    DNSDBG( TRACE, (
        "ModifyAddressInServiceInstance()\n"
        "\tpRnrCon          = %p\n"
        "\tpwsDN            = %S\n"
        "\tpCsAddr          = %p\n"
        "\tfAdd             = %d\n",
        pRnrConnection,
        pwsDn,
        pCsAddr,
        fAdd ));

    //
    //  allocate CSADDR_BERVAL
    //      - can not use CSADDR as contains pointers and will break in 64bit
    //      - CSADDR_BERVAL maps to 32-bit CSADDR size
    //

    lenLocal    = pCsAddr->LocalAddr.iSockaddrLength;
    lenRemote   = pCsAddr->RemoteAddr.iSockaddrLength;
    lenBerval   = sizeof(CSADDR_BERVAL) + lenLocal + lenRemote;

    pcsaddrBerval = (PCSADDR_BERVAL) ALLOC_HEAP_ZERO( lenBerval );
    if ( !pcsaddrBerval )
    {
        status = ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  fill in CSADDR berval with CSADDR fields -- zero pointers
    //

    pcsaddrBerval->LocalZero    = 0;
    pcsaddrBerval->LocalLength  = lenLocal;
    pcsaddrBerval->RemoteZero   = 0;
    pcsaddrBerval->RemoteLength = lenRemote;
    pcsaddrBerval->iSocketType  = pCsAddr->iSocketType;                           
    pcsaddrBerval->iProtocol    = pCsAddr->iProtocol;

    //
    //  copy sockaddrs
    //      - store offsets of sockaddrs from berval start
    //      (this allows any sockaddr
    //

    if ( lenLocal )
    {
        offset = sizeof(CSADDR_BERVAL);

        RtlCopyMemory(
            (PBYTE)pcsaddrBerval + offset,
            pCsAddr->LocalAddr.lpSockaddr,
            lenLocal );
    }
    if ( lenRemote )
    {
        offset = sizeof(CSADDR_BERVAL) + lenLocal;

        RtlCopyMemory(
            (PBYTE)pcsaddrBerval + offset,
            pCsAddr->RemoteAddr.lpSockaddr,
            lenRemote );
    }

    //
    //  WINSOCK_ADDRESSES attribute
    //      - CSADDR berval
    //

    if ( fAdd )
    {
        op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
    }
    else
    {
        op = LDAP_MOD_DELETE | LDAP_MOD_BVALUES;
    }

    mod.mod_op          = op;
    mod.mod_type        = WINSOCK_ADDRESSES;
    mod.mod_bvalues     = modBValues;
    modBValues[0]       = & berval;
    modBValues[1]       = NULL;
    berval.bv_len       = lenBerval;
    berval.bv_val       = (PBYTE) pcsaddrBerval;

    modPtrArray[0] = &mod;
    modPtrArray[1] = NULL;

    //
    //  do modify
    //

    if ( !GetRecurseLock( "ModifyAddressInServiceInstance" ) )
    {
        status = WSAEFAULT;
        goto Done;
    }
    status = ldap_modify_s(
                pRnrConnection->pLdapServer,
                pwsDn,
                modPtrArray );

    if ( !ReleaseRecurseLock( "ModifyAddressInServiceInstance" ) )
    {
        status = WSAEFAULT;
        goto Done;
    }

    //
    //  modify failed?
    //      - add treats already-exists as success
    //      - deleter treats doesn't-exist as success
    //

    if ( status != NO_ERROR )
    {
        if ( fAdd && status == LDAP_ATTRIBUTE_OR_VALUE_EXISTS )
        {
            DNSDBG( TRACE, (
                "AlreadyExists error on add modify for %S\n"
                "\ttreating as success\n",
                pwsDn ));
            status = NO_ERROR;
        }
        else if ( !fAdd && status == LDAP_NO_SUCH_ATTRIBUTE )
        {
            DNSDBG( TRACE, (
                "NoSuchAttribute error on remove modify for %S\n"
                "\ttreating as success\n",
                pwsDn ));
            status = NO_ERROR;
        }
        else
        {
            WINRNR_PRINT((
                "WINRNR!ModifyAddressInServiceInstance -\n"
                "ldap_modify_s() failed with error code: 0%x\n",
                status ));
            DNSDBG( TRACE, (
                "ERROR:  %d on CSADDR ldap_modify_s() for %S\n"
                "\tfAdd = %d\n",
                status,
                pwsDn,
                fAdd ));
            status = WSAEFAULT;
        }
    }


Done:

    FREE_HEAP( pcsaddrBerval );

    DNSDBG( TRACE, (
        "Leave ModifyAddressInServiceInstance() => %d\n",
        status ));

    return  status;
}



BOOL
ExtractCsaddrFromBerval(
    OUT     PCSADDR_INFO    pCsAddr,
    IN      PLDAP_BERVAL    pBerval,
    IN      DWORD           NumberOfProtocols,
    IN      PAFPROTOCOLS    pafpProtocols
    )
/*++

Routine Description:

    Extract CSADDR from berval, and validate it matches
    desired protocol.

Arguments:

    pCsAddr -- ptr to CSADDR buffer to write

    pBerval -- ptr to berval

    NumberOfProtocols -- number of protocols in protocol array

    pafpProtocols -- protocol array

Return Value:

    TRUE if valid CSADDR of desired protocol.
    FALSE otherwise.
                                          
--*/
{
    PCSADDR_BERVAL  pcsaBval;
    PCHAR           pend;
    DWORD           iter;
    BOOL            retval = FALSE;
    INT             lenLocal;
    INT             lenRemote;
    PSOCKADDR       psaLocal;
    PSOCKADDR       psaRemote;

    DNSDBG( TRACE, (
        "ExtractCsaddrFromBerval()\n"
        "\tpCsaddr OUT      = %p\n"
        "\tpBerval          = %p\n"
        "\tProto array      = %p\n",
        pCsAddr,
        pBerval,
        pafpProtocols ));

    IF_DNSDBG( TRACE )
    {
        DnsDbg_AfProtocolsArray(
            "\tProtocol array:",
            pafpProtocols,
            NumberOfProtocols );
    }

    //
    //  unpack
    //      - verify csaddr has both sockaddrs within berval
    //      - unpack into real CSADDR, note we set the pointers
    //      but do NOT copy the sockaddrs
    //
    //  note:  we can't directly use the CSADDR_BERVAL because it is
    //  not a CSADDR in 64-bit
    //
    //  note:  perhaps should get the family fields out for test below
    //      with UNALIGNED copy;  but as long as future sockaddrs are
    //      fixed, then their size will always be WORD aligned;  since
    //      we unpack as vanilla SOCKADDR which only assumes WORD
    //      alignment we're ok;  just need to make sure don't write
    //      odd byte count
    //

    pcsaBval = (PCSADDR_BERVAL) pBerval->bv_val;
    pend     = (PBYTE)pcsaBval + pBerval->bv_len;

    //  unpack local sockaddr info

    psaLocal = NULL;
    lenLocal = pcsaBval->LocalLength;

    if ( lenLocal )
    {
        psaLocal = (PSOCKADDR) (pcsaBval + 1);
        if ( lenLocal < 0  ||
             (PBYTE)psaLocal + (DWORD)lenLocal > pend )
        {
            DNS_ASSERT( FALSE );
            goto Exit;
        }
    }

    //  unpack remote sockaddr info

    psaRemote = NULL;
    lenRemote = pcsaBval->RemoteLength;

    if ( lenRemote )
    {
        psaRemote = (PSOCKADDR) ((PBYTE)(pcsaBval + 1) + lenLocal);
        if ( lenRemote < 0  ||
             (PBYTE)psaRemote + (DWORD)lenRemote > pend )
        {
            DNS_ASSERT( FALSE );
            goto Exit;
        }
    }

    //  fill in CSADDR fields

    pCsAddr->LocalAddr.lpSockaddr       = psaLocal;
    pCsAddr->LocalAddr.iSockaddrLength  = lenLocal;
    pCsAddr->RemoteAddr.lpSockaddr      = psaRemote;
    pCsAddr->RemoteAddr.iSockaddrLength = lenRemote;
    pCsAddr->iSocketType                = pcsaBval->iSocketType;
    pCsAddr->iProtocol                  = pcsaBval->iProtocol;      

    //
    //  if given protocols, sockaddr must match
    //

    retval = TRUE;

    if ( pafpProtocols )
    {
        retval = FALSE;

        for ( iter = 0; iter < NumberOfProtocols; iter++ )
        {
            INT proto   = pafpProtocols[iter].iProtocol;
            INT family  = pafpProtocols[iter].iAddressFamily;
    
            if ( proto == PF_UNSPEC ||
                 proto == pCsAddr->iProtocol )
            {
                if ( family == AF_UNSPEC            ||
                     family == psaLocal->sa_family  ||
                     family == psaRemote->sa_family )
                {
                    retval = TRUE;
                    break;
                }
            }
        }
    }

Exit:

    DNSDBG( TRACE, ( "Leave ExtractCsaddrFromBerval() => found = %d\n", retval ));
    return retval;
}



//
//  Add routines
//

RNR_STATUS
AddServiceClass(
    IN      PRNR_CONNECTION    pRnrConnection,
    IN      PGUID              pServiceClassId,
    IN      PWSTR              pwsClassName,
    OUT     PDN_ARRAY *        ppDnArray            OPTIONAL
    )
{
    RNR_STATUS      status = NO_ERROR;
    PWSTR           pwsDn;
    PWSTR           stringArray[6];
    PDN_ARRAY       pdnArray = NULL;

    //  mod data
    //      - need up to four mods
    //      - three string
    //      - one berval

    PLDAPMod        modPtrArray[5];
    LDAPMod         modArray[4];
    PWSTR           modValues1[2];
    PWSTR           modValues2[2];
    PWSTR           modValues3[2];
    PLDAP_BERVAL    modBvalues1[2];
    LDAP_BERVAL     berval1;
    PLDAPMod        pmod;
    DWORD           index;


    DNSDBG( TRACE, (
        "AddServiceClass()\n"
        "\tpRnr         = %p\n"
        "\tpClassGuid   = %p\n"
        "\tClassName    = %S\n",
        pRnrConnection,
        pServiceClassId,
        pwsClassName
        ));

    //
    //  build DN for the ServiceClass object to be created
    //

    index = 0;
    stringArray[index++] = FILTER_CN_EQUALS;
    stringArray[index++] = pwsClassName;
    stringArray[index++] = L",";
    stringArray[index++] = pRnrConnection->WinsockServicesDN;
   