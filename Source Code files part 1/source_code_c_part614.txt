 if ( !(OrigFlags & MCI_SYSINFO_QUANTITY) ) {
            dprintf5(( "lpstrReturn -> %s", lpSysParms->lpstrReturn ));
        }
        else {
            dprintf5(( "lpstrReturn -> %d", *(LPDWORD)lpSysParms->lpstrReturn ));
        }
    }
}
#endif


/**********************************************************************\
* UnThunkMciStatus
*
* UnThunk the Status mci command parms.
\**********************************************************************/
VOID
UnThunkStatusCmd(
    MCIDEVICEID devID,
    DWORD OrigFlags,
    DWORD UNALIGNED *pdwOrig16,
    DWORD NewParms
    )
{
#if DBG
    static  LPSTR   f_name = "UnThunkStatusCmd: ";
#endif

    MCI_GETDEVCAPS_PARMS        GetDevCaps;
    DWORD                       dwRetVal;
    DWORD                       dwParm16;
    PDWORD                      pdwParm32;
    int                         iReturnType = MCI_INTEGER;

    /*
    ** If the MCI_STATUS_ITEM flag is not specified don't bother
    ** doing any unthunking.
    */
    if ( !(OrigFlags & MCI_STATUS_ITEM) ) {
        return;
    }

    /*
    ** We need to determine what type of device we are
    ** dealing with.  We can do this by send an MCI_GETDEVCAPS
    ** command to the device. (We might as well use the Unicode
    ** version of mciSendCommand and avoid another thunk).
    */
    ZeroMemory( &GetDevCaps, sizeof(MCI_GETDEVCAPS_PARMS) );
    GetDevCaps.dwItem = MCI_GETDEVCAPS_DEVICE_TYPE;
    dwRetVal = mciSendCommandW( devID, MCI_GETDEVCAPS, MCI_GETDEVCAPS_ITEM,
                                (DWORD)&GetDevCaps );
    /*
    ** If we can't get the DevCaps then we are doomed.
    */
    if ( dwRetVal ) {
        dprintf(("%sFailure to get devcaps", f_name));
        return;
    }

    /*
    ** Determine the dwReturn type.
    */
    switch ( GetDevCaps.dwReturn ) {

    case MCI_DEVTYPE_ANIMATION:
        switch ( ((LPDWORD)NewParms)[2] ) {

        case MCI_ANIM_STATUS_HWND:
            iReturnType = MCI_HWND;
            break;

        case MCI_ANIM_STATUS_HPAL:
            iReturnType = MCI_HPAL;
            break;
        }
        break;

    case MCI_DEVTYPE_OVERLAY:
        if ( ((LPDWORD)NewParms)[2] == MCI_OVLY_STATUS_HWND ) {
            iReturnType = MCI_HWND;
        }
        break;

    case MCI_DEVTYPE_DIGITAL_VIDEO:
        switch ( ((LPDWORD)NewParms)[2] ) {

        case MCI_DGV_STATUS_HWND:
            iReturnType = MCI_HWND;
            break;

        case MCI_DGV_STATUS_HPAL:
            iReturnType = MCI_HPAL;
            break;
        }
        break;
    }


    /*
    ** Thunk the dwReturn value according to the required type
    */
    pdwParm32 = (LPDWORD)((LPBYTE)NewParms + 4);

    switch ( iReturnType ) {
    case MCI_HPAL:
        dprintf4(( "%sFound an HPAL return field", f_name ));
        dwParm16 = MAKELONG( GETHPALETTE16( (HPALETTE)*pdwParm32 ), 0 );
        STOREDWORD( *(LPDWORD)((LPBYTE)pdwOrig16 + 4), dwParm16 );
        dprintf5(( "HDC32 -> 0x%lX", *pdwParm32 ));
        dprintf5(( "HDC16 -> 0x%lX", dwParm16 ));
        break;

    case MCI_HWND:
        dprintf4(( "%sFound an HWND return field", f_name ));
        dwParm16 = MAKELONG( GETHWND16( (HWND)*pdwParm32 ), 0 );
        STOREDWORD( *(LPDWORD)((LPBYTE)pdwOrig16 + 4), dwParm16 );
        dprintf5(( "HWND32 -> 0x%lX", *pdwParm32 ));
        dprintf5(( "HWND16 -> 0x%lX", dwParm16 ));
        break;

    case MCI_INTEGER:
        dprintf4(( "%sFound an INTEGER return field", f_name ));
        STOREDWORD( *(LPDWORD)((LPBYTE)pdwOrig16 + 4), *pdwParm32 );
        dprintf5(( "INTEGER -> %ld", *pdwParm32 ));
        break;

    // no default: all possible cases accounted for
    }
}



/**********************************************************************\
*  UnThunkCommandViaTable
*
* Thunks the return field if there is one and then frees and pointers
* that were got via GETVDMPTR or GETVDMPTR.
\**********************************************************************/
int
UnThunkCommandViaTable(
    LPWSTR lpCommand,
    DWORD UNALIGNED *pdwOrig16,
    DWORD pNewParms,
    BOOL fReturnValNotThunked
    )
{

#if DBG
    static  LPSTR   f_name = "UnThunkCommandViaTable: ";
#endif

    LPWSTR          lpFirstParameter;

    UINT            wID;
    DWORD           dwValue;

    UINT            wOffset1stParm32;

    DWORD           dwParm16;
    DWORD           Size;
    PDWORD          pdwParm32;

    DWORD           dwMask = 1;


    //
    // Skip past command entry
    //
    lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                    mciEatCommandEntry( lpCommand, NULL, NULL ));
    //
    // Get the next entry
    //
    lpFirstParameter = lpCommand;

    //
    // Skip past the DWORD return value
    //
    wOffset1stParm32 = 4;

    lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                    mciEatCommandEntry( lpCommand, &dwValue, &wID ));
    //
    // If it is a return value, skip it
    //
    if ( (wID == MCI_RETURN) && (fReturnValNotThunked) ) {

        pdwParm32 = (LPDWORD)((LPBYTE)pNewParms + 4);

        //
        // Look for a string return type, these are a special case.
        //
        switch ( dwValue ) {

#if DBG
        case MCI_STRING:
            dprintf4(( "Found a STRING return field" ));
            //
            // Get string pointer and length
            //
            Size = *(LPDWORD)((LPBYTE)pNewParms + 8);

            //
            // Get the 32 bit string pointer
            //
            if ( Size > 0 ) {

                dprintf4(( "%sFreeing a return STRING pointer", f_name ));
                dprintf5(( "STRING -> %s", (LPSTR)*pdwParm32 ));
            }
            break;
#endif

        case MCI_RECT:
            {
                PRECT   pRect32 = (PRECT)((LPBYTE)pNewParms + 4);
                PRECT16 pRect16 = (PRECT16)((LPBYTE)pdwOrig16 + 4);

                dprintf4(( "%sFound a RECT return field", f_name ));
                pRect16->top    = (SHORT)LOWORD(pRect32->top);
                pRect16->bottom = (SHORT)LOWORD(pRect32->bottom);
                pRect16->left   = (SHORT)LOWORD(pRect32->left);
                pRect16->right  = (SHORT)LOWORD(pRect32->right);
            }
            break;

        case MCI_INTEGER:
            //
            // Get the 32 bit return integer and store it in the
            // 16 bit parameter structure.
            //
            dprintf4(( "%sFound an INTEGER return field", f_name ));
            STOREDWORD( *(LPDWORD)((LPBYTE)pdwOrig16 + 4), *pdwParm32 );
            dprintf5(( "INTEGER -> %ld", *pdwParm32 ));
            break;

        case MCI_HWND:
            dprintf4(( "%sFound an HWND return field", f_name ));
            dwParm16 = MAKELONG( GETHWND16( (HWND)*pdwParm32 ), 0 );
            STOREDWORD( *(LPDWORD)((LPBYTE)pdwOrig16 + 4), dwParm16 );
            dprintf5(( "HWND32 -> 0x%lX", *pdwParm32 ));
            dprintf5(( "HWND16 -> 0x%lX", dwParm16 ));
            break;

        case MCI_HPAL:
            dprintf4(( "%sFound an HPAL return field", f_name ));
            dwParm16 = MAKELONG( GETHPALETTE16( (HPALETTE)*pdwParm32 ), 0 );
            STOREDWORD( *(LPDWORD)((LPBYTE)pdwOrig16 + 4), dwParm16 );
            dprintf5(( "HDC32 -> 0x%lX", *pdwParm32 ));
            dprintf5(( "HDC16 -> 0x%lX", dwParm16 ));
            break;

        case MCI_HDC:
            dprintf4(( "%sFound an HDC return field", f_name ));
            dwParm16 = MAKELONG( GETHDC16( (HDC)*pdwParm32 ), 0 );
            STOREDWORD( *(LPDWORD)((LPBYTE)pdwOrig16 + 4), dwParm16 );
            dprintf5(( "HDC32 -> 0x%lX", *pdwParm32 ));
            dprintf5(( "HDC16 -> 0x%lX", dwParm16 ));
            break;
        }

    }

    return 0;
}

#endif // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\playsnd.c ===
/********************************************************************\
*   playsnd.c
*
*   Level 1 kitchen sink DLL sound driver functions
*
*   Copyright (c) 1991-1999 Microsoft Corporation
*
*********************************************************************/
#define UNICODE

#include "winmmi.h"
#include "playwav.h"
#include "mci.h"


WSZCODE szSoundSection[]  = L"sounds"; // WIN.INI section for sounds

WSZCODE szSystemDefaultSound[] = SOUND_DEFAULT; // Name of the default sound

#define SOUNDNAMELEN 256
STATICDT HANDLE hCurrentSound;              // handle to current sound.

extern LPWAVEHDR lpWavHdr;                  // current playing sound PLAYWAV.C

STATICFN BOOL sndPlaySoundI(LPCWSTR lszSoundName, HMODULE hMod, UINT wFlags);
STATICFN void GetDefaultSound(LPWSTR lszSoundName);
CRITICAL_SECTION SoundCritSec;
#define EnterSound()   EnterCriticalSection(&SoundCritSec);
#define LeaveSound()   LeaveCriticalSection(&SoundCritSec);

void lsplitpath (LPCTSTR pszSource,
                 LPTSTR pszDr, LPTSTR pszPath, LPTSTR pszName, LPTSTR pszExt);
void lstrncpy (LPTSTR pszTarget, LPCTSTR pszSource, size_t cch);
void lstrncpyW (LPWSTR pszTarget, LPCWSTR pszSource, size_t cch);

/****************************************************************************/

#ifndef cchLENGTH
#define cchLENGTH(_sz)  (sizeof(_sz)/sizeof(_sz[0]))
#endif

#ifndef _MAX_DRIVE
#define _MAX_DRIVE    3
#define _MAX_DIR    260
#define _MAX_EXT      5
#define _MAX_FNAME  260
#endif


/**************************************************************************\
*  Sounds are played by the variants of PlaySound (i.e. sndPlaySoundA etc)
*  either synchronously or asynchronously.  The semantics in each case is
*  that there can only be one sound playing at a time, and that we kill any
*  sound which is already playing and then start the new one.  If the new
*  one is sync then we do all the work on the current thread by calling
*  sndMessage directly.  This includes waiting for the sound to complete.
*  If the sound is async then we post a message to mmWndProc and return
*  immediately.
*
*  The message queue of mmWndProc is the queue of async messages
*  still waiting to be played.  It contains the following messages
*  which are of interest:
*     MM_WOM_DONE:  call WaveOutNotify
*     MM_SND_PLAY:  Play an async sound
*     MM_SND_ABORT: Put on the queue when a sync wave request comes in.
*
*  The calling tree is
*
*
*
*
*
*             <---------------------------------------------------
*            |  called to play sound alias synchronously          |
*            v                                                    |
*    (Snd)PlaySound--->PostMessage--->mmWndProc------------------>
*            |                (MM_SND_PLAY)| |
*            |                             | |(MM_WOM_DONE)
*             -----------------------------  |
*                     |                      |
*                     v                      |
*                 sndMessage                 v
*                     |                  WaveOutNotify
*                     v                      |
*              SetCurrentSound               |
*                 |   |                      |
*         --------    |                      |
*        |            v                      |
*        v         soundPlay             ----
*    soundFree       | | |              |
*            --------  |  -----------   |
*           |          |             |  |
*           v          v             v  v
*        soundOpen   soundWait    soundClose
*
*  hwndNotify exists for each process and is a global pseudo-constant.
*  It is set when the window is created (typically 1st async sound or
*  mci command) and is never altered thereafter.  It points in effect to
*  mmWndProc.  There is no real need for the window to exist.  It is a
*  convenience to allow messages to be posted and SENT.  If there was no
*  need to send a message (meaning wait for a reply) we could simply create
*  a thread.
*
*  When an asynch sound comes in it is just added to the queue.  mmWndProc
*  will normally find it and call sndMessage.  Before calling sndMessage
*  mmWndProc peeks at the queue to see if there is any abort message
*  pending.  If there is it doesn't bother to try to play the sound.  It
*  means that a SYNC sound has come in since and has pre-empted it.  The
*  async sound will never play.
*
*  SoundMessage critical section:
*  This mechanism in itself is not quite enough.  It is still possible
*  for an async sound to be already heading into sndMessage at the point
*  when a sync sound comes in.  The two then have a race.  To ensure that
*  there is a clear winner, all the real work in sndMessage is done
*  inside a critical section.  We guarantee that we eventually leave
*  the section by a try/finally in sndMessage.  It is entered and left by
*  the EnterSound and LeaveSound macros.
*
*  WavHdrCritSec critical section
*  The notification uses a global variable lpWavHdr.  This is set by
*  soundOpen and cleared by soundClose.  soundClose may be called
*  asynchronously by WaveOutNotify, so all attempts to dereference it
*  must be protected by a check that it is non-null and a critical section
*  to ensure that it is not nullified between the check and the dereference.
*  It is entered and left by the EnterWavHdr and LeaveWavHdr macros.
\**************************************************************************/

STATICFN UINT TransAlias(UINT alias) {
    switch (alias) {
        case SND_ALIAS_SYSTEMASTERISK:     return STR_ALIAS_SYSTEMASTERISK    ;
        case SND_ALIAS_SYSTEMQUESTION:     return STR_ALIAS_SYSTEMQUESTION    ;
        case SND_ALIAS_SYSTEMHAND:         return STR_ALIAS_SYSTEMHAND        ;
        case SND_ALIAS_SYSTEMEXIT:         return STR_ALIAS_SYSTEMEXIT        ;
        case SND_ALIAS_SYSTEMSTART:        return STR_ALIAS_SYSTEMSTART       ;
        case SND_ALIAS_SYSTEMWELCOME:      return STR_ALIAS_SYSTEMWELCOME     ;
        case SND_ALIAS_SYSTEMEXCLAMATION:  return STR_ALIAS_SYSTEMEXCLAMATION ;
        case SND_ALIAS_SYSTEMDEFAULT:      return STR_ALIAS_SYSTEMDEFAULT     ;
        default: return alias;
    }
}


extern BOOL  WinmmRunningInServer;  // Are we running in the user/base server?
extern BOOL  WaveMapperInitialized; // Wave mapper safely loaded

extern TCHAR gszSchemesRootKey[];
extern TCHAR gszSchemeAppsKey[];
extern TCHAR aszDefault[];
extern TCHAR aszCurrent[];
extern TCHAR asz4Format[];
extern TCHAR asz5Format[];
extern TCHAR asz6Format[];
extern TCHAR aszActiveKey[];
extern TCHAR aszBoolOne[];
extern TCHAR aszSetup[];	// REGSTR_PATH_SETUP
extern TCHAR aszValMedia[];	// REGSTR_VAL_MEDIA

extern TCHAR gszDefaultBeepOldAlias[];	// "SystemDefault"

BOOL UseRegistry= FALSE;
TCHAR Keyname[] = TEXT("Control Panel\\Sounds\\");


//--------------------------------------------------------------------------;
BOOL PASCAL sndQueryRegistry (LPCWSTR szScheme,
                              LPCWSTR szApp,
                              LPCWSTR szSound,
                              LPWSTR  szBuffer)
{
    TCHAR   szKey[196];
    LONG    cbValue;

    wsprintfW (szKey, asz5Format, // ("AppEvents\Apps\(app)\(sound)\(scheme)")
               gszSchemesRootKey,
               gszSchemeAppsKey,
               szApp,
               szSound,
               szScheme);

    if (mmRegQueryUserValue (szKey, NULL, MAX_SOUND_ATOM_CHARS, szBuffer))
    {
                // There's an entry--but make sure it's enabled!
                //
        wsprintfW (szKey, asz6Format,  // "AppEvents\Apps\app\snd\scheme\Active"
                   (LPCSTR)gszSchemesRootKey,
                   (LPCSTR)gszSchemeAppsKey,
                   (LPCSTR)szApp,
                   szSound,
                   szScheme,
                   aszActiveKey);

        if (!mmRegQueryUserValue (szKey, NULL, cchLENGTH(szKey), szKey))
        {
            return TRUE;	// Not disabled?  Okay.
        }

        if (!lstrcmpW (szKey, aszBoolOne))
        {
            return TRUE;	// Says it's enabled?  Okay.
        }
    }

    return FALSE;
}


/****************************************************************************/
STATICFN BOOL GetSoundAlias(
    LPCWSTR  lszSoundName,
    LPWSTR   lszBuffer,
    DWORD    dwFlags)
/****************************************************************************/
{
    BOOL   fFound;
    LPWSTR lpwstrFilePart;
    TCHAR  szApp[APP_TYPE_MAX_LENGTH];
    TCHAR  szScheme[SCH_TYPE_MAX_LENGTH];
    LONG   cbValue;
    TCHAR  szTemp[ _MAX_FNAME ];

    if ((lszSoundName == NULL) || (lszBuffer == NULL))
        return FALSE;

            //
            // Try to translate the alias (from lszSoundName--it'll be
            // ".Default", "MailBeep", etc) into a fully-qualified
            // filename.  Note that lszSoundName and lszBuffer may point
            // to the same address space.
            //
            // If it's "SystemDefault", play ".Default" instead.
            //

    fFound = FALSE;

    if (!lstrcmp (lszSoundName, gszDefaultBeepOldAlias))
    {
        lszSoundName = szSystemDefaultSound;
    }

    if (lstrlen(lszSoundName) < EVT_TYPE_MAX_LENGTH)
    {

                //
                // first determine what application is calling us;
                // we'll use ".default" if nothing is apparent, but
                // in theory we should be able to differentiate sounds
                // on an app by app basis.
                //

        szApp[0] = TEXT('\0');

        if (dwFlags & SND_APPLICATION)
        {
            if (GetModuleFileName (GetModuleHandle(NULL),
                                   szTemp, sizeof(szTemp)/sizeof(szTemp[0])))
            {
                lsplitpath (szTemp, NULL, NULL, szApp, NULL);
            }
        }

        if (szApp[0] == TEXT('\0'))
        {
            lstrcpy(szApp, aszDefault);
        }

                //
                // determine what the current scheme is, and find the
                // appropriate sound.  Try both the app we queried above,
                // and ".Default" if necessary.
                //

        szScheme[0] = TEXT('\0');

        if (sndQueryRegistry(aszCurrent, szApp,      lszSoundName, szTemp) ||
            sndQueryRegistry(aszCurrent, aszDefault, lszSoundName, szTemp))
        {
            lstrcpy (lszBuffer, szTemp);
            fFound = TRUE;
        }
    }

            //
            // Were we able to translate the alias into a valid filename?
            //

    if (!fFound)
    {
        // never found a matching alias!
        //
        return FALSE;
    }

    lstrcpy (szTemp, lszBuffer);
    return TRUE;
}


/****************************************************************************/
STATICFN BOOL PASCAL NEAR GetSoundName(
    LPCWSTR  lszSoundName,
    LPWSTR   lszBuffer,
    DWORD    flags)
/****************************************************************************/
{
    int     i;
    WCHAR   szTmpFileName[SOUNDNAMELEN];
    LPWSTR  lpwstrFilePart;

    //
    //  if the sound is defined in the [sounds] section of WIN.INI
    //  get it and remove the description, otherwise assume it is a
    //  file and qualify it.
    //
    // If we KNOW it is a filename do not look in the INI file
    if ((flags & SND_ALIAS) || !(flags & SND_FILENAME)) {

        if (!GetSoundAlias ( lszSoundName, lszBuffer, flags)) {
            lstrcpy( lszBuffer, lszSoundName );
        }

    } else  {
        lstrcpy( lszBuffer, lszSoundName );
    }

//  UNICODE:  Can't use OpenFile with Unicode string name.  As we are
//  checking to see if the file exists and then copying its fully
//  qualified name to lszBuffer, (ie. not opening the file) I will
//  use SearchPathW instead.
//
//  if (OpenFile(lszBuffer, &of, OF_EXIST | OF_READ | OF_SHARE_DENY_NONE) != HFILE_ERROR) {
//      OemToAnsi(of.szPathName, lszBuffer);
//  }


    lstrcpy( szTmpFileName, lszBuffer );
    if (!SearchPathW( NULL, szTmpFileName, L".WAV", SOUNDNAMELEN,
                      lszBuffer, &lpwstrFilePart )) {
       WCHAR szMediaPath[MAX_PATH];

       if (mmRegQueryMachineValue (aszSetup, aszValMedia,
                                   cchLENGTH(szMediaPath), szMediaPath)) {
          if (!SearchPathW( szMediaPath, szTmpFileName, L".WAV", SOUNDNAMELEN,
                            lszBuffer, &lpwstrFilePart )) {
             return FALSE;  // couldn't find the sound file anywhere!
          }
       }
    }

    //  Clearing warning.

    return TRUE;
}


/*****************************************************************************
 * @doc EXTERNAL
 *
 * @api BOOL | sndPlaySound | This function plays a waveform
 *      sound specified by a filename or by an entry in the [sounds] section
 *      of WIN.INI.  If the sound can't be found, it plays the
 *      default sound specified by the .Default entry in the
 *      [sounds] section of WIN.INI. If there is no .Default
 *      entry or if the default sound can't be found, the function
 *      makes no sound and returns FALSE.
 *
 * @parm LPCSTR | lpszSoundName | Specifies the name of the sound to play.
 *      The function searches the [sounds] section of WIN.INI for an entry
 *      with this name and plays the associated waveform file.
 *      If no entry by this name exists, then it assumes the name is
 *      the name of a waveform file. If this parameter is NULL, any
 *      currently playing sound is stopped.
 *
 * @parm UINT | wFlags | Specifies options for playing the sound using one
 *      or more of the following flags:
 *              
 * @flag  SND_SYNC            | The sound is played synchronously and the
 *      function does not return until the sound ends.
 * @flag  SND_ASYNC           | The sound is played asynchronously and the
 *      function returns immediately after beginning the sound. To terminate
 *      an asynchronously-played sound, call <f sndPlaySound> with
 *      <p lpszSoundName> set to NULL.
 * @flag  SND_NODEFAULT       | If the sound can't be found, the function
 *      returns silently without playing the default sound.
 * @flag  SND_MEMORY          | The parameter specified by <p lpszSoundName>
 *      points to an in-memory image of a waveform sound.
 * @flag  SND_LOOP            | The sound will continue to play repeatedly
 *      until <f sndPlaySound> is called again with the
 *      <p lpszSoundName> parameter set to NULL.  You must also specify the
 *      SND_ASYNC flag to loop sounds.
 * @flag  SND_NOSTOP          | If a sound is currently playing, the
 *      function will immediately return FALSE without playing the requested
 *      sound.
 *
 * @rdesc Returns TRUE if the sound is played, otherwise
 *      returns FALSE.
 *
 * @comm The sound must fit in available physical memory and be playable
 *      by an installed waveform audio device driver. The directories
 *      searched for sound files are, in order: the current directory;
 *      the Windows directory; the Windows system directory; the directories
 *      listed in the PATH environment variable; the list of directories
 *      mapped in a network. See the Windows <f OpenFile> function for
 *      more information about the directory search order.
 *
 *      If you specify the SND_MEMORY flag, <p lpszSoundName> must point
 *      to an in-memory image of a waveform sound. If the sound is stored
 *      as a resource, use <f LoadResource> and <f LockResource> to load
 *      and lock the resource and get a pointer to it. If the sound is not
 *      a resource, you must use <f GlobalAlloc> with the GMEM_MOVEABLE and
 *      GMEM_SHARE flags set and then <f GlobalLock> to allocate and lock
 *      memory for the sound.
 *
 * @xref MessageBeep
 ****************************************************************************/
BOOL APIENTRY sndPlaySoundW( LPCWSTR szSoundName, UINT wFlags)
{
    UINT    cDevs;

    //
    //  !!! quick exit for no wave devices !!!
    //

    ClientUpdatePnpInfo();

    EnterNumDevs("sndPlaySoundW");
    cDevs = wTotalWaveOutDevs;
    LeaveNumDevs("sndPlaySoundW");

    if (cDevs) {
        return sndPlaySoundI(szSoundName, NULL, wFlags);
    } else {
        return FALSE;
    }
}

BOOL APIENTRY sndPlaySoundA( LPCSTR szSoundName, UINT wFlags)
{
    return PlaySoundA(szSoundName, NULL, wFlags);
}

BOOL APIENTRY PlaySoundW(LPCWSTR szSoundName, HMODULE hModule, DWORD wFlags)
{
    UINT    cDevs;

    //
    //  !!! quick exit for no wave devices !!!
    //

    ClientUpdatePnpInfo();

    EnterNumDevs("sndPlaySoundW");
    cDevs = wTotalWaveOutDevs;
    LeaveNumDevs("sndPlaySoundW");

    if (cDevs) {
        return sndPlaySoundI(szSoundName, hModule, (UINT)wFlags);
    }
    return FALSE;
}

BOOL APIENTRY PlaySoundA(LPCSTR szSoundName, HMODULE hModule, DWORD wFlags)
{
    UINT  cDevs;
    WCHAR UnicodeStr[256]; // Unicode version of szSoundName

    //
    //  !!! quick exit for no wave devices !!!
    //

    ClientUpdatePnpInfo();

    EnterNumDevs("sndPlaySoundW");
    cDevs = wTotalWaveOutDevs;
    LeaveNumDevs("sndPlaySoundW");

    if (cDevs) {

        // We do not want to translate szSoundName unless it is a pointer
        // to an ascii string.  It may be a pointer to an in-memory copy
        // of a wave file, or it may identify a resource.  If a resource
        // then we do want to translate the name.  Note that there is an
        // overlap between SND_MEMORY and SND_RESOURCE.  This is deliberate
        // as later on the resource will be loaded - then played from memory.

        if ( HIWORD(szSoundName)         // Potential to point to an ascii name
             // Translate if NOT memory, or a resource
             // If the resource is identified by ID - the ID better be <= 0xFFFF
             // which applies to lots of other code as well!
          && (!(wFlags & SND_MEMORY) || ((wFlags & SND_RESOURCE) == SND_RESOURCE))
          ) {
            //
            // Convert the Unicode sound name into Ascii
            //

            if (Imbstowcs(UnicodeStr, szSoundName,
                          sizeof(UnicodeStr) / sizeof(WCHAR)) >=
                sizeof(UnicodeStr) / sizeof(WCHAR)) {
                return 0;
            }

            return sndPlaySoundI( UnicodeStr, hModule, (UINT)wFlags );
        }
        else {
            return sndPlaySoundI( (LPWSTR)szSoundName, hModule, (UINT)wFlags );
        }
    }
    return FALSE;
}


/****************************************************************************/
/*
@doc    INTERNAL

@func   BOOL | sndPlaySoundI | Internal version of <f>sndPlaySound<d> which
    resides in the WAVE segment instead.

    If the SND_NOSTOP flag is specifed and a wave file is currently
    playing, or if for some reason no WINMM window is present, the
    function returns failure immediately.  The first condition ensures
    that a current sound is not interrupted if the flag is set.  The
    second condition is only in case of some start up error in which
    the notification window was not created, or WINMM was not
    specified in the [drivers] line, and therefore never loaded.

    Next, if the <p>lszSoundName<d> parameter does not represent a memory
    file, and it is non-NULL, then it must represent a string.  Therefore
    the string must be parsed before sending the sound message to the
    WINMM window.  This is because the WINMM window may reside in a
    a different task than the task which is calling the function, and
    would most likely have a different current directory.

    In this case, the parameter is first checked to determine if it
    actually contains anything.  For some reason a zero length string
    was determined to be able to return TRUE from this function, so that
    is checked.

    Next the string is checked against INI entries, then parsed.

    After parsing the sound name, ensure that a task switch only occurs if
    the sound is asynchronous (SND_ASYNC), and a previous sound does not
    need to be discarded.

    If a task switch is needed, first ensure that intertask messages can
    be sent by checking to see that this task is not locked, or that the
    notification window is in the current task.

@parm   LPCSTR | lszSoundName | Specifies the name of the sound to play.

@parm   UINT | wFlags | Specifies options for playing the sound.

@rdesc  Returns TRUE if the function was successful, else FALSE if an error
    occurred.
*/
STATICFN BOOL sndPlaySoundI(
    LPCWSTR  lszSoundName,
    HMODULE  hMod,
    UINT    wFlags)
{
    BOOL        fPlayReturn;
    LPWSTR      szSoundName = NULL;
    UINT        nLength = 0;
    
    //  Note: Although the max size of a system event sound is 80 chars,
    //        the limitation of the registry key is 256 chars.
    
    WCHAR       temp[256];  // Maximum size of a system event sound

    V_FLAGS(wFlags, SND_VALIDFLAGS, sndPlaySoundW, FALSE);

    if (!(wFlags & SND_MEMORY) && HIWORD(lszSoundName)) {
        V_STRING_W(lszSoundName, 256, FALSE);
    }

    WinAssert(!SND_SYNC); // Because the code relies on SND_ASYNC being non-0

#if DBG
    if (wFlags & SND_MEMORY) {
        STATICFN SZCODE szFormat[] = "sndPlaySound(%lx) Flags %8x";
        dprintf2((szFormat, lszSoundName, wFlags));

    } else if (HIWORD(lszSoundName)) {

        STATICFN SZCODE szFormat[] = "sndPlaySound(%ls) Flags %8x";
        dprintf2((szFormat, lszSoundName, wFlags));

    } else if (lszSoundName) {

        STATICFN SZCODE szFormat[] = "sndPlaySound(0x%x)  Flags %8x";
        dprintf2((szFormat, lszSoundName, wFlags));
    }

#endif  //if DBG

    if (((wFlags & SND_NOSTOP) && lpWavHdr) /*** || (NoNotify)  ***/) {
        dprintf1(("Sound playing, or no notify window"));
        return FALSE;
    }

    //
    //  Bad things happen in functions like LoadIcon which the ACM CODECs
    //  call during their initialization if we're on a CSRSS thread so always
    //  make async calls until we're sure it's initialized.
    //  The last test makes sure we don't 'or' in the SND_ASYNC flag again
    //  on the server thread!
    //
    if ( WinmmRunningInServer && !WaveMapperInitialized &&
         SND_ALIAS_ID == (wFlags & SND_ALIAS_ID)) {
        wFlags |= SND_ASYNC;
    }

    // comments here should have been there from day 1 and explain
    // the test
    //
    //  if (!hwndNotify && !(!(wFlags & SND_ASYNC) && !lpWavHdr))
    // IF   no window
    // AND     NOT  (Synchronous, and no sound present)
    //         ==    Async OR sound present
    // Which meant that if a sound is playing we will attempt to create
    // a second thread even if this is a synchronous request.  This
    // causes havoc when we are called on the server side.


    // If this is an asynchronous call we need to create the asynchronous
    // thread on which the sound will be played.  We should NEVER create
    // the thread if this is a synchronous request, irrespective of the
    // current state (i.e. sound playing, or no sound playing).

    if (wFlags & SND_ASYNC) {
        if (!InitAsyncSound()) {
            dprintf2(("Having to play synchronously - cannot create notify window"));
            wFlags &= ~SND_ASYNC;
            if (WinmmRunningInServer) {
                return FALSE;
            }
        }
    }

    if ( WinmmRunningInServer && (wFlags & SND_ASYNC) ) {

        UINT alias;   // To check if the incoming alias is SYSTEMDEFAULT
        // lszSoundName is NOT a pointer to a filename.  It
        // is a resource id.  Resolve the name from the INI file
        // now.

        if (SND_ALIAS_ID == (wFlags & SND_ALIAS_ID)) {
            nLength = LoadStringW( ghInst,
                                   (alias = TransAlias((UINT)(UINT_PTR)lszSoundName)),
                                   temp, sizeof(temp)/sizeof(WCHAR) );
            if (0 == nLength) {
                dprintf3(("Could not translate Alias ID"));
                return(FALSE);
            } else {
                dprintf3(("Translated alias %x to sound %ls", lszSoundName, temp));
            }

            // We cannot switch control immediately to the async thread as that
            // thread does not have the correct user impersonation.  So rather
            // than passing an alias we resolve it here to a filename.
            // Later: we should get the async thread to set the correct user
            // token and inifilemapping  - then we could revert to passing aliases.

            // Turn off the ID bit, leave ALIAS on)
            wFlags &= ~(SND_ALIAS_ID);
            wFlags |= SND_ALIAS;
        } else {
            //
            // Note: I (RichJ) just stuck this ELSE in here for 3.51, but a
            // lack of it should've been causing faults or failed lookups any
            // time an async sound was requested from the server, without
            // using an ALIAS_ID as the request.  Did that just never happen?
            //
            lstrcpy (temp, lszSoundName);
        }

        // Translate the alias to a file name
        dprintf4(("Calling GetSoundName"));
        if (!GetSoundName(temp, base->szSound, SND_ALIAS)) {
            //
            // Couldn't find the sound file; if there's no default sound,
            // then don't play anything (and don't cancel what's
            // playing now--for example, what if the MenuPopup event
            // has a sound, but the MenuCommand event doesn't?)
            //
	    if (wFlags & SND_NODEFAULT) {
                return(FALSE);
	    }
	}
        dprintf4(("Set %ls as the sound name", base->szSound));

        if (lpWavHdr) {  // Sound is playing
            dprintf4(("Killing pending sound on server"));
            soundFree(NULL);  // Kill any pending sound
        }

        LockMCIGlobal;

        dprintf2(("Signalling play of %x",lszSoundName));
        base->msg = MM_SND_PLAY;
        base->dwFlags = wFlags | SND_FILENAME;
        base->dwFlags &= ~(SND_ALIAS_ID | SND_ALIAS);
        base->lszSound = lszSoundName;

        if (wFlags & SND_NODEFAULT) {
        } else {
            if (STR_ALIAS_SYSTEMDEFAULT == alias) {
                wFlags |= SND_NODEFAULT;
                // We will play the default sound, hence there is
                // no point in having the NODEFAULT flag off.
                dprintf4(("Playing the default sound"));
            } else {

                // If we cannot find or play the file passed in
                // we have to play a default sound.  By the time
                // we get around to playing a default sound we will
                // have lost the ini file mapping.  Resolve the name
                // now.
                dprintf4(("Resolving default sound"));
                GetSoundName(szSystemDefaultSound,
                             base->szDefaultSound,
                             SND_ALIAS);
            }
        }

        dprintf2(("Setting event"));
        SetMCIEvent( hEvent );

        dprintf2(("Event set"));
        UnlockMCIGlobal;

        return(TRUE);
    }

    if (!(wFlags & SND_MEMORY) && lszSoundName) {

        if (!(szSoundName = (LPWSTR)LocalAlloc(LMEM_FIXED, SOUNDNAMELEN * sizeof(WCHAR)))) {
            return FALSE;
        }
        dprintf4(("Allocated szSoundName at %8x", szSoundName));

        if (SND_ALIAS_ID == (wFlags & SND_ALIAS_ID)) {
            // lszSoundName is NOT a pointer to a filename.  It
            // is a resource id.  Resolve the name from the INI file
            // now.

            nLength = LoadStringW( ghInst,
                                   (UINT)TransAlias(PtrToUlong(lszSoundName)),
                                   szSoundName, SOUNDNAMELEN );
            if (0 == nLength) {
                dprintf3(("Could not translate Alias ID"));
                return(FALSE);
            }

            lszSoundName = szSoundName;
            // Turn off the ID bit, leave ALIAS on)
            wFlags &= (~SND_ALIAS_ID | SND_ALIAS);
        }

        if (!*lszSoundName) {
            // LATER: STOP any sound that is already playing
            LocalFree ((HLOCAL)szSoundName);
            return TRUE;
        }

        if (!GetSoundName(lszSoundName, szSoundName, wFlags)) {
            //
            // Couldn't find the sound file; if there's no default sound,
            // then don't play anything (and don't cancel what's
            // playing now--for example, what if the MenuPopup event
            // has a sound, but the MenuCommand event doesn't?)
            //
            if (wFlags & SND_NODEFAULT) {
                LocalFree ((HLOCAL)szSoundName);
                return TRUE;
            }
        }

        lszSoundName = (LPCWSTR)szSoundName;
        nLength = lstrlenW(szSoundName);

    } else {

        // lszSoundName points to a memory image (if SND_MEMORY)
        // or lszSoundName is null.  Either way we do not want to
        // load a file.  OR we may have a resource to load.

        HANDLE hResInfo;
        HANDLE hResource;

        szSoundName = NULL;

        if (SND_RESOURCE == (wFlags & SND_RESOURCE)) {
	    
	    hResInfo = FindResourceW( hMod, lszSoundName, SOUND_RESOURCE_TYPE_SOUND );
	    if (NULL == hResInfo) {
		hResInfo = FindResourceW( hMod, lszSoundName, SOUND_RESOURCE_TYPE_WAVE );
	    }

            if (hResInfo) {
                hResource = LoadResource( hMod, hResInfo);
                if (hResource) {
                    lszSoundName = LockResource(hResource);
                } else {
                    dprintf1(("failed to load resource"));
                    return(FALSE);
                }
            } else {
                dprintf1(("failed to find resource"));
                return(FALSE);
            }
            // Turn off the resource bit
            wFlags &= ~(SND_RESOURCE-SND_MEMORY);
        }
    }

    // This was the old test - replaced with the one below.  The
    if (szSoundName) {
        wFlags |= SND_FREE;
        // LocalFree((HANDLE)szSoundName);  // Freed by SNDMESSAGE
    }

    // For a synchronous sound it is valid for a prior async sound to be
    // still playing.  Before we finally play this new sound we will kill
    // the old sound.  The code commented out below caused a SYNC sound to
    // play asynchronously if a previous sound was still active
    if (!(wFlags & SND_ASYNC) /* && !lpWavHdr SOUND IS STILL PLAYING */) {

        if (hwndNotify) {  // Clear any pending asynchronous sounds
            PostMessage(hwndNotify, MM_SND_ABORT, 0, 0);
        }
        fPlayReturn = sndMessage( (LPWSTR)lszSoundName, wFlags);

    } else {

        WinAssert(hwndNotify);   // At this point we need the window
        // Note: in this leg we must free lszSoundName later
        dprintf3(("Sending MM_SND_PLAY to hwndNotify"));

        fPlayReturn = PostMessage(hwndNotify, MM_SND_PLAY, wFlags, (LPARAM)lszSoundName);
    }

    return fPlayReturn;
}

/****************************************************************************\
* INTERNAL MatchFile                                                                                                             *
*                                                                                                                                                        *
* Checks that the file stored on disk matches the cached sound file for          *
* date, time and size.  If not, then we return FALSE and the cached sound        *
* file is not used.  If the details do match we return TRUE.  Note that the  *
* last_write file time is used in case the user has updated the file.        *
\****************************************************************************/

STATICFN BOOL MatchFile(PSOUNDFILE pf, LPCWSTR lsz)
{
    HANDLE fh;
    BOOL result = FALSE;
    fh = CreateFileW( lsz,
                      GENERIC_READ,
                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL );

    if ((HANDLE)(UINT_PTR)HFILE_ERROR != fh) {
        if (pf->Size == GetFileSize(fh, NULL)) {
            FILETIME ft;
            if (GetFileTime(fh, NULL, NULL, &ft)) {
                if (CompareFileTime(&ft, &(pf->ft)) == 0) {
                    result = TRUE;
                }
            } else {
               dprintf2(("Error %d getting last write time", GetLastError()));
            }
        }
        CloseHandle(fh);
    }
    return result;
}

/*********************************************************************\
* INTERNAL SetCurrentSound
*
* Called to set the cached sound on this process to <lszSoundName>.
* Before discarding the current sound we check to see if it is the
* same as the one about to be loaded.  If so, then it need not be
* read off the disk.  To be considered the same not only the filename
* has to match, but the file date, time and size.  Note: Windows 3.1
* only matches on the name.
\*********************************************************************/
STATICFN BOOL PASCAL NEAR SetCurrentSound(
    LPCWSTR  lszSoundName)
{
    HANDLE  hSound;
    BOOL    f;
    LPWSTR  lp;

    if (hCurrentSound && (NULL != (lp = GlobalLock(hCurrentSound)))) {

        f = lstrcmpiW( ((PSOUNDFILE)lp)->Filename, (LPWSTR)lszSoundName);

        if (f == 0 && MatchFile( ((PSOUNDFILE)lp), lszSoundName)) {
            GlobalUnlock(hCurrentSound);
            dprintf2(("SetCurrentSound - sound already loaded %ls",(LPWSTR)lszSoundName));
            return TRUE;
        }
        GlobalUnlock(hCurrentSound);
    }

    dprintf2(("SetCurrentSound(%ls)\r\n",lszSoundName));

    if (NULL != (hSound = soundLoadFile(lszSoundName))) {
        soundFree(hCurrentSound);
        hCurrentSound = hSound;
        dprintf3(("SetCurrentSound returning TRUE"));
        return TRUE;
    }
    dprintf3(("SetCurrentSound returning FALSE"));
    return FALSE;
}

/****************************************************************************/
/*
@doc    INTERNAL

@func   BOOL | SoundBeep | Called to sound the speaker when the .Default
        sound either does not exist or is set to NULL

@rdesc  Returns TRUE if the function was successful, else FALSE if an error
    occurred.
*/

STATICFN BOOL SoundBeep(VOID)
{
    BOOL fBeep;
    if (WinmmRunningInServer) {
        // being played on the server thread.  We would not have
        // got here unless the user wants beeps to sound
        fBeep = TRUE;
    } else {
        if (!SystemParametersInfo(SPI_GETBEEP, 0, &fBeep, FALSE)) {
            // Failed to get hold of beep setting.  Should we be
            // noisy or quiet?  We have to choose one value...
            fBeep = TRUE;
        }
    }

    if (fBeep) {
        dprintf5(("Sounding the speaker"));
        // LATER: Symbolic constant... read from which header file?
        return Beep(440, 125);
    } else {
        dprintf5(("NO speaker sound"));
        return(TRUE);
    }
}

/****************************************************************************/
/*
@doc    INTERNAL

@func   BOOL | sndMessage | This function is called in response to an
    MM_SND_PLAY message sent to the WINMM window, and attempts to
    play the specified file, or dump current sound caching.

    If <p>lszSoundName<d> is NULL, any currently cached sound is
    discarded, and the function returns success.

    If the SND_MEMORY flag is set, then <p>lszSoundName<d> actually
    points to a buffer containing a RIFF format WAVE memory file, and
    the function attempts to play it.  The load function performs
    validation on this memory file.  Unlike playing sound names,
    memory files are not cached for future use.

    Otherwise the <p>lszSoundName<d> parameter is actually an INI entry
    or file name.  The function initially attempts to load that sound,
    and if it fails, attempts to load the system default sound.  Note of
    course that the SND_NODEFAULT flag is first checked to determine if
    the default sound is to be played when the original name cannot be
    located.  If no default is wanted, or the default cannot be located,
    the function returns failure.  Note that in calling <f>GetSoundName<d>,
    the <p>lszSoundName<d> parameter is modified.  This function assumes
    that the parameter passed has been previously allocated if a string is
    passed to this function, and is not the actual user's parameter passed
    to <f>sndPlaySound<d>.

@parm   LPSTR | lszSoundName | Specifies the name of the sound to play.

@parm   UINT | wFlags | Specifies options for playing the sound.

@rdesc  Returns TRUE if the function was successful, else FALSE if an error
    occurred.
*/
#if DBG
UINT CritCount = 0;
UINT CritOwner = 0;
#endif

BOOL FAR PASCAL sndMessage(LPWSTR lszSoundName, UINT wFlags)
{
    BOOL fResult;
#if DBG
    if (!lszSoundName) {
        dprintf3(("sndMessage - sound NULL, Flags %8x", wFlags));
    } else {
        dprintf3(("sndMessage - sound %ls, Flags %8x", lszSoundName, wFlags));
    }
#endif

  try {

#if DBG
    if (CritCount) {
        dprintf2(("Sound critical section owned by %x, thread %x waiting", CritOwner, GetCurrentThreadId()));
    }
#endif

    EnterSound();

#if DBG
    if (!CritCount++) {
        CritOwner = GetCurrentThreadId();
        dprintf2(("Thread %x entered Sound critical section", CritOwner));
    } else {
        dprintf2(("Thread %x re-entered Sound critical section, count is %d", CritOwner, CritCount));
    }
#endif

    if (!lszSoundName) {
        // Note that soundFree will stop playing the current sound if
        // it is still playing
        dprintf4(("Freeing current sound, nothing else to play"));
        soundFree(hCurrentSound);
        hCurrentSound = NULL;

        fResult = TRUE;
        goto exit;
    }

    if (wFlags & SND_MEMORY) {

        soundFree(hCurrentSound);
        hCurrentSound = soundLoadMemory( (PBYTE)lszSoundName );

    } else if (!SetCurrentSound(lszSoundName)) {

        if (wFlags & SND_NODEFAULT) {
            if (wFlags & SND_FREE) {
                dprintf3(("Freeing (1) memory block at %8x",lszSoundName));
                LocalFree(lszSoundName);
            }
            fResult = FALSE;
            goto exit;
        }

        GetDefaultSound(lszSoundName);

        // If there is no default sound (.Default == NONE in CPL applet)
        // then sound the old beep.
        if (!*lszSoundName || !SetCurrentSound(lszSoundName)) {
            fResult = SoundBeep();
            if (wFlags & SND_FREE) {
                dprintf3(("Freeing (2) memory block at %8x",lszSoundName));
                LocalFree(lszSoundName);
            }
            goto exit;
        }
    }

    if (wFlags & SND_FREE) {
        dprintf3(("Freeing (3) memory block at %8x",lszSoundName));
        LocalFree(lszSoundName);
    }

    dprintf3(("Calling soundPlay, flags are %8x", wFlags));
    fResult = soundPlay(hCurrentSound, wFlags);
    dprintf3(("returning from sndMessage"));
    exit:;

  } finally {

#if DBG
    if (!--CritCount) {
        dprintf2(("Thread %x relinquishing Sound critical section", CritOwner));
        CritOwner = 0;
    } else {
        dprintf2(("Thread %x leaving Sound critical section, Count is %d", CritOwner, CritCount));
    }
#endif

    LeaveSound();
  } // try
    return(fResult);
}


STATICFN void GetDefaultSound(LPWSTR lszSoundName)
{
    // It's a shame the default sound cannot be cached.  Unfortunately
    // the user can change the mapping (alias->different_file) or even
    // change the file while keeping the same file name.  The only time
    // we do not resolve the name from the INI file is when we are
    // executing in the server.  There may be no ini file mapping in
    // existence (but arbitrarily opening a mapping fails if already
    // open) so we rely on the default sound filename being preset.
    if (!WinmmRunningInServer) {
        GetSoundName(szSystemDefaultSound, lszSoundName, SND_ALIAS);
    } else {
        LockMCIGlobal;
        wcscpy(lszSoundName, base->szDefaultSound);
        UnlockMCIGlobal;
    }
}


void lsplitpath (LPCTSTR pszSource,
                 LPTSTR pszDrive, LPTSTR pszPath, LPTSTR pszName, LPTSTR pszExt)
{
   LPCTSTR  pszLastSlash = NULL;
   LPCTSTR  pszLastDot = NULL;
   LPCTSTR  pch;
   size_t   cchCopy;

        /*
         * NOTE: This routine was snitched out of USERPRI.LIB 'cause the
         * one in there doesn't split the extension off the name properly.
         *
         * We assume that the path argument has the following form, where any
         * or all of the components may be missing.
         *
         *      <drive><dir><fname><ext>
         *
         * and each of the components has the following expected form(s)
         *
         *  drive:
         *      0 to _MAX_DRIVE-1 characters, the last of which, if any, is a
         *      ':'
         *  dir:
         *      0 to _MAX_DIR-1 characters in the form of an absolute path
         *      (leading '/' or '\') or relative path, the last of which, if
         *      any, must be a '/' or '\'.  E.g -
         *      absolute path:
         *          \top\next\last\     ; or
         *          /top/next/last/
         *      relative path:
         *          top\next\last\      ; or
         *          top/next/last/
         *      Mixed use of '/' and '\' within a path is also tolerated
         *  fname:
         *      0 to _MAX_FNAME-1 characters not including the '.' character
         *  ext:
         *      0 to _MAX_EXT-1 characters where, if any, the first must be a
         *      '.'
         *
         */

             // extract drive letter and :, if any
             //
   if (*(pszSource + _MAX_DRIVE - 2) == TEXT(':'))
      {
      if (pszDrive)
         {
         lstrncpy (pszDrive, pszSource, _MAX_DRIVE-1);
         pszDrive[ _MAX_DRIVE-1 ] = TEXT('\0');
         }
      pszSource += _MAX_DRIVE-1;
      }
    else if (pszDrive)
      {
      *pszDrive = TEXT('\0');
      }

          // extract path string, if any.  pszSource now points to the first
          // character of the path, if any, or the filename or extension, if
          // no path was specified.  Scan ahead for the last occurence, if
          // any, of a '/' or '\' path separator character.  If none is found,
          // there is no path.  We will also note the last '.' character found,
          // if any, to aid in handling the extension.
          //
   for (pch = pszSource; *pch != TEXT('\0'); pch++)
      {
      if (*pch == TEXT('/') || *pch == TEXT('\\'))
         pszLastSlash = pch;
      else if (*pch == TEXT('.'))
         pszLastDot = pch;
      }

          // if we found a '\\' or '/', fill in pszPath
          //
   if (pszLastSlash)
      {
      if (pszPath)
         {
         cchCopy = min( (size_t)(_MAX_DIR -1), (size_t)(pszLastSlash -pszSource +1) );
         lstrncpy (pszPath, pszSource, cchCopy);
         pszPath[ cchCopy ] = 0;
         }
      pszSource = pszLastSlash +1;
      }
   else if (pszPath)
      {
      *pszPath = TEXT('\0');
      }

             // extract file name and extension, if any.  Path now points to
             // the first character of the file name, if any, or the extension
             // if no file name was given.  Dot points to the '.' beginning the
             // extension, if any.
             //

   if (pszLastDot && (pszLastDot >= pszSource))
      {
               // found the marker for an extension -
               // copy the file name up to the '.'.
               //
      if (pszName)
         {
         cchCopy = min( (size_t)(_MAX_DIR-1), (size_t)(pszLastDot -pszSource) );
         lstrncpy (pszName, pszSource, cchCopy);
         pszName[ cchCopy ] = 0;
         }

               // now we can get the extension
               //
      if (pszExt)
         {
         lstrncpy (pszExt, pszLastDot, _MAX_EXT -1);
         pszExt[ _MAX_EXT-1 ] = TEXT('\0');
         }
      }
   else
      {
               // found no extension, give empty extension and copy rest of
               // string into fname.
               //
      if (pszName)
         {
         lstrncpy (pszName, pszSource, _MAX_FNAME -1);
         pszName[ _MAX_FNAME -1 ] = TEXT('\0');
         }

      if (pszExt)
         {
         *pszExt = TEXT('\0');
         }
      }

}

void lstrncpy (LPTSTR pszTarget, LPCTSTR pszSource, size_t cch)
{
   size_t ich;
   for (ich = 0; ich < cch; ich++)
      {
      if ((pszTarget[ich] = pszSource[ich]) == TEXT('\0'))
         break;
      }
}

void lstrncpyW (LPWSTR pszTarget, LPCWSTR pszSource, size_t cch)
{
   size_t ich;
   for (ich = 0; ich < cch; ich++)
      {
      if ((pszTarget[ich] = pszSource[ich]) == L'\0')
         break;
      }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\playwav.c ===
/*******************************Module*Header*********************************\
* Module Name: playwav.c
*
* Sound support routines for NT - ported from Windows 3.1 Sonic
*
* Created:
* Author:
* Jan  92: Ported to Win32 - SteveDav
*
* History:
*
* Copyright (c) 1992-1998 Microsoft Corporation
*
\******************************************************************************/
#define UNICODE

#define MMNOSEQ
#define MMNOJOY
#define MMNOMIDI
#define MMNOMCI

#include "winmmi.h"
#include "playwav.h"

//
// These globals are used to keep track of the currently playing sound, and
// the handle to the wave device.  only 1 sound can be playing at a time.
//

STATICDT HWAVEOUT    hWaveOut;         // handle to open wave device
LPWAVEHDR   lpWavHdr;                  // current wave file playing
ULONG timeAbort;                       // time at which we should give up waiting
                                       //  for a playing sound to finish
CRITICAL_SECTION WavHdrCritSec;
#define EnterWavHdr()   EnterCriticalSection(&WavHdrCritSec);
#define LeaveWavHdr()   LeaveCriticalSection(&WavHdrCritSec);

/* flags for _lseek */
#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

#define FMEM                (GMEM_MOVEABLE)

STATICFN BOOL  NEAR PASCAL soundInitWavHdr(LPWAVEHDR lpwh, LPBYTE lpMem, DWORD dwLen);
STATICFN BOOL  NEAR PASCAL soundOpen(HANDLE  hSound, UINT wFlags);
STATICFN BOOL  NEAR PASCAL soundClose(void);
STATICFN void  NEAR PASCAL soundWait(void);

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api void | WaveOutNotify  | called by mmWndProc when it receives a
 *                              MM_WOM_DONE message
 * @rdesc None.
 *
 ****************************************************************************/

void FAR PASCAL WaveOutNotify(
    DWORD wParam,
    LONG lParam)
{

    EnterWavHdr();
    
#if DBG
    WinAssert(!hWaveOut || lpWavHdr);  // if hWaveOut, then MUST have lpWavHdr
#endif

    if (hWaveOut && !(lpWavHdr->dwFlags & WHDR_DONE)) {
        LeaveWavHdr();
        return;         // wave is not done! get out
    }

    LeaveWavHdr();
        
    //
    // wave file is done! release the device
    //

    dprintf2(("ASYNC sound done, closing wave device"));

    soundClose();
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL | soundPlay   | Pretty much speaks for itself!
 *
 * @parm HANDLE  | hSound | The sound resource to play.
 *
 * @parm wFlags | UINT | flags controlling sync/async etc.
 *
 *  @flag  SND_SYNC            | play synchronously (default)
 *  @flag  SND_ASYNC           | play asynchronously
 *
 * @rdesc Returns TRUE if successful and FALSE on failure.
 ****************************************************************************/
BOOL NEAR PASCAL soundPlay(
    HANDLE  hSound,
    UINT wFlags)
{
    //
    // Before playing a sound release it
    //
    soundClose();
    
    //
    // If the current session is disconnected
    // then don't bother playing
    //
    if (WTSCurrentSessionIsDisconnected()) return TRUE;

    //
    // open the sound device and write the sound to it.
    //
    if (!soundOpen(hSound, wFlags)) {
        dprintf1(("Returning false after calling SoundOpen"));
        return FALSE;
    }
    dprintf2(("SoundOpen OK"));

    if (!(wFlags & SND_ASYNC))
    {
        dprintf4(("Calling SoundWait"));
        soundWait();
        dprintf4(("Calling SoundClose"));
        soundClose();
    }
    return TRUE;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL | soundOpen  | Open the wave device and write a sound to it.
 *
 * @parm HANDLE  | hSound | The sound resource to play.
 *
 * @rdesc Returns TRUE if successful and FALSE on failure.
 ****************************************************************************/
STATICFN BOOL NEAR PASCAL soundOpen(
    HANDLE  hSound,
    UINT    wFlags)
{
    UINT        wErr;
    DWORD       flags = WAVE_ALLOWSYNC;
    BOOL        fResult = FALSE;

    if (!hSound) {
        return FALSE;
    }

    if (hWaveOut)
    {
        dprintf1(("WINMM: soundOpen() wave device is currently open."));
        return FALSE;
    }

    try {
        EnterWavHdr();
        lpWavHdr = (LPWAVEHDR)GlobalLock(hSound);

        if (!lpWavHdr)
        {
#if DBG
            if ((GlobalFlags(hSound) & GMEM_DISCARDED)) {
                dprintf1(("WINMM: sound was discarded before play could begin."));
            }
#endif
            goto exit;
        }

        //
        // open the wave device, open any wave device that supports the
        // format
        //
        if (hwndNotify) {
            flags |= CALLBACK_WINDOW;
        }

        wErr = waveOutOpen(&hWaveOut,           // returns handle to device
                (UINT)WAVE_MAPPER,              // device id (any device)
                (LPWAVEFORMATEX)lpWavHdr->dwUser, // wave format
                (DWORD_PTR)hwndNotify,          // callback function
                0L,                             // callback instance data
                flags);                         // flags

        if (wErr != 0)
        {
            dprintf1(("WINMM: soundOpen() unable to open wave device"));
            GlobalUnlock(hSound);
            hWaveOut = NULL;
            lpWavHdr = NULL;
            goto exit;
        }

        wErr = waveOutPrepareHeader(hWaveOut, lpWavHdr, sizeof(WAVEHDR));

        if (wErr != 0)
        {
            dprintf1(("WINMM: soundOpen() waveOutPrepare failed"));
            soundClose();
            goto exit;
        }

        //
        // Only allow sound looping if playing ASYNC sounds
        //
        if ((wFlags & SND_ASYNC) && (wFlags & SND_LOOP))
        {
            lpWavHdr->dwLoops  = 0xFFFFFFFF;     // infinite loop
            lpWavHdr->dwFlags |= WHDR_BEGINLOOP|WHDR_ENDLOOP;
        }
        else
        {
            lpWavHdr->dwLoops  = 0;
            lpWavHdr->dwFlags &=~(WHDR_BEGINLOOP|WHDR_ENDLOOP);
        }

        lpWavHdr->dwFlags &= ~WHDR_DONE;        // mark as not done!
        wErr = waveOutWrite(hWaveOut, lpWavHdr, sizeof(WAVEHDR));

        timeAbort = lpWavHdr->dwBufferLength * 1000 / ((LPWAVEFORMATEX)lpWavHdr->dwUser)->nAvgBytesPerSec;
        timeAbort = timeAbort * 2;	// 100% room for slew between audio and system clocks
        timeAbort = timeAbort + timeGetTime();

        if (wErr != 0)
        {
            dprintf1(("WINMM: soundOpen() waveOutWrite failed"));
            soundClose();
            goto exit;
        }
        fResult = TRUE;
        exit: ;

    } finally {
        LeaveWavHdr();
    }
    return fResult;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | soundClose | This function closes the sound device
 *
 * @rdesc Returns TRUE if successful and FALSE on failure.
 ****************************************************************************/
STATICFN BOOL NEAR PASCAL soundClose(
    void)
{
    UINT        wErr;

    //
    // Do we have the sound device open?
    //
try {
    EnterWavHdr();

    if (!lpWavHdr || !hWaveOut) {
        // return TRUE;
    } else {

        //
        // if the block is still playing, stop it!
        //
        if (!(lpWavHdr->dwFlags & WHDR_DONE)) {
            waveOutReset(hWaveOut);
        }

#if DBG
        if (!(lpWavHdr->dwFlags & WHDR_DONE))
        {
            dprintf1(("WINMM: soundClose() data is not DONE!???"));
            lpWavHdr->dwFlags |= WHDR_DONE;
        }

        if (!(lpWavHdr->dwFlags & WHDR_PREPARED))
        {
            dprintf1(("WINMM: soundClose() data not prepared???"));
        }
#endif

        //
        // unprepare the data anyway!
        //
        wErr = waveOutUnprepareHeader(hWaveOut, lpWavHdr, sizeof(WAVEHDR));

        if (wErr != 0)
        {
            dprintf1(("WINMM: soundClose() waveOutUnprepare failed!"));
        }

        //
        // finally, actually close the device, and unlock the data
        //
        waveOutClose(hWaveOut);
        GlobalUnlock(GlobalHandle(lpWavHdr));

        //
        // update globals, claiming the device is closed.
        //
        hWaveOut = NULL;
        lpWavHdr = NULL;
    }
} finally {
    LeaveWavHdr();
}
    return TRUE;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api void | soundWait | wait for the sound device to complete
 *
 * @rdesc none
 ****************************************************************************/
STATICFN void NEAR PASCAL soundWait(
    void)
{

    try {                         // This should ensure that even WOW
                                  // threads that die on us depart the
                                  // critical section
        EnterWavHdr();
        if (lpWavHdr) {
            LPWAVEHDR   lpExisting;       // current playing wave file
            lpExisting = lpWavHdr;
            while (lpExisting == lpWavHdr &&
		   !(lpWavHdr->dwFlags & WHDR_DONE) &&
		   (timeGetTime() < timeAbort)
		  )
	    {
                dprintf4(("Waiting for buffer to complete"));
                LeaveWavHdr();
                Sleep(75);
                EnterWavHdr();
                // LATER !! We should have an event (on another thread... sigh...)
                // which will be triggered when the buffer is played.  Waiting
                // on the WHDR_DONE bit is ported directly from Win 3.1 and is
                // certainly not the best way of doing this.  The disadvantage of
                // using the thread notification is signalling this thread to
                // continue.
            }
        }
    } finally {
        LeaveWavHdr();
    }
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api void | soundFree | This function frees a sound resource created
 *      with soundLoadFile or soundLoadMemory
 *
 * @rdesc Returns TRUE if successful and FALSE on failure.
 ****************************************************************************/
void NEAR PASCAL soundFree(
    HANDLE  hSound)
{
    // Allow a null handle to stop any pending sounds, without discarding
    // the current cached sound
    //
    // !!! we should only close the sound device iff this hSound is playing!
    //
    soundClose();

    if (hSound) {
        GlobalFree(hSound);
    }
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api HANDLE  | soundLoadFile | Loads a specified sound resource from a
 *  file into a global, discardable object.
 *
 * @parm LPCSTR | lpszFile | The file from which to load the sound resource.
 *
 * @rdesc Returns NULL on failure, GLOBAL HANDLE to a WAVEHDR iff success
 ****************************************************************************/
HANDLE  NEAR PASCAL soundLoadFile(
    LPCWSTR szFileName)
{
    HANDLE      fh;
    DWORD       dwSize;
    LPBYTE      lpData;
    HANDLE      h;
    UINT        wNameLen;

    // open the file
    fh = CreateFile( szFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

    if (fh == (HANDLE)(UINT_PTR)HFILE_ERROR) {
        dprintf3(("soundLoadFile: Failed to open %ls  Error is %d",szFileName, GetLastError()));
        return NULL;
    } else {
        dprintf3(("soundLoadFile: opened %ls",szFileName));
    }

    /* Get wNameLen rounded up to next WORD boundary.
     * We do not need to round up to a DWORD boundary as this value is
     * about to be multiplied by sizeof(WCHAR) which will do the additional
     * boundary alignment for us.  If we ever contemplate moving back to
     * non-UNICODE then this statement will have to be changed.  The
     * alignment is needed so that the actual wave data starts on a
     * DWORD boundary.
     */
    wNameLen = ((lstrlen(szFileName) + 1 + sizeof(WORD) - 1) /
            sizeof(WORD)) * sizeof(WORD);

#define BLOCKBYTES (sizeof(SOUNDFILE) + (wNameLen * sizeof(WCHAR)))
//   The amount of space we need to allocate - the WAVEHDR, file size, date
//   time plus the file name and a terminating null.

    dwSize = GetFileSize(fh, NULL);
    // note: could also use the C function FILELENGTH
    if (HFILE_ERROR == dwSize) {
        dprintf2(("Failed to find file size: %ls", szFileName));
        goto error1;
    }

    // allocate some discardable memory for a wave hdr, name and the file data.
    h = GlobalAlloc( FMEM + GMEM_DISCARDABLE,
                    BLOCKBYTES + dwSize );
    if (!h) {
        dprintf3(("soundLoadFile: Failed to allocate memory"));
        goto error1;
    }

    // lock it down
    if (NULL == (lpData = GlobalLock(h))) goto error2;

    // read the file into the memory block

    // NOTE:  We could, and probably should, use the file mapping functions.
    // Do this LATER
    if ( _lread( (HFILE)(DWORD_PTR)fh,
                 lpData + BLOCKBYTES,
                 (UINT)dwSize)
        != dwSize ) {
        goto error3;
    }

    // Save the last written time, and the file size
    ((PSOUNDFILE)lpData)->Size = dwSize;
    GetFileTime(fh, NULL, NULL, &(((PSOUNDFILE)lpData)->ft));

    // do the rest of it from the memory image
    //
    // MIPS WARNING !! Unaligned data - wNameLen is arbitrary
    //

    if (!soundInitWavHdr( (LPWAVEHDR)lpData,
                          lpData + BLOCKBYTES,
                          dwSize) )
    {
        dprintf3(("soundLoadFile: Failed to InitWaveHdr"));
        goto error3;
    }

    CloseHandle(fh);

    lstrcpyW( ((PSOUNDFILE)lpData)->Filename, szFileName);
    GlobalUnlock(h);
    return h;

error3:
    GlobalUnlock(h);
error2:
    GlobalFree(h);
error1:
    CloseHandle(fh);
    return NULL;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api HANDLE  | soundLoadMemory | Loads a user specified sound resource from a
 *  a memory block supplied by the caller.
 *
 * @parm LPCSTR | lpMem | Pointer to a memory image of the file
 *
 * @rdesc Returns NULL on failure, GLOBAL HANDLE to a WAVEHDR iff success
 ****************************************************************************/
HANDLE  NEAR PASCAL soundLoadMemory(
    LPBYTE  lpMem)
{
    HANDLE  h;
    LPBYTE  lp;

    // allocate some memory, for a wave hdr
    h = GlobalAlloc(FMEM, (LONG)(sizeof(SOUNDFILE) + sizeof(WCHAR)) );
    if (!h) {
        goto error1;
    }

    // lock it down
    if (NULL == (lp = GlobalLock(h))) goto error2;

    //
    // we must assume the memory pointer is correct! (hence the -1l)
    //
    if (!soundInitWavHdr( (LPWAVEHDR)lp, lpMem, (DWORD)-1l)) {
        goto error3;
    }

    //*(LPWSTR)(lp + sizeof(WAVEHDR)+sizeof(SOUNDFILE)) = '\0';   // No file name for memory file
    ((PSOUNDFILE)lp)->Filename[0] = '\0';   // No file name for memory file
    ((PSOUNDFILE)lp)->Size = 0;
    GlobalUnlock(h);
    return h;

error3:
    GlobalUnlock(h);
error2:
    GlobalFree(h);
error1:
    return NULL;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL | soundInitWavHdr | Initializes a WAVEHDR data structure from a
 *                         pointer to a memory image of a RIFF WAV file.
 *
 * @parm LPWAVEHDR | lpwh | Pointer to a WAVEHDR
 *
 * @parm LPCSTR | lpMem | Pointer to a memory image of a RIFF WAV file
 *
 * @rdesc Returns FALSE on failure, TRUE on success.
 *
 * @comm the dwUser field of the WAVEHDR structure is initialized to point
 * to the WAVEFORMAT structure that is inside the RIFF data
 *
 ****************************************************************************/
STATICFN BOOL NEAR PASCAL soundInitWavHdr(
    LPWAVEHDR lpwh,
    LPBYTE lpMem,
    DWORD dwLen)
{
    FPFileHeader    fpHead;
    LPWAVEFORMAT    lpFmt;
    LPBYTE          lpData;
    DWORD           dwFileSize,dwCurPos;
    DWORD           dwSize;
    DWORD           AlignError;
    DWORD           FmtSize;

    if (dwLen < sizeof(FileHeader)) {
        dprintf3(("Not a RIFF file, or not a WAVE file"));
        return FALSE;
    }

    // assume the first few bytes are the file header
    fpHead = (FPFileHeader) lpMem;

    // check that it's a valid RIFF file and a valid WAVE form.
    if (fpHead->dwRiff != RIFF_FILE || fpHead->dwWave != RIFF_WAVE ) {
        return FALSE;
    }

    dwFileSize = fpHead->dwSize;
    dwCurPos = sizeof(FileHeader);
    lpData = lpMem + sizeof(FileHeader);

    if (dwLen < dwFileSize) {     // RIFF header
        return FALSE;
    }

    // scan until we find the 'fmt' chunk
    while( 1 ) {
        if( ((FPChunkHeader)lpData)->dwCKID == RIFF_FORMAT ) {
            break; // from the while loop that's looking for it
        }
        dwCurPos += ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
        if( dwCurPos >= dwFileSize ) {
            return FALSE;
        }
        lpData += ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
    }

    // now we're at the beginning of the 'fmt' chunk data
    lpFmt = (LPWAVEFORMAT) (lpData + sizeof(ChunkHeader));

    // Save the size of the format data and check it.
    FmtSize = ((FPChunkHeader)lpData)->dwSize;
    if (FmtSize < sizeof(WAVEFORMAT)) {
        return FALSE;
    }


    // scan until we find the 'data' chunk
    lpData = lpData + ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
    while( 1 ) {
        if ( ((FPChunkHeader)lpData)->dwCKID == RIFF_CHANNEL) {
            break; // from the while loop that's looking for it
        }
        dwCurPos += ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
        if( dwCurPos >= dwFileSize ) {
            return 0;
        }
        lpData += ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
    }

    //
    // The format chunk must be aligned so move things if necessary
    // Warning - this is a hack to get round alignment problems
    //
    AlignError = ((DWORD)((LPBYTE)lpFmt - lpMem)) % sizeof(DWORD);

    if (AlignError != 0) {
        lpFmt = (LPWAVEFORMAT)((LPBYTE)lpFmt - AlignError);
        MoveMemory(lpFmt, (LPBYTE)lpFmt + AlignError, FmtSize);
    }

    // now we're at the beginning of the 'data' chunk data
    dwSize = ((FPChunkHeader)lpData)->dwSize;
    lpData = lpData + sizeof(ChunkHeader);

    // initialize the WAVEHDR

    lpwh->lpData    = (LPSTR)lpData;    // pointer to locked data buffer
    lpwh->dwBufferLength  = dwSize;     // length of data buffer
    lpwh->dwUser    = (DWORD_PTR)lpFmt;     // for client's use
    lpwh->dwFlags   = WHDR_DONE;        // assorted flags (see defines)
    lpwh->dwLoops   = 0;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\playwav.h ===
// Copyright (c) 1992 Microsoft Corporation
/*****************************************************************************

    playwav.h

 ****************************************************************************/

extern BOOL    NEAR PASCAL soundPlay(HANDLE hSound, UINT wFlags);
extern VOID    NEAR PASCAL soundFree(HANDLE hSound);
extern HANDLE  NEAR PASCAL soundLoadFile(LPCWSTR szFileName);
extern HANDLE  NEAR PASCAL soundLoadMemory(LPBYTE lpMem);

/*****************************************************************************

      STUFF TO SUPPORT MS-WAVE FORMAT FILES

 ****************************************************************************/

typedef struct _FileHeader {
        DWORD   dwRiff;
        DWORD   dwSize;
        DWORD   dwWave;
} FileHeader;
typedef FileHeader FAR *FPFileHeader;

typedef struct _ChunkHeader {
        DWORD   dwCKID;
        DWORD   dwSize;
} ChunkHeader;
typedef ChunkHeader UNALIGNED *FPChunkHeader;

/*  Chunk Types  */
//#define RIFF_FILE       FOURCC('R','I','F','F')
//#define RIFF_WAVE       FOURCC('W','A','V','E')
//#define RIFF_FORMAT     FOURCC('f','m','t',' ')
//#define RIFF_CHANNEL    FOURCC('d','a','t','a')

#define RIFF_FILE       FOURCC_RIFF    // in Winmm.H
#define RIFF_WAVE       FOURCC_WAVE        // in WinmmI.h
#define RIFF_FORMAT     FOURCC_FMT     // in WinmmI.h
#define RIFF_CHANNEL    FOURCC_DATA    // in WinmmI.h

/* When memory for a PlaySound file is allocated we insert a WAVEHDR, then
 * the size, date and time as well as the filename of the wave file.
 * Then if the user changes the file underneath us, but keeping the same
 * name, we have a chance to detect the difference and not to play the
 * cached sound file.  Note: the filetime stored is the lastwritten time.
 */
typedef struct _SoundFile {
	WAVEHDR     wh;
	ULONG		Size;
	FILETIME	ft;
	WCHAR		Filename[];   // allows field to be addressed
} SOUNDFILE;
typedef SOUNDFILE * PSOUNDFILE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\pref.c ===
/* Copyright (c) 1998-2001 Microsoft Corporation */
#define UNICODE
#define _UNICODE
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "winmmi.h"
#include <mmreg.h>
#include <regstr.h>
#include <stdlib.h>
#include <tchar.h>
#include "audiosrvc.h"

extern PCWSTR waveReferenceDevInterfaceById(IN PWAVEDRV pdrvZ, IN UINT_PTR id);
extern PCWSTR midiReferenceDevInterfaceById(IN PMIDIDRV pdrvZ, IN UINT_PTR id);

#define REGSTR_PATH_MULTIMEDIA_SOUNDMAPPER TEXT("Software\\Microsoft\\Multimedia\\Sound Mapper")
#define REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PLAYBACK TEXT("Playback")
#define REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_RECORD TEXT("Record")
#define REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_CONSOLEVOICECOM_PLAYBACK TEXT("ConsoleVoiceComPlayback")
#define REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_CONSOLEVOICECOM_RECORD   TEXT("ConsoleVoiceComRecord")
#define REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PREFERREDONLY TEXT("PreferredOnly")

#define REGSTR_PATH_MEDIARESOURCES_MIDI REGSTR_PATH_MEDIARESOURCES TEXT("\\MIDI")
#define REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_ACTIVE          TEXT("Active")
#define REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_DESCRIPTION     TEXT("Description")
#define REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_DEVICEINTERFACE TEXT("DeviceInterface")
#define REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_PHYSDEVID       TEXT("PhysDevID")
#define REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_PORT            TEXT("Port")

#define REGSTR_PATH_MULTIMEDIA_MIDIMAP REGSTR_PATH_MULTIMEDIA TEXT("\\MIDIMap")
#define REGSTR_VAL_MULTIMEDIA_MIDIMAP_CONFIGURECOUNT    TEXT("ConfigureCount")
#define REGSTR_VAL_MULTIMEDIA_MIDIMAP_USESCHEME         TEXT("UseScheme")
#define REGSTR_VAL_MULTIMEDIA_MIDIMAP_DRIVERLIST        TEXT("DriverList")
#define REGSTR_VAL_MULTIMEDIA_MIDIMAP_AUTOSCHEME        TEXT("AutoScheme")
#define REGSTR_VAL_MULTIMEDIA_MIDIMAP_CURRENTINSTRUMENT TEXT("CurrentInstrument")
#define REGSTR_VAL_MULTIMEDIA_MIDIMAP_DEVICEINTERFACE   TEXT("DeviceInterface")
#define REGSTR_VAL_MULTIMEDIA_MIDIMAP_RELATIVEINDEX     TEXT("RelativeIndex")
#define REGSTR_VAL_MULTIMEDIA_MIDIMAP_SZPNAME           TEXT("szPname")

#define REGSTR_VAL_SETUPPREFERREDAUDIODEVICES TEXT("SetupPreferredAudioDevices")
#define REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT TEXT("SetupPreferredAudioDevicesCount")

extern BOOL WaveMapperInitialized;	// in winmm.c
extern BOOL MidiMapperInitialized;	// in winmm.c

// Preferred Ids.  Setting these to *_MAPPER indicates no setting.
PWSTR gpstrWoDefaultStringId         = NULL;
PWSTR gpstrWiDefaultStringId         = NULL;
PWSTR gpstrWoConsoleVoiceComStringId = NULL;
PWSTR gpstrWiConsoleVoiceComStringId = NULL;
BOOL  gfUsePreferredWaveOnly         = TRUE;
PWSTR gpstrMoDefaultStringId         = NULL;

// These will be TRUE if we sent the preferred device change
// to sysaudio.
BOOL gfWaveOutPreferredMessageSent = FALSE;
BOOL gfWaveInPreferredMessageSent  = FALSE;
BOOL gfMidiOutPreferredMessageSent = FALSE;

//------------------------------------------------------------------------------
//
//
//	Registry helpers
//
//
//------------------------------------------------------------------------------

LONG RegQuerySzValue(HKEY hkey, PCTSTR pValueName, PTSTR *ppstrValue)
{
    LONG result;
    DWORD typeValue;
    DWORD cbstrValue = 0;
    BOOL f;
    
    result = RegQueryValueEx(hkey, pValueName, 0, &typeValue, NULL, &cbstrValue);
    if (ERROR_SUCCESS == result)
    {
	if (REG_SZ == typeValue)
	{
	    PTSTR pstrValue;
	    pstrValue = HeapAlloc(hHeap, 0, cbstrValue);
	    if (pstrValue)
	    {
		result = RegQueryValueEx(hkey, pValueName, 0, &typeValue, (PBYTE)pstrValue, &cbstrValue);
		if (ERROR_SUCCESS == result)
		{
                    if (REG_SZ == typeValue)
                    {
                        *ppstrValue = pstrValue;
                    } else {
                        result = ERROR_FILE_NOT_FOUND;
                        f = HeapFree(hHeap, 0, pstrValue);
                        WinAssert(f);
                    }
		} else {
		    f = HeapFree(hHeap, 0, pstrValue);
		    WinAssert(f);
		}
	    } else {
		result = ERROR_OUTOFMEMORY;
	    }
	} else {
	    result = ERROR_FILE_NOT_FOUND;
	}
    }
    return result;
}

LONG RegQueryDwordValue(HKEY hkey, PCTSTR pValueName, PDWORD pdwValue)
{
    DWORD cbdwValue;
    LONG result;

    cbdwValue = sizeof(*pdwValue);
    result = RegQueryValueEx(hkey, pValueName, 0, NULL, (PBYTE)pdwValue, &cbdwValue);
    return result;
}

LONG RegSetSzValue(HKEY hkey, PCTSTR pValueName, PCTSTR pstrValue)
{
    DWORD cbstrValue = (lstrlen(pstrValue) + 1) * sizeof(pstrValue[0]);
    return RegSetValueEx(hkey, pValueName, 0, REG_SZ, (PBYTE)pstrValue, cbstrValue);
}

LONG RegSetDwordValue(HKEY hkey, PCTSTR pValueName, DWORD dwValue)
{
    return RegSetValueEx(hkey, pValueName, 0, REG_DWORD, (PBYTE)&dwValue, sizeof(dwValue));
}


//------------------------------------------------------------------------------
//
//
//	AutoSetupPreferredAudio functions
//
//
//------------------------------------------------------------------------------

//--------------------------------------------------------------------------;
//
// DWORD GetCurrentSetupPreferredAudioCount
//
// Arguments:
//
// Return value:
//
// History:
//	1/19/99		FrankYe		Created
//
//--------------------------------------------------------------------------;
DWORD GetCurrentSetupPreferredAudioCount(void)
{
    HKEY hkeySetupPreferredAudioDevices;
    DWORD SetupCount = 0;
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_MEDIARESOURCES TEXT("\\") REGSTR_VAL_SETUPPREFERREDAUDIODEVICES, 0, KEY_QUERY_VALUE, &hkeySetupPreferredAudioDevices))
    {
	if (ERROR_SUCCESS != RegQueryDwordValue(hkeySetupPreferredAudioDevices, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &SetupCount)) {
	    Squirt("GCSPATS: Couldn't read hklm\\...\\SetupPreferredAudioDevicesCount");
	}
	if (ERROR_SUCCESS != RegCloseKey(hkeySetupPreferredAudioDevices)) {
	    WinAssert(!"GCSPATS: unexpected failure of RegCloseKey");
	}
    } else {
	Squirt("GCSPATS: Couldn't open hklm\\...\\SetupPreferredAudioDevices");
    }

    return SetupCount;
}

//--------------------------------------------------------------------------;
//
// DWORD GetDeviceInterfaceSetupPreferredAudioCount
//
// Arguments:
//
// Return value:
//
// History:
//	1/19/99		FrankYe		Created
//
//--------------------------------------------------------------------------;
DWORD GetDeviceInterfaceSetupPreferredAudioCount(PCWSTR DeviceInterface)
{
    PMMDEVICEINTERFACEINFO pdii;
    PMMPNPINFO pPnpInfo;
    LONG cbPnpInfo;
    DWORD count;
    int ii;

    // Handle empty DeviceInterface names in case of legacy drivers
    if (0 == lstrlen(DeviceInterface)) return 0;

    if (ERROR_SUCCESS != winmmGetPnpInfo(&cbPnpInfo, &pPnpInfo)) return 0;
    
    pdii = (PMMDEVICEINTERFACEINFO)&(pPnpInfo[1]);
    pdii = PAD_POINTER(pdii);

    for (ii = pPnpInfo->cDevInterfaces; ii; ii--)
    {
	//  Searching for the device interface...
        if (0 == lstrcmpi(pdii->szName, DeviceInterface)) break;

        pdii = (PMMDEVICEINTERFACEINFO)(pdii->szName + lstrlenW(pdii->szName) + 1);
	pdii = PAD_POINTER(pdii);
    }

    WinAssert(ii);
    
    count = pdii->SetupPreferredAudioCount;
    
    HeapFree(hHeap, 0, pPnpInfo);

    return count;
}

//------------------------------------------------------------------------------
//
//
//	NotifyServerPreferredDeviceChange
//
//
//------------------------------------------------------------------------------
void NotifyServerPreferredDeviceChange(void)
{
    winmmAdvisePreferredDeviceChange();
}

//------------------------------------------------------------------------------
//
//
//	Wave
//
//
//------------------------------------------------------------------------------

MMRESULT waveWritePersistentConsoleVoiceCom(BOOL fOut, PTSTR pstrPref, BOOL fPrefOnly)
{
    HKEY hkcu;
    HKEY hkSoundMapper;
    LONG result;
    BOOL fSuccess;

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_WRITE, &hkcu))) return MMSYSERR_WRITEERROR;

    result = RegCreateKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_SOUNDMAPPER, 0, TEXT("\0"), REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hkSoundMapper, NULL);
    if (ERROR_SUCCESS == result)
    {
	DWORD cbstrPref;

	cbstrPref = (lstrlen(pstrPref) + 1) * sizeof(pstrPref[0]);

    if (fOut)
    {
    	result = RegSetSzValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_CONSOLEVOICECOM_PLAYBACK, pstrPref);
    }
    else
    {
    	result = RegSetSzValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_CONSOLEVOICECOM_RECORD, pstrPref);
    }

	if (ERROR_SUCCESS == result)
	{
	    fSuccess = TRUE;
	    result = RegSetDwordValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PREFERREDONLY, (DWORD)fPrefOnly);
	    if (ERROR_SUCCESS != result) {
		Squirt("wWPCVC: Could not write hkcu\\...\\Sound Mapper\\PreferredOnly");
	    }
	    result = RegSetDwordValue(hkSoundMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, GetCurrentSetupPreferredAudioCount());
	    if (ERROR_SUCCESS != result) {
		Squirt("wWPCVC: Could not write hkcu\\...\\Sound Mapper\\SetupPreferredAudioCount");
	    }
	}
	result = RegCloseKey(hkSoundMapper);
	WinAssert(ERROR_SUCCESS == result);
    }

    NtClose(hkcu);

    return MMSYSERR_NOERROR;
}

BOOL waveReadPersistentConsoleVoiceCom(BOOL fOut, PTSTR *ppstrPref, PBOOL pfPrefOnly, PDWORD pSetupCount)
{
    HKEY hkcu;
    HKEY hkSoundMapper;
    LONG result;
    BOOL fSuccess;

    fSuccess = FALSE;

    *ppstrPref = NULL;
    *pfPrefOnly = FALSE;
    *pSetupCount = 0;

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_READ, &hkcu))) return FALSE;

    result = RegOpenKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_SOUNDMAPPER, 0, KEY_QUERY_VALUE, &hkSoundMapper);
    if (ERROR_SUCCESS == result)
    {
	DWORD SetupCount;

	result = RegQueryDwordValue(hkSoundMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &SetupCount);
	SetupCount = (ERROR_SUCCESS == result) ? SetupCount : 0;
	if (ERROR_SUCCESS == result)
	{
	    PTSTR pstrPref;
	    BOOL fPrefOnly;
	    DWORD dwPrefOnly;

	    result = RegQueryDwordValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PREFERREDONLY, &dwPrefOnly);
	    fPrefOnly = (ERROR_SUCCESS == result) ? (0 != dwPrefOnly) : FALSE;

            if (fOut)
            {
                result = RegQuerySzValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_CONSOLEVOICECOM_PLAYBACK, &pstrPref);
            }
            else
            {
                result = RegQuerySzValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_CONSOLEVOICECOM_RECORD, &pstrPref);
            }
    
	    if (ERROR_SUCCESS != result) pstrPref = NULL;

	    *ppstrPref = pstrPref;
	    *pfPrefOnly = fPrefOnly;
	    *pSetupCount = SetupCount;
	    fSuccess = TRUE;
	}
	result = RegCloseKey(hkSoundMapper);
	WinAssert(ERROR_SUCCESS == result);
    }

    NtClose(hkcu);

    return fSuccess;
}

MMRESULT wavePickBestConsoleVoiceComId(BOOL fOut, PUINT pPrefId, PDWORD pdwFlags)
{
    PTSTR pstrPref;
    UINT cWaveId;
    UINT WaveId;
    UINT UserSelectedId;
    UINT NonConsoleId;
    UINT PreferredId;
    DWORD UserSelectedIdSetupCount;
    BOOL fPrefOnly;
    BOOL f;

    UserSelectedId = WAVE_MAPPER;

    if (fOut)
    {
    	waveOutGetCurrentPreferredId(&NonConsoleId, NULL);
    	
        cWaveId = waveOutGetNumDevs();

        waveReadPersistentConsoleVoiceCom(fOut, &pstrPref, &fPrefOnly, &UserSelectedIdSetupCount);

        *pdwFlags = fPrefOnly ? DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY : 0;

        for (WaveId = cWaveId-1; ((int)WaveId) >= 0; WaveId--)
        {
	    WAVEOUTCAPS wc;
	    MMRESULT mmr;

	    mmr = waveOutGetDevCaps(WaveId, &wc, sizeof(wc));
	    if (mmr) continue;

	    wc.szPname[MAXPNAMELEN-1] = TEXT('\0');

	    if (pstrPref && !lstrcmp(wc.szPname, pstrPref))
            {
                UserSelectedId = WaveId;
                break;
            }
        }
    }
    else
    {
    	waveInGetCurrentPreferredId(&NonConsoleId, NULL);
    	
        cWaveId = waveInGetNumDevs();

        waveReadPersistentConsoleVoiceCom(fOut, &pstrPref, &fPrefOnly, &UserSelectedIdSetupCount);

        *pdwFlags = fPrefOnly ? DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY : 0;

        for (WaveId = cWaveId-1; ((int)WaveId) >= 0; WaveId--)
        {
            WAVEINCAPS wc;
            MMRESULT mmr;

            mmr = waveInGetDevCaps(WaveId, &wc, sizeof(wc));
            if (mmr) continue;

            wc.szPname[MAXPNAMELEN-1] = TEXT('\0');

            if (pstrPref && !lstrcmp(wc.szPname, pstrPref))
            {
                UserSelectedId = WaveId;
                break;
            }
        }
    }

    if (pstrPref) {
	f = HeapFree(hHeap, 0, pstrPref);
	WinAssert(f);
	pstrPref = NULL;
    }

    PreferredId = ((WAVE_MAPPER == UserSelectedId)?NonConsoleId:UserSelectedId);

    *pPrefId = PreferredId;
    return MMSYSERR_NOERROR;
}

//------------------------------------------------------------------------------
//
//
//	WaveOut
//
//
//------------------------------------------------------------------------------

DWORD waveOutGetSetupPreferredAudioCount(UINT WaveId)
{
    PCWSTR DeviceInterface;
    DWORD dwCount;

    DeviceInterface = waveReferenceDevInterfaceById(&waveoutdrvZ, WaveId);

    if(DeviceInterface == NULL) {
        return 0;
    }

    dwCount = GetDeviceInterfaceSetupPreferredAudioCount(DeviceInterface);
    wdmDevInterfaceDec(DeviceInterface);
    return dwCount;
}

MMRESULT waveOutSendPreferredMessage(BOOL fClear)
{
    PCWSTR DeviceInterface;
    UINT WaveId, Flags;
    MMRESULT mmr;

    if(!gfLogon) {
        return MMSYSERR_NOERROR;
    }

    waveOutGetCurrentPreferredId(&WaveId, &Flags);

    //Squirt("waveOutSendPreferredMessage: id %d f %d", WaveId, fClear);

    if(WaveId == WAVE_MAPPER) {
        return MMSYSERR_NOERROR;
    }

    DeviceInterface = waveReferenceDevInterfaceById(&waveoutdrvZ, WaveId);

    if(DeviceInterface == NULL) {
        return MMSYSERR_NOERROR;
    }

    gfWaveOutPreferredMessageSent = TRUE;

    mmr = waveOutMessage((HWAVEOUT)(UINT_PTR)WaveId, WODM_PREFERRED, (DWORD_PTR)fClear, (DWORD_PTR)DeviceInterface);
    wdmDevInterfaceDec(DeviceInterface);
    return mmr;
}

BOOL waveOutReadPersistentPref(PTSTR *ppstrPref, PBOOL pfPrefOnly, PDWORD pSetupCount)
{
    HKEY hkcu;
    HKEY hkSoundMapper;
    LONG result;
    BOOL fSuccess;

    fSuccess = FALSE;

    *ppstrPref = NULL;
    *pfPrefOnly = FALSE;
    *pSetupCount = 0;

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_READ, &hkcu))) return FALSE;

    result = RegOpenKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_SOUNDMAPPER, 0, KEY_QUERY_VALUE, &hkSoundMapper);
    if (ERROR_SUCCESS == result)
    {
	DWORD SetupCount;

	result = RegQueryDwordValue(hkSoundMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &SetupCount);
	SetupCount = (ERROR_SUCCESS == result) ? SetupCount : 0;
	if (ERROR_SUCCESS == result)
	{
	    PTSTR pstrPref;
	    BOOL fPrefOnly;
	    DWORD dwPrefOnly;

	    result = RegQueryDwordValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PREFERREDONLY, &dwPrefOnly);
	    fPrefOnly = (ERROR_SUCCESS == result) ? (0 != dwPrefOnly) : FALSE;

	    result = RegQuerySzValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PLAYBACK, &pstrPref);
	    if (ERROR_SUCCESS != result) pstrPref = NULL;

	    *ppstrPref = pstrPref;
	    *pfPrefOnly = fPrefOnly;
	    *pSetupCount = SetupCount;
	    fSuccess = TRUE;
	}
	result = RegCloseKey(hkSoundMapper);
	WinAssert(ERROR_SUCCESS == result);
    }

    NtClose(hkcu);

    return fSuccess;
}

MMRESULT waveOutPickBestId(PUINT pPrefId, PDWORD pdwFlags)
{
    PTSTR pstrPref;
    UINT cWaveId;
    UINT WaveId;
    UINT MappableId;
    UINT MixableId;
    UINT UserSelectedId;
    UINT PreferredId;
    DWORD WaveIdSetupCount;
    DWORD MappableIdSetupCount;
    DWORD MixableIdSetupCount;
    DWORD UserSelectedIdSetupCount;
    DWORD PreferredIdSetupCount;
    BOOL fPrefOnly;
    BOOL f;


    MappableId = WAVE_MAPPER;
    MixableId = WAVE_MAPPER;
    UserSelectedId = WAVE_MAPPER;
    PreferredId = WAVE_MAPPER;

    MappableIdSetupCount = 0;
    MixableIdSetupCount = 0;
    UserSelectedIdSetupCount = 0;
    PreferredIdSetupCount = 0;

    cWaveId = waveOutGetNumDevs();

    waveOutReadPersistentPref(&pstrPref, &fPrefOnly, &UserSelectedIdSetupCount);

    *pdwFlags = fPrefOnly ? DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY : 0;

    for (WaveId = cWaveId-1; ((int)WaveId) >= 0; WaveId--)
    {
    	WAVEOUTCAPS wc;
    	UINT uMixerId;
    	MMRESULT mmr;
        PWAVEDRV pdrv;
        BOOL fThisSession;

        //
        // check the protocol name
        //  mask all inappropriate TS/non-TS drivers
        //
        if (waveReferenceDriverById(&waveoutdrvZ, WaveId, &pdrv, NULL)) continue;
        fThisSession = !lstrcmpW(pdrv->wszSessProtocol, SessionProtocolName);
        mregDecUsagePtr(pdrv);
        if (!fThisSession) continue;

    	mmr = waveOutGetDevCaps(WaveId, &wc, sizeof(wc));
    	if (mmr) continue;

    	wc.szPname[MAXPNAMELEN-1] = TEXT('\0');

    	if (pstrPref && !lstrcmp(wc.szPname, pstrPref)) UserSelectedId = WaveId;

    	WaveIdSetupCount = waveOutGetSetupPreferredAudioCount(WaveId);

    	mmr = waveOutMessage((HWAVEOUT)(UINT_PTR)WaveId, DRV_QUERYMAPPABLE, 0L, 0L);
    	if (mmr) continue;

    	if (WaveIdSetupCount >= MappableIdSetupCount) {
    	    MappableId = WaveId;
    	    MappableIdSetupCount = WaveIdSetupCount;
    	}

    	mmr = mixerGetID((HMIXEROBJ)(UINT_PTR)WaveId, &uMixerId, MIXER_OBJECTF_WAVEOUT);
    	if (mmr) continue;

    	if (WaveIdSetupCount >= MixableIdSetupCount) {
    	    MixableId = WaveId;
    	    MixableIdSetupCount = WaveIdSetupCount;
    	}
    }

    if (pstrPref) {
    	f = HeapFree(hHeap, 0, pstrPref);
    	WinAssert(f);
    	pstrPref = NULL;
    }

    PreferredId = MappableId;
    PreferredIdSetupCount = MappableIdSetupCount;
    if ((MixableIdSetupCount >= PreferredIdSetupCount) && (WAVE_MAPPER != MixableId))
    {
    	PreferredId = MixableId;
    	PreferredIdSetupCount = MixableIdSetupCount;
    }
    if ((UserSelectedIdSetupCount >= PreferredIdSetupCount) && (WAVE_MAPPER != UserSelectedId))
    {
    	PreferredId = UserSelectedId;
    	PreferredIdSetupCount = UserSelectedIdSetupCount;
    }

    *pPrefId = PreferredId;
    return MMSYSERR_NOERROR;
}

void waveOutGetCurrentPreferredId(PUINT pPrefId, PDWORD pdwFlags)
{
    *pPrefId = WAVE_MAPPER;
    if (pdwFlags) *pdwFlags = gfUsePreferredWaveOnly ? DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY : 0;
    if (gpstrWoDefaultStringId) mregGetIdFromStringId(&waveoutdrvZ, gpstrWoDefaultStringId, pPrefId);
    return;
}

BOOL waveOutWritePersistentPref(PTSTR pstrPref, BOOL fPrefOnly)
{
    HKEY hkcu;
    HKEY hkSoundMapper;
    LONG result;
    BOOL fSuccess;

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_WRITE, &hkcu))) return MMSYSERR_WRITEERROR;

    result = RegCreateKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_SOUNDMAPPER, 0, TEXT("\0"), REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hkSoundMapper, NULL);
    if (ERROR_SUCCESS == result)
    {
	DWORD cbstrPref;

	cbstrPref = (lstrlen(pstrPref) + 1) * sizeof(pstrPref[0]);
	result = RegSetSzValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PLAYBACK, pstrPref);
	if (ERROR_SUCCESS == result)
	{
	    fSuccess = TRUE;
	    result = RegSetDwordValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PREFERREDONLY, (DWORD)fPrefOnly);
	    if (ERROR_SUCCESS != result) {
		Squirt("wOWPP: Could not write hkcu\\...\\Sound Mapper\\PreferredOnly");
	    }
	    result = RegSetDwordValue(hkSoundMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, GetCurrentSetupPreferredAudioCount());
	    if (ERROR_SUCCESS != result) {
		Squirt("wOWPP: Could not write hkcu\\...\\Sound Mapper\\SetupPreferredAudioCount");
	    }
	}
	result = RegCloseKey(hkSoundMapper);
	WinAssert(ERROR_SUCCESS == result);
    }

    NtClose(hkcu);

    return MMSYSERR_NOERROR;
}

MMRESULT waveOutSetCurrentPreferredId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;
    WinAssert(PrefId < wTotalWaveOutDevs || PrefId == WAVE_MAPPER);

    mmr = MMSYSERR_NOERROR;

    if (gpstrWoDefaultStringId) HeapFree(hHeap, 0, gpstrWoDefaultStringId);
    gpstrWoDefaultStringId = NULL;
    
    if (wTotalWaveOutDevs)
    {
    	UINT mixerId;
        PWAVEDRV pwavedrv;
        UINT port;
            
        mmr = waveReferenceDriverById(&waveoutdrvZ, PrefId, &pwavedrv, &port);
    	if (!mmr)
    	{
    	    mmr = mregCreateStringIdFromDriverPort(pwavedrv, port, &gpstrWoDefaultStringId, NULL);
    	    if (!mmr)
    	    {
    	    	if (!gfDisablePreferredDeviceReordering)
    	    	{
                    // Rearrange some of the driver list so that the preferred waveOut
       	            // device and its associated mixer device have a good chance of
        	    // having device ID 0
        	    mmr = mixerGetID((HMIXEROBJ)(UINT_PTR)PrefId, &mixerId, MIXER_OBJECTF_WAVEOUT);
        	    if (mmr) mixerId = 0;
        	 
        	    if (0 != PrefId)
        	    {
                        // Move the wave driver to the head of this list.  This usually
                        // makes the preferred device have ID 0.
        	            EnterNumDevs("waveOutSetCurrentPreferredId");
                        pwavedrv->Prev->Next = pwavedrv->Next;
                        pwavedrv->Next->Prev = pwavedrv->Prev;
                        pwavedrv->Next = waveoutdrvZ.Next;
                        pwavedrv->Prev = &waveoutdrvZ;
                        waveoutdrvZ.Next->Prev = pwavedrv;
                        waveoutdrvZ.Next = pwavedrv;
                        LeaveNumDevs("waveOutSetCurrentPreferredId");
    
                        mregDecUsagePtr(pwavedrv);
        	    }
        	        
                    if (0 != mixerId)
                    {
                        PMIXERDRV pmixerdrv;
                
                        mmr = mixerReferenceDriverById(mixerId, &pmixerdrv, NULL);
                        if (!mmr)
                        {
			    EnterNumDevs("waveOutSetCurrentPreferredId");
			    pmixerdrv->Prev->Next = pmixerdrv->Next;
                	    pmixerdrv->Next->Prev = pmixerdrv->Prev;
                	    pmixerdrv->Next = mixerdrvZ.Next;
                	    pmixerdrv->Prev = &mixerdrvZ;
                	    mixerdrvZ.Next->Prev = pmixerdrv;
                	    mixerdrvZ.Next = pmixerdrv;
                            LeaveNumDevs("waveOutSetCurrentPreferredId");
    
                	    mregDecUsagePtr(pmixerdrv);
                        }
                    }
    	    	}

                // Errors in this body are not critical
                mmr = MMSYSERR_NOERROR;
    	    }
    	}    	    
    }

    if (!mmr)
    {
        gfUsePreferredWaveOnly = (0 != (dwFlags & DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY));

        // Reconfigure the mapper only if it was already loaded.  Don't cause it to
        // load simply so that we can reconfigure it!
        if (WaveMapperInitialized) waveOutMessage((HWAVEOUT)(UINT_PTR)WAVE_MAPPER, DRVM_MAPPER_RECONFIGURE, 0, 0);
    }

    return mmr;
}

MMRESULT waveOutSetPersistentPreferredId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;
    WAVEOUTCAPS woc;

    if (0 != (dwFlags & ~DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY)) return MMSYSERR_INVALPARAM;
    
    mmr = waveOutGetDevCaps(PrefId, &woc, sizeof(woc));
    if (!mmr)
    {
	woc.szPname[MAXPNAMELEN-1] = TEXT('\0');
	mmr = waveOutWritePersistentPref(woc.szPname, 0 != (dwFlags & 0x00000001));
	if (!mmr) {
	    NotifyServerPreferredDeviceChange();
	} else {
	    Squirt("waveOutSetPersistentPreferredId: waveOutWritePersistenPref failed, mmr=%08Xh", mmr);
	}	    
    }

    return mmr;
}

void waveOutGetCurrentConsoleVoiceComId(PUINT pPrefId, PDWORD pdwFlags)
{
    *pPrefId = WAVE_MAPPER;
    *pdwFlags = gfUsePreferredWaveOnly ? DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY : 0;
    if (gpstrWoConsoleVoiceComStringId) mregGetIdFromStringId(&waveoutdrvZ, gpstrWoConsoleVoiceComStringId, pPrefId);
    return;
}

MMRESULT waveOutSetPersistentConsoleVoiceComId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;
    WAVEOUTCAPS woc;

    if (0 != (dwFlags & ~DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY)) return MMSYSERR_INVALPARAM;
    
    mmr = waveOutGetDevCaps(PrefId, &woc, sizeof(woc));
    if (!mmr)
    {
	woc.szPname[MAXPNAMELEN-1] = TEXT('\0');
	mmr = waveWritePersistentConsoleVoiceCom(TRUE, woc.szPname, 0 != (dwFlags & 0x00000001));
	if (!mmr) {
	    NotifyServerPreferredDeviceChange();
	} else {
	    Squirt("waveOutSetPersistentConsoleVoiceComId: waveWritePersistentConsoleVoiceCom failed, mmr=%08Xh", mmr);
	}	    
    }

    return mmr;
}

MMRESULT waveOutSetCurrentConsoleVoiceComId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;

    WinAssert(PrefId < wTotalWaveOutDevs || PrefId == WAVE_MAPPER);

    mmr = MMSYSERR_NOERROR;

    if (gpstrWoConsoleVoiceComStringId) HeapFree(hHeap, 0, gpstrWoConsoleVoiceComStringId);
    gpstrWoConsoleVoiceComStringId = NULL;
    
    if (wTotalWaveOutDevs)
    {
        PWAVEDRV pwavedrv;
        UINT port;
            
        mmr = waveReferenceDriverById(&waveoutdrvZ, PrefId, &pwavedrv, &port);
    	if (!mmr)
    	{
    	    mregCreateStringIdFromDriverPort(pwavedrv, port, &gpstrWoConsoleVoiceComStringId, NULL);
            gfUsePreferredWaveOnly = (0 != (dwFlags & DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY));
    	}    	    
    }

    return mmr;
}

//------------------------------------------------------------------------------
//
//
//	WaveIn
//
//
//------------------------------------------------------------------------------

DWORD waveInGetSetupPreferredAudioCount(UINT WaveId)
{
    PCWSTR DeviceInterface;
    DWORD dwCount;

    DeviceInterface = waveReferenceDevInterfaceById(&waveindrvZ, WaveId);

    if(DeviceInterface == NULL) {
        return 0;
    }

    dwCount = GetDeviceInterfaceSetupPreferredAudioCount(DeviceInterface);
    wdmDevInterfaceDec(DeviceInterface);
    return dwCount;
}

MMRESULT waveInSendPreferredMessage(BOOL fClear)
{
    PCWSTR DeviceInterface;
    UINT WaveId, Flags;
    MMRESULT mmr;

    if(!gfLogon) {
        return MMSYSERR_NOERROR;
    }

    waveInGetCurrentPreferredId(&WaveId, &Flags);

    //Squirt("waveInSendPreferredMessage: id %d f %d", WaveId, fClear);

    if(WaveId == WAVE_MAPPER) {
        return MMSYSERR_NOERROR;
    }

    DeviceInterface = waveReferenceDevInterfaceById(&waveindrvZ, WaveId);

    if(DeviceInterface == NULL) {
        return MMSYSERR_NOERROR;
    }

    gfWaveInPreferredMessageSent = TRUE;

    mmr = waveInMessage((HWAVEIN)(UINT_PTR)WaveId, WIDM_PREFERRED, (DWORD_PTR)fClear, (DWORD_PTR)DeviceInterface);
    wdmDevInterfaceDec(DeviceInterface);
    return mmr;
}

BOOL waveInReadPersistentPref(PTSTR *ppstrPref, PBOOL pfPrefOnly, PDWORD pSetupCount)
{
    HKEY hkcu;
    HKEY hkSoundMapper;
    LONG result;
    BOOL fSuccess;

    fSuccess = FALSE;
    
    *ppstrPref = NULL;
    *pfPrefOnly = FALSE;
    *pSetupCount = 0;

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_READ, &hkcu))) return FALSE;

    result = RegOpenKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_SOUNDMAPPER, 0, KEY_QUERY_VALUE, &hkSoundMapper);
    if (ERROR_SUCCESS == result)
    {
	DWORD SetupCount;

	result = RegQueryDwordValue(hkSoundMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &SetupCount);
	SetupCount = (ERROR_SUCCESS == result) ? SetupCount : 0;
	if (ERROR_SUCCESS == result)
	{
	    PTSTR pstrPref;
	    BOOL fPrefOnly;
	    DWORD dwPrefOnly;

	    result = RegQueryDwordValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PREFERREDONLY, &dwPrefOnly);
	    fPrefOnly = (ERROR_SUCCESS == result) ? (0 != dwPrefOnly) : FALSE;

	    result = RegQuerySzValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_RECORD, &pstrPref);
	    if (ERROR_SUCCESS != result) pstrPref = NULL;

	    *ppstrPref = pstrPref;
	    *pfPrefOnly = fPrefOnly;
	    *pSetupCount = SetupCount;
	    fSuccess = TRUE;
	}
	result = RegCloseKey(hkSoundMapper);
	WinAssert(ERROR_SUCCESS == result);
    }

    NtClose(hkcu);

    return fSuccess;
}

MMRESULT waveInPickBestId(PUINT pPrefId, PDWORD pdwFlags)
{
    PTSTR pstrPref;
    UINT cWaveId;
    UINT WaveId;
    UINT MappableId;
    UINT MixableId;
    UINT UserSelectedId;
    UINT PreferredId;
    DWORD WaveIdSetupCount;
    DWORD MappableIdSetupCount;
    DWORD MixableIdSetupCount;
    DWORD UserSelectedIdSetupCount;
    DWORD PreferredIdSetupCount;
    BOOL fPrefOnly;
    BOOL f;

    
    MappableId = WAVE_MAPPER;
    MixableId = WAVE_MAPPER;
    UserSelectedId = WAVE_MAPPER;
    PreferredId = WAVE_MAPPER;
    
    MappableIdSetupCount = 0;
    MixableIdSetupCount = 0;
    UserSelectedIdSetupCount = 0;
    PreferredIdSetupCount = 0;
    
    cWaveId = waveInGetNumDevs();

    waveInReadPersistentPref(&pstrPref, &fPrefOnly, &UserSelectedIdSetupCount);

    *pdwFlags = fPrefOnly ? DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY : 0;

    for (WaveId = cWaveId-1; ((int)WaveId) >= 0; WaveId--)
    {
	WAVEINCAPS wic;
	UINT uMixerId;
	MMRESULT mmr;

	mmr = waveInGetDevCaps(WaveId, &wic, sizeof(wic));
	if (MMSYSERR_NOERROR != mmr) continue;

	wic.szPname[MAXPNAMELEN-1] = TEXT('\0');

	if (pstrPref && !lstrcmp(wic.szPname, pstrPref)) UserSelectedId = WaveId;

	WaveIdSetupCount = waveInGetSetupPreferredAudioCount(WaveId);

	mmr = waveInMessage((HWAVEIN)(UINT_PTR)WaveId, DRV_QUERYMAPPABLE, 0L, 0L);
	if (MMSYSERR_NOERROR != mmr) continue;

	if (WaveIdSetupCount >= MappableIdSetupCount) {
	    MappableId = WaveId;
	    MappableIdSetupCount = WaveIdSetupCount;
	}

	mmr = mixerGetID((HMIXEROBJ)(UINT_PTR)WaveId, &uMixerId, MIXER_OBJECTF_WAVEIN);
	if (MMSYSERR_NOERROR != mmr) continue;

	if (WaveIdSetupCount >= MixableIdSetupCount) {
	    MixableId = WaveId;
	    MixableIdSetupCount = WaveIdSetupCount;
	}
    }

    if (pstrPref) {
	f = HeapFree(hHeap, 0, pstrPref);
	WinAssert(f);
	pstrPref = NULL;
    }

    PreferredId = MappableId;
    PreferredIdSetupCount = MappableIdSetupCount;
    if ((MixableIdSetupCount >= PreferredIdSetupCount) && (WAVE_MAPPER != MixableId)) {
	PreferredId = MixableId;
	PreferredIdSetupCount = MixableIdSetupCount;
    }
    if ((UserSelectedIdSetupCount >= PreferredIdSetupCount) && (WAVE_MAPPER != UserSelectedId))
    {
	PreferredId = UserSelectedId;
	PreferredIdSetupCount = UserSelectedIdSetupCount;
    }

    *pPrefId = PreferredId;
    
    return MMSYSERR_NOERROR;
}

void waveInGetCurrentPreferredId(PUINT pPrefId, PDWORD pdwFlags)
{
    *pPrefId = WAVE_MAPPER;
    if (pdwFlags) *pdwFlags = gfUsePreferredWaveOnly ? DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY : 0;
    if (gpstrWiDefaultStringId) mregGetIdFromStringId(&waveindrvZ, gpstrWiDefaultStringId, pPrefId);
    return;
}

BOOL waveInWritePersistentPref(PTSTR pstrPref, BOOL fPrefOnly)
{
    HKEY hkcu;
    HKEY hkSoundMapper;
    LONG result;
    BOOL fSuccess;

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_WRITE, &hkcu))) return MMSYSERR_WRITEERROR;

    result = RegCreateKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_SOUNDMAPPER, 0, TEXT("\0"), REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hkSoundMapper, NULL);
    if (ERROR_SUCCESS == result)
    {
	DWORD cbstrPref;

	cbstrPref = (lstrlen(pstrPref) + 1) * sizeof(pstrPref[0]);
	result = RegSetSzValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_RECORD, pstrPref);
	if (ERROR_SUCCESS == result)
	{
	    fSuccess = TRUE;
	    result = RegSetDwordValue(hkSoundMapper, REGSTR_VAL_MULTIMEDIA_SOUNDMAPPER_PREFERREDONLY, (DWORD)fPrefOnly);
	    if (ERROR_SUCCESS != result) {
		Squirt("wiWPP: Could not write hkcu\\...\\Sound Mapper\\PreferredOnly");
	    }
	    result = RegSetDwordValue(hkSoundMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, GetCurrentSetupPreferredAudioCount());
	    if (ERROR_SUCCESS != result) {
		Squirt("wiWPP: Could not write hkcu\\...\\Sound Mapper\\SetupPreferredAudioCount");
	    }
	}
	result = RegCloseKey(hkSoundMapper);
	WinAssert(ERROR_SUCCESS == result);
    }

    NtClose(hkcu);

    return MMSYSERR_NOERROR;
}

MMRESULT waveInSetCurrentPreferredId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;
    WinAssert(PrefId < wTotalWaveInDevs || PrefId == WAVE_MAPPER);

    mmr = MMSYSERR_NOERROR;

    if (gpstrWiDefaultStringId) HeapFree(hHeap, 0, gpstrWiDefaultStringId);
    gpstrWiDefaultStringId = NULL;
    
    if (wTotalWaveInDevs)
    {
        PWAVEDRV pwavedrv;
        UINT port;
            
        mmr = waveReferenceDriverById(&waveindrvZ, PrefId, &pwavedrv, &port);
    	if (!mmr)
    	{
    	    mmr = mregCreateStringIdFromDriverPort(pwavedrv, port, &gpstrWiDefaultStringId, NULL);
    	    if (!mmr)
    	    {
    	    	if (!gfDisablePreferredDeviceReordering)
    	    	{
                    // Rearrange some of the driver list so that the preferred waveIn
        	    // device has a good chance of having device ID 0
        	    if (0 != PrefId)
        	    {
                        // Move the wave driver to the head of this list.  This usually
                        // makes the preferred device have ID 0.
        	            EnterNumDevs("waveInSetCurrentPreferredId");
                        pwavedrv->Prev->Next = pwavedrv->Next;
                        pwavedrv->Next->Prev = pwavedrv->Prev;
                        pwavedrv->Next = waveindrvZ.Next;
                        pwavedrv->Prev = &waveindrvZ;
                        waveindrvZ.Next->Prev = pwavedrv;
                        waveindrvZ.Next = pwavedrv;
                        LeaveNumDevs("waveInSetCurrentPreferredId");
    
                        mregDecUsagePtr(pwavedrv);
        	    }
    	    	}
    	    }
    	}    	    
    }

    if (!mmr)
    {
        gfUsePreferredWaveOnly = (0 != (dwFlags & DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY));

        // Reconfigure the mapper only if it was already loaded.  Don't cause it to
        // load simply so that we can reconfigure it!
        if (WaveMapperInitialized) waveInMessage((HWAVEIN)(UINT_PTR)WAVE_MAPPER, DRVM_MAPPER_RECONFIGURE, 0, 0);
    }

    return mmr;
}

MMRESULT waveInSetPersistentPreferredId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;
    WAVEINCAPS wc;

    if (0 != (dwFlags & ~DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY)) return MMSYSERR_INVALPARAM;

    mmr = waveInGetDevCaps(PrefId, &wc, sizeof(wc));
    if (!mmr)
    {
	wc.szPname[MAXPNAMELEN-1] = TEXT('\0');
	mmr = waveInWritePersistentPref(wc.szPname, 0 != (dwFlags & DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY));
	if (!mmr) {
	    NotifyServerPreferredDeviceChange();
	} else {
	    Squirt("waveInSetPersistentPreferredId: waveInWritePersistenPref failed, mmr=%08Xh", mmr);
	}	    
    }

    return mmr;
}

void waveInGetCurrentConsoleVoiceComId(PUINT pPrefId, PDWORD pdwFlags)
{
    *pPrefId = WAVE_MAPPER;
    *pdwFlags = gfUsePreferredWaveOnly ? DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY : 0;
    if (gpstrWiConsoleVoiceComStringId) mregGetIdFromStringId(&waveindrvZ, gpstrWiConsoleVoiceComStringId, pPrefId);
    return;
}

MMRESULT waveInSetPersistentConsoleVoiceComId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;
    WAVEINCAPS wic;

    if (0 != (dwFlags & ~DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY)) return MMSYSERR_INVALPARAM;
    
    mmr = waveInGetDevCaps(PrefId, &wic, sizeof(wic));
    if (!mmr)
    {
	wic.szPname[MAXPNAMELEN-1] = TEXT('\0');
	mmr = waveWritePersistentConsoleVoiceCom(FALSE, wic.szPname, 0 != (dwFlags & 0x00000001));
	if (!mmr) {
	    NotifyServerPreferredDeviceChange();
	} else {
	    Squirt("waveInSetPersistentConsoleVoiceComId: waveWritePersistentConsoleVoiceCom failed, mmr=%08Xh", mmr);
	}	    
    }

    return mmr;
}

MMRESULT waveInSetCurrentConsoleVoiceComId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;

    WinAssert(PrefId < wTotalWaveInDevs || PrefId == WAVE_MAPPER);

    mmr = MMSYSERR_NOERROR;

    if (gpstrWiConsoleVoiceComStringId) HeapFree(hHeap, 0, gpstrWiConsoleVoiceComStringId);
    gpstrWiConsoleVoiceComStringId = NULL;
    
    if (wTotalWaveInDevs)
    {
        PWAVEDRV pwavedrv;
        UINT port;
            
        mmr = waveReferenceDriverById(&waveindrvZ, PrefId, &pwavedrv, &port);
    	if (!mmr)
    	{
    	    mregCreateStringIdFromDriverPort(pwavedrv, port, &gpstrWiConsoleVoiceComStringId, NULL);
            gfUsePreferredWaveOnly = (0 != (dwFlags & DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY));
    	}    	    
    }

    return mmr;
}


//------------------------------------------------------------------------------
//
//
//	MidiOut
//
//
//------------------------------------------------------------------------------

DWORD midiOutGetSetupPreferredAudioCount(UINT MidiId)
{
    PCWSTR DeviceInterface;
    DWORD dwCount;

    DeviceInterface = midiReferenceDevInterfaceById(&midioutdrvZ, MidiId);

    if(DeviceInterface == NULL) {
        return 0;
    }

    dwCount = GetDeviceInterfaceSetupPreferredAudioCount(DeviceInterface);
    wdmDevInterfaceDec(DeviceInterface);
    return dwCount;
}

MMRESULT midiOutSendPreferredMessage(BOOL fClear)
{
    PCWSTR DeviceInterface;
    UINT MidiId;
    MMRESULT mmr;

    if(!gfLogon) {
        return MMSYSERR_NOERROR;
    }

    midiOutGetCurrentPreferredId(&MidiId, NULL);

    if(MidiId == WAVE_MAPPER) {
        return MMSYSERR_NOERROR;
    }

    DeviceInterface = midiReferenceDevInterfaceById(&midioutdrvZ, MidiId);

    if(DeviceInterface == NULL) {
        return MMSYSERR_NOERROR;
    }

    gfMidiOutPreferredMessageSent = TRUE;

    mmr = midiOutMessage((HMIDIOUT)(UINT_PTR)MidiId, MODM_PREFERRED, (DWORD_PTR)fClear, (DWORD_PTR)DeviceInterface);
    wdmDevInterfaceDec(DeviceInterface);
    return mmr;
}

MMRESULT midiOutWritePersistentPref(IN UINT MidiOutId, IN ULONG SetupCount)
{
    HKEY hkMidiMapper;
    HKEY hkcu;
    MIDIOUTCAPS moc;
    DWORD dwDisposition;
    LONG result;
    MMRESULT mmr;

    mmr = midiOutGetDevCaps(MidiOutId, &moc, sizeof(moc));
    if (MMSYSERR_NOERROR != mmr) return mmr;

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_ALL, &hkcu))) return MMSYSERR_WRITEERROR;

    result = RegCreateKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_MIDIMAP, 0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_QUERY_VALUE, NULL, &hkMidiMapper, &dwDisposition);
    if (ERROR_SUCCESS == result)
    {
        PCWSTR pstrDeviceInterface;
        UINT RelativeIndex;

        pstrDeviceInterface = midiReferenceDevInterfaceById(&midioutdrvZ, MidiOutId);
        if (pstrDeviceInterface) {
            UINT i;
            RelativeIndex = 0;
            for (i = 0; i < MidiOutId; i++) {
                PCWSTR pstr = midiReferenceDevInterfaceById(&midioutdrvZ, i);
                if (pstr && !lstrcmpi(pstrDeviceInterface, pstr)) RelativeIndex++;
                if (pstr) wdmDevInterfaceDec(pstr);
            }
        } else {
            RelativeIndex = 0;
        }

        result = RegSetSzValue(hkMidiMapper, REGSTR_VAL_MULTIMEDIA_MIDIMAP_SZPNAME, moc.szPname);
        if (ERROR_SUCCESS == result) result = RegSetDwordValue(hkMidiMapper, REGSTR_VAL_MULTIMEDIA_MIDIMAP_RELATIVEINDEX, RelativeIndex);
        if (ERROR_SUCCESS == result) result = RegSetSzValue(hkMidiMapper, REGSTR_VAL_MULTIMEDIA_MIDIMAP_DEVICEINTERFACE, pstrDeviceInterface ? pstrDeviceInterface : TEXT(""));
        if (ERROR_SUCCESS == result) result = RegSetDwordValue(hkMidiMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, SetupCount);
        if (ERROR_SUCCESS == result) RegDeleteValue(hkMidiMapper, REGSTR_VAL_MULTIMEDIA_MIDIMAP_CURRENTINSTRUMENT);

        if (pstrDeviceInterface) wdmDevInterfaceDec(pstrDeviceInterface);
        RegCloseKey(hkMidiMapper);
    }

    if (ERROR_SUCCESS != result) mmr = MMSYSERR_WRITEERROR;

    NtClose(hkcu);
    return mmr;
}

MMRESULT midiOutGetIdFromName(IN PTSTR pstrName, OUT UINT *pMidiOutId)
{
    UINT MidiOutId;
    UINT cMidiOutId;
    MMRESULT mmr;

    cMidiOutId = midiOutGetNumDevs();
    for (MidiOutId = 0; MidiOutId < cMidiOutId; MidiOutId++)
    {
        MIDIOUTCAPS moc;
        mmr = midiOutGetDevCaps(MidiOutId, &moc, sizeof(moc));
        if (MMSYSERR_NOERROR == mmr)
        {
            if (!lstrcmp(pstrName, moc.szPname))
            {
                mmr = MMSYSERR_NOERROR;
                break;
            }
        }
    }
    
    if (MidiOutId == cMidiOutId)
    {
        mmr = MMSYSERR_NODRIVER;
    }

    if (MMSYSERR_NOERROR == mmr) *pMidiOutId = MidiOutId;
    return mmr;
}

MMRESULT midiOutGetIdFromDiAndIndex(IN PTSTR pstrDeviceInterface, IN INT RelativeIndex, OUT UINT *pMidiOutId)
{
    UINT cMidiOut;
    UINT MidiOutId;
    MMRESULT mmr;

    mmr = MMSYSERR_NODRIVER;

    cMidiOut = midiOutGetNumDevs();
    if (0 == cMidiOut) return MMSYSERR_NODRIVER;

    for (MidiOutId = 0; MidiOutId < cMidiOut; MidiOutId++) {
        PCWSTR pstr = midiReferenceDevInterfaceById(&midioutdrvZ, MidiOutId);
        if (pstr && !lstrcmpi(pstr, pstrDeviceInterface) && (0 == RelativeIndex--)) {
            *pMidiOutId = MidiOutId;
            wdmDevInterfaceDec(pstr);
            mmr = MMSYSERR_NOERROR;
            break;
        }
        if (pstr) wdmDevInterfaceDec(pstr);
    }

    return mmr;
}

MMRESULT midiOutGetInstrumentDriverData(IN PCTSTR pstrMidiSubkeyName, OUT PTSTR *ppstrDeviceInterface, OUT UINT *pDriverNum, OUT UINT *pPortNum, OUT PTSTR *ppstrPname)
{
    HKEY hkMidi;
    HKEY hkMidiSubkey;
    LONG result;
    MMRESULT mmr;
    BOOL f;

    mmr = MMSYSERR_ERROR;
    
    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_MEDIARESOURCES_MIDI, 0, KEY_QUERY_VALUE, &hkMidi);
    if (ERROR_SUCCESS != result) return MMSYSERR_ERROR;

    result = RegOpenKeyEx(hkMidi, pstrMidiSubkeyName, 0, KEY_QUERY_VALUE, &hkMidiSubkey);
    if (ERROR_SUCCESS == result)
    {
	PTSTR pstrActive;

	result = RegQuerySzValue(hkMidiSubkey, REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_ACTIVE, &pstrActive);
	if (ERROR_SUCCESS == result)
	{
	    PTCHAR pchEnd;
	    
	    BOOL fActive = _tcstol(pstrActive, &pchEnd, 10);
	    
	    f = HeapFree(hHeap, 0, pstrActive);
	    WinAssert(f);
	    
	    if (fActive)
	    {
                PTSTR pstrDeviceInterface = NULL;
                PTSTR pstrPname = NULL;
                DWORD dwDriverNum;
                DWORD dwPortNum;

		result = RegQueryDwordValue(hkMidiSubkey, REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_PHYSDEVID, &dwDriverNum);
		if (ERROR_SUCCESS == result) result = RegQueryDwordValue(hkMidiSubkey, REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_PORT, &dwPortNum);
                if (ERROR_SUCCESS == result) RegQuerySzValue(hkMidiSubkey, REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_DEVICEINTERFACE, &pstrDeviceInterface);
                if (ERROR_SUCCESS == result) RegQuerySzValue(hkMidiSubkey, REGSTR_VAL_MEDIARESOURCES_MIDI_SUBKEY_DESCRIPTION, &pstrPname);

		if (ERROR_SUCCESS == result)
		{
                    *ppstrDeviceInterface = NULL;
                    *ppstrPname = NULL;

                    if (pstrDeviceInterface) {
                        if (lstrlen(pstrDeviceInterface)> 0) {
                            *ppstrDeviceInterface = pstrDeviceInterface;
                        } else {
                            HeapFree(hHeap, 0, pstrDeviceInterface);
                        }
                    }

                    if (pstrPname) {
                        if (lstrlen(pstrPname)> 0) {
                            *ppstrPname = pstrPname;
                        } else {
                            HeapFree(hHeap, 0, pstrPname);
                        }
                    }

		    *pDriverNum = dwDriverNum;
		    *pPortNum = dwPortNum;

		    mmr = MMSYSERR_NOERROR;
		}
	    }
	}
	
	result = RegCloseKey(hkMidiSubkey);
	WinAssert(ERROR_SUCCESS == result);
    }

    result = RegCloseKey(hkMidi);
    WinAssert(ERROR_SUCCESS == result);
    
    return mmr;
}

MMRESULT midiOutGetIdFromInstrument(IN PTSTR pstrMidiKeyName, OUT UINT *outMidiOutId)
{
    PTSTR pstrDeviceInterface, pstrPname;
    UINT DriverNum, PortNum;
    UINT MidiOutId;
    MMRESULT mmr;

    mmr = midiOutGetInstrumentDriverData(pstrMidiKeyName, &pstrDeviceInterface, &DriverNum, &PortNum, &pstrPname);
    if (MMSYSERR_NOERROR == mmr) {
        if (pstrDeviceInterface) {
            mmr = midiOutGetIdFromDiAndIndex(pstrDeviceInterface, PortNum, &MidiOutId);
        } else if (pstrPname) {
            mmr = midiOutGetIdFromName(pstrPname, &MidiOutId);
        } else {
            PMIDIDRV pmidioutdrv = midioutdrvZ.Next;
            UINT DriverNum1 = DriverNum + 1;

            MidiOutId = 0;

            while ((pmidioutdrv != &midioutdrvZ) && (0 < DriverNum1))
            {
            	MidiOutId += pmidioutdrv->NumDevs;
            	DriverNum1--;
            	pmidioutdrv = pmidioutdrv->Next;
            }

            if ((pmidioutdrv != &midioutdrvZ) && (PortNum < pmidioutdrv->NumDevs))
            {
                MidiOutId += PortNum;
            } else {
                MidiOutId = MIDI_MAPPER;
                mmr = MMSYSERR_ERROR;
            }
        }
        if (pstrDeviceInterface) HeapFree(hHeap, 0, pstrDeviceInterface);
        if (pstrPname) HeapFree(hHeap, 0, pstrPname);
    }

    if (MMSYSERR_NOERROR == mmr) {
        MIDIOUTCAPS moc;
	WinAssert(MIDI_MAPPER != MidiOutId);
	mmr = midiOutGetDevCaps(MidiOutId, &moc, sizeof(moc));
    }

    if (MMSYSERR_NOERROR == mmr) *outMidiOutId = MidiOutId;
    return mmr;
}

MMRESULT midiOutReadCurrentInstrument(OUT PTSTR *ppstrCurrentInstrument, OUT DWORD *pSetupCount)
{
    HKEY hkcu;
    HKEY hkMidiMapper;
    LONG result;
    MMRESULT mmr;

    mmr = MMSYSERR_ERROR;
    
    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_READ, &hkcu))) return MMSYSERR_READERROR;

    result = RegOpenKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_MIDIMAP, 0, KEY_QUERY_VALUE, &hkMidiMapper);
    if (ERROR_SUCCESS == result)
    {
	result = RegQuerySzValue(hkMidiMapper, REGSTR_VAL_MULTIMEDIA_MIDIMAP_CURRENTINSTRUMENT, ppstrCurrentInstrument);
	if (ERROR_SUCCESS == result)
	{
	    DWORD SetupCount;

	    result = RegQueryDwordValue(hkMidiMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &SetupCount);
	    SetupCount = (ERROR_SUCCESS == result) ? SetupCount : 0;

	    *pSetupCount = SetupCount;
	    mmr = MMSYSERR_NOERROR;
	} else {
	    mmr = MMSYSERR_ERROR;
	}
	result = RegCloseKey(hkMidiMapper);
	WinAssert(ERROR_SUCCESS == result);
    }

    NtClose(hkcu);

    return mmr;
}

MMRESULT midiOutReadPreferredDeviceData(OUT PTSTR *ppstrDeviceInterface, OUT UINT *pRelativeIndex, OUT PTSTR *ppstrPname, OUT ULONG *pSetupCount)
{
    HKEY hkcu;
    HKEY hkMidiMapper;
    LONG result;
    MMRESULT mmr;

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_READ, &hkcu))) return MMSYSERR_READERROR;

    result = RegOpenKeyEx(hkcu, REGSTR_PATH_MULTIMEDIA_MIDIMAP, 0, KEY_QUERY_VALUE, &hkMidiMapper);
    if (ERROR_SUCCESS == result)
    {
        PTSTR pstrDeviceInterface = NULL;
        PTSTR pstrPname = NULL;
        DWORD dwIndex;
        DWORD dwSetupCount;
        
        // See if we have a Pname.  It is okay not to.
        result = RegQuerySzValue(hkMidiMapper, REGSTR_VAL_MULTIMEDIA_MIDIMAP_SZPNAME, &pstrPname);
        if (ERROR_FILE_NOT_FOUND == result) result = ERROR_SUCCESS;

        // See if we have a device interface + relative index.  It is okay not to.
        if (ERROR_SUCCESS == result) result = RegQueryDwordValue(hkMidiMapper, REGSTR_VAL_MULTIMEDIA_MIDIMAP_RELATIVEINDEX, &dwIndex);
        if (ERROR_SUCCESS == result) result = RegQuerySzValue(hkMidiMapper, REGSTR_VAL_MULTIMEDIA_MIDIMAP_DEVICEINTERFACE, &pstrDeviceInterface);
        if (ERROR_FILE_NOT_FOUND == result) result = ERROR_SUCCESS;

        // The device interface value might be zero length.  Act as thought it
        // doesn't exist in this case.
        if ((ERROR_SUCCESS == result) && (pstrDeviceInterface) && (0 == lstrlen(pstrDeviceInterface)))
        {
            HeapFree(hHeap, 0, pstrDeviceInterface);
            pstrDeviceInterface = NULL;
            dwIndex = 0;
        }

        if (ERROR_SUCCESS != RegQueryDwordValue(hkMidiMapper, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &dwSetupCount)) {
            dwSetupCount = 0;
        }

        if (ERROR_SUCCESS == result) {
            if (pstrPname || pstrDeviceInterface) {
                *ppstrDeviceInterface = pstrDeviceInterface;
                *ppstrPname = pstrPname;
                *pRelativeIndex = dwIndex;
                *pSetupCount = dwSetupCount;
                mmr = MMSYSERR_NOERROR;
            } else {
                mmr = MMSYSERR_VALNOTFOUND;
            }
        } else {
            mmr = MMSYSERR_READERROR;
        }

        if (MMSYSERR_NOERROR != mmr) {
            if (pstrDeviceInterface) HeapFree(hHeap, 0, pstrDeviceInterface);
            if (pstrPname) HeapFree(hHeap, 0, pstrPname);
        }
            
        RegCloseKey(hkMidiMapper);
    } else {
        if (ERROR_FILE_NOT_FOUND == result) mmr = MMSYSERR_KEYNOTFOUND;
        else mmr = MMSYSERR_READERROR;
    }

    NtClose(hkcu);

    return mmr;
}

MMRESULT midiOutReadPersistentPreferredId(OUT UINT *pMidiPrefId, OUT ULONG *pSetupCount)
{
    PTSTR pstrDeviceInterface;
    PTSTR pstrPname;
    UINT RelativeIndex;
    UINT MidiOutId;
    ULONG SetupCount;
    MMRESULT mmr;

    mmr = midiOutReadPreferredDeviceData(&pstrDeviceInterface, &RelativeIndex, &pstrPname, &SetupCount);
    if (MMSYSERR_NOERROR == mmr) {
        WinAssert(pstrDeviceInterface || pstrPname);
        if (pstrDeviceInterface) {
            mmr = midiOutGetIdFromDiAndIndex(pstrDeviceInterface, RelativeIndex, &MidiOutId);
        } else {
            WinAssert(pstrPname);
            mmr = midiOutGetIdFromName(pstrPname, &MidiOutId);
        }
        if (pstrDeviceInterface) HeapFree(hHeap, 0, pstrDeviceInterface);
        if (pstrPname) HeapFree(hHeap, 0, pstrPname);
    } else if (MMSYSERR_VALNOTFOUND == mmr || MMSYSERR_KEYNOTFOUND == mmr) {
        PTSTR pstrMidiKeyName;
        mmr = midiOutReadCurrentInstrument(&pstrMidiKeyName, &SetupCount);
        if (MMSYSERR_NOERROR == mmr) {
            mmr = midiOutGetIdFromInstrument(pstrMidiKeyName, &MidiOutId);
            // Since this is older format for storing preference, let's
            //   rewrite it in newer format.
            if (MMSYSERR_NOERROR == mmr)
            {
                midiOutWritePersistentPref(MidiOutId, SetupCount);
            }
            HeapFree(hHeap, 0, pstrMidiKeyName);
         }
    }

    if (MMSYSERR_NOERROR == mmr) {
        *pMidiPrefId = MidiOutId;
        *pSetupCount = SetupCount;
    }

    return mmr;
}

MMRESULT midiOutPickBestId(PUINT pMidiPrefId, UINT WaveOutPrefId)
{
    MIDIOUTCAPS moc;
    UINT cMidiOutId;
    UINT MidiOutId;
    UINT UserSelectedMidiOutId;
    UINT WavetableMidiOutId;
    UINT SoftwareMidiOutId;
    UINT OtherMidiOutId;
    UINT FmMidiOutId;
    UINT ExternalMidiOutId;
    DWORD MidiOutIdCount;
    DWORD UserSelectedMidiOutIdCount;
    DWORD WavetableMidiOutIdCount;
    DWORD SoftwareMidiOutIdCount;
    DWORD OtherMidiOutIdCount;
    DWORD FmMidiOutIdCount;
    DWORD ExternalMidiOutIdCount;
    MMRESULT mmrLastError;
    MMRESULT mmr;
    BOOL f;

    UserSelectedMidiOutId = MIDI_MAPPER;
    WavetableMidiOutId = MIDI_MAPPER;
    SoftwareMidiOutId = MIDI_MAPPER;
    OtherMidiOutId = MIDI_MAPPER;
    FmMidiOutId = MIDI_MAPPER;
    ExternalMidiOutId = MIDI_MAPPER;
    MidiOutId = MIDI_MAPPER;

    UserSelectedMidiOutIdCount = 0;
    WavetableMidiOutIdCount = 0;
    SoftwareMidiOutIdCount = 0;
    OtherMidiOutIdCount = 0;
    FmMidiOutIdCount = 0;
    ExternalMidiOutIdCount = 0;
    MidiOutIdCount = 0;

    mmr = midiOutReadPersistentPreferredId(&UserSelectedMidiOutId, &UserSelectedMidiOutIdCount);

    mmrLastError = MMSYSERR_NODRIVER;

    cMidiOutId = midiOutGetNumDevs();
    for (MidiOutId = 0; MidiOutId < cMidiOutId; MidiOutId++)
    {
	mmr = midiOutGetDevCaps(MidiOutId, &moc, sizeof(moc));
	if (MMSYSERR_NOERROR == mmr)
	{
	    MidiOutIdCount = midiOutGetSetupPreferredAudioCount(MidiOutId);

	    if (MOD_SWSYNTH == moc.wTechnology &&
		MM_MSFT_WDMAUDIO_MIDIOUT == moc.wPid &&
		MM_MICROSOFT == moc.wMid)
	    {
		// We need to special case this synth, and get the count from
		//  the preferred audio device.
		SoftwareMidiOutId = MidiOutId;
		if ((-1) != WaveOutPrefId) {
		    SoftwareMidiOutIdCount = waveOutGetSetupPreferredAudioCount(WaveOutPrefId);
		} else {
		    SoftwareMidiOutIdCount = 0;
		}
	    } else if (MOD_FMSYNTH == moc.wTechnology) {
		FmMidiOutId = MidiOutId;
		FmMidiOutIdCount = MidiOutIdCount;
	    } else if (MOD_MIDIPORT == moc.wTechnology) {
		ExternalMidiOutId = MidiOutId;
		ExternalMidiOutIdCount = MidiOutIdCount;
	    } else if (MOD_WAVETABLE == moc.wTechnology) {
		WavetableMidiOutId = MidiOutId;
		WavetableMidiOutIdCount = MidiOutIdCount;
	    } else {
		OtherMidiOutId = MidiOutId;
		OtherMidiOutIdCount = MidiOutIdCount;
	    }
	} else {
	    mmrLastError = mmr;
	}
    }

    MidiOutId = ExternalMidiOutId;
    MidiOutIdCount = ExternalMidiOutIdCount;
    if ((FmMidiOutIdCount >= MidiOutIdCount) && (MIDI_MAPPER != FmMidiOutId))
    {
	MidiOutId = FmMidiOutId;
	MidiOutIdCount = FmMidiOutIdCount;
    }
    if ((OtherMidiOutIdCount >= MidiOutIdCount) && (MIDI_MAPPER != OtherMidiOutId))
    {
	MidiOutId = OtherMidiOutId;
	MidiOutIdCount = OtherMidiOutIdCount;
    }
    if ((SoftwareMidiOutIdCount >= MidiOutIdCount) && (MIDI_MAPPER != SoftwareMidiOutId))
    {
	MidiOutId = SoftwareMidiOutId;
	MidiOutIdCount = SoftwareMidiOutIdCount;
    }
    if ((WavetableMidiOutIdCount >= MidiOutIdCount) && (MIDI_MAPPER != WavetableMidiOutId))
    {
	MidiOutId = WavetableMidiOutId;
	MidiOutIdCount = WavetableMidiOutIdCount;
    }
    if ((UserSelectedMidiOutIdCount >= MidiOutIdCount) && (MIDI_MAPPER != UserSelectedMidiOutId))
    {
	MidiOutId = UserSelectedMidiOutId;
	MidiOutIdCount = UserSelectedMidiOutIdCount;
    }
		    
    if ((-1) != MidiOutId) {
	mmr = MMSYSERR_NOERROR;
    } else {
	mmr = mmrLastError;
    }

    if (MMSYSERR_NOERROR == mmr) *pMidiPrefId = MidiOutId;
    return mmr;
}

void midiOutGetCurrentPreferredId(PUINT pPrefId, PDWORD pdwFlags)
{
    *pPrefId = WAVE_MAPPER;
    if (pdwFlags) *pdwFlags = 0;;
    if (gpstrMoDefaultStringId) mregGetIdFromStringId(&midioutdrvZ, gpstrMoDefaultStringId, pPrefId);
    return;
}

MMRESULT midiOutSetCurrentPreferredId(UINT PrefId)
{
    MMRESULT mmr;
    
    WinAssert(PrefId < wTotalMidiOutDevs || PrefId == MIDI_MAPPER);

    mmr = MMSYSERR_NOERROR;

    if (gpstrMoDefaultStringId) HeapFree(hHeap, 0, gpstrMoDefaultStringId);
    gpstrMoDefaultStringId = NULL;
    
    if (wTotalMidiOutDevs)
    {
        PMIDIDRV pmididrv;
        UINT port;
            
        mmr = midiReferenceDriverById(&midioutdrvZ, PrefId, &pmididrv, &port);
    	if (!mmr)
    	{
    	    mmr = mregCreateStringIdFromDriverPort(pmididrv, port, &gpstrMoDefaultStringId, NULL);
    	    if (!mmr)
    	    {
    	    	if (!gfDisablePreferredDeviceReordering)
    	    	{
                    // Rearrange some of the driver list so that the preferred midiOut
        	    // device has a good chance of having device ID 0
        	    if (0 != PrefId)
        	    {
                        // Move the midi driver to the head of this list.  This usually
                        // makes the preferred device have ID 0.
        	            EnterNumDevs("midiOutSetCurrentPreferredId");
                        pmididrv->Prev->Next = pmididrv->Next;
                        pmididrv->Next->Prev = pmididrv->Prev;
                        pmididrv->Next = midioutdrvZ.Next;
                        pmididrv->Prev = &midioutdrvZ;
                        midioutdrvZ.Next->Prev = pmididrv;
                        midioutdrvZ.Next = pmididrv;
                        LeaveNumDevs("midiOutSetCurrentPreferredId");
    
                        mregDecUsagePtr(pmididrv);
        	    }
    	    	}
    	    }
    	}    	    
    }

    if (!mmr)
    {
        // Reconfigure the mapper only if it was already loaded.  Don't cause it to
        // load simply so that we can reconfigure it!
        if (MidiMapperInitialized) midiOutMessage((HMIDIOUT)(UINT_PTR)MIDI_MAPPER, DRVM_MAPPER_RECONFIGURE, 0, 0);
    }

    return mmr;
}

MMRESULT midiOutSetPersistentPreferredId(UINT PrefId, DWORD dwFlags)
{
    MMRESULT mmr;
    mmr = midiOutWritePersistentPref(PrefId, GetCurrentSetupPreferredAudioCount());
    if (!mmr) NotifyServerPreferredDeviceChange();
    return mmr;
}

//------------------------------------------------------------------------------
//
//
//	RefreshPreferredDevices
//
//
//------------------------------------------------------------------------------
void RefreshPreferredDevices(void)
{
    UINT WaveOutPreferredId;
    DWORD WaveOutPreferredFlags;
    UINT WaveInPreferredId;
    DWORD WaveInPreferredFlags;
    UINT WaveOutConsoleVoiceComId;
    DWORD WaveOutConsoleVoiceComFlags;
    UINT WaveInConsoleVoiceComId;
    DWORD WaveInConsoleVoiceComFlags;
    UINT MidiOutPreferredId;

    UINT OldWaveOutPreferredId;
    DWORD OldWaveOutPreferredFlags;
    UINT OldWaveInPreferredId;
    DWORD OldWaveInPreferredFlags;
    UINT OldWaveOutConsoleVoiceComId;
    DWORD OldWaveOutConsoleVoiceComFlags;
    UINT OldWaveInConsoleVoiceComId;
    DWORD OldWaveInConsoleVoiceComFlags;
    UINT OldMidiOutPreferredId;

    // Squirt("RefreshPreferredDevices");
    
    BOOL fImpersonate = FALSE;
    
    waveOutGetCurrentPreferredId(&OldWaveOutPreferredId, &OldWaveOutPreferredFlags);
    if (!waveOutPickBestId(&WaveOutPreferredId, &WaveOutPreferredFlags)) {
        if ((WaveOutPreferredId != OldWaveOutPreferredId) ||
            (WaveOutPreferredFlags != OldWaveOutPreferredFlags) ||
            !gfWaveOutPreferredMessageSent)
        {
            // Squirt("RefreshPreferredDevices: different waveOut preference %d -> %d", OldWaveOutPreferredId, WaveOutPreferredId);

            waveOutSendPreferredMessage(TRUE);
            
            waveOutSetCurrentPreferredId(WaveOutPreferredId, WaveOutPreferredFlags);
            
            waveOutSendPreferredMessage(FALSE);
            
        }

    }

    waveOutGetCurrentConsoleVoiceComId(&OldWaveOutConsoleVoiceComId, &OldWaveOutConsoleVoiceComFlags);
    if (!wavePickBestConsoleVoiceComId(TRUE, &WaveOutConsoleVoiceComId, &WaveOutConsoleVoiceComFlags)) {
        if ((WaveOutConsoleVoiceComId != OldWaveOutConsoleVoiceComId) ||
            (WaveOutConsoleVoiceComFlags != OldWaveOutConsoleVoiceComFlags))
        {
            // Squirt("RefreshPreferredDevices: different waveOut preference %d -> %d", OldWaveOutConsoleVoiceComId, WaveOutConsoleVoiceComId);
            waveOutSetCurrentConsoleVoiceComId(WaveOutConsoleVoiceComId, WaveOutConsoleVoiceComFlags);
        }

    }

    waveInGetCurrentPreferredId(&OldWaveInPreferredId, &OldWaveInPreferredFlags);
    if (!waveInPickBestId(&WaveInPreferredId, &WaveInPreferredFlags)) {
        if ((WaveInPreferredId != OldWaveInPreferredId) ||
            (WaveInPreferredFlags != OldWaveInPreferredFlags) ||
            !gfWaveInPreferredMessageSent)
        {
            // Squirt("RefreshPreferredDevices: different waveIn preference %d -> %d", OldWaveInPreferredId, WaveInPreferredId);

            waveInSendPreferredMessage(TRUE);

            waveInSetCurrentPreferredId(WaveInPreferredId, WaveInPreferredFlags);

            waveInSendPreferredMessage(FALSE);

        }
    }

    waveInGetCurrentConsoleVoiceComId(&OldWaveInConsoleVoiceComId, &OldWaveInConsoleVoiceComFlags);
    if (!wavePickBestConsoleVoiceComId(FALSE, &WaveInConsoleVoiceComId, &WaveInConsoleVoiceComFlags)) {
        if ((WaveInConsoleVoiceComId != OldWaveInConsoleVoiceComId) ||
            (WaveInConsoleVoiceComFlags != OldWaveInConsoleVoiceComFlags))
        {
            // Squirt("RefreshPreferredDevices: different waveIn preference %d -> %d", OldWaveInConsoleVoiceComId, WaveInConsoleVoiceComId);
            waveInSetCurrentConsoleVoiceComId(WaveInConsoleVoiceComId, WaveInConsoleVoiceComFlags);
        }
    }

    midiOutGetCurrentPreferredId(&OldMidiOutPreferredId, NULL);
    if (!midiOutPickBestId(&MidiOutPreferredId, WaveOutPreferredId)) {
        if (MidiOutPreferredId != OldMidiOutPreferredId ||
            !gfMidiOutPreferredMessageSent)
        {
            // Squirt("RefreshPreferredDevices: different midiOut preference %d -> %d", OldMidiOutPreferredId, MidiOutPreferredId);

            midiOutSendPreferredMessage(TRUE);

            midiOutSetCurrentPreferredId(MidiOutPreferredId);

            midiOutSendPreferredMessage(FALSE);

        }
    }

    // Squirt("RefreshPreferredDevices: return");
    return;
}

void InvalidatePreferredDevices(void)
{
    if (gpstrWoDefaultStringId) HeapFree(hHeap, 0, gpstrWoDefaultStringId);
    if (gpstrWiDefaultStringId) HeapFree(hHeap, 0, gpstrWiDefaultStringId);
    gpstrWoDefaultStringId = NULL;
    gpstrWiDefaultStringId = NULL;
    
    if (gpstrWoConsoleVoiceComStringId) HeapFree(hHeap, 0, gpstrWoConsoleVoiceComStringId);
    if (gpstrWiConsoleVoiceComStringId) HeapFree(hHeap, 0, gpstrWiConsoleVoiceComStringId);
    gpstrWoConsoleVoiceComStringId = NULL;
    gpstrWiConsoleVoiceComStringId = NULL;
    
    if (gpstrMoDefaultStringId) HeapFree(hHeap, 0, gpstrMoDefaultStringId);
    gpstrMoDefaultStringId = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\task.c ===
/******************************************************************************

   Copyright (c) 1985-1998 Microsoft Corporation

   Title:   task.c - support for task creation and blocking

   Version: 1.00

   Date:    05-Mar-1990

   Author:  ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   ----- -----------------------------------------------------------
   05-MAR-1990   ROBWI First Version - APIs and structures
   18-APR-1990   ROBWI Ported from Resman to mmsystem
   25-JUN-1990   ROBWI Added mmTaskYield
   07-JUL-1991   CJP   Modified to work with new stack switcher code

                 SD    Ported to NT

                 RCBS  Added NT function - Modelled on threads and
                       PostThreadMessage :

                       HTASK is thread id (DWORD)
*****************************************************************************/

#define MMNOTIMER
#define MMNOSEQ
#define MMNOWAVE
#define MMNOMIDI
#define MMNOJOY
#define MMNOSOUND
#define MMNOMCI

#define NOMIDIDEV
#define NOWAVEDEV
#define NOTIMERDEV
#define NOJOYDEV
#define NOMCIDEV
#define NOSEQDEV

#include <winmmi.h>

#define MM_TASK_STACK_SIZE 0x200

/*
 *  Private structure type passed from mmTaskCreate to mmStartTask
 */

 typedef struct {
     HANDLE TerminationEvent;
     DWORD_PTR  dwInst;
     LPTHREAD_START_ROUTINE lpfn;
 } MM_THREAD_START_DATA;

/*
 * Task start stub
 */

STATICFN DWORD mmStartTask(LPVOID lpThreadParameter);

/*************************************************************************
 *
 * @doc     DDK    MMSYSTEM    TASK
 *
 * @api     VOID | mmTaskBlock |  This function blocks the current
 *          task context if its event count is 0.
 *
 * @parm    HANDLE | hTask | Task handle of the current task. For predictable
 *          results, get the task handle from <f mmGetCurrentTask>.
 *
 * @xref    mmTaskSignal mmTaskCreate
 *
 * @comm    WARNING : For predictable results, must only be called from a
 *          task created with <f mmTaskCreate>.
 *
 *************************************************************************/
VOID    APIENTRY mmTaskBlock(DWORD h)
{
    MSG msg;

   /*
    *   Loop until we get the message we want
    */
    for (;;) {
       /*
        *   Retrieve any message for task
        */
        GetMessage(&msg, NULL, 0, 0);

       /*
        *   If the message is for a window dispatch it
        */
        if (msg.hwnd != NULL) {
            DispatchMessage(&msg);
        } else {
           /*
            *   WM_USER is the signal message
            */
            if (msg.message == WM_USER) {
                break;
            }
        }
    }
    return;
}

/*************************************************************************
 *
 * @doc     DDK    MMSYSTEM    TASK
 *
 * @api     BOOL | mmTaskSignal |  This function signals the specified
 *          task, incrementing its event count and unblocking
 *          it.
 *
 * @parm    HTASK | hTask | Task handle. For predictable results, get the
 *          task handle from <f mmGetCurrentTask>.
 *
 * @rdesc   Returns TRUE if the signal was sent, else FALSE if the message
 *          queue was full.
 *
 * @xref    mmTaskBlock  mmTaskCreate
 *
 * @comm    Must be callable at interrupt time! WARNING : For
 *          predictable results, must only be called from a task
 *          created with <f mmTaskCreate>.
 *
 *************************************************************************/
BOOL    APIENTRY mmTaskSignal(DWORD h)
{
#ifdef DBG
    BOOL fErr;
    dprintf2(("Signalling Thread %x", (ULONG)h));
    fErr = PostThreadMessage((DWORD)h, WM_USER, 0, 0);
        if (!fErr) {
                dprintf1(("Error %d signalling Thread %x", GetLastError(), (ULONG)h));
        }
        return(fErr);
#else
    return PostThreadMessage((DWORD)h, WM_USER, 0, 0);
#endif
}

/*************************************************************************
 *
 * @doc     DDK    MMSYSTEM    TASK
 *
 * @api     VOID | mmTaskYield | This function causes the current task
 *          to yield.
 *
 * @comm    For predictable results and future compatibility, use this
 *          function rather than <f Yield> or the undocumented Kernel yield
 *          function to yield within a task created with <f mmTaskCreate>.
 *
 *************************************************************************/
VOID    APIENTRY mmTaskYield(VOID) {
   Yield();
}

/*************************************************************************
 *
 * @doc     DDK    MMSYSTEM    TASK
 *
 * @api     HTASK | mmGetCurrentTask |  This function returns the
 *          handle of the currently executing task created with
 *          <f mmTaskCreate>.
 *
 * @rdesc   Returns a task handle. For predictable results and future
 *          compatibility, use this function rather than <f GetCurrentTask>
 *          to get the task handle of a task created with <f mmTaskCreate>.
 *
 * @xref    mmTaskCreate
 *
 *************************************************************************/
DWORD   APIENTRY mmGetCurrentTask(VOID) {
   return (DWORD)GetCurrentThreadId();
}

/***************************************************************************
 *
 * @doc     DDK    MMSYSTEM    TASK
 *
 * @api     UINT | mmTaskCreate | This function creates a new task.
 *
 * @parm    LPTASKCALLBACK | lpfn |  Points to a program supplied
 *            function and represents the starting address of the new
 *            task.
 *
 * @parm    HANDLE * | lph | Points to the variable that receives the
 *            task handle (NOT the task identifier).  This is used by
 *            systems that wish to use the handle to wait for task
 *            termination.  If lph is 0 the thread handle is closed here
 *
 * @parm    DWORD | dwStack | Specifies the size of the stack to be
 *            provided to the task.
 *
 * @parm    DWORD | dwInst | DWORD of instance data to pass to the task
 *            routine.
 *
 * @rdesc   Returns zero if the function is successful. Otherwise it
 *            returns an error value which may be one of the following:
 *
 *     @flag    TASKERR_NOTASKSUPPORT | Task support is not available.
 *     @flag    TASKERR_OUTOFMEMORY | Not enough memory to create task.
 *
 * @comm    When a mmsystem task is created, the system will make a far
 *          call to the program-supplied function whose address is
 *          specified by the lpfn parameter. This function may include
 *          local variables and may call other functions as long as
 *          the stack has sufficient space.
 *
 *          The task terminates when it returns.
 *
 * @xref    mmTaskSignal mmTaskBlock
 *
 ***************************************************************************/


UINT APIENTRY mmTaskCreate(LPTASKCALLBACK lpfn, HANDLE * lph, DWORD_PTR dwInst)
{
    DWORD            ThreadId;
    HANDLE           ThreadHandle;
    HANDLE           TerminationEvent;

    MM_THREAD_START_DATA *ThreadData;

   /*
    *  Create a block to pass stuff to our new thread
    */

    ThreadData = (MM_THREAD_START_DATA *)LocalAlloc(LPTR, sizeof(*ThreadData));

    if (ThreadData == NULL) {
        return TASKERR_OUTOFMEMORY;
    }

    ThreadData->dwInst = dwInst;
    ThreadData->lpfn = (LPTHREAD_START_ROUTINE)lpfn;

   /*
    *  We create an event which will be set when the thread terminates
    *  The initial state is NOT signalled.  This means that the handle
    *  can be waited on immediately.
    */

    if (lph) {
        ThreadData->TerminationEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (ThreadData->TerminationEvent == NULL) {
            LocalFree(ThreadData);
            return TASKERR_OUTOFMEMORY;
        }
    }

   /*
    *  The new thread will free ThreadData - copy of Termination Event handle
    */

    TerminationEvent = ThreadData->TerminationEvent;

   /*
    *  create another thread so that we can run the stream outside of
    *  the context of the app.
    */

    ThreadHandle = CreateThread(NULL,
                                MM_TASK_STACK_SIZE,
                                mmStartTask,
                                (LPVOID)ThreadData,
                                0,
                                &ThreadId);
    if (ThreadHandle) {
        if (lph) {
            *lph = TerminationEvent;
        }

        CloseHandle(ThreadHandle);
        dprintf2(("Created task with thread id %x", ThreadId));
        return 0;

    } else {
        if (lph) {
            CloseHandle(ThreadData->TerminationEvent);
        }
        LocalFree(ThreadData);
        return TASKERR_OUTOFMEMORY;
    }
}


/***************************************************************************
 *
 * @doc     DDK    MMSYSTEM    TASK
 *
 * @api     DWORD | mmStartTask | This function is a stub for a new task.
 *
 * @parm    LPVOID | lpThreadParameter |  Points to the data for the
 *            thread.  In our case this is an MM_THREAD_START_DATA
 *            packet.
 *
 * @rdesc   Returns the return code of the thread routine passed.
 *
 * @comm    When a mmsystem task is created, this routine will always be
 *          the entry point for it.  It calls the routine the application
 *          wanted then sets an event for termination.  The reason for this
 *          is that we often want to wait for the thread to terminate inside
 *          winmm's DLL init routine which deadlock if you wait for threads to
 *          really terminate.  On the other hand we don't want the thread to
 *          be executing other DLL's code at the point when we say we're
 *          finished because that DLL may be unloading.
 *
 *          The task terminates when it returns.
 *
 * @xref    mmTaskSignal mmTaskBlock
 *
 ***************************************************************************/
STATICFN DWORD mmStartTask(LPVOID lpThreadParameter)
{
    MM_THREAD_START_DATA ThreadData;
    DWORD ThreadReturn;


   /*
    *  Take a copy of the input data and free the allocated memory
    */

    ThreadData = *(MM_THREAD_START_DATA *)lpThreadParameter;
    LocalFree(lpThreadParameter);


   /*
    *  Call the real thread
    */

    ThreadReturn = (*ThreadData.lpfn)((PVOID)ThreadData.dwInst);

   /*
    *  The real thread is now finshed so set its event
    */

    if (ThreadData.TerminationEvent) {
        SetEvent(ThreadData.TerminationEvent);
    }


   /*
    *  Return the return code the thread wanted to return
    */

    return ThreadReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\sources.inc ===
#
#   Create WINMM.DLL
#

MAJORCOMP=windows
MINORCOMP=winmm

TARGETNAME=winmm
TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows

DLLDEF=$(O)\winmm.def

# Define libs we need and where to find them

TARGETLIBS=$(WINDOWS_LIB_PATH)\user32p.lib     \
           $(LIBRARY_PATH)\gdi32.lib      \
           $(LIBRARY_PATH)\kernel32.lib   \
           $(LIBRARY_PATH)\advapi32.lib   \
           $(SDK_LIB_PATH)\setupapi.lib   \
           $(SDK_LIB_PATH)\ole32.lib      \
           $(DDK_LIB_PATH)\ksguid.lib     \
           $(LIBRARY_PATH)\rpcrt4.lib     \
           $(LIBRARY_PATH)\dinput.lib     \

INCLUDES=..\;..\..\inc;$(TERMSRV_INC_PATH);$(WINDOWS_INC_PATH);$(O);

MSC_WARNING_LEVEL=/W3 /WX

#
# Retail
#
C_DEFINES=$(C_DEFINES) -D_WINMM_ -DAGFX_EXPORTS

#DLLORDER=..\$(TARGETNAME).prf

#NTPROFILEINPUT=yes

#
# Debug (normally commented out but leave in file)
#
#C_DEFINES=$(C_DEFINES) -D_WINMM_ -DDEBUG -DWINVER=0x0400
#MSC_OPTIMIZATION=-Od -Zi
#NTDEBUG=ntsd
#NTDEBUGTYPE=both
#386_OPTIMIZATION=-Fc

USE_NTDLL=1

PASS1_PUBLISH={$(O)\$(TARGETNAME).lib=$(SDK_LIB_PATH)\$(TARGETNAME).lib}


SOURCES=..\audiosrv.idl   \
        ..\audiosrv_c.cpp \
        ..\audiosrvc.c     \
        ..\agfxc.c      \
        ..\regapi.c     \
        ..\csrthrd.c    \
        ..\auxout.c     \
        ..\drvr.c       \
        ..\drvrrare.c   \
        ..\debug.c      \
        ..\joy.c        \
        ..\mixer.c      \
        ..\mmwow32.c    \
        ..\mmwowmci.c   \
        ..\mci.c        \
        ..\mciparse.c   \
        ..\mcisys.c     \
        ..\mmwnd.c      \
        ..\mmio.c       \
        ..\mmioriff.c   \
        ..\mmiomisc.c   \
        ..\midi.c       \
        ..\midistrm.c   \
        ..\playsnd.c    \
        ..\playwav.c    \
        ..\time.c       \
        ..\task.c       \
        ..\util.c       \
        ..\winmm.c      \
        ..\wave.c       \
        ..\clock.c      \
        ..\midiemu.c    \
        ..\pref.c       \
        ..\winmm.rc

# Set up the entry point
DLLENTRY=DllInstanceInit

NTTARGETFILE0=audiosrv.idl audiosrv.acf
IDL_TYPE=RPC
PASS0_CLIENTDIR=$(O)
PASS0_HEADERDIR=$(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\regapi.c ===
/****************************************************************************\
*
*  Module Name : regapi.c
*
*  Multimedia support library
*
*  This module contains the code for accessing the registry
*
*  Copyright (c) 1993-1998 Microsoft Corporation
*
\****************************************************************************/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <regapi.h>
#include "winmmi.h"

HANDLE Drivers32Handle;
static WCHAR gszMsacmDriver[] = L"msacm.";

/*
**  Free everything cached
*/

VOID mmRegFree(VOID)
{
    if (Drivers32Handle != NULL) {
        NtClose(Drivers32Handle);
        Drivers32Handle = NULL;
    }
}

/*
**  Open a subkey
*/
HANDLE mmRegOpenSubkey(HANDLE BaseKeyHandle, LPCWSTR lpszSubkeyName)
{
    UNICODE_STRING    unicodeSectionName;
    HANDLE            KeyHandle;
    OBJECT_ATTRIBUTES oa;

    RtlInitUnicodeString(&unicodeSectionName, lpszSubkeyName);
    InitializeObjectAttributes(&oa,
                               &unicodeSectionName,
                               OBJ_CASE_INSENSITIVE,
                               BaseKeyHandle,
                               (PSECURITY_DESCRIPTOR)NULL);

    /*
    **  Open the sub section
    */

    if (!NT_SUCCESS(NtOpenKey(&KeyHandle, GENERIC_READ, &oa))) {
        return NULL;
    } else {
        return KeyHandle;
    }
}


/*
**  Open a subkey
*/
HANDLE mmRegOpenSubkeyForWrite(HANDLE BaseKeyHandle, LPCWSTR lpszSubkeyName)
{
    UNICODE_STRING    unicodeSectionName;
    HANDLE            KeyHandle;
    OBJECT_ATTRIBUTES oa;

    RtlInitUnicodeString(&unicodeSectionName, lpszSubkeyName);
    InitializeObjectAttributes(&oa,
                               &unicodeSectionName,
                               OBJ_CASE_INSENSITIVE,
                               BaseKeyHandle,
                               (PSECURITY_DESCRIPTOR)NULL);

    /*
    **  Open the sub section
    */

    if (!NT_SUCCESS(NtOpenKey(&KeyHandle, MAXIMUM_ALLOWED, &oa))) {
        return NULL;
    } else {
        return KeyHandle;
    }
}

/*
**  Read (small) registry data entries
*/

BOOL mmRegQueryValue(HANDLE  BaseKeyHandle,
                     LPCWSTR lpszSubkeyName,
                     LPCWSTR lpszValueName,
                     ULONG   dwLen,
                     LPWSTR  lpszValue)
{
    BOOL              ReturnCode;
    HANDLE            KeyHandle;
    UNICODE_STRING    unicodeSectionName;
    UNICODE_STRING    unicodeValueName;
    ULONG             ResultLength;

    struct   {
        KEY_VALUE_PARTIAL_INFORMATION KeyInfo;
        UCHAR                         Data[MAX_PATH * sizeof(WCHAR)];
             }        OurKeyValueInformation;


    if (lpszSubkeyName) {
        KeyHandle = mmRegOpenSubkey(BaseKeyHandle, lpszSubkeyName);
    } else {
        KeyHandle = NULL;
    }

    /*
    **  Read the data
    */


    if (lpszValueName == NULL) {
       RtlInitUnicodeString(&unicodeValueName, TEXT(""));
    } else {
       RtlInitUnicodeString(&unicodeValueName, lpszValueName);
    }

    ReturnCode = NT_SUCCESS(NtQueryValueKey(KeyHandle == NULL ?
               BaseKeyHandle : KeyHandle,
            &unicodeValueName,
            KeyValuePartialInformation,
            (PVOID)&OurKeyValueInformation,
            sizeof(OurKeyValueInformation),
            &ResultLength));

    if (ReturnCode) {
        /*
        **  Check we got the right type of data and not too much
        */

        if (OurKeyValueInformation.KeyInfo.DataLength > dwLen * sizeof(WCHAR) ||
            (OurKeyValueInformation.KeyInfo.Type != REG_SZ &&
             OurKeyValueInformation.KeyInfo.Type != REG_EXPAND_SZ)) {

            ReturnCode = FALSE;
        } else {
            /*
            **  Copy back the data
            */

            if (OurKeyValueInformation.KeyInfo.Type == REG_EXPAND_SZ) {
                lpszValue[0] = TEXT('\0');
                ExpandEnvironmentStringsW
                          ((LPCWSTR)OurKeyValueInformation.KeyInfo.Data,
                           (LPWSTR)lpszValue,
                           dwLen);
            } else {
                CopyMemory((PVOID)lpszValue,
                           (PVOID)OurKeyValueInformation.KeyInfo.Data,
                           dwLen * sizeof(WCHAR));
                lpszValue[ min(OurKeyValueInformation.KeyInfo.DataLength,
                               dwLen-1) ] = TEXT('\0');
            }
        }
    }

    if (KeyHandle) {
        NtClose(KeyHandle);
    }

    return ReturnCode;
}

/*
**  Read a mapped 'user' value in a known section
*/

BOOL mmRegQueryUserValue(LPCWSTR lpszSectionName,
                         LPCWSTR lpszValueName,
                         ULONG   dwLen,
                         LPWSTR  lpszValue)
{
    HANDLE UserHandle;
    BOOL   ReturnCode;

    /*
    **  Open the user's key.  It's important to do this EACH time because
    **  on the server it's different for different threads.
    */

    if (!NT_SUCCESS(RtlOpenCurrentUser(GENERIC_READ, &UserHandle))) {
        return FALSE;
    }


    ReturnCode = mmRegQueryValue(UserHandle,
                                 lpszSectionName,
                                 lpszValueName,
                                 dwLen,
                                 lpszValue);

    NtClose(UserHandle);

    return ReturnCode;
}


/*
**  Set a mapped 'user' value in a known section
*/

BOOL mmRegSetUserValue(LPCWSTR lpszSectionName,
                       LPCWSTR lpszValueName,
                       LPCWSTR lpszValue)
{
    HANDLE UserHandle;
    BOOL   ReturnCode = FALSE;

    /*
    **  Open the user's key.  It's important to do this EACH time because
    **  on the server it's different for different threads.
    */

    if (NT_SUCCESS(RtlOpenCurrentUser(MAXIMUM_ALLOWED, &UserHandle)))
    {
        HANDLE  KeyHandle;

        KeyHandle = mmRegOpenSubkeyForWrite (UserHandle, lpszSectionName);
        if (KeyHandle != NULL)
        {
            UNICODE_STRING ValueName;
            if (lpszValueName == NULL) {
                RtlInitUnicodeString (&ValueName, TEXT(""));
            } else {
                RtlInitUnicodeString (&ValueName, lpszValueName);
            }

            ReturnCode = NT_SUCCESS( NtSetValueKey (KeyHandle,
                                                    &ValueName,
                                                    0,
                                                    REG_SZ,
                                                    (PVOID)lpszValue,
                                                    (lstrlenW(lpszValue)+1)* sizeof(lpszValue[0])
                                                    ) );
            NtClose(KeyHandle);
        }

        NtClose(UserHandle);
    }

    return ReturnCode;
}


BOOL mmRegCreateUserKey (LPCWSTR lpszPath, LPCWSTR lpszNewKey)
{
    HANDLE UserHandle;
    BOOL   ReturnValue = FALSE;

    /*
    **  Open the user's key.  It's important to do this EACH time because
    **  on the server it's different for different threads.
    */

    if (NT_SUCCESS(RtlOpenCurrentUser(MAXIMUM_ALLOWED, &UserHandle)))
    {
        HANDLE            PathHandle;
        HANDLE            KeyHandle;
        UNICODE_STRING    unicodeSectionName;
        OBJECT_ATTRIBUTES oa;

        if (lpszPath == NULL)
        {
            PathHandle = NULL;
        }
        else
        {
            PathHandle = mmRegOpenSubkeyForWrite (UserHandle, lpszPath);
            if (PathHandle == NULL)
            {
                NtClose(UserHandle);
                return FALSE;
            }
        }


        RtlInitUnicodeString(&unicodeSectionName, lpszNewKey);
        InitializeObjectAttributes(&oa,
                                   &unicodeSectionName,
                                   OBJ_CASE_INSENSITIVE,
                                   (PathHandle == NULL)
                                      ? UserHandle : PathHandle,
                                   (PSECURITY_DESCRIPTOR)NULL);

        /*
        **  Create the sub section
        */

        if (NT_SUCCESS( NtCreateKey(&KeyHandle,
                                     KEY_READ | KEY_WRITE,
                                     &oa,
                                     0,
                                     NULL,
                                     0,
                                     NULL
                                     ) ))
        {
            if (KeyHandle)
            {
                ReturnValue = TRUE;
                NtClose (KeyHandle);
            }
        }

        if (PathHandle != NULL)
        {
            NtClose(PathHandle);
        }

        NtClose(UserHandle);
    }

    return ReturnValue;
}


/*
**  Test whether a mapped 'user' key exists
*/

BOOL mmRegQueryUserKey (LPCWSTR lpszKeyName)
{
    HANDLE UserHandle;
    BOOL   ReturnValue = FALSE;

    if (lpszKeyName == NULL)
    {
        return FALSE;
    }

    if (NT_SUCCESS(RtlOpenCurrentUser(MAXIMUM_ALLOWED, &UserHandle)))
    {
        HANDLE  KeyHandle;

        KeyHandle = mmRegOpenSubkeyForWrite (UserHandle, lpszKeyName);
        if (KeyHandle != NULL)
        {
            ReturnValue = TRUE;
            NtClose(KeyHandle);
        }

        NtClose(UserHandle);
    }

    return ReturnValue;
}


/*
**  Delete a mapped 'user' key.  Careful--this function deletes recursively!
*/

#define nMaxLevelsToRecurseInDELETEKEY 3   // don't runaway or stack fault

BOOL mmRegDeleteUserKeyRecurse (HANDLE UserHandle, LPCWSTR lpszName, int level)
{
    HANDLE KeyHandle;

    if (lpszName == NULL)
    {
        return FALSE;
    }
    if (level > nMaxLevelsToRecurseInDELETEKEY)
    {
        return FALSE;
    }

    if ((KeyHandle = mmRegOpenSubkeyForWrite (UserHandle, lpszName)) != NULL)
    {
        struct {
            KEY_BASIC_INFORMATION kbi;
            WCHAR NameBuffer [MAX_PATH];
        } kbi;

        /*
        ** Before NtDeleteKey() will work on this key, we have to ensure
        ** there are no subkeys.
        */

        while (TRUE)
        {
            ULONG  cbReturned = 0L;
            WCHAR  szSubKeyName[ MAX_PATH ];

            ZeroMemory (&kbi, sizeof(kbi));

            if (!NT_SUCCESS(NtEnumerateKey(KeyHandle,
                                           0,
           KeyBasicInformation,
           (PVOID)&kbi,
           sizeof(kbi),
           &cbReturned)))
            {
                break;
            }

            wsprintf (szSubKeyName, L"%ls\\%ls", lpszName, kbi.kbi.Name);

            if (!mmRegDeleteUserKeyRecurse (UserHandle, szSubKeyName, 1+level))
            {
                NtClose (KeyHandle);
                return FALSE;
            }
        }

        /*
        ** Once there are no subkeys, we should be able to delete this key.
        */

        if (NT_SUCCESS(NtDeleteKey(KeyHandle)))
        {
            NtClose(KeyHandle);
            return TRUE;
        }

        NtClose(KeyHandle);
    }

    return FALSE;
}


BOOL mmRegDeleteUserKey (LPCWSTR lpszKeyName)
{
    HANDLE UserHandle;
    BOOL   ReturnValue = FALSE;

    if (lpszKeyName == NULL)
    {
        return FALSE;
    }

    if (NT_SUCCESS(RtlOpenCurrentUser(MAXIMUM_ALLOWED, &UserHandle)))
    {
        ReturnValue = mmRegDeleteUserKeyRecurse (UserHandle, lpszKeyName, 1);

        NtClose(UserHandle);
    }

    return ReturnValue;
}


/*
**  Read a mapped 'HKLM' value in a known section
*/

BOOL mmRegQueryMachineValue(LPCWSTR lpszSectionName,
                            LPCWSTR lpszValueName,
                            ULONG   dwLen,
                            LPWSTR  lpszValue)
{
    WCHAR  FullKeyName[MAX_PATH];
    HANDLE HostHandle;
    BOOL   ReturnCode = FALSE;

    lstrcpyW (FullKeyName, L"\\Registry\\Machine\\");
    wcsncat (FullKeyName, lpszSectionName, (MAX_PATH - wcslen(FullKeyName) - 1));

    if ((HostHandle = mmRegOpenSubkey (NULL, FullKeyName)) != NULL)
    {
        ReturnCode = mmRegQueryValue (HostHandle,
                                      lpszSectionName,
                                      lpszValueName,
                                      dwLen,
                                      lpszValue);

        NtClose (HostHandle);
    }

    return ReturnCode;
}


/*
**  Write a mapped 'HKLM' value in a known section
*/

BOOL mmRegSetMachineValue(LPCWSTR lpszSectionName,
                          LPCWSTR lpszValueName,
                          LPCWSTR lpszValue)
{
    WCHAR  FullKeyName[MAX_PATH];
    HANDLE HostHandle;
    BOOL   ReturnCode = FALSE;

    lstrcpyW (FullKeyName, L"\\Registry\\Machine\\");
    wcsncat (FullKeyName, lpszSectionName, (MAX_PATH - wcslen(FullKeyName) - 1));

    if ((HostHandle = mmRegOpenSubkeyForWrite (NULL, FullKeyName)) != NULL)
    {
        UNICODE_STRING ValueName;
        if (lpszValueName == NULL) {
            RtlInitUnicodeString (&ValueName, TEXT(""));
        } else {
            RtlInitUnicodeString (&ValueName, lpszValueName);
        }

        ReturnCode = NT_SUCCESS( NtSetValueKey (HostHandle,
                                                &ValueName,
                                                0,
                                                REG_SZ,
                                                (PVOID)lpszValue,
                                                (lstrlenW(lpszValue)+1)* sizeof(lpszValue[0])
                                                ) );

        NtClose(HostHandle);
    }

    return ReturnCode;
}


BOOL mmRegCreateMachineKey (LPCWSTR lpszPath, LPCWSTR lpszNewKey)
{
    WCHAR  FullKeyName[MAX_PATH];
    HANDLE HostHandle;
    BOOL   ReturnValue = FALSE;

    lstrcpyW (FullKeyName, L"\\Registry\\Machine\\");
    wcsncat (FullKeyName, lpszPath, (MAX_PATH - wcslen(FullKeyName) - 1));

    if ((HostHandle = mmRegOpenSubkeyForWrite (NULL, FullKeyName)) != NULL)
    {
        HANDLE            KeyHandle;
        UNICODE_STRING    unicodeSectionName;
        OBJECT_ATTRIBUTES oa;

        RtlInitUnicodeString(&unicodeSectionName, lpszNewKey);
        InitializeObjectAttributes(&oa,
                                   &unicodeSectionName,
                                   OBJ_CASE_INSENSITIVE,
                                   HostHandle,
                                   (PSECURITY_DESCRIPTOR)NULL);

        /*
        **  Create the sub section
        */

        if (NT_SUCCESS( NtCreateKey(&KeyHandle,
                                     KEY_READ | KEY_WRITE,
                                     &oa,
                                     0,
                                     NULL,
                                     0,
                                     NULL
                                     ) ))
        {
            if (KeyHandle)
            {
                ReturnValue = TRUE;
                NtClose (KeyHandle);
            }
        }

        NtClose(HostHandle);
    }

    return ReturnValue;
}




/*
**  Read stuff from system.ini
*/

BOOL mmRegQuerySystemIni(LPCWSTR lpszSectionName,
                         LPCWSTR lpszValueName,
                         ULONG   dwLen,
                         LPWSTR  lpszValue)
{
    WCHAR KeyPathBuffer[MAX_PATH];
    WCHAR ExKeyPathBuffer[MAX_PATH];

    /*
    **  Create the full path
    */

    lstrcpy(KeyPathBuffer,
     (LPCTSTR) L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\");

    wcsncat(KeyPathBuffer, lpszSectionName, (MAX_PATH - wcslen(KeyPathBuffer) - 1));

    if (lstrcmpiW(lpszSectionName, wszDrivers) == 0) {

     //
     //  for remote session, look ..\terminal Server\RDP (or other protocols) for drivers32
     //  name
     //
     //
        if (WinmmRunningInSession) {
            lstrcat(KeyPathBuffer,L"\\");
            lstrcat(KeyPathBuffer, REG_TSERVER);
            lstrcat(KeyPathBuffer,L"\\");
            lstrcat(KeyPathBuffer, SessionProtocolName);
        }

        if (Drivers32Handle == NULL) {
            Drivers32Handle = mmRegOpenSubkey(NULL, KeyPathBuffer);
        }

        if (Drivers32Handle != NULL) {
            BOOL rc;

            rc = mmRegQueryValue(Drivers32Handle,
                                   NULL,
                                   lpszValueName,
                                   dwLen,
                                   lpszValue);

            //
            //  If we can't find the codec in the TermSrv protocol path
            //  we will look under Driver32 next
            //
            if (rc == FALSE && WinmmRunningInSession &&
                    _wcsnicmp(lpszValueName, gszMsacmDriver, lstrlen(gszMsacmDriver)) == 0) {                   
                HANDLE hKey;

                /*
                **  Create the full path
                */
            
                lstrcpy(KeyPathBuffer,
                 (LPCTSTR) L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\");
            
                lstrcat(KeyPathBuffer, lpszSectionName);

                hKey = mmRegOpenSubkey(NULL, KeyPathBuffer);

                if (hKey != NULL) {
                    rc = mmRegQueryValue(hKey,
                                   NULL,
                                   lpszValueName,
                                   dwLen,
                                   lpszValue);                    

                    RegCloseKey(hKey);
                    return rc;

                }
                else {
                    return FALSE;
                }
            }
            else {
                return rc;
            }
        } else {
            return FALSE;
        }
    }

    if (WinmmRunningInSession) {
        if (lstrcmpiW(lpszSectionName, MCI_SECTION) == 0) {

            memset(ExKeyPathBuffer, 0 , sizeof(ExKeyPathBuffer));
            lstrcpy(ExKeyPathBuffer, KeyPathBuffer);
            lstrcat(ExKeyPathBuffer,L"\\");
            lstrcat(ExKeyPathBuffer, REG_TSERVER);
            lstrcat(ExKeyPathBuffer,L"\\");
            lstrcat(ExKeyPathBuffer, SessionProtocolName);

            /*  look through terminal server section for drivers information first */
            if (mmRegQueryValue(NULL, ExKeyPathBuffer, lpszValueName, dwLen, lpszValue))
                return TRUE;
            else {
            /* pick the system default drivers information */
                return mmRegQueryValue(NULL, KeyPathBuffer, lpszValueName, dwLen, lpszValue);
            }
        }
    }

    return mmRegQueryValue(NULL, KeyPathBuffer, lpszValueName, dwLen, lpszValue);
}

/*
**  Translate name through sounds section
*/

BOOL mmRegQuerySound(LPCWSTR lpszSoundName,
                     ULONG   dwLen,
                     LPWSTR  lpszValue)
{
    WCHAR KeyPathBuffer[MAX_PATH];

    lstrcpy(KeyPathBuffer, (LPCWSTR)L"Control Panel\\");
    lstrcat(KeyPathBuffer, szSoundSection);

    return mmRegQueryUserValue(KeyPathBuffer,
                               lpszSoundName,
                               dwLen,
                               lpszValue);
}

BOOL IsAliasName(LPCWSTR lpSection, LPCWSTR lpKeyName)
{

    if ((!wcsncmp(lpKeyName, L"wave", 4)) ||
        (!wcsncmp(lpKeyName, L"midi", 4)) ||
        (!wcsncmp(lpKeyName, L"aux", 3 )) ||	
        (!wcsncmp(lpKeyName, L"mixer",5)) ||
        (!wcsncmp(lpKeyName, L"msacm",5)) ||
        (!wcsncmp(lpKeyName, L"vidc",4)) ||
        (!wcsncmp(lpKeyName, L"midimapper", 10)) ||
        (!wcsncmp(lpKeyName, L"wavemapper", 10)) ||
        (!wcsncmp(lpKeyName, L"auxmapper", 9 ))  ||	
        (!wcsncmp(lpKeyName, L"mixermapper", 11)))
    {
        return TRUE;
    }
    else
    {
        if (lstrcmpiW( lpSection, (LPCWSTR)MCI_HANDLERS) == 0L)
        {
            UINT    n = lstrlen(lpKeyName);
            
            for (; n > 0; n--)
            {
                //  Found a '.' which implies and extension, which implies a
                //  file.
            
                if ('.' == lpKeyName[n-1])
                {
                    return FALSE;
                }
            }
            
            //  Searched the string for '.'.
            //  None so it is an alias (that is -- not filename)
            return TRUE;
        }
    
        if (lstrcmpiW( lpSection, (LPCWSTR)wszDrivers) == 0L)
        {
            WCHAR   szFileName[MAX_PATH];
            //  It could be something REALLY off the wall, like "ReelDrv"
            
            return (mmRegQuerySystemIni(lpSection, lpKeyName, MAX_PATH, szFileName));
        }
    
        return FALSE;
    }
}

/*****************************Private*Routine******************************\
* MyGetPrivateProfileString
*
* Attempt to bypass stevewo's private profile stuff.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
DWORD
winmmGetPrivateProfileString(
    LPCWSTR lpSection,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR  lpReturnedString,
    DWORD   nSize,
    LPCWSTR lpFileName
)
{
    WCHAR       szFileName[MAX_PATH];

    /*                                  
    ** for now just look for to the [Drivers32] section of system.ini
    */

    if ( (lstrcmpiW( lpFileName, wszSystemIni ) == 0L)
      && ( ( lstrcmpiW( lpSection, wszDrivers ) == 0L ) ||
           ( lstrcmpiW( lpSection, (LPCWSTR)MCI_HANDLERS) == 0L ) ) ) {

		if (IsAliasName(lpSection, lpKeyName))
		{
			if (mmRegQuerySystemIni(lpSection, lpKeyName, nSize, lpReturnedString)) 
			{
				return lstrlen(lpReturnedString);
			} 
			else
			{
				return 0;
			}
		}
		else 
		{
            UINT    ii;
            HANDLE  hFile;

            lstrcpyW(szFileName, lpKeyName);

            for (ii = 0; 0 != szFileName[ii]; ii++)
            {
                if(' ' == szFileName[ii])
                {
                    //  Truncate parameters...

                    szFileName[ii] = 0;
                    break;
                }
            }

            hFile = CreateFile(
                        szFileName,
                        0,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

            if(INVALID_HANDLE_VALUE != hFile)
            {
                CloseHandle(hFile);
                wcsncpy(lpReturnedString, lpKeyName, nSize);
                return (lstrlenW(lpKeyName));
            }
            else
            {
                //  Okay was it a full file path?

                for(ii = 0; 0 != szFileName[ii]; ii++)
                {
                    if ('\\' == szFileName[ii])
                    {
                        //  Probably...

                        break;
                    }
                }

                if ('\\' != szFileName[ii])
                {
                    WCHAR       szStub[MAX_PATH];
                    LPWSTR      pszFilePart;
                    
                    lstrcpyW(szStub, lpKeyName);
                    for(ii = 0; 0 != szStub[ii]; ii++)
                    {
                        if(' ' == szStub[ii])
                        {
                            //  Truncate parameters...

                            szStub[ii] = 0;
                            break;
                        }
                    }
                    
                    if (!SearchPathW(NULL,
                                    szStub,
                                    NULL,
                                    MAX_PATH,
                                    szFileName,
                                    &pszFilePart))
                    {
                        return (0);
                    }

                    hFile = CreateFile(
                                szFileName,
                                0,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

                    if(INVALID_HANDLE_VALUE != hFile)
                    {
                        CloseHandle(hFile);
                        wcsncpy(lpReturnedString, lpKeyName, nSize);
                        return (lstrlenW(lpKeyName));
                    }
                }
            }

            if (lpDefault != NULL) {
                wcsncpy(lpReturnedString, lpDefault, nSize);
            }
            return 0;
        }
    }
    else {

        return GetPrivateProfileStringW( lpSection, lpKeyName, lpDefault,
                                         lpReturnedString, nSize, lpFileName );

    }
}

DWORD
winmmGetProfileString(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR  lpReturnedString,
    DWORD nSize
)
{

    /*
    **  See if it's one we know about
    */

    if (lstrcmpiW(lpAppName, szSoundSection) == 0) {

        if (mmRegQuerySound(lpKeyName, nSize, lpReturnedString)) {
            return lstrlen(lpReturnedString);
        } else {
            if (lpDefault != NULL) {
                wcsncpy(lpReturnedString, lpDefault, nSize);
            }
            return FALSE;
        }
    } else {
        return GetProfileString(lpAppName,
                                lpKeyName,
                                lpDefault,
                                lpReturnedString,
                                nSize);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\time.c ===
/******************************************************************************

   Copyright (c) 1985-1999 Microsoft Corporation

   Title:   TIME.C : WINMM TIMER API

   Version: 1.00

   History:

       21 Feb 1992 - Robin Speed (RobinSp) converted to Windows NT

*****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "winmmi.h"
#define _INC_ALL_WOWSTUFF
#include "mmwow32.h"

/****************************************************************************

    Structure shared between timer APIs and timer thread

****************************************************************************/

#define TDD_MINRESOLUTION 55        // in milliseconds
UINT TDD_MAXRESOLUTION;             // Should be 2 ... But ...

#define TDD_MAXPERIOD 1000000       // 1000 seconds
#define TDD_MINPERIOD TDD_MAXRESOLUTION   // Some apps assume this.

#define TIMER_STACK_SIZE 300

HANDLE hTimerThread;       // we need this to be global

#define ROUND_MIN_TIME_TO_MS(x)  (((x) + 9900) / 10000) // Special sloppy round
DWORD  MinimumTime;        // Kernel's version of the max res in 100ns units

typedef volatile struct {
    UINT             Delay;           // App requested delay (ms)
    UINT             Resolution;      // App requested resolution (ms)
    LPTIMECALLBACK   Callback;        // Whom to call when timer fires
    DWORD_PTR        User;            // Data to pass back when timer fires
    UINT             Id;              // Id allocated (bottom 4 bits = slot
                                      // id.
    UINT             Flags;           // App's option flags
    HANDLE           TimerHandle;     // Handle given to APP
    DWORD            ThreadId;        // Id of requestor thread (WOW cleanup)
    LARGE_INTEGER    FireTime;        // Time it should fire
    BOOL             IsWOW;           // For WOW events
} TIMER_EVENT;

//
// Data integrity
//

// Held while handling resolution.  ResolutionCritSec should always be 
// held when using TimerData.PeriodSlots, TimerData.CurrentPeriod and
// TimerData.CurrentActualPeriod.
CRITICAL_SECTION ResolutionCritSec;

// This critical section should be held when using Events, 
// TimerData.TimerNotCallingCallbackEvent, TimerData.CallbackTimerID 
// and TimerData.EventCount.  The critical section should also be held 
// while creating the timer thread.  This ensures that only one timer 
// thread is created.  This critical section should not be acquired if
// a thread already owns the ResolutionCritSec.  A deadlock will occur
// if this critical section is acquired after the ResolutionCritSec
// is acquired.
CRITICAL_SECTION TimerThreadCritSec;

DWORD TimerThreadId;

//
// Data used to communicate with timer thread and within timer thread
//

struct {
    //
    // Thread control (timerThread)
    //
    HANDLE           Event1;          // Synch event - schedules thread
    BOOL             Started;         // So WOW Cleanup doesn't deadlock

    UINT CallbackTimerID;             // The ID of the timer which is currently calling its' callback function.
                                      // This value is only valid if TimerCallingCallback is TRUE.
    BOOL TimerCallingCallback;        // TRUE if a timer is calling its' callback function on the timer thread. 
                                      // Otherwise FALSE.
    HANDLE TimerNotCallingCallbackEvent;  // This event is set if no timer is calling its' callback function on
                                          // the timer thread.  Otherwise it is not set.

    //
    // timeGetTime stuff
    //
    BOOL             UseTickCount;
    LARGE_INTEGER    InitialInterruptTick;
    DWORD            StartTick;
    DWORD            MinResolution;

    //
    // Internal to thread
    //
    UINT             CurrentPeriod;   // Current min res in ms
    DWORD            CurrentActualPeriod;
                                      // What the kernel gave us in ms
                                      // units
    DWORD            ThreadToKill;    // For WOW cleanup
    WORD             EventCount;      // For returning (fairly) unique handles
                                      // Make this WORD for WOW compatiblity
    WORD             PeriodSlots[TDD_MINRESOLUTION];

                                     // Count of what periods are set
} TimerData;

#define MAX_TIMER_EVENTS 16

TIMER_EVENT Events[MAX_TIMER_EVENTS];


/****************************************************************************

    Internal functions

****************************************************************************/
BOOL TimeInitThread(void);
void TimerCompletion(UINT TimerId);
BOOL timeSetTimerEvent(TIMER_EVENT *pEvent);
DWORD timeThread(LPVOID lpParameter);
LRESULT timeThreadSetEvent(TIMER_EVENT *pEvent);
void InitializeWaitEventArrays
    (
    UINT* pcObjects,
    HANDLE aTimers[MAX_TIMER_EVENTS + 1],
    UINT aEventIndexToTimerIDTable[MAX_TIMER_EVENTS+1]
    );

/*
**  Read the interrupt time from the kernel
*/

static LONGLONG __inline ReadInterruptTick(VOID) {
    LARGE_INTEGER InterruptTime;

    // Copy the interrupt time, verifying that the 64 bit quantity (copied
    // in two 32 bit operations) remains valid.
    // This may mean we need to iterate around the loop.
    do {
        InterruptTime.HighPart = USER_SHARED_DATA->InterruptTime.High1Time;
        InterruptTime.LowPart = USER_SHARED_DATA->InterruptTime.LowPart;
    } while (InterruptTime.HighPart != USER_SHARED_DATA->InterruptTime.High2Time);

    return InterruptTime.QuadPart;
}

/*
**  Calibrate our timer
*/
VOID CalibrateTimer(VOID)
{
    //
    // Find out the current time(s)
    //
    UINT n = 100;

    // We calibrate the timer by making sure that the tick count and
    // interrupt tick count are in step with each other.  Just in case
    // the hardware goes funny we put a limit on the number of times we
    // execute the loop.
    while (n) {
        DWORD EndTick;

        --n;
        TimerData.StartTick = GetCurrentTime();

        TimerData.InitialInterruptTick.QuadPart = ReadInterruptTick();

        EndTick = GetCurrentTime();

        if (EndTick == TimerData.StartTick) {
            dprintf2(("Timer calibrated, looped %d times", 100-n));
            break;
        }
    }
}


//  Calling this effectively leaks WINMM and makes sure we never
//  go through the DLL exit routine
//  This is used so we don't deadlock with shutting down our global threads
BOOL LoadWINMM()
{
    TCHAR sz[1000];
    BOOL bOK = 0 != GetModuleFileName(ghInst, sz, sizeof(sz) / sizeof(sz[0]));
    if (bOK) {
        HINSTANCE hInst = LoadLibrary(sz);
        if (hInst != NULL) {
            // ASSERT(hInst == ghInst);
        } else {
            bOK = FALSE;
        }
    }
    return bOK;
}

/****************************************************************************

    @doc INTERNAL

    @api BOOL | TimeInit | This function initialises the timer services.

    @rdesc The return value is TRUE if the services are initialised, FALSE
        if an error occurs.

    @comm it is not a FATAL error if a timer driver is not installed, this
          routine will allways return TRUE

****************************************************************************/

BOOL NEAR PASCAL TimeInit(void)
{
    //
    // Find out the maximum timer resolution we can support
    //
    {
        DWORD MaximumTime;
        DWORD CurrentTime;

        TimerData.MinResolution = TDD_MINRESOLUTION;

        if (!NT_SUCCESS(NtQueryTimerResolution(
                            &MaximumTime,
                            &MinimumTime,
                            &CurrentTime))) {


            TDD_MAXRESOLUTION = 10;     // was 16 for NT 3.1, 10 for NT 3.5
            dprintf2(("Kernel timer : using default maximum resolution"));
        } else {
            dprintf2(("               MaximumTime = %d", MaximumTime));
            dprintf2(("               CurrentTime = %d", CurrentTime));

            if ((MaximumTime + 9999) / 10000 < TDD_MINRESOLUTION) {
                TimerData.MinResolution = (MaximumTime + 9999) / 10000;
            }
            //
            //  On the x86 it's just over 1ms minimum to we allow a little
            //  leeway
            //
            TDD_MAXRESOLUTION = max(1, ROUND_MIN_TIME_TO_MS(MinimumTime));
        }
    }

    //
    //  Compute the relationship between our timer and the performance
    //  counter
    //
    CalibrateTimer();

    //
    //  Start out slowly !
    //
    TimerData.CurrentPeriod = TimerData.MinResolution;
    TimerData.CurrentActualPeriod = TimerData.CurrentPeriod;

    return TRUE;
}

/****************************************************************************

    @doc INTERNAL

    @api BOOL | TimeInitThread | This function initialises the timer thread.

    @rdesc The return value is TRUE if the services are initialised, FALSE
        if an error occurs.

    @comm it is not a FATAL error if a timer driver is not installed, this
          routine will allways return TRUE

****************************************************************************/

BOOL TimeInitThread(void)
{
    //  Make sure winmm never gets unloaded
    if (!LoadWINMM()) {
        return FALSE;
    }

    //
    // Set up events and create our thread
    //
    if (!NT_SUCCESS(NtCreateEvent(&TimerData.Event1,
                                  EVENT_ALL_ACCESS,
                                  NULL,
                                  SynchronizationEvent,
                                  FALSE))) {   // Not signalled
        return FALSE;
    }

    // Create an unnamed signaled manual reset event.  
    TimerData.TimerNotCallingCallbackEvent = CreateEvent(NULL, TRUE, TRUE, NULL);

    // CreateEvent() returns NULL if an error occurs.
    if (!TimerData.TimerNotCallingCallbackEvent) {
        NtClose(TimerData.Event1);
        TimerData.Event1 = NULL;
        return FALSE;
    }

    //
    // The thread will start up and wait on Event1 (alertably)
    //
    hTimerThread = CreateThread(NULL,
                           TIMER_STACK_SIZE,
                           timeThread,
                           NULL,
                           THREAD_SET_INFORMATION,
                           &TimerThreadId);
    if (!hTimerThread) {
        CloseHandle(TimerData.TimerNotCallingCallbackEvent);
        NtClose(TimerData.Event1);
        TimerData.TimerNotCallingCallbackEvent = NULL;
        TimerData.Event1 = NULL;
        return FALSE;
    }


    SetThreadPriority(hTimerThread, THREAD_PRIORITY_TIME_CRITICAL);


    return TRUE;
}

/****************************************************************************

    @doc EXTERNAL

    @api MMRESULT | timeGetSystemTime | This function retrieves the system time
    in milliseconds.  The system time is the time elapsed since
    Windows was started.

    @parm LPMMTIME | lpTime | Specifies a far pointer to an <t MMTIME> data
    structure.

    @parm UINT | wSize | Specifies the size of the <t MMTIME> structure.

    @rdesc Returns zero.
    The system time is returned in the <e MMTIME.ms> field of the <t MMTIME>
    structure.

    @comm The time is always returned in milliseconds.

    @xref timeGetTime
****************************************************************************/

MMRESULT APIENTRY timeGetSystemTime(LPMMTIME lpTime, UINT wSize)
{
    //
    // !!!WARNING DS is not setup right!!! see above
    //
    if (wSize < sizeof(MMTIME))
        return TIMERR_STRUCT;

    if (!ValidateWritePointer(lpTime,wSize)) {
        return TIMERR_STRUCT;
    }

    lpTime->u.ms  = timeGetTime();
    lpTime->wType = TIME_MS;

    return TIMERR_NOERROR;
}

/****************************************************************************

    @doc EXTERNAL

    @api UINT | timeSetEvent | This function sets up a timed callback event.
    The event can be a one-time event or a periodic event.  Once activated,
    the event calls the specified callback function.

    @parm UINT | wDelay | Specifies the event period in milliseconds.
    If the delay is less than the minimum period supported by the timer,
    or greater than the maximum period supported by the timer, the
    function returns an error.

    @parm UINT | wResolution | Specifies the accuracy of the delay in
    milliseconds. The resolution of the timer event increases with
    smaller <p wResolution> values. To reduce system overhead, use
    the maximum <p wResolution> value appropriate for your application.

    @parm LPTIMECALLBACK | lpFunction | Specifies the procedure address of
    a callback function that is called once upon expiration of a one-shot
    event or periodically upon expiration of periodic events.

    @parm DWORD | dwUser | Contains user-supplied callback data.

    @parm UINT | wFlags | Specifies the type of timer event, using one of
    the following flags:

    @flag TIME_ONESHOT | Event occurs once, after <p wPeriod> milliseconds.

    @flag TIME_PERIODIC | Event occurs every <p wPeriod> milliseconds.

    @rdesc Returns an ID code that identifies the timer event. Returns
    NULL if the timer event was not created. The ID code is also passed to
        the callback function.

    @comm Using this function to generate a high-frequency periodic-delay
    event (with a period less than 10 milliseconds) can consume a
        significant portion of the system CPU bandwidth.  Any call to
    <f timeSetEvent> for a periodic-delay timer
    must be paired with a call to <f timeKillEvent>.

    The callback function must reside in a DLL.  You don't have to use
    <f MakeProcInstance> to get a procedure-instance address for the callback
    function.

    @cb void CALLBACK | TimeFunc | <f TimeFunc> is a placeholder for the
    application-supplied function name.  The actual name must be exported by
    including it in the EXPORTS statement of the module-definition file for
    the DLL.

    @parm UINT | wID | The ID of the timer event.  This is the ID returned
       by <f timeSetEvent>.

    @parm UINT | wMsg | Not used.

    @parm DWORD | dwUser | User instance data supplied to the <p dwUser>
    parameter of <f timeSetEvent>.

    @parm DWORD | dw1 | Not used.

    @parm DWORD | dw2 | Not used.

    @comm Because the callback is accessed at interrupt time, it must
    reside in a DLL, and its code segment must be specified as FIXED
    in the module-definition file for the DLL.  Any data that the
    callback accesses must be in a FIXED data segment as well.
    The callback may not make any system calls except for <f PostMessage>,
    <f timeGetSystemTime>, <f timeGetTime>, <f timeSetEvent>,
    <f timeKillEvent>, <f midiOutShortMsg>,
    <f midiOutLongMsg>, and <f OutputDebugStr>.

    @xref timeKillEvent timeBeginPeriod timeEndPeriod

****************************************************************************/

UINT APIENTRY timeSetEvent(UINT wDelay, UINT wResolution,
    LPTIMECALLBACK lpFunction, DWORD_PTR dwUser, UINT wFlags)
{

    // verify the input flags
    // first remove the callback type, then check that only
    // time_periodic or time_oneshot are specified
    if (wFlags & ~(TIME_CALLBACK_TYPEMASK | TIME_ONESHOT | TIME_PERIODIC | TIME_KILL_SYNCHRONOUS)) {
        return(0);
    }

    return timeSetEventInternal(wDelay, wResolution, lpFunction,
                                dwUser, wFlags, FALSE);
}

UINT timeSetEventInternal(UINT wDelay, UINT wResolution,
    LPTIMECALLBACK lpFunction, DWORD_PTR dwUser, UINT wFlags, BOOL IsWOW)
{
    UINT TimerId;       // Our return value
    TIMER_EVENT Event;  // Event data for thread

    // V_TCALLBACK(lpFunction, MMSYSERR_INVALPARAM);

    //
    // First check our parameters
    //

    if (wDelay > TDD_MAXPERIOD || wDelay < TDD_MINPERIOD) {
        return 0;
    }

    //
    // if resolution is 0 set default resolution, otherwise
    // make sure the resolution is in range
    //

    if (wResolution > TimerData.MinResolution) {
        wResolution = TimerData.MinResolution;
    } else {
        if (wResolution < TDD_MAXRESOLUTION) {
            wResolution = TDD_MAXRESOLUTION;
        }
    }

    if (wResolution > wDelay) {
        wResolution = TimerData.MinResolution;
    }

    //
    // Remember time if it's periodic so we get accurate long term
    // timing.  Otherwise we'll just use the delay.
    //

    if ((wFlags & TIME_PERIODIC) || IsWOW) {
        Event.FireTime.QuadPart = ReadInterruptTick();
    }
    Event.Delay      = wDelay;
    Event.Resolution = wResolution;
    Event.Callback   = lpFunction;
    Event.User       = dwUser;
    Event.Flags      = wFlags;
    Event.ThreadId   = GetCurrentThreadId();  // For WOW cleanup
    Event.IsWOW      = IsWOW;

    //
    // Now set up the period to be used
    //
    if (timeBeginPeriod(wResolution) == MMSYSERR_NOERROR) {

        EnterCriticalSection(&TimerThreadCritSec);
        
        if (NULL == TimerData.Event1)
        {
            if (!TimeInitThread())
            {
                LeaveCriticalSection(&TimerThreadCritSec);            
                return(0);
            }
        }

        TimerId = (UINT)timeThreadSetEvent(&Event);

        LeaveCriticalSection(&TimerThreadCritSec);

        //
        // If we didn't get a good id give up
        //
        if (TimerId == 0) {
            timeEndPeriod(wResolution);
        }
    } else {
        TimerId = 0;
    }

    return TimerId;
}

/****************************************************************************

    @doc EXTERNAL

    @api MMRESULT | timeGetDevCaps | This function queries the timer device to
    determine its capabilities.

    @parm LPTIMECAPS | lpTimeCaps | Specifies a far pointer to a
        <t TIMECAPS> structure.  This structure is filled with information
        about the capabilities of the timer device.

    @parm UINT | wSize | Specifies the size of the <t TIMECAPS> structure.

    @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if it fails
    to return the timer device capabilities.

****************************************************************************/

MMRESULT APIENTRY timeGetDevCaps(LPTIMECAPS lpTimeCaps, UINT wSize)
{
    if (wSize < sizeof(TIMECAPS)) {
        return TIMERR_NOCANDO;
    }

    if (!ValidateWritePointer(lpTimeCaps, wSize)) {
        return TIMERR_NOCANDO;
    }

    lpTimeCaps->wPeriodMin = TDD_MINPERIOD;
    lpTimeCaps->wPeriodMax = TDD_MAXPERIOD;
    return MMSYSERR_NOERROR;
}

/****************************************************************************

    @doc EXTERNAL

    @api MMRESULT | timeBeginPeriod | This function sets the minimum (lowest
    number of milliseconds) timer resolution that an application or
    driver is going to use. Call this function immediately before starting
    to use timer-event services, and call <f timeEndPeriod> immediately
    after finishing with the timer-event services.

    @parm UINT | wPeriod | Specifies the minimum timer-event resolution
    that the application or driver will use.

    @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if the specified
    <p wPeriod> resolution value is out of range.

    @xref timeEndPeriod timeSetEvent

    @comm For each call to <f timeBeginPeriod>, you must call
    <f timeEndPeriod> with a matching <p wPeriod> value.
    An application or driver can make multiple calls to <f timeBeginPeriod>,
    as long as each <f timeBeginPeriod> call is matched with a
    <f timeEndPeriod> call.

****************************************************************************/
MMRESULT APIENTRY timeBeginPeriod(UINT uPeriod)
{

    dprintf3(("timeBeginPeriod %d", uPeriod));
    dprintf4(("     CurrentPeriod = %d, CurrentActualPeriod = %d",
              TimerData.CurrentPeriod, TimerData.CurrentActualPeriod));

    //
    // See if period is in our range
    //
    if (uPeriod < TDD_MAXRESOLUTION) {
        return TIMERR_NOCANDO;
    }

    if (uPeriod >= TimerData.MinResolution) {
        return MMSYSERR_NOERROR;
    }

    EnterCriticalSection(&ResolutionCritSec);

    //
    // See what's happening in our slot
    //
    if (TimerData.PeriodSlots[uPeriod - TDD_MAXRESOLUTION] ==
        0xFFFF) {
        //
        // Overflowed
        //
        LeaveCriticalSection(&ResolutionCritSec);
        return TIMERR_NOCANDO;
    }

    TimerData.PeriodSlots[uPeriod - TDD_MAXRESOLUTION]++;

    if (TimerData.PeriodSlots[uPeriod - TDD_MAXRESOLUTION] == 1 &&
        uPeriod < TimerData.CurrentActualPeriod) {

        DWORD NewPeriod100ns;

        //
        // Set the new period in our kernel driver handle
        // If it's just out then use the actual minimum
        //

        dprintf4(("timeBeginPeriod: setting resolution %d", uPeriod));

        NewPeriod100ns = uPeriod * 10000;
        if (NewPeriod100ns < MinimumTime) {
            NewPeriod100ns = MinimumTime;
        }

        if (!NT_SUCCESS(NtSetTimerResolution(
                            NewPeriod100ns,
                            TRUE,
                            &NewPeriod100ns))) {
            dprintf1(("timeBeginPeriod: Failed to set period %d", uPeriod));
            TimerData.PeriodSlots[uPeriod - TDD_MAXRESOLUTION]--;
            LeaveCriticalSection(&ResolutionCritSec);
            return TIMERR_NOCANDO;
        } else {
            //
            // This slot is just started to be used and is higher
            // resolution that currently set
            //

            TimerData.CurrentPeriod = uPeriod;
            TimerData.CurrentActualPeriod =
                                       ROUND_MIN_TIME_TO_MS(NewPeriod100ns);
            LeaveCriticalSection(&ResolutionCritSec);
            return MMSYSERR_NOERROR;
        }
    } else {
        //
        // No need to set period as it's already set
        //
        LeaveCriticalSection(&ResolutionCritSec);
        return MMSYSERR_NOERROR;
    }
}

/****************************************************************************

    @doc EXTERNAL

    @api MMRESULT | timeEndPeriod | This function clears a previously set
    minimum (lowest number of milliseconds) timer resolution that an
    application or driver is going to use. Call this function
    immediately after using timer event services.

    @parm UINT | wPeriod | Specifies the minimum timer-event resolution
    value specified in the previous call to <f timeBeginPeriod>.

    @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if the specified
    <p wPeriod> resolution value is out of range.

    @xref timeBeginPeriod timeSetEvent

    @comm For each call to <f timeBeginPeriod>, you must call
    <f timeEndPeriod> with a matching <p wPeriod> value.
    An application or driver can make multiple calls to <f timeBeginPeriod>,
    as long as each <f timeBeginPeriod> call is matched with a
    <f timeEndPeriod> call.

****************************************************************************/
MMRESULT APIENTRY timeEndPeriod(UINT uPeriod)
{

    dprintf3(("timeEndPeriod %d", uPeriod));
    dprintf4(("     CurrentPeriod = %d, CurrentActualPeriod = %d",
              TimerData.CurrentPeriod, TimerData.CurrentActualPeriod));

    //
    // Round the period to our range
    //
    if (uPeriod < TDD_MAXRESOLUTION) {
        return TIMERR_NOCANDO;
    }

    if (uPeriod >= TimerData.MinResolution) {
        return MMSYSERR_NOERROR;
    }

    EnterCriticalSection(&ResolutionCritSec);

    //
    // See what's happening in our slot
    //
    if (TimerData.PeriodSlots[uPeriod - TDD_MAXRESOLUTION] == 0) {
        //
        // Oops ! Overflowed
        //
        LeaveCriticalSection(&ResolutionCritSec);
        return TIMERR_NOCANDO;
    }

    TimerData.PeriodSlots[uPeriod - TDD_MAXRESOLUTION]--;

    if (TimerData.PeriodSlots[uPeriod - TDD_MAXRESOLUTION] == 0 &&
        uPeriod == TimerData.CurrentPeriod) {

        DWORD CurrentTime;

        //
        // This slot is just finished and was the fastest
        // so find the next fastest
        //

        for (;uPeriod < TimerData.MinResolution; uPeriod++) {
            if (TimerData.PeriodSlots[uPeriod - TDD_MAXRESOLUTION] != 0) {
                break;
            }
        }


        //
        //  Reset the current setting
        //

        NtSetTimerResolution(TimerData.CurrentActualPeriod * 10000,
                             FALSE,
                             &CurrentTime);

        TimerData.CurrentActualPeriod = TimerData.MinResolution;
        TimerData.CurrentPeriod       = uPeriod;

        if (uPeriod >= TimerData.MinResolution) {
            //
            // Nobody's interested in timing any more
            //

        } else {

            //
            // Set the new period in the kernel
            //

            DWORD NewPeriod100ns;

            //
            // Set the new period in our kernel driver handle
            //

            dprintf4(("timeEndPeriod: setting resolution %d", uPeriod));

            if (!NT_SUCCESS(NtSetTimerResolution(
                                uPeriod * 10000,
                                TRUE,
                                &NewPeriod100ns))) {
                //
                //  This guy's OK but everyone else is hosed
                //

                dprintf1(("timeEndPeriod: Failed to set period %d", uPeriod));
            } else {
                TimerData.CurrentActualPeriod = (NewPeriod100ns + 9999) / 10000;
            }
        }
    }

    LeaveCriticalSection(&ResolutionCritSec);
    return MMSYSERR_NOERROR;
}

/****************************************************************************

    @doc EXTERNAL

    @api MMRESULT | timeKillEvent | This functions destroys a specified timer
    callback event.

    @parm UINT | wID | Identifies the event to be destroyed.

    @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if the
    specified timer event does not exist.

    @comm The timer event ID specified by <p wID> must be an ID
        returned by <f timeSetEvent>.

    @xref  timeSetEvent

****************************************************************************/
MMRESULT APIENTRY timeKillEvent(UINT uId)
{
    MMRESULT mmr;
    TIMER_EVENT *pEvent;
    BOOL fWaitForCallbackToEnd;

    EnterCriticalSection(&TimerThreadCritSec);

    // This event will be initialized if timeSetEvent() was successfully called.
    if (NULL == TimerData.TimerNotCallingCallbackEvent) {
        LeaveCriticalSection(&TimerThreadCritSec);
        return TIMERR_NOCANDO;
    }

    pEvent = &Events[uId % MAX_TIMER_EVENTS];

    //
    // Find our event in the table and check it's there
    // This also catches already completed events
    //
    if (pEvent->Id != uId) {
        LeaveCriticalSection(&TimerThreadCritSec);
        return TIMERR_NOCANDO;
    }

    //
    // Release our event
    //
    timeEndPeriod(pEvent->Resolution);
    pEvent->Id = 0;

    if (!NT_SUCCESS(NtCancelTimer(pEvent->TimerHandle, NULL))) {
        mmr = TIMERR_NOCANDO;
    } else {
        mmr = MMSYSERR_NOERROR;
    }

    NtSetEvent(TimerData.Event1, NULL);

    fWaitForCallbackToEnd = ( TimerData.TimerCallingCallback &&
                              (uId == TimerData.CallbackTimerID) &&
                              (TimerThreadId != GetCurrentThreadId()) &&
                              (pEvent->Flags & TIME_KILL_SYNCHRONOUS) );

    LeaveCriticalSection(&TimerThreadCritSec);

    if ((MMSYSERR_NOERROR == mmr) && fWaitForCallbackToEnd) {
        WaitForSingleObject(TimerData.TimerNotCallingCallbackEvent, INFINITE);
    }

    return mmr;
}

/****************************************************************************

    @doc EXTERNAL

    @api DWORD | timeGetTime | This function retrieves the system time
    in milliseconds.  The system time is the time elapsed since
    Windows was started.

    @rdesc The return value is the system time in milliseconds.

    @comm The only difference between this function and
        the <f timeGetSystemTime> function is <f timeGetSystemTime>
        uses the standard multimedia time structure <t MMTIME> to return
        the system time.  The <f timeGetTime> function has less overhead than
        <f timeGetSystemTime>.

    @xref timeGetSystemTime

****************************************************************************/
DWORD APIENTRY timeGetTime(VOID)
{
    if (TimerData.UseTickCount) {
        //
        // Use the system service
        //
        return GetCurrentTime();
    } else {
        LARGE_INTEGER Difference;

        Difference.QuadPart = ReadInterruptTick() - TimerData.InitialInterruptTick.QuadPart;

        return (DWORD)(Difference.QuadPart / 10000) + TimerData.StartTick;
    }
}

/****************************************************************************

    @doc INTERNAL

    @api LRESULT | timeThread | The timer thread

    @parm LPVOID | lpParameter | the thread parameter (NULL here)

    @rdesc Never returns

    @comm Note that this thread serializes access to the events list

****************************************************************************/
#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)                   // Not all control paths return (due to infinite loop)
#endif

DWORD timeThread(LPVOID lpParameter)
{
    NTSTATUS    nts;
    UINT        cObjects;
    UINT        uiEventIDIndex;
    HANDLE      aTimers[MAX_TIMER_EVENTS + 1];
    UINT        aEventIndexToTimerIDTable[MAX_TIMER_EVENTS + 1];

    //
    // Tell people it's OK to call us from DLL init sections now
    //

    TimerData.Started = TRUE;
    InitializeWaitEventArrays( &cObjects, aTimers, aEventIndexToTimerIDTable );

    //
    // Sit in a loop waiting for something to do
    //
    for (;;) {
        nts = NtWaitForMultipleObjects(
                cObjects,   //  Number of objects (event + timers)
                aTimers,    //  Array of handles
                WaitAny,    //  Wait for any to signal
                TRUE,       //  Wait Alertably (???)
                NULL);      //  Wait forever

        if (STATUS_WAIT_0 == nts)
        {
            //  There's been some timer change (timeSetEvent, timeKillEvent),
            //  rebuild the array...

            InitializeWaitEventArrays( &cObjects, aTimers, aEventIndexToTimerIDTable );
        }
        else
        {
            if ((nts >= STATUS_WAIT_1) && (nts <= STATUS_WAIT_0 + MAX_TIMER_EVENTS))
            {
                uiEventIDIndex = nts - STATUS_WAIT_0;
                TimerCompletion(aEventIndexToTimerIDTable[uiEventIDIndex]);
            }
            else
            {
                WinAssert(FALSE);
            }
        }
    }

    return 1; // CreateThread() requires all threads to return a DWORD value.  The
              // value this thread returns has no meaning.
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

void InitializeWaitEventArrays
    (
    UINT* pcObjects,
    HANDLE aTimers[MAX_TIMER_EVENTS + 1],
    UINT aEventIndexToTimerIDTable[MAX_TIMER_EVENTS+1]
    )
{
    UINT cObjects;
    DWORD dwEventIndex;

    cObjects = 0;
    aTimers[cObjects++] = TimerData.Event1;

    EnterCriticalSection(&TimerThreadCritSec);
    for (dwEventIndex = 0; dwEventIndex < MAX_TIMER_EVENTS; dwEventIndex++)
    {
        if (0 != Events[dwEventIndex].Id)
        {
            aTimers[cObjects] = Events[dwEventIndex].TimerHandle;
            aEventIndexToTimerIDTable[cObjects] = Events[dwEventIndex].Id;
            cObjects++;
        }
    }

    *pcObjects = cObjects;

    LeaveCriticalSection(&TimerThreadCritSec);
}

/****************************************************************************

    @doc INTERNAL

    @api LRESULT | timeThread | The timer thread

    @parm PVOID | ApcContext | Our context - the wave buffer header

    @parm PIO_STATUS_BLOCK | The Io status block we used

    @rdesc None

****************************************************************************/

BOOL timeSetTimerEvent(TIMER_EVENT *pEvent)
{

    //
    // Work out time to fire (and store in case timer is periodic)
    //

    LONGLONG Delay;
    LARGE_INTEGER lDelay;

    //
    // Work out time to fire (and store in case timer is periodic)
    //

    pEvent->FireTime.QuadPart += pEvent->Delay*10000;

    if (pEvent->Flags & TIME_PERIODIC) {

        //
        //  Note that this arithmetic must allow for the case where
        //  timeGetTime() wraps.  We do this by computing delay as
        //  a signed quantity and testing the sign
        //
        Delay = ReadInterruptTick() - pEvent->FireTime.QuadPart;

    } else {

        Delay = -((LONGLONG)pEvent->Delay*10000);
    }

    //
    // If it's already fired then make the timer fire immediately
    // (or at least whichever is the latest - AD 1600 or now).
    // but DON'T call the callback now as we're in the TimerThreadCritSec!
    //

    if (Delay > 0) {
        // Delay = 0;   we no longer use Delay after this point
        lDelay.QuadPart = 0;
    } else {
        lDelay.QuadPart = Delay;
    }

    //
    // Create a timer if we haven't got one
    //
    if (pEvent->TimerHandle == NULL) {
        HANDLE TimerHandle;
        if (!NT_SUCCESS(NtCreateTimer(
                            &TimerHandle,
                            TIMER_ALL_ACCESS,
                            NULL,
                            NotificationTimer))) {
            return FALSE;
        }

        pEvent->TimerHandle = TimerHandle;
    }

    //
    //  Possibly valid since the timer API's are not synchronized anymore
    //

    //  WinAssert(pEvent->Id != 0);

    //
    // Set up a system timer
    //
    return
        NT_SUCCESS(
            NtSetTimer(pEvent->TimerHandle,
                       &lDelay,
                       NULL,
                       (PVOID)(DWORD_PTR)pEvent->Id,
                       FALSE,
                       0,
                       NULL));
}

/****************************************************************************

    @doc INTERNAL

    @api LRESULT | timeThreadSetEvent | Set a new event from the timer thread

    @parm TIMER_EVENT * | pEvent | Our Event

    @rdesc The new event id

****************************************************************************/
LRESULT timeThreadSetEvent(TIMER_EVENT *pEvent)
{
    UINT    i;
    LRESULT lr = 0;

    EnterCriticalSection(&TimerThreadCritSec);

    //
    // Find a free slot and fill it
    //

    for (i = 0; i < MAX_TIMER_EVENTS; i++) {
        //
        // Is the slot free ?
        //
        if (Events[i].Id == 0) {
            pEvent->TimerHandle = Events[i].TimerHandle;
            Events[i] = *pEvent;
            do {
                TimerData.EventCount += MAX_TIMER_EVENTS;
            } while (TimerData.EventCount == 0);
            Events[i].Id = i + TimerData.EventCount;
            break;   // Got our event
        }
    }

    if (i == MAX_TIMER_EVENTS) {
        lr = 0;
    } else {

        //
        // Set the new event in the driver
        //

        if (!timeSetTimerEvent(&Events[i])) {
            Events[i].Id = 0;   // Failed so free our slot
            lr = 0;
        } else {
            lr = Events[i].Id;
        }
    }

    LeaveCriticalSection(&TimerThreadCritSec);

    //  Notifying timer thread of changes..

    NtSetEvent(TimerData.Event1, NULL);
    return lr;
}

/****************************************************************************

    @doc INTERNAL

    @api void | TimerCompletion | Complete a timeout event

    @parm UINT | TimerId | Our timer handle

    @rdesc None

****************************************************************************/

void TimerCompletion(UINT TimerId)
{
    DWORD_PTR dpUser;
    TIMER_EVENT *pEvent;
    LPTIMECALLBACK pCallbackFunction;


    EnterCriticalSection(&TimerThreadCritSec);

    //
    // Find out where we are
    //

    pEvent = &Events[TimerId % MAX_TIMER_EVENTS];

    //
    // Synch up with timeKillEvent
    //

    if (pEvent->Id != TimerId) {
        LeaveCriticalSection(&TimerThreadCritSec);
        return;
    }

    if (pEvent->IsWOW) {

        //
        //  Adobe Premiere has to be sure the time has reached the time
        //  it expected.  But because the timer we use for timeGetTime is
        //  not the same (or at least not rounded the same) as the one used
        //  to set the events) this need not be the case here.
        //
        while(pEvent->FireTime.QuadPart - ReadInterruptTick() > 0) {
            Sleep(1);
        }
    }

    switch (pEvent->Flags & TIME_CALLBACK_TYPEMASK) {
        case TIME_CALLBACK_FUNCTION:

            TimerData.TimerCallingCallback = TRUE;
            TimerData.CallbackTimerID = pEvent->Id;
            ResetEvent(TimerData.TimerNotCallingCallbackEvent);

            dpUser = pEvent->User;
            pCallbackFunction = pEvent->Callback;

            LeaveCriticalSection(&TimerThreadCritSec);

            //
            // Call the callback
            //

#ifdef  _WIN64

            DriverCallback(
                *(PDWORD_PTR)&pCallbackFunction, // Function
                DCB_FUNCTION,                    // Type of callback
                (HDRVR)(DWORD_PTR)TimerId,       // Handle
                0,                               // msg = 0
                dpUser,                          // User data
                0,                               // dw1 = 0
                0);                              // dw2 = 0

#else   //  !WIN64

            if (pEvent->IsWOW) {
                WOW32DriverCallback(
                    *(DWORD *)&pCallbackFunction,    // Function
                    DCB_FUNCTION,                    // Type of callback
                    LOWORD(TimerId),                 // Handle
                    0,                               // msg = 0
                    (DWORD)dpUser,                   // User data
                    0,                               // dw1 = 0
                    0);                              // dw2 = 0
            } else {

                DriverCallback(
                    *(PDWORD_PTR)&pCallbackFunction, // Function
                    DCB_FUNCTION,                    // Type of callback
                    (HDRVR)TimerId,                  // Handle
                    0,                               // msg = 0
                    dpUser,                          // User data
                    0,                               // dw1 = 0
                    0);                              // dw2 = 0

            }

#endif  //  !WIN64

            EnterCriticalSection(&TimerThreadCritSec);

            TimerData.TimerCallingCallback = FALSE;
            SetEvent(TimerData.TimerNotCallingCallbackEvent);

            break;

        case TIME_CALLBACK_EVENT_SET:
            SetEvent((HANDLE)pEvent->Callback);
            break;

        case TIME_CALLBACK_EVENT_PULSE:
            PulseEvent((HANDLE)pEvent->Callback);
            break;

    }

    //
    //  The callback may have kill it, created new timers etc!
    //

    if (TimerId == pEvent->Id) {

        if (!(pEvent->Flags & TIME_PERIODIC)) {
            UINT uResolution;

            //
            // One-shot - so destroy the event
            //

            uResolution = pEvent->Resolution;  // Before we release the slot!
            pEvent->Id = 0;
            timeEndPeriod(uResolution);

            //  Not renewing the timer should remove it from the list...
            NtSetEvent(TimerData.Event1, NULL);

        } else {

            //
            // Try repeating the event
            //

            if (!timeSetTimerEvent(pEvent)) {
                UINT uResolution;

                //
                // Failed - so don't keep event hanging around
                //
                uResolution = pEvent->Resolution; // Before we release the slot!
                pEvent->Id = 0;
                timeEndPeriod(pEvent->Resolution);
            }
        } // Periodic processing
    }

    LeaveCriticalSection(&TimerThreadCritSec);
}

/****************************************************************************

    @doc INTERNAL

    @api void | TimerCleanup | Cleanup on thread termination or DLL unload

    @parm PVOID | ThreadId | Thread to clean up (WOW) or 0 for DLL unload

    @rdesc None

****************************************************************************/

void TimeCleanup(DWORD ThreadId)
{
    //
    // Always called from DLL init routine which is protected by process
    // semaphore so TimerData.ThreadToKill needs no extra protection
    // This variable is an input to the timer thread which either terminates
    // all timers or just those associated with the current thread (for WOW).
    //

    TimerData.ThreadToKill = ThreadId;

    //
    // Thread id of 0 means DLL cleanup
    //

    if (ThreadId == 0) {
        if (hTimerThread) {
#ifdef WRONG

            //
            // we also can not synchronize with the thread at ALL ! It may not
            // have gone through DLL initialization ! This means that during
            // our dll routines we can not do anything with the thread unless
            // we know for a fact the status of the thread !
            //
            // This could be fixed by setting a flag when the timer thread
            // goes through initialization (process mutex held) and testing
            // that flag here - but we don't exepect people to set timer
            // events and unload winmm.dll
            //

            if (TimerData.Started) {
                //
                // Kill any events (only for current thread if WOW).
                //
                {
                    int i;
                    for (i = 0; i < MAX_TIMER_EVENTS; i++) {
                        if (Events[i].Id &&
                            (TimerData.ThreadToKill == 0 ||
                             TimerData.ThreadToKill == Events[i].ThreadId)) {
                            timeKillEvent(Events[i].Id);
                        }
                    }
                }
            }

            //  WaitForSingleObject(hTimerThread, -1);
            //  We cannot wait for the thread to terminate as it will
            //  not go through DLL exit processing while we are doing
            //  our DLL exit processing
#endif
        }

        if (TimerData.Event1) {
            NtClose(TimerData.Event1);
        }

    } else {
        //
        // Per-thread Cleanup for WOW.  We don't touch anything if it
        // looks like nothing has run yet (so we might be caught out
        // if the thread is stopped in the middle of a timeSetEvent).
        //

        if (TimerData.Started) {
            //
            // Kill any events (only for current thread if WOW).
            //
            {
                int i;
                for (i = 0; i < MAX_TIMER_EVENTS; i++) {
                    if (Events[i].Id &&
                        (TimerData.ThreadToKill == 0 ||
                         TimerData.ThreadToKill == Events[i].ThreadId)) {
                        timeKillEvent(Events[i].Id);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\winmm.c ===
/****************************************************************************\
*
*  Module Name : winmm.c
*
*  Multimedia support library
*
*  This module contains the entry point, startup and termination code
*
*  Copyright (c) 1991-2001 Microsoft Corporation
*
\****************************************************************************/

#define UNICODE
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "winmmi.h"
#include "mmioi.h"
#include "mci.h"
#include <regstr.h>
#include <winuser.h>
#include <wtsapi32.h>
#include <dbt.h>
#include <ks.h>
#include <ksmedia.h>
#include <winsta.h>
#include <stdlib.h>
#include "winuserp.h"

#include "audiosrvc.h"
#include "agfxp.h"
#define _INC_WOW_CONVERSIONS
#include "mmwow32.h"

BOOL WaveInit(void);
BOOL MidiInit(void);
BOOL AuxInit(void);
BOOL MixerInit(void);
void InitDevices(void);
HANDLE mmDrvOpen(LPWSTR szAlias);
void WOWAppExit(HANDLE hTask);
void MigrateSoundEvents(void);
UINT APIENTRY mmDrvInstall(HANDLE hDriver, WCHAR * wszDrvEntry, DRIVERMSGPROC drvMessage, UINT wFlags);
STATIC void NEAR PASCAL mregAddIniScheme(LPTSTR  lszSection,
                                         LPTSTR  lszSchemeID,
                                         LPTSTR  lszSchemeName,
                                         LPTSTR  lszINI);
STATIC void NEAR PASCAL mregCreateSchemeID(LPTSTR szSchemeName, LPTSTR szSchemeID);
int lstrncmpi (LPTSTR pszA, LPTSTR pszB, size_t cch);
void RemoveMediaPath (LPTSTR pszTarget, LPTSTR pszSource);

MMRESULT waveOutDesertHandle(HWAVEOUT hWaveOut);
MMRESULT waveInDesertHandle(HWAVEIN hWaveIn);
MMRESULT midiOutDesertHandle(HMIDIOUT hMidiOut);
MMRESULT midiInDesertHandle(HMIDIIN hMidiIn);
MMRESULT mixerDesertHandle(HMIXER hmx);

#ifndef cchLENGTH
#define cchLENGTH(_sz) (sizeof(_sz) / sizeof(_sz[0]))
#endif

/****************************************************************************

    global data

****************************************************************************/

HANDLE  ghInst;                         // Module handle
BOOL    gfDisablePreferredDeviceReordering = FALSE;
BOOL    WinmmRunningInServer;           // Are we running in the user/base server?
BOOL    WinmmRunningInWOW;              // Are we running in WOW
BOOL    WinmmRunningInSession;          // Are we running in remote session
WCHAR   SessionProtocolName[WPROTOCOLNAME_LENGTH];

//                                                                            |
// The tls is used simply as an indication that the thread has entered
// waveOutOpen or waveOutGetDevCaps for a non-mapper device.  Then, we detect
// re-entrancy into either of these APIs.  In the case of re-entrancy we
// might have a driver that is enumerating and caching device IDs.  To improve
// the chances of such a driver working, we disable preferred device
// reordering in this case.  Note we rely on the OS to initialize the tls to 0.
//
DWORD   gTlsIndex = TLS_OUT_OF_INDEXES; // Thread local storage index;

CRITICAL_SECTION DriverListCritSec;       // Protect driver interface globals
CRITICAL_SECTION DriverLoadFreeCritSec; // Protect driver load/unload
CRITICAL_SECTION NumDevsCritSec;      // Protect Numdevs/Device ID's
CRITICAL_SECTION MapperInitCritSec;   // Protect test of mapper initialized

HANDLE           hClientPnpInfo        = NULL;
PMMPNPINFO       pClientPnpInfo        = NULL;
CRITICAL_SECTION PnpCritSec;

RTL_RESOURCE     gHandleListResource;       //  Serializes access to handles.

BOOL gfLogon         = FALSE;

HANDLE  hEventApiInit = NULL;

WAVEDRV waveoutdrvZ;                  // wave output device driver list head
WAVEDRV waveindrvZ;                   // wave input device driver list head
MIDIDRV midioutdrvZ;                  // midi output device driver list
MIDIDRV midiindrvZ;                   // midi input device driver list
AUXDRV  auxdrvZ;                      // aux device driver list
UINT    wTotalMidiOutDevs;            // total midi output devices
UINT    wTotalMidiInDevs;             // total midi input devices
UINT    wTotalWaveOutDevs;            // total wave output devices
UINT    wTotalWaveInDevs;             // total wave input devices
UINT    wTotalAuxDevs;                // total auxiliary output devices
LONG    cPnpEvents;                   // number of processed pnp events
LONG    cPreferredDeviceChanges = 0;  // number of processed preferred device changes

typedef struct tag_wdmdeviceinterface *PWDMDEVICEINTERFACE;
typedef struct tag_wdmdeviceinterface
{
    PWDMDEVICEINTERFACE Next;
    DWORD               cUsage;
    LONG                cPnpEvents;
    WCHAR               szDeviceInterface[0];
    
} WDMDEVICEINTERFACE, *PWDMDEVICEINTERFACE;

WDMDEVICEINTERFACE wdmDevZ;

LPCRITICAL_SECTION acs[] = {
    &HandleListCritSec,
    &DriverListCritSec,
    &DriverLoadFreeCritSec,
    &MapperInitCritSec,
    &NumDevsCritSec,
    &PnpCritSec,
    &WavHdrCritSec,
    &SoundCritSec,
    &midiStrmHdrCritSec,
    &joyCritSec,
    &mciGlobalCritSec,
    &mciCritSec,
    &TimerThreadCritSec,
    &ResolutionCritSec
};

//  HACK!!!

SERVICE_STATUS_HANDLE   hss;
SERVICE_STATUS          gss;

#ifdef DEBUG_RETAIL
BYTE    fIdReverse;                   // reverse wave/midi id's
#endif

// For sounds:

STATIC TCHAR gszControlIniTime[] = TEXT("ControlIniTimeStamp");
TCHAR gszControlPanel[] = TEXT("Control Panel");
TCHAR gszSchemesRootKey[] = TEXT("AppEvents\\Schemes");
TCHAR gszJustSchemesKey[] = TEXT("Schemes");
TCHAR aszExplorer[] = TEXT("Explorer");
TCHAR aszDefault[] = TEXT(".Default");
TCHAR aszCurrent[] = TEXT(".Current");
TCHAR gszAppEventsKey[] = TEXT("AppEvents");
TCHAR gszSchemeAppsKey[] = TEXT("Apps");
TCHAR aszSoundsSection[] = TEXT("Sounds");
TCHAR aszSoundSection[] = TEXT("Sound");
TCHAR aszActiveKey[] = TEXT("Active");
TCHAR aszBoolOne[] = TEXT("1");

TCHAR asz2Format[] = TEXT("%s\\%s");
TCHAR asz3Format[] = TEXT("%s\\%s\\%s");
TCHAR asz4Format[] = TEXT("%s\\%s\\%s\\%s");
TCHAR asz5Format[] = TEXT("%s\\%s\\%s\\%s\\%s");
TCHAR asz6Format[] = TEXT("%s\\%s\\%s\\%s\\%s\\%s");

STATIC TCHAR aszSchemeLabelsKey[] = TEXT("EventLabels");
STATIC TCHAR aszSchemeNamesKey[] = TEXT("Names");
STATIC TCHAR aszControlINI[] = TEXT("control.ini");
STATIC TCHAR aszWinINI[] = TEXT("win.ini");
STATIC TCHAR aszSchemesSection[] = TEXT("SoundSchemes");
STATIC TCHAR gszSoundScheme[] = TEXT("SoundScheme.%s");
STATIC TCHAR aszCurrentSection[] = TEXT("Current");
STATIC TCHAR aszYourOldScheme[] = TEXT("Your Old Scheme");
STATIC TCHAR aszNone[] = TEXT("<none>");
STATIC TCHAR aszDummyDrv[] = TEXT("mmsystem.dll");
STATIC TCHAR aszDummySnd[] = TEXT("SystemDefault");
STATIC TCHAR aszDummySndValue[] = TEXT(",");
STATIC TCHAR aszExtendedSounds[] = TEXT("ExtendedSounds");
STATIC TCHAR aszExtendedSoundsYes[] = TEXT("yes");

STATIC TCHAR gszApp[] = TEXT("App");
STATIC TCHAR gszSystem[] = TEXT("System");

STATIC TCHAR gszAsterisk[] = TEXT("Asterisk");
STATIC TCHAR gszDefault[] = TEXT("Default");
STATIC TCHAR gszExclamation[] = TEXT("Exclamation");
STATIC TCHAR gszExit[] = TEXT("Exit");
STATIC TCHAR gszQuestion[] = TEXT("Question");
STATIC TCHAR gszStart[] = TEXT("Start");
STATIC TCHAR gszHand[] = TEXT("Hand");

STATIC TCHAR gszClose[] = TEXT("Close");
STATIC TCHAR gszMaximize[] = TEXT("Maximize");
STATIC TCHAR gszMinimize[] = TEXT("Minimize");
STATIC TCHAR gszOpen[] = TEXT("Open");
STATIC TCHAR gszRestoreDown[] = TEXT("RestoreDown");
STATIC TCHAR gszRestoreUp[] = TEXT("RestoreUp");

STATIC TCHAR aszOptionalClips[] = REGSTR_PATH_SETUP REGSTR_KEY_SETUP TEXT("\\OptionalComponents\\Clips");
STATIC TCHAR aszInstalled[] = TEXT("Installed");

STATIC TCHAR * gpszSounds[] = {
      gszClose,
      gszMaximize,
      gszMinimize,
      gszOpen,
      gszRestoreDown,
      gszRestoreUp,
      gszAsterisk,
      gszDefault,
      gszExclamation,
      gszExit,
      gszQuestion,
      gszStart,
      gszHand
   };

STATIC TCHAR aszMigration[] = TEXT("Migrated Schemes");
#define wCurrentSchemeMigrationLEVEL 1

static struct {
   LPCTSTR pszEvent;
   int idDescription;
   LPCTSTR pszApp;
} gaEventLabels[] = {
   { TEXT("AppGPFault"),         STR_LABEL_APPGPFAULT,         aszDefault   },
   { TEXT("Close"),              STR_LABEL_CLOSE,              aszDefault   },
   { TEXT("EmptyRecycleBin"),    STR_LABEL_EMPTYRECYCLEBIN,    aszExplorer  },
   { TEXT("Maximize"),           STR_LABEL_MAXIMIZE,           aszDefault   },
   { TEXT("MenuCommand"),        STR_LABEL_MENUCOMMAND,        aszDefault   },
   { TEXT("MenuPopup"),          STR_LABEL_MENUPOPUP,          aszDefault   },
   { TEXT("Minimize"),           STR_LABEL_MINIMIZE,           aszDefault   },
   { TEXT("Open"),               STR_LABEL_OPEN,               aszDefault   },
   { TEXT("RestoreDown"),        STR_LABEL_RESTOREDOWN,        aszDefault   },
   { TEXT("RestoreUp"),          STR_LABEL_RESTOREUP,          aszDefault   },
   { TEXT("RingIn"),             STR_LABEL_RINGIN,             aszDefault   },
   { TEXT("RingOut"),            STR_LABEL_RINGOUT,            aszDefault   },
   { TEXT("SystemAsterisk"),     STR_LABEL_SYSTEMASTERISK,     aszDefault   },
   { TEXT(".Default"),           STR_LABEL_SYSTEMDEFAULT,      aszDefault   },
   { TEXT("SystemExclamation"),  STR_LABEL_SYSTEMEXCLAMATION,  aszDefault   },
   { TEXT("SystemExit"),         STR_LABEL_SYSTEMEXIT,         aszDefault   },
   { TEXT("SystemHand"),         STR_LABEL_SYSTEMHAND,         aszDefault   },
   { TEXT("SystemQuestion"),     STR_LABEL_SYSTEMQUESTION,     aszDefault   },
   { TEXT("SystemStart"),        STR_LABEL_SYSTEMSTART,        aszDefault   },
};

TCHAR gszDefaultBeepOldAlias[] = TEXT("SystemDefault");

#define nEVENTLABELS  (sizeof(gaEventLabels)/sizeof(gaEventLabels[0]))

STATIC TCHAR gszChimes[] = TEXT("chimes.wav");
STATIC TCHAR gszDing[] = TEXT("ding.wav");
STATIC TCHAR gszTada[] = TEXT("tada.wav");
STATIC TCHAR gszChord[] = TEXT("chord.wav");

STATIC TCHAR * gpszKnownWAVFiles[] = {
      gszChord,
      gszTada,
      gszChimes,
      gszDing,
   };

#define INISECTION      768
#define BIGINISECTION   2048
TCHAR szNull[] = TEXT("");
TCHAR aszSetup[] = REGSTR_PATH_SETUP;
TCHAR aszValMedia[] = REGSTR_VAL_MEDIA;
TCHAR aszValMediaUnexpanded[] = TEXT("MediaPathUnexpanded");

extern HANDLE  hInstalledDriverList;  // List of installed driver instances
extern int     cInstalledDrivers;     // High water count of installed driver instances

HANDLE ghSessionNotification = NULL;
HANDLE ghSessionNotificationEvent = NULL;
BOOL   gfSessionDisconnected = FALSE;

#define g_szWinmmConsoleAudioEvent L"Global\\WinMMConsoleAudioEvent"


//=============================================================================
//===   Reg helpers   ===
//=============================================================================
LONG RegPrepareEnum(HKEY hkey, PDWORD pcSubkeys, PTSTR *ppstrSubkeyNameBuffer, PDWORD pcchSubkeyNameBuffer)
{
    DWORD cSubkeys;
    DWORD cchMaxSubkeyName;
    LONG lresult;

    lresult = RegQueryInfoKey(hkey, NULL, NULL, NULL, &cSubkeys, &cchMaxSubkeyName, NULL, NULL, NULL, NULL, NULL, NULL);
    if (ERROR_SUCCESS == lresult) {
        PTSTR SubkeyName;
        SubkeyName = (PTSTR)HeapAlloc(hHeap, 0, (cchMaxSubkeyName+1) * sizeof(TCHAR));
        if (SubkeyName) {
		*pcSubkeys = cSubkeys;
		*ppstrSubkeyNameBuffer = SubkeyName;
		*pcchSubkeyNameBuffer = cchMaxSubkeyName+1;
	} else {
	    lresult = ERROR_OUTOFMEMORY;
	}
    }
    return lresult;
}

LONG RegEnumOpenKey(HKEY hkey, DWORD dwIndex, PTSTR SubkeyName, DWORD cchSubkeyName, REGSAM samDesired, PHKEY phkeyResult)
{
    LONG lresult;

    lresult = RegEnumKeyEx(hkey, dwIndex, SubkeyName, &cchSubkeyName, NULL, NULL, NULL, NULL);
    if (ERROR_SUCCESS == lresult) {
	HKEY hkeyResult;
	lresult = RegOpenKeyEx(hkey, SubkeyName, 0, samDesired, &hkeyResult);
	if (ERROR_SUCCESS == lresult) *phkeyResult = hkeyResult;
    }
    return lresult;
}

/**************************************************************************

          Terminal server helper functions

 **************************************************************************/
BOOL
IsPersonalTerminalServicesEnabled(
    VOID
    )
{
    static BOOL fRet;
    static BOOL fVerified = FALSE;

    DWORDLONG dwlConditionMask;
    OSVERSIONINFOEX osVersionInfo;

    if ( fVerified )
        goto exitpt;

    RtlZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wProductType = VER_NT_WORKSTATION;
    osVersionInfo.wSuiteMask = VER_SUITE_SINGLEUSERTS;

    dwlConditionMask = 0;
    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

    fRet = VerifyVersionInfo(
            &osVersionInfo,
            VER_PRODUCT_TYPE | VER_SUITENAME,
            dwlConditionMask
            );

    fVerified = TRUE;

exitpt:

    return(fRet);
}

//
//  Check if console audio is enabled in remote session
//
BOOL
IsTsConsoleAudio(
    VOID
    )
{
    BOOL    RemoteConsoleAudio = FALSE;            // Allow audio play at the console
    static  HANDLE hConsoleAudioEvent = NULL;


    if (NtCurrentPeb()->SessionId == 0 ||
        IsPersonalTerminalServicesEnabled()) {

        if (hConsoleAudioEvent == NULL) {
            hConsoleAudioEvent = OpenEvent(SYNCHRONIZE, FALSE, g_szWinmmConsoleAudioEvent);
        }

        if (hConsoleAudioEvent != NULL) {
            DWORD status;

            status = WaitForSingleObject(hConsoleAudioEvent, 0);

            if (status == WAIT_OBJECT_0) {
                RemoteConsoleAudio = TRUE;
            }
        }
        else {
            dprintf(("Remote session: console audio event NULL with error: %d\n", GetLastError()));
        }
    }

    return RemoteConsoleAudio;
}

//
//  returns TRUE if we are on the console
//
BOOL IsActiveConsoleSession( VOID )
{
    return (USER_SHARED_DATA->ActiveConsoleId == NtCurrentPeb()->SessionId);
}

void InitSession(void);
BOOL WaveReInit(void);

//
//  Check if the session is changed and load additional audio drivers
//  this is a case only for reconnecting the console from Terminal Server
//
BOOL
CheckSessionChanged(VOID)
{
    static BOOL bCalled = FALSE;
    static BOOL bWasntRedirecting;
    BOOL   bOld;
    BOOL   bDontRedirect;
    BOOL   bRefreshPreferredDevices;

    bRefreshPreferredDevices = FALSE;

    bDontRedirect = IsActiveConsoleSession() || IsTsConsoleAudio();

    if ( !InterlockedExchange( &bCalled, TRUE ))
    {
        bWasntRedirecting = !bDontRedirect;
    }

    bOld = InterlockedExchange( &bWasntRedirecting, bDontRedirect);
    if ( bOld ^ bWasntRedirecting )
    {
        //
        //  session conditions changed
        //

        dprintf(( "Session state changed: %s",
            (bWasntRedirecting)?"CONSOLE":"SESSION" ));
        //
        //  close the old registry handle
        //
        mmRegFree();

        //
        //  add new devices
        //
        InitSession();
        WaveReInit();

        bRefreshPreferredDevices = TRUE;
    }

    return bRefreshPreferredDevices;
}

/*****************************************************************************
 *
 * WTSCurrentSessionIsDisonnected
 *
 * Determines whether current session is disconnected.
 *
 ****************************************************************************/
BOOL WTSCurrentSessionIsDisconnected(void)
{
    if (NULL == ghSessionNotification)
    {
        // We create the event signalled so that we'll get the connect state
        // from audiosrv on first successful pass through this function.
        WinAssert(NULL == ghSessionNotificationEvent);
        ghSessionNotificationEvent = CreateEvent(NULL, FALSE, TRUE, NULL);
        if (ghSessionNotificationEvent) {
            LONG lresult;
            lresult = winmmRegisterSessionNotificationEvent(ghSessionNotificationEvent, &ghSessionNotification);
            if (lresult) {
                CloseHandle(ghSessionNotificationEvent);
                ghSessionNotificationEvent = NULL;
                ghSessionNotification = NULL;
            }
        }
    }

    if (ghSessionNotification) {
    	WinAssert(ghSessionNotificationEvent);
        if (WAIT_OBJECT_0 == WaitForSingleObjectEx(ghSessionNotificationEvent, 0, TRUE)) {
            INT ConnectState;
            LONG lresult;

            // Get new state from audiosrv
            lresult = winmmSessionConnectState(&ConnectState);
            if (!lresult) {
                gfSessionDisconnected = (WTSDisconnected == ConnectState);
            }
        }
    }

    return gfSessionDisconnected;
}

/**************************************************************************

    @doc EXTERNAL

    @api BOOL | mmDeleteMultipleCriticalSections | This procedure
        deletes multiple critical sections.

    @parm LPCRITICAL_SECTION* | ppCritcalSections | Pointer to an array of
        pointers to critical sections

    @parm LONG | nCount | Number of critical sections pointers in the array.

    @rdesc VOID

**************************************************************************/
void mmDeleteMultipleCriticalSections(LPCRITICAL_SECTION *ppCriticalSections, LONG nCount)
{
    int i;
    for (i = 0; i < nCount; i++) DeleteCriticalSection(ppCriticalSections[i]);
    return;
}

/**************************************************************************

    @doc EXTERNAL

    @api BOOL | mmInitializeMultipleCriticalSections | This procedure
        initializes multiple critical sections.

    @parm LPCRITICAL_SECTION* | ppCritcalSections | Pointer to an array of
        pointers to critical sections

    @parm LONG | nCount | Number of critical sections pointers in the array.

    @rdesc The return value is TRUE if the initialization completed ok,
        FALSE if not.

**************************************************************************/
BOOL mmInitializeMultipleCriticalSections(LPCRITICAL_SECTION *ppCriticalSections, LONG nCount)
{
    int i;      // Must be signed for loops to work properly

    for (i = 0; i < nCount; i++)
    {
        if (!mmInitializeCriticalSection(ppCriticalSections[i])) break;
    }

    if (i == nCount) return TRUE;

    // Back up index to the last successful initialization
    i--;

    // There must have been a failure.  Clean up the ones that succeeded.
    for ( ; i >= 0; i--)
    {
        DeleteCriticalSection(ppCriticalSections[i]);
    }
    return FALSE;
}

/*
 *    Initialization for terminal server
 */
void InitSession(void) {
   WSINFO SessionInfo;

   BOOL bCons = (BOOL)IsActiveConsoleSession();
   if ( bCons || IsTsConsoleAudio() )
        WinmmRunningInSession = FALSE;
   else
        WinmmRunningInSession = TRUE;

   if (WinmmRunningInSession) {

      memset( &SessionInfo, 0, sizeof(SessionInfo));
      GetWinStationInfo(&SessionInfo);
      lstrcpyW(SessionProtocolName, SessionInfo.ProtocolName);
      dprintf(("Remote session protocol %ls", SessionProtocolName));
      dprintf(("Remote audio driver name %ls", SessionInfo.AudioDriverName));

   } else {
      SessionProtocolName[0] = 0;
   }

}

/**************************************************************************

    @doc INTERNAL

    @api VOID | DeletePnpInfo | Frees the pClientPnpInfo file mapping
    
    @rdesc There is no return value

**************************************************************************/
void DeletePnpInfo(void)
{
    if (pClientPnpInfo) {
	BOOL f;

	WinAssert(hClientPnpInfo);

	f = UnmapViewOfFile(pClientPnpInfo);
	WinAssert(f);
	pClientPnpInfo = NULL;
	f = CloseHandle(hClientPnpInfo);
	WinAssert(f);
	hClientPnpInfo = NULL;
    }
    return;
}

/**************************************************************************

    @doc EXTERNAL

    @api BOOL | DllProcessAttach | This procedure is called whenever a
        process attaches to the DLL.

    @parm PVOID | hModule | Handle of the DLL.

    @rdesc The return value is TRUE if the initialisation completed ok,
        FALSE if not.

**************************************************************************/
BOOL DllProcessAttach(PVOID hModule)
{
    HANDLE hModWow32;
    PIMAGE_NT_HEADERS NtHeaders;    // For checking if we're in the server.
    BOOL fSuccess;

#if DBG
    CHAR strname[MAX_PATH];
    GetModuleFileNameA(NULL, strname, sizeof(strname));
    dprintf2(("Process attaching, exe=%hs (Pid %x  Tid %x)", strname, GetCurrentProcessId(), GetCurrentThreadId()));
#endif

    // We don't need to know when threads start
    DisableThreadLibraryCalls(hModule);

    // Get access to the process heap.  This is cheaper in terms of
    // overall resource being chewed up than creating our own heap.
    hHeap = RtlProcessHeap();
    if (hHeap == NULL) {
        return FALSE;
    }

    // Allocate our tls
    gTlsIndex = TlsAlloc();
    if (TLS_OUT_OF_INDEXES == gTlsIndex) return FALSE;

    //
    // Find out if we're in WOW
    //
#ifdef _WIN64
    WinmmRunningInWOW = FALSE;
#else
    if ( (hModWow32 = GetModuleHandleW( L"WOW32.DLL" )) != NULL ) {
        WinmmRunningInWOW = TRUE;
        GetVDMPointer = (LPGETVDMPOINTER)GetProcAddress( hModWow32, "WOWGetVDMPointer");
        lpWOWHandle32 = (LPWOWHANDLE32)GetProcAddress( hModWow32, "WOWHandle32" );
        lpWOWHandle16 = (LPWOWHANDLE16)GetProcAddress( hModWow32, "WOWHandle16" );
    } else {
        WinmmRunningInWOW = FALSE;
    }
#endif

    //
    //  This checks if we're running in CSRSS and this will never happen as of
    //  Win2k
    //
    WinmmRunningInServer = FALSE;                           

    if (mmInitializeMultipleCriticalSections(acs, sizeof(acs)/sizeof(acs[0])))
    {
        NTSTATUS    nts;
    
        hEventApiInit = CreateEvent(NULL, TRUE, FALSE, NULL);

        __try {
            RtlInitializeResource(&gHandleListResource);
            nts = STATUS_SUCCESS;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            nts = GetExceptionCode();
        }
        
        if ((hEventApiInit) && (NT_SUCCESS(nts))) {
            InitDebugLevel();
            InitSession();
            InitDevices();

            // it is important that the MCI window initialisation is done AFTER
            // we have initialised Wave, Midi, etc. devices.  Note the server
            // uses Wave devices, but nothing else (e.g. MCI, midi...)
            if (!WinmmRunningInServer) {
                mciGlobalInit();
            }
        } else {
            // EventApiInit Create failed
            if (hEventApiInit) CloseHandle(hEventApiInit);
            hEventApiInit = NULL;
            mmDeleteMultipleCriticalSections(acs, sizeof(acs)/sizeof(acs[0]));
            TlsFree(gTlsIndex);
            return (FALSE);
        }
    }
    else
    {
        //  Failed to initialize critical sections.
        TlsFree(gTlsIndex);
        return (FALSE);
    }

    // Added to remove warning.
    return TRUE;
}

/**************************************************************************

    @doc EXTERNAL

    @api BOOL | DllInstanceInit | This procedure is called whenever a
        process attaches or detaches from the DLL.

    @parm PVOID | hModule | Handle of the DLL.

    @parm ULONG | Reason | What the reason for the call is.

    @parm PCONTEXT | pContext | Some random other information.

    @rdesc The return value is TRUE if the initialisation completed ok,
        FALSE if not.

**************************************************************************/

BOOL DllInstanceInit(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
    PIMAGE_NT_HEADERS NtHeaders;    // For checking if we're in the server.
    HANDLE            hModWow32;
    DWORD             dwThread;
    BOOL              f;

    ghInst = (HANDLE) hModule;

    DBG_UNREFERENCED_PARAMETER(pContext);

    if (Reason == DLL_PROCESS_ATTACH) {

        return DllProcessAttach(hModule);

    } else if (Reason == DLL_PROCESS_DETACH) {

        dprintf2(("Process ending (Pid %x  Tid %x)", GetCurrentProcessId(), GetCurrentThreadId()));

        // Squirt("Entering process detach");

        // Can't really use RPC during DllMain, so let's just close first
        AudioSrvBindingFree();

        if (ghSessionNotification) 
        {
            WinAssert(ghSessionNotificationEvent);
            winmmUnregisterSessionNotification(ghSessionNotification);
            CloseHandle(ghSessionNotificationEvent);
            ghSessionNotification = NULL;
            ghSessionNotificationEvent = NULL;
        }
        else
        {
            WinAssert(!ghSessionNotificationEvent);
        }

        if (!WinmmRunningInServer) {
            TimeCleanup(0); // DLL cleanup
        }

        mmRegFree();
        JoyCleanup();                                           //qzheng

        DeletePnpInfo();

        if (hInstalledDriverList)
        {
            GlobalFree ((HGLOBAL)hInstalledDriverList);
            hInstalledDriverList = NULL;
            cInstalledDrivers = 0;      // Count of installed drivers
        }

        InvalidatePreferredDevices();

        if (hEventApiInit) CloseHandle(hEventApiInit);

        mmDeleteMultipleCriticalSections(acs, sizeof(acs)/sizeof(acs[0]));

        RtlDeleteResource(&gHandleListResource);

        TlsFree(gTlsIndex);
        
    } else if (Reason == 999) {
        // This is a dummy call to an entry point in ADVAPI32.DLL.  By
        // statically linking to the library we avoid the following:
        // An application links to winmm.dll and advapi32.dll
        // When the application loads the list of dependent dlls is built,
        // and a list of the dll init routines is created.  It happens
        // that the winmm init routine is called first.
        // IF there is a sound card in the system, winmm's dll init routine
        // call LoadLibrary on the sound driver DLL.  This DLL WILL
        // reference advapi32.dll - and call entry points in advapi32.
        // Unfortunately the init routine of advapi32.dll is marked as
        // having RUN - although that is not yet the case as we are still
        // within the load routine for winmm.
        // When the advapi32 entry point runs, it relies on its init
        // routine having completed; specifically a CriticalSection should
        // have been initialised.  This is not the case, and BOOM!
        // The workaround is to ensure that advapi32.dll runs its init
        // routine first.  This is done by making sure that WINMM has a
        // static link to the dll.
        ImpersonateSelf(999);   // This routine will never be called.
        // If it is called, it will fail.
    }

    return TRUE;
}


/*****************************************************************************
 * @doc EXTERNAL MMSYSTEM
 *
 * @api void | WOWAppExit | This function cleans up when a (WOW) application
 * terminates.
 *
 * @parm HANDLE | hTask | Thread id of application (equivalent to windows task
 * handle).
 *
 * @rdesc Nothing
 *
 * @comm  Note that NOT ALL threads are WOW threads.  We rely here on the
 *     fact that ONLY MCI creates threads other than WOW threads which
 *     use our low level device resources.
 *
 *     Note also that once a thread is inside here no other threads can
 *     go through here so, since we clean up MCI devices first, their
 *     low level devices will be freed before we get to their threads.
 *
 ****************************************************************************/

void WOWAppExit(HANDLE hTask)
{
    MCIDEVICEID DeviceID;
    HANDLE h, hNext;

    dprintf3(("WOW Multi-media - thread %x exiting", hTask));

    //
    // Free MCI devices allocated by this task (thread).
    //

    EnterCriticalSection(&mciCritSec);
    for (DeviceID=1; DeviceID < MCI_wNextDeviceID; DeviceID++)
    {

        if (MCI_VALID_DEVICE_ID(DeviceID) &&
            MCI_lpDeviceList[DeviceID]->hCreatorTask == hTask)
        {
            //
            //  Note that the loop control variables are globals so will be
            //  reloaded on each iteration.
            //
            //  Also no new devices will be opened by APPs because this is WOW
            //
            //  Hence it's safe (and essential!) to leave the critical
            //  section which we send the close command
            //

            dprintf2(("MCI device %ls (%d) not released.", MCI_lpDeviceList[DeviceID]->lpstrInstallName, DeviceID));
            LeaveCriticalSection(&mciCritSec);
            mciSendCommandW(DeviceID, MCI_CLOSE, 0, 0);
            EnterCriticalSection(&mciCritSec);
        }
    }
    LeaveCriticalSection(&mciCritSec);

    //
    // Free any timers
    //

    TimeCleanup((DWORD)(DWORD_PTR)hTask);

    //
    // free all WAVE/MIDI/MMIO handles
    //

    // ISSUE-2001/01/16-FrankYe This violates the order in which locks should
    //   be acquired.  The HandleListCritSec should be the last lock taken,
    //   but here it is held while calling winmm APIs
    EnterCriticalSection(&HandleListCritSec);
    h = GetHandleFirst();

    while (h)
    {
        hNext = GetHandleNext(h);

        if (GetHandleOwner(h) == hTask)
        {
            HANDLE hdrvDestroy;

            //
            //  hack for the wave/midi mapper, always free handles backward.
            //
            if (hNext && GetHandleOwner(hNext) == hTask) {
                h = hNext;
                continue;
            }

            //
            // do this so even if the close fails we will not
            // find it again.
            //
            SetHandleOwner(h, NULL);

            //
            // set the hdrvDestroy global so DriverCallback will not
            // do anything for this device
            //
            hdrvDestroy = h;

            switch(GetHandleType(h))
            {
                case TYPE_WAVEOUT:
                    dprintf1(("WaveOut handle (%04X) was not released.", h));
                    waveOutReset((HWAVEOUT)h);
                    waveOutClose((HWAVEOUT)h);
                    break;

                case TYPE_WAVEIN:
                    dprintf1(("WaveIn handle (%04X) was not released.", h));
                    waveInReset((HWAVEIN)h);
                    waveInClose((HWAVEIN)h);
                    break;

                case TYPE_MIDIOUT:
                    dprintf1(("MidiOut handle (%04X) was not released.", h));
                    midiOutReset((HMIDIOUT)h);
                    midiOutClose((HMIDIOUT)h);
                    break;

                case TYPE_MIDIIN:
                    dprintf1(("MidiIn handle (%04X) was not released.", h));
                    midiInReset((HMIDIIN)h);
                    midiInClose((HMIDIIN)h);
                    break;

                //
                // This is not required because WOW does not open any
                // mmio files.
                //
                // case TYPE_MMIO:
                //     dprintf1(("MMIO handle (%04X) was not released.", h));
                //     if (mmioClose((HMMIO)h, 0) != 0)
                //         mmioClose((HMMIO)h, MMIO_FHOPEN);
                //     break;
            }

            //
            // unset hdrvDestroy so DriverCallback will work.
            // some hosebag drivers (like the TIMER driver)
            // may pass NULL as their driver handle.
            // so dont set it to NULL.
            //
            hdrvDestroy = (HANDLE)-1;

            //
            // the reason we start over is because a single free may cause
            // multiple free's (ie MIDIMAPPER has another HMIDI open, ...)
            //
            h = GetHandleFirst();
        } else {
            h = GetHandleNext(h);
        }
    }
    LeaveCriticalSection(&HandleListCritSec);

    //
    // Clean up an installed IO procs for mmio
    //
    // This is not required because wow does not install any io procs.
    //
    // mmioCleanupIOProcs(hTask);
    //


    // If avicap32.dll is loaded, then ask it to clean up
    // capture drivers
    {
        HMODULE hmod;
        hmod = GetModuleHandle(TEXT("avicap32.dll"));
        if (hmod) {
            typedef void (*AppCleanupProc)(HANDLE);
            AppCleanupProc fp;

            fp = (AppCleanupProc) GetProcAddress(hmod, "AppCleanup");
            if (fp) {
                fp(hTask);
            }
        }
    }
}

BOOL IsWinlogon(void)
{
    TCHAR       szTarget[] = TEXT("winlogon.Exe");
    TCHAR       szTemp[MAX_PATH];
    UINT        ii;
    static BOOL	fAlreadyChecked = FALSE;
    static BOOL fIsWinlogon = FALSE;

    if (fAlreadyChecked) return fIsWinlogon;

    if (0 == GetModuleFileName(NULL, szTemp, sizeof(szTemp)/sizeof(szTemp[0])))
    {
        //
        //  GetModuleFileName fails...
        //

        return FALSE;
    }

    for (ii = lstrlen(szTemp) - 1; ii; ii--)
    {
        if ('\\' == szTemp[ii])
        {
            ii++;

	    fIsWinlogon = !lstrcmpi(&(szTemp[ii]), szTarget);
	    fAlreadyChecked = TRUE;
	    return fIsWinlogon;
        }
    }

    return FALSE;
}

void FreeUnusedDrivers(PMMDRV pmmdrvZ)
{
	PMMDRV pmmdrv = pmmdrvZ->Next;

	while (pmmdrv != pmmdrvZ)
	{
		PMMDRV pmmdrvNext = pmmdrv->Next;
		
		ASSERT(pmmdrv->hDriver);
		
		if ((0 == pmmdrv->NumDevs) && (0 == (pmmdrv->fdwDriver & MMDRV_DESERTED)))
		{
			// For pnp driver we send DRVM_EXIT
			if (pmmdrv->cookie) pmmdrv->drvMessage(0, DRVM_EXIT, 0L, 0L, (DWORD_PTR)pmmdrv->cookie);
			
			DrvClose(pmmdrv->hDriver, 0, 0);

                        DeleteCriticalSection(&pmmdrv->MixerCritSec);

			// Remove from list
			pmmdrv->Prev->Next = pmmdrv->Next;
			pmmdrv->Next->Prev = pmmdrv->Prev;

			// Zero memory to help catch reuse bugs
			ZeroMemory(pmmdrv, sizeof(*pmmdrv));
			
			HeapFree(hHeap, 0, pmmdrv);
		}
				
		pmmdrv = pmmdrvNext;
	}

	return;
}

extern BOOL IMixerLoadDrivers( void );
void InitDevices(void)
{
    cPnpEvents = 0;

    // Initialize various lists
    
    ZeroMemory(&wdmDevZ, sizeof(wdmDevZ));
    
    ZeroMemory(&waveoutdrvZ, sizeof(waveoutdrvZ));
    ZeroMemory(&waveindrvZ, sizeof(waveindrvZ));
    waveoutdrvZ.Next = waveoutdrvZ.Prev = &waveoutdrvZ;
    waveindrvZ.Next = waveindrvZ.Prev = &waveindrvZ;

    ZeroMemory(&midioutdrvZ, sizeof(midioutdrvZ));
    ZeroMemory(&midiindrvZ, sizeof(midiindrvZ));
    midioutdrvZ.Next = midioutdrvZ.Prev = &midioutdrvZ;
    midiindrvZ.Next = midiindrvZ.Prev = &midiindrvZ;

    ZeroMemory(&auxdrvZ, sizeof(auxdrvZ));
    auxdrvZ.Next = auxdrvZ.Prev = &auxdrvZ;

    ZeroMemory(&mixerdrvZ, sizeof(mixerdrvZ));
    mixerdrvZ.Next = mixerdrvZ.Prev = &mixerdrvZ;

    // Now initialize different device classes
    
    WaveInit();

    //
    // The server only needs wave to do message beeps.
    //

    if (!WinmmRunningInServer) {
        MidiInit();
        if (!TimeInit()) {
            dprintf1(("Failed to initialize timer services"));
        }
        midiEmulatorInit();
        AuxInit();
        JoyInit();
        MixerInit();
//      IMixerLoadDrivers();

        //
        // Clear up any drivers which don't have any devices (we do it this
        // way so we don't keep loading and unloading mmdrv.dll).
        //
        // Note - we only load the mappers if there are real devices so we
        // don't need to worry about unloading them.
        //
        
        FreeUnusedDrivers(&waveindrvZ);
        FreeUnusedDrivers(&midioutdrvZ);
        FreeUnusedDrivers(&midiindrvZ);
        FreeUnusedDrivers(&auxdrvZ);
    }
    FreeUnusedDrivers(&waveoutdrvZ);
}

/*****************************************************************************
 * @doc EXTERNAL MMSYSTEM
 *
 * @api UINT | mmsystemGetVersion | This function returns the current
 * version number of the Multimedia extensions system software.
 *
 * @rdesc The return value specifies the major and minor version numbers of
 * the Multimedia extensions.  The high-order byte specifies the major
 * version number.  The low-order byte specifies the minor version number.
 *
 ****************************************************************************/
UINT APIENTRY mmsystemGetVersion(void)
{
    return(MMSYSTEM_VERSION);
}


#define MAXDRIVERORDINAL 9

/****************************************************************************

    strings

****************************************************************************/
STATICDT  SZCODE szWodMessage[]    = WOD_MESSAGE;
STATICDT  SZCODE szWidMessage[]    = WID_MESSAGE;
STATICDT  SZCODE szModMessage[]    = MOD_MESSAGE;
STATICDT  SZCODE szMidMessage[]    = MID_MESSAGE;
STATICDT  SZCODE szAuxMessage[]    = AUX_MESSAGE;
STATICDT  SZCODE szMxdMessage[]    = MXD_MESSAGE;

STATICDT  WSZCODE wszWave[]        = L"wave";
STATICDT  WSZCODE wszMidi[]        = L"midi";
STATICDT  WSZCODE wszAux[]         = L"aux";
STATICDT  WSZCODE wszMixer[]       = L"mixer";
STATICDT  WSZCODE wszMidiMapper[]  = L"midimapper";
STATICDT  WSZCODE wszWaveMapper[]  = L"wavemapper";
STATICDT  WSZCODE wszAuxMapper[]   = L"auxmapper";
STATICDT  WSZCODE wszMixerMapper[] = L"mixermapper";

          WSZCODE wszNull[]        = L"";
          WSZCODE wszSystemIni[]   = L"system.ini";
          WSZCODE wszDrivers[]     = DRIVERS_SECTION;

/*
**  WaveMapperInit
**
**  Initialize the wave mapper if it's not already initialized.
**
*/
BOOL WaveMapperInitialized = FALSE;
void WaveMapperInit(void)
{
    HDRVR h = NULL;
    BOOL  fLoadOutput = TRUE;
    BOOL  fLoadInput  = TRUE;

    EnterNumDevs("WaveMapperInit");
    EnterCriticalSection(&MapperInitCritSec);

    if (WaveMapperInitialized) {
        LeaveCriticalSection(&MapperInitCritSec);
        LeaveNumDevs("WaveMapperInit");
        return;
    }

    /* The wave mapper.
     *
     * MMSYSTEM allows the user to install a special wave driver which is
     * not visible to the application as a physical device (it is not
     * included in the number returned from getnumdevs).
     *
     * An application opens the wave mapper when it does not care which
     * physical device is used to input or output waveform data. Thus
     * it is the wave mapper's task to select a physical device that can
     * render the application-specified waveform format or to convert the
     * data into a format that is renderable by an available physical
     * device.
     */

    if (wTotalWaveInDevs + wTotalWaveOutDevs > 0)
    {
        if (0 != (h = mmDrvOpen(wszWaveMapper)))
        {
            fLoadOutput = mmDrvInstall(h, wszWaveMapper, NULL, MMDRVI_MAPPER|MMDRVI_WAVEOUT|MMDRVI_HDRV);

            if (!WinmmRunningInServer) {
                h = mmDrvOpen(wszWaveMapper);
                fLoadInput = mmDrvInstall(h, wszWaveMapper, NULL, MMDRVI_MAPPER|MMDRVI_WAVEIN |MMDRVI_HDRV);
            }
        }

        WaveMapperInitialized |= ((0 != h) && (fLoadOutput) && (fLoadInput))?TRUE:FALSE;
    }

    LeaveCriticalSection(&MapperInitCritSec);
    LeaveNumDevs("WaveMapperInit");
}

/*
**  MidiMapperInit
**
**  Initialize the MIDI mapper if it's not already initialized.
**
*/
BOOL MidiMapperInitialized = FALSE;
void MidiMapperInit(void)
{
    HDRVR h;

    EnterNumDevs("MidiMapperInit");
    EnterCriticalSection(&MapperInitCritSec);

    if (MidiMapperInitialized) {
        LeaveCriticalSection(&MapperInitCritSec);
        LeaveNumDevs("MidiMapperInit");
        return;
    }

    /* The midi mapper.
     *
     * MMSYSTEM allows the user to install a special midi driver which is
     * not visible to the application as a physical device (it is not
     * included in the number returned from getnumdevs).
     *
     * An application opens the midi mapper when it does not care which
     * physical device is used to input or output midi data. It
     * is the midi mapper's task to modify the midi data so that it is
     * suitable for playback on the connected synthesizer hardware.
     */

//    EnterNumDevs("MidiMapperInit");
    if (wTotalMidiInDevs + wTotalMidiOutDevs > 0)
    {
        if (0 != (h = mmDrvOpen(wszMidiMapper)))
        {
            mmDrvInstall(h, wszMidiMapper, NULL, MMDRVI_MAPPER|MMDRVI_MIDIOUT|MMDRVI_HDRV);

            h = mmDrvOpen(wszMidiMapper);
            mmDrvInstall(h, wszMidiMapper, NULL, MMDRVI_MAPPER|MMDRVI_MIDIIN |MMDRVI_HDRV);
        }

        MidiMapperInitialized = TRUE;
    }
//    LeaveNumDevs("MidiMapperInit");

    LeaveCriticalSection(&MapperInitCritSec);
    LeaveNumDevs("MidiMapperInit");
}

/*****************************************************************************
 * @doc INTERNAL  WAVE
 *
 * @api BOOL | WaveInit | This function initialises the wave services.
 *
 * @rdesc Returns TRUE if the services of all loaded wave drivers are
 *      correctly initialised, FALSE if an error occurs.
 *
 * @comm the wave devices are loaded in the following order
 *
 *      \Device\WaveIn0
 *      \Device\WaveIn1
 *      \Device\WaveIn2
 *      \Device\WaveIn3
 *
 ****************************************************************************/
BOOL WaveInit(void)
{
    WCHAR szKey[ (sizeof(wszWave) + sizeof( WCHAR )) / sizeof( WCHAR ) ];
    int i;
    HDRVR h;

    // Find the real WAVE drivers

    lstrcpyW(szKey, wszWave);
    szKey[ (sizeof(szKey) / sizeof( WCHAR ))  - 1 ] = (WCHAR)'\0';
    for (i=0; i<=MAXDRIVERORDINAL; i++)
    {
        h = mmDrvOpen(szKey);
        if (h)
        {
            mmDrvInstall(h, szKey, NULL, MMDRVI_WAVEOUT|MMDRVI_HDRV);

            if (!WinmmRunningInServer) {
                h = mmDrvOpen(szKey);
                mmDrvInstall(h, szKey, NULL, MMDRVI_WAVEIN |MMDRVI_HDRV);
            }
        }
        szKey[ (sizeof(wszWave) / sizeof(WCHAR)) - 1] = (WCHAR)('1' + i);
    }

    return TRUE;
}

BOOL WaveReInit(void)
{
    WCHAR szKey[ (sizeof(wszWave) + sizeof( WCHAR )) / sizeof( WCHAR ) ];
    int i;
    HDRVR h;

    EnterCriticalSection(&NumDevsCritSec);
    
    // Find the real WAVE drivers

    lstrcpyW(szKey, wszWave);
    szKey[ (sizeof(szKey) / sizeof( WCHAR ))  - 1 ] = (WCHAR)'\0';
    for (i=0; i<=MAXDRIVERORDINAL; i++)
    {
        h = mmDrvOpen(szKey);
        if (h)
        {
            mmDrvInstall(h, szKey, NULL, MMDRVI_WAVEOUT|MMDRVI_HDRV);

            if (!WinmmRunningInServer) {
                h = mmDrvOpen(szKey);
                mmDrvInstall(h, szKey, NULL, MMDRVI_WAVEIN |MMDRVI_HDRV);
            }
        }
        szKey[ (sizeof(wszWave) / sizeof(WCHAR)) - 1] = (WCHAR)('1' + i);
    }

    FreeUnusedDrivers(&waveoutdrvZ);

    LeaveCriticalSection(&NumDevsCritSec);

    return TRUE;
}
/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api BOOL | MidiInit | This function initialises the midi services.
 *
 * @rdesc The return value is TRUE if the services are initialised, FALSE if
 *      an error occurs
 *
 * @comm the midi devices are loaded from SYSTEM.INI in the following order
 *
 *      midi
 *      midi1
 *      midi2
 *      midi3
 *
****************************************************************************/
BOOL MidiInit(void)
{
    WCHAR szKey[ (sizeof(wszMidi) + sizeof( WCHAR )) / sizeof( WCHAR ) ];
    int   i;
    HDRVR h;

    // Find the real MIDI drivers

    lstrcpyW(szKey, wszMidi);
    szKey[ (sizeof(szKey) / sizeof( WCHAR ))  - 1 ] = (WCHAR)'\0';
    for (i=0; i<=MAXDRIVERORDINAL; i++)
    {
        h = mmDrvOpen(szKey);
        if (h)
        {
            mmDrvInstall(h, szKey, NULL, MMDRVI_MIDIOUT|MMDRVI_HDRV);

            h = mmDrvOpen(szKey);
            mmDrvInstall(h, szKey, NULL, MMDRVI_MIDIIN |MMDRVI_HDRV);
        }

        szKey[ (sizeof(wszMidi) / sizeof(WCHAR)) - 1] = (WCHAR)('1' + i);
    }

    return TRUE;
}

/*****************************************************************************
 * @doc INTERNAL  AUX
 *
 * @api BOOL | AuxInit | This function initialises the auxiliary output
 *  services.
 *
 * @rdesc The return value is TRUE if the services are initialised, FALSE if
 *      an error occurs
 *
 * @comm SYSTEM.INI is searched for auxn.drv=.... where n can be from 1 to 4.
 *      Each driver is loaded and the number of devices it supports is read
 *      from it.
 *
 *      AUX devices are loaded from SYSTEM.INI in the following order
 *
 *      aux
 *      aux1
 *      aux2
 *      aux3
 *
 ****************************************************************************/
BOOL AuxInit(void)
{
    WCHAR szKey[ (sizeof(wszAux) + sizeof( WCHAR )) / sizeof( WCHAR ) ];
    int   i;
    HDRVR h;

    // Find the real Aux drivers

    lstrcpyW(szKey, wszAux);
    szKey[ (sizeof(szKey) / sizeof( WCHAR ))  - 1 ] = (WCHAR)'\0';
    for (i=0; i<=MAXDRIVERORDINAL; i++)
    {
        h = mmDrvOpen(szKey);
        if (h)
        {
            mmDrvInstall(h, szKey, NULL, MMDRVI_AUX|MMDRVI_HDRV);
        }

        // advance driver ordinal
        szKey[ (sizeof(wszAux) / sizeof(WCHAR)) - 1] = (WCHAR)('1' + i);
    }

    /* The aux mapper.
     *
     * MMSYSTEM allows the user to install a special aux driver which is
     * not visible to the application as a physical device (it is not
     * included in the number returned from getnumdevs).
     *
     * I'm not sure why anyone would do this but I'll provide the
     * capability for symmetry.
     *
     */

    if (wTotalAuxDevs > 0)
    {
        h = mmDrvOpen(wszAuxMapper);
        if (h)
        {
            mmDrvInstall(h, wszAuxMapper, NULL, MMDRVI_MAPPER|MMDRVI_AUX|MMDRVI_HDRV);
        }
    }

    return TRUE;
}

/*****************************************************************************
 * @doc INTERNAL  MIXER
 *
 * @api BOOL | MixerInit | This function initialises the mixer drivers
 *  services.
 *
 * @rdesc The return value is TRUE if the services are initialised, FALSE if
 *      an error occurs
 *
 * @comm SYSTEM.INI is searched for mixern.drv=.... where n can be from 1 to 4.
 *      Each driver is loaded and the number of devices it supports is read
 *      from it.
 *
 *      MIXER devices are loaded from SYSTEM.INI in the following order
 *
 *      mixer
 *      mixer1
 *      mixer2
 *      mixer3
 *
 ****************************************************************************/
BOOL MixerInit(void)
{
    WCHAR szKey[ (sizeof(wszMixer) + sizeof( WCHAR )) / sizeof( WCHAR ) ];
    int   i;
    HDRVR h;

    // Find the real Mixer drivers

    lstrcpyW(szKey, wszMixer);
    szKey[ (sizeof(szKey) / sizeof( WCHAR ))  - 1 ] = (WCHAR)'\0';
    for (i=0; i<=MAXDRIVERORDINAL; i++)
    {
        h = mmDrvOpen(szKey);
        if (h)
        {
            mmDrvInstall(h, szKey, NULL, MMDRVI_MIXER|MMDRVI_HDRV);
        }

        // advance driver ordinal
        szKey[ (sizeof(wszMixer) / sizeof(WCHAR)) - 1] = (WCHAR)('1' + i);
    }

#ifdef MIXER_MAPPER
    /* The Mixer mapper.
     *
     * MMSYSTEM allows the user to install a special aux driver which is
     * not visible to the application as a physical device (it is not
     * included in the number returned from getnumdevs).
     *
     * I'm not sure why anyone would do this but I'll provide the
     * capability for symmetry.
     *
     */

    if (guTotalMixerDevs > 0)
    {
        h = mmDrvOpen(wszMixerMapper);
        if (h)
        {
            mmDrvInstall(h, wszMixerMapper, NULL, MMDRVI_MAPPER|MMDRVI_MIXER|MMDRVI_HDRV);
        }
    }
#endif

    return TRUE;
}


/*****************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   HANDLE | mmDrvOpen | This function load's an installable driver, but
 *                 first checks weather it exists in the [Drivers] section.
 *
 * @parm LPSTR | szAlias | driver alias to load
 *
 * @rdesc The return value is return value from DrvOpen or NULL if the alias
 *        was not found in the [Drivers] section.
 *
 ****************************************************************************/

HANDLE mmDrvOpen(LPWSTR szAlias)
{
    WCHAR buf[300];    // Make this large to bypass GetPrivate... bug

    if ( winmmGetPrivateProfileString( wszDrivers,
                                       szAlias,
                                       wszNull,
                                       buf,
                                       sizeof(buf) / sizeof(WCHAR),
                                       wszSystemIni) ) {
        return (HANDLE)DrvOpen(szAlias, NULL, 0L);
    }
    else {
        return NULL;
    }
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api HANDLE | mmDrvInstall | This function installs/removes a WAVE/MIDI driver
 *
 * @parm HANDLE | hDriver | Module handle or driver handle containing driver
 *
 * @parm WCHAR * | wszDrvEntry | String corresponding to hDriver to be stored for
 *      later use
 *
 * @parm DRIVERMSGPROC | drvMessage | driver message procedure, if NULL
 *      the standard name will be used (looked for with GetProcAddress)
 *
 * @parm UINT | wFlags | flags
 *
 *      @flag MMDRVI_TYPE      | driver type mask
 *      @flag MMDRVI_WAVEIN    | install driver as a wave input  driver
 *      @flag MMDRVI_WAVEOUT   | install driver as a wave ouput  driver
 *      @flag MMDRVI_MIDIIN    | install driver as a midi input  driver
 *      @flag MMDRVI_MIDIOUT   | install driver as a midi output driver
 *      @flag MMDRVI_AUX       | install driver as a aux driver
 *      @flag MMDRVI_MIXER     | install driver as a mixer driver
 *
 *      @flag MMDRVI_MAPPER    | install this driver as the mapper
 *      @flag MMDRVI_HDRV      | hDriver is a installable driver
 *      @flag MMDRVI_REMOVE    | remove the driver
 *
 *  @rdesc  returns NULL if unable to install driver
 *
 ****************************************************************************/

UINT APIENTRY mmDrvInstall(
    HANDLE hDriver,
    WCHAR * wszDrvEntry,
    DRIVERMSGPROC drvMessage,
    UINT wFlags
    )
{
#define SZ_SIZE 128

    int     i;
    DWORD   dw;
    PMMDRV  pdrvZ;
    PMMDRV  pdrv;
    SIZE_T  cbdrv;
    HANDLE  hModule;
    UINT    msg_num_devs;
    UINT   *pTotalDevs;
    CHAR   *szMessage;
    WCHAR   sz[SZ_SIZE];
    BOOL    fMixerCritSec;

    fMixerCritSec = FALSE;
    pdrvZ = NULL;
    pdrv = NULL;

    if (hDriver && (wFlags & MMDRVI_HDRV))
    {
        hModule = DrvGetModuleHandle(hDriver);
    }
    else
    {
        hModule = hDriver;
        hDriver = NULL;
    }

    switch (wFlags & MMDRVI_TYPE)
    {
        case MMDRVI_WAVEOUT:
      	    pdrvZ        = &waveoutdrvZ;
            cbdrv        = sizeof(WAVEDRV);
            msg_num_devs = WODM_GETNUMDEVS;
            pTotalDevs   = &wTotalWaveOutDevs;
            szMessage    = szWodMessage;
            break;

        case MMDRVI_WAVEIN:
            pdrvZ        = &waveindrvZ;
            cbdrv        = sizeof(WAVEDRV);
            msg_num_devs = WIDM_GETNUMDEVS;
            pTotalDevs   = &wTotalWaveInDevs;
            szMessage    = szWidMessage;
            break;

        case MMDRVI_MIDIOUT:
            pdrvZ        = &midioutdrvZ;
            cbdrv        = sizeof(MIDIDRV);
            msg_num_devs = MODM_GETNUMDEVS;
            pTotalDevs   = &wTotalMidiOutDevs;
            szMessage    = szModMessage;
            break;

        case MMDRVI_MIDIIN:
            pdrvZ        = &midiindrvZ;
            cbdrv        = sizeof(MIDIDRV);
            msg_num_devs = MIDM_GETNUMDEVS;
            pTotalDevs   = &wTotalMidiInDevs;
            szMessage    = szMidMessage;
            break;

       case MMDRVI_AUX:
       	    pdrvZ        = &auxdrvZ;
       	    cbdrv        = sizeof(AUXDRV);
            msg_num_devs = AUXDM_GETNUMDEVS;
            pTotalDevs   = &wTotalAuxDevs;
            szMessage    = szAuxMessage;
            break;

       case MMDRVI_MIXER:
            pdrvZ         = &mixerdrvZ;
            cbdrv         = sizeof(MIXERDRV);
            msg_num_devs = MXDM_GETNUMDEVS;
            pTotalDevs   = &guTotalMixerDevs;
            szMessage    = szMxdMessage;
            break;

         default:
            goto error_exit;
    }

    if (drvMessage == NULL && hModule != NULL)
        drvMessage = (DRIVERMSGPROC)GetProcAddress(hModule, szMessage);

    if (drvMessage == NULL)
        goto error_exit;

    //
    // try to find the driver already installed
    //
    pdrv = pdrvZ->Next;
    while (pdrv != pdrvZ && pdrv->drvMessage != drvMessage) pdrv = pdrv->Next;
    if (pdrv != pdrvZ)
    {
    	pdrv = NULL;
    	goto error_exit;	// we found it, don't reinstall it
    }

    //
    // Make a new MMDRV for the device.
    //
    pdrv = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cbdrv);
    if (!pdrv) goto error_exit;

    pdrv->hDriver     = hDriver;
    pdrv->Usage       = 1;
    pdrv->cookie      = 0;  //  This is 0 for non-WDM drivers.
    pdrv->fdwDriver   = (wFlags & MMDRVI_MAPPER) ? MMDRV_MAPPER : 0;
    pdrv->fdwDriver  |= DrvIsPreXp(hDriver) ? MMDRV_PREXP : 0;
    pdrv->drvMessage  = drvMessage;
    WinAssert(lstrlenA(szMessage) < sizeof(pdrv->wszMessage)/sizeof(WCHAR));
    mbstowcs(pdrv->wszMessage, szMessage, sizeof(pdrv->wszMessage)/sizeof(WCHAR));
    lstrcpyW( pdrv->wszSessProtocol, SessionProtocolName );

    winmmGetPrivateProfileString(wszDrivers,         // ini section
                     wszDrvEntry,        // key name
                     wszDrvEntry,        // default if no match
                     sz,                 // return buffer
                     SZ_SIZE,            // sizeof of return buffer
                     wszSystemIni);      // ini. file

    lstrcpyW(pdrv->wszDrvEntry,sz);

    if (!mmInitializeCriticalSection(&pdrv->MixerCritSec)) goto error_exit;
    fMixerCritSec = TRUE;

    //
    //  Mixer drivers get extra message?!
    //
    if (MMDRVI_MIXER == (wFlags & MMDRVI_TYPE))
    {
        //
        //  send the init message, if the driver returns a error, should we
        //  unload them???
        //
        dw = drvMessage(0, MXDM_INIT,0L,0L,0L);
    }

    //
    // call driver to get num-devices it supports
    //
    dw = drvMessage(0,msg_num_devs,0L,0L,0L);

    //
    //  the device returned a error, or has no devices
    //
    // if (HIWORD(dw) != 0 || LOWORD(dw) == 0)
    if ((HIWORD(dw) != 0) || (0 == LOWORD(dw))) goto error_exit;

    pdrv->NumDevs = LOWORD(dw);

    //
    // dont increment number of dev's for the mapper
    //
    if (!(pdrv->fdwDriver & MMDRV_MAPPER)) *pTotalDevs += pdrv->NumDevs;

    //
    // add to end of the driver list
    //
    mregAddDriver(pdrvZ, pdrv);

    return TRUE;       // return a non-zero value

error_exit:
    if (hDriver && !(wFlags & MMDRVI_REMOVE))
    	DrvClose(hDriver, 0, 0);
    if (fMixerCritSec) DeleteCriticalSection(&pdrv->MixerCritSec);
    WinAssert(pdrv != pdrvZ);
    if (pdrv) HeapFree(hHeap, 0, pdrv);

    return FALSE;

#undef SZ_SIZE
}

/**************************************************************************

wdmDevInterfaceInstall

Notes:
Assumes that the NumDevsCritSec is owned as necessary

**************************************************************************/
HANDLE wdmDevInterfaceInstall
(
    LPCWSTR pszDev,
    LONG    cPnpEvents
)
{
    PWDMDEVICEINTERFACE pwdmDev;
    
    EnterCriticalSection(&NumDevsCritSec);

    //
    //  Look for device interface...
    //
    pwdmDev = wdmDevZ.Next;
    while (pwdmDev)
    {
    	WinAssert(pwdmDev->cUsage);
    	
    	if (!lstrcmpiW(pwdmDev->szDeviceInterface, pszDev))
    	{
    	    pwdmDev->cUsage++;
    	    pwdmDev->cPnpEvents = cPnpEvents;
    	    break;
    	}
    	pwdmDev = pwdmDev->Next;
    }

    if (!pwdmDev)
    {
    	SIZE_T cbszDev;
    	
        //
        //  Device interface not found...
        //
        cbszDev = (lstrlen(pszDev) + 1) * sizeof(pszDev[0]);
        pwdmDev = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(*pwdmDev) + cbszDev);
        if (pwdmDev)
        {
            pwdmDev->cUsage = 1;
            pwdmDev->cPnpEvents = cPnpEvents;
            lstrcpyW(pwdmDev->szDeviceInterface, pszDev);
            
            pwdmDev->Next = wdmDevZ.Next;
            wdmDevZ.Next = pwdmDev;
        }
    }

    LeaveCriticalSection(&NumDevsCritSec);

    return (pwdmDev ? pwdmDev->szDeviceInterface : NULL);
}


/**************************************************************************

wdmDevInterfaceInc

Notes:
Enters/Leaves the NumDevsCritSec

**************************************************************************/
BOOL wdmDevInterfaceInc
(
    PCWSTR dwCookie
)
{
   PWDMDEVICEINTERFACE pwdmDev;
   
    if (NULL == dwCookie)
    {
        return FALSE;
    }

    EnterCriticalSection(&NumDevsCritSec);

    //
    //  Look for device interface...
    //
    pwdmDev = wdmDevZ.Next;
    while (pwdmDev)
    {
    	WinAssert(pwdmDev->cUsage);
    	if (dwCookie == pwdmDev->szDeviceInterface)
    	{
    	    pwdmDev->cUsage++;
            LeaveCriticalSection(&NumDevsCritSec);
            return TRUE;
    	}
    	pwdmDev = pwdmDev->Next;
    }

    //
    //  If we get down here, it means that we're trying to increment the
    //  reference to a interface that doesn't exist anymore
    //
    WinAssert(FALSE);
    LeaveCriticalSection(&NumDevsCritSec);

    return FALSE;
}

/**************************************************************************

wdmDevInterfaceDec

Notes:
Enters/Leaves the NumDevsCritSec

**************************************************************************/
BOOL wdmDevInterfaceDec
(
    PCWSTR  dwCookie
)
{
    PWDMDEVICEINTERFACE pwdmDevPrev;
    
    if (NULL == dwCookie)
    {
        return FALSE;
    }

    EnterCriticalSection(&NumDevsCritSec);

    //
    //  Look for device interface...
    //
    pwdmDevPrev = &wdmDevZ;
    while (pwdmDevPrev->Next)
    {
    	PWDMDEVICEINTERFACE pwdmDev = pwdmDevPrev->Next;

    	WinAssert(pwdmDev->cUsage);
    	
    	if (dwCookie == pwdmDev->szDeviceInterface)
    	{
 	    if (0 == --pwdmDev->cUsage)
	    {
            	pwdmDevPrev->Next = pwdmDev->Next;
            	HeapFree(hHeap, 0, pwdmDev);
	    }
            LeaveCriticalSection(&NumDevsCritSec);
            return TRUE;
    	}
    	pwdmDevPrev = pwdmDev;
    }
	    	
    //
    //  If we get down here it means that we are trying to decrement the
    //  reference to an interface that doesn't exist anymore.
    //

    WinAssert(FALSE);
    LeaveCriticalSection(&NumDevsCritSec);

    return FALSE;
}


//--------------------------------------------------------------------------;
//
//  void CleanUpHandles
//
//  Description:
//      Given a particular subsystem and device interface, cleans up the
//      handles.
//
//  Arguments:
//      UINT uFlags: Has one of MMDRVI_* flags to indictate which class of
//          handle needs to be checked for desertion.
//
//      HANDLE cookie: Device interface
//
//  Return (void):
//
//  History:
//      01/25/99    Fwong       Adding Pnp Support.
//
//--------------------------------------------------------------------------;

void CleanUpHandles
(
    UINT    wFlags,
    PCWSTR  cookie
)
{
    HANDLE  hMM;
    UINT    uType;
    PHNDL   pSearch;
    BOOL    fFound;

    // Convert MMDRVI_* type flags to TYPE_*
    switch(wFlags & MMDRVI_TYPE)
    {
    	case MMDRVI_WAVEOUT:
    	    uType = TYPE_WAVEOUT;
    	    break;
        case MMDRVI_WAVEIN:
            uType = TYPE_WAVEIN;
            break;
    	case MMDRVI_MIDIOUT:
    	    uType = TYPE_MIDIOUT;
    	    break;
    	case MMDRVI_MIDIIN:
    	    uType = TYPE_MIDIIN;
    	    break;
        case MMDRVI_MIXER:
    	    uType = TYPE_MIXER;
    	    break;
    	case MMDRVI_AUX:
    	    uType = TYPE_AUX;
    	    break;
        default:
            uType = TYPE_UNKNOWN;
            WinAssert(TYPE_UNKNOWN != uType);
    }

    //  Note:  Since we are not freeing any handles (just marking them
    //  deserted), we don't have to mess with the HandleListCritSec

    for (pSearch = pHandleList; NULL != pSearch; pSearch = pSearch->pNext)
    {
        if ((cookie != pSearch->cookie) || (uType != pSearch->uType))
        {
            continue;
        }

        //  Both the cookie and type match...

        hMM = PHtoH(pSearch);

        switch (uType)
        {
            case TYPE_WAVEOUT:
                waveOutDesertHandle((HWAVEOUT)hMM);
                break;

            case TYPE_WAVEIN:
                waveInDesertHandle((HWAVEIN)hMM);
                break;

            case TYPE_MIDIOUT:
                midiOutDesertHandle((HMIDIOUT)hMM);
                break;

            case TYPE_MIDIIN:
                midiInDesertHandle((HMIDIIN)hMM);
                break;

            case TYPE_MIXER:
                mixerDesertHandle((HMIXER)hMM);
                break;
                
            case TYPE_AUX:
                //  We don't expect open handles of this type
                WinAssert(TYPE_AUX != uType);
                break;
        }
    }
} // CleanUpHandles()


UINT APIENTRY wdmDrvInstall
(
    HANDLE      hDriver,
    LPTSTR      pszDriverFile,
    HANDLE      cookie,
    UINT        wFlags
)
{
    int             i;
    DWORD           dw;
    PMMDRV          pdrvZ;
    PMMDRV          pdrv;
    SIZE_T          cbdrv;
    HANDLE          hModule;
    UINT            msg_init;
    UINT            msg_num_devs;
    UINT            *pTotalDevs;
    CHAR            *szMessage;
    DRIVERMSGPROC   pfnDrvMessage;
    WCHAR           sz[MAX_PATH];
    BOOL            fMixerCritSec;

//    Squirt("Entering wdmDrvInstall");

    fMixerCritSec = FALSE;

    pdrv = NULL;
    pfnDrvMessage = NULL;

    if (hDriver && (wFlags & MMDRVI_HDRV))
    {
        hModule = DrvGetModuleHandle(hDriver);
    }
    else
    {
        hModule = hDriver;
        hDriver = NULL;
    }

    switch (wFlags & MMDRVI_TYPE)
    {
        case MMDRVI_WAVEOUT:
            pdrvZ        = &waveoutdrvZ;
            cbdrv        = sizeof(WAVEDRV);
            msg_init     = WODM_INIT;
            msg_num_devs = WODM_GETNUMDEVS;
            pTotalDevs   = &wTotalWaveOutDevs;
            szMessage    = szWodMessage;
            break;

        case MMDRVI_WAVEIN:
            pdrvZ        = &waveindrvZ;
            cbdrv        = sizeof(WAVEDRV);
            msg_init     = WIDM_INIT;
            msg_num_devs = WIDM_GETNUMDEVS;
            pTotalDevs   = &wTotalWaveInDevs;
            szMessage    = szWidMessage;
            break;

        case MMDRVI_MIDIOUT:
            pdrvZ        = &midioutdrvZ;
            cbdrv        = sizeof(MIDIDRV);
            msg_init     = MODM_INIT;
            msg_num_devs = MODM_GETNUMDEVS;
            pTotalDevs   = &wTotalMidiOutDevs;
            szMessage    = szModMessage;
            break;

        case MMDRVI_MIDIIN:
            pdrvZ        = &midiindrvZ;
            cbdrv        = sizeof(MIDIDRV);
            msg_init     = MIDM_INIT;
            msg_num_devs = MIDM_GETNUMDEVS;
            pTotalDevs   = &wTotalMidiInDevs;
            szMessage    = szMidMessage;
            break;

       case MMDRVI_AUX:
       	    pdrvZ        = &auxdrvZ;
       	    cbdrv        = sizeof(AUXDRV);
       	    msg_init     = AUXM_INIT;
            msg_num_devs = AUXDM_GETNUMDEVS;
            pTotalDevs   = &wTotalAuxDevs;
            szMessage    = szAuxMessage;
            break;

       case MMDRVI_MIXER:
            pdrvZ        = &mixerdrvZ;
            cbdrv        = sizeof(MIXERDRV);
            msg_init     = MXDM_INIT;
            msg_num_devs = MXDM_GETNUMDEVS;
            pTotalDevs   = &guTotalMixerDevs;
            szMessage    = szMxdMessage;
            break;

        default:
            goto error_exit;
    }

    pfnDrvMessage = (DRIVERMSGPROC)GetProcAddress(hModule, szMessage);

    if (NULL == pfnDrvMessage) goto error_exit;

    //
    // either install or remove the specified driver
    //
    if (wFlags & MMDRVI_REMOVE)
    {
        //
        // try to find the driver already installed
        //
        for (pdrv = pdrvZ->Next; pdrv != pdrvZ; pdrv = pdrv->Next)
        {
       	    if (pdrv->fdwDriver & MMDRV_DESERTED) continue;
            if (cookie) {
                //  This is a wdm driver so we're matching up with cookie.
            	if (pdrv->cookie == cookie) break;
            } else {
                // ISSUE-2001/01/14-FrankYe Will this ever be called
                //    on non WDM driver???
                //  Not WDM driver, so matching up with pfnDrvMessage.
            	if (pdrv->drvMessage == pfnDrvMessage) break;
            }
        }
        
        //
        //  Driver not found.
        //
        if (pdrv == pdrvZ) pdrv = NULL;
        if (NULL == pdrv) goto error_exit;

        //
        // don't decrement number of dev's for the mapper
        //
        // Note: Moved this to before the usage check...
        //
        if (!(pdrv->fdwDriver & MMDRV_MAPPER)) *pTotalDevs -= pdrv->NumDevs;

	//
        //  Mark no devs otherwise the device mapping will be skewed.
        //
        pdrv->NumDevs  = 0;

	//
	//  Mark this driver as removed
	//
	pdrv->fdwDriver |= MMDRV_DESERTED;

	CleanUpHandles(wFlags & MMDRVI_TYPE, pdrv->cookie);

	mregDecUsagePtr(pdrv);

        return TRUE;
    }
    else
    {
        //
        // try to find the driver already installed
        //
        for (pdrv = pdrvZ->Next; pdrv != pdrvZ; pdrv = pdrv->Next)
        {
       	    if (pdrv->fdwDriver & MMDRV_DESERTED) continue;
            if (cookie) {
                //  This is a wdm driver so we're matching up with cookie.
            	if (pdrv->cookie == cookie) break;
            } else {
                // ISSUE-2001/01/14-FrankYe Will this ever be called
                //    on non WDM driver???
                //  Not WDM driver, so matching up with pfnDrvMessage.
            	if (pdrv->drvMessage == pfnDrvMessage) break;
            }
        }

	//
        //  If driver found, don't re-install.
        //
	if (pdrv != pdrvZ)
        {
            pdrv = NULL;
	    goto error_exit;
        }

        //
        // Create a MMDRV for the device
        //
        pdrv = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cbdrv);
        if (!pdrv) goto error_exit;

	//
	//  Initialize MMDRV structure
	//
        pdrv->hDriver     = hDriver;
        pdrv->NumDevs     = 0;
        pdrv->Usage       = 1;
        pdrv->cookie      = cookie;
        pdrv->fdwDriver   = (wFlags & MMDRVI_MAPPER) ? MMDRV_MAPPER : 0;
        pdrv->fdwDriver  |= DrvIsPreXp(hDriver) ? MMDRV_PREXP : 0;
        pdrv->drvMessage  = pfnDrvMessage;
        WinAssert(lstrlenA(szMessage) < sizeof(pdrv->wszMessage)/sizeof(WCHAR));
        mbstowcs(pdrv->wszMessage, szMessage, sizeof(pdrv->wszMessage)/sizeof(WCHAR));
        lstrcpyW(pdrv->wszDrvEntry, pszDriverFile);
        
        if (!mmInitializeCriticalSection(&pdrv->MixerCritSec)) goto error_exit;
        fMixerCritSec = TRUE;

        //
        //  Sending init message
        //
        dw = pfnDrvMessage(0,msg_init,0L,0L,(DWORD_PTR)cookie);

        //
        // call driver to get num-devices it supports
        //
        dw = pfnDrvMessage(0,msg_num_devs,0L,(DWORD_PTR)cookie,0L);

        //
        //  the device returned a error, or has no devices
        //
        if (0 != HIWORD(dw) || 0 == LOWORD(dw)) goto error_exit;

        pdrv->NumDevs = LOWORD(dw);
        
        wdmDevInterfaceInc(cookie);

        // Squirt("Driver [%ls:0x%04x] supports %d devices", pszDriverFile, wFlags & MMDRVI_TYPE, dw);

        //
        // dont increment number of dev's for the mapper
        //
        if (!(pdrv->fdwDriver & MMDRV_MAPPER)) *pTotalDevs += pdrv->NumDevs;

        //
        // add to end of the driver list
        //
        mregAddDriver(pdrvZ, pdrv);

        // Squirt("Installed driver");

        return TRUE;
    }

error_exit:
    // ISSUE-2001/01/05-FrankYe On add, if msg_init was sent it might be good
    //    to also send DRVM_EXIT before closing the driver.
    if (fMixerCritSec) DeleteCriticalSection(&pdrv->MixerCritSec);
    if (pdrv) HeapFree(hHeap, 0, pdrv);
    
    return FALSE;
}

void KickMapper
(
    UINT    uFlags
)
{
    PMMDRV        pmd;
    DWORD         dw;
    DRIVERMSGPROC pfnDrvMessage = NULL;
    MMRESULT      mmr;

    switch (uFlags & MMDRVI_TYPE)
    {
        case MMDRVI_WAVEOUT:
        {
            mmr = waveReferenceDriverById(&waveoutdrvZ, WAVE_MAPPER, &pmd, NULL);
            break;
        }
        
        case MMDRVI_WAVEIN:
        {
            mmr = waveReferenceDriverById(&waveindrvZ, WAVE_MAPPER, &pmd, NULL);
            break;
        }

        case MMDRVI_MIDIOUT:
        {
            mmr = midiReferenceDriverById(&midioutdrvZ, MIDI_MAPPER, &pmd, NULL);
            break;
        }

        case MMDRVI_MIDIIN:
        {
            mmr = midiReferenceDriverById(&midiindrvZ, MIDI_MAPPER, &pmd, NULL);
            break;
        }

        case MMDRVI_AUX:
        {
            mmr = auxReferenceDriverById(AUX_MAPPER, &pmd, NULL);
            break;
        }

        case MMDRVI_MIXER:
        {
            #ifdef MIXER_MAPPER
            mmr = mixerReferenceDriverById(MIXER_MAPPER, &pmd, NULL);
            #else
            mmr = MMSYSERR_NODRIVER;
            #endif
            break;
        }

        default:
            WinAssert(FALSE);
            mmr = MMSYSERR_NODRIVER;
            return;
    }

    if (!mmr)
    {
    	if (pmd->drvMessage)
        {
            pmd->drvMessage(0, DRVM_MAPPER_RECONFIGURE, 0L, 0L, 0L);
        }
    	mregDecUsagePtr(pmd);
    }
}


void wdmDriverLoadClass(
    IN HKEY hkey,
    IN PCTSTR DeviceInterface,
    IN UINT uFlags,
    IN OUT PTSTR *ppstrLeftOverDriver,
    IN OUT HDRVR *phLeftOverDriver)
{
    PTSTR pstrClass;
    HKEY hkeyClass;

    WinAssert((NULL == *ppstrLeftOverDriver) == (NULL == *phLeftOverDriver));

    switch (uFlags & MMDRVI_TYPE) {
    case MMDRVI_WAVEOUT:
    case MMDRVI_WAVEIN:
        pstrClass = TEXT("Drivers\\wave");
        break;
    case MMDRVI_MIDIOUT:
    case MMDRVI_MIDIIN:
        pstrClass = TEXT("Drivers\\midi");
        break;
    case MMDRVI_MIXER:
        pstrClass = TEXT("Drivers\\mixer");
        break;
    case MMDRVI_AUX:
        pstrClass = TEXT("Drivers\\aux");
        break;
    default:
        pstrClass = NULL;
    }

    if (pstrClass && !RegOpenKeyEx(hkey, pstrClass, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hkeyClass)) {
        DWORD cSubkeys;
        PTSTR pstrSubkeyNameBuffer;
        DWORD cchSubkeyNameBuffer;

        if (!RegPrepareEnum(hkeyClass, &cSubkeys, &pstrSubkeyNameBuffer, &cchSubkeyNameBuffer))
        {
            DWORD dwIndex;

            for (dwIndex = 0; dwIndex < cSubkeys; dwIndex++) {
                HKEY hkeyClassDriver;
                if (!RegEnumOpenKey(hkeyClass, dwIndex, pstrSubkeyNameBuffer, cchSubkeyNameBuffer, KEY_QUERY_VALUE, &hkeyClassDriver))
                {
                    PTSTR pstrDriver;
                    if (!RegQuerySzValue(hkeyClassDriver, TEXT("Driver"), &pstrDriver)) {
                        HDRVR h;
                        BOOL fLoaded = FALSE;

                        // dprintf(("wdmDriverLoadClass  %s %ls on %ls", (uFlags & MMDRVI_REMOVE) ? "removing" : "installing", pstrClass, DeviceInterface));

                        EnterCriticalSection(&NumDevsCritSec);
                        
                        if (!*phLeftOverDriver || lstrcmpi(pstrDriver, *ppstrLeftOverDriver))
                        {
                            if (*phLeftOverDriver)
                            {
                                DrvClose(*phLeftOverDriver, 0, 0);
                                HeapFree(hHeap, 0, *ppstrLeftOverDriver);
                            }
                            // dprintf(("wdmDriverLoadClass, opening driver %ls", pstrDriver));
                            h = mmDrvOpen(pstrDriver);
                        } else {
                            HeapFree(hHeap, 0, pstrDriver);
                            h = *phLeftOverDriver;
                            pstrDriver = *ppstrLeftOverDriver;
                        }
                        *phLeftOverDriver = NULL;
                        *ppstrLeftOverDriver = NULL;

                        if (h) {
                            fLoaded = wdmDrvInstall(h, pstrDriver, (HANDLE)DeviceInterface, uFlags | MMDRVI_HDRV);
                        } else {
                            HeapFree(hHeap, 0, pstrDriver);
                            pstrDriver = NULL;
                        }

                        // dprintf(("wdmDriverLoadClass, fLoaded = %s", fLoaded ? "TRUE" : "FALSE"));
                        
                        if (!fLoaded) 
                        {
                            *phLeftOverDriver = h;
                            *ppstrLeftOverDriver = pstrDriver;
                        }
                        
                        LeaveCriticalSection(&NumDevsCritSec);
                    }

                    RegCloseKey(hkeyClassDriver);
                    
                }
            }
            HeapFree(hHeap, 0, pstrSubkeyNameBuffer);
        }
        RegCloseKey(hkeyClass);
    }
}

void wdmDriverLoadAllClasses(IN PCTSTR DeviceInterface, UINT uFlags)
{
    HKEY hkey = NULL;
    LONG result;
    
    // dprintf(("wdmDriverLoadAllClasses on %ls", DeviceInterface));
    result = wdmDriverOpenDrvRegKey(DeviceInterface, KEY_ENUMERATE_SUB_KEYS, &hkey);
    
    if (!result) {
    	HDRVR hUnusedDriver = NULL;
    	PTSTR pstrUnusedDriver = NULL;
    	
        WinAssert(hkey);
        
        wdmDriverLoadClass(hkey, DeviceInterface, uFlags | MMDRVI_WAVEOUT, &pstrUnusedDriver, &hUnusedDriver);
        wdmDriverLoadClass(hkey, DeviceInterface, uFlags | MMDRVI_WAVEIN, &pstrUnusedDriver, &hUnusedDriver);
        wdmDriverLoadClass(hkey, DeviceInterface, uFlags | MMDRVI_MIDIOUT, &pstrUnusedDriver, &hUnusedDriver);
        wdmDriverLoadClass(hkey, DeviceInterface, uFlags | MMDRVI_MIDIIN, &pstrUnusedDriver, &hUnusedDriver);
        wdmDriverLoadClass(hkey, DeviceInterface, uFlags | MMDRVI_AUX, &pstrUnusedDriver, &hUnusedDriver);
        // wdmDriverLoadClass(hkey, DeviceInterface, uFlags | MMDRVI_JOY);
        wdmDriverLoadClass(hkey, DeviceInterface, uFlags | MMDRVI_MIXER, &pstrUnusedDriver, &hUnusedDriver);

        if (hUnusedDriver) {
           WinAssert(pstrUnusedDriver);
           DrvClose(hUnusedDriver, 0, 0);
           HeapFree(hHeap, 0, pstrUnusedDriver);
        }
        
        RegCloseKey(hkey);
    } else {
        dprintf(("wdmDriverLoadAllClasses: wdmDriverOpenDrvRegKey returned error %d", result));
    }
    return;
}

void wdmPnpUpdateDriver
(
    DWORD   dwType,
    LPCWSTR pszID,
    LONG    cPnpEvents
)
{
    HANDLE  cookie;

    cookie = wdmDevInterfaceInstall(pszID, cPnpEvents);

    if(0 == cookie)
    {
        return;
    }

    if(WinmmRunningInServer)
    {
        Squirt("Running in CSRSS?!?!");
        WinAssert(FALSE);
        return;
    }

    // ISSUE-2001/01/16-FrankYe This violates the order in which locks should
    //   be acquired.  The HandleListCritSec should be the last lock taken,
    //   but here it is held while calling other functions that will acquire
    //   NumDevsCritSec.  I'm not sure why we need to acquire
    //   HandleListCritSec here.

    EnterCriticalSection(&HandleListCritSec);

    switch (dwType)
    {
        case DBT_DEVICEARRIVAL:
            // Squirt("wdmPnpUpdateDriver:DBT_DEVICEARRIVAL [%ls]", pszID);
            wdmDriverLoadAllClasses(cookie, 0);
            break;

        case DBT_DEVICEREMOVECOMPLETE:
            // Squirt("wdmPnpUpdateDriver:DBT_DEVICEREMOVECOMPLETE [%ls]", pszID);
            // ISSUE-2001/02/08-FrankYe I think we never DrvClose drivers anymore!
            wdmDriverLoadAllClasses(cookie, MMDRVI_REMOVE);
            break;

        default:
            break;
    }

    LeaveCriticalSection(&HandleListCritSec);

    wdmDevInterfaceDec(cookie);
} // wdmPnpUpdateDriver()


void KickMappers
(
    void
)
{
    KickMapper(MMDRVI_WAVEOUT);
    KickMapper(MMDRVI_WAVEIN);
    KickMapper(MMDRVI_MIDIOUT);
    KickMapper(MMDRVI_MIDIIN);
    KickMapper(MMDRVI_AUX);
    KickMapper(MMDRVI_MIXER);
}

BOOL ClientPnpChange(void)
{
    BOOL                    fDeviceChange;
    PMMPNPINFO              pPnpInfo;
    LONG                    cbPnpInfo;
    PMMDEVICEINTERFACEINFO  pdii;
    UINT                    ii;

    fDeviceChange = FALSE;

    if (ERROR_SUCCESS != winmmGetPnpInfo(&cbPnpInfo, &pPnpInfo)) return fDeviceChange;
    

    //  Always grab NumDevsCriticalSection before DriverLoadFree CS
    EnterCriticalSection(&NumDevsCritSec);
    EnterCriticalSection(&DriverLoadFreeCritSec);

    cPnpEvents = pPnpInfo->cPnpEvents;
        
    //  Adding new instances...

    pdii = (PMMDEVICEINTERFACEINFO)&(pPnpInfo[1]);
    pdii = PAD_POINTER(pdii);

    for (ii = pPnpInfo->cDevInterfaces; ii; ii--)
    {
        PWDMDEVICEINTERFACE pwdmDev;
        PWSTR pstr;
        UINT  jj;

        pstr = &(pdii->szName[0]);

	pwdmDev = wdmDevZ.Next;
	while (pwdmDev)
	{
	    WinAssert(pwdmDev->cUsage);
            {
                if (0 == lstrcmpi(pwdmDev->szDeviceInterface, pstr))
                {
                    if (pdii->cPnpEvents > pwdmDev->cPnpEvents)
                    {
                        //  if it has to be updated it must be removed first...
                        wdmPnpUpdateDriver(DBT_DEVICEREMOVECOMPLETE, pstr, 0);
                        if (0 == (pdii->fdwInfo & MMDEVICEINFO_REMOVED))
                        {
                            wdmPnpUpdateDriver(DBT_DEVICEARRIVAL, pstr, pdii->cPnpEvents);
                        }

                        fDeviceChange = TRUE;
                    }

                    break;
                }
                pwdmDev = pwdmDev->Next;
            }
        }

        if (!pwdmDev)
        {
            //  Device interface should be installed.

            if (0 == (pdii->fdwInfo & MMDEVICEINFO_REMOVED))
            {
                wdmPnpUpdateDriver(DBT_DEVICEARRIVAL, pstr, pdii->cPnpEvents);
            }

            fDeviceChange = TRUE;
        }

        pdii = (PMMDEVICEINTERFACEINFO)(pstr + lstrlenW(pstr) + 1);
        pdii = PAD_POINTER(pdii);
        pstr = (PWSTR)(&pdii[1]);
    }

    LeaveCriticalSection(&DriverLoadFreeCritSec);
    LeaveCriticalSection(&NumDevsCritSec);

    HeapFree(hHeap, 0, pPnpInfo);

    return fDeviceChange;
        
}

void ClientUpdatePnpInfo(void)
{
    static BOOL fFirstCall = TRUE;
    static BOOL InThisFunction = FALSE;
    BOOL fWasFirstCall;

    if (IsWinlogon() && !gfLogon)
    {
    	dprintf(("ClientUpdatePnpInfo: warning: called in winlogon before logged on"));
    	return;
    }

    fWasFirstCall = InterlockedExchange(&fFirstCall, FALSE);
    if (fWasFirstCall)
    {
    	// Note AudioSrvBinding happens in WinmmLogon for winlogon
    	winmmWaitForService();
        if (!IsWinlogon()) AudioSrvBinding();

        if (NULL == pClientPnpInfo) {
            hClientPnpInfo = OpenFileMapping(FILE_MAP_READ, FALSE, MMGLOBALPNPINFONAME);
            if (hClientPnpInfo) {
                pClientPnpInfo = MapViewOfFile(hClientPnpInfo, FILE_MAP_READ, 0, 0, 0);
                if (!pClientPnpInfo) {
                    CloseHandle(hClientPnpInfo);
                    hClientPnpInfo = NULL;
                }
            }
            if (!hClientPnpInfo) dprintf(("ClientUpdatePnpInfo: WARNING: Could not OpenFileMapping"));
        }

        SetEvent(hEventApiInit);

    } else {
        WaitForSingleObjectEx(hEventApiInit, INFINITE, FALSE);
    }


    EnterCriticalSection(&PnpCritSec);
    if (!InterlockedExchange(&InThisFunction, TRUE))
    {
        BOOL fDeviceChange;
        BOOL fPreferredDeviceChange;
        
        fPreferredDeviceChange = CheckSessionChanged();

        fDeviceChange = FALSE;

        if (pClientPnpInfo && (cPnpEvents != pClientPnpInfo->cPnpEvents)) fDeviceChange = ClientPnpChange();

        if (fDeviceChange) InvalidatePreferredDevices();

        fPreferredDeviceChange |= (pClientPnpInfo && (cPreferredDeviceChanges != pClientPnpInfo->cPreferredDeviceChanges));
        if (fPreferredDeviceChange && pClientPnpInfo) cPreferredDeviceChanges = pClientPnpInfo->cPreferredDeviceChanges;

        if (fWasFirstCall || fDeviceChange || fPreferredDeviceChange) RefreshPreferredDevices();

        if (fDeviceChange) KickMappers();

        InterlockedExchange(&InThisFunction, FALSE);
    }
    LeaveCriticalSection(&PnpCritSec);
    
}

void WinmmLogon(BOOL fConsole)
{
 // dprintf(("WinmmLogon (%s session)", fConsole ? "console" : "remote"));

    WinAssert(IsWinlogon());
    WinAssert(!gfLogon);
 // WinAssert(fConsole ? !WinmmRunningInSession : WinmmRunningInSession);
    if (!IsWinlogon()) return;
    AudioSrvBinding();
    gfLogon = TRUE;
    // ISSUE-2001/05/04-FrankYe This is a NOP now, should remove this and 
    //   implementation in audiosrv.
    gfxLogon(GetCurrentProcessId());
    return;
}

void WinmmLogoff(void)
{
    HANDLE handle;
 // dprintf(("WinmmLogoff"));
    WinAssert(IsWinlogon());
    WinAssert(gfLogon);
    if (!IsWinlogon()) return;
    gfxLogoff();
    
    // It is very important to close this context handle now because it is associated
    // with the logged on user.  Otherwise the handle remains open, associated with the
    // logged on user, even after he logs off.
    if (ghSessionNotification)
    {
        WinAssert(ghSessionNotificationEvent);
        winmmUnregisterSessionNotification(ghSessionNotification);
        CloseHandle(ghSessionNotificationEvent);
        ghSessionNotification = NULL;
        ghSessionNotificationEvent = NULL;
    }
    else
    {
        WinAssert(!ghSessionNotificationEvent);
    }
    
    AudioSrvBindingFree();
    gfLogon = FALSE;
    return;
}

/*
 *************************************************************************
 *   MigrateSoundEvents
 *
 *      Description:
 *              Looks at the sounds section in win.ini for sound entries.
 *              Gets a current scheme name from the current section in control.ini
 *              Failing that it tries to find the current scheme in the registry
 *              Failing that it uses .default as the current scheme.
 *              Copies each of the entries in the win.ini sound section into the
 *              registry under the scheme name obtained
 *              If the scheme name came from control.ini, it creates a key from the
 *              scheme name. This key is created by removing all the existing spaces
 *              in the scheme name. This key and scheme name is added to the registry
 *
 *************************************************************************
 */
// ISSUE-2000/10/30-FrankYe Delete Winlogon's call to this function, then
//    delete this function
void MigrateAllDrivers(void)
{
    return;
}

void MigrateSoundEvents (void)
{
    TCHAR   aszEvent[SCH_TYPE_MAX_LENGTH];

    // If a MediaPathUnexpanded key exists (it will be something
    // like "%SystemRoot%\Media"), expand it into a fully-qualified
    // path and write out a matching MediaPath key (which will look
    // like "c:\win\media").  This is done every time we enter the
    // migration path, whether or not there's anything else to do.
    //
    // Setup would like to write the MediaPath key with the
    // "%SystemRoot%" stuff still in it--but while we could touch
    // our apps to understand expansion, any made-for-Win95 apps
    // probably wouldn't think to expand the string, and so wouldn't
    // work properly.  Instead, it writes the MediaPathUnexpanded
    // key, and we make sure that the MediaPath key is kept up-to-date
    // in the event that the Windows drive gets remapped (isn't
    // NT cool that way?).
    //
            
    if (mmRegQueryMachineValue (aszSetup, aszValMediaUnexpanded,
                                cchLENGTH(aszEvent), aszEvent))
    {
        WCHAR szExpanded[MAX_PATH];

        ExpandEnvironmentStrings (aszEvent, szExpanded, cchLENGTH(szExpanded));
        mmRegSetMachineValue (aszSetup, aszValMedia, szExpanded);
    }
}

int lstrncmpi (LPTSTR pszA, LPTSTR pszB, size_t cch)
{
#ifdef UNICODE
   size_t  cchA, cchB;
   TCHAR  *pch;

   for (cchA = 1, pch = pszA; cchA < cch; cchA++, pch++)
      {
      if (*pch == TEXT('\0'))
         break;
      }
   for (cchB = 1, pch = pszB; cchB < cch; cchB++, pch++)
      {
      if (*pch == TEXT('\0'))
         break;
      }

   return (CompareStringW (GetThreadLocale(), NORM_IGNORECASE,
                           pszA, cchA, pszB, cchB)
          )-2;  // CompareStringW returns {1,2,3} instead of {-1,0,1}.
#else
   return strnicmp (pszA, pszB, cch);
#endif
}

#if DBG

void Squirt(LPSTR lpszFormat, ...)
{
    char buf[512];
    UINT n;
    va_list va;

    n = wsprintfA(buf, "WINMM: (pid %x) ", GetCurrentProcessId());

    va_start(va, lpszFormat);
    n += vsprintf(buf+n, lpszFormat, va);
    va_end(va);

    buf[n++] = '\n';
    buf[n] = 0;
    OutputDebugStringA(buf);
    Sleep(0);  // let terminal catch up
}

#else

void Squirt(LPSTR lpszFormat, ...)
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\daytona\makefile.inc ===
audiosrv.idl : ..\..\audiosrv\audiosrv.idl
        copy ..\..\audiosrv\audiosrv.idl ..

audiosrv.acf : ..\..\audiosrv\audiosrv.acf
        copy ..\..\audiosrv\audiosrv.acf ..
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\wave.c ===
/****************************************************************************
    wave.c

    Level 1 kitchen sink DLL wave support module

    Copyright (c) 1990-2001 Microsoft Corporation

    Changes for NT :
        Change parameters for MapWaveId to return the driver index rather
        than a pointer

        change list of include files

        widen function parameters and return codes

        Change WINAPI to APIENTRY
****************************************************************************/

#include "winmmi.h"

/****************************************************************************

    local structures

****************************************************************************/

typedef struct wavedev_tag {
    PWAVEDRV    wavedrv;
    UINT        wDevice;
    DWORD_PTR   dwDrvUser;
    UINT        uDeviceID;
    DWORD       fdwHandle;
} WAVEDEV, *PWAVEDEV;

extern UINT gRealWaveOutPreferredId;
extern UINT gRealWaveInPreferredId;
extern BOOL WaveMapperInitialized; // Wave mapper safely loaded

/*****************************************************************************
 * @doc INTERNAL  WAVE validation code for WAVEHDRs
 *
 ****************************************************************************/

#define IsWaveHeaderPrepared(hWave, lpwh)      ((lpwh)->dwFlags &  WHDR_PREPARED)
#define MarkWaveHeaderPrepared(hWave, lpwh)    ((lpwh)->dwFlags |= WHDR_PREPARED)
#define MarkWaveHeaderUnprepared(hWave, lpwh)  ((lpwh)->dwFlags &=~WHDR_PREPARED)

/*****************************************************************************
 * @doc INTERNAL  WAVE
 *
 * @api MMRESULT | wavePrepareHeader | This function prepares the header and data
 *   if the driver returns MMSYSERR_NOTSUPPORTED.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it
 *   specifies an error number.
 ****************************************************************************/
STATIC MMRESULT wavePrepareHeader(LPWAVEHDR lpWaveHdr, UINT wSize)
{
    if (!HugePageLock(lpWaveHdr, (DWORD)sizeof(WAVEHDR)))
        return MMSYSERR_NOMEM;

    if (!HugePageLock(lpWaveHdr->lpData, lpWaveHdr->dwBufferLength)) {
        HugePageUnlock(lpWaveHdr, (DWORD)sizeof(WAVEHDR));
        return MMSYSERR_NOMEM;
    }

    lpWaveHdr->dwFlags |= WHDR_PREPARED;

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc INTERNAL  WAVE
 *
 * @api MMRESULT | waveUnprepareHeader | This function unprepares the header and
 *   data if the driver returns MMSYSERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns MMSYSERR_NOERROR.
 ****************************************************************************/
STATIC MMRESULT waveUnprepareHeader(LPWAVEHDR lpWaveHdr, UINT wSize)
{
    HugePageUnlock(lpWaveHdr->lpData, lpWaveHdr->dwBufferLength);
    HugePageUnlock(lpWaveHdr, (DWORD)sizeof(WAVEHDR));

    lpWaveHdr->dwFlags &= ~WHDR_PREPARED;

    return MMSYSERR_NOERROR;
}

/****************************************************************************
 * @doc INTERNAL  WAVE
 *
 * @api MMRESULT | waveReferenceDriverById | This function maps a logical id
 *   to a device driver and physical id.
 *
 * @parm IN PWAVEDRV | pwavedrvZ | The list of wave drivers.
 *
 * @parm IN UINT | id | The logical id to be mapped.
 *
 * @parm OUT PWAVEDRV* OPTIONAL | ppwavedrv | Pointer to WAVEDRV structure
 *    describing the driver supporting the id.
 *
 * @parm OUT UINT* OPTIONAL | pport | The driver-relative device number. If
 *    the caller supplies this buffer then it must also supply ppwavedrv.
 *
 * @rdesc The return value is zero if successful, MMSYSERR_BADDEVICEID if
 *   the id is out of range.
 *
 * @comm If the caller specifies ppwavedrv then this function increments
 *       the wavedrv's usage before returning.  The caller must ensure
 *       the usage is eventually decremented.
 *
 ****************************************************************************/
MMRESULT waveReferenceDriverById(
    IN PWAVEDRV pwavedrvZ,
    IN UINT id,
    OUT PWAVEDRV *ppwavedrv OPTIONAL,
    OUT UINT *pport OPTIONAL
)
{
    PWAVEDRV pwavedrv;
    MMRESULT mmr;

    // Should not be called asking for port but not wavedrv
    WinAssert(!(pport && !ppwavedrv));
    
    if (id == WAVE_MAPPER) {
        /*
        **  Make sure we've tried to load it
        */
        WaveMapperInit();
        // WinAssert(((WaveMapperInitialized) || (0 == wTotalWaveInDevs + wTotalWaveOutDevs)));
    }

    EnterNumDevs("waveReferenceDriverById");

    if (WAVE_MAPPER == id)
    {
        id = 0;
    	for (pwavedrv = pwavedrvZ->Next; pwavedrv != pwavedrvZ; pwavedrv = pwavedrv->Next)
    	{
	    if (pwavedrv->fdwDriver & MMDRV_MAPPER) break;
	}
    } else {
    	for (pwavedrv = pwavedrvZ->Next; pwavedrv != pwavedrvZ; pwavedrv = pwavedrv->Next)
	{
	    if (pwavedrv->fdwDriver & MMDRV_MAPPER) continue;
	    if (pwavedrv->NumDevs > id) break;
	    id -= pwavedrv->NumDevs;
	}
    }

    if (pwavedrv != pwavedrvZ)
    {
    	if (ppwavedrv) {
    	    mregIncUsagePtr(pwavedrv);
    	    *ppwavedrv = pwavedrv;
    	    if (pport) *pport = id;
    	}
    	mmr = MMSYSERR_NOERROR;
    } else {
    	mmr = MMSYSERR_BADDEVICEID;
    }

    LeaveNumDevs("waveReferenceDriverById");

    return mmr;
}

PCWSTR waveReferenceDevInterfaceById(PWAVEDRV pdrvZ, UINT_PTR id)
{

    PWAVEDRV pdrv;
    PCWSTR DevInterface;
    
    if ((pdrvZ == &waveoutdrvZ && ValidateHandle((HANDLE)id, TYPE_WAVEOUT)) ||
        (pdrvZ == &waveindrvZ  && ValidateHandle((HANDLE)id, TYPE_WAVEIN)))
    {
    	DevInterface = ((PWAVEDEV)id)->wavedrv->cookie;
    	if (DevInterface) wdmDevInterfaceInc(DevInterface);
    	return DevInterface;
    }

    if (!waveReferenceDriverById(pdrvZ, (UINT)id, &pdrv, NULL))
    {
    	DevInterface = pdrv->cookie;
    	if (DevInterface) wdmDevInterfaceInc(DevInterface);
    	mregDecUsagePtr(pdrv);
    	return DevInterface;
    }

    return NULL;
}

/*****************************************************************************
 * @doc INTERNAL  WAVE
 *
 * @func MMRESULT | waveMessage | This function sends messages to the waveform
 *   output device drivers.
 *
 * @parm HWAVE | hWave | The handle to the audio device.
 *
 * @parm UINT | wMsg | The message to send.
 *
 * @parm DWORD | dwP1 | Parameter 1.
 *
 * @parm DWORD | dwP2 | Parameter 2.
 *
 * @rdesc Returns the value returned from the driver.
 ****************************************************************************/
STATIC MMRESULT waveMessage(HWAVE hWave, UINT msg, DWORD_PTR dwP1, DWORD_PTR dwP2)
{
    MMRESULT mrc;

    ENTER_MM_HANDLE(hWave);       // Serialize on handle
    
    ReleaseHandleListResource();
    
    //  Is handle deserted?
    if (IsHandleDeserted(hWave))
    {
        LEAVE_MM_HANDLE(hWave);
        return (MMSYSERR_NODRIVER);
    }
    
    //  Are we busy (in the middle of an open/close)?
    if (IsHandleBusy(hWave))
    {
        LEAVE_MM_HANDLE(hWave);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  ISSUE:  We should no longer have to check for invalid handle... every
    //  function that calls this check with with a read lock on the handle
    //  resource.
    if (BAD_HANDLE(hWave, TYPE_WAVEOUT) && BAD_HANDLE(hWave, TYPE_WAVEIN)) {
	    WinAssert(!"Bad Handle within waveMessage");
        mrc = MMSYSERR_INVALHANDLE;
    } else {
        mrc = (MMRESULT)(*(((PWAVEDEV)hWave)->wavedrv->drvMessage))
            (((PWAVEDEV)hWave)->wDevice, msg, ((PWAVEDEV)hWave)->dwDrvUser, dwP1, dwP2);
    }

    LEAVE_MM_HANDLE(hWave);

    return mrc;
}

/****************************************************************************
 * @doc INTERNAL  WAVE
 *
 * @func MMRESULT | waveIDMessage | This function sends a message to the device
 * ID specified.  It also performs error checking on the ID passed.
 *
 * @parm PWAVEDRV | wavedrv | Pointer to the input or output device list.
 *
 * @parm UINT | wTotalNumDevs | Total number of devices in device list.
 *
 * @parm UINT | uDeviceID | Device ID to send message to.
 *
 * @parm UINT | wMessage | The message to send.
 *
 * @parm DWORD | dwParam1 | Parameter 1.
 *
 * @parm DWORD | dwParam2 | Parameter 2.
 *
 * @rdesc The return value is the low word of the returned message.
 ***************************************************************************/
// ISSUE-2001/01/09-FrankYe This should take UINT_PTR uDeviceID if we expect
//    it to accept handles.  If we change it, then review all calls to this
//    function.
STATIC  MMRESULT waveIDMessage(
    PWAVEDRV    pwavedrvZ,
    UINT        wTotalNumDevs,
    UINT_PTR    uDeviceID,
    UINT        wMessage,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2)
{
    DWORD     mmr;
    DWORD     dwClass;
    UINT      port;
    PWAVEDRV  wavedrv;

    if (uDeviceID>=wTotalNumDevs && uDeviceID!=WAVE_MAPPER) {
        // this cannot be a device ID.
        // it could be a wave handle.  Try it.
        // First we have to verify which type of handle it is (OUT or IN)
        // We can work this out as waveIDMessage is only ever called with
        // pwavedrvZ == &waveoutdrvZ or &waveindrvZ

        if ((pwavedrvZ == &waveoutdrvZ && ValidateHandle((HANDLE)uDeviceID, TYPE_WAVEOUT))
         || (pwavedrvZ == &waveindrvZ && ValidateHandle((HANDLE)uDeviceID, TYPE_WAVEIN) ))
        {

            if (0 != (((PWAVEDEV)uDeviceID)->wavedrv->fdwDriver & MMDRV_DESERTED))
            {
                //  The driver has been deserted, all calls should return
                //  MMSYSERR_NODRIVER.
	        return MMSYSERR_NODRIVER;
            }

            dprintf2(("waveIDMessage passed ID==%x, translating to handle", uDeviceID));
            // to preserve as much compatibility with previous code paths
            // we do NOT call waveMessage as that calls ENTER_MM_HANDLE

            return (MMRESULT)(*(((PWAVEDEV)uDeviceID)->wavedrv->drvMessage))
                             (((PWAVEDEV)uDeviceID)->wDevice,
                             wMessage,
                            ((PWAVEDEV)uDeviceID)->dwDrvUser, dwParam1, dwParam2);
        } else {
            return(MMSYSERR_BADDEVICEID);
        }
    }

    mmr = waveReferenceDriverById(pwavedrvZ, (UINT)uDeviceID, &wavedrv, &port);
    if (mmr)
    {
    	return mmr;
    }
    
    if (pwavedrvZ == &waveindrvZ)
       dwClass = TYPE_WAVEIN;
    else if (pwavedrvZ == &waveoutdrvZ)
       dwClass = TYPE_WAVEOUT;
    else
       dwClass = TYPE_UNKNOWN;

    if (!wavedrv->drvMessage)
    {
    	mmr = MMSYSERR_NODRIVER;
    }
    else if (!mregHandleInternalMessages(wavedrv, dwClass, port, wMessage, dwParam1, dwParam2, &mmr))
    {
    	mmr = (MMRESULT)((*(wavedrv->drvMessage))(port, wMessage, 0L, dwParam1, dwParam2));
    }

    mregDecUsagePtr(wavedrv);
    return mmr;
    	
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutGetNumDevs | This function retrieves the number of
 *   waveform output devices present in the system.
 *
 * @rdesc Returns the number of waveform output devices present in the system.
 *
 * @xref waveOutGetDevCaps
 ****************************************************************************/
UINT APIENTRY waveOutGetNumDevs(void)
{
    UINT    cDevs;

    ClientUpdatePnpInfo();

    if (WinmmRunningInServer)
    {
        if (0 == wTotalWaveOutDevs)
        {
            Squirt("Returning 1 for CSRSS process.");

            return 1;
        }

        return wTotalWaveOutDevs;
    }

    EnterNumDevs("waveOutGetNumDevs");
    cDevs = wTotalWaveOutDevs;
    LeaveNumDevs("waveOutGetNumDevs");

    dprintf3(("waveOutGetNumDevs returning %d devices", wTotalWaveOutDevs));

    return cDevs;
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveOutMessage | This function sends messages to the waveform
 *   output device drivers.
 *
 * @parm HWAVEOUT | hWaveOut | The handle to the audio device.
 *
 * @parm UINT | msg  | The message to send.
 *
 * @parm DWORD | dw1 | Parameter 1.
 *
 * @parm DWORD | dw2 | Parameter 2.
 *
 * @rdesc Returns the value returned from the driver.
 ****************************************************************************/
MMRESULT APIENTRY waveOutMessage(HWAVEOUT hWaveOut, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2)
{
    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE((HWAVE)hWaveOut, TYPE_WAVEOUT))
    {
        ReleaseHandleListResource();
        return waveIDMessage(&waveoutdrvZ, wTotalWaveOutDevs, (UINT)(UINT_PTR)hWaveOut, msg, dw1, dw2);
    }
    else
    {
        return waveMessage((HWAVE)hWaveOut, msg, dw1, dw2);
    }
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutGetDevCaps | This function queries a specified waveform
 *   device to determine its capabilities.
 *
 * @parm UINT | uDeviceID | Identifies the waveform output device.
 *
 * @parm LPWAVEOUTCAPS | lpCaps | Specifies a far pointer to a <t WAVEOUTCAPS>
 *   structure.  This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEOUTCAPS> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Use <f waveOutGetNumDevs> to determine the number of waveform output
 *   devices present in the system.  The device ID specified by <p uDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The WAVE_MAPPER constant may also be used as a device id. Only
 *   <p wSize> bytes (or less) of information is copied to the location
 *   pointed to by <p lpCaps>.  If <p wSize> is zero, nothing is copied, and
 *   the function returns zero.
 *
 * @xref waveOutGetNumDevs
 ****************************************************************************/
MMRESULT APIENTRY waveOutGetDevCapsW(UINT_PTR uDeviceID, LPWAVEOUTCAPSW lpCaps, UINT wSize)
{
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    PWAVEDRV        waveoutdrv;
    PCWSTR          DevInterface;
    MMRESULT        mmr;

    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    // Because some 32-bit applications use the value 0x0000FFFF for
    // WAVE_MAPPER instead of 0xFFFFFFFF, we clamp up to the correct value.
    // This just happened to work on Win9x because WinMM would thunk down
    // to MMSystem and send down the lower word to the 16-bit interface.
    if (uDeviceID == LOWORD(WAVE_MAPPER)) {
        uDeviceID = WAVE_MAPPER;
    }

    ClientUpdatePnpInfo();

    DevInterface = waveReferenceDevInterfaceById(&waveoutdrvZ, uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)lpCaps;
        dwParam2 = (DWORD)wSize;
    }
    else
    {
        mdCaps.cbSize = (DWORD)wSize;
        mdCaps.pCaps  = lpCaps;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    //
    //  Don't allow non proper drivers in TS environement
    //
    // ISSUE-2001/01/09-FrankYe Instead of cast to UINT.  Should check whether
    //    this is a handle and get wavedrv from handle if it is.
    waveoutdrv = NULL;
    if ((!waveReferenceDriverById(&waveoutdrvZ, (UINT)uDeviceID, &waveoutdrv, NULL)) &&
    	lstrcmpW(waveoutdrv->wszSessProtocol, SessionProtocolName))
    {
        mmr = MMSYSERR_NODRIVER;
    }
    else
    {
        AcquireHandleListResourceShared();

        if (BAD_HANDLE((HWAVE)uDeviceID, TYPE_WAVEOUT))
        {
    	    int cRecursion;

            ReleaseHandleListResource();
            
            // Unless it's the mapper, increment the recursion depth counter.  Then,
            // check whether this thread is now recursing through waveOutGetDevCaps.  If it
            // is, then disable preferred device reordering.
            cRecursion = PtrToInt(TlsGetValue(gTlsIndex));
            if ((uDeviceID != WAVE_MAPPER) && (waveoutdrv) && (waveoutdrv->fdwDriver & MMDRV_PREXP)) TlsSetValue(gTlsIndex, IntToPtr(cRecursion + 1));
            if (cRecursion) gfDisablePreferredDeviceReordering = TRUE;
    	
    	    mmr = waveIDMessage(&waveoutdrvZ, wTotalWaveOutDevs, (UINT)uDeviceID, WODM_GETDEVCAPS, dwParam1, dwParam2);
    	    
            // Restore recursion counter
            TlsSetValue(gTlsIndex, IntToPtr(cRecursion));
        }
        else
        {
    	    mmr = (MMRESULT)waveMessage((HWAVE)uDeviceID, WODM_GETDEVCAPS, dwParam1, dwParam2);
        }

    }

    if (waveoutdrv) mregDecUsagePtr(waveoutdrv);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
    
}

MMRESULT APIENTRY waveOutGetDevCapsA(UINT_PTR uDeviceID, LPWAVEOUTCAPSA lpCaps, UINT wSize)
{
    WAVEOUTCAPS2W   wDevCaps2;
    WAVEOUTCAPS2A   aDevCaps2;
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    MMRESULT        mmRes;
    PWAVEDRV        waveoutdrv;
    PCWSTR          DevInterface;

    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    // Because some 32-bit applications use the value 0x0000FFFF for
    // WAVE_MAPPER instead of 0xFFFFFFFF, we clamp up to the correct value.
    // This just happened to work on Win9x because WinMM would thunk down
    // to MMSystem and send down the lower word to the 16-bit interface.
    if (uDeviceID == LOWORD(WAVE_MAPPER)) {
        uDeviceID = WAVE_MAPPER;
    }

    ClientUpdatePnpInfo();

    DevInterface = waveReferenceDevInterfaceById(&waveoutdrvZ, uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    memset(&wDevCaps2, 0, sizeof(wDevCaps2));

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)&wDevCaps2;
        dwParam2 = (DWORD)sizeof(wDevCaps2);
    }
    else
    {
        mdCaps.cbSize = (DWORD)sizeof(wDevCaps2);
        mdCaps.pCaps  = &wDevCaps2;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    //
    //  Don't allow non proper drivers in TS environement
    //
    // ISSUE-2001/01/09-FrankYe Bad cast to UINT.  Should check whether this
    //    is a handle and get wavedrv from handle if it is.
    waveoutdrv = NULL;
    if ( uDeviceID < wTotalWaveOutDevs &&
         !waveReferenceDriverById(&waveoutdrvZ, (UINT)uDeviceID, &waveoutdrv, NULL) &&
    	 lstrcmpW(waveoutdrv->wszSessProtocol, SessionProtocolName) )
    {
    	mregDecUsagePtr(waveoutdrv);
    	if (DevInterface) wdmDevInterfaceDec(DevInterface);
    	return MMSYSERR_NODRIVER;
    }
    
    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE((HWAVE)uDeviceID, TYPE_WAVEOUT))
    {
        ReleaseHandleListResource();
        mmRes = waveIDMessage(&waveoutdrvZ, wTotalWaveOutDevs, (UINT)uDeviceID,
        	              WODM_GETDEVCAPS, dwParam1, dwParam2);
    }
    else
    {
        mmRes = waveMessage((HWAVE)uDeviceID,
        	            WODM_GETDEVCAPS,
        	            dwParam1,
        	            dwParam2);
    }

    if (waveoutdrv) mregDecUsagePtr(waveoutdrv);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);

    //
    // Make sure the call worked before proceeding with the thunk.
    //
    if ( mmRes != MMSYSERR_NOERROR ) {
        return  mmRes;
    }

    aDevCaps2.wMid             = wDevCaps2.wMid;
    aDevCaps2.wPid             = wDevCaps2.wPid;
    aDevCaps2.vDriverVersion   = wDevCaps2.vDriverVersion;
    aDevCaps2.dwFormats        = wDevCaps2.dwFormats;
    aDevCaps2.wChannels        = wDevCaps2.wChannels;
    aDevCaps2.dwSupport        = wDevCaps2.dwSupport;
    aDevCaps2.ManufacturerGuid = wDevCaps2.ManufacturerGuid;
    aDevCaps2.ProductGuid      = wDevCaps2.ProductGuid;
    aDevCaps2.NameGuid         = wDevCaps2.NameGuid;

    // copy and convert lpwText to lpText here.
    Iwcstombs(aDevCaps2.szPname, wDevCaps2.szPname, MAXPNAMELEN);

    //
    // now copy the required amount into the callers buffer.
    //
    CopyMemory( lpCaps, &aDevCaps2, min(wSize, sizeof(aDevCaps2)));

    return mmRes;
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveOutGetVolume | This function queries the current volume
 *   setting of a waveform output device.
 *
 * @parm UINT | uDeviceID | Identifies the waveform output device.
 *
 * @parm LPDWORD | lpdwVolume | Specifies a far pointer to a location to
 *   be filled with the current volume setting.  The low-order word of
 *   this location contains the left channel volume setting, and the high-order
 *   word contains the right channel setting. A value of 0xFFFF represents
 *   full volume, and a value of 0x0000 is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order word of the specified location contains
 *   the mono volume level.
 *
 *   The full 16-bit setting(s)
 *   set with <f waveOutSetVolume> is returned, regardless of whether
 *   the device supports the full 16 bits of volume-level control.
 *
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Not all devices support volume changes. To determine whether the
 *   device supports volume control, use the WAVECAPS_VOLUME
 *   flag to test the <e WAVEOUTCAPS.dwSupport> field of the <t WAVEOUTCAPS>
 *   structure (filled by <f waveOutGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both
 *   the left and right channels, use the WAVECAPS_VOLUME
 *   flag to test the <e WAVEOUTCAPS.dwSupport> field of the <t WAVEOUTCAPS>
 *   structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutSetVolume
 ****************************************************************************/
MMRESULT APIENTRY waveOutGetVolume(HWAVEOUT hwo, LPDWORD lpdwVolume)
{
    PCWSTR      DevInterface;
    MMRESULT    mmr;

    V_WPOINTER(lpdwVolume, sizeof(DWORD), MMSYSERR_INVALPARAM);

    // Because some 32-bit applications use the value 0x0000FFFF for
    // WAVE_MAPPER instead of 0xFFFFFFFF, we clamp up to the correct value.
    // This just happened to work on Win9x because WinMM would thunk down
    // to MMSystem and send down the lower word to the 16-bit interface.
    if ((UINT_PTR)hwo == LOWORD(WAVE_MAPPER)) {
        (UINT_PTR)hwo = WAVE_MAPPER;
    }

    ClientUpdatePnpInfo();

    DevInterface = waveReferenceDevInterfaceById(&waveoutdrvZ, (UINT_PTR)hwo);

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE(hwo, TYPE_WAVEOUT))
    {
        ReleaseHandleListResource();
    	mmr = waveIDMessage(&waveoutdrvZ, wTotalWaveOutDevs, PtrToUint(hwo), WODM_GETVOLUME, (DWORD_PTR)lpdwVolume, (DWORD_PTR)DevInterface);
    }
    else
    {
    	mmr = (MMRESULT)waveMessage((HWAVE)hwo, WODM_GETVOLUME, (DWORD_PTR)lpdwVolume, (DWORD_PTR)DevInterface);
    }

    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveOutSetVolume | This function sets the volume of a
 *   waveform output device.
 *
 * @parm UINT | uDeviceID | Identifies the waveform output device.
 *
 * @parm DWORD | dwVolume | Specifies the new volume setting.  The
 *   low-order word contains the left channel volume setting, and the
 *   high-order word contains the right channel setting. A value of
 *   0xFFFF represents full volume, and a value of 0x0000 is silence.
 *
 *   If a device does
 *   not support both left and right volume control, the low-order word of
 *   <p dwVolume> specifies the volume level, and the high-order word is
 *   ignored.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Not all devices support volume changes. To determine whether the
 *   device supports volume control, use the WAVECAPS_VOLUME
 *   flag to test the <e WAVEOUTCAPS.dwSupport> field of the <t WAVEOUTCAPS>
 *   structure (filled by <f waveOutGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the WAVECAPS_LRVOLUME flag
 *   flag to test the <e WAVEOUTCAPS.dwSupport> field of the <t WAVEOUTCAPS>
 *   structure (filled by <f waveOutGetDevCaps>).
 *
 *   Most devices don't support the full 16 bits of volume level control
 *   and will not use the high-order bits of the requested volume setting.
 *   For example, for a device that supports 4 bits of volume control,
 *   requested volume level values of 0x4000, 0x4fff, and 0x43be
 *   all produce the same physical volume setting, 0x4000. The
 *   <f waveOutGetVolume> function returns the full 16-bit setting set
 *   with <f waveOutSetVolume>.
 *
 *   Volume settings are interpreted logarithmically. This means the
 *   perceived increase in volume is the same when increasing the
 *   volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000.
 *
 * @xref waveOutGetVolume
 ****************************************************************************/
MMRESULT APIENTRY waveOutSetVolume(HWAVEOUT hwo, DWORD dwVolume)
{
    PCWSTR   DevInterface;
    MMRESULT mmr;

    ClientUpdatePnpInfo();

    // Because some 32-bit applications use the value 0x0000FFFF for
    // WAVE_MAPPER instead of 0xFFFFFFFF, we clamp up to the correct value.
    // This just happened to work on Win9x because WinMM would thunk down
    // to MMSystem and send down the lower word to the 16-bit interface.
    if ((UINT_PTR)hwo == LOWORD(WAVE_MAPPER)) {
        (UINT_PTR)hwo = WAVE_MAPPER;
    }

    DevInterface = waveReferenceDevInterfaceById(&waveoutdrvZ, (UINT_PTR)hwo);

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE(hwo, TYPE_WAVEOUT))
    {
        ReleaseHandleListResource();
        mmr = waveIDMessage(&waveoutdrvZ, wTotalWaveOutDevs, PtrToUint(hwo), WODM_SETVOLUME, dwVolume, (DWORD_PTR)DevInterface);
    }
    else
    {
    	mmr = (MMRESULT)waveMessage((HWAVE)hwo, WODM_SETVOLUME, dwVolume, (DWORD_PTR)DevInterface);
    }

    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}

/*****************************************************************************
 * @doc INTERNAL WAVE
 *
 * @func UINT | waveGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPTSTR | lpText | Specifies a far pointer to a buffer which
 *   is filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length in characters of the buffer
 *   pointed to by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied and MMSYSERR_NOERROR
 *   is returned.  All error descriptions are less than 80 characters long.
 ****************************************************************************/

STATIC MMRESULT waveGetErrorTextW(UINT wError, LPWSTR lpText, UINT wSize)
{
    lpText[0] = 0;

#if MMSYSERR_BASE
    if (((wError < MMSYSERR_BASE) || (wError > MMSYSERR_LASTERROR)) && ((wError < WAVERR_BASE) || (wError > WAVERR_LASTERROR)))
#else
    if ((wError > MMSYSERR_LASTERROR) && ((wError < WAVERR_BASE) || (wError > WAVERR_LASTERROR)))
#endif
        return MMSYSERR_BADERRNUM;

    if (wSize > 1)
    {
        if (!LoadStringW(ghInst, wError, lpText, wSize))
            return MMSYSERR_BADERRNUM;
    }

    return MMSYSERR_NOERROR;
}

STATIC MMRESULT waveGetErrorTextA(UINT wError, LPSTR lpText, UINT wSize)
{
    lpText[0] = 0;

#if MMSYSERR_BASE
    if (((wError < MMSYSERR_BASE) || (wError > MMSYSERR_LASTERROR)) && ((wError < WAVERR_BASE) || (wError > WAVERR_LASTERROR)))
#else
    if ((wError > MMSYSERR_LASTERROR) && ((wError < WAVERR_BASE) || (wError > WAVERR_LASTERROR)))
#endif
        return MMSYSERR_BADERRNUM;

    if (wSize > 1)
    {
        if (!LoadStringA(ghInst, wError, lpText, wSize))
            return MMSYSERR_BADERRNUM;
    }

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutGetErrorText | This function retrieves a
 *   textual description of the error identified by the specified
 *   error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPTSTR | lpText | Specifies a far pointer to a buffer to be
 *   filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length in characters of the buffer
 *   pointed to by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied, and the function
 *   returns zero. All error descriptions are less than MAXERRORLENGTH characters long.
 ****************************************************************************/
MMRESULT APIENTRY waveOutGetErrorTextW(UINT wError, LPWSTR lpText, UINT wSize)
{
    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpText, wSize*sizeof(WCHAR), MMSYSERR_INVALPARAM);

    return waveGetErrorTextW(wError, lpText, wSize);
}

MMRESULT APIENTRY waveOutGetErrorTextA(UINT wError, LPSTR lpText, UINT wSize)
{
    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpText, wSize, MMSYSERR_INVALPARAM);

    return waveGetErrorTextA(wError, lpText, wSize );
}

/****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutOpen | This function opens a specified waveform output
 *   device for playback.
 *
 * @parm LPHWAVEOUT | lphWaveOut | Specifies a far pointer to an HWAVEOUT
 *   handle.  This location is filled with a handle identifying the opened
 *   waveform output device.  Use the handle to identify the device when
 *   calling other waveform output functions.  This parameter may be
 *   NULL if the WAVE_FORMAT_QUERY flag is specified for <p dwFlags>.
 *
 * @parm UINT | uDeviceID | Identifies the waveform output device to open.
 *  Use a valid device ID or the following flag:
 *
 *   @flag WAVE_MAPPER | If this flag is specified, the function
 *     selects a waveform output device
 *     capable of playing the given format.
 *
 * @parm LPWAVEFORMATEX | lpFormat | Specifies a pointer to a <t WAVEFORMATEX>
 *   structure that identifies the format of the waveform data
 *   to be sent to the waveform output device.
 *
 * @parm DWORD | dwCallback | Specifies the address of a callback
 *   function or a handle to a window called during waveform
 *   playback to process messages related to the progress of the playback.
 *   Specify NULL for this parameter if no callback is desired.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user instance data
 *   passed to the callback.  This parameter is not used with
 *   window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device.
 *   @flag WAVE_FORMAT_QUERY | If this flag is specified, the device is
 *   queried to determine if it supports the given format but is not
 *      actually opened.
 *   @flag WAVE_ALLOWSYNC | If this flag is not specified, then the
 *   device will fail to open if it is a synchronous device.
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      assumed to be a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_ALLOCATED | Specified resource is already allocated.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *   @flag WAVERR_BADFORMAT | Attempted to open with an unsupported wave format.
 *
 * @comm Use <f waveOutGetNumDevs> to determine the number of waveform output
 *   devices present in the system.  The device ID specified by <p uDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The WAVE_MAPPER constant may also be used as a device id.
 *
 *   The <t WAVEFORMAT> structure pointed to by <p lpFormat> may be extended
 *   to include type-specific information for certain data formats.
 *   For example, for PCM data, an extra WORD is added to specify the number
 *   of bits per sample.  Use the <t PCMWAVEFORMAT> structure in this case.
 *
 *   If a window is chosen to receive callback information, the following
 *   messages are sent to the window procedure function to indicate the
 *   progress of waveform output:  <m MM_WOM_OPEN>, <m MM_WOM_CLOSE>,
 *   <m MM_WOM_DONE>
 *
 *   If a function is chosen to receive callback information, the following
 *   messages are sent to the function to indicate the progress of waveform
 *   output: <m WOM_OPEN>, <m WOM_CLOSE>, <m WOM_DONE>.  The callback function
 *   must reside in a DLL.  You do not have to use <f MakeProcInstance> to get
 *   a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | WaveOutFunc | <f WaveOutFunc> is a placeholder for the
 *   application-supplied function name.  The actual name must be exported by
 *   including it in an EXPORTS statement in the DLL's module-definition file.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform device
 *   associated with the callback.
 *
 * @parm UINT | wMsg | Specifies a waveform output message.
 *
 * @parm DWORD | dwInstance | Specifies the user instance data
 *   specified with <f waveOutOpen>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL.  Any data that the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref waveOutClose
 ****************************************************************************/
MMRESULT APIENTRY waveOutOpen(LPHWAVEOUT lphWaveOut, UINT uDeviceID,
                            LPCWAVEFORMATEX lpFormat, DWORD_PTR dwCallback,
                            DWORD_PTR dwInstance, DWORD dwFlags)
{
    WAVEOPENDESC wo;
    PWAVEDEV     pdev;
    PWAVEDRV     wavedrv;
    UINT         port;
    MMRESULT     wRet;
    DWORD_PTR    dwDrvUser;
    int          cRecursion;

    V_RPOINTER(lpFormat, sizeof(WAVEFORMAT), MMSYSERR_INVALPARAM);
    V_DCALLBACK(dwCallback, HIWORD(dwFlags), MMSYSERR_INVALPARAM);
    // Because some 32-bit applications use the value 0x0000FFFF for
    // WAVE_MAPPER instead of 0xFFFFFFFF, we clamp up to the correct value.
    // This just happened to work on Win9x because WinMM would thunk down
    // to MMSystem and send down the lower word to the 16-bit interface.
    if (uDeviceID == LOWORD(WAVE_MAPPER)) {
        uDeviceID = WAVE_MAPPER;
    }
    if (uDeviceID == WAVE_MAPPER) {
        V_FLAGS(LOWORD(dwFlags), WAVE_VALID & ~(WAVE_MAPPED), waveOutOpen, MMSYSERR_INVALFLAG);
    } else {
        V_FLAGS(LOWORD(dwFlags), WAVE_VALID, waveOutOpen, MMSYSERR_INVALFLAG);
    }
    if ((lpFormat->wFormatTag != WAVE_FORMAT_PCM)) {
        V_RPOINTER(lpFormat, sizeof(WAVEFORMATEX), MMSYSERR_INVALPARAM);
        if ((lpFormat->cbSize)) {
            V_RPOINTER(lpFormat + 1, lpFormat->cbSize, MMSYSERR_INVALPARAM);
        }
    }

    if ((dwFlags & WAVE_FORMAT_QUERY)) {
        lphWaveOut = NULL;
    } else
    {
            V_WPOINTER(lphWaveOut, sizeof(HWAVEOUT), MMSYSERR_INVALPARAM);
        //  WAVE_FORMAT_DIRECT was bounced on Win95.  Now we
        //  accept this flag.
        //
        //   if (dwFlags & WAVE_FORMAT_DIRECT)
        //       return MMSYSERR_INVALFLAG;
            *lphWaveOut = NULL;
    }

    ClientUpdatePnpInfo();

    if ((!wTotalWaveOutDevs) || waveReferenceDriverById(&waveoutdrvZ, (dwFlags & WAVE_MAPPED) ? WAVE_MAPPER : uDeviceID, &wavedrv, &port))
    {
        return MMSYSERR_BADDEVICEID;
    }

    //
    //  check if the device is appropriate for the current TS session
    //
    if (!(wavedrv->fdwDriver & MMDRV_MAPPER) &&
    	lstrcmpW(wavedrv->wszSessProtocol, SessionProtocolName))
    {
    	mregDecUsagePtr(wavedrv);
        return MMSYSERR_NODRIVER;
    }

    /* Default wave mapper :
     *
     * If a wave mapper is installed as a separate DLL then all wave mapper
     * messages are routed to it. If no wave mapper is installed, simply
     * loop through the wave devices looking for a match.
     */
    // ISSUE-2001/01/06-FrankYe This logic looks broken for the WAVE_MAPPER case
    if ((uDeviceID == WAVE_MAPPER) && !wavedrv->drvMessage) {
        MMRESULT    wErr;

        mregDecUsagePtr(wavedrv);
        wErr = MMSYSERR_ALLOCATED;

        if (dwFlags & WAVE_MAPPED)
        {
            if (wErr = waveReferenceDriverById(&waveoutdrvZ, uDeviceID, &wavedrv, &port))
                return wErr;

            if (mregHandleInternalMessages(wavedrv,
                                      MMDRVI_WAVEOUT,
                                      port,
                                      DRV_QUERYMAPPABLE,
                                      0, 0, &wErr) ||
                 (MMSYSERR_NOERROR != wErr))
            {
            	mregDecUsagePtr(wavedrv);
                return wErr;
            }
            wErr = waveOutOpen(lphWaveOut, uDeviceID, lpFormat, dwCallback, dwInstance, dwFlags & ~WAVE_MAPPED);
            mregDecUsagePtr(wavedrv);
        }
        else
        {
            for (uDeviceID=0; uDeviceID<wTotalWaveOutDevs; uDeviceID++) {
                wErr = waveOutOpen(lphWaveOut, uDeviceID, lpFormat, dwCallback, dwInstance, dwFlags);
                if (!wErr)
                    break;
            }
        }
        return wErr;

    }
    
    if (dwFlags & WAVE_FORMAT_QUERY)
        pdev = NULL;
    else {
        if (!(pdev = (PWAVEDEV)NewHandle(TYPE_WAVEOUT, wavedrv->cookie, sizeof(WAVEDEV))))
        {
            mregDecUsagePtr(wavedrv);
            return MMSYSERR_NOMEM;
        }
        
        ENTER_MM_HANDLE(pdev);
        SetHandleFlag(pdev, MMHANDLE_BUSY);
        ReleaseHandleListResource();

        pdev->wavedrv = wavedrv;
        pdev->wDevice = port;
        pdev->uDeviceID = uDeviceID;
        pdev->fdwHandle = 0;
    }

    wo.hWave      = (HWAVE)pdev;
    wo.dwCallback = dwCallback;
    wo.dwInstance = dwInstance;
    wo.uMappedDeviceID = uDeviceID;
    wo.lpFormat   = (LPWAVEFORMAT)lpFormat;  // cast away the CONST to eliminate wng
    wo.dnDevNode  = (DWORD_PTR)wavedrv->cookie;

    // Unless it's the mapper, increment the recursion depth counter.  Then,
    // check whether this thread is now recursing through waveOutOpen.  If it
    // is, then disable preferred device reordering.
    cRecursion = PtrToInt(TlsGetValue(gTlsIndex));
    if (uDeviceID != WAVE_MAPPER) TlsSetValue(gTlsIndex, IntToPtr(cRecursion + 1));
    if ((uDeviceID != WAVE_MAPPER) && (wavedrv->fdwDriver & MMDRV_PREXP)) TlsSetValue(gTlsIndex, IntToPtr(cRecursion + 1));
    if (cRecursion) gfDisablePreferredDeviceReordering = TRUE;
    	
    wRet = ((*(wavedrv->drvMessage))
        (port, WODM_OPEN, (DWORD_PTR)&dwDrvUser, (DWORD_PTR)(LPWAVEOPENDESC)&wo, dwFlags));

    // Restore recursion counter
    TlsSetValue(gTlsIndex, IntToPtr(cRecursion));

    if (pdev) {
        //  Mark as not busy on successful open...
        if (!wRet)
            ClearHandleFlag(pdev, MMHANDLE_BUSY);
            
        LEAVE_MM_HANDLE(pdev);
    
        if (wRet)
            FreeHandle((HWAVEOUT)pdev);
        else {
            // Inc usage since we opened a handle on it
            mregIncUsagePtr(wavedrv);
            *lphWaveOut = (HWAVEOUT)pdev;
            pdev->dwDrvUser = dwDrvUser;
        }
    }

    mregDecUsagePtr(wavedrv);
    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutClose | This function closes the specified waveform
 *   output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device. If the function is successful, the handle is no
 *   longer valid after this call.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_STILLPLAYING | There are still buffers in the queue.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm If the device is still playing a waveform, the close
 *   operation will fail.  Use <f waveOutReset> to terminate waveform
 *   playback before calling <f waveOutClose>.
 *
 * @xref waveOutOpen waveOutReset
 ****************************************************************************/
MMRESULT APIENTRY waveOutClose(HWAVEOUT hWaveOut)
{
    MMRESULT    wRet;
    PWAVEDRV    pwavedrv;
    PWAVEDEV    pDev = (PWAVEDEV)hWaveOut;

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    ENTER_MM_HANDLE((HWAVE)hWaveOut);
    ReleaseHandleListResource();

    if (IsHandleDeserted(hWaveOut))
    {
        //  This handle has been deserted.  Let's just free it.

        LEAVE_MM_HANDLE((HWAVE)hWaveOut);
        FreeHandle(hWaveOut);
        return MMSYSERR_NOERROR;
    }

    if (IsHandleBusy(hWaveOut))
    {
        //  Not quite invalid, but marked as closed.
    
        LEAVE_MM_HANDLE(hWaveOut);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  Marking handle as 'invalid/closed'.
    SetHandleFlag(hWaveOut, MMHANDLE_BUSY);
    
    pwavedrv = pDev->wavedrv;

    wRet = (MMRESULT)(*(pwavedrv->drvMessage))(pDev->wDevice, WODM_CLOSE, pDev->dwDrvUser, 0L, 0L);

    if (MMSYSERR_NOERROR != wRet)
    {
        //  Error closing, set the flag as valid.
        ClearHandleFlag(hWaveOut, MMHANDLE_BUSY);
    }

    LEAVE_MM_HANDLE((HWAVE)hWaveOut);
    
    if (!wRet)
    {
        FreeHandle(hWaveOut);
    	mregDecUsagePtr(pwavedrv);
        return wRet;
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutPrepareHeader | This function prepares a
 *   waveform data block for playback.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPWAVEHDR | lpWaveOutHdr | Specifies a pointer to a
 *   <t WAVEHDR> structure that identifies the data block to be prepared.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm The <t WAVEHDR> data structure and the data block pointed to by its
 *   <e WAVEHDR.lpData> field must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared has no effect, and
 *   the function returns zero.
 *
 * @xref waveOutUnprepareHeader
 ****************************************************************************/
MMRESULT APIENTRY waveOutPrepareHeader(HWAVEOUT hWaveOut, LPWAVEHDR lpWaveOutHdr, UINT wSize)
{
    MMRESULT     wRet;

    V_HEADER(lpWaveOutHdr, wSize, TYPE_WAVEOUT, MMSYSERR_INVALPARAM);

    if (IsWaveHeaderPrepared(hWaveOut, lpWaveOutHdr))
    {
        DebugErr(DBF_WARNING,"waveOutPrepareHeader: header is already prepared.");
        return MMSYSERR_NOERROR;
    }

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    lpWaveOutHdr->dwFlags &= (WHDR_BEGINLOOP | WHDR_ENDLOOP);
    
    wRet = waveMessage((HWAVE)hWaveOut, WODM_PREPARE, (DWORD_PTR)lpWaveOutHdr, (DWORD)wSize);

    if (wRet == MMSYSERR_NOTSUPPORTED)
        wRet = wavePrepareHeader(lpWaveOutHdr, wSize);

    if (wRet == MMSYSERR_NOERROR)
        MarkWaveHeaderPrepared(hWaveOut, lpWaveOutHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutUnprepareHeader | This function cleans up the
 *   preparation performed by <f waveOutPrepareHeader>. The function
 *   must be called after
 *   the device driver is finished with a data block. You must call this
 *   function before freeing the data buffer.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPWAVEHDR | lpWaveOutHdr |  Specifies a pointer to a <t WAVEHDR>
 *   structure identifying the data block to be cleaned up.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_STILLPLAYING | <p lpWaveOutHdr> is still in the queue.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm This function is the complementary function to
 * <f waveOutPrepareHeader>. You must call this function before freeing the
 *  data buffer with <f GlobalFree>.
 *   After passing a buffer to the device driver with <f waveOutWrite>, you
 *   must wait until the driver is finished with the buffer before calling
 *   <f waveOutUnprepareHeader>.
 *
 *  Unpreparing a buffer that has not been
 *  prepared has no effect, and the function returns zero.
 *
 * @xref waveOutPrepareHeader
 ****************************************************************************/
MMRESULT APIENTRY waveOutUnprepareHeader(HWAVEOUT hWaveOut,
                                            LPWAVEHDR lpWaveOutHdr, UINT wSize)
{
    MMRESULT    wRet;

    V_HEADER(lpWaveOutHdr, wSize, TYPE_WAVEOUT, MMSYSERR_INVALPARAM);

    if(lpWaveOutHdr->dwFlags & WHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING,"waveOutUnprepareHeader: header still in queue.");
        return WAVERR_STILLPLAYING;
    }

    if (!IsWaveHeaderPrepared(hWaveOut, lpWaveOutHdr))
    {
        DebugErr(DBF_WARNING,"waveOutUnprepareHeader: header is not prepared.");
        return MMSYSERR_NOERROR;
    }

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    wRet = waveMessage((HWAVE)hWaveOut, WODM_UNPREPARE, (DWORD_PTR)lpWaveOutHdr, (DWORD)wSize);
    
    if (wRet == MMSYSERR_NOTSUPPORTED)
        wRet = waveUnprepareHeader(lpWaveOutHdr, wSize);

    if ((wRet == MMSYSERR_NODRIVER) && (IsHandleDeserted(hWaveOut)))
    {
        wRet = MMSYSERR_NOERROR;
    }

    if (wRet == MMSYSERR_NOERROR)
        MarkWaveHeaderUnprepared(hWaveOut, lpWaveOutHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutWrite | This function sends a data block to the
 *   specified waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *  device.
 *
 * @parm LPWAVEHDR | lpWaveOutHdr | Specifies a far pointer to a <t WAVEHDR>
 *   structure containing information about the data block.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_UNPREPARED | <p lpWaveOutHdr> hasn't been prepared.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm The data buffer must be prepared with <f waveOutPrepareHeader> before
 *   it is passed to <f waveOutWrite>.  The <t WAVEHDR> data structure
 *   and the data buffer pointed to by its <e WAVEHDR.lpData> field must be allocated
 *   with <f GlobalAlloc> using the GMEM_MOVEABLE and GMEM_SHARE flags, and
 *   locked with <f GlobalLock>.  Unless the device is paused by calling
 *   <f waveOutPause>, playback begins when the first data block is sent to
 *   the device.
 *
 * @xref waveOutPrepareHeader waveOutPause waveOutReset waveOutRestart
 ****************************************************************************/
MMRESULT APIENTRY waveOutWrite(HWAVEOUT hWaveOut, LPWAVEHDR lpWaveOutHdr, UINT wSize)
{
    V_HEADER(lpWaveOutHdr, wSize, TYPE_WAVEOUT, MMSYSERR_INVALPARAM);

    if (!IsWaveHeaderPrepared(hWaveOut, lpWaveOutHdr))
    {
        DebugErr(DBF_WARNING,"waveOutWrite: header not prepared");
        return WAVERR_UNPREPARED;
    }

    if (lpWaveOutHdr->dwFlags & WHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING,"waveOutWrite: header is still in queue");
        return WAVERR_STILLPLAYING;
    }

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    lpWaveOutHdr->dwFlags &= ~WHDR_DONE;

    return waveMessage((HWAVE)hWaveOut, WODM_WRITE, (DWORD_PTR)lpWaveOutHdr, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutPause | This function pauses playback on a specified
 *   waveform output device.  The current playback position is saved.  Use
 *   <f waveOutRestart> to resume playback from the current playback position.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm Calling this function when the output is already paused has no
 *   effect, and the function returns zero.
 *
 * @xref waveOutRestart waveOutBreakLoop
 ****************************************************************************/
MMRESULT APIENTRY waveOutPause(HWAVEOUT hWaveOut)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    return waveMessage((HWAVE)hWaveOut, WODM_PAUSE, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutRestart | This function restarts a paused waveform
 *   output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm Calling this function when the output is not paused has no
 *   effect, and the function returns zero.
 *
 * @xref waveOutPause waveOutBreakLoop
 ****************************************************************************/
MMRESULT APIENTRY waveOutRestart(HWAVEOUT hWaveOut)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    return waveMessage((HWAVE)hWaveOut, WODM_RESTART, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutReset | This function stops playback on a given waveform
 *   output device and resets the current position to 0.  All pending
 *   playback buffers are marked as done and returned to the application.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @xref waveOutWrite waveOutClose
/****************************************************************************/
MMRESULT APIENTRY waveOutReset(HWAVEOUT hWaveOut)
{
    MMRESULT    mmr;

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    mmr = waveMessage((HWAVE)hWaveOut, WODM_RESET, 0L, 0L);
    
    if ((MMSYSERR_NODRIVER == mmr) && (IsHandleDeserted(hWaveOut)))
    {
        mmr = MMSYSERR_NOERROR;
    }
    
    return (mmr);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutBreakLoop | This function breaks a loop on a
 *   given waveform output device and allows playback to continue with the
 *   next block in the driver list.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm Waveform looping is controlled by the <e WAVEHDR.dwLoops> and
 *   <e WAVEHDR.dwFlags> fields in the <t WAVEHDR> structures passed to the device
 *   with <f waveOutWrite>. Use the WHDR_BEGINLOOP and WHDR_ENDLOOP flags
 *   in the <e WAVEHDR.dwFlags> field to specify the beginning and ending data
 *   blocks for looping.
 *
 *   To loop on a single block, specify both flags for the same block.
 *   To specify the number of loops, use the <e WAVEHDR.dwLoops> field in
 *   the <t WAVEHDR> structure for the first block in the loop.
 *
 *   The blocks making up the loop are played to the end before the loop
 *   is terminated.
 *
 *   Calling this function when the nothing is playing or looping has no
 *   effect, and the function returns zero.
 *
 * @xref waveOutWrite waveOutPause waveOutRestart
/****************************************************************************/
MMRESULT APIENTRY waveOutBreakLoop(HWAVEOUT hWaveOut)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    return waveMessage((HWAVE)hWaveOut, WODM_BREAKLOOP, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveOutGetPosition | This function retrieves the current
 *   playback position of the specified waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPMMTIME | lpInfo | Specifies a far pointer to an <t MMTIME>
 *   structure.
 *
 * @parm UINT | wSize | Specifies the size of the <t MMTIME> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm Before calling <f waveOutGetPosition>, set the <e MMTIME.wType> field of the
 *   MMTIME structure to indicate the time format that you desire.  After
 *   calling <f waveOutGetPosition>, check the <e MMTIME.wType> field
 *   to determine if the desired time format is supported.  If the desired
 *   format is not supported, <e MMTIME.wType> will specify an alternative format.
 *
 *  The position is set to zero when the device is opened or reset.
 ****************************************************************************/
MMRESULT APIENTRY waveOutGetPosition(HWAVEOUT hWaveOut, LPMMTIME lpInfo,
                                                        UINT wSize)
{
    V_WPOINTER(lpInfo, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    return waveMessage((HWAVE)hWaveOut, WODM_GETPOS, (DWORD_PTR)lpInfo, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveOutGetPitch | This function queries the the current pitch
 *   setting of a waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPDWORD | lpdwPitch | Specifies a far pointer to a location
 *   to be filled with the current pitch multiplier setting. The pitch
 *   multiplier indicates the current change in pitch from the original
 *   authored setting. The pitch multiplier must be a positive value.
 *
 * The pitch multiplier is specified as a fixed-point value. The high-order word
 * of the DWORD location contains the signed integer part of the number,
 * and the low-order word contains the fractional part. The fraction is
 * expressed as a WORD in which a value of 0x8000 represents one half,
 * and 0x4000 represents one quarter. For example, the value 0x00010000
 * specifies a multiplier of 1.0 (no pitch change), and a value of
 * 0x000F8000 specifies a multiplier of 15.5.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm Changing the pitch does not change the playback rate, sample
 *   rate, or playback time.  Not all devices support
 *   pitch changes. To determine whether the device supports pitch control,
 *   use the WAVECAPS_PITCH flag to test the <e WAVEOUTCAPS.dwSupport>
 *   field of the <t WAVEOUTCAPS> structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutSetPitch waveOutGetPlaybackRate waveOutSetPlaybackRate
 ****************************************************************************/
MMRESULT APIENTRY waveOutGetPitch(HWAVEOUT hWaveOut, LPDWORD lpdwPitch)
{
    V_WPOINTER(lpdwPitch, sizeof(DWORD), MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    return waveMessage((HWAVE)hWaveOut, WODM_GETPITCH, (DWORD_PTR)lpdwPitch, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveOutSetPitch | This function sets the pitch of a waveform
 *   output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform
 *   output device.
 *
 * @parm DWORD | dwPitch | Specifies the new pitch multiplier setting.
 *  The pitch multiplier setting indicates the current change in pitch
 *  from the original authored setting. The pitch multiplier must be a
 *  positive value.
 *
 * The pitch multiplier is specified as a fixed-point value. The high-order word
 * location contains the signed integer part of the number,
 * and the low-order word contains the fractional part. The fraction is
 * expressed as a WORD in which a value of 0x8000 represents one half,
 * and 0x4000 represents one quarter.
 * For example, the value 0x00010000 specifies a multiplier
 * of 1.0 (no pitch change), and a value of 0x000F8000 specifies a
 * multiplier of 15.5.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm Changing the pitch does not change the playback rate or the sample
 *   rate.  The playback time is also unchanged. Not all devices support
 *   pitch changes. To determine whether the device supports pitch control,
 *   use the WAVECAPS_PITCH flag to test the <e WAVEOUTCAPS.dwSupport>
 *   field of the <t WAVEOUTCAPS> structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutGetPitch waveOutSetPlaybackRate waveOutGetPlaybackRate
 ****************************************************************************/
MMRESULT APIENTRY waveOutSetPitch(HWAVEOUT hWaveOut, DWORD dwPitch)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    return waveMessage((HWAVE)hWaveOut, WODM_SETPITCH, dwPitch, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveOutGetPlaybackRate | This function queries the
 *   current playback rate setting of a waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPDWORD | lpdwRate | Specifies a far pointer to a location
 *   to be filled with the current playback rate. The playback rate setting
 *  is a multiplier indicating the current change in playback rate from
 *  the original authored setting. The playback rate multiplier must be
 *  a positive value.
 *
 * The rate is specified as a fixed-point value. The high-order word
 * of the DWORD location contains the signed integer part of the number,
 * and the low-order word contains the fractional part. The fraction is
 * expressed as a WORD in which a value of 0x8000 represents one half,
 * and 0x4000 represents one quarter. For example, the value 0x00010000
 * specifies a multiplier of 1.0 (no playback rate change), and a value
 * of 0x000F8000 specifies a multiplier of 15.5.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm Changing the playback rate does not change the sample rate but does
 *   change the playback time.
 *
 *   Not all devices support playback rate changes. To determine whether a
 *   device supports playback rate changes, use
 *   the WAVECAPS_PLAYBACKRATE flag to test the <e WAVEOUTCAPS.dwSupport> field of the
 *   <t WAVEOUTCAPS> structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutSetPlaybackRate waveOutSetPitch waveOutGetPitch
 ****************************************************************************/
MMRESULT APIENTRY waveOutGetPlaybackRate(HWAVEOUT hWaveOut, LPDWORD lpdwRate)
{
    V_WPOINTER(lpdwRate, sizeof(DWORD), MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    return waveMessage((HWAVE)hWaveOut, WODM_GETPLAYBACKRATE, (DWORD_PTR)lpdwRate, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveOutSetPlaybackRate | This function sets the
 *   playback rate of a waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform
 *   output device.
 *
 * @parm DWORD | dwRate | Specifies the new playback rate setting.
 *  The playback rate setting is a multiplier indicating the current
 *  change in playback rate from the original authored setting. The playback
 *  rate multiplier must be a positive value.
 *
 * The rate is specified as a fixed-point value. The high-order word
 * contains the signed integer part of the number,
 * and the low-order word contains the fractional part. The fraction is
 * expressed as a WORD in which a value of 0x8000 represents one half,
 * and 0x4000 represents one quarter.
 * For example, the value 0x00010000 specifies a multiplier of 1.0 (no
 * playback rate change), and a value of 0x000F8000 specifies a
 * multiplier of 15.5.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 *
 * @comm Changing the playback rate does not change the sample rate but does
 *   change the playback time.
 *
 * Not all devices support playback rate changes. To determine whether a
 *   device supports playback rate changes,
 *   use the WAVECAPS_PLAYBACKRATE flag to test the <e WAVEOUTCAPS.dwSupport> field of the
 *   <t WAVEOUTCAPS> structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutGetPlaybackRate waveOutSetPitch waveOutGetPitch
 ****************************************************************************/
MMRESULT APIENTRY waveOutSetPlaybackRate(HWAVEOUT hWaveOut, DWORD dwRate)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    return waveMessage((HWAVE)hWaveOut, WODM_SETPLAYBACKRATE, dwRate, 0L);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInGetNumDevs | This function returns the number of waveform
 *   input devices.
 *
 * @rdesc Returns the number of waveform input devices present in the system.
 *
 * @xref waveInGetDevCaps
 ****************************************************************************/
UINT APIENTRY waveInGetNumDevs(void)
{
    ClientUpdatePnpInfo();

    dprintf3(("waveInGetNumDevs returning %d devices", wTotalWaveInDevs));

//    EnterNumDevs("waveInGetNumDevs");
    return wTotalWaveInDevs;
//    LeaveNumDevs("waveInGetNumDevs");
}


//--------------------------------------------------------------------------;
//
//  MMRESULT waveOutDesertHandle
//
//  Description:
//      Cleans up the wave out handle and marks it as deserted.
//
//  Arguments:
//      HWAVEOUT hWaveOut:  Wave out handle
//
//  Return (MMRESULT):  Error code.
//
//  History:
//      01/25/99    Fwong       Adding Pnp Support.
//
//--------------------------------------------------------------------------;

MMRESULT waveOutDesertHandle
(
    HWAVEOUT    hWaveOut
)
{
    MMRESULT    mmr;
    PWAVEDEV    pDev = (PWAVEDEV)hWaveOut;

    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    
    ENTER_MM_HANDLE((HWAVE)hWaveOut);
    ReleaseHandleListResource();
    
    if (IsHandleDeserted(hWaveOut))
    {
        LEAVE_MM_HANDLE((HWAVE)hWaveOut);
        return (MMSYSERR_NOERROR);
    }
    
    if (IsHandleBusy(hWaveOut))
    {
        //  Not quite invalid, but marked as closed.
    
        LEAVE_MM_HANDLE(hWaveOut);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  Marking handle as deserted
    SetHandleFlag(hWaveOut, MMHANDLE_DESERTED);

    //  Since the handle was invalidated, we have to send the message ourselves...

    (*(pDev->wavedrv->drvMessage))(pDev->wDevice, WODM_RESET, pDev->dwDrvUser, 0L, 0L);
    (*(pDev->wavedrv->drvMessage))(pDev->wDevice, WODM_CLOSE, pDev->dwDrvUser, 0L, 0L);
    
    LEAVE_MM_HANDLE((HWAVE)hWaveOut);

    // ISSUE-2001/01/14-FrankYe Probably don't want to dec usage here,
    //    dec on close instead.
    mregDecUsagePtr(pDev->wavedrv);

    return MMSYSERR_NOERROR;
} // waveOutDesertHandle()


/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveInMessage | This function sends messages to the waveform
 *   output device drivers.
 *
 * @parm HWAVEIN | hWave | The handle to the audio device.
 *
 * @parm UINT | wMsg | The message to send.
 *
 * @parm DWORD | dw1 | Parameter 1.
 *
 * @parm DWORD | dw2 | Parameter 2.
 *
 * @rdesc Returns the value returned from the driver.
 ****************************************************************************/
MMRESULT APIENTRY waveInMessage(HWAVEIN hWaveIn, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2)
{
    ClientUpdatePnpInfo();

    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE((HWAVE)hWaveIn, TYPE_WAVEIN))
    {
        ReleaseHandleListResource();
        return waveIDMessage(&waveindrvZ, wTotalWaveInDevs, PtrToUint(hWaveIn), msg, dw1, dw2);
    }
    else
    {
        return waveMessage((HWAVE)hWaveIn, msg, dw1, dw2);
    }
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInGetDevCaps | This function queries a specified waveform
 *   input device to determine its capabilities.
 *
 * @parm UINT | uDeviceID | Identifies the waveform input device.
 *
 * @parm LPWAVEINCAPS | lpCaps | Specifies a far pointer to a <t WAVEINCAPS>
 *   structure.  This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEINCAPS> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Use <f waveInGetNumDevs> to determine the number of waveform input
 *   devices present in the system.  The device ID specified by <p uDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The WAVE_MAPPER constant may also be used as a device id. Only
 *   <p wSize> bytes (or less) of information is copied to the location
 *   pointed to by <p lpCaps>.  If <p wSize> is zero, nothing is copied, and
 *   the function returns zero.
 *
 * @xref waveInGetNumDevs
 ****************************************************************************/
MMRESULT APIENTRY waveInGetDevCapsW(UINT_PTR uDeviceID, LPWAVEINCAPSW lpCaps,UINT wSize)
{
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    PWAVEDRV        waveindrv;
    PCWSTR          DevInterface;
    MMRESULT        mmr;

    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = waveReferenceDevInterfaceById(&waveindrvZ, uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)lpCaps;
        dwParam2 = (DWORD)wSize;
    }
    else
    {
        mdCaps.cbSize = (DWORD)wSize;
        mdCaps.pCaps  = lpCaps;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }
    
    //
    //  Don't allow non proper drivers in TS environement
    //
    // ISSUE-2001/01/09-FrankYe Instead of cast to UINT.  Should check whether
    //    this is a handle and get wavedrv from handle if it is.
    waveindrv = NULL;
    if ((!waveReferenceDriverById(&waveindrvZ, (UINT)uDeviceID, &waveindrv, NULL)) &&
    	lstrcmpW(waveindrv->wszSessProtocol, SessionProtocolName))
    {
        mmr = MMSYSERR_NODRIVER;
    }
    else
    {
        AcquireHandleListResourceShared();
    
        if (BAD_HANDLE((HWAVE)uDeviceID, TYPE_WAVEIN))
        {
            ReleaseHandleListResource();
    	    mmr = waveIDMessage(&waveindrvZ, wTotalWaveInDevs, (UINT)uDeviceID, WIDM_GETDEVCAPS, dwParam1, dwParam2);
        }
        else
        {
    	    mmr = (MMRESULT)waveMessage((HWAVE)uDeviceID, WIDM_GETDEVCAPS, dwParam1, dwParam2);
        }
    }
    
    if (waveindrv) mregDecUsagePtr(waveindrv);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}

MMRESULT APIENTRY waveInGetDevCapsA(UINT_PTR uDeviceID, LPWAVEINCAPSA lpCaps,UINT wSize)
{
    WAVEINCAPS2W   wDevCaps2;
    WAVEINCAPS2A   aDevCaps2;
    DWORD_PTR      dwParam1, dwParam2;
    MDEVICECAPSEX  mdCaps;
    PCWSTR         DevInterface;
    PWAVEDRV       waveindrv;
    MMRESULT       mmRes;

    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = waveReferenceDevInterfaceById(&waveindrvZ, uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    memset(&wDevCaps2, 0, sizeof(wDevCaps2));

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)&wDevCaps2;
        dwParam2 = (DWORD)sizeof(wDevCaps2);
    }
    else
    {
        mdCaps.cbSize = (DWORD)sizeof(wDevCaps2);
        mdCaps.pCaps  = &wDevCaps2;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    //
    //  Don't allow non proper drivers in TS environement
    //
    // ISSUE-2001/01/09-FrankYe Bad cast to UINT.  Should check whether this
    //    is a handle and get wavedrv from handle if it is.
    waveindrv = NULL;
    if ( uDeviceID < wTotalWaveInDevs &&
         !waveReferenceDriverById(&waveindrvZ, (UINT)uDeviceID, &waveindrv, NULL) &&
    	 lstrcmpW(waveindrv->wszSessProtocol, SessionProtocolName) )
    {
    	mregDecUsagePtr(waveindrv);
    	if (DevInterface) wdmDevInterfaceDec(DevInterface);
    	return MMSYSERR_NODRIVER;
    }
    
    AcquireHandleListResourceShared();
    
    if (BAD_HANDLE((HWAVE)uDeviceID, TYPE_WAVEIN))
    {
        ReleaseHandleListResource();
        mmRes = waveIDMessage( &waveindrvZ, wTotalWaveInDevs, (UINT)uDeviceID,
                            WIDM_GETDEVCAPS, dwParam1, dwParam2);
    }
    else
    {
        mmRes = waveMessage((HWAVE)uDeviceID, WIDM_GETDEVCAPS,
                            dwParam1, dwParam2);
    }

    if (waveindrv) mregDecUsagePtr(waveindrv);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);

    //
    // Make sure the call worked before proceeding with the thunk.
    //
    if ( mmRes != MMSYSERR_NOERROR ) {
        return  mmRes;
    }

    aDevCaps2.wMid             = wDevCaps2.wMid;
    aDevCaps2.wPid             = wDevCaps2.wPid;
    aDevCaps2.vDriverVersion   = wDevCaps2.vDriverVersion;
    aDevCaps2.dwFormats        = wDevCaps2.dwFormats;
    aDevCaps2.wChannels        = wDevCaps2.wChannels;
    aDevCaps2.ManufacturerGuid = wDevCaps2.ManufacturerGuid;
    aDevCaps2.ProductGuid      = wDevCaps2.ProductGuid;
    aDevCaps2.NameGuid         = wDevCaps2.NameGuid;

    // copy and convert unicode to ascii here.
    Iwcstombs(aDevCaps2.szPname, wDevCaps2.szPname, MAXPNAMELEN);

    //
    // now copy the required amount into the callers buffer.
    //
    CopyMemory( lpCaps, &aDevCaps2, min(wSize, sizeof(aDevCaps2)));

    return mmRes;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPTSTR | lpText | Specifies a far pointer to the buffer to be
 *   filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length in characters of the buffer
 *   pointed to by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied, and the function
 *   returns zero. All error descriptions are less than MAXERRORLENGTH characters long.
 ****************************************************************************/
MMRESULT APIENTRY waveInGetErrorTextW(UINT wError, LPWSTR lpText, UINT wSize)
{
    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpText, wSize*sizeof(WCHAR), MMSYSERR_INVALPARAM);

    return waveGetErrorTextW(wError, lpText, wSize);
}

MMRESULT APIENTRY waveInGetErrorTextA(UINT wError, LPSTR lpText, UINT wSize)
{
    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpText, wSize, MMSYSERR_INVALPARAM);

    return waveGetErrorTextA(wError, lpText, wSize );
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInOpen | This function opens a specified waveform
 *   input device for recording.
 *
 * @parm LPHWAVEIN | lphWaveIn | Specifies a far pointer to a HWAVEIN
 *   handle.  This location is filled with a handle identifying the opened
 *   waveform input device.  Use this handle to identify the device when
 *   calling other waveform input functions.  This parameter may be NULL
 *   if the WAVE_FORMAT_QUERY flag is specified for <p dwFlags>.
 *
 * @parm UINT | uDeviceID | Identifies the waveform input device to open. Use
 *  a valid device ID or the following flag:
 *
 * @flag WAVE_MAPPER | If this flag is specified, the function
 *   selects a waveform input device capable of recording in the
 *   given format.
 *
 * @parm LPWAVEFORMATEX | lpFormat | Specifies a pointer to a <t WAVEFORMATEX>
 *   data structure that identifies the desired format for recording
 *   waveform data.
 *
 * @parm DWORD | dwCallback | Specifies the address of a callback
 *   function or a handle to a window called during waveform
 *   recording to process messages related to the progress of recording.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user
 *  instance data passed to the callback.  This parameter is not
 *  used with window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device.
 *   @flag WAVE_FORMAT_QUERY | If this flag is specified, the device will
 *   be queried to determine if it supports the given format but will not
 *      actually be opened.
 *   @flag WAVE_ALLOWSYNC | If this flag is not specified, then the
 *   device will fail to open if it is a synchronous device.
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      assumed to be a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_ALLOCATED | Specified resource is already allocated.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *   @flag WAVERR_BADFORMAT | Attempted to open with an unsupported wave format.
 *
 * @comm Use <f waveInGetNumDevs> to determine the number of waveform input
 *   devices present in the system.  The device ID specified by <p uDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The WAVE_MAPPER constant may also be used as a device id.
 *
 *   If a window is chosen to receive callback information, the following
 *   messages are sent to the window procedure function to indicate the
 *   progress of waveform input:  <m MM_WIM_OPEN>, <m MM_WIM_CLOSE>,
 *   <m MM_WIM_DATA>
 *
 *   If a function is chosen to receive callback information, the following
 *   messages are sent to the function to indicate the progress of waveform
 *   input: <m WIM_OPEN>, <m WIM_CLOSE>, <m WIM_DATA>.  The callback function
 *   must reside in a DLL.  You do not have to use <f MakeProcInstance> to get
 *   a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | WaveInFunc | <f WaveInFunc> is a placeholder for the
 *   application-supplied function name.  The actual name must be exported by
 *   including it in an EXPORTS statement in the DLL's module-definition file.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform device
 *   associated with the callback.
 *
 * @parm UINT | wMsg | Specifies a waveform input device.
 *
 * @parm DWORD | dwInstance | Specifies the user instance
 *   data specified with <f waveInOpen>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL.  Any data that the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref waveInClose
 ****************************************************************************/
MMRESULT APIENTRY waveInOpen(LPHWAVEIN lphWaveIn, UINT uDeviceID,
                           LPCWAVEFORMATEX lpFormat, DWORD_PTR dwCallback,
                           DWORD_PTR dwInstance, DWORD dwFlags)
{
    WAVEOPENDESC wo;
    UINT         port;
    PWAVEDEV     pdev;
    PWAVEDRV     wavedrv;
    MMRESULT     wRet;
    DWORD_PTR    dwDrvUser;

    V_RPOINTER(lpFormat, sizeof(WAVEFORMAT), MMSYSERR_INVALPARAM);
    V_DCALLBACK(dwCallback, HIWORD(dwFlags), MMSYSERR_INVALPARAM);
    // Because some 32-bit applications use the value 0x0000FFFF for
    // WAVE_MAPPER instead of 0xFFFFFFFF, we clamp up to the correct value.
    // This just happened to work on Win9x because WinMM would thunk down
    // to MMSystem and send down the lower word to the 16-bit interface.
    if (uDeviceID == LOWORD(WAVE_MAPPER)) {
        uDeviceID = WAVE_MAPPER;
    }
    if (uDeviceID == WAVE_MAPPER) {
        V_FLAGS(LOWORD(dwFlags), WAVE_VALID & ~(WAVE_MAPPED), waveInOpen, MMSYSERR_INVALFLAG);
    } else {
        V_FLAGS(LOWORD(dwFlags), WAVE_VALID, waveInOpen, MMSYSERR_INVALFLAG);
    }

    if (lpFormat->wFormatTag != WAVE_FORMAT_PCM) {
        V_RPOINTER(lpFormat, sizeof(WAVEFORMATEX), MMSYSERR_INVALPARAM);
        if (lpFormat->cbSize) {
            V_RPOINTER(lpFormat + 1, lpFormat->cbSize, MMSYSERR_INVALPARAM);
        }
    }

    if (dwFlags & WAVE_FORMAT_QUERY) {
        lphWaveIn = NULL;
    } else {
        V_WPOINTER((LPVOID)lphWaveIn, sizeof(HWAVEIN), MMSYSERR_INVALPARAM);
        //  WAVE_FORMAT_DIRECT was bounced on Win95.  Now we
        //  accept this flag
        //
        //  if (dwFlags & WAVE_FORMAT_DIRECT)
        //      return MMSYSERR_INVALFLAG;
        *lphWaveIn = NULL;
    }

    ClientUpdatePnpInfo();

    if ((!wTotalWaveInDevs) || waveReferenceDriverById(&waveindrvZ, (dwFlags & WAVE_MAPPED) ? WAVE_MAPPER : uDeviceID, &wavedrv, &port))
    {
        return MMSYSERR_BADDEVICEID;
    }

    //
    //  check if the device is appropriate for the current TS session
    //
    if (!(wavedrv->fdwDriver & MMDRV_MAPPER) &&
    	lstrcmpW(wavedrv->wszSessProtocol, SessionProtocolName))
    {
    	mregDecUsagePtr(wavedrv);
        return MMSYSERR_NODRIVER;
    }

    /* Default wave mapper :
     *
     * If a wave mapper is installed as a separate DLL then all wave mapper
     * messages are routed to it. If no wave mapper is installed, simply
     * loop through the wave devices looking for a match.
     */
    // ISSUE-2001/01/06-FrankYe This logic looks broken for the WAVE_MAPPED case
    if ((uDeviceID == WAVE_MAPPER && !wavedrv->drvMessage)) {
        UINT    wErr;

        mregDecUsagePtr(wavedrv);
        wErr = MMSYSERR_ALLOCATED;

        if (dwFlags & WAVE_MAPPED)
        {
            if (wErr = waveReferenceDriverById(&waveindrvZ, uDeviceID, &wavedrv, &port))
                return wErr;

            if (mregHandleInternalMessages(wavedrv,
                                           MMDRVI_WAVEIN,
                                           port,
                                           DRV_QUERYMAPPABLE,
                                           0, 0, &wErr) ||
                 (MMSYSERR_NOERROR != wErr))
            {
            	mregDecUsagePtr(wavedrv);
                return wErr;
            }
            wErr = waveInOpen(lphWaveIn, uDeviceID, lpFormat, dwCallback, dwInstance, dwFlags & ~WAVE_MAPPED);
            mregDecUsagePtr(wavedrv);
        }
        else
        {
            for (uDeviceID=0; uDeviceID<wTotalWaveInDevs; uDeviceID++) {
                wErr = waveInOpen(lphWaveIn, uDeviceID, lpFormat, dwCallback, dwInstance, dwFlags);
                if (!wErr)
                    break;
            }
        }
        return wErr;
    }
    
    if (dwFlags & WAVE_FORMAT_QUERY)
        pdev = NULL;
    else {
        if (!(pdev = (PWAVEDEV)NewHandle(TYPE_WAVEIN, wavedrv->cookie, sizeof(WAVEDEV))))
            return MMSYSERR_NOMEM;
        
        ENTER_MM_HANDLE(pdev);
        SetHandleFlag(pdev, MMHANDLE_BUSY);
        ReleaseHandleListResource();    

        pdev->wavedrv = wavedrv;
        pdev->wDevice = port;
        pdev->uDeviceID = uDeviceID;
        pdev->fdwHandle = 0;
    }

    wo.hWave        = (HWAVE)pdev;
    wo.dwCallback   = dwCallback;
    wo.dwInstance   = dwInstance;
    wo.uMappedDeviceID = uDeviceID;
    wo.lpFormat     = (LPWAVEFORMAT)lpFormat;  // cast away the CONST to eliminate wng
    wo.dnDevNode    = (DWORD_PTR)wavedrv->cookie;

    wRet = (MMRESULT)((*(wavedrv->drvMessage))
        (port, WIDM_OPEN, (DWORD_PTR)&dwDrvUser, (DWORD_PTR)(LPWAVEOPENDESC)&wo, dwFlags));

    if (pdev) {
        //  Mark as not busy on successful open...
        if (!wRet)
            ClearHandleFlag(pdev, MMHANDLE_BUSY);
            
        LEAVE_MM_HANDLE(pdev);
    
        if (wRet)
            FreeHandle((HWAVEIN)pdev);
        else {
            // Inc usage since we opened a handle on it
            mregIncUsagePtr(wavedrv);
            *lphWaveIn = (HWAVEIN)pdev;
            pdev->dwDrvUser = dwDrvUser;
        }
    }

    mregDecUsagePtr(wavedrv);
    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInClose | This function closes the specified waveform
 *   input device.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *  If the function is successful, the handle is no longer
 *   valid after this call.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_STILLPLAYING | There are still buffers in the queue.
 *
 * @comm If there are input buffers that have been sent with
 *   <f waveInAddBuffer>, and haven't been returned to the application,
 *   the close operation will fail.  Call <f waveInReset> to mark all
 *   pending buffers as done.
 *
 * @xref waveInOpen waveInReset
 ****************************************************************************/
MMRESULT APIENTRY waveInClose(HWAVEIN hWaveIn)
{
    MMRESULT    wRet;
    PWAVEDRV    pwavedrv;
    PWAVEDEV    pDev = (PWAVEDEV)hWaveIn;

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    
    ENTER_MM_HANDLE((HWAVE)hWaveIn);
    ReleaseHandleListResource();
    
    if (IsHandleDeserted(hWaveIn))
    {
        //  This handle has been deserted.  Let's just free it.

        LEAVE_MM_HANDLE((HWAVE)hWaveIn);
        FreeHandle(hWaveIn);
        return MMSYSERR_NOERROR;
    }
    
    if (IsHandleBusy(hWaveIn))
    {
        //  Not quite invalid, but marked as closed.
    
        LEAVE_MM_HANDLE(hWaveIn);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  Marking handle as 'invalid/closed'.
    SetHandleFlag(hWaveIn, MMHANDLE_BUSY);
    
    pwavedrv = pDev->wavedrv;

    wRet = (MMRESULT)(*(pwavedrv->drvMessage))(pDev->wDevice, WIDM_CLOSE, pDev->dwDrvUser, 0L, 0L);

    if (MMSYSERR_NOERROR != wRet)
    {
        ClearHandleFlag(hWaveIn, MMHANDLE_BUSY);
    }

    LEAVE_MM_HANDLE((HWAVE)hWaveIn);

    if (!wRet)
    {
        FreeHandle(hWaveIn);
    	mregDecUsagePtr(pwavedrv);
        return wRet;
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInPrepareHeader | This function prepares a buffer
 *   for waveform input.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input
 *   device.
 *
 * @parm LPWAVEHDR | lpWaveInHdr | Specifies a pointer to a
 *   <t WAVEHDR> structure that identifies the buffer to be prepared.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveIn> is in use on another
 *      thread.
 *
 * @comm The <t WAVEHDR> data structure and the data block pointed to by its
 *   <e WAVEHDR.lpData> field must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared will have no effect,
 *   and the function will return zero.
 *
 * @xref waveInUnprepareHeader
 ****************************************************************************/
MMRESULT APIENTRY waveInPrepareHeader(HWAVEIN hWaveIn, LPWAVEHDR lpWaveInHdr,
                                                                  UINT wSize)
{
    MMRESULT         wRet;

    V_HEADER(lpWaveInHdr, wSize, TYPE_WAVEIN, MMSYSERR_INVALPARAM);

    if (IsWaveHeaderPrepared(hWaveIn, lpWaveInHdr))
    {
        DebugErr(DBF_WARNING,"waveInPrepareHeader: header is already prepared.");
        return MMSYSERR_NOERROR;
    }

    lpWaveInHdr->dwFlags = 0;

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    
    wRet = waveMessage((HWAVE)hWaveIn, WIDM_PREPARE, (DWORD_PTR)lpWaveInHdr, (DWORD)wSize);

    if (wRet == MMSYSERR_NOTSUPPORTED)
        wRet = wavePrepareHeader(lpWaveInHdr, wSize);

    if (wRet == MMSYSERR_NOERROR)
        MarkWaveHeaderPrepared(hWaveIn, lpWaveInHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInUnprepareHeader | This function cleans up the
 * preparation performed by <f waveInPrepareHeader>. The function must
 * be called after the device
 *   driver fills a data buffer and returns it to the application. You
 *  must call this function before freeing the data buffer.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input
 *   device.
 *
 * @parm LPWAVEHDR | lpWaveInHdr |  Specifies a pointer to a <t WAVEHDR>
 *   structure identifying the data buffer to be cleaned up.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_STILLPLAYING | <p lpWaveInHdr> is still in the queue.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveIn> is in use on another
 *      thread.
 *
 * @comm This function is the complementary function to <f waveInPrepareHeader>.
 * You must call this function before freeing the data buffer with <f GlobalFree>.
 *   After passing a buffer to the device driver with <f waveInAddBuffer>, you
 *   must wait until the driver is finished with the buffer before calling
 *   <f waveInUnprepareHeader>. Unpreparing a buffer that has not been
 *   prepared has no effect, and the function returns zero.
 *
 * @xref waveInPrepareHeader
 ****************************************************************************/
MMRESULT APIENTRY waveInUnprepareHeader(HWAVEIN hWaveIn, LPWAVEHDR lpWaveInHdr, UINT wSize)
{
    MMRESULT        wRet;

    V_HEADER(lpWaveInHdr, wSize, TYPE_WAVEIN, MMSYSERR_INVALPARAM);

    if (lpWaveInHdr->dwFlags & WHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "waveInUnprepareHeader: buffer still in queue.");
        return WAVERR_STILLPLAYING;
    }

    if (!IsWaveHeaderPrepared(hWaveIn, lpWaveInHdr))
    {
        DebugErr(DBF_WARNING,"waveInUnprepareHeader: header is not prepared.");
        return MMSYSERR_NOERROR;
    }

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    
    wRet = waveMessage((HWAVE)hWaveIn, WIDM_UNPREPARE, (DWORD_PTR)lpWaveInHdr, (DWORD)wSize);

    if (wRet == MMSYSERR_NOTSUPPORTED)
        wRet = waveUnprepareHeader(lpWaveInHdr, wSize);

    if ((wRet == MMSYSERR_NODRIVER) && (IsHandleDeserted(hWaveIn)))
    {
        wRet = MMSYSERR_NOERROR;
    }

    if (wRet == MMSYSERR_NOERROR)
        MarkWaveHeaderUnprepared(hWaveIn, lpWaveInHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInAddBuffer | This function sends an input buffer to a
 *   waveform input device.  When the buffer is filled, it is sent back
 *   to the application.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *
 * @parm LPWAVEHDR | lpWaveInHdr | Specifies a far pointer to a <t WAVEHDR>
 *   structure that identifies the buffer.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_UNPREPARED | <p lpWaveInHdr> hasn't been prepared.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveIn> is in use on another
 *      thread.
 *
 * @comm The data buffer must be prepared with <f waveInPrepareHeader> before
 *   it is passed to <f waveInAddBuffer>.  The <t WAVEHDR> data structure
 *   and the data buffer pointed to by its <e WAVEHDR.lpData> field must be allocated
 *   with <f GlobalAlloc> using the GMEM_MOVEABLE and GMEM_SHARE flags, and
 *   locked with <f GlobalLock>.
 *
 * @xref waveInPrepareHeader
 ****************************************************************************/
MMRESULT APIENTRY waveInAddBuffer(HWAVEIN hWaveIn, LPWAVEHDR lpWaveInHdr,
                                                                UINT wSize)
{
    V_HEADER(lpWaveInHdr, wSize, TYPE_WAVEIN, MMSYSERR_INVALPARAM);

    if (!IsWaveHeaderPrepared(hWaveIn, lpWaveInHdr))
    {
        DebugErr(DBF_WARNING, "waveInAddBuffer: buffer not prepared.");
        return WAVERR_UNPREPARED;
    }

    if (lpWaveInHdr->dwFlags & WHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "waveInAddBuffer: buffer already in queue.");
        return WAVERR_STILLPLAYING;
    }

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    
    return waveMessage((HWAVE)hWaveIn, WIDM_ADDBUFFER, (DWORD_PTR)lpWaveInHdr, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInStart | This function starts input on the specified
 *   waveform input device.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveIn> is in use on another
 *      thread.
 *
 * @comm Buffers are returned to the client when full or when <f waveInReset>
 *   is called (the <e WAVEHDR.dwBytesRecorded> field in the header will contain the
 *   actual length of data). If there are no buffers in the queue, the data is
 *   thrown away without notification to the client, and input continues.
 *
 *   Calling this function when input is already started has no effect, and
 *   the function returns zero.
 *
 * @xref waveInStop waveInReset
 ****************************************************************************/
MMRESULT APIENTRY waveInStart(HWAVEIN hWaveIn)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);

    return waveMessage((HWAVE)hWaveIn, WIDM_START, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInStop | This function stops waveform input.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveIn> is in use on another
 *      thread.
 *
 * @comm If there are any buffers in the queue, the current buffer will be
 *   marked as done (the <e WAVEHDR.dwBytesRecorded> field in the header will contain
 *   the actual length of data), but any empty buffers in the queue will remain
 *   there.  Calling this function when input is not started has no effect,
 *   and the function returns zero.
 *
 * @xref waveInStart waveInReset
 ****************************************************************************/
MMRESULT APIENTRY waveInStop(HWAVEIN hWaveIn)
{
    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);

    return waveMessage((HWAVE)hWaveIn, WIDM_STOP, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInReset | This function stops input on a given waveform
 *   input device and resets the current position to 0.  All pending
 *   buffers are marked as done and returned to the application.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveIn> is in use on another
 *      thread.
 *
 * @xref waveInStart waveInStop waveInAddBuffer waveInClose
/****************************************************************************/
MMRESULT APIENTRY waveInReset(HWAVEIN hWaveIn)
{
    MMRESULT    mmr;

    ClientUpdatePnpInfo();

    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    
    mmr = waveMessage((HWAVE)hWaveIn, WIDM_RESET, 0L, 0L);
    
    if ((MMSYSERR_NODRIVER == mmr) && (IsHandleDeserted(hWaveIn)))
    {
        mmr = MMSYSERR_NOERROR;
    }
    
    return (mmr);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api MMRESULT | waveInGetPosition | This function retrieves the current input
 *   position of the specified waveform input device.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *
 * @parm LPMMTIME | lpInfo | Specifies a far pointer to an <t MMTIME>
 *   structure.
 *
 * @parm UINT | wSize | Specifies the size of the <t MMTIME> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Before calling <f waveInGetPosition>, set the <e MMTIME.wType> field of the
 *   <t MMTIME> structure to indicate the time format that you desire.  After
 *   calling <f waveInGetPosition>, be sure to check the <e MMTIME.wType> field to
 *   determine if the desired time format is supported.  If the desired
 *   format is not supported, <e MMTIME.wType> will specify an alternative format.
 *
 *  The position is set to zero when the device is opened or reset.
 ****************************************************************************/
MMRESULT APIENTRY waveInGetPosition(HWAVEIN hWaveIn, LPMMTIME lpInfo,
                                                        UINT wSize)
{
    V_WPOINTER(lpInfo, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();
    
    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);

    return waveMessage((HWAVE)hWaveIn, WIDM_GETPOS, (DWORD_PTR)lpInfo, (DWORD)wSize);
}


//--------------------------------------------------------------------------;
//
//  MMRESULT waveInDesertHandle
//
//  Description:
//      Cleans up the wave in handle and marks it as deserted.
//
//  Arguments:
//      HWAVEIN hWaveIn:  Wave in handle
//
//  Return (MMRESULT):  Error code.
//
//  History:
//      01/25/99    Fwong       Adding Pnp Support.
//
//--------------------------------------------------------------------------;

MMRESULT waveInDesertHandle
(
    HWAVEIN hWaveIn
)
{
    MMRESULT    mmr;
    PWAVEDEV    pDev = (PWAVEDEV)hWaveIn;

    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    
    ENTER_MM_HANDLE((HWAVE)hWaveIn);
    ReleaseHandleListResource();
    
    if (IsHandleDeserted(hWaveIn))
    {
        LEAVE_MM_HANDLE((HWAVE)hWaveIn);
        return (MMSYSERR_NOERROR);
    }

    if (IsHandleBusy(hWaveIn))
    {
        //  Not quite invalid, but marked as closed.
    
        LEAVE_MM_HANDLE(hWaveIn);
        return (MMSYSERR_HANDLEBUSY);
    }

    //  Marking handle as deserted
    SetHandleFlag(hWaveIn, MMHANDLE_DESERTED);
    
    //  Since the handle was invalidated, we have to send the message ourselves...
    
    (*(pDev->wavedrv->drvMessage))(pDev->wDevice, WIDM_RESET, pDev->dwDrvUser, 0L, 0L);
    (*(pDev->wavedrv->drvMessage))(pDev->wDevice, WIDM_CLOSE, pDev->dwDrvUser, 0L, 0L);

    LEAVE_MM_HANDLE((HWAVE)hWaveIn);
    
    // ISSUE-2001/01/14-FrankYe Probably don't want to dec usage here,
    //    dec on close instead.
    mregDecUsagePtr(pDev->wavedrv);

    return MMSYSERR_NOERROR;
} // waveInDesertHandle()


/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveInGetID | This function gets the device ID for a
 * waveform input device.
 *
 * @parm HWAVEIN | hWaveIn | Specifies the handle to the waveform
 * input device.
 * @parm PUINT  | lpuDeviceID | Specifies a pointer to the UINT-sized memory
 * location to be filled with the device ID.
 *
 * @rdesc Returns zero if successful. Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | The <p hWaveIn> parameter specifies an
 * invalid handle.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveIn> is in use on another
 *      thread.
 *
 ****************************************************************************/
MMRESULT APIENTRY waveInGetID(HWAVEIN hWaveIn, PUINT lpuDeviceID)
{
    V_WPOINTER(lpuDeviceID, sizeof(UINT), MMSYSERR_INVALPARAM);
    V_HANDLE_ACQ(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);

    *lpuDeviceID = ((PWAVEDEV)hWaveIn)->uDeviceID;

    ReleaseHandleListResource();
    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api MMRESULT | waveOutGetID | This function gets the device ID for a
 * waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies the handle to the waveform
 * output device.
 * @parm PUINT  | lpuDeviceID | Specifies a pointer to the UINT-sized memory
 * location to be filled with the device ID.
 *
 * @rdesc Returns zero if successful. Otherwise, it returns
 *   an error number.  Possible error returns are:
 * @flag MMSYSERR_INVALHANDLE | The <p hWaveIn> parameter specifies an
 * invalid handle.
 *   @flag MMSYSERR_HANDLEBUSY | The handle <p hWaveOut> is in use on another
 *      thread.
 ****************************************************************************/
MMRESULT APIENTRY waveOutGetID(HWAVEOUT hWaveOut, PUINT lpuDeviceID)
{
    V_WPOINTER(lpuDeviceID, sizeof(UINT), MMSYSERR_INVALPARAM);
    V_HANDLE_ACQ(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    *lpuDeviceID = ((PWAVEDEV)hWaveOut)->uDeviceID;

    ReleaseHandleListResource();
    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\array.c ===
/******************************Module*Header*******************************\
* Module Name: array.c
*
* OpenGL client side vertex array functions.
*
* Created: 1-30-1996
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "os.h"
#include "glsbcltu.h"
#include "glclt.h"
#include "compsize.h"
#include "glsize.h"
#include "context.h"
#include "global.h"
#include "lcfuncs.h"

void FASTCALL VA_ArrayElementB(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_V2F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_C3F_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_N3F_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_C3F_N3F_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_C4F_N3F_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_T2F_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_T2F_C3F_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_T2F_N3F_V3F_B(__GLcontext *gc, GLint firstVertex,  GLint nVertices);
void FASTCALL VA_ArrayElement_T2F_C3F_N3F_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);
void FASTCALL VA_ArrayElement_T2F_C4F_N3F_V3F_B(__GLcontext *gc, GLint firstVertex, GLint nVertices);

void FASTCALL VA_ArrayElementBI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_V2F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_C3F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_N3F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_C3F_N3F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_C4F_N3F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_T2F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_T2F_C3F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_T2F_N3F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_T2F_C3F_N3F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);
void FASTCALL VA_ArrayElement_T2F_C4F_N3F_V3F_BI(__GLcontext *gc, GLint nVertices, VAMAP* indices);

void FASTCALL VA_ArrayElement(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_V2F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_C3F_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_N3F_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_C3F_N3F_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_C4F_N3F_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_T2F_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_T2F_C3F_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_T2F_N3F_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_T2F_C3F_N3F_V3F(__GLcontext *gc, GLint i);
void FASTCALL VA_ArrayElement_T2F_C4F_N3F_V3F(__GLcontext *gc, GLint i);

#define VAMASK_FORMAT_C3F \
  (VAMASK_COLOR_ENABLE_MASK | VAMASK_COLOR_SIZE_3 | VAMASK_COLOR_TYPE_FLOAT)
#define VAMASK_FORMAT_C4F \
  (VAMASK_COLOR_ENABLE_MASK | VAMASK_COLOR_SIZE_4 | VAMASK_COLOR_TYPE_FLOAT)
#define VAMASK_FORMAT_C4UB \
  (VAMASK_COLOR_ENABLE_MASK | VAMASK_COLOR_SIZE_4 | VAMASK_COLOR_TYPE_UBYTE)
#define VAMASK_FORMAT_N3F \
  (VAMASK_NORMAL_ENABLE_MASK | VAMASK_NORMAL_TYPE_FLOAT)
#define VAMASK_FORMAT_T2F \
  (VAMASK_TEXCOORD_ENABLE_MASK | VAMASK_TEXCOORD_SIZE_2 | VAMASK_TEXCOORD_TYPE_FLOAT)
#define VAMASK_FORMAT_T4F \
  (VAMASK_TEXCOORD_ENABLE_MASK | VAMASK_TEXCOORD_SIZE_4 | VAMASK_TEXCOORD_TYPE_FLOAT)
#define VAMASK_FORMAT_V2F \
  (VAMASK_VERTEX_ENABLE_MASK | VAMASK_VERTEX_SIZE_2 | VAMASK_VERTEX_TYPE_FLOAT)
#define VAMASK_FORMAT_V3F \
  (VAMASK_VERTEX_ENABLE_MASK | VAMASK_VERTEX_SIZE_3 | VAMASK_VERTEX_TYPE_FLOAT)
#define VAMASK_FORMAT_V4F \
  (VAMASK_VERTEX_ENABLE_MASK | VAMASK_VERTEX_SIZE_4 | VAMASK_VERTEX_TYPE_FLOAT)
#define VAMASK_FORMAT_C3F_V3F \
  (VAMASK_FORMAT_C3F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_N3F_V3F \
  (VAMASK_FORMAT_N3F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_C3F_N3F_V3F \
  (VAMASK_FORMAT_C3F | VAMASK_FORMAT_N3F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_C4F_N3F_V3F \
  (VAMASK_FORMAT_C4F | VAMASK_FORMAT_N3F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_T2F_V3F \
  (VAMASK_FORMAT_T2F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_T2F_C3F_V3F \
  (VAMASK_FORMAT_T2F | VAMASK_FORMAT_C3F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_T2F_N3F_V3F \
  (VAMASK_FORMAT_T2F | VAMASK_FORMAT_N3F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_T2F_C3F_N3F_V3F \
  (VAMASK_FORMAT_T2F | VAMASK_FORMAT_C3F | VAMASK_FORMAT_N3F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_T2F_C4F_N3F_V3F \
  (VAMASK_FORMAT_T2F | VAMASK_FORMAT_C4F | VAMASK_FORMAT_N3F | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_C4UB_V2F \
  (VAMASK_FORMAT_C4UB | VAMASK_FORMAT_V2F)
#define VAMASK_FORMAT_C4UB_V3F \
  (VAMASK_FORMAT_C4UB | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_T4F_V4F \
  (VAMASK_FORMAT_T4F | VAMASK_FORMAT_V4F)
#define VAMASK_FORMAT_T2F_C4UB_V3F \
  (VAMASK_FORMAT_T2F | VAMASK_FORMAT_C4UB | VAMASK_FORMAT_V3F)
#define VAMASK_FORMAT_T4F_C4F_N3F_V4F \
  (VAMASK_FORMAT_T4F | VAMASK_FORMAT_C4F | VAMASK_FORMAT_N3F | VAMASK_FORMAT_V4F)

// TYPE_ASSERT
GLint __glTypeSize[] =
{
    sizeof(GLbyte),   // GL_BYTE
    sizeof(GLubyte),  // GL_UNSIGNED_BYTE
    sizeof(GLshort),  // GL_SHORT
    sizeof(GLushort), // GL_UNSIGNED_SHORT
    sizeof(GLint),    // GL_INT
    sizeof(GLuint),   // GL_UNSIGNED_INT
    sizeof(GLfloat),  // GL_FLOAT
    2,                // GL_2_BYTES
    3,                // GL_3_BYTES
    4,                // GL_4_BYTES
    sizeof(GLdouble)  // GL_DOUBLE
};

// ARRAY_TYPE_ASSERT
GLuint vaEnable[] =
{
    VAMASK_VERTEX_ENABLE_MASK,   // GL_VERTEX_ARRAY
    VAMASK_NORMAL_ENABLE_MASK,   // GL_NORMAL_ARRAY
    VAMASK_COLOR_ENABLE_MASK,    // GL_COLOR_ARRAY
    VAMASK_INDEX_ENABLE_MASK,    // GL_INDEX_ARRAY
    VAMASK_TEXCOORD_ENABLE_MASK, // GL_TEXTURE_COORD_ARRAY
    VAMASK_EDGEFLAG_ENABLE_MASK  // GL_EDGE_FLAG_ARRAY
};

PFNGLVECTOR afnTexCoord[] =
{
    (PFNGLVECTOR)glcltTexCoord1sv,
    (PFNGLVECTOR)glcltTexCoord1iv,
    (PFNGLVECTOR)glcltTexCoord1fv,
    (PFNGLVECTOR)glcltTexCoord1dv,

    (PFNGLVECTOR)glcltTexCoord2sv,
    (PFNGLVECTOR)glcltTexCoord2iv,
    (PFNGLVECTOR)glcltTexCoord2fv,
    (PFNGLVECTOR)glcltTexCoord2dv,

    (PFNGLVECTOR)glcltTexCoord3sv,
    (PFNGLVECTOR)glcltTexCoord3iv,
    (PFNGLVECTOR)glcltTexCoord3fv,
    (PFNGLVECTOR)glcltTexCoord3dv,

    (PFNGLVECTOR)glcltTexCoord4sv,
    (PFNGLVECTOR)glcltTexCoord4iv,
    (PFNGLVECTOR)glcltTexCoord4fv,
    (PFNGLVECTOR)glcltTexCoord4dv,
};

PFNGLVECTOR afnTexCoordCompile[] =
{
    (PFNGLVECTOR)__gllc_TexCoord1sv,
    (PFNGLVECTOR)__gllc_TexCoord1iv,
    (PFNGLVECTOR)__gllc_TexCoord1fv,
    (PFNGLVECTOR)__gllc_TexCoord1dv,

    (PFNGLVECTOR)__gllc_TexCoord2sv,
    (PFNGLVECTOR)__gllc_TexCoord2iv,
    (PFNGLVECTOR)__gllc_TexCoord2fv,
    (PFNGLVECTOR)__gllc_TexCoord2dv,

    (PFNGLVECTOR)__gllc_TexCoord3sv,
    (PFNGLVECTOR)__gllc_TexCoord3iv,
    (PFNGLVECTOR)__gllc_TexCoord3fv,
    (PFNGLVECTOR)__gllc_TexCoord3dv,

    (PFNGLVECTOR)__gllc_TexCoord4sv,
    (PFNGLVECTOR)__gllc_TexCoord4iv,
    (PFNGLVECTOR)__gllc_TexCoord4fv,
    (PFNGLVECTOR)__gllc_TexCoord4dv,
};

PFNGLVECTOR afnColor_InRGBA[] =
{
    (PFNGLVECTOR)glcltColor3bv_InRGBA,
    (PFNGLVECTOR)glcltColor3ubv_InRGBA,
    (PFNGLVECTOR)glcltColor3sv_InRGBA,
    (PFNGLVECTOR)glcltColor3usv_InRGBA,
    (PFNGLVECTOR)glcltColor3iv_InRGBA,
    (PFNGLVECTOR)glcltColor3uiv_InRGBA,
    (PFNGLVECTOR)glcltColor3fv_InRGBA,
    (PFNGLVECTOR)glcltColor3dv_InRGBA,

    (PFNGLVECTOR)glcltColor4bv_InRGBA,
    (PFNGLVECTOR)glcltColor4ubv_InRGBA,
    (PFNGLVECTOR)glcltColor4sv_InRGBA,
    (PFNGLVECTOR)glcltColor4usv_InRGBA,
    (PFNGLVECTOR)glcltColor4iv_InRGBA,
    (PFNGLVECTOR)glcltColor4uiv_InRGBA,
    (PFNGLVECTOR)glcltColor4fv_InRGBA,
    (PFNGLVECTOR)glcltColor4dv_InRGBA,
};

PFNGLVECTOR afnColor_InCI[] =
{
    (PFNGLVECTOR)glcltColor3bv_InCI,
    (PFNGLVECTOR)glcltColor3ubv_InCI,
    (PFNGLVECTOR)glcltColor3sv_InCI,
    (PFNGLVECTOR)glcltColor3usv_InCI,
    (PFNGLVECTOR)glcltColor3iv_InCI,
    (PFNGLVECTOR)glcltColor3uiv_InCI,
    (PFNGLVECTOR)glcltColor3fv_InCI,
    (PFNGLVECTOR)glcltColor3dv_InCI,

    (PFNGLVECTOR)glcltColor4bv_InCI,
    (PFNGLVECTOR)glcltColor4ubv_InCI,
    (PFNGLVECTOR)glcltColor4sv_InCI,
    (PFNGLVECTOR)glcltColor4usv_InCI,
    (PFNGLVECTOR)glcltColor4iv_InCI,
    (PFNGLVECTOR)glcltColor4uiv_InCI,
    (PFNGLVECTOR)glcltColor4fv_InCI,
    (PFNGLVECTOR)glcltColor4dv_InCI,
};

PFNGLVECTOR afnColorCompile[] =
{
    (PFNGLVECTOR)__gllc_Color3bv,
    (PFNGLVECTOR)__gllc_Color3ubv,
    (PFNGLVECTOR)__gllc_Color3sv,
    (PFNGLVECTOR)__gllc_Color3usv,
    (PFNGLVECTOR)__gllc_Color3iv,
    (PFNGLVECTOR)__gllc_Color3uiv,
    (PFNGLVECTOR)__gllc_Color3fv,
    (PFNGLVECTOR)__gllc_Color3dv,

    (PFNGLVECTOR)__gllc_Color4bv,
    (PFNGLVECTOR)__gllc_Color4ubv,
    (PFNGLVECTOR)__gllc_Color4sv,
    (PFNGLVECTOR)__gllc_Color4usv,
    (PFNGLVECTOR)__gllc_Color4iv,
    (PFNGLVECTOR)__gllc_Color4uiv,
    (PFNGLVECTOR)__gllc_Color4fv,
    (PFNGLVECTOR)__gllc_Color4dv,
};

PFNGLVECTOR afnIndex_InRGBA[] =
{
    (PFNGLVECTOR)glcltIndexubv_InRGBA,
    (PFNGLVECTOR)glcltIndexsv_InRGBA,
    (PFNGLVECTOR)glcltIndexiv_InRGBA,
    (PFNGLVECTOR)glcltIndexfv_InRGBA,
    (PFNGLVECTOR)glcltIndexdv_InRGBA,
};

PFNGLVECTOR afnIndex_InCI[] =
{
    (PFNGLVECTOR)glcltIndexubv_InCI,
    (PFNGLVECTOR)glcltIndexsv_InCI,
    (PFNGLVECTOR)glcltIndexiv_InCI,
    (PFNGLVECTOR)glcltIndexfv_InCI,
    (PFNGLVECTOR)glcltIndexdv_InCI,
};

PFNGLVECTOR afnIndexCompile[] =
{
    (PFNGLVECTOR)__gllc_Indexubv,
    (PFNGLVECTOR)__gllc_Indexsv,
    (PFNGLVECTOR)__gllc_Indexiv,
    (PFNGLVECTOR)__gllc_Indexfv,
    (PFNGLVECTOR)__gllc_Indexdv,
};

PFNGLVECTOR afnNormal[] =
{
    (PFNGLVECTOR)glcltNormal3bv,
    (PFNGLVECTOR)glcltNormal3sv,
    (PFNGLVECTOR)glcltNormal3iv,
    (PFNGLVECTOR)glcltNormal3fv,
    (PFNGLVECTOR)glcltNormal3dv,
};

PFNGLVECTOR afnNormalCompile[] =
{
    (PFNGLVECTOR)__gllc_Normal3bv,
    (PFNGLVECTOR)__gllc_Normal3sv,
    (PFNGLVECTOR)__gllc_Normal3iv,
    (PFNGLVECTOR)__gllc_Normal3fv,
    (PFNGLVECTOR)__gllc_Normal3dv,
};

PFNGLVECTOR afnVertex[] =
{
    (PFNGLVECTOR)glcltVertex2sv,
    (PFNGLVECTOR)glcltVertex2iv,
    (PFNGLVECTOR)glcltVertex2fv,
    (PFNGLVECTOR)glcltVertex2dv,

    (PFNGLVECTOR)glcltVertex3sv,
    (PFNGLVECTOR)glcltVertex3iv,
    (PFNGLVECTOR)glcltVertex3fv,
    (PFNGLVECTOR)glcltVertex3dv,

    (PFNGLVECTOR)glcltVertex4sv,
    (PFNGLVECTOR)glcltVertex4iv,
    (PFNGLVECTOR)glcltVertex4fv,
    (PFNGLVECTOR)glcltVertex4dv,
};

PFNGLVECTOR afnVertexCompile[] =
{
    (PFNGLVECTOR)__gllc_Vertex2sv,
    (PFNGLVECTOR)__gllc_Vertex2iv,
    (PFNGLVECTOR)__gllc_Vertex2fv,
    (PFNGLVECTOR)__gllc_Vertex2dv,

    (PFNGLVECTOR)__gllc_Vertex3sv,
    (PFNGLVECTOR)__gllc_Vertex3iv,
    (PFNGLVECTOR)__gllc_Vertex3fv,
    (PFNGLVECTOR)__gllc_Vertex3dv,

    (PFNGLVECTOR)__gllc_Vertex4sv,
    (PFNGLVECTOR)__gllc_Vertex4iv,
    (PFNGLVECTOR)__gllc_Vertex4fv,
    (PFNGLVECTOR)__gllc_Vertex4dv,
};

void FASTCALL __glInitVertexArray(__GLcontext *gc)
{
    // Initial vertex array state.
    static __GLvertexArray defaultVertexArrayState =
    {
        __GL_VERTEX_ARRAY_DIRTY,            // flags

        VAMASK_TEXCOORD_SIZE_4 |            // mask
        VAMASK_TEXCOORD_TYPE_FLOAT |
        VAMASK_INDEX_TYPE_FLOAT |
        VAMASK_COLOR_SIZE_4 |
        VAMASK_COLOR_TYPE_FLOAT |
        VAMASK_NORMAL_TYPE_FLOAT |
        VAMASK_VERTEX_SIZE_4 |
        VAMASK_VERTEX_TYPE_FLOAT,

        VA_ArrayElement,                    // pfnArrayElement
        VA_ArrayElementB,                   // pfnArrayElementBatch
        VA_ArrayElementBI,                  // pfnArrayElementBatchIndirect
        {                                   // edgeFlag
            sizeof(GLboolean),              //   ibytes
            0,                              //   stride
            NULL,                           //   pointer
            glcltEdgeFlagv,                 //   pfn
            __gllc_EdgeFlagv,               //   pfnCompile
        },

        {                                   // texcoord
            4,                              //   size
            GL_FLOAT,                       //   type
            4 * sizeof(GLfloat),            //   ibytes
            0,                              //   stride
            NULL,                           //   pointer
            NULL,                           //   pfn
            NULL,                           //   pfnCompile
        },

        {                                   // index
            GL_FLOAT,                       //   type
            sizeof(GLfloat),                //   ibytes
            0,                              //   stride
            NULL,                           //   pointer
            NULL,                           //   pfn
            NULL,                           //   pfnCompile
        },

        {                                   // color
            4,                              //   size
            GL_FLOAT,                       //   type
            4 * sizeof(GLfloat),            //   ibytes
            0,                              //   stride
            NULL,                           //   pointer
            NULL,                           //   pfn
            NULL,                           //   pfnCompile
        },

        {                                   // normal
            GL_FLOAT,                       //   type
            3 * sizeof(GLfloat),            //   ibytes
            0,                              //   stride
            NULL,                           //   pointer
            NULL,                           //   pfn
            NULL,                           //   pfnCompile
        },

        {                                   // vertex
            4,                              //   size
            GL_FLOAT,                       //   type
            4 * sizeof(GLfloat),            //   ibytes
            0,                              //   stride
            NULL,                           //   pointer
            NULL,                           //   pfn
            NULL,                           //   pfnCompile
        },
    };

    gc->vertexArray = defaultVertexArrayState;
}

void APIENTRY glcltEdgeFlagPointer (GLsizei stride, const GLvoid *pointer)
{
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    if (stride < 0)
    {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    } 

    if (stride)
        gc->vertexArray.edgeFlag.ibytes = stride;
    else
        gc->vertexArray.edgeFlag.ibytes = sizeof(GLboolean);

    gc->vertexArray.edgeFlag.stride  = stride;
    gc->vertexArray.edgeFlag.pointer = pointer;
}

void APIENTRY glcltTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    GLuint vaMask;
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    switch (type)
    {
      case GL_SHORT:
        vaMask = VAMASK_TEXCOORD_TYPE_SHORT;
        break;
      case GL_INT:
        vaMask = VAMASK_TEXCOORD_TYPE_INT;
        break;
      case GL_FLOAT:
        vaMask = VAMASK_TEXCOORD_TYPE_FLOAT;
        break;
      case GL_DOUBLE:
        vaMask = VAMASK_TEXCOORD_TYPE_DOUBLE;
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    switch (size)
    {
      case 1:
        vaMask |= VAMASK_TEXCOORD_SIZE_1;
        break;
      case 2:
        vaMask |= VAMASK_TEXCOORD_SIZE_2;
        break;
      case 3:
        vaMask |= VAMASK_TEXCOORD_SIZE_3;
        break;
      case 4:
        vaMask |= VAMASK_TEXCOORD_SIZE_4;
        break;
      default:
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    if (stride < 0)
    {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    if (stride)
        gc->vertexArray.texCoord.ibytes = stride;
    else
        gc->vertexArray.texCoord.ibytes = size * __GLTYPESIZE(type);

    gc->vertexArray.texCoord.size    = size;
    gc->vertexArray.texCoord.type    = type;
    gc->vertexArray.texCoord.stride  = stride;
    gc->vertexArray.texCoord.pointer = pointer;
    if ((gc->vertexArray.mask & VAMASK_TEXCOORD_TYPE_SIZE_MASK) != vaMask)
    {
        gc->vertexArray.mask  &= ~VAMASK_TEXCOORD_TYPE_SIZE_MASK;
        gc->vertexArray.mask  |= vaMask;
        gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
    }
}

void APIENTRY glcltColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    GLuint vaMask;
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    switch (type)
    {
      case GL_BYTE:
        vaMask = VAMASK_COLOR_TYPE_BYTE;
        break;
      case GL_UNSIGNED_BYTE:
        vaMask = VAMASK_COLOR_TYPE_UBYTE;
        break;
      case GL_SHORT:
        vaMask = VAMASK_COLOR_TYPE_SHORT;
        break;
      case GL_UNSIGNED_SHORT:
        vaMask = VAMASK_COLOR_TYPE_USHORT;
        break;
      case GL_INT:
        vaMask = VAMASK_COLOR_TYPE_INT;
        break;
      case GL_UNSIGNED_INT:
        vaMask = VAMASK_COLOR_TYPE_UINT;
        break;
      case GL_FLOAT:
        vaMask = VAMASK_COLOR_TYPE_FLOAT;
        break;
      case GL_DOUBLE:
        vaMask = VAMASK_COLOR_TYPE_DOUBLE;
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    switch (size)
    {
      case 3:
        vaMask |= VAMASK_COLOR_SIZE_3;
        break;
      case 4:
        vaMask |= VAMASK_COLOR_SIZE_4;
        break;
      default:
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }

    if (stride < 0)
    {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }

    if (stride)
        gc->vertexArray.color.ibytes = stride;
    else
        gc->vertexArray.color.ibytes = size * __GLTYPESIZE(type);

    gc->vertexArray.color.size    = size;
    gc->vertexArray.color.type    = type;
    gc->vertexArray.color.stride  = stride;
    gc->vertexArray.color.pointer = pointer;
    if ((gc->vertexArray.mask & VAMASK_COLOR_TYPE_SIZE_MASK) != vaMask)
    {
        gc->vertexArray.mask  &= ~VAMASK_COLOR_TYPE_SIZE_MASK;
        gc->vertexArray.mask  |= vaMask;
        gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
    }
}

void APIENTRY glcltIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer)
{
    GLuint vaMask;
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    switch (type)
    {
      case GL_UNSIGNED_BYTE:
        vaMask = VAMASK_INDEX_TYPE_UBYTE;
	break;
      case GL_SHORT:
        vaMask = VAMASK_INDEX_TYPE_SHORT;
	break;
      case GL_INT:
        vaMask = VAMASK_INDEX_TYPE_INT;
	break;
      case GL_FLOAT:
        vaMask = VAMASK_INDEX_TYPE_FLOAT;
	break;
      case GL_DOUBLE:
        vaMask = VAMASK_INDEX_TYPE_DOUBLE;
	break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    if (stride < 0)
    {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }

    if (stride)
        gc->vertexArray.index.ibytes = stride;
    else
        gc->vertexArray.index.ibytes = __GLTYPESIZE(type);

    gc->vertexArray.index.type    = type;
    gc->vertexArray.index.stride  = stride;
    gc->vertexArray.index.pointer = pointer;
    // update index function pointer!
    if ((gc->vertexArray.mask & VAMASK_INDEX_TYPE_SIZE_MASK) != vaMask)
    {
        gc->vertexArray.mask  &= ~VAMASK_INDEX_TYPE_SIZE_MASK;
        gc->vertexArray.mask  |= vaMask;
        gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
    }
}

void APIENTRY glcltNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer)
{
    GLuint vaMask;
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    switch (type)
    {
      case GL_BYTE:
        vaMask = VAMASK_NORMAL_TYPE_BYTE;
        break;
      case GL_SHORT:
        vaMask = VAMASK_NORMAL_TYPE_SHORT;
        break;
      case GL_INT:
        vaMask = VAMASK_NORMAL_TYPE_INT;
        break;
      case GL_FLOAT:
        vaMask = VAMASK_NORMAL_TYPE_FLOAT;
        break;
      case GL_DOUBLE:
        vaMask = VAMASK_NORMAL_TYPE_DOUBLE;
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    if (stride < 0)
    {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }

    if (stride)
        gc->vertexArray.normal.ibytes = stride;
    else
        gc->vertexArray.normal.ibytes = 3 * __GLTYPESIZE(type);

    gc->vertexArray.normal.type    = type;
    gc->vertexArray.normal.stride  = stride;
    gc->vertexArray.normal.pointer = pointer;
    if ((gc->vertexArray.mask & VAMASK_NORMAL_TYPE_SIZE_MASK) != vaMask)
    {
        gc->vertexArray.mask  &= ~VAMASK_NORMAL_TYPE_SIZE_MASK;
        gc->vertexArray.mask  |= vaMask;
        gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
    }
}

void APIENTRY glcltVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    GLuint vaMask;
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    switch (type)
    {
      case GL_SHORT:
        vaMask = VAMASK_VERTEX_TYPE_SHORT;
        break;
      case GL_INT:
        vaMask = VAMASK_VERTEX_TYPE_INT;
        break;
      case GL_FLOAT:
        vaMask = VAMASK_VERTEX_TYPE_FLOAT;
        break;
      case GL_DOUBLE:
        vaMask = VAMASK_VERTEX_TYPE_DOUBLE;
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    switch (size)
    {
      case 2:
        vaMask |= VAMASK_VERTEX_SIZE_2;
        break;
      case 3:
        vaMask |= VAMASK_VERTEX_SIZE_3;
        break;
      case 4:
        vaMask |= VAMASK_VERTEX_SIZE_4;
        break;
      default:
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }

    if (stride < 0)
    {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }

    if (stride)
        gc->vertexArray.vertex.ibytes = stride;
    else
        gc->vertexArray.vertex.ibytes = size * __GLTYPESIZE(type);

    gc->vertexArray.vertex.size    = size;
    gc->vertexArray.vertex.type    = type;
    gc->vertexArray.vertex.stride  = stride;
    gc->vertexArray.vertex.pointer = pointer;
    if ((gc->vertexArray.mask & VAMASK_VERTEX_TYPE_SIZE_MASK) != vaMask)
    {
        gc->vertexArray.mask  &= ~VAMASK_VERTEX_TYPE_SIZE_MASK;
        gc->vertexArray.mask  |= vaMask;
        gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
    }
}

void APIENTRY glcltEnableClientState (GLenum cap)
{
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    // ARRAY_TYPE_ASSERT
    if (RANGE(cap,GL_VERTEX_ARRAY,GL_EDGE_FLAG_ARRAY))
    {
        if (!(gc->vertexArray.mask & vaEnable[cap - GL_VERTEX_ARRAY]))
        {
            gc->vertexArray.mask  |= vaEnable[cap - GL_VERTEX_ARRAY];
            gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
        }
    }
}

void APIENTRY glcltDisableClientState (GLenum cap)
{
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    // ARRAY_TYPE_ASSERT
    if (RANGE(cap,GL_VERTEX_ARRAY,GL_EDGE_FLAG_ARRAY))
    {
        if (gc->vertexArray.mask & vaEnable[cap - GL_VERTEX_ARRAY])
        {
	        gc->vertexArray.mask  &= ~vaEnable[cap - GL_VERTEX_ARRAY];
	        gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
        }
    }
}

void APIENTRY glcltGetPointerv (GLenum pname, GLvoid* *params)
{
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    switch (pname)
    {
      case GL_VERTEX_ARRAY_POINTER:
        *params = (GLvoid *) gc->vertexArray.vertex.pointer;
        break;
      case GL_NORMAL_ARRAY_POINTER:
        *params = (GLvoid *) gc->vertexArray.normal.pointer;
        break;
      case GL_COLOR_ARRAY_POINTER:
        *params = (GLvoid *) gc->vertexArray.color.pointer;
        break;
      case GL_INDEX_ARRAY_POINTER:
        *params = (GLvoid *) gc->vertexArray.index.pointer;
        break;
      case GL_TEXTURE_COORD_ARRAY_POINTER:
        *params = (GLvoid *) gc->vertexArray.texCoord.pointer;
        break;
      case GL_EDGE_FLAG_ARRAY_POINTER:
        *params = (GLvoid *) gc->vertexArray.edgeFlag.pointer;
        break;
      case GL_SELECTION_BUFFER_POINTER:
        // The client pointer is maintained current at all times.
        *params = (GLvoid *) gc->select.resultBase;
        break;
      case GL_FEEDBACK_BUFFER_POINTER:
        // The client pointer is maintained current at all times.
        *params = (GLvoid *) gc->feedback.resultBase;
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        break;
    }
}

// We have special cases for the following formats.  They also match the
// special cases in display list.
//
//   V2F
//   V3F
//   C3F_V3F
//   N3F_V3F
//   C3F_N3F_V3F     (non 1.1 format)
//   C4F_N3F_V3F
//   T2F_V3F
//   T2F_C3F_V3F
//   T2F_N3F_V3F
//   T2F_C3F_N3F_V3F (non 1.1 format)
//   T2F_C4F_N3F_V3F
//
// There are no special cases for the following 1.1 formats:
//
//   C4UB_V2F
//   C4UB_V3F
//   T4F_V4F
//   T2F_C4UB_V3F
//   T4F_C4F_N3F_V4F

void FASTCALL VA_ValidateArrayPointers(__GLcontext *gc)
{
    GLuint vaMask;
    GLuint formatMask;
    PFNVAELEMENT fp;
    PFNVAELEMENTBATCH fpB;
    PFNVAELEMENTBATCHINDIRECT fpBI;

    fp = VA_ArrayElement;
    fpB  = VA_ArrayElementB;
    fpBI = VA_ArrayElementBI;
    vaMask = gc->vertexArray.mask;

// The fast routines are for RGBA mode only.  Edge flag and index array
// pointers are disabled in these routines.  Vertex array pointer is enabled.

    if (!gc->modes.colorIndexMode &&
        !(vaMask & (VAMASK_EDGEFLAG_ENABLE_MASK | VAMASK_INDEX_ENABLE_MASK)) &&
        (vaMask & VAMASK_VERTEX_ENABLE_MASK))
    {
        formatMask = VAMASK_VERTEX_TYPE_SIZE_MASK | VAMASK_VERTEX_ENABLE_MASK;
        if (vaMask & VAMASK_TEXCOORD_ENABLE_MASK)
	        formatMask |= VAMASK_TEXCOORD_TYPE_SIZE_MASK | VAMASK_TEXCOORD_ENABLE_MASK;
        if (vaMask & VAMASK_COLOR_ENABLE_MASK)
	        formatMask |= VAMASK_COLOR_TYPE_SIZE_MASK | VAMASK_COLOR_ENABLE_MASK;
        if (vaMask & VAMASK_NORMAL_ENABLE_MASK)
	        formatMask |= VAMASK_NORMAL_TYPE_SIZE_MASK | VAMASK_NORMAL_ENABLE_MASK;

        switch (vaMask & formatMask)
        {
          case VAMASK_FORMAT_V2F:
	        fp = VA_ArrayElement_V2F;
	        fpB = VA_ArrayElement_V2F_B;
	        fpBI = VA_ArrayElement_V2F_BI;
	        break;
          case VAMASK_FORMAT_V3F:
	        fp = VA_ArrayElement_V3F;
	        fpB = VA_ArrayElement_V3F_B;
	        fpBI = VA_ArrayElement_V3F_BI;
	        break;
          case VAMASK_FORMAT_C3F_V3F:
	        fp = VA_ArrayElement_C3F_V3F;
	        fpB = VA_ArrayElement_C3F_V3F_B;
	        fpBI = VA_ArrayElement_C3F_V3F_BI;
	        break;
          case VAMASK_FORMAT_N3F_V3F:
	        fp = VA_ArrayElement_N3F_V3F;
	        fpB = VA_ArrayElement_N3F_V3F_B;
	        fpBI = VA_ArrayElement_N3F_V3F_BI;
	        break;
          case VAMASK_FORMAT_C3F_N3F_V3F:
	        fp = VA_ArrayElement_C3F_N3F_V3F;
	        fpB = VA_ArrayElement_C3F_N3F_V3F_B;
	        fpBI = VA_ArrayElement_C3F_N3F_V3F_BI;
	        break;
          case VAMASK_FORMAT_C4F_N3F_V3F:
	        fp = VA_ArrayElement_C4F_N3F_V3F;
	        fpB = VA_ArrayElement_C4F_N3F_V3F_B;
	        fpBI = VA_ArrayElement_C4F_N3F_V3F_BI;
	        break;
          case VAMASK_FORMAT_T2F_V3F:
	        fp = VA_ArrayElement_T2F_V3F;
	        fpB = VA_ArrayElement_T2F_V3F_B;
	        fpBI = VA_ArrayElement_T2F_V3F_BI;
	        break;
          case VAMASK_FORMAT_T2F_C3F_V3F:
	        fp = VA_ArrayElement_T2F_C3F_V3F;
	        fpB = VA_ArrayElement_T2F_C3F_V3F_B;
	        fpBI = VA_ArrayElement_T2F_C3F_V3F_BI;
	        break;
          case VAMASK_FORMAT_T2F_N3F_V3F:
	        fp = VA_ArrayElement_T2F_N3F_V3F;
	        fpB = VA_ArrayElement_T2F_N3F_V3F_B;
	        fpBI = VA_ArrayElement_T2F_N3F_V3F_BI;
	        break;
          case VAMASK_FORMAT_T2F_C3F_N3F_V3F:
	        fp = VA_ArrayElement_T2F_C3F_N3F_V3F;
	        fpB = VA_ArrayElement_T2F_C3F_N3F_V3F_B;
	        fpBI = VA_ArrayElement_T2F_C3F_N3F_V3F_BI;
	        break;
          case VAMASK_FORMAT_T2F_C4F_N3F_V3F:
	        fp = VA_ArrayElement_T2F_C4F_N3F_V3F;
	        fpB = VA_ArrayElement_T2F_C4F_N3F_V3F_B;
	        fpBI = VA_ArrayElement_T2F_C4F_N3F_V3F_BI;
	        break;
        }
    }

// The default function pointers are used outside Begin.

    ASSERTOPENGL(gc->vertexArray.edgeFlag.pfn == (PFNGLVECTOR) glcltEdgeFlagv &&
                 gc->vertexArray.edgeFlag.pfnCompile == (PFNGLVECTOR) __gllc_EdgeFlagv,
	"edgeFlag.pfn and edgeFlag.pfnCompile not initialized\n");
    gc->vertexArray.texCoord.pfn
	= afnTexCoord[(vaMask & VAMASK_TEXCOORD_TYPE_SIZE_MASK) >> VAMASK_TEXCOORD_TYPE_SHIFT];
    gc->vertexArray.texCoord.pfnCompile
	= afnTexCoordCompile[(vaMask & VAMASK_TEXCOORD_TYPE_SIZE_MASK) >> VAMASK_TEXCOORD_TYPE_SHIFT];
    if (gc->modes.colorIndexMode)
    {
        gc->vertexArray.color.pfn
	        = afnColor_InCI[(vaMask & VAMASK_COLOR_TYPE_SIZE_MASK) >> VAMASK_COLOR_TYPE_SHIFT];
        gc->vertexArray.index.pfn
	        = afnIndex_InCI[(vaMask & VAMASK_INDEX_TYPE_SIZE_MASK) >> VAMASK_INDEX_TYPE_SHIFT];
    }
    else
    {
        gc->vertexArray.color.pfn
	        = afnColor_InRGBA[(vaMask & VAMASK_COLOR_TYPE_SIZE_MASK) >> VAMASK_COLOR_TYPE_SHIFT];
        gc->vertexArray.index.pfn
	        = afnIndex_InRGBA[(vaMask & VAMASK_INDEX_TYPE_SIZE_MASK) >> VAMASK_INDEX_TYPE_SHIFT];
    }
    gc->vertexArray.color.pfnCompile
        = afnColorCompile[(vaMask & VAMASK_COLOR_TYPE_SIZE_MASK) >> VAMASK_COLOR_TYPE_SHIFT];
    gc->vertexArray.index.pfnCompile
        = afnIndexCompile[(vaMask & VAMASK_INDEX_TYPE_SIZE_MASK) >> VAMASK_INDEX_TYPE_SHIFT];
    gc->vertexArray.normal.pfn
        = afnNormal[(vaMask & VAMASK_NORMAL_TYPE_SIZE_MASK) >> VAMASK_NORMAL_TYPE_SHIFT];
    gc->vertexArray.normal.pfnCompile
        = afnNormalCompile[(vaMask & VAMASK_NORMAL_TYPE_SIZE_MASK) >> VAMASK_NORMAL_TYPE_SHIFT];
    gc->vertexArray.vertex.pfn
        = afnVertex[(vaMask & VAMASK_VERTEX_TYPE_SIZE_MASK) >> VAMASK_VERTEX_TYPE_SHIFT];
    gc->vertexArray.vertex.pfnCompile
        = afnVertexCompile[(vaMask & VAMASK_VERTEX_TYPE_SIZE_MASK) >> VAMASK_VERTEX_TYPE_SHIFT];

    gc->vertexArray.pfnArrayElement = fp;
    gc->vertexArray.pfnArrayElementBatch = fpB;
    gc->vertexArray.pfnArrayElementBatchIndirect = fpBI;
    gc->vertexArray.flags &= ~__GL_VERTEX_ARRAY_DIRTY;
}

void APIENTRY glcltArrayElement (GLint i)
{
    __GL_SETUP();

    if (gc->vertexArray.flags & __GL_VERTEX_ARRAY_DIRTY)
	VA_ValidateArrayPointers(gc);

// The fast routines are called in Begin only.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
        (*gc->vertexArray.pfnArrayElement)(gc, i);
    else
        VA_ArrayElement(gc, i);
}

// Define fast VA_ArrayElement functions.

#define __VA_ARRAY_ELEMENT_V2F			1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_V2F

#define __VA_ARRAY_ELEMENT_V3F			1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_V3F

#define __VA_ARRAY_ELEMENT_C3F_V3F		1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_C3F_V3F

#define __VA_ARRAY_ELEMENT_N3F_V3F		1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_N3F_V3F

#define __VA_ARRAY_ELEMENT_C3F_N3F_V3F		1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_C3F_N3F_V3F

#define __VA_ARRAY_ELEMENT_C4F_N3F_V3F		1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_C4F_N3F_V3F

#define __VA_ARRAY_ELEMENT_T2F_V3F		1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_T2F_V3F

#define __VA_ARRAY_ELEMENT_T2F_C3F_V3F		1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_T2F_C3F_V3F

#define __VA_ARRAY_ELEMENT_T2F_N3F_V3F		1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_T2F_N3F_V3F

#define __VA_ARRAY_ELEMENT_T2F_C3F_N3F_V3F	1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_T2F_C3F_N3F_V3F

#define __VA_ARRAY_ELEMENT_T2F_C4F_N3F_V3F	1
    #include "array.h"
#undef __VA_ARRAY_ELEMENT_T2F_C4F_N3F_V3F

#define CALLARRAYPOINTER(ap, i) \
    ((*(ap).pfn)((ap).pointer + (i) * (ap).ibytes))

#define CALLARRAYPOINTERS                               \
    if (vaMask & VAMASK_EDGEFLAG_ENABLE_MASK)           \
        CALLARRAYPOINTER(gc->vertexArray.edgeFlag, i);  \
    if (vaMask & VAMASK_TEXCOORD_ENABLE_MASK)           \
        CALLARRAYPOINTER(gc->vertexArray.texCoord, i);  \
    if (vaMask & VAMASK_COLOR_ENABLE_MASK)              \
        CALLARRAYPOINTER(gc->vertexArray.color, i);     \
    if (vaMask & VAMASK_INDEX_ENABLE_MASK)              \
        CALLARRAYPOINTER(gc->vertexArray.index, i);     \
    if (vaMask & VAMASK_NORMAL_ENABLE_MASK)             \
        CALLARRAYPOINTER(gc->vertexArray.normal, i);    \
    if (vaMask & VAMASK_VERTEX_ENABLE_MASK)             \
        CALLARRAYPOINTER(gc->vertexArray.vertex, i);

void FASTCALL VA_ArrayElementB(__GLcontext *gc, GLint firstVertex, GLint nVertices)
{
    GLint   k, i;
    GLuint  vaMask = gc->vertexArray.mask;

    for (k=0; k < nVertices; k++)
    {
        i = k+firstVertex;
        CALLARRAYPOINTERS;
    }
}

void FASTCALL VA_ArrayElementBI(__GLcontext *gc, GLint nVertices, VAMAP* indices)
{
    GLint   k, i;
    GLuint  vaMask = gc->vertexArray.mask;

    for (k=0; k < nVertices; k++)
    {
        i = indices[k].iIn;
        CALLARRAYPOINTERS;
    }
}

void FASTCALL VA_ArrayElement(__GLcontext *gc, GLint i)
{
    GLuint vaMask = gc->vertexArray.mask;

    CALLARRAYPOINTERS;
}

void APIENTRY glcltDrawArrays (GLenum mode, GLint first, GLsizei count)
{
    int i;
    POLYARRAY    *pa;
    PFNVAELEMENTBATCH pfn;

    __GL_SETUP();

    pa = gc->paTeb;

// Not allowed in begin/end.

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    if ((GLuint) mode > GL_POLYGON)
    {
        GLSETERROR(GL_INVALID_ENUM);
	return;
    }

    if (count < 0)
    {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    } else if (!count)
        return;

// Find array element function to use.

    if (gc->vertexArray.flags & __GL_VERTEX_ARRAY_DIRTY)
	VA_ValidateArrayPointers(gc);

    pfn = gc->vertexArray.pfnArrayElementBatch;

// Check polyarray buffer size before calling Begin.
// We will minimize breaking poly data records into batches where possible.
// The number 8 is loosely chosen to allow for the poly array entry
// and the flush limit.  At worst, it causes an unnecessary attention!

    if (count <= (GLsizei) gc->vertex.pdBufSize - 8 &&
        count >= (GLsizei) (pa->pdBufferMax - pa->pdBufferNext + 1 - 8))
        glsbAttention();

// Draw the array elements.

    glcltBegin(mode);
    pa->flags |= POLYARRAY_SAME_POLYDATA_TYPE;

    (*pfn)(gc, first, count);

    glcltEnd();
}

// Do not modify these constants.  The code will likely break if they are
// changed.
#define VA_HASH_SIZE            256
#define VA_HASH(indexIn)        ((GLubyte) indexIn)

// If the size of the mapping array is greater than 256, we need to change
// datatype and code below.
#if (VA_DRAWELEM_MAP_SIZE > 256)
#error "VA_DRAWELEM_MAP_SIZE is too large"
#endif

/******************************Public*Routine******************************\
* ReduceDrawElements
*
* Takes a set of DrawElements indices and reduces it into small chunks
* of unique vertex indices
*
* History:
*  Sat Mar 02 14:25:26 1996     -by-    Hock San Lee    [hockl]
* Wrote original version embedded in DrawElements
*  Sat Mar 02 14:25:26 1996     -by-    Drew Bliss      [drewb]
* Split into function shared between immediate and dlist
*
\**************************************************************************/

void FASTCALL ReduceDrawElements(__GLcontext *gc,
                                 GLenum mode, GLsizei count, GLenum type,
                                 const GLvoid *pIn,
                                 pfnReducedElementsHandler pfnHandler)
{
    GLushort     _aHash[VA_HASH_SIZE + 2];
    GLushort     *pHash;
    VAMAP        aMap[VA_DRAWELEM_MAP_SIZE];
    GLushort     iMap, iMapNext;
    GLushort     iOutNext;
    GLubyte      aOut[VA_DRAWELEM_INDEX_SIZE];
    GLsizei      iPartialIndices;
    GLsizei      iCount, nLeft;
    GLuint       iIn;
    
// We will now sort the input index array using a hash table.  The output
// index array will be zero based.  For example, if the input array is
// [103, 101,   0,   2, 105, 103,   2,   4], the output index will be
// [0,     1,   2,   3,   4,   0,   3,   5].  This allows us to store
// vertices in a consecutive order.
// Dword aligned hash array.

    pHash = (GLushort *) (((UINT_PTR) _aHash + 3) & ~3);

// Initialize input index array pointer.

    iCount = 0;
    iPartialIndices = 0;

DrawElements_NextBatch:

// Reset output index array for this batch.
// Initialize identity mapping for the first reserved vertex entries.
// New vertices are accumulated after them.

    for (iOutNext = 0; iOutNext < (GLushort) iPartialIndices; iOutNext++)
	aOut[iOutNext] = (GLubyte) iOutNext;

// Reset index mapping array that maps the In array to Out array.
// The index map corresponds to the vertices in the vertex buffer.
// Skip the reserved indices that are used for connectivity between
// partial primitives.

    iMapNext = iOutNext;

// Reset hash array to no mapping (-1).

    RtlFillMemoryUlong((PVOID) pHash, (ULONG) VA_HASH_SIZE * sizeof(*pHash),
	(ULONG) -1);

// There are 3 possibilities in the following loop:
//
// 1. All input indices have been processed.  The primitive is complete!
// 2. The index map overflows.  We have accumulated 256 vertices for a partial
//    primitive.
// 3. The output index array overflows.  We have exceeded our estimated size
//    of the output index array for a partial primitive.

    for ( ; iCount < count; iCount++)
    {
// Get next input index.

	if (type == GL_UNSIGNED_BYTE)
	    iIn = (GLuint) ((GLubyte *)  pIn)[iCount];
	else if (type == GL_UNSIGNED_SHORT)
	    iIn = (GLuint) ((GLushort *) pIn)[iCount];
	else
	    iIn = (GLuint) ((GLuint *)   pIn)[iCount];

#if DRAWELEM_DEBUG
	DbgPrint("iCount %d ", iCount);
	DbgPrint("iIn %d ", iIn);
	DbgPrint("iMapNext %d iOutNext %d",
                 (GLuint) iMapNext, (GLuint) iOutNext);
#endif

// Look up previously mapped index if one exists.

	iMap = pHash[VA_HASH(iIn)];
	while (iMap != (GLushort) -1 && aMap[iMap].iIn != iIn)
	    iMap = aMap[iMap].next;

#if DRAWELEM_DEBUG
	DbgPrint("iMapFound %d\n", (GLuint) iMap);
#endif

// If aMap or aOut overflows, flush the partial primitive.

	if (iOutNext >= VA_DRAWELEM_INDEX_SIZE ||
            (iMap == (GLushort) -1 && iMapNext >= VA_DRAWELEM_MAP_SIZE))
        {
#if DRAWELEM_DEBUG
            DbgPrint("Flush iMapNext %d iOutNext %d\n",
                     (GLuint) iMapNext, (GLuint) iOutNext);
#endif

// We have accumulated enough vertices for a partial primitive.  We now
// need to figure out the exact number of vertices to flush and redo
// the leftover vertices in the next partial primitive.

#if DBG
            if (iOutNext >= VA_DRAWELEM_INDEX_SIZE)
                DbgPrint("DrawElements: aOut buffer overflows\n");
#endif

// Find the flush vertex of this partial primitive.

            nLeft = 0;
            switch (mode)
            {
            case GL_LINE_STRIP:
            case GL_TRIANGLE_FAN:
                break;
            case GL_POINTS:
            case GL_LINE_LOOP:
            case GL_POLYGON:
                ASSERTOPENGL(FALSE, "unexpected primitive type\n");
                break;
            case GL_LINES:
            case GL_TRIANGLE_STRIP:
            case GL_QUAD_STRIP:
                // number of vertices must be a multiple of 2
                if (iOutNext % 2)
                    nLeft++;
                break;
            case GL_TRIANGLES:
                // number of vertices must be a multiple of 3
                switch (iOutNext % 3)
                {
                case 2: nLeft++;        // fall through
                case 1: nLeft++;
                }
                break;
            case GL_QUADS:
                // number of vertices must be a multiple of 4
                switch (iOutNext % 4)
                {
                case 3: nLeft++;        // fall through
                case 2: nLeft++;        // fall through
                case 1: nLeft++;
                }
                break;
            }

// Add the leftover vertices back to the input array and redo them
// in the next partial primitive.

            iCount   -= nLeft;
            iOutNext -= (GLushort) nLeft;

            // When passing on our data, skip any vertices
            // that were reserved from a previous partial primitive
            (*pfnHandler)(gc, mode,
                          iMapNext-iPartialIndices, 0, aMap+iPartialIndices,
                          iOutNext, aOut, GL_TRUE);

            iPartialIndices = nReservedIndicesPartialBegin[mode];
                
// Continue to process remaining vertices.

            goto DrawElements_NextBatch;
        }

// If no previously mapped index is found, add the new vertex.

        if (iMap == (GLushort) -1)
        {
            ASSERTOPENGL(iMapNext < VA_DRAWELEM_MAP_SIZE,
                         "index map overflows!\n");

#if DRAWELEM_DEBUG
            DbgPrint("    Add iIn %d iMap %d iHash %d\n",
                     iIn, (GLuint) iMapNext, (GLuint) VA_HASH(iIn));
#endif

            iMap = iMapNext++;
            aMap[iMap].iIn  = iIn;
            aMap[iMap].next = pHash[VA_HASH(iIn)];
            pHash[VA_HASH(iIn)] = iMap;
        }

// Add the mapped index to output index array.

	ASSERTOPENGL(iMap < VA_DRAWELEM_MAP_SIZE, "bad mapped index\n");
	ASSERTOPENGL(iOutNext < VA_DRAWELEM_INDEX_SIZE,
                     "aOut array overflows!\n");

#if DRAWELEM_DEBUG
	DbgPrint("    Add iOutNext %d iMap %d\n",
                 (GLuint) iOutNext, (GLuint) iMap);
#endif
	aOut[iOutNext++] = (GLubyte) iMap;
    }

// We have processed all input vertices.
// Pass on any remaining data

    (*pfnHandler)(gc, mode,
                  iMapNext-iPartialIndices, 0, aMap+iPartialIndices,
                  iOutNext, aOut, GL_FALSE);
}

void FASTCALL glcltReducedElementsHandler(__GLcontext *gc,
                                          GLenum mode,
                                          GLsizei iVertexCount,
                                          GLsizei iVertexBase,
                                          VAMAP *pvmVertices,
                                          GLsizei iElementCount,
                                          GLubyte *pbElements,
                                          GLboolean fPartial)
{
    POLYARRAY *pa = gc->paTeb;
    PFNVAELEMENT pfn;
    GLsizei i;
    
    // Set up the vertex data
    pfn = gc->vertexArray.pfnArrayElement;
    if (pvmVertices != NULL)
    {
        PFNVAELEMENTBATCHINDIRECT pfn = gc->vertexArray.pfnArrayElementBatchIndirect;
        (*pfn)(gc, iVertexCount, pvmVertices);
    }
    else
    {
        // Access consecutive block of vertices, starting at iVertexBase
        PFNVAELEMENTBATCH pfn = gc->vertexArray.pfnArrayElementBatch;
        (*pfn)(gc, iVertexBase, iVertexCount);
    }
    
// Copy the index array to the end of the polyarray primitive.

    pa->nIndices = (GLuint) iElementCount;
    // skip terminator vertex
    pa->aIndices = (GLubyte *) (pa->pdNextVertex + 1);
    ASSERTOPENGL(pa->aIndices + pa->nIndices
                 <= (GLubyte *) (pa->pdBufferMax+1),
                 "Vertex buffer overflows!\n");
    memcpy(pa->aIndices, pbElements, pa->nIndices * sizeof(GLubyte));

    if (fPartial)
    {
    // Flush the partial primitive.

        VA_DrawElementsFlushPartialPrimitive(pa, mode);
    }
    else
    {
        VA_DrawElementsEnd(pa);
    }
}

// This handles primitive modes that DrawElements or DrawRangeElements don't.
void FASTCALL VA_DrawElementsHandleOtherPrimTypes( __GLcontext *gc,
                                                   GLenum mode,
                                                   GLsizei count,
                                                   GLenum type,
                                                   GLvoid *pIn )
{
    GLsizei      iCount;
    PFNVAELEMENT pfn;
    POLYARRAY    *pa;
    GLuint       iIn;

    pa = gc->paTeb;
    pfn = gc->vertexArray.pfnArrayElement;

    glcltBegin(mode);
    pa->flags |= POLYARRAY_SAME_POLYDATA_TYPE;

    for (iCount = 0; iCount < count; iCount++)
    {
        // Get next input index.
        if (type == GL_UNSIGNED_BYTE)
	        iIn = (GLuint) ((GLubyte *)  pIn)[iCount];
        else if (type == GL_UNSIGNED_SHORT)
	        iIn = (GLuint) ((GLushort *) pIn)[iCount];
        else
	        iIn = (GLuint) ((GLuint *)   pIn)[iCount];

        (*pfn)(gc, iIn);
    }

    glcltEnd();
}

void APIENTRY glcltDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *pIn)
{
    POLYARRAY    *pa;
    GLuint       iIn;
    GLsizei      iCount;

    __GL_SETUP();

    pa = gc->paTeb;

#define DRAWELEM_DEBUG 0
#if DRAWELEM_DEBUG
{
    DbgPrint("mode %d, count %d, type %d\n", mode, count, type);
    DbgPrint("pIn: ");
    for (iCount = 0; iCount < count; iCount++)
    {
	if (type == GL_UNSIGNED_BYTE)
	    iIn = (GLuint) ((GLubyte *)  pIn)[iCount];
	else if (type == GL_UNSIGNED_SHORT)
	    iIn = (GLuint) ((GLushort *) pIn)[iCount];
	else
	    iIn = (GLuint) ((GLuint *)   pIn)[iCount];

	DbgPrint("%d ", iIn);
    }
    DbgPrint("\n");
}
#endif

// If we are already in the begin/end bracket, return an error.

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    if ((GLuint) mode > GL_POLYGON)
    {
        GLSETERROR(GL_INVALID_ENUM);
	return;
    }

    if (count < 0)
    {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    } else if (!count)
        return;

    switch (type)
    {
      case GL_UNSIGNED_BYTE:
      case GL_UNSIGNED_SHORT:
      case GL_UNSIGNED_INT:
	break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

// Find array element function to use.

    if (gc->vertexArray.flags & __GL_VERTEX_ARRAY_DIRTY)
        VA_ValidateArrayPointers(gc);

// Send Points, Line Loop, and Polygon to Begin/End call.  Points and Polygon
// don't benefit from optimization in this function.  Further, Polygon and
// Line Loop are too tricky to deal with in this function.

    if (mode == GL_POINTS || mode == GL_LINE_LOOP || mode == GL_POLYGON)
    {
        VA_DrawElementsHandleOtherPrimTypes( gc, mode, count, type, (GLvoid *) pIn );
	    return;
    }

// Begin primitive.

    VA_DrawElementsBegin(pa, mode, count);

    // The primitive will be ended on the last batch of
    // elements
    ReduceDrawElements(gc, mode, count, type, pIn,
                       glcltReducedElementsHandler);
}

void RebaseIndices( GLvoid *pIn, GLubyte *aOut, GLsizei count, GLuint start, 
                    GLenum type )
{
    if (type == GL_UNSIGNED_BYTE) {
        while( count-- )
            *aOut++ = (GLubyte) ( ((GLuint) *( ((GLubyte *) pIn) ++ )) - start);
    }
    else if (type == GL_UNSIGNED_SHORT) {
        while( count-- )
            *aOut++ = (GLubyte) ( ((GLuint) *( ((GLushort *) pIn) ++ )) - start);
    }
    else {
        while( count-- )
            *aOut++ = (GLubyte) ( ((GLuint) *( ((GLuint *) pIn) ++ )) - start);
    }
}

void APIENTRY glcltDrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *pIn)
{
    POLYARRAY    *pa;
    GLuint       iVertexCount;
    GLubyte      aOut[VA_DRAWELEM_INDEX_SIZE];

    __GL_SETUP();

    pa = gc->paTeb;

// If we are already in the begin/end bracket, return an error.

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    if ((GLuint) mode > GL_POLYGON)
    {
        GLSETERROR(GL_INVALID_ENUM);
	return;
    }

    iVertexCount = end-start+1;
    if( (count < 0) || 
        (end < start) )
    {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }
    else if (!count)
    {
        return;
    }

    switch (type)
    {
      case GL_UNSIGNED_BYTE:
      case GL_UNSIGNED_SHORT:
      case GL_UNSIGNED_INT:
	break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    if (gc->vertexArray.flags & __GL_VERTEX_ARRAY_DIRTY)
	VA_ValidateArrayPointers(gc);

// Send Points, Line Loop, and Polygon to Begin/End call.  Points and Polygon
// don't benefit from optimization in this function.  Further, Polygon and
// Line Loop are too tricky to deal with in this function.

    if (mode == GL_POINTS || mode == GL_LINE_LOOP || mode == GL_POLYGON)
    {
        VA_DrawElementsHandleOtherPrimTypes( gc, mode, count, type, (GLvoid *) pIn );
	return;
    }

    // Begin primitive.

    VA_DrawElementsBegin(pa, mode, count);

    if ( (count > VA_DRAWRANGEELEM_MAX_INDICES) ||
         (iVertexCount > VA_DRAWRANGEELEM_MAX_VERTICES) )
    {
        // The primitive is too large to be processed directly so
        // we have to reduce it. The primitive will be ended on the
        // last batch of elements.
        ReduceDrawElements(gc, mode, count, type, pIn,
                           glcltReducedElementsHandler);
    }
    else
    {
        // Need to rebase (0-base) the indices and convert them to ubyte for
        // the reduced element handler.
        RebaseIndices( (GLvoid *) pIn, aOut, count, start, type );

        // Finish primitive
        glcltReducedElementsHandler(gc, mode, 
                                    iVertexCount,
                                    start, // iVertexBase
                                    NULL,
                                    count,
                                    aOut,
                                    GL_FALSE);
    }
}

// Interleaved array AND mask.
// INTERLEAVED_FORMAT_ASSERT
GLuint iaAndMask[14] =
{
// GL_V2F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_TEXCOORD_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_COLOR_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_TEXCOORD_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_COLOR_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_C4UB_V2F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_TEXCOORD_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_C4UB_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_TEXCOORD_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_C3F_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_TEXCOORD_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_N3F_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_TEXCOORD_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_COLOR_TYPE_SIZE_MASK,
// GL_C4F_N3F_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_TEXCOORD_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK,
// GL_T2F_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_COLOR_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_T4F_V4F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_COLOR_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_T2F_C4UB_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_T2F_C3F_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_NORMAL_TYPE_SIZE_MASK,
// GL_T2F_N3F_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK |
    VAMASK_COLOR_TYPE_SIZE_MASK,
// GL_T2F_C4F_N3F_V3F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK,
// GL_T4F_C4F_N3F_V4F
    VAMASK_EDGEFLAG_TYPE_SIZE_MASK |
    VAMASK_INDEX_TYPE_SIZE_MASK,
};

// Interleaved array OR mask.
// INTERLEAVED_FORMAT_ASSERT
GLuint iaOrMask[14] =
{
    VAMASK_FORMAT_V2F,             // GL_V2F
    VAMASK_FORMAT_V3F,             // GL_V3F
    VAMASK_FORMAT_C4UB_V2F,        // GL_C4UB_V2F
    VAMASK_FORMAT_C4UB_V3F,        // GL_C4UB_V3F
    VAMASK_FORMAT_C3F_V3F,         // GL_C3F_V3F
    VAMASK_FORMAT_N3F_V3F,         // GL_N3F_V3F
    VAMASK_FORMAT_C4F_N3F_V3F,     // GL_C4F_N3F_V3F
    VAMASK_FORMAT_T2F_V3F,         // GL_T2F_V3F
    VAMASK_FORMAT_T4F_V4F,         // GL_T4F_V4F
    VAMASK_FORMAT_T2F_C4UB_V3F,    // GL_T2F_C4UB_V3F
    VAMASK_FORMAT_T2F_C3F_V3F,     // GL_T2F_C3F_V3F
    VAMASK_FORMAT_T2F_N3F_V3F,     // GL_T2F_N3F_V3F
    VAMASK_FORMAT_T2F_C4F_N3F_V3F, // GL_T2F_C4F_N3F_V3F
    VAMASK_FORMAT_T4F_C4F_N3F_V4F, // GL_T4F_C4F_N3F_V4F
};

// Interleaved array default strides.
GLuint iaStride[14] =
{
     2 * sizeof(GLfloat),                       // GL_V2F
     3 * sizeof(GLfloat),                       // GL_V3F
     2 * sizeof(GLfloat) + 4 * sizeof(GLubyte), // GL_C4UB_V2F
     3 * sizeof(GLfloat) + 4 * sizeof(GLubyte), // GL_C4UB_V3F
     6 * sizeof(GLfloat),                       // GL_C3F_V3F
     6 * sizeof(GLfloat),                       // GL_N3F_V3F
    10 * sizeof(GLfloat),                       // GL_C4F_N3F_V3F
     5 * sizeof(GLfloat),                       // GL_T2F_V3F
     8 * sizeof(GLfloat),                       // GL_T4F_V4F
     5 * sizeof(GLfloat) + 4 * sizeof(GLubyte), // GL_T2F_C4UB_V3F
     8 * sizeof(GLfloat),                       // GL_T2F_C3F_V3F
     8 * sizeof(GLfloat),                       // GL_T2F_N3F_V3F
    12 * sizeof(GLfloat),                       // GL_T2F_C4F_N3F_V3F
    15 * sizeof(GLfloat),                       // GL_T4F_C4F_N3F_V4F
};

void APIENTRY glcltInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer)
{
    GLuint iFormat, iStride;
    GLuint vaMask;
    const GLbyte *pb = pointer;
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    // INTERLEAVED_FORMAT_ASSERT
    iFormat = (GLuint) (format - GL_V2F);
    if (iFormat > GL_T4F_C4F_N3F_V4F)
    {
	GLSETERROR(GL_INVALID_ENUM);
	return;
    }

    if (stride < 0)
    {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    if (stride)
	iStride = stride;
    else
	iStride = iaStride[iFormat];

// Compute new mask.
// If we are disabling an array, don't modify its type and size field!

    vaMask  = gc->vertexArray.mask;
    vaMask &= iaAndMask[iFormat];
    vaMask |= iaOrMask[iFormat];

    if (gc->vertexArray.mask != vaMask)
    {
	gc->vertexArray.mask  = vaMask;
	gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
    }

    if (vaMask & VAMASK_TEXCOORD_ENABLE_MASK)
    {
	gc->vertexArray.texCoord.type    = GL_FLOAT;
	gc->vertexArray.texCoord.stride  = iStride;
	gc->vertexArray.texCoord.ibytes  = iStride;
	gc->vertexArray.texCoord.pointer = pb;
	if ((vaMask & VAMASK_TEXCOORD_TYPE_SIZE_MASK) ==
	      (VAMASK_TEXCOORD_SIZE_4 | VAMASK_TEXCOORD_TYPE_FLOAT))
	{
	    gc->vertexArray.texCoord.size = 4;
	    pb += 4 * sizeof(GLfloat);
	}
	else
	{
	    ASSERTOPENGL((vaMask & VAMASK_TEXCOORD_TYPE_SIZE_MASK) ==
	        (VAMASK_TEXCOORD_SIZE_2 | VAMASK_TEXCOORD_TYPE_FLOAT),
	        "unhandled texcoord format\n");
	    gc->vertexArray.texCoord.size = 2;
	    pb += 2 * sizeof(GLfloat);
	}
    }

    if (vaMask & VAMASK_COLOR_ENABLE_MASK)
    {
	gc->vertexArray.color.stride  = iStride;
	gc->vertexArray.color.ibytes  = iStride;
	gc->vertexArray.color.pointer = pb;

	switch (vaMask & VAMASK_COLOR_TYPE_SIZE_MASK)
	{
          case VAMASK_COLOR_TYPE_UBYTE | VAMASK_COLOR_SIZE_4:
	    gc->vertexArray.color.type = GL_UNSIGNED_BYTE;
	    gc->vertexArray.color.size = 4;
	    pb += 4 * sizeof(GLubyte);
	    break;
          case VAMASK_COLOR_TYPE_FLOAT | VAMASK_COLOR_SIZE_3:
	    gc->vertexArray.color.type = GL_FLOAT;
	    gc->vertexArray.color.size = 3;
	    pb += 3 * sizeof(GLfloat);
	    break;
          case VAMASK_COLOR_TYPE_FLOAT | VAMASK_COLOR_SIZE_4:
	    gc->vertexArray.color.type = GL_FLOAT;
	    gc->vertexArray.color.size = 4;
	    pb += 4 * sizeof(GLfloat);
	    break;
          default:
	    ASSERTOPENGL(FALSE, "unhandled color format\n");
	    break;
	}
    }

    if (vaMask & VAMASK_NORMAL_ENABLE_MASK)
    {
	gc->vertexArray.normal.type    = GL_FLOAT;
	gc->vertexArray.normal.stride  = iStride;
	gc->vertexArray.normal.ibytes  = iStride;
	gc->vertexArray.normal.pointer = pb;
	pb += 3 * sizeof(GLfloat);
    }

    gc->vertexArray.vertex.type    = GL_FLOAT;
    gc->vertexArray.vertex.stride  = iStride;
    gc->vertexArray.vertex.ibytes  = iStride;
    gc->vertexArray.vertex.pointer = pb;
    switch (vaMask & VAMASK_VERTEX_TYPE_SIZE_MASK)
    {
      case VAMASK_VERTEX_TYPE_FLOAT | VAMASK_VERTEX_SIZE_4:
	gc->vertexArray.vertex.size = 4;
	break;
      case VAMASK_VERTEX_TYPE_FLOAT | VAMASK_VERTEX_SIZE_3:
	gc->vertexArray.vertex.size = 3;
	break;
      case VAMASK_VERTEX_TYPE_FLOAT | VAMASK_VERTEX_SIZE_2:
	gc->vertexArray.vertex.size = 2;
	break;
      default:
	ASSERTOPENGL(FALSE, "unhandled vertex format\n");
	break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\array.h ===
/******************************Module*Header*******************************\
* Module Name: array.h
*
* Fast VA_ArrayElement functions.
*
* Created: 1-31-1996
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#ifndef __array_h_
#define __array_h_

#define __VA_PD_FLAGS_T2F     (POLYDATA_TEXTURE_VALID|POLYDATA_DLIST_TEXTURE2)
#define __VA_PD_FLAGS_C3F     (POLYDATA_COLOR_VALID)
#define __VA_PD_FLAGS_C4F     (POLYDATA_COLOR_VALID| POLYDATA_DLIST_COLOR_4)
#define __VA_PD_FLAGS_N3F     (POLYDATA_NORMAL_VALID)
#define __VA_PD_FLAGS_V2F     (POLYDATA_VERTEX2)
#define __VA_PD_FLAGS_V3F     (POLYDATA_VERTEX3)
#define __VA_PD_FLAGS_V4F     (POLYDATA_VERTEX4)

#define __VA_PA_FLAGS_T2F     (POLYARRAY_TEXTURE2)
#define __VA_PA_FLAGS_C3F     (0)
#define __VA_PA_FLAGS_C4F     (0)
#define __VA_PA_FLAGS_N3F     (0)
#define __VA_PA_FLAGS_V2F     (POLYARRAY_VERTEX2)
#define __VA_PA_FLAGS_V3F     (POLYARRAY_VERTEX3)
#define __VA_PA_FLAGS_V4F     (POLYARRAY_VERTEX4)

#endif // __array_h_

#ifdef __VA_ARRAY_ELEMENT_V2F
    #define __VA_NAME        VA_ArrayElement_V2F
    #define __VA_NAMEB       VA_ArrayElement_V2F_B
    #define __VA_NAMEBI      VA_ArrayElement_V2F_BI
    #define __VA_T2F         0
    #define __VA_C3F         0
    #define __VA_C4F         0
    #define __VA_N3F         0
    #define __VA_V2F         1
    #define __VA_V3F         0
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_V3F
    #define __VA_NAME        VA_ArrayElement_V3F
    #define __VA_NAMEB       VA_ArrayElement_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_V3F_BI
    #define __VA_T2F         0
    #define __VA_C3F         0
    #define __VA_C4F         0
    #define __VA_N3F         0
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_C3F_V3F
    #define __VA_NAME        VA_ArrayElement_C3F_V3F
    #define __VA_NAMEB       VA_ArrayElement_C3F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_C3F_V3F_BI
    #define __VA_T2F         0
    #define __VA_C3F         1
    #define __VA_C4F         0
    #define __VA_N3F         0
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_N3F_V3F
    #define __VA_NAME        VA_ArrayElement_N3F_V3F
    #define __VA_NAMEB       VA_ArrayElement_N3F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_N3F_V3F_BI
    #define __VA_T2F         0
    #define __VA_C3F         0
    #define __VA_C4F         0
    #define __VA_N3F         1
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_C3F_N3F_V3F
    #define __VA_NAME        VA_ArrayElement_C3F_N3F_V3F
    #define __VA_NAMEB       VA_ArrayElement_C3F_N3F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_C3F_N3F_V3F_BI
    #define __VA_T2F         0
    #define __VA_C3F         1
    #define __VA_C4F         0
    #define __VA_N3F         1
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_C4F_N3F_V3F
    #define __VA_NAME        VA_ArrayElement_C4F_N3F_V3F
    #define __VA_NAMEB       VA_ArrayElement_C4F_N3F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_C4F_N3F_V3F_BI
    #define __VA_T2F         0
    #define __VA_C3F         0
    #define __VA_C4F         1
    #define __VA_N3F         1
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_T2F_V3F
    #define __VA_NAME        VA_ArrayElement_T2F_V3F
    #define __VA_NAMEB       VA_ArrayElement_T2F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_T2F_V3F_BI
    #define __VA_T2F         1
    #define __VA_C3F         0
    #define __VA_C4F         0
    #define __VA_N3F         0
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_T2F_C3F_V3F
    #define __VA_NAME        VA_ArrayElement_T2F_C3F_V3F
    #define __VA_NAMEB       VA_ArrayElement_T2F_C3F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_T2F_C3F_V3F_BI
    #define __VA_T2F         1
    #define __VA_C3F         1
    #define __VA_C4F         0
    #define __VA_N3F         0
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_T2F_N3F_V3F
    #define __VA_NAME        VA_ArrayElement_T2F_N3F_V3F
    #define __VA_NAMEB       VA_ArrayElement_T2F_N3F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_T2F_N3F_V3F_BI
    #define __VA_T2F         1
    #define __VA_C3F         0
    #define __VA_C4F         0
    #define __VA_N3F         1
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_T2F_C3F_N3F_V3F
    #define __VA_NAME        VA_ArrayElement_T2F_C3F_N3F_V3F
    #define __VA_NAMEB       VA_ArrayElement_T2F_C3F_N3F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_T2F_C3F_N3F_V3F_BI
    #define __VA_T2F         1
    #define __VA_C3F         1
    #define __VA_C4F         0
    #define __VA_N3F         1
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif
#ifdef __VA_ARRAY_ELEMENT_T2F_C4F_N3F_V3F
    #define __VA_NAME        VA_ArrayElement_T2F_C4F_N3F_V3F
    #define __VA_NAMEB       VA_ArrayElement_T2F_C4F_N3F_V3F_B
    #define __VA_NAMEBI      VA_ArrayElement_T2F_C4F_N3F_V3F_BI
    #define __VA_T2F         1
    #define __VA_C3F         0
    #define __VA_C4F         1
    #define __VA_N3F         1
    #define __VA_V2F         0
    #define __VA_V3F         1
    #define __VA_V4F         0
#endif

/*************************************************************************/
// Compute pd flags and pa flags

#if __VA_T2F
    #define __VA_PD_FLAGS_T   __VA_PD_FLAGS_T2F
    #define __VA_PA_FLAGS_T   __VA_PA_FLAGS_T2F
#else
    #define __VA_PD_FLAGS_T   0
    #define __VA_PA_FLAGS_T   0
#endif

#if __VA_C3F
    #define __VA_PD_FLAGS_C   __VA_PD_FLAGS_C3F
    #define __VA_PA_FLAGS_C   __VA_PA_FLAGS_C3F
#elif __VA_C4F
    #define __VA_PD_FLAGS_C   __VA_PD_FLAGS_C4F
    #define __VA_PA_FLAGS_C   __VA_PA_FLAGS_C4F
#else
    #define __VA_PD_FLAGS_C   0
    #define __VA_PA_FLAGS_C   0
#endif

#if __VA_N3F
    #define __VA_PD_FLAGS_N   __VA_PD_FLAGS_N3F
    #define __VA_PA_FLAGS_N   __VA_PA_FLAGS_N3F
#else
    #define __VA_PD_FLAGS_N   0
    #define __VA_PA_FLAGS_N   0
#endif

#if __VA_V2F
    #define __VA_PD_FLAGS_V   __VA_PD_FLAGS_V2F
    #define __VA_PA_FLAGS_V   __VA_PA_FLAGS_V2F
#elif __VA_V3F
    #define __VA_PD_FLAGS_V   __VA_PD_FLAGS_V3F
    #define __VA_PA_FLAGS_V   __VA_PA_FLAGS_V3F
#elif __VA_V4F
    #define __VA_PD_FLAGS_V   __VA_PD_FLAGS_V4F
    #define __VA_PA_FLAGS_V   __VA_PA_FLAGS_V4F
#endif

#define __VA_PD_FLAGS \
    (__VA_PD_FLAGS_T|__VA_PD_FLAGS_C|__VA_PD_FLAGS_N|__VA_PD_FLAGS_V)
#define __VA_PA_FLAGS \
    (__VA_PA_FLAGS_T|__VA_PA_FLAGS_C|__VA_PA_FLAGS_N|__VA_PA_FLAGS_V)

#define VA_COPY_VERTEX_V2F(dataCoord)           \
    pd->obj.x = ((__GLcoord *) dataCoord)->x;   \
    pd->obj.y = ((__GLcoord *) dataCoord)->y;   \
    pd->obj.z = __glZero;                       \
    pd->obj.w = __glOne;                        

#define VA_COPY_VERTEX_V3F(dataCoord)           \
    pd->obj.x = ((__GLcoord *) dataCoord)->x;   \
    pd->obj.y = ((__GLcoord *) dataCoord)->y;   \
    pd->obj.z = ((__GLcoord *) dataCoord)->z;   \
    pd->obj.w = __glOne;                        

#define VA_COPY_VERTEX_V4F(dataCoord)           \
    pd->obj = *((__GLcoord *) data);            

#define VA_COPY_TEXTURE_T2F(dataTexture)            \
    pd->texture.x = ((__GLcoord *) dataTexture)->x; \
    pd->texture.y = ((__GLcoord *) dataTexture)->y; \
    pd->texture.z = __glZero;                       \
    pd->texture.w = __glOne;

#define VA_COPY_COLOR_C3F(dataColor)                                \
    __GL_SCALE_AND_CHECK_CLAMP_RGB(pd->colors[0].r,                 \
                                   pd->colors[0].g,                 \
                                   pd->colors[0].b,                 \
				                   gc, pa->flags,                   \
                                   ((__GLcolor *) dataColor)->r,    \
                                   ((__GLcolor *) dataColor)->g,    \
                                   ((__GLcolor *) dataColor)->b);   \
    pd->colors[0].a = gc->alphaVertexScale;

#define VA_COPY_COLOR_C4F(dataColor)                                \
__GL_SCALE_AND_CHECK_CLAMP_RGBA(pd->colors[0].r,                    \
                                pd->colors[0].g,                    \
                                pd->colors[0].b,                    \
                                pd->colors[0].a,                    \
                                gc, pa->flags,                      \
                                ((__GLcolor *) dataColor)->r,       \
                                ((__GLcolor *) dataColor)->g,       \
                                ((__GLcolor *) dataColor)->b,       \
                                ((__GLcolor *) dataColor)->a);

#define VA_COPY_NORMAL_N3F(dataNormal)                              \
            pd->normal.x = ((__GLcoord *) dataNormal)->x;           \
            pd->normal.y = ((__GLcoord *) dataNormal)->y;           \
            pd->normal.z = ((__GLcoord *) dataNormal)->z;

/*************************************************************************/
// Define a fast VA_ArrayElement function for batch mode.
// This function is called in Begin and in RGBA mode only!
//
void FASTCALL __VA_NAMEB(__GLcontext *gc, GLint firstIndex, GLint nVertices)
{
    POLYARRAY* const    pa = gc->paTeb;
    POLYDATA*           pd;
    const GLbyte *dataCoord     = gc->vertexArray.vertex.pointer;
    const int   coordStride     = gc->vertexArray.vertex.ibytes;
#if __VA_N3F
    const GLbyte *dataNormal    = gc->vertexArray.normal.pointer;
    const int   normalStride    = gc->vertexArray.normal.ibytes;
#endif
#if __VA_T2F
    const GLbyte *dataTexture   = gc->vertexArray.texCoord.pointer;
    const int   textureStride   = gc->vertexArray.texCoord.ibytes;
#endif
#if __VA_C3F ||  __VA_C4F
    const GLbyte *dataColor     = gc->vertexArray.color.pointer;
    const int   colorStride     = gc->vertexArray.color.ibytes;
#endif

    if (firstIndex != 0)
    {
        dataCoord  += firstIndex*coordStride;
#if __VA_N3F
        dataNormal += firstIndex*normalStride;
#endif
#if __VA_T2F
        dataTexture+= firstIndex*textureStride;
#endif
#if __VA_C3F ||  __VA_C4F
        dataColor  += firstIndex*colorStride;
#endif
    }

    ASSERTOPENGL(pa->flags & POLYARRAY_IN_BEGIN,
	"VA_ArrayElement called outside Begin!\n");

    while (nVertices > 0)
    {
        int     n, nProcess;
        int     needFlush = FALSE;
        
        pa->flags |= __VA_PA_FLAGS;
        pd = pa->pdNextVertex; 
        if (&pd[nVertices-1] >= pa->pdFlush)
        {
            nProcess = (int)((ULONG_PTR)(pa->pdFlush - pd) + 1);
            needFlush = TRUE;
        }
        else
            nProcess = nVertices;

        for (n=nProcess; n > 0; n--)
        {

        // Update pd attributes.

            pd->flags = __VA_PD_FLAGS;

        #if __VA_V2F
            VA_COPY_VERTEX_V2F(dataCoord);
        #elif __VA_V3F
            VA_COPY_VERTEX_V3F(dataCoord);
        #elif __VA_V4F
            VA_COPY_VERTEX_V4F(dataCoord);
        #endif
            dataCoord += coordStride;

        #if __VA_T2F
            VA_COPY_TEXTURE_T2F(dataTexture);
            dataTexture += textureStride;
        #endif

        #if __VA_C3F
            // Color
            VA_COPY_COLOR_C3F(dataColor);
            dataColor += colorStride;
        #elif __VA_C4F
            // Color
            VA_COPY_COLOR_C4F(dataColor);
            dataColor += colorStride;
        #endif

        #if __VA_N3F
            // Normal
            VA_COPY_NORMAL_N3F(dataNormal);
            dataNormal += normalStride;
        #endif
            pd++;
        } // End of loop
        
        pa->pdNextVertex = pd;
        pd->flags = 0;
        pd--;
    #if __VA_T2F
        pa->pdCurTexture = pd;
    #endif
    #if __VA_C3F || __VA_C4F
        pa->pdCurColor   = pd;
    #endif
    #if __VA_N3F
        pa->pdCurNormal  = pd;
    #endif
        nVertices-= nProcess;
        if (needFlush) 
            PolyArrayFlushPartialPrimitive();
    }
}

/*************************************************************************/
// Define a fast VA_ArrayElement function for batch indirect mode.
// This function is called in Begin and in RGBA mode only!
//
void FASTCALL __VA_NAMEBI(__GLcontext *gc, GLint nVertices, VAMAP* indices)
{
    POLYARRAY* const    pa = gc->paTeb;
    POLYDATA*           pd;
    const GLbyte *dataCoord0    = gc->vertexArray.vertex.pointer;
    const int   coordStride     = gc->vertexArray.vertex.ibytes;
#if __VA_N3F
    const GLbyte *dataNormal0    = gc->vertexArray.normal.pointer;
    const int   normalStride    = gc->vertexArray.normal.ibytes;
#endif
#if __VA_T2F
    const GLbyte *dataTexture0  = gc->vertexArray.texCoord.pointer;
    const int   textureStride   = gc->vertexArray.texCoord.ibytes;
#endif
#if __VA_C3F || __VA_C4F
    const GLbyte *dataColor0    = gc->vertexArray.color.pointer;
    const int   colorStride     = gc->vertexArray.color.ibytes;
#endif

    ASSERTOPENGL(pa->flags & POLYARRAY_IN_BEGIN,
	"VA_ArrayElement called outside Begin!\n");

    while (nVertices > 0)
    {
        int     n, nProcess;
        int     needFlush = FALSE;

        pa->flags |= __VA_PA_FLAGS;
        pd = pa->pdNextVertex; 
        if (&pd[nVertices-1] >= pa->pdFlush)
        {
            nProcess = (int)((ULONG_PTR)(pa->pdFlush - pd) + 1);
            needFlush = TRUE;
        }
        else
            nProcess = nVertices;
        for (n=nProcess; n > 0; n--)
        {
            int  i = indices->iIn;
            const GLbyte* dataCoord;
        #if __VA_N3F
            const GLbyte* dataNormal;
        #endif
        #if __VA_C3F ||  __VA_C4F
            const GLbyte* dataColor;
        #endif
        #if __VA_T2F
            const GLbyte* dataTexture;
        #endif
            indices++;

        // Update pd attributes.

            pd->flags = __VA_PD_FLAGS;

            dataCoord   = dataCoord0 + i * coordStride;
        #if __VA_V2F
            VA_COPY_VERTEX_V2F(dataCoord);
        #elif __VA_V3F
            VA_COPY_VERTEX_V3F(dataCoord);
        #elif __VA_V4F
            VA_COPY_VERTEX_V4F(dataCoord);
        #endif

        #if __VA_T2F
            dataTexture = dataTexture0 + i * textureStride;
            VA_COPY_TEXTURE_T2F(dataTexture);
        #endif

        #if __VA_C3F
            // Color
            dataColor   = dataColor0 + i * colorStride;
            VA_COPY_COLOR_C3F(dataColor);
        #elif __VA_C4F
            // Color
            dataColor   = dataColor0 + i * colorStride;
            VA_COPY_COLOR_C4F(dataColor);
        #endif

        #if __VA_N3F
            // Normal
            dataNormal  = dataNormal0 + i * normalStride;
            VA_COPY_NORMAL_N3F(dataNormal);
        #endif
            pd++;
        } // End of loop
        
        pa->pdNextVertex = pd;
        pd->flags = 0;
        pd--;
    #if __VA_T2F
        pa->pdCurTexture = pd;
    #endif
    #if __VA_C3F || __VA_C4F
        pa->pdCurColor   = pd;
    #endif
    #if __VA_N3F
        pa->pdCurNormal  = pd;
    #endif
        nVertices-= nProcess;
        if (needFlush) 
            PolyArrayFlushPartialPrimitive();
    }
}
/*************************************************************************/
// Define a fast VA_ArrayElement function.
// This function is called in Begin and in RGBA mode only!
void FASTCALL __VA_NAME(__GLcontext *gc, GLint i)
{
    POLYARRAY    *pa;
    POLYDATA     *pd;
    const GLbyte *data;

    pa = gc->paTeb;

    ASSERTOPENGL(pa->flags & POLYARRAY_IN_BEGIN,
	"VA_ArrayElement called outside Begin!\n");

// Update pa fields.

    pa->flags |= __VA_PA_FLAGS;
    pd = pa->pdNextVertex++;

#if __VA_T2F
    pa->pdCurTexture = pd;
#endif
#if __VA_C3F || __VA_C4F
    pa->pdCurColor   = pd;
#endif
#if __VA_N3F
    pa->pdCurNormal  = pd;
#endif

// Update pd attributes.

    pd->flags |= __VA_PD_FLAGS;

    data = gc->vertexArray.vertex.pointer + i * gc->vertexArray.vertex.ibytes;
#if __VA_V2F
    VA_COPY_VERTEX_V2F(data);
#elif __VA_V3F
    VA_COPY_VERTEX_V3F(data);
#elif __VA_V4F
    VA_COPY_VERTEX_V4F(data);
#endif

#if __VA_T2F
    data = gc->vertexArray.texCoord.pointer + i * gc->vertexArray.texCoord.ibytes;
    VA_COPY_TEXTURE_T2F(data);
#endif

#if __VA_C3F
    data = gc->vertexArray.color.pointer + i * gc->vertexArray.color.ibytes;
    VA_COPY_COLOR_C3F(data);
#elif __VA_C4F
    data = gc->vertexArray.color.pointer + i * gc->vertexArray.color.ibytes;
    VA_COPY_COLOR_C4F(data);
#endif

#if __VA_N3F
    // Normal
    data = gc->vertexArray.normal.pointer + i * gc->vertexArray.normal.ibytes;
    VA_COPY_NORMAL_N3F(data);
#endif

    pd[1].flags = 0;
    if (pd >= pa->pdFlush)
        PolyArrayFlushPartialPrimitive();
}

    #undef __VA_NAMEB
    #undef __VA_NAMEBI
    #undef VA_COPY_VERTEX_V2F
    #undef VA_COPY_VERTEX_V3F
    #undef VA_COPY_VERTEX_V4F
    #undef VA_COPY_TEXTURE
    #undef VA_COPY_COLOR_C3F
    #undef VA_COPY_COLOR_C4F
    #undef VA_COPY_NORMAL
    #undef __VA_NAME
    #undef __VA_T2F
    #undef __VA_C3F
    #undef __VA_C4F
    #undef __VA_N3F
    #undef __VA_V2F
    #undef __VA_V3F
    #undef __VA_V4F
    #undef __VA_PD_FLAGS_T
    #undef __VA_PD_FLAGS_C
    #undef __VA_PD_FLAGS_N
    #undef __VA_PD_FLAGS_V
    #undef __VA_PA_FLAGS_T
    #undef __VA_PA_FLAGS_C
    #undef __VA_PA_FLAGS_N
    #undef __VA_PA_FLAGS_V
    #undef __VA_PD_FLAGS
    #undef __VA_PA_FLAGS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\util.c ===
/****************************************************************************
 *
 *   util.c
 *
 *   Copyright (c) 1992-1999 Microsoft Corporation
 *
 ***************************************************************************/

#include "winmmi.h"

//
//  Assist with unicode conversions
//


// This function translates from Unicode strings to multibyte strings.
// It will automatically munge down the Unicode string until the translation
// is guaranteed to succeed with the buffer space available in the multibyte
// buffer.  Then it performs the conversion.


int Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len)
{

int wlength;

wlength=wcslen(lpwstr)+1;

	while (WideCharToMultiByte(GetACP(), 0, lpwstr, wlength, NULL, 0, NULL, NULL)>len && wlength>0) {
		wlength--;
		}

    return WideCharToMultiByte(GetACP(), 0, lpwstr, wlength, lpstr, len, NULL, NULL);
}

int Imbstowcs(LPWSTR lpwstr, LPCSTR lpstr, int len)
{
    return MultiByteToWideChar(GetACP(),
                               MB_PRECOMPOSED,
                               lpstr,
                               -1,
                               lpwstr,
                               len);
}

#if 0
BOOL HugePageLock(LPVOID lpArea, DWORD dwLength)
{
     PVOID BaseAddress = lpArea;
     ULONG RegionSize = dwLength;
     NTSTATUS Status;

     Status =
         NtLockVirtualMemory(NtCurrentProcess(),
                             &BaseAddress,
                             &RegionSize,
                             MAP_PROCESS);

     //
     // People without the right priviledge will not have the luxury
     // of having their pages locked
     // (maybe we should do something else to commit it ?)
     //

     if (!NT_SUCCESS(Status) && Status != STATUS_PRIVILEGE_NOT_HELD) {
         dprintf2(("Failed to lock virtual memory - code %X", Status));
         return FALSE;
     }
     return TRUE;
}

void HugePageUnlock(LPVOID lpArea, DWORD dwLength)
{
     PVOID BaseAddress = lpArea;
     ULONG RegionSize = dwLength;
     NTSTATUS Status;

     Status =
         NtUnlockVirtualMemory(NtCurrentProcess(),
                               &BaseAddress,
                               &RegionSize,
                               MAP_PROCESS);

     //
     // People without the right priviledge will not have the luxury
     // of having their pages locked
     // (maybe we should do something else to commit it ?)
     //

     if (!NT_SUCCESS(Status) && Status != STATUS_PRIVILEGE_NOT_HELD) {
         dprintf2(("Failed to unlock virtual memory - code %X", Status));
     }
}
#endif

/****************************************************************************
*
*   @doc DDK MMSYSTEM
*
*   @api BOOL | DriverCallback | This function notifies a client
*     application by sending a message to a window or callback
*     function or by unblocking a task.
*
*   @parm   DWORD   | dwCallBack    | Specifies either the address of
*     a callback function, a window handle, or a task handle, depending on
*     the flags specified in the <p wFlags> parameter.
*
*   @parm   DWORD   | dwFlags        | Specifies how the client
*     application is notified, according to one of the following flags:
*
*   @flag   DCB_FUNCTION        | The application is notified by
*     sending a message to a callback function.  The <p dwCallback>
*     parameter specifies a procedure-instance address.
*   @flag   DCB_WINDOW          | The application is notified by
*     sending a message to a window.  The low-order word of the
*     <p dwCallback> parameter specifies a window handle.
*   @flag   DCB_TASK            | The application is notified by
*     calling mmTaskSignal
*   @flag   DCB_EVENT           | The application is notified by
*     calling SetEvent on the (assumed) event handle
*
*   @parm   HANDLE   | hDevice       | Specifies a handle to the device
*     associated with the notification.  This is the handle assigned by
*     MMSYSTEM when the device was opened.
*
*   @parm   DWORD   | dwMsg          | Specifies a message to send to the
*     application.
*
*   @parm   DWORD   | dwUser        | Specifies the DWORD of user instance
*     data supplied by the application when the device was opened.
*
*   @parm   DWORD   | dwParam1      | Specifies a message-dependent parameter.
*   @parm   DWORD   | dwParam2      | Specifies a message-dependent parameter.
*
*   @rdesc Returns TRUE if the callback was performed, else FALSE if an invalid
*     parameter was passed, or the task's message queue was full.
*
*   @comm  This function can be called from an APC routine.
*
*   The flags DCB_FUNCTION and DCB_WINDOW are equivalent to the
*   high-order word of the corresponding flags CALLBACK_FUNCTION
*   and CALLBACK_WINDOW specified when the device was opened.
*
*   If notification is done with a callback function, <p hDevice>,
*   <p wMsg>, <p dwUser>, <p dwParam1>, and <p dwParam2> are passed to
*   the callback.  If notification is done with a window, only <p wMsg>,
*   <p hDevice>, and <p dwParam1> are passed to the window.
 ***************************************************************************/

BOOL APIENTRY DriverCallback(DWORD_PTR       dwCallBack,
                             DWORD           dwFlags,
                             HDRVR           hDrv,
                             DWORD           dwMsg,
                             DWORD_PTR       dwUser,
                             DWORD_PTR       dw1,
                             DWORD_PTR       dw2)
{

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
//   if this is a MIM_DATA message, and thruing is enabled for this
//   device, pass the data on the the thru device
//   NOTE: we do this BEFORE we check for NULL callback type on purpose!
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;

//
//	if this is not a MIM_DATA message, or if we have no
//	thruing handle installed in the midi in device,
//	we can skip all of the midi thruing code
//
    if ((dwMsg == MIM_DATA) && (HtoPT(PMIDIDEV,hDrv)->pmThru))
	{
	    MMRESULT mmr;

		mmr = midiOutShortMsg((HMIDIOUT)HtoPT(PMIDIDEV,hDrv)->pmThru, (DWORD)dw1);

		if (MIDIERR_DONT_CONTINUE == mmr)
		{
		    return FALSE;
		}

		if (MMSYSERR_INVALHANDLE == mmr)
		{
		    HtoPT(PMIDIDEV,hDrv)->pmThru = NULL;
		}
	}

	//
    // If the callback routine is null or erroneous flags are set return
    // at once
    //

    if (dwCallBack == 0L) {
        return FALSE;
    }

    //
    // Test what type of callback we're to make
    //

    switch (dwFlags & DCB_TYPEMASK) {

    case DCB_WINDOW:
        //
        // Send message to window
        //

        return PostMessage(*(HWND *)&dwCallBack, dwMsg, (WPARAM)hDrv, (LPARAM)dw1);

    case DCB_TASK:
        //
        // Send message to task
        //
        PostThreadMessage((DWORD)dwCallBack, dwMsg, (WPARAM)hDrv, (LPARAM)dw1);
        return mmTaskSignal((DWORD)dwCallBack);

    case DCB_FUNCTION:
        //
        // Call back the user's callback
        //
        (**(PDRVCALLBACK *)&dwCallBack)(hDrv, dwMsg, dwUser, dw1, dw2);
        return TRUE;

    case DCB_EVENT:
        //
        // Signal the user's event
        //
	SetEvent((HANDLE)dwCallBack);
        return TRUE;

    default:
        return FALSE;
    }
}

/*
 * @doc INTERNAL MCI
 * @api PVOID | mciAlloc | Allocate memory from our heap and zero it
 *
 * @parm DWORD | cb | The amount of memory to allocate
 *
 * @rdesc returns pointer to the new memory
 *
 */

PVOID winmmAlloc(DWORD cb)
{
    PVOID ptr;

    ptr = (PVOID)HeapAlloc(hHeap, 0, cb);

    if (ptr == NULL) {
        return NULL;
    } else {
        ZeroMemory(ptr, cb);
        return ptr;
    }

}

/*
 * @doc INTERNAL MCI
 * @api PVOID | mciReAlloc | ReAllocate memory from our heap and zero extra
 *
 * @parm DWORD | cb | The new size
 *
 * @rdesc returns pointer to the new memory
 *
 */

PVOID winmmReAlloc(PVOID ptr, DWORD cb)
{
    PVOID newptr;
    DWORD oldcb;

    newptr = (PVOID)HeapAlloc(hHeap, 0, cb);

    if (newptr != NULL) {
        oldcb = (DWORD)HeapSize(hHeap, 0, ptr);
        if (oldcb<cb) {  // Block is being expanded
            ZeroMemory((PBYTE)newptr+oldcb, cb-oldcb);
            cb = oldcb;
        }
        CopyMemory(newptr, ptr, cb);
        HeapFree(hHeap, 0, ptr);
    }
    return newptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\winmm\winmmi.h ===
/***************************************************************************
 *  winmmi.h
 *
 *  Copyright (c) 1990-2001 Microsoft Corporation
 *
 *  private include file
 *
 *  History
 *
 *  15 Jan 92 - Robin Speed (RobinSp) and Steve Davies (SteveDav) -
 *      major NT update
 *  6  Feb 92 - LaurieGr replaced HLOCAL by HANDLE
 *
 ***************************************************************************/

/***************************************************************************


 Useful include files for winmm component


 ***************************************************************************/
#define DEBUG_RETAIL        /* Parameter checking is IN         */
#if DBG
  #ifndef DEBUG
    #define DEBUG
  #endif
#endif

#ifndef WINMMI_H
    #define WINMMI_H        /* Protect against double inclusion */

#ifndef RC_INVOKED

#include <string.h>
#include <stdio.h>

#endif /* RC_INVOKED */

#include <windows.h>
#include "mmsystem.h"       /* Pick up the public header */
#include "mmsysp.h"         /* pick up the internal definitions */
#include "mmcommon.h"       /* pick up the definitions common to the NT project */

#ifndef NODDK
#include "mmddkp.h"
#endif


extern BOOL             WinmmRunningInWOW;   // Are we running in WOW


/*--------------------------------------------------------------------*\
 * Unicode helper macros
\*--------------------------------------------------------------------*/
#define SZCODE  CHAR
#define WSZCODE WCHAR

#define BYTE_GIVEN_CHAR(x)  ( (x) * sizeof( WCHAR ) )
#define CHAR_GIVEN_BYTE(x)  ( (x) / sizeof( WCHAR ) )

int Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len);
int Imbstowcs(LPWSTR lpwstr, LPCSTR lpstr, int len);

/***************************************************************************


 Definitions to help with common windows code


 ***************************************************************************/

#define HPSTR LPSTR

#ifndef RC_INVOKED  /* These are defined to RC */
#define STATICDT
#define STATICFN
#define STATIC

#if DBG
    extern void InitDebugLevel(void);
    void mciCheckLocks(void);

    #undef STATICDT
    #undef STATICFN
    #undef STATIC
    #define STATICDT
    #define STATICFN
    #define STATIC
#else
    #define InitDebugLevel()
#endif  /* DBG */

#endif  /* RC_INVOKED */


/**************************************************************************



 **************************************************************************/

#define APPLICATION_DESKTOP_NAME TEXT("Default")


/**************************************************************************


  Strings related to INI files


 **************************************************************************/

/*
// File and section names for sound aliases
*/

#define SOUND_INI_FILE      L"win.ini"
#define SOUND_SECTION       L"Sounds"
#define SOUND_DEFAULT       L".Default"
#define SOUND_RESOURCE_TYPE_SOUND L"SOUND"     // in .rc file
#define SOUND_RESOURCE_TYPE_WAVE  L"WAVE"      // in .rc file
extern  WSZCODE szSystemDefaultSound[];  // Name of the default sound
extern  WSZCODE szSoundSection[];        // WIN.INI section for sounds
extern  WSZCODE wszSystemIni[];          // defined in Winmm.c
extern  WSZCODE wszDrivers[];            // defined in Winmm.c
extern  WSZCODE wszNull[];               // defined in Winmm.c

//  HACK!!  HACK!!  Should update \nt\private\inc\mmcommon.h

#ifndef MMDRVI_MIXER
#define MMDRVI_MIXER        0x0007
#define MXD_MESSAGE         "mxdMessage";
#endif

#define STR_ALIAS_SYSTEMASTERISK        3000
#define STR_ALIAS_SYSTEMQUESTION        3001
#define STR_ALIAS_SYSTEMHAND            3002
#define STR_ALIAS_SYSTEMEXIT            3003
#define STR_ALIAS_SYSTEMSTART           3004
#define STR_ALIAS_SYSTEMWELCOME         3005
#define STR_ALIAS_SYSTEMEXCLAMATION     3006
#define STR_ALIAS_SYSTEMDEFAULT         3007

#define STR_LABEL_APPGPFAULT            3008
#define STR_LABEL_CLOSE                 3009
#define STR_LABEL_EMPTYRECYCLEBIN       3010
#define STR_LABEL_MAXIMIZE              3011
#define STR_LABEL_MENUCOMMAND           3012
#define STR_LABEL_MENUPOPUP             3013
#define STR_LABEL_MINIMIZE              3014
#define STR_LABEL_OPEN                  3015
#define STR_LABEL_RESTOREDOWN           3016
#define STR_LABEL_RESTOREUP             3017
#define STR_LABEL_RINGIN                3018
#define STR_LABEL_RINGOUT               3019
#define STR_LABEL_SYSTEMASTERISK        3020
#define STR_LABEL_SYSTEMDEFAULT         3021
#define STR_LABEL_SYSTEMEXCLAMATION     3022
#define STR_LABEL_SYSTEMEXIT            3023
#define STR_LABEL_SYSTEMHAND            3024
#define STR_LABEL_SYSTEMQUESTION        3025
#define STR_LABEL_SYSTEMSTART           3026

#define STR_WINDOWS_APP_NAME            3027
#define STR_EXPLORER_APP_NAME           3028
#define STR_JOYSTICKNAME                3029

/*
// File and section names for the mci functions
*/

#define MCIDRIVERS_INI_FILE L"system.ini"
#define MCI_HANDLERS        MCI_SECTION

/***********************************************************************
 *
 *    Wrap InitializeCriticalSection to make it easier to handle error
 *
 ***********************************************************************/
_inline BOOL mmInitializeCriticalSection(OUT LPCRITICAL_SECTION lpCriticalSection)
{
    try {
	InitializeCriticalSection(lpCriticalSection);
	return TRUE;
    } except (EXCEPTION_EXECUTE_HANDLER) {
	return FALSE;
    }
}

/***********************************************************************
 *
 *    Speed up profile stuff by going straight to the registry
 *
 ***********************************************************************/

LONG
RegQuerySzValue(
    HKEY hkey,
    PCTSTR pValueName,
    PTSTR *ppstrValue
);

VOID mmRegFree(VOID);
BOOL
mmRegCreateUserKey (
    LPCWSTR lpszPathName,
    LPCWSTR lpszKeyName
);

BOOL
mmRegQueryUserKey (
    LPCWSTR lpszKeyName
);

BOOL
mmRegDeleteUserKey (
    LPCWSTR lpszKeyName
);

BOOL
mmRegSetUserValue (
    LPCWSTR lpszSectionName,
    LPCWSTR lpszValueName,
    LPCWSTR lpszValue
);

BOOL
mmRegQueryUserValue (
    LPCWSTR lpszSectionName,
    LPCWSTR lpszValueName,
    ULONG   dwLen,
    LPWSTR  lpszValue
);

BOOL
mmRegCreateMachineKey (
    LPCWSTR lpszPath,
    LPCWSTR lpszNewKey
);

BOOL
mmRegSetMachineValue (
    LPCWSTR lpszSectionName,
    LPCWSTR lpszValueName,
    LPCWSTR lpszValue
);

BOOL
mmRegQueryMachineValue (
    LPCWSTR lpszSectionName,
    LPCWSTR lpszValueName,
    ULONG   dwLen,
    LPWSTR  lpszValue
);

DWORD
winmmGetProfileString(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize
);

DWORD
winmmGetPrivateProfileString(
    LPCWSTR lpSection,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR  lpReturnedString,
    DWORD   nSize,
    LPCWSTR lpFileName
);

/***********************************************************************
 *
 *    Used by hwndNotify code
 *
 ***********************************************************************/

extern BOOL  sndMessage( LPWSTR lszSoundName, UINT wFlags );
extern BOOL InitAsyncSound(VOID);
extern CRITICAL_SECTION WavHdrCritSec;
extern CRITICAL_SECTION SoundCritSec;
extern CRITICAL_SECTION mciGlobalCritSec;

/***********************************************************************
 *
 *    Critical section for NumDevs/DeviceID's, and other stuff
 *
 ***********************************************************************/

extern CRITICAL_SECTION NumDevsCritSec;
extern HANDLE           hEventApiInit;
extern CRITICAL_SECTION midiStrmHdrCritSec;
extern CRITICAL_SECTION joyCritSec;		//in joy.c, qzheng
extern CRITICAL_SECTION ResolutionCritSec;      //in time.c
extern CRITICAL_SECTION TimerThreadCritSec;	//in time.c

/***********************************************************************
 *
 *    Flag deduced by initialization to special case running in the server
 *
 ***********************************************************************/

extern BOOL    WinmmRunningInServer;  // Are we running in the user/base server?

/***********************************************************************
 *
 *    prototypes from "winmm.c"
 *
 ***********************************************************************/

void WaveMapperInit(void);
void MidiMapperInit(void);
void midiEmulatorInit(void);


/***********************************************************************
 *
 *    prototypes from "mmiomisc.c"
 *
 ***********************************************************************/


PBYTE AsciiStrToUnicodeStr( PBYTE pdst, PBYTE pmax, LPCSTR psrc );
PBYTE UnicodeStrToAsciiStr( PBYTE pdst, PBYTE pmax, LPCWSTR psrc);
LPWSTR     AllocUnicodeStr( LPCSTR lpSourceStr );
BOOL        FreeUnicodeStr( LPWSTR lpStr );
LPSTR        AllocAsciiStr( LPCWSTR lpSourceStr );
BOOL          FreeAsciiStr( LPSTR lpStr );

/***********************************************************************
 *
 *    prototypes from "mmio.c"
 *
 ***********************************************************************/

void mmioCleanupIOProcs(HANDLE hTask);

/***********************************************************************
 *
 *  Timer functions
 *
 ***********************************************************************/

#ifndef MMNOTIMER
 BOOL TimeInit(void);
 void TimeCleanup(DWORD ThreadId);
 UINT timeSetEventInternal(UINT wDelay, UINT wResolution,
     LPTIMECALLBACK lpFunction, DWORD_PTR dwUser, UINT wFlags, BOOL IsWOW);
#endif // !MMNOTIMER


/***********************************************************************
 *
 *  Information structure used to play sounds
 *
 ***********************************************************************/

#define PLAY_NAME_SIZE  256

typedef struct _PLAY_INFO {
    HANDLE hModule;
    HANDLE hRequestingTask; // Handle of thread that requested sound
    DWORD dwFlags;
    WCHAR szName[1];     // the structure will be allocated large enough for the name
} PLAY_INFO, *PPLAY_INFO;


#define WAIT_FOREVER ((DWORD)(-1))

/***************************************************************************

    global data

 ***************************************************************************/

extern HANDLE ghInst;
       HANDLE hHeap;

extern DWORD  gTlsIndex;

extern BOOL   gfDisablePreferredDeviceReordering;

/***************************************************************************
 *
 *  Define the product version to be returned from
 *  mmsystemgetversion and any other messagebox or
 *  API that needs the public product version.
 *
 ***************************************************************************/

#define MMSYSTEM_VERSION 0X030A



typedef UINT    MMMESSAGE;      // Multi media message type (internal)

#ifndef WM_MM_RESERVED_FIRST    // Copy constants from winuserp.h
#define WM_MM_RESERVED_FIRST            0x03A0
#define WM_MM_RESERVED_LAST             0x03DF
#endif
#define MM_POLYMSGBUFRDONE  (WM_MM_RESERVED_FIRST+0x2B)
#define MM_SND_PLAY         (WM_MM_RESERVED_FIRST+0x2C)
#define MM_SND_ABORT        (WM_MM_RESERVED_FIRST+0x2D)
#define MM_SND_SEND         (WM_MM_RESERVED_FIRST+0x2E)
#define MM_SND_WAIT         (WM_MM_RESERVED_FIRST+0x2F)
#define MCIWAITMSG          (MM_SND_WAIT)

#if MM_SND_WAIT > WM_MM_RESERVED_LAST
  #error "MM_SND_WAIT is defined beyond the reserved WM_MM range"
#endif

/***************************************************************************

    DEBUGGING SUPPORT

 ***************************************************************************/


#if DBG

    #ifdef DEBUGLEVELVAR
      // So that other WINMM related modules can use their own debug level
      // variable
      #define winmmDebugLevel DEBUGLEVELVAR
    #endif

    extern int winmmDebugLevel;
    extern void winmmDbgOut(LPSTR lpszFormat, ...);
    extern void dDbgAssert(LPSTR exp, LPSTR file, int line);

    DWORD __dwEval;

    extern void winmmDbgOut(LPSTR lpszFormat, ...);

    #define dprintf( _x_ )                            winmmDbgOut _x_
    #define dprintf1( _x_ ) if (winmmDebugLevel >= 1) winmmDbgOut _x_
    #define dprintf2( _x_ ) if (winmmDebugLevel >= 2) winmmDbgOut _x_
    #define dprintf3( _x_ ) if (winmmDebugLevel >= 3) winmmDbgOut _x_
    #define dprintf4( _x_ ) if (winmmDebugLevel >= 4) winmmDbgOut _x_
    #define dprintf5( _x_ ) if (winmmDebugLevel >= 5) winmmDbgOut _x_
    #define dprintf6( _x_ ) if (winmmDebugLevel >= 6) winmmDbgOut _x_

    #define WinAssert(exp) \
	((exp) ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__))

    #define WinEval(exp) \
	((__dwEval=(DWORD)(exp)),  \
	  __dwEval ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__), __dwEval)

    #define DOUT(x) (OutputDebugStringA x, 0)
//  #define DOUTX(x) (OutputDebugStringA x, 0)
//  #define ROUTS(x) (OutputDebugStringA(x), OutputDebugStringA("\r\n"), 0)
    #define ROUTSW(x) (OutputDebugStringW x, OutputDebugStringW(L"\r\n"), 0)
    #define ROUT(x) (OutputDebugStringA x, OutputDebugStringA("\r\n"), 0)
//  #define ROUTX(x) (OutputDebugStringA(x), 0)

#else

    #define dprintf(x)  ((void) 0)
    #define dprintf1(x) ((void) 0)
    #define dprintf2(x) ((void) 0)
    #define dprintf3(x) ((void) 0)
    #define dprintf4(x) ((void) 0)
    #define dprintf5(x) ((void) 0)
    #define dprintf6(x) ((void) 0)

    #define WinAssert(exp) ((void) 0)
    #define WinEval(exp) (exp)

    #define DOUT(x)     ((void) 0)
//  #define DOUTX(x)    ((void) 0)
//  #define ROUTS(x)    ((void) 0)
    #define ROUT(x)     ((void) 0)
//  #define ROUTX(x)    ((void) 0)

#endif



/***************************************************************************

    Resource IDs

***************************************************************************/

#define IDS_TASKSTUB           2000
#define STR_MCIUNKNOWN         2001  /* "Unknown error returned from MCI command" */
// #define STR_WAVEINPUT          2004
// #define STR_WAVEOUTPUT         2005
// #define STR_MIDIINPUT          2006
// #define STR_MIDIOUTPUT         2007
#define STR_MCISSERRTXT        2009
#define STR_MCISCERRTXT        2010
#define STR_MIDIMAPPER         2011
#define STR_DRIVERS            2012
#define STR_SYSTEMINI          2013
#define STR_BOOT               2014

/***************************************************************************

    Memory allocation using our local heap

***************************************************************************/
HANDLE hHeap;
PVOID winmmAlloc(DWORD cb);
PVOID winmmReAlloc(PVOID ptr, DWORD cb);
#define winmmFree(ptr) HeapFree(hHeap, 0, (ptr))
void Squirt(LPSTR lpszFormat, ...);

/***************************************************************************

    LOCKING AND UNLOCKING MEMORY

***************************************************************************/

#if 0
BOOL HugePageLock(LPVOID lpArea, DWORD dwLength);
void HugePageUnlock(LPVOID lpArea, DWORD dwLength);
#else
#define HugePageLock(lpArea, dwLength)      (TRUE)
#define HugePageUnlock(lpArea, dwLength)
#endif

/***************************************************************************

    Pnp Structures and related functions.

***************************************************************************/

void ClientUpdatePnpInfo();

//#ifdef DBG
#if 0
#define EnterNumDevs(a) Squirt("Allocating NumDevs CS [%s]", a); EnterCriticalSection(&NumDevsCritSec)
#define LeaveNumDevs(a) LeaveCriticalSection(&NumDevsCritSec); Squirt("Releasing NumDevs CS [%s]", a)
#else
#define EnterNumDevs(a) EnterCriticalSection(&NumDevsCritSec)
#define LeaveNumDevs(a) LeaveCriticalSection(&NumDevsCritSec)
#endif

BOOL wdmDevInterfaceInc(IN PCWSTR pstrDeviceInterface);
BOOL wdmDevInterfaceDec(IN PCWSTR pstrDeviceInterface);

/****************************************************************************

  API to install/remove/query a MMSYS driver

****************************************************************************/

/* generic prototype for audio device driver entry-point functions
// midMessage(), modMessage(), widMessage(), wodMessage(), auxMessage()
*/
typedef DWORD (APIENTRY *DRIVERMSGPROC)(DWORD, DWORD, DWORD_PTR, DWORD_PTR, DWORD_PTR);

/*
@doc    INTERNAL MMSYSTEM
@type   UINT | HMD |
	This type definition specifies a handle to media resource entry. This
	can be used as a unique identifier when specifying a media resource.
*/

DECLARE_HANDLE(HMD);

typedef struct _MMDRV* PMMDRV;
void mregAddDriver(IN PMMDRV pdrvZ, IN PMMDRV pdrv);
MMRESULT mregCreateStringIdFromDriverPort(IN PMMDRV pdrv, IN UINT port, OUT PWSTR* pStringId, OUT ULONG* pcbStringId);
MMRESULT mregGetIdFromStringId(IN PMMDRV pdrvZ, IN PCWSTR StringId, OUT UINT *puDeviceID);
BOOL FAR PASCAL mregHandleInternalMessages(IN PMMDRV pdrv, DWORD dwType, UINT Port, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2, MMRESULT * pmmr);
DWORD FAR PASCAL mregDriverInformation(UINT uDeviceID, WORD fwClass, UINT uMessage, DWORD dwParam1, DWORD dwParam2);
UINT FAR PASCAL mregIncUsage(HMD hmd);
UINT FAR PASCAL mregIncUsagePtr(IN PMMDRV pmd);
UINT FAR PASCAL mregDecUsage(HMD hmd);
UINT FAR PASCAL mregDecUsagePtr(IN PMMDRV pmd);
MMRESULT FAR PASCAL mregFindDevice(UINT uDeviceID, WORD fwFindDevice, HMD FAR* phmd, UINT FAR* puDevicePort);

/*****************************************************************************

  Driver stuff - This will change when we work out the real
  installable driver story on NT

 ****************************************************************************/
LRESULT DrvClose(HANDLE hDriver, LPARAM lParam1, LPARAM lParam2);
HANDLE  DrvOpen(LPCWSTR szDriverName, LPCWSTR szSectionName, LPARAM lParam2);
LRESULT DrvSendMessage(HANDLE hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);
//HMODULE APIENTRY DrvGetModuleHandle(HDRVR hDriver);
BOOL    DrvIsPreXp(IN HANDLE hDriver);

typedef DWORD (DRVPROC)(HANDLE hDriver, UINT msg, LONG lp1, LONG lp2);
typedef DRVPROC *LPDRVPROC;

//
// Init and Cleanup Joystick service, in joy.c
//

BOOL JoyInit(void);
void JoyCleanup(void);

/*
**  Special function for creating threads inside the server process (we only
**  use this to create the thread for playing sounds)
*/

BOOLEAN CreateServerPlayingThread(PVOID ThreadStartRoutine);

/*
// exclude some stuff if MMDDK.H is not included
*/
#ifdef MMDDKINC   /* use this to test for MMDDK.H */

    #define MMDRV_DESERTED  0x00000001
    #define MMDRV_MAPPER    0x00000002
    #define MMDRV_PREXP     0x00000004

    //
    // base drv instance list node struct
    //
    typedef struct _MMDRV *PMMDRV;
    typedef struct _MMDRV
    {
    PMMDRV              Next;
    PMMDRV              Prev;
    PMMDRV              NextStringIdDictNode;
    PMMDRV              PrevStringIdDictNode;
    HANDLE              hDriver;            /* handle to the module                  */
    WCHAR               wszMessage[20];     /* name of entry point                   */
    DRIVERMSGPROC       drvMessage;         /* pointer to entry point                */
    ULONG               NumDevs;            /* number of devices supported           */
    ULONG               Usage;              /* usage count (number of handle's open) */
    // ISSUE-2001/01/05-FrankYe Rename cookie to DeviceInterface
    PCWSTR              cookie;             /* PnP driver device interface           */
    DWORD               fdwDriver;          /* flags for driver                      */
    CRITICAL_SECTION    MixerCritSec;       /* Serialize use of mixer                */
    WCHAR               wszDrvEntry[64];    /* driver filename                       */
    WCHAR               wszSessProtocol[10];
                                            /* Session protocol name, empty
                                               if console driver               */
    } MMDRV, *PMMDRV;

    #ifndef MMNOMIDI


/****************************************************************************

   Preferred devices

****************************************************************************/
void     waveOutGetCurrentConsoleVoiceComId(PUINT pPrefId, PDWORD pdwFlags);
void     waveOutGetCurrentPreferredId(PUINT pPrefId, PDWORD pdwFlags);
MMRESULT waveOutSetPersistentConsoleVoiceComId(UINT PrefId, DWORD dwFlags);
MMRESULT waveOutSetPersistentPreferredId(UINT PrefId, DWORD dwFlags);

void     waveInGetCurrentConsoleVoiceComId(PUINT pPrefId, PDWORD pdwFlags);
void     waveInGetCurrentPreferredId(PUINT pPrefId, PDWORD pdwFlags);
MMRESULT waveInSetPersistentPreferredId(UINT PrefId, DWORD dwFlags);
MMRESULT waveInSetPersistentConsoleVoiceComId(UINT PrefId, DWORD dwFlags);

void     midiOutGetCurrentPreferredId(PUINT pPrefId, PDWORD dwFlags);
MMRESULT midiOutSetPersistentPreferredId(UINT PrefId, DWORD dwFlags);

void     InvalidatePreferredDevices(void);
void     RefreshPreferredDevices(void);

/****************************************************************************

    Clock routines used by MIDI. These routines provide clocks which run
    at the current tempo or SMPTE rate based on timeGetTime().

****************************************************************************/

    typedef DWORD   MILLISECS;
    typedef long        TICKS;

    #define CLK_CS_PAUSED   0x00000001L
    #define CLK_CS_RUNNING  0x00000002L

    #define CLK_TK_NOW      ((TICKS)-1L)

    //
    // This structure is allocated by the client (probably in a handle structure)
    // in MMSYSTEM's DS and passed as a near pointer.
    //

    typedef struct tag_clock *PCLOCK;

    typedef DWORD (FAR PASCAL *CLK_TIMEBASE)(PCLOCK);
    typedef struct tag_clock
    {
    MILLISECS       msPrev;
    TICKS           tkPrev;
    MILLISECS       msT0;
    DWORD           dwNum;
    DWORD           dwDenom;
    DWORD           dwState;
    CLK_TIMEBASE    fnTimebase;
    }   CLOCK;

    void FAR PASCAL      clockInit(PCLOCK pclock, MILLISECS msPrev, TICKS tkPrev, CLK_TIMEBASE fnTimebase);
    void FAR PASCAL      clockSetRate(PCLOCK pclock, TICKS tkWhen, DWORD dwNum, DWORD dwDenom);
    void FAR PASCAL      clockPause(PCLOCK pclock, TICKS tkWhen);
    void FAR PASCAL      clockRestart(PCLOCK pclock, TICKS tkWhen, MILLISECS msWhen);
    TICKS FAR PASCAL     clockTime(PCLOCK pclock);
    MILLISECS FAR PASCAL clockMsTime(PCLOCK pclock);
    MILLISECS FAR PASCAL clockOffsetTo(PCLOCK pclock, TICKS tkWhen);

/****************************************************************************

    Macros and prototypes shared by the MIDI subsystem.

****************************************************************************/

    // #pragma message() with file/line numbers!
    //
    #define __PRAGMSG(l,x,c) message(__FILE__"("#l") : "c": "x)
    #define _WARN(l,x) __PRAGMSG(l,x, "warning")
    #define WARNMSG(x) _WARN(__LINE__,x)

    #define _FIX(l,x) __PRAGMSG(l,x, "fix")
    #define FIXMSG(x) _FIX(__LINE__,x)

    #define DEFAULT_TEMPO   500000L         // 500,000 uSec/qn == 120 BPM
    #define DEFAULT_TIMEDIV 24              // 24 ticks per quarter note
    #define DEFAULT_CBTIMEOUT   100         // 100 milliseconds

    #define PM_STATE_READY      0           // polymsg ready to play
    #define PM_STATE_BLOCKED    1           // Blocked on outgoing SysEx
    #define PM_STATE_EMPTY          2           // No polymsg queued
    #define PM_STATE_STOPPED    3           // Just opened/reset/stopped
									   // No polymsg sent yet.
    #define PM_STATE_PAUSED     4           // Paused at some position

    #define MIN_PERIOD          1           // millisecs of timer resolution

    //
    // Macros for dealing with time division dword
    //
    #define IS_SMPTE 0x00008000L
    #define METER_NUM(dw) (UINT)((HIWORD(dw)>>8)&0x00FF)
    #define METER_DENOM(dw) (UINT)(HIWORD(dw)&0x00FF)
    #define TICKS_PER_QN(dw) (UINT)((dw)&0x7FFF)
    #define SMPTE_FORMAT(dw) (((int)((dw)&0xFF00))>>8)
    #define TICKS_PER_FRAME(dw) (UINT)((dw)&0x00FF)

    //
    // Constants for 30-Drop format conversion
    //
    #define S30D_FRAMES_PER_10MIN       17982
    #define S30D_FRAMES_PER_MIN         1798

    //
    // SMPTE formats from MIDI file time division
    //
    #define SMPTE_24                    24
    #define SMPTE_25                    25
    #define SMPTE_30DROP                29
    #define SMPTE_30                    30

    //
    // Stuff that's part of MIDI spec
    //
    #define MIDI_NOTEOFF        (BYTE)(0x80)
    #define MIDI_NOTEON         (BYTE)(0x90)
    #define MIDI_CONTROLCHANGE  (BYTE)(0xB0)
    #define MIDI_SYSEX          (BYTE)(0xF0)
    #define MIDI_TIMING_CLK     (BYTE)(0xF8)

    #define MIDI_SUSTAIN        (BYTE)(0x40)    // w/ MIDI_CONTROLCHANGE

    //
    // Indices into dwReserved[] fields of struct
    //
    // 0,1,2 -- MMSYSTEM (core, emulator)
    // 3,4,5 -- MIDI mapper
    // 6,7   -- DDK (3rd party drivers)
    #define MH_REFCNT           0       // MMSYSTEM core (stream header only)
    #define MH_PARENT           0       // MMSYSTEM core (shadow header only)
    #define MH_STREAM           0       // Emulator (long msg header only)
    #define MH_SHADOW           1       // MMSYSTEM core (stream header only)
    #define MH_BUFIDX           1       // Emulator (shadow header only)
    #define MH_STRMPME          2       // Emulator (shadow header, long msg header)

/*****************************************************************************
 *
 * @doc INTERNAL MIDI
 *
 * @types MIDIDRV | This structure contains all of the information about an
 *  open <t HMIDIIN> or <t HMIDIOUT> handle.
 *
 * @field HMD | hmd |
 *  Handle to media device for this driver.
 *
 * @field UINT | uDevice |
 *  Index of this device off of HMD (subunit number relative to this driver).
 *
 * @field DRIVERMSGPROC | drvMessage |
 *  Pointer to the associated driver entry point.
 *
 * @field DWORD | dwDrvUser |
 *  Driver user DWORD; used by driver to differentiate open instance. Set
 *  by driver on OPEN message; passed back to driver on every call.
 *
 * @field PMIDIDRV | pdevNext |
 *  Specifies the next handle in the linked list of open handles.
 *  (Only kept for <t HMIDIOUT> handles.
 *
 * @field UINT | uLockCount |
 *  Semaphore to serialize access to the handle structure between API calls
 *  and interrupt callbacks.
 *
 * @field DWORD | dwTimeDiv |
 *  The time division setting that is active right now during polymsg playback
 *  on this handle. The format is the same as described for
 *  <f midiOutSetTimeDivision>.
 *
 * @field DWORD | dwTempo |
 *  Current tempo for polymsg out in microseconds per quarter note (as in the
 *  Standard MIDI File specification).
 *
 * @field DWORD | dwPolyMsgState |
 *  The current state of polymsg playback for emulation.
 *  @flag PM_STATE_READY | Events may be played and are waiting.
 *  @flag PM_STATE_BLOCKED | Driver is busy sending SysEx; don't play anything
 *   else.
 *  @flag PM_STATE_EMPTY | Not busy but nothing else in the queue to play.
 *  @flag PM_STATE_PAUSED | Device has been paused with <f midiOutPause>.
 *
 * @field DWORD | dwSavedState |
 *  If the device is paused, this field will contain the state to be
 *  restored when restart occurs.
 *
 * @field LPMIDIHDR | lpmhFront |
 *  Front of queue of MIDIHDR's waiting to be played via polymsg in/out. The
 *  header pointed to by this field is the header currently being played/
 *  recorded.
 *
 * @field LPMIDIHDR | lpmhRear |
 *  End of MIDIHDR queue. Buffers are inserted from the app here.
 *
 * @field DWORD | dwCallback |
 *  Address of user callback.
 *
 * @field DWORD | dwFlags |
 *  User-supplied callback flags.
 *
 * @field BOOL | fEmulate |
 *  TRUE if we are emulating polymsg in/out.
 *
 * @field BOOL | fReset |
 *  TRUE if we're in the middle of a MIDM_RESET. Checked to see if we should
 *  give our shadow buffers back to the driver or retain them for cleanup.
 *
 * @field BOOL | fStarted |
 *  TRUE if MIDI input has been started.
 *
 * @field UINT | uCBTimeout |
 *  Time in milliseconds that a buffer can be help in MIDI input w/o being
 *  called back.
 *
 * @field UINT | uCBTimer |
 *  Timer ID of the timer which is being used to determine if a MIDI
 *  input buffer has been queued for too long.
 *
 * @field DWORD | dwInputBuffers |
 *  The maximum number of input buffers that have been prepared on this handle.
 *  Used for calculating shadow buffer pool.
 *
 * @field DWORD | cbInputBuffers |
 *  The maximum size of input buffer which has been prepared on this handle.
 *  Used for calculating shadow buffer pool.
 *
 * @field DWORD | dwShadowBuffers |
 *  The current number of shadow buffers allocated on this handle.
 *
 * @field CLOCK | clock |
 *  Clock maintained by the clock API's for timebase of both output and
 *  input emulation.
 *
 * @field DWORD | tkNextEventDue | Tick time of the next event due
 *  on polymsg emulation.
 *
 * @field TICKS | tkTimeOfLastEvent | Tick time that emulator sent the
 *  last event.
 *
 * @field DWORD | tkPlayed | Total ticks played on stream.
 *
 * @field DWORD | tkTime | Tick position in stream now.
 *
 * @field DWORD | dwTimebase | Flag indicating where timebase is coming
 *  from. May be one of:
 *  @flag MIDI_TBF_INTERNAL | Timebase is <f timeGetTime>
 *  @flag MIDI_TBF_MIDICLK | Timebase is MIDI input clocks.
 *
 * @field BYTE | rbNoteOn[] | Array of note-on counts per-channel per-note.
 *  Only allocated for output handles which are doing COOKED mode emulation.
 *
 *****************************************************************************/

    #define ELESIZE(t,e) (sizeof(((t*)NULL)->e))

    //#define MDV_F_EXPANDSTATUS      0x00000001L
    #define MDV_F_EMULATE           0x00000002L
    #define MDV_F_RESET             0x00000004L
    #define MDV_F_STARTED           0x00000008L
    #define MDV_F_ZOMBIE            0x00000010L
    #define MDV_F_SENDING           0x00000020L
    #define MDV_F_OWNED             0x00000040L
    #define MDV_F_LOCKED            0x00000080L

    #define MEM_MAX_LATENESS        64


    typedef MMDRV MIDIDRV, *PMIDIDRV;

    typedef struct midistrm_tag *PMIDISTRM;
    typedef struct mididev_tag *PMIDIDEV;
    typedef struct midiemu_tag *PMIDIEMU;

    typedef struct mididev_tag {
    PMIDIDRV    mididrv;
    UINT        wDevice;
    DWORD_PTR   dwDrvUser;
    UINT        uDeviceID;
    DWORD       fdwHandle;
    PMIDIDEV    pmThru;            /* pointer to midi thru device           */
    PMIDIEMU    pme;               /* Iff owned by emulator                 */
    } MIDIDEV;
    typedef MIDIDEV *PMIDIDEV;

    extern MIDIDRV midioutdrvZ;                     /* output device driver list */
    extern MIDIDRV midiindrvZ;                      /* input device driver list  */
    extern UINT    wTotalMidiOutDevs;               /* total midi output devices */
    extern UINT    wTotalMidiInDevs;                /* total midi input devices  */

    typedef struct midiemusid_tag {
    DWORD       dwStreamID;
    HMIDI       hMidi;
    } MIDIEMUSID, *PMIDIEMUSID;

    typedef struct midiemu_tag {
    PMIDIEMU                pNext;
    HMIDISTRM               hStream;
    DWORD                   fdwDev;
    LONG                    lLockCount;         // Must be 32-bit aligned
    CRITICAL_SECTION        CritSec;            // Serialize access
    DWORD                   dwSignature;        // Cookie to keep track of validity
    DWORD                   dwTimeDiv;          // Time division in use right now
    DWORD                   dwTempo;            // Current tempo
    DWORD                   dwPolyMsgState;     // Ready or blocked on SysEx
    DWORD                   dwSavedState;       // State saved when paused
    LPMIDIHDR               lpmhFront ;         // Front of PolyMsg queue
    LPMIDIHDR               lpmhRear ;          // Rear of PolyMsg queue
    DWORD_PTR               dwCallback;         // User callback
    DWORD                   dwFlags;            // User callback flags
    DWORD_PTR               dwInstance;
    DWORD                   dwSupport;          // From MODM_GETDEVCAPS
    BYTE                    bRunningStatus;     // Track running status

	//
	// Rewrite midiOutPolyMsg timekeeping - new stuff!!!
	//
    CLOCK       clock;

    TICKS       tkNextEventDue;     // Tick time of next event
    TICKS       tkTimeOfLastEvent;  // Tick time of last received event
    TICKS       tkPlayed;           // Cumulative ticks played so far
    TICKS       tkTime;             // Tick position in stream *NOW*

    LPBYTE      rbNoteOn;           // Count of notes on per channel per note

    UINT        cSentLongMsgs;      // Oustanding long messages

    UINT        chMidi;             // # Stream ID's

    UINT        cPostedBuffers;     // Posted to mmtask for cleanup

    #ifdef DEBUG
    DWORD       cEvents;
    UINT        auLateness[MEM_MAX_LATENESS];
								   // 0..64 milliseconds late
    #endif

    MIDIEMUSID  rIds[];             // HMIDI's indexed by stream ID
    } MIDIEMU;

    #define MSI_F_EMULATOR                      0x00000001L
    #define MSI_F_FIRST                         0x00000002L
    #define MSI_F_OPENED                        0x00000004L
    #define MSI_F_INITIALIZEDCRITICALSECTION	0x00000008L

    #define MSE_SIGNATURE       0x12341234L

    typedef struct midistrmid_tag {
    HMD hmd;
    UINT uDevice;
    DRIVERMSGPROC drvMessage;
    DWORD_PTR dwDrvUser;
    DWORD fdwId;
    CRITICAL_SECTION CritSec;
    } MIDISTRMID, *PMIDISTRMID;

    #define MDS_F_STOPPING      0x00000001L

    typedef struct midistrm_tag {
    DWORD       fdwOpen;
    DWORD       fdwStrm;
    DWORD_PTR   dwCallback;
    DWORD_PTR   dwInstance;
    DWORD       cDrvrs;             // # unique drivers in rgIds[]
    DWORD       cIds;
    MIDISTRMID  rgIds[];
    } MIDISTRM;


/*****************************************************************************
 *
 * @doc INTERNAL MIDI
 *
 * @types MIDIHDREXT |
 *  This structure is allocated by <f midiOutPolyMsg> and is pointed to by the
 *  <t reserved> field of the associated <t MIDIHDR>. It contains information
 *  about what embedded long messages are in the polymsg buffer described
 *  by the MIDIHDR.
 *
 *  The <t MIDIHDREXT> is followed by multiple <t MIDIDHR> structures, also
 *  allocated by <f midiOutPolyMsg>, which describe each of the embedded
 *  long messages which need to be played.
 *
 * @field DWORD | dwTimeDivision |
 *  The time division specified with <f midiOutPolyMsg> to play this buffer
 *  with.
 *
 * @field UINT | nHeaders |
 *  The number of <t MIDIHDR> structures which follow the end of this
 *  <MIDIHDREXT>.
 *
 * @field LPMIDIHDR | lpmidihdr |
 *  Pointer to the next <t MIDIHDR> structure due to be played.
 *
 *
 *****************************************************************************/
    typedef struct midihdrext_tag {
    UINT        nHeaders ;
    LPMIDIHDR   lpmidihdr ;
    } MIDIHDREXT, FAR *LPMIDIHDREXT ;

	extern HANDLE g_hClosepme;

    /*
     * Internal prototypes for MIDI
     */
    extern MMRESULT midiReferenceDriverById(
        IN PMIDIDRV pwavedrvZ,
        IN UINT id,
        OUT PMIDIDRV *ppwavedrv OPTIONAL,
        OUT UINT *pport OPTIONAL
    );

    extern BOOL FAR PASCAL midiLockPageable(void);
    extern void NEAR PASCAL midiUnlockPageable(void);
    extern MMRESULT NEAR PASCAL midiPrepareHeader(LPMIDIHDR lpMidiHdr, UINT wSize);
    extern MMRESULT NEAR PASCAL midiUnprepareHeader(LPMIDIHDR lpMidiHdr, UINT wSize);
    extern STATIC MMRESULT midiMessage(HMIDI hMidi, UINT msg, DWORD_PTR dwP1, DWORD_PTR dwP2);
    extern DWORD FAR PASCAL midiStreamMessage(PMIDISTRMID pmsi, UINT msg, DWORD_PTR dwP1, DWORD_PTR dwP2);
    extern DWORD FAR PASCAL midiStreamBroadcast(PMIDISTRM pms, UINT msg, DWORD_PTR dwP1, DWORD_PTR dwP2);
    extern STATIC MMRESULT midiIDMessage(PMIDIDRV pmididrvZ, UINT wTotalNumDevs, UINT_PTR uDeviceID, UINT wMessage, DWORD_PTR dwParam1, DWORD_PTR dwParam2);
    extern MMRESULT NEAR PASCAL midiGetPosition(PMIDISTRM pms, LPMMTIME pmmt, UINT cbmmt);
    extern MMRESULT NEAR PASCAL midiGetErrorText(MMRESULT wError, LPSTR lpText, UINT wSize);


    extern MMRESULT WINAPI midiOutGetID(HMIDIOUT hMidiOut, UINT FAR* lpuDeviceID);
    extern MMRESULT FAR PASCAL mseOutSend(PMIDIEMU pme, LPMIDIHDR lpMidiHdr, UINT cbMidiHdr);
    extern void FAR PASCAL midiOutSetClockRate(PMIDIEMU pme, TICKS tkWhen);
    extern BOOL NEAR PASCAL midiOutScheduleNextEvent(PMIDIEMU pme);
    #ifdef DEBUG
    extern void NEAR PASCAL midiOutPlayNextPolyEvent(PMIDIEMU pme, DWORD dwStartTime);
    #else
    extern void NEAR PASCAL midiOutPlayNextPolyEvent(PMIDIEMU pme);
    #endif

    extern void NEAR PASCAL midiOutDequeueAndCallback(PMIDIEMU pme);
    extern void FAR PASCAL midiOutNukePMBuffer(PMIDIEMU pme, LPMIDIHDR lpmh);
    extern void CALLBACK midiOutTimerTick(UINT uTimerID, UINT wMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2);
    extern void CALLBACK midiOutCallback(HMIDIOUT hMidiOut, WORD wMsg, DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2);
    extern void NEAR PASCAL midiOutAllNotesOff(PMIDIEMU pme);

    extern void CALLBACK midiOutStreamCallback(HMIDISTRM hMidiOut, WORD wMsg, DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

    extern MMRESULT midiInSetThru (HMIDI hmi, HMIDIOUT hmo, BOOL bAdd);

    // mseXXX - MIDI Stream Emulator
    //
    extern DWORD FAR PASCAL mseMessage(UINT msg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2);


    #endif /* ifndef MMNOMIDI */

    #ifndef MMNOWAVE

    typedef MMDRV WAVEDRV, *PWAVEDRV;

    extern WAVEDRV waveoutdrvZ;                     /* output device driver list */
    extern WAVEDRV waveindrvZ;                      /* input device driver list  */
    extern UINT    wTotalWaveOutDevs;               /* total wave output devices */
    extern UINT    wTotalWaveInDevs;                /* total wave input devices  */

    extern MMRESULT waveReferenceDriverById(
        IN PWAVEDRV pwavedrvZ,
        IN UINT id,
        OUT PWAVEDRV *ppwavedrv OPTIONAL,
        OUT UINT *pport OPTIONAL
    );

    #endif /*ifndef MMNOWAVE */

    #ifndef MMNOMIXER

    typedef MMDRV MIXERDRV, *PMIXERDRV;

    extern MIXERDRV mixerdrvZ;                      /* mixer device driver list */
    extern UINT     guTotalMixerDevs;               /* total mixer devices */

    MMRESULT mixerReferenceDriverById(
        IN UINT id,
        OUT PMIXERDRV *ppdrv OPTIONAL,
        OUT UINT *pport OPTIONAL
    );

    #endif /*ifndef MMNOMIXER */

    #ifndef MMNOAUX

    typedef MMDRV AUXDRV, *PAUXDRV;

    extern AUXDRV auxdrvZ;                         /* auxiliary device driver list   */
    extern UINT   wTotalAuxDevs;                   /* total auxiliary output devices */

    MMRESULT auxReferenceDriverById(
        IN UINT id,
        OUT PAUXDRV *ppauxdrv OPTIONAL,
        OUT UINT *pport OPTIONAL
    );

    #endif /* ifndef MMNOAUX */

    #ifdef DEBUG_RETAIL
    extern BYTE    fIdReverse;
    #endif /* ifdef DEBUG_RETAIL */

#endif //ifdef MMDDKINC

/****************************************************************************

    handle apis's

****************************************************************************/

/*
// all MMSYSTEM handles are tagged with the following structure.
//
// a MMSYSTEM handle is really a fixed local memory object.
//
// the functions NewHandle() and FreeHandle() create and release a MMSYSTEM
// handle.
//
*/
typedef struct tagHNDL {
    struct  tagHNDL *pNext; // link to next handle
    UINT    uType;          // type of handle wave, midi, mmio, ...
    DWORD   fdwHandle;      // Particulars about this handle, Deserted? Busy?
    HANDLE  hThread;        // task that owns it
    UINT    h16;            // Corresponding WOW handle
    PCWSTR  cookie;         // Device interface name for driver handles
    CRITICAL_SECTION CritSec; // Serialize access
} HNDL, *PHNDL;
/*************************************************************************/

#define MMHANDLE_DESERTED   MMDRV_DESERTED
#define MMHANDLE_BUSY       0x00000002

#define HtoPH(h)        ((PHNDL)(h)-1)
#define PHtoH(ph)       ((ph) ? (HANDLE)((PHNDL)(ph)+1) : 0)
#define HtoPT(t,h)      ((t)(h))
#define PTtoH(t,pt)     ((t)(pt))


//
// Handles can be tested for ownership and reserved at the same time
//

#define ENTER_MM_HANDLE(h) (EnterCriticalSection(&HtoPH(h)->CritSec))
#define LEAVE_MM_HANDLE(h) ((void)LeaveCriticalSection(&HtoPH(h)->CritSec))

/*
// all wave and midi handles will be linked into
// a global list, so we can enumerate them latter if needed.
//
// all handle structures start with a HNDL structure, that contain common fields
//
// pHandleList points to the first handle in the list
//
// HandleListCritSec protects the handle list
//
// the NewHandle() and FreeHandle() functions are used to add/remove
// a handle to/from the list
*/

PHNDL pHandleList;
CRITICAL_SECTION HandleListCritSec;

extern HANDLE NewHandle(UINT uType, PCWSTR cookie, UINT size);
extern void   ReleaseHandleListResource();
extern void   AcquireHandleListResourceShared();
extern void   AcquireHandleListResourceExclusive();
extern void   FreeHandle(HANDLE h);
extern void   InvalidateHandle(HANDLE h);

#define GetHandleType(h)        (HtoPH(h)->uType)
#define GetHandleOwner(h)       (HtoPH(h)->hThread)
#define GetHandleFirst()        (PHtoH(pHandleList))
#define GetHandleNext(h)        (PHtoH(HtoPH(h)->pNext))
#define SetHandleOwner(h,hOwn)  (HtoPH(h)->hThread = (hOwn))
#define SetHandleFlag(h,f)      (HtoPH(h)->fdwHandle |= (f))
#define ClearHandleFlag(h,f)    (HtoPH(h)->fdwHandle &= (~(f)))
#define CheckHandleFlag(h,f)    (HtoPH(h)->fdwHandle & (f))
#define IsHandleDeserted(h)     (0 != CheckHandleFlag((h), MMHANDLE_DESERTED))
#define IsHandleBusy(h)         (0 != CheckHandleFlag((h), MMHANDLE_BUSY))

#define GetWOWHandle(h)         (HtoPH(h)->h16)
#define SetWOWHandle(h, myh16)  (HtoPH(h)->h16 = (myh16))

/**************************************************************************

    Test whether the current process is the WOW process.  This
    is not a very nice test to have to make but it's the best we
    can think of until the WOW people come up with a proper call

 **************************************************************************/

#define IS_WOW_PROCESS (NULL != GetModuleHandleW(L"WOW32.DLL"))


/****************************************************************************

    user debug support

****************************************************************************/

#define DebugErr(x,y)
#define DebugErr1(flags, sz, a)

#ifdef DEBUG_RETAIL

#define MM_GET_DEBUG        DRV_USER
#define MM_GET_DEBUGOUT     DRV_USER+1
#define MM_SET_DEBUGOUT     DRV_USER+2
#define MM_GET_MCI_DEBUG    DRV_USER+3
#define MM_SET_MCI_DEBUG    DRV_USER+4
#define MM_GET_MM_DEBUG     DRV_USER+5
#define MM_SET_MM_DEBUG     DRV_USER+6

#define MM_HINFO_NEXT       DRV_USER+10
#define MM_HINFO_TASK       DRV_USER+11
#define MM_HINFO_TYPE       DRV_USER+12
#define MM_HINFO_MCI        DRV_USER+20

#define MM_DRV_RESTART      DRV_USER+30

/*
// these validation routines can be found in DEBUG.C
*/
// The kernel validation is turned OFF because it appeared to test every page
// before use and this took over a minute for soundrec with a 10MB buffer
//
//#define USE_KERNEL_VALIDATION
#ifdef USE_KERNEL_VALIDATION

#define  ValidateReadPointer(p, len)     (!IsBadReadPtr(p, len))
#define  ValidateWritePointer(p, len)    (!IsBadWritePtr(p, len))
#define  ValidateString(lsz, max_len)    (!IsBadStringPtrA(lsz, max_len))
#define  ValidateStringW(lsz, max_len)   (!IsBadStringPtrW(lsz, max_len))

#else

BOOL  ValidateReadPointer(LPVOID p, DWORD len);
BOOL  ValidateWritePointer(LPVOID p, DWORD len);
BOOL  ValidateString(LPCSTR lsz, DWORD max_len);
BOOL  ValidateStringW(LPCWSTR lsz, DWORD max_len);

#endif // USE_KERNEL_VALIDATION

BOOL  ValidateHandle(HANDLE h, UINT uType);
BOOL  ValidateHeader(LPVOID p, UINT uSize, UINT uType);
BOOL  ValidateCallbackType(DWORD_PTR dwCallback, UINT uType);

/********************************************************************
* When time permits we should change to using the Kernel supplied and
* supported validation routines:
*
* BOOL  WINAPI IsBadReadPtr(CONST VOID *lp, UINT ucb );
* BOOL  WINAPI IsBadWritePtr(LPVOID lp, UINT ucb );
* BOOL  WINAPI IsBadHugeReadPtr(CONST VOID *lp, UINT ucb);
* BOOL  WINAPI IsBadHugeWritePtr(LPVOID lp, UINT ucb);
* BOOL  WINAPI IsBadCodePtr(FARPROC lpfn);
* BOOL  WINAPI IsBadStringPtrA(LPCSTR lpsz, UINT ucchMax);
* BOOL  WINAPI IsBadStringPtrW(LPCWSTR lpsz, UINT ucchMax);
*
* These routines can be found in * \nt\private\WINDOWS\BASE\CLIENT\PROCESS.C
*
********************************************************************/

#define V_HANDLE(h, t, r)       { if (!ValidateHandle(h, t)) return (r); }
#define V_HANDLE_ACQ(h, t, r)   { AcquireHandleListResourceShared(); if (!ValidateHandle(h, t)) { ReleaseHandleListResource(); return (r);} }
#define BAD_HANDLE(h, t)            ( !(ValidateHandle((h), (t))) )
#define V_HEADER(p, w, t, r)    { if (!ValidateHeader((p), (w), (t))) return (r); }
#define V_RPOINTER(p, l, r)     { if (!ValidateReadPointer((PVOID)(p), (l))) return (r); }
#define V_RPOINTER0(p, l, r)    { if ((p) && !ValidateReadPointer((PVOID)(p), (l))) return (r); }
#define V_WPOINTER(p, l, r)     { if (!ValidateWritePointer((PVOID)(p), (l))) return (r); }
#define V_WPOINTER0(p, l, r)    { if ((p) && !ValidateWritePointer((PVOID)(p), (l))) return (r); }
#define V_DCALLBACK(d, w, r)    { if ((d) && !ValidateCallbackType((d), (w))) return(r); }
//#define V_DCALLBACK(d, w, r)    0
#define V_TCALLBACK(d, r)       0
#define V_CALLBACK(f, r)        { if (IsBadCodePtr((f))) return (r); }
#define V_CALLBACK0(f, r)       { if ((f) && IsBadCodePtr((f))) return (r); }
#define V_STRING(s, l, r)       { if (!ValidateString(s,l)) return (r); }
#define V_STRING_W(s, l, r)       { if (!ValidateStringW(s,l)) return (r); }
#define V_FLAGS(t, b, f, r)     { if ((t) & ~(b)) { return (r); }}
#define V_DFLAGS(t, b, f, r)    { if ((t) & ~(b)) {/* LogParamError(ERR_BAD_DFLAGS, (FARPROC)(f), (LPVOID)(DWORD)(t));*/ return (r); }}
#define V_MMSYSERR(e, f, t, r)  { /* LogParamError(e, (FARPROC)(f), (LPVOID)(DWORD)(t));*/ return (r); }

#else /*ifdef DEBUG_RETAIL */

#define V_HANDLE(h, t, r)       { if (!(h)) return (r); }
#define V_HANDLE_ACQ(h, t, r)   { AcquireHandleListResourceShared(); if (!ValidateHandle(h, t)) { ReleaseHandleListResource(); return (r);} }
#define BAD_HANDLE(h, t)            ( !(ValidateHandle((h), (t))) )
#define V_HEADER(p, w, t, r)    { if (!(p)) return (r); }
#define V_RPOINTER(p, l, r)     { if (!(p)) return (r); }
#define V_RPOINTER0(p, l, r)    0
#define V_WPOINTER(p, l, r)     { if (!(p)) return (r); }
#define V_WPOINTER0(p, l, r)    0
#define V_DCALLBACK(d, w, r)    { if ((d) && !ValidateCallbackType((d), (w))) return(r); }
//#define V_DCALLBACK(d, w, r)    0
#define V_TCALLBACK(d, r)       0
#define V_CALLBACK(f, r)        { if (IsBadCodePtr((f))) return (r); }
#define V_CALLBACK0(f, r)       { if ((f) && IsBadCodePtr((f))) return (r); }
//#define V_CALLBACK(f, r)        { if (!(f)) return (r); }
#define V_CALLBACK0(f, r)       0
#define V_STRING(s, l, r)       { if (!(s)) return (r); }
#define V_STRING_W(s, l, r)     { if (!(s)) return (r); }
#define V_FLAGS(t, b, f, r)     0
#define V_DFLAGS(t, b, f, r)    { if ((t) & ~(b)) return (r); }
#define V_MMSYSERR(e, f, t, r)  { return (r); }

#endif /* ifdef DEBUG_RETAIL */

 /**************************************************************************
//
//**************************************************************************/
#define TYPE_UNKNOWN            0
#define TYPE_WAVEOUT            1
#define TYPE_WAVEIN             2
#define TYPE_MIDIOUT            3
#define TYPE_MIDIIN             4
#define TYPE_MMIO               5
#define TYPE_MCI                6
#define TYPE_DRVR               7
#define TYPE_MIXER              8
#define TYPE_MIDISTRM           9
#define TYPE_AUX               10



/**************************************************************************/


/****************************************************************************

    RIFF constants used to access wave files

****************************************************************************/

#define FOURCC_FMT  mmioFOURCC('f', 'm', 't', ' ')
#define FOURCC_DATA mmioFOURCC('d', 'a', 't', 'a')
#define FOURCC_WAVE mmioFOURCC('W', 'A', 'V', 'E')


extern HWND hwndNotify;

void FAR PASCAL WaveOutNotify(DWORD wParam, LONG lParam);    // in PLAYWAV.C

/*
// Things not in Win32
*/

#define GetCurrentTask() ((HANDLE)(DWORD_PTR)GetCurrentThreadId())

/*
// other stuff
*/

	 // Maximum length, including the terminating NULL, of an Scheme entry.
	 //
#define SCH_TYPE_MAX_LENGTH 64

	 // Maximum length, including the terminating NULL, of an Event entry.
	 //
#define EVT_TYPE_MAX_LENGTH 32

	 // Maximum length, including the terminating NULL, of an App entry.
	 //
#define APP_TYPE_MAX_LENGTH 64

	 // Sound event names can be a fully qualified filepath with a NULL
	 // terminator.
	 //
#define MAX_SOUND_NAME_CHARS    144

	 //  sound atom names are composed of:
	 //     <1 char id>
	 //     <reg key name>
	 //     <1 char sep>
	 //     <filepath>
	 //
#define MAX_SOUND_ATOM_CHARS    (1 + 40 + 1 + MAX_SOUND_NAME_CHARS)

#if 0
#undef hmemcpy
#define hmemcpy CopyMemory
#endif

//
// for terminal server defination and security
//
extern BOOL   WinmmRunningInSession;
extern WCHAR  SessionProtocolName[];
extern BOOL   gfLogon;

BOOL IsWinlogon(void);
BOOL WTSCurrentSessionIsDisconnected(void);

//  Keep winmm loaded
extern BOOL LoadWINMM();

#endif /* WINMMI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\ddtex.c ===
/******************************Module*Header*******************************\
* Module Name: ddtex.c
*
* wgl DirectDraw texture support
*
* Created: 02-10-1997
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1993-1997 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "gencx.h"

// Simple surface description for supported texture formats

#define DDTF_BGRA               0
#define DDTF_BGR                1
#define DDTF_PALETTED           2

typedef struct _DDTEXFORMAT
{
    int iFormat;
    int cColorBits;
} DDTEXFORMAT;

// Supported formats
static DDTEXFORMAT ddtfFormats[] =
{
    DDTF_BGRA, 32,
    DDTF_BGR, 32,
    DDTF_PALETTED, 8
};
#define NDDTF (sizeof(ddtfFormats)/sizeof(ddtfFormats[0]))

/******************************Public*Routine******************************\
*
* DescribeDdtf
*
* Fill out a DDSURFACEDESC from a DDTEXFORMAT
*
* History:
*  Tue Sep 03 18:16:50 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void DescribeDdtf(DDTEXFORMAT *pddtf, DDSURFACEDESC *pddsd)
{
    memset(pddsd, 0, sizeof(*pddsd));
    pddsd->dwSize = sizeof(*pddsd);
    pddsd->dwFlags = DDSD_CAPS | DDSD_PIXELFORMAT;
    pddsd->ddsCaps.dwCaps = DDSCAPS_MIPMAP | DDSCAPS_TEXTURE;
    pddsd->ddpfPixelFormat.dwFlags = DDPF_RGB;
    pddsd->ddpfPixelFormat.dwRGBBitCount = pddtf->cColorBits;
    switch(pddtf->iFormat)
    {
    case DDTF_BGRA:
        pddsd->dwFlags |= DDSD_ALPHABITDEPTH;
        pddsd->dwAlphaBitDepth = pddtf->cColorBits/4;
        pddsd->ddsCaps.dwCaps |= DDSCAPS_ALPHA;
        pddsd->ddpfPixelFormat.dwFlags |= DDPF_ALPHAPIXELS;
        // Fall through
    case DDTF_BGR:
        switch(pddtf->cColorBits)
        {
        case 32:
            pddsd->ddpfPixelFormat.dwRBitMask = 0xff0000;
            pddsd->ddpfPixelFormat.dwGBitMask = 0xff00;
            pddsd->ddpfPixelFormat.dwBBitMask = 0xff;
            if (pddtf->iFormat == DDTF_BGRA)
            {
                pddsd->ddpfPixelFormat.dwRGBAlphaBitMask = 0xff000000;
            }
            break;
        }
        break;
    case DDTF_PALETTED:
        switch(pddtf->cColorBits)
        {
        case 1:
            pddsd->ddpfPixelFormat.dwFlags |= DDPF_PALETTEINDEXED1;
            break;
        case 2:
            pddsd->ddpfPixelFormat.dwFlags |= DDPF_PALETTEINDEXED2;
            break;
        case 4:
            pddsd->ddpfPixelFormat.dwFlags |= DDPF_PALETTEINDEXED4;
            break;
        case 8:
            pddsd->ddpfPixelFormat.dwFlags |= DDPF_PALETTEINDEXED8;
            break;
        }
        break;
    }
}

/******************************Public*Routine******************************\
*
* CacheTextureFormats
*
* Creates list of valid texture formats for a context
*
* History:
*  Fri Sep 27 16:14:29 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL CacheTextureFormats(PLRC plrc)
{
    int i;
    int nFmts;
    int nMcdFmts;
    DDTEXFORMAT *pddtf;
    DDSURFACEDESC *pddsdAlloc, *pddsd;
    __GLGENcontext *gengc;

    ASSERTOPENGL(plrc->pddsdTexFormats == NULL,
                 "CacheTextureFormats overwriting cache\n");

    if (plrc->dhrc != 0)
    {
        // Call the ICD
        if (plrc->pGLDriver->pfnDrvEnumTextureFormats == NULL)
        {
            nFmts = 0;
        }
        else
        {
            nFmts = plrc->pGLDriver->pfnDrvEnumTextureFormats(0, NULL);
            if (nFmts < 0)
            {
                return FALSE;
            }
        }
    }
    else
    {
        gengc = (__GLGENcontext *)GLTEB_SRVCONTEXT();
        ASSERTOPENGL(gengc != NULL, "No server context\n");

        nFmts = NDDTF;
        nMcdFmts = 0;

#if MCD_VER_MAJOR >= 2 || (MCD_VER_MAJOR == 1 && MCD_VER_MINOR >= 0x10)
        if (gengc->pMcdState != NULL &&
            McdDriverInfo.mcdDriver.pMCDrvGetTextureFormats != NULL)
        {
            nMcdFmts = GenMcdGetTextureFormats(gengc, 0, NULL);
            if (nMcdFmts < 0)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
            
            nFmts += nMcdFmts;
        }
#endif // 1.1
    }
        
    pddsdAlloc = (DDSURFACEDESC *)ALLOC(sizeof(DDSURFACEDESC)*nFmts);
    if (pddsdAlloc == NULL)
    {
        return FALSE;
    }

    if (plrc->dhrc != 0)
    {
        if (nFmts > 0)
        {
            nFmts = plrc->pGLDriver->pfnDrvEnumTextureFormats(nFmts,
                                                              pddsdAlloc);
            if (nFmts < 0)
            {
                FREE(pddsdAlloc);
                return FALSE;
            }
        }
    }
    else
    {
        pddsd = pddsdAlloc;
        pddtf = ddtfFormats;
        for (i = 0; i < NDDTF; i++)
        {
            DescribeDdtf(pddtf, pddsd);
            pddtf++;
            pddsd++;
        }

        if (gengc->pMcdState != NULL && nMcdFmts > 0)
        {
            nMcdFmts = GenMcdGetTextureFormats(gengc, nMcdFmts, pddsd);
            if (nMcdFmts < 0)
            {
                FREE(pddsdAlloc);
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
        }
    }

    plrc->pddsdTexFormats = pddsdAlloc;
    plrc->nDdTexFormats = nFmts;
    
    return TRUE;
}

/******************************Public*Routine******************************\
*
* wglEnumTextureFormats
*
* Enumerates texture formats supported for DirectDraw surfaces
*
* History:
*  Tue Sep 03 17:52:17 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#ifdef ALLOW_DDTEX
BOOL WINAPI wglEnumTextureFormats(WGLENUMTEXTUREFORMATSCALLBACK pfnCallback,
                                  LPVOID pvUser)
{
    int i;
    DDSURFACEDESC *pddsd;
    BOOL bRet = TRUE;
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();
    if (plrc == NULL)
    {
        SetLastError(ERROR_INVALID_FUNCTION);
        return FALSE;
    }

    glFlush();
    
    if (plrc->pddsdTexFormats == NULL &&
        !CacheTextureFormats(plrc))
    {
        return FALSE;
    }

    pddsd = plrc->pddsdTexFormats;
    for (i = 0; i < plrc->nDdTexFormats; i++)
    {
        if (!pfnCallback(pddsd, pvUser))
        {
            break;
        }
        
        pddsd++;
    }

    // Should this return FALSE if the enumeration was terminated?
    return bRet;
}
#endif

/******************************Public*Routine******************************\
*
* wglBindDirectDrawTexture
*
* Makes a DirectDraw surface the current 2D texture source
*
* History:
*  Tue Sep 03 17:53:43 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL WINAPI wglBindDirectDrawTexture(LPDIRECTDRAWSURFACE pdds)
{
    DDSURFACEDESC ddsd;
    int i;
    DDSURFACEDESC *pddsd;
    __GLcontext *gc;
    int iLev = 0;
    PLRC plrc;
    LPDIRECTDRAWSURFACE apdds[__GL_WGL_MAX_MIPMAP_LEVEL];
    GLuint ulFlags;

    plrc = GLTEB_CLTCURRENTRC();
    if (plrc == NULL)
    {
        SetLastError(ERROR_INVALID_FUNCTION);
        return FALSE;
    }

    glFlush();

    if (plrc->dhrc != 0)
    {
        if (plrc->pGLDriver->pfnDrvBindDirectDrawTexture == NULL)
        {
            SetLastError(ERROR_INVALID_FUNCTION);
            return FALSE;
        }
    }
    else
    {
        gc = (__GLcontext *)GLTEB_SRVCONTEXT();
        ASSERTOPENGL(gc != NULL, "No server context\n");
    }

    if (pdds == NULL)
    {
        // Clear any previous binding
        if (plrc->dhrc != 0)
        {
            return plrc->pGLDriver->pfnDrvBindDirectDrawTexture(pdds);
        }
        else
        {
            glsrvUnbindDirectDrawTexture(gc);
            // If we're just unbinding, we're done
            return TRUE;
        }
    }
    
    memset(&ddsd, 0, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    if (pdds->lpVtbl->GetSurfaceDesc(pdds, &ddsd) != DD_OK)
    {
        return FALSE;
    }

    // Surface must be a texture
    // Surface must have a width and height which are powers of two
    if ((ddsd.dwFlags & (DDSD_CAPS | DDSD_PIXELFORMAT | DDSD_WIDTH |
                         DDSD_HEIGHT)) !=
        (DDSD_CAPS | DDSD_PIXELFORMAT | DDSD_WIDTH | DDSD_HEIGHT) ||
        (ddsd.ddsCaps.dwCaps & DDSCAPS_TEXTURE) == 0 ||
        (ddsd.dwWidth & (ddsd.dwWidth-1)) != 0 ||
        (ddsd.dwHeight & (ddsd.dwHeight-1)) != 0)
    {
        return FALSE;
    }

    // Surface must match a supported format
    if (plrc->pddsdTexFormats == NULL &&
        !CacheTextureFormats(plrc))
    {
        return FALSE;
    }

    pddsd = plrc->pddsdTexFormats;
    for (i = 0; i < plrc->nDdTexFormats; i++)
    {
        if (ddsd.ddpfPixelFormat.dwFlags & DDPF_RGB)
        {
            if (ddsd.ddpfPixelFormat.dwRGBBitCount ==
		(DWORD)pddsd->ddpfPixelFormat.dwRGBBitCount)
            {
                if (ddsd.ddpfPixelFormat.dwRBitMask !=
                    pddsd->ddpfPixelFormat.dwRBitMask ||
                    ddsd.ddpfPixelFormat.dwGBitMask !=
                    pddsd->ddpfPixelFormat.dwGBitMask ||
                    ddsd.ddpfPixelFormat.dwBBitMask !=
                    pddsd->ddpfPixelFormat.dwBBitMask)
                {
                    return FALSE;
                }
                else
                {
                    break;
                }
            }
        }
        else
        {
            if ((ddsd.ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED1 |
                                                 DDPF_PALETTEINDEXED2 |
                                                 DDPF_PALETTEINDEXED4 |
                                                 DDPF_PALETTEINDEXED8)) !=
                (pddsd->ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED1 |
                                                   DDPF_PALETTEINDEXED2 |
                                                   DDPF_PALETTEINDEXED4 |
                                                   DDPF_PALETTEINDEXED8)))
            {
                return FALSE;
            }
            else
            {
                break;
            }
        }

        pddsd++;
    }

    if (i == plrc->nDdTexFormats)
    {
        return FALSE;
    }

    ulFlags = 0;

    if (i < NDDTF)
    {
        ulFlags |= DDTEX_GENERIC_FORMAT;
    }
    
    if (plrc->dhrc != 0)
    {
        return plrc->pGLDriver->pfnDrvBindDirectDrawTexture(pdds);
    }
    
    pdds->lpVtbl->AddRef(pdds);

    // Track whether the texture is in video memory or not.
    ulFlags |= DDTEX_VIDEO_MEMORY;
    if ((ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) == 0)
    {
        ulFlags &= ~DDTEX_VIDEO_MEMORY;
    }
    
    // If mipmaps are given, all mipmaps must be present
    if (ddsd.ddsCaps.dwCaps & DDSCAPS_MIPMAP)
    {
        DWORD dwWidth;
        DWORD dwHeight;
        LONG lPitch;
        int cColorBits;
        LPDIRECTDRAWSURFACE pddsMipmap, pddsNext;
        DDSCAPS ddscaps;
        DDSURFACEDESC ddsdMipmap;

        // Determine pixel depth
        if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED1)
        {
            cColorBits = 1;
        }
        else if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED2)
        {
            cColorBits = 2;
        }
        else if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED4)
        {
            cColorBits = 4;
        }
        else if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)
        {
            cColorBits = 8;
        }
        else
        {
            ASSERTOPENGL(ddsd.ddpfPixelFormat.dwFlags & DDPF_RGB,
                         "DDPF_RGB expected\n");
            
            cColorBits =
                DdPixDepthToCount(pddsd->ddpfPixelFormat.dwRGBBitCount);
        }

        dwWidth = ddsd.dwWidth;
        dwHeight = ddsd.dwHeight;
        
        // Compute pitch from pixel depth.  The generic texturing code
        // doesn't support a pitch that differs from the natural pitch
        // given the width and depth of the surface.
        lPitch = (cColorBits*dwWidth+7)/8;

        if (ddsd.lPitch != lPitch)
        {
            goto CleanMipmap;
        }
        
        pddsMipmap = pdds;
        ddscaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
	ddsdMipmap.dwSize = sizeof(DDSURFACEDESC);
        for (;;)
        {
            apdds[iLev++] = pddsMipmap;

            if (pddsMipmap->lpVtbl->
                GetSurfaceDesc(pddsMipmap, &ddsdMipmap) != DD_OK ||
                ((ddsdMipmap.ddpfPixelFormat.dwFlags & DDPF_RGB) &&
                 ddsdMipmap.ddpfPixelFormat.dwRGBBitCount !=
                 ddsd.ddpfPixelFormat.dwRGBBitCount) ||
                ((ddsdMipmap.ddpfPixelFormat.dwFlags & DDPF_RGB) == 0 &&
                 (ddsdMipmap.ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED1 |
                                                        DDPF_PALETTEINDEXED2 |
                                                        DDPF_PALETTEINDEXED4 |
                                                        DDPF_PALETTEINDEXED8)) !=
                 (ddsd.ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED1 |
                                                  DDPF_PALETTEINDEXED2 |
                                                  DDPF_PALETTEINDEXED4 |
                                                  DDPF_PALETTEINDEXED8))) ||
                ddsdMipmap.dwWidth != dwWidth ||
                ddsdMipmap.dwHeight != dwHeight ||
                ddsdMipmap.lPitch != lPitch)
            {
                goto CleanMipmap;
            }

            if ((ddsdMipmap.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) == 0)
            {
                ulFlags &= ~DDTEX_VIDEO_MEMORY;
            }
            
            if (iLev > gc->constants.maxMipMapLevel ||
                (dwWidth == 1 && dwHeight == 1))
            {
                break;
            }
            
            if (pddsMipmap->lpVtbl->
                GetAttachedSurface(pddsMipmap, &ddscaps, &pddsNext) != DD_OK)
            {
                goto CleanMipmap;
            }
            pddsMipmap = pddsNext;

            if (dwWidth != 1)
            {
                dwWidth >>= 1;
                lPitch >>= 1;
            }
            if (dwHeight != 1)
            {
                dwHeight >>= 1;
            }
        }
    }
    else
    {
        apdds[iLev++] = pdds;
    }

    if (glsrvBindDirectDrawTexture(gc, iLev, apdds, &ddsd, ulFlags))
    {
        return TRUE;
    }

 CleanMipmap:
    while (--iLev >= 0)
    {
        apdds[iLev]->lpVtbl->Release(apdds[iLev]);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\eval.c ===
/******************************Module*Header*******************************\
* Module Name: eval.c
*
* OpenGL Evaluator functions on the client side.
*
* Created: 
* Author: 
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "glsbcltu.h"
#include "glclt.h"
#include "compsize.h"

#include "glsize.h"

#include "context.h"
#include "global.h"
#include "attrib.h"
#include "imports.h"

////////////////////////////////////////////////////////////////////
// Stuff needed for PA_EvalMesh2 ///////////////////////////////////
////////////////////////////////////////////////////////////////////
#define MV_VERTEX3    0x0001
#define MV_VERTEX4    0x0002
#define MV_NORMAL     0x0004
#define MV_COLOR      0x0008
#define MV_INDEX      0x0010
#define MV_TEXTURE1   0x0020
#define MV_TEXTURE2   0x0040
#define MV_TEXTURE3   0x0080
#define MV_TEXTURE4   0x0100

// Assumption: U is moving, left to right. V is moving top to bottom
#define MV_TOP        0x0001
#define MV_LEFT       0x0002

typedef struct {
    __GLcoord vertex;
    __GLcoord normal;
    __GLcoord texture;
    __GLcolor color;
} MESHVERTEX;


#define MAX_MESH_VERTICES     MAX_U_SIZE*MAX_V_SIZE
#define MAX_U_SIZE       16
#define MAX_V_SIZE       16

GLubyte *dBufFill;     //fill only
GLuint totFillPts;
GLubyte *dBufTopLeft;     //for mv_left 
GLuint totTopLeftPts;
GLubyte *dBufTopRight;      //for non mv_left
GLuint totTopRightPts;

//////////////////////////////////////////////////////////////////////
/// Function Prototypes //////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
void FASTCALL PADoEval1(__GLcontext *, __GLfloat);
void FASTCALL PADoEval2(__GLcontext *, __GLfloat, __GLfloat);
void FASTCALL PADoEval2VArray(__GLcontext *, __GLfloat, __GLfloat, 
                              MESHVERTEX *, GLuint *);
static void PreEvaluate(GLint , __GLfloat , __GLfloat *);
static void PreEvaluateWithDeriv(GLint, __GLfloat, __GLfloat *, __GLfloat *);
void DoDomain2(__GLevaluatorMachine *, __GLfloat, __GLfloat, 
               __GLevaluator2 *, __GLfloat *, __GLfloat *);
void DoDomain2WithDerivs(__GLevaluatorMachine *, __GLfloat,    __GLfloat, 
                            __GLevaluator2 *, __GLfloat *,    __GLfloat *, 
                         __GLfloat *, __GLfloat *);
int FASTCALL genMeshElts (GLenum, GLuint, GLint, GLint, GLubyte *);
void FASTCALL PA_EvalMesh2Fast(__GLcontext *, GLint, GLint, GLint,
                               GLint, GLint, GLenum, GLuint);
void glcltColor4fv_Eval (__GLfloat *c4);
void glcltIndexf_Eval (__GLfloat ci);
void glcltNormal3fv_Eval(__GLfloat *n3);
void glcltTexCoord1fv_Eval(__GLfloat *t1);
void glcltTexCoord2fv_Eval(__GLfloat *t2);
void glcltTexCoord3fv_Eval(__GLfloat *t3);
void glcltTexCoord4fv_Eval(__GLfloat *t4);

/************************************************************************/
/********************** Client-side entry points ************************/
/********************** for 1-D Evaluators       ************************/
/************************************************************************/


void APIENTRY
glcltEvalMesh1 ( IN GLenum mode, IN GLint u1, IN GLint u2 )
{
    __GL_SETUP ();
    POLYARRAY *pa;
    GLenum     primType;
    GLint      i;
    WORD       flags = (WORD) GET_EVALSTATE (gc);
    __GLfloat u;
    __GLfloat du;
    __GLevaluatorGrid *gu;
    
    // Not allowed in begin/end.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    switch(mode)
    {
      case GL_LINE:
        primType = GL_LINE_STRIP;
        break;
      case GL_POINT:
        primType = GL_POINTS;
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    // if there are any pending API calls that affect the Evaluator state
    // then flush the message buffer

    if (flags & (__EVALS_AFFECTS_1D_EVAL|
                 __EVALS_AFFECTS_ALL_EVAL))
        glsbAttention();

    gu = &gc->state.evaluator.u1;
    //du = (gu->finish - gu->start)/(__GLfloat)gu->n;
    du = gu->step;

    // Call Begin/End.  

    glcltBegin(primType);
    for (i = u1; i <= u2; i++)
    {
        u = (i == gu->n) ? gu->finish : (gu->start + i * du);
        PADoEval1(gc, u);
    }
    glcltEnd();
}


void APIENTRY
glcltEvalPoint1 ( IN GLint i )
{
    __GL_SETUP ();
    POLYARRAY *pa;
    __GLfloat u;
    __GLfloat du;
    __GLevaluatorGrid *gu;

    // This call has no effect outside begin/end 
    // (unless it is being compiled).

    pa = GLTEB_CLTPOLYARRAY();

    if (!(pa->flags & POLYARRAY_IN_BEGIN))
    {
        return;
    }

    gu = &gc->state.evaluator.u1;
    du = gu->step;
    //du = (gu->finish - gu->start)/(__GLfloat)gu->n;
    u = (i == gu->n) ? gu->finish : (gu->start + i * du);

    PADoEval1(gc, u);
}

void APIENTRY
glcltEvalCoord1f ( IN GLfloat u )
{
    __GL_SETUP ();
    POLYARRAY *pa;

    // This call has no effect outside begin/end 
    // (unless it is being compiled).

    pa = GLTEB_CLTPOLYARRAY();

    // If not in Begin-End block, return without doing anything
    if (!(pa->flags & POLYARRAY_IN_BEGIN))
    {
        return;
    }

    PADoEval1(gc, u);
}

void APIENTRY
glcltEvalCoord1d ( IN GLdouble u )
{
    glcltEvalCoord1f((GLfloat) u);
}

void APIENTRY
glcltEvalCoord1dv ( IN const GLdouble u[1] )
{
    glcltEvalCoord1f((GLfloat) u[0]);
}

void APIENTRY
glcltEvalCoord1fv ( IN const GLfloat u[1] )
{
    glcltEvalCoord1f((GLfloat) u[0]);
}

void APIENTRY
glcltMapGrid1d ( IN GLint un, IN GLdouble u1, IN GLdouble u2 )
{
    glcltMapGrid1f(un, (GLfloat) u1, (GLfloat) u2);
}

void APIENTRY
glcltMapGrid1f ( IN GLint un, IN GLfloat u1, IN GLfloat u2 )
{
    POLYARRAY *pa;
    __GL_SETUP ();
    WORD     flags = (WORD) GET_EVALSTATE (gc);

    // Check if it is called inside a Begin-End block
    // If we are already in the begin/end bracket, return an error.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    // if there are any pending API calls that affect the Evaluator state
    // then flush the message buffer

    if (flags & (__EVALS_PUSH_EVAL_ATTRIB | __EVALS_POP_EVAL_ATTRIB))
        glsbAttention ();
    
#ifdef NT
    if (un <= 0)
    {
    __glSetError(GL_INVALID_VALUE);
    return;
    }
#endif
    gc->state.evaluator.u1.start = (__GLfloat)u1;
    gc->state.evaluator.u1.finish = (__GLfloat)u2;
    gc->state.evaluator.u1.n = un;
    gc->state.evaluator.u1.step = ((__GLfloat)u2 - (__GLfloat)u1)/(__GLfloat)un;
}


void APIENTRY
glcltMap1d ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint stride, IN GLint order, IN const GLdouble points[] )
{
    __GLevaluator1 *ev;
    __GLfloat *data;
    POLYARRAY *pa;
    __GL_SETUP ();

    // Check if it is called inside a Begin-End block
    // If we are already in the begin/end bracket, return an error.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    ev = __glSetUpMap1(gc, target, order, u1, u2);
    if (ev == 0) {
    return;
    }
    if (stride < ev->k) {
    __glSetError(GL_INVALID_VALUE);
    return;
    }
    data = gc->eval.eval1Data[__GL_EVAL1D_INDEX(target)];
    __glFillMap1d(ev->k, order, stride, points, data);
}

void APIENTRY
glcltMap1f ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint stride, IN GLint order, IN const GLfloat points[] )
{
    __GLevaluator1 *ev;
    __GLfloat *data;
    POLYARRAY *pa;
    __GL_SETUP ();

    // Check if it is called inside a Begin-End block
    // If we are already in the begin/end bracket, return an error.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    ev = __glSetUpMap1(gc, target, order, u1, u2);
    if (ev == 0) {
    return;
    }
    if (stride < ev->k) {
    __glSetError(GL_INVALID_VALUE);
    return;
    }
    data = gc->eval.eval1Data[__GL_EVAL1D_INDEX(target)];
    __glFillMap1f(ev->k, order, stride, points, data);
}

/************************************************************************/
/********************** Client-side entry points ************************/
/********************** for 2-D Evaluators       ************************/
/************************************************************************/

void APIENTRY
glcltEvalMesh2 ( IN GLenum mode, IN GLint u1, IN GLint u2, IN GLint v1, IN GLint v2 )
{
    POLYARRAY *pa;
    GLint      i, j, meshSize;
    __GL_SETUP();
    GLboolean done_v, done_u;
    GLint v_beg, v_end, u_beg, u_end, u_len;
    GLuint sides;
    WORD   flags = (WORD) GET_EVALSTATE (gc);

    // Flush the command buffer before we start.  We need to access the
    // latest evaluator states in this function.
    // if there are any pending API calls that affect the Evaluator state
    // then flush the message buffer

    if (flags & (__EVALS_AFFECTS_2D_EVAL|
                 __EVALS_AFFECTS_ALL_EVAL))
        glsbAttention ();

    // Not allowed in begin/end.

    pa = gc->paTeb;
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    // If vertex map is not enabled, this is a noop.

    if (!(gc->state.enables.eval2 & (__GL_MAP2_VERTEX_4_ENABLE |
                                     __GL_MAP2_VERTEX_3_ENABLE)))
        return;

    // Make sure that the mesh is not empty.

    if (u1 > u2 || v1 > v2)
        return;

    if (mode == GL_FILL && dBufFill == NULL) 
    {
        if (!(dBufFill = (GLubyte *) ALLOC (
                           4 * MAX_U_SIZE * MAX_V_SIZE * sizeof (GLubyte)))) 
        {
            GLSETERROR(GL_OUT_OF_MEMORY);
            return;
        }

        totFillPts = genMeshElts (GL_FILL, MV_TOP | MV_LEFT, MAX_U_SIZE, 
                                    MAX_V_SIZE, dBufFill);
    }

    if (mode == GL_LINE && dBufTopLeft == NULL) 
    {
        if (!(dBufTopLeft = (GLubyte *) ALLOC (
                        2 * 4 * MAX_U_SIZE * MAX_V_SIZE * sizeof (GLubyte))))
        {
            GLSETERROR(GL_OUT_OF_MEMORY);
            return;
        }
        dBufTopRight = &dBufTopLeft[4 * MAX_U_SIZE * MAX_V_SIZE];

        totTopLeftPts = genMeshElts (GL_LINE, MV_TOP | MV_LEFT, MAX_U_SIZE, 
                                     MAX_V_SIZE,  dBufTopLeft);
        totTopRightPts = genMeshElts (GL_LINE, MV_TOP, MAX_U_SIZE, MAX_V_SIZE,
                                      dBufTopRight);
    }

    switch(mode)
    {
      case GL_POINT:
        glcltBegin(GL_POINTS);
        for (i = v1; i <= v2; i++)
            for (j = u1; j <= u2; j++)
                glcltEvalPoint2(j, i);
        glcltEnd();
        break ;

      case GL_LINE:
      case GL_FILL: // the sides argument in the fastcall is ignored
        meshSize = (u2 - u1 + 1)*(v2 - v1 + 1);
        if (meshSize <= MAX_MESH_VERTICES)
            PA_EvalMesh2Fast(gc, u1, u2, v1, v2, meshSize, mode, 
                             (GLubyte) 15);
        else {
            u_beg = u1;
            u_end = u_beg + MAX_U_SIZE - 1;
            done_u = GL_FALSE;
            while (!done_u) {           //Along U side
                if(u_end >= u2) {
                    u_end = u2;
                    done_u = GL_TRUE;
                }
                u_len = u_end - u_beg + 1;        
                v_beg = v1;
                v_end = v_beg + MAX_V_SIZE - 1;
                done_v = GL_FALSE;

                while(!done_v) {       //Along V side
                    if(v_end >= v2) {
                        v_end = v2;
                        done_v = GL_TRUE;
                    }
                    meshSize = u_len*(v_end - v_beg + 1);
                    sides = 0;
                    if (u_beg == u1) 
                        sides |= MV_LEFT;
                    if (v_beg == v1)
                        sides |= MV_TOP;
                    PA_EvalMesh2Fast(gc, u_beg, u_end,
                                     v_beg, v_end, meshSize, mode, sides);
                    v_beg = v_end;
                    v_end = v_beg+MAX_V_SIZE-1;
                }
                u_beg = u_end;
                u_end = u_beg + MAX_U_SIZE - 1;
            }
        }
        break ;

      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }
}


void APIENTRY
glcltEvalCoord2f ( IN GLfloat u, IN GLfloat v )
{
    __GL_SETUP ();
    POLYARRAY *pa;

    // This call has no effect outside begin/end
    // (unless it is being compiled).

    pa = GLTEB_CLTPOLYARRAY();

    if (!(pa->flags & POLYARRAY_IN_BEGIN))
    {
        return;
    }

    PADoEval2(gc, u, v);
}

void APIENTRY
glcltEvalCoord2d ( IN GLdouble u, IN GLdouble v )
{
    glcltEvalCoord2f((GLfloat) u, (GLfloat) v);
}

void APIENTRY
glcltEvalCoord2dv ( IN const GLdouble u[2] )
{
    glcltEvalCoord2f((GLfloat) u[0], (GLfloat) u[1]);
}

void APIENTRY
glcltEvalCoord2fv ( IN const GLfloat u[2] )
{
    glcltEvalCoord2f((GLfloat) u[0], (GLfloat) u[1]);
}

void APIENTRY
glcltEvalPoint2 ( IN GLint i, IN GLint j )
{
    __GL_SETUP ();
    POLYARRAY *pa;
    __GLfloat u, v;
    __GLfloat du, dv;
    __GLevaluatorGrid *gu;
    __GLevaluatorGrid *gv;

    // This call has no effect outside begin/end
    // (unless it is being compiled).

    pa = GLTEB_CLTPOLYARRAY();

    if (!(pa->flags & POLYARRAY_IN_BEGIN))
    {
        return;
    }

    gu = &gc->state.evaluator.u2;
    gv = &gc->state.evaluator.v2;
    du = gu->step;
    dv = gv->step;

    //du = (gu->finish - gu->start)/(__GLfloat)gu->n;
    //dv = (gv->finish - gv->start)/(__GLfloat)gv->n;
    u = (i == gu->n) ? gu->finish : (gu->start + i * du);
    v = (j == gv->n) ? gv->finish : (gv->start + j * dv);

    PADoEval2 (gc, u, v);
}

void APIENTRY
glcltMapGrid2d ( IN GLint un, IN GLdouble u1, IN GLdouble u2, IN GLint vn, IN GLdouble v1, IN GLdouble v2 )
{
    glcltMapGrid2f(un, (GLfloat) u1, (GLfloat) u2, vn, (GLfloat) v1, (GLfloat) v2);
}

void APIENTRY
glcltMapGrid2f ( IN GLint un, IN GLfloat u1, IN GLfloat u2, IN GLint vn, IN GLfloat v1, IN GLfloat v2 )
{
    POLYARRAY *pa;
    __GL_SETUP ();
    WORD flags = (WORD) GET_EVALSTATE (gc);

    // Check if it is called inside a Begin-End block
    // If we are already in the begin/end bracket, return an error.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    // if there are any pending API calls that affect the Evaluator state
    // then flush the message buffer

    if (flags & (__EVALS_PUSH_EVAL_ATTRIB|
                 __EVALS_POP_EVAL_ATTRIB))
        glsbAttention ();

#ifdef NT
    if (un <= 0 || vn <= 0)
    {
    __glSetError(GL_INVALID_VALUE);
    return;
    }
#endif
    gc->state.evaluator.u2.start = (__GLfloat)u1;
    gc->state.evaluator.u2.finish = (__GLfloat)u2;
    gc->state.evaluator.u2.n = un;
    gc->state.evaluator.u2.step = ((__GLfloat)u2 - (__GLfloat)u1)/(__GLfloat)un;
    
    gc->state.evaluator.v2.start = (__GLfloat)v1;
    gc->state.evaluator.v2.finish = (__GLfloat)v2;
    gc->state.evaluator.v2.n = vn;
    gc->state.evaluator.v2.step = ((__GLfloat)v2 - (__GLfloat)v1)/(__GLfloat)vn;
}


void APIENTRY
glcltMap2d ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint ustride, IN GLint uorder, IN GLdouble v1, IN GLdouble v2, IN GLint vstride, IN GLint vorder, IN const GLdouble points[] )
{
    __GLevaluator2 *ev;
    __GLfloat *data;
    POLYARRAY *pa;
    __GL_SETUP ();

    // Check if it is called inside a Begin-End block
    // If we are already in the begin/end bracket, return an error.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    ev = __glSetUpMap2(gc, target, uorder, vorder, u1, u2, v1, v2);
    if (ev == 0) {
        return;
    }
    if (ustride < ev->k) {
        __glSetError(GL_INVALID_VALUE);
        return;
    }
    if (vstride < ev->k) {
        __glSetError(GL_INVALID_VALUE);
        return;
    }
    data = gc->eval.eval2Data[__GL_EVAL2D_INDEX(target)];
    __glFillMap2d(ev->k, uorder, vorder, ustride, vstride,
                  points, data);
}

void APIENTRY
glcltMap2f ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint ustride, IN GLint uorder, IN GLfloat v1, IN GLfloat v2, IN GLint vstride, IN GLint vorder, IN const GLfloat points[] )
{
    __GLevaluator2 *ev;
    __GLfloat *data;
    POLYARRAY *pa;
    __GL_SETUP ();

    // Check if it is called inside a Begin-End block
    // If we are already in the begin/end bracket, return an error.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    ev = __glSetUpMap2(gc, target, uorder, vorder, u1, u2, v1, v2);
    if (ev == 0) {
        return;
    }
    if (ustride < ev->k) {
        __glSetError(GL_INVALID_VALUE);
        return;
    }
    if (vstride < ev->k) {
        __glSetError(GL_INVALID_VALUE);
        return;
    }
    data = gc->eval.eval2Data[__GL_EVAL2D_INDEX(target)];
    __glFillMap2f(ev->k, uorder, vorder, ustride, vstride,
                  points, data);
}

/************************************************************************/
/********************** Evaluator helper functions **********************/
/********************** taken from so_eval.c       **********************/
/************************************************************************/

GLint FASTCALL __glEvalComputeK(GLenum target)
{
    switch(target) {
      case GL_MAP1_VERTEX_4:
      case GL_MAP1_COLOR_4:
      case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_4:
      case GL_MAP2_COLOR_4:
      case GL_MAP2_TEXTURE_COORD_4:
    return 4;
      case GL_MAP1_VERTEX_3:
      case GL_MAP1_TEXTURE_COORD_3:
      case GL_MAP1_NORMAL:
      case GL_MAP2_VERTEX_3:
      case GL_MAP2_TEXTURE_COORD_3:
      case GL_MAP2_NORMAL:
    return 3;
      case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_2:
    return 2;
      case GL_MAP1_TEXTURE_COORD_1:
      case GL_MAP2_TEXTURE_COORD_1:
      case GL_MAP1_INDEX:
      case GL_MAP2_INDEX:
    return 1;
      default:
    return -1;
    }
}


void ComputeNormal2(__GLcontext *gc, __GLfloat *n, __GLfloat *pu, 
               __GLfloat *pv)
{
    n[0] = pu[1]*pv[2] - pu[2]*pv[1];
    n[1] = pu[2]*pv[0] - pu[0]*pv[2];
    n[2] = pu[0]*pv[1] - pu[1]*pv[0];
    
#ifdef NT
// Only need to normalize auto normals if normalization is not enabled!
    if (!(gc->state.enables.general & __GL_NORMALIZE_ENABLE))
#endif
        __glNormalize(n, n);
}


void ComputeFirstPartials(__GLfloat *p, __GLfloat *pu, __GLfloat *pv)
{
    pu[0] = pu[0]*p[3] - pu[3]*p[0];
    pu[1] = pu[1]*p[3] - pu[3]*p[1];
    pu[2] = pu[2]*p[3] - pu[3]*p[2];

    pv[0] = pv[0]*p[3] - pv[3]*p[0];
    pv[1] = pv[1]*p[3] - pv[3]*p[1];
    pv[2] = pv[2]*p[3] - pv[3]*p[2];
}

/*
** define a one dimensional map
*/
__GLevaluator1 *__glSetUpMap1(__GLcontext *gc, GLenum type,
                  GLint order, __GLfloat u1, __GLfloat u2)
{
    __GLevaluator1 *ev;
    __GLfloat **evData;
    __GLfloat *pevData;

    switch (type) 
    {
      case GL_MAP1_COLOR_4:
      case GL_MAP1_INDEX:
      case GL_MAP1_NORMAL:
      case GL_MAP1_TEXTURE_COORD_1:
      case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP1_TEXTURE_COORD_3:
      case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP1_VERTEX_3:
      case GL_MAP1_VERTEX_4:
    ev = &gc->eval.eval1[__GL_EVAL1D_INDEX(type)];
    evData = &gc->eval.eval1Data[__GL_EVAL1D_INDEX(type)];
    break;
      default:
    __glSetError(GL_INVALID_ENUM);
    return 0;
    }
    if (u1 == u2 || order < 1 || order > gc->constants.maxEvalOrder) 
    {
        __glSetError(GL_INVALID_VALUE);
        return 0;
    }
    pevData = (__GLfloat *)
        GCREALLOC(gc, *evData,
                  (__glMap1_size(ev->k, order) * sizeof(__GLfloat)));
    if (!pevData)
    {
        __glSetError(GL_OUT_OF_MEMORY);
        return 0;
    }
    *evData = pevData;

    ev->order = order;
    ev->u1 = u1;
    ev->u2 = u2;

    return ev;
}

/*
** define a two dimensional map
*/
__GLevaluator2 *__glSetUpMap2(__GLcontext *gc, GLenum type,
                  GLint majorOrder, GLint minorOrder,
                  __GLfloat u1, __GLfloat u2,
                  __GLfloat v1, __GLfloat v2)
{
    __GLevaluator2 *ev;
    __GLfloat **evData;
    __GLfloat *pevData;

    switch (type) {
      case GL_MAP2_COLOR_4:
      case GL_MAP2_INDEX:
      case GL_MAP2_NORMAL:
      case GL_MAP2_TEXTURE_COORD_1:
      case GL_MAP2_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_3:
      case GL_MAP2_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_3:
      case GL_MAP2_VERTEX_4:
    ev = &gc->eval.eval2[__GL_EVAL2D_INDEX(type)];
    evData = &gc->eval.eval2Data[__GL_EVAL2D_INDEX(type)];
    break;
      default:
    __glSetError(GL_INVALID_ENUM);
    return 0;
    }
    if (minorOrder < 1 || minorOrder > gc->constants.maxEvalOrder ||
        majorOrder < 1 || majorOrder > gc->constants.maxEvalOrder ||
        u1 == u2 || v1 == v2) 
    {
        __glSetError(GL_INVALID_VALUE);
        return 0;
    }
    pevData = (__GLfloat *)
        GCREALLOC(gc, *evData,
                  (__glMap2_size(ev->k, majorOrder, minorOrder)
                   * sizeof(__GLfloat)));
    if (!pevData)
    {
        __glSetError(GL_OUT_OF_MEMORY);
        return 0;
    }
    *evData = pevData;

    ev->majorOrder = majorOrder;
    ev->minorOrder = minorOrder;
    ev->u1 = u1;
    ev->u2 = u2;
    ev->v1 = v1;
    ev->v2 = v2;

    return ev;
}


/*
** Fill our data from user data
*/
void APIPRIVATE __glFillMap1f(GLint k, GLint order, GLint stride, 
           const GLfloat *points, __GLfloat *data)
{
    int i,j;

#ifndef __GL_DOUBLE
    /* Optimization always hit during display list execution */
    if (k == stride) 
    {
        __GL_MEMCOPY(data, points, 
                    __glMap1_size(k, order) * sizeof(__GLfloat));
        return;
    }
#endif
    for (i=0; i<order; i++) 
    {
        for (j=0; j<k; j++) 
        {
            data[j] = points[j];
        }
        points += stride;
        data += k;
    }
}


void APIPRIVATE __glFillMap1d(GLint k, GLint order, GLint stride, 
           const GLdouble *points, __GLfloat *data)
{
    int i,j;

    for (i=0; i<order; i++) 
    {
        for (j=0; j<k; j++) 
        {
            data[j] = points[j];
        }
        points += stride;
        data += k;
    }
}

void APIPRIVATE __glFillMap2f(GLint k, GLint majorOrder, GLint minorOrder, 
           GLint majorStride, GLint minorStride,
           const GLfloat *points, __GLfloat *data)
{
    int i,j,x;

#ifndef __GL_DOUBLE
    /* Optimization always hit during display list execution */
    if (k == minorStride && majorStride == k * minorOrder) 
    {
        __GL_MEMCOPY(data, points, 
            __glMap2_size(k, majorOrder, minorOrder) * sizeof(__GLfloat));
        return;
    }
#endif
    for (i=0; i<majorOrder; i++) 
    {
        for (j=0; j<minorOrder; j++) 
        {
            for (x=0; x<k; x++) 
            {
                data[x] = points[x];
            }
            points += minorStride;
            data += k;
        }
        points += majorStride - minorStride * minorOrder;
    }
}

void APIPRIVATE __glFillMap2d(GLint k, GLint majorOrder, GLint minorOrder, 
           GLint majorStride, GLint minorStride,
           const GLdouble *points, __GLfloat *data)
{
    int i,j,x;

    for (i=0; i<majorOrder; i++) 
    {
        for (j=0; j<minorOrder; j++) 
        {
            for (x=0; x<k; x++) 
            {
                data[x] = points[x];
            }
            points += minorStride;
            data += k;
        }
        points += majorStride - minorStride * minorOrder;
    }
}


#define TYPE_COEFF_AND_DERIV    1
#define TYPE_COEFF        2


void DoDomain1(__GLevaluatorMachine *em, __GLfloat u, __GLevaluator1 *e, 
    __GLfloat *v, __GLfloat *baseData)
{
    GLint j, row;
    __GLfloat uprime;
    __GLfloat *data;
    GLint k;

#ifdef NT
    ASSERTOPENGL(e->u2 != e->u1, "Assert in DoDomain1 failed\n");
    // assert(e->u2 != e->u1);
#else
    if(e->u2 == e->u1)
    return;
#endif
    uprime = (u - e->u1) / (e->u2 - e->u1);

    /* Use already cached values if possible */
    if (em->uvalue != uprime || em->uorder != e->order) 
    {
        /* Compute coefficients for values */
        PreEvaluate(e->order, uprime, em->ucoeff);
        em->utype = TYPE_COEFF;
        em->uorder = e->order;
        em->uvalue = uprime;
    }

    k=e->k;
    for (j = 0; j < k; j++) 
    {
        data=baseData+j;
        v[j] = 0;
        for (row = 0; row < e->order; row++) 
        {
            v[j] += em->ucoeff[row] * (*data);
            data += k;
        }
    }
}

// Helper Macro  used in PADoEval1 and PADoEval2
#ifdef __NO_OPTIMIZE_FOR_DLIST

#define  PropagateToNextPolyData (eval, pa)                       \
{                                                                 \
    if ((gc)->eval.accFlags & EVAL_COLOR_VALID)                   \
    {                                                             \
        (pa)->pdNextVertex->flags &= ~POLYDATA_EVAL_COLOR;        \
        if ((gc)->modes.colorIndexMode)                           \
            glcltIndexf_InCI((gc)->eval.color.r);                 \
        else                                                      \
            glcltColor4f_InRGBA ((gc)->eval.color.r,              \
                                 (gc)->eval.color.g,              \
                                 (gc)->eval.color.b,              \
                                 (gc)->eval.color.a);             \
    }                                                             \
                                                                  \
    if ((gc)->eval.accFlags & EVAL_NORMAL_VALID)                  \
    {                                                             \
        (pa)->pdNextVertex->flags &= ~POLYDATA_EVAL_NORMAL;       \
        glcltNormal3f ((gc)->eval.normal.x,                       \
                       (gc)->eval.normal.y,                       \
                       (gc)->eval.normal.z);                      \
    }                                                             \
                                                                  \
    if ((gc)->eval.accFlags & EVAL_TEXTURE_VALID)                 \
    {                                                             \
        (pa)->pdNextVertex->flags &= ~POLYDATA_EVAL_TEXCOORD;     \
        if (__GL_FLOAT_COMPARE_PONE((gc)->eval.texture.w, !=))    \
            glcltTexCoord4f ((gc)->eval.texture.x,                \
                             (gc)->eval.texture.y,                \
                             (gc)->eval.texture.z,                \
                             (gc)->eval.texture.w);               \
        else if (__GL_FLOAT_NEZ((gc)->eval.texture.z))            \
            glcltTexCoord3f ((gc)->eval.texture.x,                \
                             (gc)->eval.texture.y,                \
                             (gc)->eval.texture.z);               \
        else if (__GL_FLOAT_NEZ((gc)->eval.texture.y))            \
            glcltTexCoord2f ((gc)->eval.texture.x,                \
                             (gc)->eval.texture.y);               \
        else                                                      \
            glcltTexCoord1f ((gc)->eval.texture.x);               \
    }                                                             \
}

#else

#define  PropagateToNextPolyData(eval,pa)                         \
                                                                  \
    if ((gc)->eval.accFlags & EVAL_COLOR_VALID)                   \
    {                                                             \
        (pa)->pdNextVertex->flags &= ~POLYDATA_EVAL_COLOR;        \
        if ((gc)->modes.colorIndexMode)                           \
            glcltIndexf_InCI((gc)->eval.color.r);                 \
        else                                                      \
            glcltColor4f_InRGBA ((gc)->eval.color.r,              \
                                 (gc)->eval.color.g,              \
                                 (gc)->eval.color.b,              \
                                 (gc)->eval.color.a);             \
    }                                                             \
                                                                  \
    if ((gc)->eval.accFlags & EVAL_NORMAL_VALID)                  \
    {                                                             \
        (pa)->pdNextVertex->flags &= ~POLYDATA_EVAL_NORMAL;       \
        glcltNormal3f ((gc)->eval.normal.x,                       \
                       (gc)->eval.normal.y,                       \
                       (gc)->eval.normal.z);                      \
    }                                                             \
                                                                  \
    if ((gc)->eval.accFlags & EVAL_TEXTURE_VALID)                 \
    {                                                             \
        (pa)->pdNextVertex->flags &= ~POLYDATA_EVAL_TEXCOORD;     \
        glcltTexCoord4f ((gc)->eval.texture.x,                    \
                         (gc)->eval.texture.y,                    \
                         (gc)->eval.texture.z,                    \
                         (gc)->eval.texture.w);                   \
    }                                                             

#endif



//////////////////////////////////////////////////////
// Assuming that the latest State is available here //
//////////////////////////////////////////////////////
void FASTCALL PADoEval1(__GLcontext *gc, __GLfloat u)
{
    __GLevaluator1 *eval;
    __GLfloat **evalData;
    __GLevaluatorMachine em;
    __GLfloat v4[4];
    __GLfloat n3[3];
    __GLfloat t4[4];
    __GLfloat c4[4];
    __GLfloat ci;
    POLYARRAY *pa;
    
    pa = gc->paTeb;

    eval = gc->eval.eval1;
    evalData = gc->eval.eval1Data;
    em = gc->eval;
    
    // Initialize the flag
    gc->eval.accFlags = 0;
    
    // Evaluated color, index, normal and texture coords are ignored 
    // in selection

    if ((gc->renderMode != GL_SELECT) &&
        (gc->state.enables.eval1 & (__GL_MAP1_VERTEX_4_ENABLE | 
                                    __GL_MAP1_VERTEX_3_ENABLE ))
        )
    {
        if (gc->modes.colorIndexMode)
        {
            if (!(gc->state.enables.general & __GL_LIGHTING_ENABLE))
            {
                if (gc->state.enables.eval1 & __GL_MAP1_INDEX_ENABLE)
                {
                    DoDomain1(&em, u, &eval[__GL_I], &ci, evalData[__GL_I]);
                    glcltIndexf_Eval(ci);
                }
            }
        }
        else
        {
            if (gc->state.enables.eval1 & __GL_MAP1_COLOR_4_ENABLE)
            {
                // NOTE: In OpenGL 1.0, color material does not apply to 
                // evaluated colors.
                // In OpenGL 1.1, this behavior was changed.  
                // This (1.1) code assumes that ColorMaterial applies to 
                // evaluated colors to simplify the graphics pipeline.
                // Otherwise, the evaluated colors have no effect when 
                // lighting is enabled.

                DoDomain1(&em, u, &eval[__GL_C4], c4, evalData[__GL_C4]);
                
                // If some color is set in the current polydata, then
                // Save it in a temporary buffer and call glcltColor later
                // Also make sure that the current-color pointer is updated 
                // appropriately

                glcltColor4fv_Eval(c4);
            }

            if (gc->state.enables.eval1 & __GL_MAP1_TEXTURE_COORD_4_ENABLE)
            {
                DoDomain1(&em, u, &eval[__GL_T4], t4, evalData[__GL_T4]);
                glcltTexCoord4fv_Eval(t4);
            }
            else if (gc->state.enables.eval1 &
                                          __GL_MAP1_TEXTURE_COORD_3_ENABLE)
            {
                DoDomain1(&em, u, &eval[__GL_T3], t4, evalData[__GL_T3]);
                glcltTexCoord3fv_Eval(t4);
            }
            else if (gc->state.enables.eval1 & 
                                        __GL_MAP1_TEXTURE_COORD_2_ENABLE)
            {
                DoDomain1(&em, u, &eval[__GL_T2], t4, evalData[__GL_T2]);
                glcltTexCoord2fv_Eval(t4);
            }
            else if (gc->state.enables.eval1 & 
                                        __GL_MAP1_TEXTURE_COORD_1_ENABLE)
            {
                DoDomain1(&em, u, &eval[__GL_T1], t4, evalData[__GL_T1]);
                glcltTexCoord1fv_Eval(t4);
            }
        }

        if (gc->state.enables.eval1 & __GL_MAP1_NORMAL_ENABLE)
        {
            DoDomain1(&em, u, &eval[__GL_N3], n3, evalData[__GL_N3]);
            glcltNormal3fv_Eval(n3);
        }
    }

    /* Vertex */

    if (gc->state.enables.eval1 & __GL_MAP1_VERTEX_4_ENABLE)
    {
        DoDomain1(&em, u, &eval[__GL_V4], v4, evalData[__GL_V4]);
        glcltVertex4fv (v4);
    }
    else if (gc->state.enables.eval1 & __GL_MAP1_VERTEX_3_ENABLE)
    {
        DoDomain1(&em, u, &eval[__GL_V3], v4, evalData[__GL_V3]);
        glcltVertex3fv (v4);
    }

    // If there are any prior glcltColor, glcltIndex, glcltTexCoord
    // or glcltNormal calls. The values are saved in gc->eval. Use
    // these and propagate them, to the next PolyData

    PropagateToNextPolyData (eval, pa);
}


// Compute the color, texture, normal, vertex based upon u and v.
//
// NOTE: This function is called by the client side EvalMesh2 functions.
//       If you modify it, make sure that you modify the callers too!

//////////////////////////////////////////////////////
// Assuming that the latest State is available here //
//////////////////////////////////////////////////////
void FASTCALL PADoEval2(__GLcontext *gc, __GLfloat u, __GLfloat v)
{
    __GLevaluator2 *eval = gc->eval.eval2;
    __GLfloat **evalData = gc->eval.eval2Data;
    __GLevaluatorMachine em = gc->eval;
    __GLfloat v4[4];
    __GLfloat n3[3];
    __GLfloat t4[4];
    __GLfloat c4[4];
    __GLfloat ci;
    POLYARRAY *pa;
    
    pa = gc->paTeb;

    // Mark this PolyArray to indicate that it has a Evaluator vertex
    // pa->flags |= POLYARRAY_EVALCOORD;
    
// Evaluated colors, normals and texture coords are ignored in selection.

    if (gc->renderMode == GL_SELECT)
    {
        if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_4_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_V4], v4, evalData[__GL_V4]);
            glcltVertex4fv (v4);
        }
        else if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_3_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_V3], v4, evalData[__GL_V3]);
            glcltVertex3fv (v4);
        }
        return;
    }

    if (gc->state.enables.eval2 & (__GL_MAP2_VERTEX_3_ENABLE |
                                   __GL_MAP2_VERTEX_4_ENABLE))
    {
        if (gc->modes.colorIndexMode)
        {
            if (!(gc->state.enables.general & __GL_LIGHTING_ENABLE))
            {
                if (gc->state.enables.eval2 & __GL_MAP2_INDEX_ENABLE)
                {
                    DoDomain2(&em, u, v, &eval[__GL_I], &ci, evalData[__GL_I]);
                    glcltIndexf_Eval(ci);
                }
            }
        }
        else
        {
            if (gc->state.enables.eval2 & __GL_MAP2_COLOR_4_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_C4], c4, evalData[__GL_C4]);
                glcltColor4fv_Eval(c4);
            }
            
            if (gc->state.enables.eval2 & __GL_MAP2_TEXTURE_COORD_4_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_T4], t4, evalData[__GL_T4]);
                glcltTexCoord4fv_Eval(t4);
            }
            else if (gc->state.enables.eval2 & 
                     __GL_MAP2_TEXTURE_COORD_3_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_T3], t4, evalData[__GL_T3]);
                glcltTexCoord3fv_Eval(t4);
            }
            else if (gc->state.enables.eval2 & 
                     __GL_MAP2_TEXTURE_COORD_2_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_T2], t4, evalData[__GL_T2]);
                glcltTexCoord2fv_Eval(t4);
            }
            else if (gc->state.enables.eval2 & 
                     __GL_MAP2_TEXTURE_COORD_1_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_T1], t4, evalData[__GL_T1]); 
                glcltTexCoord1fv_Eval(t4);
            }
        }

        if (gc->state.enables.general & __GL_AUTO_NORMAL_ENABLE)
        {
            if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_4_ENABLE)
            {
                __GLfloat du[4];
                __GLfloat dv[4];

                DoDomain2WithDerivs(&em, u, v, &eval[__GL_V4], v4, du, dv,
                                    evalData[__GL_V4]);
                ComputeFirstPartials(v4, du, dv);
                ComputeNormal2(gc, n3, du, dv);
                glcltNormal3fv_Eval(n3);
                glcltVertex4fv(v4);
            }
            else if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_3_ENABLE)
            {
                __GLfloat du[3];
                __GLfloat dv[3];
                DoDomain2WithDerivs(&em, u, v, &eval[__GL_V3], v4, du, dv,
                                    evalData[__GL_V3]);
                ComputeNormal2(gc, n3, du, dv);
                glcltNormal3fv_Eval(n3);
                glcltVertex3fv(v4);
            }
        }
        else
        {
            if (gc->state.enables.eval2 & __GL_MAP2_NORMAL_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_N3], n3, evalData[__GL_N3]);
                glcltNormal3fv_Eval(n3);
            }
            if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_4_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_V4], v4, evalData[__GL_V4]);
                glcltVertex4fv(v4);
            }
            else if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_3_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_V3], v4, evalData[__GL_V3]);
                glcltVertex3fv(v4);
            }
        }
    }
    
    // If there are any prior glcltColor, glcltIndex, glcltTexCoord
    // or glcltNormal calls. The values are saved in gc->eval. Use
    // these and propagate them, to the next PolyData

    PropagateToNextPolyData (eval, pa);
}

#define COPYMESHVERTEX(m,v)                                          \
{                                                                    \
    (m)->vertex.x = (v)[0];                                          \
    (m)->vertex.y = (v)[1];                                          \
    (m)->vertex.z = (v)[2];                                          \
    (m)->vertex.w = (v)[3];                                          \
}                                                               

#define COPYMESHNORMAL(m,n)                                          \
{                                                                    \
    (m)->normal.x = (n)[0];                                          \
    (m)->normal.y = (n)[1];                                          \
    (m)->normal.z = (n)[2];                                          \
}                                                               

#define COPYMESHCOLOR(m,c)                                          \
{                                                                   \
    (m)->color.r = (c)[0];                                          \
    (m)->color.g = (c)[1];                                          \
    (m)->color.b = (c)[2];                                          \
    (m)->color.a = (c)[3];                                          \
}                                                               

#define COPYMESHTEXTURE(m,t)                                          \
{                                                                     \
    (m)->texture.x = (t)[0];                                          \
    (m)->texture.y = (t)[1];                                          \
    (m)->texture.z = (t)[2];                                          \
    (m)->texture.w = (t)[3];                                          \
}                                                               

//////////////////////////////////////////////////////
// Assuming that the latest State is available here //
//////////////////////////////////////////////////////
void FASTCALL PADoEval2VArray(__GLcontext *gc, __GLfloat u, __GLfloat v, 
                              MESHVERTEX *mv, GLuint *flags)
{
    __GLevaluator2 *eval = gc->eval.eval2;
    __GLfloat **evalData = gc->eval.eval2Data;
    __GLevaluatorMachine em = gc->eval;
    __GLfloat v4[4];
    __GLfloat n3[3];
    __GLfloat t4[4];
    __GLfloat c4[4];
    __GLfloat ci;
    
// Evaluated colors, normals and texture coords are ignored in selection.

    if (gc->renderMode == GL_SELECT)
    {
        if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_4_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_V4], v4, evalData[__GL_V4]);
            *flags = *flags | MV_VERTEX4;
        }
        else if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_3_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_V3], v4, evalData[__GL_V3]);
            *flags = *flags | MV_VERTEX3;
        }
        COPYMESHVERTEX (mv, v4);
        return;
    }

    if (gc->state.enables.general & __GL_AUTO_NORMAL_ENABLE)
    {
        if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_4_ENABLE)
        {
            __GLfloat du[4];
            __GLfloat dv[4];

            DoDomain2WithDerivs(&em, u, v, &eval[__GL_V4], v4, du, dv,
                                evalData[__GL_V4]);
            ComputeFirstPartials(v4, du, dv);
            ComputeNormal2(gc, n3, du, dv);
            *flags = *flags | MV_VERTEX4 | MV_NORMAL;
        }
        else if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_3_ENABLE)
        {
            __GLfloat du[3];
            __GLfloat dv[3];
            DoDomain2WithDerivs(&em, u, v, &eval[__GL_V3], v4, du, dv,
                                evalData[__GL_V3]);
            ComputeNormal2(gc, n3, du, dv);
            *flags = *flags | MV_VERTEX3 | MV_NORMAL;
        }
        COPYMESHNORMAL (mv, n3);
        COPYMESHVERTEX (mv, v4);
    }
    else
    {
        if (gc->state.enables.eval2 & __GL_MAP2_NORMAL_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_N3], n3, evalData[__GL_N3]);
            COPYMESHNORMAL (mv, n3);
            *flags = *flags | MV_NORMAL;
        }
        if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_4_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_V4], v4, evalData[__GL_V4]);
            COPYMESHVERTEX (mv, v4);
            *flags = *flags | MV_VERTEX4;
        }
        else if (gc->state.enables.eval2 & __GL_MAP2_VERTEX_3_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_V3], v4, evalData[__GL_V3]);
            COPYMESHVERTEX (mv, v4);
            *flags = *flags | MV_VERTEX3;
        }
    }

    if (gc->modes.colorIndexMode)
    {
        if (!(gc->state.enables.general & __GL_LIGHTING_ENABLE))
        {
            if (gc->state.enables.eval2 & __GL_MAP2_INDEX_ENABLE)
            {
                DoDomain2(&em, u, v, &eval[__GL_I], &(mv->color.r), 
                evalData[__GL_I]);
                *flags = *flags | MV_INDEX;
            }
        }
    }
    else
    {
        if (gc->state.enables.eval2 & __GL_MAP2_COLOR_4_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_C4], c4, evalData[__GL_C4]);
            COPYMESHCOLOR (mv, c4);
            *flags = *flags | MV_COLOR;
        }

        if (gc->state.enables.eval2 & __GL_MAP2_TEXTURE_COORD_4_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_T4], t4, evalData[__GL_T4]);
            COPYMESHTEXTURE (mv, t4);
            *flags = *flags | MV_TEXTURE4;
        }
        else if (gc->state.enables.eval2 & __GL_MAP2_TEXTURE_COORD_3_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_T3], t4, evalData[__GL_T3]);
            COPYMESHTEXTURE (mv, t4);
            *flags = *flags | MV_TEXTURE3;
        }
        else if (gc->state.enables.eval2 & __GL_MAP2_TEXTURE_COORD_2_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_T2], t4, evalData[__GL_T2]);
            COPYMESHTEXTURE (mv, t4);
            *flags = *flags | MV_TEXTURE2;
        }
        else if (gc->state.enables.eval2 & __GL_MAP2_TEXTURE_COORD_1_ENABLE)
        {
            DoDomain2(&em, u, v, &eval[__GL_T1], t4, evalData[__GL_T1]); 
            COPYMESHTEXTURE (mv, t4);
            *flags = *flags | MV_TEXTURE1;
        }
    }
}


/*
** Optimization to precompute coefficients for polynomial evaluation.
*/
static void PreEvaluate(GLint order, __GLfloat vprime, __GLfloat *coeff)
{
    GLint i, j;
    __GLfloat oldval, temp;
    __GLfloat oneMinusvprime;

    /*
    ** Minor optimization
    ** Compute orders 1 and 2 outright, and set coeff[0], coeff[1] to
    ** their i==1 loop values to avoid the initialization and the i==1 loop.
    */
    if (order == 1) 
    {
        coeff[0] = ((__GLfloat) 1.0);
        return;
    }

    oneMinusvprime = 1-vprime;
    coeff[0] = oneMinusvprime;
    coeff[1] = vprime;
    if (order == 2) return;

    for (i = 2; i < order; i++) 
    {
        oldval = coeff[0] * vprime;
        coeff[0] = oneMinusvprime * coeff[0];
        for (j = 1; j < i; j++) 
        {
            temp = oldval;
            oldval = coeff[j] * vprime;
            coeff[j] = temp + oneMinusvprime * coeff[j];
        }
        coeff[j] = oldval;
    }
}

/*
** Optimization to precompute coefficients for polynomial evaluation.
*/
static void PreEvaluateWithDeriv(GLint order, __GLfloat vprime, 
    __GLfloat *coeff, __GLfloat *coeffDeriv)
{
    GLint i, j;
    __GLfloat oldval, temp;
    __GLfloat oneMinusvprime;

    oneMinusvprime = 1-vprime;
    /*
    ** Minor optimization
    ** Compute orders 1 and 2 outright, and set coeff[0], coeff[1] to 
    ** their i==1 loop values to avoid the initialization and the i==1 loop.
    */
    if (order == 1) 
    {
        coeff[0] = ((__GLfloat) 1.0);
        coeffDeriv[0] = __glZero;
        return;
    } 
    else if (order == 2) 
    {
        coeffDeriv[0] = __glMinusOne;
        coeffDeriv[1] = ((__GLfloat) 1.0);
        coeff[0] = oneMinusvprime;
        coeff[1] = vprime;
        return;
    }
    coeff[0] = oneMinusvprime;
    coeff[1] = vprime;
    for (i = 2; i < order - 1; i++) 
    {
        oldval = coeff[0] * vprime;
        coeff[0] = oneMinusvprime * coeff[0];
        for (j = 1; j < i; j++) 
        {
            temp = oldval;
            oldval = coeff[j] * vprime;
            coeff[j] = temp + oneMinusvprime * coeff[j];
        }
        coeff[j] = oldval;
    }
    coeffDeriv[0] = -coeff[0];
    /*
    ** Minor optimization:
    ** Would make this a "for (j=1; j<order-1; j++)" loop, but it is always
    ** executed at least once, so this is more efficient.
    */
    j=1;
    do 
    {
        coeffDeriv[j] = coeff[j-1] - coeff[j];
        j++;
    } while (j < order - 1);
    coeffDeriv[j] = coeff[j-1];

    oldval = coeff[0] * vprime;
    coeff[0] = oneMinusvprime * coeff[0];
    for (j = 1; j < i; j++) 
    {
        temp = oldval;
        oldval = coeff[j] * vprime;
        coeff[j] = temp + oneMinusvprime * coeff[j];
    }
    coeff[j] = oldval;
}

void DoDomain2(__GLevaluatorMachine *em, __GLfloat u, __GLfloat v, 
    __GLevaluator2 *e, __GLfloat *r, __GLfloat *baseData)
{
    GLint j, row, col;
    __GLfloat uprime;
    __GLfloat vprime;
    __GLfloat p;
    __GLfloat *data;
    GLint k;
    
#ifdef NT
    ASSERTOPENGL((e->u2 != e->u1) && (e->v2 != e->v1), "In DoDomain2\n");
    // assert((e->u2 != e->u1) && (e->v2 != e->v1));
#else
    if((e->u2 == e->u1) || (e->v2 == e->v1))
    return;
#endif
    uprime = (u - e->u1) / (e->u2 - e->u1);
    vprime = (v - e->v1) / (e->v2 - e->v1);

    /* Compute coefficients for values */

    /* Use already cached values if possible */
    if (em->uvalue != uprime || em->uorder != e->majorOrder) 
    {
        PreEvaluate(e->majorOrder, uprime, em->ucoeff);
        em->utype = TYPE_COEFF;
        em->uorder = e->majorOrder;
        em->uvalue = uprime;
    }
    if (em->vvalue != vprime || em->vorder != e->minorOrder) 
    {
        PreEvaluate(e->minorOrder, vprime, em->vcoeff);
        em->vtype = TYPE_COEFF;
        em->vorder = e->minorOrder;
        em->vvalue = vprime;
    }
    
    k=e->k;
    for (j = 0; j < k; j++) 
    { 
        data=baseData+j;
        r[j] = 0;
        for (row = 0; row < e->majorOrder; row++)  
        {
            /* 
            ** Minor optimization.
            ** The col == 0 part of the loop is extracted so we don't
            ** have to initialize p to 0.
            */
            p=em->vcoeff[0] * (*data);
            data += k;
            for (col = 1; col < e->minorOrder; col++) 
            {
                p += em->vcoeff[col] * (*data);
                data += k;
            }
            r[j] += em->ucoeff[row] * p;
        }
    }
}

void DoDomain2WithDerivs(__GLevaluatorMachine *em, __GLfloat u, 
        __GLfloat v, __GLevaluator2 *e, __GLfloat *r,
        __GLfloat *du, __GLfloat *dv, __GLfloat *baseData)
{
    GLint j, row, col;
    __GLfloat uprime;
    __GLfloat vprime;
    __GLfloat p;
    __GLfloat pdv;
    __GLfloat n[3];
    __GLfloat *data;
    GLint k;

#ifdef NT
    ASSERTOPENGL((e->u2 != e->u1) && (e->v2 != e->v1), 
                 "In Dodomain2WithDerivs\n");
    // assert((e->u2 != e->u1) && (e->v2 != e->v1));
#else
    if((e->u2 == e->u1) || (e->v2 == e->v1))
    return;
#endif
    uprime = (u - e->u1) / (e->u2 - e->u1);
    vprime = (v - e->v1) / (e->v2 - e->v1);
    
    /* Compute coefficients for values and derivs */

    /* Use already cached values if possible */
    if (em->uvalue != uprime || em->utype != TYPE_COEFF_AND_DERIV || 
      em->uorder != e->majorOrder) 
    {
        PreEvaluateWithDeriv(e->majorOrder, uprime, em->ucoeff, 
                             em->ucoeffDeriv);
        em->utype = TYPE_COEFF_AND_DERIV;
        em->uorder = e->majorOrder;
        em->uvalue = uprime;
    }
    if (em->vvalue != vprime || em->vtype != TYPE_COEFF_AND_DERIV ||
      em->vorder != e->minorOrder) 
    {
        PreEvaluateWithDeriv(e->minorOrder, vprime, em->vcoeff, 
                             em->vcoeffDeriv);
        em->vtype = TYPE_COEFF_AND_DERIV;
        em->vorder = e->minorOrder;
        em->vvalue = vprime;
    }

    k=e->k;
    for (j = 0; j < k; j++) 
    {
        data=baseData+j;
        r[j] = du[j] = dv[j] = __glZero;
        for (row = 0; row < e->majorOrder; row++)  
        {
            /* 
            ** Minor optimization.
            ** The col == 0 part of the loop is extracted so we don't
            ** have to initialize p and pdv to 0.
            */
            p = em->vcoeff[0] * (*data);
            pdv = em->vcoeffDeriv[0] * (*data);
            data += k;
            for (col = 1; col < e->minorOrder; col++) 
            {
                /* Incrementally build up p, pdv value */
                p += em->vcoeff[col] * (*data);
                pdv += em->vcoeffDeriv[col] * (*data);
                data += k;
            }
            /* Use p, pdv value to incrementally add up r, du, dv */
            r[j] += em->ucoeff[row] * p;
            du[j] += em->ucoeffDeriv[row] * p;
            dv[j] += em->ucoeff[row] * pdv;
        }
    }
}

int FASTCALL genMeshElts (GLenum mode, GLuint sides, GLint nu, GLint nv, 
                          GLubyte *buff)
{
GLint start;
GLint i, j, k;

// Compute the DrawElements Indices

    switch(mode) {
      case GL_LINE :
        // Draw lines along U direction
        start = 1;
        k = 0;
        if (sides & MV_TOP)
            start = 0 ;
        for (i=start; i<nv; i++)
            for(j=0; j<nu-1; j++) {
                buff[k++] = i*nu+j;
                buff[k++] = i*nu+j+1;
            }

        // Draw lines along V direction
        start = 1 ;
        if (sides & MV_LEFT)
            start = 0;
        for (i=start; i<nu; i++)
            for (j=0; j<nv-1; j++) {
                buff[k++] = j*nu+i;
                buff[k++] = (j+1)*nu+i;
            }
        break ;

      case GL_FILL  :
        for (i=0, k=0; i<nv-1; i++)
            for (j=0; j<nu-1; j++) {
                buff[k++] = i*nu+j;
                buff[k++] = (i+1)*nu+j;
                buff[k++] = (i+1)*nu+j+1;
                buff[k++] = i*nu+j+1;
            }
        break ;
    }
    return k; //the total number of points
}

void FASTCALL PA_EvalMesh2Fast(__GLcontext *gc, GLint u1, GLint u2, GLint v1,
                               GLint v2, GLint meshSize, GLenum mode, 
                               GLuint sides)
{
    GLint i, j, k, nu, nv;
    __GLcolor currentColor;
    __GLcoord currentNormal, currentTexture;
    GLboolean currentEdgeFlag;
    MESHVERTEX *mv, mvBuf[MAX_U_SIZE*MAX_V_SIZE];
    GLuint mflags = 0;
    GLuint stride;
    GLubyte *disBuf;
    __GLvertexArray currentVertexInfo;
    GLuint texSize = 0, start, totalPts;
    GLubyte dBufSmall[4*MAX_U_SIZE*MAX_V_SIZE];     //small
    __GLfloat u, v;
    __GLfloat du, dv;
    __GLevaluatorGrid *gu;
    __GLevaluatorGrid *gv;

    // Now build the mesh vertex array [0..u2-u1, 0..v2-v1]
  
    gu = &gc->state.evaluator.u2;
    gv = &gc->state.evaluator.v2;

    du = gu->step;
    dv = gv->step;
    //du = (gu->finish - gu->start)/(__GLfloat)gu->n;
    //dv = (gv->finish - gv->start)/(__GLfloat)gv->n;

    mv = &mvBuf[0];
    nu = u2 - u1 + 1;
    nv = v2 - v1 + 1;
    for (i = v1; i < nv+v1; i++)                     //along V 
    {                   
        for (j = u1; j < nu+u1; j++)                 //along U
        {               
            u = (j == gu->n) ? gu->finish : (gu->start + j * du);
            v = (i == gv->n) ? gv->finish : (gv->start + i * dv);
            PADoEval2VArray(gc, u, v, mv, &mflags);
            mv++;
        }
    }
    
    if ((nv != MAX_V_SIZE) || (nu != MAX_U_SIZE)) {
        disBuf = dBufSmall;
        totalPts = genMeshElts (mode, sides, nu, nv, disBuf);
    } else {
        if (mode == GL_FILL) {
            disBuf = dBufFill;
            totalPts = totFillPts;
        } else
            switch (sides) {
              case (MV_TOP | MV_LEFT): 
                disBuf = dBufTopLeft;
                totalPts = totTopLeftPts;
                break;
              case (MV_TOP): 
                disBuf = dBufTopRight;
                totalPts = totTopRightPts;
                break;
              case (MV_LEFT): 
                disBuf = &dBufTopLeft [(MAX_U_SIZE - 1) * 2];
                totalPts = totTopLeftPts - (MAX_U_SIZE - 1) * 2;
                break;
              default : //NONE
                disBuf = &dBufTopRight [(MAX_V_SIZE - 1) * 2];
                totalPts = totTopRightPts - (MAX_V_SIZE - 1) * 2;
                break;
            }
    }

    if (mflags & MV_TEXTURE4)
            texSize = 4;
    else if (mflags & MV_TEXTURE3)
            texSize = 3;
    else if (mflags & MV_TEXTURE2)
            texSize = 2;
    else if (mflags & MV_TEXTURE1)
            texSize = 1;
    
    // Save current values.

    if (mflags & MV_NORMAL)
        currentNormal = gc->state.current.normal;

    if (mflags & MV_INDEX)
        currentColor.r = gc->state.current.userColorIndex;
    else if (mflags & MV_COLOR)
        currentColor = gc->state.current.userColor;

    if (texSize)
        currentTexture = gc->state.current.texture;

    // Always force edge flag on in GL_FILL mode.  The spec uses QUAD_STRIP
    // which implies that edge flag is on for the evaluated mesh.
    currentEdgeFlag = gc->state.current.edgeTag;
    gc->state.current.edgeTag = GL_TRUE;

    currentVertexInfo = gc->vertexArray;

//Enable the appropriate arrays    

    // Disable the arrays followed by enabling each individual array.
    gc->vertexArray.flags |= __GL_VERTEX_ARRAY_DIRTY;
    gc->vertexArray.mask &= ~(VAMASK_VERTEX_ENABLE_MASK |
                  VAMASK_NORMAL_ENABLE_MASK |
                  VAMASK_COLOR_ENABLE_MASK |
                  VAMASK_INDEX_ENABLE_MASK |
                  VAMASK_TEXCOORD_ENABLE_MASK |
                  VAMASK_EDGEFLAG_ENABLE_MASK);

    stride = sizeof(MESHVERTEX);
    if (mflags & MV_NORMAL) 
    {
        gc->vertexArray.mask |= VAMASK_NORMAL_ENABLE_MASK;
        glcltNormalPointer(GL_FLOAT, stride, &(mvBuf[0].normal.x));        
    }

    if (mflags & MV_INDEX) {
    gc->vertexArray.mask |= VAMASK_INDEX_ENABLE_MASK;
        glcltIndexPointer(GL_FLOAT, stride, &(mvBuf[0].color.r));
    } else if (mflags & MV_COLOR) {
    gc->vertexArray.mask |= VAMASK_COLOR_ENABLE_MASK;
        glcltColorPointer(3, GL_FLOAT, stride, &(mvBuf[0].color.r));
    }

    if (texSize) 
    {
        glcltTexCoordPointer(texSize, GL_FLOAT, stride, 
                             &(mvBuf[0].texture.x));
        gc->vertexArray.mask |= VAMASK_TEXCOORD_ENABLE_MASK;
    }

    if (mflags & MV_VERTEX3)
        glcltVertexPointer(3, GL_FLOAT, stride, &(mvBuf[0].vertex.x));
    else
        glcltVertexPointer(4, GL_FLOAT, stride, &(mvBuf[0].vertex.x));
    gc->vertexArray.mask |= VAMASK_VERTEX_ENABLE_MASK;

    if (mode == GL_FILL)
        glcltDrawElements(GL_QUADS, totalPts, GL_UNSIGNED_BYTE, disBuf);
    else
        glcltDrawElements(GL_LINES, totalPts, GL_UNSIGNED_BYTE, disBuf);

    // Execute the command now.  
    // Otherwise, the current states will be messed up.

    glsbAttention();

    // Restore current values.

    if (mflags & MV_NORMAL)
        gc->state.current.normal = currentNormal;
    
    if (mflags & MV_INDEX)
        gc->state.current.userColorIndex = currentColor.r;
    else if (mflags & MV_COLOR)
        gc->state.current.userColor = currentColor;

    if (texSize)
        gc->state.current.texture = currentTexture;

    gc->state.current.edgeTag = currentEdgeFlag;
    gc->vertexArray = currentVertexInfo ;
}


void glcltColor4fv_Eval (__GLfloat *c4)
{
    __GL_SETUP ();
    POLYARRAY *pa;
    POLYDATA *pd;
    // POLYDATA *pdNext;
    
    pa = gc->paTeb; 
	pd = pa->pdNextVertex;					            

    // We are in RGBA mode.
    ASSERTOPENGL (!gc->modes.colorIndexMode, "We should be in RGBA mode\n");

    // Do not update the CurColor pointer 

    // If the color has already been set by a previous glcltColor call,
    // simply, push this color to the next POLYDATA. 
    // This is a COLOR and not an INDEX. 
    if ((pd->flags & POLYDATA_COLOR_VALID) &&
        !(pd->flags & POLYDATA_EVAL_COLOR))
    {
        gc->eval.color.r = pd->colors[0].r;
        gc->eval.color.g = pd->colors[0].g;
        gc->eval.color.b = pd->colors[0].b;
        gc->eval.color.a = pd->colors[0].a;
        gc->eval.accFlags |= EVAL_COLOR_VALID;
    }


    __GL_SCALE_AND_CHECK_CLAMP_RGBA(pd->colors[0].r,                    
                                    pd->colors[0].g,                
                                    pd->colors[0].b,                
                                    pd->colors[0].a,                
                                    gc, pa->flags,                  
                                    c4[0], c4[1], c4[2], c4[3]);       
    pd->flags |= (POLYDATA_COLOR_VALID | POLYDATA_DLIST_COLOR_4 | 
                  POLYDATA_EVAL_COLOR) ;	   
    pa->pdLastEvalColor = pd;
}

void glcltIndexf_Eval (__GLfloat ci)
{
    __GL_SETUP ();
    POLYARRAY *pa;
    POLYDATA *pd;
    
    pa = gc->paTeb; 
	pd = pa->pdNextVertex;					            

    // We are in CI mode.
    ASSERTOPENGL (gc->modes.colorIndexMode, "We should be in CI mode\n");

    // Do not update the CurColor pointer 

    // If the index has already been set by a previous glcltIndex call,
    // simply, push this color to the next POLYDATA. 
    // This is an INDEX and not a COLOR. 
    if ((pd->flags & POLYDATA_COLOR_VALID) &&
        !(pd->flags & POLYDATA_EVAL_COLOR))
    {
        gc->eval.color.r = pd->colors[0].r;
        gc->eval.accFlags |= EVAL_COLOR_VALID;
    }
    
    __GL_CHECK_CLAMP_CI(pd->colors[0].r, gc, pa->flags, ci);	
    pd->flags |= (POLYDATA_COLOR_VALID | POLYDATA_EVAL_COLOR) ;	   
    pa->pdLastEvalColor = pd;
}

void glcltTexCoord1fv_Eval (__GLfloat *t1)
{
    __GL_SETUP ();
    POLYARRAY *pa;
    POLYDATA *pd;
    
    pa = GLTEB_CLTPOLYARRAY();
	pa->flags |= POLYARRAY_TEXTURE1;
	pd = pa->pdNextVertex;					            

    // Do not update the CurTexture pointer 

    if (pd->flags & POLYDATA_TEXTURE_VALID) 
    {
        ASSERTOPENGL (!(pd->flags & POLYDATA_EVAL_TEXCOORD), 
                      "This cannot have been generated by an evaluator\n");
        gc->eval.texture.x = pd->texture.x;
        gc->eval.texture.y = pd->texture.y;
        gc->eval.texture.z = pd->texture.z;
        gc->eval.texture.w = pd->texture.w;
        gc->eval.accFlags |= EVAL_TEXTURE_VALID;
    }

	pd->texture.x = t1[0];
	pd->texture.y = __glZero;
	pd->texture.z = __glZero;
	pd->texture.w = __glOne;
	pd->flags |= (POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE1 |
                  POLYDATA_EVAL_TEXCOORD);
    pa->pdLastEvalTexture = pd;
}

void glcltTexCoord2fv_Eval (__GLfloat *t2)
{
    __GL_SETUP ();
    POLYARRAY *pa;
    POLYDATA *pd;
    
    pa = GLTEB_CLTPOLYARRAY();
	pa->flags |= POLYARRAY_TEXTURE2;
	pd = pa->pdNextVertex;					            

    // Do not update the CurTexture pointer 

    if (pd->flags & POLYDATA_TEXTURE_VALID) 
    {
        ASSERTOPENGL (!(pd->flags & POLYDATA_EVAL_TEXCOORD), 
                      "This cannot have been generated by an evaluator\n");
        gc->eval.texture.x = pd->texture.x;
        gc->eval.texture.y = pd->texture.y;
        gc->eval.texture.z = pd->texture.z;
        gc->eval.texture.w = pd->texture.w;
        gc->eval.accFlags |= EVAL_TEXTURE_VALID;
    }

	pd->texture.x = t2[0];
	pd->texture.y = t2[1];
	pd->texture.z = __glZero;
	pd->texture.w = __glOne;
	pd->flags |= (POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE2 |
                  POLYDATA_EVAL_TEXCOORD);
    pa->pdLastEvalTexture = pd;
}

void glcltTexCoord3fv_Eval (__GLfloat *t3)
{
    __GL_SETUP ();
    POLYARRAY *pa;
    POLYDATA *pd;
    
    pa = GLTEB_CLTPOLYARRAY();
	pa->flags |= POLYARRAY_TEXTURE3;
	pd = pa->pdNextVertex;					            

    if (pd->flags & POLYDATA_TEXTURE_VALID) 
    {
        ASSERTOPENGL (!(pd->flags & POLYDATA_EVAL_TEXCOORD), 
                      "This cannot have been generated by an evaluator\n");
        gc->eval.texture.x = pd->texture.x;
        gc->eval.texture.y = pd->texture.y;
        gc->eval.texture.z = pd->texture.z;
        gc->eval.texture.w = pd->texture.w;
        gc->eval.accFlags |= EVAL_TEXTURE_VALID;
    }

	pd->texture.x = t3[0];
	pd->texture.y = t3[1];
	pd->texture.z = t3[2];
	pd->texture.w = __glOne;
	pd->flags |= (POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE3 | 
                  POLYDATA_EVAL_TEXCOORD) ;
    pa->pdLastEvalTexture = pd;
}

// Do not update the CurTexture pointer
void glcltTexCoord4fv_Eval (__GLfloat *t4)
{
    __GL_SETUP ();
    POLYARRAY *pa;
    POLYDATA *pd;
    
    pa = GLTEB_CLTPOLYARRAY();
	pa->flags |= POLYARRAY_TEXTURE4;
	pd = pa->pdNextVertex;					            

    if (pd->flags & POLYDATA_TEXTURE_VALID)
    {
        ASSERTOPENGL (!(pd->flags & POLYDATA_EVAL_TEXCOORD), 
                      "This cannot have been generated by an evaluator\n");
        gc->eval.texture.x = pd->texture.x;
        gc->eval.texture.y = pd->texture.y;
        gc->eval.texture.z = pd->texture.z;
        gc->eval.texture.w = pd->texture.w;
        gc->eval.accFlags |= EVAL_TEXTURE_VALID;
    }

	pd->texture.x = t4[0];
	pd->texture.y = t4[1];
	pd->texture.z = t4[2];
	pd->texture.w = t4[4];
	pd->flags |= (POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE4 |
                  POLYDATA_EVAL_TEXCOORD);
    pa->pdLastEvalTexture = pd;
}

// We do not update the CurNormal pointer here
void glcltNormal3fv_Eval (__GLfloat *n3)
{
    __GL_SETUP ();
    POLYARRAY *pa;
    POLYDATA *pd;
    
    pa = GLTEB_CLTPOLYARRAY();
	pd = pa->pdNextVertex;					            

    // If the existing normal is not from an evaluator, store it
    // so that it can be set later.

    if (pd->flags & POLYDATA_NORMAL_VALID)
    {
        ASSERTOPENGL (!(pd->flags & POLYDATA_EVAL_NORMAL), 
                      "This cannot have been generated by an evaluator\n");
        
        gc->eval.normal.x = pd->normal.x;
        gc->eval.normal.y = pd->normal.y;
        gc->eval.normal.z = pd->normal.z;
        gc->eval.accFlags |= EVAL_NORMAL_VALID;
    }

	pd->normal.x = n3[0];
	pd->normal.y = n3[1];
	pd->normal.z = n3[2];
	pd->flags |= (POLYDATA_NORMAL_VALID | POLYDATA_EVAL_NORMAL);
    pa->pdLastEvalNormal = pd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\fontextr.c ===
#include "precomp.h"
#pragma hdrstop

#include <commdlg.h>
#include <ptypes32.h>
#include <pwin32.h>
#include <math.h>

#include <GL\gl.h>
#include <GL\glu.h>

#include <imports.h>
#include <types.h>

#include "fontoutl.h"

// Extrusion types
#define EXTR_LINES    0
#define EXTR_POLYGONS 1

// Prim to prim transitions
#define EXTR_LINE_LINE      0
#define EXTR_LINE_CURVE     1
#define EXTR_CURVE_LINE     2
#define EXTR_CURVE_CURVE    3

static const double   CurveCurveCutoffAngle = PI/2.0;
static const double   LineCurveCutoffAngle = PI/4.0;

static BOOL   InitFaceBuf(      EXTRContext *ec );

#ifndef VARRAY
static void   DrawFacePolygons( EXTRContext *ec,
                                FLOAT       z );
#endif

static BOOL   DrawSidePolygons( EXTRContext *ec, 
                                LOOP_LIST   *pLoopList );

static void   DrawPrims(        EXTRContext *ec, 
                                LOOP        *pLoop );

static void   DrawQuads(        PRIM        *pPrim, 
                                FLOAT       zExtrusion );

static void   DrawQuadStrip(    EXTRContext *ec, 
                                PRIM        *pPrim );

static BOOL   AppendToFaceBuf(  EXTRContext *ec, 
                                FLOAT       value );

static BOOL   ReallocFaceBuf(   EXTRContext *ec );


static BOOL   CalculateFaceNormals(   LOOP        *pLoop, 
                                      GLenum      orientation );

static BOOL   CalculateVertexNormals( LOOP        *pLoop );

static void   ConsolidatePrims(       LOOP        *pLoop );

static double PrimNormAngle(          PRIM        *pPrimA, 
                                      PRIM        *pPrimB );

static int    PrimTransition(         PRIM        *pPrevPrim, 
                                      PRIM        *pPrim );

static GLenum LoopOrientation(        LOOP_LIST   *pLoopList );

static LOOP*  GetMaxExtentLoop(       LOOP_LIST   *pLoopList );

double        CalcAngle(              POINT2D     *v1, 
                                      POINT2D     *v2 );

static void   CalcNormal2d(           POINT2D     *p, 
                                      POINT2D     *n,
                                      GLenum      orientation );

static void   Normalize2d(            POINT2D     *n );

static void   AddVectors3d(           POINT3D     *v1, 
                                      POINT3D     *v2, 
                                      POINT3D     *n );

static void   FreeLoopMem(            LOOP        *pLoop );


#ifdef VARRAY

static PFNGLVERTEXPOINTEREXTPROC     glWFOVertexPointerEXT    ;
static PFNGLNORMALPOINTEREXTPROC     glWFONormalPointerEXT    ;
static PFNGLDRAWARRAYSEXTPROC        glWFODrawArraysEXT       ;

static BOOL InitVArray( EXTRContext *ec );
static BOOL VArrayBufSize( EXTRContext *ec, DWORD size );

#endif

/*****************************************************************************
 * exported functions
*****************************************************************************/

/*****************************************************************************
 * extr_Init
 *
 * Initialises extrusion for a wglUseFontOutline call

*****************************************************************************/

EXTRContext *
extr_Init( FLOAT extrusion, INT format )
{
    EXTRContext *ec;

    ec = (EXTRContext *) ALLOCZ(sizeof(EXTRContext) );

    if( !ec )
        return NULL;

    ec->zExtrusion = -extrusion;

    switch( format ) {
        case WGL_FONT_LINES :
            ec->extrType = EXTR_LINES;
#ifdef FONT_DEBUG
            ec->bSidePolys = FALSE;
            ec->bFacePolys = FALSE;
#endif
            break;
        case WGL_FONT_POLYGONS :
            ec->extrType = EXTR_POLYGONS;
#ifdef FONT_DEBUG
            ec->bSidePolys = TRUE;
            ec->bFacePolys = TRUE;
#endif
#ifdef VARRAY
            if( ! InitVArray( ec ) ) {
                FREE( ec );
                return NULL;
            }
#endif
            break;
        default:
            ASSERTOPENGL( FALSE, "extr_Init(): invalid format\n" );
    }
    return ec;
}

/*****************************************************************************
 * extr_Finish
 *
 * Finishes extrusion for a wglUseFontOutline call

*****************************************************************************/

void
extr_Finish( EXTRContext *ec )
{
#ifdef VARRAY
    if( ec->extrType == EXTR_POLYGONS )
        FREE( ec->vaBuf );
#endif
    FREE( ec );
}

/*****************************************************************************
 * extr_PolyInit
 *
 * Initializes the extrusion of a single glyph.
 * If the extrusion is polygonal, it sets up FaceBuf, which holds a buffer
 * of primitives for drawing the faces of the extruded glyphs.
 *
*****************************************************************************/

BOOL extr_PolyInit( EXTRContext *ec )
{
    if( ec->extrType == EXTR_LINES )
        return WFO_SUCCESS;

    ec->FaceBuf = (FLOAT *) NULL;
    if( !InitFaceBuf( ec ) ||
        !AppendToFaceBuf( ec, 0.0f) ) // primitive count at FaceBuf[0]
        return WFO_FAILURE;

    // initialize error flag
    ec->TessErrorOccurred = 0;

    return WFO_SUCCESS;
}

/*****************************************************************************
 * extr_PolyFinish
 *
 * Cleans up stuff from processing a single glyph

*****************************************************************************/

void extr_PolyFinish(  EXTRContext *ec )
{
    if( ec->extrType == EXTR_LINES )
        return;

    if( ec->FaceBuf ) {
        FREE( ec->FaceBuf );
        ec->FaceBuf = (FLOAT *) NULL;
    }
}

/*****************************************************************************
 * extr_DrawLines
 *
 * Draws the lines in a glyph loop for Line extrusion

*****************************************************************************/

void extr_DrawLines( EXTRContext *ec, LOOP_LIST *pLoopList )
{
    DWORD   nLoops, nVerts;
    POINT2D *p;
    LOOP    *pLoop;

    nLoops = pLoopList->nLoops;
    pLoop = pLoopList->LoopBuf;
    for( ; nLoops; nLoops--, pLoop++ ) {

        // Draw the back face loop

#ifdef FONT_DEBUG
        DrawColorCodedLineLoop( pLoop, ec->zExtrusion );
#else
        glBegin(GL_LINE_LOOP);

            nVerts = pLoop->nVerts - 1; // skip last point
            p = pLoop->VertBuf;
            for ( ; nVerts; nVerts--, p++ ) {
                glVertex3f( p->x, p->y, ec->zExtrusion );
            }

        glEnd();
#endif

        // Draw the lines along the sides

#ifdef FONT_DEBUG
        glColor3d( 0.0, 0.0, 1.0 );
#endif

        glBegin(GL_LINES);

            nVerts = pLoop->nVerts - 1; // skip last point
            p = pLoop->VertBuf;
            for( ; nVerts; nVerts--, p++ ) {
                glVertex2fv( (GLfloat *) p);
                glVertex3f( p->x, p->y, ec->zExtrusion );
            }

        glEnd();
    }
}

/*****************************************************************************
 * extr_glBegin
 *
 * Tesselation callback for glBegin.
 * Buffers data into FaceBuf
 *
*****************************************************************************/

void CALLBACK
extr_glBegin( GLenum primType, void *data )
{
    EXTRContext *ec = ((OFContext *)data)->ec;

    // buffer face data
    ec->FaceBuf[0] += 1.0f; // increment prim counter
    ec->FaceVertexCountIndex = ec->FaceBufIndex+1; // mark vertex count index

    if( !AppendToFaceBuf( ec, (FLOAT) primType ) ||  // enter prim type
        !AppendToFaceBuf( ec, 0.0f ) )               // vertex count
        ec->TessErrorOccurred = GLU_OUT_OF_MEMORY;
}

/*****************************************************************************
 * extr_glEnd
 *
 * Tesselation callback for glEnd.
 * Noop, since we are just tracking the tesselation at this point.
 *
*****************************************************************************/

void CALLBACK
extr_glEnd( void )
{
}

/*****************************************************************************
 * extr_glVertex
 *
 * Tesselation callback for glVertex.
 * Buffers data into FaceBuf
 *
*****************************************************************************/

void CALLBACK
extr_glVertex( GLfloat *v, void *data )
{
    EXTRContext *ec = ((OFContext *)data)->ec;

    // put vertex in face buffer
    if( !AppendToFaceBuf( ec, v[0]) || !AppendToFaceBuf( ec, v[1]) )
        ec->TessErrorOccurred = GLU_OUT_OF_MEMORY;

    // increment vertex counter
    ec->FaceBuf[ec->FaceVertexCountIndex] += 1.0f;
}


/*****************************************************************************
 * extr_DrawPolygons
 *
 * Draws the side and face polygons of a glyph for polygonal extrusion
 * Gets polygon information from LineBuf, which was created during
 * MakeLinesFromGlyph().

*****************************************************************************/

BOOL
extr_DrawPolygons( EXTRContext *ec, LOOP_LIST *pLoopList ) 
{
#ifdef FONT_DEBUG
    if( ec->bSidePolys )
        if( !DrawSidePolygons( ec, pLoopList ) ) {
            return WFO_FAILURE;
        }

    if( ec->bFacePolys ) {
        DrawFacePolygons( ec, 0.0f );              // front face
        DrawFacePolygons( ec, ec->zExtrusion );    // back face
    }
#else
    if( !DrawSidePolygons( ec, pLoopList ) )
        return WFO_FAILURE;

    DrawFacePolygons( ec, 0.0f );              // front face
    DrawFacePolygons( ec, ec->zExtrusion );    // back face
#endif

    return WFO_SUCCESS;
}


/*****************************************************************************
 * internal functions
*****************************************************************************/


/*****************************************************************************
 * DrawSidePolygons
 *
 * Draw the side prims, using several passes on each prim loop:
 *  1) Calculate face normals for all the prims
 *  2) Consolidate prims if possible
 *  3) Calculate vertex normals for curve prims
 *  4) Draw the prims
 * Side effects: sets glFrontFace 

*****************************************************************************/

static BOOL
DrawSidePolygons( EXTRContext *ec,
                  LOOP_LIST   *pLoopList )
{
    DWORD nLoops;
    LOOP *pLoop;
    GLenum orientation;

    nLoops = pLoopList->nLoops;
    if( !nLoops )
        return WFO_SUCCESS;

    /* 
     * Determine orientation of loop
     */
    orientation = LoopOrientation( pLoopList );

    glFrontFace( orientation );

    pLoop = pLoopList->LoopBuf;
    for( ; nLoops; nLoops--, pLoop++ ) {

        // Calculate face normals
        if( !CalculateFaceNormals( pLoop, orientation ) )
            return WFO_FAILURE;

        // Consolidate list of prims
        ConsolidatePrims( pLoop );

        // Calculate vertex normals
        if( !CalculateVertexNormals( pLoop ) ) {
            FreeLoopMem( pLoop ); // free mem alloc'd by CalculateFaceNormals
            return WFO_FAILURE;
        }
    
        DrawPrims( ec, pLoop );

        // Free memory allocated during loop processing
        FreeLoopMem( pLoop );
    }
    return WFO_SUCCESS;
}

/*****************************************************************************
 * FreeLoopMem
 *
 * Frees up memory associated with each prim loop

*****************************************************************************/

static void 
FreeLoopMem( LOOP *pLoop )
{
    PRIM *pPrim;

    if( !pLoop )
        return;

    if( pLoop->FNormBuf )
        FREE( pLoop->FNormBuf );
    if( pLoop->VNormBuf )
        FREE( pLoop->VNormBuf );
}

/*****************************************************************************
 * DrawPrims
 *
 * Draws a loop of Prims

*****************************************************************************/

static void 
DrawPrims( EXTRContext *ec, LOOP *pLoop )
{
    PRIM  *pPrim;
    DWORD nPrims;

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;

    for( ; nPrims; nPrims--, pPrim++ ) {

        switch( pPrim->primType ) {
            case PRIM_LINE:
                DrawQuads( pPrim, ec->zExtrusion ); 
                break;

            case PRIM_CURVE:
                DrawQuadStrip( ec, pPrim ); 
                break;
        }
    }
}


//#define EXTRANORMAL 1

/*****************************************************************************
 * DrawQuads
 *
 * Draws independent quads of a PRIM.

*****************************************************************************/

static void
DrawQuads( PRIM *pPrim, FLOAT zExtrusion )
{
    POINT2D *p;
    POINT3D *pNorm;
    ULONG quadCount;

    quadCount = pPrim->nVerts - 1;

    glBegin( GL_QUADS );

        p = pPrim->pVert;
        pNorm = pPrim->pFNorm;

        while( quadCount-- ) {
            Normalize2d( (POINT2D *) pNorm );     // normalize
            glNormal3fv( (GLfloat *) pNorm );

            glVertex3f( p->x, p->y, 0.0f );
            glVertex3f( p->x, p->y, zExtrusion );
            p++;
#ifdef EXTRANORMAL
            glNormal3fv( (GLfloat *) pNorm );
#endif
            glVertex3f( p->x, p->y, zExtrusion );
            glVertex3f( p->x, p->y, 0.0f );
            pNorm++;
        }

    glEnd();
}

/*****************************************************************************
 * DrawQuadStrip
 *
 * Draws a quadstrip from a PRIM

*****************************************************************************/

static void
DrawQuadStrip( EXTRContext *ec, PRIM *pPrim )
{
#ifndef VARRAY
    POINT3D *pNorm;
    POINT2D *p;
    ULONG   nVerts;


    glBegin( GL_QUAD_STRIP );

        // initialize pointers, setup
        nVerts = pPrim->nVerts;
        p = pPrim->pVert;
        pNorm = pPrim->pVNorm;

        while( nVerts-- ) {
            glNormal3fv( (GLfloat *) pNorm );
            glVertex3f( p->x, p->y, 0.0f );
#ifdef EXTRANORMAL
            glNormal3fv( (GLfloat *) pNorm );
#endif
            glVertex3f( p->x, p->y, ec->zExtrusion );

            // reset pointers
            p++;  // next point
            pNorm++;  // next vertex normal
        }

    glEnd();
#else
    POINT3D *n;
    POINT2D *p;
    ULONG   nVerts;
    ULONG   i;
    FLOAT   *pDst, *pVert, *pNorm;

    nVerts = pPrim->nVerts;

    // For every vertex in prim, need in varray buf: 2 verts, 2 normals
    if( !VArrayBufSize( ec, nVerts * 2 * 2 * 3) )
        return; // nothing drawn
 
    // setup vertices

    p = pPrim->pVert;
    pVert = pDst = ec->vaBuf;
    for( i = 0; i < nVerts; i++, p++ ) {
        *pDst++ = p->x;
        *pDst++ = p->y;
        *pDst++ = 0.0f;
        *pDst++ = p->x;
        *pDst++ = p->y;
        *pDst++ = ec->zExtrusion;
    }

    // setup normals

    n = pPrim->pVNorm;
    pNorm = pDst;
    for( i = 0; i < nVerts; i++, n++ ) {
        *( ((POINT3D *) pDst)++ ) = *n;
        *( ((POINT3D *) pDst)++ ) = *n;
    }

    // send it
    glEnable(GL_NORMAL_ARRAY_EXT);
    glWFOVertexPointerEXT(3, GL_FLOAT, 0, nVerts*2, pVert );
    glWFONormalPointerEXT(   GL_FLOAT, 0, nVerts*2, pNorm );
    glWFODrawArraysEXT( GL_QUAD_STRIP, 0, nVerts*2);
    glDisable(GL_NORMAL_ARRAY_EXT);
#endif
}



/*****************************************************************************
 * DrawFacePolygons
 *
 * Draws the front or back facing polygons of a glyph.
 * If z is 0.0, the front face of the glyph is drawn, otherwise the back
 * face is drawn.

*****************************************************************************/
#ifdef VARRAY
void 
#else
static void 
#endif
DrawFacePolygons( EXTRContext *ec, FLOAT z )
{
    ULONG primCount, vertexCount;
    GLenum primType;
    FLOAT *FaceBuf = ec->FaceBuf;
    FLOAT *p;
#ifdef VARRAY
    POINT3D normal = {0.0f, 0.0f, 0.0f};
    FLOAT *pVert, *pNorm, *pDst;
    ULONG i;
#endif

    if( z == 0.0f ) {
        glNormal3f( 0.0f, 0.0f, 1.0f );
        glFrontFace( GL_CCW );
    } else {
        glNormal3f( 0.0f, 0.0f, -1.0f );
        glFrontFace( GL_CW );
    }

    primCount = (ULONG) FaceBuf[0];
    p = &FaceBuf[1];

#ifndef VARRAY
    while( primCount-- ) {
    
        primType = (GLenum) *p++;
        vertexCount = (ULONG) *p++;

        glBegin( primType ); 

        for( ; vertexCount; vertexCount--, p+=2 )
            glVertex3f( p[0], p[1], z );

        glEnd();
    }
#else
    if( z == 0.0f )
        normal.z = 1.0f;
    else
        normal.z = -1.0f;

    while( primCount-- ) {
    
        primType = (GLenum) *p++;
        vertexCount = (ULONG) *p++;

        if( !VArrayBufSize( ec, vertexCount * 3 ) )
            return; // nothing drawn
 
        pVert = pDst = ec->vaBuf;

        // put vertices into varray buf
        for( i = 0; i < vertexCount; i++, p+=2 ) {
            *pDst++ = p[0];
            *pDst++ = p[1];
            *pDst++ = z;
        }

        glWFOVertexPointerEXT(3, GL_FLOAT, 0, vertexCount, pVert );
        glWFODrawArraysEXT( primType, 0, vertexCount );
    }
#endif
}

/*****************************************************************************
 * ConsolidatePrims
 *
 *  Consolidate a loop of prims.
 *  Go through list of prims, consolidating consecutive Curve and Line prims
 *  When 2 prims are consolidated into one, the first prim is set to
 *  null by setting it's nVerts=0.  The second prim get's the first's stuff.
 *  If joining occured, the array of prims is compacted at the end.
 *

*****************************************************************************/

static void
ConsolidatePrims( LOOP *pLoop )
{
    DWORD nPrims, nJoined = 0;
    BOOL bJoined; 
    PRIM *pPrim, *pPrevPrim;
    int trans;
    double angle;

    nPrims = pLoop->nPrims;
    if( nPrims < 2 )
        return;

    pPrim = pLoop->PrimBuf;
    pPrevPrim = pPrim++;

    nPrims--; // nPrim-1 comparisons
    for( ; nPrims; nPrims--, pPrevPrim = pPrim++ ) {

        bJoined = FALSE;
        trans = PrimTransition( pPrevPrim, pPrim );
        switch( trans ) {
            case EXTR_LINE_LINE:
                // always consolidate 2 lines
                bJoined = TRUE;
                break;

            case EXTR_LINE_CURVE:
                break;

            case EXTR_CURVE_LINE:
                break;

            case EXTR_CURVE_CURVE:
                /*
                 * Join the prims if angle_between_norms < cutoff_angle
                 */
                angle = PrimNormAngle( pPrevPrim, pPrim );
                if( angle < CurveCurveCutoffAngle ) {
                    bJoined = TRUE;
                }
                break;
        }
        if( bJoined ) {
            // nullify the prev prim - move all data to current prim
            pPrim->nVerts += (pPrevPrim->nVerts - 1);
            pPrim->pVert = pPrevPrim->pVert;
            pPrim->pFNorm = pPrevPrim->pFNorm;
            pPrevPrim->nVerts = 0;
            nJoined++;
        }
    }

    if( nJoined ) {
        // one or more prims eliminated - compact the list

        nPrims = pLoop->nPrims;
        pPrim = pLoop->PrimBuf;
        // set new nPrims value
        pLoop->nPrims = nPrims - nJoined;
        nJoined = 0;  // nJoined now used as counter
        for( ; nPrims; nPrims--, pPrim++ ) {
            if( pPrim->nVerts == 0 ) {
                nJoined++;
                continue;
            }
            *(pPrim-nJoined) = *pPrim;
        }
    }
}

/*****************************************************************************
 * PrimTransition
 *
 * Given two adjacent prims, returns a code based on prim-type transition.
 *
*****************************************************************************/

static int
PrimTransition( PRIM *pPrevPrim, PRIM *pPrim )
{
    int trans;

    if( pPrevPrim->primType == PRIM_LINE ) {
        if( pPrim->primType == PRIM_LINE )
            trans = EXTR_LINE_LINE;
        else
            trans = EXTR_LINE_CURVE;
    } else {
        if( pPrim->primType == PRIM_LINE )
            trans = EXTR_CURVE_LINE;
        else
            trans = EXTR_CURVE_CURVE;
    }

    return trans;
}

/*****************************************************************************
 * LoopOrientation
 *
 * Check for glyphs that have incorrectly specified the contour direction (for
 * example, many of the Wingding glyphs).  We do this by first determining
 * the loop in the glyph that has the largest extent.  We then make the
 * assumption that this loop is external, and check it's orientation.  If
 * the orientation is CCW (non-default), we have to set the orientation to
 * GL_CCW in the extrusion context, so that normals will be generated
 * correctly.

* The method used here may fail for any loops that intersect themselves.
* This will happen if the loops created by the intersections are in the opposite
* direction to the main loop (if 1 such extra loop exists, then the sum of
* angles around the entire contour will be 0 - we put in a check for this,
* and always default to CW in this case)
*
* Note that this method *always* works for properly designed TruyType glyphs.
* From the TrueType font spec "The direction of the curves has to be such that,
* if the curve is followed in the direction of increasing point numbers, the
* black space (the filled area) will always be to the right."  So this means
* that the outer loop should always be CW.
* 
*****************************************************************************/

// These macros handle the rare case of a self-intersecting, polarity-reversing
// loop as explained above.  (Observed in animals1.ttf)  Note that will only
// catch some cases.
#define INTERSECTING_LOOP_WORKAROUND 1
#define NEAR_ZERO( fAngle ) \
    ( fabs(fAngle) < 0.00001 )

static GLenum
LoopOrientation( LOOP_LIST *pLoopList )
{
    DWORD  nLoops, nVerts;
    double angle = 0;
    POINT2D *p1, *p2, v1, v2;
    LOOP *pMaxLoop;

    nLoops = pLoopList->nLoops;
    if( !nLoops )
        return GL_CW; // default value

    // determine which loop has the maximum extent

    pMaxLoop = GetMaxExtentLoop( pLoopList );

    nVerts = pMaxLoop->nVerts;
    if( nVerts < 3 )
        return GL_CW;  // can't determine angle

    p1 = pMaxLoop->VertBuf + nVerts - 2;  // 2nd to last point
    p2 = pMaxLoop->VertBuf; // first point

    /* 
     * Accumulate relative angle between consecutive line segments along
     * the loop - this will tell us the loop's orientation.
     */
    v1.x = p2->x - p1->x;
    v1.y = p2->y - p1->y;
    nVerts--; // n-1 comparisons

    for( ; nVerts; nVerts-- ) {
        // calc next vector
        p1 = p2++;
        v2.x = p2->x - p1->x;
        v2.y = p2->y - p1->y;
        angle += CalcAngle( &v1, &v2 );
        v1 = v2;
    }

#ifdef INTERSECTING_LOOP_WORKAROUND
    if( NEAR_ZERO( angle ) ) {
        DBGPRINT( "wglUseFontOutlines:LoopOrientation : Total loop angle is zero, assuming CW orientation\n" );
        return GL_CW;
    }
#endif

    if( angle > 0.0 )
        return GL_CCW;
    else
        return GL_CW;
}


/*****************************************************************************
 * GetMaxExtentLoop
 *
 * Determine which of the loops in a glyph description has the maximum
 * extent, and return a ptr to it.  We check extents in the x direction.

*****************************************************************************/

LOOP *
GetMaxExtentLoop( LOOP_LIST *pLoopList )
{
    DWORD nLoops, nVerts;
    FLOAT curxExtent, xExtent=0.0f, x, xMin, xMax;
    LOOP  *pMaxLoop, *pLoop;
    POINT2D *p;

    pMaxLoop = pLoop = pLoopList->LoopBuf;

    nLoops = pLoopList->nLoops;
    if( nLoops == 1 )
        // just one loop - no comparison required
        return pMaxLoop;

    for( ; nLoops; nLoops--, pLoop++ ) {
        nVerts = pLoop->nVerts;
        p = pLoop->VertBuf;
        // use x value of first point as reference
        x = p->x;
        xMin = xMax = x;
        // compare x's of rest of points
        for( ; nVerts; nVerts--, p++ ) {
            x = p->x;
            if( x < xMin )
                xMin = x;
            else if( x > xMax )
                xMax = x;
        }
        curxExtent = xMax - xMin;
        if( curxExtent > xExtent ) {
            xExtent = curxExtent;
            pMaxLoop = pLoop;
        }
    }
    return pMaxLoop;
}

/*****************************************************************************
 * CalcAngle
 *
 * Determine the signed angle between 2 vectors.  The angle is measured CCW
 * from vector 1 to vector 2.

*****************************************************************************/

double
CalcAngle( POINT2D *v1, POINT2D *v2 )
{
    double angle1, angle2, angle;

    // Calculate absolute angle of each vector

    /* Check for (0,0) vectors - this shouldn't happen unless 2 consecutive
     * vertices in the VertBuf are equal.
     */
    if( (v1->y == 0.0f) && (v1->x == 0.0f) )
        angle1 = 0.0f;
    else
        angle1 = __GL_ATAN2F( v1->y, v1->x ); // range: -PI to PI

    if( (v2->y == 0.0f) && (v2->x == 0.0f) )
        angle1 = 0.0f;
    else
        angle2 = __GL_ATAN2F( v2->y, v2->x ); // range: -PI to PI

    // Calculate relative angle between vectors
    angle = angle2 - angle1;        // range:  -2*PI to 2*PI

    // force angle to be in range -PI to PI
    if( angle < -PI  )
        angle += TWO_PI;
    else if( angle > PI )
        angle -= TWO_PI;

    return angle;
}

/*****************************************************************************
 * CalculateFaceNormals
 *
 * Calculate face normals for a prim loop.
 * The normals are NOT normalized.
 *
*****************************************************************************/

static BOOL
CalculateFaceNormals( LOOP      *pLoop, 
                      GLenum    orientation )
{
    DWORD nPrims;
    ULONG nQuads = 0;
    POINT2D *p;
    POINT3D *pNorm;
    PRIM *pPrim;

    // Need 1 normal per vertex
    pNorm = (POINT3D*) ALLOC(pLoop->nVerts*sizeof(POINT3D));
    pLoop->FNormBuf = pNorm;
    if( !pNorm )
        return WFO_FAILURE;

    // Calculate the face normals

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;
    for( ; nPrims; nPrims--, pPrim++ ) {
        pPrim->pFNorm = pNorm;   // ptr to each prims norms
        nQuads = pPrim->nVerts - 1;
        p = pPrim->pVert;
        for( ; nQuads; nQuads--, p++, pNorm++ ) {
            CalcNormal2d( p, (POINT2D *) pNorm, orientation );
            pNorm->z = 0.0f;    // normals in xy plane
        }
    }
    return WFO_SUCCESS;
}

/*****************************************************************************
 * CalculateVertexNormals
 *
 * Calculate vertex normals for a prim loop, only for those prims that
 * are of type 'CURVE'.
 * Uses previously calculated face normals to generate the vertex normals.
 * Allocates memory for the normals by calculating memory requirements on
 * the fly. 
 * The normals are normalized.
 * Handles closing of loops properly.
 * 
*****************************************************************************/

static BOOL
CalculateVertexNormals( LOOP *pLoop )
{
    ULONG nPrims, nVerts = 0;
    POINT3D *pVNorm, *pFNorm, *pDstNorm;
    PRIM    *pPrim, *pPrevPrim;
    double angle;
    GLenum trans;

    // How much memory we need for the normals?

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;
    for( ; nPrims; nPrims--, pPrim++ ) {
        if( pPrim->primType == PRIM_CURVE )
            nVerts += pPrim->nVerts;
    }

    if( !nVerts )
        return WFO_SUCCESS;

    // XXX: could just allocate 2*nVerts of mem for the normals
    pVNorm = (POINT3D*) ALLOC( nVerts*sizeof(POINT3D) );
    pLoop->VNormBuf = pVNorm;
    if( !pVNorm )
        return WFO_FAILURE;

    // First pass: calculate normals for all vertices of Curve prims

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;
    for( ; nPrims; nPrims--, pPrim++ ) {

        if( pPrim->primType == PRIM_LINE )
            continue;

        nVerts = pPrim->nVerts;
        pPrim->pVNorm = pVNorm;   // ptr to each prims norms
        pFNorm = pPrim->pFNorm;   // ptr to face norms already calculated

        // set the first vnorm to the fnorm
        *pVNorm = *pFNorm;

        Normalize2d( (POINT2D *) pVNorm );         // normalize it
        nVerts--;  // one less vertex to worry about
        pVNorm++;  // advance ptrs
        pFNorm++;

        nVerts--;  // do last vertex after this loop
        for( ; nVerts; nVerts--, pFNorm++, pVNorm++ ) {
            // use neighbouring face normals to get vertex normal
            AddVectors3d( pFNorm, pFNorm-1, pVNorm );
            Normalize2d( (POINT2D *) pVNorm );      // normalize it
        }

        // last vnorm is same as fnorm of *previous* vertex
        *pVNorm = *(pFNorm-1);
        Normalize2d( (POINT2D *) pVNorm );         // normalize it

        pVNorm++;  // next available space in vnorm buffer
    }

    // Second pass: calculate normals on prim boundaries

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;
    // set pPrevPrim to last prim in loop
    pPrevPrim = pLoop->PrimBuf + pLoop->nPrims - 1;

    for( ; nPrims; nPrims--, pPrevPrim = pPrim++ ) {
        trans = PrimTransition( pPrevPrim, pPrim );
        angle = PrimNormAngle( pPrevPrim, pPrim );

        switch( trans ) {
            case EXTR_LINE_CURVE:
                if( angle < LineCurveCutoffAngle ) {
                    // set curve's first vnorm to line's last fnorm
                    *(pPrim->pVNorm) = 
                                *(pPrevPrim->pFNorm + pPrevPrim->nVerts -2);
                    Normalize2d( (POINT2D *) pPrim->pVNorm );
                }
                break;

            case EXTR_CURVE_LINE:
                if( angle < LineCurveCutoffAngle ) {
                    // set curve's last vnorm to line's first fnorm
                    pDstNorm = pPrevPrim->pVNorm + pPrevPrim->nVerts - 1;
                    *pDstNorm = *(pPrim->pFNorm);
                    Normalize2d( (POINT2D *) pDstNorm );
                }
                break;

            case EXTR_CURVE_CURVE:
                if( angle < CurveCurveCutoffAngle ) {
                    // average normals of adjoining faces, and
                    // set last curve's first vnorm to averaged normal
                    AddVectors3d( pPrevPrim->pFNorm + pPrevPrim->nVerts - 2, 
                                  pPrim->pFNorm, 
                                  pPrim->pVNorm );
                    Normalize2d( (POINT2D *) pPrim->pVNorm );
                    // set first curve's last vnorm to averaged normal
                    *(pPrevPrim->pVNorm + pPrevPrim->nVerts - 1) =
                                                        *(pPrim->pVNorm); 
                }
                break;
            case EXTR_LINE_LINE:
                // nothing to do
                break;
        }

    }
    return WFO_SUCCESS;
}


/*****************************************************************************
 * PrimNormAngle
 *
 *  Determine angle between the last face's normal of primA, and the first
 *  face's normal of primB.
 *
 *  The result should be an angle between -PI and PI.
 *  For now, we only care about the relative angle, so we return the
 *  absolute value of the signed angle between the faces.
 *
*****************************************************************************/

static double
PrimNormAngle( PRIM *pPrimA, PRIM *pPrimB )
{
    double angle;
    // last face norm at index (nvert-2)
    POINT3D *normA = pPrimA->pFNorm + pPrimA->nVerts - 2;
    POINT3D *normB = pPrimB->pFNorm;

    angle = CalcAngle( (POINT2D *) normA, (POINT2D *) normB );

    return fabs(angle); // don't care about sign of angle for now
}


/*****************************************************************************
 * InitFaceBuf
 * 
 * Initializes FaceBuf and its associated size and current-element
 * counters.
 * 
*****************************************************************************/

static BOOL
InitFaceBuf( EXTRContext *ec )
{
    DWORD initSize = 1000;

    if( !(ec->FaceBuf = 
        (FLOAT*) ALLOC(initSize*sizeof(FLOAT))) )
        return WFO_FAILURE;
    ec->FaceBufSize = initSize;
    ec->FaceBufIndex = 0;
    return WFO_SUCCESS;
}


/*****************************************************************************
 * AppendToFaceBuf
 *
 * Appends one floating-point value to the FaceBuf array.

*****************************************************************************/

static BOOL
AppendToFaceBuf(EXTRContext *ec, FLOAT value)
{
    if (ec->FaceBufIndex >= ec->FaceBufSize)
    {
       if( !ReallocFaceBuf( ec ) )
            return WFO_FAILURE;
    }
    ec->FaceBuf[ec->FaceBufIndex++] = value;
    return WFO_SUCCESS;
}

/*****************************************************************************
 * ReallocBuf
 *
 * Increases size of FaceBuf by a constant value.
 *
*****************************************************************************/

static BOOL
ReallocFaceBuf( EXTRContext *ec )
{
    FLOAT* f;
    DWORD increase = 1000; // in floats

    f = (FLOAT*) REALLOC(ec->FaceBuf, 
        (ec->FaceBufSize += increase)*sizeof(FLOAT));
    if (!f)
        return WFO_FAILURE;
    ec->FaceBuf = f;
    return WFO_SUCCESS;
}


/*****************************************************************************
 * CalcNormal2d
 *
 * Calculates the 2d normal of a 2d vector, by rotating the vector:
 * - CCW 90 degrees for CW contours.
 * - CW 90 degrees for CCW contours.
 * Does not normalize.
 *
*****************************************************************************/

static void
CalcNormal2d( POINT2D *p, POINT2D *n, GLenum orientation )
{
    static POINT2D v;

    v.x = (p+1)->x - p->x;
    v.y = (p+1)->y - p->y;
    if( orientation == GL_CW ) {
        n->x = -v.y;
        n->y = v.x;
    } else {
        n->x = v.y;
        n->y = -v.x;
    }
}


/*****************************************************************************
 * Normalize2d
 *
 * Normalizes a 2d vector
 *
*****************************************************************************/

static void
Normalize2d( POINT2D *n )
{
    float len;

    len = (n->x * n->x) + (n->y * n->y);
    if (len > ZERO_EPS)
        len = 1.0f / __GL_SQRTF(len);
    else
        len = 1.0f;

    n->x *= len;
    n->y *= len;
}

/*****************************************************************************
 * AddVectors3d
 *
 * Adds two 3d vectors.
 *
*****************************************************************************/

static void
AddVectors3d( POINT3D *v1, POINT3D *v2, POINT3D *n )
{
    n->x = v1->x + v2->x;
    n->y = v1->y + v2->y;
    n->z = v1->z + v2->z;
}

#ifdef VARRAY
static BOOL
InitVArray( EXTRContext *ec )
{
    int size = 500;

    // set up global buffer
    ec->vaBufSize = size;
    ec->vaBuf =  (FLOAT*) ALLOC( size*sizeof(FLOAT) );
    if( !ec->vaBuf ) {
        return WFO_FAILURE;
    }

    // set up and enable ptrs
    glWFOVertexPointerEXT     = (PFNGLVERTEXPOINTEREXTPROC       )wglGetProcAddress("glVertexPointerEXT");
    glWFONormalPointerEXT     = (PFNGLNORMALPOINTEREXTPROC       )wglGetProcAddress("glNormalPointerEXT");
    glWFODrawArraysEXT        = (PFNGLDRAWARRAYSEXTPROC          )wglGetProcAddress("glDrawArraysEXT");

    if(    (glWFOVertexPointerEXT == NULL)
        || (glWFONormalPointerEXT == NULL)
        || (glWFODrawArraysEXT == NULL) ) {
        FREE( ec->vaBuf );
        return WFO_FAILURE;
    }
        
    glEnable(GL_VERTEX_ARRAY_EXT);
    return WFO_SUCCESS;
}

/*****************************************************************************
 *
 * Size is in floats

 *
*****************************************************************************/

static BOOL
VArrayBufSize( EXTRContext *ec, DWORD size )
{
    if( size > ec->vaBufSize )
    {
        FLOAT *f;

        f = (FLOAT*) REALLOC( ec->vaBuf, size*sizeof(FLOAT));
        if( !f )
            return WFO_FAILURE;
        ec->vaBuf = f;
        ec->vaBufSize = size;
    }
    return WFO_SUCCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\fontoutl.c ===
#include "precomp.h"
#pragma hdrstop

#include <math.h>
#include <GL\glu.h>

#include "batchinf.h"
#include "glteb.h"
#include "glapi.h"
#include "glsbcltu.h"

#include "fontoutl.h"

static OFContext* CreateOFContext(      HDC         hdc,
                                        FLOAT       chordalDeviation,
                                        FLOAT       extrusion, 
                                        int         type,
                                        BOOL        bUnicode );

static BOOL  ScaleFont(                 HDC         hdc, 
                                        OFContext*  ofc,
                                        BOOL        bUnicode );

static void  DestroyOFContext(          HDC         hdc,
                                        OFContext*  ofc );

static BOOL  DrawGlyph(                 OFContext*  ofc );

static BOOL  MakeDisplayListFromGlyph(  OFContext*     ofc, 
                                        DWORD          listName,
                                        LPGLYPHMETRICS glyphMetrics );


static BOOL  MakeLinesFromArc(          OFContext*  ofc, 
                                        LOOP*       pLoop,
                                        PRIM*       pPrim,
                                        POINT2D     p0,
                                        POINT2D     p1,
                                        POINT2D     p2,
                                        FLOAT       chordalDeviationSquared);

static LOOP_LIST* MakeLinesFromGlyph(   OFContext*  ofc );

static BOOL  MakeLinesFromTTLine(       OFContext*  ofc, 
                                        LOOP*       pLoop,
                                        PRIM*       pPrim,
                                        UCHAR**     pp,
                                        WORD        pointCount );

static BOOL  MakeLinesFromTTPolycurve(  OFContext*  ofc, 
                                        LOOP*       pLoop,
                                        UCHAR**     pp );

static BOOL  MakeLinesFromTTPolygon(    OFContext*  ofc, 
                                        LOOP_LIST*  pLoopList,
                                        UCHAR**     pp );

static BOOL  MakeLinesFromTTQSpline(    OFContext*  ofc, 
                                        LOOP*       pLoop,
                                        PRIM*       pPrim,
                                        UCHAR**     pp,
                                        WORD        pointCount );

static void CALLBACK TessError(         GLenum      error,
                                        void        *data);

static void CALLBACK TessCombine(       GLdouble    coord[3], 
                                        POINT2D*    data[4], 
                                        GLfloat     w[4],
                                        POINT2D**   dataOut,
                                        void        *userData);

static void FreeCombinePool(            MEM_POOL    *combinePool );

static void ApplyVertexFilter(          LOOP_LIST   *pLoopList );

static void CheckRedundantVertices(     LOOP*       pLoop );

static BOOL PointsColinear(             POINT2D     *p1, 
                                        POINT2D     *p2, 
                                        POINT2D     *p3 ); 

static FLOAT      GetFixed(             UCHAR**     p );

static LOOP_LIST* InitLoopBuf(          void );

static LOOP*      NewLoop(              LOOP_LIST   *Loops, 
                                        POINT2D     *pFirstPoint );

static void       FreeLoopList(         LOOP_LIST   *pLoopList );

static PRIM*      NewPrim(              LOOP        *pLoop, 
                                        DWORD       primType );

static void       CalcVertPtrs(         LOOP        *pLoop );

static BOOL       AppendToVertBuf(      LOOP*       pLoop,
                                        PRIM*       pPrim,
                                        POINT2D     *p );


// macros to access data from byte streams:

// get WORD from byte stream, increment stream ptr by WORD
#define GetWord( p ) \
    ( *( ((UNALIGNED WORD *) *p)++ ) ) 

// get DWORD from byte stream, increment stream ptr by DWORD
#define GetDWord( p ) \
    ( *( ((UNALIGNED DWORD *) *p)++ ) ) 

// get signed word (SHORT) from byte stream, increment stream ptr by SHORT
#define GetSignedWord( p ) \
    ( *( ((UNALIGNED SHORT *) *p)++ ) ) 


#define POINT2DEQUAL( p1, p2 ) \
    ( (p1->x == p2->x) && (p1->y == p2->y) )

/******************************Public*Routine******************************\
* wglUseFontOutlinesA
* wglUseFontOutlinesW
*
* Stubs that call wglUseFontOutlinesAW with the bUnicode flag set
* appropriately.
*
\**************************************************************************/

BOOL WINAPI
wglUseFontOutlinesAW( HDC   hDC,
                      DWORD first,
                      DWORD count,
                      DWORD listBase,
                      FLOAT chordalDeviation,
                      FLOAT extrusion,
                      int   format,
                      LPGLYPHMETRICSFLOAT lpgmf,
                      BOOL  bUnicode );

BOOL WINAPI
wglUseFontOutlinesA(  HDC   hDC,
                      DWORD first,
                      DWORD count,
                      DWORD listBase,
                      FLOAT chordalDeviation,
                      FLOAT extrusion,
                      int   format,
                      LPGLYPHMETRICSFLOAT lpgmf )
{
    return wglUseFontOutlinesAW( hDC, first, count, listBase, chordalDeviation,
                                 extrusion, format, lpgmf, FALSE );
}

BOOL WINAPI
wglUseFontOutlinesW(  HDC   hDC,
                      DWORD first,
                      DWORD count,
                      DWORD listBase,
                      FLOAT chordalDeviation,
                      FLOAT extrusion,
                      int   format,
                      LPGLYPHMETRICSFLOAT lpgmf )
{
    return wglUseFontOutlinesAW( hDC, first, count, listBase, chordalDeviation,
                                 extrusion, format, lpgmf, TRUE );
}

/*****************************************************************************
 * wglUseFontOutlinesAW
 * 
 * Converts a subrange of the glyphs in a TrueType font to OpenGL display
 * lists.
 *
 * History:
 *  15-Dec-1994 -by- Marc Fortier [marcfo]
 * Wrote it.
*****************************************************************************/

BOOL WINAPI
wglUseFontOutlinesAW( HDC   hDC,
                      DWORD first,
                      DWORD count,
                      DWORD listBase,
                      FLOAT chordalDeviation,
                      FLOAT extrusion,
                      int   format,
                      LPGLYPHMETRICSFLOAT lpgmf,
                      BOOL  bUnicode
)
{
    DWORD       glyphIndex;
    DWORD       listIndex = listBase;
    UCHAR*      glyphBuf;
    DWORD       glyphBufSize, error;
    OFContext*  ofc;
    BOOL        status=WFO_FAILURE;


    // Return error if there is no current RC.

    if (!GLTEB_CLTCURRENTRC())
    {
        WARNING("wglUseFontOutlines: no current RC\n");
        SetLastError(ERROR_INVALID_HANDLE);
        return status;
    }

    /*
     * Flush any previous OpenGL errors.  This allows us to check for
     * new errors so they can be reported.
     */
    while (glGetError() != GL_NO_ERROR)
        ;

    /*
     * Preallocate a buffer for the outline data, and track its size:
     */
    // XXX: do we need to start with such a big size for this buffer ?
    glyphBuf = (UCHAR*) ALLOC(glyphBufSize = 10240);
    if (!glyphBuf) {
        WARNING("Alloc of glyphBuf failed\n");
        return status;
    }

    /*
     * Create font outline context
     */
    ofc = CreateOFContext( hDC, chordalDeviation, extrusion, format,
                           bUnicode );
    if( !ofc ) {
        WARNING("CreateOFContext failed\n");
        goto exit;
    }

    /*
     * Process each glyph in the given range:
    */
    for (glyphIndex = first; glyphIndex - first < count; ++glyphIndex)
    {
        GLYPHMETRICS    glyphMetrics;
        DWORD           glyphSize;
        static MAT2 matrix =
        {
            {0, 1}, {0, 0},
            {0, 0}, {0, 1}
        };


        /*
         * Determine how much space is needed to store the glyph's
         * outlines.  If our glyph buffer isn't large enough,
         * resize it.
         */
        if( bUnicode )
            glyphSize = GetGlyphOutlineW( hDC, glyphIndex, GGO_NATIVE,
                                          &glyphMetrics, 0, NULL, &matrix );
        else
            glyphSize = GetGlyphOutlineA( hDC, glyphIndex, GGO_NATIVE,
                                          &glyphMetrics, 0, NULL, &matrix );

        if( glyphSize == GDI_ERROR ) {
            WARNING("GetGlyphOutline() failed\n");
            goto exit;
        }

        if (glyphSize > glyphBufSize)
        {
            FREE(glyphBuf);
            glyphBuf = (UCHAR*) ALLOC(glyphBufSize = glyphSize);
            if (!glyphBuf) {
                WARNING("Alloc of glyphBuf failed\n");
                goto exit;
            }
        }


        /*
         * Get the glyph's outlines.
         */
        if( bUnicode )
            error = GetGlyphOutlineW( hDC, glyphIndex, GGO_NATIVE, 
                        &glyphMetrics, glyphBufSize, glyphBuf, &matrix );
        else
            error = GetGlyphOutlineA( hDC, glyphIndex, GGO_NATIVE, 
                        &glyphMetrics, glyphBufSize, glyphBuf, &matrix );

        if( error == GDI_ERROR ) {
            WARNING("GetGlyphOutline() failed\n");
            goto exit;
        }

        /*
         * Turn the glyph into a display list:
         */
        ofc->glyphBuf = glyphBuf;
        ofc->glyphSize = glyphSize;

        if (!MakeDisplayListFromGlyph(  ofc,
                                        listIndex,
                                        &glyphMetrics)) {
            WARNING("MakeDisplayListFromGlyph() failed\n");
            listIndex++;  // so it will be deleted
            goto exit;
        }

        /*
         * Supply scaled glyphMetrics if requested
         */
        if( lpgmf ) {
            lpgmf->gmfBlackBoxX = 
                ofc->scale * (FLOAT) glyphMetrics.gmBlackBoxX;
            lpgmf->gmfBlackBoxY = 
                ofc->scale * (FLOAT) glyphMetrics.gmBlackBoxY;
            lpgmf->gmfptGlyphOrigin.x = 
                ofc->scale * (FLOAT) glyphMetrics.gmptGlyphOrigin.x;
            lpgmf->gmfptGlyphOrigin.y = 
                ofc->scale * (FLOAT) glyphMetrics.gmptGlyphOrigin.y;
            lpgmf->gmfCellIncX = 
                ofc->scale * (FLOAT) glyphMetrics.gmCellIncX;
            lpgmf->gmfCellIncY = 
                ofc->scale * (FLOAT) glyphMetrics.gmCellIncY;

            lpgmf++;
        }

        listIndex++;
    }

    // Set status to SUCCESS if we get this far
    status = WFO_SUCCESS;

    /*
     * Clean up temporary storage and return.  If an error occurred,
     * set error flags and return FAILURE status;
     * otherwise just return SUCCESS.
     */

exit:
    if( glyphBuf )
        FREE(glyphBuf);

    if( ofc )
        DestroyOFContext( hDC, ofc);

    if( !status ) 
    {
        // assume memory error
        WARNING("wglUseFontOutlines: not enough memory\n");
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);

        // free up display lists
        glDeleteLists( listBase, listIndex-listBase );
    }

    return status;
}



/*****************************************************************************
 * MakeDisplayListFromGlyph
 * 
 * Converts the outline of a glyph to an OpenGL display list.
 *
 * Return value is nonzero for success, zero for failure.
 *
 * Does not check for OpenGL errors, so if the caller needs to know about them,
 * it should call glGetError().

*****************************************************************************/

static BOOL
MakeDisplayListFromGlyph( IN  OFContext*        ofc, 
                          IN  DWORD             listName,
                          IN  LPGLYPHMETRICS    glyphMetrics )
{
    BOOL status;

    glNewList(listName, GL_COMPILE);
    /*
     * Set normal and orientation for front face of glyph
     */
    glNormal3f( 0.0f, 0.0f, 1.0f );
    glFrontFace( GL_CCW );

    status = DrawGlyph( ofc );

    /*
     * Translate by gmCellIncX, gmCellIncY
     */
    glTranslatef( ofc->scale * (FLOAT) glyphMetrics->gmCellIncX, 
                  ofc->scale * (FLOAT) glyphMetrics->gmCellIncY, 
                  0.0f );
    glEndList();

    // Check for GL errors occuring during processing of the glyph

    while( glGetError() != GL_NO_ERROR )
        status = WFO_FAILURE; 

    return status;
}



/*****************************************************************************
 * DrawGlyph
 * 
 * Converts the outline of a glyph to OpenGL drawing primitives, tessellating
 * as needed, and then draws the glyph.  Tessellation of the quadratic splines
 * in the outline is controlled by "chordalDeviation", and the drawing
 * primitives (lines or polygons) are selected by "format".
 *
 * Return value is nonzero for success, zero for failure.
 *
 * Does not check for OpenGL errors, so if the caller needs to know about them,
 * it should call glGetError().

 * History:
 *  26-Sep-1995 -by- Marc Fortier [marcfo]
 * Use extrusioniser to draw polygonal faces with extrusion=0

*****************************************************************************/


static BOOL
DrawGlyph( IN OFContext *ofc )
{
    BOOL                status = WFO_FAILURE;
    DWORD               nLoops;
    DWORD               point;
    DWORD               nVerts;
    LOOP_LIST           *pLoopList;
    LOOP                *pLoop;
    POINT2D             *p;
    MEM_POOL            *mp = NULL;

    /*
     * Convert the glyph outlines to a set of polyline loops.
     * (See MakeLinesFromGlyph() for the format of the loop data
     * structure.)
     */
    if( !(pLoopList = MakeLinesFromGlyph(ofc)) )
        goto exit;

    /*
     * Filter out unnecessary vertices
     */
    ApplyVertexFilter( pLoopList );

    /*
     * Now draw the loops in the appropriate format:
     */
    if( ofc->format == WGL_FONT_LINES )
    {
        /*
         * This is the easy case.  Just draw the outlines.
         */
        nLoops = pLoopList->nLoops;
        pLoop = pLoopList->LoopBuf;
#ifndef FONT_DEBUG
        for( ; nLoops; nLoops--, pLoop++ )
        {
            glBegin(GL_LINE_LOOP);

            nVerts = pLoop->nVerts;
            p = pLoop->VertBuf;
            for( ; nVerts; nVerts--, p++ ) {
                glVertex2fv( (FLOAT*) p );
            }

            glEnd();

        }
#else
        // color code the primitives

        for( ; nLoops; nLoops--, pLoop++ )
        {
            DrawColorCodedLineLoop( pLoop, 0.0f );
        }
#endif
        if( ofc->ec )
            extr_DrawLines( ofc->ec, pLoopList );
        status = WFO_SUCCESS;
    }

    else if (ofc->format == WGL_FONT_POLYGONS)
    {
        GLdouble v[3];

        /*
         * This is the hard case.  We have to set up a tessellator
         * to convert the outlines into a set of polygonal
         * primitives, which the tessellator passes to some
         * auxiliary routines for drawing.
         */

        /* Initialize polygon extrusion for the glyph.
         * This prepares for tracking of the tesselation in order to
         * build the Back-facing polygons.
         */

        mp = &ofc->combinePool;
        ofc->curCombinePool = mp;
        mp->index = 0;
        mp->next = NULL;

        if( ofc->ec ) {
            if( !extr_PolyInit( ofc->ec ) )
                goto exit;

        }

        ofc->TessErrorOccurred = 0;
        v[2] = 0.0;
        gluTessBeginPolygon( ofc->tess, ofc );

        /*
         * Each loop returned from MakeLinesFromGlyph is closed (first and 
         * last points are the same).  The old tesselator had trouble with
         * this.  Since the tesselator automatically closes all loops,
         * we skip the last point to be on the safe side.
         */

        nLoops = pLoopList->nLoops;
        pLoop = pLoopList->LoopBuf;
        for( ; nLoops; nLoops--, pLoop++ )
        {
            gluTessBeginContour( ofc->tess );
                
            nVerts = pLoop->nVerts - 1;  // skip last point

            p = pLoop->VertBuf;
            for( ; nVerts; nVerts--, p++ )
            {
                v[0] = p->x;
                v[1] = p->y;
                gluTessVertex(ofc->tess, v, p);
            }
            gluTessEndContour( ofc->tess );
        }

        gluTessEndPolygon( ofc->tess );

        if (ofc->TessErrorOccurred)
            goto exit;

        if( ofc->ec ) {
            /* check for OUT_OF_MEMORY_ERROR in extrusion lib, that might
             * have occured during tesselation tracking.
             */
            if( ofc->ec->TessErrorOccurred )
                goto exit;
#ifdef VARRAY
            if( ofc->ec->zExtrusion == 0.0f )
                DrawFacePolygons( ofc->ec, 0.0f );
            else if( !extr_DrawPolygons( ofc->ec, pLoopList ) )
                goto exit;
#else
            if( !extr_DrawPolygons( ofc->ec, pLoopList ) ) 
                goto exit; 
#endif
        }
        status = WFO_SUCCESS;
    }

exit:
    /*
     * Putting PolyFinish here means PolyInit may not have been called.
     * This is ok.
     */
    if( mp )
        FreeCombinePool( mp );
    if( pLoopList )
        FreeLoopList( pLoopList );
    if( ofc->ec )
        extr_PolyFinish( ofc->ec );

    return status;
}

/*****************************************************************************
 * TessCombine
 *
 * Tesselation callback for loop intersection.  We have to allocate a vertex
 * and return it to tesselator.  Allocation is from the context's static pool.
 * If this runs dry, then a linked list of MEM_POOL blocks is used.

*****************************************************************************/
 
static void CALLBACK
TessCombine( GLdouble coord[3], POINT2D *data[4], GLfloat w[4],
             POINT2D **dataOut, void *userData )
{
    OFContext *ofc = (OFContext *) userData;
    MEM_POOL *mp = ofc->curCombinePool;
    POINT2D *p;

    // make sure there's room available in the current pool block
    if( mp->index >=  POOL_SIZE )
    {
        // we need to allocate another MEM_POOL block
        MEM_POOL *newPool;

        newPool = (MEM_POOL *) ALLOC( sizeof(MEM_POOL) );
        if( !newPool )
            // tesselator will handle any problem with this
            return;

        newPool->index = 0;
        newPool->next = NULL;
        mp->next = newPool;
        mp = newPool;
        ofc->curCombinePool = mp; // new pool becomes the current pool
    }

    p = mp->pool + mp->index;
    p->x = (GLfloat) coord[0];        
    p->y = (GLfloat) coord[1];        
    mp->index ++;

    *dataOut = p;
}

/*****************************************************************************
 * FreeCombinePool
 *
 * Frees any pools of memory allocated by TessCombine callback

*****************************************************************************/
static void
FreeCombinePool( MEM_POOL *memPool )
{
    MEM_POOL *nextPool;

    memPool = memPool->next;  // first pool in list is static part of context
    while( memPool ) {
        nextPool = memPool->next;
        FREE( memPool );
        memPool = nextPool;
    }
}

/*****************************************************************************
 * TessError
 *
 * Saves the last tessellator error code in ofc->TessErrorOccurred.

*****************************************************************************/
 
static void CALLBACK
TessError(GLenum error, void *data)
{
    OFContext *ofc = (OFContext *) data;

    // Only some of these errors are fatal:
    switch( error ) {
        case GLU_TESS_COORD_TOO_LARGE:
        case GLU_TESS_NEED_COMBINE_CALLBACK:
            ofc->TessErrorOccurred = error;
            break;
        default:
            break;
    }
}



/*****************************************************************************
 * MakeLinesFromGlyph
 * 
 * Converts the outline of a glyph from the TTPOLYGON format into
 * structures of Loops, Primitives and Vertices.
 *
 * Line segments from the TTPOLYGON are transferred to the output array in
 * the obvious way.  Quadratic splines in the TTPOLYGON are converted to
 * collections of line segments

*****************************************************************************/


static LOOP_LIST*
MakeLinesFromGlyph( IN OFContext* ofc )
{
    UCHAR*  p;
    BOOL status = WFO_FAILURE;
    LOOP_LIST *pLoopList;

    /*
     * Initialize the buffer into which we place the loop data:
     */
    if( !(pLoopList = InitLoopBuf()) )
        return NULL;

    p = ofc->glyphBuf;
    while (p < ofc->glyphBuf + ofc->glyphSize)
    {
        if( !MakeLinesFromTTPolygon( ofc, pLoopList, &p) )
            goto exit;
    }

    status = WFO_SUCCESS;

exit:
    if (!status) {
        FreeLoopList( pLoopList );
        pLoopList = (LOOP_LIST *) NULL;
    }
    
    return pLoopList;
}



/*****************************************************************************
 * MakeLinesFromTTPolygon
 *
 * Converts a TTPOLYGONHEADER and its associated curve structures into a
 * LOOP structure.

*****************************************************************************/

static BOOL
MakeLinesFromTTPolygon( IN      OFContext*  ofc, 
                        IN      LOOP_LIST*  pLoopList,
                        IN OUT  UCHAR**     pp)
{
    DWORD   polySize;
    UCHAR*  polyStart;
    POINT2D *pFirstP, *pLastP, firstPoint;
    LOOP    *pLoop;
    PRIM    *pPrim;

    /*
     * Record where the polygon data begins.
     */
    polyStart = *pp;

    /*
     * Extract relevant data from the TTPOLYGONHEADER:
     */
    polySize = GetDWord(pp);
    if( GetDWord(pp) != TT_POLYGON_TYPE )  /* polygon type */
        return WFO_FAILURE;
    firstPoint.x = ofc->scale * GetFixed(pp); // 1st X coord
    firstPoint.y = ofc->scale * GetFixed(pp); // 1st Y coord

    /* 
     * Initialize a new LOOP struct in the LoopBuf, with the first point
     */
    if( !(pLoop = NewLoop( pLoopList, &firstPoint )) )
        return WFO_FAILURE;
    
    /*
     * Process each of the TTPOLYCURVE structures in the polygon:
     */

    while (*pp < polyStart + polySize) {
        if( !MakeLinesFromTTPolycurve(  ofc, pLoop, pp ) )
            return WFO_FAILURE;
    }

    /* Now have to fix up end of loop : after studying the chars, it
     * was determined that if a curve started with a line, and ended with
     * a qspline, AND the first and last point were not the same, then there
     * is an implied line joining the two.
     * In any case, we also make sure here that first and last points are
     * coincident.
     */
    
    pLastP = (POINT2D *) (pLoop->VertBuf+pLoop->nVerts-1);
    pFirstP = &firstPoint;

    if( !POINT2DEQUAL( pLastP, pFirstP ) ) {
        // add 1-vertex line prim at the end

        if( !(pPrim = NewPrim( pLoop, TT_PRIM_LINE)) )
            return WFO_FAILURE;

        if ( !AppendToVertBuf( pLoop, pPrim, pFirstP) )
            return WFO_FAILURE;
    }

    /* At end of each loop, calculate pVert for each PRIM from its
     * VertIndex value (for convenience later).
     */
    CalcVertPtrs( pLoop );

    return WFO_SUCCESS;
}


/*****************************************************************************
 * MakeLinesFromTTPolyCurve
 *
 * Converts the lines and splines in a single TTPOLYCURVE structure to points
 * in the Loop.

*****************************************************************************/

static BOOL
MakeLinesFromTTPolycurve( IN     OFContext* ofc, 
                          IN     LOOP*      pLoop,
                          IN OUT UCHAR**    pp )
{
    WORD type;
    WORD pointCount;
    PRIM *pPrim;

    /*
     * Pick up the relevant fields of the TTPOLYCURVE structure:
     */
    type = GetWord(pp);
    pointCount = GetWord(pp);

    if( !(pPrim = NewPrim( pLoop, type )) )
        return WFO_FAILURE;

    /*
     * Convert the "curve" to line segments:
     */
    if (type == TT_PRIM_LINE) {
        return MakeLinesFromTTLine( ofc, pLoop, pPrim, pp, pointCount);

    } else if (type == TT_PRIM_QSPLINE) {
        return MakeLinesFromTTQSpline( ofc, pLoop, pPrim, pp, pointCount );

    } else
        return WFO_FAILURE;
}



/*****************************************************************************
 * MakeLinesFromTTLine
 *
 * Converts points from the polyline in a TT_PRIM_LINE structure to
 * equivalent points in the Loop.

*****************************************************************************/
static BOOL
MakeLinesFromTTLine(    IN     OFContext* ofc, 
                        IN     LOOP*      pLoop,
                        IN     PRIM*      pPrim,
                        IN OUT UCHAR**    pp,
                        IN     WORD       pointCount)
{
    POINT2D p;

    /*
     * Just copy the line segments into the vertex buffer (converting
     * type as we go):
     */

    while (pointCount--)
    {
        p.x = ofc->scale * GetFixed(pp); // X coord 
        p.y = ofc->scale * GetFixed(pp); // Y coord
        if( !AppendToVertBuf( pLoop, pPrim, &p ) )
            return WFO_FAILURE;
    }

    return WFO_SUCCESS;
}


/*****************************************************************************
 * MakeLinesFromTTQSpline
 *
 * Converts points from the poly quadratic spline in a TT_PRIM_QSPLINE
 * structure to polyline points in the Loop. 

*****************************************************************************/

static BOOL
MakeLinesFromTTQSpline( IN      OFContext*  ofc, 
                        IN      LOOP*       pLoop,
                        IN      PRIM*       pPrim,
                        IN  OUT UCHAR**     pp,
                        IN      WORD        pointCount )
{
    POINT2D p0, p1, p2;
    WORD point;
    POINT2D p, *pLastP;

    /*
     * Process each of the non-interpolated points in the outline.
     * To do this, we need to generate two interpolated points (the
     * start and end of the arc) for each non-interpolated point.
     * The first interpolated point is always the one most recently
     * stored in VertBuf, so we just extract it from there.  The
     * second interpolated point is either the average of the next
     * two points in the QSpline, or the last point in the QSpline
     * if only one remains.
     */

    // Start with last generated point in VertBuf
    p0 = *(pLoop->VertBuf + pLoop->nVerts - 1);

    // pointCount should be >=2, but in case it's not...
    p1 = p2 = p0;

    for (point = 0; point < pointCount - 1; ++point)
    {
        p1.x = ofc->scale * GetFixed(pp);
        p1.y = ofc->scale * GetFixed(pp);

        if (point == pointCount - 2)
        {
            /*
             * This is the last arc in the QSpline.  The final
             * point is the end of the arc.
             */
            p2.x = ofc->scale * GetFixed(pp);
            p2.y = ofc->scale * GetFixed(pp);
        }
        else
        {
            /*
             * Peek at the next point in the input to compute
             * the end of the arc:
             */
            p.x = ofc->scale * GetFixed(pp);
            p.y = ofc->scale * GetFixed(pp);
            p2.x = 0.5f * (p1.x + p.x);
            p2.y = 0.5f * (p1.y + p.y);
            /*
             * Push the point back onto the input so it will
             * be reused as the next off-curve point:
             */
            *pp -= 2*sizeof(FIXED); // x and y
        }

        if( !MakeLinesFromArc(  ofc,
                                pLoop,
                                pPrim,
                                p0,
                                p1,
                                p2,
                                ofc->chordalDeviation * ofc->chordalDeviation))
            return WFO_FAILURE;

        // p0 is now the last interpolated point (p2)
        p0 = p2;
    }

    // put in last point in arc
    if( !AppendToVertBuf( pLoop, pPrim, &p2 ) )
        return WFO_FAILURE;

    return WFO_SUCCESS;
}


/*****************************************************************************
 * MakeLinesFromArc
 *
 * Subdivides one arc of a quadratic spline until the chordal deviation
 * tolerance requirement is met, then places the resulting set of line
 * segments in the Loop.

*****************************************************************************/

static BOOL
MakeLinesFromArc(   IN OFContext *ofc, 
                    IN LOOP*     pLoop,
                    IN PRIM*     pPrim,
                    IN POINT2D   p0,
                    IN POINT2D   p1,
                    IN POINT2D   p2,
                    IN FLOAT     chordalDeviationSquared)
{
    POINT2D p01;
    POINT2D p12;
    POINT2D midPoint;
    FLOAT   deltaX;
    FLOAT   deltaY;

    /*
     * Calculate midpoint of the curve by de Casteljau:
     */
    p01.x = 0.5f * (p0.x + p1.x);
    p01.y = 0.5f * (p0.y + p1.y);
    p12.x = 0.5f * (p1.x + p2.x);
    p12.y = 0.5f * (p1.y + p2.y);
    midPoint.x = 0.5f * (p01.x + p12.x);
    midPoint.y = 0.5f * (p01.y + p12.y);


    /*
     * Estimate chordal deviation by the distance from the midpoint
     * of the curve to its non-interpolated control point.  If this
     * distance is greater than the specified chordal deviation
     * constraint, then subdivide.  Otherwise, generate polylines
     * from the three control points.
     */
    deltaX = midPoint.x - p1.x;
    deltaY = midPoint.y - p1.y;
    if (deltaX * deltaX + deltaY * deltaY > chordalDeviationSquared)
    {
        if( !MakeLinesFromArc( ofc, pLoop, pPrim, 
                               p0,
                               p01,
                               midPoint,
                               chordalDeviationSquared) )
            return WFO_FAILURE;

        if( !MakeLinesFromArc( ofc, pLoop, pPrim, 
                               midPoint,
                               p12,
                               p2,
                               chordalDeviationSquared) )
            return WFO_FAILURE;
    }
    else
    {
        /*
         * The "pen" is already at (x0, y0), so we don't need to
         * add that point to the LineBuf.
         */
        if( !AppendToVertBuf( pLoop, pPrim, &p1 ) )
            return WFO_FAILURE;
    }

    return WFO_SUCCESS;
}


/*****************************************************************************
 * ApplyVertexFilter
 *
 * Filter the vertex buffer to get rid of redundant vertices.
 * These can occur on Primitive boundaries.

*****************************************************************************/
static void ApplyVertexFilter( LOOP_LIST *pLoopList )
{
    DWORD nLoops;
    LOOP *pLoop;

    nLoops = pLoopList->nLoops;
    pLoop = pLoopList->LoopBuf;

    for( ; nLoops; nLoops--, pLoop++ ) {
        CheckRedundantVertices( pLoop );
    }
}

/*****************************************************************************
 * CheckRedundantVertices
 *
 * Check for redundant vertices on Curve-Curve boundaries (including loop
 * closure), and get rid of them, using in-place algorithm.

*****************************************************************************/

static void CheckRedundantVertices( LOOP  *pLoop )
{
    PRIM *pPrim, *pNextPrim; 
    DWORD primType, nextPrimType, nVerts;
    BOOL bEliminate, bLastEliminate;
    DWORD nEliminated=0, nPrims;
    POINT2D *pVert, *pVert2ndToLast;
    
    nPrims = pLoop->nPrims;
    if( nPrims < 2 )
        return;

    pPrim = pLoop->PrimBuf;
    pNextPrim = pPrim + 1;
    
    nPrims--; // the last prim is dealt with afterwards
    for( ; nPrims; nPrims--, pPrim = pNextPrim++ ) {
        bEliminate = FALSE;
        nVerts = pPrim->nVerts;

        // check spline<->* boundaries
        if( (pPrim->nVerts >= 2) &&
            ((pPrim->primType     == PRIM_CURVE ) || 
             (pNextPrim->primType == PRIM_CURVE )) ) {

            /* get ptr to 2nd-to-last vertex in current prim 
             * !! Note that last vertex in current prim and first vertex in
             *  next prim are the same.
             */
            pVert2ndToLast = pPrim->pVert + pPrim->nVerts - 2;
            if( PointsColinear( pVert2ndToLast, 
                                pVert2ndToLast+1,
                                pNextPrim->pVert+1 ) ) {
                // we eliminate last vertex in current prim
                bEliminate = TRUE;
                pPrim->nVerts--; 
                nVerts--;
            }
        }

        /* move vertices up in vertBuf if necessary (if any vertices
         * were PREVIOUSLY eliminated)
         */
        if( nEliminated ) {
            pVert = pPrim->pVert - nEliminated; // new pVert
            memcpy( pVert+1, pPrim->pVert+1, (nVerts-1)*sizeof(POINT2D));
            pPrim->pVert = pVert;
        }
        if( bEliminate ) {
            nEliminated += 1;
        }
    }

    /* also check for redundancy at closure:
     * - replace firstPrim's first vertex with 2nd-to-last of last prim
     * - eliminate last vertex in last prim
     */
    bLastEliminate = bEliminate;
    bEliminate = FALSE;
    nVerts = pPrim->nVerts;
    pNextPrim = pLoop->PrimBuf; // first prim in loop

    if( (pPrim->nVerts >= 2) &&
        ((pPrim->primType     == PRIM_CURVE ) || 
         (pNextPrim->primType == PRIM_CURVE )) ) {

        POINT2D *pVertLast;

        pVert2ndToLast = pPrim->pVert + pPrim->nVerts - 2; // always >=2 verts
        pVertLast = pVert2ndToLast + 1;

        if( (pPrim->nVerts == 2) && bLastEliminate )
            /* 2ndToLast vert (same as first vert) of this prim has
             * been eliminated.  Deal with it by backing up the ptr.
             * This didn't matter in above loop, because there wasn't the
             * possibility of munging the first vertex in the loop
             */
            pVert2ndToLast--;

        // point to 2nd-to-last vertex in prim
        if( PointsColinear( pVert2ndToLast, 
                            pVertLast,
                            pNextPrim->pVert+1 ) ) {
            bEliminate = TRUE;
            pPrim->nVerts--; 
            // munge first prim's first vertex
            /* problem here if have 2 eliminations in a row, and pPrim was
             * a 2 vertex prim - then pVert2ndToLast is pointing to an
             * eliminated vertex
             */
            *(pNextPrim->pVert) = *(pVert2ndToLast);
            nVerts--;
        }
    }

    // move up last prim's vertices if necessary
    if( nEliminated ) {
        pVert = pPrim->pVert - nEliminated; // new pVert
        memcpy( pVert+1, pPrim->pVert+1, (nVerts-1)*sizeof(POINT2D) );
        // This misses copying one vertex
        pPrim->pVert = pVert;
    }

    if( bEliminate ) {
        nEliminated += 1;
    }

    // now update vertex count in Loop
    pLoop->nVerts -= nEliminated;

    // Check for prims with nVerts=1 (invalidated), and remove them

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;
    nEliminated = 0;
    for( ; nPrims; nPrims--, pPrim++ ) {
        if( pPrim->nVerts == 1 ) {
            nEliminated++;
            continue;
        }
        *(pPrim-nEliminated) = *pPrim;
    }
    pLoop->nPrims -= nEliminated;
}

/*****************************************************************************
 * PointsColinear
 *
 * Returns TRUE if the 3 points are colinear enough.

*****************************************************************************/

static BOOL PointsColinear( POINT2D *p1,
                            POINT2D *p2,
                            POINT2D *p3 )
{
    POINT2D v1, v2;

    // compare slopes of the 2 vectors? - optimize later
    if( POINT2DEQUAL( p1, p2 ) || POINT2DEQUAL( p2, p3 ) )
        // avoid sending 0 vector to CalcAngle (generates FPE)
        return TRUE;

    v1.x = p2->x - p1->x;
    v1.y = p2->y - p1->y;
    v2.x = p3->x - p2->x;
    v2.y = p3->y - p2->y;
    if( fabs(CalcAngle( &v1, &v2 )) < CoplanarThresholdAngle )
        return TRUE;

    return FALSE;
}


/*****************************************************************************
 * CreateOFContext
 *
 * Create and initialize the outline font context.
 *
 * History:
 *  26-Sep-1995 -by- Marc Fortier [marcfo]
 * Use extrusioniser to draw polygonal faces with extrusion=0

*****************************************************************************/

static OFContext* CreateOFContext( HDC    hdc,
                                   FLOAT  chordalDeviation,
                                   FLOAT  extrusion, 
                                   INT    format,
                                   BOOL   bUnicode )
{
    OFContext *ofc = (OFContext *) NULL;
    BOOL status = WFO_FAILURE;

    // validate parameters

    if( (format != WGL_FONT_LINES) && (format != WGL_FONT_POLYGONS) ) {
        WARNING("wglUseFontOutlines: invalid format parameter\n");
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if( chordalDeviation < 0.0f ) {
        WARNING("wglUseFontOutlines: invalid deviation parameter\n");
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if( extrusion < 0.0f ) {
        WARNING("wglUseFontOutlines: invalid extrusion parameter\n");
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    ofc = (OFContext *) ALLOCZ( sizeof(OFContext) );

    if( !ofc ) 
        return NULL;

    ofc->format = format;
    ofc->chordalDeviation = chordalDeviation;

    if( !ScaleFont( hdc, ofc, bUnicode ) )
        goto exit;

    // handle extrusion
#ifdef VARRAY
    if( !((format == WGL_FONT_LINES) && (extrusion == 0.0f)) ) {
#else
    if( extrusion != 0.0f ) {
#endif
        ofc->ec = extr_Init( extrusion, format );
        if( !ofc->ec ) {
            goto exit;
        }
    } else {
        ofc->ec = (EXTRContext *) NULL;
    }

    // init a tess obj
    ofc->tess = NULL;
    if( ofc->format == WGL_FONT_POLYGONS ) {
        GLUtesselator *tess;

        if (!(tess = gluNewTess()))
            goto exit;

        if( ofc->ec ) {
            gluTessCallback(tess, GLU_TESS_BEGIN_DATA,  
                                    (void(CALLBACK*)()) extr_glBegin);
            gluTessCallback(tess, GLU_TESS_END,    
                                    (void(CALLBACK*)()) extr_glEnd);
            gluTessCallback(tess, GLU_TESS_VERTEX_DATA, 
                                    (void(CALLBACK*)()) extr_glVertex);
        } else {
            gluTessCallback(tess, GLU_BEGIN,  (void(CALLBACK*)()) glBegin);
            gluTessCallback(tess, GLU_END,    (void(CALLBACK*)()) glEnd);
            gluTessCallback(tess, GLU_VERTEX, (void(CALLBACK*)()) glVertex2fv);
        }
        gluTessCallback(tess, GLU_TESS_ERROR_DATA,        
                                        (void(CALLBACK*)()) TessError);
        gluTessCallback(tess, GLU_TESS_COMBINE_DATA, 
                                        (void(CALLBACK*)()) TessCombine);

        // set tesselator normal and winding rule

        gluTessNormal( tess, 0.0, 0.0, 1.0 );
        gluTessProperty( tess, GLU_TESS_WINDING_RULE, GLU_TESS_WINDING_NONZERO);

        ofc->tess = tess;
    }

    status = WFO_SUCCESS;

exit:
    if( !status ) {
        DestroyOFContext( hdc, ofc );
        return NULL;
    }
    return ofc;
}

/*****************************************************************************
* ScaleFont
*
* To get the best representation of the font, we use its design height, or
* the emSquare size.  We then scale emSquare to 1.0.
* A maxChordTolerance value is set, otherwise it was found that some
* glyphs displayed ugly loop intersections.  The value .035f was chosen
* after cursory examination of the glyphs. 
*
* History:
*  31-Jul-1995 -by- [marcfo]
* Get rid of unicode functions - since we're just accessing text metrics,
* the default 'string' functions should work on all platforms.
*****************************************************************************/

static BOOL
ScaleFont( HDC hdc, OFContext *ofc, BOOL bUnicode )
{
    OUTLINETEXTMETRIC otm;
    HFONT       hfont;
    LOGFONT    lf;
    DWORD       textMetricsSize;
    FLOAT       scale, maxChordTolerance=0.035f;
    UINT        otmEMSquare;

    // Query font metrics

    if( GetOutlineTextMetrics( hdc, sizeof(otm), &otm) <= 0 )
        // cmd failed, or buffer size=0
        return WFO_FAILURE;

    otmEMSquare = otm.otmEMSquare;

    /*
     * The font data is scaled, so that 1.0 maps to the font's em square
     * size.  Note that it is still possible for glyphs to extend beyond
     * this square.
     */
    scale = 1.0f / (FLOAT) otmEMSquare;

    // create new font object, using largest size

    hfont = GetCurrentObject( hdc, OBJ_FONT );
    GetObject( hfont, sizeof(LOGFONT), &lf );
    lf.lfHeight = otmEMSquare;
    lf.lfWidth = 0;  // this will choose default width for the height
    hfont = CreateFontIndirect(&lf);

    // select new font into DC, and save current font
    ofc->hfontOld = SelectObject( hdc, hfont );

    // set ofc values

    ofc->scale = scale;

    /* check chord tolerance: in design space, minimum chord tolerance is
     * ~1 logical unit, = ofc->scale.
     */
    if( ofc->chordalDeviation == 0.0f ) {
        // select minimum tolerance in this case
        ofc->chordalDeviation = ofc->scale;
    }
    /* also impose a maximum, or things can get ugly */
    else if( ofc->chordalDeviation > maxChordTolerance ) {
        // XXX might want to change maxChordTolerance based on scale ?
        ofc->chordalDeviation = maxChordTolerance;
    }

    return WFO_SUCCESS;
}

/*****************************************************************************
 * DestroyOFContext
 *
*****************************************************************************/

static void 
DestroyOFContext( HDC hdc, OFContext* ofc )
{
    HFONT hfont;

    if( ofc->ec ) {
        extr_Finish( ofc->ec );
    }

    // put back original font object
    if( ofc->hfontOld ) {
        hfont = SelectObject( hdc, ofc->hfontOld );
        DeleteObject( hfont );
    }

    if( ofc->format == WGL_FONT_POLYGONS ) {
        if( ofc->tess )
            gluDeleteTess( ofc->tess );
    }

    FREE( ofc );
}

/*****************************************************************************
 * InitLoopBuf
 *
 * Initializes a LOOP_LIST structure for the Loops of each glyph.

*****************************************************************************/

static LOOP_LIST*
InitLoopBuf( void )
{
    LOOP *pLoop;
    LOOP_LIST *pLoopList;
    DWORD initSize = 10;

    pLoopList = (LOOP_LIST*) ALLOC( sizeof(LOOP_LIST) );
    if( !pLoopList )
        return( (LOOP_LIST *) NULL );

    pLoop = (LOOP*) ALLOC( initSize * sizeof(LOOP) );
    if( !pLoop ) {
        FREE( pLoopList );
        return( (LOOP_LIST *) NULL );
    }

    pLoopList->LoopBuf = pLoop;
    pLoopList->nLoops = 0;
    pLoopList->LoopBufSize = initSize;

    return pLoopList; 
}

/*****************************************************************************
 * NewLoop
 * 
 * Create a new LOOP structure.  The first point in the loop is supplied.

*****************************************************************************/

static LOOP*
NewLoop( LOOP_LIST *pLoopList, POINT2D *pFirstPoint )
{
    LOOP    *pNewLoop;
    PRIM    *pPrim;
    POINT2D *pVert;
    DWORD   size = 50;

    if( pLoopList->nLoops >=  pLoopList->LoopBufSize)
    {
        // need to increase size of LoopBuf
        LOOP *pLoop;

        pLoop = (LOOP*) REALLOC(pLoopList->LoopBuf,  
                                (pLoopList->LoopBufSize += size) *
                                sizeof(LOOP));
        if( !pLoop )
            return (LOOP *) NULL;
        pLoopList->LoopBuf = pLoop;
    }

    pNewLoop = pLoopList->LoopBuf + pLoopList->nLoops;

    // give the loop a block of prims to work with
    pPrim = (PRIM *) ALLOC( size * sizeof(PRIM) );
    if( !pPrim )
        return (LOOP *) NULL;
    pNewLoop->PrimBuf = pPrim;
    pNewLoop->nPrims = 0;
    pNewLoop->PrimBufSize = size;

    // give the loop a block of vertices to work with
    pVert = (POINT2D*) ALLOC( size * sizeof(POINT2D) );
    if( !pVert ) {
        FREE( pPrim );
        return (LOOP *) NULL;
    }
    pNewLoop->VertBuf = pVert;
    pNewLoop->nVerts = 0;
    pNewLoop->VertBufSize = size;

    // stick that first point in
    pVert->x = pFirstPoint->x;
    pVert->y = pFirstPoint->y;
    pNewLoop->nVerts++;

    // normal buffers - used by extrusion
    pNewLoop->FNormBuf = (POINT3D *) NULL;
    pNewLoop->VNormBuf = (POINT3D *) NULL;

    pLoopList->nLoops++; // increment loop count

    return pNewLoop;
}

/*****************************************************************************
 * NewPrim
 *
 * Create a new PRIM structure.  The primType is supplied.

*****************************************************************************/

static PRIM*
NewPrim( LOOP *pLoop, DWORD primType )
{
    PRIM    *pNewPrim;
    POINT2D *pVert;
    DWORD   size = 50;

    if( pLoop->nPrims >=  pLoop->PrimBufSize)
    {
        // need to increase size of PrimBuf
        PRIM *pPrim;

        pPrim = (PRIM *) REALLOC(pLoop->PrimBuf,  
                                 (pLoop->PrimBufSize += size) * sizeof(PRIM));
        if( !pPrim )
            return (PRIM *) NULL;
        pLoop->PrimBuf = pPrim;
    }

    pNewPrim = pLoop->PrimBuf + pLoop->nPrims;
    // translate primType to extrusion prim type
    primType = (primType == TT_PRIM_LINE) ? PRIM_LINE : PRIM_CURVE;
    pNewPrim->primType = primType;
    pNewPrim->nVerts = 1;  // since we include last point:
    /* 
     * VertIndex must point to the last point of the previous prim
     */
    pNewPrim->VertIndex = pLoop->nVerts - 1;
    // normal pointers - used by extrusion
    pNewPrim->pFNorm = (POINT3D *) NULL;
    pNewPrim->pVNorm = (POINT3D *) NULL;

    pLoop->nPrims++; // increment prim count

    return pNewPrim;
}

/*****************************************************************************
 * FreeLoopList
 *
 * Free up all memory associated with processing a glyph.
 *
*****************************************************************************/

static void
FreeLoopList( LOOP_LIST *pLoopList )
{
    DWORD nLoops;

    if( !pLoopList )
        return;

    if( pLoopList->LoopBuf ) {
        // free up each loop
        LOOP *pLoop = pLoopList->LoopBuf;

        nLoops = pLoopList->nLoops;
        for( ; nLoops; nLoops--, pLoop++ ) {
            if( pLoop->PrimBuf )
                FREE( pLoop->PrimBuf );
            if( pLoop->VertBuf )
                FREE( pLoop->VertBuf );
        } 
        FREE( pLoopList->LoopBuf );
    }
    FREE( pLoopList );
}

/*****************************************************************************
 * AppendToVertBuf
 *
 * Append a vertex to the Loop's VertBuf

*****************************************************************************/

static BOOL
AppendToVertBuf( LOOP      *pLoop,
                 PRIM      *pPrim,
                 POINT2D   *p )
{
    if( pLoop->nVerts >=  pLoop->VertBufSize)
    {
        POINT2D *vertBuf;
        DWORD   size = 100;

        vertBuf = (POINT2D *) REALLOC(pLoop->VertBuf,
                                      (pLoop->VertBufSize += size) *
                                      sizeof(POINT2D));
        if( !vertBuf )
            return WFO_FAILURE;
        pLoop->VertBuf = vertBuf;
    }
    pLoop->VertBuf[pLoop->nVerts] = *p;
    pLoop->nVerts++;
    pPrim->nVerts++;
    return WFO_SUCCESS;
}

/*****************************************************************************
 * CalcVertPtrs
 *
 * Calculate vertex ptrs from index values for the prims in a loop.

*****************************************************************************/

static void
CalcVertPtrs( LOOP *pLoop )
{
    DWORD nPrims;
    PRIM  *pPrim;

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;

    for( ; nPrims; pPrim++, nPrims-- ) {
        pPrim->pVert = pLoop->VertBuf + pPrim->VertIndex;
    }
}


/*****************************************************************************
 * GetFixed
 *
 * Fetch the next 32-bit fixed-point value from a little-endian byte stream,
 * convert it to floating-point, and increment the stream pointer to the next
 * unscanned byte.

*****************************************************************************/

static FLOAT GetFixed(UCHAR** p)
{
    FLOAT value;
    FLOAT fraction;

    fraction = ((FLOAT) (UINT) GetWord(p)) / 65536.0f;
    value    = (FLOAT) GetSignedWord(p);

    return value+fraction;
}

#ifdef FONT_DEBUG
void
DrawColorCodedLineLoop( LOOP *pLoop, FLOAT zextrusion )
{
    POINT2D *p;
    DWORD   nPrims;
    DWORD   nVerts;
    PRIM    *pPrim;

    nPrims = pLoop->nPrims;
    pPrim  = pLoop->PrimBuf;
    for( ; nPrims; nPrims--, pPrim++ ) {

        if( pPrim->primType == PRIM_LINE ) {
            if( nPrims == pLoop->nPrims ) // first prim
                glColor3d( 0.5, 0.0, 0.0 );
            else
                glColor3d( 1.0, 0.0, 0.0 );
        } else {
            if( nPrims == pLoop->nPrims ) // first prim
                glColor3d( 0.5, 0.5, 0.0 );
            else
                glColor3d( 1.0, 1.0, 0.0 );
        }
        
        nVerts = pPrim->nVerts;
        p = pPrim->pVert;
        glBegin(GL_LINE_STRIP);
        for( ; nVerts; nVerts--, p++ ) {
            glVertex3f( p->x, p->y, zextrusion );
        }
        glEnd();
#define DRAW_POINTS 1
#ifdef DRAW_POINTS
        glColor3d( 0.0, 0.5, 0.0 );
        nVerts = pPrim->nVerts;
        p = pPrim->pVert;
        glPointSize( 4.0f );
        glBegin( GL_POINTS );
        for( ; nVerts; nVerts--, p++ ) {
            glVertex3f( p->x, p->y, zextrusion );
        }
        glEnd();
#endif
    }

    // Draw bright green point at start of loop
    if( pLoop->nVerts ) {
        glColor3d( 0.0, 1.0, 0.0 );
        glPointSize( 4.0f );
        glBegin( GL_POINTS );
        p = pLoop->VertBuf;
        glVertex3f( p->x, p->y, zextrusion );
        glEnd();
        glPointSize( 1.0f );
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\fontoutl.h ===
#define WFO_FAILURE   FALSE 
#define WFO_SUCCESS   TRUE

#define PI      3.141592653589793
#define TWO_PI  2.0*PI   

#define ZERO_EPS    0.00000001

//#define VARRAY 1

static const double   CoplanarThresholdAngle = PI/180.0/2.0; // 0.5 degreees

// outline prim types
#define PRIM_LINE     3
#define PRIM_CURVE    4

typedef struct {
    FLOAT x,y;
} POINT2D;

typedef struct {
    FLOAT x,y,z;
} POINT3D;

typedef struct {
    DWORD   primType;
    DWORD   nVerts;
    DWORD   VertIndex;// index into Loop's VertBuf
    POINT2D *pVert;   // ptr to vertex list in Loop's VertBuf
    POINT3D *pFNorm;  // face normals
    POINT3D *pVNorm;  // vertex normals
} PRIM;


typedef struct {
    PRIM    *PrimBuf;  // array of prims
    DWORD   nPrims;
    DWORD   PrimBufSize;
    POINT2D *VertBuf;  // buffer of vertices for the loop
    DWORD   nVerts;
    DWORD   VertBufSize;
    POINT3D *FNormBuf;  // buffer of face normals
    POINT3D *VNormBuf;  // buffer of vertex normals
} LOOP;

typedef struct {
    LOOP    *LoopBuf;  // array of loops
    DWORD   nLoops;
    DWORD   LoopBufSize;
} LOOP_LIST;

typedef struct {
    FLOAT        zExtrusion;
    INT          extrType;
    FLOAT*       FaceBuf;
    DWORD        FaceBufSize;
    DWORD        FaceBufIndex;
    DWORD        FaceVertexCountIndex;
#ifdef VARRAY
    FLOAT*       vaBuf;
    DWORD        vaBufSize;
#endif
#ifdef FONT_DEBUG
    BOOL         bSidePolys;
    BOOL         bFacePolys;
#endif
    GLenum       TessErrorOccurred;
} EXTRContext;

// Memory pool for tesselation Combine callback
#define POOL_SIZE 50
typedef struct MEM_POOL MEM_POOL;

struct MEM_POOL {
    int      index;             // next free space in pool
    POINT2D  pool[POOL_SIZE];   // memory pool
    MEM_POOL *next;             // next pool
};

typedef struct {
    GLenum              TessErrorOccurred;
    FLOAT               chordalDeviation;
    FLOAT               scale;
    int                 format;
    UCHAR*              glyphBuf;
    DWORD               glyphSize;
    HFONT               hfontOld;
    GLUtesselator*      tess;
    MEM_POOL            combinePool;     // start of MEM_POOL chain
    MEM_POOL            *curCombinePool; // currently active MEM_POOL
    EXTRContext         *ec;
} OFContext;  // Outline Font Context

extern EXTRContext*   extr_Init(                FLOAT       extrusion,  
                                                INT         format ); 

extern void           extr_Finish(              EXTRContext *ec );

extern void           extr_DrawLines(           EXTRContext *ec, 
                                                LOOP_LIST   *pLoopList );

extern BOOL           extr_DrawPolygons(        EXTRContext *ec,
                                                LOOP_LIST   *pLoopList );

#ifdef VARRAY
extern void           DrawFacePolygons(         EXTRContext *ec,  
                                                FLOAT       z );
#endif

extern BOOL           extr_PolyInit(            EXTRContext *ec );

extern void           extr_PolyFinish(          EXTRContext *ec );

extern void CALLBACK  extr_glBegin(             GLenum      primType,
                                                void        *data );

extern void CALLBACK  extr_glVertex(            GLfloat     *v,
                                                void        *data );

extern void CALLBACK  extr_glEnd(               void );

extern double         CalcAngle(                POINT2D     *v1, 
                                                POINT2D     *v2 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\compsize.c ===
/******************************Module*Header*******************************\
* Module Name: compsize.c
*
* Functions to compute size of input buffer.
*
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#ifndef _CLIENTSIDE_
#include "precomp.h"
#pragma hdrstop

#include "compsize.h"
#include "glsize.h"

// Server code will flag the bad enum

#define GL_BAD_SIZE(x)   {return(0);}

static GLint gaiMapSize[] = {
                4,  //GL_MAP1_COLOR_4        , GL_MAP2_COLOR_4
                1,  //GL_MAP1_INDEX          , GL_MAP2_INDEX
                3,  //GL_MAP1_NORMAL         , GL_MAP2_NORMAL
                1,  //GL_MAP1_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_1
                2,  //GL_MAP1_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_2
                3,  //GL_MAP1_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_3
                4,  //GL_MAP1_TEXTURE_COORD_4, GL_MAP2_TEXTURE_COORD_4
                3,  //GL_MAP1_VERTEX_3       , GL_MAP2_VERTEX_3
                4,  //GL_MAP1_VERTEX_4       , GL_MAP2_VERTEX_4
                };

#define RANGE_MAP1SIZE(n) RANGE(n,GL_MAP1_COLOR_4,GL_MAP1_VERTEX_4)
#define MAP1SIZE(n)       gaiMapSize[(n)-GL_MAP1_COLOR_4]
#define RANGE_MAP2SIZE(n) RANGE(n,GL_MAP2_COLOR_4,GL_MAP2_VERTEX_4)
#define MAP2SIZE(n)       gaiMapSize[(n)-GL_MAP2_COLOR_4]

GLint gaiGLTypeSize[] = {
         1,  //GL_BYTE
         1,  //GL_UNSIGNED_BYTE
         2,  //GL_SHORT
         2,  //GL_UNSIGNED_SHORT
         4,  //GL_INT
         4,  //GL_UNSIGNED_INT
         4,  //GL_FLOAT
         2,  //GL_2_BYTES
         3,  //GL_3_BYTES
         4   //GL_4_BYTES
         };

GLint __glCallLists_size(GLint n, GLenum type)
{
    if ( RANGE_GLTYPESIZE(type) )
        return(GLTYPESIZE(type) * n);

    GL_BAD_SIZE(type);
}

GLint __glCltMap1_size(GLenum target)
{
    if (RANGE_MAP1SIZE(target))
        return(MAP1SIZE(target));

    GL_BAD_SIZE(target);
}

//XXX Optimize if (vstride != MAP2SIZE) or (ustride != MAP2SIZE * vorder)
//XXX by changing vstride to MAP1SIZE, ustride to MAPSIZE * vorder
//XXX and copying minimal data to the shared memory window.

GLint __glCltMap2_size(GLenum target)
{
// PTAR: (uorder - 1) ???
// How come nothing is done with target?
//
//    if (RANGE_MAP2SIZE(target)
//     && ustride >= MAP2SIZE(target) && vstride >= MAP2SIZE(target)
//     && uorder >= 1 && vorder >= 1)
//        return(ustride * (uorder - 1) + vstride * vorder);

    if (RANGE_MAP2SIZE(target))
        return(MAP2SIZE(target));

    GL_BAD_SIZE(target);
}

GLint __glGetMap_size(GLenum target, GLenum query)
{
    GLint order, majorMinor[2];

    if ( RANGE_MAP1SIZE(target) )
    {
        switch (query)
        {
        case GL_COEFF:
            glGetMapiv(target, GL_ORDER, &order);
            return (order * MAP1SIZE(target));
        case GL_ORDER:
            return 1;
        case GL_DOMAIN:
            return 2;
        }
    }
    else if ( RANGE_MAP2SIZE(target) )
    {
        switch (query)
        {
        case GL_COEFF:
            glGetMapiv(target, GL_ORDER, majorMinor);
            return (majorMinor[0] * majorMinor[1] * MAP2SIZE(target));
        case GL_ORDER:
            return 2;
        case GL_DOMAIN:
            return 4;
        }
    }

    GL_BAD_SIZE(target);
}

GLint __glGetPixelMap_size(GLenum map)
{
    GLint size;

    if ( RANGE(map, GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_A_TO_A) )
    {
    // For each GL_PIXEL_* there is a corresponding GL_PIXEL_*_SIZE
    // for which we can call glGetIntergerv.  We convert GL_PIXEL_*
    // to GL_PIXEL_*_SIZE by exploiting the contiguous nature of the
    // indices (i.e., we add to map the offset of the GL_PIXEL_*_SIZE
    // range from the GL_PIXEL_* range).

        glGetIntegerv(map+(GL_PIXEL_MAP_I_TO_I_SIZE - GL_PIXEL_MAP_I_TO_I), &size);
        return size;
    }

    GL_BAD_SIZE(map);
}

#define GET_INDEX_MIN      GL_CURRENT_COLOR
#define GET_INDEX_MAX      GL_TEXTURE_2D

static GLubyte gabGetSize[GET_INDEX_MAX - GET_INDEX_MIN + 1] = 
{
    4,   // GL_CURRENT_COLOR                 0x0B00
    1,   // GL_CURRENT_INDEX                 0x0B01
    3,   // GL_CURRENT_NORMAL                0x0B02
    4,   // GL_CURRENT_TEXTURE_COORDS        0x0B03
    4,   // GL_CURRENT_RASTER_COLOR          0x0B04
    1,   // GL_CURRENT_RASTER_INDEX          0x0B05
    4,   // GL_CURRENT_RASTER_TEXTURE_COORDS 0x0B06
    4,   // GL_CURRENT_RASTER_POSITION       0x0B07
    1,   // GL_CURRENT_RASTER_POSITION_VALID 0x0B08
    1,   // GL_CURRENT_RASTER_DISTANCE       0x0B09
    0,   //                                  0x0B0A
    0,   //                                  0x0B0B
    0,   //                                  0x0B0C
    0,   //                                  0x0B0D
    0,   //                                  0x0B0E
    0,   //                                  0x0B0F
    1,   // GL_POINT_SMOOTH                  0x0B10
    1,   // GL_POINT_SIZE                    0x0B11
    2,   // GL_POINT_SIZE_RANGE              0x0B12
    1,   // GL_POINT_SIZE_GRANULARITY        0x0B13
    0,   //                                  0x0B14
    0,   //                                  0x0B15
    0,   //                                  0x0B16
    0,   //                                  0x0B17
    0,   //                                  0x0B18
    0,   //                                  0x0B19
    0,   //                                  0x0B1A
    0,   //                                  0x0B1B
    0,   //                                  0x0B1C
    0,   //                                  0x0B1D
    0,   //                                  0x0B1E
    0,   //                                  0x0B1F
    1,   // GL_LINE_SMOOTH                   0x0B20
    1,   // GL_LINE_WIDTH                    0x0B21
    2,   // GL_LINE_WIDTH_RANGE              0x0B22
    1,   // GL_LINE_WIDTH_GRANULARITY        0x0B23
    1,   // GL_LINE_STIPPLE                  0x0B24
    1,   // GL_LINE_STIPPLE_PATTERN          0x0B25
    1,   // GL_LINE_STIPPLE_REPEAT           0x0B26
    0,   //                                  0x0B27
    0,   //                                  0x0B28
    0,   //                                  0x0B29
    0,   //                                  0x0B2A
    0,   //                                  0x0B2B
    0,   //                                  0x0B2C
    0,   //                                  0x0B2D
    0,   //                                  0x0B2E
    0,   //                                  0x0B2F
    1,   // GL_LIST_MODE                     0x0B30
    1,   // GL_MAX_LIST_NESTING              0x0B31
    1,   // GL_LIST_BASE                     0x0B32
    1,   // GL_LIST_INDEX                    0x0B33
    0,   //                                  0x0B34
    0,   //                                  0x0B35
    0,   //                                  0x0B36
    0,   //                                  0x0B37
    0,   //                                  0x0B38
    0,   //                                  0x0B39
    0,   //                                  0x0B3A
    0,   //                                  0x0B3B
    0,   //                                  0x0B3C
    0,   //                                  0x0B3D
    0,   //                                  0x0B3E
    0,   //                                  0x0B3F
    2,   // GL_POLYGON_MODE                  0x0B40
    1,   // GL_POLYGON_SMOOTH                0x0B41
    1,   // GL_POLYGON_STIPPLE               0x0B42
    1,   // GL_EDGE_FLAG                     0x0B43
    1,   // GL_CULL_FACE                     0x0B44
    1,   // GL_CULL_FACE_MODE                0x0B45
    1,   // GL_FRONT_FACE                    0x0B46
    0,   //                                  0x0B47
    0,   //                                  0x0B48
    0,   //                                  0x0B49
    0,   //                                  0x0B4A
    0,   //                                  0x0B4B
    0,   //                                  0x0B4C
    0,   //                                  0x0B4D
    0,   //                                  0x0B4E
    0,   //                                  0x0B4F
    1,   // GL_LIGHTING                      0x0B50
    1,   // GL_LIGHT_MODEL_LOCAL_VIEWER      0x0B51
    1,   // GL_LIGHT_MODEL_TWO_SIDE          0x0B52
    4,   // GL_LIGHT_MODEL_AMBIENT           0x0B53
    1,   // GL_SHADE_MODEL                   0x0B54
    1,   // GL_COLOR_MATERIAL_FACE           0x0B55
    1,   // GL_COLOR_MATERIAL_PARAMETER      0x0B56
    1,   // GL_COLOR_MATERIAL                0x0B57
    0,   //                                  0x0B58
    0,   //                                  0x0B59
    0,   //                                  0x0B5A
    0,   //                                  0x0B5B
    0,   //                                  0x0B5C
    0,   //                                  0x0B5D
    0,   //                                  0x0B5E
    0,   //                                  0x0B5F
    1,   // GL_FOG                           0x0B60
    1,   // GL_FOG_INDEX                     0x0B61
    1,   // GL_FOG_DENSITY                   0x0B62
    1,   // GL_FOG_START                     0x0B63
    1,   // GL_FOG_END                       0x0B64
    1,   // GL_FOG_MODE                      0x0B65
    4,   // GL_FOG_COLOR                     0x0B66
    0,   //                                  0x0B67
    0,   //                                  0x0B68
    0,   //                                  0x0B69
    0,   //                                  0x0B6A
    0,   //                                  0x0B6B
    0,   //                                  0x0B6C
    0,   //                                  0x0B6D
    0,   //                                  0x0B6E
    0,   //                                  0x0B6F
    2,   // GL_DEPTH_RANGE                   0x0B70
    1,   // GL_DEPTH_TEST                    0x0B71
    1,   // GL_DEPTH_WRITEMASK               0x0B72
    1,   // GL_DEPTH_CLEAR_VALUE             0x0B73
    1,   // GL_DEPTH_FUNC                    0x0B74
    0,   //                                  0x0B75
    0,   //                                  0x0B76
    0,   //                                  0x0B77
    0,   //                                  0x0B78
    0,   //                                  0x0B79
    0,   //                                  0x0B7A
    0,   //                                  0x0B7B
    0,   //                                  0x0B7C
    0,   //                                  0x0B7D
    0,   //                                  0x0B7E
    0,   //                                  0x0B7F
    4,   // GL_ACCUM_CLEAR_VALUE             0x0B80
    0,   //                                  0x0B81
    0,   //                                  0x0B82
    0,   //                                  0x0B83
    0,   //                                  0x0B84
    0,   //                                  0x0B85
    0,   //                                  0x0B86
    0,   //                                  0x0B87
    0,   //                                  0x0B88
    0,   //                                  0x0B89
    0,   //                                  0x0B8A
    0,   //                                  0x0B8B
    0,   //                                  0x0B8C
    0,   //                                  0x0B8D
    0,   //                                  0x0B8E
    0,   //                                  0x0B8F
    1,   // GL_STENCIL_TEST                  0x0B90
    1,   // GL_STENCIL_CLEAR_VALUE           0x0B91
    1,   // GL_STENCIL_FUNC                  0x0B92
    1,   // GL_STENCIL_VALUE_MASK            0x0B93
    1,   // GL_STENCIL_FAIL                  0x0B94
    1,   // GL_STENCIL_PASS_DEPTH_FAIL       0x0B95
    1,   // GL_STENCIL_PASS_DEPTH_PASS       0x0B96
    1,   // GL_STENCIL_REF                   0x0B97
    1,   // GL_STENCIL_WRITEMASK             0x0B98
    0,   //                                  0x0B99
    0,   //                                  0x0B9A
    0,   //                                  0x0B9B
    0,   //                                  0x0B9C
    0,   //                                  0x0B9D
    0,   //                                  0x0B9E
    0,   //                                  0x0B9F
    1,   // GL_MATRIX_MODE                   0x0BA0
    1,   // GL_NORMALIZE                     0x0BA1
    4,   // GL_VIEWPORT                      0x0BA2
    1,   // GL_MODELVIEW_STACK_DEPTH         0x0BA3
    1,   // GL_PROJECTION_STACK_DEPTH        0x0BA4
    1,   // GL_TEXTURE_STACK_DEPTH           0x0BA5
    16,  // GL_MODELVIEW_MATRIX              0x0BA6
    16,  // GL_PROJECTION_MATRIX             0x0BA7
    16,  // GL_TEXTURE_MATRIX                0x0BA8
    0,   //                                  0x0BA9
    0,   //                                  0x0BAA
    0,   //                                  0x0BAB
    0,   //                                  0x0BAC
    0,   //                                  0x0BAD
    0,   //                                  0x0BAE
    0,   //                                  0x0BAF
    1,   // GL_ATTRIB_STACK_DEPTH            0x0BB0
    0,   //                                  0x0BB1
    0,   //                                  0x0BB2
    0,   //                                  0x0BB3
    0,   //                                  0x0BB4
    0,   //                                  0x0BB5
    0,   //                                  0x0BB6
    0,   //                                  0x0BB7
    0,   //                                  0x0BB8
    0,   //                                  0x0BB9
    0,   //                                  0x0BBA
    0,   //                                  0x0BBB
    0,   //                                  0x0BBC
    0,   //                                  0x0BBD
    0,   //                                  0x0BBE
    0,   //                                  0x0BBF
    1,   // GL_ALPHA_TEST                    0x0BC0
    1,   // GL_ALPHA_TEST_FUNC               0x0BC1
    1,   // GL_ALPHA_TEST_REF                0x0BC2
    0,   //                                  0x0BC3
    0,   //                                  0x0BC4
    0,   //                                  0x0BC5
    0,   //                                  0x0BC6
    0,   //                                  0x0BC7
    0,   //                                  0x0BC8
    0,   //                                  0x0BC9
    0,   //                                  0x0BCA
    0,   //                                  0x0BCB
    0,   //                                  0x0BCC
    0,   //                                  0x0BCD
    0,   //                                  0x0BCE
    0,   //                                  0x0BCF
    1,   // GL_DITHER                        0x0BD0
    0,   //                                  0x0BD1
    0,   //                                  0x0BD2
    0,   //                                  0x0BD3
    0,   //                                  0x0BD4
    0,   //                                  0x0BD5
    0,   //                                  0x0BD6
    0,   //                                  0x0BD7
    0,   //                                  0x0BD8
    0,   //                                  0x0BD9
    0,   //                                  0x0BDA
    0,   //                                  0x0BDB
    0,   //                                  0x0BDC
    0,   //                                  0x0BDD
    0,   //                                  0x0BDE
    0,   //                                  0x0BDF
    1,   // GL_BLEND_DST                     0x0BE0
    1,   // GL_BLEND_SRC                     0x0BE1
    1,   // GL_BLEND                         0x0BE2
    0,   //                                  0x0BE3
    0,   //                                  0x0BE4
    0,   //                                  0x0BE5
    0,   //                                  0x0BE6
    0,   //                                  0x0BE7
    0,   //                                  0x0BE8
    0,   //                                  0x0BE9
    0,   //                                  0x0BEA
    0,   //                                  0x0BEB
    0,   //                                  0x0BEC
    0,   //                                  0x0BED
    0,   //                                  0x0BEE
    0,   //                                  0x0BEF
    1,   // GL_LOGIC_OP_MODE                 0x0BF0
    1,   // GL_LOGIC_OP                      0x0BF1
    0,   //                                  0x0BF2
    0,   //                                  0x0BF3
    0,   //                                  0x0BF4
    0,   //                                  0x0BF5
    0,   //                                  0x0BF6
    0,   //                                  0x0BF7
    0,   //                                  0x0BF8
    0,   //                                  0x0BF9
    0,   //                                  0x0BFA
    0,   //                                  0x0BFB
    0,   //                                  0x0BFC
    0,   //                                  0x0BFD
    0,   //                                  0x0BFE
    0,   //                                  0x0BFF
    1,   // GL_AUX_BUFFERS                   0x0C00
    1,   // GL_DRAW_BUFFER                   0x0C01
    1,   // GL_READ_BUFFER                   0x0C02
    0,   //                                  0x0C03
    0,   //                                  0x0C04
    0,   //                                  0x0C05
    0,   //                                  0x0C06
    0,   //                                  0x0C07
    0,   //                                  0x0C08
    0,   //                                  0x0C09
    0,   //                                  0x0C0A
    0,   //                                  0x0C0B
    0,   //                                  0x0C0C
    0,   //                                  0x0C0D
    0,   //                                  0x0C0E
    0,   //                                  0x0C0F
    4,   // GL_SCISSOR_BOX                   0x0C10
    1,   // GL_SCISSOR_TEST                  0x0C11
    0,   //                                  0x0C12
    0,   //                                  0x0C13
    0,   //                                  0x0C14
    0,   //                                  0x0C15
    0,   //                                  0x0C16
    0,   //                                  0x0C17
    0,   //                                  0x0C18
    0,   //                                  0x0C19
    0,   //                                  0x0C1A
    0,   //                                  0x0C1B
    0,   //                                  0x0C1C
    0,   //                                  0x0C1D
    0,   //                                  0x0C1E
    0,   //                                  0x0C1F
    1,   // GL_INDEX_CLEAR_VALUE             0x0C20
    1,   // GL_INDEX_WRITEMASK               0x0C21
    4,   // GL_COLOR_CLEAR_VALUE             0x0C22
    4,   // GL_COLOR_WRITEMASK               0x0C23
    0,   //                                  0x0C24
    0,   //                                  0x0C25
    0,   //                                  0x0C26
    0,   //                                  0x0C27
    0,   //                                  0x0C28
    0,   //                                  0x0C29
    0,   //                                  0x0C2A
    0,   //                                  0x0C2B
    0,   //                                  0x0C2C
    0,   //                                  0x0C2D
    0,   //                                  0x0C2E
    0,   //                                  0x0C2F
    1,   // GL_INDEX_MODE                    0x0C30
    1,   // GL_RGBA_MODE                     0x0C31
    1,   // GL_DOUBLEBUFFER                  0x0C32
    1,   // GL_STEREO                        0x0C33
    0,   //                                  0x0C34
    0,   //                                  0x0C35
    0,   //                                  0x0C36
    0,   //                                  0x0C37
    0,   //                                  0x0C38
    0,   //                                  0x0C39
    0,   //                                  0x0C3A
    0,   //                                  0x0C3B
    0,   //                                  0x0C3C
    0,   //                                  0x0C3D
    0,   //                                  0x0C3E
    0,   //                                  0x0C3F
    1,   // GL_RENDER_MODE                   0x0C40
    0,   //                                  0x0C41
    0,   //                                  0x0C42
    0,   //                                  0x0C43
    0,   //                                  0x0C44
    0,   //                                  0x0C45
    0,   //                                  0x0C46
    0,   //                                  0x0C47
    0,   //                                  0x0C48
    0,   //                                  0x0C49
    0,   //                                  0x0C4A
    0,   //                                  0x0C4B
    0,   //                                  0x0C4C
    0,   //                                  0x0C4D
    0,   //                                  0x0C4E
    0,   //                                  0x0C4F
    1,   // GL_PERSPECTIVE_CORRECTION_HINT   0x0C50
    1,   // GL_POINT_SMOOTH_HINT             0x0C51
    1,   // GL_LINE_SMOOTH_HINT              0x0C52
    1,   // GL_POLYGON_SMOOTH_HINT           0x0C53
    1,   // GL_FOG_HINT                      0x0C54
    0,   //                                  0x0C55
    0,   //                                  0x0C56
    0,   //                                  0x0C57
    0,   //                                  0x0C58
    0,   //                                  0x0C59
    0,   //                                  0x0C5A
    0,   //                                  0x0C5B
    0,   //                                  0x0C5C
    0,   //                                  0x0C5D
    0,   //                                  0x0C5E
    0,   //                                  0x0C5F
    1,   // GL_TEXTURE_GEN_S                 0x0C60
    1,   // GL_TEXTURE_GEN_T                 0x0C61
    1,   // GL_TEXTURE_GEN_R                 0x0C62
    1,   // GL_TEXTURE_GEN_Q                 0x0C63
    0,   //                                  0x0C64
    0,   //                                  0x0C65
    0,   //                                  0x0C66
    0,   //                                  0x0C67
    0,   //                                  0x0C68
    0,   //                                  0x0C69
    0,   //                                  0x0C6A
    0,   //                                  0x0C6B
    0,   //                                  0x0C6C
    0,   //                                  0x0C6D
    0,   //                                  0x0C6E
    0,   //                                  0x0C6F
    0,   // GL_PIXEL_MAP_I_TO_I              0x0C70
    0,   // GL_PIXEL_MAP_S_TO_S              0x0C71
    0,   // GL_PIXEL_MAP_I_TO_R              0x0C72
    0,   // GL_PIXEL_MAP_I_TO_G              0x0C73
    0,   // GL_PIXEL_MAP_I_TO_B              0x0C74
    0,   // GL_PIXEL_MAP_I_TO_A              0x0C75
    0,   // GL_PIXEL_MAP_R_TO_R              0x0C76
    0,   // GL_PIXEL_MAP_G_TO_G              0x0C77
    0,   // GL_PIXEL_MAP_B_TO_B              0x0C78
    0,   // GL_PIXEL_MAP_A_TO_A              0x0C79
    0,   //                                  0x0C7A
    0,   //                                  0x0C7B
    0,   //                                  0x0C7C
    0,   //                                  0x0C7D
    0,   //                                  0x0C7E
    0,   //                                  0x0C7F
    0,   //                                  0x0C80
    0,   //                                  0x0C81
    0,   //                                  0x0C82
    0,   //                                  0x0C83
    0,   //                                  0x0C84
    0,   //                                  0x0C85
    0,   //                                  0x0C86
    0,   //                                  0x0C87
    0,   //                                  0x0C88
    0,   //                                  0x0C89
    0,   //                                  0x0C8A
    0,   //                                  0x0C8B
    0,   //                                  0x0C8C
    0,   //                                  0x0C8D
    0,   //                                  0x0C8E
    0,   //                                  0x0C8F
    0,   //                                  0x0C90
    0,   //                                  0x0C91
    0,   //                                  0x0C92
    0,   //                                  0x0C93
    0,   //                                  0x0C94
    0,   //                                  0x0C95
    0,   //                                  0x0C96
    0,   //                                  0x0C97
    0,   //                                  0x0C98
    0,   //                                  0x0C99
    0,   //                                  0x0C9A
    0,   //                                  0x0C9B
    0,   //                                  0x0C9C
    0,   //                                  0x0C9D
    0,   //                                  0x0C9E
    0,   //                                  0x0C9F
    0,   //                                  0x0CA0
    0,   //                                  0x0CA1
    0,   //                                  0x0CA2
    0,   //                                  0x0CA3
    0,   //                                  0x0CA4
    0,   //                                  0x0CA5
    0,   //                                  0x0CA6
    0,   //                                  0x0CA7
    0,   //                                  0x0CA8
    0,   //                                  0x0CA9
    0,   //                                  0x0CAA
    0,   //                                  0x0CAB
    0,   //                                  0x0CAC
    0,   //                                  0x0CAD
    0,   //                                  0x0CAE
    0,   //                                  0x0CAF
    1,   // GL_PIXEL_MAP_I_TO_I_SIZE         0x0CB0
    1,   // GL_PIXEL_MAP_S_TO_S_SIZE         0x0CB1
    1,   // GL_PIXEL_MAP_I_TO_R_SIZE         0x0CB2
    1,   // GL_PIXEL_MAP_I_TO_G_SIZE         0x0CB3
    1,   // GL_PIXEL_MAP_I_TO_B_SIZE         0x0CB4
    1,   // GL_PIXEL_MAP_I_TO_A_SIZE         0x0CB5
    1,   // GL_PIXEL_MAP_R_TO_R_SIZE         0x0CB6
    1,   // GL_PIXEL_MAP_G_TO_G_SIZE         0x0CB7
    1,   // GL_PIXEL_MAP_B_TO_B_SIZE         0x0CB8
    1,   // GL_PIXEL_MAP_A_TO_A_SIZE         0x0CB9
    0,   //                                  0x0CBA
    0,   //                                  0x0CBB
    0,   //                                  0x0CBC
    0,   //                                  0x0CBD
    0,   //                                  0x0CBE
    0,   //                                  0x0CBF
    0,   //                                  0x0CC0
    0,   //                                  0x0CC1
    0,   //                                  0x0CC2
    0,   //                                  0x0CC3
    0,   //                                  0x0CC4
    0,   //                                  0x0CC5
    0,   //                                  0x0CC6
    0,   //                                  0x0CC7
    0,   //                                  0x0CC8
    0,   //                                  0x0CC9
    0,   //                                  0x0CCA
    0,   //                                  0x0CCB
    0,   //                                  0x0CCC
    0,   //                                  0x0CCD
    0,   //                                  0x0CCE
    0,   //                                  0x0CCF
    0,   //                                  0x0CD0
    0,   //                                  0x0CD1
    0,   //                                  0x0CD2
    0,   //                                  0x0CD3
    0,   //                                  0x0CD4
    0,   //                                  0x0CD5
    0,   //                                  0x0CD6
    0,   //                                  0x0CD7
    0,   //                                  0x0CD8
    0,   //                                  0x0CD9
    0,   //                                  0x0CDA
    0,   //                                  0x0CDB
    0,   //                                  0x0CDC
    0,   //                                  0x0CDD
    0,   //                                  0x0CDE
    0,   //                                  0x0CDF
    0,   //                                  0x0CE0
    0,   //                                  0x0CE1
    0,   //                                  0x0CE2
    0,   //                                  0x0CE3
    0,   //                                  0x0CE4
    0,   //                                  0x0CE5
    0,   //                                  0x0CE6
    0,   //                                  0x0CE7
    0,   //                                  0x0CE8
    0,   //                                  0x0CE9
    0,   //                                  0x0CEA
    0,   //                                  0x0CEB
    0,   //                                  0x0CEC
    0,   //                                  0x0CED
    0,   //                                  0x0CEE
    0,   //                                  0x0CEF
    1,   // GL_UNPACK_SWAP_BYTES             0x0CF0
    1,   // GL_UNPACK_LSB_FIRST              0x0CF1
    1,   // GL_UNPACK_ROW_LENGTH             0x0CF2
    1,   // GL_UNPACK_SKIP_ROWS              0x0CF3
    1,   // GL_UNPACK_SKIP_PIXELS            0x0CF4
    1,   // GL_UNPACK_ALIGNMENT              0x0CF5
    0,   //                                  0x0CF6
    0,   //                                  0x0CF7
    0,   //                                  0x0CF8
    0,   //                                  0x0CF9
    0,   //                                  0x0CFA
    0,   //                                  0x0CFB
    0,   //                                  0x0CFC
    0,   //                                  0x0CFD
    0,   //                                  0x0CFE
    0,   //                                  0x0CFF
    1,   // GL_PACK_SWAP_BYTES               0x0D00
    1,   // GL_PACK_LSB_FIRST                0x0D01
    1,   // GL_PACK_ROW_LENGTH               0x0D02
    1,   // GL_PACK_SKIP_ROWS                0x0D03
    1,   // GL_PACK_SKIP_PIXELS              0x0D04
    1,   // GL_PACK_ALIGNMENT                0x0D05
    0,   //                                  0x0D06
    0,   //                                  0x0D07
    0,   //                                  0x0D08
    0,   //                                  0x0D09
    0,   //                                  0x0D0A
    0,   //                                  0x0D0B
    0,   //                                  0x0D0C
    0,   //                                  0x0D0D
    0,   //                                  0x0D0E
    0,   //                                  0x0D0F
    1,   // GL_MAP_COLOR                     0x0D10
    1,   // GL_MAP_STENCIL                   0x0D11
    1,   // GL_INDEX_SHIFT                   0x0D12
    1,   // GL_INDEX_OFFSET                  0x0D13
    1,   // GL_RED_SCALE                     0x0D14
    1,   // GL_RED_BIAS                      0x0D15
    1,   // GL_ZOOM_X                        0x0D16
    1,   // GL_ZOOM_Y                        0x0D17
    1,   // GL_GREEN_SCALE                   0x0D18
    1,   // GL_GREEN_BIAS                    0x0D19
    1,   // GL_BLUE_SCALE                    0x0D1A
    1,   // GL_BLUE_BIAS                     0x0D1B
    1,   // GL_ALPHA_SCALE                   0x0D1C
    1,   // GL_ALPHA_BIAS                    0x0D1D
    1,   // GL_DEPTH_SCALE                   0x0D1E
    1,   // GL_DEPTH_BIAS                    0x0D1F
    0,   //                                  0x0D20
    0,   //                                  0x0D21
    0,   //                                  0x0D22
    0,   //                                  0x0D23
    0,   //                                  0x0D24
    0,   //                                  0x0D25
    0,   //                                  0x0D26
    0,   //                                  0x0D27
    0,   //                                  0x0D28
    0,   //                                  0x0D29
    0,   //                                  0x0D2A
    0,   //                                  0x0D2B
    0,   //                                  0x0D2C
    0,   //                                  0x0D2D
    0,   //                                  0x0D2E
    0,   //                                  0x0D2F
    1,   // GL_MAX_EVAL_ORDER                0x0D30
    1,   // GL_MAX_LIGHTS                    0x0D31
    1,   // GL_MAX_CLIP_PLANES               0x0D32
    1,   // GL_MAX_TEXTURE_SIZE              0x0D33
    1,   // GL_MAX_PIXEL_MAP_TABLE           0x0D34
    1,   // GL_MAX_ATTRIB_STACK_DEPTH        0x0D35
    1,   // GL_MAX_MODELVIEW_STACK_DEPTH     0x0D36
    1,   // GL_MAX_NAME_STACK_DEPTH          0x0D37
    1,   // GL_MAX_PROJECTION_STACK_DEPTH    0x0D38
    1,   // GL_MAX_TEXTURE_STACK_DEPTH       0x0D39
    2,   // GL_MAX_VIEWPORT_DIMS             0x0D3A
    0,   //                                  0x0D3B
    0,   //                                  0x0D3C
    0,   //                                  0x0D3D
    0,   //                                  0x0D3E
    0,   //                                  0x0D3F
    0,   //                                  0x0D40
    0,   //                                  0x0D41
    0,   //                                  0x0D42
    0,   //                                  0x0D43
    0,   //                                  0x0D44
    0,   //                                  0x0D45
    0,   //                                  0x0D46
    0,   //                                  0x0D47
    0,   //                                  0x0D48
    0,   //                                  0x0D49
    0,   //                                  0x0D4A
    0,   //                                  0x0D4B
    0,   //                                  0x0D4C
    0,   //                                  0x0D4D
    0,   //                                  0x0D4E
    0,   //                                  0x0D4F
    1,   // GL_SUBPIXEL_BITS                 0x0D50
    1,   // GL_INDEX_BITS                    0x0D51
    1,   // GL_RED_BITS                      0x0D52
    1,   // GL_GREEN_BITS                    0x0D53
    1,   // GL_BLUE_BITS                     0x0D54
    1,   // GL_ALPHA_BITS                    0x0D55
    1,   // GL_DEPTH_BITS                    0x0D56
    1,   // GL_STENCIL_BITS                  0x0D57
    1,   // GL_ACCUM_RED_BITS                0x0D58
    1,   // GL_ACCUM_GREEN_BITS              0x0D59
    1,   // GL_ACCUM_BLUE_BITS               0x0D5A
    1,   // GL_ACCUM_ALPHA_BITS              0x0D5B
    0,   //                                  0x0D5C
    0,   //                                  0x0D5D
    0,   //                                  0x0D5E
    0,   //                                  0x0D5F
    0,   //                                  0x0D60
    0,   //                                  0x0D61
    0,   //                                  0x0D62
    0,   //                                  0x0D63
    0,   //                                  0x0D64
    0,   //                                  0x0D65
    0,   //                                  0x0D66
    0,   //                                  0x0D67
    0,   //                                  0x0D68
    0,   //                                  0x0D69
    0,   //                                  0x0D6A
    0,   //                                  0x0D6B
    0,   //                                  0x0D6C
    0,   //                                  0x0D6D
    0,   //                                  0x0D6E
    0,   //                                  0x0D6F
    1,   // GL_NAME_STACK_DEPTH              0x0D70
    0,   //                                  0x0D71
    0,   //                                  0x0D72
    0,   //                                  0x0D73
    0,   //                                  0x0D74
    0,   //                                  0x0D75
    0,   //                                  0x0D76
    0,   //                                  0x0D77
    0,   //                                  0x0D78
    0,   //                                  0x0D79
    0,   //                                  0x0D7A
    0,   //                                  0x0D7B
    0,   //                                  0x0D7C
    0,   //                                  0x0D7D
    0,   //                                  0x0D7E
    0,   //                                  0x0D7F
    1,   // GL_AUTO_NORMAL                   0x0D80
    0,   //                                  0x0D81
    0,   //                                  0x0D82
    0,   //                                  0x0D83
    0,   //                                  0x0D84
    0,   //                                  0x0D85
    0,   //                                  0x0D86
    0,   //                                  0x0D87
    0,   //                                  0x0D88
    0,   //                                  0x0D89
    0,   //                                  0x0D8A
    0,   //                                  0x0D8B
    0,   //                                  0x0D8C
    0,   //                                  0x0D8D
    0,   //                                  0x0D8E
    0,   //                                  0x0D8F
    1,   // GL_MAP1_COLOR_4                  0x0D90
    1,   // GL_MAP1_INDEX                    0x0D91
    1,   // GL_MAP1_NORMAL                   0x0D92
    1,   // GL_MAP1_TEXTURE_COORD_1          0x0D93
    1,   // GL_MAP1_TEXTURE_COORD_2          0x0D94
    1,   // GL_MAP1_TEXTURE_COORD_3          0x0D95
    1,   // GL_MAP1_TEXTURE_COORD_4          0x0D96
    1,   // GL_MAP1_VERTEX_3                 0x0D97
    1,   // GL_MAP1_VERTEX_4                 0x0D98
    0,   //                                  0x0D99
    0,   //                                  0x0D9A
    0,   //                                  0x0D9B
    0,   //                                  0x0D9C
    0,   //                                  0x0D9D
    0,   //                                  0x0D9E
    0,   //                                  0x0D9F
    0,   //                                  0x0DA0
    0,   //                                  0x0DA1
    0,   //                                  0x0DA2
    0,   //                                  0x0DA3
    0,   //                                  0x0DA4
    0,   //                                  0x0DA5
    0,   //                                  0x0DA6
    0,   //                                  0x0DA7
    0,   //                                  0x0DA8
    0,   //                                  0x0DA9
    0,   //                                  0x0DAA
    0,   //                                  0x0DAB
    0,   //                                  0x0DAC
    0,   //                                  0x0DAD
    0,   //                                  0x0DAE
    0,   //                                  0x0DAF
    1,   // GL_MAP2_COLOR_4                  0x0DB0
    1,   // GL_MAP2_INDEX                    0x0DB1
    1,   // GL_MAP2_NORMAL                   0x0DB2
    1,   // GL_MAP2_TEXTURE_COORD_1          0x0DB3
    1,   // GL_MAP2_TEXTURE_COORD_2          0x0DB4
    1,   // GL_MAP2_TEXTURE_COORD_3          0x0DB5
    1,   // GL_MAP2_TEXTURE_COORD_4          0x0DB6
    1,   // GL_MAP2_VERTEX_3                 0x0DB7
    1,   // GL_MAP2_VERTEX_4                 0x0DB8
    0,   //                                  0x0DB9
    0,   //                                  0x0DBA
    0,   //                                  0x0DBB
    0,   //                                  0x0DBC
    0,   //                                  0x0DBD
    0,   //                                  0x0DBE
    0,   //                                  0x0DBF
    0,   //                                  0x0DC0
    0,   //                                  0x0DC1
    0,   //                                  0x0DC2
    0,   //                                  0x0DC3
    0,   //                                  0x0DC4
    0,   //                                  0x0DC5
    0,   //                                  0x0DC6
    0,   //                                  0x0DC7
    0,   //                                  0x0DC8
    0,   //                                  0x0DC9
    0,   //                                  0x0DCA
    0,   //                                  0x0DCB
    0,   //                                  0x0DCC
    0,   //                                  0x0DCD
    0,   //                                  0x0DCE
    0,   //                                  0x0DCF
    2,   // GL_MAP1_GRID_DOMAIN              0x0DD0
    1,   // GL_MAP1_GRID_SEGMENTS            0x0DD1
    4,   // GL_MAP2_GRID_DOMAIN              0x0DD2
    2,   // GL_MAP2_GRID_SEGMENTS            0x0DD3
    0,   //                                  0x0DD4
    0,   //                                  0x0DD5
    0,   //                                  0x0DD6
    0,   //                                  0x0DD7
    0,   //                                  0x0DD8
    0,   //                                  0x0DD9
    0,   //                                  0x0DDA
    0,   //                                  0x0DDB
    0,   //                                  0x0DDC
    0,   //                                  0x0DDD
    0,   //                                  0x0DDE
    0,   //                                  0x0DDF
    1,   // GL_TEXTURE_1D                    0x0DE0
    1,   // GL_TEXTURE_2D                    0x0DE1
};

GLint __glGet_size(GLenum sq)
{
    if (RANGE(sq, GET_INDEX_MIN, GET_INDEX_MAX))
        return((GLint) gabGetSize[sq - GET_INDEX_MIN]);
    else if (RANGE(sq, GL_CLIP_PLANE0, GL_CLIP_PLANE5)
          || RANGE(sq, GL_LIGHT0, GL_LIGHT7))
        return(1);
    else
        return(0);
}
#endif //!_CLIENTSIDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\dllinit.c ===
/******************************Module*Header*******************************\
* Module Name: dllinit.c
*
* (Brief description)
*
* Created: 18-Oct-1993 14:13:21
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1993 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "batchinf.h"
#include "glteb.h"
#include "glapi.h"
#include "glsbcltu.h"
#ifdef _CLIENTSIDE_
#include "glscreen.h"
#include "glgenwin.h"
#endif //_CLIENTSIDE_
#include "context.h"
#include "global.h"
#include "parray.h"
#include "gencx.h"
#include "cpu.h"
#include "fixed.h"

#ifdef _CLIENTSIDE_
// Global screen access info.  This is NULL if screen access is not available.

SCREENINFO *gpScreenInfo = NULL;

extern GLubyte *dBufFill;
extern GLubyte *dBufTopLeft;

//
// This global multiply-lookup table helps with pixel-related functions.
//

BYTE gbMulTable[256*256+4];
BYTE gbSatTable[256+256];

//
// This global inverse-lookup table helps with rasterization setup
//

#define INV_TABLE_SIZE  (1 << __GL_VERTEX_FRAC_BITS) * (__GL_MAX_INV_TABLE + 1)

__GLfloat invTable[INV_TABLE_SIZE];

// Global thread local storage index.  Allocated at process attach.
// This is the slot reserved in thread local storage for per-thread
// GLTLSINFO structures.

static DWORD dwTlsIndex = 0xFFFFFFFF;

static BOOL bProcessInitialized = FALSE;

// Offset into the TEB where dwTlsIndex is
// This enables us to directly access our TLS data in the TEB

#if defined(_WIN64)
#define NT_TLS_OFFSET 5248
#else
#define NT_TLS_OFFSET 3600
#endif

#define WIN95_TLS_OFFSET 136

DWORD dwTlsOffset;

// Platform indicator for conditional code
DWORD dwPlatformId;

// Thread count
LONG lThreadsAttached = 0;

// Global header node for the linked list of GLGENwindow structures.
// The semaphore in the header node is used as the list access semaphore.

GLGENwindow gwndHeader;

// Synchronization object for pixel formats
CRITICAL_SECTION gcsPixelFormat;

// Protection for palette watcher
CRITICAL_SECTION gcsPaletteWatcher;

#ifdef GL_METAFILE
BOOL (APIENTRY *pfnGdiAddGlsRecord)(HDC hdc, DWORD cb, BYTE *pb,
                                    LPRECTL prclBounds);
BOOL (APIENTRY *pfnGdiAddGlsBounds)(HDC hdc, LPRECTL prclBounds);
BOOL (APIENTRY *pfnGdiIsMetaPrintDC)(HDC hdc);
#endif

#endif //_CLIENTSIDE_

// OpenGL client debug flag
#if DBG
long glDebugLevel;
ULONG glDebugFlags;
#endif

BOOL bDirectScreen = FALSE;

PFN_GETSURFACEFROMDC pfnGetSurfaceFromDC = NULL;

/******************************Public*Routine******************************\
*
* DdbdToCount
*
* Converts a DDBD constant to its equivalent number
*
* History:
*  Mon Aug 26 14:11:34 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD APIENTRY DdbdToCount(DWORD ddbd)
{
    switch(ddbd)
    {
    case DDBD_1:
        return 1;
    case DDBD_2:
        return 2;
    case DDBD_4:
        return 4;
    case DDBD_8:
        return 8;
    case DDBD_16:
        return 16;
    case DDBD_24:
        return 24;
    case DDBD_32:
        return 32;
    }
    ASSERTOPENGL(FALSE, "DdbdToCount: Invalid ddbd\n");
    return 0;
}

/******************************Public*Routine******************************\
* GLInitializeProcess
*
* Called from OPENGL32.DLL entry point for PROCESS_ATTACH.
*
* History:
*  01-Nov-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL GLInitializeProcess()
{
    PVOID pv;
#ifdef _CLIENTSIDE_
    OSVERSIONINFO osvi;
#endif

    // Attempt to locate GDI exports for metafiling support
    {
        HMODULE hdll;

        hdll = GetModuleHandleA("gdi32");
        ASSERTOPENGL(hdll != NULL, "Unable to get gdi32 handle\n");
        *(PROC *)&pfnGdiAddGlsRecord = GetProcAddress(hdll, "GdiAddGlsRecord");
        *(PROC *)&pfnGdiAddGlsBounds = GetProcAddress(hdll, "GdiAddGlsBounds");
        *(PROC *)&pfnGdiIsMetaPrintDC = GetProcAddress(hdll,
                                                       "GdiIsMetaPrintDC");

#ifdef ALLOW_DDRAW_SURFACES
        hdll = GetModuleHandleA("ddraw");
        ASSERTOPENGL(hdll != NULL, "Unable to get ddraw handle\n");
        pfnGetSurfaceFromDC = (PFN_GETSURFACEFROMDC)
            GetProcAddress(hdll, "GetSurfaceFromDC");
#endif
    }

#if DBG
#define STR_OPENGL_DEBUG (PCSTR)"Software\\Microsoft\\Windows\\CurrentVersion\\DebugOpenGL"
    {
        HKEY hkDebug;

        // Initialize debugging level and flags.

        glDebugLevel = LEVEL_ERROR;
        glDebugFlags = 0;
        if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                           STR_OPENGL_DEBUG,
                           0,
                           KEY_QUERY_VALUE,
                           &hkDebug) == ERROR_SUCCESS )
        {
            DWORD dwDataType;
            DWORD cjSize;
            long lTmp;

            cjSize = sizeof(long);
            if ( (RegQueryValueExA(hkDebug,
                                   (LPSTR) "glDebugLevel",
                                   (LPDWORD) NULL,
                                   &dwDataType,
                                   (LPBYTE) &lTmp,
                                   &cjSize) == ERROR_SUCCESS) )
            {
                glDebugLevel = lTmp;
            }

            cjSize = sizeof(long);
            if ( (RegQueryValueExA(hkDebug,
                                   (LPSTR) "glDebugFlags",
                                   (LPDWORD) NULL,
                                   &dwDataType,
                                   (LPBYTE) &lTmp,
                                   &cjSize) == ERROR_SUCCESS) )
            {
                glDebugFlags = (ULONG) lTmp;
            }

            RegCloseKey(hkDebug);
        }
    }
#endif

#ifdef _CLIENTSIDE_
// Determine which platform we're running on and remember it

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (!GetVersionEx(&osvi))
    {
        WARNING1("GetVersionEx failed with %d\n", GetLastError());
        goto EH_Fail;
    }

    dwPlatformId = osvi.dwPlatformId;

    if (!(
          (dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ||
          (dwPlatformId == VER_PLATFORM_WIN32_NT
             && !(osvi.dwMajorVersion == 3 && osvi.dwMinorVersion <= 51)
          )
         )
       )
    {
        WARNING("DLL must be run on NT 4.0 or Win95");
        goto EH_Fail;
    }

// Allocate a thread local storage slot.

    if ( (dwTlsIndex = TlsAlloc()) == 0xFFFFFFFF )
    {
        WARNING("DllInitialize: TlsAlloc failed\n");
        goto EH_Fail;
    }

    // Set up the offset to the TLS slot, OS-specific

    if (dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        ASSERTOPENGL(FIELD_OFFSET(TEB, TlsSlots) == NT_TLS_OFFSET,
                     "NT TLS offset not at expected location");

        dwTlsOffset = dwTlsIndex*sizeof(DWORD_PTR)+NT_TLS_OFFSET;
    }

#if !defined(_WIN64)

    else
    {
        // We don't have Win95's TIB type available so the assert is
        // slightly different
        ASSERTOPENGL(((ULONG_PTR)(NtCurrentTeb()->ThreadLocalStoragePointer)-
                      (ULONG_PTR)NtCurrentTeb()) == WIN95_TLS_OFFSET,
                     "Win95 TLS offset not at expected location");

        dwTlsOffset = dwTlsIndex*sizeof(DWORD)+WIN95_TLS_OFFSET;
    }

#endif
#endif

// Reserve memory for the local handle table.

    if ( (pLocalTable = (PLHE) VirtualAlloc (
                            (LPVOID) NULL,    // let base locate it
                            MAX_HANDLES*sizeof(LHE),
                            MEM_RESERVE | MEM_TOP_DOWN,
                            PAGE_READWRITE
                            )) == (PLHE) NULL )
    {
        WARNING("DllInitialize: VirtualAlloc failed\n");
        goto EH_TlsIndex;
    }

    // Initialize the local handle manager semaphore.
    __try
    {
        INITIALIZECRITICALSECTION(&semLocal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        goto EH_LocalTable;
    }

#ifdef _CLIENTSIDE_
    // Initialize the GLGENwindow list semaphore.
    __try
    {
        INITIALIZECRITICALSECTION(&gwndHeader.sem);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        goto EH_semLocal;
    }
    gwndHeader.pNext = &gwndHeader;

    // Initialize the pixel format critical section
    __try
    {
        INITIALIZECRITICALSECTION(&gcsPixelFormat);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        goto EH_gwndHeader;
    }

    // Initialize the palette watcher critical section.
    __try
    {
        INITIALIZECRITICALSECTION(&gcsPaletteWatcher);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        goto EH_PixelFormat;
    }

// Initialize direct screen access.

    if (GetSystemMetrics(SM_CMONITORS) > 1)
    {
        gpScreenInfo = NULL;
    }
    else
    {
#if _WIN32_WINNT >= 0x0501
        BOOL wow64Process;

        if (IsWow64Process(GetCurrentProcess(), &wow64Process) && wow64Process)
            gpScreenInfo = NULL;
        else
#endif
        gpScreenInfo = (SCREENINFO *)ALLOCZ(sizeof(SCREENINFO));
    }

    if ( gpScreenInfo )
    {
        UINT uiOldErrorMode;
        HRESULT hr;

        // We want to ensure that DDraw doesn't pop up any message
        // boxes on failure when we call DirectDrawCreate.  DDraw
        // does errors on a different thread which it creates just
        // for the error.  It waits for the error to complete before
        // returning.  This function is running inside the loader
        // DllInitialize critical section, though, so other threads
        // do not get to run, causing a deadlock.
        // Force the error mode to get around this.
        uiOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

        hr = DirectDrawCreate(NULL, &gpScreenInfo->pdd, NULL);

        SetErrorMode(uiOldErrorMode);

        if (hr == DD_OK)
        {
            hr = gpScreenInfo->pdd->lpVtbl->
                SetCooperativeLevel(gpScreenInfo->pdd, NULL, DDSCL_NORMAL);

            if (hr == DD_OK)
            {
                gpScreenInfo->gdds.ddsd.dwSize = sizeof(DDSURFACEDESC);
                gpScreenInfo->gdds.ddsd.dwFlags = DDSD_CAPS;
                gpScreenInfo->gdds.ddsd.ddsCaps.dwCaps =
                    DDSCAPS_PRIMARYSURFACE;
                hr = gpScreenInfo->pdd->lpVtbl->
                    CreateSurface(gpScreenInfo->pdd, &gpScreenInfo->gdds.ddsd,
                                  &gpScreenInfo->gdds.pdds, NULL);
            }

            if (hr == DD_OK)
            {
#if DBG

#define LEVEL_SCREEN   LEVEL_INFO

                gpScreenInfo->gdds.pdds->lpVtbl->
                    GetSurfaceDesc(gpScreenInfo->gdds.pdds,
                                   &gpScreenInfo->gdds.ddsd);
                DBGLEVEL (LEVEL_SCREEN, "=============================\n");
                DBGLEVEL (LEVEL_SCREEN, "Direct screen access enabled for OpenGL\n\n");
                DBGLEVEL (LEVEL_SCREEN, "Surface info:\n");
                DBGLEVEL1(LEVEL_SCREEN, "\tdwSize        = 0x%lx\n",
                    gpScreenInfo->gdds.ddsd.dwSize);
                DBGLEVEL1(LEVEL_SCREEN, "\tdwWidth       = %ld\n",
                    gpScreenInfo->gdds.ddsd.dwWidth);
                DBGLEVEL1(LEVEL_SCREEN, "\tdwHeight      = %ld\n",
                    gpScreenInfo->gdds.ddsd.dwHeight);
                DBGLEVEL1(LEVEL_SCREEN, "\tlStride       = 0x%lx\n",
                    gpScreenInfo->gdds.ddsd.lPitch);
                DBGLEVEL1(LEVEL_SCREEN, "\tdwBitCount    = %ld\n",
                    gpScreenInfo->gdds.ddsd.ddpfPixelFormat.dwRGBBitCount);

                gpScreenInfo->gdds.pdds->lpVtbl->
                    Lock(gpScreenInfo->gdds.pdds,
                         NULL, &gpScreenInfo->gdds.ddsd,
                         DDLOCK_SURFACEMEMORYPTR, NULL);
                DBGLEVEL1(LEVEL_SCREEN, "\tdwOffSurface  = 0x%lx\n",
                    gpScreenInfo->gdds.ddsd.lpSurface);
                gpScreenInfo->gdds.pdds->lpVtbl->
                    Unlock(gpScreenInfo->gdds.pdds, gpScreenInfo->gdds.ddsd.lpSurface);
                DBGLEVEL (LEVEL_SCREEN, "=============================\n");
#endif

           // Verify screen access

                if (gpScreenInfo->gdds.pdds->lpVtbl->
                    GetSurfaceDesc(gpScreenInfo->gdds.pdds,
                                   &gpScreenInfo->gdds.ddsd) != DD_OK ||
                    gpScreenInfo->gdds.pdds->lpVtbl->
                    Lock(gpScreenInfo->gdds.pdds,
                         NULL, &gpScreenInfo->gdds.ddsd,
                         DDLOCK_SURFACEMEMORYPTR, NULL) != DD_OK)
                {
                    DBGLEVEL(LEVEL_SCREEN,
                             "Direct screen access failure : disabling\n");
                }
                else
                {
                    gpScreenInfo->gdds.dwBitDepth =
                        DdPixDepthToCount(gpScreenInfo->gdds.ddsd.
                                          ddpfPixelFormat.dwRGBBitCount);
                    gpScreenInfo->gdds.pdds->lpVtbl->
                        Unlock(gpScreenInfo->gdds.pdds,
                               gpScreenInfo->gdds.ddsd.lpSurface);

                    bDirectScreen = TRUE;
                }
            }
#if DBG
            else
            {
                DBGLEVEL (LEVEL_SCREEN, "=============================\n");
                DBGLEVEL2(LEVEL_SCREEN,
                          "Screen access failed code 0x%08lX (%s)\n",
                          hr, (hr == DDERR_NOTFOUND) ? "DDERR_NOTFOUND" :
                                                       "unknown");
                DBGLEVEL (LEVEL_SCREEN, "=============================\n");
            }
#endif
        }
        else
        {
            DBGLEVEL(LEVEL_SCREEN, "DirectDrawCreate failed\n");
        }
    }

    if (!bDirectScreen)
    {
        if (gpScreenInfo)
        {
            if (gpScreenInfo->gdds.pdds)
            {
                gpScreenInfo->gdds.pdds->lpVtbl->
                    Release(gpScreenInfo->gdds.pdds);
            }
            if (gpScreenInfo->pdd)
            {
                gpScreenInfo->pdd->lpVtbl->Release(gpScreenInfo->pdd);
            }
            FREE(gpScreenInfo);
	    gpScreenInfo = NULL;
        }
    }

#endif

    // Set up our multiplication table:

    {
        BYTE *pMulTable = gbMulTable;
        ULONG i, j;

        for (i = 0; i < 256; i++) {
            ULONG tmp = 0;

            for (j = 0; j < 256; j++, tmp += i) {
                *pMulTable++ = (BYTE)(tmp >> 8);
            }
        }
    }

    // Set up our saturation table:

    {
        ULONG i;

        for (i = 0; i < 256; i++)
            gbSatTable[i] = (BYTE)i;

        for (; i < (256+256); i++)
            gbSatTable[i] = 255;
    }

    // Set up inverse-lookup table:

    {
       __GLfloat accum = (__GLfloat)(1.0 / (__GLfloat)__GL_VERTEX_FRAC_ONE);
       GLint i;

       invTable[0] = (__GLfloat)0.0;

       for (i = 1; i < INV_TABLE_SIZE; i++) {

           invTable[i] = __glOne / accum;
           accum += (__GLfloat)(1.0 / (__GLfloat)__GL_VERTEX_FRAC_ONE);
        }
    }

    bProcessInitialized = TRUE;

    return TRUE;

 EH_PixelFormat:
    DELETECRITICALSECTION(&gcsPixelFormat);
 EH_gwndHeader:
    DELETECRITICALSECTION(&gwndHeader.sem);
 EH_semLocal:
    DELETECRITICALSECTION(&semLocal);
 EH_LocalTable:
    VirtualFree(pLocalTable, 0, MEM_RELEASE);
 EH_TlsIndex:
    TlsFree(dwTlsIndex);
    dwTlsIndex = 0xFFFFFFFF;
 EH_Fail:
    return FALSE;
}

/******************************Public*Routine******************************\
* GLUnInitializeProcess
*
* Called from OPENGL32.DLL entry point for PROCESS_DETACH.
*
* History:
*  01-Nov-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void GLUnInitializeProcess()
{
// If we never finished process initialization, quit now.

    if (!bProcessInitialized)
	return;

// Cleanup stray HGLRCs that the app may have forgotten to delete.
    {
        static GLTEBINFO gltebInfoTmp;

    // Need a temporary GLTEBINFO for this thread in order to do the
    // cleanup processing.

        ASSERTOPENGL(!CURRENT_GLTEBINFO(),
                     "GLUnInitializeProcess: GLTEBINFO not NULL!\n");
        // made static and no longer need memset
        // memset(&gltebInfoTmp, 0, sizeof(gltebInfoTmp));
        SET_CURRENT_GLTEBINFO(&gltebInfoTmp);

        vCleanupAllLRC();

        SET_CURRENT_GLTEBINFO((PGLTEBINFO) NULL);
    }

// Cleanup window tracking structures (GLGENwindow structs).

    vCleanupWnd();

// Cleanup evaluator arrays

    if (dBufFill)
	FREE(dBufFill);
    if (dBufTopLeft)
	FREE(dBufTopLeft);

// Screen access shutdown.

    if (gpScreenInfo)
    {
        if (gpScreenInfo->gdds.pdds)
        {
            gpScreenInfo->gdds.pdds->lpVtbl->Release(gpScreenInfo->gdds.pdds);
        }
        if (gpScreenInfo->pdd)
        {
            gpScreenInfo->pdd->lpVtbl->Release(gpScreenInfo->pdd);
        }
        FREE(gpScreenInfo);
    }

// Free the TLS slot.

    if (dwTlsIndex != 0xFFFFFFFF)
	if (!TlsFree(dwTlsIndex))
	    RIP("DllInitialize: TlsFree failed\n");

// Free the global semaphores.

    DELETECRITICALSECTION(&gcsPaletteWatcher);
    DELETECRITICALSECTION(&gcsPixelFormat);
    DELETECRITICALSECTION(&gwndHeader.sem);
    DELETECRITICALSECTION(&semLocal);

// Free the local handle table.

    if ( pLocalTable )
        VirtualFree(pLocalTable, 0, MEM_RELEASE);
}

/******************************Public*Routine******************************\
* GLInitializeThread
*
* Called from OPENGL32.DLL entry point for THREAD_ATTACH.  May assume that
* GLInitializeProcess has succeeded.
*
\**************************************************************************/

VOID GLInitializeThread(ULONG ulReason)
{
    GLTEBINFO *pglti;
    GLMSGBATCHINFO *pMsgBatchInfo;
    POLYARRAY *pa;

#if !defined(_WIN95_) && defined(_X86_)
    {
        TEB *pteb;

        pteb = NtCurrentTeb();

        // Set up linear pointers to TEB regions in the TEB
        // this saves an addition when referencing these values
        // This must occur early so that these pointers are available
        // for the rest of thread initialization
        ((POLYARRAY *)pteb->glReserved1)->paTeb =
            (POLYARRAY *)pteb->glReserved1;
        pteb->glTable = pteb->glDispatchTable;
    }
#endif

    pglti = (GLTEBINFO *)ALLOCZ(sizeof(GLTEBINFO));
    SET_CURRENT_GLTEBINFO(pglti);

    if (pglti)
    {
        pa = GLTEB_CLTPOLYARRAY();
        pa->flags = 0;      // not in begin mode

        // Save shared section pointer in POLYARRAY for fast pointer access
        pa->pMsgBatchInfo = (PVOID) pglti->glMsgBatchInfo;

        pMsgBatchInfo = (GLMSGBATCHINFO *) pa->pMsgBatchInfo;
        pMsgBatchInfo->MaximumOffset
            = SHARED_SECTION_SIZE - GLMSG_ALIGN(sizeof(ULONG));
        pMsgBatchInfo->FirstOffset
            = GLMSG_ALIGN(sizeof(GLMSGBATCHINFO));
        pMsgBatchInfo->NextOffset
            = GLMSG_ALIGN(sizeof(GLMSGBATCHINFO));
        SetCltProcTable(&glNullCltProcTable, &glNullExtProcTable, TRUE);
        GLTEB_SET_CLTCURRENTRC(NULL);
        GLTEB_SET_CLTPOLYMATERIAL(NULL);
        GLTEB_SET_CLTDRIVERSLOT(NULL);

#if !defined(_WIN95_)
        ASSERTOPENGL((ULONG_PTR) pMsgBatchInfo == GLMSG_ALIGNPTR(pMsgBatchInfo),
                     "bad shared memory alignment!\n");
#endif
    }
    else
    {
        // This can be made into a WARNING (debug builds only) later on.
        DbgPrint ("Memory alloc failed for TebInfo structure, thread may AV if GL calls are made without MakeCurrent\n");
    }
}

/******************************Public*Routine******************************\
* GLUnInitializeThread
*
* Called from OPENGL32.DLL entry point for THREAD_DETACH.
*
* The server generic driver should cleanup on its own.  Same for the
* installable driver.
*
\**************************************************************************/

VOID GLUnInitializeThread(VOID)
{
// If we never finished process initialization, quit now.

    if (!bProcessInitialized)
	return;

    if (!CURRENT_GLTEBINFO())
    {
        return;
    }

    if (GLTEB_CLTCURRENTRC() != NULL)
    {
        PLRC plrc = GLTEB_CLTCURRENTRC();

        // May be an application error

        DBGERROR("GLUnInitializeThread: RC is current when thread exits\n");

        // Release the RC

        plrc->tidCurrent = INVALID_THREAD_ID;
        plrc->gwidCurrent.iType = GLWID_ERROR;
        GLTEB_SET_CLTCURRENTRC(NULL);
        vUnlockHandle((ULONG_PTR)(plrc->hrc));
    }
    // GLTEB_SET_CLTPROCTABLE(&glNullCltProcTable,&glNullExtProcTable);

    if (GLTEB_CLTPOLYMATERIAL())
	FreePolyMaterial();

    FREE(CURRENT_GLTEBINFO());
    SET_CURRENT_GLTEBINFO(NULL);
}

/******************************Public*Routine******************************\
* DllInitialize
*
* This is the entry point for OPENGL32.DLL, which is called each time
* a process or thread that is linked to it is created or terminated.
*
\**************************************************************************/

BOOL DllInitialize(HMODULE hModule, ULONG Reason, PVOID Reserved)
{
// Do the appropriate task for process and thread attach/detach.

    DBGLEVEL3(LEVEL_INFO, "DllInitialize: %s  Pid %d, Tid %d\n",
        Reason == DLL_PROCESS_ATTACH ? "PROCESS_ATTACH" :
        Reason == DLL_PROCESS_DETACH ? "PROCESS_DETACH" :
        Reason == DLL_THREAD_ATTACH  ? "THREAD_ATTACH" :
        Reason == DLL_THREAD_DETACH  ? "THREAD_DETACH" :
                                       "Reason UNKNOWN!",
        GetCurrentProcessId(), GetCurrentThreadId());

    switch (Reason)
    {
    case DLL_THREAD_ATTACH:
    case DLL_PROCESS_ATTACH:

        if (Reason == DLL_PROCESS_ATTACH)
        {
            if (!GLInitializeProcess())
                return FALSE;
        }

        InterlockedIncrement(&lThreadsAttached);
        GLInitializeThread(Reason);

        break;

    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:

        GLUnInitializeThread();
        InterlockedDecrement(&lThreadsAttached);

        if ( Reason == DLL_PROCESS_DETACH )
        {
            GLUnInitializeProcess();
        }

        break;

    default:
        RIP("DllInitialize: unknown reason!\n");
        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\glapi.c ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT */

#include "precomp.h"
#pragma hdrstop

#include "glapi.h"

void APIENTRY
glNewList ( IN GLuint list, IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glNewList)( list, mode );
}

void APIENTRY
glEndList ( void )
{
    (*GLTEB_CLTDISPATCHTABLE()->glEndList)( );
}

void APIENTRY
glCallList ( IN GLuint list )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glCallList)( list );
}

void APIENTRY
glCallLists ( IN GLsizei n, IN GLenum type, IN const GLvoid *lists )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glCallLists)( n, type, lists );
}

void APIENTRY
glDeleteLists ( IN GLuint list, IN GLsizei range )
{
    (*GLTEB_CLTDISPATCHTABLE()->glDeleteLists)( list, range );
}

GLuint APIENTRY
glGenLists ( IN GLsizei range )
{
    return( (*GLTEB_CLTDISPATCHTABLE()->glGenLists)( range ) );
}

void APIENTRY
glListBase ( IN GLuint base )
{
    (*GLTEB_CLTDISPATCHTABLE()->glListBase)( base );
}

void APIENTRY
glBegin ( IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glBegin)( mode );
}

void APIENTRY
glBitmap ( IN GLsizei width, IN GLsizei height, IN GLfloat xorig, IN GLfloat yorig, IN GLfloat xmove, IN GLfloat ymove, IN const GLubyte bitmap[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glBitmap)( width, height, xorig, yorig, xmove, ymove, bitmap );
}

void APIENTRY
glColor3b ( IN GLbyte red, IN GLbyte green, IN GLbyte blue )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3b)( red, green, blue );
}

void APIENTRY
glColor3bv ( IN const GLbyte v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3bv)( v );
}

void APIENTRY
glColor3d ( IN GLdouble red, IN GLdouble green, IN GLdouble blue )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3d)( red, green, blue );
}

void APIENTRY
glColor3dv ( IN const GLdouble v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3dv)( v );
}

void APIENTRY
glColor3f ( IN GLfloat red, IN GLfloat green, IN GLfloat blue )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3f)( red, green, blue );
}

void APIENTRY
glColor3fv ( IN const GLfloat v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3fv)( v );
}

void APIENTRY
glColor3i ( IN GLint red, IN GLint green, IN GLint blue )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3i)( red, green, blue );
}

void APIENTRY
glColor3iv ( IN const GLint v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3iv)( v );
}

void APIENTRY
glColor3s ( IN GLshort red, IN GLshort green, IN GLshort blue )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3s)( red, green, blue );
}

void APIENTRY
glColor3sv ( IN const GLshort v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3sv)( v );
}

void APIENTRY
glColor3ub ( IN GLubyte red, IN GLubyte green, IN GLubyte blue )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3ub)( red, green, blue );
}

void APIENTRY
glColor3ubv ( IN const GLubyte v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3ubv)( v );
}

void APIENTRY
glColor3ui ( IN GLuint red, IN GLuint green, IN GLuint blue )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3ui)( red, green, blue );
}

void APIENTRY
glColor3uiv ( IN const GLuint v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3uiv)( v );
}

void APIENTRY
glColor3us ( IN GLushort red, IN GLushort green, IN GLushort blue )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3us)( red, green, blue );
}

void APIENTRY
glColor3usv ( IN const GLushort v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor3usv)( v );
}

void APIENTRY
glColor4b ( IN GLbyte red, IN GLbyte green, IN GLbyte blue, IN GLbyte alpha )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4b)( red, green, blue, alpha );
}

void APIENTRY
glColor4bv ( IN const GLbyte v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4bv)( v );
}

void APIENTRY
glColor4d ( IN GLdouble red, IN GLdouble green, IN GLdouble blue, IN GLdouble alpha )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4d)( red, green, blue, alpha );
}

void APIENTRY
glColor4dv ( IN const GLdouble v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4dv)( v );
}

void APIENTRY
glColor4f ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4f)( red, green, blue, alpha );
}

void APIENTRY
glColor4fv ( IN const GLfloat v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4fv)( v );
}

void APIENTRY
glColor4i ( IN GLint red, IN GLint green, IN GLint blue, IN GLint alpha )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4i)( red, green, blue, alpha );
}

void APIENTRY
glColor4iv ( IN const GLint v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4iv)( v );
}

void APIENTRY
glColor4s ( IN GLshort red, IN GLshort green, IN GLshort blue, IN GLshort alpha )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4s)( red, green, blue, alpha );
}

void APIENTRY
glColor4sv ( IN const GLshort v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4sv)( v );
}

void APIENTRY
glColor4ub ( IN GLubyte red, IN GLubyte green, IN GLubyte blue, IN GLubyte alpha )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4ub)( red, green, blue, alpha );
}

void APIENTRY
glColor4ubv ( IN const GLubyte v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4ubv)( v );
}

void APIENTRY
glColor4ui ( IN GLuint red, IN GLuint green, IN GLuint blue, IN GLuint alpha )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4ui)( red, green, blue, alpha );
}

void APIENTRY
glColor4uiv ( IN const GLuint v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4uiv)( v );
}

void APIENTRY
glColor4us ( IN GLushort red, IN GLushort green, IN GLushort blue, IN GLushort alpha )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4us)( red, green, blue, alpha );
}

void APIENTRY
glColor4usv ( IN const GLushort v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColor4usv)( v );
}

void APIENTRY
glEdgeFlag ( IN GLboolean flag )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEdgeFlag)( flag );
}

void APIENTRY
glEdgeFlagv ( IN const GLboolean flag[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEdgeFlagv)( flag );
}

void APIENTRY
glEnd ( void )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEnd)( );
}

void APIENTRY
glIndexd ( IN GLdouble c )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexd)( c );
}

void APIENTRY
glIndexdv ( IN const GLdouble c[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexdv)( c );
}

void APIENTRY
glIndexf ( IN GLfloat c )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexf)( c );
}

void APIENTRY
glIndexfv ( IN const GLfloat c[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexfv)( c );
}

void APIENTRY
glIndexi ( IN GLint c )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexi)( c );
}

void APIENTRY
glIndexiv ( IN const GLint c[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexiv)( c );
}

void APIENTRY
glIndexs ( IN GLshort c )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexs)( c );
}

void APIENTRY
glIndexsv ( IN const GLshort c[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexsv)( c );
}

void APIENTRY
glNormal3b ( IN GLbyte nx, IN GLbyte ny, IN GLbyte nz )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3b)( nx, ny, nz );
}

void APIENTRY
glNormal3bv ( IN const GLbyte v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3bv)( v );
}

void APIENTRY
glNormal3d ( IN GLdouble nx, IN GLdouble ny, IN GLdouble nz )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3d)( nx, ny, nz );
}

void APIENTRY
glNormal3dv ( IN const GLdouble v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3dv)( v );
}

void APIENTRY
glNormal3f ( IN GLfloat nx, IN GLfloat ny, IN GLfloat nz )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3f)( nx, ny, nz );
}

void APIENTRY
glNormal3fv ( IN const GLfloat v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3fv)( v );
}

void APIENTRY
glNormal3i ( IN GLint nx, IN GLint ny, IN GLint nz )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3i)( nx, ny, nz );
}

void APIENTRY
glNormal3iv ( IN const GLint v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3iv)( v );
}

void APIENTRY
glNormal3s ( IN GLshort nx, IN GLshort ny, IN GLshort nz )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3s)( nx, ny, nz );
}

void APIENTRY
glNormal3sv ( IN const GLshort v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormal3sv)( v );
}

void APIENTRY
glRasterPos2d ( IN GLdouble x, IN GLdouble y )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos2d)( x, y );
}

void APIENTRY
glRasterPos2dv ( IN const GLdouble v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos2dv)( v );
}

void APIENTRY
glRasterPos2f ( IN GLfloat x, IN GLfloat y )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos2f)( x, y );
}

void APIENTRY
glRasterPos2fv ( IN const GLfloat v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos2fv)( v );
}

void APIENTRY
glRasterPos2i ( IN GLint x, IN GLint y )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos2i)( x, y );
}

void APIENTRY
glRasterPos2iv ( IN const GLint v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos2iv)( v );
}

void APIENTRY
glRasterPos2s ( IN GLshort x, IN GLshort y )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos2s)( x, y );
}

void APIENTRY
glRasterPos2sv ( IN const GLshort v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos2sv)( v );
}

void APIENTRY
glRasterPos3d ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos3d)( x, y, z );
}

void APIENTRY
glRasterPos3dv ( IN const GLdouble v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos3dv)( v );
}

void APIENTRY
glRasterPos3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos3f)( x, y, z );
}

void APIENTRY
glRasterPos3fv ( IN const GLfloat v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos3fv)( v );
}

void APIENTRY
glRasterPos3i ( IN GLint x, IN GLint y, IN GLint z )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos3i)( x, y, z );
}

void APIENTRY
glRasterPos3iv ( IN const GLint v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos3iv)( v );
}

void APIENTRY
glRasterPos3s ( IN GLshort x, IN GLshort y, IN GLshort z )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos3s)( x, y, z );
}

void APIENTRY
glRasterPos3sv ( IN const GLshort v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos3sv)( v );
}

void APIENTRY
glRasterPos4d ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos4d)( x, y, z, w );
}

void APIENTRY
glRasterPos4dv ( IN const GLdouble v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos4dv)( v );
}

void APIENTRY
glRasterPos4f ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos4f)( x, y, z, w );
}

void APIENTRY
glRasterPos4fv ( IN const GLfloat v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos4fv)( v );
}

void APIENTRY
glRasterPos4i ( IN GLint x, IN GLint y, IN GLint z, IN GLint w )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos4i)( x, y, z, w );
}

void APIENTRY
glRasterPos4iv ( IN const GLint v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos4iv)( v );
}

void APIENTRY
glRasterPos4s ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos4s)( x, y, z, w );
}

void APIENTRY
glRasterPos4sv ( IN const GLshort v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRasterPos4sv)( v );
}

void APIENTRY
glRectd ( IN GLdouble x1, IN GLdouble y1, IN GLdouble x2, IN GLdouble y2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRectd)( x1, y1, x2, y2 );
}

void APIENTRY
glRectdv ( IN const GLdouble v1[2], IN const GLdouble v2[2] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRectdv)( v1, v2 );
}

void APIENTRY
glRectf ( IN GLfloat x1, IN GLfloat y1, IN GLfloat x2, IN GLfloat y2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRectf)( x1, y1, x2, y2 );
}

void APIENTRY
glRectfv ( IN const GLfloat v1[2], IN const GLfloat v2[2] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRectfv)( v1, v2 );
}

void APIENTRY
glRecti ( IN GLint x1, IN GLint y1, IN GLint x2, IN GLint y2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRecti)( x1, y1, x2, y2 );
}

void APIENTRY
glRectiv ( IN const GLint v1[2], IN const GLint v2[2] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRectiv)( v1, v2 );
}

void APIENTRY
glRects ( IN GLshort x1, IN GLshort y1, IN GLshort x2, IN GLshort y2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRects)( x1, y1, x2, y2 );
}

void APIENTRY
glRectsv ( IN const GLshort v1[2], IN const GLshort v2[2] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glRectsv)( v1, v2 );
}

void APIENTRY
glTexCoord1d ( IN GLdouble s )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord1d)( s );
}

void APIENTRY
glTexCoord1dv ( IN const GLdouble v[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord1dv)( v );
}

void APIENTRY
glTexCoord1f ( IN GLfloat s )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord1f)( s );
}

void APIENTRY
glTexCoord1fv ( IN const GLfloat v[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord1fv)( v );
}

void APIENTRY
glTexCoord1i ( IN GLint s )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord1i)( s );
}

void APIENTRY
glTexCoord1iv ( IN const GLint v[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord1iv)( v );
}

void APIENTRY
glTexCoord1s ( IN GLshort s )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord1s)( s );
}

void APIENTRY
glTexCoord1sv ( IN const GLshort v[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord1sv)( v );
}

void APIENTRY
glTexCoord2d ( IN GLdouble s, IN GLdouble t )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord2d)( s, t );
}

void APIENTRY
glTexCoord2dv ( IN const GLdouble v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord2dv)( v );
}

void APIENTRY
glTexCoord2f ( IN GLfloat s, IN GLfloat t )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord2f)( s, t );
}

void APIENTRY
glTexCoord2fv ( IN const GLfloat v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord2fv)( v );
}

void APIENTRY
glTexCoord2i ( IN GLint s, IN GLint t )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord2i)( s, t );
}

void APIENTRY
glTexCoord2iv ( IN const GLint v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord2iv)( v );
}

void APIENTRY
glTexCoord2s ( IN GLshort s, IN GLshort t )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord2s)( s, t );
}

void APIENTRY
glTexCoord2sv ( IN const GLshort v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord2sv)( v );
}

void APIENTRY
glTexCoord3d ( IN GLdouble s, IN GLdouble t, IN GLdouble r )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord3d)( s, t, r );
}

void APIENTRY
glTexCoord3dv ( IN const GLdouble v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord3dv)( v );
}

void APIENTRY
glTexCoord3f ( IN GLfloat s, IN GLfloat t, IN GLfloat r )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord3f)( s, t, r );
}

void APIENTRY
glTexCoord3fv ( IN const GLfloat v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord3fv)( v );
}

void APIENTRY
glTexCoord3i ( IN GLint s, IN GLint t, IN GLint r )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord3i)( s, t, r );
}

void APIENTRY
glTexCoord3iv ( IN const GLint v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord3iv)( v );
}

void APIENTRY
glTexCoord3s ( IN GLshort s, IN GLshort t, IN GLshort r )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord3s)( s, t, r );
}

void APIENTRY
glTexCoord3sv ( IN const GLshort v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord3sv)( v );
}

void APIENTRY
glTexCoord4d ( IN GLdouble s, IN GLdouble t, IN GLdouble r, IN GLdouble q )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord4d)( s, t, r, q );
}

void APIENTRY
glTexCoord4dv ( IN const GLdouble v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord4dv)( v );
}

void APIENTRY
glTexCoord4f ( IN GLfloat s, IN GLfloat t, IN GLfloat r, IN GLfloat q )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord4f)( s, t, r, q );
}

void APIENTRY
glTexCoord4fv ( IN const GLfloat v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord4fv)( v );
}

void APIENTRY
glTexCoord4i ( IN GLint s, IN GLint t, IN GLint r, IN GLint q )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord4i)( s, t, r, q );
}

void APIENTRY
glTexCoord4iv ( IN const GLint v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord4iv)( v );
}

void APIENTRY
glTexCoord4s ( IN GLshort s, IN GLshort t, IN GLshort r, IN GLshort q )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord4s)( s, t, r, q );
}

void APIENTRY
glTexCoord4sv ( IN const GLshort v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoord4sv)( v );
}

void APIENTRY
glVertex2d ( IN GLdouble x, IN GLdouble y )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex2d)( x, y );
}

void APIENTRY
glVertex2dv ( IN const GLdouble v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex2dv)( v );
}

void APIENTRY
glVertex2f ( IN GLfloat x, IN GLfloat y )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex2f)( x, y );
}

void APIENTRY
glVertex2fv ( IN const GLfloat v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex2fv)( v );
}

void APIENTRY
glVertex2i ( IN GLint x, IN GLint y )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex2i)( x, y );
}

void APIENTRY
glVertex2iv ( IN const GLint v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex2iv)( v );
}

void APIENTRY
glVertex2s ( IN GLshort x, IN GLshort y )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex2s)( x, y );
}

void APIENTRY
glVertex2sv ( IN const GLshort v[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex2sv)( v );
}

void APIENTRY
glVertex3d ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex3d)( x, y, z );
}

void APIENTRY
glVertex3dv ( IN const GLdouble v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex3dv)( v );
}

void APIENTRY
glVertex3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex3f)( x, y, z );
}

void APIENTRY
glVertex3fv ( IN const GLfloat v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex3fv)( v );
}

void APIENTRY
glVertex3i ( IN GLint x, IN GLint y, IN GLint z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex3i)( x, y, z );
}

void APIENTRY
glVertex3iv ( IN const GLint v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex3iv)( v );
}

void APIENTRY
glVertex3s ( IN GLshort x, IN GLshort y, IN GLshort z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex3s)( x, y, z );
}

void APIENTRY
glVertex3sv ( IN const GLshort v[3] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex3sv)( v );
}

void APIENTRY
glVertex4d ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex4d)( x, y, z, w );
}

void APIENTRY
glVertex4dv ( IN const GLdouble v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex4dv)( v );
}

void APIENTRY
glVertex4f ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex4f)( x, y, z, w );
}

void APIENTRY
glVertex4fv ( IN const GLfloat v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex4fv)( v );
}

void APIENTRY
glVertex4i ( IN GLint x, IN GLint y, IN GLint z, IN GLint w )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex4i)( x, y, z, w );
}

void APIENTRY
glVertex4iv ( IN const GLint v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex4iv)( v );
}

void APIENTRY
glVertex4s ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex4s)( x, y, z, w );
}

void APIENTRY
glVertex4sv ( IN const GLshort v[4] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertex4sv)( v );
}

void APIENTRY
glClipPlane ( IN GLenum plane, IN const GLdouble equation[4] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glClipPlane)( plane, equation );
}

void APIENTRY
glColorMaterial ( IN GLenum face, IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glColorMaterial)( face, mode );
}

void APIENTRY
glCullFace ( IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glCullFace)( mode );
}

void APIENTRY
glFogf ( IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFogf)( pname, param );
}

void APIENTRY
glFogfv ( IN GLenum pname, IN const GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFogfv)( pname, params );
}

void APIENTRY
glFogi ( IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFogi)( pname, param );
}

void APIENTRY
glFogiv ( IN GLenum pname, IN const GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFogiv)( pname, params );
}

void APIENTRY
glFrontFace ( IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFrontFace)( mode );
}

void APIENTRY
glHint ( IN GLenum target, IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glHint)( target, mode );
}

void APIENTRY
glLightf ( IN GLenum light, IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLightf)( light, pname, param );
}

void APIENTRY
glLightfv ( IN GLenum light, IN GLenum pname, IN const GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLightfv)( light, pname, params );
}

void APIENTRY
glLighti ( IN GLenum light, IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLighti)( light, pname, param );
}

void APIENTRY
glLightiv ( IN GLenum light, IN GLenum pname, IN const GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLightiv)( light, pname, params );
}

void APIENTRY
glLightModelf ( IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLightModelf)( pname, param );
}

void APIENTRY
glLightModelfv ( IN GLenum pname, IN const GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLightModelfv)( pname, params );
}

void APIENTRY
glLightModeli ( IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLightModeli)( pname, param );
}

void APIENTRY
glLightModeliv ( IN GLenum pname, IN const GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLightModeliv)( pname, params );
}

void APIENTRY
glLineStipple ( IN GLint factor, IN GLushort pattern )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLineStipple)( factor, pattern );
}

void APIENTRY
glLineWidth ( IN GLfloat width )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLineWidth)( width );
}

void APIENTRY
glMaterialf ( IN GLenum face, IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMaterialf)( face, pname, param );
}

void APIENTRY
glMaterialfv ( IN GLenum face, IN GLenum pname, IN const GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMaterialfv)( face, pname, params );
}

void APIENTRY
glMateriali ( IN GLenum face, IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMateriali)( face, pname, param );
}

void APIENTRY
glMaterialiv ( IN GLenum face, IN GLenum pname, IN const GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMaterialiv)( face, pname, params );
}

void APIENTRY
glPointSize ( IN GLfloat size )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPointSize)( size );
}

void APIENTRY
glPolygonMode ( IN GLenum face, IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPolygonMode)( face, mode );
}

void APIENTRY
glPolygonStipple ( IN const GLubyte mask[128] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPolygonStipple)( mask );
}

void APIENTRY
glScissor ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height )
{
    (*GLTEB_CLTDISPATCHTABLE()->glScissor)( x, y, width, height );
}

void APIENTRY
glShadeModel ( IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glShadeModel)( mode );
}

void APIENTRY
glTexParameterf ( IN GLenum target, IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexParameterf)( target, pname, param );
}

void APIENTRY
glTexParameterfv ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexParameterfv)( target, pname, params );
}

void APIENTRY
glTexParameteri ( IN GLenum target, IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexParameteri)( target, pname, param );
}

void APIENTRY
glTexParameteriv ( IN GLenum target, IN GLenum pname, IN const GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexParameteriv)( target, pname, params );
}

void APIENTRY
glTexImage1D ( IN GLenum target, IN GLint level, IN GLint components, IN GLsizei width, IN GLint border, IN GLenum format, IN GLenum type, IN const GLvoid *pixels )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexImage1D)( target, level, components, width, border, format, type, pixels );
}

void APIENTRY
glTexImage2D ( IN GLenum target, IN GLint level, IN GLint components, IN GLsizei width, IN GLsizei height, IN GLint border, IN GLenum format, IN GLenum type, IN const GLvoid *pixels )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexImage2D)( target, level, components, width, height, border, format, type, pixels );
}

void APIENTRY
glTexEnvf ( IN GLenum target, IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexEnvf)( target, pname, param );
}

void APIENTRY
glTexEnvfv ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexEnvfv)( target, pname, params );
}

void APIENTRY
glTexEnvi ( IN GLenum target, IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexEnvi)( target, pname, param );
}

void APIENTRY
glTexEnviv ( IN GLenum target, IN GLenum pname, IN const GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexEnviv)( target, pname, params );
}

void APIENTRY
glTexGend ( IN GLenum coord, IN GLenum pname, IN GLdouble param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexGend)( coord, pname, param );
}

void APIENTRY
glTexGendv ( IN GLenum coord, IN GLenum pname, IN const GLdouble params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexGendv)( coord, pname, params );
}

void APIENTRY
glTexGenf ( IN GLenum coord, IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexGenf)( coord, pname, param );
}

void APIENTRY
glTexGenfv ( IN GLenum coord, IN GLenum pname, IN const GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexGenfv)( coord, pname, params );
}

void APIENTRY
glTexGeni ( IN GLenum coord, IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexGeni)( coord, pname, param );
}

void APIENTRY
glTexGeniv ( IN GLenum coord, IN GLenum pname, IN const GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexGeniv)( coord, pname, params );
}

void APIENTRY
glFeedbackBuffer ( IN GLsizei size, IN GLenum type, OUT GLfloat buffer[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFeedbackBuffer)( size, type, buffer );
}

void APIENTRY
glSelectBuffer ( IN GLsizei size, OUT GLuint buffer[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glSelectBuffer)( size, buffer );
}

GLint APIENTRY
glRenderMode ( IN GLenum mode )
{
    return( (*GLTEB_CLTDISPATCHTABLE()->glRenderMode)( mode ) );
}

void APIENTRY
glInitNames ( void )
{
    (*GLTEB_CLTDISPATCHTABLE()->glInitNames)( );
}

void APIENTRY
glLoadName ( IN GLuint name )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLoadName)( name );
}

void APIENTRY
glPassThrough ( IN GLfloat token )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPassThrough)( token );
}

void APIENTRY
glPopName ( void )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPopName)( );
}

void APIENTRY
glPushName ( IN GLuint name )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPushName)( name );
}

void APIENTRY
glDrawBuffer ( IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glDrawBuffer)( mode );
}

void APIENTRY
glClear ( IN GLbitfield mask )
{
    (*GLTEB_CLTDISPATCHTABLE()->glClear)( mask );
}

void APIENTRY
glClearAccum ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    (*GLTEB_CLTDISPATCHTABLE()->glClearAccum)( red, green, blue, alpha );
}

void APIENTRY
glClearIndex ( IN GLfloat c )
{
    (*GLTEB_CLTDISPATCHTABLE()->glClearIndex)( c );
}

void APIENTRY
glClearColor ( IN GLclampf red, IN GLclampf green, IN GLclampf blue, IN GLclampf alpha )
{
    (*GLTEB_CLTDISPATCHTABLE()->glClearColor)( red, green, blue, alpha );
}

void APIENTRY
glClearStencil ( IN GLint s )
{
    (*GLTEB_CLTDISPATCHTABLE()->glClearStencil)( s );
}

void APIENTRY
glClearDepth ( IN GLclampd depth )
{
    (*GLTEB_CLTDISPATCHTABLE()->glClearDepth)( depth );
}

void APIENTRY
glStencilMask ( IN GLuint mask )
{
    (*GLTEB_CLTDISPATCHTABLE()->glStencilMask)( mask );
}

void APIENTRY
glColorMask ( IN GLboolean red, IN GLboolean green, IN GLboolean blue, IN GLboolean alpha )
{
    (*GLTEB_CLTDISPATCHTABLE()->glColorMask)( red, green, blue, alpha );
}

void APIENTRY
glDepthMask ( IN GLboolean flag )
{
    (*GLTEB_CLTDISPATCHTABLE()->glDepthMask)( flag );
}

void APIENTRY
glIndexMask ( IN GLuint mask )
{
    (*GLTEB_CLTDISPATCHTABLE()->glIndexMask)( mask );
}

void APIENTRY
glAccum ( IN GLenum op, IN GLfloat value )
{
    (*GLTEB_CLTDISPATCHTABLE()->glAccum)( op, value );
}

void APIENTRY
glDisable ( IN GLenum cap )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glDisable)( cap );
}

void APIENTRY
glEnable ( IN GLenum cap )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEnable)( cap );
}

void APIENTRY
glFinish ( void )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFinish)( );
}

void APIENTRY
glFlush ( void )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFlush)( );
}

void APIENTRY
glPopAttrib ( void )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glPopAttrib)( );
}

void APIENTRY
glPushAttrib ( IN GLbitfield mask )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glPushAttrib)( mask );
}

void APIENTRY
glMap1d ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint stride, IN GLint order, IN const GLdouble points[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glMap1d)( target, u1, u2, stride, order, points );
}

void APIENTRY
glMap1f ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint stride, IN GLint order, IN const GLfloat points[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glMap1f)( target, u1, u2, stride, order, points );
}

void APIENTRY
glMap2d ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint ustride, IN GLint uorder, IN GLdouble v1, IN GLdouble v2, IN GLint vstride, IN GLint vorder, IN const GLdouble points[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glMap2d)( target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points );
}

void APIENTRY
glMap2f ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint ustride, IN GLint uorder, IN GLfloat v1, IN GLfloat v2, IN GLint vstride, IN GLint vorder, IN const GLfloat points[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glMap2f)( target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points );
}

void APIENTRY
glMapGrid1d ( IN GLint un, IN GLdouble u1, IN GLdouble u2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glMapGrid1d)( un, u1, u2 );
}

void APIENTRY
glMapGrid1f ( IN GLint un, IN GLfloat u1, IN GLfloat u2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glMapGrid1f)( un, u1, u2 );
}

void APIENTRY
glMapGrid2d ( IN GLint un, IN GLdouble u1, IN GLdouble u2, IN GLint vn, IN GLdouble v1, IN GLdouble v2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glMapGrid2d)( un, u1, u2, vn, v1, v2 );
}

void APIENTRY
glMapGrid2f ( IN GLint un, IN GLfloat u1, IN GLfloat u2, IN GLint vn, IN GLfloat v1, IN GLfloat v2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glMapGrid2f)( un, u1, u2, vn, v1, v2 );
}

void APIENTRY
glEvalCoord1d ( IN GLdouble u )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalCoord1d)( u );
}

void APIENTRY
glEvalCoord1dv ( IN const GLdouble u[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalCoord1dv)( u );
}

void APIENTRY
glEvalCoord1f ( IN GLfloat u )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalCoord1f)( u );
}

void APIENTRY
glEvalCoord1fv ( IN const GLfloat u[1] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalCoord1fv)( u );
}

void APIENTRY
glEvalCoord2d ( IN GLdouble u, IN GLdouble v )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalCoord2d)( u, v );
}

void APIENTRY
glEvalCoord2dv ( IN const GLdouble u[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalCoord2dv)( u );
}

void APIENTRY
glEvalCoord2f ( IN GLfloat u, IN GLfloat v )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalCoord2f)( u, v );
}

void APIENTRY
glEvalCoord2fv ( IN const GLfloat u[2] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalCoord2fv)( u );
}

void APIENTRY
glEvalMesh1 ( IN GLenum mode, IN GLint i1, IN GLint i2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glEvalMesh1)( mode, i1, i2 );
}

void APIENTRY
glEvalPoint1 ( IN GLint i )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalPoint1)( i );
}

void APIENTRY
glEvalMesh2 ( IN GLenum mode, IN GLint i1, IN GLint i2, IN GLint j1, IN GLint j2 )
{
    (*GLTEB_CLTDISPATCHTABLE()->glEvalMesh2)( mode, i1, i2, j1, j2 );
}

void APIENTRY
glEvalPoint2 ( IN GLint i, IN GLint j )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEvalPoint2)( i, j );
}

void APIENTRY
glAlphaFunc ( IN GLenum func, IN GLclampf ref )
{
    (*GLTEB_CLTDISPATCHTABLE()->glAlphaFunc)( func, ref );
}

void APIENTRY
glBlendFunc ( IN GLenum sfactor, IN GLenum dfactor )
{
    (*GLTEB_CLTDISPATCHTABLE()->glBlendFunc)( sfactor, dfactor );
}

void APIENTRY
glLogicOp ( IN GLenum opcode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glLogicOp)( opcode );
}

void APIENTRY
glStencilFunc ( IN GLenum func, IN GLint ref, IN GLuint mask )
{
    (*GLTEB_CLTDISPATCHTABLE()->glStencilFunc)( func, ref, mask );
}

void APIENTRY
glStencilOp ( IN GLenum fail, IN GLenum zfail, IN GLenum zpass )
{
    (*GLTEB_CLTDISPATCHTABLE()->glStencilOp)( fail, zfail, zpass );
}

void APIENTRY
glDepthFunc ( IN GLenum func )
{
    (*GLTEB_CLTDISPATCHTABLE()->glDepthFunc)( func );
}

void APIENTRY
glPixelZoom ( IN GLfloat xfactor, IN GLfloat yfactor )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPixelZoom)( xfactor, yfactor );
}

void APIENTRY
glPixelTransferf ( IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPixelTransferf)( pname, param );
}

void APIENTRY
glPixelTransferi ( IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPixelTransferi)( pname, param );
}

void APIENTRY
glPixelStoref ( IN GLenum pname, IN GLfloat param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPixelStoref)( pname, param );
}

void APIENTRY
glPixelStorei ( IN GLenum pname, IN GLint param )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPixelStorei)( pname, param );
}

void APIENTRY
glPixelMapfv ( IN GLenum map, IN GLint mapsize, IN const GLfloat values[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPixelMapfv)( map, mapsize, values );
}

void APIENTRY
glPixelMapuiv ( IN GLenum map, IN GLint mapsize, IN const GLuint values[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPixelMapuiv)( map, mapsize, values );
}

void APIENTRY
glPixelMapusv ( IN GLenum map, IN GLint mapsize, IN const GLushort values[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glPixelMapusv)( map, mapsize, values );
}

void APIENTRY
glReadBuffer ( IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE()->glReadBuffer)( mode );
}

void APIENTRY
glCopyPixels ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum type )
{
    (*GLTEB_CLTDISPATCHTABLE()->glCopyPixels)( x, y, width, height, type );
}

void APIENTRY
glReadPixels ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum format, IN GLenum type, OUT GLvoid *pixels )
{
    (*GLTEB_CLTDISPATCHTABLE()->glReadPixels)( x, y, width, height, format, type, pixels );
}

void APIENTRY
glDrawPixels ( IN GLsizei width, IN GLsizei height, IN GLenum format, IN GLenum type, IN const GLvoid *pixels )
{
    (*GLTEB_CLTDISPATCHTABLE()->glDrawPixels)( width, height, format, type, pixels );
}

void APIENTRY
glGetBooleanv ( IN GLenum pname, OUT GLboolean params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetBooleanv)( pname, params );
}

void APIENTRY
glGetClipPlane ( IN GLenum plane, OUT GLdouble equation[4] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetClipPlane)( plane, equation );
}

void APIENTRY
glGetDoublev ( IN GLenum pname, OUT GLdouble params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetDoublev)( pname, params );
}

GLenum APIENTRY
glGetError ( void )
{
    return( (*GLTEB_CLTDISPATCHTABLE()->glGetError)( ) );
}

void APIENTRY
glGetFloatv ( IN GLenum pname, OUT GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetFloatv)( pname, params );
}

void APIENTRY
glGetIntegerv ( IN GLenum pname, OUT GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetIntegerv)( pname, params );
}

void APIENTRY
glGetLightfv ( IN GLenum light, IN GLenum pname, OUT GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetLightfv)( light, pname, params );
}

void APIENTRY
glGetLightiv ( IN GLenum light, IN GLenum pname, OUT GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetLightiv)( light, pname, params );
}

void APIENTRY
glGetMapdv ( IN GLenum target, IN GLenum query, OUT GLdouble v[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetMapdv)( target, query, v );
}

void APIENTRY
glGetMapfv ( IN GLenum target, IN GLenum query, OUT GLfloat v[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetMapfv)( target, query, v );
}

void APIENTRY
glGetMapiv ( IN GLenum target, IN GLenum query, OUT GLint v[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetMapiv)( target, query, v );
}

void APIENTRY
glGetMaterialfv ( IN GLenum face, IN GLenum pname, OUT GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetMaterialfv)( face, pname, params );
}

void APIENTRY
glGetMaterialiv ( IN GLenum face, IN GLenum pname, OUT GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetMaterialiv)( face, pname, params );
}

void APIENTRY
glGetPixelMapfv ( IN GLenum map, OUT GLfloat values[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetPixelMapfv)( map, values );
}

void APIENTRY
glGetPixelMapuiv ( IN GLenum map, OUT GLuint values[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetPixelMapuiv)( map, values );
}

void APIENTRY
glGetPixelMapusv ( IN GLenum map, OUT GLushort values[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetPixelMapusv)( map, values );
}

void APIENTRY
glGetPolygonStipple ( OUT GLubyte mask[128] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetPolygonStipple)( mask );
}

const GLubyte * APIENTRY
glGetString ( IN GLenum name )
{
    return( (*GLTEB_CLTDISPATCHTABLE()->glGetString)( name ) );
}

void APIENTRY
glGetTexEnvfv ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexEnvfv)( target, pname, params );
}

void APIENTRY
glGetTexEnviv ( IN GLenum target, IN GLenum pname, OUT GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexEnviv)( target, pname, params );
}

void APIENTRY
glGetTexGendv ( IN GLenum coord, IN GLenum pname, OUT GLdouble params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexGendv)( coord, pname, params );
}

void APIENTRY
glGetTexGenfv ( IN GLenum coord, IN GLenum pname, OUT GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexGenfv)( coord, pname, params );
}

void APIENTRY
glGetTexGeniv ( IN GLenum coord, IN GLenum pname, OUT GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexGeniv)( coord, pname, params );
}

void APIENTRY
glGetTexImage ( IN GLenum target, IN GLint level, IN GLenum format, IN GLenum type, OUT GLvoid *pixels )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexImage)( target, level, format, type, pixels );
}

void APIENTRY
glGetTexParameterfv ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexParameterfv)( target, pname, params );
}

void APIENTRY
glGetTexParameteriv ( IN GLenum target, IN GLenum pname, OUT GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexParameteriv)( target, pname, params );
}

void APIENTRY
glGetTexLevelParameterfv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLfloat params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexLevelParameterfv)( target, level, pname, params );
}

void APIENTRY
glGetTexLevelParameteriv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLint params[] )
{
    (*GLTEB_CLTDISPATCHTABLE()->glGetTexLevelParameteriv)( target, level, pname, params );
}

GLboolean APIENTRY
glIsEnabled ( IN GLenum cap )
{
    return( (*GLTEB_CLTDISPATCHTABLE()->glIsEnabled)( cap ) );
}

GLboolean APIENTRY
glIsList ( IN GLuint list )
{
    return( (*GLTEB_CLTDISPATCHTABLE()->glIsList)( list ) );
}

void APIENTRY
glDepthRange ( IN GLclampd zNear, IN GLclampd zFar )
{
    (*GLTEB_CLTDISPATCHTABLE()->glDepthRange)( zNear, zFar );
}

void APIENTRY
glFrustum ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar )
{
    (*GLTEB_CLTDISPATCHTABLE()->glFrustum)( left, right, bottom, top, zNear, zFar );
}

void APIENTRY
glLoadIdentity ( void )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glLoadIdentity)( );
}

void APIENTRY
glLoadMatrixf ( IN const GLfloat m[16] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glLoadMatrixf)( m );
}

void APIENTRY
glLoadMatrixd ( IN const GLdouble m[16] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glLoadMatrixd)( m );
}

void APIENTRY
glMatrixMode ( IN GLenum mode )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMatrixMode)( mode );
}

void APIENTRY
glMultMatrixf ( IN const GLfloat m[16] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultMatrixf)( m );
}

void APIENTRY
glMultMatrixd ( IN const GLdouble m[16] )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultMatrixd)( m );
}

void APIENTRY
glOrtho ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar )
{
    (*GLTEB_CLTDISPATCHTABLE()->glOrtho)( left, right, bottom, top, zNear, zFar );
}

void APIENTRY
glPopMatrix ( void )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glPopMatrix)( );
}

void APIENTRY
glPushMatrix ( void )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glPushMatrix)( );
}

void APIENTRY
glRotated ( IN GLdouble angle, IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glRotated)( angle, x, y, z );
}

void APIENTRY
glRotatef ( IN GLfloat angle, IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glRotatef)( angle, x, y, z );
}

void APIENTRY
glScaled ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glScaled)( x, y, z );
}

void APIENTRY
glScalef ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glScalef)( x, y, z );
}

void APIENTRY
glTranslated ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTranslated)( x, y, z );
}

void APIENTRY
glTranslatef ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTranslatef)( x, y, z );
}

void APIENTRY
glViewport ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height )
{
    (*GLTEB_CLTDISPATCHTABLE()->glViewport)( x, y, width, height );
}

GLboolean APIENTRY
glAreTexturesResident(GLsizei n, const GLuint *textures,
                                            GLboolean *residences)
{
    return (*GLTEB_CLTDISPATCHTABLE()->glAreTexturesResident)(n, textures, residences);
}

void APIENTRY
glBindTexture(GLenum target, GLuint texture)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glBindTexture)(target, texture);
}

void APIENTRY
glCopyTexImage1D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLint border)
{
    (*GLTEB_CLTDISPATCHTABLE()->glCopyTexImage1D)(target, level,
                                                  internalformat,
                                                  x, y, width, border);
}

void APIENTRY
glCopyTexImage2D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLsizei height, GLint border)
{
    (*GLTEB_CLTDISPATCHTABLE()->glCopyTexImage2D)(target, level, internalformat, x, y, width, height, border);
}

void APIENTRY
glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                     GLint x, GLint y, GLsizei width)
{
    (*GLTEB_CLTDISPATCHTABLE()->glCopyTexSubImage1D)(target, level, xoffset, x, y, width);
}

void APIENTRY
glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                     GLint yoffset, GLint x, GLint y,
                                     GLsizei width, GLsizei height)
{
    (*GLTEB_CLTDISPATCHTABLE()->glCopyTexSubImage2D)(target, level, xoffset, yoffset, x, y, width, height);
}

void APIENTRY
glDeleteTextures(GLsizei n, const GLuint *textures)
{
    (*GLTEB_CLTDISPATCHTABLE()->glDeleteTextures)(n, textures);
}

void APIENTRY
glGenTextures(GLsizei n, GLuint *textures)
{
    (*GLTEB_CLTDISPATCHTABLE()->glGenTextures)(n, textures);
}

GLboolean APIENTRY
glIsTexture(GLuint texture)
{
    return (*GLTEB_CLTDISPATCHTABLE()->glIsTexture)(texture);
}

void APIENTRY
glPrioritizeTextures(GLsizei n, const GLuint *textures,
                                      const GLclampf *priorities)
{
    (*GLTEB_CLTDISPATCHTABLE()->glPrioritizeTextures)(n, textures, priorities);
}

void APIENTRY
glTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid *pixels)
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexSubImage1D)(target, level, xoffset, width, format, type, pixels);
}

void APIENTRY
glTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels)
{
    (*GLTEB_CLTDISPATCHTABLE()->glTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

void APIENTRY
glArrayElement(GLint i)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glArrayElement)(i);
}

void APIENTRY
glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColorPointer)(size, type, stride, pointer);
}

void APIENTRY
glDisableClientState(GLenum array)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glDisableClientState)(array);
}

void APIENTRY
glDrawArrays(GLenum mode, GLint first, GLsizei count)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glDrawArrays)(mode, first, count);
}

void APIENTRY
glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glDrawElements)(mode, count, type, indices);
}

void APIENTRY
glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEdgeFlagPointer)(stride, pointer);
}

void APIENTRY
glEnableClientState(GLenum array)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glEnableClientState)(array);
}

void APIENTRY
glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexPointer)(type, stride, pointer);
}

void APIENTRY
glIndexub(GLubyte c)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexub)(c);
}

void APIENTRY
glIndexubv(const GLubyte *c)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glIndexubv)(c);
}

void APIENTRY
glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glInterleavedArrays)(format, stride, pointer);
}

void APIENTRY
glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNormalPointer)(type, stride, pointer);
}

void APIENTRY
glPolygonOffset(GLfloat factor, GLfloat units)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glPolygonOffset)(factor, units);
}

void APIENTRY
glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glTexCoordPointer)(size, type, stride, pointer);
}

void APIENTRY
glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glVertexPointer)(size, type, stride, pointer);
}

void APIENTRY
glGetPointerv(GLenum pname, GLvoid* *params)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glGetPointerv)(pname, params);
}

void APIENTRY
glPopClientAttrib(void)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glPopClientAttrib)();
}

void APIENTRY
glPushClientAttrib(IN GLbitfield mask)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glPushClientAttrib)(mask);
}

void APIENTRY
glDrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glDrawRangeElementsWIN)(mode, start, end, count, type, indices);
}

void APIENTRY glColorTableEXT( GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *data)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColorTableEXT)(target, internalFormat, width, format, type, data);
}

void APIENTRY glColorSubTableEXT( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glColorSubTableEXT)(target, start, count, format, type, data);
}

void APIENTRY glGetColorTableEXT( GLenum target, GLenum format, GLenum type, GLvoid *data)
{
    (*GLTEB_EXTDISPATCHTABLE()->glGetColorTableEXT)(target, format, type, data);
}

void APIENTRY glGetColorTableParameterivEXT( GLenum target, GLenum pname, GLint *params)
{
    (*GLTEB_EXTDISPATCHTABLE()->glGetColorTableParameterivEXT)(target, pname, params);
}

void APIENTRY glGetColorTableParameterfvEXT( GLenum target, GLenum pname, GLfloat *params)
{
    (*GLTEB_EXTDISPATCHTABLE()->glGetColorTableParameterfvEXT)(target, pname, params);
}

#ifdef GL_WIN_multiple_textures
void APIENTRY glCurrentTextureIndexWIN
    (GLuint index)
{
    (*GLTEB_CLTTDISPATCHTABLE_FAST()->glCurrentTextureIndexWIN)
        (index);
}

void APIENTRY glMultiTexCoord1dWIN
    (GLbitfield mask, GLdouble s)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord1dWIN)
        (mask, s);
}

void APIENTRY glMultiTexCoord1dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord1dvWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord1fWIN
    (GLbitfield mask, GLfloat s)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultiTexCoord1fWIN)
        (mask, s);
}

void APIENTRY glMultiTexCoord1fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultiTexCoord1fvWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord1iWIN
    (GLbitfield mask, GLint s)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultiTexCoord1iWIN)
        (mask, s);
}

void APIENTRY glMultiTexCoord1ivWIN
    (GLbitfield mask, const GLint *v)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultiTexCoord1ivWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord1sWIN
    (GLbitfield mask, GLshort s)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord1sWIN)
        (mask, s);
}

void APIENTRY glMultiTexCoord1svWIN
    (GLbitfield mask, const GLshort *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord1svWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord2dWIN
    (GLbitfield mask, GLdouble s, GLdouble t)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord2dWIN)
        (mask, s, t);
}

void APIENTRY glMultiTexCoord2dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord2dvWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord2fWIN
    (GLbitfield mask, GLfloat s, GLfloat t)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultiTexCoord2fWIN)
        (mask, s, t);
}

void APIENTRY glMultiTexCoord2fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultiTexCoord2fvWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord2iWIN
    (GLbitfield mask, GLint s, GLint t)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultiTexCoord2iWIN)
        (mask, s, t);
}

void APIENTRY glMultiTexCoord2ivWIN
    (GLbitfield mask, const GLint *v)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glMultiTexCoord2ivWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord2sWIN
    (GLbitfield mask, GLshort s, GLshort t)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord2sWIN)
        (mask, s, t);
}

void APIENTRY glMultiTexCoord2svWIN
    (GLbitfield mask, const GLshort *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord2svWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord3dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord3dWIN)
        (mask, s, t, r);
}

void APIENTRY glMultiTexCoord3dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord3dvWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord3fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord3fWIN)
        (mask, s, t, r);
}

void APIENTRY glMultiTexCoord3fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord3fvWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord3iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord3iWIN)
        (mask, s, t, r);
}

void APIENTRY glMultiTexCoord3ivWIN
    (GLbitfield mask, const GLint *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord3ivWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord3sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord3sWIN)
        (mask, s, t, r);
}

void APIENTRY glMultiTexCoord3svWIN
    (GLbitfield mask, const GLshort *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord3svWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord4dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord4dWIN)
        (mask, s, t, r, q);
}

void APIENTRY glMultiTexCoord4dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord4dvWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord4fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord4fWIN)
        (mask, s, t, r, q);
}

void APIENTRY glMultiTexCoord4fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord4fvWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord4iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r, GLint q)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord4iWIN)
        (mask, s, t, r, q);
}

void APIENTRY glMultiTexCoord4ivWIN
    (GLbitfield mask, const GLint *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord4ivWIN)
        (mask, v);
}

void APIENTRY glMultiTexCoord4sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r, GLshort q)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord4sWIN)
        (mask, s, t, r, q);
}

void APIENTRY glMultiTexCoord4svWIN
    (GLbitfield mask, const GLshort *v)
{
    (*GLTEB_EXTDISPATCHTABLE()->glMultiTexCoord4svWIN)
        (mask, v);
}

void APIENTRY glBindNthTextureWIN
    (GLuint index, GLenum target, GLuint texture)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glBindNthTextureWIN)
        (index, target, texture);
}

void APIENTRY glNthTexCombineFuncWIN
    (GLuint index,
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor)
{
    (*GLTEB_CLTDISPATCHTABLE_FAST()->glNthTexCombineFuncWIN)
        (index, leftColorFactor, colorOp, rightColorFactor,
         leftAlphaFactor, alphaOp, rightAlphaFactor);
}
#endif // GL_WIN_multiple_textures
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\glcltgs.c ===
/******************************Module*Header*******************************\
* Module Name: glcltgs.c
*
* Routines to batch function calls and primitives
*
* Copyright (c) 1993-1996 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/


/*
 * AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT
 * IF YOU MUST MODIFY THIS FILE, PLEASE CONTACT ptar@sgi.com 415-390-1483
 */

#include "precomp.h"
#pragma hdrstop

/* Generic OpenGL Client using subbatching. */
#include <string.h>

#include "imports.h"
#include "types.h"

#include "glsbmsg.h"
#include "glsbmsgh.h"
#include "glsrvspt.h"

#include "subbatch.h"
#include "batchinf.h"
#include "glteb.h"
#include "glsbcltu.h"
#include "glclt.h"
#include "compsize.h"
#include "context.h"
#include "global.h"
#include "parray.h"
#include "glarray.h"
#include "lighting.h"
#include "imfuncs.h"
#include "..\dlist\dlistopt.h"

#ifdef NEW_PARTIAL_PRIM

// Vertex flags that should be propagated to polyarray flags
//
#define VERTEX_FLAGS_FOR_POLYARRAY (POLYDATA_VERTEX2 | POLYDATA_VERTEX3 | \
                                    POLYDATA_VERTEX4)

#define VERTEX_MATERIAL(pm, pa, pd) (pm->pdMaterial0[pd - pa->pdBuffer0])

PDMATERIAL* FASTCALL GetVertexMaterial(POLYARRAY *pa, POLYDATA *pd)
{
    POLYMATERIAL *pm = GLTEB_CLTPOLYMATERIAL();
    if (!pm)
    {
        PAMatAlloc();
        pm = GLTEB_CLTPOLYMATERIAL();
        if (!pm)
            return NULL;
    }
    return &VERTEX_MATERIAL(pm, pa, pd);
}
//------------------------------------------------------------------------
// Assumes that POLYMATERIAL structure is valid
//
PDMATERIAL* FASTCALL GetVertexMaterialSafe(POLYARRAY *pa, POLYDATA *pd)
{
    POLYMATERIAL *pm = GLTEB_CLTPOLYMATERIAL();
    return &VERTEX_MATERIAL(pm, pa, pd);
}
//------------------------------------------------------------------------
// Copy material changes from src to pd material
//
void FASTCALL SetVertexMaterial(POLYARRAY *pa, 
                                POLYDATA *pd, 
                                __GLmatChange *src, 
                                GLint faceOrientation)
{
    __GLmatChange *pdMat;
    PDMATERIAL    *mat;

   // Get POLYMATERIAL pointer after PAMatAlloc!
    mat = GetVertexMaterial(pa, pd);
    if (!mat) 
        return;
    if (faceOrientation == __GL_FRONTFACE)
    {
       mat->front = PAMatAlloc();
       if (!mat->front)
           return;
       pdMat = mat->front;
    }
    else
    {
       mat->back = PAMatAlloc();
       pdMat = mat->back;
    }
    if (pdMat)
        *pdMat = *src;
}
//-----------------------------------------------------------------------------
// Save shared vertex for a partial primitive
//
// We have to save all data applicapable for vertex (all data that can be inside 
// BEGIN END brackets): flags, color, texture, normal, coordinate, material, edge flag. 
// We do not save evaluator data, because it was processed earlier.
//
void SaveSharedVertex(SAVEREGION *dst, POLYDATA *src, POLYARRAY *pa)
{                
    dst->pd.flags = src->flags;       
    dst->pd.obj = src->obj;         
    if (src->flags & POLYDATA_TEXTURE_VALID)  
        dst->pd.texture = src->texture;    
    if (src->flags & POLYDATA_NORMAL_VALID)   
        dst->pd.normal = src->normal;     
    if (src->flags & POLYDATA_COLOR_VALID)    
        dst->pd.colors[0] = src->colors[0];
    if (src->flags & POLYDATA_MATERIAL_FRONT)
        dst->front = *(GetVertexMaterial(pa, src)->front);
    if (src->flags & POLYDATA_MATERIAL_BACK)
        dst->back = *(GetVertexMaterial(pa, src)->back);
}
//
// dst  - POLYDATA
// src  - SAVEREGION
// pa   - POLYARRAY
//
#define RESTOREMATERIAL(dst, src, pa)                                   \
    if (dst->flags & POLYDATA_MATERIAL_FRONT)                           \
    {                                                                   \
        SetVertexMaterial(pa, dst, &src->front, __GL_FRONTFACE);        \
    }                                                                   \
    if (dst->flags & POLYDATA_MATERIAL_BACK)                            \
    {                                                                   \
        SetVertexMaterial(pa, dst, &src->back, __GL_BACKFACE);          \
    }
// Restore shared vertex for a partial primitive
//
// We have to restore all data applicapable for vertex (all data that can be inside 
// BEGIN END brackets): flags, color, texture, normal, coordinate, material, edge flag. 
// We do not restore evaluator data, because it was processed earlier.
// We must update POLYARRAY flags and current color, normal, edge flag, texture pointers.
// We also must intitialize flags for a next vertex.
//
void RestoreSharedVertex(POLYDATA *dst, SAVEREGION *src, POLYARRAY *pa)               
{
    dst->flags = src->pd.flags;            
    dst->obj = src->pd.obj;              
    if (dst->flags & POLYDATA_TEXTURE_VALID)   
    {                                            
        dst->texture = src->pd.texture;      
        if (src->pd.flags & POLYDATA_EVAL_TEXCOORD)
            pa->pdLastEvalTexture = dst;
        else
            pa->pdCurTexture = dst;                
    }                                            
    if (dst->flags & POLYDATA_NORMAL_VALID)    
    {                                            
        dst->normal = src->pd.normal;       
        if (src->pd.flags & POLYDATA_EVAL_NORMAL)
            pa->pdLastEvalNormal = dst;
        else
            pa->pdCurNormal = dst;               
    }                                            
    if (dst->flags & POLYDATA_COLOR_VALID)     
    {                                            
        dst->colors[0] = src->pd.colors[0];    
        if (src->pd.flags & POLYDATA_EVAL_COLOR)
            pa->pdLastEvalColor = dst;
        else
            pa->pdCurColor = dst;                  
    }                                            
    if (dst->flags & POLYDATA_EDGEFLAG_VALID)  
        pa->pdCurEdgeFlag = dst;               

    RESTOREMATERIAL(dst, src, pa);
    
    pa->flags |= (dst->flags & VERTEX_FLAGS_FOR_POLYARRAY);
    (dst+1)->flags = 0;     // Initialize flag for a next vertex
}
//------------------------------------------------------------------------------
// Copy data from Graphics Context
//
void FASTCALL CopyColorFromGC(__GLcontext *gc, POLYARRAY *pa, POLYDATA *pd)
{
    __GLcolor scaledUserColor;

    pd->flags |= POLYDATA_COLOR_VALID;
    if (!gc->modes.colorIndexMode) 
    {
        __GL_SCALE_AND_CHECK_CLAMP_RGBA(scaledUserColor.r,
                                        scaledUserColor.g,
                                        scaledUserColor.b,
                                        scaledUserColor.a,
                                        gc, pa->flags,
                                        gc->state.current.userColor.r,
                                        gc->state.current.userColor.g,
                                        gc->state.current.userColor.b,
                                        gc->state.current.userColor.a);
    } 
    else 
    {
        __GL_CHECK_CLAMP_CI(scaledUserColor.r, gc, pa->flags, 
                            gc->state.current.userColorIndex);
    }
    pd->colors[0] = scaledUserColor;
}

void FASTCALL CopyTextureFromGC(__GLcontext *gc, POLYARRAY *pa, POLYDATA *pd)
{
    pd->flags |= POLYDATA_TEXTURE_VALID;
    pd->texture = gc->state.current.texture;

    if (__GL_FLOAT_COMPARE_PONE(pd->texture.w, !=))
        pa->flags |= POLYARRAY_TEXTURE4;
    else if (__GL_FLOAT_NEZ(pd->texture.z))
        pa->flags |= POLYARRAY_TEXTURE3;
    else if (__GL_FLOAT_NEZ(pd->texture.y))
        pa->flags |= POLYARRAY_TEXTURE2;
    else
        pa->flags |= POLYARRAY_TEXTURE1;
}

void FASTCALL CopyEdgeFlagFromGC(__GLcontext *gc, POLYDATA *pd)
{
    pd->flags |= POLYDATA_EDGEFLAG_VALID;
    if (gc->state.current.edgeTag)
        pd->flags |= POLYDATA_EDGEFLAG_BOUNDARY;
}

void FASTCALL CopyNormalFromGC(__GLcontext *gc, POLYDATA *pd)
{
    pd->flags |= POLYDATA_NORMAL_VALID;
    pd->normal = gc->state.current.normal;
}
//-------------------------------------------------------------------------------
// Copy material state corresponding to changeBits from GC to mat.
// face defines front or back material to use.
//
void FASTCALL CopyMaterialFromGC(__GLcontext *gc, __GLmatChange *mat, 
                                 GLuint changeBits, GLint face)
{
    __GLmaterialState *ms;

    ms = &gc->state.light.front;
    if (face != __GL_FRONTFACE)
        ms = &gc->state.light.back;
     
    // Take data from graphics context

    if (changeBits & __GL_MATERIAL_AMBIENT)
        mat->ambient = ms->ambient;

    if (changeBits & __GL_MATERIAL_DIFFUSE)
        mat->diffuse = ms->diffuse;

    if (changeBits & __GL_MATERIAL_SPECULAR)
        mat->specular = ms->specular;

    if (changeBits & __GL_MATERIAL_EMISSIVE)
    {
        mat->emissive.r = ms->emissive.r * gc->oneOverRedVertexScale;   
        mat->emissive.g = ms->emissive.g * gc->oneOverGreenVertexScale;   
        mat->emissive.b = ms->emissive.b * gc->oneOverBlueVertexScale;    
        mat->emissive.a = ms->emissive.a * gc->oneOverAlphaVertexScale;   
    }

    if (changeBits & __GL_MATERIAL_SHININESS)
         mat->shininess = ms->specularExponent;

    if (changeBits & __GL_MATERIAL_COLORINDEXES)
    {
        mat->cmapa = ms->cmapa;
        mat->cmapd = ms->cmapd;
        mat->cmaps = ms->cmaps;
    }
}
//-------------------------------------------------------------------------------
// Compute complete vertex state to restore state modified by pdLast vertex.
//
// We have to preserve the following state for a vertex:
// - normal
// - texture
// - color
// - edge flag
// - material
//
// Input:
//  dst     - where to copy vertex state
//  pdStart - we go from this vertex to the beginning of a polyarray to find 
//            material changes
//  pdLast  - we have to update vertex state only if the state is changed by 
//            this vertex
//
void FASTCALL UpdateVertexState(__GLcontext *gc, 
                                POLYARRAY   *pa, 
                                SAVEREGION  *dst, 
                                POLYDATA    *pdStart,
                                POLYDATA    *pdLast)
{
    GLuint flags = dst->pd.flags;
    GLuint flagsLast = pdLast ? pdLast->flags : 0xFFFFFFFF;
    POLYDATA *pd0 = pa->pd0;

    ASSERTOPENGL(pdStart >= pd0, "Infinite loop possible!");

    // If last vertex changes normal we have to find nearest previous normal
    // and propagate it to the dst
    if (flagsLast & POLYDATA_NORMAL_VALID && !(flags & POLYDATA_NORMAL_VALID))
    {
        POLYDATA *pd;
        // Find nearest normal
        for (pd = pdStart; pd >= pd0; pd--)
        {
            if (pd->flags & POLYDATA_NORMAL_VALID && 
                !(pd->flags & POLYDATA_EVAL_NORMAL))
                break;
        }
        flags |= POLYDATA_NORMAL_VALID;
        if (pd < pd0)
            //  We have not found any normal, so take value from graphics state
            CopyNormalFromGC(gc, &dst->pd);
        else
            dst->pd.normal = pd->normal;
    }

    // If last vertex changes texture we have to find nearest previous texture
    // and propagate it to the dst
    if (flagsLast & POLYDATA_TEXTURE_VALID && !(flags & POLYDATA_TEXTURE_VALID))
    {
        POLYDATA *pd;
        // Find latest texture
        for (pd = pdStart; pd >= pd0; pd--)
        {
            if (pd->flags & POLYDATA_TEXTURE_VALID && 
                !(pd->flags & POLYDATA_EVAL_TEXCOORD))
                break;
        }
        flags |= POLYDATA_TEXTURE_VALID;
        if (pd < pd0)
            //  We have not found any vertex, so take value from graphics state
            CopyTextureFromGC(gc, pa, &dst->pd);
        else
            dst->pd.texture = pd->texture;
    }

    // If last vertex changes color we have to find nearest previous color
    // and propagate it to the dst
    if (flagsLast & POLYDATA_COLOR_VALID && !(flags & POLYDATA_COLOR_VALID))
    {
        POLYDATA *pd;
        // Find latest color
        for (pd = pdStart; pd >= pd0; pd--)
        {
            if (pd->flags & POLYDATA_COLOR_VALID && 
                !(pd->flags & POLYDATA_EVAL_COLOR))
                break;
        }
        flags |= POLYDATA_COLOR_VALID;
        if (pd < pd0)
            //  We have not found any vertex, so take value from graphics state
            CopyColorFromGC(gc, pa, &dst->pd);
        else
            dst->pd.colors[0] = pd->colors[0];
    }

    if (flagsLast & POLYDATA_EDGEFLAG_VALID && !(flags & POLYDATA_EDGEFLAG_VALID))
    {
        POLYDATA *pd;
        // Find latest edge flag
        for (pd = pdStart; pd >= pd0; pd--)
        {
            if (pd->flags & POLYDATA_EDGEFLAG_VALID)
                break;
        }
        flags |= POLYDATA_EDGEFLAG_VALID;
        if (pd < pd0)
        { 
            //  We have not found any vertex, so take value from graphics state
            if (gc->state.current.edgeTag)
                flags |= POLYDATA_EDGEFLAG_BOUNDARY;
        }
        else
            flags |= (pd->flags & POLYDATA_EDGEFLAG_BOUNDARY);
    }

    dst->pd.flags |= flags;

    // Now we have to update material state

    if (pdLast->flags & (POLYARRAY_MATERIAL_FRONT | POLYARRAY_MATERIAL_BACK))
    {
        // We have to compute material state for pdLast1, because after the primitive is
        // processed, current material state will have changes from pdLast2 vertex.

        __GLmatChange *mat;
        __GLmatChange *pdMatLast;
        POLYDATA      *pd;
        GLint         face;
        GLuint        matMask;
        GLuint        changeBits;

        for (face = __GL_BACKFACE, matMask = POLYARRAY_MATERIAL_BACK;
              face >= 0;
              face--, matMask = POLYARRAY_MATERIAL_FRONT
             )
        {
            if (!(pa->flags & matMask))
                continue;

            // Only reset material data changed by pdLast
            if (face == __GL_FRONTFACE)
            {
                pdMatLast = GetVertexMaterial(pa, pdLast)->front;
                changeBits = pdMatLast->dirtyBits;
                mat  = &dst->front;
                // Don't modify color materials if they are in effect!
                changeBits &= ~gc->light.front.colorMaterialChange;
            }
            else
            {
                pdMatLast = GetVertexMaterial(pa, pdLast)->back;
                changeBits = pdMatLast->dirtyBits;
                mat  = &dst->back;
                // Don't modify color materials if they are in effect!
                changeBits &= ~gc->light.back.colorMaterialChange;
            }

            // Don't modify material settings used by this vertex
            changeBits &= ~mat->dirtyBits;

            if (!changeBits) 
                continue;   

            mat->dirtyBits |= changeBits;

            // Apply changes from vertices
            // We go backwards and apply the latest change
            for (pd = pdStart; pd >= pd0; pd--)
            {
                __GLmatChange *pdMat;
                GLuint dirtyBits;
                if (pd->flags & matMask)
                {
                    GLuint dirtyBits;
              
                    pdMat = GetVertexMaterial(pa, pd)->front + face;
                    dirtyBits  = pdMat->dirtyBits & changeBits;

                    if (!dirtyBits) 
                        continue;

                    if (dirtyBits & __GL_MATERIAL_AMBIENT)
                    {
                        mat->ambient = pdMat->ambient;
                    }
              
                    if (dirtyBits & __GL_MATERIAL_DIFFUSE)
                    {
                        mat->diffuse = pdMat->diffuse;
                    }

                    if (dirtyBits & __GL_MATERIAL_SPECULAR)
                    {
                        mat->specular = pdMat->specular;
                    }
              
                    if (dirtyBits & __GL_MATERIAL_EMISSIVE)
                    {
                        mat->emissive = pdMat->emissive;
                    }
              
                    if (dirtyBits & __GL_MATERIAL_SHININESS)
                    {
                        mat->shininess = pdMat->shininess;
                    }

                    if (dirtyBits & __GL_MATERIAL_COLORINDEXES)
                    {
                        mat->cmapa = pdMat->cmapa;
                        mat->cmapd = pdMat->cmapd;
                        mat->cmaps = pdMat->cmaps;
                    }

                    // Clear processed bits
                    changeBits &= ~dirtyBits;

                    if (!changeBits)
                        break;
                }
            }

            if (changeBits)
                CopyMaterialFromGC (gc, mat, changeBits, face);

            dst->pd.flags |= matMask;
        }
    }
}
//-------------------------------------------------------------------------------------
// Propagate vertex state from GC to the vertex.
//
// Already set vertex data should be preserved.
//
void FASTCALL UpdateVertexStateUsingGC(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *dst)
{ 
    POLYDATA * const pd = &dst->pd;
    if (!(pd->flags & POLYDATA_NORMAL_VALID))
        CopyNormalFromGC(gc, pd);

    if (!(pd->flags & POLYDATA_TEXTURE_VALID))
        CopyTextureFromGC(gc, pa, pd);

    if (!(pd->flags & POLYDATA_COLOR_VALID))
        CopyColorFromGC(gc, pa, pd);

    if (!(pd->flags & POLYDATA_EDGEFLAG_VALID))
        CopyEdgeFlagFromGC(gc, pd);

    if (pa->flags & (POLYARRAY_MATERIAL_FRONT | POLYARRAY_MATERIAL_BACK))
    {
        // Compute material state for the vertex, using GC
        // Do not override material changes in the vertex

        __GLmatChange *mat;
        GLint         face;
        GLuint        matMask;
        GLuint        changeBits;

        for (face = __GL_BACKFACE, matMask = POLYARRAY_MATERIAL_BACK;
              face >= 0;
              face--, matMask = POLYARRAY_MATERIAL_FRONT
             )
        {
            GLuint  dirtyBits;
            if (!(pa->flags & matMask))
                continue;

            // Don't modify color materials if they are in effect or if they are set 
            // by pdFirst!

            changeBits = 0xFFFFFFFF;
            if (face == __GL_FRONTFACE)
            {
                if (pd->flags & matMask)
                    changeBits &= ~dst->front.dirtyBits;

                changeBits &= ~gc->light.front.colorMaterialChange;
                mat = &dst->front;
            }
            else
            {
                if (pd->flags & matMask)
                    changeBits &= ~dst->back.dirtyBits;
                changeBits  = ~gc->light.back.colorMaterialChange;
                mat = &dst->back;
            }

            // Apply changes from vertices
            // We go backwards and remember the latest change

            if (changeBits)
            {
                CopyMaterialFromGC (gc, mat, changeBits, face);
                // Update changes for the vertex
                pd->flags |= matMask;
                mat->dirtyBits |= changeBits;
            }

        }
    }
}
#endif // NEW_PARTIAL_PRIM

//
// extension apis these are not exported
//

void APIENTRY
glAddSwapHintRectWIN(IN GLint x, IN GLint y, IN GLint width, IN GLint height)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL || plrc->dhrc != 0) {
        // this api should only be called if there is a generic rc
        // currently selected.
        return;
    }

    GLCLIENT_BEGIN( AddSwapHintRectWIN, ADDSWAPHINTRECTWIN )
        pMsg->xs = x;
        pMsg->ys = y;
        pMsg->xe = x + width;
        pMsg->ye = y + height;
    return;
    GLCLIENT_END
}

#ifdef PRIMITIVE_TRACK
static ULONG prim_entries;
static ULONG prim_total = 0;
static ULONG prim_count = 0;
#endif

// Polyarray begin flags.  Reset line stipple for new line loop,
// line strip, and polygon.
// Assume that all vertices have the same color.
GLuint aPolyArrayBeginFlags[] =
{
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA, // GL_POINTS
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA, // GL_LINES
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA | POLYARRAY_RESET_STIPPLE, // GL_LINE_LOOP
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA | POLYARRAY_RESET_STIPPLE, // GL_LINE_STRIP
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA, // GL_TRIANGLES
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA, // GL_TRIANGLE_STRIP
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA, // GL_TRIANGLE_FAN
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA, // GL_QUADS
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA, // GL_QUAD_STRIP
    POLYARRAY_IN_BEGIN | POLYARRAY_SAME_COLOR_DATA | POLYARRAY_RESET_STIPPLE  // GL_POLYGON
};

// If you modify this function, you need to also modify VA_DrawElementsBegin.
void APIENTRY
glcltBegin ( IN GLenum mode )
{
    POLYARRAY *pa;
    POLYDATA  *pd0, *pdFlush;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;
    __GL_SETUP();
    DWORD flags = GET_EVALSTATE (gc);


    // The invalid functions within begin/end are detected in glsbAttention.

    pa = GLTEB_CLTPOLYARRAY();

    // The vertex buffer is used as follows.  The first entry contains the
    // POLYARRAY structure.  The incoming vertices will be saved beginning
    // at a following entry.  As an optimization, the POLYARRAY structure is
    // kept in the TEB.  When glEnd is called, it will be copied to the
    // vertex buffer.

#ifndef _WIN95_
    ASSERTOPENGL(sizeof(POLYARRAY) <= sizeof(NtCurrentTeb()->glReserved1),
       "POLYARRAY and TEB sizes mismatch!");
#endif

    ASSERTOPENGL(sizeof(POLYDATA) == sizeof(__GLvertex),
       "POLYDATA and __GLvertex sizes mismatch!");

    ASSERTOPENGL(sizeof(POLYARRAY) <= sizeof(POLYDATA),
       "POLYARRAY and POLYDATA sizes mismatch!");

    // Keep vertex structure a multiple of 4 bytes (or 8 bytes).
    // The vertex buffer must be 4-byte aligned.

    ASSERTOPENGL(!(sizeof(POLYDATA) & 0x3), "bad POLYDATA size!");
    ASSERTOPENGL(!((ULONG_PTR)pa->pdBuffer0 & 0x3), "POLYDATA should be aligned!\n");

    // If we are already in the begin/end bracket, return an error.

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    if ((GLuint) mode > GL_POLYGON)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

	// if there are any pending API calls that affect the Evaluator state
    // then flush the message buffer

    if (flags & (__EVALS_AFFECTS_ALL_EVAL|
                 __EVALS_AFFECTS_1D_EVAL|
                 __EVALS_AFFECTS_2D_EVAL))
        glsbAttention ();

    // Flush the command buffer if the vertex buffer is nearly full.
    // Otherwise, just continue with the next available vertex buffer entry.

    if (pa->pdBufferNext > pa->pdBufferMax - MIN_POLYDATA_BATCH_SIZE)
    {
#ifdef PRIMITIVE_TRACK
        DbgPrint("* Min-not-present flush\n");
#endif
        glsbAttention();	// it resets pdBufferNext pointer too

        ASSERTOPENGL(pa->nextMsgOffset == PA_nextMsgOffset_RESET_VALUE, 
                 "bad nextMsgOffset\n");
    }

    // Batch POLYARRAY command in the command buffer.
    // We want to leave enough room to accomodate at least one invalid command
    // that may be batched in the begin/end bracket.  When glsbAttention,
    // glsbAttentionAlt, or glcltEnd is called, we will remove these invalid
    // commands.
    //
    // Combine adjacent DrawPolyArray commands into one command.

    // request DRAWPOLYARRAY_LARGE structure to make room for invalid commands
    GLCLIENT_BEGIN(DrawPolyArray, DRAWPOLYARRAY_LARGE)
    // need msg pointer to update pa later
    pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *) pMsg;

	if (pa->nextMsgOffset == CurrentOffset)
	{
	    // rewind command buffer pointer
	    pMsgBatchInfo->NextOffset = CurrentOffset;
	    ((BYTE *) pMsgDrawPolyArray) -= 
		 GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY));

	    // chain adjacent DrawPolyArray commands
	    ((POLYARRAY *) pMsgDrawPolyArray->paLast)->paNext
		= (POLYARRAY *) pa->pdBufferNext;
	    ((POLYARRAY *) pMsgDrawPolyArray->paLast)
		= (POLYARRAY *) pa->pdBufferNext;
	}
	else
	{
	    // resize the msg to the real size
	    pMsgBatchInfo->NextOffset = CurrentOffset
		+ GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY));

	    // remember the end of the primitive command
	    pa->nextMsgOffset = pMsgBatchInfo->NextOffset;

	    // start of a new chain
	    pMsgDrawPolyArray->pa0    =
	    pMsgDrawPolyArray->paLast = (PVOID) pa->pdBufferNext;
	}
    GLCLIENT_END


// Compute the start of the primitive.  A new primitive always begins with a
// POLYARRAY entry immediately followed by vertex entries.

    pd0 = pa->pdBufferNext + 1;

    // Initialize first polydata.

    pd0->flags = 0;

    ASSERTOPENGL(pd0->color == &pd0->colors[__GL_FRONTFACE],
                 "bad color pointer!\n");
    
    // Initialize the polyarray structure in the TEB.

    pa->flags         = aPolyArrayBeginFlags[mode];
    pa->pdNextVertex  =
    pa->pd0           = pd0;
    pa->primType      = mode;
    pa->pdCurColor    =	
    pa->pdCurNormal   =	
    pa->pdCurTexture  =	
    pa->pdCurEdgeFlag =	NULL;
    pa->paNext        = NULL;
    pa->nIndices      = 0;
    pa->aIndices      = NULL;	// identity mapping
    pa->pdLastEvalColor   =
    pa->pdLastEvalNormal  =
    pa->pdLastEvalTexture = NULL;
           
    // Compute the flush vertex for this primitive.  When the flush vertex is
    // reached, we will have accumulated enough vertices to render a partially
    // composed primitive.

    pdFlush = pa->pdBufferMax;
    switch (mode)
    {
      case GL_POINTS:
      case GL_LINE_STRIP:
      case GL_TRIANGLE_FAN:
        break;
      case GL_LINE_LOOP:
        // Line loop reserves an additional end vertex to close the loop.
        pdFlush--;
        break;
      case GL_POLYGON:
        // The polygon decomposer can only handle up to
        // __GL_MAX_POLYGON_CLIP_SIZE vertices.
        if (pdFlush > pd0 + __GL_MAX_POLYGON_CLIP_SIZE - 1)
	    pdFlush = pd0 + __GL_MAX_POLYGON_CLIP_SIZE - 1;
        break;
      case GL_LINES:
      case GL_TRIANGLE_STRIP:
      case GL_QUAD_STRIP:
        // number of vertices must be a multiple of 2
        if ((pdFlush - pd0 + 1) % 2)
            pdFlush--;
        break;
      case GL_TRIANGLES:
        // number of vertices must be a multiple of 3
        switch ((pdFlush - pd0 + 1) % 3)
        {
          case 2: pdFlush--;        // fall through
          case 1: pdFlush--;
        }
        break;
      case GL_QUADS:
        // number of vertices must be a multiple of 4
        switch ((pdFlush - pd0 + 1) % 4)
        {
          case 3: pdFlush--;        // fall through
          case 2: pdFlush--;        // fall through
          case 1: pdFlush--;
        }
        break;
    }
    pa->pdFlush = pdFlush;

#ifdef PRIMITIVE_TRACK
    DbgPrint("glcltBegin with %3d space left\n", pdFlush-pd0+1);
    prim_entries = 0;
#endif
}

// Special version of Begin for DrawElements.
// If you modify this function, you need to also modify glcltBegin.
void FASTCALL VA_DrawElementsBegin(POLYARRAY *pa, GLenum mode, GLsizei count)
{
    POLYDATA  *pd0;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;
    GLint     maxVertexCount;

    // The vertex buffer is used as follows.  The first entry contains the
    // POLYARRAY structure.  The incoming vertices will be saved beginning
    // at a following entry.  As an optimization, the POLYARRAY structure is
    // kept in the TEB.  When VA_DrawElementsEnd is called, it will be copied
    // to the vertex buffer.

    // We don't handle Points, Line Loop, and Polygon here.  They should
    // have been sent to Begin/End.

    ASSERTOPENGL(mode != GL_POINTS && mode != GL_LINE_LOOP && mode != GL_POLYGON,
    "Primitive type not handled\n");

    // Flush the command buffer if the vertex buffer will overflow.
    // Otherwise, just continue with the next available vertex buffer entry.

    // Maximum number of vertex entries that we will handle in next batch
    maxVertexCount = min(count,VA_DRAWELEM_MAP_SIZE)
    // Add maximum number of entries used for index map
    + (VA_DRAWELEM_INDEX_SIZE + sizeof(POLYDATA) - 1) / sizeof(POLYDATA)
    // Reserve an extra vertex entry to prevent calling
    // PolyArrayFlushPartialPrimitive in the Vertex routines.
    // It should call VA_DrawElementsFlushPartialPrimitive instead.
    + 1
    // Add an entry for POLYARRAY
    + 1
    // Add a few more entries to be safe
    + 4;

    if (pa->pdBufferNext > pa->pdBufferMax - maxVertexCount + 1)
    {
#ifdef PRIMITIVE_TRACK
        DbgPrint("* Min-not-present flush\n");
#endif
        glsbAttention();    // it resets pdBufferNext pointer too

        ASSERTOPENGL(pa->nextMsgOffset == PA_nextMsgOffset_RESET_VALUE, 
                     "bad nextMsgOffset\n");
    }

    // The vertex buffer must have at least maxVertexCount (currently <= 277)
    // entries.
    ASSERTOPENGL(maxVertexCount <= pa->pdBufferMax - pa->pdBuffer0 + 1,
    "vertex buffer is too small!\n");

    // Batch POLYARRAY command in the command buffer.
    // Combine adjacent DrawPolyArray commands into one command.

    GLCLIENT_BEGIN(DrawPolyArray, DRAWPOLYARRAY)
    // need msg pointer to update pa later
    pMsgDrawPolyArray = pMsg;

    if (pa->nextMsgOffset == CurrentOffset)
    {
        // rewind command buffer pointer
        pMsgBatchInfo->NextOffset = CurrentOffset;
        ((BYTE *) pMsgDrawPolyArray) -= 
         GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY));

        // chain adjacent DrawPolyArray commands
        ((POLYARRAY *) pMsgDrawPolyArray->paLast)->paNext
        = (POLYARRAY *) pa->pdBufferNext;
        ((POLYARRAY *) pMsgDrawPolyArray->paLast)
        = (POLYARRAY *) pa->pdBufferNext;
    }
    else
    {
        // remember the end of the primitive command
        pa->nextMsgOffset = pMsgBatchInfo->NextOffset;

        // start of a new chain
        pMsgDrawPolyArray->pa0    =
        pMsgDrawPolyArray->paLast = (PVOID) pa->pdBufferNext;
    }
    GLCLIENT_END


// Compute the start of the primitive.  A new primitive always begins with a
// POLYARRAY entry immediately followed by vertex entries.

    pd0 = pa->pdBufferNext + 1;

    // Initialize first polydata.

    pd0->flags = 0;
    
    ASSERTOPENGL(pd0->color == &pd0->colors[__GL_FRONTFACE],
                 "bad color pointer!\n");
    
    // Initialize the polyarray structure in the TEB.

    pa->flags         = aPolyArrayBeginFlags[mode] | POLYARRAY_SAME_POLYDATA_TYPE;
    pa->pdNextVertex  =
    pa->pd0           = pd0;
    pa->primType      = mode;
    pa->pdCurColor    =
    pa->pdCurNormal   =
    pa->pdCurTexture  =
    pa->pdCurEdgeFlag = NULL;
    pa->paNext        = NULL;
    pa->nIndices      = 0;
    pa->aIndices      = PA_aIndices_INITIAL_VALUE; // this is updated in End

    // For consistency
    pa->pdLastEvalColor    =
    pa->pdLastEvalNormal   =
    pa->pdLastEvalTexture  = NULL;

// The flush vertex for this primitive should never be reached.  We have
// reserved enough room for a vertex batch.  Set it to maximum and assert
// that we never reach the vertex in PolyArrayFlushPartialPrimitive!

    pa->pdFlush = pa->pdBufferMax;

#ifdef PRIMITIVE_TRACK
    DbgPrint("VA_DrawElementsBegin with %3d space left\n", pa->pdBufferMax-pd0+1);
#endif
    return;
}

void APIENTRY
glcltEnd ( void )
{
    POLYARRAY *pa;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;

#ifdef NEW_PARTIAL_PRIM
    __GL_SETUP();
    pa = gc->paTeb;
#else
    pa = GLTEB_CLTPOLYARRAY();
#endif

// Flush invalid commands accumulated in the command buffer if there is any.

    glsbAttention();

    // If we are not in the begin/end bracket, return an error.

    if (!(pa->flags & POLYARRAY_IN_BEGIN))
    {
        GLSETERROR(GL_INVALID_OPERATION);
        return;
    }

    // Clear the POLYARRAY_IN_BEGIN flag in the TEB.  We are now out of
    // the begin/end bracket.

    pa->flags &= ~POLYARRAY_IN_BEGIN;

    // Clear POLYARRAY_SAME_COLOR_DATA flag if the primitive uses more than
    // one color.  Also clear the flag if an evaluator is used.  We cannot
    // tell if an evaluator modifies the color on the client side.

    // If there are evaluator calls in this polyarray that also generate
    // color, then too, remove the POLYARRAY_SAME_COLOR_DATA flag

    if ((pa->pdCurColor != pa->pd0) ||
        ((pa->pd0->flags & POLYDATA_COLOR_VALID) &&
         (pa->flags & POLYARRAY_PARTIAL_BEGIN)) || 
        (pa->pdLastEvalColor != NULL))
        pa->flags &= ~POLYARRAY_SAME_COLOR_DATA;

    // Compute nIndices.  It is the final number of vertices passed to the low
    // level render routines and is different from the number of polydata's
    // accumulated.  The final number includes the reserved vertices and the
    // accumulated vertices.

    pa->nIndices += (GLint)((ULONG_PTR)(pa->pdNextVertex - pa->pd0));
    /*
    // If there are no vertices and no attributes to propagate to a next 
    // primitive, we can remove this polyarray from the batch
    if (pa->nIndices == 0 && pa->pdNextVertex->flags == 0)
        return;
        */

#ifdef NEW_PARTIAL_PRIM
    if (pa->primType == GL_LINE_LOOP)
    {
        if (pa->nIndices > 1)
        {
        // We have to add an additional vertex at the end. It could be
        //   - saved vertex if primitive is partial begin OR 
        //   - first vertex
        // We will change primitive type to GL_LINE_STRIP after we update 
        // current color, normal, texture, edge flag in __glim_DrawPolyArray
        //
            POLYDATA   *pd = pa->pdNextVertex++;
            SAVEREGION firstVertex;
            SAVEREGION lastVertex;
            SAVEREGION *reg;
            // We have to propagate vertex state for next primitive before we 
            // insert the vertex.

            pa->nIndices++;  
            if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
            { // This is partial primitive
                reg = &gc->vertex.regSaved;
            }
            else
            { // This is non partial primitive
                SaveSharedVertex(&firstVertex, pa->pd0, pa);
                reg = &firstVertex;
            }
            // Save pdNextVertex before we override it
            SaveSharedVertex(&lastVertex, pd, pa);      
            // Insert first vertex at the end
            RestoreSharedVertex(pd, reg, pa); 
            // Compute state for last vertex, because we have to override 
            // changes made by first vertex.
            UpdateVertexState(gc, pa, &lastVertex, pd-1, pd);
            // pdNextVertex will have state for a next primitive
            RestoreSharedVertex(pa->pdNextVertex, &lastVertex, pa);
        }

        pa->primType = GL_LINE_STRIP;
    }
#else // NEW_PARTIAL_PRIM
    if (pa->primType == GL_LINE_LOOP)
        pa->nIndices++;     // add one extra vertex when a line loop is closed.
                            // It's okay not to advance pdBufferNext since we
                            // don't need attributes after they've been
                            // processed.
#endif // NEWFLUSH

    // Save the POLYARRAY structure in the batch.

    pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
    ((BYTE *) pa->pMsgBatchInfo + pa->nextMsgOffset -
         GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
    *(POLYARRAY *) pMsgDrawPolyArray->paLast = *pa;

#ifdef PRIMITIVE_TRACK
    prim_entries += pa->pdNextVertex-pa->pd0;
    prim_total += prim_entries;
    prim_count++;
    DbgPrint("glcltEnd   with %3d polydata entries, %3d now, avg %d\n",
         prim_entries, pa->pdNextVertex-pa->pd0, prim_total/prim_count);
#endif

// Advance polyarray batch pointer.
// Skip a vertex because it may contain attributes for the current batch.

    pa->pdBufferNext = pa->pdNextVertex + 1;
}

void FASTCALL VA_DrawElementsEnd(POLYARRAY *pa)
{
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;

    ASSERTOPENGL(pa->flags & POLYARRAY_IN_BEGIN, "not in begin\n");
    ASSERTOPENGL(pa->aIndices && (pa->aIndices != PA_aIndices_INITIAL_VALUE),
	"no output index array!\n");

// Clear the POLYARRAY_IN_BEGIN flag in the TEB.  We are now out of
// the begin/end bracket.

    pa->flags &= ~POLYARRAY_IN_BEGIN;

// Clear POLYARRAY_SAME_COLOR_DATA flag if the primitive uses more than
// one color.

    if (pa->pdCurColor != pa->pd0)
	pa->flags &= ~POLYARRAY_SAME_COLOR_DATA;

// Save the POLYARRAY structure in the batch.

    pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
	((BYTE *) pa->pMsgBatchInfo + pa->nextMsgOffset -
         GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
    *(POLYARRAY *) pMsgDrawPolyArray->paLast = *pa;

#ifdef PRIMITIVE_TRACK
    prim_count++;
    DbgPrint("VA_DrawElementsEnd called\n");
#endif

// Advance polyarray batch pointer.

    pa->pdBufferNext = (POLYDATA *) (pa->aIndices +
	(pa->nIndices + sizeof(POLYDATA) - 1) / sizeof(POLYDATA) * sizeof(POLYDATA));
}

#ifdef NEW_PARTIAL_PRIM

typedef void (*PFNSAVERESTORE)(__GLcontext*, POLYARRAY*, SAVEREGION*);

void FASTCALL SaveFirstVertex(__GLcontext* gc, POLYARRAY* pa)
{
    if (!(pa->flags & POLYARRAY_PARTIAL_BEGIN))
    {
        GLuint  flags = pa->flags & (POLYARRAY_MATERIAL_FRONT | POLYARRAY_MATERIAL_BACK);
        SaveSharedVertex(&gc->vertex.regSaved, pa->pd0, pa);
        // Save vertex state to restore it later
        pa->flags |= (POLYARRAY_MATERIAL_FRONT | POLYARRAY_MATERIAL_BACK);
        UpdateVertexStateUsingGC(gc, pa, &gc->vertex.regSaved);
        // Restore pa flags
        pa->flags &= ~(POLYARRAY_MATERIAL_FRONT | POLYARRAY_MATERIAL_BACK);
        pa->flags |= flags;
    }
}

// This function is used by GL_POINTS, GL_LINES, GL_TRIANGLES, GL_QUADS, 
// because for these cases parts of broken primitive are not connected. 
// We also clear POLYARRAY_PARTIAL_END flag, because in DrawPolyArray we 
// can remove this partial primitive if it is clipped out (we do not have
// to preserve line stipple for these primitives).
//
void SaveEmpty(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    pa->flags &= ~POLYARRAY_PARTIAL_END;
}

// A line loop is the same as a line strip except that a final segment is
// added from the final specified vertex to the first vertex.  We convert 
// the line loop into a strip here. We have to save first vertex of line 
// loop only if the primitive is not partial begin (i.e. it is not a middle 
// part of a line loop broken into more than two polyarrays). 
// We do not clear POLYARRAY_PARTIAL_END flag, because in DrawPolyArray we 
// can not remove this partial primitive if it is clipped out to preserve 
// line stipple. 
// Index mapping is always indentity for GL_LINE_LOOP.
// We save first vertex in graphics state, because it will be restored in glcltEnd.
// We change line loop to line strip here.
//
// When the first vertex is saved we have preserve its state to restore it in the next part
// of partial primitive.
//
void SaveLineLoop(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    POLYDATA*  pd;

    SaveFirstVertex(gc, pa);

    pd = pa->pdNextVertex-1;
    SaveSharedVertex(r, pd, pa);
    pa->primType = GL_LINE_STRIP;
}

// For GL_LINE_STRIP we save last vertex. We do not clear POLYARRAY_PARTIAL_END flag,
// because in DrawPolyArray we can not remove this partial primitive if it is clipped
// out to preserve line stipple.
// We do not preserve index because it is assumed to be 0 for the next part
// of the primitive.
//
void SaveLineStrip(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    POLYDATA *pd;
    if (pa->aIndices)
        pd = &pa->pd0[pa->aIndices[pa->nIndices-1]];
    else
        pd = pa->pdNextVertex-1;
    SaveSharedVertex(r, pd, pa);
}

// For GL_TRIANLE_FAN we save first and last vertices. Line stipple is reset for every 
// triangle in a fan, so we can clear POLYARRAY_PARTIAL_END flag
// We do not preserve indices because they are assumed to be 0 and 1 for the next part
// of the primitive.
//
// When we restore first vertex it must have the same state as when we saved it.
// But this state should no affect vertex last vertex.
// So we have to compute vertex state for the first when we save it and compute
// vertex state for the lase vertex when we restore it.
// First vertex and its state should be computed only once, even if a primitive is broken 
// several times.
//
void SaveTFan(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    if (pa->aIndices)
    {
        POLYDATA *pd;
        GLubyte  *aIndices = pa->aIndices;

        pd = &pa->pd0[aIndices[0]];
        SaveSharedVertex(&gc->vertex.regSaved, pd, pa);

        pd = &pa->pd0[aIndices[pa->nIndices-1]];
        SaveSharedVertex(r, pd, pa);
    }
    else
    {
        POLYDATA *pd;
        // Compute state for the first vertex only for the very first part
        // of partial primitive
        SaveFirstVertex(gc, pa);

        pd = pa->pdNextVertex-1;
        SaveSharedVertex(r, pd, pa);
    }
    pa->flags &= ~POLYARRAY_PARTIAL_END;
}

// This function handles GL_TRIANGLE_STRIP and GL_QUAD_STRIP.
// We save two last vertices.
// Line stipple is reset for every triangle (quad) in a strip, so we can clear 
// POLYARRAY_PARTIAL_END flag.
// We do not preserve indices because they are assumed to be 0 and 1 for the 
// next part of the primitive.
//
// We have to save 2 last vertices: v1 and v2 (last vertex).
// Next part of partial primitive will start with vertex v1.
// v2 could change vertex state, so we have to compute vertex state for v1 and
// restore it. This should be done only for non indexed case.
//
void SaveTStrip(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    if (pa->aIndices)
    {
        POLYDATA *pd;
        GLint     nIndices = pa->nIndices;
        GLubyte  *aIndices = pa->aIndices;

        pd = &pa->pd0[aIndices[nIndices-2]];
        SaveSharedVertex(r, pd, pa);
        pd = &pa->pd0[aIndices[nIndices-1]];
        SaveSharedVertex(r+1, pd, pa);
    }
    else
    {
        POLYDATA *pd = pa->pdNextVertex-2;

        SaveSharedVertex(r, pd, pa);
        // Compute vertex state, changed by vertex pd+1
        UpdateVertexState(gc, pa, r, pd-1, pd+1);
        pd++;
        SaveSharedVertex(r+1, pd, pa);
    }
    pa->flags &= ~POLYARRAY_PARTIAL_END;
}

// For GL_POLYGON we first and last two vertices, because we do not know 
// if the last vertex of this part is the last vertex for the primitive. We need this
// information to compute edge flag for the last vertex.
// We remove last vertex from the primitive. It will be processed in the next part of 
// the primitive.
// We need POLYARRAY_PARTIAL_END flag when we compute edge flag in DrawPolyArray.
//
void SavePolygon(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    POLYDATA *pd;
    // Compute state for the first vertex only for the very first part
    // of partial primitive
    SaveFirstVertex(gc, pa);

    pd = pa->pdNextVertex-2;
    SaveSharedVertex(r, pd, pa);

    r++;
    pd = pa->pdNextVertex-1;
    SaveSharedVertex(r, pd, pa);

// Remove last vertex from the primitive
    pa->nIndices--;
    pa->pdNextVertex--;
}

PFNSAVERESTORE  pfnSaveFunc[] =
{
    SaveEmpty,      // GL_POINTS
    SaveEmpty,      // GL_LINES
    SaveLineLoop,   // GL_LINE_LOOP
    SaveLineStrip,  // GL_LINE_STRIP
    SaveEmpty,      // GL_TRIANGLES
    SaveTStrip,     // GL_TRIANGLE_STRIP
    SaveTFan,       // GL_TRIANGLE_FAN
    SaveEmpty,      // GL_QUADS
    SaveTStrip,     // GL_QUAD_STRIP
    SavePolygon     // GL_POLYGON
};

// This function is used by GL_POINTS, GL_LINES, GL_TRIANGLES, GL_QUADS, 
// because for these cases parts of broken primitive are not connected. We 
// also clear POLYARRAY_PARTIAL_BEGIN flag, because in DrawPolyArray we can 
// remove this partial primitive if it is clipped out (we do not have to 
// preserve line stipple for these primitives).
//
void RestoreEmpty(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    pa->flags &= ~POLYARRAY_PARTIAL_BEGIN;
}

// For GL_LINE_LOOP and GL_LINE_STRIP last vertex from previous part will be the first.
// We will convert line loop into line strip in glcltEnd or PolyArrayFlushPartialPrimitive
// To preserve line stipple we need POLYARRAY_PARTIAL_BEGIN flag.
//
void RestoreLineStrip(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    POLYDATA *pd = pa->pdNextVertex++;

    RestoreSharedVertex(pd, r, pa);
}

// For GL_TRIANGLE_STRIP and GL_QUAD_STRIP we have to add two saved
// vertices at the beginning of primitive.
// We do not to preserve line stipple, so we clear POLYARRAY_PARTIAL_BEGIN flag.
//
void RestoreTStrip(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    POLYDATA *pd = pa->pdNextVertex++;

    RestoreSharedVertex(pd, r, pa);
                 
    r++;
    pd = pa->pdNextVertex++;
    RestoreSharedVertex(pd, r, pa);

    pa->flags &= ~POLYARRAY_PARTIAL_BEGIN;
}

// For GL_TRIANGLE_FAN we have to add two saved vertices at the beginning 
// of primitive. Last vertex should have a state, not modified by previous vertex.
// We do not to preserve line stipple, so we clear POLYARRAY_PARTIAL_BEGIN flag.
//
void RestoreTFan(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    POLYDATA *pd = pa->pdNextVertex++;

    RestoreSharedVertex(pd, &gc->vertex.regSaved, pa);

    pd = pa->pdNextVertex++;
    if (!pa->aIndices)
        // Compute state for last vertex, because it could be modified 
        // by first vertex
        UpdateVertexStateUsingGC(gc, pa, r);
    RestoreSharedVertex(pd, r, pa);
}

// For GL_POLYGON we have to add three saved vertices at the beginning of primitive.
// We need POLYARRAY_PARTIAL_BEGIN flag to compute edge flag in DrawPolyArray.
//
void RestorePolygon(__GLcontext *gc, POLYARRAY *pa, SAVEREGION *r)
{
    POLYDATA *pd = pa->pdNextVertex++;

    RestoreSharedVertex(pd, &gc->vertex.regSaved, pa);
                 
    // Compute state for this vertex, because it could be modified 
    // by first vertex
    UpdateVertexStateUsingGC(gc, pa, r);
    pd = pa->pdNextVertex++;
    RestoreSharedVertex(pd, r, pa);

    r++;
    pd = pa->pdNextVertex++;
    RestoreSharedVertex(pd, r, pa);
}

PFNSAVERESTORE  pfnRestoreFunc[] =
{
    RestoreEmpty,      // GL_POINTS
    RestoreEmpty,      // GL_LINES
    RestoreLineStrip,  // GL_LINE_LOOP
    RestoreLineStrip,  // GL_LINE_STRIP
    RestoreEmpty,      // GL_TRIANGLES
    RestoreTStrip,     // GL_TRIANGLE_STRIP
    RestoreTFan,       // GL_TRIANGLE_FAN
    RestoreEmpty,      // GL_QUADS
    RestoreTStrip,     // GL_QUAD_STRIP
    RestorePolygon     // GL_POLYGON
};               

#endif // NEW_PARTIAL_PRIM

// Number of reserved vertices for partial Begin.
GLint nReservedIndicesPartialBegin[] =
{
    0, // GL_POINTS
    0, // GL_LINES
    1, // GL_LINE_LOOP
    1, // GL_LINE_STRIP
    0, // GL_TRIANGLES
    2, // GL_TRIANGLE_STRIP
    2, // GL_TRIANGLE_FAN
    0, // GL_QUADS
    2, // GL_QUAD_STRIP
    3  // GL_POLYGON
};

// If you modify this function, you need to also modify
// VA_DrawElementsFlushPartialPrimitive.
void FASTCALL PolyArrayFlushPartialPrimitive()
{
    POLYARRAY *pa;
    POLYDATA  *pd0, *pdFlush;
    GLenum    mode;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;
    GLuint    paFlags;
#ifdef NEW_PARTIAL_PRIM
    SAVEREGION savereg[3];     // Temporary storage for vertices, shared between
#endif // NEW_PARTIAL_PRIM     // parts of decomposed primitive                 
    __GL_SETUP();

    pa = gc->paTeb;

#ifdef PRIMITIVE_TRACK
    prim_entries += pa->pdNextVertex-pa->pd0;
    DbgPrint("* Flush partial primitive with %d polydata entries\n",
          pa->pdNextVertex-pa->pd0);
#endif

    ASSERTOPENGL(pa->flags & POLYARRAY_IN_BEGIN, "not in begin\n");
    ASSERTOPENGL(!pa->aIndices || (pa->aIndices == PA_aIndices_INITIAL_VALUE),
                 "Flushing DrawElements unexpected!\n");

// Flush invalid commands accumulated in the command buffer if there is any.

    glsbAttention();

    // Clear the POLYARRAY_IN_BEGIN flag in the TEB.  We are now out of
    // the begin/end bracket temporarily.  glsbAttention does not flush
    // unless the flag is clear.

    pa->flags &= ~POLYARRAY_IN_BEGIN;

    // Mark it as a partially completed primitive batch.

    pa->flags |= POLYARRAY_PARTIAL_END;

    // Clear POLYARRAY_SAME_COLOR_DATA flag if the primitive uses more than
    // one color.  Also clear the flag if an evaluator is used.  We cannot
    // tell if an evaluator modifies the color on the client side.

    if ((pa->pdCurColor != pa->pd0) ||
        ((pa->pd0->flags & POLYDATA_COLOR_VALID) &&
         (pa->flags & POLYARRAY_PARTIAL_BEGIN)) ||
        (pa->pdLastEvalColor != pa->pd0))
        pa->flags &= ~POLYARRAY_SAME_COLOR_DATA;

    // Save some pa flags for next partial primitive.
    // Need to preserve POLYARRAY_CLAMP_COLOR flag in dlist playback.

#ifdef NEW_PARTIAL_PRIM
    // We have to preserve material flags to handle first vertex
    //
    paFlags = pa->flags & (POLYARRAY_SAME_POLYDATA_TYPE |
                           POLYARRAY_SAME_COLOR_DATA |
                           POLYARRAY_TEXTURE1 |
                           POLYARRAY_TEXTURE2 |
                           POLYARRAY_TEXTURE3 |
                           POLYARRAY_TEXTURE4 |
                           POLYARRAY_VERTEX2  |
                           POLYARRAY_VERTEX3  |
                           POLYARRAY_VERTEX4  |
                           POLYDATA_MATERIAL_FRONT | 
                           POLYDATA_MATERIAL_BACK  |
                           POLYARRAY_CLAMP_COLOR);
#else
    paFlags = pa->flags & (POLYARRAY_SAME_POLYDATA_TYPE |
                           POLYARRAY_SAME_COLOR_DATA |
                           POLYARRAY_CLAMP_COLOR);
#endif
    // Compute nIndices.  It is the final number of vertices passed to the low
    // level render routines and is different from the number of polydata's
    // accumulated.  The final number includes the reserved vertices and the
    // accumulated vertices.

    pa->nIndices += (GLint)((ULONG_PTR)(pa->pdNextVertex - pa->pd0));

    // Save states before flushing the batch.

    mode = pa->primType;

#ifdef NEW_PARTIAL_PRIM
    // Save shared vertices for the next part of the partial primitive

    pfnSaveFunc[mode](gc, pa, savereg);
#endif // NEW_PARTIAL_PRIM

    // Save the POLYARRAY structure in the batch.

    pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
    
    ((BYTE *) pa->pMsgBatchInfo + pa->nextMsgOffset -
       GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
    *(POLYARRAY *) pMsgDrawPolyArray->paLast = *pa;


    // Flush the command buffer and reset pointer for the next batch.
    // If we are compiling poly array primitive in dlist, record the last poly
    // data record.

    if (gc->dlist.beginRec)
    {
        // Record the poly data.
        __glDlistCompilePolyData(gc, GL_FALSE);

        // We just recorded this vertex, don't record it in the compile
        // code again!
        gc->dlist.skipPolyData = GL_TRUE;

        if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE)
            glsbAttention();    // reset pdBufferNext pointer too!
        else
            glsbResetBuffers(TRUE); // reset pointers but no execution
    }
    else
    {
        glsbAttention();    // reset pdBufferNext pointer too!
    }

    ASSERTOPENGL(pa->nextMsgOffset == PA_nextMsgOffset_RESET_VALUE, 
                 "bad nextMsgOffset\n");

    // Batch new POLYARRAY command in the command buffer.
    
    GLCLIENT_BEGIN(DrawPolyArray, DRAWPOLYARRAY)
    // need msg pointer to update pa later
    pMsgDrawPolyArray = pMsg;

    // start of a new chain
    pMsgDrawPolyArray->pa0    =
    pMsgDrawPolyArray->paLast = (PVOID) pa->pdBufferNext;

    // remember the end of the primitive command
    pa->nextMsgOffset = pMsgBatchInfo->NextOffset;
    GLCLIENT_END

#ifdef NEW_PARTIAL_PRIM
// Compute the start of the PARTIAL primitive.  A partial primitive begins
// with a POLYARRAY entry followed by vertex entries.  We DO NOT not need to
// reserve additional vertex entries at the beginning for connectivity
// between decomposed primitives. Because we just add them at the beginning

    pd0 = pa->pdBufferNext + 1;
#else
// Compute the start of the PARTIAL primitive.  A partial primitive begins
// with a POLYARRAY entry followed by vertex entries.  We need to
// reserve additional vertex entries at the beginning for connectivity
// between decomposed primitives.

    pd0 = pa->pdBufferNext + 1 + nReservedIndicesPartialBegin[mode];

#endif // NEW_PARTIAL_PRIM

    // Initialize first polydata.

    pd0->flags = 0;
    
    ASSERTOPENGL(pd0->color == &pd0->colors[__GL_FRONTFACE],
                 "bad color pointer!\n");
    
    // Initialize the polyarray structure in the TEB.

    pa->flags         = POLYARRAY_IN_BEGIN | POLYARRAY_PARTIAL_BEGIN | paFlags;
    pa->pdNextVertex  =
    pa->pd0           = pd0;
    pa->primType      = mode;
    pa->paNext        = NULL;
#ifdef NEW_PARTIAL_PRIM
    pa->nIndices      = 0;          // WE do not reserve any vertices
#else
    pa->nIndices      = nReservedIndicesPartialBegin[mode];
#endif // NEW_PARTIAL_PRIM
    pa->aIndices      = NULL;   // identity mapping
    pa->pdCurColor    =
    pa->pdCurNormal   =
    pa->pdCurTexture  =
    pa->pdCurEdgeFlag =
    pa->pdLastEvalColor    =
    pa->pdLastEvalNormal   =
    pa->pdLastEvalTexture  = NULL;


    // Compute the flush vertex for this primitive.  When the flush vertex is
    // reached, we will have accumulated enough vertices to render a partially
    // composed primitive.

    pdFlush = pa->pdBufferMax;
    switch (mode)
    {
      case GL_POINTS:
      case GL_LINE_STRIP:
      case GL_TRIANGLE_FAN:
        break;
      case GL_LINE_LOOP:
        // Line loop reserves an additional end vertex to close the loop.
        pdFlush--;
        break;
      case GL_POLYGON:
        // The polygon decomposer can only handle up to
        // __GL_MAX_POLYGON_CLIP_SIZE vertices.  We also need to give
        // allowance for 3 vertices in the decomposed polygons.
        if (pdFlush > (pd0 - 3) + __GL_MAX_POLYGON_CLIP_SIZE - 1)
            pdFlush = (pd0 - 3) + __GL_MAX_POLYGON_CLIP_SIZE - 1;
        ASSERTOPENGL(nReservedIndicesPartialBegin[GL_POLYGON] == 3,
                     "bad reserved size!\n");
        break;
      case GL_LINES:
      case GL_TRIANGLE_STRIP:
      case GL_QUAD_STRIP:
        // number of vertices must be a multiple of 2
        if ((pdFlush - pd0 + 1) % 2)
            pdFlush--;
        break;
      case GL_TRIANGLES:
        // number of vertices must be a multiple of 3
        switch ((pdFlush - pd0 + 1) % 3)
        {
          case 2: pdFlush--;        // fall through
          case 1: pdFlush--;
        }
        break;
      case GL_QUADS:
        // number of vertices must be a multiple of 4
        switch ((pdFlush - pd0 + 1) % 4)
        {
          case 3: pdFlush--;        // fall through
          case 2: pdFlush--;        // fall through
          case 1: pdFlush--;
        }
        break;
    }
    pa->pdFlush = pdFlush;

#ifdef NEW_PARTIAL_PRIM
    // Add saved vertices into the new part of the primitive

    pfnRestoreFunc[mode](gc, pa, savereg);

#endif // NEW_PARTIAL_PRIM
}

// Special version of Flush for DrawElements.
// If you modify this function, you need to also modify
// PolyArrayFlushPartialPrimitive.
void FASTCALL VA_DrawElementsFlushPartialPrimitive(POLYARRAY *pa, GLenum mode)
{
    POLYDATA  *pd0;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;
    GLuint    paFlags;
#ifdef NEW_PARTIAL_PRIM
    SAVEREGION  savereg[3];     // Temporary storage for vertices, shared between
#endif // NEW_PARTIAL_PRIM             // parts of decomposed primitive                 
    __GL_SETUP();

#ifdef PRIMITIVE_TRACK
    DbgPrint("VA_DrawElementsFlushPartialPrimitive called\n");
#endif

    // We don't handle Points, Line Loop, and Polygon here.  They should
    // have been sent to Begin/End.

    ASSERTOPENGL(mode != GL_POINTS && mode != GL_LINE_LOOP && mode != GL_POLYGON,
                 "Primitive type not handled\n");

    ASSERTOPENGL(pa->flags & POLYARRAY_IN_BEGIN, "not in begin\n");
    ASSERTOPENGL(pa->aIndices && (pa->aIndices != PA_aIndices_INITIAL_VALUE),
	"no output index array!\n");

    // Clear the POLYARRAY_IN_BEGIN flag in the TEB.  We are now out of
    // the begin/end bracket temporarily.  glsbAttention does not flush
    // unless the flag is clear.

    pa->flags &= ~POLYARRAY_IN_BEGIN;

    // Mark it as a partially completed primitive batch.

    pa->flags |= POLYARRAY_PARTIAL_END;

    // Clear POLYARRAY_SAME_COLOR_DATA flag if the primitive uses more than
    // one color.

    if (pa->pdCurColor != pa->pd0)
        pa->flags &= ~POLYARRAY_SAME_COLOR_DATA;

    // Save some pa flags for next partial primitive.

    paFlags = pa->flags & (POLYARRAY_SAME_COLOR_DATA |
                           POLYARRAY_TEXTURE1 |
                           POLYARRAY_TEXTURE2 |
                           POLYARRAY_TEXTURE3 |
                           POLYARRAY_TEXTURE4 |
                           POLYARRAY_VERTEX2  |
                           POLYARRAY_VERTEX3  |
                           POLYARRAY_VERTEX4  |
                           POLYARRAY_CLAMP_COLOR);

#ifdef NEW_PARTIAL_PRIM
    // Save shared vertices for the next part of partial primitive

    pfnSaveFunc[mode](gc, pa, savereg);

#endif // NEW_PARTIAL_PRIM

    // Save the POLYARRAY structure in the batch.

    pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
      ((BYTE *) pa->pMsgBatchInfo + pa->nextMsgOffset -
       GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
    *(POLYARRAY *) pMsgDrawPolyArray->paLast = *pa;

    // Flush the command buffer and reset pointer for the next batch.

    ASSERTOPENGL(!gc->dlist.beginRec
                 || gc->dlist.mode == GL_COMPILE_AND_EXECUTE,
                 "dlist complilation unexpected!\n");
    glsbAttention();    // reset pdBufferNext pointer too!

    ASSERTOPENGL(pa->nextMsgOffset == PA_nextMsgOffset_RESET_VALUE, 
                 "bad nextMsgOffset\n");

    // Batch new POLYARRAY command in the command buffer.

    GLCLIENT_BEGIN(DrawPolyArray, DRAWPOLYARRAY)
    // need msg pointer to update pa later
    pMsgDrawPolyArray = pMsg;

    // start of a new chain
    pMsgDrawPolyArray->pa0    =
    pMsgDrawPolyArray->paLast = (PVOID) pa->pdBufferNext;

    // remember the end of the primitive command
    pa->nextMsgOffset = pMsgBatchInfo->NextOffset;
    GLCLIENT_END

#ifdef NEW_PARTIAL_PRIM
// Compute the start of the PARTIAL primitive.  A partial primitive begins
// with a POLYARRAY entry followed by vertex entries.  We DO NOT need to
// reserve additional vertex entries at the beginning for connectivity
// between decomposed primitives.

    pd0 = pa->pdBufferNext + 1;
#else
// Compute the start of the PARTIAL primitive.  A partial primitive begins
// with a POLYARRAY entry followed by vertex entries.  We need to
// reserve additional vertex entries at the beginning for connectivity
// between decomposed primitives.

    pd0 = pa->pdBufferNext + 1 + nReservedIndicesPartialBegin[mode];
#endif

    // Initialize first polydata.

    pd0->flags = 0;
    
    ASSERTOPENGL(pd0->color == &pd0->colors[__GL_FRONTFACE],
                 "bad color pointer!\n");
    
    // Initialize the polyarray structure in the TEB.

    pa->flags         = POLYARRAY_IN_BEGIN | POLYARRAY_PARTIAL_BEGIN |
      POLYARRAY_SAME_POLYDATA_TYPE | paFlags;
    pa->pdNextVertex  =
    pa->pd0           = pd0;
    pa->primType      = mode;
    pa->pdCurColor    =
    pa->pdCurNormal   =
    pa->pdCurTexture  =
    pa->pdCurEdgeFlag = NULL;
    pa->paNext        = NULL;
#ifdef NEW_PARTIAL_PRIM
    pa->nIndices      = 0;
#else
    pa->nIndices      = nReservedIndicesPartialBegin[mode];
#endif // NEW_PARTIAL_PRIM
    pa->aIndices      = PA_aIndices_INITIAL_VALUE;  // this is updated in End
    
// The flush vertex for this primitive should never be reached.  The call
// to glsbAttention in this function has left enough room for a vertex batch.
// Set it to maximum and assert that we never reach the vertex in
// PolyArrayFlushPartialPrimitive!

    pa->pdFlush = pa->pdBufferMax;

#ifdef NEW_PARTIAL_PRIM
    // Add saved vertices into the new part of the primitive

    pfnRestoreFunc[mode](gc, pa, savereg);

#endif // NEW_PARTIAL_PRIM
}

// The vertex functions are called in begin/end only.
#define PA_VERTEX2(x1,y1)					\
								\
    POLYARRAY *pa;						\
    POLYDATA  *pd;						\
								\
    pa = GLTEB_CLTPOLYARRAY();					\
								\
    if (pa->flags & POLYARRAY_IN_BEGIN)				\
    {								\
	pa->flags |= POLYARRAY_VERTEX2;				\
								\
	pd = pa->pdNextVertex++;				\
	pd->flags |= POLYDATA_VERTEX2;				\
	pd->obj.x = x1;						\
	pd->obj.y = y1;						\
	pd->obj.z = __glZero;					\
	pd->obj.w = __glOne;					\
								\
	pd[1].flags = 0;					\
								\
	if (pd >= pa->pdFlush)            			\
	    PolyArrayFlushPartialPrimitive(); 			\
    }      

#define PA_VERTEX3(x1,y1,z1)				\
{								            \
    GLfloat t1;							    \
    POLYARRAY *pa;							\
    POLYDATA  *pd, *pd1;					\
    ULONG	flag1, flag2, flag3;			\
    register GLfloat tone;					\
                                            \
    pa = GLTEB_CLTPOLYARRAY();				\
    tone = 1.0;                             \
                                            \
    pd1 = pa->pdFlush;						\
    flag1 = pa->flags;						\
    pd = pa->pdNextVertex;					\
                                            \
    if (flag1 & POLYARRAY_IN_BEGIN)         \
    {                                       \
        flag3 = pd->flags;                  \
        pa->pdNextVertex++;                 \
        flag2 = flag1 | POLYARRAY_VERTEX3;  \
        flag3 = flag3 | POLYDATA_VERTEX3;   \
                                            \
        pd->obj.x = x1;						\
        pd->obj.y = y1;						\
        pd->obj.z = z1;						\
        pd->obj.w = tone;					\
        pa->flags = flag2;					\
        pd->flags = flag3;					    \
								                \
        pd[1].flags = 0;					    \
								                \
        if (pd >= pd1)		            		\
	        PolyArrayFlushPartialPrimitive();   \
    }                                           \
}

#define PA_VERTEX4(x1,y1,z1,w1)					\
								\
    POLYARRAY *pa;						\
    POLYDATA  *pd;						\
								\
    pa = GLTEB_CLTPOLYARRAY();					\
								\
    if (pa->flags & POLYARRAY_IN_BEGIN)				\
    {								\
	pa->flags |= POLYARRAY_VERTEX4;				\
								\
	pd = pa->pdNextVertex++;				\
	pd->flags |= POLYDATA_VERTEX4;				\
	pd->obj.x = x1;						\
	pd->obj.y = y1;						\
	pd->obj.z = z1;						\
	pd->obj.w = w1;						\
								\
	pd[1].flags = 0;					\
								\
	if (pd >= pa->pdFlush)            			\
	    PolyArrayFlushPartialPrimitive(); 			\
    }

#define PA_COLOR_IN_RGBA_NO_CLAMP1(red,green,blue)		            \
    POLYARRAY *pa;						            \
    POLYDATA  *pd;						            \
    __GL_SETUP();                                                           \
								            \
    pa = gc->paTeb;							    \
								            \
    if (pa->flags & POLYARRAY_IN_BEGIN)				            \
    {								            \
	pd = pa->pdNextVertex;					            \
	pa->pdCurColor = pd;					            \
                                                                            \
        __GL_SCALE_RGB(pd->colors[0].r, pd->colors[0].g, pd->colors[0].b,   \
                       gc, red, green, blue);    	                    \
        pd->colors[0].a = gc->alphaVertexScale;                             \
                                                                            \
	pd->flags |= POLYDATA_COLOR_VALID;				    \
    }								            \
    else							            \
    {								            \
	glcltColor4f_InRGBA_NotInBegin(gc, pa,				    \
	  POLYDATA_COLOR_VALID, red, green, blue, __glOne);		    \
    }

#define PA_COLOR_IN_RGBA_NO_CLAMP(red,green,blue,alpha)		            \
    POLYARRAY *pa;						            \
    POLYDATA  *pd;						            \
    __GL_SETUP();                                                           \
								            \
    pa = gc->paTeb;							    \
								            \
    if (pa->flags & POLYARRAY_IN_BEGIN)				            \
    {								            \
	pd = pa->pdNextVertex;					            \
	pa->pdCurColor = pd;					            \
                                                                            \
        __GL_SCALE_RGBA(pd->colors[0].r,                                    \
                        pd->colors[0].g,                                    \
                        pd->colors[0].b,                                    \
                        pd->colors[0].a,                                    \
                        gc, red, green, blue, alpha);                       \
                                                                            \
	pd->flags |= POLYDATA_COLOR_VALID | POLYDATA_DLIST_COLOR_4;	    \
    }								            \
    else							            \
    {								            \
	glcltColor4f_InRGBA_NotInBegin(gc, pa,				    \
	  POLYDATA_COLOR_VALID | POLYDATA_DLIST_COLOR_4, red, green, blue, alpha);\
    }

#define PA_COLOR_IN_RGB1(red,green,blue)			            \
    POLYARRAY *pa;						            \
    POLYDATA  *pd;						            \
    __GL_SETUP();                                                           \
								            \
    pa = gc->paTeb;						            \
								            \
    if (pa->flags & POLYARRAY_IN_BEGIN)				            \
    {								            \
	pd = pa->pdNextVertex;					            \
	pa->pdCurColor = pd;					            \
                                                                            \
        __GL_SCALE_AND_CHECK_CLAMP_RGB(pd->colors[0].r,                     \
                                       pd->colors[0].g,                     \
                                       pd->colors[0].b,                     \
                                       gc, pa->flags,                       \
                                       red, green, blue);                   \
        pd->colors[0].a = gc->alphaVertexScale;                             \
                                                                            \
	pd->flags |= POLYDATA_COLOR_VALID;			            \
    }								            \
    else							            \
    {								            \
	glcltColor4f_InRGBA_NotInBegin(gc, pa,				    \
	  POLYDATA_COLOR_VALID, red, green, blue, __glOne);		    \
    }

#define PA_COLOR_IN_RGB2(red, green, blue)      \
{                                               \
    POLYARRAY *pa;                              \
    POLYDATA  *pd;                              \
    GLfloat sr, sg, sb;                         \
    ULONG f1, f2, f3, f4, f5, f6;               \
    LONG t1, t2, t3;                            \
                                                \
    __GL_SETUP();                               \
                                                \
    pa = gc->paTeb;                             \
                                                \
    if (pa->flags & POLYARRAY_IN_BEGIN)			\
    {                                           \
                                                \
        t1 = (LONG) (CASTINT(gc->redVertexScale));      \
        t2 = (LONG) (CASTINT(gc->greenVertexScale));	\
        t3 = (LONG) (CASTINT(gc->blueVertexScale));		\
                                                \
        pd = pa->pdNextVertex;                  \
        pa->pdCurColor = pd;                    \
                                                \
        sr = red *  gc->redVertexScale;         \
        sg = green * gc->greenVertexScale;      \
        sb = blue * gc->blueVertexScale;        \
                                                \
        f1 = (ULONG) (CASTINT(sr));             \
        f2 = (ULONG) (CASTINT(sg));             \
        f3 = (ULONG) (CASTINT(sb));             \
							                    \
        f4 = (ULONG) (t1 - CASTINT(sr));		\
        f5 = (ULONG) (t2 - CASTINT(sg));		\
        f6 = (ULONG) (t3 - CASTINT(sb));		\
                                                \
        f1 = f1 | f2;                           \
        f3 = f3 | f4;                           \
        f5 = f5 | f6;                           \
                                                \
        pd->colors[0].r = sr;					\
        pd->colors[0].g = sg;					\
        pd->colors[0].b = sb;					\
                                                \
        f1 = f1 | f3 | f5;                      \
                                                \
        pa->flags |= (f1 & 0x80000000);         \
                                                \
        pd->colors[0].a = gc->alphaVertexScale; \
                             				    \
        pd->flags |= POLYDATA_COLOR_VALID;		\
    }	                                        \
    else                                        \
    {	                                        \
        glcltColor4f_InRGBA_NotInBegin(gc, pa,              \
          POLYDATA_COLOR_VALID, red, green, blue, __glOne);	\
    }								                        \
}

#define PA_COLOR_IN_RGBA(red,green,blue,alpha)			            \
    POLYARRAY *pa;						            \
    POLYDATA  *pd;						            \
    __GL_SETUP();                                                           \
								            \
    pa = gc->paTeb;							    \
								            \
    if (pa->flags & POLYARRAY_IN_BEGIN)				            \
    {								            \
	pd = pa->pdNextVertex;					            \
	pa->pdCurColor = pd;					            \
                                                                            \
        __GL_SCALE_AND_CHECK_CLAMP_RGBA(pd->colors[0].r,                    \
                                        pd->colors[0].g,                    \
                                        pd->colors[0].b,                    \
                                        pd->colors[0].a,                    \
                                        gc, pa->flags,                      \
                                        red, green, blue, alpha);           \
                                                                            \
	pd->flags |= POLYDATA_COLOR_VALID | POLYDATA_DLIST_COLOR_4;	    \
    }								            \
    else							            \
    {								            \
	glcltColor4f_InRGBA_NotInBegin(gc, pa,				    \
	  POLYDATA_COLOR_VALID | POLYDATA_DLIST_COLOR_4, red, green, blue, alpha);\
    }

#define PA_COLOR_IN_CI(red,green,blue,alpha)			\
								\
    POLYARRAY *pa;						\
								\
    pa = GLTEB_CLTPOLYARRAY();					\
								\
    if (pa->flags & POLYARRAY_IN_BEGIN)				\
    {								\
	pa->flags |= POLYARRAY_OTHER_COLOR;			\
	/* need only record the latest values */		\
	/* otherColor in the TEB may not be aligned at 16-byte boundary */ \
	pa->otherColor.r = red;					\
	pa->otherColor.g = green;				\
	pa->otherColor.b = blue;				\
	pa->otherColor.a = alpha;				\
    }								\
    else							\
    {								\
	glcltColor4f_NotInBegin(red, green, blue, alpha);	\
    }

void FASTCALL glcltColor4f_NotInBegin(GLfloat red, GLfloat green,
    GLfloat blue, GLfloat alpha)
{
    GLCLIENT_BEGIN( Color4fv, COLOR4FV )
        pMsg->v[0] = red;
        pMsg->v[1] = green;
        pMsg->v[2] = blue;
        pMsg->v[3] = alpha;
    GLCLIENT_END
}

void FASTCALL glcltColor4f_InRGBA_NotInBegin(__GLcontext *gc, POLYARRAY *pa,
    GLuint pdFlags, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
    POLYDATA  *pd;
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;

    pMsgBatchInfo = (GLMSGBATCHINFO *) pa->pMsgBatchInfo;

    // If the last command is DrawPolyArray, add it to the command.
    // This allows us to chain primitives separated by the attribute.
    if (pMsgBatchInfo->NextOffset == pa->nextMsgOffset)
    {
	pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
	    ((BYTE *) pMsgBatchInfo + pMsgBatchInfo->NextOffset -
	     GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
        pa = (POLYARRAY *) pMsgDrawPolyArray->paLast;

	pd = pa->pdNextVertex;
	pa->pdCurColor = pd;

        __GL_SCALE_AND_CHECK_CLAMP_RGBA(pd->colors[0].r,
                                        pd->colors[0].g,
                                        pd->colors[0].b,
                                        pd->colors[0].a,
                                        gc, pa->flags,
                                        red, green, blue, alpha);

	pd->flags |= pdFlags;
    }
    else
    {
	glcltColor4f_NotInBegin(red, green, blue, alpha);
    }
}

#define PA_INDEX_IN_RGBA(i)					\
								\
    POLYARRAY *pa;						\
								\
    pa = GLTEB_CLTPOLYARRAY();					\
								\
    if (pa->flags & POLYARRAY_IN_BEGIN)				\
    {								\
	pa->flags |= POLYARRAY_OTHER_COLOR;			\
	/* need only record the latest value */			\
	pa->otherColor.r = i;					\
    }								\
    else							\
    {								\
	glcltIndexf_NotInBegin(i);				\
    }

#define PA_INDEX_IN_CI(i)					\
								\
    POLYARRAY *pa;						\
    POLYDATA  *pd;						\
    __GL_SETUP();                                               \
								\
    pa = gc->paTeb;					        \
								\
    if (pa->flags & POLYARRAY_IN_BEGIN)				\
    {								\
	pd = pa->pdNextVertex;					\
	pa->pdCurColor = pd;					\
        __GL_CHECK_CLAMP_CI(pd->colors[0].r, gc, pa->flags, i);	\
	pd->flags |= POLYDATA_COLOR_VALID;			\
    }								\
    else							\
    {								\
	glcltIndexf_InCI_NotInBegin(gc, pa, i);			\
    }

void FASTCALL glcltIndexf_NotInBegin(GLfloat c)
{
    GLCLIENT_BEGIN( Indexf, INDEXF )
	pMsg->c = c;
    GLCLIENT_END
}

void FASTCALL glcltIndexf_InCI_NotInBegin(__GLcontext *gc, POLYARRAY *pa, GLfloat c)
{
    POLYDATA  *pd;
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;

    pMsgBatchInfo = (GLMSGBATCHINFO *) pa->pMsgBatchInfo;

    // If the last command is DrawPolyArray, add it to the command.
    // This allows us to chain primitives separated by the attribute.
    if (pMsgBatchInfo->NextOffset == pa->nextMsgOffset)
    {
	pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
	    ((BYTE *) pMsgBatchInfo + pMsgBatchInfo->NextOffset -
	     GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
        pa = (POLYARRAY *) pMsgDrawPolyArray->paLast;

	pd = pa->pdNextVertex;
	pa->pdCurColor = pd;
        __GL_CHECK_CLAMP_CI(pd->colors[0].r, gc, pa->flags, c);
	pd->flags |= POLYDATA_COLOR_VALID;
    }
    else
    {
	glcltIndexf_NotInBegin(c);
    }
}

#define PA_TEXTURE1(s1)							\
									\
    POLYARRAY *pa;							\
    POLYDATA  *pd;							\
									\
    pa = GLTEB_CLTPOLYARRAY();						\
									\
    if (pa->flags & POLYARRAY_IN_BEGIN)					\
    {									\
	pa->flags |= POLYARRAY_TEXTURE1;				\
									\
	pd = pa->pdNextVertex;						\
	pa->pdCurTexture = pd;						\
	pd->flags |= POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE1;	\
	pd->texture.x = s1;						\
	pd->texture.y = __glZero;					\
	pd->texture.z = __glZero;					\
	pd->texture.w = __glOne;					\
    }									\
    else								\
    {									\
	glcltTexCoord4f_NotInBegin(pa, POLYARRAY_TEXTURE1,		\
	    s1, __glZero, __glZero, __glOne);				\
    }

#define PA_TEXTURE2(s1,t1)						\
									\
    POLYARRAY *pa;							\
    POLYDATA  *pd;							\
									\
    pa = GLTEB_CLTPOLYARRAY();						\
									\
    if (pa->flags & POLYARRAY_IN_BEGIN)					\
    {									\
	pa->flags |= POLYARRAY_TEXTURE2;				\
									\
	pd = pa->pdNextVertex;						\
	pa->pdCurTexture = pd;						\
	pd->flags |= POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE2;	\
	pd->texture.x = s1;						\
	pd->texture.y = t1;						\
	pd->texture.z = __glZero;					\
	pd->texture.w = __glOne;					\
    }									\
    else								\
    {									\
	glcltTexCoord4f_NotInBegin(pa, POLYARRAY_TEXTURE2,		\
	    s1, t1, __glZero, __glOne);					\
    }

#define PA_TEXTURE3(s1,t1,r1)						\
									\
    POLYARRAY *pa;							\
    POLYDATA  *pd;							\
									\
    pa = GLTEB_CLTPOLYARRAY();						\
									\
    if (pa->flags & POLYARRAY_IN_BEGIN)					\
    {									\
	pa->flags |= POLYARRAY_TEXTURE3;				\
									\
	pd = pa->pdNextVertex;						\
	pa->pdCurTexture = pd;						\
	pd->flags |= POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE3;	\
	pd->texture.x = s1;						\
	pd->texture.y = t1;						\
	pd->texture.z = r1;						\
	pd->texture.w = __glOne;					\
    }									\
    else								\
    {									\
	glcltTexCoord4f_NotInBegin(pa, POLYARRAY_TEXTURE3,		\
	    s1, t1, r1, __glOne);					\
    }

#define PA_TEXTURE4(s1,t1,r1,q1)					\
									\
    POLYARRAY *pa;							\
    POLYDATA  *pd;							\
									\
    pa = GLTEB_CLTPOLYARRAY();						\
									\
    if (pa->flags & POLYARRAY_IN_BEGIN)					\
    {									\
	pa->flags |= POLYARRAY_TEXTURE4;				\
									\
	pd = pa->pdNextVertex;						\
	pa->pdCurTexture = pd;						\
	pd->flags |= POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE4;	\
	pd->texture.x = s1;						\
	pd->texture.y = t1;						\
	pd->texture.z = r1;						\
	pd->texture.w = q1;						\
    }									\
    else								\
    {									\
	glcltTexCoord4f_NotInBegin(pa, POLYARRAY_TEXTURE4,		\
	    s1, t1, r1, q1);						\
    }

void FASTCALL glcltTexCoord4f_NotInBegin(POLYARRAY *pa, GLuint paFlags,
    GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
    POLYDATA  *pd;
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;

    pMsgBatchInfo = (GLMSGBATCHINFO *) pa->pMsgBatchInfo;

    // If the last command is DrawPolyArray, add it to the command.
    // This allows us to chain primitives separated by the attribute.
    if (pMsgBatchInfo->NextOffset == pa->nextMsgOffset)
    {
	pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
	    ((BYTE *) pMsgBatchInfo + pMsgBatchInfo->NextOffset -
	     GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
        pa = (POLYARRAY *) pMsgDrawPolyArray->paLast;

	pa->flags |= paFlags;
	pd = pa->pdNextVertex;
	pa->pdCurTexture = pd;
	pd->flags |= POLYDATA_TEXTURE_VALID | paFlags;
	pd->texture.x = s;
	pd->texture.y = t;
	pd->texture.z = r;
	pd->texture.w = q;
    }
    else
    {
	GLCLIENT_BEGIN( TexCoord4fv, TEXCOORD4FV )
	    pMsg->v[0] = s;
	    pMsg->v[1] = t;
	    pMsg->v[2] = r;
	    pMsg->v[3] = q;
	GLCLIENT_END
    }
}

#define PA_NORMAL(x1, y1, z1)					\
{								\
    POLYARRAY *pa;						\
    POLYDATA  *pd;						\
    ULONG flag1, flag2;						\
								\
    pa = GLTEB_CLTPOLYARRAY();					\
								\
    pd = pa->pdNextVertex;					\
    flag1 = pa->flags;						\
								\
    if (flag1 & POLYARRAY_IN_BEGIN)         \
    {                                       \
        flag2 = pd->flags;					\
        flag2 |= POLYDATA_NORMAL_VALID;	    \
        pa->pdCurNormal = pd;				\
        pd->normal.x = x1;					\
        pd->normal.y = y1;					\
        pd->normal.z = z1;					\
        pd->flags = flag2;					\
    }								\
    else							\
    {								\
        glcltNormal3f_NotInBegin(pa, x1, y1, z1);		\
    }								\
								\
}

void FASTCALL glcltNormal3f_NotInBegin(POLYARRAY *pa, GLfloat nx, GLfloat ny, GLfloat nz)
{
    POLYDATA  *pd;
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;

    pMsgBatchInfo = (GLMSGBATCHINFO *) pa->pMsgBatchInfo;

    // If the last command is DrawPolyArray, add it to the command.
    // This allows us to chain primitives separated by the attribute.
    if (pMsgBatchInfo->NextOffset == pa->nextMsgOffset)
    {
	pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
	    ((BYTE *) pMsgBatchInfo + pMsgBatchInfo->NextOffset -
	     GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
        pa = (POLYARRAY *) pMsgDrawPolyArray->paLast;

	pd = pa->pdNextVertex;
	pa->pdCurNormal = pd;
	pd->flags |= POLYDATA_NORMAL_VALID;
	pd->normal.x = nx;
	pd->normal.y = ny;
	pd->normal.z = nz;
    }
    else
    {
	GLCLIENT_BEGIN( Normal3fv, NORMAL3FV )
	    pMsg->v[ 0] = nx;
	    pMsg->v[ 1] = ny;
	    pMsg->v[ 2] = nz;
	GLCLIENT_END
    }
}

#define PA_EDGEFLAG(edgeflag)						    \
									    \
    POLYARRAY *pa;							    \
    POLYDATA  *pd;							    \
									    \
    pa = GLTEB_CLTPOLYARRAY();						    \
									    \
    if (pa->flags & POLYARRAY_IN_BEGIN)					    \
    {									    \
	pd = pa->pdNextVertex;						    \
	pa->pdCurEdgeFlag = pd;						    \
	if (edgeflag)							    \
	    pd->flags |= POLYDATA_EDGEFLAG_VALID|POLYDATA_EDGEFLAG_BOUNDARY;\
	else								    \
	{								    \
	    /* must clear POLYDATA_EDGEFLAG_BOUNDARY flag here since    */  \
	    /* there may have been a previous edge flag for this same   */  \
	    /* vertex!                                                  */  \
	    pd->flags &= ~POLYDATA_EDGEFLAG_BOUNDARY;			    \
	    pd->flags |= POLYDATA_EDGEFLAG_VALID;			    \
	}								    \
    }									    \
    else								    \
    {									    \
	glcltEdgeFlag_NotInBegin(edgeflag);				    \
    }

void FASTCALL glcltEdgeFlag_NotInBegin(GLboolean flag)
{
    GLCLIENT_BEGIN( EdgeFlag, EDGEFLAG )
	pMsg->flag  = flag;
    GLCLIENT_END
}

void APIENTRY
glcltColor3b_InRGBA ( IN GLbyte red, IN GLbyte green, IN GLbyte blue )
{
    PA_COLOR_IN_RGB1(__GL_B_TO_FLOAT(red), __GL_B_TO_FLOAT(green),
	             __GL_B_TO_FLOAT(blue));
}

void APIENTRY
glcltColor3bv_InRGBA ( IN const GLbyte v[3] )
{
    PA_COLOR_IN_RGB1(__GL_B_TO_FLOAT(v[0]), __GL_B_TO_FLOAT(v[1]),
	             __GL_B_TO_FLOAT(v[2]));
}

void APIENTRY
glcltColor3d_InRGBA ( IN GLdouble red, IN GLdouble green, IN GLdouble blue )
{
    PA_COLOR_IN_RGB1((GLfloat) red, (GLfloat) green,
		     (GLfloat) blue);
}

void APIENTRY
glcltColor3dv_InRGBA ( IN const GLdouble v[3] )
{
    PA_COLOR_IN_RGB1((GLfloat) v[0], (GLfloat) v[1],
		     (GLfloat) v[2]);
}

#ifndef __GL_ASM_GLCLTCOLOR3F_INRGBA
void APIENTRY
glcltColor3f_InRGBA ( IN GLfloat red, IN GLfloat green, IN GLfloat blue )
{
    PA_COLOR_IN_RGB2(red, green, blue);
}
#endif // __GL_ASM_GLCLTCOLOR3F_INRGBA

#ifndef __GL_ASM_GLCLTCOLOR3FV_INRGBA
void APIENTRY
glcltColor3fv_InRGBA ( IN const GLfloat v[3] )
{
    GLfloat red, green, blue;

    red = (GLfloat) v[0];
    green = (GLfloat) v[1];
    blue = (GLfloat) v[2];

    PA_COLOR_IN_RGB2(red, green, blue);
}
#endif // __GL_ASM_GLCLTCOLOR3FV_INRGBA

void APIENTRY
glcltColor3i_InRGBA ( IN GLint red, IN GLint green, IN GLint blue )
{
    PA_COLOR_IN_RGB1(__GL_I_TO_FLOAT(red), __GL_I_TO_FLOAT(green),
	             __GL_I_TO_FLOAT(blue));
}

void APIENTRY
glcltColor3iv_InRGBA ( IN const GLint v[3] )
{
    PA_COLOR_IN_RGB1(__GL_I_TO_FLOAT(v[0]), __GL_I_TO_FLOAT(v[1]),
	             __GL_I_TO_FLOAT(v[2]));
}

void APIENTRY
glcltColor3s_InRGBA ( IN GLshort red, IN GLshort green, IN GLshort blue )
{
    PA_COLOR_IN_RGB1(__GL_S_TO_FLOAT(red), __GL_S_TO_FLOAT(green),
	             __GL_S_TO_FLOAT(blue));
}

void APIENTRY
glcltColor3sv_InRGBA ( IN const GLshort v[3] )
{
    PA_COLOR_IN_RGB1(__GL_S_TO_FLOAT(v[0]), __GL_S_TO_FLOAT(v[1]),
	             __GL_S_TO_FLOAT(v[2]));
}

void APIENTRY
glcltColor3ub_InRGBA ( IN GLubyte red, IN GLubyte green, IN GLubyte blue )
{
    PA_COLOR_IN_RGBA_NO_CLAMP1(__GL_UB_TO_FLOAT(red), __GL_UB_TO_FLOAT(green),
	             __GL_UB_TO_FLOAT(blue));
}

void APIENTRY
glcltColor3ubv_InRGBA ( IN const GLubyte v[3] )
{
    PA_COLOR_IN_RGBA_NO_CLAMP1(__GL_UB_TO_FLOAT(v[0]), __GL_UB_TO_FLOAT(v[1]),
	             __GL_UB_TO_FLOAT(v[2]));
}

void APIENTRY
glcltColor3ui_InRGBA ( IN GLuint red, IN GLuint green, IN GLuint blue )
{
    PA_COLOR_IN_RGB1(__GL_UI_TO_FLOAT(red), __GL_UI_TO_FLOAT(green),
	             __GL_UI_TO_FLOAT(blue));
}

void APIENTRY
glcltColor3uiv_InRGBA ( IN const GLuint v[3] )
{
    PA_COLOR_IN_RGB1(__GL_UI_TO_FLOAT(v[0]), __GL_UI_TO_FLOAT(v[1]),
	             __GL_UI_TO_FLOAT(v[2]));
}

void APIENTRY
glcltColor3us_InRGBA ( IN GLushort red, IN GLushort green, IN GLushort blue )
{
    PA_COLOR_IN_RGBA_NO_CLAMP1(__GL_US_TO_FLOAT(red), __GL_US_TO_FLOAT(green),
	             __GL_US_TO_FLOAT(blue));
}

void APIENTRY
glcltColor3usv_InRGBA ( IN const GLushort v[3] )
{
    PA_COLOR_IN_RGBA_NO_CLAMP1(__GL_US_TO_FLOAT(v[0]), __GL_US_TO_FLOAT(v[1]),
	             __GL_US_TO_FLOAT(v[2]));
}

void APIENTRY
glcltColor4b_InRGBA ( IN GLbyte red, IN GLbyte green, IN GLbyte blue, IN GLbyte alpha )
{
    PA_COLOR_IN_RGBA(__GL_B_TO_FLOAT(red), __GL_B_TO_FLOAT(green),
	             __GL_B_TO_FLOAT(blue), __GL_B_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4bv_InRGBA ( IN const GLbyte v[4] )
{
    PA_COLOR_IN_RGBA(__GL_B_TO_FLOAT(v[0]), __GL_B_TO_FLOAT(v[1]),
	             __GL_B_TO_FLOAT(v[2]), __GL_B_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4d_InRGBA ( IN GLdouble red, IN GLdouble green, IN GLdouble blue, IN GLdouble alpha )
{
    PA_COLOR_IN_RGBA((GLfloat) red, (GLfloat) green,
		     (GLfloat) blue, (GLfloat) alpha);
}

void APIENTRY
glcltColor4dv_InRGBA ( IN const GLdouble v[4] )
{
    PA_COLOR_IN_RGBA((GLfloat) v[0], (GLfloat) v[1],
		     (GLfloat) v[2], (GLfloat) v[3]);
}

#ifndef __GL_ASM_GLCLTCOLOR4F_INRGBA
void APIENTRY
glcltColor4f_InRGBA ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    PA_COLOR_IN_RGBA(red, green, blue, alpha);
}
#endif // __GL_ASM_GLCLTCOLOR4F_INRGBA

#ifndef __GL_ASM_GLCLTCOLOR4FV_INRGBA
void APIENTRY
glcltColor4fv_InRGBA ( IN const GLfloat v[4] )
{
    PA_COLOR_IN_RGBA(v[0], v[1], v[2], v[3]);
}
#endif // __GL_ASM_GLCLTCOLOR4FV_INRGBA

void APIENTRY
glcltColor4i_InRGBA ( IN GLint red, IN GLint green, IN GLint blue, IN GLint alpha )
{
    PA_COLOR_IN_RGBA(__GL_I_TO_FLOAT(red), __GL_I_TO_FLOAT(green),
	             __GL_I_TO_FLOAT(blue), __GL_I_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4iv_InRGBA ( IN const GLint v[4] )
{
    PA_COLOR_IN_RGBA(__GL_I_TO_FLOAT(v[0]), __GL_I_TO_FLOAT(v[1]),
	             __GL_I_TO_FLOAT(v[2]), __GL_I_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4s_InRGBA ( IN GLshort red, IN GLshort green, IN GLshort blue, IN GLshort alpha )
{
    PA_COLOR_IN_RGBA(__GL_S_TO_FLOAT(red), __GL_S_TO_FLOAT(green),
	             __GL_S_TO_FLOAT(blue), __GL_S_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4sv_InRGBA ( IN const GLshort v[4] )
{
    PA_COLOR_IN_RGBA(__GL_S_TO_FLOAT(v[0]), __GL_S_TO_FLOAT(v[1]),
	             __GL_S_TO_FLOAT(v[2]), __GL_S_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4ub_InRGBA ( IN GLubyte red, IN GLubyte green, IN GLubyte blue, IN GLubyte alpha )
{
    PA_COLOR_IN_RGBA_NO_CLAMP(__GL_UB_TO_FLOAT(red), __GL_UB_TO_FLOAT(green),
	             __GL_UB_TO_FLOAT(blue), __GL_UB_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4ubv_InRGBA ( IN const GLubyte v[4] )
{
    PA_COLOR_IN_RGBA_NO_CLAMP(__GL_UB_TO_FLOAT(v[0]), __GL_UB_TO_FLOAT(v[1]),
	             __GL_UB_TO_FLOAT(v[2]), __GL_UB_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4ui_InRGBA ( IN GLuint red, IN GLuint green, IN GLuint blue, IN GLuint alpha )
{
    PA_COLOR_IN_RGBA(__GL_UI_TO_FLOAT(red), __GL_UI_TO_FLOAT(green),
	             __GL_UI_TO_FLOAT(blue), __GL_UI_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4uiv_InRGBA ( IN const GLuint v[4] )
{
    PA_COLOR_IN_RGBA(__GL_UI_TO_FLOAT(v[0]), __GL_UI_TO_FLOAT(v[1]),
	             __GL_UI_TO_FLOAT(v[2]), __GL_UI_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4us_InRGBA ( IN GLushort red, IN GLushort green, IN GLushort blue, IN GLushort alpha )
{
    PA_COLOR_IN_RGBA_NO_CLAMP(__GL_US_TO_FLOAT(red), __GL_US_TO_FLOAT(green),
	             __GL_US_TO_FLOAT(blue), __GL_US_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4usv_InRGBA ( IN const GLushort v[4] )
{
    PA_COLOR_IN_RGBA_NO_CLAMP(__GL_US_TO_FLOAT(v[0]), __GL_US_TO_FLOAT(v[1]),
	             __GL_US_TO_FLOAT(v[2]), __GL_US_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor3b_InCI ( IN GLbyte red, IN GLbyte green, IN GLbyte blue )
{
    PA_COLOR_IN_CI(__GL_B_TO_FLOAT(red), __GL_B_TO_FLOAT(green),
	             __GL_B_TO_FLOAT(blue), __glOne);
}

void APIENTRY
glcltColor3bv_InCI ( IN const GLbyte v[3] )
{
    PA_COLOR_IN_CI(__GL_B_TO_FLOAT(v[0]), __GL_B_TO_FLOAT(v[1]),
	             __GL_B_TO_FLOAT(v[2]), __glOne);
}

void APIENTRY
glcltColor3d_InCI ( IN GLdouble red, IN GLdouble green, IN GLdouble blue )
{
    PA_COLOR_IN_CI((GLfloat) red, (GLfloat) green,
		     (GLfloat) blue, __glOne);
}

void APIENTRY
glcltColor3dv_InCI ( IN const GLdouble v[3] )
{
    PA_COLOR_IN_CI((GLfloat) v[0], (GLfloat) v[1],
		     (GLfloat) v[2], __glOne);
}

void APIENTRY
glcltColor3f_InCI ( IN GLfloat red, IN GLfloat green, IN GLfloat blue )
{
    PA_COLOR_IN_CI(red, green, blue, __glOne);
}

void APIENTRY
glcltColor3fv_InCI ( IN const GLfloat v[3] )
{
    PA_COLOR_IN_CI(v[0], v[1], v[2], __glOne);
}

void APIENTRY
glcltColor3i_InCI ( IN GLint red, IN GLint green, IN GLint blue )
{
    PA_COLOR_IN_CI(__GL_I_TO_FLOAT(red), __GL_I_TO_FLOAT(green),
	             __GL_I_TO_FLOAT(blue), __glOne);
}

void APIENTRY
glcltColor3iv_InCI ( IN const GLint v[3] )
{
    PA_COLOR_IN_CI(__GL_I_TO_FLOAT(v[0]), __GL_I_TO_FLOAT(v[1]),
	             __GL_I_TO_FLOAT(v[2]), __glOne);
}

void APIENTRY
glcltColor3s_InCI ( IN GLshort red, IN GLshort green, IN GLshort blue )
{
    PA_COLOR_IN_CI(__GL_S_TO_FLOAT(red), __GL_S_TO_FLOAT(green),
	             __GL_S_TO_FLOAT(blue), __glOne);
}

void APIENTRY
glcltColor3sv_InCI ( IN const GLshort v[3] )
{
    PA_COLOR_IN_CI(__GL_S_TO_FLOAT(v[0]), __GL_S_TO_FLOAT(v[1]),
	             __GL_S_TO_FLOAT(v[2]), __glOne);
}

void APIENTRY
glcltColor3ub_InCI ( IN GLubyte red, IN GLubyte green, IN GLubyte blue )
{
    PA_COLOR_IN_CI(__GL_UB_TO_FLOAT(red), __GL_UB_TO_FLOAT(green),
	             __GL_UB_TO_FLOAT(blue), __glOne);
}

void APIENTRY
glcltColor3ubv_InCI ( IN const GLubyte v[3] )
{
    PA_COLOR_IN_CI(__GL_UB_TO_FLOAT(v[0]), __GL_UB_TO_FLOAT(v[1]),
	             __GL_UB_TO_FLOAT(v[2]), __glOne);
}

void APIENTRY
glcltColor3ui_InCI ( IN GLuint red, IN GLuint green, IN GLuint blue )
{
    PA_COLOR_IN_CI(__GL_UI_TO_FLOAT(red), __GL_UI_TO_FLOAT(green),
	             __GL_UI_TO_FLOAT(blue), __glOne);
}

void APIENTRY
glcltColor3uiv_InCI ( IN const GLuint v[3] )
{
    PA_COLOR_IN_CI(__GL_UI_TO_FLOAT(v[0]), __GL_UI_TO_FLOAT(v[1]),
	             __GL_UI_TO_FLOAT(v[2]), __glOne);
}

void APIENTRY
glcltColor3us_InCI ( IN GLushort red, IN GLushort green, IN GLushort blue )
{
    PA_COLOR_IN_CI(__GL_US_TO_FLOAT(red), __GL_US_TO_FLOAT(green),
	             __GL_US_TO_FLOAT(blue), __glOne);
}

void APIENTRY
glcltColor3usv_InCI ( IN const GLushort v[3] )
{
    PA_COLOR_IN_CI(__GL_US_TO_FLOAT(v[0]), __GL_US_TO_FLOAT(v[1]),
	             __GL_US_TO_FLOAT(v[2]), __glOne);
}

void APIENTRY
glcltColor4b_InCI ( IN GLbyte red, IN GLbyte green, IN GLbyte blue, IN GLbyte alpha )
{
    PA_COLOR_IN_CI(__GL_B_TO_FLOAT(red), __GL_B_TO_FLOAT(green),
	             __GL_B_TO_FLOAT(blue), __GL_B_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4bv_InCI ( IN const GLbyte v[4] )
{
    PA_COLOR_IN_CI(__GL_B_TO_FLOAT(v[0]), __GL_B_TO_FLOAT(v[1]),
	             __GL_B_TO_FLOAT(v[2]), __GL_B_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4d_InCI ( IN GLdouble red, IN GLdouble green, IN GLdouble blue, IN GLdouble alpha )
{
    PA_COLOR_IN_CI((GLfloat) red, (GLfloat) green,
		     (GLfloat) blue, (GLfloat) alpha);
}

void APIENTRY
glcltColor4dv_InCI ( IN const GLdouble v[4] )
{
    PA_COLOR_IN_CI((GLfloat) v[0], (GLfloat) v[1],
		     (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltColor4f_InCI ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    PA_COLOR_IN_CI(red, green, blue, alpha);
}

void APIENTRY
glcltColor4fv_InCI ( IN const GLfloat v[4] )
{
    PA_COLOR_IN_CI(v[0], v[1], v[2], v[3]);
}

void APIENTRY
glcltColor4i_InCI ( IN GLint red, IN GLint green, IN GLint blue, IN GLint alpha )
{
    PA_COLOR_IN_CI(__GL_I_TO_FLOAT(red), __GL_I_TO_FLOAT(green),
	             __GL_I_TO_FLOAT(blue), __GL_I_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4iv_InCI ( IN const GLint v[4] )
{
    PA_COLOR_IN_CI(__GL_I_TO_FLOAT(v[0]), __GL_I_TO_FLOAT(v[1]),
	             __GL_I_TO_FLOAT(v[2]), __GL_I_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4s_InCI ( IN GLshort red, IN GLshort green, IN GLshort blue, IN GLshort alpha )
{
    PA_COLOR_IN_CI(__GL_S_TO_FLOAT(red), __GL_S_TO_FLOAT(green),
	             __GL_S_TO_FLOAT(blue), __GL_S_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4sv_InCI ( IN const GLshort v[4] )
{
    PA_COLOR_IN_CI(__GL_S_TO_FLOAT(v[0]), __GL_S_TO_FLOAT(v[1]),
	             __GL_S_TO_FLOAT(v[2]), __GL_S_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4ub_InCI ( IN GLubyte red, IN GLubyte green, IN GLubyte blue, IN GLubyte alpha )
{
    PA_COLOR_IN_CI(__GL_UB_TO_FLOAT(red), __GL_UB_TO_FLOAT(green),
	             __GL_UB_TO_FLOAT(blue), __GL_UB_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4ubv_InCI ( IN const GLubyte v[4] )
{
    PA_COLOR_IN_CI(__GL_UB_TO_FLOAT(v[0]), __GL_UB_TO_FLOAT(v[1]),
	             __GL_UB_TO_FLOAT(v[2]), __GL_UB_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4ui_InCI ( IN GLuint red, IN GLuint green, IN GLuint blue, IN GLuint alpha )
{
    PA_COLOR_IN_CI(__GL_UI_TO_FLOAT(red), __GL_UI_TO_FLOAT(green),
	             __GL_UI_TO_FLOAT(blue), __GL_UI_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4uiv_InCI ( IN const GLuint v[4] )
{
    PA_COLOR_IN_CI(__GL_UI_TO_FLOAT(v[0]), __GL_UI_TO_FLOAT(v[1]),
	             __GL_UI_TO_FLOAT(v[2]), __GL_UI_TO_FLOAT(v[3]));
}

void APIENTRY
glcltColor4us_InCI ( IN GLushort red, IN GLushort green, IN GLushort blue, IN GLushort alpha )
{
    PA_COLOR_IN_CI(__GL_US_TO_FLOAT(red), __GL_US_TO_FLOAT(green),
	             __GL_US_TO_FLOAT(blue), __GL_US_TO_FLOAT(alpha));
}

void APIENTRY
glcltColor4usv_InCI ( IN const GLushort v[4] )
{
    PA_COLOR_IN_CI(__GL_US_TO_FLOAT(v[0]), __GL_US_TO_FLOAT(v[1]),
	             __GL_US_TO_FLOAT(v[2]), __GL_US_TO_FLOAT(v[3]));
}

// Allocate a __GLmatChange structure.
//
// The POLYMATERIAL structure contains pointers to __GLmatChange arrays.
// These __GLmatChange structures are used to record material changes to
// vertices in the vertex buffer.
//
// To reduce memory requirement, the POLYMATERIAL structure keeps an array
// of pointers to __GLmatChange arrays.  Each __GLmatChange array is
// allocated as needed.
//
// An iMat index is used to keep track of the next free __GLmatChange
// entry.  When the poly array buffer is flushed in glsbAttention, iMat
// is reset to 0.
//
// The POLYMATERIAL structure and its __GLmatChange arrays are part of
// a thread local storage and are freed when the thread exits.

__GLmatChange * FASTCALL PAMatAlloc()
{
    POLYMATERIAL *pm;
    GLuint iArray, iMat;
#if DBG
    __GL_SETUP();
#endif

    pm = GLTEB_CLTPOLYMATERIAL();

// Allocate a POLYMATERIAL structure for this thread if one does not exist.

    if (!pm)
    {
        GLuint nv, aMatSize;
        __GL_SETUP();

        nv       = gc->vertex.pdBufSize;
        aMatSize = nv * 2 / POLYMATERIAL_ARRAY_SIZE + 1;

	if (!(pm = (POLYMATERIAL *) ALLOCZ(
		// Base size
		sizeof(POLYMATERIAL) - sizeof(__GLmatChange *) +
		// array of pointers to __GLmatChange arrays
		aMatSize * sizeof(__GLmatChange *) +
		// the PDMATERIAL array
		nv * sizeof(PDMATERIAL))))
	{
	    GLSETERROR(GL_OUT_OF_MEMORY);
	    return NULL;
	}

        pm->aMatSize = aMatSize;
        // Initialize pointer to the PDMATERIAL array
        pm->pdMaterial0 = (PDMATERIAL *) &pm->aMat[aMatSize];

        GLTEB_SET_CLTPOLYMATERIAL(pm);
    }

// Sanity check that pdBufSize has not changed.

    ASSERTOPENGL
    (
	pm->aMatSize == gc->vertex.pdBufSize * 2 / POLYMATERIAL_ARRAY_SIZE + 1,
	"vertex buffer size has changed!\n"
    );

// Find the material array from which to allocate the material change structure.

    iMat = pm->iMat;
    iArray = iMat / POLYMATERIAL_ARRAY_SIZE;
    iMat   = iMat % POLYMATERIAL_ARRAY_SIZE;

    ASSERTOPENGL(iArray < pm->aMatSize, "iArray exceeds range!\n");

// Allocate the material array if it has not been allocated.

    if (!(pm->aMat[iArray]))
    {
	if (!(pm->aMat[iArray] = (__GLmatChange *) ALLOC(
		sizeof(__GLmatChange) * POLYMATERIAL_ARRAY_SIZE)))
	{
	    GLSETERROR(GL_OUT_OF_MEMORY);
	    return NULL;
	}
    }

// Advance next available material pointer.

    pm->iMat++;
    ASSERTOPENGL(pm->iMat <= gc->vertex.pdBufSize * 2,
	"too many material changes!\n");

// Return the material change.

    return (&pm->aMat[iArray][iMat]);
}

// Free polymaterial for current thread.
void FASTCALL FreePolyMaterial(void)
{
    POLYMATERIAL *pm = GLTEB_CLTPOLYMATERIAL();
    GLuint i;

    if (pm)
    {
	for (i = 0; i < pm->aMatSize && pm->aMat[i]; i++)
	{
	    FREE(pm->aMat[i]);
	}
	FREE(pm);

	GLTEB_SET_CLTPOLYMATERIAL(NULL);
    }
}

#if !((POLYARRAY_MATERIAL_FRONT == POLYDATA_MATERIAL_FRONT)      \
   && (POLYARRAY_MATERIAL_BACK  == POLYDATA_MATERIAL_BACK))
#error "bad material mask\n"
#endif

void APIENTRY
glcltMaterialfv ( IN GLenum face, IN GLenum pname, IN const GLfloat params[] )
{
    POLYARRAY *pa;
    POLYDATA  *pd;
    GLuint    i, pdFlags, dirtyBits, matMask;
    POLYMATERIAL *pm;

    pa = GLTEB_CLTPOLYARRAY();

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        switch (pname)
        {
          case GL_SHININESS:
            if (params[0] < (GLfloat) 0 || params[0] > (GLfloat) 128)
            {
                GLSETERROR(GL_INVALID_VALUE);
                return;
            }
            dirtyBits = __GL_MATERIAL_SHININESS;
            break;
          case GL_EMISSION:
            dirtyBits = __GL_MATERIAL_EMISSIVE;
            break;
          case GL_AMBIENT:
            dirtyBits = __GL_MATERIAL_AMBIENT;
            break;
          case GL_DIFFUSE:
            dirtyBits = __GL_MATERIAL_DIFFUSE;
            break;
          case GL_SPECULAR:
            dirtyBits = __GL_MATERIAL_SPECULAR;
            break;
          case GL_AMBIENT_AND_DIFFUSE:
            dirtyBits = __GL_MATERIAL_AMBIENT | __GL_MATERIAL_DIFFUSE;
            break;
          case GL_COLOR_INDEXES:
            dirtyBits = __GL_MATERIAL_COLORINDEXES;
            break;
          default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
        }

        switch (face)
        {
          case GL_FRONT:
            pdFlags = POLYDATA_MATERIAL_FRONT;
            break;
          case GL_BACK:
            pdFlags = POLYDATA_MATERIAL_BACK;
            break;
          case GL_FRONT_AND_BACK:
            pdFlags = POLYDATA_MATERIAL_FRONT | POLYDATA_MATERIAL_BACK;
            break;
          default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
        }

// Update pa flags POLYARRAY_MATERIAL_FRONT and POLYARRAY_MATERIAL_BACK.

        pa->flags |= pdFlags;

// Do front and back material for this vertex
// Overwrite the previous material changes for this vertex if they exist since
// only the last material changes matter.

        pd = pa->pdNextVertex;

        for (i = 0, matMask = POLYDATA_MATERIAL_FRONT;
             i < 2;
             i++,   matMask = POLYDATA_MATERIAL_BACK)
        {
            __GLmatChange *pdMat;

            if (!(pdFlags & matMask))
                continue;

            // allocate __GLmatChange structure if this vertex hasn't got one
            if (!(pd->flags & matMask))
            {
                if (!(pdMat = PAMatAlloc()))
                    return;

                // Get POLYMATERIAL pointer after PAMatAlloc!
                pm = GLTEB_CLTPOLYMATERIAL();
                if (matMask == POLYDATA_MATERIAL_FRONT)
                    pm->pdMaterial0[pd - pa->pdBuffer0].front = pdMat;
                else
                    pm->pdMaterial0[pd - pa->pdBuffer0].back  = pdMat;

                pdMat->dirtyBits = dirtyBits;
            }
            else
            {
                pm = GLTEB_CLTPOLYMATERIAL();
                if (matMask == POLYDATA_MATERIAL_FRONT)
                    pdMat = pm->pdMaterial0[pd - pa->pdBuffer0].front;
                else
                    pdMat = pm->pdMaterial0[pd - pa->pdBuffer0].back;

                pdMat->dirtyBits |= dirtyBits;
            }

            if (dirtyBits & __GL_MATERIAL_SHININESS)
            {
                pdMat->shininess = params[0];
            }
            else if (dirtyBits & __GL_MATERIAL_COLORINDEXES)
            {
                pdMat->cmapa = params[0];
                pdMat->cmapd = params[1];
                pdMat->cmaps = params[2];
            }
            else if (dirtyBits & __GL_MATERIAL_EMISSIVE)
            {
                pdMat->emissive.r = params[0];
                pdMat->emissive.g = params[1];
                pdMat->emissive.b = params[2];
                pdMat->emissive.a = params[3];
            }
            else if (dirtyBits & __GL_MATERIAL_SPECULAR)
            {
                pdMat->specular.r = params[0];
                pdMat->specular.g = params[1];
                pdMat->specular.b = params[2];
                pdMat->specular.a = params[3];
            }
            else
            {
                // ambient and/or diffuse
                if (dirtyBits & __GL_MATERIAL_AMBIENT)
                {
                    pdMat->ambient.r = params[0];
                    pdMat->ambient.g = params[1];
                    pdMat->ambient.b = params[2];
                    pdMat->ambient.a = params[3];
                }
                if (dirtyBits & __GL_MATERIAL_DIFFUSE)
                {
                    pdMat->diffuse.r = params[0];
                    pdMat->diffuse.g = params[1];
                    pdMat->diffuse.b = params[2];
                    pdMat->diffuse.a = params[3];
                }
            }
        }
        
        // Finally, update pd flags

        pd->flags |= pdFlags;
    }
    else
    {
        int cArgs;

        switch (pname)
        {
          case GL_SHININESS:
            if (params[0] < (GLfloat) 0 || params[0] > (GLfloat) 128)
            {
                GLSETERROR(GL_INVALID_VALUE);
                return;
            }
            cArgs = 1;
            break;
          case GL_EMISSION:
          case GL_AMBIENT:
          case GL_DIFFUSE:
          case GL_SPECULAR:
          case GL_AMBIENT_AND_DIFFUSE:
            cArgs = 4;
            break;
          case GL_COLOR_INDEXES:
            cArgs = 3;
            break;
          default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
        }

        switch (face)
        {
          case GL_FRONT:
          case GL_BACK:
          case GL_FRONT_AND_BACK:
            break;
          default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
        }
        
        GLCLIENT_BEGIN( Materialfv, MATERIALFV )
          pMsg->face      = face;
          pMsg->pname     = pname;
          while (--cArgs >= 0)
              pMsg->params[cArgs] = params[cArgs];
        GLCLIENT_END
    }
}

void APIENTRY
glcltMaterialf ( IN GLenum face, IN GLenum pname, IN GLfloat param )
{
    if (pname != GL_SHININESS)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltMaterialfv(face, pname, &param);
}

void APIENTRY
glcltMateriali ( IN GLenum face, IN GLenum pname, IN GLint param )
{
    GLfloat fParams[1];

    if (pname != GL_SHININESS)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    fParams[0] = (GLfloat) param;
    glcltMaterialfv(face, pname, fParams);
}

void APIENTRY
glcltMaterialiv ( IN GLenum face, IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_EMISSION:
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_SPECULAR:
      case GL_AMBIENT_AND_DIFFUSE:
	fParams[0] = __GL_I_TO_FLOAT(params[0]);
	fParams[1] = __GL_I_TO_FLOAT(params[1]);
	fParams[2] = __GL_I_TO_FLOAT(params[2]);
	fParams[3] = __GL_I_TO_FLOAT(params[3]);
        break;
      case GL_COLOR_INDEXES:
	fParams[2] = (GLfloat) params[2];
	fParams[1] = (GLfloat) params[1];
      case GL_SHININESS:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    glcltMaterialfv(face, pname, fParams);
}

void APIENTRY
glcltEdgeFlag ( IN GLboolean flag )
{
    PA_EDGEFLAG(flag);
}

void APIENTRY
glcltEdgeFlagv ( IN const GLboolean flag[1] )
{
    PA_EDGEFLAG(flag[0]);
}

void APIENTRY
glcltIndexd_InCI ( IN GLdouble c )
{
    PA_INDEX_IN_CI((GLfloat) c);
}

void APIENTRY
glcltIndexdv_InCI ( IN const GLdouble c[1] )
{
    PA_INDEX_IN_CI((GLfloat) c[0]);
}

void APIENTRY
glcltIndexf_InCI ( IN GLfloat c )
{
    PA_INDEX_IN_CI((GLfloat) c);
}

void APIENTRY
glcltIndexfv_InCI ( IN const GLfloat c[1] )
{
    PA_INDEX_IN_CI((GLfloat) c[0]);
}

void APIENTRY
glcltIndexi_InCI ( IN GLint c )
{
    PA_INDEX_IN_CI((GLfloat) c);
}

void APIENTRY
glcltIndexiv_InCI ( IN const GLint c[1] )
{
    PA_INDEX_IN_CI((GLfloat) c[0]);
}

void APIENTRY
glcltIndexs_InCI ( IN GLshort c )
{
    PA_INDEX_IN_CI((GLfloat) c);
}

void APIENTRY
glcltIndexsv_InCI ( IN const GLshort c[1] )
{
    PA_INDEX_IN_CI((GLfloat) c[0]);
}

void APIENTRY
glcltIndexub_InCI ( IN GLubyte c )
{
    PA_INDEX_IN_CI((GLfloat) c);
}

void APIENTRY
glcltIndexubv_InCI ( IN const GLubyte c[1] )
{
    PA_INDEX_IN_CI((GLfloat) c[0]);
}

void APIENTRY
glcltIndexd_InRGBA ( IN GLdouble c )
{
    PA_INDEX_IN_RGBA((GLfloat) c);
}

void APIENTRY
glcltIndexdv_InRGBA ( IN const GLdouble c[1] )
{
    PA_INDEX_IN_RGBA((GLfloat) c[0]);
}

void APIENTRY
glcltIndexf_InRGBA ( IN GLfloat c )
{
    PA_INDEX_IN_RGBA((GLfloat) c);
}

void APIENTRY
glcltIndexfv_InRGBA ( IN const GLfloat c[1] )
{
    PA_INDEX_IN_RGBA((GLfloat) c[0]);
}

void APIENTRY
glcltIndexi_InRGBA ( IN GLint c )
{
    PA_INDEX_IN_RGBA((GLfloat) c);
}

void APIENTRY
glcltIndexiv_InRGBA ( IN const GLint c[1] )
{
    PA_INDEX_IN_RGBA((GLfloat) c[0]);
}

void APIENTRY
glcltIndexs_InRGBA ( IN GLshort c )
{
    PA_INDEX_IN_RGBA((GLfloat) c);
}

void APIENTRY
glcltIndexsv_InRGBA ( IN const GLshort c[1] )
{
    PA_INDEX_IN_RGBA((GLfloat) c[0]);
}

void APIENTRY
glcltIndexub_InRGBA ( IN GLubyte c )
{
    PA_INDEX_IN_RGBA((GLfloat) c);
}

void APIENTRY
glcltIndexubv_InRGBA ( IN const GLubyte c[1] )
{
    PA_INDEX_IN_RGBA((GLfloat) c[0]);
}

/******************************************************************/
void APIENTRY
glcltNormal3b ( IN GLbyte nx, IN GLbyte ny, IN GLbyte nz )
{
    PA_NORMAL(__GL_B_TO_FLOAT(nx), __GL_B_TO_FLOAT(ny), __GL_B_TO_FLOAT(nz));
}

void APIENTRY
glcltNormal3bv ( IN const GLbyte v[3] )
{
    PA_NORMAL(__GL_B_TO_FLOAT(v[0]), __GL_B_TO_FLOAT(v[1]), __GL_B_TO_FLOAT(v[2]));
}

void APIENTRY
glcltNormal3d ( IN GLdouble nx, IN GLdouble ny, IN GLdouble nz )
{
    PA_NORMAL((GLfloat) nx, (GLfloat) ny, (GLfloat) nz);
}

void APIENTRY
glcltNormal3dv ( IN const GLdouble v[3] )
{
    PA_NORMAL((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

#ifndef __GL_ASM_GLCLTNORMAL3F
void APIENTRY
glcltNormal3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    PA_NORMAL(x, y, z);
}
#endif //__GL_ASM_GLCLTNORMAL3F

#ifndef __GL_ASM_GLCLTNORMAL3FV
void APIENTRY
glcltNormal3fv ( IN const GLfloat v[3] )
{
    GLfloat x, y, z;

    x = v[0];
    y = v[1];
    z = v[2];

    PA_NORMAL(x, y, z);
}
#endif //__GL_ASM_GLCLTNORMAL3FV

void APIENTRY
glcltNormal3i ( IN GLint nx, IN GLint ny, IN GLint nz )
{
    PA_NORMAL(__GL_I_TO_FLOAT(nx), __GL_I_TO_FLOAT(ny), __GL_I_TO_FLOAT(nz));
}

void APIENTRY
glcltNormal3iv ( IN const GLint v[3] )
{
    PA_NORMAL(__GL_I_TO_FLOAT(v[0]), __GL_I_TO_FLOAT(v[1]), __GL_I_TO_FLOAT(v[2]));
}

void APIENTRY
glcltNormal3s ( IN GLshort nx, IN GLshort ny, IN GLshort nz )
{
    PA_NORMAL(__GL_S_TO_FLOAT(nx), __GL_S_TO_FLOAT(ny), __GL_S_TO_FLOAT(nz));
}

void APIENTRY
glcltNormal3sv ( IN const GLshort v[3] )
{
    PA_NORMAL(__GL_S_TO_FLOAT(v[0]), __GL_S_TO_FLOAT(v[1]), __GL_S_TO_FLOAT(v[2]));
}

void APIENTRY
glcltRasterPos2d ( IN GLdouble x, IN GLdouble y )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) 0.0, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos2dv ( IN const GLdouble v[2] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) 0.0, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos2f ( IN GLfloat x, IN GLfloat y )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) 0.0, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos2fv ( IN const GLfloat v[2] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) 0.0, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos2i ( IN GLint x, IN GLint y )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) 0.0, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos2iv ( IN const GLint v[2] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) 0.0, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos2s ( IN GLshort x, IN GLshort y )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) 0.0, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos2sv ( IN const GLshort v[2] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) 0.0, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos3d ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos3dv ( IN const GLdouble v[3] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos3fv ( IN const GLfloat v[3] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos3i ( IN GLint x, IN GLint y, IN GLint z )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos3iv ( IN const GLint v[3] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos3s ( IN GLshort x, IN GLshort y, IN GLshort z )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos3sv ( IN const GLshort v[3] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) 1.0);
}

void APIENTRY
glcltRasterPos4d ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
glcltRasterPos4dv ( IN const GLdouble v[4] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltRasterPos4f ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w )
{
    GLCLIENT_BEGIN( RasterPos4fv, RASTERPOS4FV )
        pMsg->v[0] = x;
        pMsg->v[1] = y;
        pMsg->v[2] = z;
        pMsg->v[3] = w;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltRasterPos4fv ( IN const GLfloat v[4] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltRasterPos4i ( IN GLint x, IN GLint y, IN GLint z, IN GLint w )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
glcltRasterPos4iv ( IN const GLint v[4] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltRasterPos4s ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w )
{
    glcltRasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
glcltRasterPos4sv ( IN const GLshort v[4] )
{
    glcltRasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltRectd ( IN GLdouble x1, IN GLdouble y1, IN GLdouble x2, IN GLdouble y2 )
{
    glcltRectf((GLfloat) x1, (GLfloat) y1, (GLfloat) x2, (GLfloat) y2);
}

void APIENTRY
glcltRectdv ( IN const GLdouble v1[2], IN const GLdouble v2[2] )
{
    glcltRectf((GLfloat) v1[0], (GLfloat) v1[1], (GLfloat) v2[0], (GLfloat) v2[1]);
}

void APIENTRY
glcltRectf ( IN GLfloat x1, IN GLfloat y1, IN GLfloat x2, IN GLfloat y2 )
{
    POLYARRAY *pa;

// Not allowed in begin/end.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

// Call Begin/End to do polyarray correctly.  Note that by calling these
// functions, we allow poly array to be batched correctly.
// Note also that we use quad strip instead of quad to force edge flag to be on.

    //!!! Conformance fails if we use QUAD_STRIP!
    //glcltBegin(GL_QUAD_STRIP);
    glcltBegin(GL_QUADS);
    pa->flags |= POLYARRAY_SAME_POLYDATA_TYPE;
    glcltVertex2f(x1, y1);
    glcltVertex2f(x2, y1);
    glcltVertex2f(x2, y2);
    glcltVertex2f(x1, y2);
    glcltEnd();
}

void APIENTRY
glcltRectfv ( IN const GLfloat v1[2], IN const GLfloat v2[2] )
{
    glcltRectf((GLfloat) v1[0], (GLfloat) v1[1], (GLfloat) v2[0], (GLfloat) v2[1]);
}

void APIENTRY
glcltRecti ( IN GLint x1, IN GLint y1, IN GLint x2, IN GLint y2 )
{
    glcltRectf((GLfloat) x1, (GLfloat) y1, (GLfloat) x2, (GLfloat) y2);
}

void APIENTRY
glcltRectiv ( IN const GLint v1[2], IN const GLint v2[2] )
{
    glcltRectf((GLfloat) v1[0], (GLfloat) v1[1], (GLfloat) v2[0], (GLfloat) v2[1]);
}

void APIENTRY
glcltRects ( IN GLshort x1, IN GLshort y1, IN GLshort x2, IN GLshort y2 )
{
    glcltRectf((GLfloat) x1, (GLfloat) y1, (GLfloat) x2, (GLfloat) y2);
}

void APIENTRY
glcltRectsv ( IN const GLshort v1[2], IN const GLshort v2[2] )
{
    glcltRectf((GLfloat) v1[0], (GLfloat) v1[1], (GLfloat) v2[0], (GLfloat) v2[1]);
}

void APIENTRY
glcltTexCoord1d ( IN GLdouble s )
{
    PA_TEXTURE1((GLfloat) s);
}

void APIENTRY
glcltTexCoord1dv ( IN const GLdouble v[1] )
{
    PA_TEXTURE1((GLfloat) v[0]);
}

void APIENTRY
glcltTexCoord1f ( IN GLfloat s )
{
    PA_TEXTURE1((GLfloat) s);
}

void APIENTRY
glcltTexCoord1fv ( IN const GLfloat v[1] )
{
    PA_TEXTURE1((GLfloat) v[0]);
}

void APIENTRY
glcltTexCoord1i ( IN GLint s )
{
    PA_TEXTURE1((GLfloat) s);
}

void APIENTRY
glcltTexCoord1iv ( IN const GLint v[1] )
{
    PA_TEXTURE1((GLfloat) v[0]);
}

void APIENTRY
glcltTexCoord1s ( IN GLshort s )
{
    PA_TEXTURE1((GLfloat) s);
}

void APIENTRY
glcltTexCoord1sv ( IN const GLshort v[1] )
{
    PA_TEXTURE1((GLfloat) v[0]);
}

void APIENTRY
glcltTexCoord2d ( IN GLdouble s, IN GLdouble t )
{
    PA_TEXTURE2((GLfloat) s, (GLfloat) t);
}

void APIENTRY
glcltTexCoord2dv ( IN const GLdouble v[2] )
{
    PA_TEXTURE2((GLfloat) v[0], (GLfloat) v[1]);
}

#ifndef __GL_ASM_GLCLTTEXCOORD2F
void APIENTRY
glcltTexCoord2f ( IN GLfloat s, IN GLfloat t )
{
    PA_TEXTURE2((GLfloat) s, (GLfloat) t);
}
#endif //__GL_ASM_GLCLTTEXCOORD2F

#ifndef __GL_ASM_GLCLTTEXCOORD2FV
void APIENTRY
glcltTexCoord2fv ( IN const GLfloat v[2] )
{
    PA_TEXTURE2((GLfloat) v[0], (GLfloat) v[1]);
}
#endif //__GL_ASM_GLCLTTEXCOORD2FV

void APIENTRY
glcltTexCoord2i ( IN GLint s, IN GLint t )
{
    PA_TEXTURE2((GLfloat) s, (GLfloat) t);
}

void APIENTRY
glcltTexCoord2iv ( IN const GLint v[2] )
{
    PA_TEXTURE2((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
glcltTexCoord2s ( IN GLshort s, IN GLshort t )
{
    PA_TEXTURE2((GLfloat) s, (GLfloat) t);
}

void APIENTRY
glcltTexCoord2sv ( IN const GLshort v[2] )
{
    PA_TEXTURE2((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
glcltTexCoord3d ( IN GLdouble s, IN GLdouble t, IN GLdouble r )
{
    PA_TEXTURE3((GLfloat) s, (GLfloat) t, (GLfloat) r);
}

void APIENTRY
glcltTexCoord3dv ( IN const GLdouble v[3] )
{
    PA_TEXTURE3((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

#ifndef __GL_ASM_GLCLTTEXCOORD3F
void APIENTRY
glcltTexCoord3f ( IN GLfloat s, IN GLfloat t, IN GLfloat r )
{
    PA_TEXTURE3((GLfloat) s, (GLfloat) t, (GLfloat) r);
}
#endif //__GL_ASM_GLCLTTEXCOORD3F

#ifndef __GL_ASM_GLCLTTEXCOORD3FV
void APIENTRY
glcltTexCoord3fv ( IN const GLfloat v[3] )
{
    PA_TEXTURE3((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}
#endif //__GL_ASM_GLCLTTEXCOORD3FV

void APIENTRY
glcltTexCoord3i ( IN GLint s, IN GLint t, IN GLint r )
{
    PA_TEXTURE3((GLfloat) s, (GLfloat) t, (GLfloat) r);
}

void APIENTRY
glcltTexCoord3iv ( IN const GLint v[3] )
{
    PA_TEXTURE3((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
glcltTexCoord3s ( IN GLshort s, IN GLshort t, IN GLshort r )
{
    PA_TEXTURE3((GLfloat) s, (GLfloat) t, (GLfloat) r);
}

void APIENTRY
glcltTexCoord3sv ( IN const GLshort v[3] )
{
    PA_TEXTURE3((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
glcltTexCoord4d ( IN GLdouble s, IN GLdouble t, IN GLdouble r, IN GLdouble q )
{
    PA_TEXTURE4((GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
}

void APIENTRY
glcltTexCoord4dv ( IN const GLdouble v[4] )
{
    PA_TEXTURE4((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltTexCoord4f ( IN GLfloat s, IN GLfloat t, IN GLfloat r, IN GLfloat q )
{
    PA_TEXTURE4((GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
}

void APIENTRY
glcltTexCoord4fv ( IN const GLfloat v[4] )
{
    PA_TEXTURE4((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltTexCoord4i ( IN GLint s, IN GLint t, IN GLint r, IN GLint q )
{
    PA_TEXTURE4((GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
}

void APIENTRY
glcltTexCoord4iv ( IN const GLint v[4] )
{
    PA_TEXTURE4((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltTexCoord4s ( IN GLshort s, IN GLshort t, IN GLshort r, IN GLshort q )
{
    PA_TEXTURE4((GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
}

void APIENTRY
glcltTexCoord4sv ( IN const GLshort v[4] )
{
    PA_TEXTURE4((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

#ifdef GL_WIN_multiple_textures
void APIENTRY glcltMultiTexCoord1dWIN
    (GLbitfield mask, GLdouble s)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord1dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord1fWIN
    (GLbitfield mask, GLfloat s)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord1fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord1iWIN
    (GLbitfield mask, GLint s)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord1ivWIN
    (GLbitfield mask, const GLint *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord1sWIN
    (GLbitfield mask, GLshort s)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord1svWIN
    (GLbitfield mask, const GLshort *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord2dWIN
    (GLbitfield mask, GLdouble s, GLdouble t)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord2dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord2fWIN
    (GLbitfield mask, GLfloat s, GLfloat t)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord2fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord2iWIN
    (GLbitfield mask, GLint s, GLint t)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord2ivWIN
    (GLbitfield mask, const GLint *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord2sWIN
    (GLbitfield mask, GLshort s, GLshort t)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord2svWIN
    (GLbitfield mask, const GLshort *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord3dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord3dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord3fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord3fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord3iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord3ivWIN
    (GLbitfield mask, const GLint *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord3sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord3svWIN
    (GLbitfield mask, const GLshort *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord4dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord4dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord4fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord4fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord4iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r, GLint q)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord4ivWIN
    (GLbitfield mask, const GLint *v)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord4sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r, GLshort q)
{
    // ATTENTION
}

void APIENTRY glcltMultiTexCoord4svWIN
    (GLbitfield mask, const GLshort *v)
{
    // ATTENTION
}
#endif // GL_WIN_multiple_textures

void APIENTRY
glcltVertex2d ( IN GLdouble x, IN GLdouble y )
{
    PA_VERTEX2((GLfloat) x, (GLfloat) y);
}

void APIENTRY
glcltVertex2dv ( IN const GLdouble v[2] )
{
    PA_VERTEX2((GLfloat) v[0], (GLfloat) v[1]);
}

#ifndef __GL_ASM_GLCLTVERTEX2F
void APIENTRY
glcltVertex2f ( IN GLfloat x, IN GLfloat y )
{
    PA_VERTEX2((GLfloat) x, (GLfloat) y);
}
#endif //__GL_ASM_GLCLTVERTEX2F

#ifndef __GL_ASM_GLCLTVERTEX2FV
void APIENTRY
glcltVertex2fv ( IN const GLfloat v[2] )
{
    PA_VERTEX2((GLfloat) v[0], (GLfloat) v[1]);
}
#endif //__GL_ASM_GLCLTVERTEX2FV

void APIENTRY
glcltVertex2i ( IN GLint x, IN GLint y )
{
    PA_VERTEX2((GLfloat) x, (GLfloat) y);
}

void APIENTRY
glcltVertex2iv ( IN const GLint v[2] )
{
    PA_VERTEX2((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
glcltVertex2s ( IN GLshort x, IN GLshort y )
{
    PA_VERTEX2((GLfloat) x, (GLfloat) y);
}

void APIENTRY
glcltVertex2sv ( IN const GLshort v[2] )
{
    PA_VERTEX2((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
glcltVertex3d ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    PA_VERTEX3((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
glcltVertex3dv ( IN const GLdouble v[3] )
{
    PA_VERTEX3((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

#ifndef __GL_ASM_GLCLTVERTEX3F
void APIENTRY
glcltVertex3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    PA_VERTEX3((GLfloat) x, (GLfloat) y, (GLfloat) z);
}
#endif //__GL_ASM_GLCLTVERTEX3F

#ifndef __GL_ASM_GLCLTVERTEX3FV
void APIENTRY
glcltVertex3fv ( IN const GLfloat v[3] )
{
    GLfloat x1, y1, z1;

    x1 = (GLfloat) v[0];
    y1 = (GLfloat) v[1];
    z1 = (GLfloat) v[2];

    PA_VERTEX3(x1, y1, z1);

}
#endif //__GL_ASM_GLCLTVERTEX3FV

void APIENTRY
glcltVertex3i ( IN GLint x, IN GLint y, IN GLint z )
{
    PA_VERTEX3((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
glcltVertex3iv ( IN const GLint v[3] )
{
    PA_VERTEX3((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
glcltVertex3s ( IN GLshort x, IN GLshort y, IN GLshort z )
{
    PA_VERTEX3((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
glcltVertex3sv ( IN const GLshort v[3] )
{
    PA_VERTEX3((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
glcltVertex4d ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w )
{
    PA_VERTEX4((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
glcltVertex4dv ( IN const GLdouble v[4] )
{
    PA_VERTEX4((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltVertex4f ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w )
{
    PA_VERTEX4((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
glcltVertex4fv ( IN const GLfloat v[4] )
{
    PA_VERTEX4((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltVertex4i ( IN GLint x, IN GLint y, IN GLint z, IN GLint w )
{
    PA_VERTEX4((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
glcltVertex4iv ( IN const GLint v[4] )
{
    PA_VERTEX4((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltVertex4s ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w )
{
    PA_VERTEX4((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
glcltVertex4sv ( IN const GLshort v[4] )
{
    PA_VERTEX4((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
glcltClipPlane ( IN GLenum plane, IN const GLdouble equation[4] )
{
    GLCLIENT_BEGIN( ClipPlane, CLIPPLANE )
        pMsg->plane    = plane   ;
        pMsg->equation[ 0] = equation[ 0];
        pMsg->equation[ 1] = equation[ 1];
        pMsg->equation[ 2] = equation[ 2];
        pMsg->equation[ 3] = equation[ 3];
    return;
    GLCLIENT_END
}

void APIENTRY
glcltColorMaterial ( IN GLenum face, IN GLenum mode )
{
    GLCLIENT_BEGIN( ColorMaterial, COLORMATERIAL )
        pMsg->face     = face    ;
        pMsg->mode     = mode    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltCullFace ( IN GLenum mode )
{
    GLCLIENT_BEGIN( CullFace, CULLFACE )
        pMsg->mode     = mode    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltFrontFace ( IN GLenum mode )
{
    GLCLIENT_BEGIN( FrontFace, FRONTFACE )
        pMsg->mode     = mode    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltHint ( IN GLenum target, IN GLenum mode )
{
    GLCLIENT_BEGIN( Hint, HINT )
        pMsg->target   = target  ;
        pMsg->mode     = mode    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltLineStipple ( IN GLint factor, IN GLushort pattern )
{
    GLCLIENT_BEGIN( LineStipple, LINESTIPPLE )
        pMsg->factor   = factor  ;
        pMsg->pattern  = pattern ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltLineWidth ( IN GLfloat width )
{
    GLCLIENT_BEGIN( LineWidth, LINEWIDTH )
        pMsg->width    = width   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPointSize ( IN GLfloat size )
{
    GLCLIENT_BEGIN( PointSize, POINTSIZE )
        pMsg->size     = size    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPolygonMode ( IN GLenum face, IN GLenum mode )
{
    GLCLIENT_BEGIN( PolygonMode, POLYGONMODE )
        pMsg->face     = face    ;
        pMsg->mode     = mode    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltScissor ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height )
{
    GLCLIENT_BEGIN( Scissor, SCISSOR )
        pMsg->x        = x       ;
        pMsg->y        = y       ;
        pMsg->width    = width   ;
        pMsg->height   = height  ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltShadeModel ( IN GLenum mode )
{
    GLCLIENT_BEGIN( ShadeModel, SHADEMODEL )
        pMsg->mode     = mode    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltInitNames ( void )
{
    GLCLIENT_BEGIN( InitNames, INITNAMES )
    return;
    GLCLIENT_END
}

void APIENTRY
glcltLoadName ( IN GLuint name )
{
    GLCLIENT_BEGIN( LoadName, LOADNAME )
        pMsg->name     = name    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPassThrough ( IN GLfloat token )
{
    GLCLIENT_BEGIN( PassThrough, PASSTHROUGH )
        pMsg->token    = token   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPopName ( void )
{
    GLCLIENT_BEGIN( PopName, POPNAME )
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPushName ( IN GLuint name )
{
    GLCLIENT_BEGIN( PushName, PUSHNAME )
        pMsg->name     = name    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltDrawBuffer ( IN GLenum mode )
{
// We're doing something special here.  By doing a glsbAttention after
// putting a glDrawBuffer in the batch, we are guaranteeing that all
// drawing done in the batch is in the same drawing mode and that the
// drawing mode cannot change until the end of the batch.  This allows
// the server to sample the current drawing mode at the beginning of
// batch and to assume that it is constant for the entire batch.
//
// The server might be able to take advantage of the fact, for example,
// that all drawing in a batch is only to the back buffer.

    GLCLIENT_BEGIN( DrawBuffer, DRAWBUFFER )
        pMsg->mode     = mode    ;
        glsbAttention();
    return;
    GLCLIENT_END
}

void APIENTRY
glcltClear ( IN GLbitfield mask )
{
    GLCLIENT_BEGIN( Clear, CLEAR )
        pMsg->mask     = mask    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltClearAccum ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    GLCLIENT_BEGIN( ClearAccum, CLEARACCUM )
        pMsg->red      = red     ;
        pMsg->green    = green   ;
        pMsg->blue     = blue    ;
        pMsg->alpha    = alpha   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltClearIndex ( IN GLfloat c )
{
    GLCLIENT_BEGIN( ClearIndex, CLEARINDEX )
        pMsg->c        = c       ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltClearColor ( IN GLclampf red, IN GLclampf green, IN GLclampf blue, IN GLclampf alpha )
{
    GLCLIENT_BEGIN( ClearColor, CLEARCOLOR )
        pMsg->red      = red     ;
        pMsg->green    = green   ;
        pMsg->blue     = blue    ;
        pMsg->alpha    = alpha   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltClearStencil ( IN GLint s )
{
    GLCLIENT_BEGIN( ClearStencil, CLEARSTENCIL )
        pMsg->s        = s       ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltClearDepth ( IN GLclampd depth )
{
    GLCLIENT_BEGIN( ClearDepth, CLEARDEPTH )
        pMsg->depth    = depth   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltStencilMask ( IN GLuint mask )
{
    GLCLIENT_BEGIN( StencilMask, STENCILMASK )
        pMsg->mask     = mask    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltColorMask ( IN GLboolean red, IN GLboolean green, IN GLboolean blue, IN GLboolean alpha )
{
    GLCLIENT_BEGIN( ColorMask, COLORMASK )
        pMsg->red      = red     ;
        pMsg->green    = green   ;
        pMsg->blue     = blue    ;
        pMsg->alpha    = alpha   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltDepthMask ( IN GLboolean flag )
{
    GLCLIENT_BEGIN( DepthMask, DEPTHMASK )
        pMsg->flag     = flag    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltIndexMask ( IN GLuint mask )
{
    GLCLIENT_BEGIN( IndexMask, INDEXMASK )
        pMsg->mask     = mask    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltAccum ( IN GLenum op, IN GLfloat value )
{
    GLCLIENT_BEGIN( Accum, ACCUM )
        pMsg->op       = op      ;
        pMsg->value    = value   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltDisable ( IN GLenum cap )
{
    __GL_SETUP();

    GLCLIENT_BEGIN( Disable, DISABLE )
        pMsg->cap      = cap     ;

	    // Set the enable flags for the evaluators
	    switch (cap)
        {
        case GL_MAP1_COLOR_4:
        case GL_MAP1_INDEX:
        case GL_MAP1_NORMAL:
        case GL_MAP1_TEXTURE_COORD_1:
        case GL_MAP1_TEXTURE_COORD_2:
        case GL_MAP1_TEXTURE_COORD_3:
        case GL_MAP1_TEXTURE_COORD_4:
        case GL_MAP1_VERTEX_3:
        case GL_MAP1_VERTEX_4:
            gc->eval.evalStateFlags |= __EVALS_AFFECTS_1D_EVAL;
            break;
        case GL_MAP2_COLOR_4:
        case GL_MAP2_INDEX:
        case GL_MAP2_NORMAL:
        case GL_MAP2_TEXTURE_COORD_1:
        case GL_MAP2_TEXTURE_COORD_2:
        case GL_MAP2_TEXTURE_COORD_3:
        case GL_MAP2_TEXTURE_COORD_4:
        case GL_MAP2_VERTEX_3:
        case GL_MAP2_VERTEX_4:
        case GL_NORMALIZE:
        case GL_AUTO_NORMAL:
            gc->eval.evalStateFlags |= __EVALS_AFFECTS_2D_EVAL;
            break;
        case GL_LIGHTING:
            gc->eval.evalStateFlags |= __EVALS_AFFECTS_ALL_EVAL;
            break;
        }
    return;
    GLCLIENT_END
}

void APIENTRY
glcltEnable ( IN GLenum cap )
{
    __GL_SETUP();
  
    GLCLIENT_BEGIN( Enable, ENABLE )
        pMsg->cap      = cap     ;

    // Set the enable flags for the evaluators
    switch (cap)
    {
    case GL_MAP1_COLOR_4:
    case GL_MAP1_INDEX:
    case GL_MAP1_NORMAL:
    case GL_MAP1_TEXTURE_COORD_1:
    case GL_MAP1_TEXTURE_COORD_2:
    case GL_MAP1_TEXTURE_COORD_3:
    case GL_MAP1_TEXTURE_COORD_4:
    case GL_MAP1_VERTEX_3:
    case GL_MAP1_VERTEX_4:
        gc->eval.evalStateFlags |= __EVALS_AFFECTS_1D_EVAL;
        break;
    case GL_MAP2_COLOR_4:
    case GL_MAP2_INDEX:
    case GL_MAP2_NORMAL:
    case GL_MAP2_TEXTURE_COORD_1:
    case GL_MAP2_TEXTURE_COORD_2:
    case GL_MAP2_TEXTURE_COORD_3:
    case GL_MAP2_TEXTURE_COORD_4:
    case GL_MAP2_VERTEX_3:
    case GL_MAP2_VERTEX_4:
    case GL_NORMALIZE:
    case GL_AUTO_NORMAL:
        gc->eval.evalStateFlags |= __EVALS_AFFECTS_2D_EVAL;
        break;
    case GL_LIGHTING:
        gc->eval.evalStateFlags |= __EVALS_AFFECTS_ALL_EVAL;
        break;
    }
    return;
    GLCLIENT_END
}

void APIENTRY
glcltFinish ( void )
{
// This function is invalid between glBegin and glEnd.
// This is detected in glsbAttention.

    glsbAttention();
}

void APIENTRY
glcltFlush ( void )
{
// This function is invalid between glBegin and glEnd.
// This is detected in glsbAttention.

    glsbAttention();
}

void APIENTRY
glcltPopAttrib ( void )
{
    __GL_SETUP();

    GLCLIENT_BEGIN( PopAttrib, POPATTRIB )
    if (gc->eval.evalStackState & 0x1)
    {
        gc->eval.evalStateFlags = gc->eval.evalStateFlags |
                                  __EVALS_AFFECTS_ALL_EVAL |
                                  __EVALS_POP_EVAL_ATTRIB;
    }
    gc->eval.evalStackState = (gc->eval.evalStackState) >> 1;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPushAttrib ( IN GLbitfield mask )
{
    __GL_SETUP ();
  
    // Assert that the stack size is always less than 31 since the
    // bitfield is a DWORD. 
    ASSERTOPENGL (gc->constants.maxAttribStackDepth < 31, "Attrib state stack is greater than the size of the bitfield used to track it\n");
    
    GLCLIENT_BEGIN( PushAttrib, PUSHATTRIB )
        pMsg->mask     = mask    ;
        gc->eval.evalStackState = (gc->eval.evalStackState) << 1;
        if (mask & GL_EVAL_BIT)
    	{
    	    gc->eval.evalStateFlags = gc->eval.evalStateFlags | 
                                      __EVALS_AFFECTS_ALL_EVAL |
                                      __EVALS_PUSH_EVAL_ATTRIB;
    		gc->eval.evalStackState = (gc->eval.evalStackState) | 0x1;
        }
    return;
    GLCLIENT_END
}




void APIENTRY
glcltAlphaFunc ( IN GLenum func, IN GLclampf ref )
{
    GLCLIENT_BEGIN( AlphaFunc, ALPHAFUNC )
        pMsg->func     = func    ;
        pMsg->ref      = ref     ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltBlendFunc ( IN GLenum sfactor, IN GLenum dfactor )
{
    GLCLIENT_BEGIN( BlendFunc, BLENDFUNC )
        pMsg->sfactor  = sfactor ;
        pMsg->dfactor  = dfactor ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltLogicOp ( IN GLenum opcode )
{
    GLCLIENT_BEGIN( LogicOp, LOGICOP )
        pMsg->opcode   = opcode  ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltStencilFunc ( IN GLenum func, IN GLint ref, IN GLuint mask )
{
    GLCLIENT_BEGIN( StencilFunc, STENCILFUNC )
        pMsg->func     = func    ;
        pMsg->ref      = ref     ;
        pMsg->mask     = mask    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltStencilOp ( IN GLenum fail, IN GLenum zfail, IN GLenum zpass )
{
    GLCLIENT_BEGIN( StencilOp, STENCILOP )
        pMsg->fail     = fail    ;
        pMsg->zfail    = zfail   ;
        pMsg->zpass    = zpass   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltDepthFunc ( IN GLenum func )
{
    GLCLIENT_BEGIN( DepthFunc, DEPTHFUNC )
        pMsg->func     = func    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPixelZoom ( IN GLfloat xfactor, IN GLfloat yfactor )
{
    GLCLIENT_BEGIN( PixelZoom, PIXELZOOM )
        pMsg->xfactor  = xfactor ;
        pMsg->yfactor  = yfactor ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPixelTransferf ( IN GLenum pname, IN GLfloat param )
{
    GLCLIENT_BEGIN( PixelTransferf, PIXELTRANSFERF )
        pMsg->pname    = pname   ;
        pMsg->param    = param   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPixelTransferi ( IN GLenum pname, IN GLint param )
{
    GLCLIENT_BEGIN( PixelTransferi, PIXELTRANSFERI )
        pMsg->pname    = pname   ;
        pMsg->param    = param   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPixelStoref ( IN GLenum pname, IN GLfloat param )
{
    GLCLIENT_BEGIN( PixelStoref, PIXELSTOREF )
        pMsg->pname    = pname   ;
        pMsg->param    = param   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPixelStorei ( IN GLenum pname, IN GLint param )
{
    GLCLIENT_BEGIN( PixelStorei, PIXELSTOREI )
        pMsg->pname    = pname   ;
        pMsg->param    = param   ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPixelMapfv ( IN GLenum map, IN GLint mapsize, IN const GLfloat values[] )
{
    GLCLIENT_BEGIN_LARGE_SET( PixelMapfv, PIXELMAPFV, values, ulSize, valuesOff )
        pMsg->map      = map     ;
        pMsg->mapsize  = mapsize ;
    GLCLIENT_END_LARGE_SET
    return;
}

void APIENTRY
glcltPixelMapuiv ( IN GLenum map, IN GLint mapsize, IN const GLuint values[] )
{
    GLCLIENT_BEGIN_LARGE_SET( PixelMapuiv, PIXELMAPUIV, values, ulSize, valuesOff )
        pMsg->map      = map     ;
        pMsg->mapsize  = mapsize ;
    GLCLIENT_END_LARGE_SET
    return;
}

void APIENTRY
glcltPixelMapusv ( IN GLenum map, IN GLint mapsize, IN const GLushort values[] )
{
    GLCLIENT_BEGIN_LARGE_SET( PixelMapusv, PIXELMAPUSV, values, ulSize, valuesOff )
        pMsg->map      = map     ;
        pMsg->mapsize  = mapsize ;
    GLCLIENT_END_LARGE_SET
    return;
}

void APIENTRY
glcltReadBuffer ( IN GLenum mode )
{
    GLCLIENT_BEGIN( ReadBuffer, READBUFFER )
        pMsg->mode     = mode    ;
        glsbAttention();
    return;
    GLCLIENT_END
}

void APIENTRY
glcltCopyPixels ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum type )
{
    GLCLIENT_BEGIN( CopyPixels, COPYPIXELS )
        pMsg->x        = x       ;
        pMsg->y        = y       ;
        pMsg->width    = width   ;
        pMsg->height   = height  ;
        pMsg->type     = type    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltGetClipPlane ( IN GLenum plane, OUT GLdouble equation[4] )
{
    GLCLIENT_BEGIN( GetClipPlane, GETCLIPPLANE )
        pMsg->plane    = plane   ;
        pMsg->equation = equation;
        glsbAttention();
    return;
    GLCLIENT_END
}

GLenum APIENTRY
glcltGetError ( void )
{
    GLCLIENT_BEGIN( GetError, GETERROR )
        GLTEB_RETURNVALUE()  = GL_INVALID_OPERATION;   // assume error
        glsbAttention();
    return((GLenum)GLTEB_RETURNVALUE());
    GLCLIENT_END
}

void APIENTRY
glcltGetMapdv ( IN GLenum target, IN GLenum query, OUT GLdouble v[] )
{
    GLCLIENT_BEGIN_LARGE_GET( GetMapdv, GETMAPDV, v, ulSize, vOff )
        pMsg->target   = target  ;
        pMsg->query    = query   ;
    GLCLIENT_END_LARGE_GET
    return;
}

void APIENTRY
glcltGetMapfv ( IN GLenum target, IN GLenum query, OUT GLfloat v[] )
{
    GLCLIENT_BEGIN_LARGE_GET( GetMapfv, GETMAPFV, v, ulSize, vOff )
        pMsg->target   = target  ;
        pMsg->query    = query   ;
    GLCLIENT_END_LARGE_GET
    return;
}

void APIENTRY
glcltGetMapiv ( IN GLenum target, IN GLenum query, OUT GLint v[] )
{
    GLCLIENT_BEGIN_LARGE_GET( GetMapiv, GETMAPIV, v, ulSize, vOff )
        pMsg->target   = target  ;
        pMsg->query    = query   ;
    GLCLIENT_END_LARGE_GET
    return;
}

void APIENTRY
glcltGetPixelMapfv ( IN GLenum map, OUT GLfloat values[] )
{
    GLCLIENT_BEGIN_LARGE_GET( GetPixelMapfv, GETPIXELMAPFV, values, ulSize, valuesOff )
        pMsg->map      = map     ;
    GLCLIENT_END_LARGE_GET
    return;
}

void APIENTRY
glcltGetPixelMapuiv ( IN GLenum map, OUT GLuint values[] )
{
    GLCLIENT_BEGIN_LARGE_GET( GetPixelMapuiv, GETPIXELMAPUIV, values, ulSize, valuesOff )
        pMsg->map      = map     ;
    GLCLIENT_END_LARGE_GET
    return;
}

void APIENTRY
glcltGetPixelMapusv ( IN GLenum map, OUT GLushort values[] )
{
    GLCLIENT_BEGIN_LARGE_GET( GetPixelMapusv, GETPIXELMAPUSV, values, ulSize, valuesOff )
        pMsg->map      = map     ;
    GLCLIENT_END_LARGE_GET
    return;
}

GLboolean APIENTRY
glcltIsEnabled ( IN GLenum cap )
{
    GLCLIENT_BEGIN( IsEnabled, ISENABLED )
        pMsg->cap      = cap     ;
        GLTEB_RETURNVALUE()  = 0;              // assume error
        glsbAttention();
    return((GLboolean)GLTEB_RETURNVALUE());
    GLCLIENT_END
}

void APIENTRY
glcltDepthRange ( IN GLclampd zNear, IN GLclampd zFar )
{
    GLCLIENT_BEGIN( DepthRange, DEPTHRANGE )
        pMsg->zNear    = zNear   ;
        pMsg->zFar     = zFar    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltFrustum ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar )
{
    GLCLIENT_BEGIN( Frustum, FRUSTUM )
        pMsg->left     = left    ;
        pMsg->right    = right   ;
        pMsg->bottom   = bottom  ;
        pMsg->top      = top     ;
        pMsg->zNear    = zNear   ;
        pMsg->zFar     = zFar    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltLoadIdentity ( void )
{
    GLCLIENT_BEGIN( LoadIdentity, LOADIDENTITY )
    return;
    GLCLIENT_END
}

void APIENTRY
glcltLoadMatrixf ( IN const GLfloat m[16] )
{
    GLCLIENT_BEGIN( LoadMatrixf, LOADMATRIXF )
        pMsg->m[ 0] = m[ 0];
        pMsg->m[ 1] = m[ 1];
        pMsg->m[ 2] = m[ 2];
        pMsg->m[ 3] = m[ 3];
        pMsg->m[ 4] = m[ 4];
        pMsg->m[ 5] = m[ 5];
        pMsg->m[ 6] = m[ 6];
        pMsg->m[ 7] = m[ 7];
        pMsg->m[ 8] = m[ 8];
        pMsg->m[ 9] = m[ 9];
        pMsg->m[10] = m[10];
        pMsg->m[11] = m[11];
        pMsg->m[12] = m[12];
        pMsg->m[13] = m[13];
        pMsg->m[14] = m[14];
        pMsg->m[15] = m[15];
    return;
    GLCLIENT_END
}

void APIENTRY
glcltLoadMatrixd ( IN const GLdouble m[16] )
{
// Call LoadMatrixf instead

    GLCLIENT_BEGIN( LoadMatrixf, LOADMATRIXF )
        pMsg->m[ 0] = (GLfloat) m[ 0];
        pMsg->m[ 1] = (GLfloat) m[ 1];
        pMsg->m[ 2] = (GLfloat) m[ 2];
        pMsg->m[ 3] = (GLfloat) m[ 3];
        pMsg->m[ 4] = (GLfloat) m[ 4];
        pMsg->m[ 5] = (GLfloat) m[ 5];
        pMsg->m[ 6] = (GLfloat) m[ 6];
        pMsg->m[ 7] = (GLfloat) m[ 7];
        pMsg->m[ 8] = (GLfloat) m[ 8];
        pMsg->m[ 9] = (GLfloat) m[ 9];
        pMsg->m[10] = (GLfloat) m[10];
        pMsg->m[11] = (GLfloat) m[11];
        pMsg->m[12] = (GLfloat) m[12];
        pMsg->m[13] = (GLfloat) m[13];
        pMsg->m[14] = (GLfloat) m[14];
        pMsg->m[15] = (GLfloat) m[15];
    return;
    GLCLIENT_END
}

void APIENTRY
glcltMatrixMode ( IN GLenum mode )
{
    GLCLIENT_BEGIN( MatrixMode, MATRIXMODE )
        pMsg->mode     = mode    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltMultMatrixf ( IN const GLfloat m[16] )
{
    GLCLIENT_BEGIN( MultMatrixf, MULTMATRIXF )
        pMsg->m[ 0] = m[ 0];
        pMsg->m[ 1] = m[ 1];
        pMsg->m[ 2] = m[ 2];
        pMsg->m[ 3] = m[ 3];
        pMsg->m[ 4] = m[ 4];
        pMsg->m[ 5] = m[ 5];
        pMsg->m[ 6] = m[ 6];
        pMsg->m[ 7] = m[ 7];
        pMsg->m[ 8] = m[ 8];
        pMsg->m[ 9] = m[ 9];
        pMsg->m[10] = m[10];
        pMsg->m[11] = m[11];
        pMsg->m[12] = m[12];
        pMsg->m[13] = m[13];
        pMsg->m[14] = m[14];
        pMsg->m[15] = m[15];
    return;
    GLCLIENT_END
}

void APIENTRY
glcltMultMatrixd ( IN const GLdouble m[16] )
{
// Call MultMatrixf instead

    GLCLIENT_BEGIN( MultMatrixf, MULTMATRIXF )
        pMsg->m[ 0] = (GLfloat) m[ 0];
        pMsg->m[ 1] = (GLfloat) m[ 1];
        pMsg->m[ 2] = (GLfloat) m[ 2];
        pMsg->m[ 3] = (GLfloat) m[ 3];
        pMsg->m[ 4] = (GLfloat) m[ 4];
        pMsg->m[ 5] = (GLfloat) m[ 5];
        pMsg->m[ 6] = (GLfloat) m[ 6];
        pMsg->m[ 7] = (GLfloat) m[ 7];
        pMsg->m[ 8] = (GLfloat) m[ 8];
        pMsg->m[ 9] = (GLfloat) m[ 9];
        pMsg->m[10] = (GLfloat) m[10];
        pMsg->m[11] = (GLfloat) m[11];
        pMsg->m[12] = (GLfloat) m[12];
        pMsg->m[13] = (GLfloat) m[13];
        pMsg->m[14] = (GLfloat) m[14];
        pMsg->m[15] = (GLfloat) m[15];
    return;
    GLCLIENT_END
}

void APIENTRY
glcltOrtho ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar )
{
    GLCLIENT_BEGIN( Ortho, ORTHO )
        pMsg->left     = left    ;
        pMsg->right    = right   ;
        pMsg->bottom   = bottom  ;
        pMsg->top      = top     ;
        pMsg->zNear    = zNear   ;
        pMsg->zFar     = zFar    ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPopMatrix ( void )
{
    GLCLIENT_BEGIN( PopMatrix, POPMATRIX )
    return;
    GLCLIENT_END
}

void APIENTRY
glcltPushMatrix ( void )
{
    GLCLIENT_BEGIN( PushMatrix, PUSHMATRIX )
    return;
    GLCLIENT_END
}

void APIENTRY
glcltRotated ( IN GLdouble angle, IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
// Call Rotatef instead

    glcltRotatef((GLfloat) angle, (GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
glcltRotatef ( IN GLfloat angle, IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    GLCLIENT_BEGIN( Rotatef, ROTATEF )
        pMsg->angle    = angle   ;
        pMsg->x        = x       ;
        pMsg->y        = y       ;
        pMsg->z        = z       ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltScaled ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
// Call Scalef instead

    glcltScalef((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
glcltScalef ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    GLCLIENT_BEGIN( Scalef, SCALEF )
        pMsg->x        = x       ;
        pMsg->y        = y       ;
        pMsg->z        = z       ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltTranslated ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
// Call Translatef instead

    glcltTranslatef((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
glcltTranslatef ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    GLCLIENT_BEGIN( Translatef, TRANSLATEF )
        pMsg->x        = x       ;
        pMsg->y        = y       ;
        pMsg->z        = z       ;
    return;
    GLCLIENT_END
}

void APIENTRY
glcltViewport ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height )
{
    GLCLIENT_BEGIN( Viewport, VIEWPORT )
        pMsg->x        = x       ;
        pMsg->y        = y       ;
        pMsg->width    = width   ;
        pMsg->height   = height  ;
    return;
    GLCLIENT_END
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\glcltgsh.c ===
/******************************Module*Header*******************************\
* Module Name: glcltgsh.c
*
* OpenGL client side generic functions.
*
* Created: 11-7-1993
* Author: Hock San Lee [hockl]
*
* 08-Nov-1993   Added functions Pixel, Evaluators, GetString,
*               Feedback and Selection functions
*               Pierre Tardif, ptar@sgi.com
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

/* Generic OpenGL Client using subbatching. Hand coded functions */

#include "precomp.h"
#pragma hdrstop

#include "types.h"

#include "glsbmsg.h"
#include "glsbmsgh.h"
#include "glsrvspt.h"

#include "subbatch.h"
#include "batchinf.h"
#include "glsbcltu.h"
#include "glclt.h"
#include "compsize.h"

#include "glsize.h"

#include "context.h"
#include "global.h"
#include "lighting.h"

void APIENTRY
glcltFogf ( IN GLenum pname, IN GLfloat param )
{
// FOG_ASSERT

    if (!RANGE(pname,GL_FOG_INDEX,GL_FOG_MODE))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltFogfv(pname, &param);
}

void APIENTRY
glcltFogfv ( IN GLenum pname, IN const GLfloat params[] )
{
// FOG_ASSERT

    if (!RANGE(pname,GL_FOG_INDEX,GL_FOG_COLOR))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( Fogfv, FOGFV )
        pMsg->pname     = pname;
        pMsg->params[0] = params[0];
        if (pname == GL_FOG_COLOR)
        {
            pMsg->params[1] = params[1];
            pMsg->params[2] = params[2];
            pMsg->params[3] = params[3];
        }
    GLCLIENT_END
    return;
}

void APIENTRY
glcltFogi ( IN GLenum pname, IN GLint param )
{
    GLfloat fParam;

// FOG_ASSERT

    if (!RANGE(pname,GL_FOG_INDEX,GL_FOG_MODE))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    fParam = (GLfloat) param;
    glcltFogfv(pname, &fParam);
}

void APIENTRY
glcltFogiv ( IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_FOG_INDEX:
      case GL_FOG_DENSITY:
      case GL_FOG_START:
      case GL_FOG_END:
      case GL_FOG_MODE:
	fParams[0] = (GLfloat) params[0];
        break;
      case GL_FOG_COLOR:
	fParams[0] = __GL_I_TO_FLOAT(params[0]);
	fParams[1] = __GL_I_TO_FLOAT(params[1]);
	fParams[2] = __GL_I_TO_FLOAT(params[2]);
	fParams[3] = __GL_I_TO_FLOAT(params[3]);
        break;
    }

    glcltFogfv(pname, fParams);
}

void APIENTRY
glcltLightf ( IN GLenum light, IN GLenum pname, IN GLfloat param )
{
// LIGHT_SOURCE_ASSERT

    if (!RANGE(pname,GL_SPOT_EXPONENT,GL_QUADRATIC_ATTENUATION))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltLightfv(light, pname, &param);
}

void APIENTRY
glcltLightfv ( IN GLenum light, IN GLenum pname, IN const GLfloat params[] )
{
// LIGHT_SOURCE_ASSERT

    if (!RANGE(pname,GL_AMBIENT,GL_QUADRATIC_ATTENUATION))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( Lightfv, LIGHTFV )
        pMsg->light     = light;
        pMsg->pname     = pname;
        switch (pname)
        {
        case GL_AMBIENT:
        case GL_DIFFUSE:
        case GL_SPECULAR:
        case GL_POSITION:
            pMsg->params[3] = params[3];
        case GL_SPOT_DIRECTION:
            pMsg->params[2] = params[2];
            pMsg->params[1] = params[1];
        default:
            pMsg->params[0] = params[0];
        }
    GLCLIENT_END
    return;
}

void APIENTRY
glcltLighti ( IN GLenum light, IN GLenum pname, IN GLint param )
{
    GLfloat fParam;

// LIGHT_SOURCE_ASSERT

    if (!RANGE(pname,GL_SPOT_EXPONENT,GL_QUADRATIC_ATTENUATION))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    fParam = (GLfloat) param;
    glcltLightfv(light, pname, &fParam);
}

void APIENTRY
glcltLightiv ( IN GLenum light, IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_SPECULAR:
	fParams[0] = __GL_I_TO_FLOAT(params[0]);
	fParams[1] = __GL_I_TO_FLOAT(params[1]);
	fParams[2] = __GL_I_TO_FLOAT(params[2]);
	fParams[3] = __GL_I_TO_FLOAT(params[3]);
        break;
      case GL_POSITION:
	fParams[3] = (GLfloat) params[3];
      case GL_SPOT_DIRECTION:
	fParams[2] = (GLfloat) params[2];
	fParams[1] = (GLfloat) params[1];
      case GL_SPOT_EXPONENT:
      case GL_SPOT_CUTOFF:
      case GL_CONSTANT_ATTENUATION:
      case GL_LINEAR_ATTENUATION:
      case GL_QUADRATIC_ATTENUATION:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    glcltLightfv(light, pname, fParams);
}

void APIENTRY
glcltLightModelf ( IN GLenum pname, IN GLfloat param )
{
// LIGHT_MODEL_ASSERT

    if (!RANGE(pname,GL_LIGHT_MODEL_LOCAL_VIEWER,GL_LIGHT_MODEL_TWO_SIDE))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltLightModelfv(pname, &param);
}

void APIENTRY
glcltLightModelfv ( IN GLenum pname, IN const GLfloat params[] )
{
// LIGHT_MODEL_ASSERT

    if (!RANGE(pname,GL_LIGHT_MODEL_LOCAL_VIEWER,GL_LIGHT_MODEL_AMBIENT))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( LightModelfv, LIGHTMODELFV )
        pMsg->pname     = pname;
        pMsg->params[0] = params[0];
        if (pname == GL_LIGHT_MODEL_AMBIENT)
        {
            pMsg->params[1] = params[1];
            pMsg->params[2] = params[2];
            pMsg->params[3] = params[3];
        }
    GLCLIENT_END
    return;
}

void APIENTRY
glcltLightModeli ( IN GLenum pname, IN GLint param )
{
    GLfloat fParam;

// LIGHT_MODEL_ASSERT

    if (!RANGE(pname,GL_LIGHT_MODEL_LOCAL_VIEWER,GL_LIGHT_MODEL_TWO_SIDE))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    fParam = (GLfloat) param;
    glcltLightModelfv(pname, &fParam);
}

void APIENTRY
glcltLightModeliv ( IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_LIGHT_MODEL_AMBIENT:
	fParams[0] = __GL_I_TO_FLOAT(params[0]);
	fParams[1] = __GL_I_TO_FLOAT(params[1]);
	fParams[2] = __GL_I_TO_FLOAT(params[2]);
	fParams[3] = __GL_I_TO_FLOAT(params[3]);
        break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
      case GL_LIGHT_MODEL_TWO_SIDE:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    glcltLightModelfv(pname, fParams);
}

void APIENTRY
glcltTexParameterf ( IN GLenum target, IN GLenum pname, IN GLfloat param )
{
// TEX_PARAMETER_ASSERT

    if (!RANGE(pname,GL_TEXTURE_MAG_FILTER,GL_TEXTURE_WRAP_T) &&
        pname != GL_TEXTURE_PRIORITY)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltTexParameterfv(target, pname, &param);
}

void APIENTRY
glcltTexParameterfv ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] )
{
    switch (pname) {
      case GL_TEXTURE_WRAP_S:
      case GL_TEXTURE_WRAP_T:
      case GL_TEXTURE_MIN_FILTER:
      case GL_TEXTURE_MAG_FILTER:
      case GL_TEXTURE_BORDER_COLOR:
      case GL_TEXTURE_PRIORITY:
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( TexParameterfv, TEXPARAMETERFV )
        pMsg->target = target;
        pMsg->pname  = pname;
        pMsg->params[0] = params[0];
        if (pname == GL_TEXTURE_BORDER_COLOR)
        {
            pMsg->params[1] = params[1];
            pMsg->params[2] = params[2];
            pMsg->params[3] = params[3];
        }
    GLCLIENT_END
    return;
}

void APIENTRY
glcltTexParameteri ( IN GLenum target, IN GLenum pname, IN GLint param )
{
// TEX_PARAMETER_ASSERT

    if (!RANGE(pname,GL_TEXTURE_MAG_FILTER,GL_TEXTURE_WRAP_T) &&
        pname != GL_TEXTURE_PRIORITY)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltTexParameteriv(target, pname, &param);
}

void APIENTRY
glcltTexParameteriv ( IN GLenum target, IN GLenum pname, IN const GLint params[] )
{
    switch (pname) {
      case GL_TEXTURE_WRAP_S:
      case GL_TEXTURE_WRAP_T:
      case GL_TEXTURE_MIN_FILTER:
      case GL_TEXTURE_MAG_FILTER:
      case GL_TEXTURE_BORDER_COLOR:
      case GL_TEXTURE_PRIORITY:
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( TexParameteriv, TEXPARAMETERIV )
        pMsg->target = target;
        pMsg->pname  = pname;
        pMsg->params[0] = params[0];
        if (pname == GL_TEXTURE_BORDER_COLOR)
        {
            pMsg->params[1] = params[1];
            pMsg->params[2] = params[2];
            pMsg->params[3] = params[3];
        }
    GLCLIENT_END
    return;
}

void APIENTRY
glcltTexEnvf ( IN GLenum target, IN GLenum pname, IN GLfloat param )
{
    if (pname != GL_TEXTURE_ENV_MODE)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltTexEnvfv(target, pname, &param);
}

void APIENTRY
glcltTexEnvfv ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] )
{
    if (pname != GL_TEXTURE_ENV_MODE && pname != GL_TEXTURE_ENV_COLOR)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( TexEnvfv, TEXENVFV )
        pMsg->target    = target;
        pMsg->pname     = pname;
        pMsg->params[0] = params[0];
        if (pname == GL_TEXTURE_ENV_COLOR)
        {
            pMsg->params[1] = params[1];
            pMsg->params[2] = params[2];
            pMsg->params[3] = params[3];
        }
    GLCLIENT_END
    return;
}

void APIENTRY
glcltTexEnvi ( IN GLenum target, IN GLenum pname, IN GLint param )
{
    if (pname != GL_TEXTURE_ENV_MODE)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltTexEnviv(target, pname, &param);
}

void APIENTRY
glcltTexEnviv ( IN GLenum target, IN GLenum pname, IN const GLint params[] )
{
    if (pname != GL_TEXTURE_ENV_MODE && pname != GL_TEXTURE_ENV_COLOR)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( TexEnviv, TEXENVIV )
        pMsg->target    = target;
        pMsg->pname     = pname;
        pMsg->params[0] = params[0];
        if (pname == GL_TEXTURE_ENV_COLOR)
        {
            pMsg->params[1] = params[1];
            pMsg->params[2] = params[2];
            pMsg->params[3] = params[3];
        }
    GLCLIENT_END
    return;
}

void APIENTRY
glcltTexGend ( IN GLenum coord, IN GLenum pname, IN GLdouble param )
{
    GLfloat fParam;

    if (pname != GL_TEXTURE_GEN_MODE)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    fParam = (GLfloat) param;
    glcltTexGenfv(coord, pname, &fParam);
}

void APIENTRY
glcltTexGendv ( IN GLenum coord, IN GLenum pname, IN const GLdouble params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_OBJECT_PLANE:
      case GL_EYE_PLANE:
	fParams[3] = (GLfloat) params[3];
	fParams[2] = (GLfloat) params[2];
	fParams[1] = (GLfloat) params[1];
	// fall through
      case GL_TEXTURE_GEN_MODE:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    glcltTexGenfv(coord, pname, fParams);
}

void APIENTRY
glcltTexGenf ( IN GLenum coord, IN GLenum pname, IN GLfloat param )
{
    if (pname != GL_TEXTURE_GEN_MODE)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    glcltTexGenfv(coord, pname, &param);
}

void APIENTRY
glcltTexGenfv ( IN GLenum coord, IN GLenum pname, IN const GLfloat params[] )
{
// TEX_GEN_ASSERT

    if (!RANGE(pname,GL_TEXTURE_GEN_MODE,GL_EYE_PLANE))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( TexGenfv, TEXGENFV )
        pMsg->coord     = coord;
        pMsg->pname     = pname;
        pMsg->params[0] = params[0];
        if (pname != GL_TEXTURE_GEN_MODE)
        {
            pMsg->params[1] = params[1];
            pMsg->params[2] = params[2];
            pMsg->params[3] = params[3];
        }
    GLCLIENT_END
    return;
}

void APIENTRY
glcltTexGeni ( IN GLenum coord, IN GLenum pname, IN GLint param )
{
    GLfloat fParam;

    if (pname != GL_TEXTURE_GEN_MODE)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    fParam = (GLfloat) param;
    glcltTexGenfv(coord, pname, &fParam);
}

void APIENTRY
glcltTexGeniv ( IN GLenum coord, IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_OBJECT_PLANE:
      case GL_EYE_PLANE:
	fParams[3] = (GLfloat) params[3];
	fParams[2] = (GLfloat) params[2];
	fParams[1] = (GLfloat) params[1];
	// fall through
      case GL_TEXTURE_GEN_MODE:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    glcltTexGenfv(coord, pname, fParams);
}

void APIENTRY
glcltGetBooleanv ( IN GLenum pname, OUT GLboolean params[] )
{
#ifndef _CLIENTSIDE_
    int cArgs;

    cArgs = __glGet_size(pname);
    if (cArgs == 0)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }
    ASSERTOPENGL(cArgs <= 16, "bad get size");

    GLCLIENT_BEGIN( GetBooleanv, GETBOOLEANV )
        pMsg->pname = pname;
        glsbAttention();
        while (--cArgs >= 0)
            params[cArgs] = pMsg->params[cArgs];
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetBooleanv, GETBOOLEANV )
        pMsg->pname  = pname;
        pMsg->params = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetDoublev ( IN GLenum pname, OUT GLdouble params[] )
{
#ifndef _CLIENTSIDE_
    int cArgs;

    cArgs = __glGet_size(pname);
    if (cArgs == 0)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }
    ASSERTOPENGL(cArgs <= 16, "bad get size");

    GLCLIENT_BEGIN( GetDoublev, GETDOUBLEV )
        pMsg->pname = pname;
        glsbAttention();
        while (--cArgs >= 0)
            params[cArgs] = pMsg->params[cArgs];
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetDoublev, GETDOUBLEV )
        pMsg->pname  = pname;
        pMsg->params = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetFloatv ( IN GLenum pname, OUT GLfloat params[] )
{
#ifndef _CLIENTSIDE_
    int cArgs;

    cArgs = __glGet_size(pname);
    if (cArgs == 0)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }
    ASSERTOPENGL(cArgs <= 16, "bad get size");

    GLCLIENT_BEGIN( GetFloatv, GETFLOATV )
        pMsg->pname = pname;
        glsbAttention();
        while (--cArgs >= 0)
            params[cArgs] = pMsg->params[cArgs];
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetFloatv, GETFLOATV )
        pMsg->pname  = pname;
        pMsg->params = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetIntegerv ( IN GLenum pname, OUT GLint params[] )
{
#ifndef _CLIENTSIDE_
    int cArgs;

    cArgs = __glGet_size(pname);
    if (cArgs == 0)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }
    ASSERTOPENGL(cArgs <= 16, "bad get size");

    GLCLIENT_BEGIN( GetIntegerv, GETINTEGERV )
        pMsg->pname = pname;
        glsbAttention();
        while (--cArgs >= 0)
            params[cArgs] = pMsg->params[cArgs];
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetIntegerv, GETINTEGERV )
        pMsg->pname  = pname;
        pMsg->params = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetLightfv ( IN GLenum light, IN GLenum pname, OUT GLfloat params[] )
{
#ifndef _CLIENTSIDE_
// LIGHT_SOURCE_ASSERT

    if (!RANGE(pname,GL_AMBIENT,GL_QUADRATIC_ATTENUATION))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetLightfv, GETLIGHTFV )
        pMsg->light     = light;
        pMsg->pname     = pname;
        glsbAttention();
        switch (pname)
        {
        case GL_AMBIENT:
        case GL_DIFFUSE:
        case GL_SPECULAR:
        case GL_POSITION:
            params[3] = pMsg->params[3];
        case GL_SPOT_DIRECTION:
            params[2] = pMsg->params[2];
            params[1] = pMsg->params[1];
        default:
            params[0] = pMsg->params[0];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetLightfv, GETLIGHTFV )
        pMsg->light     = light;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetLightiv ( IN GLenum light, IN GLenum pname, OUT GLint params[] )
{
#ifndef _CLIENTSIDE_
// LIGHT_SOURCE_ASSERT

    if (!RANGE(pname,GL_AMBIENT,GL_QUADRATIC_ATTENUATION))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetLightiv, GETLIGHTIV )
        pMsg->light     = light;
        pMsg->pname     = pname;
        glsbAttention();
        switch (pname)
        {
        case GL_AMBIENT:
        case GL_DIFFUSE:
        case GL_SPECULAR:
        case GL_POSITION:
            params[3] = pMsg->params[3];
        case GL_SPOT_DIRECTION:
            params[2] = pMsg->params[2];
            params[1] = pMsg->params[1];
        default:
            params[0] = pMsg->params[0];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetLightiv, GETLIGHTIV )
        pMsg->light     = light;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetMaterialfv ( IN GLenum face, IN GLenum pname, OUT GLfloat params[] )
{
#ifndef _CLIENTSIDE_
    int cArgs;

    switch (pname) {
      case GL_SHININESS:
        cArgs = 1;
        break;
      case GL_EMISSION:
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_SPECULAR:
        cArgs = 4;
        break;
      case GL_COLOR_INDEXES:
        cArgs = 3;
        break;
      case GL_AMBIENT_AND_DIFFUSE:
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetMaterialfv, GETMATERIALFV )
        pMsg->face      = face;
        pMsg->pname     = pname;
        glsbAttention();
        while (--cArgs >= 0)
            params[cArgs] = pMsg->params[cArgs];
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetMaterialfv, GETMATERIALFV )
        pMsg->face      = face;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetMaterialiv ( IN GLenum face, IN GLenum pname, OUT GLint params[] )
{
#ifndef _CLIENTSIDE_
    int cArgs;

    switch (pname) {
      case GL_SHININESS:
        cArgs = 1;
        break;
      case GL_EMISSION:
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_SPECULAR:
        cArgs = 4;
        break;
      case GL_COLOR_INDEXES:
        cArgs = 3;
        break;
      case GL_AMBIENT_AND_DIFFUSE:
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetMaterialiv, GETMATERIALIV )
        pMsg->face      = face;
        pMsg->pname     = pname;
        glsbAttention();
        while (--cArgs >= 0)
            params[cArgs] = pMsg->params[cArgs];
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetMaterialiv, GETMATERIALIV )
        pMsg->face      = face;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexEnvfv ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] )
{
#ifndef _CLIENTSIDE_
    if (pname != GL_TEXTURE_ENV_MODE && pname != GL_TEXTURE_ENV_COLOR)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexEnvfv, GETTEXENVFV )
        pMsg->target    = target;
        pMsg->pname     = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
        if (pname == GL_TEXTURE_ENV_COLOR)
        {
            params[1] = pMsg->params[1];
            params[2] = pMsg->params[2];
            params[3] = pMsg->params[3];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexEnvfv, GETTEXENVFV )
        pMsg->target    = target;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexEnviv ( IN GLenum target, IN GLenum pname, OUT GLint params[] )
{
#ifndef _CLIENTSIDE_
    if (pname != GL_TEXTURE_ENV_MODE && pname != GL_TEXTURE_ENV_COLOR)
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexEnviv, GETTEXENVIV )
        pMsg->target    = target;
        pMsg->pname     = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
        if (pname == GL_TEXTURE_ENV_COLOR)
        {
            params[1] = pMsg->params[1];
            params[2] = pMsg->params[2];
            params[3] = pMsg->params[3];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexEnviv, GETTEXENVIV )
        pMsg->target    = target;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexGendv ( IN GLenum coord, IN GLenum pname, OUT GLdouble params[] )
{
#ifndef _CLIENTSIDE_
// TEX_GEN_ASSERT

    if (!RANGE(pname,GL_TEXTURE_GEN_MODE,GL_EYE_PLANE))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexGendv, GETTEXGENDV )
        pMsg->coord     = coord;
        pMsg->pname     = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
        if (pname != GL_TEXTURE_GEN_MODE)
        {
            params[1] = pMsg->params[1];
            params[2] = pMsg->params[2];
            params[3] = pMsg->params[3];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexGendv, GETTEXGENDV )
        pMsg->coord     = coord;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexGenfv ( IN GLenum coord, IN GLenum pname, OUT GLfloat params[] )
{
#ifndef _CLIENTSIDE_
// TEX_GEN_ASSERT

    if (!RANGE(pname,GL_TEXTURE_GEN_MODE,GL_EYE_PLANE))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexGenfv, GETTEXGENFV )
        pMsg->coord     = coord;
        pMsg->pname     = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
        if (pname != GL_TEXTURE_GEN_MODE)
        {
            params[1] = pMsg->params[1];
            params[2] = pMsg->params[2];
            params[3] = pMsg->params[3];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexGenfv, GETTEXGENFV )
        pMsg->coord     = coord;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexGeniv ( IN GLenum coord, IN GLenum pname, OUT GLint params[] )
{
#ifndef _CLIENTSIDE_
// TEX_GEN_ASSERT

    if (!RANGE(pname,GL_TEXTURE_GEN_MODE,GL_EYE_PLANE))
    {
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexGeniv, GETTEXGENIV )
        pMsg->coord     = coord;
        pMsg->pname     = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
        if (pname != GL_TEXTURE_GEN_MODE)
        {
            params[1] = pMsg->params[1];
            params[2] = pMsg->params[2];
            params[3] = pMsg->params[3];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexGeniv, GETTEXGENIV )
        pMsg->coord     = coord;
        pMsg->pname     = pname;
        pMsg->params    = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexParameterfv ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] )
{
#ifndef _CLIENTSIDE_
    switch (pname) {
      case GL_TEXTURE_WRAP_S:
      case GL_TEXTURE_WRAP_T:
      case GL_TEXTURE_MIN_FILTER:
      case GL_TEXTURE_MAG_FILTER:
      case GL_TEXTURE_BORDER_COLOR:
      case GL_TEXTURE_PRIORITY:
      case GL_TEXTURE_RESIDENT:
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexParameterfv, GETTEXPARAMETERFV )
        pMsg->target = target;
        pMsg->pname  = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
        if (pname == GL_TEXTURE_BORDER_COLOR)
        {
            params[1] = pMsg->params[1];
            params[2] = pMsg->params[2];
            params[3] = pMsg->params[3];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexParameterfv, GETTEXPARAMETERFV )
        pMsg->target = target;
        pMsg->pname  = pname;
        pMsg->params = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexParameteriv ( IN GLenum target, IN GLenum pname, OUT GLint params[] )
{
#ifndef _CLIENTSIDE_
    switch (pname) {
      case GL_TEXTURE_WRAP_S:
      case GL_TEXTURE_WRAP_T:
      case GL_TEXTURE_MIN_FILTER:
      case GL_TEXTURE_MAG_FILTER:
      case GL_TEXTURE_BORDER_COLOR:
      case GL_TEXTURE_PRIORITY:
      case GL_TEXTURE_RESIDENT:
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexParameteriv, GETTEXPARAMETERIV )
        pMsg->target = target;
        pMsg->pname  = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
        if (pname == GL_TEXTURE_BORDER_COLOR)
        {
            params[1] = pMsg->params[1];
            params[2] = pMsg->params[2];
            params[3] = pMsg->params[3];
        }
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexParameteriv, GETTEXPARAMETERIV )
        pMsg->target = target;
        pMsg->pname  = pname;
        pMsg->params = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexLevelParameterfv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLfloat params[] )
{
#ifndef _CLIENTSIDE_
    switch (pname) {
      case GL_TEXTURE_WIDTH:
      case GL_TEXTURE_HEIGHT:
      case GL_TEXTURE_COMPONENTS:
      case GL_TEXTURE_BORDER:
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexLevelParameterfv, GETTEXLEVELPARAMETERFV )
        pMsg->target = target;
        pMsg->level  = level;
        pMsg->pname  = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexLevelParameterfv, GETTEXLEVELPARAMETERFV )
        pMsg->target = target;
        pMsg->level  = level;
        pMsg->pname  = pname;
        pMsg->params = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

void APIENTRY
glcltGetTexLevelParameteriv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLint params[] )
{
#ifndef _CLIENTSIDE_
    switch (pname) {
      case GL_TEXTURE_WIDTH:
      case GL_TEXTURE_HEIGHT:
      case GL_TEXTURE_COMPONENTS:
      case GL_TEXTURE_BORDER:
        break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    GLCLIENT_BEGIN( GetTexLevelParameteriv, GETTEXLEVELPARAMETERIV )
        pMsg->target = target;
        pMsg->level  = level;
        pMsg->pname  = pname;
        glsbAttention();
        params[0] = pMsg->params[0];
    GLCLIENT_END
    return;
#else
    GLCLIENT_BEGIN( GetTexLevelParameteriv, GETTEXLEVELPARAMETERIV )
        pMsg->target = target;
        pMsg->level  = level;
        pMsg->pname  = pname;
        pMsg->params = params;
        glsbAttention();
    GLCLIENT_END
    return;
#endif
}

/******* Select and Feedback functions ******************************/

/*
 *  Note:
 *
 *      The size of the data is not required on the client side.
 *      Since calculating the size of the data requires
 *      knowledge of the visual type (RGBA/ColorIndex) it is
 *      appropriate to let the server calculate it.
 */

void APIENTRY
glcltFeedbackBuffer( IN GLsizei size, IN GLenum type, OUT GLfloat buffer[] )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_FEEDBACKBUFFER *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* This is the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(GLMSG_FEEDBACKBUFFER));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(GLMSG_FEEDBACKBUFFER));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_FEEDBACKBUFFER *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvFeedbackBuffer);

    /* Assign the members in the message */

    pMsg->size      = size;
    pMsg->type      = type;
    pMsg->bufferOff = (ULONG_PTR)buffer;

    pMsgBatchInfo->NextOffset = NextOffset;

    return;
#else
    GLCLIENT_BEGIN_LARGE_SET( FeedbackBuffer, FEEDBACKBUFFER, buffer, size, bufferOff )
        pMsg->size      = size;
        pMsg->type      = type;
    GLCLIENT_END_LARGE_SET
    return;
#endif // _CLIENTSIDE_
}

void APIENTRY
glcltSelectBuffer( IN GLsizei size, OUT GLuint buffer[] )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_SELECTBUFFER *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* This is the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(GLMSG_SELECTBUFFER));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(GLMSG_SELECTBUFFER));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_SELECTBUFFER *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvSelectBuffer);

    /* Assign the members in the message */

    pMsg->size      = size;
    pMsg->bufferOff = (ULONG_PTR)buffer;

    pMsgBatchInfo->NextOffset = NextOffset;

    return;
#else
    GLCLIENT_BEGIN_LARGE_SET( SelectBuffer, SELECTBUFFER, buffer, size, bufferOff )
        pMsg->size      = size;
    GLCLIENT_END_LARGE_SET
    return;
#endif // _CLIENTSIDE_
}

GLint APIENTRY
glcltRenderMode( IN GLenum mode )
{
    GLCLIENT_BEGIN( RenderMode, RENDERMODE )
        pMsg->mode     = mode    ;
        GLTEB_RETURNVALUE()  = 0;              // assume error
        glsbAttention();
    return( (GLint)GLTEB_RETURNVALUE() );
    GLCLIENT_END
}

const GLubyte * APIENTRY
glcltGetString( IN GLenum name )
{
    switch (name)
    {
        case GL_VENDOR:
            return("Microsoft Corporation");
        case GL_RENDERER:
            return("GDI Generic");
        case GL_VERSION:
// Version numbers
//   WinNT 3.5:     1.0
//   WinNT 3.51:    1.01
//   Win95 beta:    1.015
//   Win95:         1.02
//   WinNT 4.0:     1.1.0
            return("1.1.0");
        case GL_EXTENSIONS:
#ifdef GL_WIN_swap_hint
            return "GL_WIN_swap_hint"
#endif
#ifdef GL_EXT_bgra
                   " GL_EXT_bgra"
#endif
#ifdef GL_EXT_paletted_texture
		   " GL_EXT_paletted_texture"
#endif
#ifdef GL_WIN_phong_shading
		   " GL_WIN_phong_shading"
#endif
#ifdef GL_EXT_flat_paletted_lighting
                   " GL_EXT_flat_paletted_lighting"
#endif
#ifdef GL_WIN_specular_fog
		   " GL_WIN_specular_fog"
#endif //GL_WIN_specular_fog
#ifdef GL_WIN_multiple_textures
                   " GL_WIN_multiple_textures"
#endif
		   ;
    }
    GLSETERROR(GL_INVALID_ENUM);
    return((const GLubyte *)0);
}

/*********** Evaluator functions ************************************/
// Look in eval.c


/*********** Pixel Functions ****************************************/

void APIENTRY
glcltReadPixels (   IN GLint x,
                    IN GLint y,
                    IN GLsizei width,
                    IN GLsizei height,
                    IN GLenum format,
                    IN GLenum type,
                    OUT GLvoid *pixels
                )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_READPIXELS *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* Tentative offset, where we may want to place our data   */
    /* This is also the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(*pMsg));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(*pMsg));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_READPIXELS *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvReadPixels);

    /* Assign the members in the message as required */

    pMsg->x         = x             ;
    pMsg->y         = y             ;
    pMsg->width     = width         ;
    pMsg->height    = height        ;
    pMsg->format    = format        ;
    pMsg->type      = type          ;
    pMsg->pixelsOff = (ULONG_PTR)pixels ;

    /* Get the batch ready for the next message */

    pMsgBatchInfo->NextOffset = NextOffset;
    glsbAttention();
    return;
#else
    GLCLIENT_BEGIN_LARGE_GET( ReadPixels, READPIXELS, pixels, width*height, pixelsOff )
        pMsg->x         = x             ;
        pMsg->y         = y             ;
        pMsg->width     = width         ;
        pMsg->height    = height        ;
        pMsg->format    = format        ;
        pMsg->type      = type          ;
    GLCLIENT_END_LARGE_GET
    return;
#endif // _CLIENTSIDE_
}


void APIENTRY
glcltGetTexImage (  IN GLenum target,
                    IN GLint level,
                    IN GLenum format,
                    IN GLenum type,
                    OUT GLvoid *pixels
                 )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_GETTEXIMAGE *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* Tentative offset, where we may want to place our data   */
    /* This is also the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(*pMsg));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(*pMsg));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_GETTEXIMAGE *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvGetTexImage);

    /* Assign the members in the message as required */

    pMsg->target    = target        ;
    pMsg->level     = level         ;
    pMsg->format    = format        ;
    pMsg->type      = type          ;
    pMsg->pixelsOff = (ULONG_PTR)pixels ;

    /* Get the batch ready for the next message */

    pMsgBatchInfo->NextOffset = NextOffset;
    glsbAttention();
    return;
#else
    GLCLIENT_BEGIN_LARGE_GET( GetTexImage, GETTEXIMAGE, pixels, -1, pixelsOff )
        pMsg->target    = target        ;
        pMsg->level     = level         ;
        pMsg->format    = format        ;
        pMsg->type      = type          ;
    GLCLIENT_END_LARGE_GET
    return;
#endif // _CLIENTSIDE_
}


void APIENTRY
glcltDrawPixels (   IN GLsizei width,
                    IN GLsizei height,
                    IN GLenum format,
                    IN GLenum type,
                    IN const GLvoid *pixels
                )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_DRAWPIXELS *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* Tentative offset, where we may want to place our data   */
    /* This is also the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(*pMsg));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(*pMsg));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_DRAWPIXELS *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvDrawPixels);

    /* Assign the members in the message as required */

    pMsg->width     = width         ;
    pMsg->height    = height        ;
    pMsg->format    = format        ;
    pMsg->type      = type          ;
    pMsg->pixelsOff = (ULONG_PTR)pixels ;

    /* Get the batch ready for the next message */

    pMsgBatchInfo->NextOffset = NextOffset;
    glsbAttention();
    return;
#else
    GLCLIENT_BEGIN_LARGE_SET( DrawPixels, DRAWPIXELS, pixels, width*height, pixelsOff )
        pMsg->width     = width         ;
        pMsg->height    = height        ;
        pMsg->format    = format        ;
        pMsg->type      = type          ;
        pMsg->_IsDlist  = GL_FALSE      ;
    GLCLIENT_END_LARGE_SET
    return;
#endif // _CLIENTSIDE_
}

void APIENTRY
glcltBitmap (   IN GLsizei width,
                IN GLsizei height,
                IN GLfloat xorig,
                IN GLfloat yorig,
                IN GLfloat xmove,
                IN GLfloat ymove,
                IN const GLubyte bitmap[]
            )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_BITMAP *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* Tentative offset, where we may want to place our data   */
    /* This is also the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(*pMsg));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(*pMsg));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_BITMAP *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvBitmap);

    /* Assign the members in the message as required */

    pMsg->width     = width         ;
    pMsg->height    = height        ;
    pMsg->xorig     = xorig         ;
    pMsg->yorig     = yorig         ;
    pMsg->xmove     = xmove         ;
    pMsg->ymove     = ymove         ;
    pMsg->bitmapOff = (ULONG)bitmap ;

    /* Get the batch ready for the next message */

    pMsgBatchInfo->NextOffset = NextOffset;
    glsbAttention();
    return;
#else
    GLCLIENT_BEGIN_LARGE_SET( Bitmap, BITMAP, bitmap, width*height, bitmapOff )
        pMsg->width     = width         ;
        pMsg->height    = height        ;
        pMsg->xorig     = xorig         ;
        pMsg->yorig     = yorig         ;
        pMsg->xmove     = xmove         ;
        pMsg->ymove     = ymove         ;
        pMsg->_IsDlist  = GL_FALSE      ;
    GLCLIENT_END_LARGE_SET
    return;
#endif // _CLIENTSIDE_
}

void APIENTRY
glcltPolygonStipple ( const GLubyte *mask )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_POLYGONSTIPPLE *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* Tentative offset, where we may want to place our data   */
    /* This is also the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(*pMsg));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(*pMsg));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_POLYGONSTIPPLE *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvPolygonStipple);

    /* Assign the members in the message as required */

    pMsg->maskOff = (ULONG)mask;

    /* Get the batch ready for the next message */

    pMsgBatchInfo->NextOffset = NextOffset;
    glsbAttention();
    return;
#else
    GLCLIENT_BEGIN_LARGE_SET( PolygonStipple, POLYGONSTIPPLE, mask, -1, maskOff )
        pMsg->_IsDlist = GL_FALSE;
    GLCLIENT_END_LARGE_SET
    return;
#endif // _CLIENTSIDE_
}

void APIENTRY
glcltGetPolygonStipple ( GLubyte mask[] )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_GETPOLYGONSTIPPLE *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* Tentative offset, where we may want to place our data   */
    /* This is also the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(*pMsg));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(*pMsg));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_GETPOLYGONSTIPPLE *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvGetPolygonStipple);

    /* Assign the members in the message as required */

    pMsg->maskOff = (ULONG)mask;

    /* Get the batch ready for the next message */

    pMsgBatchInfo->NextOffset = NextOffset;
    glsbAttention();
    return;
#else
    GLCLIENT_BEGIN_LARGE_GET( GetPolygonStipple, GETPOLYGONSTIPPLE, mask, -1, maskOff )
    GLCLIENT_END_LARGE_GET
    return;
#endif // _CLIENTSIDE_
}



void APIENTRY
glcltTexImage1D (   IN GLenum target,
                    IN GLint level,
                    IN GLint components,
                    IN GLsizei width,
                    IN GLint border,
                    IN GLenum format,
                    IN GLenum type,
                    IN const GLvoid *pixels
                )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_TEXIMAGE1D *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* Tentative offset, where we may want to place our data   */
    /* This is also the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(*pMsg));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(*pMsg));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_TEXIMAGE1D *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvTexImage1D);

    /* Assign the members in the message as required */

    pMsg->target        = target        ;
    pMsg->level         = level         ;
    pMsg->components    = components    ;
    pMsg->width         = width         ;
    pMsg->border        = border        ;
    pMsg->format        = format        ;
    pMsg->type          = type          ;
    pMsg->pixelsOff     = (ULONG_PTR)pixels ;

    /* Get the batch ready for the next message */

    pMsgBatchInfo->NextOffset = NextOffset;

    glsbAttention();
    return;
#else
    GLCLIENT_BEGIN_LARGE_SET( TexImage1D, TEXIMAGE1D, pixels, width, pixelsOff )
        pMsg->target        = target        ;
        pMsg->level         = level         ;
        pMsg->components    = components    ;
        pMsg->width         = width         ;
        pMsg->border        = border        ;
        pMsg->format        = format        ;
        pMsg->type          = type          ;
        pMsg->_IsDlist      = GL_FALSE      ;
    GLCLIENT_END_LARGE_SET
    return;
#endif // _CLIENTSIDE_
}

void APIENTRY
glcltTexImage2D (   IN GLenum target,
                    IN GLint level,
                    IN GLint components,
                    IN GLsizei width,
                    IN GLsizei height,
                    IN GLint border,
                    IN GLenum format,
                    IN GLenum type,
                    IN const GLvoid *pixels
                )
{
#ifndef _CLIENTSIDE_
    GLMSGBATCHINFO *pMsgBatchInfo;
    GLMSG_TEXIMAGE2D *pMsg;
    ULONG NextOffset;

    /* Set a pointer to the batch information structure */

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    /* Tentative offset, where we may want to place our data   */
    /* This is also the first available byte after the message */

    NextOffset = pMsgBatchInfo->NextOffset +
            GLMSG_ALIGN(sizeof(*pMsg));

    if ( NextOffset > pMsgBatchInfo->MaximumOffset )
    {
        /* No room for the message, flush the batch */

        glsbAttention();

        /* Reset NextOffset */

        NextOffset = pMsgBatchInfo->NextOffset +
                GLMSG_ALIGN(sizeof(*pMsg));
    }

    /* This is where we will store our message */

    pMsg = (GLMSG_TEXIMAGE2D *)( ((BYTE *)pMsgBatchInfo) +
                pMsgBatchInfo->NextOffset);

    /* Set the ProcOffset for this function */

    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrvTexImage2D);

    /* Assign the members in the message as required */

    pMsg->target        = target        ;
    pMsg->level         = level         ;
    pMsg->components    = components    ;
    pMsg->width         = width         ;
    pMsg->height        = height        ;
    pMsg->border        = border        ;
    pMsg->format        = format        ;
    pMsg->type          = type          ;
    pMsg->pixelsOff     = (ULONG_PTR)pixels ;

    /* Get the batch ready for the next message */

    pMsgBatchInfo->NextOffset = NextOffset;
    glsbAttention();
    return;
#else
    GLCLIENT_BEGIN_LARGE_SET( TexImage2D, TEXIMAGE2D, pixels, width*height, pixelsOff )
        pMsg->target        = target        ;
        pMsg->level         = level         ;
        pMsg->components    = components    ;
        pMsg->width         = width         ;
        pMsg->height        = height        ;
        pMsg->border        = border        ;
        pMsg->format        = format        ;
        pMsg->type          = type          ;
        pMsg->_IsDlist      = GL_FALSE      ;
    GLCLIENT_END_LARGE_SET
    return;
#endif // _CLIENTSIDE_
}

GLboolean APIENTRY glcltAreTexturesResident(GLsizei n, const GLuint *textures,
                                            GLboolean *residences)
{
    GLCLIENT_BEGIN(AreTexturesResident, ARETEXTURESRESIDENT)
        pMsg->n = n;
        pMsg->textures = textures;
        pMsg->residences = residences;
        GLTEB_RETURNVALUE() = 0;
        glsbAttention();
    return (GLboolean)GLTEB_RETURNVALUE();
    GLCLIENT_END
}
        
void APIENTRY glcltBindTexture(GLenum target, GLuint texture)
{
    GLCLIENT_BEGIN(BindTexture, BINDTEXTURE)
        pMsg->target = target;
        pMsg->texture = texture;
    return;
    GLCLIENT_END
}

void APIENTRY glcltCopyTexImage1D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLint border)
{
    GLCLIENT_BEGIN(CopyTexImage1D, COPYTEXIMAGE1D)
        pMsg->target = target;
        pMsg->level = level;
        pMsg->internalformat = internalformat;
        pMsg->x = x;
        pMsg->y = y;
        pMsg->width = width;
        pMsg->border = border;
    return;
    GLCLIENT_END
}

void APIENTRY glcltCopyTexImage2D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLsizei height, GLint border)
{
    GLCLIENT_BEGIN(CopyTexImage2D, COPYTEXIMAGE2D)
        pMsg->target = target;
        pMsg->level = level;
        pMsg->internalformat = internalformat;
        pMsg->x = x;
        pMsg->y = y;
        pMsg->width = width;
        pMsg->height = height;
        pMsg->border = border;
    return;
    GLCLIENT_END
}

void APIENTRY glcltCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                     GLint x, GLint y, GLsizei width)
{
    GLCLIENT_BEGIN(CopyTexSubImage1D, COPYTEXSUBIMAGE1D)
        pMsg->target = target;
        pMsg->level = level;
        pMsg->xoffset = xoffset;
        pMsg->x = x;
        pMsg->y = y;
        pMsg->width = width;
    return;
    GLCLIENT_END
}

void APIENTRY glcltCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                     GLint yoffset, GLint x, GLint y,
                                     GLsizei width, GLsizei height)
{
    GLCLIENT_BEGIN(CopyTexSubImage2D, COPYTEXSUBIMAGE2D)
        pMsg->target = target;
        pMsg->level = level;
        pMsg->xoffset = xoffset;
        pMsg->yoffset = yoffset;
        pMsg->x = x;
        pMsg->y = y;
        pMsg->width = width;
        pMsg->height = height;
    return;
    GLCLIENT_END
}

void APIENTRY glcltDeleteTextures(GLsizei n, const GLuint *textures)
{
    GLCLIENT_BEGIN(DeleteTextures, DELETETEXTURES)
        pMsg->n = n;
        pMsg->textures = textures;
        // Flush pointer
        glsbAttention();
    return;
    GLCLIENT_END
}

void APIENTRY glcltGenTextures(GLsizei n, GLuint *textures)
{
    GLCLIENT_BEGIN(GenTextures, GENTEXTURES)
        pMsg->n = n;
        pMsg->textures = textures;
        glsbAttention();
    return;
    GLCLIENT_END
}

GLboolean APIENTRY glcltIsTexture(GLuint texture)
{
    GLCLIENT_BEGIN(IsTexture, ISTEXTURE)
        pMsg->texture = texture;
        GLTEB_RETURNVALUE() = 0;
        glsbAttention();
    return (GLboolean)GLTEB_RETURNVALUE();
    GLCLIENT_END
}

void APIENTRY glcltPrioritizeTextures(GLsizei n, const GLuint *textures,
                                      const GLclampf *priorities)
{
    GLCLIENT_BEGIN(PrioritizeTextures, PRIORITIZETEXTURES)
        pMsg->n = n;
        pMsg->textures = textures;
        pMsg->priorities = priorities;
        // Flush pointer
        glsbAttention();
    return;
    GLCLIENT_END
}

void APIENTRY glcltTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid *pixels)
{
    GLCLIENT_BEGIN_LARGE_SET(TexSubImage1D, TEXSUBIMAGE1D, pixels, width,
                             pixelsOff )
        pMsg->target        = target        ;
        pMsg->level         = level         ;
        pMsg->xoffset       = xoffset       ;
        pMsg->width         = width         ;
        pMsg->format        = format        ;
        pMsg->type          = type          ;
        pMsg->_IsDlist      = GL_FALSE      ;
    GLCLIENT_END_LARGE_SET
    return;
}

void APIENTRY glcltTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels)
{
    GLCLIENT_BEGIN_LARGE_SET(TexSubImage2D, TEXSUBIMAGE2D, pixels,
                             width*height, pixelsOff )
        pMsg->target        = target        ;
        pMsg->level         = level         ;
        pMsg->xoffset       = xoffset       ;
        pMsg->yoffset       = yoffset       ;
        pMsg->width         = width         ;
        pMsg->height        = height        ;
        pMsg->format        = format        ;
        pMsg->type          = type          ;
        pMsg->_IsDlist      = GL_FALSE      ;
    GLCLIENT_END_LARGE_SET
    return;
}

void APIENTRY glcltColorTableEXT(GLenum target, GLenum internalFormat,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid *data)
{
    GLCLIENT_BEGIN(ColorTableEXT, COLORTABLEEXT)
        pMsg->target = target;
        pMsg->internalFormat = internalFormat;
        pMsg->width = width;
        pMsg->format = format;
        pMsg->type = type;
        pMsg->data = data;
        pMsg->_IsDlist = GL_FALSE;
        // Flush pointer
        glsbAttention();
    return;
    GLCLIENT_END
}

void APIENTRY glcltColorSubTableEXT(GLenum target, GLsizei start,
                                    GLsizei count,
                                    GLenum format, GLenum type,
                                    const GLvoid *data)
{
    GLCLIENT_BEGIN(ColorSubTableEXT, COLORSUBTABLEEXT)
        pMsg->target = target;
        pMsg->start = start;
        pMsg->count = count;
        pMsg->format = format;
        pMsg->type = type;
        pMsg->data = data;
        pMsg->_IsDlist = GL_FALSE;
        // Flush pointer
        glsbAttention();
    return;
    GLCLIENT_END
}

void APIENTRY glcltGetColorTableEXT(GLenum target,
                                    GLenum format, GLenum type, GLvoid *data)
{
    GLCLIENT_BEGIN(GetColorTableEXT, GETCOLORTABLEEXT)
        pMsg->target = target;
        pMsg->format = format;
        pMsg->type = type;
        pMsg->data = data;
        glsbAttention();
    return;
    GLCLIENT_END
}

void APIENTRY glcltGetColorTableParameterivEXT( GLenum target, GLenum pname, GLint *params)
{
    GLCLIENT_BEGIN(GetColorTableParameterivEXT, GETCOLORTABLEPARAMETERIVEXT)
        pMsg->target = target;
        pMsg->pname = pname;
        pMsg->params = params;
        glsbAttention();
        return;
    GLCLIENT_END
}

void APIENTRY glcltGetColorTableParameterfvEXT( GLenum target, GLenum pname, GLfloat *params)
{
    GLCLIENT_BEGIN(GetColorTableParameterfvEXT, GETCOLORTABLEPARAMETERFVEXT)
        pMsg->target = target;
        pMsg->pname = pname;
        pMsg->params = params;
        glsbAttention();
        return;
    GLCLIENT_END
}

void APIENTRY glcltPolygonOffset(GLfloat factor, GLfloat units)
{
    GLCLIENT_BEGIN(PolygonOffset, POLYGONOFFSET)
        pMsg->factor = factor;
        pMsg->units = units;
    return;
    GLCLIENT_END
}

void APIENTRY glcltPushClientAttrib (IN GLbitfield mask)
{
    __GLclientAttribute **spp;
    __GLclientAttribute *sp;
    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

// The pixel store states are currently kept in the server, flush the
// command buffer to keep client and server in ssync.

    if (mask & GL_CLIENT_PIXEL_STORE_BIT)
	glsbAttention();

    spp = gc->clientAttributes.stackPointer;
    if (spp < &gc->clientAttributes.stack[gc->constants.maxClientAttribStackDepth])
    {
	if (!(sp = *spp))
	{
	    sp = (__GLclientAttribute*)
		GCALLOCZ(gc, sizeof(__GLclientAttribute));
	    if (NULL == sp)
	        return;
	    *spp = sp;
	}
	sp->mask = mask;
	gc->clientAttributes.stackPointer = spp + 1;

	if (mask & GL_CLIENT_PIXEL_STORE_BIT)
	{
	    sp->pixelPackModes = gc->state.pixel.packModes;
	    sp->pixelUnpackModes = gc->state.pixel.unpackModes;
	}
	if (mask & GL_CLIENT_VERTEX_ARRAY_BIT)
	{
	    sp->vertexArray = gc->vertexArray;
	}
    }
    else
    {
        GLSETERROR(GL_STACK_OVERFLOW);
    }
}

GLuint FASTCALL __glInternalPopClientAttrib(__GLcontext *gc, GLboolean bSync,
                                            GLboolean destroy)
{
    __GLclientAttribute **spp;
    __GLclientAttribute *sp;
    GLbitfield mask;
    GLuint dirtyMask = 0;

    spp = gc->clientAttributes.stackPointer;
    if (spp > &gc->clientAttributes.stack[0])
    {
	--spp;
	sp = *spp;
	ASSERTOPENGL(sp != 0, "corrupted client stack");
	mask = sp->mask;
	gc->clientAttributes.stackPointer = spp;

// If this function is called by client side, flush the command buffer
// to keep client and server pixel store states in ssync.
// If it is called by the server side __glDestroyContext() function,
// do not flush the command buffer!

	if ((mask & GL_CLIENT_PIXEL_STORE_BIT) && bSync)
	    glsbAttention();

	if (mask & GL_CLIENT_PIXEL_STORE_BIT)
	{
	    gc->state.pixel.packModes   = sp->pixelPackModes;
	    gc->state.pixel.unpackModes = sp->pixelUnpackModes;
	    dirtyMask |= __GL_DIRTY_PIXEL;
	}
	if (mask & GL_CLIENT_VERTEX_ARRAY_BIT)
	{
	    gc->vertexArray = sp->vertexArray;
	}

	/*
	** Clear out mask so that any memory frees done above won't get
	** re-done when the context is destroyed
	*/
	sp->mask = 0;
    }
    else
    {
        GLSETERROR(GL_STACK_UNDERFLOW);
    }

    return dirtyMask;
}

void APIENTRY glcltPopClientAttrib (void)
{
    GLuint dirtyMask;

    __GL_SETUP();

// Not allowed in begin/end.

    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    dirtyMask = __glInternalPopClientAttrib(gc, GL_TRUE, GL_FALSE);
    if (dirtyMask)
    {
	// __GL_DELAY_VALIDATE_MASK(gc, dirtyMask);
	gc->beginMode = __GL_NEED_VALIDATE;
	gc->dirtyMask |= dirtyMask;
    }
}

#ifdef GL_EXT_flat_paletted_lighting
void APIPRIVATE __glim_ColorTableParameterivEXT(GLenum target,
                                                GLenum pname,
                                                const GLint *params);
void APIENTRY glColorTableParameterivEXT(GLenum target,
                                         GLenum pname,
                                         const GLint *params)
{
    glsbAttention();
    __glim_ColorTableParameterivEXT(target, pname, params);
}

void APIPRIVATE __glim_ColorTableParameterfvEXT(GLenum target,
                                                GLenum pname,
                                                const GLfloat *params);
void APIENTRY glColorTableParameterfvEXT(GLenum target,
                                         GLenum pname,
                                         const GLfloat *params)
{
    glsbAttention();
    __glim_ColorTableParameterfvEXT(target, pname, params);
}
#endif // GL_EXT_flat_paletted_lighting

#ifdef GL_WIN_multiple_textures
void APIENTRY glcltCurrentTextureIndexWIN
    (GLuint index)
{
    GLCLIENT_BEGIN(CurrentTextureIndexWIN, CURRENTTEXTUREINDEXWIN)
        pMsg->index = index;
    return;
    GLCLIENT_END
}

void APIENTRY glcltBindNthTextureWIN
    (GLuint index, GLenum target, GLuint texture)
{
    GLCLIENT_BEGIN(BindNthTextureWIN, BINDNTHTEXTUREWIN)
        pMsg->index = index;
        pMsg->target = target;
        pMsg->texture = texture;
    return;
    GLCLIENT_END
}

void APIENTRY glcltNthTexCombineFuncWIN
    (GLuint index,
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor)
{
    GLCLIENT_BEGIN(NthTexCombineFuncWIN, NTHTEXCOMBINEFUNCWIN)
        pMsg->index = index;
        pMsg->leftColorFactor = leftColorFactor;
        pMsg->colorOp = colorOp;
        pMsg->rightColorFactor = rightColorFactor;
        pMsg->leftAlphaFactor = leftAlphaFactor;
        pMsg->alphaOp = alphaOp;
        pMsg->rightAlphaFactor = rightAlphaFactor;
    return;
    GLCLIENT_END
}
#endif // GL_WIN_multiple_textures
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\glcltpt.c ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/


/*
 * AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT
 * IF YOU MUST MODIFY THIS FILE, PLEASE CONTACT ptar@sgi.com 415-390-1483
 */

/* Client Side Procedure Table */

#include "precomp.h"
#pragma hdrstop

#include "glclt.h"
#ifdef GL_METAFILE
#include "metasup.h"
#endif

// There are now 2 tables!
// One table is used for RGBA mode and the other is for CI mode.

GLCLTPROCTABLE glCltRGBAProcTable = {

/* Number of function entries in the table */

     sizeof(GLDISPATCHTABLE) / sizeof(PROC),

/* gl Entry points */
  {
     glcltNewList                ,
     glcltEndList                ,
     glcltCallList               ,
     glcltCallLists              ,
     glcltDeleteLists            ,
     glcltGenLists               ,
     glcltListBase               ,
     glcltBegin                  ,
     glcltBitmap                 ,
     glcltColor3b_InRGBA         ,
     glcltColor3bv_InRGBA        ,
     glcltColor3d_InRGBA         ,
     glcltColor3dv_InRGBA        ,
     glcltColor3f_InRGBA         ,
     glcltColor3fv_InRGBA        ,
     glcltColor3i_InRGBA         ,
     glcltColor3iv_InRGBA        ,
     glcltColor3s_InRGBA         ,
     glcltColor3sv_InRGBA        ,
     glcltColor3ub_InRGBA        ,
     glcltColor3ubv_InRGBA       ,
     glcltColor3ui_InRGBA        ,
     glcltColor3uiv_InRGBA       ,
     glcltColor3us_InRGBA        ,
     glcltColor3usv_InRGBA       ,
     glcltColor4b_InRGBA         ,
     glcltColor4bv_InRGBA        ,
     glcltColor4d_InRGBA         ,
     glcltColor4dv_InRGBA        ,
     glcltColor4f_InRGBA         ,
     glcltColor4fv_InRGBA        ,
     glcltColor4i_InRGBA         ,
     glcltColor4iv_InRGBA        ,
     glcltColor4s_InRGBA         ,
     glcltColor4sv_InRGBA        ,
     glcltColor4ub_InRGBA        ,
     glcltColor4ubv_InRGBA       ,
     glcltColor4ui_InRGBA        ,
     glcltColor4uiv_InRGBA       ,
     glcltColor4us_InRGBA        ,
     glcltColor4usv_InRGBA       ,
     glcltEdgeFlag               ,
     glcltEdgeFlagv              ,
     glcltEnd                    ,
     glcltIndexd_InRGBA          ,
     glcltIndexdv_InRGBA         ,
     glcltIndexf_InRGBA          ,
     glcltIndexfv_InRGBA         ,
     glcltIndexi_InRGBA          ,
     glcltIndexiv_InRGBA         ,
     glcltIndexs_InRGBA          ,
     glcltIndexsv_InRGBA         ,
     glcltNormal3b               ,
     glcltNormal3bv              ,
     glcltNormal3d               ,
     glcltNormal3dv              ,
     glcltNormal3f               ,
     glcltNormal3fv              ,
     glcltNormal3i               ,
     glcltNormal3iv              ,
     glcltNormal3s               ,
     glcltNormal3sv              ,
     glcltRasterPos2d            ,
     glcltRasterPos2dv           ,
     glcltRasterPos2f            ,
     glcltRasterPos2fv           ,
     glcltRasterPos2i            ,
     glcltRasterPos2iv           ,
     glcltRasterPos2s            ,
     glcltRasterPos2sv           ,
     glcltRasterPos3d            ,
     glcltRasterPos3dv           ,
     glcltRasterPos3f            ,
     glcltRasterPos3fv           ,
     glcltRasterPos3i            ,
     glcltRasterPos3iv           ,
     glcltRasterPos3s            ,
     glcltRasterPos3sv           ,
     glcltRasterPos4d            ,
     glcltRasterPos4dv           ,
     glcltRasterPos4f            ,
     glcltRasterPos4fv           ,
     glcltRasterPos4i            ,
     glcltRasterPos4iv           ,
     glcltRasterPos4s            ,
     glcltRasterPos4sv           ,
     glcltRectd                  ,
     glcltRectdv                 ,
     glcltRectf                  ,
     glcltRectfv                 ,
     glcltRecti                  ,
     glcltRectiv                 ,
     glcltRects                  ,
     glcltRectsv                 ,
     glcltTexCoord1d             ,
     glcltTexCoord1dv            ,
     glcltTexCoord1f             ,
     glcltTexCoord1fv            ,
     glcltTexCoord1i             ,
     glcltTexCoord1iv            ,
     glcltTexCoord1s             ,
     glcltTexCoord1sv            ,
     glcltTexCoord2d             ,
     glcltTexCoord2dv            ,
     glcltTexCoord2f             ,
     glcltTexCoord2fv            ,
     glcltTexCoord2i             ,
     glcltTexCoord2iv            ,
     glcltTexCoord2s             ,
     glcltTexCoord2sv            ,
     glcltTexCoord3d             ,
     glcltTexCoord3dv            ,
     glcltTexCoord3f             ,
     glcltTexCoord3fv            ,
     glcltTexCoord3i             ,
     glcltTexCoord3iv            ,
     glcltTexCoord3s             ,
     glcltTexCoord3sv            ,
     glcltTexCoord4d             ,
     glcltTexCoord4dv            ,
     glcltTexCoord4f             ,
     glcltTexCoord4fv            ,
     glcltTexCoord4i             ,
     glcltTexCoord4iv            ,
     glcltTexCoord4s             ,
     glcltTexCoord4sv            ,
     glcltVertex2d               ,
     glcltVertex2dv              ,
     glcltVertex2f               ,
     glcltVertex2fv              ,
     glcltVertex2i               ,
     glcltVertex2iv              ,
     glcltVertex2s               ,
     glcltVertex2sv              ,
     glcltVertex3d               ,
     glcltVertex3dv              ,
     glcltVertex3f               ,
     glcltVertex3fv              ,
     glcltVertex3i               ,
     glcltVertex3iv              ,
     glcltVertex3s               ,
     glcltVertex3sv              ,
     glcltVertex4d               ,
     glcltVertex4dv              ,
     glcltVertex4f               ,
     glcltVertex4fv              ,
     glcltVertex4i               ,
     glcltVertex4iv              ,
     glcltVertex4s               ,
     glcltVertex4sv              ,
     glcltClipPlane              ,
     glcltColorMaterial          ,
     glcltCullFace               ,
     glcltFogf                   ,
     glcltFogfv                  ,
     glcltFogi                   ,
     glcltFogiv                  ,
     glcltFrontFace              ,
     glcltHint                   ,
     glcltLightf                 ,
     glcltLightfv                ,
     glcltLighti                 ,
     glcltLightiv                ,
     glcltLightModelf            ,
     glcltLightModelfv           ,
     glcltLightModeli            ,
     glcltLightModeliv           ,
     glcltLineStipple            ,
     glcltLineWidth              ,
     glcltMaterialf              ,
     glcltMaterialfv             ,
     glcltMateriali              ,
     glcltMaterialiv             ,
     glcltPointSize              ,
     glcltPolygonMode            ,
     glcltPolygonStipple         ,
     glcltScissor                ,
     glcltShadeModel             ,
     glcltTexParameterf          ,
     glcltTexParameterfv         ,
     glcltTexParameteri          ,
     glcltTexParameteriv         ,
     glcltTexImage1D             ,
     glcltTexImage2D             ,
     glcltTexEnvf                ,
     glcltTexEnvfv               ,
     glcltTexEnvi                ,
     glcltTexEnviv               ,
     glcltTexGend                ,
     glcltTexGendv               ,
     glcltTexGenf                ,
     glcltTexGenfv               ,
     glcltTexGeni                ,
     glcltTexGeniv               ,
     glcltFeedbackBuffer         ,
     glcltSelectBuffer           ,
     glcltRenderMode             ,
     glcltInitNames              ,
     glcltLoadName               ,
     glcltPassThrough            ,
     glcltPopName                ,
     glcltPushName               ,
     glcltDrawBuffer             ,
     glcltClear                  ,
     glcltClearAccum             ,
     glcltClearIndex             ,
     glcltClearColor             ,
     glcltClearStencil           ,
     glcltClearDepth             ,
     glcltStencilMask            ,
     glcltColorMask              ,
     glcltDepthMask              ,
     glcltIndexMask              ,
     glcltAccum                  ,
     glcltDisable                ,
     glcltEnable                 ,
     glcltFinish                 ,
     glcltFlush                  ,
     glcltPopAttrib              ,
     glcltPushAttrib             ,
     glcltMap1d                  ,
     glcltMap1f                  ,
     glcltMap2d                  ,
     glcltMap2f                  ,
     glcltMapGrid1d              ,
     glcltMapGrid1f              ,
     glcltMapGrid2d              ,
     glcltMapGrid2f              ,
     glcltEvalCoord1d            ,
     glcltEvalCoord1dv           ,
     glcltEvalCoord1f            ,
     glcltEvalCoord1fv           ,
     glcltEvalCoord2d            ,
     glcltEvalCoord2dv           ,
     glcltEvalCoord2f            ,
     glcltEvalCoord2fv           ,
     glcltEvalMesh1              ,
     glcltEvalPoint1             ,
     glcltEvalMesh2              ,
     glcltEvalPoint2             ,
     glcltAlphaFunc              ,
     glcltBlendFunc              ,
     glcltLogicOp                ,
     glcltStencilFunc            ,
     glcltStencilOp              ,
     glcltDepthFunc              ,
     glcltPixelZoom              ,
     glcltPixelTransferf         ,
     glcltPixelTransferi         ,
     glcltPixelStoref            ,
     glcltPixelStorei            ,
     glcltPixelMapfv             ,
     glcltPixelMapuiv            ,
     glcltPixelMapusv            ,
     glcltReadBuffer             ,
     glcltCopyPixels             ,
     glcltReadPixels             ,
     glcltDrawPixels             ,
     glcltGetBooleanv            ,
     glcltGetClipPlane           ,
     glcltGetDoublev             ,
     glcltGetError               ,
     glcltGetFloatv              ,
     glcltGetIntegerv            ,
     glcltGetLightfv             ,
     glcltGetLightiv             ,
     glcltGetMapdv               ,
     glcltGetMapfv               ,
     glcltGetMapiv               ,
     glcltGetMaterialfv          ,
     glcltGetMaterialiv          ,
     glcltGetPixelMapfv          ,
     glcltGetPixelMapuiv         ,
     glcltGetPixelMapusv         ,
     glcltGetPolygonStipple      ,
     glcltGetString              ,
     glcltGetTexEnvfv            ,
     glcltGetTexEnviv            ,
     glcltGetTexGendv            ,
     glcltGetTexGenfv            ,
     glcltGetTexGeniv            ,
     glcltGetTexImage            ,
     glcltGetTexParameterfv      ,
     glcltGetTexParameteriv      ,
     glcltGetTexLevelParameterfv ,
     glcltGetTexLevelParameteriv ,
     glcltIsEnabled              ,
     glcltIsList                 ,
     glcltDepthRange             ,
     glcltFrustum                ,
     glcltLoadIdentity           ,
     glcltLoadMatrixf            ,
     glcltLoadMatrixd            ,
     glcltMatrixMode             ,
     glcltMultMatrixf            ,
     glcltMultMatrixd            ,
     glcltOrtho                  ,
     glcltPopMatrix              ,
     glcltPushMatrix             ,
     glcltRotated                ,
     glcltRotatef                ,
     glcltScaled                 ,
     glcltScalef                 ,
     glcltTranslated             ,
     glcltTranslatef             ,
     glcltViewport               ,
     glcltArrayElement           ,
     glcltBindTexture            ,
     glcltColorPointer           ,
     glcltDisableClientState     ,
     glcltDrawArrays             ,
     glcltDrawElements           ,
     glcltEdgeFlagPointer        ,
     glcltEnableClientState      ,
     glcltIndexPointer           ,
     glcltIndexub_InRGBA         ,
     glcltIndexubv_InRGBA        ,
     glcltInterleavedArrays      ,
     glcltNormalPointer          ,
     glcltPolygonOffset          ,
     glcltTexCoordPointer        ,
     glcltVertexPointer          ,
     glcltAreTexturesResident    ,
     glcltCopyTexImage1D         ,
     glcltCopyTexImage2D         ,
     glcltCopyTexSubImage1D      ,
     glcltCopyTexSubImage2D      ,
     glcltDeleteTextures         ,
     glcltGenTextures            ,
     glcltGetPointerv            ,
     glcltIsTexture              ,
     glcltPrioritizeTextures     ,
     glcltTexSubImage1D          ,
     glcltTexSubImage2D          ,
     glcltPopClientAttrib        ,
     glcltPushClientAttrib       ,
  }

};

GLCLTPROCTABLE glCltCIProcTable = {

/* Number of function entries in the table */

     sizeof(GLDISPATCHTABLE) / sizeof(PROC),

/* gl Entry points */
  {
     glcltNewList                ,
     glcltEndList                ,
     glcltCallList               ,
     glcltCallLists              ,
     glcltDeleteLists            ,
     glcltGenLists               ,
     glcltListBase               ,
     glcltBegin                  ,
     glcltBitmap                 ,
     glcltColor3b_InCI           ,
     glcltColor3bv_InCI          ,
     glcltColor3d_InCI           ,
     glcltColor3dv_InCI          ,
     glcltColor3f_InCI           ,
     glcltColor3fv_InCI          ,
     glcltColor3i_InCI           ,
     glcltColor3iv_InCI          ,
     glcltColor3s_InCI           ,
     glcltColor3sv_InCI          ,
     glcltColor3ub_InCI          ,
     glcltColor3ubv_InCI         ,
     glcltColor3ui_InCI          ,
     glcltColor3uiv_InCI         ,
     glcltColor3us_InCI          ,
     glcltColor3usv_InCI         ,
     glcltColor4b_InCI           ,
     glcltColor4bv_InCI          ,
     glcltColor4d_InCI           ,
     glcltColor4dv_InCI          ,
     glcltColor4f_InCI           ,
     glcltColor4fv_InCI          ,
     glcltColor4i_InCI           ,
     glcltColor4iv_InCI          ,
     glcltColor4s_InCI           ,
     glcltColor4sv_InCI          ,
     glcltColor4ub_InCI          ,
     glcltColor4ubv_InCI         ,
     glcltColor4ui_InCI          ,
     glcltColor4uiv_InCI         ,
     glcltColor4us_InCI          ,
     glcltColor4usv_InCI         ,
     glcltEdgeFlag               ,
     glcltEdgeFlagv              ,
     glcltEnd                    ,
     glcltIndexd_InCI            ,
     glcltIndexdv_InCI           ,
     glcltIndexf_InCI            ,
     glcltIndexfv_InCI           ,
     glcltIndexi_InCI            ,
     glcltIndexiv_InCI           ,
     glcltIndexs_InCI            ,
     glcltIndexsv_InCI           ,
     glcltNormal3b               ,
     glcltNormal3bv              ,
     glcltNormal3d               ,
     glcltNormal3dv              ,
     glcltNormal3f               ,
     glcltNormal3fv              ,
     glcltNormal3i               ,
     glcltNormal3iv              ,
     glcltNormal3s               ,
     glcltNormal3sv              ,
     glcltRasterPos2d            ,
     glcltRasterPos2dv           ,
     glcltRasterPos2f            ,
     glcltRasterPos2fv           ,
     glcltRasterPos2i            ,
     glcltRasterPos2iv           ,
     glcltRasterPos2s            ,
     glcltRasterPos2sv           ,
     glcltRasterPos3d            ,
     glcltRasterPos3dv           ,
     glcltRasterPos3f            ,
     glcltRasterPos3fv           ,
     glcltRasterPos3i            ,
     glcltRasterPos3iv           ,
     glcltRasterPos3s            ,
     glcltRasterPos3sv           ,
     glcltRasterPos4d            ,
     glcltRasterPos4dv           ,
     glcltRasterPos4f            ,
     glcltRasterPos4fv           ,
     glcltRasterPos4i            ,
     glcltRasterPos4iv           ,
     glcltRasterPos4s            ,
     glcltRasterPos4sv           ,
     glcltRectd                  ,
     glcltRectdv                 ,
     glcltRectf                  ,
     glcltRectfv                 ,
     glcltRecti                  ,
     glcltRectiv                 ,
     glcltRects                  ,
     glcltRectsv                 ,
     glcltTexCoord1d             ,
     glcltTexCoord1dv            ,
     glcltTexCoord1f             ,
     glcltTexCoord1fv            ,
     glcltTexCoord1i             ,
     glcltTexCoord1iv            ,
     glcltTexCoord1s             ,
     glcltTexCoord1sv            ,
     glcltTexCoord2d             ,
     glcltTexCoord2dv            ,
     glcltTexCoord2f             ,
     glcltTexCoord2fv            ,
     glcltTexCoord2i             ,
     glcltTexCoord2iv            ,
     glcltTexCoord2s             ,
     glcltTexCoord2sv            ,
     glcltTexCoord3d             ,
     glcltTexCoord3dv            ,
     glcltTexCoord3f             ,
     glcltTexCoord3fv            ,
     glcltTexCoord3i             ,
     glcltTexCoord3iv            ,
     glcltTexCoord3s             ,
     glcltTexCoord3sv            ,
     glcltTexCoord4d             ,
     glcltTexCoord4dv            ,
     glcltTexCoord4f             ,
     glcltTexCoord4fv            ,
     glcltTexCoord4i             ,
     glcltTexCoord4iv            ,
     glcltTexCoord4s             ,
     glcltTexCoord4sv            ,
     glcltVertex2d               ,
     glcltVertex2dv              ,
     glcltVertex2f               ,
     glcltVertex2fv              ,
     glcltVertex2i               ,
     glcltVertex2iv              ,
     glcltVertex2s               ,
     glcltVertex2sv              ,
     glcltVertex3d               ,
     glcltVertex3dv              ,
     glcltVertex3f               ,
     glcltVertex3fv              ,
     glcltVertex3i               ,
     glcltVertex3iv              ,
     glcltVertex3s               ,
     glcltVertex3sv              ,
     glcltVertex4d               ,
     glcltVertex4dv              ,
     glcltVertex4f               ,
     glcltVertex4fv              ,
     glcltVertex4i               ,
     glcltVertex4iv              ,
     glcltVertex4s               ,
     glcltVertex4sv              ,
     glcltClipPlane              ,
     glcltColorMaterial          ,
     glcltCullFace               ,
     glcltFogf                   ,
     glcltFogfv                  ,
     glcltFogi                   ,
     glcltFogiv                  ,
     glcltFrontFace              ,
     glcltHint                   ,
     glcltLightf                 ,
     glcltLightfv                ,
     glcltLighti                 ,
     glcltLightiv                ,
     glcltLightModelf            ,
     glcltLightModelfv           ,
     glcltLightModeli            ,
     glcltLightModeliv           ,
     glcltLineStipple            ,
     glcltLineWidth              ,
     glcltMaterialf              ,
     glcltMaterialfv             ,
     glcltMateriali              ,
     glcltMaterialiv             ,
     glcltPointSize              ,
     glcltPolygonMode            ,
     glcltPolygonStipple         ,
     glcltScissor                ,
     glcltShadeModel             ,
     glcltTexParameterf          ,
     glcltTexParameterfv         ,
     glcltTexParameteri          ,
     glcltTexParameteriv         ,
     glcltTexImage1D             ,
     glcltTexImage2D             ,
     glcltTexEnvf                ,
     glcltTexEnvfv               ,
     glcltTexEnvi                ,
     glcltTexEnviv               ,
     glcltTexGend                ,
     glcltTexGendv               ,
     glcltTexGenf                ,
     glcltTexGenfv               ,
     glcltTexGeni                ,
     glcltTexGeniv               ,
     glcltFeedbackBuffer         ,
     glcltSelectBuffer           ,
     glcltRenderMode             ,
     glcltInitNames              ,
     glcltLoadName               ,
     glcltPassThrough            ,
     glcltPopName                ,
     glcltPushName               ,
     glcltDrawBuffer             ,
     glcltClear                  ,
     glcltClearAccum             ,
     glcltClearIndex             ,
     glcltClearColor             ,
     glcltClearStencil           ,
     glcltClearDepth             ,
     glcltStencilMask            ,
     glcltColorMask              ,
     glcltDepthMask              ,
     glcltIndexMask              ,
     glcltAccum                  ,
     glcltDisable                ,
     glcltEnable                 ,
     glcltFinish                 ,
     glcltFlush                  ,
     glcltPopAttrib              ,
     glcltPushAttrib             ,
     glcltMap1d                  ,
     glcltMap1f                  ,
     glcltMap2d                  ,
     glcltMap2f                  ,
     glcltMapGrid1d              ,
     glcltMapGrid1f              ,
     glcltMapGrid2d              ,
     glcltMapGrid2f              ,
     glcltEvalCoord1d            ,
     glcltEvalCoord1dv           ,
     glcltEvalCoord1f            ,
     glcltEvalCoord1fv           ,
     glcltEvalCoord2d            ,
     glcltEvalCoord2dv           ,
     glcltEvalCoord2f            ,
     glcltEvalCoord2fv           ,
     glcltEvalMesh1              ,
     glcltEvalPoint1             ,
     glcltEvalMesh2              ,
     glcltEvalPoint2             ,
     glcltAlphaFunc              ,
     glcltBlendFunc              ,
     glcltLogicOp                ,
     glcltStencilFunc            ,
     glcltStencilOp              ,
     glcltDepthFunc              ,
     glcltPixelZoom              ,
     glcltPixelTransferf         ,
     glcltPixelTransferi         ,
     glcltPixelStoref            ,
     glcltPixelStorei            ,
     glcltPixelMapfv             ,
     glcltPixelMapuiv            ,
     glcltPixelMapusv            ,
     glcltReadBuffer             ,
     glcltCopyPixels             ,
     glcltReadPixels             ,
     glcltDrawPixels             ,
     glcltGetBooleanv            ,
     glcltGetClipPlane           ,
     glcltGetDoublev             ,
     glcltGetError               ,
     glcltGetFloatv              ,
     glcltGetIntegerv            ,
     glcltGetLightfv             ,
     glcltGetLightiv             ,
     glcltGetMapdv               ,
     glcltGetMapfv               ,
     glcltGetMapiv               ,
     glcltGetMaterialfv          ,
     glcltGetMaterialiv          ,
     glcltGetPixelMapfv          ,
     glcltGetPixelMapuiv         ,
     glcltGetPixelMapusv         ,
     glcltGetPolygonStipple      ,
     glcltGetString              ,
     glcltGetTexEnvfv            ,
     glcltGetTexEnviv            ,
     glcltGetTexGendv            ,
     glcltGetTexGenfv            ,
     glcltGetTexGeniv            ,
     glcltGetTexImage            ,
     glcltGetTexParameterfv      ,
     glcltGetTexParameteriv      ,
     glcltGetTexLevelParameterfv ,
     glcltGetTexLevelParameteriv ,
     glcltIsEnabled              ,
     glcltIsList                 ,
     glcltDepthRange             ,
     glcltFrustum                ,
     glcltLoadIdentity           ,
     glcltLoadMatrixf            ,
     glcltLoadMatrixd            ,
     glcltMatrixMode             ,
     glcltMultMatrixf            ,
     glcltMultMatrixd            ,
     glcltOrtho                  ,
     glcltPopMatrix              ,
     glcltPushMatrix             ,
     glcltRotated                ,
     glcltRotatef                ,
     glcltScaled                 ,
     glcltScalef                 ,
     glcltTranslated             ,
     glcltTranslatef             ,
     glcltViewport               ,
     glcltArrayElement           ,
     glcltBindTexture            ,
     glcltColorPointer           ,
     glcltDisableClientState     ,
     glcltDrawArrays             ,
     glcltDrawElements           ,
     glcltEdgeFlagPointer        ,
     glcltEnableClientState      ,
     glcltIndexPointer           ,
     glcltIndexub_InCI           ,
     glcltIndexubv_InCI          ,
     glcltInterleavedArrays      ,
     glcltNormalPointer          ,
     glcltPolygonOffset          ,
     glcltTexCoordPointer        ,
     glcltVertexPointer          ,
     glcltAreTexturesResident    ,
     glcltCopyTexImage1D         ,
     glcltCopyTexImage2D         ,
     glcltCopyTexSubImage1D      ,
     glcltCopyTexSubImage2D      ,
     glcltDeleteTextures         ,
     glcltGenTextures            ,
     glcltGetPointerv            ,
     glcltIsTexture              ,
     glcltPrioritizeTextures     ,
     glcltTexSubImage1D          ,
     glcltTexSubImage2D          ,
     glcltPopClientAttrib        ,
     glcltPushClientAttrib       ,
  }

};

GLEXTPROCTABLE glExtProcTable =
{
    /* Number of function entries in the table */
    sizeof(GLEXTDISPATCHTABLE) / sizeof(PROC),

    /* gl EXT Entry points */
    {
        glcltDrawRangeElementsWIN,
        glcltColorTableEXT,
        glcltColorSubTableEXT,
        glcltGetColorTableEXT,
        glcltGetColorTableParameterivEXT,
        glcltGetColorTableParameterfvEXT,
#ifdef GL_WIN_multiple_textures
        glcltCurrentTextureIndexWIN,
        glcltMultiTexCoord1dWIN,
        glcltMultiTexCoord1dvWIN,
        glcltMultiTexCoord1fWIN,
        glcltMultiTexCoord1fvWIN,
        glcltMultiTexCoord1iWIN,
        glcltMultiTexCoord1ivWIN,
        glcltMultiTexCoord1sWIN,
        glcltMultiTexCoord1svWIN,
        glcltMultiTexCoord2dWIN,
        glcltMultiTexCoord2dvWIN,
        glcltMultiTexCoord2fWIN,
        glcltMultiTexCoord2fvWIN,
        glcltMultiTexCoord2iWIN,
        glcltMultiTexCoord2ivWIN,
        glcltMultiTexCoord2sWIN,
        glcltMultiTexCoord2svWIN,
        glcltMultiTexCoord3dWIN,
        glcltMultiTexCoord3dvWIN,
        glcltMultiTexCoord3fWIN,
        glcltMultiTexCoord3fvWIN,
        glcltMultiTexCoord3iWIN,
        glcltMultiTexCoord3ivWIN,
        glcltMultiTexCoord3sWIN,
        glcltMultiTexCoord3svWIN,
        glcltMultiTexCoord4dWIN,
        glcltMultiTexCoord4dvWIN,
        glcltMultiTexCoord4fWIN,
        glcltMultiTexCoord4fvWIN,
        glcltMultiTexCoord4iWIN,
        glcltMultiTexCoord4ivWIN,
        glcltMultiTexCoord4sWIN,
        glcltMultiTexCoord4svWIN,
        glcltBindNthTextureWIN,
        glcltNthTexCombineFuncWIN,
#endif // GL_WIN_multiple_textures
    }
};

/******************************Public*Routine******************************\
* vInitTebCache
*
* Within the NT TEB, there is a table where OpenGL can cache OpenGL API
* function pointers.  In this area we can cache frequently used portions
* of the dispatch table.  Functions cached in this area can save a level
* of indirection by avoiding deferencing the dispatch table pointer.
*
* History:
*  06-Nov-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

// The following table defines the ranges of the dispatch table that should
// be cached in the TEB.  Each pair of indices defines the start and end of
// each range.

int static gaiCacheFuncs[] = {
    INDEX_glCallList    ,     INDEX_glCallLists   ,
    INDEX_glBegin       ,     INDEX_glBegin       ,
    INDEX_glColor3b     ,     INDEX_glNormal3sv   ,
    INDEX_glTexCoord1d  ,     INDEX_glVertex4sv   ,
    INDEX_glMaterialf   ,     INDEX_glMaterialiv  ,
    INDEX_glDisable     ,     INDEX_glEnable      ,
    INDEX_glPopAttrib   ,     INDEX_glPushAttrib  ,
    INDEX_glEvalCoord1d ,     INDEX_glEvalCoord2fv,
    INDEX_glEvalPoint1  ,     INDEX_glEvalPoint1  ,
    INDEX_glEvalPoint2  ,     INDEX_glEvalPoint2  ,
    INDEX_glLoadIdentity,     INDEX_glMultMatrixd ,
    INDEX_glPopMatrix   ,     INDEX_glTranslatef  ,
    INDEX_glArrayElement,     INDEX_glVertexPointer,
    INDEX_glGetPointerv,      INDEX_glGetPointerv ,
    INDEX_glPopClientAttrib,  INDEX_glPushClientAttrib,
    INDEX_glDrawRangeElementsWIN,    INDEX_glColorSubTableEXT,
#ifdef GL_WIN_multiple_textures
    INDEX_glCurrentTextureIndexWIN, INDEX_glCurrentTextureIndexWIN,
    INDEX_glBindNthTextureWIN, INDEX_glNthTexCombineFuncWIN,
    INDEX_glMultiTexCoord1fWIN, INDEX_glMultiTexCoord1ivWIN,
    INDEX_glMultiTexCoord2fWIN, INDEX_glMultiTexCoord2ivWIN,
#endif // GL_WIN_multiple_textures
};

void vInitTebCache(PVOID glTable)
{
    int iRange, iCache;
    PROC *pfnCltDispatchTableFast;

    pfnCltDispatchTableFast = (PROC *)GLTEB_CLTDISPATCHTABLE_FAST();

// Copy each range of FPs, defined by the table gaiCacheFuncs, from the
// dispatch table to the TEB FP cache.

    for ( iRange = 0, iCache = 0;
          iRange < (sizeof(gaiCacheFuncs) / sizeof(int));
          iRange+=2 )
    {
        PVOID pvCache;      // ptr into FP cache within TEB
        PVOID pvDispatch;   // ptr to current range within dispatch table
        int iNum;           // number of FPs in current range to cache

        pvCache = (PVOID)&pfnCltDispatchTableFast[iCache];
        pvDispatch = (PVOID)&((PROC *)glTable)[gaiCacheFuncs[iRange]];
        iNum = gaiCacheFuncs[iRange+1] - gaiCacheFuncs[iRange] + 1;

        ASSERTOPENGL((BYTE *)pvCache >= (BYTE *)pfnCltDispatchTableFast &&
		     (BYTE *)pvCache < (BYTE *)GLTEB_CLTPOLYARRAY() &&
		     ((PROC *)pvCache)+iNum <= (PROC *)GLTEB_CLTPOLYARRAY(),
                     "Fast dispatch area overflow\n");

        memcpy(pvCache, pvDispatch, iNum * sizeof(PROC));

        iCache += iNum;
    }

    ASSERTOPENGL(iCache == sizeof(GLDISPATCHTABLE_FAST) / sizeof(PROC),
		 "fast dispatch table not initialized properly\n");
}

/******************************Public*Routine******************************\
*
* SetCltProcTable
*
* Sets the client-side dispatch table or update the metafiling
* dispatch table if capturing
*
* History:
*  Fri Jan 05 16:37:40 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void SetCltProcTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept,
                     BOOL fForce)
{
#ifdef GL_METAFILE
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();
    if (!fForce && plrc != NULL && plrc->fCapturing)
    {
        MetaSetCltProcTable(pgcpt, pgept);
    }
    else
#endif
    {
        // Copy base proc table
        memcpy((PVOID) CURRENT_GLTEBINFO()->glCltDispatchTable,
               &pgcpt->glDispatchTable,
               pgcpt->cEntries * sizeof(PROC));
        // If the given proc table doesn't have a complete set of entries,
        // pad it out with noops
        if (pgcpt->cEntries < OPENGL_VERSION_110_ENTRIES)
        {
            memcpy(((PROC *)CURRENT_GLTEBINFO()->glCltDispatchTable)+
                   pgcpt->cEntries,
                   ((PROC *)&glNullCltProcTable.glDispatchTable)+
                   pgcpt->cEntries,
                   (OPENGL_VERSION_110_ENTRIES-pgcpt->cEntries)*sizeof(PROC));
        }

        // Copy extension proc table
        // This is a purely internal table so it should always have the
        // right number of entries
        ASSERTOPENGL(pgept->cEntries == glNullExtProcTable.cEntries,
                     "Bad extension proc table\n");
        memcpy(CURRENT_GLTEBINFO()->glCltDispatchTable+
               GL_EXT_PROC_TABLE_OFFSET,
               &pgept->glDispatchTable,
               pgept->cEntries * sizeof(PROC));
        vInitTebCache(CURRENT_GLTEBINFO()->glCltDispatchTable);
    }
}

/******************************Public*Routine******************************\
*
* GetCltProcTable
*
* Gets the client-side dispatch table or the metafile capture
* exec table depending on the metafile capture state
*
* History:
*  Fri Jan 05 19:11:26 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void GetCltProcTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept,
                     BOOL fForce)
{
#ifdef GL_METAFILE
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();
    if (!fForce && plrc != NULL && plrc->fCapturing)
    {
        MetaGetCltProcTable(pgcpt, pgept);
    }
    else
#endif
    {
	memcpy(&pgcpt->glDispatchTable,
	       (PVOID) CURRENT_GLTEBINFO()->glCltDispatchTable,
               pgcpt->cEntries * sizeof(PROC));
	memcpy(&pgept->glDispatchTable,
               CURRENT_GLTEBINFO()->glCltDispatchTable+GL_EXT_PROC_TABLE_OFFSET,
               pgept->cEntries * sizeof(PROC));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\local.c ===
/*****************************Module*Header*******************************\
* Module Name: local.c                                                     *
*                                                                          *
* Support routines for client side objects.                                *
*                                                                          *
* Created: 30-May-1991 21:55:57                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1991,1993 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ntcsrdll.h>

LHE             *pLocalTable;              // Points to handle table.
ULONG            iFreeLhe = INVALID_INDEX; // Identifies a free handle index.
ULONG            cLheCommitted = 0;        // Count of LHEs with committed RAM.
CRITICAL_SECTION semLocal;                 // Semaphore for handle allocation.


//XXX Useless but needed by csrgdi.h

#if DBG
ULONG gcHits  = 0;
ULONG gcBatch = 0;
ULONG gcCache = 0;
ULONG gcUser  = 0;
#endif

/******************************Private*Routine*****************************\
* bMakeMoreHandles ()                                                      *
*                                                                          *
* Commits more RAM to the local handle table and links the new free        *
* handles together.  Returns TRUE on success, FALSE on error.              *
*                                                                          *
* History:                                                                 *
*  Sat 01-Jun-1991 17:06:45 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bMakeMoreHandles()
{
    UINT ii;

// Commit more RAM for the handle table.

    if (
        (cLheCommitted >= MAX_HANDLES) ||
        (VirtualAlloc(
            (LPVOID) &pLocalTable[cLheCommitted],
            COMMIT_COUNT * sizeof(LHE),
            MEM_COMMIT,
            PAGE_READWRITE
            ) == (LPVOID) NULL)
       )
    {
        WARNING("bMakeMoreHandles(): failed to commit more memory\n");
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

// Initialize the new handles.

    ii = iFreeLhe = cLheCommitted;
    cLheCommitted += COMMIT_COUNT;

    for (; ii<cLheCommitted; ii++)
    {
        pLocalTable[ii].metalink = ii+1;
        pLocalTable[ii].iUniq    = 1;
        pLocalTable[ii].iType    = LO_NULL;
    }
    pLocalTable[ii-1].metalink = INVALID_INDEX;

    return(TRUE);
}

/******************************Public*Routine******************************\
* iAllocHandle (iType,hgre,pv)                                             *
*                                                                          *
* Allocates a handle from the local handle table, initializes fields in    *
* the handle entry.  Returns the handle index or INVALID_INDEX on error.   *
*                                                                          *
* History:                                                                 *
*  Sat 01-Jun-1991 17:08:54 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

ULONG iAllocHandle(ULONG iType,ULONG hgre,PVOID pv)
{
    ULONG ii = INVALID_INDEX;
    PLHE  plhe;

// Get critical for handle allocation.

    ENTERCRITICALSECTION(&semLocal);

// Make sure a handle is available.

    if (iFreeLhe != INVALID_INDEX || bMakeMoreHandles())
    {
        ii = iFreeLhe;
        plhe = pLocalTable + ii;
        iFreeLhe = plhe->metalink;
        plhe->hgre     = hgre;
        plhe->cRef     = 0;
        plhe->iType    = (BYTE) iType;
        plhe->pv       = pv;
        plhe->metalink = 0;
        plhe->tidOwner = 0;
        plhe->cLock    = 0;
    }

// Leave the critical section.

    LEAVECRITICALSECTION(&semLocal);
    return(ii);
}

/******************************Public*Routine******************************\
* vFreeHandle (h)                                                          *
*                                                                          *
* Frees up a local handle.  The handle is added to the free list.  This    *
* may be called with either an index or handle.  The iUniq count is        *
* updated so the next user of this handle slot will have a different       *
* handle.                                                                  *
*                                                                          *
* Note for client side implementation:                                     *
*   Caller should have handle locked before calling this.                  *
*                                                                          *
* History:                                                                 *
*  Sat 01-Jun-1991 17:11:23 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

VOID vFreeHandle(ULONG_PTR h)
{
// Extract the index from the handle.

    UINT ii = MASKINDEX(h);

// Get critical for handle deallocation.

    ENTERCRITICALSECTION(&semLocal);

// Caller should lock handle before freeing.

    ASSERTOPENGL(pLocalTable[ii].cLock == 1,
                 "vFreeHandle(): cLock != 1\n");
    ASSERTOPENGL(pLocalTable[ii].tidOwner == GetCurrentThreadId(),
                 "vFreeHandle(): thread not owner\n");

// Add the handle to the free list.

    pLocalTable[ii].metalink = iFreeLhe;
    iFreeLhe = ii;

// Increment the iUniq count.

    pLocalTable[ii].iUniq++;
    if (pLocalTable[ii].iUniq == 0)
        pLocalTable[ii].iUniq = 1;
    pLocalTable[ii].iType = LO_NULL;

// Leave the critical section.

    LEAVECRITICALSECTION(&semLocal);
}

/******************************Public*Routine******************************\
* cLockHandle (h)
*
* Lock handle for access by a thread.  If another thread possesses the lock,
* this will fail.
*
* Returns:
*   Lock count.  Returns -1 if failure.
*
* History:
*  31-Jan-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LONG cLockHandle(ULONG_PTR h)
{
    LONG lRet = -1;

// Extract the index from the handle.

    UINT ii = MASKINDEX(h);
    PLHE plhe = pLocalTable + ii;

// Get critical for handle locking.

    ENTERCRITICALSECTION(&semLocal);

    if ((ii >= cLheCommitted) ||
        (!MATCHUNIQ(plhe,h))  ||
        ((plhe->iType != LO_RC))
       )
    {
        DBGLEVEL1(LEVEL_ERROR, "cLockHandle: invalid handle 0x%lx\n", h);
        SetLastError(ERROR_INVALID_HANDLE);
        goto cLockHandle_exit;
    }

// If not currently locked or if current owning thread is the same,
// do the lock.

    if ( (pLocalTable[ii].cLock == 0) ||
         (pLocalTable[ii].tidOwner == GetCurrentThreadId()) )
    {
        pLocalTable[ii].cLock++;
        pLocalTable[ii].tidOwner = GetCurrentThreadId();

        lRet = (LONG) pLocalTable[ii].cLock;
    }
    else
    {
        WARNING("cLockHandle(): current thread not owner\n");
        SetLastError(ERROR_BUSY);
    }

// Leave the critical section.

cLockHandle_exit:
    LEAVECRITICALSECTION(&semLocal);
    return lRet;
}

/******************************Public*Routine******************************\
* vUnlockHandle (h)
*
* Removes a lock from the handle.  Must be owned by current thread.
*
* Note:
*   Caller should possess the lock before this is called.  This implies
*   that cLockHandle must be called and its return code must be heeded.
*
* History:
*  31-Jan-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vUnlockHandle(ULONG_PTR h)
{
// Extract the index from the handle.

    UINT ii = MASKINDEX(h);

// Get critical for handle deallocation.

    ENTERCRITICALSECTION(&semLocal);

// If not currently locked or if current owning thread is the same,
// do the lock.

    ASSERTOPENGL(pLocalTable[ii].cLock > 0,
                 "vUnlockHandle(): not locked\n");
    ASSERTOPENGL(pLocalTable[ii].tidOwner == GetCurrentThreadId(),
                 "vUnlockHandle(): thread not owner\n");

    if ( (pLocalTable[ii].cLock > 0) &&
         (pLocalTable[ii].tidOwner == GetCurrentThreadId()) )
    {
        pLocalTable[ii].cLock--;
    }

// Leave the critical section.

    LEAVECRITICALSECTION(&semLocal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\layer.c ===
/******************************Module*Header*******************************\
* Module Name: layer.c
*
* OpenGL layer planes support
*
* History:
*  Fri Mar 16 13:27:47 1995	-by-	Drew Bliss [drewb]
*   Created
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <glp.h>
#include <glscreen.h>
#include <glgenwin.h>

#include "gencx.h"
#include "context.h"

// Macro to call glFlush or glFinish only if a RC is current.

#define GLFLUSH()          if (GLTEB_CLTCURRENTRC()) glFlush()
#define GLFINISH()         if (GLTEB_CLTCURRENTRC()) glFinish()

/*****************************Private*Routine******************************\
*
* ValidateLayerIndex
*
* Checks to see whether the given layer index is legal for the given
* pixel format
*
* History:
*  Fri Mar 17 14:35:27 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY ValidateLayerIndex(int iLayerPlane, PIXELFORMATDESCRIPTOR *ppfd)
{
    if (iLayerPlane < 0)
    {
        if (-iLayerPlane > ((ppfd->bReserved >> 4) & 15))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }
    else if (iLayerPlane > 0)
    {
        if (iLayerPlane > (ppfd->bReserved & 15))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }
    else
        return FALSE;

    return TRUE;
}

/*****************************Private*Routine******************************\
*
* ValidateLayerIndexForDc
*
* Checks to see whether the given layer index is valid for the
* pixel format currently selected in the DC
*
* Returns the current pixel format
*
* History:
*  Fri Mar 17 14:35:55 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

static BOOL ValidateLayerIndexForDc(int iLayerPlane,
                                    HDC hdc,
                                    PIXELFORMATDESCRIPTOR *ppfd)
{
    int ipfd;

    if (IsDirectDrawDevice(hdc))
    {
        SetLastError(ERROR_INVALID_FUNCTION);
        return FALSE;
    }
    
    ipfd = GetPixelFormat(hdc);
    if (ipfd == 0)
    {
        return FALSE;
    }

    if (DescribePixelFormat(hdc, ipfd,
                            sizeof(PIXELFORMATDESCRIPTOR), ppfd) == 0)
    {
        return FALSE;
    }

    return ValidateLayerIndex(iLayerPlane, ppfd);
}

/******************************Public*Routine******************************\
*
* wglDescribeLayerPlane
*
* Describes the given layer plane
*
* History:
*  Fri Mar 17 13:16:23 1995	-by-	Drew Bliss [drewb]
*   Created
\**************************************************************************/

BOOL WINAPI wglDescribeLayerPlane(HDC hdc,
                                  int iPixelFormat,
                                  int iLayerPlane,
                                  UINT nBytes,
                                  LPLAYERPLANEDESCRIPTOR plpd)
{
    PIXELFORMATDESCRIPTOR pfd;
    BOOL bRet;

    if (IsDirectDrawDevice(hdc))
    {
        SetLastError(ERROR_INVALID_FUNCTION);
        return FALSE;
    }
    
    // Retrieve the pixel format information
    // Validates the HDC and pixel format
    if (DescribePixelFormat(hdc, iPixelFormat, sizeof(pfd), &pfd) == 0)
    {
        return FALSE;
    }

    // Check for correct size of return buffer
    if (nBytes < sizeof(LAYERPLANEDESCRIPTOR))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    // Make sure the given layer plane is valid
    if (!ValidateLayerIndex(iLayerPlane, &pfd))
    {
        return FALSE;
    }

    // Generic implementations don't currently support layers
    ASSERTOPENGL(!(pfd.dwFlags & PFD_GENERIC_FORMAT)
                 || (pfd.dwFlags & PFD_GENERIC_ACCELERATED), "bad generic pfd");

    if (!(pfd.dwFlags & PFD_GENERIC_ACCELERATED))
    {
        PGLDRIVER pgldrv;
        
        // Pass request on to the driver if it supports it
        pgldrv = pgldrvLoadInstalledDriver(hdc);
        if (pgldrv != NULL &&
            pgldrv->pfnDrvDescribeLayerPlane != NULL)
        {
            bRet = pgldrv->pfnDrvDescribeLayerPlane(hdc, iPixelFormat,
                                                    iLayerPlane, nBytes, plpd);
        }
        else
        {
            bRet = FALSE;
        }
    }
    else
    {
        bRet = GenMcdDescribeLayerPlane(hdc, iPixelFormat, iLayerPlane,
                                        nBytes, plpd);
    }
    
    return bRet;
}

/******************************Public*Routine******************************\
*
* wglSetLayerPaletteEntries
*
* Sets palette entries for the given layer plane
*
* History:
*  Fri Mar 17 13:17:11 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

int WINAPI wglSetLayerPaletteEntries(HDC hdc,
                                     int iLayerPlane,
                                     int iStart,
                                     int cEntries,
                                     CONST COLORREF *pcr)
{
    PIXELFORMATDESCRIPTOR pfd;
    int iRet;

    // Validate the layer and retrieve the current pixel format
    if (!ValidateLayerIndexForDc(iLayerPlane, hdc, &pfd))
    {
        return 0;
    }

    // Flush OpenGL calls.

    GLFLUSH();

    // Generic implementations don't currently support layers
    ASSERTOPENGL(!(pfd.dwFlags & PFD_GENERIC_FORMAT)
                 || (pfd.dwFlags & PFD_GENERIC_ACCELERATED), "bad generic pfd");

    if (!(pfd.dwFlags & PFD_GENERIC_ACCELERATED))
    {
        PGLDRIVER pgldrv;
        
        // Pass request on to the driver if it supports it
        pgldrv = pgldrvLoadInstalledDriver(hdc);
        if (pgldrv != NULL &&
            pgldrv->pfnDrvSetLayerPaletteEntries != NULL)
        {
            iRet = pgldrv->pfnDrvSetLayerPaletteEntries(hdc, iLayerPlane,
                                                        iStart, cEntries, pcr);
        }
        else
        {
            iRet = 0;
        }
    }
    else
    {
        iRet = GenMcdSetLayerPaletteEntries(hdc, iLayerPlane,
                                            iStart, cEntries, pcr);
    }
    
    return iRet;
}

/******************************Public*Routine******************************\
*
* wglGetLayerPaletteEntries
*
* Retrieves palette information for the given layer plane
*
* History:
*  Fri Mar 17 13:18:00 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

int WINAPI wglGetLayerPaletteEntries(HDC hdc,
                                     int iLayerPlane,
                                     int iStart,
                                     int cEntries,
                                     COLORREF *pcr)
{
    PIXELFORMATDESCRIPTOR pfd;
    int iRet;

    // Validate the layer and retrieve the current pixel format
    if (!ValidateLayerIndexForDc(iLayerPlane, hdc, &pfd))
    {
        return 0;
    }

    // Generic implementations don't currently support layers
    ASSERTOPENGL(!(pfd.dwFlags & PFD_GENERIC_FORMAT)
                 || (pfd.dwFlags & PFD_GENERIC_ACCELERATED), "bad generic pfd");

    if (!(pfd.dwFlags & PFD_GENERIC_ACCELERATED))
    {
        PGLDRIVER pgldrv;
        
        // Pass request on to the driver if it supports it
        pgldrv = pgldrvLoadInstalledDriver(hdc);
        if (pgldrv != NULL &&
            pgldrv->pfnDrvGetLayerPaletteEntries != NULL)
        {
            iRet = pgldrv->pfnDrvGetLayerPaletteEntries(hdc, iLayerPlane,
                                                        iStart, cEntries, pcr);
        }
        else
        {
            iRet = 0;
        }
    }
    else
    {
        iRet = GenMcdGetLayerPaletteEntries(hdc, iLayerPlane,
                                            iStart, cEntries, pcr);
    }
    
    return iRet;
}

/******************************Public*Routine******************************\
*
* wglRealizeLayerPalette
*
* Realizes the current palette for the given layer plane
*
* History:
*  Fri Mar 17 13:18:54 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL WINAPI wglRealizeLayerPalette(HDC hdc,
                                   int iLayerPlane,
                                   BOOL bRealize)
{
    PIXELFORMATDESCRIPTOR pfd;
    BOOL bRet;

    // Validate the layer and retrieve the current pixel format
    if (!ValidateLayerIndexForDc(iLayerPlane, hdc, &pfd))
    {
        return FALSE;
    }

    // Flush OpenGL calls.

    GLFLUSH();

    // Generic implementations don't currently support layers
    ASSERTOPENGL(!(pfd.dwFlags & PFD_GENERIC_FORMAT)
                 || (pfd.dwFlags & PFD_GENERIC_ACCELERATED), "bad generic pfd");

    if (!(pfd.dwFlags & PFD_GENERIC_ACCELERATED))
    {
        PGLDRIVER pgldrv;
        
        // Pass request on to the driver if it supports it
        pgldrv = pgldrvLoadInstalledDriver(hdc);
        if (pgldrv != NULL &&
            pgldrv->pfnDrvRealizeLayerPalette != NULL)
        {
            bRet = pgldrv->pfnDrvRealizeLayerPalette(hdc, iLayerPlane,
                                                     bRealize);
        }
        else
        {
            bRet = FALSE;
        }
    }
    else
    {
        bRet = GenMcdRealizeLayerPalette(hdc, iLayerPlane, bRealize);
    }
    
    return bRet;
}

/******************************Public*Routine******************************\
*
* wglSwapLayerBuffers
*
* Swaps the buffers indicated by fuFlags
*
* History:
*  Fri Mar 17 13:19:20 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL WINAPI wglSwapLayerBuffers(HDC hdc,
                                UINT fuFlags)
{
    GLGENwindow *pwnd;
    int ipfd;
    BOOL bRet;
    GLWINDOWID gwid;

#if 0
    // If fuFlags == -1, it is a SwapBuffers call.
    if (fuFlags & 0x80000000)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
#endif

    if (IsDirectDrawDevice(hdc))
    {
        SetLastError(ERROR_INVALID_FUNCTION);
        return FALSE;
    }
    
    // Finish OpenGL calls.

    GLFINISH();

    ipfd = GetPixelFormat(hdc);
    if (ipfd == 0)
    {
        return FALSE;
    }

    WindowIdFromHdc(hdc, &gwid);
    pwnd = pwndGetFromID(&gwid);
    if (!pwnd)
    {
        return FALSE;
    }

    if (ipfd > pwnd->ipfdDevMax)
    {
        PIXELFORMATDESCRIPTOR pfd;

        if (DescribePixelFormat(hdc, ipfd,
                                sizeof(PIXELFORMATDESCRIPTOR), &pfd) == 0)
        {
            return FALSE;
        }

        // Generic implementations only support the main plane unless MCD
        // has overlay support.

        if (pfd.dwFlags & PFD_GENERIC_ACCELERATED)
        {
            // MCD always support this (whether or not there are layers).

            bRet = GenMcdSwapLayerBuffers(hdc, fuFlags);
        }
        else if (fuFlags & WGL_SWAP_MAIN_PLANE)
        {
            // We are generic, so substituting SwapBuffers is OK as long
            // as the main plane is being swapped.  We ignore the bits for
            // the layer planes (they don't exist!).

            bRet = SwapBuffers(hdc);
        }
        else
        {
            // We are generic and the request is to swap only layer planes
            // (none of which exist).  Since we ignore unsupported planes
            // there is nothing to do, but we can return success.

            bRet = TRUE;
        }
    }
    else
    {
        PGLDRIVER pgldrv;
        
        // Pass request on to the driver if it supports it
        pgldrv = pgldrvLoadInstalledDriver(hdc);
        if (pgldrv != NULL &&
            pgldrv->pfnDrvSwapLayerBuffers != NULL)
        {
            bRet = pgldrv->pfnDrvSwapLayerBuffers(hdc, fuFlags);
        }
        else if (fuFlags & WGL_SWAP_MAIN_PLANE)
        {
            // If the driver doesn't have DrvSwapLayerBuffers, we
            // can still try and swap the main plane via
            // SwapBuffers.  The bit flags for unsupported planes
            // are ignored
            // We're assuming that the fact that the driver doesn't
            // expose DrvSwapLayerBuffers means that it doesn't support
            // layers at all, possibly not a valid assumption but
            // a reasonably safe one.  If the driver did support layers,
            // this call will cause swapping of all layer planes and
            // problems will result
            bRet = SwapBuffers(hdc);
        }
        else
        {
            // Nothing to swap.
            //
            // Again, we are assuming that if the driver doesn't support
            // DrvSwapLayerBuffers, there are no layer planes at all.
            // However, since we ignore the bits for layers that do not
            // exist, this is not an error case.
            bRet = TRUE;
        }
    }

    pwndRelease(pwnd);
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\makecur.c ===
/******************************Module*Header*******************************\
* Module Name: makecur.c
*
* wglMakeCurrent implementation
*
* Created: 02-10-1997
*
* Copyright (c) 1993-1997 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <context.h>
#include <global.h>

#include "metasup.h"
#include "wgldef.h"

/******************************Public*Routine******************************\
*
* __wglSetProcTable
*
* Callback function given to ICDs to set a proc table
*
\**************************************************************************/

void APIENTRY
__wglSetProcTable(PGLCLTPROCTABLE pglCltProcTable)
{
    if (pglCltProcTable == (PGLCLTPROCTABLE) NULL)
        return;

// It must have either 306 entries for version 1.0 or 336 entries for 1.1

    if (pglCltProcTable->cEntries != OPENGL_VERSION_100_ENTRIES &&
        pglCltProcTable->cEntries != OPENGL_VERSION_110_ENTRIES)
    {
        return;
    }

    // This function is called by client drivers which do not use
    // the EXT procs provided by opengl32.  Use the null EXT proc
    // table to disable those stubs since they should never be
    // called anyway
    SetCltProcTable(pglCltProcTable, &glNullExtProcTable, TRUE);
}

/******************************Public*Routine******************************\
*
* CheckDeviceModes
*
* Ensures that the HDC doesn't have any disallowed state
*
* History:
*  Mon Aug 26 15:03:28 1996	-by-	Drew Bliss [drewb]
*   Split from wglMakeCurrent
*
\**************************************************************************/

BOOL CheckDeviceModes(HDC hdc)
{
    SIZE szW, szV;
    XFORM xform;
    POINT pt;
    HRGN  hrgnTmp;
    int   iRgn;

// For release 1, GDI transforms must be identity.
// This is to allow GDI transform binding in future.

    switch (GetMapMode(hdc))
    {
    case MM_TEXT:
        break;
    case MM_ANISOTROPIC:
        if (!GetWindowExtEx(hdc, &szW)
         || !GetViewportExtEx(hdc, &szV)
         || szW.cx != szV.cx
         || szW.cy != szV.cy)
            goto wglMakeCurrent_xform_error;
        break;
    default:
        goto wglMakeCurrent_xform_error;
    }

    if (!GetViewportOrgEx(hdc, &pt) || pt.x != 0 || pt.y != 0)
        goto wglMakeCurrent_xform_error;

    if (!GetWindowOrgEx(hdc, &pt) || pt.x != 0 || pt.y != 0)
        goto wglMakeCurrent_xform_error;

    if (!GetWorldTransform(hdc, &xform))
    {
// Win95 does not support GetWorldTransform.

        if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
            goto wglMakeCurrent_xform_error;
    }
    else if (xform.eDx  != 0.0f   || xform.eDy  != 0.0f
          || xform.eM12 != 0.0f   || xform.eM21 != 0.0f
          || xform.eM11 <  0.999f || xform.eM11 >  1.001f // allow rounding errors
          || xform.eM22 <  0.999f || xform.eM22 >  1.001f)
    {
wglMakeCurrent_xform_error:
        DBGERROR("wglMakeCurrent: GDI transforms not identity\n");
        SetLastError(ERROR_TRANSFORM_NOT_SUPPORTED);
        return FALSE;
    }

// For release 1, GDI clip region is not allowed.
// This is to allow GDI clip region binding in future.

    if (!(hrgnTmp = CreateRectRgn(0, 0, 0, 0)))
        return FALSE;

    iRgn = GetClipRgn(hdc, hrgnTmp);

    if (!DeleteObject(hrgnTmp))
        ASSERTOPENGL(FALSE, "DeleteObject failed");

    switch (iRgn)
    {
    case -1:    // error
        WARNING("wglMakeCurrent: GetClipRgn failed\n");
        return FALSE;

    case 0:     // no initial clip region
        break;

    case 1:     // has initial clip region
        DBGERROR("wglMakeCurrent: GDI clip region not allowed\n");
        SetLastError(ERROR_CLIPPING_NOT_SUPPORTED);
        return FALSE;
    }

    return TRUE;
}

/******************************Public*Routine******************************\
*
* MakeAnyCurrent
*
* Makes any type of context current
*
* History:
*  Mon Aug 26 15:00:44 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL MakeAnyCurrent(HGLRC hrc, int ipfd, DWORD dwObjectType,
                    GLWINDOWID *pgwid)
{
    HGLRC hrcSrv;
    PLRC  plrc;
    DWORD tidCurrent;
    ULONG irc;
    PLHE  plheRC;
    PGLCLTPROCTABLE pglProcTable;
    PGLEXTPROCTABLE pglExtProcTable;
    POLYARRAY *pa;

    DBGENTRY("wglMakeCurrent\n");

    // If this is a new, uninitialized thread, try to initialize it
    if (CURRENT_GLTEBINFO() == NULL)
    {
        GLInitializeThread(DLL_THREAD_ATTACH);
    
// If the teb was not set up at thread initialization, return failure.

	if (!CURRENT_GLTEBINFO())
	{
	    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
	    return(FALSE);
	}
    }

// There are four cases:
//
// 1. hrc is NULL and there is no current RC.
// 2. hrc is NULL and there is a current RC.
// 3. hrc is not NULL and there is a current RC.
// 4. hrc is not NULL and there is no current RC.

// Case 1: hrc is NULL and there is no current RC.
// This is a noop, return success.

    if (hrc == (HGLRC) 0 && (GLTEB_CLTCURRENTRC() == (PLRC) NULL))
        return(TRUE);

// Case 2: hrc is NULL and there is a current RC.
// Make the current RC inactive.

    if (hrc == (HGLRC) 0 && (GLTEB_CLTCURRENTRC() != (PLRC) NULL))
        return(bMakeNoCurrent());

// Get the current thread id.

    tidCurrent = GetCurrentThreadId();
    ASSERTOPENGL(tidCurrent != INVALID_THREAD_ID,
        "wglMakeCurrent: GetCurrentThreadId returned a bad value\n");

// Validate the handles.  hrc is not NULL here.

    ASSERTOPENGL(hrc != (HGLRC) NULL, "wglMakeCurrent: hrc is NULL\n");

// Validate the RC.

    if (cLockHandle((ULONG_PTR)hrc) <= 0)
    {
        DBGLEVEL1(LEVEL_ERROR, "wglMakeCurrent: can't lock hrc 0x%lx\n", hrc);
        goto wglMakeCurrent_error_nolock;
    }
    irc = MASKINDEX(hrc);
    plheRC = pLocalTable + irc;
    plrc   = (PLRC) plheRC->pv;
    hrcSrv = (HGLRC) plheRC->hgre;
    ASSERTOPENGL(plrc->ident == LRC_IDENTIFIER, "wglMakeCurrent: Bad plrc\n");

#ifdef GL_METAFILE
    // Ensure that metafile RC's are made current only to
    // metafile DC's
    if (plrc->uiGlsCaptureContext != 0 && dwObjectType != OBJ_ENHMETADC)
    {
        DBGLEVEL(LEVEL_ERROR,
                 "wglMakeCurrent: attempt to make meta RC current "
                 "to non-meta DC\n");
        SetLastError(ERROR_INVALID_HANDLE);
        vUnlockHandle((ULONG_PTR)hrc);
        return FALSE;
    }

    // Ensure that non-metafile RC's are made current only to
    // non-metafile DC's
    if (plrc->uiGlsCaptureContext == 0 && dwObjectType == OBJ_ENHMETADC)
    {
        DBGLEVEL(LEVEL_ERROR,
                 "wglMakeCurrent: attempt to make non-meta RC current "
                 "to meta DC\n");
        SetLastError(ERROR_METAFILE_NOT_SUPPORTED);
        vUnlockHandle((ULONG_PTR)hrc);
        return FALSE;
    }
#endif
    
// If the RC is current, it must be current to this thread because 
// makecurrent locks down the handle.
// If the given RC is already current to this thread, we will release it first,
// then make it current again.  This is to support DC/RC attribute bindings in
// this function.

    ASSERTOPENGL(plrc->tidCurrent == INVALID_THREAD_ID ||
                 plrc->tidCurrent == tidCurrent,
                 "wglMakeCurrent: hrc is current to another thread\n");

// Case 3: hrc is not NULL and there is a current RC.
// This is case 2 followed by case 4.

    if (GLTEB_CLTCURRENTRC())
    {
// First, make the current RC inactive.

        if (!bMakeNoCurrent())
        {
            DBGERROR("wglMakeCurrent: bMakeNoCurrent failed\n");
            vUnlockHandle((ULONG_PTR)hrc);
            return(FALSE);
        }

// Second, make hrc current.  Fall through to case 4.
    }

// Case 4: hrc is not NULL and there is no current RC.

    ASSERTOPENGL(GLTEB_CLTCURRENTRC() == (PLRC) NULL,
        "wglMakeCurrent: There is a current RC!\n");

// If the pixel format of the window or surface is different from that of
// the RC, return error.

    if (ipfd != plrc->iPixelFormat)
    {
        DBGERROR("wglMakeCurrent: different hdc and hrc pixel formats\n");
        SetLastError(ERROR_INVALID_PIXEL_FORMAT);
        goto wglMakeCurrent_error;
    }

// Since the client code manages the function table, we will make
// either the server or the driver current.

    if (!plrc->dhrc)
    {
// If this is a generic format, tell the server to make it current.

#ifndef _CLIENTSIDE_
// If the subbatch data has not been set up for this thread, set it up now.

        if (GLTEB_CLTSHAREDSECTIONINFO() == NULL)
        {
            if (!glsbCreateAndDuplicateSection(SHARED_SECTION_SIZE))
            {
                WARNING("wglMakeCurrent: unable to create section\n");
                goto wglMakeCurrent_error;
            }
        }
#endif // !_CLIENTSIDE_

        if (!__wglMakeCurrent(pgwid, hrcSrv, plrc->uiGlsCaptureContext != 0))
        {
            DBGERROR("wglMakeCurrent: server failed\n");
            goto wglMakeCurrent_error;
        }

// Get the generic function table or metafile function table

#ifdef GL_METAFILE
        if (plrc->fCapturing)
        {
            MetaGlProcTables(&pglProcTable, &pglExtProcTable);
        }
        else
#endif
        {
// Use RGBA or CI proc table depending on the color mode.

	    // The gc should be available by now.
	    __GL_SETUP();

	    if (gc->modes.colorIndexMode)
		pglProcTable = &glCltCIProcTable;
	    else
		pglProcTable = &glCltRGBAProcTable;
            pglExtProcTable = &glExtProcTable;
        }
    }
    else
    {
// If this is a device format, tell the driver to make it current.
// Get the driver function table from the driver.
// pfnDrvSetContext returns the address of the driver OpenGL function
// table if successful; NULL otherwise.

        ASSERTOPENGL(plrc->pGLDriver, "wglMakeCurrent: No GLDriver\n");

        pglProcTable = plrc->pGLDriver->pfnDrvSetContext(pgwid->hdc,
                                                         plrc->dhrc,
                                                         __wglSetProcTable);
        if (pglProcTable == (PGLCLTPROCTABLE) NULL)
        {
            DBGERROR("wglMakeCurrent: pfnDrvSetContext failed\n");
            goto wglMakeCurrent_error;
        }

// It must have either 306 entries for version 1.0 or 336 entries for 1.1

        if (pglProcTable->cEntries != OPENGL_VERSION_100_ENTRIES &&
            pglProcTable->cEntries != OPENGL_VERSION_110_ENTRIES)
        {
            DBGERROR("wglMakeCurrent: pfnDrvSetContext returned bad table\n");
            plrc->pGLDriver->pfnDrvReleaseContext(plrc->dhrc);
            SetLastError(ERROR_BAD_DRIVER);
            goto wglMakeCurrent_error;
        }

        DBGLEVEL1(LEVEL_INFO, "wglMakeCurrent: driver function table 0x%lx\n",
            pglProcTable);

        // Always use the null EXT proc table since client drivers don't
        // use opengl32's stubs for EXT procs
        pglExtProcTable = &glNullExtProcTable;
    }

// Make hrc current.

    plrc->tidCurrent = tidCurrent;
    plrc->gwidCurrent = *pgwid;
    GLTEB_SET_CLTCURRENTRC(plrc);
    SetCltProcTable(pglProcTable, pglExtProcTable, TRUE);

#ifdef GL_METAFILE
    // Set up metafile context if necessary
    if (plrc->fCapturing)
    {
        __GL_SETUP();
            
        ActivateMetaRc(plrc, pgwid->hdc);

        // Set the metafile's base dispatch table by resetting
        // the proc table.  Since we know we're capturing, this
        // will cause the GLS capture exec table to be updated
        // with the RGBA or CI proc table, preparing the
        // GLS context for correct passthrough
        
        if (gc->modes.colorIndexMode)
            pglProcTable = &glCltCIProcTable;
        else
            pglProcTable = &glCltRGBAProcTable;
        pglExtProcTable = &glExtProcTable;
        SetCltProcTable(pglProcTable, pglExtProcTable, FALSE);
    }
#endif

// Initialize polyarray structure in the TEB.

    pa = GLTEB_CLTPOLYARRAY();
    pa->flags = 0;		// not in begin mode
    if (!plrc->dhrc)
    {
	POLYMATERIAL *pm;
	__GL_SETUP();

	pa->pdBufferNext = &gc->vertex.pdBuf[0];
	pa->pdBuffer0    = &gc->vertex.pdBuf[0];
	pa->pdBufferMax  = &gc->vertex.pdBuf[gc->vertex.pdBufSize - 1];
	// reset next DPA message offset
        pa->nextMsgOffset = PA_nextMsgOffset_RESET_VALUE;

// Vertex buffer size may have changed.  For example, a generic gc's
// vertex buffer may be of a different size than a MCD vertex buffer.
// If it has changed, free the polymaterial array and realloc it later.

	pm = GLTEB_CLTPOLYMATERIAL();
	if (pm)
	{
	    if (pm->aMatSize !=
                gc->vertex.pdBufSize * 2 / POLYMATERIAL_ARRAY_SIZE + 1)
		FreePolyMaterial();
	}
    }

// Keep the handle locked while it is current.

    return(TRUE);

// An error has occured, release the current RC.

wglMakeCurrent_error:
    vUnlockHandle((ULONG_PTR)hrc);
wglMakeCurrent_error_nolock:
    if (GLTEB_CLTCURRENTRC() != (PLRC) NULL)
        (void) bMakeNoCurrent();
    return(FALSE);
}

/******************************Public*Routine******************************\
*
* WindowIdFromHdc
*
* Fills out a GLWINDOWID for an HDC
*
* History:
*  Wed Aug 28 18:33:19 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void APIENTRY WindowIdFromHdc(HDC hdc, GLWINDOWID *pgwid)
{
    LPDIRECTDRAWSURFACE pdds;
    HDC hdcDriver;

    if (pfnGetSurfaceFromDC != NULL &&
        pfnGetSurfaceFromDC(hdc, &pdds, &hdcDriver) == DD_OK)
    {
        // Release reference on the surface since this surface value
        // is only used as an identifier.
        pdds->lpVtbl->Release(pdds);
        
        pgwid->iType = GLWID_DDRAW;
        pgwid->hwnd = NULL;
        pgwid->hdc = hdcDriver;
        pgwid->pdds = pdds;
    }
    else
    {
        pgwid->hdc = hdc;
        pgwid->hwnd = WindowFromDC(hdc);
        if (pgwid->hwnd == NULL)
        {
            pgwid->iType = GLWID_HDC;
        }
        else
        {
            pgwid->iType = GLWID_HWND;
        }
        pgwid->pdds = NULL;
    }
}
    
/******************************Public*Routine******************************\
* wglMakeCurrent(HDC hdc, HGLRC hrc)
*
* Make the hrc current.
* Both hrc and hdc must have the same pixel format.
*
* If an error occurs, the current RC, if any, is made not current!
*
* Arguments:
*   hdc        - Device context.
*   hrc        - Rendering context.
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL WINAPI wglMakeCurrent(HDC hdc, HGLRC hrc)
{
    int   iPixelFormat;
    DWORD dwObjectType;
    GLWINDOWID gwid;

    DBGENTRY("wglMakeCurrent\n");

    if (GLTEB_CLTCURRENTRC() != NULL)
    {
        // Flush OpenGL calls.
        glFlush();

        // Avoid HDC validation for simple make-non-current cases
        if (hrc == NULL)
        {
            return bMakeNoCurrent();
        }
    }
    
// Validate the DC.

    dwObjectType = wglObjectType(hdc);
    switch (dwObjectType)
    {
    case OBJ_DC:
    case OBJ_MEMDC:
        break;

    case OBJ_ENHMETADC:
#ifdef GL_METAFILE
        if (pfnGdiAddGlsRecord == NULL)
        {
            DBGLEVEL1(LEVEL_ERROR, "wglMakeCurrent: metafile hdc: 0x%lx\n",
                      hdc);
            SetLastError(ERROR_INVALID_HANDLE);
            return FALSE;
        }
        break;
#else
        DBGLEVEL1(LEVEL_ERROR, "wglMakeCurrent: metafile hdc: 0x%lx\n", hdc);
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
#endif
        
    case OBJ_METADC:
    default:
        // 16-bit metafiles are not supported
        DBGLEVEL1(LEVEL_ERROR, "wglMakeCurrent: bad hdc: 0x%lx\n", hdc);
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (!CheckDeviceModes(hdc))
    {
        return FALSE;
    }
    
#ifdef GL_METAFILE
    // For metafile RC's, use the reference HDC rather than the
    // metafile DC
    // Skip pixel format checks
    if (dwObjectType == OBJ_ENHMETADC)
    {
        iPixelFormat = 0;
        goto NoPixelFormat;
    }
#endif
    
// Get the current pixel format of the window or surface.
// If no pixel format has been set, return error.

    if (!(iPixelFormat = GetPixelFormat(hdc)))
    {
        WARNING("wglMakeCurrent: No pixel format set in hdc\n");
        return FALSE;
    }

#ifdef GL_METAFILE
 NoPixelFormat:
#endif

    WindowIdFromHdc(hdc, &gwid);
    return MakeAnyCurrent(hrc, iPixelFormat, dwObjectType, &gwid);
}

/******************************Public*Routine******************************\
* bMakeNoCurrent
*
* Make the current RC inactive.
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL bMakeNoCurrent(void)
{
    BOOL bRet = FALSE;      // assume error
    PLRC plrc = GLTEB_CLTCURRENTRC();

    DBGENTRY("bMakeNoCurrent\n");

    ASSERTOPENGL(plrc != (PLRC) NULL, "bMakeNoCurrent: No current RC!\n");
    ASSERTOPENGL(plrc->tidCurrent == GetCurrentThreadId(),
        "bMakeNoCurrent: Current RC does not belong to this thread!\n");
    ASSERTOPENGL(plrc->gwidCurrent.iType != GLWID_ERROR,
                 "bMakeNoCurrent: Current surface is NULL!\n");

    if (!plrc->dhrc)
    {
#ifdef GL_METAFILE
        // Reset metafile context if necessary
        if (plrc->uiGlsCaptureContext != 0)
        {
            DeactivateMetaRc(plrc);
        }
#endif
        
// If this is a generic format, tell the server to make the current RC inactive.

        bRet = __wglMakeCurrent(NULL, NULL, FALSE);
        if (!bRet)
        {
            DBGERROR("bMakeNoCurrent: server failed\n");
        }
    }
    else
    {
// If this is a device format, tell the driver to make the current RC inactive.

        ASSERTOPENGL(plrc->pGLDriver, "wglMakeCurrent: No GLDriver\n");

        bRet = plrc->pGLDriver->pfnDrvReleaseContext(plrc->dhrc);
        if (!bRet)
        {
            DBGERROR("bMakeNoCurrent: pfnDrvReleaseContext failed\n");
        }
    }

// Always make the current RC inactive.
// The handle is also unlocked when the RC becomes inactive.

    plrc->tidCurrent = INVALID_THREAD_ID;
    plrc->gwidCurrent.iType = GLWID_ERROR;
    GLTEB_SET_CLTCURRENTRC(NULL);
    SetCltProcTable(&glNullCltProcTable, &glNullExtProcTable, TRUE);
    vUnlockHandle((ULONG_PTR)(plrc->hrc));
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\local.h ===
/******************************Module*Header*******************************\
* Module Name: local.h                                                     *
*                                                                          *
* Definitions needed for client side objects and attribute caching.        *
*                                                                          *
* Modified: 3-Aug-1992 22:35:30 by Gerrit van Wingerden [gerritv]          *
*   Added client side transform support.                                   *
*                                                                          *
* Created: 30-May-1991 21:55:01                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/

/**************************************************************************\
 *
 * Local handle macros
 *
\**************************************************************************/

// Handle uniqueness is nice to check but an unnecesary performance cost in
// a free build.

// To match the uniqness field:  If the handle uniqness == 0, let it through
// anyway.  This is a method for WOW to only keep track of the low 16 bits but
// still get reasonable performance.  Even if a 32 bit app does this, all it
// can do is hose it self, not the system or another app.

#define INDEX_MASK  0xFFFF
#define UNIQ_SHIFT  16
#define UNIQ_MASK   0xFFFF
#define HIPART(x) *(((USHORT *) &(x))+1)
#define MATCHUNIQ(plhe,h) ((USHORT) plhe->iUniq == HIPART(h))
#define MASKINDEX(h) ((UINT)((UINT_PTR)h & INDEX_MASK))
#define LHANDLE(i)  (i+((ULONG)pLocalTable[i].iUniq<<UNIQ_SHIFT))

//!!!XXX -- Do we really need typing?  Not really, but we may add more
//!!!XXX    later.  So eventually we might take it out, but its nice for now.

// Define the types of local objects.

enum LO_TYPE
{
    LO_NULL,
    LO_RC,
    LO_LAST
};

#define INVALID_INDEX 0xFFFFFFFFL
#define COMMIT_COUNT  (4096/sizeof(LHE))
#define MAX_HANDLES (16384/COMMIT_COUNT)*COMMIT_COUNT

// Define a Local Handle Entry.  Our Local Handle Table, pLocalTable, is an
// array of these.

typedef struct _LHE
{
    ULONG_PTR hgre;     // GRE Handle.
    USHORT cRef;        // Reference count of the object.
    BYTE   iType;       // Object type.
    BYTE   iUniq;       // Handle uniqueness field.  Always non-zero.
    PVOID  pv;          // Pointer to local object.
    ULONG  metalink;    // Non-zero if object is a "metafile friend".
                        // Points to a metafile DC object if it's a metafile.
                        // Also links the free list.
    DWORD  tidOwner;    // Per-thread lock owner.
    LONG   cLock;       // Lock count.
} LHE,*PLHE;

extern LHE                  *pLocalTable;   // Points to handle table.
extern ULONG                 iFreeLhe;      // Identifies a free handle index.
extern ULONG                 cLheCommitted; // Count of LHEs with committed RAM.
extern CRITICAL_SECTION      semLocal;      // Semaphore for handle allocation.
extern CRITICAL_SECTION      wfo_cs;        // Semaphore for wglUseFontOutlines


// Semaphore utilities

#define INITIALIZECRITICALSECTION(psem) InitializeCriticalSection((psem))
#define ENTERCRITICALSECTION(hsem)      EnterCriticalSection((hsem))
#define LEAVECRITICALSECTION(hsem)      LeaveCriticalSection((hsem))
#define DELETECRITICALSECTION(psem)     DeleteCriticalSection((psem))

// Local data structures

// Maximum OpenGL driver name

#define MAX_GLDRIVER_NAME   MAX_PATH

// GetCurrentThreadID will never return this value

#define INVALID_THREAD_ID   0

// Driver context function prototypes

typedef BOOL            (APIENTRY *PFN_DRVVALIDATEVERSION) (ULONG);
typedef VOID            (APIENTRY *PFN_DRVSETCALLBACKPROCS)(INT, PROC *);

// Driver flags.

// Driver wants buffer calls sent to ICD DLL rather than the display
// driver.  This is required on Win95.
#define GLDRIVER_CLIENT_BUFFER_CALLS    0x00000001

// Driver does not want glFinish called during swap.  Only
// applies to client swap calls.
#define GLDRIVER_NO_FINISH_ON_SWAP      0x00000002

// Driver had registry key rather than just registry value.
// This provides a way to check for new-style registry information.
#define GLDRIVER_FULL_REGISTRY          0x80000000

// Driver data

typedef struct _GLDRIVER {
    HINSTANCE             hModule;             // Module handle
    DWORD                 dwFlags;

    // Driver function pointers

    // Required
    DHGLRC          (APIENTRY *pfnDrvCreateContext)(HDC);
    BOOL            (APIENTRY *pfnDrvDeleteContext)(DHGLRC);
    PGLCLTPROCTABLE (APIENTRY *pfnDrvSetContext)(HDC, DHGLRC,
                                                 PFN_SETPROCTABLE);
    BOOL            (APIENTRY *pfnDrvReleaseContext)(DHGLRC);

    // Optional
    BOOL            (APIENTRY *pfnDrvCopyContext)(DHGLRC, DHGLRC, UINT);
    DHGLRC          (APIENTRY *pfnDrvCreateLayerContext)(HDC, int);
    BOOL            (APIENTRY *pfnDrvShareLists)(DHGLRC, DHGLRC);
    PROC            (APIENTRY *pfnDrvGetProcAddress)(LPCSTR);
    BOOL            (APIENTRY *pfnDrvDescribeLayerPlane)(HDC, INT, INT, UINT,
                                                      LPLAYERPLANEDESCRIPTOR);
    INT             (APIENTRY *pfnDrvSetLayerPaletteEntries)(HDC, INT, INT,
                                                             INT,
                                                             CONST COLORREF *);
    INT             (APIENTRY *pfnDrvGetLayerPaletteEntries)(HDC, INT, INT,
                                                             INT, COLORREF *);
    BOOL            (APIENTRY *pfnDrvRealizeLayerPalette)(HDC, INT, BOOL);
    BOOL            (APIENTRY *pfnDrvSwapLayerBuffers)(HDC, UINT);
    DHGLRC          (APIENTRY *pfnDrvCreateDirectDrawContext)
        (HDC, LPDIRECTDRAWSURFACE, int);
    int             (APIENTRY *pfnDrvEnumTextureFormats)(int, DDSURFACEDESC *);
    BOOL            (APIENTRY *pfnDrvBindDirectDrawTexture)
        (LPDIRECTDRAWSURFACE);
    DWORD           (APIENTRY *pfnDrvSwapMultipleBuffers)(UINT,
                                                          CONST WGLSWAP *);
    
    // The following functions are only called if driver asks for them.
    // This is required on Win95.
    LONG            (APIENTRY *pfnDrvDescribePixelFormat)(HDC, LONG, ULONG,
                                                      PIXELFORMATDESCRIPTOR *);
    BOOL            (APIENTRY *pfnDrvSetPixelFormat)(HDC, LONG);
    BOOL            (APIENTRY *pfnDrvSwapBuffers)(HDC);

    struct _GLDRIVER    *pGLDriver;            // Next loaded GL driver
    TCHAR tszDllName[MAX_GLDRIVER_NAME+1];     // Null terminated DLL name
} GLDRIVER, *PGLDRIVER;

extern PGLDRIVER APIENTRY pgldrvLoadInstalledDriver(HDC hdc);


/****************************************************************************/

void APIENTRY glDrawRangeElementsWIN( GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);

void APIENTRY glAddSwapHintRectWIN(IN GLint, IN GLint, IN GLint, IN GLint);

void glColorTableEXT( GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *data);
void glColorSubTableEXT( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
void glGetColorTableEXT( GLenum target, GLenum format, GLenum type, GLvoid *data);
void glGetColorTableParameterivEXT( GLenum target, GLenum pname, GLint *params);
void glGetColorTableParameterfvEXT( GLenum target, GLenum pname, GLfloat *params);
void APIENTRY glColorTableParameterivEXT(GLenum target,
                                         GLenum pname,
                                         const GLint *params);
void APIENTRY glColorTableParameterfvEXT(GLenum target,
                                         GLenum pname,
                                         const GLfloat *params);

#ifdef GL_WIN_multiple_textures
void APIENTRY glCurrentTextureIndexWIN
    (GLuint index);
void APIENTRY glMultiTexCoord1dWIN
    (GLbitfield mask, GLdouble s);
void APIENTRY glMultiTexCoord1dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glMultiTexCoord1fWIN
    (GLbitfield mask, GLfloat s);
void APIENTRY glMultiTexCoord1fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glMultiTexCoord1iWIN
    (GLbitfield mask, GLint s);
void APIENTRY glMultiTexCoord1ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glMultiTexCoord1sWIN
    (GLbitfield mask, GLshort s);
void APIENTRY glMultiTexCoord1svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glMultiTexCoord2dWIN
    (GLbitfield mask, GLdouble s, GLdouble t);
void APIENTRY glMultiTexCoord2dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glMultiTexCoord2fWIN
    (GLbitfield mask, GLfloat s, GLfloat t);
void APIENTRY glMultiTexCoord2fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glMultiTexCoord2iWIN
    (GLbitfield mask, GLint s, GLint t);
void APIENTRY glMultiTexCoord2ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glMultiTexCoord2sWIN
    (GLbitfield mask, GLshort s, GLshort t);
void APIENTRY glMultiTexCoord2svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glMultiTexCoord3dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r);
void APIENTRY glMultiTexCoord3dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glMultiTexCoord3fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r);
void APIENTRY glMultiTexCoord3fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glMultiTexCoord3iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r);
void APIENTRY glMultiTexCoord3ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glMultiTexCoord3sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r);
void APIENTRY glMultiTexCoord3svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glMultiTexCoord4dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
void APIENTRY glMultiTexCoord4dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glMultiTexCoord4fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
void APIENTRY glMultiTexCoord4fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glMultiTexCoord4iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r, GLint q);
void APIENTRY glMultiTexCoord4ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glMultiTexCoord4sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r, GLshort q);
void APIENTRY glMultiTexCoord4svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glBindNthTextureWIN
    (GLuint index, GLenum target, GLuint texture);
void APIENTRY glNthTexCombineFuncWIN
    (GLuint index,
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor);
#endif // GL_WIN_multiple_textures

/****************************************************************************/

// Local RC object

#define LRC_IDENTIFIER    0x2043524C    /* 'LRC ' */

typedef struct _LRC {
    DHGLRC    dhrc;             // Driver handle
    HGLRC     hrc;              // Client handle
    int       iPixelFormat;     // Pixel format index
    DWORD     ident;            // LRC_IDENTIFIER
    DWORD     tidCurrent;       // Thread id if the DC is current,
                                //   INVALID_THREAD_ID otherwise
    PGLDRIVER pGLDriver;        // Driver data
    GLWINDOWID gwidCurrent;     // Current surface ID
    GLWINDOWID gwidCreate;      // Creation surface ID

#ifdef GL_METAFILE
    GLuint    uiGlsCaptureContext;  // GLS capturing context for metafile RC's
    GLuint    uiGlsPlaybackContext; // GLS context for playback
    BOOL      fCapturing;       // GLS is in BeginCapture
    
    // GLS playback scaling factors
    int iGlsSubtractX;
    int iGlsSubtractY;
    int iGlsNumeratorX;
    int iGlsNumeratorY;
    int iGlsDenominatorX;
    int iGlsDenominatorY;
    int iGlsAddX;
    int iGlsAddY;
    GLfloat fGlsScaleX;
    GLfloat fGlsScaleY;
#endif

    GLubyte *pszExtensions;

#ifdef GL_METAFILE
    XFORM xformMeta;            // World transform storage during GLS blocks
    LPRECTL prclGlsBounds;      // Bounds during GLS recording
#endif
    
    struct _DDSURFACEDESC *pddsdTexFormats;
    int nDdTexFormats;
} LRC, *PLRC;

// Various dispatch tables available
extern GLCLTPROCTABLE glNullCltProcTable;
extern GLCLTPROCTABLE glCltRGBAProcTable;
extern GLCLTPROCTABLE glCltCIProcTable;
extern GLEXTPROCTABLE glNullExtProcTable;
extern GLEXTPROCTABLE glExtProcTable;
#ifdef GL_METAFILE
extern GLCLTPROCTABLE gcptGlsProcTable;
extern GLEXTPROCTABLE geptGlsExtProcTable;
#endif

// Declare support functions.

ULONG   iAllocHandle(ULONG iType,ULONG hgre,PVOID pv);
VOID    vFreeHandle(ULONG_PTR h);
LONG    cLockHandle(ULONG_PTR h);
VOID    vUnlockHandle(ULONG_PTR h);
VOID    vCleanupAllLRC(VOID);
VOID    vFreeLRC(PLRC plrc);

BOOL    bMakeNoCurrent(void);

VOID GLInitializeThread(ULONG ulReason);

// Macro to call glFlush only if a RC is current.
#define GLFLUSH()          if (GLTEB_CLTCURRENTRC()) glFlush()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\metasup.c ===
/******************************Module*Header*******************************\
* Module Name: metasup.c
*
* OpenGL metafile support
*
* History:
*  Thu Feb 23 15:27:47 1995	-by-	Drew Bliss [drewb]
*   Created
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ntpsapi.h>
#include <wingdip.h>

#include "global.h"
#include <glgenwin.h>

#include "metasup.h"

#if defined(GL_METAFILE)

#include <glmf.h>
#include <encoding.h>

GLCLTPROCTABLE gcptGlsProcTable;
GLEXTPROCTABLE geptGlsExtProcTable;

// Functions in GL which we will do device coordinate translation for
typedef struct _GLDEVICEPROCS
{
    void (APIENTRY *glBitmap)(GLsizei width, GLsizei height,
                              GLfloat xorig, GLfloat yorig,
                              GLfloat xmove, GLfloat ymove,
                              const GLubyte *bitmap);
    void (APIENTRY *glCopyPixels)(GLint x, GLint y,
                                  GLsizei width, GLsizei height,
                                  GLenum type);
    void (APIENTRY *glCopyTexImage1D)(GLenum target, GLint level,
                                      GLenum internalformat,
                                      GLint x, GLint y,
                                      GLsizei width, GLint border);
    void (APIENTRY *glCopyTexImage2D)(GLenum target, GLint level,
                                      GLenum internalformat,
                                      GLint x, GLint y,
                                      GLsizei width, GLsizei height,
                                      GLint border);
    void (APIENTRY *glCopyTexSubImage1D)(GLenum target, GLint level,
                                         GLint xoffset, GLint x, GLint y,
                                         GLsizei width);
    void (APIENTRY *glCopyTexSubImage2D)(GLenum target, GLint level,
                                         GLint xoffset, GLint yoffset,
                                         GLint x, GLint y,
                                         GLsizei width, GLsizei height);
    void (APIENTRY *glDrawPixels)(GLsizei width, GLsizei height,
                                  GLenum format, GLenum type,
                                  const GLvoid *pixels);
    void (APIENTRY *glLineWidth)(GLfloat width);
    void (APIENTRY *glPointSize)(GLfloat size);
    void (APIENTRY *glScissor)(GLint x, GLint y,
                               GLsizei width, GLsizei height);
    void (APIENTRY *glViewport)(GLint x, GLint y,
                                GLsizei w, GLsizei h);
} GLDEVICEPROCS;
#define GL_DEVICE_PROCS (sizeof(GLDEVICEPROCS)/sizeof(PROC))

// Opcode for device procs
static GLSopcode glsopDeviceProcs[GL_DEVICE_PROCS] =
{
    GLS_OP_glBitmap,
    GLS_OP_glCopyPixels,
    GLS_OP_glCopyTexImage1D,
    GLS_OP_glCopyTexImage2D,
    GLS_OP_glCopyTexSubImage1D,
    GLS_OP_glCopyTexSubImage2D,
    GLS_OP_glDrawPixels,
    GLS_OP_glLineWidth,
    GLS_OP_glPointSize,
    GLS_OP_glScissor,
    GLS_OP_glViewport
};

static GLDEVICEPROCS gdpGlsActual;

/*****************************Private*Routine******************************\
*
* GLS recording callbacks
*
* Perfoms any necessary work when capturing a call
*
* History:
*  Mon Mar 27 14:21:09 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void GlsBitmapIn(GLsizei width, GLsizei height,
                 GLfloat xorig, GLfloat yorig,
                 GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
{
    PLRC plrc;
    RECTL rcl;

    plrc = GLTEB_CLTCURRENTRC();
    ASSERTOPENGL(plrc != NULL, "GlsBitmapIn: No current RC!\n");

    // Record bounds for the bitmap
    rcl.left = 0;
    rcl.top = 0;
    rcl.right = width;
    rcl.bottom = height;
    plrc->prclGlsBounds = &rcl;

    gdpGlsActual.glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap);

    plrc->prclGlsBounds = NULL;
}

void GlsDrawPixelsIn(GLsizei width, GLsizei height,
                     GLenum format, GLenum type,
                     const GLvoid *pixels)
{
    PLRC plrc;
    RECTL rcl;

    plrc = GLTEB_CLTCURRENTRC();
    ASSERTOPENGL(plrc != NULL, "GlsBitmapIn: No current RC!\n");

    // Record bounds for the bitmap
    rcl.left = 0;
    rcl.top = 0;
    rcl.right = width;
    rcl.bottom = height;
    plrc->prclGlsBounds = &rcl;

    gdpGlsActual.glDrawPixels(width, height, format, type, pixels);

    plrc->prclGlsBounds = NULL;
}

void GlsViewportIn(GLint x, GLint y, GLsizei width, GLsizei height)
{
    RECTL rcl;
    PLRC plrc;
    
    plrc = GLTEB_CLTCURRENTRC();
    ASSERTOPENGL(plrc != NULL, "GlsViewportIn: No current RC!\n");
    
    // Send the bounds on
    // The rect is inclusive-exclusive while the incoming parameters
    // are inclusive-inclusive
    rcl.left = x;
    rcl.right = x+width+1;
    rcl.top = y;
    rcl.bottom = y+height+1;
    if (!GlGdiAddGlsBounds(plrc->gwidCreate.hdc, &rcl))
    {
        ASSERTOPENGL(FALSE, "GdiAddGlsBounds failed");
    }

    gdpGlsActual.glViewport(x, y, width, height);
}

// glViewport is the only device-dependent function that we need to
// do work for on input
static GLDEVICEPROCS gdpInput =
{
    GlsBitmapIn,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    GlsDrawPixelsIn,
    NULL,
    NULL,
    NULL,
    GlsViewportIn
};

/*****************************Private*Routine******************************\
*
* MetaLoadGls
*
* Loads glmf32.dll for metafile use
*
* History:
*  Thu Feb 23 17:40:59 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

static char *pszGlsEntryPoints[] =
{
    "glsBeginCapture",
    "glsBinary",
    "glsCallArrayInContext",
    "glsCaptureFlags",
    "glsCaptureFunc",
    "glsCommandFunc",
    "glsContext",
    "glsDeleteContext",
    "glsEndCapture",
    "glsFlush",
    "glsGenContext",
    "glsGetCaptureDispatchTable",
    "glsGetCaptureExecTable",
    "glsGetCommandAlignment",
    "glsGetCurrentContext",
    "glsUpdateCaptureExecTable",
    "glsWriteFunc",
    "glsBeginGLS",
    "glsBlock",
    "glsCallStream",
    "glsEndGLS",
    "glsError",
    "glsGLRC",
    "glsGLRCLayer",
    "glsHeaderGLRCi",
    "glsHeaderLayerf",
    "glsHeaderLayeri",
    "glsHeaderf",
    "glsHeaderfv",
    "glsHeaderi",
    "glsHeaderiv",
    "glsHeaderubz",
    "glsRequireExtension",
    "glsUnsupportedCommand",
    "glsAppRef",
    "glsBeginObj",
    "glsCharubz",
    "glsComment",
    "glsDisplayMapfv",
    "glsEndObj",
    "glsNumb",
    "glsNumbv",
    "glsNumd",
    "glsNumdv",
    "glsNumf",
    "glsNumfv",
    "glsNumi",
    "glsNumiv",
    "glsNuml",
    "glsNumlv",
    "glsNums",
    "glsNumsv",
    "glsNumub",
    "glsNumubv",
    "glsNumui",
    "glsNumuiv",
    "glsNumul",
    "glsNumulv",
    "glsNumus",
    "glsNumusv",
    "glsPad",
    "glsSwapBuffers"
};
#define GLS_ENTRY_POINT_STRINGS (sizeof(pszGlsEntryPoints)/sizeof(char *))

typedef struct _GLSENTRYPOINTS
{
    GLboolean (APIENTRY *glsBeginCapture)(const GLubyte *, GLSenum,
                                          GLbitfield);
    GLSenum   (APIENTRY *glsBinary)(GLboolean);
    void      (APIENTRY *glsCallArrayInContext)(GLuint, GLSenum, size_t,
                                                const GLubyte *);
    void      (APIENTRY *glsCaptureFlags)(GLSopcode, GLbitfield);
    void      (APIENTRY *glsCaptureFunc)(GLSenum, GLScaptureFunc);
    void      (APIENTRY *glsCommandFunc)(GLSopcode, GLSfunc);
    void      (APIENTRY *glsContext)(GLuint);
    void      (APIENTRY *glsDeleteContext)(GLuint);
    void      (APIENTRY *glsEndCapture)(void);
    void      (APIENTRY *glsFlush)(GLSenum);
    GLuint    (APIENTRY *glsGenContext)(void);
    void      (APIENTRY *glsGetCaptureDispatchTable)(GLCLTPROCTABLE *,
                                                     GLEXTPROCTABLE *);
    void      (APIENTRY *glsGetCaptureExecTable)(GLCLTPROCTABLE *,
                                                 GLEXTPROCTABLE *);
    GLScommandAlignment *
              (APIENTRY *glsGetCommandAlignment)(GLSopcode, GLSenum,
                                                 GLScommandAlignment *);
    GLuint    (APIENTRY *glsGetCurrentContext)(void);
    void      (APIENTRY *glsUpdateCaptureExecTable)(GLCLTPROCTABLE *,
                                                    GLEXTPROCTABLE *);
    void      (APIENTRY *glsWriteFunc)(GLSwriteFunc);

    // The following are only used in glsCommandFunc and so don't
    // require real prototypes
    GLSfunc glsBeginGLS;
    GLSfunc glsBlock;
    GLSfunc glsCallStream;
    GLSfunc glsEndGLS;
    GLSfunc glsError;
    GLSfunc glsGLRC;
    GLSfunc glsGLRCLayer;
    GLSfunc glsHeaderGLRCi;
    GLSfunc glsHeaderLayerf;
    GLSfunc glsHeaderLayeri;
    GLSfunc glsHeaderf;
    GLSfunc glsHeaderfv;
    GLSfunc glsHeaderi;
    GLSfunc glsHeaderiv;
    GLSfunc glsHeaderubz;
    GLSfunc glsRequireExtension;
    GLSfunc glsUnsupportedCommand;
    GLSfunc glsAppRef;
    GLSfunc glsBeginObj;
    GLSfunc glsCharubz;
    GLSfunc glsComment;
    GLSfunc glsDisplayMapfv;
    GLSfunc glsEndObj;
    GLSfunc glsNumb;
    GLSfunc glsNumbv;
    GLSfunc glsNumd;
    GLSfunc glsNumdv;
    GLSfunc glsNumf;
    GLSfunc glsNumfv;
    GLSfunc glsNumi;
    GLSfunc glsNumiv;
    GLSfunc glsNuml;
    GLSfunc glsNumlv;
    GLSfunc glsNums;
    GLSfunc glsNumsv;
    GLSfunc glsNumub;
    GLSfunc glsNumubv;
    GLSfunc glsNumui;
    GLSfunc glsNumuiv;
    GLSfunc glsNumul;
    GLSfunc glsNumulv;
    GLSfunc glsNumus;
    GLSfunc glsNumusv;
    GLSfunc glsPad;
    GLSfunc glsSwapBuffers;
} GLSENTRYPOINTS;
#define GLS_ENTRY_POINTS (sizeof(GLSENTRYPOINTS)/sizeof(void *))

static GLSENTRYPOINTS gepGlsFuncs = {NULL};
static HMODULE hGlsDll = NULL;

BOOL MetaLoadGls(void)
{
    HMODULE hdll;
    BOOL bRet = FALSE;
    GLSENTRYPOINTS gep;
    PROC *ppfn, *ppfnActual, *ppfnInput;
    GLSfunc *pgfnNormal, *pgfnExt;
    int i;
    
    ASSERTOPENGL(GLS_ENTRY_POINT_STRINGS == GLS_ENTRY_POINTS,
                 "GLS entry point strings/pointers mismatch\n");
    
    ENTERCRITICALSECTION(&semLocal);

    if (hGlsDll != NULL)
    {
        bRet = TRUE;
        goto Exit;
    }

    hdll = LoadLibrary(__TEXT("glmf32.dll"));
    if (hdll == NULL)
    {
        WARNING1("Unable to load glmf32.dll, %d\n", GetLastError());
        goto Exit;
    }
    
    ppfn = (PROC *)&gep;
    for (i = 0; i < GLS_ENTRY_POINTS; i++)
    {
        if (!(*ppfn = GetProcAddress(hdll, pszGlsEntryPoints[i])))
        {
            WARNING1("glmf32.dll is missing '%s'\n", pszGlsEntryPoints[i]);
            FreeLibrary(hdll);
            goto Exit;
        }
        
        ppfn++;
    }

    // The table copied out is constant as long as the DLL is loaded
    gep.glsGetCaptureDispatchTable(&gcptGlsProcTable, &geptGlsExtProcTable);
    
    // Patch the table for certain functions to allow us to
    // do some coordinate conversion and bounds accumlation
    ppfnActual = (PROC *)&gdpGlsActual;
    ppfnInput = (PROC *)&gdpInput;
    for (i = 0; i < GL_DEVICE_PROCS; i++)
    {
        if (*ppfnInput != NULL)
        {
            ppfn = ((PROC *)&gcptGlsProcTable.glDispatchTable)+
                glsopDeviceProcs[i]-GLS_OP_glNewList;
            *ppfnActual = *ppfn;
            *ppfn = *ppfnInput;
        }

        ppfnActual++;
        ppfnInput++;
    }
    
    gepGlsFuncs = gep;
    hGlsDll = hdll;
    bRet = TRUE;
    
 Exit:
    LEAVECRITICALSECTION(&semLocal);
    return bRet;
}

/*****************************Private*Routine******************************\
*
* MetaGlProcTables
*
* Returns the GL dispatch tables to use for metafile RC's
*
* History:
*  Thu Feb 23 17:40:25 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void MetaGlProcTables(PGLCLTPROCTABLE *ppgcpt, PGLEXTPROCTABLE *ppgept)
{
    ASSERTOPENGL(hGlsDll != NULL, "MetaGlProcTables: GLS not loaded\n");
    *ppgcpt = &gcptGlsProcTable;
    *ppgept = &geptGlsExtProcTable;
}

/******************************Public*Routine******************************\
*
* MetaSetCltProcTable
*
* Update GLS's generic dispatch tables
*
* History:
*  Fri Jan 05 16:40:31 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void MetaSetCltProcTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept)
{
    gepGlsFuncs.glsUpdateCaptureExecTable(pgcpt, pgept);
}

/******************************Public*Routine******************************\
*
* MetaGetCltProcTable
*
* Retrieves GLS's generic dispatch tables
*
* History:
*  Fri Jan 05 19:14:18 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void MetaGetCltProcTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept)
{
    gepGlsFuncs.glsGetCaptureExecTable(pgcpt, pgept);
}

/*****************************Private*Routine******************************\
*
* GlsWriter
*
* GLS write function for metafile support
*
* History:
*  Thu Feb 23 15:49:03 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

size_t GlsWriter(size_t cb, CONST BYTE *pb)
{
    PLRC plrc;

#if 0
    DbgPrint("GlsWriter(%d)\n", cb);
#endif
    
    plrc = GLTEB_CLTCURRENTRC();
    if( plrc == NULL ) 
    {
        DBGERROR( "GlsWriter: No current RC!\n");
        return 0;
    }
    
    ASSERTOPENGL(plrc->gwidCreate.hdc != NULL,
                 "GlsWriter: hdcCreate is NULL\n");
    ASSERTOPENGL(gepGlsFuncs.glsGetCurrentContext() ==
                 plrc->uiGlsCaptureContext,
                 "GlsWriter: Wrong GLS context\n");
    ASSERTOPENGL(plrc->fCapturing == TRUE,
                 "GlsWriter: Not capturing\n");

    if (GlGdiAddGlsRecord(plrc->gwidCreate.hdc,
                          cb, (BYTE *)pb, plrc->prclGlsBounds))
    {
        return cb;
    }
    else
    {
        return 0;
    }
}

/*****************************Private*Routine******************************\
*
* GlsFlush
*
* Post-command GLS callback to flush the GLS stream
*
* History:
*  Fri Feb 24 10:12:49 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void GlsFlush(GLSopcode op)
{
    gepGlsFuncs.glsFlush(GLS_LAST);
}

/*****************************Private*Routine******************************\
*
* MetaRcBegin
*
* Start capturing on a metafile
*
* History:
*  Thu Feb 23 18:35:32 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL MetaRcBegin(PLRC plrc, HDC hdc)
{
    PLRC plrcOld;

    // The GLS commands here will cause data to be written, which
    // requires a current RC.  The RC is only used for data storage
    // so we don't need to set the proc table
    plrcOld = GLTEB_CLTCURRENTRC();
    GLTEB_SET_CLTCURRENTRC(plrc);
    
    // Set capturing first because the block commands will cause
    // GlsWriter calls
    plrc->fCapturing = TRUE;

    // Start recording
    if (!gepGlsFuncs.glsBeginCapture("", gepGlsFuncs.glsBinary(GL_FALSE),
                                     GLS_NONE))
    {
        plrc->fCapturing = FALSE;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        GLTEB_SET_CLTCURRENTRC(plrcOld);
        return FALSE;
    }

    GLTEB_SET_CLTCURRENTRC(plrcOld);
    
    return TRUE;
}

/*****************************Private*Routine******************************\
*
* MetaRcEnd
*
* Stop capturing on a metafile RC
*
* History:
*  Thu Feb 23 17:13:48 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void MetaRcEnd(PLRC plrc)
{
    PLRC plrcOld;
    
    // The GLS commands here will cause data to be written, which
    // requires a current RC.  The RC is only used for data storage
    // so we don't need to set the proc table
    plrcOld = GLTEB_CLTCURRENTRC();
    GLTEB_SET_CLTCURRENTRC(plrc);
    
    gepGlsFuncs.glsEndCapture();
    
    plrc->fCapturing = FALSE;
    
    GLTEB_SET_CLTCURRENTRC(plrcOld);
}

// Table of operations which GLS should execute when capturing
// in order to return information
// Currently all of them are in the list
//          Should we attempt to do only the critical calls?
static GLSopcode opExecuteBits[] =
{
    GLS_OP_glAccum,
    GLS_OP_glAlphaFunc,
    GLS_OP_glAreTexturesResidentEXT,
    GLS_OP_glArrayElementEXT,
    GLS_OP_glBegin,
    GLS_OP_glBindTextureEXT,
    GLS_OP_glBitmap,
    GLS_OP_glBlendColorEXT,
    GLS_OP_glBlendEquationEXT,
    GLS_OP_glBlendFunc,
    GLS_OP_glCallList,
    GLS_OP_glCallLists,
    GLS_OP_glClear,
    GLS_OP_glClearAccum,
    GLS_OP_glClearColor,
    GLS_OP_glClearDepth,
    GLS_OP_glClearIndex,
    GLS_OP_glClearStencil,
    GLS_OP_glClipPlane,
    GLS_OP_glColor3b,
    GLS_OP_glColor3bv,
    GLS_OP_glColor3d,
    GLS_OP_glColor3dv,
    GLS_OP_glColor3f,
    GLS_OP_glColor3fv,
    GLS_OP_glColor3i,
    GLS_OP_glColor3iv,
    GLS_OP_glColor3s,
    GLS_OP_glColor3sv,
    GLS_OP_glColor3ub,
    GLS_OP_glColor3ubv,
    GLS_OP_glColor3ui,
    GLS_OP_glColor3uiv,
    GLS_OP_glColor3us,
    GLS_OP_glColor3usv,
    GLS_OP_glColor4b,
    GLS_OP_glColor4bv,
    GLS_OP_glColor4d,
    GLS_OP_glColor4dv,
    GLS_OP_glColor4f,
    GLS_OP_glColor4fv,
    GLS_OP_glColor4i,
    GLS_OP_glColor4iv,
    GLS_OP_glColor4s,
    GLS_OP_glColor4sv,
    GLS_OP_glColor4ub,
    GLS_OP_glColor4ubv,
    GLS_OP_glColor4ui,
    GLS_OP_glColor4uiv,
    GLS_OP_glColor4us,
    GLS_OP_glColor4usv,
    GLS_OP_glColorMask,
    GLS_OP_glColorMaterial,
    GLS_OP_glColorPointerEXT,
    GLS_OP_glColorSubTableEXT,
    GLS_OP_glDrawRangeElementsWIN,
    GLS_OP_glColorTableParameterfvSGI,
    GLS_OP_glColorTableParameterivSGI,
    GLS_OP_glColorTableEXT,
    GLS_OP_glConvolutionFilter1DEXT,
    GLS_OP_glConvolutionFilter2DEXT,
    GLS_OP_glConvolutionParameterfEXT,
    GLS_OP_glConvolutionParameterfvEXT,
    GLS_OP_glConvolutionParameteriEXT,
    GLS_OP_glConvolutionParameterivEXT,
    GLS_OP_glCopyColorTableSGI,
    GLS_OP_glCopyConvolutionFilter1DEXT,
    GLS_OP_glCopyConvolutionFilter2DEXT,
    GLS_OP_glCopyPixels,
    GLS_OP_glCopyTexImage1DEXT,
    GLS_OP_glCopyTexImage2DEXT,
    GLS_OP_glCopyTexSubImage1DEXT,
    GLS_OP_glCopyTexSubImage2DEXT,
    GLS_OP_glCopyTexSubImage3DEXT,
    GLS_OP_glCullFace,
    GLS_OP_glDeleteLists,
    GLS_OP_glDeleteTexturesEXT,
    GLS_OP_glDepthFunc,
    GLS_OP_glDepthMask,
    GLS_OP_glDepthRange,
    GLS_OP_glDetailTexFuncSGIS,
    GLS_OP_glDisable,
    GLS_OP_glDrawArraysEXT,
    GLS_OP_glDrawBuffer,
    GLS_OP_glDrawPixels,
    GLS_OP_glEdgeFlag,
    GLS_OP_glEdgeFlagPointerEXT,
    GLS_OP_glEdgeFlagv,
    GLS_OP_glEnable,
    GLS_OP_glEnd,
    GLS_OP_glEndList,
    GLS_OP_glEvalCoord1d,
    GLS_OP_glEvalCoord1dv,
    GLS_OP_glEvalCoord1f,
    GLS_OP_glEvalCoord1fv,
    GLS_OP_glEvalCoord2d,
    GLS_OP_glEvalCoord2dv,
    GLS_OP_glEvalCoord2f,
    GLS_OP_glEvalCoord2fv,
    GLS_OP_glEvalMesh1,
    GLS_OP_glEvalMesh2,
    GLS_OP_glEvalPoint1,
    GLS_OP_glEvalPoint2,
    GLS_OP_glFeedbackBuffer,
    GLS_OP_glFinish,
    GLS_OP_glFlush,
    GLS_OP_glFogf,
    GLS_OP_glFogfv,
    GLS_OP_glFogi,
    GLS_OP_glFogiv,
    GLS_OP_glFrontFace,
    GLS_OP_glFrustum,
    GLS_OP_glGenLists,
    GLS_OP_glGenTexturesEXT,
    GLS_OP_glGetBooleanv,
    GLS_OP_glGetClipPlane,
    GLS_OP_glGetColorTableParameterfvEXT,
    GLS_OP_glGetColorTableParameterivEXT,
    GLS_OP_glGetColorTableEXT,
    GLS_OP_glGetConvolutionFilterEXT,
    GLS_OP_glGetConvolutionParameterfvEXT,
    GLS_OP_glGetConvolutionParameterivEXT,
    GLS_OP_glGetDetailTexFuncSGIS,
    GLS_OP_glGetDoublev,
    GLS_OP_glGetError,
    GLS_OP_glGetFloatv,
    GLS_OP_glGetHistogramEXT,
    GLS_OP_glGetHistogramParameterfvEXT,
    GLS_OP_glGetHistogramParameterivEXT,
    GLS_OP_glGetIntegerv,
    GLS_OP_glGetLightfv,
    GLS_OP_glGetLightiv,
    GLS_OP_glGetMapdv,
    GLS_OP_glGetMapfv,
    GLS_OP_glGetMapiv,
    GLS_OP_glGetMaterialfv,
    GLS_OP_glGetMaterialiv,
    GLS_OP_glGetMinmaxEXT,
    GLS_OP_glGetMinmaxParameterfvEXT,
    GLS_OP_glGetMinmaxParameterivEXT,
    GLS_OP_glGetPixelMapfv,
    GLS_OP_glGetPixelMapuiv,
    GLS_OP_glGetPixelMapusv,
    GLS_OP_glGetPointervEXT,
    GLS_OP_glGetPolygonStipple,
    GLS_OP_glGetSeparableFilterEXT,
    GLS_OP_glGetSharpenTexFuncSGIS,
    GLS_OP_glGetString,
    GLS_OP_glGetTexColorTableParameterfvSGI,
    GLS_OP_glGetTexColorTableParameterivSGI,
    GLS_OP_glGetTexEnvfv,
    GLS_OP_glGetTexEnviv,
    GLS_OP_glGetTexGendv,
    GLS_OP_glGetTexGenfv,
    GLS_OP_glGetTexGeniv,
    GLS_OP_glGetTexImage,
    GLS_OP_glGetTexLevelParameterfv,
    GLS_OP_glGetTexLevelParameteriv,
    GLS_OP_glGetTexParameterfv,
    GLS_OP_glGetTexParameteriv,
    GLS_OP_glHint,
    GLS_OP_glHistogramEXT,
    GLS_OP_glIndexMask,
    GLS_OP_glIndexPointerEXT,
    GLS_OP_glIndexd,
    GLS_OP_glIndexdv,
    GLS_OP_glIndexf,
    GLS_OP_glIndexfv,
    GLS_OP_glIndexi,
    GLS_OP_glIndexiv,
    GLS_OP_glIndexs,
    GLS_OP_glIndexsv,
    GLS_OP_glInitNames,
    GLS_OP_glIsEnabled,
    GLS_OP_glIsList,
    GLS_OP_glIsTextureEXT,
    GLS_OP_glLightModelf,
    GLS_OP_glLightModelfv,
    GLS_OP_glLightModeli,
    GLS_OP_glLightModeliv,
    GLS_OP_glLightf,
    GLS_OP_glLightfv,
    GLS_OP_glLighti,
    GLS_OP_glLightiv,
    GLS_OP_glLineStipple,
    GLS_OP_glLineWidth,
    GLS_OP_glListBase,
    GLS_OP_glLoadIdentity,
    GLS_OP_glLoadMatrixd,
    GLS_OP_glLoadMatrixf,
    GLS_OP_glLoadName,
    GLS_OP_glLogicOp,
    GLS_OP_glMap1d,
    GLS_OP_glMap1f,
    GLS_OP_glMap2d,
    GLS_OP_glMap2f,
    GLS_OP_glMapGrid1d,
    GLS_OP_glMapGrid1f,
    GLS_OP_glMapGrid2d,
    GLS_OP_glMapGrid2f,
    GLS_OP_glMaterialf,
    GLS_OP_glMaterialfv,
    GLS_OP_glMateriali,
    GLS_OP_glMaterialiv,
    GLS_OP_glMatrixMode,
    GLS_OP_glMinmaxEXT,
    GLS_OP_glMultMatrixd,
    GLS_OP_glMultMatrixf,
    GLS_OP_glNewList,
    GLS_OP_glNormal3b,
    GLS_OP_glNormal3bv,
    GLS_OP_glNormal3d,
    GLS_OP_glNormal3dv,
    GLS_OP_glNormal3f,
    GLS_OP_glNormal3fv,
    GLS_OP_glNormal3i,
    GLS_OP_glNormal3iv,
    GLS_OP_glNormal3s,
    GLS_OP_glNormal3sv,
    GLS_OP_glNormalPointerEXT,
    GLS_OP_glOrtho,
    GLS_OP_glPassThrough,
    GLS_OP_glPixelMapfv,
    GLS_OP_glPixelMapuiv,
    GLS_OP_glPixelMapusv,
    GLS_OP_glPixelStoref,
    GLS_OP_glPixelStorei,
    GLS_OP_glPixelTexGenSGIX,
    GLS_OP_glPixelTransferf,
    GLS_OP_glPixelTransferi,
    GLS_OP_glPixelZoom,
    GLS_OP_glPointSize,
    GLS_OP_glPolygonMode,
    GLS_OP_glPolygonOffsetEXT,
    GLS_OP_glPolygonStipple,
    GLS_OP_glPopAttrib,
    GLS_OP_glPopMatrix,
    GLS_OP_glPopName,
    GLS_OP_glPrioritizeTexturesEXT,
    GLS_OP_glPushAttrib,
    GLS_OP_glPushMatrix,
    GLS_OP_glPushName,
    GLS_OP_glRasterPos2d,
    GLS_OP_glRasterPos2dv,
    GLS_OP_glRasterPos2f,
    GLS_OP_glRasterPos2fv,
    GLS_OP_glRasterPos2i,
    GLS_OP_glRasterPos2iv,
    GLS_OP_glRasterPos2s,
    GLS_OP_glRasterPos2sv,
    GLS_OP_glRasterPos3d,
    GLS_OP_glRasterPos3dv,
    GLS_OP_glRasterPos3f,
    GLS_OP_glRasterPos3fv,
    GLS_OP_glRasterPos3i,
    GLS_OP_glRasterPos3iv,
    GLS_OP_glRasterPos3s,
    GLS_OP_glRasterPos3sv,
    GLS_OP_glRasterPos4d,
    GLS_OP_glRasterPos4dv,
    GLS_OP_glRasterPos4f,
    GLS_OP_glRasterPos4fv,
    GLS_OP_glRasterPos4i,
    GLS_OP_glRasterPos4iv,
    GLS_OP_glRasterPos4s,
    GLS_OP_glRasterPos4sv,
    GLS_OP_glReadBuffer,
    GLS_OP_glReadPixels,
    GLS_OP_glRectd,
    GLS_OP_glRectdv,
    GLS_OP_glRectf,
    GLS_OP_glRectfv,
    GLS_OP_glRecti,
    GLS_OP_glRectiv,
    GLS_OP_glRects,
    GLS_OP_glRectsv,
    GLS_OP_glRenderMode,
    GLS_OP_glResetHistogramEXT,
    GLS_OP_glResetMinmaxEXT,
    GLS_OP_glRotated,
    GLS_OP_glRotatef,
    GLS_OP_glSampleMaskSGIS,
    GLS_OP_glSamplePatternSGIS,
    GLS_OP_glScaled,
    GLS_OP_glScalef,
    GLS_OP_glScissor,
    GLS_OP_glSelectBuffer,
    GLS_OP_glSeparableFilter2DEXT,
    GLS_OP_glShadeModel,
    GLS_OP_glSharpenTexFuncSGIS,
    GLS_OP_glStencilFunc,
    GLS_OP_glStencilMask,
    GLS_OP_glStencilOp,
    GLS_OP_glTagSampleBufferSGIX,
    GLS_OP_glTexColorTableParameterfvSGI,
    GLS_OP_glTexColorTableParameterivSGI,
    GLS_OP_glTexCoord1d,
    GLS_OP_glTexCoord1dv,
    GLS_OP_glTexCoord1f,
    GLS_OP_glTexCoord1fv,
    GLS_OP_glTexCoord1i,
    GLS_OP_glTexCoord1iv,
    GLS_OP_glTexCoord1s,
    GLS_OP_glTexCoord1sv,
    GLS_OP_glTexCoord2d,
    GLS_OP_glTexCoord2dv,
    GLS_OP_glTexCoord2f,
    GLS_OP_glTexCoord2fv,
    GLS_OP_glTexCoord2i,
    GLS_OP_glTexCoord2iv,
    GLS_OP_glTexCoord2s,
    GLS_OP_glTexCoord2sv,
    GLS_OP_glTexCoord3d,
    GLS_OP_glTexCoord3dv,
    GLS_OP_glTexCoord3f,
    GLS_OP_glTexCoord3fv,
    GLS_OP_glTexCoord3i,
    GLS_OP_glTexCoord3iv,
    GLS_OP_glTexCoord3s,
    GLS_OP_glTexCoord3sv,
    GLS_OP_glTexCoord4d,
    GLS_OP_glTexCoord4dv,
    GLS_OP_glTexCoord4f,
    GLS_OP_glTexCoord4fv,
    GLS_OP_glTexCoord4i,
    GLS_OP_glTexCoord4iv,
    GLS_OP_glTexCoord4s,
    GLS_OP_glTexCoord4sv,
    GLS_OP_glTexCoordPointerEXT,
    GLS_OP_glTexEnvf,
    GLS_OP_glTexEnvfv,
    GLS_OP_glTexEnvi,
    GLS_OP_glTexEnviv,
    GLS_OP_glTexGend,
    GLS_OP_glTexGendv,
    GLS_OP_glTexGenf,
    GLS_OP_glTexGenfv,
    GLS_OP_glTexGeni,
    GLS_OP_glTexGeniv,
    GLS_OP_glTexImage1D,
    GLS_OP_glTexImage2D,
    GLS_OP_glTexImage3DEXT,
    GLS_OP_glTexImage4DSGIS,
    GLS_OP_glTexParameterf,
    GLS_OP_glTexParameterfv,
    GLS_OP_glTexParameteri,
    GLS_OP_glTexParameteriv,
    GLS_OP_glTexSubImage1DEXT,
    GLS_OP_glTexSubImage2DEXT,
    GLS_OP_glTexSubImage3DEXT,
    GLS_OP_glTexSubImage4DSGIS,
    GLS_OP_glTranslated,
    GLS_OP_glTranslatef,
    GLS_OP_glVertex2d,
    GLS_OP_glVertex2dv,
    GLS_OP_glVertex2f,
    GLS_OP_glVertex2fv,
    GLS_OP_glVertex2i,
    GLS_OP_glVertex2iv,
    GLS_OP_glVertex2s,
    GLS_OP_glVertex2sv,
    GLS_OP_glVertex3d,
    GLS_OP_glVertex3dv,
    GLS_OP_glVertex3f,
    GLS_OP_glVertex3fv,
    GLS_OP_glVertex3i,
    GLS_OP_glVertex3iv,
    GLS_OP_glVertex3s,
    GLS_OP_glVertex3sv,
    GLS_OP_glVertex4d,
    GLS_OP_glVertex4dv,
    GLS_OP_glVertex4f,
    GLS_OP_glVertex4fv,
    GLS_OP_glVertex4i,
    GLS_OP_glVertex4iv,
    GLS_OP_glVertex4s,
    GLS_OP_glVertex4sv,
    GLS_OP_glVertexPointerEXT,
    GLS_OP_glViewport,
    GLS_OP_glArrayElement,
    GLS_OP_glBindTexture,
    GLS_OP_glColorPointer,
    GLS_OP_glDisableClientState,
    GLS_OP_glDrawArrays,
    GLS_OP_glDrawElements,
    GLS_OP_glEdgeFlagPointer,
    GLS_OP_glEnableClientState,
    GLS_OP_glIndexPointer,
    GLS_OP_glIndexub,
    GLS_OP_glIndexubv,
    GLS_OP_glInterleavedArrays,
    GLS_OP_glNormalPointer,
    GLS_OP_glPolygonOffset,
    GLS_OP_glTexCoordPointer,
    GLS_OP_glVertexPointer,
    GLS_OP_glAreTexturesResident,
    GLS_OP_glCopyTexImage1D,
    GLS_OP_glCopyTexImage2D,
    GLS_OP_glCopyTexSubImage1D,
    GLS_OP_glCopyTexSubImage2D,
    GLS_OP_glDeleteTextures,
    GLS_OP_glGenTextures,
    GLS_OP_glGetPointerv,
    GLS_OP_glIsTexture,
    GLS_OP_glPrioritizeTextures,
    GLS_OP_glTexSubImage1D,
    GLS_OP_glTexSubImage2D,
    GLS_OP_glPushClientAttrib,
    GLS_OP_glPopClientAttrib,
};
#define EXECUTE_BITS (sizeof(opExecuteBits)/sizeof(opExecuteBits[0]))

/*****************************Private*Routine******************************\
*
* CreateMetaRc
*
* Creates a rendering context for a metafile DC
*
* History:
*  Thu Feb 23 15:27:47 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL CreateMetaRc(HDC hdc, PLRC plrc)
{
    int i;
    BOOL fSuccess;
    
    if (!MetaLoadGls())
    {
        return FALSE;
    }
    
    // If there's currently a GLS context active we can't record
    // because we require our own context to be current for recording
    if (gepGlsFuncs.glsGetCurrentContext() != 0)
    {
        SetLastError(ERROR_BUSY);
        return FALSE;
    }
    
    // Create a GLS context to record into
    plrc->uiGlsCaptureContext = gepGlsFuncs.glsGenContext();
    if (plrc->uiGlsCaptureContext == 0)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto EH_NoContext;
    }

    // No bounds by default
    plrc->prclGlsBounds = NULL;
    
    // Set current GLS context
    gepGlsFuncs.glsContext(plrc->uiGlsCaptureContext);

    // Point to our writer function
    gepGlsFuncs.glsWriteFunc(GlsWriter);

    // Set up a callback to flush after every command
    // This lets every GL command form its own separate record in the
    // metafile
    gepGlsFuncs.glsCaptureFunc(GLS_CAPTURE_EXIT_FUNC, GlsFlush);

    // Set execute bits on commands which retrieve state
    // This allows accurate results to come back for retrieval functions
    for (i = 0; i < EXECUTE_BITS; i++)
    {
        gepGlsFuncs.glsCaptureFlags(opExecuteBits[i],
                                    GLS_CAPTURE_EXECUTE_BIT |
                                    GLS_CAPTURE_WRITE_BIT);
    }
    
    fSuccess = MetaRcBegin(plrc, hdc);
    
    // Remove context to avoid inadvertent GLS calls
    // Also needed in failure case
    gepGlsFuncs.glsContext(0);

    if (fSuccess)
    {
        return TRUE;
    }

    gepGlsFuncs.glsDeleteContext(plrc->uiGlsCaptureContext);
    plrc->uiGlsCaptureContext = 0;
 EH_NoContext:
    DBGERROR("CreateMetaRc failed\n");
    return FALSE;
}

/*****************************Private*Routine******************************\
*
* DeleteMetaRc
*
* Cleans up a metafile RC
*
* History:
*  Thu Feb 23 16:35:19 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void DeleteMetaRc(PLRC plrc)
{
    GLuint uiGlsCurrent;
    
    if (plrc->uiGlsCaptureContext != 0)
    {
        // Make the GLS context current just in case
        // A different GLS context can be active at this time, though,
        // because a different metafile RC could be current to this
        // thread at the time of the delete, so we have to preserve
        // any current context
        uiGlsCurrent = gepGlsFuncs.glsGetCurrentContext();
    
        gepGlsFuncs.glsContext(plrc->uiGlsCaptureContext);

        // If we're still capturing, stop
        if (plrc->fCapturing)
        {
            MetaRcEnd(plrc);
        }

        // Restore old context
        gepGlsFuncs.glsContext(uiGlsCurrent);
    
        // Clean up dying context
        gepGlsFuncs.glsDeleteContext(plrc->uiGlsCaptureContext);
        plrc->uiGlsCaptureContext = 0;
    }

    // Clean up playback context if necessary
    // This can happen when metafile playback crashes or an
    // application crashes while enumerating
    if (plrc->uiGlsPlaybackContext != 0)
    {
        gepGlsFuncs.glsDeleteContext(plrc->uiGlsPlaybackContext);
        plrc->uiGlsPlaybackContext = 0;
    }
    
    // LRC and handle will be cleaned up elsewhere
}

/*****************************Private*Routine******************************\
*
* ActivateMetaRc
*
* Make a metafile RC current
*
* History:
*  Thu Feb 23 16:50:31 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void ActivateMetaRc(PLRC plrc, HDC hdc)
{
    ASSERTOPENGL(plrc->uiGlsCaptureContext != 0,
                 "ActivateMetaRc: No GLS context\n");
    ASSERTOPENGL(gepGlsFuncs.glsGetCurrentContext() == 0,
                 "ActivateMetaRc: Already a current GLS context\n");
    
    gepGlsFuncs.glsContext(plrc->uiGlsCaptureContext);
}

/*****************************Private*Routine******************************\
*
* DeactivateMetaRc
*
* Make a metafile RC non-current
*
* History:
*  Thu Feb 23 16:49:51 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void DeactivateMetaRc(PLRC plrc)
{
    // The current GLS context may not be this RC's capturing context
    // in the case where the RC has been made current after a
    // CloseEnhMetaFile has stopped capturing
    if (gepGlsFuncs.glsGetCurrentContext() == plrc->uiGlsCaptureContext)
    {
        gepGlsFuncs.glsContext(0);
    }
}

/*****************************Private*Routine******************************\
*
* GlmfSave
*
* Save all current GL state
*
* History:
*  Fri Feb 24 15:15:50 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void GlmfSave(void)
{
    // What is the exact list of state to be saved?
    // What about overflowing the projection and textures stacks?
    // They're small
    
    glPushAttrib(GL_ALL_ATTRIB_BITS);
    
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();

    glMatrixMode(GL_PROJECTION);
    glPushMatrix();

    glMatrixMode(GL_TEXTURE);
    glPushMatrix();
}

/*****************************Private*Routine******************************\
*
* GlmfRestore
*
* Restores saved state
*
* History:
*  Fri Feb 24 15:16:14 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void GlmfRestore(void)
{
    glMatrixMode(GL_TEXTURE);
    glPopMatrix();

    glMatrixMode(GL_PROJECTION);
    glPopMatrix();

    glMatrixMode(GL_MODELVIEW);
    glPopMatrix();

    glPopAttrib();
}

#define ScaleLongX(plrc, l) \
    MulDiv(l, plrc->iGlsNumeratorX, plrc->iGlsDenominatorX)
#define ScaleLongY(plrc, l) \
    MulDiv(l, plrc->iGlsNumeratorY, plrc->iGlsDenominatorY)
#define ScaleFloatX(plrc, f) ((f)*(plrc)->fGlsScaleX)
#define ScaleFloatY(plrc, f) ((f)*(plrc)->fGlsScaleY)

/*****************************Private*Routine******************************\
*
* TransformLongPt
*
* Transform an integer point
*
* History:
*  Fri Feb 24 15:27:37 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void TransformLongPt(PLRC plrc, POINT *ppt)
{
    ppt->x = MulDiv(ppt->x-plrc->iGlsSubtractX, plrc->iGlsNumeratorX,
                    plrc->iGlsDenominatorX)+plrc->iGlsAddX;
    ppt->y = MulDiv(ppt->y-plrc->iGlsSubtractY, plrc->iGlsNumeratorY,
                    plrc->iGlsDenominatorY)+plrc->iGlsAddY;
}

/*****************************Private*Routine******************************\
*
* ScaleLongPt
*
* Scale an integer point, no translation, for values rather than coordinates
*
* History:
*  Fri Feb 24 15:27:52 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void ScaleLongPt(PLRC plrc, POINT *ppt)
{
    ppt->x = MulDiv(ppt->x, plrc->iGlsNumeratorX, plrc->iGlsDenominatorX);
    ppt->y = MulDiv(ppt->y, plrc->iGlsNumeratorY, plrc->iGlsDenominatorY);
}

/*****************************Private*Routine******************************\
*
* TransformFloatPt
*
* Transform a float point
*
* History:
*  Fri Feb 24 15:27:37 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void TransformFloatPt(PLRC plrc, POINTFLOAT *pptf)
{
    pptf->x = (pptf->x-plrc->iGlsSubtractX)*plrc->iGlsNumeratorX/
        plrc->iGlsDenominatorX+plrc->iGlsAddX;
    pptf->y = (pptf->y-plrc->iGlsSubtractY)*plrc->iGlsNumeratorY/
        plrc->iGlsDenominatorY+plrc->iGlsAddY;
}

/*****************************Private*Routine******************************\
*
* ScaleFloatPt
*
* Scale a float point
*
* History:
*  Fri Feb 24 15:27:37 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void ScaleFloatPt(PLRC plrc, POINTFLOAT *pptf)
{
    pptf->x = pptf->x*plrc->iGlsNumeratorX/plrc->iGlsDenominatorX;
    pptf->y = pptf->y*plrc->iGlsNumeratorY/plrc->iGlsDenominatorY;
}

/*****************************Private*Routine******************************\
*
* GLS output scaling callbacks
*
* The following functions are used as GLS command functions for
* intercepting device coordinates and scaling them appropriately
*
* Bitmap contents are not scaled, but the current raster position is
* correctly maintained so that they are positioned appropriately
*
* Stipples are not scaled
*
* History:
*  Fri Feb 24 15:28:23 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void GlsBitmapOut(GLsizei width, GLsizei height,
                  GLfloat xorig, GLfloat yorig,
                  GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
{
    PLRC plrc;
    POINTFLOAT ptf;

    plrc = GLTEB_CLTCURRENTRC();
    
    ptf.x = xmove;
    ptf.y = ymove;
    ScaleFloatPt(plrc, &ptf);
    
    glBitmap(width, height, xorig, yorig, ptf.x, ptf.y, bitmap);
}

void GlsCopyPixelsOut(GLint x, GLint y, GLsizei width, GLsizei height,
                      GLenum type)
{
    POINT ptXY, ptWH;
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();
    
    ptXY.x = x;
    ptXY.y = y;
    TransformLongPt(plrc, &ptXY);
    
    ptWH.x = (LONG)width;
    ptWH.y = (LONG)height;
    ScaleLongPt(plrc, &ptWH);

    glCopyPixels(ptXY.x, ptXY.y, ptWH.x, ptWH.y, type);
}

void GlsCopyTexImage1DOut(GLenum target, GLint level,
                          GLenum internalformat,
                          GLint x, GLint y,
                          GLsizei width, GLint border)
{
    POINT ptXY;
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();

    ptXY.x = x;
    ptXY.y = y;
    TransformLongPt(plrc, &ptXY);
    
    glCopyTexImage1D(target, level, internalformat,
                     ptXY.x, ptXY.y, ScaleLongX(plrc, width), border);
}

    
void GlsCopyTexImage2DOut(GLenum target, GLint level,
                          GLenum internalformat,
                          GLint x, GLint y,
                          GLsizei width, GLsizei height,
                          GLint border)
{
    POINT ptXY, ptWH;
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();

    ptXY.x = x;
    ptXY.y = y;
    TransformLongPt(plrc, &ptXY);
    
    ptWH.x = (LONG)width;
    ptWH.y = (LONG)height;
    ScaleLongPt(plrc, &ptWH);
    
    glCopyTexImage2D(target, level, internalformat,
                     ptXY.x, ptXY.y, ptWH.x, ptWH.y, border);
}

void GlsCopyTexSubImage1DOut(GLenum target, GLint level,
                             GLint xoffset, GLint x, GLint y,
                             GLsizei width)
{
    POINT ptXY;
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();

    ptXY.x = x;
    ptXY.y = y;
    TransformLongPt(plrc, &ptXY);
    
    glCopyTexSubImage1D(target, level, xoffset,
                        ptXY.x, ptXY.y, ScaleLongX(plrc, width));
}

void GlsCopyTexSubImage2DOut(GLenum target, GLint level,
                             GLint xoffset, GLint yoffset,
                             GLint x, GLint y,
                             GLsizei width, GLsizei height)
{
    POINT ptXY, ptWH;
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();

    ptXY.x = x;
    ptXY.y = y;
    TransformLongPt(plrc, &ptXY);
    
    ptWH.x = (LONG)width;
    ptWH.y = (LONG)height;
    ScaleLongPt(plrc, &ptWH);
    
    glCopyTexSubImage2D(target, level, xoffset, yoffset,
                        ptXY.x, ptXY.y, ptWH.x, ptWH.y);
}

void GlsLineWidthOut(GLfloat width)
{
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();

    // Use X scaling here
    glLineWidth(ScaleFloatX(plrc, width));
}

void GlsPointSizeOut(GLfloat size)
{
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();
    
    // Use X scaling here
    glPointSize(ScaleFloatX(plrc, size));
}

void GlsScissorOut(GLint x, GLint y, GLsizei width, GLsizei height)
{
    POINT ptXY, ptWH;
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();

    ptXY.x = x;
    ptXY.y = y;
    TransformLongPt(plrc, &ptXY);
    
    ptWH.x = (LONG)width;
    ptWH.y = (LONG)height;
    ScaleLongPt(plrc, &ptWH);

    glScissor(ptXY.x, ptXY.y, ptWH.x, ptWH.y);
}

void GlsViewportOut(GLint x, GLint y, GLsizei width, GLsizei height)
{
    POINT ptXY, ptWH;
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();

    ptXY.x = x;
    ptXY.y = y;
    TransformLongPt(plrc, &ptXY);
    
    ptWH.x = (LONG)width;
    ptWH.y = (LONG)height;
    ScaleLongPt(plrc, &ptWH);

#if 0
    DbgPrint("glViewport(%d, %d, %d, %d)\n", ptXY.x, ptXY.y,
             ptWH.x, ptWH.y);
#endif

    glViewport(ptXY.x, ptXY.y, ptWH.x, ptWH.y);
}

static GLDEVICEPROCS gdpOutput =
{
    GlsBitmapOut,
    GlsCopyPixelsOut,
    GlsCopyTexImage1DOut,
    GlsCopyTexImage2DOut,
    GlsCopyTexSubImage1DOut,
    GlsCopyTexSubImage2DOut,
    NULL, // glDrawPixels
    GlsLineWidthOut,
    GlsPointSizeOut,
    GlsScissorOut,
    GlsViewportOut
};

/*****************************Private*Routine******************************\
*
* GlmfHookDeviceFns
*
* Hook all functions that deal with device units
*
* History:
*  Fri Feb 24 15:30:45 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void GlmfHookDeviceFns(void)
{
    int i;
    PROC *ppfn;

    ppfn = (PROC *)&gdpOutput;
    for (i = 0; i < GL_DEVICE_PROCS; i++)
    {
        if (*ppfn != NULL)
        {
            gepGlsFuncs.glsCommandFunc(glsopDeviceProcs[i], *ppfn);
        }
        
        ppfn++;
    }
}

/*****************************Private*Routine******************************\
*
* GlmfInitTransform
*
* Compute 2D playback transform from source and destination rectangles
* Hook GLS with scaling functions
*
* History:
*  Fri Feb 24 15:31:24 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void GlmfInitTransform(LPRECTL prclFrom, LPRECTL prclTo)
{
    PLRC plrc;

    plrc = GLTEB_CLTCURRENTRC();
    
    // Rectangles are inclusive-inclusive
    
    plrc->iGlsSubtractX = prclFrom->left;
    plrc->iGlsSubtractY = prclFrom->top;
    plrc->iGlsNumeratorX = prclTo->right-prclTo->left+1;
    plrc->iGlsNumeratorY = prclTo->bottom-prclTo->top+1;
    plrc->iGlsDenominatorX = prclFrom->right-prclFrom->left+1;
    plrc->iGlsDenominatorY = prclFrom->bottom-prclFrom->top+1;
    plrc->iGlsAddX = prclTo->left;
    plrc->iGlsAddY = prclTo->top;

#if 0
    DbgPrint("- %d,%d * %d,%d / %d,%d + %d,%d\n",
             plrc->iGlsSubtractX, plrc->iGlsSubtractY,
             plrc->iGlsNumeratorX, plrc->iGlsNumeratorY,
             plrc->iGlsDenominatorX, plrc->iGlsDenominatorY,
             plrc->iGlsAddX, plrc->iGlsAddY);
#endif
    
    // Only install hooks if the transform is not identity
    if (plrc->iGlsSubtractX != plrc->iGlsAddX ||
        plrc->iGlsSubtractY != plrc->iGlsAddY ||
        plrc->iGlsNumeratorX != plrc->iGlsDenominatorX ||
        plrc->iGlsNumeratorY != plrc->iGlsDenominatorY)
    {
        plrc->fGlsScaleX = (GLfloat)plrc->iGlsNumeratorX/
            plrc->iGlsDenominatorX;
        plrc->fGlsScaleY = (GLfloat)plrc->iGlsNumeratorY/
            plrc->iGlsDenominatorY;

        GlmfHookDeviceFns();
    }
}

// Table of functions which need to have their command funcs
// reset for playback virtualization
static GLSopcode opRecirculate[] =
{
    GLS_OP_glsBeginGLS,
    GLS_OP_glsBlock,
    GLS_OP_glsCallStream,
    GLS_OP_glsEndGLS,
    GLS_OP_glsError,
    GLS_OP_glsGLRC,
    GLS_OP_glsGLRCLayer,
    GLS_OP_glsHeaderGLRCi,
    GLS_OP_glsHeaderLayerf,
    GLS_OP_glsHeaderLayeri,
    GLS_OP_glsHeaderf,
    GLS_OP_glsHeaderfv,
    GLS_OP_glsHeaderi,
    GLS_OP_glsHeaderiv,
    GLS_OP_glsHeaderubz,
    GLS_OP_glsRequireExtension,
    GLS_OP_glsUnsupportedCommand,
    GLS_OP_glsAppRef,
    GLS_OP_glsBeginObj,
    GLS_OP_glsCharubz,
    GLS_OP_glsComment,
    GLS_OP_glsDisplayMapfv,
    GLS_OP_glsEndObj,
    GLS_OP_glsNumb,
    GLS_OP_glsNumbv,
    GLS_OP_glsNumd,
    GLS_OP_glsNumdv,
    GLS_OP_glsNumf,
    GLS_OP_glsNumfv,
    GLS_OP_glsNumi,
    GLS_OP_glsNumiv,
    GLS_OP_glsNuml,
    GLS_OP_glsNumlv,
    GLS_OP_glsNums,
    GLS_OP_glsNumsv,
    GLS_OP_glsNumub,
    GLS_OP_glsNumubv,
    GLS_OP_glsNumui,
    GLS_OP_glsNumuiv,
    GLS_OP_glsNumul,
    GLS_OP_glsNumulv,
    GLS_OP_glsNumus,
    GLS_OP_glsNumusv,
    GLS_OP_glsPad,
    GLS_OP_glsSwapBuffers
};
#define RECIRCULATE_OPS (sizeof(opRecirculate)/sizeof(opRecirculate[0]))

/******************************Public*Routine******************************\
*
* GlmfInitPlayback
*
* Initialize GL metafile playback, called from PlayEnhMetaFile for
* metafiles with GL information in them
*
* History:
*  Fri Feb 24 10:32:29 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfInitPlayback(HDC hdc, ENHMETAHEADER *pemh, LPRECTL prclDest)
{
    GLuint uiCurrentCtx;
    PLRC plrc;
    RECTL rclSourceDevice;
    int i;

    // If we don't have the appropriate GL context set up,
    // do nothing.  This allows applications to play metafiles containing
    // GL information even if they don't know anything about GL
    plrc = GLTEB_CLTCURRENTRC();
    if (plrc == NULL)
    {
        return TRUE;
    }
    
    if (!MetaLoadGls())
    {
        return FALSE;
    }

    plrc->uiGlsPlaybackContext = gepGlsFuncs.glsGenContext();
    if (plrc->uiGlsPlaybackContext == 0)
    {
        return FALSE;
    }

    GlmfSave();

    // Set an initial viewport just as a default
    glViewport(prclDest->left, prclDest->top,
               prclDest->right-prclDest->left,
               prclDest->bottom-prclDest->top);

    // The frame is in .01mm units.  Convert it to reference
    // device units using the information in the metafile header
    rclSourceDevice.left = MulDiv(pemh->rclFrame.left, pemh->szlDevice.cx,
                                  pemh->szlMillimeters.cx*100);
    rclSourceDevice.right = MulDiv(pemh->rclFrame.right, pemh->szlDevice.cx,
                                   pemh->szlMillimeters.cx*100);
    rclSourceDevice.top = MulDiv(pemh->rclFrame.top, pemh->szlDevice.cy,
                                 pemh->szlMillimeters.cy*100);
    rclSourceDevice.bottom = MulDiv(pemh->rclFrame.bottom, pemh->szlDevice.cy,
                                    pemh->szlMillimeters.cy*100);

    // We are resetting command funcs so we need our playback context
    // to be current.  Another context could be current now, though,
    // so preserve it
    uiCurrentCtx = gepGlsFuncs.glsGetCurrentContext();
    gepGlsFuncs.glsContext(plrc->uiGlsPlaybackContext);
    
    GlmfInitTransform(&rclSourceDevice, prclDest);

    // Reset all GLS command funcs to point to the actual exported
    // routines.  This means that playback on this context will
    // be exactly the same as if all the routines were being called
    // directly, so embedding a metafile into another one works
    // as expected
    //
    // NOTE: This context should not be made current because any
    // GLS commands executed on it when it is current will now
    // cause infinite loops
    for (i = 0; i < RECIRCULATE_OPS; i++)
    {
        gepGlsFuncs.glsCommandFunc(opRecirculate[i],
                                   (&gepGlsFuncs.glsBeginGLS)[i]);
    }

    // Restore preserved context
    gepGlsFuncs.glsContext(uiCurrentCtx);
    
    return TRUE;
}

/******************************Public*Routine******************************\
*
* GlmfBeginGlsBlock
*
* Sets up things for GLS record playback which can only be active during
* GLS records
* Currently this only sets the world transform to identity to avoid
* it interacting with GL drawing
*
* History:
*  Mon Apr 10 11:20:19 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfBeginGlsBlock(HDC hdc)
{
    PLRC plrc;
    BOOL bRet;
    
    // If we don't have the appropriate GL context set up,
    // do nothing.  This allows applications to play metafiles containing
    // GL information even if they don't know anything about GL
    plrc = GLTEB_CLTCURRENTRC();
    if (plrc == NULL)
    {
        return TRUE;
    }
    
    bRet = GetWorldTransform(hdc, &plrc->xformMeta);
    if (bRet)
    {
        bRet = ModifyWorldTransform(hdc, NULL, MWT_IDENTITY);
    }

    return bRet;
}
    
/******************************Public*Routine******************************\
*
* GlmfPlayGlsRecord
*
* Play a GL metafile record
*
* History:
*  Fri Feb 24 10:33:38 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define PLAY_STACK_BUFFER 256

BOOL APIENTRY GlmfPlayGlsRecord(HDC hdc, DWORD cb, BYTE *pb,
                                LPRECTL prclBounds)
{
    PLRC plrc;
    LARGE_INTEGER liBuffer[(PLAY_STACK_BUFFER+sizeof(LARGE_INTEGER)-1)/
                           sizeof(LARGE_INTEGER)+1];
    BYTE *pbPlay, *pbAlloc = NULL;
    __GLSbinCommandHead_large *gbch;
    GLSopcode op;
    GLScommandAlignment gca;

#if 0
    DbgPrint("GlmfPlayGlsRecord(%d)\n", cb);
#endif
    
    // If we don't have the appropriate GL and GLS contexts set up,
    // do nothing.  This allows applications to play metafiles containing
    // GL information even if they don't know anything about GL
    plrc = GLTEB_CLTCURRENTRC();
    if (plrc == NULL || plrc->uiGlsPlaybackContext == 0)
    {
        return TRUE;
    }
    
    ASSERTOPENGL(hGlsDll != NULL, "GlmfPlayGlsRecord: GLS not loaded\n");
    
    ASSERTOPENGL(plrc->tidCurrent == GetCurrentThreadId(),
                 "GlmfPlayGlsRecord: "
                 "Current RC does not belong to this thread!\n");
    ASSERTOPENGL(plrc->gwidCurrent.hdc != 0,
                 "GlmfPlayGlsRecord: Current HDC is NULL!\n");

    // pb points to some arbitrary block of memory
    // GLS requires that this block be appropriately aligned for
    // any commands that are executed out of it, so we need to
    // determine which command is in the buffer and then query
    // GLS for its alignment.
    // This is trickier than you would think since GLS doesn't
    // always add padding to commands relative to their beginning; it
    // sometimes adds padding to the end of the previous command.
    // We need to detect the case where padding is added.
    // 
    // NOTE: This definitely works when there is only one command
    // in the buffer.  It should work when there are multiple commands
    // because the following commands are padded according to the 
    // alignment of the initial command.  However, this assumption
    // should probably be validated if blocks start containing
    // multiple commands.

    // Check for an initial pad and skip it if necessary
    gbch = (__GLSbinCommandHead_large *)pb;
    if (gbch->opSmall == GLS_OP_glsPad &&
        gbch->countSmall == 1)
    {
        pb += sizeof(__GLSbinCommandHead_small);
        cb -= sizeof(__GLSbinCommandHead_small);
        gbch = (__GLSbinCommandHead_large *)pb;
    }

    ASSERTOPENGL(gbch->countSmall == 0 ||
                 gbch->opSmall != GLS_OP_glsPad,
                 "Unexpected glsPad in command buffer\n");

    op = gbch->countSmall == 0 ? gbch->opLarge : gbch->opSmall;

    gepGlsFuncs.glsGetCommandAlignment(op, gepGlsFuncs.glsBinary(GL_FALSE),
                                       &gca);
    ASSERTOPENGL(gca.mask <= 7, "Unhandled GLS playback alignment\n");

    if (((ULONG_PTR)pb & gca.mask) != gca.value)
    {
        if (cb <= PLAY_STACK_BUFFER)
        {
            pbPlay = (BYTE *)liBuffer+gca.value;
        }
        else
        {
            pbAlloc = (BYTE *)ALLOC(cb+gca.value);
            if (pbAlloc == NULL)
            {
                return FALSE;
            }

            pbPlay = pbAlloc+gca.value;
        }
        
        RtlCopyMemory(pbPlay, pb, cb);
    }
    else
    {
        pbPlay = pb;
    }
    
    gepGlsFuncs.glsCallArrayInContext(plrc->uiGlsPlaybackContext,
                                      gepGlsFuncs.glsBinary(GL_FALSE),
                                      cb, pbPlay);

    if (pbAlloc != NULL)
    {
        FREE(pbAlloc);
    }
    
    return TRUE;
}

/******************************Public*Routine******************************\
*
* GlmfEndGlsBlock
*
* Resets state changed for GLS record playback
* Currently restores the world transform
*
* History:
*  Mon Apr 10 11:23:06 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfEndGlsBlock(HDC hdc)
{
    PLRC plrc;
    
    // If we don't have the appropriate GL context set up,
    // do nothing.  This allows applications to play metafiles containing
    // GL information even if they don't know anything about GL
    plrc = GLTEB_CLTCURRENTRC();
    if (plrc == NULL)
    {
        return TRUE;
    }

    // Doesn't matter which side we multiply by since the transform
    // should be identity
    return ModifyWorldTransform(hdc, &plrc->xformMeta, MWT_LEFTMULTIPLY);
}
    
/******************************Public*Routine******************************\
*
* GlmfEndPlayback
*
* End GL metafile playback, called at the end of metafile playback
* Only called if GlmfInitPlayback was successful
*
* History:
*  Fri Feb 24 10:36:36 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfEndPlayback(HDC hdc)
{
    PLRC plrc;

    // If we don't have the appropriate GL and GLS contexts set up,
    // do nothing.  This allows applications to play metafiles containing
    // GL information even if they don't know anything about GL
    plrc = GLTEB_CLTCURRENTRC();
    if (plrc == NULL || plrc->uiGlsPlaybackContext == 0)
    {
        return TRUE;
    }

    ASSERTOPENGL(hGlsDll != NULL, "GlmfEndPlayback: GLS not loaded\n");

    // Since GlmfInitPlayback completed, we must have saved state
    GlmfRestore();

    ASSERTOPENGL(plrc->uiGlsPlaybackContext != 0,
                 "GlmfEndPlayback: No playback context\n");
    gepGlsFuncs.glsDeleteContext(plrc->uiGlsPlaybackContext);
    plrc->uiGlsPlaybackContext = 0;

    // Request cleanup of windows on the theory that most orphaned
    // windows are produced by DCs created for metafiles and memory
    // DCs used by printing.  Cleaning up during playback will mean
    // that orphaned windows are only around for one extra playback
    wglValidateWindows();

    return TRUE;
}

/******************************Public*Routine******************************\
*
* GlmfCloseMetaFile
*
* Called in CloseEnhMetaFile if GL records are present in the metafile
*
* History:
*  Fri Mar 03 18:05:50 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfCloseMetaFile(HDC hdc)
{
    PLRC plrc;
    GLGENwindow *pwnd;
    GLWINDOWID gwid;

    // This DC has just gone away so clean up its WNDOBJ if necessary
    WindowIdFromHdc(hdc, &gwid);
    pwnd = pwndGetFromID(&gwid);
    if (pwnd != NULL)
    {
        pwndCleanup(pwnd);
    }
    
    // The app could have called wglDeleteContext before CloseEnhMetaFile,
    // so we're not guaranteed to have a context
    plrc = GLTEB_CLTCURRENTRC();
    if (plrc == NULL ||
        !plrc->fCapturing)
    {
        return TRUE;
    }

    ASSERTOPENGL(hGlsDll != NULL, "GlmfCloseMetaFile: GLS not loaded\n");

    ASSERTOPENGL(plrc->uiGlsCaptureContext != 0,
                 "GlmfCloseMetaFile: GLS context is invalid");
    MetaRcEnd(plrc);

    // Set the proc table to the generic routines because capturing
    // is over.  Metafiling always uses the generic routines because
    // the underlying surface is always faked on top of an info DC.
    {
    // Use RGBA or CI proc table depending on the color mode.

	GLCLTPROCTABLE *pglProcTable;
	__GL_SETUP();

	if (gc->modes.colorIndexMode)
	    pglProcTable = &glCltCIProcTable;
	else
	    pglProcTable = &glCltRGBAProcTable;

	SetCltProcTable(pglProcTable, &glExtProcTable, TRUE);
    }

    return TRUE;
}

/******************************Public*Routine******************************\
*
* GlGdi routines
*
* Thunks to allow the same binary to run on both NT with metafile support
* and Win95 without it
*
* History:
*  Thu Aug 31 15:46:37 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#if DBG
BOOL APIENTRY GlGdiAddGlsRecord(HDC hdc, DWORD cb, BYTE *pb,
                                LPRECTL prclBounds)
{
    ASSERTOPENGL(pfnGdiAddGlsRecord != NULL,
                 "GdiAddGlsRecord called without support\n");
    return pfnGdiAddGlsRecord(hdc, cb, pb, prclBounds);
}

BOOL APIENTRY GlGdiAddGlsBounds(HDC hdc, LPRECTL prclBounds)
{
    ASSERTOPENGL(pfnGdiAddGlsBounds != NULL,
                 "GdiAddGlsBounds called without support\n");
    return pfnGdiAddGlsBounds(hdc, prclBounds);
}

BOOL APIENTRY GlGdiIsMetaPrintDC(HDC hdc)
{
    ASSERTOPENGL(pfnGdiIsMetaPrintDC != NULL,
                 "GdiIsMetaPrintDC called without support\n");
    return pfnGdiIsMetaPrintDC(hdc);
}
#endif

#else

PROC * APIENTRY wglGetDefaultDispatchTable(void)
{
    return NULL;
}

BOOL APIENTRY GlmfInitPlayback(HDC hdc, ENHMETAHEADER *pemh, LPRECTL prclDest)
{
    return FALSE;
}

BOOL APIENTRY GlmfBeginGlsBlock(HDC hdc)
{
    return FALSE;
}

BOOL APIENTRY GlmfPlayGlsRecord(HDC hdc, DWORD cb, BYTE *pb,
                                LPRECTL prclBounds)
{
    return FALSE;
}

BOOL APIENTRY GlmfEndGlsBlock(HDC hdc)
{
    return FALSE;
}

BOOL APIENTRY GlmfEndPlayback(HDC hdc)
{
    return FALSE;
}

BOOL APIENTRY GlmfCloseMetaFile(HDC hdc)
{
    return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\metasup.h ===
/******************************Module*Header*******************************\
* Module Name: metasup.h
*
* OpenGL metafile support
*
* History:
*  Thu Feb 23 15:27:47 1995	-by-	Drew Bliss [drewb]
*   Created
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#ifndef __METASUP_H__
#define __METASUP_H__

BOOL CreateMetaRc(HDC hdc, PLRC plrc);
void DeleteMetaRc(PLRC plrc);
void ActivateMetaRc(PLRC plrc, HDC hdc);
void DeactivateMetaRc(PLRC plrc);
void MetaRcEnd(PLRC plrc);

void MetaGlProcTables(PGLCLTPROCTABLE *ppgcpt, PGLEXTPROCTABLE *ppgept);
void MetaSetCltProcTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept);
void MetaGetCltProcTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept);

#endif /* __METASUP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\noopapir.c ===
/*
** Copyright 1991, 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT */

// Noop api dispatch for risc

#include "precomp.h"
#pragma hdrstop

#if DBG
// The WARNING_NOOP macro will output the debug message once only.
// If we have output a warning before, the new warnings are ignored.

int cWarningNoop = 0;

#define WARNING_NOOP(str)                                       \
        {                                                       \
            if (!cWarningNoop++)                                \
                DbgPrint("%s(%d): " str,__FILE__,__LINE__);     \
        }
#else
#define WARNING_NOOP(str)
#endif // DBG

// Some functions have return values!
GLint APIENTRY
glnoop(void)
{
    WARNING_NOOP("GL Noop\n");
    return 0;
}

const VOID * APIENTRY
glnoopptr(void)
{
    WARNING_NOOP("GL Noop\n");
    return 0;
}

GLenum APIENTRY
glnoopGetError ( void )
{
    WARNING_NOOP("GL Noop:glGetError\n");
    return(GL_INVALID_OPERATION);
}

#pragma warning(disable : 4113)
#pragma warning(disable : 4133)
#pragma warning(disable : 4047)
#pragma warning(disable : 4028)

/* Client Side Procedure Table */
/* WARNING:  If size of table changes, this file must be changed */

GLCLTPROCTABLE glNullCltProcTable = {

/* Number of function entries in the table */

     sizeof(GLDISPATCHTABLE) / sizeof(PROC),

/* gl Entry points */
  {
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoopGetError,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoopptr,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
     glnoop,
  }
};

GLEXTPROCTABLE glNullExtProcTable =
{
    /* Number of function entries in the table */
     sizeof(GLEXTDISPATCHTABLE) / sizeof(PROC),

    /* EXT Entry points */
    {
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
	glnoop,
#ifdef GL_WIN_multiple_textures
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
        glnoop,
#endif // GL_WIN_multiple_textures
    }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <ddrawp.h>
#include <GL/gl.h>

#include <stddef.h>

#define _NO_DDRAWINT_NO_COM
#include <winddi.h>
#include <glapi.h>
#include <glteb.h>
// temporay workaround for NT 3.51
// typedef ULONG FLONG;
#include <gldrv.h>
#include <glp.h>
#include <glgenwin.h>

#include "local.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\noopapi.c ===
/*
** Copyright 1991, 1992, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT */

#include "precomp.h"
#pragma hdrstop

#if DBG
// The WARNING_NOOP macro will output the debug message once only.
// If we have output a warning before, the new warnings are ignored.

int cWarningNoop = 0;

#define WARNING_NOOP(str)                                       \
        {                                                       \
            if (!cWarningNoop++)                                \
                DbgPrint("%s(%d): " str,__FILE__,__LINE__);     \
        }
#else
#define WARNING_NOOP(str)
#endif // DBG

void APIENTRY
glnoopNewList ( IN GLuint list, IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glNewList\n");
}

void APIENTRY
glnoopEndList ( void )
{
    WARNING_NOOP("GL Noop:glEndList\n");
}

void APIENTRY
glnoopCallList ( IN GLuint list )
{
    WARNING_NOOP("GL Noop:glCallList\n");
}

void APIENTRY
glnoopCallLists ( IN GLsizei n, IN GLenum type, IN const GLvoid *lists )
{
    WARNING_NOOP("GL Noop:glCallLists\n");
}

void APIENTRY
glnoopDeleteLists ( IN GLuint list, IN GLsizei range )
{
    WARNING_NOOP("GL Noop:glDeleteLists\n");
}

GLuint APIENTRY
glnoopGenLists ( IN GLsizei range )
{
    WARNING_NOOP("GL Noop:glGenLists\n");
    return ((GLuint) 0);
}

void APIENTRY
glnoopListBase ( IN GLuint base )
{
    WARNING_NOOP("GL Noop:glListBase\n");
}

void APIENTRY
glnoopBegin ( IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glBegin\n");
}

void APIENTRY
glnoopBitmap ( IN GLsizei width, IN GLsizei height, IN GLfloat xorig, IN GLfloat yorig, IN GLfloat xmove, IN GLfloat ymove, IN const GLubyte bitmap[] )
{
    WARNING_NOOP("GL Noop:glBitmap\n");
}

void APIENTRY
glnoopColor3b ( IN GLbyte red, IN GLbyte green, IN GLbyte blue )
{
    WARNING_NOOP("GL Noop:glColor3b\n");
}

void APIENTRY
glnoopColor3bv ( IN const GLbyte v[3] )
{
    WARNING_NOOP("GL Noop:glColor3bv\n");
}

void APIENTRY
glnoopColor3d ( IN GLdouble red, IN GLdouble green, IN GLdouble blue )
{
    WARNING_NOOP("GL Noop:glColor3d\n");
}

void APIENTRY
glnoopColor3dv ( IN const GLdouble v[3] )
{
    WARNING_NOOP("GL Noop:glColor3dv\n");
}

void APIENTRY
glnoopColor3f ( IN GLfloat red, IN GLfloat green, IN GLfloat blue )
{
    WARNING_NOOP("GL Noop:glColor3f\n");
}

void APIENTRY
glnoopColor3fv ( IN const GLfloat v[3] )
{
    WARNING_NOOP("GL Noop:glColor3fv\n");
}

void APIENTRY
glnoopColor3i ( IN GLint red, IN GLint green, IN GLint blue )
{
    WARNING_NOOP("GL Noop:glColor3i\n");
}

void APIENTRY
glnoopColor3iv ( IN const GLint v[3] )
{
    WARNING_NOOP("GL Noop:glColor3iv\n");
}

void APIENTRY
glnoopColor3s ( IN GLshort red, IN GLshort green, IN GLshort blue )
{
    WARNING_NOOP("GL Noop:glColor3s\n");
}

void APIENTRY
glnoopColor3sv ( IN const GLshort v[3] )
{
    WARNING_NOOP("GL Noop:glColor3sv\n");
}

void APIENTRY
glnoopColor3ub ( IN GLubyte red, IN GLubyte green, IN GLubyte blue )
{
    WARNING_NOOP("GL Noop:glColor3ub\n");
}

void APIENTRY
glnoopColor3ubv ( IN const GLubyte v[3] )
{
    WARNING_NOOP("GL Noop:glColor3ubv\n");
}

void APIENTRY
glnoopColor3ui ( IN GLuint red, IN GLuint green, IN GLuint blue )
{
    WARNING_NOOP("GL Noop:glColor3ui\n");
}

void APIENTRY
glnoopColor3uiv ( IN const GLuint v[3] )
{
    WARNING_NOOP("GL Noop:glColor3uiv\n");
}

void APIENTRY
glnoopColor3us ( IN GLushort red, IN GLushort green, IN GLushort blue )
{
    WARNING_NOOP("GL Noop:glColor3us\n");
}

void APIENTRY
glnoopColor3usv ( IN const GLushort v[3] )
{
    WARNING_NOOP("GL Noop:glColor3usv\n");
}

void APIENTRY
glnoopColor4b ( IN GLbyte red, IN GLbyte green, IN GLbyte blue, IN GLbyte alpha )
{
    WARNING_NOOP("GL Noop:glColor4b\n");
}

void APIENTRY
glnoopColor4bv ( IN const GLbyte v[4] )
{
    WARNING_NOOP("GL Noop:glColor4bv\n");
}

void APIENTRY
glnoopColor4d ( IN GLdouble red, IN GLdouble green, IN GLdouble blue, IN GLdouble alpha )
{
    WARNING_NOOP("GL Noop:glColor4d\n");
}

void APIENTRY
glnoopColor4dv ( IN const GLdouble v[4] )
{
    WARNING_NOOP("GL Noop:glColor4dv\n");
}

void APIENTRY
glnoopColor4f ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    WARNING_NOOP("GL Noop:glColor4f\n");
}

void APIENTRY
glnoopColor4fv ( IN const GLfloat v[4] )
{
    WARNING_NOOP("GL Noop:glColor4fv\n");
}

void APIENTRY
glnoopColor4i ( IN GLint red, IN GLint green, IN GLint blue, IN GLint alpha )
{
    WARNING_NOOP("GL Noop:glColor4i\n");
}

void APIENTRY
glnoopColor4iv ( IN const GLint v[4] )
{
    WARNING_NOOP("GL Noop:glColor4iv\n");
}

void APIENTRY
glnoopColor4s ( IN GLshort red, IN GLshort green, IN GLshort blue, IN GLshort alpha )
{
    WARNING_NOOP("GL Noop:glColor4s\n");
}

void APIENTRY
glnoopColor4sv ( IN const GLshort v[4] )
{
    WARNING_NOOP("GL Noop:glColor4sv\n");
}

void APIENTRY
glnoopColor4ub ( IN GLubyte red, IN GLubyte green, IN GLubyte blue, IN GLubyte alpha )
{
    WARNING_NOOP("GL Noop:glColor4ub\n");
}

void APIENTRY
glnoopColor4ubv ( IN const GLubyte v[4] )
{
    WARNING_NOOP("GL Noop:glColor4ubv\n");
}

void APIENTRY
glnoopColor4ui ( IN GLuint red, IN GLuint green, IN GLuint blue, IN GLuint alpha )
{
    WARNING_NOOP("GL Noop:glColor4ui\n");
}

void APIENTRY
glnoopColor4uiv ( IN const GLuint v[4] )
{
    WARNING_NOOP("GL Noop:glColor4uiv\n");
}

void APIENTRY
glnoopColor4us ( IN GLushort red, IN GLushort green, IN GLushort blue, IN GLushort alpha )
{
    WARNING_NOOP("GL Noop:glColor4us\n");
}

void APIENTRY
glnoopColor4usv ( IN const GLushort v[4] )
{
    WARNING_NOOP("GL Noop:glColor4usv\n");
}

void APIENTRY
glnoopEdgeFlag ( IN GLboolean flag )
{
    WARNING_NOOP("GL Noop:glEdgeFlag\n");
}

void APIENTRY
glnoopEdgeFlagv ( IN const GLboolean flag[1] )
{
    WARNING_NOOP("GL Noop:glEdgeFlagv\n");
}

void APIENTRY
glnoopEnd ( void )
{
    WARNING_NOOP("GL Noop:glEnd\n");
}

void APIENTRY
glnoopIndexd ( IN GLdouble c )
{
    WARNING_NOOP("GL Noop:glIndexd\n");
}

void APIENTRY
glnoopIndexdv ( IN const GLdouble c[1] )
{
    WARNING_NOOP("GL Noop:glIndexdv\n");
}

void APIENTRY
glnoopIndexf ( IN GLfloat c )
{
    WARNING_NOOP("GL Noop:glIndexf\n");
}

void APIENTRY
glnoopIndexfv ( IN const GLfloat c[1] )
{
    WARNING_NOOP("GL Noop:glIndexfv\n");
}

void APIENTRY
glnoopIndexi ( IN GLint c )
{
    WARNING_NOOP("GL Noop:glIndexi\n");
}

void APIENTRY
glnoopIndexiv ( IN const GLint c[1] )
{
    WARNING_NOOP("GL Noop:glIndexiv\n");
}

void APIENTRY
glnoopIndexs ( IN GLshort c )
{
    WARNING_NOOP("GL Noop:glIndexs\n");
}

void APIENTRY
glnoopIndexsv ( IN const GLshort c[1] )
{
    WARNING_NOOP("GL Noop:glIndexsv\n");
}

void APIENTRY
glnoopNormal3b ( IN GLbyte nx, IN GLbyte ny, IN GLbyte nz )
{
    WARNING_NOOP("GL Noop:glNormal3b\n");
}

void APIENTRY
glnoopNormal3bv ( IN const GLbyte v[3] )
{
    WARNING_NOOP("GL Noop:glNormal3bv\n");
}

void APIENTRY
glnoopNormal3d ( IN GLdouble nx, IN GLdouble ny, IN GLdouble nz )
{
    WARNING_NOOP("GL Noop:glNormal3d\n");
}

void APIENTRY
glnoopNormal3dv ( IN const GLdouble v[3] )
{
    WARNING_NOOP("GL Noop:glNormal3dv\n");
}

void APIENTRY
glnoopNormal3f ( IN GLfloat nx, IN GLfloat ny, IN GLfloat nz )
{
    WARNING_NOOP("GL Noop:glNormal3f\n");
}

void APIENTRY
glnoopNormal3fv ( IN const GLfloat v[3] )
{
    WARNING_NOOP("GL Noop:glNormal3fv\n");
}

void APIENTRY
glnoopNormal3i ( IN GLint nx, IN GLint ny, IN GLint nz )
{
    WARNING_NOOP("GL Noop:glNormal3i\n");
}

void APIENTRY
glnoopNormal3iv ( IN const GLint v[3] )
{
    WARNING_NOOP("GL Noop:glNormal3iv\n");
}

void APIENTRY
glnoopNormal3s ( IN GLshort nx, IN GLshort ny, IN GLshort nz )
{
    WARNING_NOOP("GL Noop:glNormal3s\n");
}

void APIENTRY
glnoopNormal3sv ( IN const GLshort v[3] )
{
    WARNING_NOOP("GL Noop:glNormal3sv\n");
}

void APIENTRY
glnoopRasterPos2d ( IN GLdouble x, IN GLdouble y )
{
    WARNING_NOOP("GL Noop:glRasterPos2d\n");
}

void APIENTRY
glnoopRasterPos2dv ( IN const GLdouble v[2] )
{
    WARNING_NOOP("GL Noop:glRasterPos2dv\n");
}

void APIENTRY
glnoopRasterPos2f ( IN GLfloat x, IN GLfloat y )
{
    WARNING_NOOP("GL Noop:glRasterPos2f\n");
}

void APIENTRY
glnoopRasterPos2fv ( IN const GLfloat v[2] )
{
    WARNING_NOOP("GL Noop:glRasterPos2fv\n");
}

void APIENTRY
glnoopRasterPos2i ( IN GLint x, IN GLint y )
{
    WARNING_NOOP("GL Noop:glRasterPos2i\n");
}

void APIENTRY
glnoopRasterPos2iv ( IN const GLint v[2] )
{
    WARNING_NOOP("GL Noop:glRasterPos2iv\n");
}

void APIENTRY
glnoopRasterPos2s ( IN GLshort x, IN GLshort y )
{
    WARNING_NOOP("GL Noop:glRasterPos2s\n");
}

void APIENTRY
glnoopRasterPos2sv ( IN const GLshort v[2] )
{
    WARNING_NOOP("GL Noop:glRasterPos2sv\n");
}

void APIENTRY
glnoopRasterPos3d ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    WARNING_NOOP("GL Noop:glRasterPos3d\n");
}

void APIENTRY
glnoopRasterPos3dv ( IN const GLdouble v[3] )
{
    WARNING_NOOP("GL Noop:glRasterPos3dv\n");
}

void APIENTRY
glnoopRasterPos3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    WARNING_NOOP("GL Noop:glRasterPos3f\n");
}

void APIENTRY
glnoopRasterPos3fv ( IN const GLfloat v[3] )
{
    WARNING_NOOP("GL Noop:glRasterPos3fv\n");
}

void APIENTRY
glnoopRasterPos3i ( IN GLint x, IN GLint y, IN GLint z )
{
    WARNING_NOOP("GL Noop:glRasterPos3i\n");
}

void APIENTRY
glnoopRasterPos3iv ( IN const GLint v[3] )
{
    WARNING_NOOP("GL Noop:glRasterPos3iv\n");
}

void APIENTRY
glnoopRasterPos3s ( IN GLshort x, IN GLshort y, IN GLshort z )
{
    WARNING_NOOP("GL Noop:glRasterPos3s\n");
}

void APIENTRY
glnoopRasterPos3sv ( IN const GLshort v[3] )
{
    WARNING_NOOP("GL Noop:glRasterPos3sv\n");
}

void APIENTRY
glnoopRasterPos4d ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w )
{
    WARNING_NOOP("GL Noop:glRasterPos4d\n");
}

void APIENTRY
glnoopRasterPos4dv ( IN const GLdouble v[4] )
{
    WARNING_NOOP("GL Noop:glRasterPos4dv\n");
}

void APIENTRY
glnoopRasterPos4f ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w )
{
    WARNING_NOOP("GL Noop:glRasterPos4f\n");
}

void APIENTRY
glnoopRasterPos4fv ( IN const GLfloat v[4] )
{
    WARNING_NOOP("GL Noop:glRasterPos4fv\n");
}

void APIENTRY
glnoopRasterPos4i ( IN GLint x, IN GLint y, IN GLint z, IN GLint w )
{
    WARNING_NOOP("GL Noop:glRasterPos4i\n");
}

void APIENTRY
glnoopRasterPos4iv ( IN const GLint v[4] )
{
    WARNING_NOOP("GL Noop:glRasterPos4iv\n");
}

void APIENTRY
glnoopRasterPos4s ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w )
{
    WARNING_NOOP("GL Noop:glRasterPos4s\n");
}

void APIENTRY
glnoopRasterPos4sv ( IN const GLshort v[4] )
{
    WARNING_NOOP("GL Noop:glRasterPos4sv\n");
}

void APIENTRY
glnoopRectd ( IN GLdouble x1, IN GLdouble y1, IN GLdouble x2, IN GLdouble y2 )
{
    WARNING_NOOP("GL Noop:glRectd\n");
}

void APIENTRY
glnoopRectdv ( IN const GLdouble v1[2], IN const GLdouble v2[2] )
{
    WARNING_NOOP("GL Noop:glRectdv\n");
}

void APIENTRY
glnoopRectf ( IN GLfloat x1, IN GLfloat y1, IN GLfloat x2, IN GLfloat y2 )
{
    WARNING_NOOP("GL Noop:glRectf\n");
}

void APIENTRY
glnoopRectfv ( IN const GLfloat v1[2], IN const GLfloat v2[2] )
{
    WARNING_NOOP("GL Noop:glRectfv\n");
}

void APIENTRY
glnoopRecti ( IN GLint x1, IN GLint y1, IN GLint x2, IN GLint y2 )
{
    WARNING_NOOP("GL Noop:glRecti\n");
}

void APIENTRY
glnoopRectiv ( IN const GLint v1[2], IN const GLint v2[2] )
{
    WARNING_NOOP("GL Noop:glRectiv\n");
}

void APIENTRY
glnoopRects ( IN GLshort x1, IN GLshort y1, IN GLshort x2, IN GLshort y2 )
{
    WARNING_NOOP("GL Noop:glRects\n");
}

void APIENTRY
glnoopRectsv ( IN const GLshort v1[2], IN const GLshort v2[2] )
{
    WARNING_NOOP("GL Noop:glRectsv\n");
}

void APIENTRY
glnoopTexCoord1d ( IN GLdouble s )
{
    WARNING_NOOP("GL Noop:glTexCoord1d\n");
}

void APIENTRY
glnoopTexCoord1dv ( IN const GLdouble v[1] )
{
    WARNING_NOOP("GL Noop:glTexCoord1dv\n");
}

void APIENTRY
glnoopTexCoord1f ( IN GLfloat s )
{
    WARNING_NOOP("GL Noop:glTexCoord1f\n");
}

void APIENTRY
glnoopTexCoord1fv ( IN const GLfloat v[1] )
{
    WARNING_NOOP("GL Noop:glTexCoord1fv\n");
}

void APIENTRY
glnoopTexCoord1i ( IN GLint s )
{
    WARNING_NOOP("GL Noop:glTexCoord1i\n");
}

void APIENTRY
glnoopTexCoord1iv ( IN const GLint v[1] )
{
    WARNING_NOOP("GL Noop:glTexCoord1iv\n");
}

void APIENTRY
glnoopTexCoord1s ( IN GLshort s )
{
    WARNING_NOOP("GL Noop:glTexCoord1s\n");
}

void APIENTRY
glnoopTexCoord1sv ( IN const GLshort v[1] )
{
    WARNING_NOOP("GL Noop:glTexCoord1sv\n");
}

void APIENTRY
glnoopTexCoord2d ( IN GLdouble s, IN GLdouble t )
{
    WARNING_NOOP("GL Noop:glTexCoord2d\n");
}

void APIENTRY
glnoopTexCoord2dv ( IN const GLdouble v[2] )
{
    WARNING_NOOP("GL Noop:glTexCoord2dv\n");
}

void APIENTRY
glnoopTexCoord2f ( IN GLfloat s, IN GLfloat t )
{
    WARNING_NOOP("GL Noop:glTexCoord2f\n");
}

void APIENTRY
glnoopTexCoord2fv ( IN const GLfloat v[2] )
{
    WARNING_NOOP("GL Noop:glTexCoord2fv\n");
}

void APIENTRY
glnoopTexCoord2i ( IN GLint s, IN GLint t )
{
    WARNING_NOOP("GL Noop:glTexCoord2i\n");
}

void APIENTRY
glnoopTexCoord2iv ( IN const GLint v[2] )
{
    WARNING_NOOP("GL Noop:glTexCoord2iv\n");
}

void APIENTRY
glnoopTexCoord2s ( IN GLshort s, IN GLshort t )
{
    WARNING_NOOP("GL Noop:glTexCoord2s\n");
}

void APIENTRY
glnoopTexCoord2sv ( IN const GLshort v[2] )
{
    WARNING_NOOP("GL Noop:glTexCoord2sv\n");
}

void APIENTRY
glnoopTexCoord3d ( IN GLdouble s, IN GLdouble t, IN GLdouble r )
{
    WARNING_NOOP("GL Noop:glTexCoord3d\n");
}

void APIENTRY
glnoopTexCoord3dv ( IN const GLdouble v[3] )
{
    WARNING_NOOP("GL Noop:glTexCoord3dv\n");
}

void APIENTRY
glnoopTexCoord3f ( IN GLfloat s, IN GLfloat t, IN GLfloat r )
{
    WARNING_NOOP("GL Noop:glTexCoord3f\n");
}

void APIENTRY
glnoopTexCoord3fv ( IN const GLfloat v[3] )
{
    WARNING_NOOP("GL Noop:glTexCoord3fv\n");
}

void APIENTRY
glnoopTexCoord3i ( IN GLint s, IN GLint t, IN GLint r )
{
    WARNING_NOOP("GL Noop:glTexCoord3i\n");
}

void APIENTRY
glnoopTexCoord3iv ( IN const GLint v[3] )
{
    WARNING_NOOP("GL Noop:glTexCoord3iv\n");
}

void APIENTRY
glnoopTexCoord3s ( IN GLshort s, IN GLshort t, IN GLshort r )
{
    WARNING_NOOP("GL Noop:glTexCoord3s\n");
}

void APIENTRY
glnoopTexCoord3sv ( IN const GLshort v[3] )
{
    WARNING_NOOP("GL Noop:glTexCoord3sv\n");
}

void APIENTRY
glnoopTexCoord4d ( IN GLdouble s, IN GLdouble t, IN GLdouble r, IN GLdouble q )
{
    WARNING_NOOP("GL Noop:glTexCoord4d\n");
}

void APIENTRY
glnoopTexCoord4dv ( IN const GLdouble v[4] )
{
    WARNING_NOOP("GL Noop:glTexCoord4dv\n");
}

void APIENTRY
glnoopTexCoord4f ( IN GLfloat s, IN GLfloat t, IN GLfloat r, IN GLfloat q )
{
    WARNING_NOOP("GL Noop:glTexCoord4f\n");
}

void APIENTRY
glnoopTexCoord4fv ( IN const GLfloat v[4] )
{
    WARNING_NOOP("GL Noop:glTexCoord4fv\n");
}

void APIENTRY
glnoopTexCoord4i ( IN GLint s, IN GLint t, IN GLint r, IN GLint q )
{
    WARNING_NOOP("GL Noop:glTexCoord4i\n");
}

void APIENTRY
glnoopTexCoord4iv ( IN const GLint v[4] )
{
    WARNING_NOOP("GL Noop:glTexCoord4iv\n");
}

void APIENTRY
glnoopTexCoord4s ( IN GLshort s, IN GLshort t, IN GLshort r, IN GLshort q )
{
    WARNING_NOOP("GL Noop:glTexCoord4s\n");
}

void APIENTRY
glnoopTexCoord4sv ( IN const GLshort v[4] )
{
    WARNING_NOOP("GL Noop:glTexCoord4sv\n");
}

void APIENTRY
glnoopVertex2d ( IN GLdouble x, IN GLdouble y )
{
    WARNING_NOOP("GL Noop:glVertex2d\n");
}

void APIENTRY
glnoopVertex2dv ( IN const GLdouble v[2] )
{
    WARNING_NOOP("GL Noop:glVertex2dv\n");
}

void APIENTRY
glnoopVertex2f ( IN GLfloat x, IN GLfloat y )
{
    WARNING_NOOP("GL Noop:glVertex2f\n");
}

void APIENTRY
glnoopVertex2fv ( IN const GLfloat v[2] )
{
    WARNING_NOOP("GL Noop:glVertex2fv\n");
}

void APIENTRY
glnoopVertex2i ( IN GLint x, IN GLint y )
{
    WARNING_NOOP("GL Noop:glVertex2i\n");
}

void APIENTRY
glnoopVertex2iv ( IN const GLint v[2] )
{
    WARNING_NOOP("GL Noop:glVertex2iv\n");
}

void APIENTRY
glnoopVertex2s ( IN GLshort x, IN GLshort y )
{
    WARNING_NOOP("GL Noop:glVertex2s\n");
}

void APIENTRY
glnoopVertex2sv ( IN const GLshort v[2] )
{
    WARNING_NOOP("GL Noop:glVertex2sv\n");
}

void APIENTRY
glnoopVertex3d ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    WARNING_NOOP("GL Noop:glVertex3d\n");
}

void APIENTRY
glnoopVertex3dv ( IN const GLdouble v[3] )
{
    WARNING_NOOP("GL Noop:glVertex3dv\n");
}

void APIENTRY
glnoopVertex3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    WARNING_NOOP("GL Noop:glVertex3f\n");
}

void APIENTRY
glnoopVertex3fv ( IN const GLfloat v[3] )
{
    WARNING_NOOP("GL Noop:glVertex3fv\n");
}

void APIENTRY
glnoopVertex3i ( IN GLint x, IN GLint y, IN GLint z )
{
    WARNING_NOOP("GL Noop:glVertex3i\n");
}

void APIENTRY
glnoopVertex3iv ( IN const GLint v[3] )
{
    WARNING_NOOP("GL Noop:glVertex3iv\n");
}

void APIENTRY
glnoopVertex3s ( IN GLshort x, IN GLshort y, IN GLshort z )
{
    WARNING_NOOP("GL Noop:glVertex3s\n");
}

void APIENTRY
glnoopVertex3sv ( IN const GLshort v[3] )
{
    WARNING_NOOP("GL Noop:glVertex3sv\n");
}

void APIENTRY
glnoopVertex4d ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w )
{
    WARNING_NOOP("GL Noop:glVertex4d\n");
}

void APIENTRY
glnoopVertex4dv ( IN const GLdouble v[4] )
{
    WARNING_NOOP("GL Noop:glVertex4dv\n");
}

void APIENTRY
glnoopVertex4f ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w )
{
    WARNING_NOOP("GL Noop:glVertex4f\n");
}

void APIENTRY
glnoopVertex4fv ( IN const GLfloat v[4] )
{
    WARNING_NOOP("GL Noop:glVertex4fv\n");
}

void APIENTRY
glnoopVertex4i ( IN GLint x, IN GLint y, IN GLint z, IN GLint w )
{
    WARNING_NOOP("GL Noop:glVertex4i\n");
}

void APIENTRY
glnoopVertex4iv ( IN const GLint v[4] )
{
    WARNING_NOOP("GL Noop:glVertex4iv\n");
}

void APIENTRY
glnoopVertex4s ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w )
{
    WARNING_NOOP("GL Noop:glVertex4s\n");
}

void APIENTRY
glnoopVertex4sv ( IN const GLshort v[4] )
{
    WARNING_NOOP("GL Noop:glVertex4sv\n");
}

void APIENTRY
glnoopClipPlane ( IN GLenum plane, IN const GLdouble equation[4] )
{
    WARNING_NOOP("GL Noop:glClipPlane\n");
}

void APIENTRY
glnoopColorMaterial ( IN GLenum face, IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glColorMaterial\n");
}

void APIENTRY
glnoopCullFace ( IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glCullFace\n");
}

void APIENTRY
glnoopFogf ( IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glFogf\n");
}

void APIENTRY
glnoopFogfv ( IN GLenum pname, IN const GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glFogfv\n");
}

void APIENTRY
glnoopFogi ( IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glFogi\n");
}

void APIENTRY
glnoopFogiv ( IN GLenum pname, IN const GLint params[] )
{
    WARNING_NOOP("GL Noop:glFogiv\n");
}

void APIENTRY
glnoopFrontFace ( IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glFrontFace\n");
}

void APIENTRY
glnoopHint ( IN GLenum target, IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glHint\n");
}

void APIENTRY
glnoopLightf ( IN GLenum light, IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glLightf\n");
}

void APIENTRY
glnoopLightfv ( IN GLenum light, IN GLenum pname, IN const GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glLightfv\n");
}

void APIENTRY
glnoopLighti ( IN GLenum light, IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glLighti\n");
}

void APIENTRY
glnoopLightiv ( IN GLenum light, IN GLenum pname, IN const GLint params[] )
{
    WARNING_NOOP("GL Noop:glLightiv\n");
}

void APIENTRY
glnoopLightModelf ( IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glLightModelf\n");
}

void APIENTRY
glnoopLightModelfv ( IN GLenum pname, IN const GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glLightModelfv\n");
}

void APIENTRY
glnoopLightModeli ( IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glLightModeli\n");
}

void APIENTRY
glnoopLightModeliv ( IN GLenum pname, IN const GLint params[] )
{
    WARNING_NOOP("GL Noop:glLightModeliv\n");
}

void APIENTRY
glnoopLineStipple ( IN GLint factor, IN GLushort pattern )
{
    WARNING_NOOP("GL Noop:glLineStipple\n");
}

void APIENTRY
glnoopLineWidth ( IN GLfloat width )
{
    WARNING_NOOP("GL Noop:glLineWidth\n");
}

void APIENTRY
glnoopMaterialf ( IN GLenum face, IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glMaterialf\n");
}

void APIENTRY
glnoopMaterialfv ( IN GLenum face, IN GLenum pname, IN const GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glMaterialfv\n");
}

void APIENTRY
glnoopMateriali ( IN GLenum face, IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glMateriali\n");
}

void APIENTRY
glnoopMaterialiv ( IN GLenum face, IN GLenum pname, IN const GLint params[] )
{
    WARNING_NOOP("GL Noop:glMaterialiv\n");
}

void APIENTRY
glnoopPointSize ( IN GLfloat size )
{
    WARNING_NOOP("GL Noop:glPointSize\n");
}

void APIENTRY
glnoopPolygonMode ( IN GLenum face, IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glPolygonMode\n");
}

void APIENTRY
glnoopPolygonStipple ( IN const GLubyte mask[128] )
{
    WARNING_NOOP("GL Noop:glPolygonStipple\n");
}

void APIENTRY
glnoopScissor ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height )
{
    WARNING_NOOP("GL Noop:glScissor\n");
}

void APIENTRY
glnoopShadeModel ( IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glShadeModel\n");
}

void APIENTRY
glnoopTexParameterf ( IN GLenum target, IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glTexParameterf\n");
}

void APIENTRY
glnoopTexParameterfv ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glTexParameterfv\n");
}

void APIENTRY
glnoopTexParameteri ( IN GLenum target, IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glTexParameteri\n");
}

void APIENTRY
glnoopTexParameteriv ( IN GLenum target, IN GLenum pname, IN const GLint params[] )
{
    WARNING_NOOP("GL Noop:glTexParameteriv\n");
}

void APIENTRY
glnoopTexImage1D ( IN GLenum target, IN GLint level, IN GLint components, IN GLsizei width, IN GLint border, IN GLenum format, IN GLenum type, IN const GLvoid *pixels )
{
    WARNING_NOOP("GL Noop:glTexImage1D\n");
}

void APIENTRY
glnoopTexImage2D ( IN GLenum target, IN GLint level, IN GLint components, IN GLsizei width, IN GLsizei height, IN GLint border, IN GLenum format, IN GLenum type, IN const GLvoid *pixels )
{
    WARNING_NOOP("GL Noop:glTexImage2D\n");
}

void APIENTRY
glnoopTexEnvf ( IN GLenum target, IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glTexEnvf\n");
}

void APIENTRY
glnoopTexEnvfv ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glTexEnvfv\n");
}

void APIENTRY
glnoopTexEnvi ( IN GLenum target, IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glTexEnvi\n");
}

void APIENTRY
glnoopTexEnviv ( IN GLenum target, IN GLenum pname, IN const GLint params[] )
{
    WARNING_NOOP("GL Noop:glTexEnviv\n");
}

void APIENTRY
glnoopTexGend ( IN GLenum coord, IN GLenum pname, IN GLdouble param )
{
    WARNING_NOOP("GL Noop:glTexGend\n");
}

void APIENTRY
glnoopTexGendv ( IN GLenum coord, IN GLenum pname, IN const GLdouble params[] )
{
    WARNING_NOOP("GL Noop:glTexGendv\n");
}

void APIENTRY
glnoopTexGenf ( IN GLenum coord, IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glTexGenf\n");
}

void APIENTRY
glnoopTexGenfv ( IN GLenum coord, IN GLenum pname, IN const GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glTexGenfv\n");
}

void APIENTRY
glnoopTexGeni ( IN GLenum coord, IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glTexGeni\n");
}

void APIENTRY
glnoopTexGeniv ( IN GLenum coord, IN GLenum pname, IN const GLint params[] )
{
    WARNING_NOOP("GL Noop:glTexGeniv\n");
}

void APIENTRY
glnoopFeedbackBuffer ( IN GLsizei size, IN GLenum type, OUT GLfloat buffer[] )
{
    WARNING_NOOP("GL Noop:glFeedbackBuffer\n");
}

void APIENTRY
glnoopSelectBuffer ( IN GLsizei size, OUT GLuint buffer[] )
{
    WARNING_NOOP("GL Noop:glSelectBuffer\n");
}

GLint APIENTRY
glnoopRenderMode ( IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glRenderMode\n");
    return((GLint) 0);
}

void APIENTRY
glnoopInitNames ( void )
{
    WARNING_NOOP("GL Noop:glInitNames\n");
}

void APIENTRY
glnoopLoadName ( IN GLuint name )
{
    WARNING_NOOP("GL Noop:glLoadName\n");
}

void APIENTRY
glnoopPassThrough ( IN GLfloat token )
{
    WARNING_NOOP("GL Noop:glPassThrough\n");
}

void APIENTRY
glnoopPopName ( void )
{
    WARNING_NOOP("GL Noop:glPopName\n");
}

void APIENTRY
glnoopPushName ( IN GLuint name )
{
    WARNING_NOOP("GL Noop:glPushName\n");
}

void APIENTRY
glnoopDrawBuffer ( IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glDrawBuffer\n");
}

void APIENTRY
glnoopClear ( IN GLbitfield mask )
{
    WARNING_NOOP("GL Noop:glClear\n");
}

void APIENTRY
glnoopClearAccum ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    WARNING_NOOP("GL Noop:glClearAccum\n");
}

void APIENTRY
glnoopClearIndex ( IN GLfloat c )
{
    WARNING_NOOP("GL Noop:glClearIndex\n");
}

void APIENTRY
glnoopClearColor ( IN GLclampf red, IN GLclampf green, IN GLclampf blue, IN GLclampf alpha )
{
    WARNING_NOOP("GL Noop:glClearColor\n");
}

void APIENTRY
glnoopClearStencil ( IN GLint s )
{
    WARNING_NOOP("GL Noop:glClearStencil\n");
}

void APIENTRY
glnoopClearDepth ( IN GLclampd depth )
{
    WARNING_NOOP("GL Noop:glClearDepth\n");
}

void APIENTRY
glnoopStencilMask ( IN GLuint mask )
{
    WARNING_NOOP("GL Noop:glStencilMask\n");
}

void APIENTRY
glnoopColorMask ( IN GLboolean red, IN GLboolean green, IN GLboolean blue, IN GLboolean alpha )
{
    WARNING_NOOP("GL Noop:glColorMask\n");
}

void APIENTRY
glnoopDepthMask ( IN GLboolean flag )
{
    WARNING_NOOP("GL Noop:glDepthMask\n");
}

void APIENTRY
glnoopIndexMask ( IN GLuint mask )
{
    WARNING_NOOP("GL Noop:glIndexMask\n");
}

void APIENTRY
glnoopAccum ( IN GLenum op, IN GLfloat value )
{
    WARNING_NOOP("GL Noop:glAccum\n");
}

void APIENTRY
glnoopDisable ( IN GLenum cap )
{
    WARNING_NOOP("GL Noop:glDisable\n");
}

void APIENTRY
glnoopEnable ( IN GLenum cap )
{
    WARNING_NOOP("GL Noop:glEnable\n");
}

void APIENTRY
glnoopFinish ( void )
{
    WARNING_NOOP("GL Noop:glFinish\n");
}

void APIENTRY
glnoopFlush ( void )
{
    WARNING_NOOP("GL Noop:glFlush\n");
}

void APIENTRY
glnoopPopAttrib ( void )
{
    WARNING_NOOP("GL Noop:glPopAttrib\n");
}

void APIENTRY
glnoopPushAttrib ( IN GLbitfield mask )
{
    WARNING_NOOP("GL Noop:glPushAttrib\n");
}

void APIENTRY
glnoopMap1d ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint stride, IN GLint order, IN const GLdouble points[] )
{
    WARNING_NOOP("GL Noop:glMap1d\n");
}

void APIENTRY
glnoopMap1f ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint stride, IN GLint order, IN const GLfloat points[] )
{
    WARNING_NOOP("GL Noop:glMap1f\n");
}

void APIENTRY
glnoopMap2d ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint ustride, IN GLint uorder, IN GLdouble v1, IN GLdouble v2, IN GLint vstride, IN GLint vorder, IN const GLdouble points[] )
{
    WARNING_NOOP("GL Noop:glMap2d\n");
}

void APIENTRY
glnoopMap2f ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint ustride, IN GLint uorder, IN GLfloat v1, IN GLfloat v2, IN GLint vstride, IN GLint vorder, IN const GLfloat points[] )
{
    WARNING_NOOP("GL Noop:glMap2f\n");
}

void APIENTRY
glnoopMapGrid1d ( IN GLint un, IN GLdouble u1, IN GLdouble u2 )
{
    WARNING_NOOP("GL Noop:glMapGrid1d\n");
}

void APIENTRY
glnoopMapGrid1f ( IN GLint un, IN GLfloat u1, IN GLfloat u2 )
{
    WARNING_NOOP("GL Noop:glMapGrid1f\n");
}

void APIENTRY
glnoopMapGrid2d ( IN GLint un, IN GLdouble u1, IN GLdouble u2, IN GLint vn, IN GLdouble v1, IN GLdouble v2 )
{
    WARNING_NOOP("GL Noop:glMapGrid2d\n");
}

void APIENTRY
glnoopMapGrid2f ( IN GLint un, IN GLfloat u1, IN GLfloat u2, IN GLint vn, IN GLfloat v1, IN GLfloat v2 )
{
    WARNING_NOOP("GL Noop:glMapGrid2f\n");
}

void APIENTRY
glnoopEvalCoord1d ( IN GLdouble u )
{
    WARNING_NOOP("GL Noop:glEvalCoord1d\n");
}

void APIENTRY
glnoopEvalCoord1dv ( IN const GLdouble u[1] )
{
    WARNING_NOOP("GL Noop:glEvalCoord1dv\n");
}

void APIENTRY
glnoopEvalCoord1f ( IN GLfloat u )
{
    WARNING_NOOP("GL Noop:glEvalCoord1f\n");
}

void APIENTRY
glnoopEvalCoord1fv ( IN const GLfloat u[1] )
{
    WARNING_NOOP("GL Noop:glEvalCoord1fv\n");
}

void APIENTRY
glnoopEvalCoord2d ( IN GLdouble u, IN GLdouble v )
{
    WARNING_NOOP("GL Noop:glEvalCoord2d\n");
}

void APIENTRY
glnoopEvalCoord2dv ( IN const GLdouble u[2] )
{
    WARNING_NOOP("GL Noop:glEvalCoord2dv\n");
}

void APIENTRY
glnoopEvalCoord2f ( IN GLfloat u, IN GLfloat v )
{
    WARNING_NOOP("GL Noop:glEvalCoord2f\n");
}

void APIENTRY
glnoopEvalCoord2fv ( IN const GLfloat u[2] )
{
    WARNING_NOOP("GL Noop:glEvalCoord2fv\n");
}

void APIENTRY
glnoopEvalMesh1 ( IN GLenum mode, IN GLint i1, IN GLint i2 )
{
    WARNING_NOOP("GL Noop:glEvalMesh1\n");
}

void APIENTRY
glnoopEvalPoint1 ( IN GLint i )
{
    WARNING_NOOP("GL Noop:glEvalPoint1\n");
}

void APIENTRY
glnoopEvalMesh2 ( IN GLenum mode, IN GLint i1, IN GLint i2, IN GLint j1, IN GLint j2 )
{
    WARNING_NOOP("GL Noop:glEvalMesh2\n");
}

void APIENTRY
glnoopEvalPoint2 ( IN GLint i, IN GLint j )
{
    WARNING_NOOP("GL Noop:glEvalPoint2\n");
}

void APIENTRY
glnoopAlphaFunc ( IN GLenum func, IN GLclampf ref )
{
    WARNING_NOOP("GL Noop:glAlphaFunc\n");
}

void APIENTRY
glnoopBlendFunc ( IN GLenum sfactor, IN GLenum dfactor )
{
    WARNING_NOOP("GL Noop:glBlendFunc\n");
}

void APIENTRY
glnoopLogicOp ( IN GLenum opcode )
{
    WARNING_NOOP("GL Noop:glLogicOp\n");
}

void APIENTRY
glnoopStencilFunc ( IN GLenum func, IN GLint ref, IN GLuint mask )
{
    WARNING_NOOP("GL Noop:glStencilFunc\n");
}

void APIENTRY
glnoopStencilOp ( IN GLenum fail, IN GLenum zfail, IN GLenum zpass )
{
    WARNING_NOOP("GL Noop:glStencilOp\n");
}

void APIENTRY
glnoopDepthFunc ( IN GLenum func )
{
    WARNING_NOOP("GL Noop:glDepthFunc\n");
}

void APIENTRY
glnoopPixelZoom ( IN GLfloat xfactor, IN GLfloat yfactor )
{
    WARNING_NOOP("GL Noop:glPixelZoom\n");
}

void APIENTRY
glnoopPixelTransferf ( IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glPixelTransferf\n");
}

void APIENTRY
glnoopPixelTransferi ( IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glPixelTransferi\n");
}

void APIENTRY
glnoopPixelStoref ( IN GLenum pname, IN GLfloat param )
{
    WARNING_NOOP("GL Noop:glPixelStoref\n");
}

void APIENTRY
glnoopPixelStorei ( IN GLenum pname, IN GLint param )
{
    WARNING_NOOP("GL Noop:glPixelStorei\n");
}

void APIENTRY
glnoopPixelMapfv ( IN GLenum map, IN GLint mapsize, IN const GLfloat values[] )
{
    WARNING_NOOP("GL Noop:glPixelMapfv\n");
}

void APIENTRY
glnoopPixelMapuiv ( IN GLenum map, IN GLint mapsize, IN const GLuint values[] )
{
    WARNING_NOOP("GL Noop:glPixelMapuiv\n");
}

void APIENTRY
glnoopPixelMapusv ( IN GLenum map, IN GLint mapsize, IN const GLushort values[] )
{
    WARNING_NOOP("GL Noop:glPixelMapusv\n");
}

void APIENTRY
glnoopReadBuffer ( IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glReadBuffer\n");
}

void APIENTRY
glnoopCopyPixels ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum type )
{
    WARNING_NOOP("GL Noop:glCopyPixels\n");
}

void APIENTRY
glnoopReadPixels ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum format, IN GLenum type, OUT GLvoid *pixels )
{
    WARNING_NOOP("GL Noop:glReadPixels\n");
}

void APIENTRY
glnoopDrawPixels ( IN GLsizei width, IN GLsizei height, IN GLenum format, IN GLenum type, IN const GLvoid *pixels )
{
    WARNING_NOOP("GL Noop:glDrawPixels\n");
}

void APIENTRY
glnoopGetBooleanv ( IN GLenum pname, OUT GLboolean params[] )
{
    WARNING_NOOP("GL Noop:glGetBooleanv\n");
}

void APIENTRY
glnoopGetClipPlane ( IN GLenum plane, OUT GLdouble equation[4] )
{
    WARNING_NOOP("GL Noop:glGetClipPlane\n");
}

void APIENTRY
glnoopGetDoublev ( IN GLenum pname, OUT GLdouble params[] )
{
    WARNING_NOOP("GL Noop:glGetDoublev\n");
}

GLenum APIENTRY
glnoopGetError ( void )
{
    WARNING_NOOP("GL Noop:glGetError\n");
    return(GL_INVALID_OPERATION);
}

void APIENTRY
glnoopGetFloatv ( IN GLenum pname, OUT GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glGetFloatv\n");
}

void APIENTRY
glnoopGetIntegerv ( IN GLenum pname, OUT GLint params[] )
{
    WARNING_NOOP("GL Noop:glGetIntegerv\n");
}

void APIENTRY
glnoopGetLightfv ( IN GLenum light, IN GLenum pname, OUT GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glGetLightfv\n");
}

void APIENTRY
glnoopGetLightiv ( IN GLenum light, IN GLenum pname, OUT GLint params[] )
{
    WARNING_NOOP("GL Noop:glGetLightiv\n");
}

void APIENTRY
glnoopGetMapdv ( IN GLenum target, IN GLenum query, OUT GLdouble v[] )
{
    WARNING_NOOP("GL Noop:glGetMapdv\n");
}

void APIENTRY
glnoopGetMapfv ( IN GLenum target, IN GLenum query, OUT GLfloat v[] )
{
    WARNING_NOOP("GL Noop:glGetMapfv\n");
}

void APIENTRY
glnoopGetMapiv ( IN GLenum target, IN GLenum query, OUT GLint v[] )
{
    WARNING_NOOP("GL Noop:glGetMapiv\n");
}

void APIENTRY
glnoopGetMaterialfv ( IN GLenum face, IN GLenum pname, OUT GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glGetMaterialfv\n");
}

void APIENTRY
glnoopGetMaterialiv ( IN GLenum face, IN GLenum pname, OUT GLint params[] )
{
    WARNING_NOOP("GL Noop:glGetMaterialiv\n");
}

void APIENTRY
glnoopGetPixelMapfv ( IN GLenum map, OUT GLfloat values[] )
{
    WARNING_NOOP("GL Noop:glGetPixelMapfv\n");
}

void APIENTRY
glnoopGetPixelMapuiv ( IN GLenum map, OUT GLuint values[] )
{
    WARNING_NOOP("GL Noop:glGetPixelMapuiv\n");
}

void APIENTRY
glnoopGetPixelMapusv ( IN GLenum map, OUT GLushort values[] )
{
    WARNING_NOOP("GL Noop:glGetPixelMapusv\n");
}

void APIENTRY
glnoopGetPolygonStipple ( OUT GLubyte mask[128] )
{
    WARNING_NOOP("GL Noop:glGetPolygonStipple\n");
}

const GLubyte * APIENTRY
glnoopGetString ( IN GLenum name )
{
    WARNING_NOOP("GL Noop:glGetString\n");
    return((const GLubyte *) NULL);
}

void APIENTRY
glnoopGetTexEnvfv ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glGetTexEnvfv\n");
}

void APIENTRY
glnoopGetTexEnviv ( IN GLenum target, IN GLenum pname, OUT GLint params[] )
{
    WARNING_NOOP("GL Noop:glGetTexEnviv\n");
}

void APIENTRY
glnoopGetTexGendv ( IN GLenum coord, IN GLenum pname, OUT GLdouble params[] )
{
    WARNING_NOOP("GL Noop:glGetTexGendv\n");
}

void APIENTRY
glnoopGetTexGenfv ( IN GLenum coord, IN GLenum pname, OUT GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glGetTexGenfv\n");
}

void APIENTRY
glnoopGetTexGeniv ( IN GLenum coord, IN GLenum pname, OUT GLint params[] )
{
    WARNING_NOOP("GL Noop:glGetTexGeniv\n");
}

void APIENTRY
glnoopGetTexImage ( IN GLenum target, IN GLint level, IN GLenum format, IN GLenum type, OUT GLvoid *pixels )
{
    WARNING_NOOP("GL Noop:glGetTexImage\n");
}

void APIENTRY
glnoopGetTexParameterfv ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glGetTexParameterfv\n");
}

void APIENTRY
glnoopGetTexParameteriv ( IN GLenum target, IN GLenum pname, OUT GLint params[] )
{
    WARNING_NOOP("GL Noop:glGetTexParameteriv\n");
}

void APIENTRY
glnoopGetTexLevelParameterfv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLfloat params[] )
{
    WARNING_NOOP("GL Noop:glGetTexLevelParameterfv\n");
}

void APIENTRY
glnoopGetTexLevelParameteriv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLint params[] )
{
    WARNING_NOOP("GL Noop:glGetTexLevelParameteriv\n");
}

GLboolean APIENTRY
glnoopIsEnabled ( IN GLenum cap )
{
    WARNING_NOOP("GL Noop:glIsEnabled\n");
    return((GLboolean) FALSE);
}

GLboolean APIENTRY
glnoopIsList ( IN GLuint list )
{
    WARNING_NOOP("GL Noop:glIsList\n");
    return((GLboolean) FALSE);
}

void APIENTRY
glnoopDepthRange ( IN GLclampd zNear, IN GLclampd zFar )
{
    WARNING_NOOP("GL Noop:glDepthRange\n");
}

void APIENTRY
glnoopFrustum ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar )
{
    WARNING_NOOP("GL Noop:glFrustum\n");
}

void APIENTRY
glnoopLoadIdentity ( void )
{
    WARNING_NOOP("GL Noop:glLoadIdentity\n");
}

void APIENTRY
glnoopLoadMatrixf ( IN const GLfloat m[16] )
{
    WARNING_NOOP("GL Noop:glLoadMatrixf\n");
}

void APIENTRY
glnoopLoadMatrixd ( IN const GLdouble m[16] )
{
    WARNING_NOOP("GL Noop:glLoadMatrixd\n");
}

void APIENTRY
glnoopMatrixMode ( IN GLenum mode )
{
    WARNING_NOOP("GL Noop:glMatrixMode\n");
}

void APIENTRY
glnoopMultMatrixf ( IN const GLfloat m[16] )
{
    WARNING_NOOP("GL Noop:glMultMatrixf\n");
}

void APIENTRY
glnoopMultMatrixd ( IN const GLdouble m[16] )
{
    WARNING_NOOP("GL Noop:glMultMatrixd\n");
}

void APIENTRY
glnoopOrtho ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar )
{
    WARNING_NOOP("GL Noop:glOrtho\n");
}

void APIENTRY
glnoopPopMatrix ( void )
{
    WARNING_NOOP("GL Noop:glPopMatrix\n");
}

void APIENTRY
glnoopPushMatrix ( void )
{
    WARNING_NOOP("GL Noop:glPushMatrix\n");
}

void APIENTRY
glnoopRotated ( IN GLdouble angle, IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    WARNING_NOOP("GL Noop:glRotated\n");
}

void APIENTRY
glnoopRotatef ( IN GLfloat angle, IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    WARNING_NOOP("GL Noop:glRotatef\n");
}

void APIENTRY
glnoopScaled ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    WARNING_NOOP("GL Noop:glScaled\n");
}

void APIENTRY
glnoopScalef ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    WARNING_NOOP("GL Noop:glScalef\n");
}

void APIENTRY
glnoopTranslated ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    WARNING_NOOP("GL Noop:glTranslated\n");
}

void APIENTRY
glnoopTranslatef ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    WARNING_NOOP("GL Noop:glTranslatef\n");
}

void APIENTRY
glnoopViewport ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height )
{
    WARNING_NOOP("GL Noop:glViewport\n");
}

GLboolean APIENTRY
glnoopAreTexturesResident(GLsizei n, const GLuint *textures,
                                            GLboolean *residences)
{
    WARNING_NOOP("GL Noop:glAreTexturesResident\n");
    return GL_FALSE;
}

void APIENTRY
glnoopBindTexture(GLenum target, GLuint texture)
{
    WARNING_NOOP("GL Noop:glBindTexture\n");
}

void APIENTRY
glnoopCopyTexImage1D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLint border)
{
    WARNING_NOOP("GL Noop:glCopyTexImage1D\n");
}

void APIENTRY
glnoopCopyTexImage2D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLsizei height, GLint border)
{
    WARNING_NOOP("GL Noop:glCopyTexImage2D\n");
}

void APIENTRY
glnoopCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                     GLint x, GLint y, GLsizei width)
{
    WARNING_NOOP("GL Noop:glCopyTexSubImage1D\n");
}

void APIENTRY
glnoopCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                     GLint yoffset, GLint x, GLint y,
                                     GLsizei width, GLsizei height)
{
    WARNING_NOOP("GL Noop:glCopyTexSubImage2D\n");
}

void APIENTRY
glnoopDeleteTextures(GLsizei n, const GLuint *textures)
{
    WARNING_NOOP("GL Noop:glDeleteTextures\n");
}

void APIENTRY
glnoopGenTextures(GLsizei n, GLuint *textures)
{
    WARNING_NOOP("GL Noop:glGenTextures\n");
}

GLboolean APIENTRY
glnoopIsTexture(GLuint texture)
{
    WARNING_NOOP("GL Noop:glIsTexture\n");
    return GL_FALSE;
}

void APIENTRY
glnoopPrioritizeTextures(GLsizei n, const GLuint *textures,
                                      const GLclampf *priorities)
{
    WARNING_NOOP("GL Noop:glPrioritizeTextures\n");
}

void APIENTRY
glnoopTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid *pixels)
{
    WARNING_NOOP("GL Noop:glTexSubImage1D\n");
}

void APIENTRY
glnoopTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels)
{
    WARNING_NOOP("GL Noop:glTexSubImage2D\n");
}

void APIENTRY
glnoopArrayElement(GLint i)
{
    WARNING_NOOP("GL Noop:glArrayElement\n");
}

void APIENTRY
glnoopColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    WARNING_NOOP("GL Noop:glColorPointer\n");
}

void APIENTRY
glnoopDisableClientState(GLenum array)
{
    WARNING_NOOP("GL Noop:glDisableClientState\n");
}

void APIENTRY
glnoopDrawArrays(GLenum mode, GLint first, GLsizei count)
{
    WARNING_NOOP("GL Noop:glDrawArrays\n");
}

void APIENTRY
glnoopDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
    WARNING_NOOP("GL Noop:glDrawElements\n");
}

void APIENTRY
glnoopEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
{
    WARNING_NOOP("GL Noop:glEdgeFlagPointer\n");
}

void APIENTRY
glnoopEnableClientState(GLenum array)
{
    WARNING_NOOP("GL Noop:glEnableClientState\n");
}

void APIENTRY
glnoopIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
    WARNING_NOOP("GL Noop:glIndexPointer\n");
}

void APIENTRY
glnoopIndexub(GLubyte c)
{
    WARNING_NOOP("GL Noop:glIndexub\n");
}

void APIENTRY
glnoopIndexubv(const GLubyte *c)
{
    WARNING_NOOP("GL Noop:glIndexubv\n");
}

void APIENTRY
glnoopInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
{
    WARNING_NOOP("GL Noop:glInterleavedArrays\n");
}

void APIENTRY
glnoopNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
    WARNING_NOOP("GL Noop:glNormalPointer\n");
}

void APIENTRY
glnoopPolygonOffset(GLfloat factor, GLfloat units)
{
    WARNING_NOOP("GL Noop:glPolygonOffset\n");
}

void APIENTRY
glnoopTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    WARNING_NOOP("GL Noop:glTexCoordPointer\n");
}

void APIENTRY
glnoopVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    WARNING_NOOP("GL Noop:glVertexPointer\n");
}

void APIENTRY
glnoopGetPointerv(GLenum pname, GLvoid* *params)
{
    WARNING_NOOP("GL Noop:glGetPointerv\n");
}

void APIENTRY
glnoopPopClientAttrib(void)
{
    WARNING_NOOP("GL Noop:glPopClientAttrib\n");
}

void APIENTRY
glnoopPushClientAttrib(IN GLbitfield mask)
{
    WARNING_NOOP("GL Noop:glPushClientAttrib\n");
}


/* Client Side Procedure Table */

GLCLTPROCTABLE glNullCltProcTable = {

/* Number of function entries in the table */

     sizeof(GLDISPATCHTABLE) / sizeof(PROC),

/* gl Entry points */
  {
     glnoopNewList                ,
     glnoopEndList                ,
     glnoopCallList               ,
     glnoopCallLists              ,
     glnoopDeleteLists            ,
     glnoopGenLists               ,
     glnoopListBase               ,
     glnoopBegin                  ,
     glnoopBitmap                 ,
     glnoopColor3b                ,
     glnoopColor3bv               ,
     glnoopColor3d                ,
     glnoopColor3dv               ,
     glnoopColor3f                ,
     glnoopColor3fv               ,
     glnoopColor3i                ,
     glnoopColor3iv               ,
     glnoopColor3s                ,
     glnoopColor3sv               ,
     glnoopColor3ub               ,
     glnoopColor3ubv              ,
     glnoopColor3ui               ,
     glnoopColor3uiv              ,
     glnoopColor3us               ,
     glnoopColor3usv              ,
     glnoopColor4b                ,
     glnoopColor4bv               ,
     glnoopColor4d                ,
     glnoopColor4dv               ,
     glnoopColor4f                ,
     glnoopColor4fv               ,
     glnoopColor4i                ,
     glnoopColor4iv               ,
     glnoopColor4s                ,
     glnoopColor4sv               ,
     glnoopColor4ub               ,
     glnoopColor4ubv              ,
     glnoopColor4ui               ,
     glnoopColor4uiv              ,
     glnoopColor4us               ,
     glnoopColor4usv              ,
     glnoopEdgeFlag               ,
     glnoopEdgeFlagv              ,
     glnoopEnd                    ,
     glnoopIndexd                 ,
     glnoopIndexdv                ,
     glnoopIndexf                 ,
     glnoopIndexfv                ,
     glnoopIndexi                 ,
     glnoopIndexiv                ,
     glnoopIndexs                 ,
     glnoopIndexsv                ,
     glnoopNormal3b               ,
     glnoopNormal3bv              ,
     glnoopNormal3d               ,
     glnoopNormal3dv              ,
     glnoopNormal3f               ,
     glnoopNormal3fv              ,
     glnoopNormal3i               ,
     glnoopNormal3iv              ,
     glnoopNormal3s               ,
     glnoopNormal3sv              ,
     glnoopRasterPos2d            ,
     glnoopRasterPos2dv           ,
     glnoopRasterPos2f            ,
     glnoopRasterPos2fv           ,
     glnoopRasterPos2i            ,
     glnoopRasterPos2iv           ,
     glnoopRasterPos2s            ,
     glnoopRasterPos2sv           ,
     glnoopRasterPos3d            ,
     glnoopRasterPos3dv           ,
     glnoopRasterPos3f            ,
     glnoopRasterPos3fv           ,
     glnoopRasterPos3i            ,
     glnoopRasterPos3iv           ,
     glnoopRasterPos3s            ,
     glnoopRasterPos3sv           ,
     glnoopRasterPos4d            ,
     glnoopRasterPos4dv           ,
     glnoopRasterPos4f            ,
     glnoopRasterPos4fv           ,
     glnoopRasterPos4i            ,
     glnoopRasterPos4iv           ,
     glnoopRasterPos4s            ,
     glnoopRasterPos4sv           ,
     glnoopRectd                  ,
     glnoopRectdv                 ,
     glnoopRectf                  ,
     glnoopRectfv                 ,
     glnoopRecti                  ,
     glnoopRectiv                 ,
     glnoopRects                  ,
     glnoopRectsv                 ,
     glnoopTexCoord1d             ,
     glnoopTexCoord1dv            ,
     glnoopTexCoord1f             ,
     glnoopTexCoord1fv            ,
     glnoopTexCoord1i             ,
     glnoopTexCoord1iv            ,
     glnoopTexCoord1s             ,
     glnoopTexCoord1sv            ,
     glnoopTexCoord2d             ,
     glnoopTexCoord2dv            ,
     glnoopTexCoord2f             ,
     glnoopTexCoord2fv            ,
     glnoopTexCoord2i             ,
     glnoopTexCoord2iv            ,
     glnoopTexCoord2s             ,
     glnoopTexCoord2sv            ,
     glnoopTexCoord3d             ,
     glnoopTexCoord3dv            ,
     glnoopTexCoord3f             ,
     glnoopTexCoord3fv            ,
     glnoopTexCoord3i             ,
     glnoopTexCoord3iv            ,
     glnoopTexCoord3s             ,
     glnoopTexCoord3sv            ,
     glnoopTexCoord4d             ,
     glnoopTexCoord4dv            ,
     glnoopTexCoord4f             ,
     glnoopTexCoord4fv            ,
     glnoopTexCoord4i             ,
     glnoopTexCoord4iv            ,
     glnoopTexCoord4s             ,
     glnoopTexCoord4sv            ,
     glnoopVertex2d               ,
     glnoopVertex2dv              ,
     glnoopVertex2f               ,
     glnoopVertex2fv              ,
     glnoopVertex2i               ,
     glnoopVertex2iv              ,
     glnoopVertex2s               ,
     glnoopVertex2sv              ,
     glnoopVertex3d               ,
     glnoopVertex3dv              ,
     glnoopVertex3f               ,
     glnoopVertex3fv              ,
     glnoopVertex3i               ,
     glnoopVertex3iv              ,
     glnoopVertex3s               ,
     glnoopVertex3sv              ,
     glnoopVertex4d               ,
     glnoopVertex4dv              ,
     glnoopVertex4f               ,
     glnoopVertex4fv              ,
     glnoopVertex4i               ,
     glnoopVertex4iv              ,
     glnoopVertex4s               ,
     glnoopVertex4sv              ,
     glnoopClipPlane              ,
     glnoopColorMaterial          ,
     glnoopCullFace               ,
     glnoopFogf                   ,
     glnoopFogfv                  ,
     glnoopFogi                   ,
     glnoopFogiv                  ,
     glnoopFrontFace              ,
     glnoopHint                   ,
     glnoopLightf                 ,
     glnoopLightfv                ,
     glnoopLighti                 ,
     glnoopLightiv                ,
     glnoopLightModelf            ,
     glnoopLightModelfv           ,
     glnoopLightModeli            ,
     glnoopLightModeliv           ,
     glnoopLineStipple            ,
     glnoopLineWidth              ,
     glnoopMaterialf              ,
     glnoopMaterialfv             ,
     glnoopMateriali              ,
     glnoopMaterialiv             ,
     glnoopPointSize              ,
     glnoopPolygonMode            ,
     glnoopPolygonStipple         ,
     glnoopScissor                ,
     glnoopShadeModel             ,
     glnoopTexParameterf          ,
     glnoopTexParameterfv         ,
     glnoopTexParameteri          ,
     glnoopTexParameteriv         ,
     glnoopTexImage1D             ,
     glnoopTexImage2D             ,
     glnoopTexEnvf                ,
     glnoopTexEnvfv               ,
     glnoopTexEnvi                ,
     glnoopTexEnviv               ,
     glnoopTexGend                ,
     glnoopTexGendv               ,
     glnoopTexGenf                ,
     glnoopTexGenfv               ,
     glnoopTexGeni                ,
     glnoopTexGeniv               ,
     glnoopFeedbackBuffer         ,
     glnoopSelectBuffer           ,
     glnoopRenderMode             ,
     glnoopInitNames              ,
     glnoopLoadName               ,
     glnoopPassThrough            ,
     glnoopPopName                ,
     glnoopPushName               ,
     glnoopDrawBuffer             ,
     glnoopClear                  ,
     glnoopClearAccum             ,
     glnoopClearIndex             ,
     glnoopClearColor             ,
     glnoopClearStencil           ,
     glnoopClearDepth             ,
     glnoopStencilMask            ,
     glnoopColorMask              ,
     glnoopDepthMask              ,
     glnoopIndexMask              ,
     glnoopAccum                  ,
     glnoopDisable                ,
     glnoopEnable                 ,
     glnoopFinish                 ,
     glnoopFlush                  ,
     glnoopPopAttrib              ,
     glnoopPushAttrib             ,
     glnoopMap1d                  ,
     glnoopMap1f                  ,
     glnoopMap2d                  ,
     glnoopMap2f                  ,
     glnoopMapGrid1d              ,
     glnoopMapGrid1f              ,
     glnoopMapGrid2d              ,
     glnoopMapGrid2f              ,
     glnoopEvalCoord1d            ,
     glnoopEvalCoord1dv           ,
     glnoopEvalCoord1f            ,
     glnoopEvalCoord1fv           ,
     glnoopEvalCoord2d            ,
     glnoopEvalCoord2dv           ,
     glnoopEvalCoord2f            ,
     glnoopEvalCoord2fv           ,
     glnoopEvalMesh1              ,
     glnoopEvalPoint1             ,
     glnoopEvalMesh2              ,
     glnoopEvalPoint2             ,
     glnoopAlphaFunc              ,
     glnoopBlendFunc              ,
     glnoopLogicOp                ,
     glnoopStencilFunc            ,
     glnoopStencilOp              ,
     glnoopDepthFunc              ,
     glnoopPixelZoom              ,
     glnoopPixelTransferf         ,
     glnoopPixelTransferi         ,
     glnoopPixelStoref            ,
     glnoopPixelStorei            ,
     glnoopPixelMapfv             ,
     glnoopPixelMapuiv            ,
     glnoopPixelMapusv            ,
     glnoopReadBuffer             ,
     glnoopCopyPixels             ,
     glnoopReadPixels             ,
     glnoopDrawPixels             ,
     glnoopGetBooleanv            ,
     glnoopGetClipPlane           ,
     glnoopGetDoublev             ,
     glnoopGetError               ,
     glnoopGetFloatv              ,
     glnoopGetIntegerv            ,
     glnoopGetLightfv             ,
     glnoopGetLightiv             ,
     glnoopGetMapdv               ,
     glnoopGetMapfv               ,
     glnoopGetMapiv               ,
     glnoopGetMaterialfv          ,
     glnoopGetMaterialiv          ,
     glnoopGetPixelMapfv          ,
     glnoopGetPixelMapuiv         ,
     glnoopGetPixelMapusv         ,
     glnoopGetPolygonStipple      ,
     glnoopGetString              ,
     glnoopGetTexEnvfv            ,
     glnoopGetTexEnviv            ,
     glnoopGetTexGendv            ,
     glnoopGetTexGenfv            ,
     glnoopGetTexGeniv            ,
     glnoopGetTexImage            ,
     glnoopGetTexParameterfv      ,
     glnoopGetTexParameteriv      ,
     glnoopGetTexLevelParameterfv ,
     glnoopGetTexLevelParameteriv ,
     glnoopIsEnabled              ,
     glnoopIsList                 ,
     glnoopDepthRange             ,
     glnoopFrustum                ,
     glnoopLoadIdentity           ,
     glnoopLoadMatrixf            ,
     glnoopLoadMatrixd            ,
     glnoopMatrixMode             ,
     glnoopMultMatrixf            ,
     glnoopMultMatrixd            ,
     glnoopOrtho                  ,
     glnoopPopMatrix              ,
     glnoopPushMatrix             ,
     glnoopRotated                ,
     glnoopRotatef                ,
     glnoopScaled                 ,
     glnoopScalef                 ,
     glnoopTranslated             ,
     glnoopTranslatef             ,
     glnoopViewport               ,
     glnoopArrayElement           ,
     glnoopBindTexture            ,
     glnoopColorPointer           ,
     glnoopDisableClientState     ,
     glnoopDrawArrays             ,
     glnoopDrawElements           ,
     glnoopEdgeFlagPointer        ,
     glnoopEnableClientState      ,
     glnoopIndexPointer           ,
     glnoopIndexub                ,
     glnoopIndexubv               ,
     glnoopInterleavedArrays      ,
     glnoopNormalPointer          ,
     glnoopPolygonOffset          ,
     glnoopTexCoordPointer        ,
     glnoopVertexPointer          ,
     glnoopAreTexturesResident    ,
     glnoopCopyTexImage1D         ,
     glnoopCopyTexImage2D         ,
     glnoopCopyTexSubImage1D      ,
     glnoopCopyTexSubImage2D      ,
     glnoopDeleteTextures         ,
     glnoopGenTextures            ,
     glnoopGetPointerv            ,
     glnoopIsTexture              ,
     glnoopPrioritizeTextures     ,
     glnoopTexSubImage1D          ,
     glnoopTexSubImage2D          ,
     glnoopPopClientAttrib        ,
     glnoopPushClientAttrib       ,
  }

};

void APIENTRY
glnoopDrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
    WARNING_NOOP("GL Noop:glDrawRangeElementsWIN\n");
}

void glnoopColorTableEXT( GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *data)
{
    WARNING_NOOP("GL Noop:glColorTableEXT\n");
}

void glnoopColorSubTableEXT( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
{
    WARNING_NOOP("GL Noop:glColorSubTableEXT\n");
}

void glnoopGetColorTableEXT( GLenum target, GLenum format, GLenum type, GLvoid *data)
{
    WARNING_NOOP("GL Noop:glGetColorTableEXT\n");
}

void glnoopGetColorTableParameterivEXT( GLenum target, GLenum pname, GLint *params)
{
    WARNING_NOOP("GL Noop:glGetColorTableParameterivEXT\n");
}

void glnoopGetColorTableParameterfvEXT( GLenum target, GLenum pname, GLfloat *params)
{
    WARNING_NOOP("GL Noop:glGetColorTableParameterfvEXT\n");
}

#ifdef GL_WIN_multiple_textures
void glnoopCurrentTextureIndexWIN
    (GLuint index)
{
    WARNING_NOOP("GL Noop:glCurrentTextureIndexWIN\n");
}

void glnoopMultiTexCoord1dWIN
    (GLbitfield mask, GLdouble s)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord1dWIN\n");
}

void glnoopMultiTexCoord1dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord1dvWIN\n");
}

void glnoopMultiTexCoord1fWIN
    (GLbitfield mask, GLfloat s)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord1fWIN\n");
}

void glnoopMultiTexCoord1fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord1fvWIN\n");
}

void glnoopMultiTexCoord1iWIN
    (GLbitfield mask, GLint s)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord1iWIN\n");
}

void glnoopMultiTexCoord1ivWIN
    (GLbitfield mask, const GLint *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord1ivWIN\n");
}

void glnoopMultiTexCoord1sWIN
    (GLbitfield mask, GLshort s)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord1sWIN\n");
}

void glnoopMultiTexCoord1svWIN
    (GLbitfield mask, const GLshort *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord1svWIN\n");
}

void glnoopMultiTexCoord2dWIN
    (GLbitfield mask, GLdouble s, GLdouble t)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord2dWIN\n");
}

void glnoopMultiTexCoord2dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord2dvWIN\n");
}

void glnoopMultiTexCoord2fWIN
    (GLbitfield mask, GLfloat s, GLfloat t)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord2fWIN\n");
}

void glnoopMultiTexCoord2fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord2fvWIN\n");
}

void glnoopMultiTexCoord2iWIN
    (GLbitfield mask, GLint s, GLint t)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord2iWIN\n");
}

void glnoopMultiTexCoord2ivWIN
    (GLbitfield mask, const GLint *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord2ivWIN\n");
}

void glnoopMultiTexCoord2sWIN
    (GLbitfield mask, GLshort s, GLshort t)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord2sWIN\n");
}

void glnoopMultiTexCoord2svWIN
    (GLbitfield mask, const GLshort *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord2svWIN\n");
}

void glnoopMultiTexCoord3dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord3dWIN\n");
}

void glnoopMultiTexCoord3dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord3dvWIN\n");
}

void glnoopMultiTexCoord3fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord3fWIN\n");
}

void glnoopMultiTexCoord3fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord3fvWIN\n");
}

void glnoopMultiTexCoord3iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord3iWIN\n");
}

void glnoopMultiTexCoord3ivWIN
    (GLbitfield mask, const GLint *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord3ivWIN\n");
}

void glnoopMultiTexCoord3sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord3sWIN\n");
}

void glnoopMultiTexCoord3svWIN
    (GLbitfield mask, const GLshort *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord3svWIN\n");
}

void glnoopMultiTexCoord4dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord4dWIN\n");
}

void glnoopMultiTexCoord4dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord4dvWIN\n");
}

void glnoopMultiTexCoord4fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord4fWIN\n");
}

void glnoopMultiTexCoord4fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord4fvWIN\n");
}

void glnoopMultiTexCoord4iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r, GLint q)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord4iWIN\n");
}

void glnoopMultiTexCoord4ivWIN
    (GLbitfield mask, const GLint *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord4ivWIN\n");
}

void glnoopMultiTexCoord4sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r, GLshort q)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord4sWIN\n");
}

void glnoopMultiTexCoord4svWIN
    (GLbitfield mask, const GLshort *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord4svWIN\n");
}

void glnoopBindNthTextureWIN
    (GLuint index, GLenum target, GLuint texture)
{
    WARNING_NOOP("GL Noop:glBindNthTextureWIN\n");
}

void glnoopNthTexCombineFuncWIN
    (GLuint index
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor)
{
    WARNING_NOOP("GL Noop:glNthTexCombineFuncWIN\n");
}
#endif // GL_WIN_multiple_textures

GLEXTPROCTABLE glNullExtProcTable =
{
    /* Number of function entries in the table */
     sizeof(GLEXTDISPATCHTABLE) / sizeof(PROC),

    /* EXT Entry points */
    {
        glnoopDrawRangeElementsWIN,
        glnoopColorTableEXT,
        glnoopColorSubTableEXT,
        glnoopGetColorTableEXT,
        glnoopGetColorTableParameterivEXT,
        glnoopGetColorTableParameterfvEXT,
#ifdef GL_WIN_multiple_textures
        glnoopCurrentTextureIndexWIN,
        glnoopMultiTexCoord1dWIN,
        glnoopMultiTexCoord1dvWIN,
        glnoopMultiTexCoord1fWIN,
        glnoopMultiTexCoord1fvWIN,
        glnoopMultiTexCoord1iWIN,
        glnoopMultiTexCoord1ivWIN,
        glnoopMultiTexCoord1sWIN,
        glnoopMultiTexCoord1svWIN,
        glnoopMultiTexCoord2dWIN,
        glnoopMultiTexCoord2dvWIN,
        glnoopMultiTexCoord2fWIN,
        glnoopMultiTexCoord2fvWIN,
        glnoopMultiTexCoord2iWIN,
        glnoopMultiTexCoord2ivWIN,
        glnoopMultiTexCoord2sWIN,
        glnoopMultiTexCoord2svWIN,
        glnoopMultiTexCoord3dWIN,
        glnoopMultiTexCoord3dvWIN,
        glnoopMultiTexCoord3fWIN,
        glnoopMultiTexCoord3fvWIN,
        glnoopMultiTexCoord3iWIN,
        glnoopMultiTexCoord3ivWIN,
        glnoopMultiTexCoord3sWIN,
        glnoopMultiTexCoord3svWIN,
        glnoopMultiTexCoord4dWIN,
        glnoopMultiTexCoord4dvWIN,
        glnoopMultiTexCoord4fWIN,
        glnoopMultiTexCoord4fvWIN,
        glnoopMultiTexCoord4iWIN,
        glnoopMultiTexCoord4ivWIN,
        glnoopMultiTexCoord4sWIN,
        glnoopMultiTexCoord4svWIN,
        glnoopBindNthTextureWIN,
        glnoopNthTexCombineFuncWIN,
#endif // GL_WIN_multiple_textures
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\subutil.c ===
/***************************************************************************\
* Module Name: subutil.c
*
* Section initialization code for client/server batching.
*
* Copyright (c) 1993-1996 Microsoft Corporation
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "glsbmsg.h"
#include "glgdimsg.h"
#include "batchinf.h"
#include "glsbcltu.h"
#include "wgldef.h"
#include "compsize.h"
#include "context.h"
#include "global.h"
#include "parray.h"
#include "lighting.h"

/******************************Public*Routine******************************\ 
* glsbAttentionAlt
*
* Calls glsbAttention() from the GLCLIENT_BEGIN macro.
* It puts a null proc at the end of the current batch and flushes the batch.
*
* Returns the new message offset and updates pMsgBatchInfo->NextOffset.
* This code is dependent on the GLCLIENT_BEGIN macro!
*
* History:
*  Thu Nov 11 18:02:26 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

#ifdef CHECK_HEAP
PVOID AttnLastCaller = 0, AttnLastCallersCaller = 0;
DWORD AttnCallThread = 0;
#endif

ULONG APIENTRY glsbAttentionAlt(ULONG Offset)
{
    GLMSGBATCHINFO *pMsgBatchInfo;
    ULONG  MsgSize;
    PULONG pNullProcOffset;
    POLYARRAY *pa;
    POLYMATERIAL *pm;

#ifdef PRIMITIVE_TRACK
    DbgPrint("*** glsbAttentionAlt\n");
#endif

    pa = GLTEB_CLTPOLYARRAY();
    pMsgBatchInfo = (GLMSGBATCHINFO *) pa->pMsgBatchInfo;

#ifdef CHECK_HEAP
    AttnCallThread = GetCurrentThreadId();
    RtlValidateHeap(RtlProcessHeap(), 0, 0);
    RtlGetCallersAddress(&AttnLastCaller, &AttnLastCallersCaller);
#endif

    if (Offset == pMsgBatchInfo->FirstOffset)
        return(pMsgBatchInfo->FirstOffset);     // No messages, return

    MsgSize = pMsgBatchInfo->NextOffset - Offset;

// If we are in the begin/end bracket, remove the invalid commands issued
// since the last Begin call.

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        // DrawElements should not cause a flush while building polydata's.
        // pa->aIndices can be reset by VA_DrawElementsBegin, so allow
        // this value as well.
        ASSERTOPENGL( (!pa->aIndices || 
                       (pa->aIndices == PA_aIndices_INITIAL_VALUE)),
                      "unexpected flush in DrawElements\n");
        if (Offset == pa->nextMsgOffset)
            return(Offset);
        GLSETERROR(GL_INVALID_OPERATION);
        pMsgBatchInfo->NextOffset = pa->nextMsgOffset + MsgSize;
        return(pa->nextMsgOffset);
    }

#ifdef PRIMITIVE_TRACK
    DbgPrint("! Reset on attention\n");
#endif
    
    pa->pdBufferNext = pa->pdBuffer0;       // reset vertex buffer pointer
    pa->nextMsgOffset = PA_nextMsgOffset_RESET_VALUE;
    if (pm = GLTEB_CLTPOLYMATERIAL())
    pm->iMat = 0;                       // reset material pointer

    pNullProcOffset  = (ULONG *)((BYTE *)pMsgBatchInfo + Offset);
    *pNullProcOffset = 0;

// #define POLYARRAY_CHECK_COLOR_POINTERS 1
#if POLYARRAY_CHECK_COLOR_POINTERS
{
    POLYDATA *pd;
    for (pd = pa->pdBuffer0; pd < pa->pdBufferMax; pd++)
    {
        if (pd->color != &pd->colors[__GL_FRONTFACE])
            DbgPrint("glsbAttentionAlt: pd 0x%x has modified color pointer\n", pd);
    }
}
#endif

    (void) __wglAttention();

#if POLYARRAY_CHECK_COLOR_POINTERS
{
    POLYDATA *pd;
    for (pd = pa->pdBuffer0; pd < pa->pdBufferMax; pd++)
    {
        if (pd->color != &pd->colors[__GL_FRONTFACE])
            DbgPrint("glsbAttentionAlt: pd 0x%x has BAD color pointer\n", pd);
    }
}
#endif

    pMsgBatchInfo->NextOffset = pMsgBatchInfo->FirstOffset + MsgSize;
    return(pMsgBatchInfo->FirstOffset);
}

/******************************Public*Routine******************************\
* glsbAttention
*
* Let the server know that the section needs attention
*
* History:
*  15-Oct-1993 -by- Gilman Wong [gilmanw]
* Added bCheckRC flag.
\**************************************************************************/

BOOL APIENTRY
glsbAttention ( void )
{
    BOOL bRet = FALSE;
    GLMSGBATCHINFO *pMsgBatchInfo;
    PULONG pNullProcOffset;
    POLYARRAY *pa;
    POLYMATERIAL *pm;
    DWORD flags;
    __GL_SETUP();

    pa = GLTEB_CLTPOLYARRAY();
    pMsgBatchInfo = (GLMSGBATCHINFO *) pa->pMsgBatchInfo;

#ifdef CHECK_HEAP
    AttnCallThread = GetCurrentThreadId();
    RtlValidateHeap(RtlProcessHeap(), 0, 0);
    RtlGetCallersAddress(&AttnLastCaller, &AttnLastCallersCaller);
#endif

    if (pMsgBatchInfo->NextOffset == pMsgBatchInfo->FirstOffset)
        return(TRUE);   // No messages, return

// If we are in the begin/end bracket, remove the invalid commands issued
// since the last Begin call.

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        // DrawElements should not cause a flush while building polydata's.
        // pa->aIndices can be reset by VA_DrawElementsBegin, so allow
        // the reset value as well.
        ASSERTOPENGL( (!pa->aIndices || 
                       (pa->aIndices == PA_aIndices_INITIAL_VALUE)),
                      "unexpected flush in DrawElements\n");
        if (pMsgBatchInfo->NextOffset == pa->nextMsgOffset)
            return(TRUE);
        GLSETERROR(GL_INVALID_OPERATION);
        pMsgBatchInfo->NextOffset = pa->nextMsgOffset;
        return(TRUE);
    }

#ifdef PRIMITIVE_TRACK
    DbgPrint("! Reset on attention\n");
#endif
    
    pa->pdBufferNext = pa->pdBuffer0;       // reset vertex buffer pointer
    pa->nextMsgOffset = PA_nextMsgOffset_RESET_VALUE; // reset next DPA message offset
    if (pm = GLTEB_CLTPOLYMATERIAL())
        pm->iMat = 0;                       // reset material pointer

    pNullProcOffset  = (ULONG *)((BYTE *)pMsgBatchInfo + pMsgBatchInfo->NextOffset);
    *pNullProcOffset = 0;

#if POLYARRAY_CHECK_COLOR_POINTERS
{
    POLYDATA *pd;
    for (pd = pa->pdBuffer0; pd < pa->pdBufferMax; pd++)
    {
        if (pd->color != &pd->colors[__GL_FRONTFACE])
            DbgPrint("glsbAttention: pd 0x%x has modified color pointer\n", pd);
    }
}
#endif

    bRet = __wglAttention();

#if POLYARRAY_CHECK_COLOR_POINTERS
{
    POLYDATA *pd;
    for (pd = pa->pdBuffer0; pd < pa->pdBufferMax; pd++)
    {
        if (pd->color != &pd->colors[__GL_FRONTFACE])
            DbgPrint("glsbAttention: pd 0x%x has BAD color pointer\n", pd);
    }
}
#endif

    // Clear the Evaluator state flags
    flags = GET_EVALSTATE (gc);
    flags = flags & ~(__EVALS_AFFECTS_1D_EVAL|
                      __EVALS_AFFECTS_2D_EVAL|
                      __EVALS_AFFECTS_ALL_EVAL|
                      __EVALS_PUSH_EVAL_ATTRIB|
                      __EVALS_POP_EVAL_ATTRIB);
    SET_EVALSTATE (gc, flags);

    pMsgBatchInfo->NextOffset = pMsgBatchInfo->FirstOffset;
    return(bRet);
}

/******************************Public*Routine******************************\
* glsbResetBuffers
*
* Reset the command buffer, the poly array buffer, and the poly material
* buffer.
*
* History:
*  Tue Jan 09 17:38:22 1996     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID APIENTRY glsbResetBuffers(BOOL bRestoreColorPointer)
{
    GLMSGBATCHINFO *pMsgBatchInfo;
    POLYARRAY *pa;
    POLYMATERIAL *pm;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;

    pa = GLTEB_CLTPOLYARRAY();

    // Reset command buffer
    pMsgBatchInfo = (GLMSGBATCHINFO *) pa->pMsgBatchInfo;
    pMsgBatchInfo->NextOffset = pMsgBatchInfo->FirstOffset;

#ifdef PRIMITIVE_TRACK
    DbgPrint("! Reset on ResetBuffers\n");
#endif

#if POLYARRAY_CHECK_COLOR_POINTERS
{
    POLYDATA *pd;
    for (pd = pa->pdBuffer0; pd < pa->pdBufferMax; pd++)
    {
        if (pd->color != &pd->colors[__GL_FRONTFACE])
            DbgPrint("glsbResetBuffers: pd 0x%x has modified color pointer\n",pd);
    }
}
#endif

    // In COMPILE mode, restore color pointer in the vertex buffer that
    // may have been overwritten by the POLYARRAY structure.  In normal
    // and COMPILE_AND_EXECUTE modes, the server takes care of this.
    // In addition, there can be no more than one DrawPolyArray command
    // in the batch in COMPILE mode.
    if (bRestoreColorPointer)
    {
        POLYARRAY *paCmd;
        POLYDATA  *pd, *pdLast;
        
        // See also PolyArrayRestoreColorPointer
#if DBG
        __GL_SETUP();
        ASSERTOPENGL(gc->dlist.mode == GL_COMPILE, "not in compile mode\n");
#endif
        pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
          ((BYTE *) pMsgBatchInfo + pa->nextMsgOffset -
           GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
        paCmd = (POLYARRAY *) pMsgDrawPolyArray->paLast;

        ASSERTOPENGL(pMsgDrawPolyArray->pa0 == pMsgDrawPolyArray->paLast &&
                     paCmd->paNext == NULL,
                     "DrawPolyArray chain unexpected in COMPILE mode\n");
        
        // Reset color pointer in output index array
        if (paCmd->aIndices && (paCmd->aIndices != PA_aIndices_INITIAL_VALUE))
        {
            pdLast = (POLYDATA *) (paCmd->aIndices + paCmd->nIndices);
            for (pd = (POLYDATA *) paCmd->aIndices; pd < pdLast; pd++)
                pd->color = &pd->colors[__GL_FRONTFACE];

            ASSERTOPENGL(pd >= pa->pdBuffer0 &&
                         pd <= pa->pdBufferMax + 1,
                         "bad polyarray pointer\n");
        }

        // Reset color pointer in the POLYARRAY structure last!
        ASSERTOPENGL((POLYDATA *) paCmd >= pa->pdBuffer0 &&
                     (POLYDATA *) paCmd <= pa->pdBufferMax,
                     "bad polyarray pointer\n");
        ((POLYDATA *) paCmd)->color =
          &((POLYDATA *) paCmd)->colors[__GL_FRONTFACE];
    }

    // Reset material pointer
    if (pm = GLTEB_CLTPOLYMATERIAL())
        pm->iMat = 0;

    // Reset vertex buffer pointer
    pa->pdBufferNext = pa->pdBuffer0; 

    // Reset next DPA message offset
    pa->nextMsgOffset = PA_nextMsgOffset_RESET_VALUE;

#if POLYARRAY_CHECK_COLOR_POINTERS
{
    POLYDATA *pd;
    for (pd = pa->pdBuffer0; pd < pa->pdBufferMax; pd++)
    {
        if (pd->color != &pd->colors[__GL_FRONTFACE])
            DbgPrint("glsbResetBuffers: pd 0x%x has BAD color pointer\n", pd);
    }
}
#endif
}

#if 0
// REWRITE THIS IF NEEDED

/******************************Public*Routine******************************\
* glsbMsgStats
*
* Batch area statistics.
*
*
* History:
\**************************************************************************/

BOOL APIENTRY
glsbMsgStats ( LONG Action, GLMSGBATCHSTATS *BatchStats )
{
#ifdef DOGLMSGBATCHSTATS

    ULONG Result;
    GLMSGBATCHINFO *pMsgBatchInfo;

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    if ( GLMSGBATCHSTATS_GETSTATS == Action )
    {
        BatchStats->ClientCalls  = pMsgBatchInfo->BatchStats.ClientCalls;
    }
    else
    {
        pMsgBatchInfo->BatchStats.ClientCalls = 0;
    }

    // reset user's poll count so it counts this as output
    // put it right next to BEGINMSG so that NtCurrentTeb() is optimized

    RESETUSERPOLLCOUNT();

    BEGINMSG( MSG_GLMSGBATCHSTATS, GLSBMSGSTATS )
        pmsg->Action = Action;

        Result = CALLSERVER();

        if ( TRUE == Result )
        {
            if ( GLMSGBATCHSTATS_GETSTATS == Action )
            {
                BatchStats->ServerTrips = pmsg->BatchStats.ServerTrips;
                BatchStats->ServerCalls = pmsg->BatchStats.ServerCalls;
            }
        }
        else
        {
            DBGERROR("glsbMsgStats(): Server returned FALSE\n");
        }

    ENDMSG
MSGERROR:
    return((BOOL)Result);

#else

    return(FALSE);

#endif /* DOGLMSGBATCHSTATS */
}
#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\swapmult.c ===
/******************************Module*Header*******************************\
* Module Name: swapmult.c
*
* wglSwapMultiple implementation
*
* Created: 02-10-1997
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1993-1997 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <gencx.h>
#include <mcdcx.h>

/******************************Public*Routine******************************\
*
* BufferSwapperType
*
* Determines what basic type of swapper is responsible for the given
* swap info.
*
* History:
*  Mon Oct 14 18:46:28 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define BSWP_ICD        0
#define BSWP_MCD        1
#define BSWP_GENERIC    2

int BufferSwapperType(GENMCDSWAP *pgms)
{
    // The buffer can be for an ICD, an MCD or generic
    // 1.  ICD buffers have an ICD pixel format
    // 2.  MCD buffers have MCD state
    
    if (pgms->pwnd->ipfd <= pgms->pwnd->ipfdDevMax)
    {
        return BSWP_ICD;
    }
    else
    {
        if (pgms->pwnd->buffers != NULL)
        {
            if (pgms->pwnd->buffers->pMcdSurf != NULL)
            {
                return BSWP_MCD;
            }
        }
    }

    return BSWP_GENERIC;
}

/******************************Public*Routine******************************\
*
* SameSwapper
*
* Checks whether the two swapinfos are swapped by the same swapping
* agency.
*
* History:
*  Mon Oct 14 18:49:26 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL SameSwapper(int iSwapperTypeA, GENMCDSWAP *pgmsA, GENMCDSWAP *pgmsB)
{
    switch(iSwapperTypeA)
    {
    case BSWP_ICD:
        // Must be the same ICD
        if (BufferSwapperType(pgmsB) != BSWP_ICD ||
            pgmsA->pwnd->pvDriver != pgmsB->pwnd->pvDriver)
        {
            return FALSE;
        }
        return TRUE;
        
    case BSWP_MCD:
    case BSWP_GENERIC:
        // No way to refine the comparison any more
        return BufferSwapperType(pgmsB) == iSwapperTypeA;

    default:
        ASSERTOPENGL(FALSE, "SameSwapper UNREACHED\n");
        return FALSE;
    }
}

/******************************Public*Routine******************************\
*
* wglSwapMultipleBuffers
*
* Swaps as many of the given buffers as possible.
* Returns a bitmask of the buffers that were swapped.
*
* History:
*  Mon Oct 14 17:19:09 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

// #define VERBOSE_MULTI

DWORD WINAPI wglSwapMultipleBuffers(UINT cBuffers, CONST WGLSWAP *pwswapAll)
{
    GENMCDSWAP agmsAll[WGL_SWAPMULTIPLE_MAX];
    GENMCDSWAP *pgmsFirst;
    GENMCDSWAP *pgmsEnd;
    GENMCDSWAP *pgms;
    GENMCDSWAP *apgmsGroup[WGL_SWAPMULTIPLE_MAX];
    GENMCDSWAP **ppgmsGroup;
    WGLSWAP *pwswap;
    DWORD dwMask;
    UINT uiCur;
    UINT uiIdx;
    GLWINDOWID gwid;
    GLGENwindow *pwnd;
    DWORD dwBit;
    DWORD dwCallMask;
    DWORD adwCallIndex[WGL_SWAPMULTIPLE_MAX];
    DWORD *pdwCallIndex;
    DWORD cGroup;
    DWORD cDone;
    int iSwapperType;
    BOOL bCall;

    ASSERTOPENGL(WGL_SWAPMULTIPLE_MAX <= 16,
                 "WGL_SWAPMULTIPLE_MAX too large\n");
    ASSERTOPENGL(WGL_SWAPMULTIPLE_MAX == OPENGLCMD_MAXMULTI &&
                 WGL_SWAPMULTIPLE_MAX == MCDESC_MAX_EXTRA_WNDOBJ,
                 "WGL_SWAPMULTIPLE_MAX mismatch\n");

    if (cBuffers > WGL_SWAPMULTIPLE_MAX)
    {
        SetLastError(ERROR_INVALID_FUNCTION);
        return 0;
    }
    
    dwMask = 0;
    
    // Validate all input buffers and do one-time information gathering for
    // them.
    pgms = agmsAll;
    pwswap = (WGLSWAP *)pwswapAll;
    for (uiCur = 0; uiCur < cBuffers; uiCur++, pwswap++)
    {
        // Validate DC
        if (IsDirectDrawDevice(pwswap->hdc))
        {
            continue;
        }
    
        switch(GetObjectType(pwswap->hdc))
        {
        case OBJ_DC:
            break;
            
        case OBJ_MEMDC:
            // Nothing to do for memdc
            dwMask |= 1 << uiCur;
            
            // Fall through
            
        default:
            continue;
        }

        // Look up pwnd
        WindowIdFromHdc(pwswap->hdc, &gwid);
        pwnd = pwndGetFromID(&gwid);
        if (pwnd == NULL)
        {
            continue;
        }

        if (pwnd->ipfd == 0)
        {
            pwndRelease(pwnd);
            continue;
        }

        // We have a valid candidate for swapping.  Remember it.
        pgms->pwswap = pwswap;
        pgms->pwnd = pwnd;
        pgms++;
    }

#ifdef VERBOSE_MULTI
    DbgPrint("%d cand\n", pgms-agmsAll);
#endif
    
    // Walk list of candidates and gather by swapper
    pgmsEnd = pgms;
    pgmsFirst = agmsAll;
    while (pgmsFirst < pgmsEnd)
    {
        // Skip over any candidates that have already been swapped
        if (pgmsFirst->pwswap == NULL)
        {
            pgmsFirst++;
            continue;
        }

        iSwapperType = BufferSwapperType(pgmsFirst);

#ifdef VERBOSE_MULTI
        DbgPrint("  Gathering for %d, type %d\n", pgmsFirst-agmsAll,
                 iSwapperType);
#endif
        
        ppgmsGroup = apgmsGroup;
        *ppgmsGroup++ = pgmsFirst;
        pgmsFirst++;

        pgms = pgmsFirst;
        while (pgms < pgmsEnd)
        {
            if (pgms->pwswap != NULL)
            {
                if (SameSwapper(iSwapperType, apgmsGroup[0], pgms))
                {
#ifdef VERBOSE_MULTI
                    DbgPrint("  Match with %d\n", pgms-agmsAll);
#endif
                    
                    *ppgmsGroup++ = pgms;
                }
            }

            pgms++;
        }

        // Dispatch group to swapper for swapping.  This may require
        // multiple attempts because the same swapper may be responsible
        // for multiple devices and only one device can be handled at
        // a time.
        
        cGroup = (DWORD)((ULONG_PTR)(ppgmsGroup-apgmsGroup));

#ifdef VERBOSE_MULTI
        DbgPrint("  Group of %d\n", cGroup);
#endif
        
        cDone = 0;
        while (cDone < cGroup)
        {
            WGLSWAP awswapIcdCall[WGL_SWAPMULTIPLE_MAX];
            PGLDRIVER pgldrv;
            GENMCDSWAP agmsMcdCall[WGL_SWAPMULTIPLE_MAX];
            GENMCDSWAP *pgmsCall;
            
            // Collect any remaining swaps into calling format
            pdwCallIndex = adwCallIndex;
            pgms = NULL;

            // After each case, uiCur must be set to the number of
            // swaps attempted and dwMask must be set to the
            // attempted/succeeded mask.
            
            switch(iSwapperType)
            {
            case BSWP_ICD:
                pwswap = awswapIcdCall;
                for (uiCur = 0; uiCur < cGroup; uiCur++)
                {
                    if (apgmsGroup[uiCur] != NULL)
                    {
                        pgms = apgmsGroup[uiCur];
                        *pwswap++ = *pgms->pwswap;
                        *pdwCallIndex++ = uiCur;
                    }
                }

                uiCur = (UINT)((ULONG_PTR)(pwswap-awswapIcdCall));
                
                // Quit if nothing remaining
                if (uiCur == 0)
                {
                    dwCallMask = 0;
                }
                else
                {
                    pgldrv = (PGLDRIVER)pgms->pwnd->pvDriver;
                    ASSERTOPENGL(pgldrv != NULL,
                                 "ICD not loaded\n");
                    
                    // Ask for swap

                    // If the ICD supports SwapMultiple, pass the call on
                    if (pgldrv->pfnDrvSwapMultipleBuffers != NULL)
                    {
                        dwCallMask = pgldrv->
                            pfnDrvSwapMultipleBuffers(uiCur, awswapIcdCall);
                    }
                    else if (pgldrv->pfnDrvSwapLayerBuffers != NULL)
                    {
                        // The ICD doesn't support multiple swap but
                        // it does support layer swaps so iterate
                        // through all the separate swaps.
                        
                        dwCallMask = 0;
                        dwBit = 1 << (uiCur-1);
                        while (--pwswap >= awswapIcdCall)
                        {
                            // Every swap is attempted
                            dwCallMask |= dwBit << (32-WGL_SWAPMULTIPLE_MAX);

                            if (pgldrv->
                                pfnDrvSwapLayerBuffers(pwswap->hdc,
                                                       pwswap->uiFlags))
                            {
                                dwCallMask |= dwBit;
                            }

                            dwBit >>= 1;
                        }
                    }
                    else
                    {
                        // The ICD only supports SwapBuffers so
                        // iterate and swap all main plane requests.
                        // Any overlay plane swaps are ignored and
                        // reported as successful.
                        
                        dwCallMask = 0;
                        dwBit = 1 << (uiCur-1);
                        while (--pwswap >= awswapIcdCall)
                        {
                            // Every swap is attempted
                            dwCallMask |= dwBit << (32-WGL_SWAPMULTIPLE_MAX);

                            if (pwswap->uiFlags & WGL_SWAP_MAIN_PLANE)
                            {
                                bCall = __DrvSwapBuffers(pwswap->hdc, FALSE);
                            }
                            else
                            {
                                bCall = TRUE;
                            }

                            if (bCall)
                            {
                                dwCallMask |= dwBit;
                            }

                            dwBit >>= 1;
                        }
                    }
                }
                break;
            
            case BSWP_MCD:
                pgmsCall = agmsMcdCall;
                for (uiCur = 0; uiCur < cGroup; uiCur++)
                {
                    if (apgmsGroup[uiCur] != NULL)
                    {
                        pgms = apgmsGroup[uiCur];
                        *pgmsCall++ = *pgms;
                        *pdwCallIndex++ = uiCur;
                    }
                }

                uiCur = (UINT)((ULONG_PTR)(pgmsCall-agmsMcdCall));
                
                // Quit if nothing remaining
                if (uiCur == 0)
                {
                    dwCallMask = 0;
                }
                else
                {
                    // Ask for swap
                    dwCallMask = GenMcdSwapMultiple(uiCur, agmsMcdCall);
                }
                break;

            case BSWP_GENERIC:
                // No accleration exists so just iterate and swap
                dwCallMask = 0;
                dwBit = 1;
                for (uiCur = 0; uiCur < cGroup; uiCur++)
                {
                    pgms = apgmsGroup[uiCur];
                    *pdwCallIndex++ = uiCur;

                    // Every swap is attempted
                    dwCallMask |= dwBit << (32-WGL_SWAPMULTIPLE_MAX);

                    // Since this is a generic swap we only swap the
                    // main plane.  Overlay planes are ignored and
                    // reported as successful.
                    if (pgms->pwswap->uiFlags & WGL_SWAP_MAIN_PLANE)
                    {
                        ENTER_WINCRIT(pgms->pwnd);

                        bCall = glsrvSwapBuffers(pgms->pwswap->hdc,
                                                 pgms->pwnd);
                        
                        LEAVE_WINCRIT(pgms->pwnd);
                    }
                    else
                    {
                        bCall = TRUE;
                    }

                    if (bCall)
                    {
                        dwCallMask |= dwBit;
                    }
                    
                    dwBit <<= 1; 
                }
                break;
            }

#ifdef VERBOSE_MULTI
            DbgPrint("  Attempted %d, mask %X\n", uiCur, dwCallMask);
#endif
            
            // Quit if nothing was swapped.
            if (dwCallMask == 0)
            {
                break;
            }
        
            // Determine which buffers were really swapped and
            // clear any buffers for which a swap was attempted.
            dwBit = 1 << (uiCur-1);
            while (uiCur-- > 0)
            {
                uiIdx = adwCallIndex[uiCur];
                pgms = apgmsGroup[uiIdx];
                
                if (dwCallMask & dwBit)
                {
                    dwMask |= 1 << (pgms->pwswap-pwswapAll);
                }
                if ((dwCallMask >> (32-WGL_SWAPMULTIPLE_MAX)) & dwBit)
                {
                    // Take out of overall list
                    pgms->pwswap = NULL;
                    
                    // Take out of group list
                    apgmsGroup[uiIdx] = NULL;

                    cDone++;
                }
                
                dwBit >>= 1;
            }

#ifdef VERBOSE_MULTI
            DbgPrint("  Done with %d, mask %X\n", cDone, dwMask);
#endif
        }
    }

    // Release all the pwnds
    pgms = agmsAll;
    while (pgms < pgmsEnd)
    {
        pwndRelease(pgms->pwnd);
        pgms++;
    }

#ifdef VERBOSE_MULTI
    DbgPrint("Final mask %X\n", dwMask);
#endif
    
    return dwMask;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\wcreate.c ===
/******************************Module*Header*******************************\
* Module Name: wcreate.c
*
* wgl Context creation routines
*
* Created: 08-27-1996
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ddrawpr.h>

#include <glscreen.h>
#include <glgenwin.h>

#include <gencx.h>

#include "metasup.h"
#include "wgldef.h"

// List of loaded GL drivers for the process.
// A driver is loaded only once per process.  Once it is loaded,
// it will not be freed until the process quits.

static PGLDRIVER pGLDriverList = (PGLDRIVER) NULL;

/******************************Public*Routine******************************\
* iAllocLRC
*
* Allocates a LRC and a handle.  Initializes the LDC to have the default
* attributes.  Returns the handle index.  On error returns INVALID_INDEX.
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

static LRC lrcDefault =
{
    0,                    // dhrc
    0,                    // hrc
    0,                    // iPixelFormat
    LRC_IDENTIFIER,       // ident
    INVALID_THREAD_ID,    // tidCurrent
    NULL,                 // pGLDriver
    GLWID_ERROR, NULL, NULL, NULL, // gwidCurrent
    GLWID_ERROR, NULL, NULL, NULL, // gwidCreate
#ifdef GL_METAFILE
    0,                    // uiGlsCaptureContext
    0,                    // uiGlsPlaybackContext
    FALSE,                // fCapturing
    0, 0, 0, 0, 0,        // Metafile scaling constants
    0, 0, 0, 0.0f, 0.0f,
#endif

    NULL,  // GLubyte *pszExtensions

#ifdef GL_METAFILE
    {0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, // XFORM xformMeta
    NULL,                                 // LPRECTL prclGlsBounds
#endif

    NULL, 0,                    // DDraw texture formats
};

static ULONG iAllocLRC(int iPixelFormat)
{
    ULONG  irc = INVALID_INDEX;
    PLRC   plrc;

// Allocate a local RC.

    plrc = (PLRC) ALLOC(sizeof(LRC));
    if (plrc == (PLRC) NULL)
    {
        DBGERROR("Alloc failed\n");
        return(irc);
    }

// Initialize the local RC.

    *plrc = lrcDefault;
    plrc->iPixelFormat = iPixelFormat;

// Allocate a local handle.

    irc = iAllocHandle(LO_RC, 0, (PVOID) plrc);
    if (irc == INVALID_INDEX)
    {
        vFreeLRC(plrc);
        return(irc);
    }
    return(irc);
}

/******************************Public*Routine******************************\
* vFreeLRC
*
* Free a local side RC.
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Copied from gdi client.
\**************************************************************************/

VOID vFreeLRC(PLRC plrc)
{
// The driver will not be unloaded here.  It is loaded for the process forever.
// Some assertions.

    ASSERTOPENGL(plrc->ident == LRC_IDENTIFIER,
                 "vFreeLRC: Bad plrc\n");
    ASSERTOPENGL(plrc->dhrc == (DHGLRC) 0,
                 "vFreeLRC: Driver RC is not freed!\n");
    ASSERTOPENGL(plrc->tidCurrent == INVALID_THREAD_ID,
                 "vFreeLRC: RC is current!\n");
    ASSERTOPENGL(plrc->gwidCurrent.iType == GLWID_ERROR,
                 "vFreeLRC: Current surface is not NULL!\n");
#ifdef GL_METAFILE
    ASSERTOPENGL(plrc->uiGlsCaptureContext == 0,
                 "vFreeLRC: GLS capture context not freed");
    ASSERTOPENGL(plrc->uiGlsPlaybackContext == 0,
                 "vFreeLRC: GLS playback context not freed");
    ASSERTOPENGL(plrc->fCapturing == FALSE,
                 "vFreeLRC: GLS still capturing");
#endif

// Smash the identifier.

    plrc->ident = 0;

// Free the memory.

    if (plrc->pszExtensions)
        FREE(plrc->pszExtensions);

    if (plrc->pddsdTexFormats != NULL)
    {
        FREE(plrc->pddsdTexFormats);
    }

    FREE(plrc);
}

/******************************Public*Routine******************************\
* vCleanupAllLRC
*
* Process cleanup -- make sure all HGLRCs are deleted.  This is done by
* scanning the local handle table for all currently allocated objects
* of type LO_RC and deleting them.
*
* Called *ONLY* during DLL process detach.
*
* History:
*  24-Jul-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vCleanupAllLRC()
{
    UINT ii;

    if ( pLocalTable )
    {
        ENTERCRITICALSECTION(&semLocal);

        // Scan handle table for handles of type LO_RC.  Make sure to always
        // read the commit value since we need to periodically release the
        // semaphore.

        for (ii = 0; ii < *((volatile ULONG *)&cLheCommitted); ii++)
        {
            if ( pLocalTable[ii].iType == LO_RC )
            {
                if ( !wglDeleteContext((HGLRC) ULongToPtr(LHANDLE(ii))) )
                {
                    WARNING1("bCleanupAllLRC: failed to remove hrc = 0x%lx\n",
                             LHANDLE(ii));
                }
            }
        }

        LEAVECRITICALSECTION(&semLocal);
    }
}

/******************************Public*Routine******************************\
*
* GetDrvRegInfo
*
* Looks up driver registry information by name.
* An old-style ICD registry entry has a REG_SZ value under the given name.
* A new-style ICD registry entry has a key of the given name with
* various values.
*
* This routine checks first for a key and then will optionally
* try the value.  If a key is not found then extended driver information
* is filled out with the defaults.
*
* History:
*  Tue Apr 01 17:33:12 1997     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

typedef struct _GLDRVINFO
{
    DWORD dwFlags;
    TCHAR tszDllName[MAX_GLDRIVER_NAME+1];
    DWORD dwVersion;
    DWORD dwDriverVersion;
} GLDRVINFO;

#ifdef _WIN95_
#define STR_OPENGL_DRIVER_LIST (PCSTR)"Software\\Microsoft\\Windows\\CurrentVersion\\OpenGLDrivers"
#else
#define STR_OPENGL_DRIVER_LIST (PCWSTR)L"Software\\Microsoft\\Windows NT\\CurrentVersion\\OpenGLDrivers"
#endif

BOOL GetDrvRegInfo(PTCHAR ptszName, GLDRVINFO *pgdi)
{
    HKEY hkDriverList = NULL;
    HKEY hkDriverInfo;
    DWORD dwDataType;
    DWORD cjSize;
    BOOL bRet;

    bRet = FALSE;

    // Open the registry key for the list of OpenGL drivers.
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, STR_OPENGL_DRIVER_LIST,
                     0, KEY_READ, &hkDriverList) != ERROR_SUCCESS)
    {
        WARNING("RegOpenKeyEx failed\n");
        return bRet;
    }

    // Force a terminator on the DLL name so that we can check for
    // valid DLL name data.
    pgdi->tszDllName[MAX_GLDRIVER_NAME] = 0;

    cjSize = sizeof(TCHAR) * MAX_GLDRIVER_NAME;

    // Attempt to open a key under the driver's name.
    if (RegOpenKeyEx(hkDriverList, ptszName, 0, KEY_READ,
                     &hkDriverInfo) == ERROR_SUCCESS)
    {
        // New-style driver entry.  Fetch information from values.

        bRet = TRUE;

        if (RegQueryValueEx(hkDriverInfo, __TEXT("DLL"), NULL, &dwDataType,
                            (LPBYTE)pgdi->tszDllName,
                            &cjSize) != ERROR_SUCCESS ||
            dwDataType != REG_SZ)
        {
            WARNING("Invalid DLL value in ICD key\n");
            bRet = FALSE;
        }

        cjSize = sizeof(DWORD);

        if (bRet &&
            (RegQueryValueEx(hkDriverInfo, __TEXT("Flags"), NULL, &dwDataType,
                             (LPBYTE)&pgdi->dwFlags,
                             &cjSize) != ERROR_SUCCESS ||
             dwDataType != REG_DWORD))
        {
            WARNING("Invalid Flags value in ICD key\n");
            bRet = FALSE;
        }

        if (bRet &&
            (RegQueryValueEx(hkDriverInfo, __TEXT("Version"), NULL,
                             &dwDataType, (LPBYTE)&pgdi->dwVersion,
                             &cjSize) != ERROR_SUCCESS ||
             dwDataType != REG_DWORD))
        {
            WARNING("Invalid Version value in ICD key\n");
            bRet = FALSE;
        }

        if (bRet &&
            (RegQueryValueEx(hkDriverInfo, __TEXT("DriverVersion"), NULL,
                             &dwDataType, (LPBYTE)&pgdi->dwDriverVersion,
                             &cjSize) != ERROR_SUCCESS ||
             dwDataType != REG_DWORD))
        {
            WARNING("Invalid DriverVersion value in ICD key\n");
            bRet = FALSE;
        }

        // Mark as having full information.
        pgdi->dwFlags |= GLDRIVER_FULL_REGISTRY;

        RegCloseKey(hkDriverInfo);
    }
    else
    {
        // Attempt to fetch value under driver's name.

        if (RegQueryValueEx(hkDriverList, ptszName, NULL, &dwDataType,
                            (LPBYTE)pgdi->tszDllName,
                            &cjSize) != ERROR_SUCCESS ||
            dwDataType != REG_SZ)
        {
            WARNING1("RegQueryValueEx failed, %d\n", GetLastError());
        }
        else
        {
            // We found old-style information which only provides the
            // DLL name.  Fill in the rest with defaults.
            //
            // Version and DriverVersion are not set here under the
            // assumption that the display driver set them in the
            // OPENGL_GETINFO escape since the old-style path requires
            // the escape to occur before getting here.

            pgdi->dwFlags = 0;

            bRet = TRUE;
        }
    }

    RegCloseKey(hkDriverList);

    // Validate the driver name.  It must have some characters and
    // it must be terminated.
    if (bRet &&
        (pgdi->tszDllName[0] == 0 ||
         pgdi->tszDllName[MAX_GLDRIVER_NAME] != 0))
    {
        WARNING("Invalid DLL name information for ICD\n");
        bRet = FALSE;
    }

#ifdef _WIN95_
    // Force client-side buffer calls for Win95.
    pgdi->dwFlags |= GLDRIVER_CLIENT_BUFFER_CALLS;
#endif

    return bRet;
}

/******************************Public*Routine******************************\
* bGetDriverInfo
*
* The HDC is used to determine the display driver name.  This name in turn
* is used as a subkey to search the registry for a corresponding OpenGL
* driver name.
*
* The OpenGL driver name is returned in the buffer pointed to by pwszDriver.
* If the name is not found or does not fit in the buffer, an error is
* returned.
*
* Returns:
*   TRUE if sucessful.
*   FALSE if the driver name does not fit in the buffer or if an error occurs.
*
* History:
*  16-Jan-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bGetDriverInfo(HDC hdc, GLDRVINFO *pgdi)
{
    GLDRVNAME    dn;
    GLDRVNAMERET dnRet;

// Get display driver name.

    dn.oglget.ulSubEsc = OPENGL_GETINFO_DRVNAME;
    if ( ExtEscape(hdc, OPENGL_GETINFO, sizeof(GLDRVNAME), (LPCSTR) &dn,
                      sizeof(GLDRVNAMERET), (LPSTR) &dnRet) <= 0 )
    {
        WARNING("ExtEscape(OPENGL_GETINFO, "
                "OPENGL_GETINFO_DRVNAME) failed\n");
        return FALSE;
    }

    pgdi->dwVersion = dnRet.ulVersion;
    pgdi->dwDriverVersion = dnRet.ulDriverVersion;

    if (GetDrvRegInfo((PTCHAR)dnRet.awch, pgdi))
    {
        // Verify that the client-side driver version information
        // matches the information returned from the display driver.
        // Is this too restrictive?  Old scheme used
        // DrvValidateVersion to allow the client-side DLL to validate
        // the display driver's version however it felt like.
        // In the new scheme DrvValidateVersion is mostly useless because
        // of the below code.
        return pgdi->dwVersion == dnRet.ulVersion &&
            pgdi->dwDriverVersion == dnRet.ulDriverVersion;
    }
    else
    {
        return FALSE;
    }
}

/*****************************Private*Routine******************************\
*
* wglCbSetCurrentValue
*
* Sets a thread-local value for a client-side driver
*
* History:
*  Wed Dec 21 15:10:40 1994     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void APIENTRY wglCbSetCurrentValue(VOID *pv)
{
    GLTEB_SET_CLTDRIVERSLOT(pv);
}

/*****************************Private*Routine******************************\
*
* wglCbGetCurrentValue
*
* Gets a thread-local value for a client-side driver
*
* History:
*  Wed Dec 21 15:11:32 1994     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

PVOID APIENTRY wglCbGetCurrentValue(void)
{
    return GLTEB_CLTDRIVERSLOT();
}

/******************************Public*Routine******************************\
*
* wglCbGetDhglrc
*
* Translates an HGLRC to a DHGLRC for a client-side driver
*
* History:
*  Mon Jan 16 17:03:38 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DHGLRC APIENTRY wglCbGetDhglrc(HGLRC hrc)
{
    PLRC plrc;
    ULONG irc;
    PLHE plheRC;

    irc = MASKINDEX(hrc);
    plheRC = pLocalTable + irc;
    if ((irc >= cLheCommitted) ||
        (!MATCHUNIQ(plheRC, hrc)) ||
        ((plheRC->iType != LO_RC))
       )
    {
        DBGLEVEL1(LEVEL_ERROR, "wglCbGetDhglrc: invalid hrc 0x%lx\n", hrc);
        SetLastError(ERROR_INVALID_HANDLE);
        return 0;
    }

    plrc = (PLRC)plheRC->pv;
    ASSERTOPENGL(plrc->ident == LRC_IDENTIFIER,
                 "wglCbGetDhglrc: Bad plrc\n");

    return plrc->dhrc;
}

/******************************Public*Routine******************************\
*
* wglCbGetDdHandle
*
* Callback to allow ICDs to extract kernel-mode handles for DDraw surfaces
*
* History:
*  Tue Feb 25 17:14:29 1997     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

HANDLE APIENTRY wglCbGetDdHandle(LPDIRECTDRAWSURFACE pdds)
{
    return (HANDLE)(((LPDDRAWI_DDRAWSURFACE_INT)pdds)->lpLcl)->hDDSurface;
}

// wgl's default callback procedures
#define CALLBACK_PROC_COUNT 4

static PROC __wglCallbackProcs[CALLBACK_PROC_COUNT] =
{
    (PROC)wglCbSetCurrentValue,
    (PROC)wglCbGetCurrentValue,
    (PROC)wglCbGetDhglrc,
    (PROC)wglCbGetDdHandle
};

static char *pszDriverEntryPoints[] =
{
    "DrvCreateContext",
    "DrvDeleteContext",
    "DrvSetContext",
    "DrvReleaseContext",
    "DrvCopyContext",
    "DrvCreateLayerContext",
    "DrvShareLists",
    "DrvGetProcAddress",
    "DrvDescribeLayerPlane",
    "DrvSetLayerPaletteEntries",
    "DrvGetLayerPaletteEntries",
    "DrvRealizeLayerPalette",
    "DrvSwapLayerBuffers",
    "DrvCreateDirectDrawContext",
    "DrvEnumTextureFormats",
    "DrvBindDirectDrawTexture",
    "DrvSwapMultipleBuffers",
    "DrvDescribePixelFormat",
    "DrvSetPixelFormat",
    "DrvSwapBuffers"
};
#define DRIVER_ENTRY_POINTS (sizeof(pszDriverEntryPoints)/sizeof(char *))

/******************************Public*Routine******************************\
* pgldrvLoadInstalledDriver
*
* Loads the opengl driver for the given device.  Once the driver is loaded,
* it will not be freed until the process goes away!  It is loaded only once
* for each process that references it.
*
* Returns the GLDRIVER structure if the driver is loaded.
* Returns NULL if no driver is found or an error occurs.
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Rewrote it.
\**************************************************************************/

PGLDRIVER APIENTRY pgldrvLoadInstalledDriver(HDC hdc)
{
    GLDRVINFO gdi;
    PGLDRIVER pGLDriverNext;
    PGLDRIVER pGLDriver = (PGLDRIVER) NULL;     // needed by clean up
    PGLDRIVER pGLDriverRet = (PGLDRIVER) NULL;  // return value, assume error
    PFN_DRVVALIDATEVERSION pfnDrvValidateVersion = (PFN_DRVVALIDATEVERSION) NULL;
    PFN_DRVSETCALLBACKPROCS pfnDrvSetCallbackProcs;
    DWORD        dwEscape;
    int          i;
    PROC        *pproc;
    GLGENwindow *pwnd;
    GLWINDOWID   gwid;

    DBGENTRY("pgldrvLoadInstalledDriver\n");

// Try to grab the cached pgldrv from the GLGENwindow if it exists.
// This only works for DCs that have a window with a device pixel format.

    WindowIdFromHdc(hdc, &gwid);
    pwnd = pwndGetFromID(&gwid);
    if (pwnd)
    {
        ULONG ulFlags;

        ulFlags = pwnd->ulFlags;
        pGLDriverRet = (PGLDRIVER) pwnd->pvDriver;

        pwndRelease(pwnd);

        if ( ulFlags & GLGENWIN_DRIVERSET )
        {
            return pGLDriverRet;
        }
    }

// Do a quick check and see if this driver even understands OpenGL

    dwEscape = OPENGL_GETINFO;
    if (ExtEscape(hdc, QUERYESCSUPPORT, sizeof(dwEscape), (LPCSTR)&dwEscape,
                  0, NULL) <= 0)
    {
        // Don't output a message since this code path is traversed often
        // for the pixel format routines.

#ifdef CHECK_DEFAULT_ICD
        // The display driver doesn't support a specific ICD.  Check
        // for a default ICD.  It must have full registry information.
        if (!GetDrvRegInfo(__TEXT("Default"), &gdi) ||
            (gdi.dwFlags & GLDRIVER_FULL_REGISTRY) == 0)
        {
            return NULL;
        }
#else
        return NULL;
#endif
    }

// Determine driver info from hdc

    else if ( !bGetDriverInfo(hdc, &gdi) )
    {
        WARNING("bGetDriverInfo failed\n");
        return NULL;
    }

// Load the driver only once per process.

    ENTERCRITICALSECTION(&semLocal);

// Look for the OpenGL driver in the previously loaded driver list.

    for (pGLDriverNext = pGLDriverList;
         pGLDriverNext != (PGLDRIVER) NULL;
         pGLDriverNext = pGLDriverNext->pGLDriver)
    {
        PTCHAR ptszDllName1 = pGLDriverNext->tszDllName;
        PTCHAR ptszDllName2 = gdi.tszDllName;

        while (*ptszDllName1 == *ptszDllName2)
        {
// If we find one, return that driver.

            if (*ptszDllName1 == 0)
            {
                DBGINFO("pgldrvLoadInstalledDriver: "
                        "return previously loaded driver\n");
                pGLDriverRet = pGLDriverNext;       // found one
                goto pgldrvLoadInstalledDriver_crit_exit;
            }

            ptszDllName1++;
            ptszDllName2++;
        }
    }

// Load the driver for the first time.
// Allocate the driver data.

    pGLDriver = (PGLDRIVER) ALLOC(sizeof(GLDRIVER));
    if (pGLDriver == (PGLDRIVER) NULL)
    {
        WARNING("Alloc failed\n");
        goto pgldrvLoadInstalledDriver_crit_exit;   // error
    }

// Load the driver.

    pGLDriver->hModule = LoadLibrary(gdi.tszDllName);
    if (pGLDriver->hModule == (HINSTANCE) NULL)
    {
        WARNING("pgldrvLoadInstalledDriver: LoadLibrary failed\n");
        goto pgldrvLoadInstalledDriver_crit_exit;   // error
    }

// Copy the driver info.

    memcpy
    (
        pGLDriver->tszDllName,
        gdi.tszDllName,
        (MAX_GLDRIVER_NAME + 1) * sizeof(TCHAR)
    );
    pGLDriver->dwFlags = gdi.dwFlags;

// Get the proc addresses.
// DrvGetProcAddress is optional.  It must be provided if a driver supports
// extensions.

    pfnDrvValidateVersion = (PFN_DRVVALIDATEVERSION)
        GetProcAddress(pGLDriver->hModule, "DrvValidateVersion");
    pfnDrvSetCallbackProcs = (PFN_DRVSETCALLBACKPROCS)
        GetProcAddress(pGLDriver->hModule, "DrvSetCallbackProcs");

    pproc = (PROC *)&pGLDriver->pfnDrvCreateContext;
    for (i = 0; i < DRIVER_ENTRY_POINTS; i++)
    {
        *pproc++ =
            GetProcAddress(pGLDriver->hModule, pszDriverEntryPoints[i]);
    }

    if ((pGLDriver->pfnDrvCreateContext == NULL &&
          pGLDriver->pfnDrvCreateLayerContext == NULL) ||
        pGLDriver->pfnDrvDeleteContext == NULL ||
        pGLDriver->pfnDrvSetContext == NULL ||
        pGLDriver->pfnDrvReleaseContext == NULL ||
        ((gdi.dwFlags & GLDRIVER_CLIENT_BUFFER_CALLS) &&
         (pGLDriver->pfnDrvDescribePixelFormat == NULL ||
          pGLDriver->pfnDrvSetPixelFormat == NULL ||
          pGLDriver->pfnDrvSwapBuffers == NULL)) ||
        pfnDrvValidateVersion == NULL)
    {
        WARNING("pgldrvLoadInstalledDriver: GetProcAddress failed\n");
        goto pgldrvLoadInstalledDriver_crit_exit;   // error
    }

// Validate the driver.

    //!!!XXX -- Need to define a manifest constant for the ulVersion number
    //          in this release.  Where should it go?
    if ( gdi.dwVersion != 2 || !pfnDrvValidateVersion(gdi.dwDriverVersion) )
    {
        WARNING2("pgldrvLoadInstalledDriver: bad driver version "
                 "(0x%lx, 0x%lx)\n", gdi.dwVersion, gdi.dwDriverVersion);
        goto pgldrvLoadInstalledDriver_crit_exit;   // error
    }

// Everything is golden.
// Add it to the driver list.

    pGLDriver->pGLDriver = pGLDriverList;
    pGLDriverList = pGLDriver;
    pGLDriverRet = pGLDriver;       // set return value
    DBGINFO("pgldrvLoadInstalledDriver: Loaded an OpenGL driver\n");

    // Set the callback procs for the driver if the driver supports doing so
    if (pfnDrvSetCallbackProcs != NULL)
    {
        pfnDrvSetCallbackProcs(CALLBACK_PROC_COUNT, __wglCallbackProcs);
    }

// Error clean up in the critical section.

pgldrvLoadInstalledDriver_crit_exit:
    if (pGLDriverRet == (PGLDRIVER) NULL)
    {
        if (pGLDriver != (PGLDRIVER) NULL)
        {
            if (pGLDriver->hModule != (HINSTANCE) NULL)
                if (!FreeLibrary(pGLDriver->hModule))
                    RIP("FreeLibrary failed\n");

            FREE(pGLDriver);
        }
    }

    LEAVECRITICALSECTION(&semLocal);

    return(pGLDriverRet);
}

/******************************Public*Routine******************************\
*
* CreateAnyContext
*
* Base worker function for creating all kinds of contexts
*
* History:
*  Mon Aug 26 14:41:31 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

HGLRC CreateAnyContext(GLSURF *pgsurf)
{
    PLHE  plheRC;
    ULONG irc;
    HGLRC hrc;
    PLRC  plrc;

#ifndef _WIN95_
    // _OPENGL_NT_
    // On NT, client-side drivers can use special fast TEB access macros
    // which rely on glContext being at a fixed offset into the
    // TEB.  Assert that the offset is where we think it is
    // to catch any TEB changes which could break client-side
    // drivers
    // This assert is here in wglCreateContext to ensure that it
    // is checked very early in OpenGL operation
    ASSERTOPENGL(FIELD_OFFSET(TEB, glContext) == TeglContext,
                 "TEB.glContext at wrong offset\n");
    ASSERTOPENGL(FIELD_OFFSET(TEB, glDispatchTable) == TeglDispatchTable,
                 "TEB.glDispatchTable at wrong offset\n");
    ASSERTOPENGL(FIELD_OFFSET(TEB, glReserved1) == TeglReserved1,
                 "TEB.glReserved1 at wrong offset\n");
#if !defined(_WIN64)
    ASSERTOPENGL(FIELD_OFFSET(TEB, glReserved1)+(18 * sizeof(ULONG_PTR)) == TeglPaTeb,
                 "TEB.glPaTeb at wrong offset\n");
#endif
    ASSERTOPENGL(FIELD_OFFSET(TEB, glReserved2) == TeglReserved2,
                 "TEB.glReserved2 at wrong offset\n");
    ASSERTOPENGL(FIELD_OFFSET(TEB, glSectionInfo) == TeglSectionInfo,
                 "TEB.glSectionInfo at wrong offset\n");
    ASSERTOPENGL(FIELD_OFFSET(TEB, glSection) == TeglSection,
                 "TEB.glSection at wrong offset\n");
    ASSERTOPENGL(FIELD_OFFSET(TEB, glTable) == TeglTable,
                 "TEB.glTable at wrong offset\n");
    ASSERTOPENGL(FIELD_OFFSET(TEB, glCurrentRC) == TeglCurrentRC,
                 "TEB.glCurrentRC at wrong offset\n");
#endif

// Create the local RC.

    ENTERCRITICALSECTION(&semLocal);
    irc = iAllocLRC(pgsurf->ipfd);
    if (irc == INVALID_INDEX ||
        cLockHandle((ULONG_PTR)(hrc = (HGLRC) ULongToPtr(LHANDLE(irc)))) <= 0)
    {
        // cLockHandle should never fail or we will need to free the handle.
        ASSERTOPENGL(irc == INVALID_INDEX, "cLockHandle should not fail!\n");
        LEAVECRITICALSECTION(&semLocal);
        return((HGLRC) 0);
    }
    LEAVECRITICALSECTION(&semLocal);

    plheRC = &pLocalTable[irc];
    plrc = (PLRC) plheRC->pv;

    // Remember the creation DC.  This needs to be done early because
    // it is referenced in some code paths.

    plrc->gwidCreate.hdc = pgsurf->hdc;
    if (pgsurf->dwFlags & GLSURF_HDC)
    {
        plrc->gwidCreate.hwnd = pgsurf->hwnd;
        if (plrc->gwidCreate.hwnd == NULL)
        {
            plrc->gwidCreate.iType = GLWID_HDC;
        }
        else
        {
            plrc->gwidCreate.iType = GLWID_HWND;
        }
        plrc->gwidCreate.pdds = NULL;
    }
    else
    {
        plrc->gwidCreate.iType = GLWID_DDRAW;
        plrc->gwidCreate.pdds = pgsurf->dd.gddsFront.pdds;
        plrc->gwidCreate.hwnd = NULL;
    }

    if (!(pgsurf->pfd.dwFlags & PFD_GENERIC_FORMAT) &&
        !(pgsurf->pfd.dwFlags & PFD_GENERIC_ACCELERATED))
    {
    // If it is a device format, load the installable OpenGL driver.
    // Find and load the OpenGL driver referenced by this DC.

        if (!(plrc->pGLDriver = pgldrvLoadInstalledDriver(pgsurf->hdc)))
            goto wglCreateContext_error;

    // Create a driver context.

        // If the surface is a DirectDraw surface use the DirectDraw
        // entry point
        if (pgsurf->dwFlags & GLSURF_DIRECTDRAW)
        {
            if (plrc->pGLDriver->pfnDrvCreateDirectDrawContext == NULL)
            {
                SetLastError(ERROR_INVALID_FUNCTION);
                goto wglCreateContext_error;
            }

            plrc->dhrc = plrc->pGLDriver->pfnDrvCreateDirectDrawContext(
                    pgsurf->hdc, pgsurf->dd.gddsFront.pdds, pgsurf->ipfd);
            if (plrc->dhrc == 0)
            {
                WARNING("wglCreateContext: "
                        "pfnDrvCreateDirectDrawContext failed\n");
                goto wglCreateContext_error;
            }
        }
        // If the driver supports layers then create a context for the
        // given layer.  Otherwise reject all layers except for the
        // main plane and call the layer-less create
        else if (plrc->pGLDriver->pfnDrvCreateLayerContext != NULL)
        {
            if (!(plrc->dhrc =
                  plrc->pGLDriver->pfnDrvCreateLayerContext(pgsurf->hdc,
                                                            pgsurf->iLayer)))
            {
                WARNING("wglCreateContext: pfnDrvCreateLayerContext failed\n");
                goto wglCreateContext_error;
            }
        }
        else if (pgsurf->iLayer != 0)
        {
            WARNING("wglCreateContext: "
                    "Layer given for driver without layer support\n");
            SetLastError(ERROR_INVALID_FUNCTION);
            goto wglCreateContext_error;
        }
        else if (!(plrc->dhrc =
                   plrc->pGLDriver->pfnDrvCreateContext(pgsurf->hdc)))
        {
            WARNING("wglCreateContext: pfnDrvCreateContext failed\n");
            goto wglCreateContext_error;
        }
    }
    else
    {
        GLCLTPROCTABLE *pgcpt;
        GLEXTPROCTABLE *pgept;
        __GLcontext *gc;

        // Unless supported by MCD, the generic implementation doesn't
        // support layers
        if ((pgsurf->iLayer != 0) &&
            !(pgsurf->pfd.dwFlags & PFD_GENERIC_ACCELERATED))
        {
            WARNING("wglCreateContext: Layer given to generic\n");
            goto wglCreateContext_error;
        }

#ifdef GL_METAFILE
        // Create a metafile context if necessary
        if (pgsurf->dwFlags & GLSURF_METAFILE)
        {
            if (!CreateMetaRc(pgsurf->hdc, plrc))
            {
                WARNING("wglCreateContext: CreateMetaRc failed\n");
                goto wglCreateContext_error;
            }
        }
#endif

    // If it is a generic format, call the generic OpenGL server.
    // Create a server RC.

        plheRC->hgre = (ULONG_PTR) __wglCreateContext(&plrc->gwidCreate, pgsurf);
        if (plheRC->hgre == 0)
            goto wglCreateContext_error;

        // Set up the default dispatch tables for display list playback
        gc = (__GLcontext *)plheRC->hgre;
        if (gc->modes.colorIndexMode)
            pgcpt = &glCltCIProcTable;
        else
            pgcpt = &glCltRGBAProcTable;
        pgept = &glExtProcTable;
        memcpy(&gc->savedCltProcTable.glDispatchTable, &pgcpt->glDispatchTable,
               pgcpt->cEntries*sizeof(PROC));
        memcpy(&gc->savedExtProcTable.glDispatchTable, &pgept->glDispatchTable,
               pgept->cEntries*sizeof(PROC));
    }

    DBGLEVEL3(LEVEL_INFO,
        "wglCreateContext: plrc = 0x%lx, pGLDriver = 0x%lx, hgre = 0x%lx\n",
        plrc, plrc->pGLDriver, plheRC->hgre);

// Success, return the result.

    plrc->hrc = hrc;

    vUnlockHandle((ULONG_PTR)hrc);

    return hrc;

wglCreateContext_error:

// Fail, clean up and return 0.

#ifdef GL_METAFILE
    // Clean up metafile context if necessary
    if (plrc->uiGlsCaptureContext != 0)
    {
        DeleteMetaRc(plrc);
    }
#endif

    DBGERROR("wglCreateContext failed\n");
    ASSERTOPENGL(plrc->dhrc == (DHGLRC) 0, "wglCreateContext: dhrc != 0\n");
    vFreeLRC(plrc);
    vFreeHandle(irc);           // it unlocks handle too
    return NULL;
}

/******************************Public*Routine******************************\
*
* CreateMetafileSurf
*
* Fills out a GLSURF for a metafile DC
*
* History:
*  Tue Aug 27 11:41:35 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#ifdef GL_METAFILE
void CreateMetafileSurf(HDC hdc, int iLayer, GLSURF *pgsurf)
{
    pgsurf->dwFlags = GLSURF_HDC | GLSURF_METAFILE;
    pgsurf->iLayer = iLayer;

    // Metafile surfaces don't have a real pixel format
    pgsurf->ipfd = 0;

    // Create a fake format of 24-bit DIB with BGR
    memset(&pgsurf->pfd, 0, sizeof(PIXELFORMATDESCRIPTOR));
    pgsurf->pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);
    pgsurf->pfd.nVersion = 1;
    pgsurf->pfd.dwFlags = PFD_DRAW_TO_BITMAP | PFD_SUPPORT_OPENGL |
        PFD_GENERIC_FORMAT;
    pgsurf->pfd.iPixelType = PFD_TYPE_RGBA;
    pgsurf->pfd.cColorBits = 24;
    pgsurf->pfd.cStencilBits = 8;
    pgsurf->pfd.cRedBits = 8;
    pgsurf->pfd.cRedShift = 16;
    pgsurf->pfd.cGreenBits = 8;
    pgsurf->pfd.cGreenShift = 8;
    pgsurf->pfd.cBlueBits = 8;
    pgsurf->pfd.cBlueShift = 0;
    pgsurf->pfd.cDepthBits = 16;
    pgsurf->pfd.iLayerType = PFD_MAIN_PLANE;

    pgsurf->hdc = hdc;
}
#endif

/******************************Public*Routine******************************\
* wglSurfacePixelFormat
*
* wglDescribePixelFormat doesn't describe the format of the surface we want
* to render into.  Some fields need to be fixed up if the surface is RGB,
* BGR, or BITFIELDS.
*
* Expects a Describe'd pixel format as input
*
\**************************************************************************/

VOID APIENTRY wglSurfacePixelFormat(HDC hdc, PIXELFORMATDESCRIPTOR *ppfd)
{
    HBITMAP hbm;
    BITMAP bm;
    ULONG cBitmapColorBits;

    hbm = CreateCompatibleBitmap(hdc, 1, 1);
    if ( hbm )
    {
        if ( GetObject(hbm, sizeof(bm), &bm) )
        {
            cBitmapColorBits = bm.bmPlanes * bm.bmBitsPixel;

#if DBG
            // If dynamic color depth caused depth mismatch one of two
            // things will happen: 1) bitmap creation will fail because
            // we failed to fill in color format, or 2) drawing will
            // be incorrect.  We will not crash.

            if (cBitmapColorBits != ppfd->cColorBits)
                WARNING("pixel format/surface color depth mismatch\n");
#endif

            if ( cBitmapColorBits >= 16 )
                __wglGetBitfieldColorFormat(hdc, cBitmapColorBits, ppfd,
                                            TRUE);
        }
        else
        {
            WARNING("wglSurfacePixelFormat: GetObject failed\n");
        }

        DeleteObject(hbm);
    }
    else
    {
        WARNING("wglSurfacePixelFormat: Unable to create cbm\n");
    }
}

/******************************Public*Routine******************************\
* bLayerPixelFormat
*
* Fake up a pixel format using the layer descriptor format.
*
* We use this to describe the layer plane in a format that the generic
* context can understand.
*
* Expects a Describe'd pixel format as input for the flags
*
\**************************************************************************/

BOOL FASTCALL bLayerPixelFormat(HDC hdc, PIXELFORMATDESCRIPTOR *ppfd,
                                int ipfd, LONG iLayer)
{
    LAYERPLANEDESCRIPTOR lpd;

    if (!wglDescribeLayerPlane(hdc, ipfd, iLayer, sizeof(lpd), &lpd))
        return FALSE;

    ppfd->nSize    = sizeof(PIXELFORMATDESCRIPTOR);
    ppfd->nVersion = 1;
    ppfd->dwFlags  = (ppfd->dwFlags & (PFD_GENERIC_FORMAT |
                                       PFD_GENERIC_ACCELERATED)) |
                     (lpd.dwFlags & ~(LPD_SHARE_DEPTH | LPD_SHARE_STENCIL |
                                      LPD_SHARE_ACCUM | LPD_TRANSPARENT));
    ppfd->iPixelType  = lpd.iPixelType;
    ppfd->cColorBits  = lpd.cColorBits;
    ppfd->cRedBits    = lpd.cRedBits   ;
    ppfd->cRedShift   = lpd.cRedShift  ;
    ppfd->cGreenBits  = lpd.cGreenBits ;
    ppfd->cGreenShift = lpd.cGreenShift;
    ppfd->cBlueBits   = lpd.cBlueBits  ;
    ppfd->cBlueShift  = lpd.cBlueShift ;
    ppfd->cAlphaBits  = lpd.cAlphaBits ;
    ppfd->cAlphaShift = lpd.cAlphaShift;
    if (!(lpd.dwFlags & LPD_SHARE_ACCUM))
    {
        ppfd->cAccumBits      = 0;
        ppfd->cAccumRedBits   = 0;
        ppfd->cAccumGreenBits = 0;
        ppfd->cAccumBlueBits  = 0;
        ppfd->cAccumAlphaBits = 0;
    }
    if (!(lpd.dwFlags & LPD_SHARE_DEPTH))
    {
        ppfd->cDepthBits = 0;
    }
    if (!(lpd.dwFlags & LPD_SHARE_STENCIL))
    {
        ppfd->cStencilBits = 0;
    }
    ppfd->cAuxBuffers = 0;

    return TRUE;
}

/******************************Public*Routine******************************\
*
* IsDirectDrawDevice
*
* Returns surface associated with HDC if such an association exists
*
* History:
*  Wed Sep 25 13:18:02 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY IsDirectDrawDevice(HDC hdc)
{
    LPDIRECTDRAWSURFACE pdds;
    HDC hdcDevice;

    if (pfnGetSurfaceFromDC != NULL &&
        pfnGetSurfaceFromDC(hdc, &pdds, &hdcDevice) == DD_OK)
    {
        // The call gave us a reference on the surface so release it.
        pdds->lpVtbl->Release(pdds);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/******************************Public*Routine******************************\
*
* DdPixelDepth
*
* Determines the number of bits per pixel for a surface.
*
* History:
*  Wed Nov 20 16:57:07 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BYTE APIENTRY DdPixelDepth(DDSURFACEDESC *pddsd)
{
    if (pddsd->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED4)
    {
        return 4;
    }
    else if (pddsd->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)
    {
        return 8;
    }
    else
    {
        return (BYTE)DdPixDepthToCount(pddsd->ddpfPixelFormat.dwRGBBitCount);
    }
}

/******************************Public*Routine******************************\
*
* wglIsDirectDevice
*
* Checks to see whether the given DC is a screen DC on the
* surface for which we have direct screen access
*
* History:
*  Fri Apr 19 15:17:30 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY wglIsDirectDevice(HDC hdc)
{
    if (wglObjectType(hdc) != OBJ_DC)
    {
        return FALSE;
    }

    // What about multiple displays?
    return GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY;
}

/******************************Public*Routine******************************\
*
* InitDeviceSurface
*
* Fills out a GLSURF for an HDC-based surface
*
* History:
*  Tue Aug 27 19:22:38 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY InitDeviceSurface(HDC hdc, int ipfd, int iLayer,
                                DWORD dwObjectType, BOOL bUpdatePfd,
                                GLSURF *pgsurf)
{
    pgsurf->dwFlags = GLSURF_HDC;
    pgsurf->iLayer = iLayer;
    pgsurf->ipfd = ipfd;
    pgsurf->hdc = hdc;
    pgsurf->hwnd = NULL;

    // Determine whether direct memory access is available for this surface
    // or not.  The two cases are:
    //   It's a screen surface and we have direct screen access
    //   It's a DIBSECTION memory surface
    if (dwObjectType == OBJ_DC)
    {
        pgsurf->dwFlags |= GLSURF_DIRECTDC;

        if (wglIsDirectDevice(hdc))
        {
            pgsurf->dwFlags |= GLSURF_SCREEN | GLSURF_VIDEO_MEMORY;
            pgsurf->hwnd = WindowFromDC(hdc);

            if (GLDIRECTSCREEN)
            {
                pgsurf->dwFlags |= GLSURF_DIRECT_ACCESS;
            }
        }
    }
    else if (dwObjectType == OBJ_MEMDC)
    {
        DIBSECTION ds;

        if (GetObject(GetCurrentObject(hdc, OBJ_BITMAP), sizeof(ds), &ds) ==
            sizeof(ds) && ds.dsBm.bmBits != NULL)
        {
            pgsurf->dwFlags |= GLSURF_DIRECT_ACCESS;
        }

        if (bUpdatePfd)
        {
            // Update pixel format with true surface information rather
            // than device information
            wglSurfacePixelFormat(hdc, &pgsurf->pfd);
        }
    }

    if (bUpdatePfd &&
        iLayer > 0 &&
        !bLayerPixelFormat(hdc, &pgsurf->pfd, ipfd, iLayer))
    {
        return FALSE;
    }

    return TRUE;
}

/******************************Public*Routine******************************\
*
* InitDdSurface
*
* Completes a GLSURF for a DirectDraw-based surface.
* Pixel format information should already be filled in.
*
* History:
*  Mon Aug 26 13:50:04 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL InitDdSurface(LPDIRECTDRAWSURFACE pdds, HDC hdcDevice, GLSURF *pgsurf)
{
    DDSCAPS ddscaps;
    LPDIRECTDRAWSURFACE pddsZ;
    DDSURFACEDESC *pddsd;

    pgsurf->hdc = hdcDevice;

    pgsurf->dd.gddsFront.ddsd.dwSize = sizeof(DDSURFACEDESC);
    pgsurf->dd.gddsZ.ddsd.dwSize = sizeof(DDSURFACEDESC);

    pddsd = &pgsurf->dd.gddsFront.ddsd;
    if (pdds->lpVtbl->GetSurfaceDesc(pdds, pddsd) != DD_OK)
    {
        return FALSE;
    }

    pgsurf->dwFlags = GLSURF_DIRECTDRAW | GLSURF_DIRECT_ACCESS;
    pgsurf->iLayer = 0;

    // Check for an attached Z buffer
    memset(&ddscaps, 0, sizeof(ddscaps));
    ddscaps.dwCaps = DDSCAPS_ZBUFFER;
    pddsd = &pgsurf->dd.gddsZ.ddsd;
    if (pdds->lpVtbl->GetAttachedSurface(pdds, &ddscaps, &pddsZ) == DD_OK)
    {
        if (pddsZ->lpVtbl->GetSurfaceDesc(pddsZ, pddsd) != DD_OK)
        {
            pddsZ->lpVtbl->Release(pddsZ);
            return FALSE;
        }
    }
    else
    {
        memset(&pgsurf->dd.gddsZ, 0, sizeof(pgsurf->dd.gddsZ));
    }

    // If both the color buffer and the Z buffer are in video memory
    // then hardware acceleration is possible
    if ((pgsurf->dd.gddsFront.ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
        (pddsZ == NULL ||
         (pgsurf->dd.gddsZ.ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)))
    {
        pgsurf->dwFlags |= GLSURF_VIDEO_MEMORY;
    }

    pgsurf->dd.gddsFront.pdds = pdds;
    pgsurf->dd.gddsFront.dwBitDepth =
        DdPixDepthToCount(pgsurf->dd.gddsFront.
                          ddsd.ddpfPixelFormat.dwRGBBitCount);
    // GetAttachedSurface gave us a reference to the Z buffer
    pgsurf->dd.gddsZ.pdds = pddsZ;
    pgsurf->dd.gddsZ.dwBitDepth =
        DdPixDepthToCount(pgsurf->dd.gddsZ.
                          ddsd.ddpfPixelFormat.dwZBufferBitDepth);

    return TRUE;
}

/******************************Public*Routine******************************\
* wglCreateLayerContext(HDC hdc, int iLayer)
*
* Create a rendering context for a specific layer
*
* Arguments:
*   hdc        - Device context.
*   iLayer     - Layer
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Rewrote it.
\**************************************************************************/

HGLRC WINAPI wglCreateLayerContext(HDC hdc, int iLayer)
{
    DWORD dwObjectType;
    GLSURF gsurf;
    LPDIRECTDRAWSURFACE pdds;
    HDC hdcDevice;
    HGLRC hrc;

    DBGENTRY("wglCreateLayerContext\n");

// Flush OpenGL calls.

    GLFLUSH();

// Validate the DC.

    dwObjectType = wglObjectType(hdc);
    switch (dwObjectType)
    {
    case OBJ_DC:
    case OBJ_MEMDC:
        break;

    case OBJ_ENHMETADC:
#ifdef GL_METAFILE
        if (pfnGdiAddGlsRecord == NULL)
        {
            DBGLEVEL1(LEVEL_ERROR, "wglCreateContext: metafile hdc: 0x%lx\n",
                      hdc);
            SetLastError(ERROR_INVALID_HANDLE);
            return((HGLRC) 0);
        }
        break;
#else
        DBGLEVEL1(LEVEL_ERROR, "wglCreateContext: metafile hdc: 0x%lx\n", hdc);
        SetLastError(ERROR_INVALID_HANDLE);
        return((HGLRC) 0);
#endif

    case OBJ_METADC:
    default:
        // 16-bit metafiles are not supported
        DBGLEVEL1(LEVEL_ERROR, "wglCreateContext: bad hdc: 0x%lx\n", hdc);
        SetLastError(ERROR_INVALID_HANDLE);
        return((HGLRC) 0);
    }

    pdds = NULL;
    hrc = NULL;

    memset(&gsurf, 0, sizeof(gsurf));
    gsurf.ipfd = GetPixelFormat(hdc);

#ifdef GL_METAFILE
    // Skip pixel format checks for metafiles
    if (dwObjectType == OBJ_ENHMETADC)
    {
        CreateMetafileSurf(hdc, iLayer, &gsurf);
        goto NoPixelFormat;
    }
#endif

// Get the current pixel format of the window or surface.
// If no pixel format has been set, return error.

    if (gsurf.ipfd == 0)
    {
        WARNING("wglCreateContext: No pixel format set in hdc\n");
        SetLastError(ERROR_INVALID_PIXEL_FORMAT);
        return ((HGLRC) 0);
    }

    if (!DescribePixelFormat(hdc, gsurf.ipfd, sizeof(gsurf.pfd), &gsurf.pfd))
    {
        DBGERROR("wglCreateContext: DescribePixelFormat failed\n");
        return ((HGLRC) 0);
    }

    // Check for a DirectDraw surface
    if (pfnGetSurfaceFromDC != NULL &&
        pfnGetSurfaceFromDC(hdc, &pdds, &hdcDevice) == DD_OK)
    {
        // Don't allow layers for DirectDraw surfaces since
        // layering is done through DirectDraw itself.
        if (iLayer != 0 ||
            !InitDdSurface(pdds, hdcDevice, &gsurf))
        {
            goto Exit;
        }
    }
    else if (!InitDeviceSurface(hdc, gsurf.ipfd, iLayer, dwObjectType,
                                TRUE, &gsurf))
    {
        goto Exit;
    }

#ifdef GL_METAFILE
 NoPixelFormat:
#endif

    hrc = CreateAnyContext(&gsurf);

 Exit:
    if (hrc == NULL)
    {
        if (pdds != NULL)
        {
            pdds->lpVtbl->Release(pdds);

            // Release reference on Z buffer if necessary
            if (gsurf.dd.gddsZ.pdds != NULL)
            {
                gsurf.dd.gddsZ.pdds->lpVtbl->Release(gsurf.dd.gddsZ.pdds);
            }
        }
    }

    return hrc;
}

/******************************Public*Routine******************************\
* wglCreateContext(HDC hdc)
*
* Create a rendering context.
*
* Arguments:
*   hdc        - Device context.
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Rewrote it.
\**************************************************************************/

HGLRC WINAPI wglCreateContext(HDC hdc)
{
    return wglCreateLayerContext(hdc, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\wgl.c ===
/******************************Module*Header*******************************\
* Module Name: wgl.c
*
* Routines to integrate Windows NT and OpenGL.
*
* Created: 10-26-1993
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <wingdip.h>

#include <glscreen.h>
#include <glgenwin.h>

#include "batchinf.h"
#include "glapi.h"
#include "glsbcltu.h"
#include "wgldef.h"
#include "metasup.h"
#include "glclt.h"
#include "gencx.h"
#include "context.h"
#include "global.h"
#include "mcdcx.h"

// Static functions prototypes

static PROC      pfnGenGlExtProc(LPCSTR lpszProc);
static PROC      pfnSimGlExtProc(LPCSTR lpszProc);

/******************************Public*Routine******************************\
*
* wglObjectType
*
* Returns GetObjectType result with the exception that
* metafile-spooled printer DC's come back as metafile objects
*
* History:
*  Fri Jun 16 12:10:07 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD APIENTRY wglObjectType(HDC hdc)
{
    DWORD dwObjectType;

    dwObjectType = GetObjectType(hdc);

#ifdef GL_METAFILE
    if (dwObjectType == OBJ_DC &&
        pfnGdiIsMetaPrintDC != NULL &&
        GlGdiIsMetaPrintDC(hdc))
    {
        dwObjectType = OBJ_ENHMETADC;
    }
#endif

    // OBJ_DDRAW is reserved as a special identifier.  Make sure
    // we aren't returning it from here.
    ASSERTOPENGL(dwObjectType != OBJ_DDRAW,
                 "Unexpected object type\n");
    
    return dwObjectType;
}

/******************************Public*Routine******************************\
* wglDeleteContext(HGLRC hrc)
*
* Delete the rendering context
*
* Arguments:
*   hrc        - Rendering context.
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Rewrote it.
\**************************************************************************/

BOOL WINAPI wglDeleteContext(HGLRC hrc)
{
    PLHE  plheRC;
    ULONG irc;
    PLRC  plrc;
    BOOL  bRet = FALSE;

    DBGENTRY("wglDeleteContext\n");

// Flush OpenGL calls.

    GLFLUSH();

// Validate the RC.

    if (cLockHandle((ULONG_PTR)hrc) <= 0)
    {
        DBGLEVEL1(LEVEL_ERROR, "wglDeleteContext: can't lock hrc 0x%lx\n", hrc);
        return(bRet);
    }
    irc = MASKINDEX(hrc);
    plheRC = pLocalTable + irc;
    plrc = (PLRC) plheRC->pv;
    ASSERTOPENGL(plrc->ident == LRC_IDENTIFIER, "wglDeleteContext: Bad plrc\n");
    DBGLEVEL2(LEVEL_INFO, "wglDeleteContext: hrc: 0x%lx, plrc: 0x%lx\n", hrc, plrc);

    if (plrc->tidCurrent != INVALID_THREAD_ID)
    {
// The RC must be current to this thread because makecurrent locks
// down the handle.

        ASSERTOPENGL(plrc->tidCurrent == GetCurrentThreadId(),
            "wglDeleteCurrent: hrc is current to another thread\n");

// Make the RC inactive first.

        if (!bMakeNoCurrent())
        {
            DBGERROR("wglDeleteCurrent: bMakeNoCurrent failed\n");
        }
    }

    if (plrc->dhrc)
    {
// If it is a device format, call the driver to delete its context.

        bRet = plrc->pGLDriver->pfnDrvDeleteContext(plrc->dhrc);
        plrc->dhrc = (DHGLRC) 0;
    }
    else
    {
#ifdef GL_METAFILE
        // If we have metafile state, clean it up
        if (plrc->uiGlsCaptureContext != 0 ||
            plrc->uiGlsPlaybackContext != 0)
        {
            DeleteMetaRc(plrc);
        }
#endif
        
// If it is a generic format, call the server to delete its context.

        bRet = __wglDeleteContext((HANDLE) plheRC->hgre);
    }

// Always clean up local objects.

    vFreeLRC(plrc);
    vFreeHandle(irc);           // it unlocks handle too
    if (!bRet)
        DBGERROR("wglDeleteContext failed\n");
    return(bRet);
}

/******************************Public*Routine******************************\
* wglGetCurrentContext(VOID)
*
* Return the current rendering context
*
* Arguments:
*   None
*
* Returns:
*   hrc        - Rendering context.
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

HGLRC WINAPI wglGetCurrentContext(VOID)
{
    DBGENTRY("wglGetCurrentContext\n");

    if (GLTEB_CLTCURRENTRC())
        return(GLTEB_CLTCURRENTRC()->hrc);
    else
        return((HGLRC) 0);
}

/******************************Public*Routine******************************\
* wglGetCurrentDC(VOID)
*
* Return the device context that is associated with the current rendering
* context
*
* Arguments:
*   None
*
* Returns:
*   hdc        - device context.
*
* History:
*  Mon Jan 31 12:15:12 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

HDC WINAPI wglGetCurrentDC(VOID)
{
    PLRC plrc;
    
    DBGENTRY("wglGetCurrentDC\n");

    plrc = GLTEB_CLTCURRENTRC();
    if (plrc != NULL)
    {
        return plrc->gwidCurrent.hdc;
    }
    else
    {
        return((HDC) 0);
    }
}

/******************************Public*Routine******************************\
* wglUseFontBitmapsA
* wglUseFontBitmapsW
*
* Stubs that call wglUseFontBitmapsAW with the bUnicode flag set
* appropriately.
*
* History:
*  11-Mar-1994 gilmanw
* Changed to call wglUseFontBitmapsAW.
*
*  17-Dec-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL WINAPI wglUseFontBitmapsAW(HDC hdc, DWORD first, DWORD count,
                                DWORD listBase, BOOL bUnicode);

BOOL WINAPI
wglUseFontBitmapsA(HDC hdc, DWORD first, DWORD count, DWORD listBase)
{
    return wglUseFontBitmapsAW(hdc, first, count, listBase, FALSE);
}

BOOL WINAPI
wglUseFontBitmapsW(HDC hdc, DWORD first, DWORD count, DWORD listBase)
{
    return wglUseFontBitmapsAW(hdc, first, count, listBase, TRUE);
}

/******************************Public*Routine******************************\
* wglUseFontBitmapsAW
*
* Uses the current font in the specified DC to generate a series of OpenGL
* display lists, each of which consists of a glyph bitmap.
*
* Each glyph bitmap is generated by calling ExtTextOut to draw the glyph
* into a memory DC.  The contents of the memory DC are then copied into
* a buffer by GetDIBits and then put into the OpenGL display list.
*
* ABC spacing is used (if GetCharABCWidth() is supported by the font) to
* determine proper placement of the glyph origin and character advance width.
* Otherwise, A = C = 0 spacing is assumed and GetCharWidth() is used for the
* advance widths.
*
* Returns:
*
*   TRUE if successful, FALSE otherwise.
*
* History:
*  17-Dec-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL WINAPI
wglUseFontBitmapsAW(
    HDC   hdc,          // use HFONT from this DC
    DWORD first,        // generate glyphs starting with this Unicode codepoint
    DWORD count,        // range is this long [first, first+count-1]
    DWORD listBase,     // starting display list number
    BOOL  bUnicode      // TRUE for if in Unicode mode, FALSE if in Ansi mode
    )
{
    BOOL        bRet = FALSE;               // return value
    HDC         hdcMem;                     // render glyphs to this memory DC
    HBITMAP     hbm;                        // monochrome bitmap for memory DC
    LPABC       pabc, pabcTmp, pabcEnd;     // array of ABC spacing
    LPINT       piWidth, piTmp, piWidthEnd; // array of char adv. widths
    WCHAR       wc;                         // current Unicode char to render
    RECT        rc;                         // background rectangle to clear
    TEXTMETRICA tm;                         // metrics of the font
    BOOL        bTrueType;                  // TrueType supports ABC spacing
    int         iMaxWidth = 1;              // maximum glyph width
    int         iBitmapWidth;               // DWORD aligned bitmap width
    BYTE        ajBmi[sizeof(BITMAPINFO) + sizeof(RGBQUAD)];
    BITMAPINFO  *pbmi = (BITMAPINFO *)ajBmi;// bitmap info for GetDIBits
    GLint       iUnpackRowLength;           // save GL_UNPACK_ROW_LENGTH
    GLint       iUnpackAlign;               // save GL_UNPACK_ALIGNMENT
    PVOID       pv;                         // pointer to glyph bitmap buffer

// Return error if there is no current RC.

    if (!GLTEB_CLTCURRENTRC())
    {
        WARNING("wglUseFontBitmapsAW: no current RC\n");
        SetLastError(ERROR_INVALID_HANDLE);
        return bRet;
    }

// Get TEXTMETRIC.  The only fields used are those that are invariant with
// respect to Unicode vs. ANSI.  Therefore, we can call GetTextMetricsA for
// both cases.

    if ( !GetTextMetricsA(hdc, &tm) )
    {
        WARNING("wglUseFontBitmapsAW: GetTextMetricsA failed\n");
        return bRet;
    }

// If its a TrueType font, we can get ABC spacing.

    if ( bTrueType = (tm.tmPitchAndFamily & TMPF_TRUETYPE) )
    {
    // Allocate memory for array of ABC data.

        if ( (pabc = (LPABC) ALLOC(sizeof(ABC) * count)) == (LPABC) NULL )
        {
            WARNING("wglUseFontBitmapsAW: Alloc of pabc failed\n");
            return bRet;
        }

    // Get ABC metrics.

        if ( bUnicode )
        {
            if ( !GetCharABCWidthsW(hdc, first, first + count - 1, pabc) )
            {
                WARNING("wglUseFontBitmapsAW: GetCharABCWidthsW failed\n");
                FREE(pabc);
                return bRet;
            }
        }
        else
        {
            if ( !GetCharABCWidthsA(hdc, first, first + count - 1, pabc) )
            {
                WARNING("wglUseFontBitmapsAW: GetCharABCWidthsA failed\n");
                FREE(pabc);
                return bRet;
            }
        }

    // Find max glyph width.

        for (pabcTmp = pabc, pabcEnd = pabc + count;
             pabcTmp < pabcEnd;
             pabcTmp++)
        {
            if (iMaxWidth < (int) pabcTmp->abcB)
                iMaxWidth = pabcTmp->abcB;
        }
    }

// Otherwise we will have to use just the advance width and assume
// A = C = 0.

    else
    {
    // Allocate memory for array of ABC data.

        if ( (piWidth = (LPINT) ALLOC(sizeof(INT) * count)) == (LPINT) NULL )
        {
            WARNING("wglUseFontBitmapsAW: Alloc of pabc failed\n");
            return bRet;
        }

    // Get char widths.

        if ( bUnicode )
        {
            if ( !GetCharWidthW(hdc, first, first + count - 1, piWidth) )
            {
                WARNING("wglUseFontBitmapsAW: GetCharWidthW failed\n");
                FREE(piWidth);
                return bRet;
            }
        }
        else
        {
            if ( !GetCharWidthA(hdc, first, first + count - 1, piWidth) )
            {
                WARNING("wglUseFontBitmapsAW: GetCharWidthA failed\n");
                FREE(piWidth);
                return bRet;
            }
        }

    // Find max glyph width.

        for (piTmp = piWidth, piWidthEnd = piWidth + count;
             piTmp < piWidthEnd;
             piTmp++)
        {
            if (iMaxWidth < *piTmp)
                iMaxWidth = *piTmp;
        }
    }

// Compute the dword aligned width.  Bitmap scanlines must be aligned.

    iBitmapWidth = (iMaxWidth + 31) & -32;

// Allocate memory for the DIB.

    if ( (pv = (PVOID)
          ALLOC((iBitmapWidth / 8) * tm.tmHeight)) == (PVOID) NULL )
    {
        WARNING("wglUseFontBitmapsAW: Alloc of pv failed\n");
        (bTrueType) ? FREE(pabc) : FREE(piWidth);
        return bRet;
    }

// Create compatible DC/bitmap big enough to accomodate the biggest glyph
// in the range requested.

    hdcMem = CreateCompatibleDC(hdc);
    if ( (hbm = CreateBitmap(iBitmapWidth, tm.tmHeight, 1, 1, (VOID *) NULL)) == (HBITMAP) NULL )
    {
        WARNING("wglUseFontBitmapsAW: CreateBitmap failed\n");
        (bTrueType) ? FREE(pabc) : FREE(piWidth);
        FREE(pv);
        DeleteDC(hdcMem);
        return bRet;
    }
    SelectObject(hdcMem, hbm);
    SelectObject(hdcMem, GetCurrentObject(hdc, OBJ_FONT));
    SetMapMode(hdcMem, MM_TEXT);
    SetTextAlign(hdcMem, TA_TOP | TA_LEFT);
    SetBkColor(hdcMem, RGB(0, 0, 0));
    SetBkMode(hdcMem, OPAQUE);
    SetTextColor(hdcMem, RGB(255, 255, 255));

// Setup bitmap info header to retrieve a DIB from the compatible bitmap.

    pbmi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth         = iBitmapWidth;
    pbmi->bmiHeader.biHeight        = tm.tmHeight;
    pbmi->bmiHeader.biPlanes        = 1;
    pbmi->bmiHeader.biBitCount      = 1;
    pbmi->bmiHeader.biCompression   = BI_RGB;
    pbmi->bmiHeader.biSizeImage     = 0;
    pbmi->bmiHeader.biXPelsPerMeter = 0;
    pbmi->bmiHeader.biYPelsPerMeter = 0;
    pbmi->bmiHeader.biClrUsed       = 0;
    pbmi->bmiHeader.biClrImportant  = 0;
    pbmi->bmiColors[0].rgbRed   = 0;
    pbmi->bmiColors[0].rgbGreen = 0;
    pbmi->bmiColors[0].rgbBlue  = 0;
    pbmi->bmiColors[1].rgbRed   = 0xff;
    pbmi->bmiColors[1].rgbGreen = 0xff;
    pbmi->bmiColors[1].rgbBlue  = 0xff;

// Setup OpenGL to accept our bitmap format.

    glGetIntegerv(GL_UNPACK_ROW_LENGTH, &iUnpackRowLength);
    glGetIntegerv(GL_UNPACK_ALIGNMENT, &iUnpackAlign);

    if (glGetError() != GL_NO_ERROR)
    {
        //XXX too noisy on debug builds running stress with mode changes
        //WARNING("wglUseFontBitmapsAW: failed to get GL state\n");
        goto wglUseFontBitmapsAW_exit;
    }

    glPixelStorei(GL_UNPACK_ROW_LENGTH, iBitmapWidth);
    if (glGetError() != GL_NO_ERROR)
    {
        //XXX too noisy on debug builds running stress with mode changes
        //WARNING("wglUseFontBitmapsAW: failed to set GL state, row length\n");
        goto wglUseFontBitmapsAW_restore_state;
    }
    glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
    if (glGetError() != GL_NO_ERROR)
    {
        //XXX too noisy on debug builds running stress with mode changes
        //WARNING("wglUseFontBitmapsAW: failed to set GL state, alignment\n");
        goto wglUseFontBitmapsAW_restore_state;
    }

// Get the glyphs.  Each glyph is rendered one at a time into the the
// memory DC with ExtTextOutW (notice that the optional rectangle is
// used to clear the background).  Each glyph is then copied out of the
// memory DC's bitmap with GetDIBits into a buffer.  This buffer is passed
// to glBitmap as each display list is created.

    rc.left = 0;
    rc.top = 0;
    rc.right = iBitmapWidth;
    rc.bottom = tm.tmHeight;

    pabcTmp = pabc;
    piTmp = piWidth;
    
    for (wc = (WCHAR) first; wc < (WCHAR) (first + count); wc++, listBase++)
    {
        if ( bUnicode )
        {
            if ( !ExtTextOutW(hdcMem, bTrueType ? -pabcTmp->abcA : 0, 0, ETO_OPAQUE, &rc, &wc, 1, (INT *) NULL) ||
                 !GetDIBits(hdcMem, hbm, 0, tm.tmHeight, pv, pbmi, DIB_RGB_COLORS) )
            {
                WARNING("wglUseFontBitmapsAW: failed to render glyph\n");
                goto wglUseFontBitmapsAW_restore_state;
            }
        }
        else
        {
            if ( !ExtTextOutA(hdcMem, bTrueType ? -pabcTmp->abcA : 0, 0, ETO_OPAQUE, &rc, (LPCSTR) &wc, 1, (INT *) NULL) ||
                 !GetDIBits(hdcMem, hbm, 0, tm.tmHeight, pv, pbmi, DIB_RGB_COLORS) )
            {
                WARNING("wglUseFontBitmapsAW: failed to render glyph\n");
                goto wglUseFontBitmapsAW_restore_state;
            }
        }

        glNewList(listBase, GL_COMPILE);
        glBitmap((GLsizei) iBitmapWidth,
                 (GLsizei) tm.tmHeight,
                 (GLfloat) (bTrueType ? -pabcTmp->abcA : 0),
                 (GLfloat) tm.tmDescent,
                 (GLfloat) (bTrueType ? (pabcTmp->abcA + pabcTmp->abcB + pabcTmp->abcC) : *piTmp),
                 (GLfloat) 0.0,
                 (GLubyte *) pv);
        glEndList();

        if (bTrueType)
            pabcTmp++;
        else
            piTmp++;
    }

// We can finally return success.

    bRet = TRUE;

// Free resources.

wglUseFontBitmapsAW_restore_state:
    glPixelStorei(GL_UNPACK_ROW_LENGTH, iUnpackRowLength);
    glPixelStorei(GL_UNPACK_ALIGNMENT, iUnpackAlign);
wglUseFontBitmapsAW_exit:
    (bTrueType) ? FREE(pabc) : FREE(piWidth);
    FREE(pv);
    DeleteDC(hdcMem);
    DeleteObject(hbm);

    return bRet;
}

/******************************Public*Routine******************************\
*
* wglShareLists
*
* Allows a rendering context to share the display lists of another RC
*
* Returns:
*  TRUE if successful, FALSE otherwise
*
* History:
*  Tue Dec 13 14:57:17 1994     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL WINAPI
wglShareLists(HGLRC hrcSource, HGLRC hrcShare)
{
    BOOL fRet;
    PLRC plrcSource, plrcShare;
    ULONG irc;
    PLHE plheRC;
    HANDLE hrcSrvSource, hrcSrvShare;

    GLFLUSH();
    
    fRet = FALSE;

    // Validate the contexts

    if (cLockHandle((ULONG_PTR)hrcSource) <= 0)
    {
        DBGLEVEL1(LEVEL_ERROR, "wglShareLists: can't lock hrcSource 0x%lx\n",
                  hrcSource);
        goto wglShareListsEnd_nolock;
    }
    irc = MASKINDEX(hrcSource);
    plheRC = pLocalTable + irc;
    plrcSource = (PLRC)plheRC->pv;
    hrcSrvSource = (HANDLE) plheRC->hgre;
    ASSERTOPENGL(plrcSource->ident == LRC_IDENTIFIER,
                 "wglShareLists: Bad plrc\n");
    
    if (cLockHandle((ULONG_PTR)hrcShare) <= 0)
    {
        DBGLEVEL1(LEVEL_ERROR, "wglShareLists: can't lock hrcShare 0x%lx\n",
                  hrcShare);
        goto wglShareListsEnd_onelock;
    }
    irc = MASKINDEX(hrcShare);
    plheRC = pLocalTable + irc;
    plrcShare = (PLRC)plheRC->pv;
    hrcSrvShare = (HANDLE) plheRC->hgre;
    ASSERTOPENGL(plrcShare->ident == LRC_IDENTIFIER,
                 "wglShareLists: Bad plrc\n");

#ifdef GL_METAFILE
    // Metafile RC's can't share lists to ensure that metafiles are
    // completely self-sufficient
    if (plrcSource->uiGlsCaptureContext != 0 ||
        plrcShare->uiGlsCaptureContext != 0 ||
        plrcSource->uiGlsPlaybackContext != 0 ||
        plrcShare->uiGlsPlaybackContext != 0)
    {
        DBGLEVEL(LEVEL_ERROR,
                 "wglShareLists: Attempt to share metafile RC\n");
        SetLastError(ERROR_INVALID_HANDLE);
        goto wglShareListsEnd;
    }
#endif
    
    // Lists can only be shared between like implementations so make
    // sure that both contexts are either driver contexts or generic
    // contexts
    if ((plrcSource->dhrc != 0) != (plrcShare->dhrc != 0))
    {
        DBGLEVEL(LEVEL_ERROR, "wglShareLists: mismatched implementations\n");
        SetLastError(ERROR_INVALID_FUNCTION);
        goto wglShareListsEnd;
    }

    if (plrcSource->dhrc == 0)
    {
        PIXELFORMATDESCRIPTOR *ppfdShare, *ppfdSource;
        
        // Fail sharing unless color parameters match for the two contexts
        ppfdShare = &((__GLGENcontext *)hrcSrvShare)->gsurf.pfd;
        ppfdSource = &((__GLGENcontext *)hrcSrvSource)->gsurf.pfd;

        if (ppfdShare->iPixelType != ppfdSource->iPixelType ||
            ppfdShare->cColorBits != ppfdSource->cColorBits ||
            ppfdShare->cRedBits != ppfdSource->cRedBits ||
            ppfdShare->cRedShift != ppfdSource->cRedShift ||
            ppfdShare->cGreenBits != ppfdSource->cGreenBits ||
            ppfdShare->cGreenShift != ppfdSource->cGreenShift ||
            ppfdShare->cBlueBits != ppfdSource->cBlueBits ||
            ppfdShare->cBlueShift != ppfdSource->cBlueShift ||
            ppfdShare->cAlphaBits != ppfdSource->cAlphaBits ||
            ppfdShare->cAlphaShift != ppfdSource->cAlphaShift ||
	    (ppfdShare->dwFlags & PFD_GENERIC_ACCELERATED) !=
	    (ppfdSource->dwFlags & PFD_GENERIC_ACCELERATED))
        {
            SetLastError(ERROR_INVALID_PIXEL_FORMAT);
            goto wglShareListsEnd;
        }
        
        // For generic contexts, tell the server to share the lists
        
        fRet = __wglShareLists(hrcSrvShare, hrcSrvSource);
        if (!fRet)
        {
            DBGERROR("wglShareLists: server call failed\n");
        }
    }
    else
    {
        // For device contexts tell the server to share the lists
        
        // Ensure that both implementations are the same
        if (plrcSource->pGLDriver != plrcShare->pGLDriver)
        {
            DBGLEVEL(LEVEL_ERROR, "wglShareLists: mismatched "
                     "implementations\n");
            SetLastError(ERROR_INVALID_FUNCTION);
            goto wglShareListsEnd;
        }
        
        ASSERTOPENGL(plrcSource->pGLDriver != NULL,
                     "wglShareLists: No GLDriver\n");

        // Older drivers may not support this entry point, so
        // fail the call if they don't

        if (plrcSource->pGLDriver->pfnDrvShareLists == NULL)
        {
            WARNING("wglShareLists called on driver context "
                    "without driver support\n");
            SetLastError(ERROR_NOT_SUPPORTED);
        }
        else
        {
            fRet = plrcSource->pGLDriver->pfnDrvShareLists(plrcSource->dhrc,
                                                           plrcShare->dhrc);
        }
    }

wglShareListsEnd:
    vUnlockHandle((ULONG_PTR)hrcShare);
wglShareListsEnd_onelock:
    vUnlockHandle((ULONG_PTR)hrcSource);
wglShareListsEnd_nolock:
    return fRet;
}

/******************************Public*Routine******************************\
*
* wglGetDefaultProcAddress
*
* Returns generic extension functions for metafiling
*
* History:
*  Tue Nov 28 16:40:35 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

PROC WINAPI wglGetDefaultProcAddress(LPCSTR lpszProc)
{
    return pfnGenGlExtProc(lpszProc);
}

/******************************Public*Routine******************************\
* wglGetProcAddress
*
* The wglGetProcAddress function returns the address of an OpenGL extension
* function to be used with the current OpenGL rendering context.
*
* Arguments:
*   lpszProc   - Points to a null-terminated string containing the function
*                name.  The function must be an extension supported by the
*                implementation.
*
* Returns:
*   If the function succeeds, the return value is the address of the extension
*   function.  If no current context exists or the function fails, the return
*   value is NULL. To get extended error information, call GetLastError. 
*
* History:
*  Thu Dec 01 13:50:22 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

PROC WINAPI wglGetProcAddress(LPCSTR lpszProc)
{
    PLRC  plrc = GLTEB_CLTCURRENTRC();

    DBGENTRY("wglGetProcAddress\n");

// Flush OpenGL calls.

    GLFLUSH();

// Return error if there is no current RC.

    if (!plrc)
    {
        WARNING("wglGetProcAddress: no current RC\n");
        SetLastError(ERROR_INVALID_HANDLE);
        return((PROC) NULL);
    }

// Handle generic RC.
// Return the generic extension function entry point

    if (!plrc->dhrc)
        return(pfnGenGlExtProc(lpszProc));

// Handle driver RC.
// There are 3 cases:
//   1. New drivers that support DrvGetProcAddress.
//   2. Old drivers that don't support DrvGetProcAddress but export the function
//   3. If we fail to obtain a function address in 1 and 2, it may still be
//      simulated by the generic implemenation for the driver
//      (e.g. glDrawArraysEXT).  Return the simulated entry point if found.

    if (plrc->pGLDriver->pfnDrvGetProcAddress)
    {
// Case 1
        PROC pfn = plrc->pGLDriver->pfnDrvGetProcAddress(lpszProc);
        if (pfn)
            return(pfn);
    }
#ifdef OBSOLETE
    else
    {
// Case 2
        PROC pfn = GetProcAddress(plrc->pGLDriver->hModule, lpszProc);
        if (pfn)
            return(pfn);
    }
#endif

// Case 3
    return (pfnSimGlExtProc(lpszProc));
}

/******************************Public*Routine******************************\
* pfnGenGlExtProc
*
* Return the generic implementation extension function address.
*
* Returns NULL if the function is not found.
*
* History:
*  Thu Dec 01 13:50:22 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

typedef struct _GLEXTPROC {
    LPCSTR szProc;      // extension function name
    PROC   Proc;        // extension function address
} GLEXTPROC, *PGLEXTPROC;

// Extension functions supported by the generic implementation
// See also genglExtProcsSim for simulations.
// NOTE: remember to update GL_EXTENSIONS in glGetString.

GLEXTPROC genglExtProcs[] =
{
    { "glAddSwapHintRectWIN"   , (PROC) glAddSwapHintRectWIN      },
    { "glColorTableEXT"        , (PROC) glColorTableEXT           },
    { "glColorSubTableEXT"     , (PROC) glColorSubTableEXT        },
    { "glGetColorTableEXT"     , (PROC) glGetColorTableEXT        },
    { "glGetColorTableParameterivEXT", (PROC) glGetColorTableParameterivEXT},
    { "glGetColorTableParameterfvEXT", (PROC) glGetColorTableParameterfvEXT},
    { "glDrawRangeElementsWIN", (PROC) glDrawRangeElementsWIN},
#ifdef GL_EXT_flat_paletted_lighting
    { "glColorTableParameterivEXT", (PROC) glColorTableParameterivEXT},
    { "glColorTableParameterfvEXT", (PROC) glColorTableParameterfvEXT},
#endif // GL_EXT_flat_paletted_lighting
#ifdef GL_WIN_multiple_textures
    { "glCurrentTextureIndexWIN", (PROC) glCurrentTextureIndexWIN },
    { "glMultiTexCoord1dWIN", (PROC) glMultiTexCoord1dWIN },
    { "glMultiTexCoord1dvWIN", (PROC) glMultiTexCoord1dvWIN },
    { "glMultiTexCoord1fWIN", (PROC) glMultiTexCoord1fWIN },
    { "glMultiTexCoord1fvWIN", (PROC) glMultiTexCoord1fvWIN },
    { "glMultiTexCoord1iWIN", (PROC) glMultiTexCoord1iWIN },
    { "glMultiTexCoord1ivWIN", (PROC) glMultiTexCoord1ivWIN },
    { "glMultiTexCoord1sWIN", (PROC) glMultiTexCoord1sWIN },
    { "glMultiTexCoord1svWIN", (PROC) glMultiTexCoord1svWIN },
    { "glMultiTexCoord2dWIN", (PROC) glMultiTexCoord2dWIN },
    { "glMultiTexCoord2dvWIN", (PROC) glMultiTexCoord2dvWIN },
    { "glMultiTexCoord2fWIN", (PROC) glMultiTexCoord2fWIN },
    { "glMultiTexCoord2fvWIN", (PROC) glMultiTexCoord2fvWIN },
    { "glMultiTexCoord2iWIN", (PROC) glMultiTexCoord2iWIN },
    { "glMultiTexCoord2ivWIN", (PROC) glMultiTexCoord2ivWIN },
    { "glMultiTexCoord2sWIN", (PROC) glMultiTexCoord2sWIN },
    { "glMultiTexCoord2svWIN", (PROC) glMultiTexCoord2svWIN },
    { "glMultiTexCoord3dWIN", (PROC) glMultiTexCoord3dWIN },
    { "glMultiTexCoord3dvWIN", (PROC) glMultiTexCoord3dvWIN },
    { "glMultiTexCoord3fWIN", (PROC) glMultiTexCoord3fWIN },
    { "glMultiTexCoord3fvWIN", (PROC) glMultiTexCoord3fvWIN },
    { "glMultiTexCoord3iWIN", (PROC) glMultiTexCoord3iWIN },
    { "glMultiTexCoord3ivWIN", (PROC) glMultiTexCoord3ivWIN },
    { "glMultiTexCoord3sWIN", (PROC) glMultiTexCoord3sWIN },
    { "glMultiTexCoord3svWIN", (PROC) glMultiTexCoord3svWIN },
    { "glMultiTexCoord4dWIN", (PROC) glMultiTexCoord4dWIN },
    { "glMultiTexCoord4dvWIN", (PROC) glMultiTexCoord4dvWIN },
    { "glMultiTexCoord4fWIN", (PROC) glMultiTexCoord4fWIN },
    { "glMultiTexCoord4fvWIN", (PROC) glMultiTexCoord4fvWIN },
    { "glMultiTexCoord4iWIN", (PROC) glMultiTexCoord4iWIN },
    { "glMultiTexCoord4ivWIN", (PROC) glMultiTexCoord4ivWIN },
    { "glMultiTexCoord4sWIN", (PROC) glMultiTexCoord4sWIN },
    { "glMultiTexCoord4svWIN", (PROC) glMultiTexCoord4svWIN },
    { "glBindNthTextureWIN", (PROC) glBindNthTextureWIN },
    { "glNthTexCombineFuncWIN", (PROC) glNthTexCombineFuncWIN },
#endif // GL_WIN_multiple_textures
};

static PROC pfnGenGlExtProc(LPCSTR lpszProc)
{
    CONST CHAR *pch1, *pch2;
    int  i;

    DBGENTRY("pfnGenGlExtProc\n");

// Return extension function address if it is found.

    for (i = 0; i < sizeof(genglExtProcs) / sizeof(genglExtProcs[0]); i++)
    {
        // Compare names.
        for (pch1 = lpszProc, pch2 = genglExtProcs[i].szProc;
             *pch1 == *pch2 && *pch1;
             pch1++, pch2++)
            ;

        // If found, return the address.
        if (*pch1 == *pch2 && !*pch1)
            return genglExtProcs[i].Proc;
    }

// Extension is not supported by the generic implementation, return NULL.

    SetLastError(ERROR_PROC_NOT_FOUND);
    return((PROC) NULL);
}

/******************************Public*Routine******************************\
* pfnSimGlExtProc
*
* Return the extension function address that is the generic implemenation's
* simulation for the client drivers.  The simulation is used only if the
* driver does not support an extension that is desirable to apps.
*
* Returns NULL if the function is not found.
*
* History:
*  Thu Dec 01 13:50:22 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

// Extension functions simulated by the generic implementation for the client
// drivers
// NOTE: remember to update GL_EXTENSIONS in glGetString.

static PROC pfnSimGlExtProc(LPCSTR lpszProc)
{
// Extension is not supported by the generic implementation, return NULL.

    SetLastError(ERROR_PROC_NOT_FOUND);
    return((PROC) NULL);
}

/******************************Public*Routine******************************\
*
* wglCopyContext
*
* Copies all of one context's state to another one
*
* Returns:
*  TRUE if successful, FALSE otherwise
*
* History:
*  Fri May 26 14:57:17 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL WINAPI
wglCopyContext(HGLRC hrcSource, HGLRC hrcDest, UINT fuMask)
{
    BOOL fRet;
    PLRC plrcSource, plrcDest;
    ULONG irc;
    PLHE plheRC;
    HANDLE hrcSrvSource, hrcSrvDest;

    GLFLUSH();
    
    fRet = FALSE;

    // Validate the contexts

    if (cLockHandle((ULONG_PTR)hrcSource) <= 0)
    {
        DBGLEVEL1(LEVEL_ERROR, "wglCopyContext: can't lock hrcSource 0x%lx\n",
                  hrcSource);
        goto wglCopyContextEnd_nolock;
    }
    irc = MASKINDEX(hrcSource);
    plheRC = pLocalTable + irc;
    plrcSource = (PLRC)plheRC->pv;
    hrcSrvSource = (HANDLE) plheRC->hgre;
    ASSERTOPENGL(plrcSource->ident == LRC_IDENTIFIER,
                 "wglCopyContext: Bad plrc\n");
    
    if (cLockHandle((ULONG_PTR)hrcDest) <= 0)
    {
        DBGLEVEL1(LEVEL_ERROR, "wglCopyContext: can't lock hrcDest 0x%lx\n",
                  hrcDest);
        goto wglCopyContextEnd_onelock;
    }
    irc = MASKINDEX(hrcDest);
    plheRC = pLocalTable + irc;
    plrcDest = (PLRC)plheRC->pv;
    hrcSrvDest = (HANDLE) plheRC->hgre;
    ASSERTOPENGL(plrcDest->ident == LRC_IDENTIFIER,
                 "wglCopyContext: Bad plrc\n");

    // Context can only be copied between like implementations so make
    // sure that both contexts are either driver contexts or generic
    // contexts
    if ((plrcSource->dhrc != 0) != (plrcDest->dhrc != 0))
    {
        DBGLEVEL(LEVEL_ERROR, "wglCopyContext: mismatched implementations\n");
        SetLastError(ERROR_INVALID_FUNCTION);
        goto wglCopyContextEnd;
    }

    // The destination context cannot be current to a thread
    if (plrcDest->tidCurrent != INVALID_THREAD_ID)
    {
        DBGLEVEL(LEVEL_ERROR, "wglCopyContext: destination has tidCurrent\n");
        SetLastError(ERROR_INVALID_HANDLE);
        goto wglCopyContextEnd;
    }
    
    if (plrcSource->dhrc == 0)
    {
        // For generic contexts, tell the server to share the lists
        
        fRet = __wglCopyContext(hrcSrvSource, hrcSrvDest, fuMask);
        if (!fRet)
        {
            DBGERROR("wglCopyContext: server call failed\n");
        }
    }
    else
    {
        // For device contexts tell the driver to copy the context
        
        // Ensure that both implementations are the same
        if (plrcSource->pGLDriver != plrcDest->pGLDriver)
        {
            DBGLEVEL(LEVEL_ERROR, "wglCopyContext: mismatched "
                     "implementations\n");
            SetLastError(ERROR_INVALID_FUNCTION);
            goto wglCopyContextEnd;
        }
        
        ASSERTOPENGL(plrcSource->pGLDriver != NULL,
                     "wglCopyContext: No GLDriver\n");

        // Older drivers may not support this entry point, so
        // fail the call if they don't

        if (plrcSource->pGLDriver->pfnDrvCopyContext == NULL)
        {
            WARNING("wglCopyContext called on driver context "
                    "without driver support\n");
            SetLastError(ERROR_NOT_SUPPORTED);
        }
        else
        {
            fRet = plrcSource->pGLDriver->pfnDrvCopyContext(plrcSource->dhrc,
                                                            plrcDest->dhrc,
                                                            fuMask);
        }
    }

wglCopyContextEnd:
    vUnlockHandle((ULONG_PTR)hrcDest);
wglCopyContextEnd_onelock:
    vUnlockHandle((ULONG_PTR)hrcSource);
wglCopyContextEnd_nolock:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\varray.c ===
/****************************************************************************\
*
* Client side vertex array
*
* History
*   16-Jan-1995 mikeke    Created
*
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <stdio.h>

#include "compsize.h"
#include "glsize.h"

/****************************************************************************/

#if DBG
// The WARNING_NOOP macro will output the debug message once only.
// If we have output a warning before, the new warnings are ignored.

static int cWarningNoop = 0;

#define WARNING_NOOP(str)                                       \
        {                                                       \
            if (!cWarningNoop++)                                \
                DbgPrint("%s(%d): " str,__FILE__,__LINE__);     \
        }
#else
#define WARNING_NOOP(str)
#endif // DBG

/****************************************************************************/

PFNCLTVECTOR ppfnvTexCoord[32] = {
    NULL,
    NULL,
    (PFNCLTVECTOR)glTexCoord1sv,
    NULL,
    (PFNCLTVECTOR)glTexCoord1iv,
    NULL,
    (PFNCLTVECTOR)glTexCoord1fv,
    (PFNCLTVECTOR)glTexCoord1dv,

    NULL,
    NULL,
    (PFNCLTVECTOR)glTexCoord2sv,
    NULL,
    (PFNCLTVECTOR)glTexCoord2iv,
    NULL,
    (PFNCLTVECTOR)glTexCoord2fv,
    (PFNCLTVECTOR)glTexCoord2dv,

    NULL,
    NULL,
    (PFNCLTVECTOR)glTexCoord3sv,
    NULL,
    (PFNCLTVECTOR)glTexCoord3iv,
    NULL,
    (PFNCLTVECTOR)glTexCoord3fv,
    (PFNCLTVECTOR)glTexCoord3dv,

    NULL,
    NULL,
    (PFNCLTVECTOR)glTexCoord4sv,
    NULL,
    (PFNCLTVECTOR)glTexCoord4iv,
    NULL,
    (PFNCLTVECTOR)glTexCoord4fv,
    (PFNCLTVECTOR)glTexCoord4dv,
};

PFNCLTVECTOR ppfnvVertex[32] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    NULL,
    NULL,
    (PFNCLTVECTOR)glVertex2sv,
    NULL,
    (PFNCLTVECTOR)glVertex2iv,
    NULL,
    (PFNCLTVECTOR)glVertex2fv,
    (PFNCLTVECTOR)glVertex2dv,

    NULL,
    NULL,
    (PFNCLTVECTOR)glVertex3sv,
    NULL,
    (PFNCLTVECTOR)glVertex3iv,
    NULL,
    (PFNCLTVECTOR)glVertex3fv,
    (PFNCLTVECTOR)glVertex3dv,

    NULL,
    NULL,
    (PFNCLTVECTOR)glVertex4sv,
    NULL,
    (PFNCLTVECTOR)glVertex4iv,
    NULL,
    (PFNCLTVECTOR)glVertex4fv,
    (PFNCLTVECTOR)glVertex4dv,
};

PFNCLTVECTOR ppfnvIndex[32] = {
    NULL,
    NULL,
    (PFNCLTVECTOR)glIndexsv,
    NULL,
    (PFNCLTVECTOR)glIndexiv,
    NULL,
    (PFNCLTVECTOR)glIndexfv,
    (PFNCLTVECTOR)glIndexdv,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
};

PFNCLTVECTOR ppfnvEdgeFlag[32] = {
    NULL,
    (PFNCLTVECTOR)glEdgeFlagv,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
};

PFNCLTVECTOR ppfnvColor[32] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    (PFNCLTVECTOR)glColor3bv,
    (PFNCLTVECTOR)glColor3ubv,
    (PFNCLTVECTOR)glColor3sv,
    (PFNCLTVECTOR)glColor3usv,
    (PFNCLTVECTOR)glColor3iv,
    (PFNCLTVECTOR)glColor3uiv,
    (PFNCLTVECTOR)glColor3fv,
    (PFNCLTVECTOR)glColor3dv,

    (PFNCLTVECTOR)glColor4bv,
    (PFNCLTVECTOR)glColor4ubv,
    (PFNCLTVECTOR)glColor4sv,
    (PFNCLTVECTOR)glColor4usv,
    (PFNCLTVECTOR)glColor4iv,
    (PFNCLTVECTOR)glColor4uiv,
    (PFNCLTVECTOR)glColor4fv,
    (PFNCLTVECTOR)glColor4dv,
};

PFNCLTVECTOR ppfnvNormal[32] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    (PFNCLTVECTOR)glNormal3bv,
    NULL,
    (PFNCLTVECTOR)glNormal3sv,
    NULL,
    (PFNCLTVECTOR)glNormal3iv,
    NULL,
    (PFNCLTVECTOR)glNormal3fv,
    (PFNCLTVECTOR)glNormal3dv,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
};

/****************************************************************************/

static void cltSetupArrayPointer(
    PCLTARRAYPOINTER pap,
    PFNCLTVECTOR* ppfnVector)
{
    GLint itype;

    switch (pap->type) {
        case GL_BYTE:           itype = 0; break;
        case GL_UNSIGNED_BYTE:  itype = 1; break;
        case GL_SHORT:          itype = 2; break;
        case GL_UNSIGNED_SHORT: itype = 3; break;
        case GL_INT:            itype = 4; break;
        case GL_UNSIGNED_INT:   itype = 5; break;
        case GL_FLOAT:          itype = 6; break;
        case GL_DOUBLE_EXT:     itype = 7; break;
    }

    if (pap->stride != 0) {
        pap->ibytes = pap->stride;
    } else {
        pap->ibytes = __GLTYPESIZE(pap->type) * pap->size;
    }

    pap->pfn = ppfnVector[itype + (pap->size - 1) * 8];
}

/****************************************************************************/

void APIENTRY glsimVertexPointerEXT(
    GLint size,
    GLenum type,
    GLsizei stride,
    GLsizei count,
    const GLvoid* pointer)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glVertexPointerEXT\n");
        return;
    }

    if (size < 2 || size > 4 || stride < 0 || count < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    switch (type) {
        case GL_SHORT:          break;
        case GL_INT:            break;
        case GL_FLOAT:          break;
        case GL_DOUBLE_EXT:     break;
        default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
    }

    plrc->apVertex.size    = size   ;
    plrc->apVertex.type    = type   ;
    plrc->apVertex.stride  = stride ;
    plrc->apVertex.count   = count  ;
    plrc->apVertex.pointer = (GLbyte*)pointer;

    cltSetupArrayPointer(&(plrc->apVertex), ppfnvVertex);
}

void APIENTRY glsimColorPointerEXT(
    GLint size,
    GLenum type,
    GLsizei stride,
    GLsizei count,
    const GLvoid* pointer)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glColorPointerEXT\n");
        return;
    }

    if (size < 3 || size > 4 || stride < 0 || count < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    switch (type) {
        case GL_BYTE:           break;
        case GL_UNSIGNED_BYTE:  break;
        case GL_SHORT:          break;
        case GL_UNSIGNED_SHORT: break;
        case GL_INT:            break;
        case GL_UNSIGNED_INT:   break;
        case GL_FLOAT:          break;
        case GL_DOUBLE_EXT:     break;
        default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
    }

    plrc->apColor.size    = size   ;
    plrc->apColor.type    = type   ;
    plrc->apColor.stride  = stride ;
    plrc->apColor.count   = count  ;
    plrc->apColor.pointer = (GLbyte*)pointer;

    cltSetupArrayPointer(&(plrc->apColor), ppfnvColor);
}

void APIENTRY glsimTexCoordPointerEXT(
    GLint size,
    GLenum type,
    GLsizei stride,
    GLsizei count,
    const GLvoid* pointer)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glTexCoordPointerEXT\n");
        return;
    }

    if (size < 1 || size > 4 || stride < 0 || count < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    switch (type) {
        case GL_SHORT:          break;
        case GL_INT:            break;
        case GL_FLOAT:          break;
        case GL_DOUBLE_EXT:     break;
        default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
    }

    plrc->apTexCoord.size    = size   ;
    plrc->apTexCoord.type    = type   ;
    plrc->apTexCoord.stride  = stride ;
    plrc->apTexCoord.count   = count  ;
    plrc->apTexCoord.pointer = (GLbyte*)pointer;

    cltSetupArrayPointer(&(plrc->apTexCoord), ppfnvTexCoord);
}

void APIENTRY glsimNormalPointerEXT(
    GLenum type,
    GLsizei stride,
    GLsizei count,
    const GLvoid* pointer)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glNormalPointerEXT\n");
        return;
    }

    if (stride < 0 || count < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    switch (type) {
        case GL_BYTE:           break;
        case GL_SHORT:          break;
        case GL_INT:            break;
        case GL_FLOAT:          break;
        case GL_DOUBLE_EXT:     break;
        default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
    }

    plrc->apNormal.size    = 3      ;
    plrc->apNormal.type    = type   ;
    plrc->apNormal.stride  = stride ;
    plrc->apNormal.count   = count  ;
    plrc->apNormal.pointer = (GLbyte*)pointer;

    cltSetupArrayPointer(&(plrc->apNormal), ppfnvNormal);
}

void APIENTRY glsimIndexPointerEXT(
    GLenum type,
    GLsizei stride,
    GLsizei count,
    const GLvoid* pointer)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glIndexPointerEXT\n");
        return;
    }

    if (stride < 0 || count < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    switch (type) {
        case GL_SHORT:          break;
        case GL_INT:            break;
        case GL_FLOAT:          break;
        case GL_DOUBLE_EXT:     break;
        default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
    }

    plrc->apIndex.size    = 1      ;
    plrc->apIndex.type    = type   ;
    plrc->apIndex.stride  = stride ;
    plrc->apIndex.count   = count  ;
    plrc->apIndex.pointer = (GLbyte*)pointer;

    cltSetupArrayPointer(&(plrc->apIndex), ppfnvIndex);
}

void APIENTRY glsimEdgeFlagPointerEXT(
    GLsizei stride,
    GLsizei count,
    const GLboolean* pointer)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glEdgeFlagPointerEXT\n");
        return;
    }

    if (stride < 0 || count < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    } 

    plrc->apEdgeFlag.size    = 1;
    plrc->apEdgeFlag.type    = GL_UNSIGNED_BYTE;
    plrc->apEdgeFlag.stride  = stride ;
    plrc->apEdgeFlag.count   = count  ;
    plrc->apEdgeFlag.pointer = (GLbyte*)pointer;

    cltSetupArrayPointer(&(plrc->apEdgeFlag), ppfnvEdgeFlag);
}

/****************************************************************************/

#define CALLARRAYPOINTER(ap) \
    if ((ap).fEnabled) \
        (((ap).pfn)((ap).pointer + i * (ap).ibytes))

void APIENTRY glsimArrayElementEXT(
    GLint i)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glArrayElementEXT\n");
        return;
    }

    CALLARRAYPOINTER(plrc->apNormal);
    CALLARRAYPOINTER(plrc->apColor);
    CALLARRAYPOINTER(plrc->apIndex);
    CALLARRAYPOINTER(plrc->apTexCoord);
    CALLARRAYPOINTER(plrc->apEdgeFlag);
    CALLARRAYPOINTER(plrc->apVertex);
}

/****************************************************************************/

void APIENTRY glsimArrayElementArrayEXT(
    GLenum mode,
    GLsizei count,
    const GLvoid* pi)
{
    int i;

    switch(mode) {
      case GL_POINTS:
      case GL_LINE_STRIP:
      case GL_LINE_LOOP:
      case GL_LINES:
      case GL_TRIANGLE_STRIP:
      case GL_TRIANGLE_FAN:
      case GL_TRIANGLES:
      case GL_QUAD_STRIP:
      case GL_QUADS:
      case GL_POLYGON:
	break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    if (count < 0) {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }

    glBegin(mode);

    for (i = 0; i < count; i++) {
        glsimArrayElementEXT(((GLint *)pi)[i]);
    }

    glEnd();
}

/****************************************************************************/

void APIENTRY glsimDrawArraysEXT(
    GLenum mode,
    GLint first,
    GLsizei count)
{
    int i;
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glDrawArrayEXT\n");
        return;
    }

    switch(mode) {
      case GL_POINTS:
      case GL_LINE_STRIP:
      case GL_LINE_LOOP:
      case GL_LINES:
      case GL_TRIANGLE_STRIP:
      case GL_TRIANGLE_FAN:
      case GL_TRIANGLES:
      case GL_QUAD_STRIP:
      case GL_QUADS:
      case GL_POLYGON:
	break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    if (count < 0) {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }

    glBegin(mode);

    for (i = 0; i < count; i++) {
        glsimArrayElementEXT(first + i);
    }

    glEnd();
}

/****************************************************************************/

void APIENTRY glsimGetPointervEXT(
    GLenum pname,
    void** params)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glGetPointerEXT\n");
        return;
    }

    switch (pname) {
	case GL_VERTEX_ARRAY_POINTER_EXT:        *params = plrc->apVertex.pointer  ; return;
	case GL_NORMAL_ARRAY_POINTER_EXT:        *params = plrc->apNormal.pointer  ; return;
	case GL_COLOR_ARRAY_POINTER_EXT:         *params = plrc->apColor.pointer   ; return;
	case GL_INDEX_ARRAY_POINTER_EXT:         *params = plrc->apIndex.pointer   ; return;
	case GL_TEXTURE_COORD_ARRAY_POINTER_EXT: *params = plrc->apTexCoord.pointer; return;
	case GL_EDGE_FLAG_ARRAY_POINTER_EXT:     *params = plrc->apEdgeFlag.pointer; return;
        default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
    }
}

/****************************************************************************/

GLubyte* EXTENSIONSTRING = "GL_EXT_vertex_array";

const GLubyte * APIENTRY VArrayGetString( IN GLenum name )
{
    PLRC plrc = GLTEB_CLTCURRENTRC();
    GLubyte *psz;

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glGetString\n");
        return 0;
    }

    psz = (GLubyte*)plrc->pfnGetString(name);

    if (name == GL_EXTENSIONS) {

// The vertex array extension string is already in the generic GetString.
        if (!plrc->dhrc)
	    return psz;

        if (psz == NULL) {
            return EXTENSIONSTRING;
        }

        if (plrc->pszExtensions == NULL) {
            plrc->pszExtensions = (GLubyte*)LOCALALLOC(LPTR, strlen(psz) + strlen(EXTENSIONSTRING) + 2);
            sprintf(plrc->pszExtensions, "%s %s", EXTENSIONSTRING, psz);
        }

        return plrc->pszExtensions;
    }
    return psz;
}

/****************************************************************************/

void APIENTRY VArrayEnable(
    IN GLenum cap)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glEnable\n");
        return;
    }

    switch (cap) {
        case GL_NORMAL_ARRAY_EXT:        plrc->apNormal.fEnabled = TRUE;   return;
        case GL_COLOR_ARRAY_EXT:         plrc->apColor.fEnabled = TRUE;    return;
        case GL_INDEX_ARRAY_EXT:         plrc->apIndex.fEnabled = TRUE;    return;
        case GL_TEXTURE_COORD_ARRAY_EXT: plrc->apTexCoord.fEnabled = TRUE; return;
        case GL_EDGE_FLAG_ARRAY_EXT:     plrc->apEdgeFlag.fEnabled = TRUE; return;
        case GL_VERTEX_ARRAY_EXT:        plrc->apVertex.fEnabled = TRUE;   return;
    }

    plrc->pfnEnable(cap);
}

/****************************************************************************/

void APIENTRY VArrayDisable(
    IN GLenum cap)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glDisable\n");
        return;
    }

    switch (cap) {
        case GL_NORMAL_ARRAY_EXT:        plrc->apNormal.fEnabled = FALSE;   return;
        case GL_COLOR_ARRAY_EXT:         plrc->apColor.fEnabled = FALSE;    return;
        case GL_INDEX_ARRAY_EXT:         plrc->apIndex.fEnabled = FALSE;    return;
        case GL_TEXTURE_COORD_ARRAY_EXT: plrc->apTexCoord.fEnabled = FALSE; return;
        case GL_EDGE_FLAG_ARRAY_EXT:     plrc->apEdgeFlag.fEnabled = FALSE; return;
        case GL_VERTEX_ARRAY_EXT:        plrc->apVertex.fEnabled = FALSE;   return;
    }

    plrc->pfnDisable(cap);
}

/****************************************************************************/

GLboolean APIENTRY VArrayIsEnabled(
    IN GLenum cap)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glIsEnabled\n");
        return 0;
    }

    switch (cap) {
        case GL_NORMAL_ARRAY_EXT:        return plrc->apNormal.fEnabled;
        case GL_COLOR_ARRAY_EXT:         return plrc->apColor.fEnabled;
        case GL_INDEX_ARRAY_EXT:         return plrc->apIndex.fEnabled;
        case GL_TEXTURE_COORD_ARRAY_EXT: return plrc->apTexCoord.fEnabled;
        case GL_EDGE_FLAG_ARRAY_EXT:     return plrc->apEdgeFlag.fEnabled;
        case GL_VERTEX_ARRAY_EXT:        return plrc->apVertex.fEnabled;
    }

    return plrc->pfnIsEnabled(cap);
}

/****************************************************************************/

BOOL VArrayGetIntegerInternal(
    PLRC plrc,
    GLenum cap,
    GLint *pi)
{
    switch (cap) {
        case GL_NORMAL_ARRAY_EXT:               *pi = plrc->apNormal.fEnabled;   return TRUE;
        case GL_COLOR_ARRAY_EXT:                *pi = plrc->apColor.fEnabled;    return TRUE;
        case GL_INDEX_ARRAY_EXT:                *pi = plrc->apIndex.fEnabled;    return TRUE;
        case GL_TEXTURE_COORD_ARRAY_EXT:        *pi = plrc->apTexCoord.fEnabled; return TRUE;
        case GL_EDGE_FLAG_ARRAY_EXT:            *pi = plrc->apEdgeFlag.fEnabled; return TRUE;
        case GL_VERTEX_ARRAY_EXT:               *pi = plrc->apVertex.fEnabled;   return TRUE;

	case GL_VERTEX_ARRAY_SIZE_EXT:          *pi = plrc->apVertex.size  ;     return TRUE;
	case GL_VERTEX_ARRAY_TYPE_EXT:          *pi = plrc->apVertex.type  ;     return TRUE;
	case GL_VERTEX_ARRAY_STRIDE_EXT:        *pi = plrc->apVertex.stride;     return TRUE;
	case GL_VERTEX_ARRAY_COUNT_EXT:         *pi = plrc->apVertex.count ;     return TRUE;

	case GL_NORMAL_ARRAY_TYPE_EXT:          *pi = plrc->apNormal.type  ;     return TRUE;
	case GL_NORMAL_ARRAY_STRIDE_EXT:        *pi = plrc->apNormal.stride;     return TRUE;
	case GL_NORMAL_ARRAY_COUNT_EXT:         *pi = plrc->apNormal.count ;     return TRUE;

	case GL_COLOR_ARRAY_SIZE_EXT:           *pi = plrc->apColor.size  ;      return TRUE;
	case GL_COLOR_ARRAY_TYPE_EXT:           *pi = plrc->apColor.type  ;      return TRUE;
	case GL_COLOR_ARRAY_STRIDE_EXT:         *pi = plrc->apColor.stride;      return TRUE;
	case GL_COLOR_ARRAY_COUNT_EXT:          *pi = plrc->apColor.count ;      return TRUE;

	case GL_INDEX_ARRAY_TYPE_EXT:           *pi = plrc->apIndex.type  ;      return TRUE;
	case GL_INDEX_ARRAY_STRIDE_EXT:         *pi = plrc->apIndex.stride;      return TRUE;
	case GL_INDEX_ARRAY_COUNT_EXT:          *pi = plrc->apIndex.count ;      return TRUE;

	case GL_TEXTURE_COORD_ARRAY_SIZE_EXT:   *pi = plrc->apTexCoord.size  ;   return TRUE;
	case GL_TEXTURE_COORD_ARRAY_TYPE_EXT:   *pi = plrc->apTexCoord.type  ;   return TRUE;
	case GL_TEXTURE_COORD_ARRAY_STRIDE_EXT: *pi = plrc->apTexCoord.stride;   return TRUE;
	case GL_TEXTURE_COORD_ARRAY_COUNT_EXT:  *pi = plrc->apTexCoord.count ;   return TRUE;

	case GL_EDGE_FLAG_ARRAY_STRIDE_EXT:     *pi = plrc->apEdgeFlag.stride;   return TRUE;
	case GL_EDGE_FLAG_ARRAY_COUNT_EXT:      *pi = plrc->apEdgeFlag.count ;   return TRUE;
    }
    return FALSE;
}

/****************************************************************************/

void APIENTRY VArrayGetBooleanv(
    IN GLenum pname,
    OUT GLboolean params[])
{
    PLRC plrc = GLTEB_CLTCURRENTRC();
    GLint glint;

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glGetBooleanv\n");
        return;
    }

    if (VArrayGetIntegerInternal(plrc, pname, &glint)) {
        params[0] = glint ? 1 : 0;
        return;
    }

    plrc->pfnGetBooleanv(pname, params);
}
/****************************************************************************/

void APIENTRY VArrayGetDoublev(
    IN GLenum pname,
    OUT GLdouble params[])
{
    PLRC plrc = GLTEB_CLTCURRENTRC();
    GLint glint;

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glGetDoublev\n");
        return;
    }

    if (VArrayGetIntegerInternal(plrc, pname, &glint)) {
        params[0] = (GLdouble)glint;
        return;
    }

    plrc->pfnGetDoublev(pname, params);
}
/****************************************************************************/

void APIENTRY VArrayGetFloatv(
    IN GLenum pname,
    OUT GLfloat params[])
{
    PLRC plrc = GLTEB_CLTCURRENTRC();
    GLint glint;

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glGetFloatv\n");
        return;
    }

    if (VArrayGetIntegerInternal(plrc, pname, &glint)) {
        params[0] = (GLfloat)glint;
        return;
    }

    plrc->pfnGetFloatv(pname, params);
}
/****************************************************************************/

void APIENTRY VArrayGetIntegerv(
    IN GLenum pname,
    OUT GLint params[])
{
    PLRC plrc = GLTEB_CLTCURRENTRC();
    GLint glint;

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glGetIntegerv\n");
        return;
    }

    if (VArrayGetIntegerInternal(plrc, pname, &glint)) {
        params[0] = glint;
        return;
    }

    plrc->pfnGetIntegerv(pname, params);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\wglcli.c ===
/******************************Module*Header*******************************\
* Module Name: wglcli.c
*
* Routines to support OpenGL client implementation.
*
* Created: 01-17-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef _CLIENTSIDE_

#include <wingdip.h>

#include <glp.h>
#include <glscreen.h>
#include <glgenwin.h>

#include "wgldef.h"

PGLDRIVER pgldrvLoadInstalledDriver(HDC hdc);

// Mirror code from gre\rcobj.cxx
// Need DC and RC validation similar to those of DCOBJ and RCOBJ!!!

HANDLE __wglCreateContext(GLWINDOWID *pgwid, GLSURF *pgsurf)
{
    HANDLE hrcSrv;

    if (hrcSrv = (HANDLE) glsrvCreateContext(pgwid, pgsurf))
    {
        return(hrcSrv);
    }

    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return((HANDLE) 0);
}

BOOL __wglDeleteContext(HANDLE hrcSrv)
{
    wglValidateWindows();
    return(glsrvDeleteContext((PVOID) hrcSrv));
}

BOOL __wglMakeCurrent(GLWINDOWID *pgwid, HANDLE hrcSrv, BOOL bMeta)
{
    BOOL  bRet = FALSE;
    ULONG iError = ERROR_INVALID_HANDLE;    // Default error code
    GLGENwindow *pwnd;

    wglValidateWindows();
    
    if (!hrcSrv)
    {
        glsrvLoseCurrent(GLTEB_SRVCONTEXT());
        return(TRUE);
    }

    pwnd = pwndGetFromID(pgwid);

    // Metafiles are allowed to not have pixel formats and therefore
    // to not have GLGENwindows.  Other types must have a genwin.
    if (pwnd != NULL || bMeta)
    {
        iError = ERROR_NOT_ENOUGH_MEMORY;
        bRet = glsrvMakeCurrent(pgwid, (PVOID) hrcSrv, pwnd);
    }
    else
    {
        WARNING("__wglMakeCurrent: No pixel genwin\n");
        iError = ERROR_INVALID_PIXEL_FORMAT;
    }
        
    if (pwnd != NULL)
    {
        pwndRelease(pwnd);
    }

    if (!bRet)
    {
        SetLastError(iError);
    }

    return(bRet);
}

BOOL __wglShareLists(HANDLE hrcSrvShare, HANDLE hrcSrvSource)
{
    ULONG iError;

    iError = glsrvShareLists((VOID *) hrcSrvShare, (VOID *) hrcSrvSource);

    if (iError == ERROR_SUCCESS)
    {
        return(TRUE);
    }
    else
    {
        SetLastError(iError);
        return(FALSE);
    }
}

BOOL __wglAttention()
{
    return
    (
        glsrvAttention((VOID *) NULL, (VOID *) GLTEB_SRVCONTEXT(),
                       (VOID *) NULL, (VOID *) NULL)
    );
}

int WINAPI __DrvDescribePixelFormat(HDC hdc, int ipfd, UINT cjpfd,
                                    LPPIXELFORMATDESCRIPTOR ppfd)
{
    int iRet = 0;
    PGLDRIVER pglDriver;

    if ((pglDriver = pgldrvLoadInstalledDriver(hdc)) &&
        (pglDriver->dwFlags & GLDRIVER_CLIENT_BUFFER_CALLS))
    {
	ASSERTOPENGL(pglDriver->pfnDrvDescribePixelFormat != NULL,
                     "Missing DrvDescribePixelFormat\n");
	iRet = pglDriver->pfnDrvDescribePixelFormat(hdc, ipfd, cjpfd, ppfd);
    }
#ifndef _WIN95_
    else
    {
        iRet = GdiDescribePixelFormat(hdc, ipfd, cjpfd, ppfd);
    }
#endif
    return iRet;
}

BOOL WINAPI __DrvSetPixelFormat(HDC hdc, int ipfd, PVOID *pwnd)
{
    BOOL bRet = FALSE;
    PGLDRIVER pglDriver;
    
    if ((pglDriver = pgldrvLoadInstalledDriver(hdc)) &&
        (pglDriver->dwFlags & GLDRIVER_CLIENT_BUFFER_CALLS))
    {
	ASSERTOPENGL(pglDriver->pfnDrvSetPixelFormat != NULL,
                     "Missing DrvSetPixelFormat\n");
	bRet = pglDriver->pfnDrvSetPixelFormat(hdc, ipfd);
    }
#ifndef _WIN95_
    else
    {
        bRet = GdiSetPixelFormat(hdc, ipfd);
    }
#endif
    
    if ( bRet && pwnd )
    {
        ((GLGENwindow *) pwnd)->pvDriver = (PVOID) pglDriver;
        ((GLGENwindow *) pwnd)->ulFlags |= GLGENWIN_DRIVERSET;
    }

    return bRet;
}

BOOL WINAPI __DrvSwapBuffers(HDC hdc, BOOL bFinish)
{
    BOOL bRet = FALSE;
    PGLDRIVER pglDriver;

    if ((pglDriver = pgldrvLoadInstalledDriver(hdc)) &&
        (pglDriver->dwFlags & GLDRIVER_CLIENT_BUFFER_CALLS))
    {
	ASSERTOPENGL(pglDriver->pfnDrvSwapBuffers != NULL,
                     "Missing DrvSwapBuffers\n");

        // If the driver has not indicated that it doesn't
        // need glFinish synchronization on swap then call
        // glFinish to sync things.
        if (bFinish && !(pglDriver->dwFlags & GLDRIVER_NO_FINISH_ON_SWAP))
        {
            glFinish();
        }
            
	bRet = pglDriver->pfnDrvSwapBuffers(hdc);
    }
#ifndef _WIN95_
    else
    {
        if (bFinish)
        {
            // In this case we always call glFinish for compatibility
            // with previous version's behavior.
            glFinish();
        }
        
        bRet = GdiSwapBuffers(hdc);
    }
#endif
    return bRet;
}

BOOL __wglCopyContext(HANDLE hrcSrvSrc, HANDLE hrcSrvDest, UINT fuFlags)
{
    return glsrvCopyContext((VOID *) hrcSrvSrc, (VOID *) hrcSrvDest, fuFlags);
}

#endif // _CLIENTSIDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\wglsrv.c ===
/******************************Module*Header*******************************\
* Module Name: wglsrv.c
*
* Routines to support OpenGL client-server implementation on Windows NT.
*
* Created: 01-17-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "wgldef.h"

#ifndef _CLIENTSIDE_

HANDLE __wglCreateContext(HDC hdc, HDC hdcSrvIn, LONG iLayerPlane)
{
    HDC    hdcSrv;
    HANDLE hrcSrv = (HANDLE) 0;

// Get the server-side DC handle.

    if (hdcSrvIn != NULL)
    {
        hdcSrv = hdcSrvIn;
    }
    else
    {
        hdcSrv = GdiConvertDC(hdc);
    }
    
    if (hdcSrv == (HDC) 0)
    {
        WARNING1("__wglCreateContext: unexpected bad hdc: 0x%lx\n", hdc);
        return(hrcSrv);
    }

    BEGINMSG(MSG_WGLCREATECONTEXT,WGLCREATECONTEXT)
        pmsg->hdc = hdcSrv;
        hrcSrv = (HANDLE) CALLSERVER();
    ENDMSG
MSGERROR:
    return(hrcSrv);
}

BOOL __wglDeleteContext(HANDLE hrcSrv)
{
    BOOL bRet = FALSE;

    BEGINMSG(MSG_WGLDELETECONTEXT,WGLDELETECONTEXT)
        pmsg->hrc = (HGLRC) hrcSrv;
        bRet = CALLSERVER();
    ENDMSG
MSGERROR:
    return(bRet);
}

BOOL __wglMakeCurrent(HDC hdc, HANDLE hrcSrv, HDC hdcSrvIn)
{
    HDC  hdcSrv = (HDC) 0;
    BOOL bRet = FALSE;

// Get the server-side DC handle.

    if (hdc)
    {
        if (hdcSrvIn != NULL)
        {
            hdcSrv = hdcSrvIn;
        }
        else
        {
            hdcSrv = GdiConvertDC(hdc);
        }
        
        if (hdcSrv == (HDC) 0)
        {
            WARNING1("__wglMakeCurrent: unexpected bad hdc: 0x%lx\n", hdc);
            return(bRet);
        }
    }

    BEGINMSG(MSG_WGLMAKECURRENT,WGLMAKECURRENT)
        pmsg->hdc = hdcSrv;
        pmsg->hrc = hrcSrv;
        bRet = CALLSERVER();
    ENDMSG
MSGERROR:
    return(bRet);
}

BOOL __wglShareLists(HANDLE hrcSrvShare, HANDLE hrcSrvSource)
{
    BOOL bRet = FALSE;

    BEGINMSG(MSG_WGLSHARELISTS, WGLSHARELISTS)
        pmsg->hrcSource = hrcSrvSource;
        pmsg->hrcShare = hrcSrvShare;
        bRet = CALLSERVER();
    ENDMSG
MSGERROR:
    return(bRet);
}

BOOL __wglAttention()
{
    BOOL bRet = FALSE;

    // reset user's poll count so it counts this as output
    // put it right next to BEGINMSG so that NtCurrentTeb() is optimized

    RESETUSERPOLLCOUNT();

    BEGINMSG(MSG_GLSBATTENTION, GLSBATTENTION)
        bRet = CALLSERVER();
    ENDMSG
MSGERROR:
    return(bRet);
}

BOOL __wglCopyContext(HANDLE hrcSrvSrc, HANDLE hrcSrvDest, UINT fuFlags)
{
    // Server implementation doesn't support this call
    return FALSE;
}

#endif // !_CLIENTSIDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\wgldef.h ===
/******************************Module*Header*******************************\
* Module Name: wgldef.h                                                    *
*                                                                          *
* Local declarations.                                                      *
*                                                                          *
* Created: 01-17-1995                                                      * 
* Author: Hock San Lee [hockl]                                             *
*                                                                          *
* Copyright (c) 1995 Microsoft Corporation                                 *
\**************************************************************************/

HANDLE __wglCreateContext(GLWINDOWID *pgwid, GLSURF *pgsurf);
BOOL   __wglDeleteContext(HANDLE hrcSrv);
BOOL   __wglMakeCurrent(GLWINDOWID *pgwid, HANDLE hrcSrv, BOOL bMeta);
BOOL   __wglShareLists(HANDLE hrcSrvShare, HANDLE hrcSrvSource);
BOOL   __wglAttention();
BOOL   __wglCopyContext(HANDLE hrcSrvSrc, HANDLE hrcSrvDest, UINT fuFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\i386\gliapi.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: glapi.asm
;
; OpenGL API function entries for i386.
;
; Created: 11/16/1993
; Author: Hock San Lee [hockl]
;
; Copyright (c) 1993 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include ks386.inc
        include glapi.inc
        .list

;#ifdef _CLIENTSIDE_
        .data
_DATA   SEGMENT DWORD PUBLIC 'DATA'
        extrn dwTlsOffset:DWORD
_DATA   ENDS
;#endif

; Macro for creating aligned public OpenGL API function
; This is modified from stdcall.inc.
;
; Do an indirect jump through the OpenGL function dispatch table in the TEB.
;
; Here is the previous code before we put the dispatch table in the TEB.
; It still works.
;       ;mov    eax,fs:TbglTable        ; get gl function table
;       ;jmp    DWORD PTR [eax+(offset glDispatchTable)+INDEX_&Func*4]

; NT - This macro must leave the TEB pointer in eax
; Win95 - This macro must leave the GLTEBINFO pointer in edx
MAKEOPENGLAPI   macro Func,N
        align   4
        ifb    <N>
            public      &Func&@0
            &Func&@0:
        else
            public      &Func&@&N
            &Func&@&N:
        endif
        ; Grab TEB pointer
        mov      eax, fs:[PcTeb]

        ; Add offset to reserved TLS storage slot
	mov      edx, eax
        add      edx, dword ptr dwTlsOffset

        ; Get GLTEBINFO pointer
        mov      edx, dword ptr [edx]

        ; Jump via dispatch table in GLTEBINFO
        jmp      dword ptr [edx+(INDEX_&Func*4)]
endm

; NT - This macro must leave the TEB pointer in eax
; Win95 - This macro must leave the GLTEBINFO pointer in edx
FASTOPENGLAPI   macro Func,N
        align   4
        ifb    <N>
            public      &Func&@0
            &Func&@0:
        else
            public      &Func&@&N
            &Func&@&N:
        endif
ifdef _WIN95_
        ; Grab TEB pointer
        mov      eax, fs:[PcTeb]

        ; Add offset to reserved TLS storage slot
	mov      edx, eax
        add      edx, dword ptr dwTlsOffset

        ; Get GLTEBINFO pointer
        mov      edx, dword ptr [edx]

        ; Jump via dispatch table in GLTEBINFO
        jmp      dword ptr [edx+(INDEX_&Func*4)]
else
        mov      eax, fs:[PcTeb]
        jmp      DWORD PTR [eax+TbglDispatchTable+(FASTINDEX_&Func*4)]
endif
endm

        .code
        align   4

; OpenGL API function entries
; The indices below are generated from the .cod file compiled from glapi.c

FASTOPENGLAPI   glCallList,4
FASTOPENGLAPI   glCallLists,12
FASTOPENGLAPI   glBegin,4
FASTOPENGLAPI   glColor3b,12
FASTOPENGLAPI   glColor3bv,4
FASTOPENGLAPI   glColor3d,24
FASTOPENGLAPI   glColor3dv,4
FASTOPENGLAPI   glColor3f,12
FASTOPENGLAPI   glColor3fv,4
FASTOPENGLAPI   glColor3i,12
FASTOPENGLAPI   glColor3iv,4
FASTOPENGLAPI   glColor3s,12
FASTOPENGLAPI   glColor3sv,4
FASTOPENGLAPI   glColor3ub,12
FASTOPENGLAPI   glColor3ubv,4
FASTOPENGLAPI   glColor3ui,12
FASTOPENGLAPI   glColor3uiv,4
FASTOPENGLAPI   glColor3us,12
FASTOPENGLAPI   glColor3usv,4
FASTOPENGLAPI   glColor4b,16
FASTOPENGLAPI   glColor4bv,4
FASTOPENGLAPI   glColor4d,32
FASTOPENGLAPI   glColor4dv,4
FASTOPENGLAPI   glColor4f,16
FASTOPENGLAPI   glColor4fv,4
FASTOPENGLAPI   glColor4i,16
FASTOPENGLAPI   glColor4iv,4
FASTOPENGLAPI   glColor4s,16
FASTOPENGLAPI   glColor4sv,4
FASTOPENGLAPI   glColor4ub,16
FASTOPENGLAPI   glColor4ubv,4
FASTOPENGLAPI   glColor4ui,16
FASTOPENGLAPI   glColor4uiv,4
FASTOPENGLAPI   glColor4us,16
FASTOPENGLAPI   glColor4usv,4
FASTOPENGLAPI   glEdgeFlag,4
FASTOPENGLAPI   glEdgeFlagv,4
FASTOPENGLAPI   glEnd,0
FASTOPENGLAPI   glIndexd,8
FASTOPENGLAPI   glIndexdv,4
FASTOPENGLAPI   glIndexf,4
FASTOPENGLAPI   glIndexfv,4
FASTOPENGLAPI   glIndexi,4
FASTOPENGLAPI   glIndexiv,4
FASTOPENGLAPI   glIndexs,4
FASTOPENGLAPI   glIndexsv,4
FASTOPENGLAPI   glNormal3b,12
FASTOPENGLAPI   glNormal3bv,4
FASTOPENGLAPI   glNormal3d,24
FASTOPENGLAPI   glNormal3dv,4
FASTOPENGLAPI   glNormal3f,12
FASTOPENGLAPI   glNormal3fv,4
FASTOPENGLAPI   glNormal3i,12
FASTOPENGLAPI   glNormal3iv,4
FASTOPENGLAPI   glNormal3s,12
FASTOPENGLAPI   glNormal3sv,4
FASTOPENGLAPI   glTexCoord1d,8
FASTOPENGLAPI   glTexCoord1dv,4
FASTOPENGLAPI   glTexCoord1f,4
FASTOPENGLAPI   glTexCoord1fv,4
FASTOPENGLAPI   glTexCoord1i,4
FASTOPENGLAPI   glTexCoord1iv,4
FASTOPENGLAPI   glTexCoord1s,4
FASTOPENGLAPI   glTexCoord1sv,4
FASTOPENGLAPI   glTexCoord2d,16
FASTOPENGLAPI   glTexCoord2dv,4
FASTOPENGLAPI   glTexCoord2f,8
FASTOPENGLAPI   glTexCoord2fv,4
FASTOPENGLAPI   glTexCoord2i,8
FASTOPENGLAPI   glTexCoord2iv,4
FASTOPENGLAPI   glTexCoord2s,8
FASTOPENGLAPI   glTexCoord2sv,4
FASTOPENGLAPI   glTexCoord3d,24
FASTOPENGLAPI   glTexCoord3dv,4
FASTOPENGLAPI   glTexCoord3f,12
FASTOPENGLAPI   glTexCoord3fv,4
FASTOPENGLAPI   glTexCoord3i,12
FASTOPENGLAPI   glTexCoord3iv,4
FASTOPENGLAPI   glTexCoord3s,12
FASTOPENGLAPI   glTexCoord3sv,4
FASTOPENGLAPI   glTexCoord4d,32
FASTOPENGLAPI   glTexCoord4dv,4
FASTOPENGLAPI   glTexCoord4f,16
FASTOPENGLAPI   glTexCoord4fv,4
FASTOPENGLAPI   glTexCoord4i,16
FASTOPENGLAPI   glTexCoord4iv,4
FASTOPENGLAPI   glTexCoord4s,16
FASTOPENGLAPI   glTexCoord4sv,4
FASTOPENGLAPI   glVertex2d,16
FASTOPENGLAPI   glVertex2dv,4
FASTOPENGLAPI   glVertex2f,8
FASTOPENGLAPI   glVertex2fv,4
FASTOPENGLAPI   glVertex2i,8
FASTOPENGLAPI   glVertex2iv,4
FASTOPENGLAPI   glVertex2s,8
FASTOPENGLAPI   glVertex2sv,4
FASTOPENGLAPI   glVertex3d,24
FASTOPENGLAPI   glVertex3dv,4
FASTOPENGLAPI   glVertex3f,12
FASTOPENGLAPI   glVertex3fv,4
FASTOPENGLAPI   glVertex3i,12
FASTOPENGLAPI   glVertex3iv,4
FASTOPENGLAPI   glVertex3s,12
FASTOPENGLAPI   glVertex3sv,4
FASTOPENGLAPI   glVertex4d,32
FASTOPENGLAPI   glVertex4dv,4
FASTOPENGLAPI   glVertex4f,16
FASTOPENGLAPI   glVertex4fv,4
FASTOPENGLAPI   glVertex4i,16
FASTOPENGLAPI   glVertex4iv,4
FASTOPENGLAPI   glVertex4s,16
FASTOPENGLAPI   glVertex4sv,4
FASTOPENGLAPI   glMaterialf,12
FASTOPENGLAPI   glMaterialfv,12
FASTOPENGLAPI   glMateriali,12
FASTOPENGLAPI   glMaterialiv,12
FASTOPENGLAPI   glDisable,4
FASTOPENGLAPI   glEnable,4
FASTOPENGLAPI   glPopAttrib,0
FASTOPENGLAPI   glPushAttrib,4
FASTOPENGLAPI   glEvalCoord1d,8
FASTOPENGLAPI   glEvalCoord1dv,4
FASTOPENGLAPI   glEvalCoord1f,4
FASTOPENGLAPI   glEvalCoord1fv,4
FASTOPENGLAPI   glEvalCoord2d,16
FASTOPENGLAPI   glEvalCoord2dv,4
FASTOPENGLAPI   glEvalCoord2f,8
FASTOPENGLAPI   glEvalCoord2fv,4
FASTOPENGLAPI   glEvalPoint1,4
FASTOPENGLAPI   glEvalPoint2,8
FASTOPENGLAPI   glLoadIdentity,0
FASTOPENGLAPI   glLoadMatrixf,4
FASTOPENGLAPI   glLoadMatrixd,4
FASTOPENGLAPI   glMatrixMode,4
FASTOPENGLAPI   glMultMatrixf,4
FASTOPENGLAPI   glMultMatrixd,4
FASTOPENGLAPI   glPopMatrix,0
FASTOPENGLAPI   glPushMatrix,0
FASTOPENGLAPI   glRotated,32
FASTOPENGLAPI   glRotatef,16
FASTOPENGLAPI   glScaled,24
FASTOPENGLAPI   glScalef,12
FASTOPENGLAPI   glTranslated,24
FASTOPENGLAPI   glTranslatef,12
FASTOPENGLAPI   glArrayElement,4
FASTOPENGLAPI   glBindTexture,8
FASTOPENGLAPI   glColorPointer,16
FASTOPENGLAPI   glDisableClientState,4
FASTOPENGLAPI   glDrawArrays,12
FASTOPENGLAPI   glDrawElements,16
FASTOPENGLAPI   glEdgeFlagPointer,8
FASTOPENGLAPI   glEnableClientState,4
FASTOPENGLAPI   glIndexPointer,12
FASTOPENGLAPI   glIndexub,4
FASTOPENGLAPI   glIndexubv,4
FASTOPENGLAPI   glInterleavedArrays,12
FASTOPENGLAPI   glNormalPointer,12
FASTOPENGLAPI   glPolygonOffset,8
FASTOPENGLAPI   glTexCoordPointer,16
FASTOPENGLAPI   glVertexPointer,16
FASTOPENGLAPI   glGetPointerv,8
FASTOPENGLAPI   glPopClientAttrib,0
FASTOPENGLAPI   glPushClientAttrib,4
FASTOPENGLAPI   glDrawRangeElementsWIN,24
FASTOPENGLAPI   glColorTableEXT,24
FASTOPENGLAPI   glColorSubTableEXT,24
FASTOPENGLAPI   glCurrentTextureIndexWIN,4
FASTOPENGLAPI   glBindNthTextureWIN,12
FASTOPENGLAPI   glNthTexCombineFuncWIN,28
FASTOPENGLAPI   glMultiTexCoord1fWIN,8
FASTOPENGLAPI   glMultiTexCoord1fvWIN,8
FASTOPENGLAPI   glMultiTexCoord1iWIN,8
FASTOPENGLAPI   glMultiTexCoord1ivWIN,8
FASTOPENGLAPI   glMultiTexCoord2fWIN,12
FASTOPENGLAPI   glMultiTexCoord2fvWIN,8
FASTOPENGLAPI   glMultiTexCoord2iWIN,12
FASTOPENGLAPI   glMultiTexCoord2ivWIN,8

MAKEOPENGLAPI   glClear,4
MAKEOPENGLAPI   glClearAccum,16
MAKEOPENGLAPI   glClearIndex,4
MAKEOPENGLAPI   glClearColor,16
MAKEOPENGLAPI   glClearStencil,4
MAKEOPENGLAPI   glClearDepth,8
MAKEOPENGLAPI   glBitmap,28
MAKEOPENGLAPI   glTexImage1D,32
MAKEOPENGLAPI   glTexImage2D,36
MAKEOPENGLAPI   glCopyPixels,20
MAKEOPENGLAPI   glReadPixels,28
MAKEOPENGLAPI   glDrawPixels,20
MAKEOPENGLAPI   glRectd,32
MAKEOPENGLAPI   glRectdv,8
MAKEOPENGLAPI   glRectf,16
MAKEOPENGLAPI   glRectfv,8
MAKEOPENGLAPI   glRecti,16
MAKEOPENGLAPI   glRectiv,8
MAKEOPENGLAPI   glRects,16
MAKEOPENGLAPI   glRectsv,8
MAKEOPENGLAPI   glNewList,8
MAKEOPENGLAPI   glEndList,0
MAKEOPENGLAPI   glDeleteLists,8
MAKEOPENGLAPI   glGenLists,4
MAKEOPENGLAPI   glListBase,4
MAKEOPENGLAPI   glRasterPos2d,16
MAKEOPENGLAPI   glRasterPos2dv,4
MAKEOPENGLAPI   glRasterPos2f,8
MAKEOPENGLAPI   glRasterPos2fv,4
MAKEOPENGLAPI   glRasterPos2i,8
MAKEOPENGLAPI   glRasterPos2iv,4
MAKEOPENGLAPI   glRasterPos2s,8
MAKEOPENGLAPI   glRasterPos2sv,4
MAKEOPENGLAPI   glRasterPos3d,24
MAKEOPENGLAPI   glRasterPos3dv,4
MAKEOPENGLAPI   glRasterPos3f,12
MAKEOPENGLAPI   glRasterPos3fv,4
MAKEOPENGLAPI   glRasterPos3i,12
MAKEOPENGLAPI   glRasterPos3iv,4
MAKEOPENGLAPI   glRasterPos3s,12
MAKEOPENGLAPI   glRasterPos3sv,4
MAKEOPENGLAPI   glRasterPos4d,32
MAKEOPENGLAPI   glRasterPos4dv,4
MAKEOPENGLAPI   glRasterPos4f,16
MAKEOPENGLAPI   glRasterPos4fv,4
MAKEOPENGLAPI   glRasterPos4i,16
MAKEOPENGLAPI   glRasterPos4iv,4
MAKEOPENGLAPI   glRasterPos4s,16
MAKEOPENGLAPI   glRasterPos4sv,4
MAKEOPENGLAPI   glClipPlane,8
MAKEOPENGLAPI   glColorMaterial,8
MAKEOPENGLAPI   glCullFace,4
MAKEOPENGLAPI   glFogf,8
MAKEOPENGLAPI   glFogfv,8
MAKEOPENGLAPI   glFogi,8
MAKEOPENGLAPI   glFogiv,8
MAKEOPENGLAPI   glFrontFace,4
MAKEOPENGLAPI   glHint,8
MAKEOPENGLAPI   glLightf,12
MAKEOPENGLAPI   glLightfv,12
MAKEOPENGLAPI   glLighti,12
MAKEOPENGLAPI   glLightiv,12
MAKEOPENGLAPI   glLightModelf,8
MAKEOPENGLAPI   glLightModelfv,8
MAKEOPENGLAPI   glLightModeli,8
MAKEOPENGLAPI   glLightModeliv,8
MAKEOPENGLAPI   glLineStipple,8
MAKEOPENGLAPI   glLineWidth,4
MAKEOPENGLAPI   glPointSize,4
MAKEOPENGLAPI   glPolygonMode,8
MAKEOPENGLAPI   glPolygonStipple,4
MAKEOPENGLAPI   glScissor,16
MAKEOPENGLAPI   glFinish,0
MAKEOPENGLAPI   glShadeModel,4
MAKEOPENGLAPI   glTexParameterf,12
MAKEOPENGLAPI   glTexParameterfv,12
MAKEOPENGLAPI   glTexParameteri,12
MAKEOPENGLAPI   glTexParameteriv,12
MAKEOPENGLAPI   glTexEnvf,12
MAKEOPENGLAPI   glTexEnvfv,12
MAKEOPENGLAPI   glTexEnvi,12
MAKEOPENGLAPI   glTexEnviv,12
MAKEOPENGLAPI   glTexGend,16
MAKEOPENGLAPI   glTexGendv,12
MAKEOPENGLAPI   glTexGenf,12
MAKEOPENGLAPI   glTexGenfv,12
MAKEOPENGLAPI   glTexGeni,12
MAKEOPENGLAPI   glTexGeniv,12
MAKEOPENGLAPI   glFeedbackBuffer,12
MAKEOPENGLAPI   glSelectBuffer,8
MAKEOPENGLAPI   glRenderMode,4
MAKEOPENGLAPI   glInitNames,0
MAKEOPENGLAPI   glLoadName,4
MAKEOPENGLAPI   glPassThrough,4
MAKEOPENGLAPI   glPopName,0
MAKEOPENGLAPI   glPushName,4
MAKEOPENGLAPI   glDrawBuffer,4
MAKEOPENGLAPI   glStencilMask,4
MAKEOPENGLAPI   glColorMask,16
MAKEOPENGLAPI   glDepthMask,4
MAKEOPENGLAPI   glIndexMask,4
MAKEOPENGLAPI   glAccum,8
MAKEOPENGLAPI   glFlush,0
MAKEOPENGLAPI   glMap1d,32
MAKEOPENGLAPI   glMap1f,24
MAKEOPENGLAPI   glMap2d,56
MAKEOPENGLAPI   glMap2f,40
MAKEOPENGLAPI   glMapGrid1d,20
MAKEOPENGLAPI   glMapGrid1f,12
MAKEOPENGLAPI   glMapGrid2d,40
MAKEOPENGLAPI   glMapGrid2f,24
MAKEOPENGLAPI   glEvalMesh1,12
MAKEOPENGLAPI   glEvalMesh2,20
MAKEOPENGLAPI   glAlphaFunc,8
MAKEOPENGLAPI   glBlendFunc,8
MAKEOPENGLAPI   glLogicOp,4
MAKEOPENGLAPI   glStencilFunc,12
MAKEOPENGLAPI   glStencilOp,12
MAKEOPENGLAPI   glDepthFunc,4
MAKEOPENGLAPI   glPixelZoom,8
MAKEOPENGLAPI   glPixelTransferf,8
MAKEOPENGLAPI   glPixelTransferi,8
MAKEOPENGLAPI   glPixelStoref,8
MAKEOPENGLAPI   glPixelStorei,8
MAKEOPENGLAPI   glPixelMapfv,12
MAKEOPENGLAPI   glPixelMapuiv,12
MAKEOPENGLAPI   glPixelMapusv,12
MAKEOPENGLAPI   glReadBuffer,4
MAKEOPENGLAPI   glGetBooleanv,8
MAKEOPENGLAPI   glGetClipPlane,8
MAKEOPENGLAPI   glGetDoublev,8
MAKEOPENGLAPI   glGetError,0
MAKEOPENGLAPI   glGetFloatv,8
MAKEOPENGLAPI   glGetIntegerv,8
MAKEOPENGLAPI   glGetLightfv,12
MAKEOPENGLAPI   glGetLightiv,12
MAKEOPENGLAPI   glGetMapdv,12
MAKEOPENGLAPI   glGetMapfv,12
MAKEOPENGLAPI   glGetMapiv,12
MAKEOPENGLAPI   glGetMaterialfv,12
MAKEOPENGLAPI   glGetMaterialiv,12
MAKEOPENGLAPI   glGetPixelMapfv,8
MAKEOPENGLAPI   glGetPixelMapuiv,8
MAKEOPENGLAPI   glGetPixelMapusv,8
MAKEOPENGLAPI   glGetPolygonStipple,4
MAKEOPENGLAPI   glGetString,4
MAKEOPENGLAPI   glGetTexEnvfv,12
MAKEOPENGLAPI   glGetTexEnviv,12
MAKEOPENGLAPI   glGetTexGendv,12
MAKEOPENGLAPI   glGetTexGenfv,12
MAKEOPENGLAPI   glGetTexGeniv,12
MAKEOPENGLAPI   glGetTexImage,20
MAKEOPENGLAPI   glGetTexParameterfv,12
MAKEOPENGLAPI   glGetTexParameteriv,12
MAKEOPENGLAPI   glGetTexLevelParameterfv,16
MAKEOPENGLAPI   glGetTexLevelParameteriv,16
MAKEOPENGLAPI   glIsEnabled,4
MAKEOPENGLAPI   glIsList,4
MAKEOPENGLAPI   glDepthRange,16
MAKEOPENGLAPI   glFrustum,48
MAKEOPENGLAPI   glOrtho,48
MAKEOPENGLAPI   glViewport,16
MAKEOPENGLAPI   glAreTexturesResident,12
MAKEOPENGLAPI   glCopyTexImage1D,28
MAKEOPENGLAPI   glCopyTexImage2D,32
MAKEOPENGLAPI   glCopyTexSubImage1D,24
MAKEOPENGLAPI   glCopyTexSubImage2D,32
MAKEOPENGLAPI   glDeleteTextures,8
MAKEOPENGLAPI   glGenTextures,8
MAKEOPENGLAPI   glIsTexture,4
MAKEOPENGLAPI   glPrioritizeTextures,12
MAKEOPENGLAPI   glTexSubImage1D,28
MAKEOPENGLAPI   glTexSubImage2D,36
MAKEOPENGLAPI   glGetColorTableEXT,16
MAKEOPENGLAPI   glGetColorTableParameterivEXT,12
MAKEOPENGLAPI   glGetColorTableParameterfvEXT,12
MAKEOPENGLAPI   glMultiTexCoord1dWIN,12
MAKEOPENGLAPI   glMultiTexCoord1dvWIN,8
MAKEOPENGLAPI   glMultiTexCoord1sWIN,8
MAKEOPENGLAPI   glMultiTexCoord1svWIN,8
MAKEOPENGLAPI   glMultiTexCoord2dWIN,20
MAKEOPENGLAPI   glMultiTexCoord2dvWIN,8
MAKEOPENGLAPI   glMultiTexCoord2sWIN,12
MAKEOPENGLAPI   glMultiTexCoord2svWIN,8
MAKEOPENGLAPI   glMultiTexCoord3dWIN,28
MAKEOPENGLAPI   glMultiTexCoord3dvWIN,8
MAKEOPENGLAPI   glMultiTexCoord3fWIN,16
MAKEOPENGLAPI   glMultiTexCoord3fvWIN,8
MAKEOPENGLAPI   glMultiTexCoord3iWIN,16
MAKEOPENGLAPI   glMultiTexCoord3ivWIN,8
MAKEOPENGLAPI   glMultiTexCoord3sWIN,16
MAKEOPENGLAPI   glMultiTexCoord3svWIN,8
MAKEOPENGLAPI   glMultiTexCoord4dWIN,36
MAKEOPENGLAPI   glMultiTexCoord4dvWIN,8
MAKEOPENGLAPI   glMultiTexCoord4fWIN,20
MAKEOPENGLAPI   glMultiTexCoord4fvWIN,8
MAKEOPENGLAPI   glMultiTexCoord4iWIN,20
MAKEOPENGLAPI   glMultiTexCoord4ivWIN,8
MAKEOPENGLAPI   glMultiTexCoord4sWIN,20
MAKEOPENGLAPI   glMultiTexCoord4svWIN,8

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\i386\glivtx.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: glivtx.asm
;
; OpenGL vertex API function entries for i386.
;
; Created: 04/16/1996
; Author: Drew Bliss [drewb]
;
; Copyright (c) 1996 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include ks386.inc
        include gli386.inc
	PROFILE = 0
	include profile.inc
        .list

	OPTION PROLOGUE:NONE
	OPTION EPILOGUE:NONE

@PolyArrayFlushPartialPrimitive@0 PROTO SYSCALL
@glcltNormal3f_NotInBegin@16 PROTO SYSCALL
@glcltTexCoord4f_NotInBegin@24 PROTO SYSCALL
@glcltColor4f_InRGBA_NotInBegin@28 PROTO SYSCALL

	IF POLYARRAY_IN_BEGIN GT 255
	.ERR POLYARRAY_IN_BEGIN too large
	ENDIF
	IF POLYARRAY_VERTEX3 GT 255
	.ERR POLYARRAY_VERTEX3 too large
	ENDIF
	IF POLYDATA_VERTEX3 GT 255
	.ERR POLYDATA_VERTEX3 too large
	ENDIF
	IF POLYARRAY_VERTEX2 GT 255
	.ERR POLYARRAY_VERTEX2 too large
	ENDIF
	IF POLYDATA_VERTEX2 GT 255
	.ERR POLYDATA_VERTEX2 too large
	ENDIF
	IF POLYDATA_NORMAL_VALID GT 255
	.ERR POLYDATA_NORMAL_VALID too large
	ENDIF
		
        .data
	
        extrn dwTlsOffset:DWORD
 	
	.code

	; Gets the current POLYARRAY pointer in eax
	; These functions cannot rely on registers being set by
	; the dispatch functions because they are also called directly
	; in the display list code
IFDEF _WIN95_
GET_PATEB MACRO
	mov eax, fs:[PcTeb]
	add eax, DWORD PTR [dwTlsOffset]
	mov eax, [eax]
	add eax, GtiPaTeb
	ENDM
GL_SETUP MACRO
	mov eax, fs:[PcTeb]
	add eax, DWORD PTR [dwTlsOffset]
	mov eax, [eax]
	mov ebx, [eax+GtiSectionInfo]
	add eax, GtiPaTeb
	ENDM
ELSE
GET_PATEB MACRO
	mov eax, fs:[TeglPaTeb]
	ENDM
GL_SETUP MACRO
	mov eax, fs:[TeglPaTeb]
	mov ebx, fs:[TeglSectionInfo]
	ENDM
ENDIF
		
PA_VERTEX_STACK_USAGE	EQU	4

	; Handles two and three-element vertex calls
PA_VERTEX_23 MACRO base, offs, ret_n, pop_ebp, elts, pa_flag, pd_flag
	LOCAL NotInBegin, Flush
	
        GET_PATEB
        push esi
        mov ecx, [eax+PA_flags]
        mov esi, [eax+PA_pdNextVertex]
        test ecx, POLYARRAY_IN_BEGIN
        lea edx, [esi+sizeof_POLYDATA]
        jz NotInBegin
        or ecx, pa_flag
        mov [eax+PA_pdNextVertex], edx
        mov [eax+PA_flags], ecx
        mov ecx, [esi+PD_flags]
        mov [edx+PD_flags], 0
        or ecx, pd_flag
        mov eax, [eax+PA_pdFlush]
        mov [esi+PD_flags], ecx
        cmp esi, eax
        mov edx, [base+offs]
        mov ecx, [base+offs+4]
	IF elts GT 2
        mov eax, [base+offs+8]
	ELSE
	; xor clears flags so don't use it here
	mov eax, 0
	ENDIF
        mov [esi+PD_obj], edx
        mov [esi+PD_obj+4], ecx
        mov [esi+PD_obj+8], eax
        mov DWORD PTR [esi+PD_obj+12], __FLOAT_ONE
        jge Flush
NotInBegin:
        pop esi
        IF pop_ebp
        pop ebp
	ENDIF
        ret ret_n
Flush:
	call @PolyArrayFlushPartialPrimitive@0
	pop esi
        IF pop_ebp
        pop ebp
	ENDIF
	ret ret_n
	ENDM

glcltVertex2f@8 PROC PUBLIC
        PROF_ENTRY
	PA_VERTEX_23 esp, 4+PA_VERTEX_STACK_USAGE, 8, 0, 2, \
	    POLYARRAY_VERTEX2, POLYDATA_VERTEX2
glcltVertex2f@8 ENDP
	
glcltVertex2fv@4 PROC PUBLIC
        PROF_ENTRY
	push ebp
	mov ebp, [esp+8]
	PA_VERTEX_23 ebp, 0, 4, 1, 2, \
	    POLYARRAY_VERTEX2, POLYDATA_VERTEX2
glcltVertex2fv@4 ENDP
	
glcltVertex3f@12 PROC PUBLIC
        PROF_ENTRY
	PA_VERTEX_23 esp, 4+PA_VERTEX_STACK_USAGE, 12, 0, 3, \
	    POLYARRAY_VERTEX3, POLYDATA_VERTEX3
glcltVertex3f@12 ENDP
	
glcltVertex3fv@4 PROC PUBLIC
        PROF_ENTRY
	push ebp
	mov ebp, [esp+8]
	PA_VERTEX_23 ebp, 0, 4, 1, 3, \
	    POLYARRAY_VERTEX3, POLYDATA_VERTEX3
glcltVertex3fv@4 ENDP
	
PA_NORMAL_STACK_USAGE	EQU	4

	; Handles three-element normal calls
PA_NORMAL_3 MACRO base, offs, ret_n, pop_ebp
	LOCAL NotInBegin, Flush
	
        GET_PATEB
        push esi
        mov ecx, [eax+PA_flags]
        mov esi, [eax+PA_pdNextVertex]
        test ecx, POLYARRAY_IN_BEGIN
        mov edx, [base+offs]	
        jz NotInBegin
        mov ecx, [esi+PD_flags]
	mov [eax+PA_pdCurNormal], esi
        or ecx, POLYDATA_NORMAL_VALID
        mov eax, [base+offs+4]
        mov [esi+PD_flags], ecx
        mov ecx, [base+offs+8]
        mov [esi+PD_normal], edx
        mov [esi+PD_normal+4], eax
        mov [esi+PD_normal+8], ecx
        pop esi
        IF pop_ebp
        pop ebp
	ENDIF
        ret ret_n
NotInBegin:
	mov ecx, eax
	lea edx, [base+offs]
	push [edx+8]
	push [edx+4]
	push [edx]
	call @glcltNormal3f_NotInBegin@16
	pop esi
        IF pop_ebp
        pop ebp
	ENDIF
	ret ret_n
	ENDM
	
glcltNormal3f@12 PROC PUBLIC
        PROF_ENTRY
	PA_NORMAL_3 esp, 4+PA_NORMAL_STACK_USAGE, 12, 0
glcltNormal3f@12 ENDP
	
glcltNormal3fv@4 PROC PUBLIC
        PROF_ENTRY
	push ebp
	mov ebp, [esp+8]
	PA_NORMAL_3 ebp, 0, 4, 1
glcltNormal3fv@4 ENDP

PA_TEXTURE_STACK_USAGE	EQU	4

	; Handles two and three-element texture calls
PA_TEXTURE_23 MACRO base, offs, ret_n, pop_ebp, elts, pa_flag, pd_flag
	LOCAL NotInBegin, Flush
	
        GET_PATEB
        push esi
        mov ecx, [eax+PA_flags]
        mov esi, [eax+PA_pdNextVertex]
        test ecx, POLYARRAY_IN_BEGIN
        jz NotInBegin
	or ecx, pa_flag
	mov [eax+PA_pdCurTexture], esi
	mov [eax+PA_flags], ecx
        mov ecx, [esi+PD_flags]
        mov eax, [base+offs]
        or ecx, POLYDATA_TEXTURE_VALID OR pd_flag
        mov edx, [base+offs+4]
        mov [esi+PD_flags], ecx
        mov [esi+PD_texture], eax
	IF elts GT 2
        mov ecx, [base+offs+8]
	ELSE
	xor ecx, ecx
	ENDIF
        mov [esi+PD_texture+4], edx
        mov [esi+PD_texture+8], ecx
	mov DWORD PTR [esi+PD_texture+12], __FLOAT_ONE
        pop esi
        IF pop_ebp
        pop ebp
	ENDIF
        ret ret_n
NotInBegin:
	mov ecx, eax
	lea edx, [base+offs]
	push __FLOAT_ONE
	IF elts GT 2
	push [edx+8]
	ELSE
	push 0
	ENDIF
	push [edx+4]
	push [edx]
	mov edx, pa_flag
	call @glcltTexCoord4f_NotInBegin@24
	pop esi
        IF pop_ebp
        pop ebp
	ENDIF
	ret ret_n
	ENDM
	
glcltTexCoord2f@8 PROC PUBLIC
        PROF_ENTRY
	PA_TEXTURE_23 esp, 4+PA_TEXTURE_STACK_USAGE, 8, 0, 2, \
	    POLYARRAY_TEXTURE2, POLYDATA_DLIST_TEXTURE2
glcltTexCoord2f@8 ENDP
	
glcltTexCoord2fv@4 PROC PUBLIC
        PROF_ENTRY
	push ebp
	mov ebp, [esp+8]
	PA_TEXTURE_23 ebp, 0, 4, 1, 2, \
	    POLYARRAY_TEXTURE2, POLYDATA_DLIST_TEXTURE2
glcltTexCoord2fv@4 ENDP
	
glcltTexCoord3f@12 PROC PUBLIC
        PROF_ENTRY
	PA_TEXTURE_23 esp, 4+PA_TEXTURE_STACK_USAGE, 12, 0, 3, \
	    POLYARRAY_TEXTURE3, POLYDATA_DLIST_TEXTURE3
glcltTexCoord3f@12 ENDP
	
glcltTexCoord3fv@4 PROC PUBLIC
        PROF_ENTRY
	push ebp
	mov ebp, [esp+8]
	PA_TEXTURE_23 ebp, 0, 4, 1, 3, \
	    POLYARRAY_TEXTURE3, POLYDATA_DLIST_TEXTURE3
glcltTexCoord3fv@4 ENDP

if POLYARRAY_CLAMP_COLOR NE 080000000h
.err <Color logic assumes POLYARRAY_CLAMP_COLOR is 080000000h>
endif


PA_COLOR_STACK_USAGE	EQU	12

	; Handles three and four-element color calls
PA_COLOR_34 MACRO base, offs, ret_n, pop_ebp, elts, pd_flag
	LOCAL NotInBegin, Flush
	
	push ebx
        GL_SETUP
        push esi
	push edi

        mov ecx, [eax+PA_flags]
        mov esi, [eax+PA_pdNextVertex]
        test ecx, POLYARRAY_IN_BEGIN
        jz NotInBegin
	IF elts GT 3
		fld DWORD PTR [base+offs+12]		
		fmul DWORD PTR [ebx+GC_alphaVertexScale]
	ENDIF
		fld DWORD PTR [base+offs]
	mov [eax+PA_pdCurColor], esi
		fmul DWORD PTR [ebx+GC_redVertexScale]
        mov ecx, [esi+PD_flags]
		fld DWORD PTR [base+offs+4]		
        or ecx, (POLYDATA_COLOR_VALID or pd_flag)
		fmul DWORD PTR [ebx+GC_greenVertexScale]
        mov [esi+PD_flags], ecx
		fld DWORD PTR [base+offs+8]		
		fmul DWORD PTR [ebx+GC_blueVertexScale] ;; b g r (a)
		fxch ST(2)		 		;; r g b (a)

        fstp    DWORD PTR [esi+PD_colors0+0]
        mov     eax, [ebx+GC_redVertexScale]
        fstp    DWORD PTR [esi+PD_colors0+4]
        mov     edx, [esi+PD_colors0+0]
        fstp    DWORD PTR [esi+PD_colors0+8]
        mov     ecx, [ebx+GC_greenVertexScale]
	IF elts GT 3
        fstp    DWORD PTR [esi+PD_colors0+12]
	ENDIF

        mov     edi, [esi+PD_colors0+4]
        sub     eax, edx
        sub     ecx, edi
        or      eax, edx
        or      ecx, edi
        mov     edx, [ebx+GC_blueVertexScale]
        or      eax, ecx
        mov     edi, [esi+PD_colors0+8]
	mov	ecx, [ebx+GC_paTeb]		;; we no longer have pa, so
        or      eax, edi			;; reload it
        sub     edx, edi
	mov	edi, [ebx+GC_alphaVertexScale]
	or	eax, edx
	IF elts GT 3
        mov	edx, [esi+PD_colors0+12]
	sub	edi, edx
        mov 	edx, [ecx+PA_flags]
	or	eax, edi
	ELSE
	mov	[esi+PD_colors0+12], edi
        mov 	edx, [ecx+PA_flags]
	ENDIF

	pop edi
	and eax, POLYARRAY_CLAMP_COLOR
	pop esi
	or eax, edx
        pop ebx

        IF pop_ebp
        pop ebp
	ENDIF

	mov [ecx+PA_flags], eax

        ret ret_n
NotInBegin:

	;; ecx = gc = ebx
	;; edx = pa = eax

	lea edi, [base+offs]
	mov ecx, ebx
	mov edx, eax

	IF elts GT 3
	push [edi+12]
	ELSE
	push __FLOAT_ONE
	ENDIF
	push [edi+8]
	push [edi+4]
	push [edi+0]
	push DWORD PTR POLYDATA_COLOR_VALID OR pd_flag
	call @glcltColor4f_InRGBA_NotInBegin@28
	pop edi
	pop esi
        pop ebx
        IF pop_ebp
        pop ebp
	ENDIF
	ret ret_n
	ENDM

glcltColor3f_InRGBA@12 PROC PUBLIC
        PROF_ENTRY
	PA_COLOR_34 esp, 4+PA_COLOR_STACK_USAGE, 12, 0, 3, 0
glcltColor3f_InRGBA@12 ENDP
	
glcltColor3fv_InRGBA@4 PROC PUBLIC
        PROF_ENTRY
	push ebp
	mov ebp, [esp+8]
	PA_COLOR_34 ebp, 0, 4, 1, 3, 0
glcltColor3fv_InRGBA@4 ENDP
	
glcltColor4f_InRGBA@16 PROC PUBLIC
        PROF_ENTRY
	PA_COLOR_34 esp, 4+PA_COLOR_STACK_USAGE, 16, 0, 4, \
	    POLYDATA_DLIST_COLOR_4
glcltColor4f_InRGBA@16 ENDP
	
glcltColor4fv_InRGBA@4 PROC PUBLIC
        PROF_ENTRY
	push ebp
	mov ebp, [esp+8]
	PA_COLOR_34 ebp, 0, 4, 1, 4, \
	    POLYDATA_DLIST_COLOR_4
glcltColor4fv_InRGBA@4 ENDP


END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\amd64\glapi.asm ===
title   "OpenGL Functions:
;++
;
; Copyright (c) 2000 Microsoft Corporation
;
; Module Name:
;
;   glapi.asm
;
; Abstract:
;
;   OpenGL API function entries for AMD64.
;
; Author:
;
;   David N. Cutler (davec) 31-Dec-2000
;
; Environment:
;
;    User mode only.
;
;--

include ksamd64.inc
include glapi.inc

        extern  dwTlsOffset:dword

;
; Define macro for creating aligned public OpenGL API function.
;

MAKEOPENGLAPI macro Func

        LEAF_ENTRY Func, _TEXT$00

        mov     eax, dwTlsOffset        ; get TLS slot index
        add     rax, gs:[TeSelf]        ; get address of GLTEBINFO address
        mov     rax, [rax]              ; get GLTEBINFO address
        jmp     qword ptr (INDEX_&Func * 8)[rax] ; dispatch to function

        LEAF_END Func, _TEXT$00

        endm

;
; Define macro to jump through the OpenGL function dispatch table in the TEB.
;

FASTOPENGLAPI macro Func

        LEAF_ENTRY Func, _TEXT$00

        mov     rax, gs:[TeSelf]        ; get TEB address
        jmp     qword ptr TeglDispatchTable+ (FASTINDEX_&Func * 8)[rax] ;

        LEAF_END Func, _TEXT$00

        endm

FASTOPENGLAPI glCallList
FASTOPENGLAPI glCallLists
FASTOPENGLAPI glBegin
FASTOPENGLAPI glColor3b
FASTOPENGLAPI glColor3bv
FASTOPENGLAPI glColor3d
FASTOPENGLAPI glColor3dv
FASTOPENGLAPI glColor3f
FASTOPENGLAPI glColor3fv
FASTOPENGLAPI glColor3i
FASTOPENGLAPI glColor3iv
FASTOPENGLAPI glColor3s
FASTOPENGLAPI glColor3sv
FASTOPENGLAPI glColor3ub
FASTOPENGLAPI glColor3ubv
FASTOPENGLAPI glColor3ui
FASTOPENGLAPI glColor3uiv
FASTOPENGLAPI glColor3us
FASTOPENGLAPI glColor3usv
FASTOPENGLAPI glColor4b
FASTOPENGLAPI glColor4bv
FASTOPENGLAPI glColor4d
FASTOPENGLAPI glColor4dv
FASTOPENGLAPI glColor4f
FASTOPENGLAPI glColor4fv
FASTOPENGLAPI glColor4i
FASTOPENGLAPI glColor4iv
FASTOPENGLAPI glColor4s
FASTOPENGLAPI glColor4sv
FASTOPENGLAPI glColor4ub
FASTOPENGLAPI glColor4ubv
FASTOPENGLAPI glColor4ui
FASTOPENGLAPI glColor4uiv
FASTOPENGLAPI glColor4us
FASTOPENGLAPI glColor4usv
FASTOPENGLAPI glEdgeFlag
FASTOPENGLAPI glEdgeFlagv
FASTOPENGLAPI glEnd
FASTOPENGLAPI glIndexd
FASTOPENGLAPI glIndexdv
FASTOPENGLAPI glIndexf
FASTOPENGLAPI glIndexfv
FASTOPENGLAPI glIndexi
FASTOPENGLAPI glIndexiv
FASTOPENGLAPI glIndexs
FASTOPENGLAPI glIndexsv
FASTOPENGLAPI glNormal3b
FASTOPENGLAPI glNormal3bv
FASTOPENGLAPI glNormal3d
FASTOPENGLAPI glNormal3dv
FASTOPENGLAPI glNormal3f
FASTOPENGLAPI glNormal3fv
FASTOPENGLAPI glNormal3i
FASTOPENGLAPI glNormal3iv
FASTOPENGLAPI glNormal3s
FASTOPENGLAPI glNormal3sv
FASTOPENGLAPI glTexCoord1d
FASTOPENGLAPI glTexCoord1dv
FASTOPENGLAPI glTexCoord1f
FASTOPENGLAPI glTexCoord1fv
FASTOPENGLAPI glTexCoord1i
FASTOPENGLAPI glTexCoord1iv
FASTOPENGLAPI glTexCoord1s
FASTOPENGLAPI glTexCoord1sv
FASTOPENGLAPI glTexCoord2d
FASTOPENGLAPI glTexCoord2dv
FASTOPENGLAPI glTexCoord2f
FASTOPENGLAPI glTexCoord2fv
FASTOPENGLAPI glTexCoord2i
FASTOPENGLAPI glTexCoord2iv
FASTOPENGLAPI glTexCoord2s
FASTOPENGLAPI glTexCoord2sv
FASTOPENGLAPI glTexCoord3d
FASTOPENGLAPI glTexCoord3dv
FASTOPENGLAPI glTexCoord3f
FASTOPENGLAPI glTexCoord3fv
FASTOPENGLAPI glTexCoord3i
FASTOPENGLAPI glTexCoord3iv
FASTOPENGLAPI glTexCoord3s
FASTOPENGLAPI glTexCoord3sv
FASTOPENGLAPI glTexCoord4d
FASTOPENGLAPI glTexCoord4dv
FASTOPENGLAPI glTexCoord4f
FASTOPENGLAPI glTexCoord4fv
FASTOPENGLAPI glTexCoord4i
FASTOPENGLAPI glTexCoord4iv
FASTOPENGLAPI glTexCoord4s
FASTOPENGLAPI glTexCoord4sv
FASTOPENGLAPI glVertex2d
FASTOPENGLAPI glVertex2dv
FASTOPENGLAPI glVertex2f
FASTOPENGLAPI glVertex2fv
FASTOPENGLAPI glVertex2i
FASTOPENGLAPI glVertex2iv
FASTOPENGLAPI glVertex2s
FASTOPENGLAPI glVertex2sv
FASTOPENGLAPI glVertex3d
FASTOPENGLAPI glVertex3dv
FASTOPENGLAPI glVertex3f
FASTOPENGLAPI glVertex3fv
FASTOPENGLAPI glVertex3i
FASTOPENGLAPI glVertex3iv
FASTOPENGLAPI glVertex3s
FASTOPENGLAPI glVertex3sv
FASTOPENGLAPI glVertex4d
FASTOPENGLAPI glVertex4dv
FASTOPENGLAPI glVertex4f
FASTOPENGLAPI glVertex4fv
FASTOPENGLAPI glVertex4i
FASTOPENGLAPI glVertex4iv
FASTOPENGLAPI glVertex4s
FASTOPENGLAPI glVertex4sv
FASTOPENGLAPI glMaterialf
FASTOPENGLAPI glMaterialfv
FASTOPENGLAPI glMateriali
FASTOPENGLAPI glMaterialiv
FASTOPENGLAPI glDisable
FASTOPENGLAPI glEnable
FASTOPENGLAPI glPopAttrib
FASTOPENGLAPI glPushAttrib
FASTOPENGLAPI glEvalCoord1d
FASTOPENGLAPI glEvalCoord1dv
FASTOPENGLAPI glEvalCoord1f
FASTOPENGLAPI glEvalCoord1fv
FASTOPENGLAPI glEvalCoord2d
FASTOPENGLAPI glEvalCoord2dv
FASTOPENGLAPI glEvalCoord2f
FASTOPENGLAPI glEvalCoord2fv
FASTOPENGLAPI glEvalPoint1
FASTOPENGLAPI glEvalPoint2
FASTOPENGLAPI glLoadIdentity
FASTOPENGLAPI glLoadMatrixf
FASTOPENGLAPI glLoadMatrixd
FASTOPENGLAPI glMatrixMode
FASTOPENGLAPI glMultMatrixf
FASTOPENGLAPI glMultMatrixd
FASTOPENGLAPI glPopMatrix
FASTOPENGLAPI glPushMatrix
FASTOPENGLAPI glRotated
FASTOPENGLAPI glRotatef
FASTOPENGLAPI glScaled
FASTOPENGLAPI glScalef
FASTOPENGLAPI glTranslated
FASTOPENGLAPI glTranslatef
FASTOPENGLAPI glArrayElement
FASTOPENGLAPI glBindTexture
FASTOPENGLAPI glColorPointer
FASTOPENGLAPI glDisableClientState
FASTOPENGLAPI glDrawArrays
FASTOPENGLAPI glDrawElements
FASTOPENGLAPI glEdgeFlagPointer
FASTOPENGLAPI glEnableClientState
FASTOPENGLAPI glIndexPointer
FASTOPENGLAPI glIndexub
FASTOPENGLAPI glIndexubv
FASTOPENGLAPI glInterleavedArrays
FASTOPENGLAPI glNormalPointer
FASTOPENGLAPI glPolygonOffset
FASTOPENGLAPI glTexCoordPointer
FASTOPENGLAPI glVertexPointer
FASTOPENGLAPI glGetPointerv
FASTOPENGLAPI glPopClientAttrib
FASTOPENGLAPI glPushClientAttrib
FASTOPENGLAPI glDrawRangeElementsWIN
FASTOPENGLAPI glColorTableEXT
FASTOPENGLAPI glColorSubTableEXT
FASTOPENGLAPI glCurrentTextureIndexWIN	
FASTOPENGLAPI glBindNthTextureWIN	
FASTOPENGLAPI glNthTexCombineFuncWIN	
FASTOPENGLAPI glMultiTexCoord1fWIN	
FASTOPENGLAPI glMultiTexCoord1fvWIN	
FASTOPENGLAPI glMultiTexCoord1iWIN	
FASTOPENGLAPI glMultiTexCoord1ivWIN	
FASTOPENGLAPI glMultiTexCoord2fWIN	
FASTOPENGLAPI glMultiTexCoord2fvWIN	
FASTOPENGLAPI glMultiTexCoord2iWIN	
FASTOPENGLAPI glMultiTexCoord2ivWIN	

MAKEOPENGLAPI glClear	 		
MAKEOPENGLAPI glClearAccum
MAKEOPENGLAPI glClearIndex
MAKEOPENGLAPI glClearColor
MAKEOPENGLAPI glClearStencil
MAKEOPENGLAPI glClearDepth
MAKEOPENGLAPI glBitmap
MAKEOPENGLAPI glTexImage1D
MAKEOPENGLAPI glTexImage2D
MAKEOPENGLAPI glCopyPixels
MAKEOPENGLAPI glReadPixels
MAKEOPENGLAPI glDrawPixels
MAKEOPENGLAPI glRectd
MAKEOPENGLAPI glRectdv
MAKEOPENGLAPI glRectf
MAKEOPENGLAPI glRectfv
MAKEOPENGLAPI glRecti
MAKEOPENGLAPI glRectiv
MAKEOPENGLAPI glRects
MAKEOPENGLAPI glRectsv
MAKEOPENGLAPI glNewList
MAKEOPENGLAPI glEndList
MAKEOPENGLAPI glDeleteLists
MAKEOPENGLAPI glGenLists
MAKEOPENGLAPI glListBase
MAKEOPENGLAPI glRasterPos2d
MAKEOPENGLAPI glRasterPos2dv
MAKEOPENGLAPI glRasterPos2f
MAKEOPENGLAPI glRasterPos2fv
MAKEOPENGLAPI glRasterPos2i
MAKEOPENGLAPI glRasterPos2iv
MAKEOPENGLAPI glRasterPos2s
MAKEOPENGLAPI glRasterPos2sv
MAKEOPENGLAPI glRasterPos3d
MAKEOPENGLAPI glRasterPos3dv
MAKEOPENGLAPI glRasterPos3f
MAKEOPENGLAPI glRasterPos3fv
MAKEOPENGLAPI glRasterPos3i
MAKEOPENGLAPI glRasterPos3iv
MAKEOPENGLAPI glRasterPos3s
MAKEOPENGLAPI glRasterPos3sv
MAKEOPENGLAPI glRasterPos4d
MAKEOPENGLAPI glRasterPos4dv
MAKEOPENGLAPI glRasterPos4f
MAKEOPENGLAPI glRasterPos4fv
MAKEOPENGLAPI glRasterPos4i
MAKEOPENGLAPI glRasterPos4iv
MAKEOPENGLAPI glRasterPos4s
MAKEOPENGLAPI glRasterPos4sv
MAKEOPENGLAPI glClipPlane
MAKEOPENGLAPI glColorMaterial
MAKEOPENGLAPI glCullFace
MAKEOPENGLAPI glFogf
MAKEOPENGLAPI glFogfv
MAKEOPENGLAPI glFogi
MAKEOPENGLAPI glFogiv
MAKEOPENGLAPI glFrontFace
MAKEOPENGLAPI glHint
MAKEOPENGLAPI glLightf
MAKEOPENGLAPI glLightfv
MAKEOPENGLAPI glLighti
MAKEOPENGLAPI glLightiv
MAKEOPENGLAPI glLightModelf
MAKEOPENGLAPI glLightModelfv
MAKEOPENGLAPI glLightModeli
MAKEOPENGLAPI glLightModeliv
MAKEOPENGLAPI glLineStipple
MAKEOPENGLAPI glLineWidth
MAKEOPENGLAPI glPointSize
MAKEOPENGLAPI glPolygonMode
MAKEOPENGLAPI glPolygonStipple
MAKEOPENGLAPI glScissor
MAKEOPENGLAPI glFinish
MAKEOPENGLAPI glShadeModel
MAKEOPENGLAPI glTexParameterf
MAKEOPENGLAPI glTexParameterfv
MAKEOPENGLAPI glTexParameteri
MAKEOPENGLAPI glTexParameteriv
MAKEOPENGLAPI glTexEnvf
MAKEOPENGLAPI glTexEnvfv
MAKEOPENGLAPI glTexEnvi
MAKEOPENGLAPI glTexEnviv
MAKEOPENGLAPI glTexGend
MAKEOPENGLAPI glTexGendv
MAKEOPENGLAPI glTexGenf
MAKEOPENGLAPI glTexGenfv
MAKEOPENGLAPI glTexGeni
MAKEOPENGLAPI glTexGeniv
MAKEOPENGLAPI glFeedbackBuffer
MAKEOPENGLAPI glSelectBuffer
MAKEOPENGLAPI glRenderMode
MAKEOPENGLAPI glInitNames
MAKEOPENGLAPI glLoadName
MAKEOPENGLAPI glPassThrough
MAKEOPENGLAPI glPopName
MAKEOPENGLAPI glPushName
MAKEOPENGLAPI glDrawBuffer
MAKEOPENGLAPI glStencilMask
MAKEOPENGLAPI glColorMask
MAKEOPENGLAPI glDepthMask
MAKEOPENGLAPI glIndexMask
MAKEOPENGLAPI glAccum
MAKEOPENGLAPI glFlush
MAKEOPENGLAPI glMap1d
MAKEOPENGLAPI glMap1f
MAKEOPENGLAPI glMap2d
MAKEOPENGLAPI glMap2f
MAKEOPENGLAPI glMapGrid1d
MAKEOPENGLAPI glMapGrid1f
MAKEOPENGLAPI glMapGrid2d
MAKEOPENGLAPI glMapGrid2f
MAKEOPENGLAPI glEvalMesh1
MAKEOPENGLAPI glEvalMesh2
MAKEOPENGLAPI glAlphaFunc
MAKEOPENGLAPI glBlendFunc
MAKEOPENGLAPI glLogicOp
MAKEOPENGLAPI glStencilFunc
MAKEOPENGLAPI glStencilOp
MAKEOPENGLAPI glDepthFunc
MAKEOPENGLAPI glPixelZoom
MAKEOPENGLAPI glPixelTransferf
MAKEOPENGLAPI glPixelTransferi
MAKEOPENGLAPI glPixelStoref
MAKEOPENGLAPI glPixelStorei
MAKEOPENGLAPI glPixelMapfv
MAKEOPENGLAPI glPixelMapuiv
MAKEOPENGLAPI glPixelMapusv
MAKEOPENGLAPI glReadBuffer
MAKEOPENGLAPI glGetBooleanv
MAKEOPENGLAPI glGetClipPlane
MAKEOPENGLAPI glGetDoublev
MAKEOPENGLAPI glGetError
MAKEOPENGLAPI glGetFloatv
MAKEOPENGLAPI glGetIntegerv
MAKEOPENGLAPI glGetLightfv
MAKEOPENGLAPI glGetLightiv
MAKEOPENGLAPI glGetMapdv
MAKEOPENGLAPI glGetMapfv
MAKEOPENGLAPI glGetMapiv
MAKEOPENGLAPI glGetMaterialfv
MAKEOPENGLAPI glGetMaterialiv
MAKEOPENGLAPI glGetPixelMapfv
MAKEOPENGLAPI glGetPixelMapuiv
MAKEOPENGLAPI glGetPixelMapusv
MAKEOPENGLAPI glGetPolygonStipple
MAKEOPENGLAPI glGetString
MAKEOPENGLAPI glGetTexEnvfv
MAKEOPENGLAPI glGetTexEnviv
MAKEOPENGLAPI glGetTexGendv
MAKEOPENGLAPI glGetTexGenfv
MAKEOPENGLAPI glGetTexGeniv
MAKEOPENGLAPI glGetTexImage
MAKEOPENGLAPI glGetTexParameterfv
MAKEOPENGLAPI glGetTexParameteriv
MAKEOPENGLAPI glGetTexLevelParameterfv
MAKEOPENGLAPI glGetTexLevelParameteriv
MAKEOPENGLAPI glIsEnabled
MAKEOPENGLAPI glIsList
MAKEOPENGLAPI glDepthRange
MAKEOPENGLAPI glFrustum
MAKEOPENGLAPI glOrtho
MAKEOPENGLAPI glViewport
MAKEOPENGLAPI glAreTexturesResident
MAKEOPENGLAPI glCopyTexImage1D
MAKEOPENGLAPI glCopyTexImage2D
MAKEOPENGLAPI glCopyTexSubImage1D
MAKEOPENGLAPI glCopyTexSubImage2D
MAKEOPENGLAPI glDeleteTextures
MAKEOPENGLAPI glGenTextures
MAKEOPENGLAPI glIsTexture
MAKEOPENGLAPI glPrioritizeTextures
MAKEOPENGLAPI glTexSubImage1D
MAKEOPENGLAPI glTexSubImage2D
MAKEOPENGLAPI glGetColorTableEXT
MAKEOPENGLAPI glGetColorTableParameterivEXT
MAKEOPENGLAPI glGetColorTableParameterfvEXT
MAKEOPENGLAPI glMultiTexCoord1dWIN	
MAKEOPENGLAPI glMultiTexCoord1dvWIN	
MAKEOPENGLAPI glMultiTexCoord1sWIN	
MAKEOPENGLAPI glMultiTexCoord1svWIN	
MAKEOPENGLAPI glMultiTexCoord2dWIN	
MAKEOPENGLAPI glMultiTexCoord2dvWIN	
MAKEOPENGLAPI glMultiTexCoord2sWIN	
MAKEOPENGLAPI glMultiTexCoord2svWIN	
MAKEOPENGLAPI glMultiTexCoord3dWIN	
MAKEOPENGLAPI glMultiTexCoord3dvWIN	
MAKEOPENGLAPI glMultiTexCoord3fWIN	
MAKEOPENGLAPI glMultiTexCoord3fvWIN	
MAKEOPENGLAPI glMultiTexCoord3iWIN	
MAKEOPENGLAPI glMultiTexCoord3ivWIN	
MAKEOPENGLAPI glMultiTexCoord3sWIN	
MAKEOPENGLAPI glMultiTexCoord3svWIN	
MAKEOPENGLAPI glMultiTexCoord4dWIN	
MAKEOPENGLAPI glMultiTexCoord4dvWIN	
MAKEOPENGLAPI glMultiTexCoord4fWIN	
MAKEOPENGLAPI glMultiTexCoord4fvWIN	
MAKEOPENGLAPI glMultiTexCoord4iWIN	
MAKEOPENGLAPI glMultiTexCoord4ivWIN	
MAKEOPENGLAPI glMultiTexCoord4sWIN	
MAKEOPENGLAPI glMultiTexCoord4svWIN

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\i386\noopapi.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: noopapi.asm
;
; OpenGL API function entries for i386.
;
; Created: 11/16/1993
; Author: Hock San Lee [hockl]
;
; Copyright (c) 1993 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        .list

; XXX We should create an asm include file for these constants.

GL_INVALID_OPERATION    equ         0502h

; Macro for creating OpenGL API noop function
; This is modified from stdcall.inc.
; The noop functions always return 0 since some functions have return values.
; The only exception is glnoopGetError which returns GL_INVALID_OPERATION.

MAKEOPENGLNOOPAPI       macro Func,nBytes,RetVal
        &Func&@&nBytes:
        if DBG
            cmp     cWarningNoop,0
            jne     @F              ; print debug message once
            push    offset OPENGL_NoCurrentRC
            call    DbgPrint
            add     esp,4
        @@: inc     cWarningNoop
        endif
        ifb    <RetVal>
            xor     eax,eax         ; set return value to 0
        else
            mov     eax,&RetVal     ; set return value
        endif
        ret     &nBytes             ; pop stack
endm

        .data
if DBG
        align   4
        public  cWarningNoop
cWarningNoop        dd     0
        align   4
OPENGL_NoCurrentRC  db     'OPENGL32: No current RC',10,0
endif; DBG

        .code

if DBG
extrn   DbgPrint:proc
endif; DBG

; OpenGL API noop function entries
; The gl indices below are generated from the .cod file compiled from glapi.c
; The wgl indices below are generated from the .cod file compiled from wglcltgs.c

        align   4
MAKEOPENGLNOOPAPI       noop,0
MAKEOPENGLNOOPAPI       noop,4
MAKEOPENGLNOOPAPI       noop,8
MAKEOPENGLNOOPAPI       noop,12
MAKEOPENGLNOOPAPI       noop,16
MAKEOPENGLNOOPAPI       noop,20
MAKEOPENGLNOOPAPI       noop,24
MAKEOPENGLNOOPAPI       noop,28
MAKEOPENGLNOOPAPI       noop,32
MAKEOPENGLNOOPAPI       noop,36
MAKEOPENGLNOOPAPI       noop,40
MAKEOPENGLNOOPAPI       noop,48
MAKEOPENGLNOOPAPI       noop,56
MAKEOPENGLNOOPAPI       noop_GetError,0,GL_INVALID_OPERATION

; Define labels for the noop function table below.

glnoopNewList                   equ     noop@8
glnoopEndList                   equ     noop@0
glnoopCallList                  equ     noop@4
glnoopCallLists                 equ     noop@12
glnoopDeleteLists               equ     noop@8
glnoopGenLists                  equ     noop@4
glnoopListBase                  equ     noop@4
glnoopBegin                     equ     noop@4
glnoopBitmap                    equ     noop@28
glnoopColor3b                   equ     noop@12
glnoopColor3bv                  equ     noop@4
glnoopColor3d                   equ     noop@24
glnoopColor3dv                  equ     noop@4
glnoopColor3f                   equ     noop@12
glnoopColor3fv                  equ     noop@4
glnoopColor3i                   equ     noop@12
glnoopColor3iv                  equ     noop@4
glnoopColor3s                   equ     noop@12
glnoopColor3sv                  equ     noop@4
glnoopColor3ub                  equ     noop@12
glnoopColor3ubv                 equ     noop@4
glnoopColor3ui                  equ     noop@12
glnoopColor3uiv                 equ     noop@4
glnoopColor3us                  equ     noop@12
glnoopColor3usv                 equ     noop@4
glnoopColor4b                   equ     noop@16
glnoopColor4bv                  equ     noop@4
glnoopColor4d                   equ     noop@32
glnoopColor4dv                  equ     noop@4
glnoopColor4f                   equ     noop@16
glnoopColor4fv                  equ     noop@4
glnoopColor4i                   equ     noop@16
glnoopColor4iv                  equ     noop@4
glnoopColor4s                   equ     noop@16
glnoopColor4sv                  equ     noop@4
glnoopColor4ub                  equ     noop@16
glnoopColor4ubv                 equ     noop@4
glnoopColor4ui                  equ     noop@16
glnoopColor4uiv                 equ     noop@4
glnoopColor4us                  equ     noop@16
glnoopColor4usv                 equ     noop@4
glnoopEdgeFlag                  equ     noop@4
glnoopEdgeFlagv                 equ     noop@4
glnoopEnd                       equ     noop@0
glnoopIndexd                    equ     noop@8
glnoopIndexdv                   equ     noop@4
glnoopIndexf                    equ     noop@4
glnoopIndexfv                   equ     noop@4
glnoopIndexi                    equ     noop@4
glnoopIndexiv                   equ     noop@4
glnoopIndexs                    equ     noop@4
glnoopIndexsv                   equ     noop@4
glnoopNormal3b                  equ     noop@12
glnoopNormal3bv                 equ     noop@4
glnoopNormal3d                  equ     noop@24
glnoopNormal3dv                 equ     noop@4
glnoopNormal3f                  equ     noop@12
glnoopNormal3fv                 equ     noop@4
glnoopNormal3i                  equ     noop@12
glnoopNormal3iv                 equ     noop@4
glnoopNormal3s                  equ     noop@12
glnoopNormal3sv                 equ     noop@4
glnoopRasterPos2d               equ     noop@16
glnoopRasterPos2dv              equ     noop@4
glnoopRasterPos2f               equ     noop@8
glnoopRasterPos2fv              equ     noop@4
glnoopRasterPos2i               equ     noop@8
glnoopRasterPos2iv              equ     noop@4
glnoopRasterPos2s               equ     noop@8
glnoopRasterPos2sv              equ     noop@4
glnoopRasterPos3d               equ     noop@24
glnoopRasterPos3dv              equ     noop@4
glnoopRasterPos3f               equ     noop@12
glnoopRasterPos3fv              equ     noop@4
glnoopRasterPos3i               equ     noop@12
glnoopRasterPos3iv              equ     noop@4
glnoopRasterPos3s               equ     noop@12
glnoopRasterPos3sv              equ     noop@4
glnoopRasterPos4d               equ     noop@32
glnoopRasterPos4dv              equ     noop@4
glnoopRasterPos4f               equ     noop@16
glnoopRasterPos4fv              equ     noop@4
glnoopRasterPos4i               equ     noop@16
glnoopRasterPos4iv              equ     noop@4
glnoopRasterPos4s               equ     noop@16
glnoopRasterPos4sv              equ     noop@4
glnoopRectd                     equ     noop@32
glnoopRectdv                    equ     noop@8
glnoopRectf                     equ     noop@16
glnoopRectfv                    equ     noop@8
glnoopRecti                     equ     noop@16
glnoopRectiv                    equ     noop@8
glnoopRects                     equ     noop@16
glnoopRectsv                    equ     noop@8
glnoopTexCoord1d                equ     noop@8
glnoopTexCoord1dv               equ     noop@4
glnoopTexCoord1f                equ     noop@4
glnoopTexCoord1fv               equ     noop@4
glnoopTexCoord1i                equ     noop@4
glnoopTexCoord1iv               equ     noop@4
glnoopTexCoord1s                equ     noop@4
glnoopTexCoord1sv               equ     noop@4
glnoopTexCoord2d                equ     noop@16
glnoopTexCoord2dv               equ     noop@4
glnoopTexCoord2f                equ     noop@8
glnoopTexCoord2fv               equ     noop@4
glnoopTexCoord2i                equ     noop@8
glnoopTexCoord2iv               equ     noop@4
glnoopTexCoord2s                equ     noop@8
glnoopTexCoord2sv               equ     noop@4
glnoopTexCoord3d                equ     noop@24
glnoopTexCoord3dv               equ     noop@4
glnoopTexCoord3f                equ     noop@12
glnoopTexCoord3fv               equ     noop@4
glnoopTexCoord3i                equ     noop@12
glnoopTexCoord3iv               equ     noop@4
glnoopTexCoord3s                equ     noop@12
glnoopTexCoord3sv               equ     noop@4
glnoopTexCoord4d                equ     noop@32
glnoopTexCoord4dv               equ     noop@4
glnoopTexCoord4f                equ     noop@16
glnoopTexCoord4fv               equ     noop@4
glnoopTexCoord4i                equ     noop@16
glnoopTexCoord4iv               equ     noop@4
glnoopTexCoord4s                equ     noop@16
glnoopTexCoord4sv               equ     noop@4
glnoopVertex2d                  equ     noop@16
glnoopVertex2dv                 equ     noop@4
glnoopVertex2f                  equ     noop@8
glnoopVertex2fv                 equ     noop@4
glnoopVertex2i                  equ     noop@8
glnoopVertex2iv                 equ     noop@4
glnoopVertex2s                  equ     noop@8
glnoopVertex2sv                 equ     noop@4
glnoopVertex3d                  equ     noop@24
glnoopVertex3dv                 equ     noop@4
glnoopVertex3f                  equ     noop@12
glnoopVertex3fv                 equ     noop@4
glnoopVertex3i                  equ     noop@12
glnoopVertex3iv                 equ     noop@4
glnoopVertex3s                  equ     noop@12
glnoopVertex3sv                 equ     noop@4
glnoopVertex4d                  equ     noop@32
glnoopVertex4dv                 equ     noop@4
glnoopVertex4f                  equ     noop@16
glnoopVertex4fv                 equ     noop@4
glnoopVertex4i                  equ     noop@16
glnoopVertex4iv                 equ     noop@4
glnoopVertex4s                  equ     noop@16
glnoopVertex4sv                 equ     noop@4
glnoopClipPlane                 equ     noop@8
glnoopColorMaterial             equ     noop@8
glnoopCullFace                  equ     noop@4
glnoopFogf                      equ     noop@8
glnoopFogfv                     equ     noop@8
glnoopFogi                      equ     noop@8
glnoopFogiv                     equ     noop@8
glnoopFrontFace                 equ     noop@4
glnoopHint                      equ     noop@8
glnoopLightf                    equ     noop@12
glnoopLightfv                   equ     noop@12
glnoopLighti                    equ     noop@12
glnoopLightiv                   equ     noop@12
glnoopLightModelf               equ     noop@8
glnoopLightModelfv              equ     noop@8
glnoopLightModeli               equ     noop@8
glnoopLightModeliv              equ     noop@8
glnoopLineStipple               equ     noop@8
glnoopLineWidth                 equ     noop@4
glnoopMaterialf                 equ     noop@12
glnoopMaterialfv                equ     noop@12
glnoopMateriali                 equ     noop@12
glnoopMaterialiv                equ     noop@12
glnoopPointSize                 equ     noop@4
glnoopPolygonMode               equ     noop@8
glnoopPolygonStipple            equ     noop@4
glnoopScissor                   equ     noop@16
glnoopShadeModel                equ     noop@4
glnoopTexParameterf             equ     noop@12
glnoopTexParameterfv            equ     noop@12
glnoopTexParameteri             equ     noop@12
glnoopTexParameteriv            equ     noop@12
glnoopTexImage1D                equ     noop@32
glnoopTexImage2D                equ     noop@36
glnoopTexEnvf                   equ     noop@12
glnoopTexEnvfv                  equ     noop@12
glnoopTexEnvi                   equ     noop@12
glnoopTexEnviv                  equ     noop@12
glnoopTexGend                   equ     noop@16
glnoopTexGendv                  equ     noop@12
glnoopTexGenf                   equ     noop@12
glnoopTexGenfv                  equ     noop@12
glnoopTexGeni                   equ     noop@12
glnoopTexGeniv                  equ     noop@12
glnoopFeedbackBuffer            equ     noop@12
glnoopSelectBuffer              equ     noop@8
glnoopRenderMode                equ     noop@4
glnoopInitNames                 equ     noop@0
glnoopLoadName                  equ     noop@4
glnoopPassThrough               equ     noop@4
glnoopPopName                   equ     noop@0
glnoopPushName                  equ     noop@4
glnoopDrawBuffer                equ     noop@4
glnoopClear                     equ     noop@4
glnoopClearAccum                equ     noop@16
glnoopClearIndex                equ     noop@4
glnoopClearColor                equ     noop@16
glnoopClearStencil              equ     noop@4
glnoopClearDepth                equ     noop@8
glnoopStencilMask               equ     noop@4
glnoopColorMask                 equ     noop@16
glnoopDepthMask                 equ     noop@4
glnoopIndexMask                 equ     noop@4
glnoopAccum                     equ     noop@8
glnoopDisable                   equ     noop@4
glnoopEnable                    equ     noop@4
glnoopFinish                    equ     noop@0
glnoopFlush                     equ     noop@0
glnoopPopAttrib                 equ     noop@0
glnoopPushAttrib                equ     noop@4
glnoopMap1d                     equ     noop@32
glnoopMap1f                     equ     noop@24
glnoopMap2d                     equ     noop@56
glnoopMap2f                     equ     noop@40
glnoopMapGrid1d                 equ     noop@20
glnoopMapGrid1f                 equ     noop@12
glnoopMapGrid2d                 equ     noop@40
glnoopMapGrid2f                 equ     noop@24
glnoopEvalCoord1d               equ     noop@8
glnoopEvalCoord1dv              equ     noop@4
glnoopEvalCoord1f               equ     noop@4
glnoopEvalCoord1fv              equ     noop@4
glnoopEvalCoord2d               equ     noop@16
glnoopEvalCoord2dv              equ     noop@4
glnoopEvalCoord2f               equ     noop@8
glnoopEvalCoord2fv              equ     noop@4
glnoopEvalMesh1                 equ     noop@12
glnoopEvalPoint1                equ     noop@4
glnoopEvalMesh2                 equ     noop@20
glnoopEvalPoint2                equ     noop@8
glnoopAlphaFunc                 equ     noop@8
glnoopBlendFunc                 equ     noop@8
glnoopLogicOp                   equ     noop@4
glnoopStencilFunc               equ     noop@12
glnoopStencilOp                 equ     noop@12
glnoopDepthFunc                 equ     noop@4
glnoopPixelZoom                 equ     noop@8
glnoopPixelTransferf            equ     noop@8
glnoopPixelTransferi            equ     noop@8
glnoopPixelStoref               equ     noop@8
glnoopPixelStorei               equ     noop@8
glnoopPixelMapfv                equ     noop@12
glnoopPixelMapuiv               equ     noop@12
glnoopPixelMapusv               equ     noop@12
glnoopReadBuffer                equ     noop@4
glnoopCopyPixels                equ     noop@20
glnoopReadPixels                equ     noop@28
glnoopDrawPixels                equ     noop@20
glnoopGetBooleanv               equ     noop@8
glnoopGetClipPlane              equ     noop@8
glnoopGetDoublev                equ     noop@8
glnoopGetError                  equ     noop_GetError@0
glnoopGetFloatv                 equ     noop@8
glnoopGetIntegerv               equ     noop@8
glnoopGetLightfv                equ     noop@12
glnoopGetLightiv                equ     noop@12
glnoopGetMapdv                  equ     noop@12
glnoopGetMapfv                  equ     noop@12
glnoopGetMapiv                  equ     noop@12
glnoopGetMaterialfv             equ     noop@12
glnoopGetMaterialiv             equ     noop@12
glnoopGetPixelMapfv             equ     noop@8
glnoopGetPixelMapuiv            equ     noop@8
glnoopGetPixelMapusv            equ     noop@8
glnoopGetPolygonStipple         equ     noop@4
glnoopGetString                 equ     noop@4
glnoopGetTexEnvfv               equ     noop@12
glnoopGetTexEnviv               equ     noop@12
glnoopGetTexGendv               equ     noop@12
glnoopGetTexGenfv               equ     noop@12
glnoopGetTexGeniv               equ     noop@12
glnoopGetTexImage               equ     noop@20
glnoopGetTexParameterfv         equ     noop@12
glnoopGetTexParameteriv         equ     noop@12
glnoopGetTexLevelParameterfv    equ     noop@16
glnoopGetTexLevelParameteriv    equ     noop@16
glnoopIsEnabled                 equ     noop@4
glnoopIsList                    equ     noop@4
glnoopDepthRange                equ     noop@16
glnoopFrustum                   equ     noop@48
glnoopLoadIdentity              equ     noop@0
glnoopLoadMatrixf               equ     noop@4
glnoopLoadMatrixd               equ     noop@4
glnoopMatrixMode                equ     noop@4
glnoopMultMatrixf               equ     noop@4
glnoopMultMatrixd               equ     noop@4
glnoopOrtho                     equ     noop@48
glnoopPopMatrix                 equ     noop@0
glnoopPushMatrix                equ     noop@0
glnoopRotated                   equ     noop@32
glnoopRotatef                   equ     noop@16
glnoopScaled                    equ     noop@24
glnoopScalef                    equ     noop@12
glnoopTranslated                equ     noop@24
glnoopTranslatef                equ     noop@12
glnoopViewport                  equ     noop@16
glnoopArrayElement		equ     noop@4
glnoopBindTexture		equ     noop@8
glnoopColorPointer		equ     noop@16
glnoopDisableClientState	equ     noop@4
glnoopDrawArrays		equ     noop@12
glnoopDrawElements		equ     noop@16
glnoopEdgeFlagPointer		equ     noop@8
glnoopEnableClientState		equ     noop@4
glnoopIndexPointer		equ     noop@12
glnoopIndexub			equ     noop@4
glnoopIndexubv			equ     noop@4
glnoopInterleavedArrays		equ     noop@12
glnoopNormalPointer		equ     noop@12
glnoopPolygonOffset		equ     noop@8
glnoopTexCoordPointer		equ     noop@16
glnoopVertexPointer		equ     noop@16
glnoopAreTexturesResident	equ     noop@12
glnoopCopyTexImage1D		equ     noop@28
glnoopCopyTexImage2D		equ     noop@32
glnoopCopyTexSubImage1D		equ     noop@24
glnoopCopyTexSubImage2D		equ     noop@32
glnoopDeleteTextures		equ     noop@8
glnoopGenTextures		equ     noop@8
glnoopGetPointerv		equ     noop@8
glnoopIsTexture			equ     noop@4
glnoopPrioritizeTextures	equ     noop@12
glnoopTexSubImage1D		equ     noop@28
glnoopTexSubImage2D		equ     noop@36
glnoopPopClientAttrib           equ     noop@0
glnoopPushClientAttrib          equ     noop@4

; OpenGL API noop function table.

        align   4
        public  glNullCltProcTable
glNullCltProcTable  label   dword
        dd      (glNullCltProcTableEnd-glNullCltProcTable-size(dword)) / size(dword)
        dd      glnoopNewList
        dd      glnoopEndList
        dd      glnoopCallList
        dd      glnoopCallLists
        dd      glnoopDeleteLists
        dd      glnoopGenLists
        dd      glnoopListBase
        dd      glnoopBegin
        dd      glnoopBitmap
        dd      glnoopColor3b
        dd      glnoopColor3bv
        dd      glnoopColor3d
        dd      glnoopColor3dv
        dd      glnoopColor3f
        dd      glnoopColor3fv
        dd      glnoopColor3i
        dd      glnoopColor3iv
        dd      glnoopColor3s
        dd      glnoopColor3sv
        dd      glnoopColor3ub
        dd      glnoopColor3ubv
        dd      glnoopColor3ui
        dd      glnoopColor3uiv
        dd      glnoopColor3us
        dd      glnoopColor3usv
        dd      glnoopColor4b
        dd      glnoopColor4bv
        dd      glnoopColor4d
        dd      glnoopColor4dv
        dd      glnoopColor4f
        dd      glnoopColor4fv
        dd      glnoopColor4i
        dd      glnoopColor4iv
        dd      glnoopColor4s
        dd      glnoopColor4sv
        dd      glnoopColor4ub
        dd      glnoopColor4ubv
        dd      glnoopColor4ui
        dd      glnoopColor4uiv
        dd      glnoopColor4us
        dd      glnoopColor4usv
        dd      glnoopEdgeFlag
        dd      glnoopEdgeFlagv
        dd      glnoopEnd
        dd      glnoopIndexd
        dd      glnoopIndexdv
        dd      glnoopIndexf
        dd      glnoopIndexfv
        dd      glnoopIndexi
        dd      glnoopIndexiv
        dd      glnoopIndexs
        dd      glnoopIndexsv
        dd      glnoopNormal3b
        dd      glnoopNormal3bv
        dd      glnoopNormal3d
        dd      glnoopNormal3dv
        dd      glnoopNormal3f
        dd      glnoopNormal3fv
        dd      glnoopNormal3i
        dd      glnoopNormal3iv
        dd      glnoopNormal3s
        dd      glnoopNormal3sv
        dd      glnoopRasterPos2d
        dd      glnoopRasterPos2dv
        dd      glnoopRasterPos2f
        dd      glnoopRasterPos2fv
        dd      glnoopRasterPos2i
        dd      glnoopRasterPos2iv
        dd      glnoopRasterPos2s
        dd      glnoopRasterPos2sv
        dd      glnoopRasterPos3d
        dd      glnoopRasterPos3dv
        dd      glnoopRasterPos3f
        dd      glnoopRasterPos3fv
        dd      glnoopRasterPos3i
        dd      glnoopRasterPos3iv
        dd      glnoopRasterPos3s
        dd      glnoopRasterPos3sv
        dd      glnoopRasterPos4d
        dd      glnoopRasterPos4dv
        dd      glnoopRasterPos4f
        dd      glnoopRasterPos4fv
        dd      glnoopRasterPos4i
        dd      glnoopRasterPos4iv
        dd      glnoopRasterPos4s
        dd      glnoopRasterPos4sv
        dd      glnoopRectd
        dd      glnoopRectdv
        dd      glnoopRectf
        dd      glnoopRectfv
        dd      glnoopRecti
        dd      glnoopRectiv
        dd      glnoopRects
        dd      glnoopRectsv
        dd      glnoopTexCoord1d
        dd      glnoopTexCoord1dv
        dd      glnoopTexCoord1f
        dd      glnoopTexCoord1fv
        dd      glnoopTexCoord1i
        dd      glnoopTexCoord1iv
        dd      glnoopTexCoord1s
        dd      glnoopTexCoord1sv
        dd      glnoopTexCoord2d
        dd      glnoopTexCoord2dv
        dd      glnoopTexCoord2f
        dd      glnoopTexCoord2fv
        dd      glnoopTexCoord2i
        dd      glnoopTexCoord2iv
        dd      glnoopTexCoord2s
        dd      glnoopTexCoord2sv
        dd      glnoopTexCoord3d
        dd      glnoopTexCoord3dv
        dd      glnoopTexCoord3f
        dd      glnoopTexCoord3fv
        dd      glnoopTexCoord3i
        dd      glnoopTexCoord3iv
        dd      glnoopTexCoord3s
        dd      glnoopTexCoord3sv
        dd      glnoopTexCoord4d
        dd      glnoopTexCoord4dv
        dd      glnoopTexCoord4f
        dd      glnoopTexCoord4fv
        dd      glnoopTexCoord4i
        dd      glnoopTexCoord4iv
        dd      glnoopTexCoord4s
        dd      glnoopTexCoord4sv
        dd      glnoopVertex2d
        dd      glnoopVertex2dv
        dd      glnoopVertex2f
        dd      glnoopVertex2fv
        dd      glnoopVertex2i
        dd      glnoopVertex2iv
        dd      glnoopVertex2s
        dd      glnoopVertex2sv
        dd      glnoopVertex3d
        dd      glnoopVertex3dv
        dd      glnoopVertex3f
        dd      glnoopVertex3fv
        dd      glnoopVertex3i
        dd      glnoopVertex3iv
        dd      glnoopVertex3s
        dd      glnoopVertex3sv
        dd      glnoopVertex4d
        dd      glnoopVertex4dv
        dd      glnoopVertex4f
        dd      glnoopVertex4fv
        dd      glnoopVertex4i
        dd      glnoopVertex4iv
        dd      glnoopVertex4s
        dd      glnoopVertex4sv
        dd      glnoopClipPlane
        dd      glnoopColorMaterial
        dd      glnoopCullFace
        dd      glnoopFogf
        dd      glnoopFogfv
        dd      glnoopFogi
        dd      glnoopFogiv
        dd      glnoopFrontFace
        dd      glnoopHint
        dd      glnoopLightf
        dd      glnoopLightfv
        dd      glnoopLighti
        dd      glnoopLightiv
        dd      glnoopLightModelf
        dd      glnoopLightModelfv
        dd      glnoopLightModeli
        dd      glnoopLightModeliv
        dd      glnoopLineStipple
        dd      glnoopLineWidth
        dd      glnoopMaterialf
        dd      glnoopMaterialfv
        dd      glnoopMateriali
        dd      glnoopMaterialiv
        dd      glnoopPointSize
        dd      glnoopPolygonMode
        dd      glnoopPolygonStipple
        dd      glnoopScissor
        dd      glnoopShadeModel
        dd      glnoopTexParameterf
        dd      glnoopTexParameterfv
        dd      glnoopTexParameteri
        dd      glnoopTexParameteriv
        dd      glnoopTexImage1D
        dd      glnoopTexImage2D
        dd      glnoopTexEnvf
        dd      glnoopTexEnvfv
        dd      glnoopTexEnvi
        dd      glnoopTexEnviv
        dd      glnoopTexGend
        dd      glnoopTexGendv
        dd      glnoopTexGenf
        dd      glnoopTexGenfv
        dd      glnoopTexGeni
        dd      glnoopTexGeniv
        dd      glnoopFeedbackBuffer
        dd      glnoopSelectBuffer
        dd      glnoopRenderMode
        dd      glnoopInitNames
        dd      glnoopLoadName
        dd      glnoopPassThrough
        dd      glnoopPopName
        dd      glnoopPushName
        dd      glnoopDrawBuffer
        dd      glnoopClear
        dd      glnoopClearAccum
        dd      glnoopClearIndex
        dd      glnoopClearColor
        dd      glnoopClearStencil
        dd      glnoopClearDepth
        dd      glnoopStencilMask
        dd      glnoopColorMask
        dd      glnoopDepthMask
        dd      glnoopIndexMask
        dd      glnoopAccum
        dd      glnoopDisable
        dd      glnoopEnable
        dd      glnoopFinish
        dd      glnoopFlush
        dd      glnoopPopAttrib
        dd      glnoopPushAttrib
        dd      glnoopMap1d
        dd      glnoopMap1f
        dd      glnoopMap2d
        dd      glnoopMap2f
        dd      glnoopMapGrid1d
        dd      glnoopMapGrid1f
        dd      glnoopMapGrid2d
        dd      glnoopMapGrid2f
        dd      glnoopEvalCoord1d
        dd      glnoopEvalCoord1dv
        dd      glnoopEvalCoord1f
        dd      glnoopEvalCoord1fv
        dd      glnoopEvalCoord2d
        dd      glnoopEvalCoord2dv
        dd      glnoopEvalCoord2f
        dd      glnoopEvalCoord2fv
        dd      glnoopEvalMesh1
        dd      glnoopEvalPoint1
        dd      glnoopEvalMesh2
        dd      glnoopEvalPoint2
        dd      glnoopAlphaFunc
        dd      glnoopBlendFunc
        dd      glnoopLogicOp
        dd      glnoopStencilFunc
        dd      glnoopStencilOp
        dd      glnoopDepthFunc
        dd      glnoopPixelZoom
        dd      glnoopPixelTransferf
        dd      glnoopPixelTransferi
        dd      glnoopPixelStoref
        dd      glnoopPixelStorei
        dd      glnoopPixelMapfv
        dd      glnoopPixelMapuiv
        dd      glnoopPixelMapusv
        dd      glnoopReadBuffer
        dd      glnoopCopyPixels
        dd      glnoopReadPixels
        dd      glnoopDrawPixels
        dd      glnoopGetBooleanv
        dd      glnoopGetClipPlane
        dd      glnoopGetDoublev
        dd      glnoopGetError
        dd      glnoopGetFloatv
        dd      glnoopGetIntegerv
        dd      glnoopGetLightfv
        dd      glnoopGetLightiv
        dd      glnoopGetMapdv
        dd      glnoopGetMapfv
        dd      glnoopGetMapiv
        dd      glnoopGetMaterialfv
        dd      glnoopGetMaterialiv
        dd      glnoopGetPixelMapfv
        dd      glnoopGetPixelMapuiv
        dd      glnoopGetPixelMapusv
        dd      glnoopGetPolygonStipple
        dd      glnoopGetString
        dd      glnoopGetTexEnvfv
        dd      glnoopGetTexEnviv
        dd      glnoopGetTexGendv
        dd      glnoopGetTexGenfv
        dd      glnoopGetTexGeniv
        dd      glnoopGetTexImage
        dd      glnoopGetTexParameterfv
        dd      glnoopGetTexParameteriv
        dd      glnoopGetTexLevelParameterfv
        dd      glnoopGetTexLevelParameteriv
        dd      glnoopIsEnabled
        dd      glnoopIsList
        dd      glnoopDepthRange
        dd      glnoopFrustum
        dd      glnoopLoadIdentity
        dd      glnoopLoadMatrixf
        dd      glnoopLoadMatrixd
        dd      glnoopMatrixMode
        dd      glnoopMultMatrixf
        dd      glnoopMultMatrixd
        dd      glnoopOrtho
        dd      glnoopPopMatrix
        dd      glnoopPushMatrix
        dd      glnoopRotated
        dd      glnoopRotatef
        dd      glnoopScaled
        dd      glnoopScalef
        dd      glnoopTranslated
        dd      glnoopTranslatef
        dd      glnoopViewport
        dd      glnoopArrayElement
        dd      glnoopBindTexture
        dd      glnoopColorPointer
        dd      glnoopDisableClientState
        dd      glnoopDrawArrays
        dd      glnoopDrawElements
        dd      glnoopEdgeFlagPointer
        dd      glnoopEnableClientState
        dd      glnoopIndexPointer
        dd      glnoopIndexub
        dd      glnoopIndexubv
        dd      glnoopInterleavedArrays
        dd      glnoopNormalPointer
        dd      glnoopPolygonOffset
        dd      glnoopTexCoordPointer
        dd      glnoopVertexPointer
        dd      glnoopAreTexturesResident
        dd      glnoopCopyTexImage1D
        dd      glnoopCopyTexImage2D
        dd      glnoopCopyTexSubImage1D
        dd      glnoopCopyTexSubImage2D
        dd      glnoopDeleteTextures
        dd      glnoopGenTextures
        dd      glnoopGetPointerv
        dd      glnoopIsTexture
        dd      glnoopPrioritizeTextures
        dd      glnoopTexSubImage1D
        dd      glnoopTexSubImage2D
        dd      glnoopPopClientAttrib
        dd      glnoopPushClientAttrib
glNullCltProcTableEnd    equ    $

glnoopDrawRangeElementsWIN	equ	noop@24
glnoopColorTableEXT		equ	noop@24
glnoopColorSubTableEXT		equ	noop@24
glnoopGetColorTableEXT		equ	noop@16
glnoopGetColorTableParameterivEXT equ	noop@12
glnoopGetColorTableParameterfvEXT equ	noop@12
glnoopCurrentTextureIndexWIN	equ	noop@4
glnoopMultiTexCoord1dWIN	equ	noop@12
glnoopMultiTexCoord1dvWIN	equ	noop@8
glnoopMultiTexCoord1fWIN	equ	noop@8
glnoopMultiTexCoord1fvWIN	equ	noop@8
glnoopMultiTexCoord1iWIN	equ	noop@8
glnoopMultiTexCoord1ivWIN	equ	noop@8
glnoopMultiTexCoord1sWIN	equ	noop@8
glnoopMultiTexCoord1svWIN	equ	noop@8
glnoopMultiTexCoord2dWIN	equ	noop@20
glnoopMultiTexCoord2dvWIN	equ	noop@8
glnoopMultiTexCoord2fWIN	equ	noop@12
glnoopMultiTexCoord2fvWIN	equ	noop@8
glnoopMultiTexCoord2iWIN	equ	noop@12
glnoopMultiTexCoord2ivWIN	equ	noop@8
glnoopMultiTexCoord2sWIN	equ	noop@12
glnoopMultiTexCoord2svWIN	equ	noop@8
glnoopMultiTexCoord3dWIN	equ	noop@28
glnoopMultiTexCoord3dvWIN	equ	noop@8
glnoopMultiTexCoord3fWIN	equ	noop@16
glnoopMultiTexCoord3fvWIN	equ	noop@8
glnoopMultiTexCoord3iWIN	equ	noop@16
glnoopMultiTexCoord3ivWIN	equ	noop@8
glnoopMultiTexCoord3sWIN	equ	noop@16
glnoopMultiTexCoord3svWIN	equ	noop@8
glnoopMultiTexCoord4dWIN	equ	noop@36
glnoopMultiTexCoord4dvWIN	equ	noop@8
glnoopMultiTexCoord4fWIN	equ	noop@20
glnoopMultiTexCoord4fvWIN	equ	noop@8
glnoopMultiTexCoord4iWIN	equ	noop@20
glnoopMultiTexCoord4ivWIN	equ	noop@8
glnoopMultiTexCoord4sWIN	equ	noop@20
glnoopMultiTexCoord4svWIN	equ	noop@8
glnoopBindNthTextureWIN		equ	noop@12
glnoopNthTexCombineFuncWIN	equ	noop@28
	
; OpenGL EXT API noop function table.

        align   4
        public  glNullExtProcTable
glNullExtProcTable  label   dword
        dd      (glNullExtProcTableEnd-glNullExtProcTable-size(dword)) / size(dword)
        dd glnoopDrawRangeElementsWIN
        dd glnoopColorTableEXT
        dd glnoopColorSubTableEXT
        dd glnoopGetColorTableEXT
        dd glnoopGetColorTableParameterivEXT
        dd glnoopGetColorTableParameterfvEXT
IFDEF GL_WIN_multiple_textures
        dd glnoopCurrentTextureIndexWIN
        dd glnoopMultiTexCoord1dWIN
        dd glnoopMultiTexCoord1dvWIN
        dd glnoopMultiTexCoord1fWIN
        dd glnoopMultiTexCoord1fvWIN
        dd glnoopMultiTexCoord1iWIN
        dd glnoopMultiTexCoord1ivWIN
        dd glnoopMultiTexCoord1sWIN
        dd glnoopMultiTexCoord1svWIN
        dd glnoopMultiTexCoord2dWIN
        dd glnoopMultiTexCoord2dvWIN
        dd glnoopMultiTexCoord2fWIN
        dd glnoopMultiTexCoord2fvWIN
        dd glnoopMultiTexCoord2iWIN
        dd glnoopMultiTexCoord2ivWIN
        dd glnoopMultiTexCoord2sWIN
        dd glnoopMultiTexCoord2svWIN
        dd glnoopMultiTexCoord3dWIN
	dd glnoopMultiTexCoord3dvWIN
	dd glnoopMultiTexCoord3fWIN
        dd glnoopMultiTexCoord3fvWIN
        dd glnoopMultiTexCoord3iWIN
        dd glnoopMultiTexCoord3ivWIN
        dd glnoopMultiTexCoord3sWIN
        dd glnoopMultiTexCoord3svWIN
        dd glnoopMultiTexCoord4dWIN
        dd glnoopMultiTexCoord4dvWIN
        dd glnoopMultiTexCoord4fWIN
        dd glnoopMultiTexCoord4fvWIN
        dd glnoopMultiTexCoord4iWIN
        dd glnoopMultiTexCoord4ivWIN
        dd glnoopMultiTexCoord4sWIN
        dd glnoopMultiTexCoord4svWIN
        dd glnoopBindNthTextureWIN
        dd glnoopNthTexCombineFuncWIN
ENDIF
glNullExtProcTableEnd    equ    $
	
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\i386\profile.inc ===
IFNDEF __PROFILE_INC__
__PROFILE_INC EQU 1

IF PROFILE
EXTRN _penter:NEAR
	
PROF_ENTRY MACRO
	call _penter
	ENDM
ELSE
PROF_ENTRY MACRO
	ENDM
ENDIF
	
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\client\ia64\gleapi.s ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

//++
//
// Module Name:
//
//    glpapi.s
//
// Abstract:
//
//    OpenGL API function entries for IA64
//
// Author:
//
//
// Environment:
//
//    User mode only.
//
// Revision History:
//
//
//--

#include "ksia64.h"
#include "dispindx.h"

         .global  dwTlsOffset

// Macro for creating aligned public OpenGL API function
// Do an indirect jump through the OpenGL function dispatch table.
// This macro must leave the TEB in v0.

#define MAKEOPENGLAPI(Func)                                     \
    LEAF_ENTRY( Func );                                         \
    add         t3 = @gprel(dwTlsOffset), gp;                   \
    ;;                                                          \
    ld4         t2 = [t3];                                      \
    mov         v0 = teb;                                       \
    ;;                                                          \
    add         t0 = t2, v0;                                    \
    ;;                                                          \
    ld8         t6 = [t0];                                      \
    ;;                                                          \
    add         t1 = INDEX_##Func*SizeofPointer, t6;            \
    ;;                                                          \
    ld8         t4 = [t1];                                      \
    ;;                                                          \
    ld8         t5 = [t4], 8;                                   \
    ;;                                                          \
    ld8         gp = [t4];                                      \
    mov         b6 = t5;                                        \
    br##.##sptk b6;                                             \
    LEAF_EXIT( Func)


// Macro for creating aligned public OpenGL API function
// Do an indirect jump through the OpenGL function dispatch table in the TEB.


#define FASTOPENGLAPI(Func)                                     \
    LEAF_ENTRY( Func );                                         \
    add         t0 = TeglDispatchTable+(FASTINDEX_##Func*SizeofPointer), teb;   \
    ;;                                                          \
    ld8         t1 = [t0];                                      \
    ;;                                                          \
    ld8         t2 = [t1], 8;                                   \
    ;;                                                          \
    ld8         gp = [t1];                                      \
    mov         b6 = t2;                                        \
    br##.##sptk b6;                                             \
    LEAF_EXIT( Func)


FASTOPENGLAPI( glCallList                )
FASTOPENGLAPI( glCallLists               )
FASTOPENGLAPI( glBegin                   )
FASTOPENGLAPI( glColor3b                 )
FASTOPENGLAPI( glColor3bv                )
FASTOPENGLAPI( glColor3d                 )
FASTOPENGLAPI( glColor3dv                )
FASTOPENGLAPI( glColor3f                 )
FASTOPENGLAPI( glColor3fv                )
FASTOPENGLAPI( glColor3i                 )
FASTOPENGLAPI( glColor3iv                )
FASTOPENGLAPI( glColor3s                 )
FASTOPENGLAPI( glColor3sv                )
FASTOPENGLAPI( glColor3ub                )
FASTOPENGLAPI( glColor3ubv               )
FASTOPENGLAPI( glColor3ui                )
FASTOPENGLAPI( glColor3uiv               )
FASTOPENGLAPI( glColor3us                )
FASTOPENGLAPI( glColor3usv               )
FASTOPENGLAPI( glColor4b                 )
FASTOPENGLAPI( glColor4bv                )
FASTOPENGLAPI( glColor4d                 )
FASTOPENGLAPI( glColor4dv                )
FASTOPENGLAPI( glColor4f                 )
FASTOPENGLAPI( glColor4fv                )
FASTOPENGLAPI( glColor4i                 )
FASTOPENGLAPI( glColor4iv                )
FASTOPENGLAPI( glColor4s                 )
FASTOPENGLAPI( glColor4sv                )
FASTOPENGLAPI( glColor4ub                )
FASTOPENGLAPI( glColor4ubv               )
FASTOPENGLAPI( glColor4ui                )
FASTOPENGLAPI( glColor4uiv               )
FASTOPENGLAPI( glColor4us                )
FASTOPENGLAPI( glColor4usv               )
FASTOPENGLAPI( glEdgeFlag                )
FASTOPENGLAPI( glEdgeFlagv               )
FASTOPENGLAPI( glEnd                     )
FASTOPENGLAPI( glIndexd                  )
FASTOPENGLAPI( glIndexdv                 )
FASTOPENGLAPI( glIndexf                  )
FASTOPENGLAPI( glIndexfv                 )
FASTOPENGLAPI( glIndexi                  )
FASTOPENGLAPI( glIndexiv                 )
FASTOPENGLAPI( glIndexs                  )
FASTOPENGLAPI( glIndexsv                 )
FASTOPENGLAPI( glNormal3b                )
FASTOPENGLAPI( glNormal3bv               )
FASTOPENGLAPI( glNormal3d                )
FASTOPENGLAPI( glNormal3dv               )
FASTOPENGLAPI( glNormal3f                )
FASTOPENGLAPI( glNormal3fv               )
FASTOPENGLAPI( glNormal3i                )
FASTOPENGLAPI( glNormal3iv               )
FASTOPENGLAPI( glNormal3s                )
FASTOPENGLAPI( glNormal3sv               )
FASTOPENGLAPI( glTexCoord1d              )
FASTOPENGLAPI( glTexCoord1dv             )
FASTOPENGLAPI( glTexCoord1f              )
FASTOPENGLAPI( glTexCoord1fv             )
FASTOPENGLAPI( glTexCoord1i              )
FASTOPENGLAPI( glTexCoord1iv             )
FASTOPENGLAPI( glTexCoord1s              )
FASTOPENGLAPI( glTexCoord1sv             )
FASTOPENGLAPI( glTexCoord2d              )
FASTOPENGLAPI( glTexCoord2dv             )
FASTOPENGLAPI( glTexCoord2f              )
FASTOPENGLAPI( glTexCoord2fv             )
FASTOPENGLAPI( glTexCoord2i              )
FASTOPENGLAPI( glTexCoord2iv             )
FASTOPENGLAPI( glTexCoord2s              )
FASTOPENGLAPI( glTexCoord2sv             )
FASTOPENGLAPI( glTexCoord3d              )
FASTOPENGLAPI( glTexCoord3dv             )
FASTOPENGLAPI( glTexCoord3f              )
FASTOPENGLAPI( glTexCoord3fv             )
FASTOPENGLAPI( glTexCoord3i              )
FASTOPENGLAPI( glTexCoord3iv             )
FASTOPENGLAPI( glTexCoord3s              )
FASTOPENGLAPI( glTexCoord3sv             )
FASTOPENGLAPI( glTexCoord4d              )
FASTOPENGLAPI( glTexCoord4dv             )
FASTOPENGLAPI( glTexCoord4f              )
FASTOPENGLAPI( glTexCoord4fv             )
FASTOPENGLAPI( glTexCoord4i              )
FASTOPENGLAPI( glTexCoord4iv             )
FASTOPENGLAPI( glTexCoord4s              )
FASTOPENGLAPI( glTexCoord4sv             )
FASTOPENGLAPI( glVertex2d                )
FASTOPENGLAPI( glVertex2dv               )
FASTOPENGLAPI( glVertex2f                )
FASTOPENGLAPI( glVertex2fv               )
FASTOPENGLAPI( glVertex2i                )
FASTOPENGLAPI( glVertex2iv               )
FASTOPENGLAPI( glVertex2s                )
FASTOPENGLAPI( glVertex2sv               )
FASTOPENGLAPI( glVertex3d                )
FASTOPENGLAPI( glVertex3dv               )
FASTOPENGLAPI( glVertex3f                )
FASTOPENGLAPI( glVertex3fv               )
FASTOPENGLAPI( glVertex3i                )
FASTOPENGLAPI( glVertex3iv               )
FASTOPENGLAPI( glVertex3s                )
FASTOPENGLAPI( glVertex3sv               )
FASTOPENGLAPI( glVertex4d                )
FASTOPENGLAPI( glVertex4dv               )
FASTOPENGLAPI( glVertex4f                )
FASTOPENGLAPI( glVertex4fv               )
FASTOPENGLAPI( glVertex4i                )
FASTOPENGLAPI( glVertex4iv               )
FASTOPENGLAPI( glVertex4s                )
FASTOPENGLAPI( glVertex4sv               )
FASTOPENGLAPI( glMaterialf               )
FASTOPENGLAPI( glMaterialfv              )
FASTOPENGLAPI( glMateriali               )
FASTOPENGLAPI( glMaterialiv              )
FASTOPENGLAPI( glDisable                 )
FASTOPENGLAPI( glEnable                  )
FASTOPENGLAPI( glPopAttrib               )
FASTOPENGLAPI( glPushAttrib              )
FASTOPENGLAPI( glEvalCoord1d             )
FASTOPENGLAPI( glEvalCoord1dv            )
FASTOPENGLAPI( glEvalCoord1f             )
FASTOPENGLAPI( glEvalCoord1fv            )
FASTOPENGLAPI( glEvalCoord2d             )
FASTOPENGLAPI( glEvalCoord2dv            )
FASTOPENGLAPI( glEvalCoord2f             )
FASTOPENGLAPI( glEvalCoord2fv            )
FASTOPENGLAPI( glEvalPoint1              )
FASTOPENGLAPI( glEvalPoint2              )
FASTOPENGLAPI( glLoadIdentity            )
FASTOPENGLAPI( glLoadMatrixf             )
FASTOPENGLAPI( glLoadMatrixd             )
FASTOPENGLAPI( glMatrixMode              )
FASTOPENGLAPI( glMultMatrixf             )
FASTOPENGLAPI( glMultMatrixd             )
FASTOPENGLAPI( glPopMatrix               )
FASTOPENGLAPI( glPushMatrix              )
FASTOPENGLAPI( glRotated                 )
FASTOPENGLAPI( glRotatef                 )
FASTOPENGLAPI( glScaled                  )
FASTOPENGLAPI( glScalef                  )
FASTOPENGLAPI( glTranslated              )
FASTOPENGLAPI( glTranslatef              )
FASTOPENGLAPI( glArrayElement            )
FASTOPENGLAPI( glBindTexture             )
FASTOPENGLAPI( glColorPointer            )
FASTOPENGLAPI( glDisableClientState      )
FASTOPENGLAPI( glDrawArrays              )
FASTOPENGLAPI( glDrawElements            )
FASTOPENGLAPI( glEdgeFlagPointer         )
FASTOPENGLAPI( glEnableClientState       )
FASTOPENGLAPI( glIndexPointer            )
FASTOPENGLAPI( glIndexub                 )
FASTOPENGLAPI( glIndexubv                )
FASTOPENGLAPI( glInterleavedArrays       )
FASTOPENGLAPI( glNormalPointer           )
FASTOPENGLAPI( glPolygonOffset           )
FASTOPENGLAPI( glTexCoordPointer         )
FASTOPENGLAPI( glVertexPointer           )
FASTOPENGLAPI( glGetPointerv             )
FASTOPENGLAPI( glPopClientAttrib         )
FASTOPENGLAPI( glPushClientAttrib        )
FASTOPENGLAPI( glDrawRangeElementsWIN    )
FASTOPENGLAPI( glColorTableEXT           )
FASTOPENGLAPI( glColorSubTableEXT        )

MAKEOPENGLAPI( glClear	 		 )
MAKEOPENGLAPI( glClearAccum              )
MAKEOPENGLAPI( glClearIndex              )
MAKEOPENGLAPI( glClearColor              )
MAKEOPENGLAPI( glClearStencil            )
MAKEOPENGLAPI( glClearDepth              )
MAKEOPENGLAPI( glBitmap                  )
MAKEOPENGLAPI( glTexImage1D              )
MAKEOPENGLAPI( glTexImage2D              )
MAKEOPENGLAPI( glCopyPixels              )
MAKEOPENGLAPI( glReadPixels              )
MAKEOPENGLAPI( glDrawPixels              )
MAKEOPENGLAPI( glRectd                   )
MAKEOPENGLAPI( glRectdv                  )
MAKEOPENGLAPI( glRectf                   )
MAKEOPENGLAPI( glRectfv                  )
MAKEOPENGLAPI( glRecti                   )
MAKEOPENGLAPI( glRectiv                  )
MAKEOPENGLAPI( glRects                   )
MAKEOPENGLAPI( glRectsv                  )
MAKEOPENGLAPI( glNewList                 )
MAKEOPENGLAPI( glEndList                 )
MAKEOPENGLAPI( glDeleteLists             )
MAKEOPENGLAPI( glGenLists                )
MAKEOPENGLAPI( glListBase                )
MAKEOPENGLAPI( glRasterPos2d             )
MAKEOPENGLAPI( glRasterPos2dv            )
MAKEOPENGLAPI( glRasterPos2f             )
MAKEOPENGLAPI( glRasterPos2fv            )
MAKEOPENGLAPI( glRasterPos2i             )
MAKEOPENGLAPI( glRasterPos2iv            )
MAKEOPENGLAPI( glRasterPos2s             )
MAKEOPENGLAPI( glRasterPos2sv            )
MAKEOPENGLAPI( glRasterPos3d             )
MAKEOPENGLAPI( glRasterPos3dv            )
MAKEOPENGLAPI( glRasterPos3f             )
MAKEOPENGLAPI( glRasterPos3fv            )
MAKEOPENGLAPI( glRasterPos3i             )
MAKEOPENGLAPI( glRasterPos3iv            )
MAKEOPENGLAPI( glRasterPos3s             )
MAKEOPENGLAPI( glRasterPos3sv            )
MAKEOPENGLAPI( glRasterPos4d             )
MAKEOPENGLAPI( glRasterPos4dv            )
MAKEOPENGLAPI( glRasterPos4f             )
MAKEOPENGLAPI( glRasterPos4fv            )
MAKEOPENGLAPI( glRasterPos4i             )
MAKEOPENGLAPI( glRasterPos4iv            )
MAKEOPENGLAPI( glRasterPos4s             )
MAKEOPENGLAPI( glRasterPos4sv            )
MAKEOPENGLAPI( glClipPlane               )
MAKEOPENGLAPI( glColorMaterial           )
MAKEOPENGLAPI( glCullFace                )
MAKEOPENGLAPI( glFogf                    )
MAKEOPENGLAPI( glFogfv                   )
MAKEOPENGLAPI( glFogi                    )
MAKEOPENGLAPI( glFogiv                   )
MAKEOPENGLAPI( glFrontFace               )
MAKEOPENGLAPI( glHint                    )
MAKEOPENGLAPI( glLightf                  )
MAKEOPENGLAPI( glLightfv                 )
MAKEOPENGLAPI( glLighti                  )
MAKEOPENGLAPI( glLightiv                 )
MAKEOPENGLAPI( glLightModelf             )
MAKEOPENGLAPI( glLightModelfv            )
MAKEOPENGLAPI( glLightModeli             )
MAKEOPENGLAPI( glLightModeliv            )
MAKEOPENGLAPI( glLineStipple             )
MAKEOPENGLAPI( glLineWidth               )
MAKEOPENGLAPI( glPointSize               )
MAKEOPENGLAPI( glPolygonMode             )
MAKEOPENGLAPI( glPolygonStipple          )
MAKEOPENGLAPI( glScissor                 )
MAKEOPENGLAPI( glFinish                  )
MAKEOPENGLAPI( glShadeModel              )
MAKEOPENGLAPI( glTexParameterf           )
MAKEOPENGLAPI( glTexParameterfv          )
MAKEOPENGLAPI( glTexParameteri           )
MAKEOPENGLAPI( glTexParameteriv          )
MAKEOPENGLAPI( glTexEnvf                 )
MAKEOPENGLAPI( glTexEnvfv                )
MAKEOPENGLAPI( glTexEnvi                 )
MAKEOPENGLAPI( glTexEnviv                )
MAKEOPENGLAPI( glTexGend                 )
MAKEOPENGLAPI( glTexGendv                )
MAKEOPENGLAPI( glTexGenf                 )
MAKEOPENGLAPI( glTexGenfv                )
MAKEOPENGLAPI( glTexGeni                 )
MAKEOPENGLAPI( glTexGeniv                )
MAKEOPENGLAPI( glFeedbackBuffer          )
MAKEOPENGLAPI( glSelectBuffer            )
MAKEOPENGLAPI( glRenderMode              )
MAKEOPENGLAPI( glInitNames               )
MAKEOPENGLAPI( glLoadName                )
MAKEOPENGLAPI( glPassThrough             )
MAKEOPENGLAPI( glPopName                 )
MAKEOPENGLAPI( glPushName                )
MAKEOPENGLAPI( glDrawBuffer              )
MAKEOPENGLAPI( glStencilMask             )
MAKEOPENGLAPI( glColorMask               )
MAKEOPENGLAPI( glDepthMask               )
MAKEOPENGLAPI( glIndexMask               )
MAKEOPENGLAPI( glAccum                   )
MAKEOPENGLAPI( glFlush                   )
MAKEOPENGLAPI( glMap1d                   )
MAKEOPENGLAPI( glMap1f                   )
MAKEOPENGLAPI( glMap2d                   )
MAKEOPENGLAPI( glMap2f                   )
MAKEOPENGLAPI( glMapGrid1d               )
MAKEOPENGLAPI( glMapGrid1f               )
MAKEOPENGLAPI( glMapGrid2d               )
MAKEOPENGLAPI( glMapGrid2f               )
MAKEOPENGLAPI( glEvalMesh1               )
MAKEOPENGLAPI( glEvalMesh2               )
MAKEOPENGLAPI( glAlphaFunc               )
MAKEOPENGLAPI( glBlendFunc               )
MAKEOPENGLAPI( glLogicOp                 )
MAKEOPENGLAPI( glStencilFunc             )
MAKEOPENGLAPI( glStencilOp               )
MAKEOPENGLAPI( glDepthFunc               )
MAKEOPENGLAPI( glPixelZoom               )
MAKEOPENGLAPI( glPixelTransferf          )
MAKEOPENGLAPI( glPixelTransferi          )
MAKEOPENGLAPI( glPixelStoref             )
MAKEOPENGLAPI( glPixelStorei             )
MAKEOPENGLAPI( glPixelMapfv              )
MAKEOPENGLAPI( glPixelMapuiv             )
MAKEOPENGLAPI( glPixelMapusv             )
MAKEOPENGLAPI( glReadBuffer              )
MAKEOPENGLAPI( glGetBooleanv             )
MAKEOPENGLAPI( glGetClipPlane            )
MAKEOPENGLAPI( glGetDoublev              )
MAKEOPENGLAPI( glGetError                )
MAKEOPENGLAPI( glGetFloatv               )
MAKEOPENGLAPI( glGetIntegerv             )
MAKEOPENGLAPI( glGetLightfv              )
MAKEOPENGLAPI( glGetLightiv              )
MAKEOPENGLAPI( glGetMapdv                )
MAKEOPENGLAPI( glGetMapfv                )
MAKEOPENGLAPI( glGetMapiv                )
MAKEOPENGLAPI( glGetMaterialfv           )
MAKEOPENGLAPI( glGetMaterialiv           )
MAKEOPENGLAPI( glGetPixelMapfv           )
MAKEOPENGLAPI( glGetPixelMapuiv          )
MAKEOPENGLAPI( glGetPixelMapusv          )
MAKEOPENGLAPI( glGetPolygonStipple       )
MAKEOPENGLAPI( glGetString               )
MAKEOPENGLAPI( glGetTexEnvfv             )
MAKEOPENGLAPI( glGetTexEnviv             )
MAKEOPENGLAPI( glGetTexGendv             )
MAKEOPENGLAPI( glGetTexGenfv             )
MAKEOPENGLAPI( glGetTexGeniv             )
MAKEOPENGLAPI( glGetTexImage             )
MAKEOPENGLAPI( glGetTexParameterfv       )
MAKEOPENGLAPI( glGetTexParameteriv       )
MAKEOPENGLAPI( glGetTexLevelParameterfv  )
MAKEOPENGLAPI( glGetTexLevelParameteriv  )
MAKEOPENGLAPI( glIsEnabled               )
MAKEOPENGLAPI( glIsList                  )
MAKEOPENGLAPI( glDepthRange              )
MAKEOPENGLAPI( glFrustum                 )
MAKEOPENGLAPI( glOrtho                   )
MAKEOPENGLAPI( glViewport                )
MAKEOPENGLAPI( glAreTexturesResident     )
MAKEOPENGLAPI( glCopyTexImage1D          )
MAKEOPENGLAPI( glCopyTexImage2D          )
MAKEOPENGLAPI( glCopyTexSubImage1D       )
MAKEOPENGLAPI( glCopyTexSubImage2D       )
MAKEOPENGLAPI( glDeleteTextures          )
MAKEOPENGLAPI( glGenTextures             )
MAKEOPENGLAPI( glIsTexture               )
MAKEOPENGLAPI( glPrioritizeTextures      )
MAKEOPENGLAPI( glTexSubImage1D           )
MAKEOPENGLAPI( glTexSubImage2D           )
MAKEOPENGLAPI( glGetColorTableEXT        )
MAKEOPENGLAPI( glGetColorTableParameterivEXT )
MAKEOPENGLAPI( glGetColorTableParameterfvEXT )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\dlist\dlistfn.h ===
/******************************Module*Header*******************************\
* Module Name: dlistfn.h
*
* Display list inline functions
* Cannot be in dlist.h because they require full definitions of structures
* defines in context.h
*
* Created: 23-Oct-1995 18:31:42
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1995-96 Microsoft Corporation
*
\**************************************************************************/

#ifndef __DLISTFN_H__
#define __DLISTFN_H__

extern const GLubyte * FASTCALL __glle_Nop(__GLcontext *gc, const GLubyte *PC);

// Allocate space in a display for a display list op and return
// a pointer to the data space for the record
// These functions are specially written to be small so that they
// can be inlined to remove call overhead
    
// Add an op which doesn't require QWORD alignment
__inline
void *__glDlistAddOpUnaligned(__GLcontext *gc,
                              GLuint size,
                              __GLlistExecFunc *fp)
{
    __GLdlist *dlist;
    GLubyte *data;
    
    dlist = gc->dlist.listData;
    
    if (dlist->size-dlist->used < size)
    {
        if ((dlist = __glDlistGrow(size)) == NULL)
        {
            return NULL;
        }
    }

    data = dlist->head+dlist->used;
    dlist->used += size;
    
    *((__GLlistExecFunc * UNALIGNED64 *) data) = fp;

    return data+sizeof(__GLlistExecFunc *);
}

// Add an op which does require QWORD alignment
__inline
void *__glDlistAddOpAligned(__GLcontext *gc,
                            GLuint size,
                            __GLlistExecFunc *fp)
{
    __GLdlist *dlist;
    GLubyte *data;
    GLboolean addPad;
    
    dlist = gc->dlist.listData;
    
    // dlist->head is always non-QWORD aligned, but make sure
    // We use this fact to simplify the alignment check below
#ifndef _IA64_
    ASSERTOPENGL((((char *) (&dlist->head) - (char *) (dlist)) & 7) == 4,
	"bad dlist->head alignment\n");
#endif

    // Add padding for aligned records
    // Since head is always non-QWORD aligned, dlist->head is guaranteed
    // to be at QWORD offset 4.  Since we stick a dispatch pointer at
    // the head of every record, this gets bumped up to an even QWORD
    // boundary as long as the current record would begin at a half
    // QWORD boundary.  That means as long as dlist->used is QWORD-even,
    // the record data will be QWORD aligned
    // Win95 note: LocalAlloc doesn't appear to return QWORD aligned
    // memory so we need to check the real pointer for alignment
#ifndef _IA64_
    if (((ULONG_PTR)(dlist->head+dlist->used) & 7) == 0)
    {
        size += sizeof(__GLlistExecFunc **);
        addPad = GL_TRUE;
    }
    else
#endif
    {
        addPad = GL_FALSE;
    }

    if (dlist->size-dlist->used < size)
    {
        // New dlist->head will be properly non-QWORD aligned - remove any 
        // padding
        if( addPad ) {
            size -= sizeof(__GLlistExecFunc **);
            addPad = GL_FALSE;
        }
        if ((dlist = __glDlistGrow(size)) == NULL)
        {
            return NULL;
        }
    }

    data = dlist->head+dlist->used;
    dlist->used += size;
    
    if (addPad)
    {
        *((__GLlistExecFunc **) data) = __glle_Nop;
        data += sizeof(__GLlistExecFunc **);
    }

    *((__GLlistExecFunc * UNALIGNED64 *) data) = fp;

    return data+sizeof(__GLlistExecFunc *);
}

/*
** Append the given op to the currently under construction list.
*/
__inline
void __glDlistAppendOp(__GLcontext *gc, void *data,
                       __GLlistExecFunc *fp)
{
    if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE)
    {
        fp(gc, (GLubyte *)data);
    }
}

// Resize the current op to a smaller size.
__inline
void __glDlistResizeCurrentOp(__GLcontext *gc, GLuint oldSize, GLuint newSize)
{
    __GLdlist *dlist;
    
    ASSERTOPENGL(oldSize >= newSize, "new size > old size!\n");

    dlist = gc->dlist.listData;
    dlist->used -= oldSize - newSize;
    return;
}
#endif // __DLISTFN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\dlist\dlistint.h ===
#ifndef __gldlistint_h
#define __gldlistint_h

/*
** Copyright 1991, 1922, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Display list internal structure description.
**
** $Revision: 1.2 $
** $Date: 1993/09/29 00:45:06 $
*/
#include "dlist.h"

/*
** Minimum size of an allocated block of display lists.
** If the user uses a single display list in a reserved block,
** __GL_DLIST_MIN_ARRAY_BLOCK will be allocated at once.
**
** A block will not be grown any larger than __GL_DLIST_MAX_ARRAY_BLOCK.
** Large blocks are easier to use when display lists are being executed, but
** more difficult to manage when they are being created.
*/
#define __GL_DLIST_MIN_ARRAY_BLOCK      16
#define __GL_DLIST_MAX_ARRAY_BLOCK      1024

#ifndef NT
/*
** Display list group structure
*/
struct __GLdlistArrayRec {
    GLint refcount;            /* # contexts using this array */
};

/*
** Regardless of what __GLdlistArray looks like, the following api points
** must be provided, along with __glim_GenLists(), __glim_IsList(),
** __glim_ListBase(), and __glim_DeleteLists() (defined in dlist.h)
*/

/*
** Allocate and initialize a new array structure.
*/
extern __GLdlistArray *__glDlistNewArray(__GLcontext *gc);

/*
** Free the array structure.
*/
extern void FASTCALL __glDlistFreeArray(__GLcontext *gc, __GLdlistArray *array);
#endif

/*
** Clean up a display list,
** given to names management code
** Also called directly
*/
void WINAPIV __glDisposeDlist(__GLcontext *gc, void *pData);

#ifdef NT_SERVER_SHARE_LISTS
extern void DlReleaseLocks(__GLcontext *gc);
#endif

#endif /* __gldlistint_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\dlist\dl_init.c ===
/******************************Module*Header*******************************\
* Module Name: dl_init.c
*
* Display list initialization and sharing rountines.
*
* Copyright (c) 1995-96 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Display list init/destroy code.
**
** $Revision: 1.7 $
** $Date: 1993/09/29 00:44:06 $
*/
#include "precomp.h"
#pragma hdrstop

/*
** Empty data structure for display lists.
*/
static  __GLdlist emptyDlist = {
	2,			/* refcount, two so that it can never die */
        0                       /* Everything else, some initialized later */
};

static __GLnamesArrayTypeInfo dlistTypeInfo =
{
    &emptyDlist,
    sizeof(__GLdlist),
    __glDisposeDlist,
    NULL
};

/*
** Used to share display lists between two different contexts.
*/
#ifdef NT_SERVER_SHARE_LISTS
GLboolean FASTCALL __glCanShareDlist(__GLcontext *gc, __GLcontext *shareMe)
{
    GLboolean canShare = GL_TRUE;
    
    if (gc->dlist.namesArray != NULL)
    {
        __glNamesLockArray(gc, gc->dlist.namesArray);
        
        // Make sure we're not trying to replace a shared list
        // The spec also says that it is illegal for the new context
        // to have any display lists
        canShare = gc->dlist.namesArray->refcount == 1 &&
            gc->dlist.namesArray->tree == NULL &&
            shareMe->dlist.namesArray != NULL;

        __glNamesUnlockArray(gc, gc->dlist.namesArray);
    }
    
    return canShare;
}
#endif

void FASTCALL __glShareDlist(__GLcontext *gc, __GLcontext *shareMe)
{
#ifdef NT_SERVER_SHARE_LISTS
    __glFreeDlistState(gc);
    __glNamesLockArray(gc, shareMe->dlist.namesArray);
#endif

    gc->dlist.namesArray = shareMe->dlist.namesArray;
    gc->dlist.namesArray->refcount++;
    
#ifdef NT_SERVER_SHARE_LISTS
    DBGLEVEL3(LEVEL_INFO, "Sharing dlists %p with %p, count %d\n", gc, shareMe,
              gc->dlist.namesArray->refcount);

    __glNamesUnlockArray(gc, shareMe->dlist.namesArray);
#endif
}

void FASTCALL __glInitDlistState(__GLcontext *gc)
{
    __GLdlistMachine *dlist;

    // This is required by the names management code
    ASSERTOPENGL(offsetof(__GLdlist, refcount) == 0,
                 "Dlist refcount not at offset zero\n");

    // Set empty dlist to contain no entries
    emptyDlist.end = emptyDlist.head;
    
    dlist = &gc->dlist;

    dlist->nesting = 0;
    dlist->currentList = 0;
    dlist->listData = NULL;
    dlist->beginRec = NULL;

    ASSERTOPENGL(dlist->namesArray == NULL, "Dlist namesArray not NULL\n");
    dlist->namesArray = __glNamesNewArray(gc, &dlistTypeInfo);
}

void FASTCALL __glFreeDlistState(__GLcontext *gc)
{
    __GLnamesArray *narray;

    narray = gc->dlist.namesArray;

    if (narray == NULL)
    {
        return;
    }
    
#ifdef NT_SERVER_SHARE_LISTS
    __glNamesLockArray(gc, narray);

    // Clean up any lists that this context may have locked
    DlReleaseLocks(gc);
#endif

    DBGLEVEL2(LEVEL_INFO, "Freeing dlists for %p, ref %d\n", gc,
              narray->refcount);

    narray->refcount--;
    if (narray->refcount == 0)
    {
        // NULL the array pointer first, preventing its reuse
        // after we unlock it.  We need to unlock before we free it
        // because the critical section will be cleaned up in the
        // free
        gc->dlist.namesArray = NULL;
	// Decrement dlist refcounts and free them if they reach 0
	__glNamesFreeArray(gc, narray);
    }
    else
    {
        __glNamesUnlockArray(gc, narray);
        gc->dlist.namesArray = NULL;
    }

    if (gc->dlist.listData != NULL)
    {
	// We were in the middle of compiling a display list when this
	// function is called!  Free the display list data.
        __glFreeDlist(gc, gc->dlist.listData);
        gc->dlist.listData = NULL;
        gc->dlist.currentList = 0;
    }
}

/******************************Public*Routine******************************\
*
* glsrvShareLists
*
* Server side implementation of wglShareLists
*
* History:
*  Tue Dec 13 17:14:18 1994	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#ifdef NT_SERVER_SHARE_LISTS
ULONG APIENTRY glsrvShareLists(__GLcontext *gcShare, __GLcontext *gcSource)
{
    if (!__glCanShareDlist(gcShare, gcSource) ||
        !__glCanShareTextures(gcShare, gcSource))
    {
        return ERROR_INVALID_PARAMETER;
    }
    else
    {
        __glShareDlist(gcShare, gcSource);
        __glShareTextures(gcShare, gcSource);
        return ERROR_SUCCESS;
    }
}
#endif

/******************************Public*Routine******************************\
*
* __glDlistThreadCleanup
*
* Performs thread-exit cleanup for dlist state
*
* History:
*  Mon Dec 19 13:22:38 1994	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#ifdef NT_SERVER_SHARE_LISTS

#if DBG
// Critical section check routine from usersrv
extern void APIENTRY CheckCritSectionOut(LPCRITICAL_SECTION pcs);
#endif

void __glDlistThreadCleanup(__GLcontext *gc)
{
#if DBG
    // Make sure we're not holding the display list critical section
    // We only hold this for short periods of time in our own code
    // so we should never be holding it unless we have bugs
    // In other words, it's ok to just assert this because no
    // client action can cause us to hold it
    CheckCritSectionOut(&gc->dlist.namesArray->critsec);
#endif
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\dlist\dl_lexec.c ===
/******************************Module*Header*******************************\
* Module Name: dl_lexec.c
*
* Display list execution routines.
*
* Created: 12-24-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995-96 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

/*
** Execution routines for display lists for all of the basic
** OpenGL commands.  These were automatically generated at one point, 
** but now the basic format has stabilized, and we make minor changes to
** individual routines from time to time.
*/

/***************************************************************************/
// Color functions.

const GLubyte * FASTCALL __glle_Color3fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Color3fv_Rec *data;

    data = (struct __gllc_Color3fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glColor3fv)(data->v);
    return PC + sizeof(struct __gllc_Color3fv_Rec);
}

const GLubyte * FASTCALL __glle_Color3ubv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Color3ubv_Rec *data;

    data = (struct __gllc_Color3ubv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glColor3ubv)(data->v);
    return PC + sizeof(struct __gllc_Color3ubv_Rec);
}

const GLubyte * FASTCALL __glle_Color4fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Color4fv_Rec *data;

    data = (struct __gllc_Color4fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glColor4fv)(data->v);
    return PC + sizeof(struct __gllc_Color4fv_Rec);
}

const GLubyte * FASTCALL __glle_Color4ubv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Color4ubv_Rec *data;

    data = (struct __gllc_Color4ubv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glColor4ubv)(data->v);
    return PC + sizeof(struct __gllc_Color4ubv_Rec);
}

/***************************************************************************/
// EdgeFlag function.

const GLubyte * FASTCALL __glle_EdgeFlag(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_EdgeFlag_Rec *data;

    data = (struct __gllc_EdgeFlag_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glEdgeFlag)(data->flag);
    return PC + sizeof(struct __gllc_EdgeFlag_Rec);
}

/***************************************************************************/
// Indexf function.

const GLubyte * FASTCALL __glle_Indexf(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Indexf_Rec *data;

    data = (struct __gllc_Indexf_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glIndexf)(data->c);
    return PC + sizeof(struct __gllc_Indexf_Rec);
}

/***************************************************************************/
// Normal functions.

const GLubyte * FASTCALL __glle_Normal3bv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Normal3bv_Rec *data;

    data = (struct __gllc_Normal3bv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glNormal3bv)(data->v);
    return PC + sizeof(struct __gllc_Normal3bv_Rec);
}

const GLubyte * FASTCALL __glle_Normal3fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Normal3fv_Rec *data;

    data = (struct __gllc_Normal3fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glNormal3fv)(data->v);
    return PC + sizeof(struct __gllc_Normal3fv_Rec);
}

/***************************************************************************/
// RasterPos functions.

const GLubyte * FASTCALL __glle_RasterPos2f(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_RasterPos2f_Rec *data;

    data = (struct __gllc_RasterPos2f_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glRasterPos2f)(data->x, data->y);
    return PC + sizeof(struct __gllc_RasterPos2f_Rec);
}

const GLubyte * FASTCALL __glle_RasterPos3fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_RasterPos3fv_Rec *data;

    data = (struct __gllc_RasterPos3fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glRasterPos3fv)(data->v);
    return PC + sizeof(struct __gllc_RasterPos3fv_Rec);
}

const GLubyte * FASTCALL __glle_RasterPos4fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_RasterPos4fv_Rec *data;

    data = (struct __gllc_RasterPos4fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glRasterPos4fv)(data->v);
    return PC + sizeof(struct __gllc_RasterPos4fv_Rec);
}

/***************************************************************************/
// Rectf function.

const GLubyte * FASTCALL __glle_Rectf(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Rectf_Rec *data;

    data = (struct __gllc_Rectf_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glRectf)(data->x1, data->y1, data->x2, data->y2);
    return PC + sizeof(struct __gllc_Rectf_Rec);
}

/***************************************************************************/
// TexCoord functions.

const GLubyte * FASTCALL __glle_TexCoord1f(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_TexCoord1f_Rec *data;

    data = (struct __gllc_TexCoord1f_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexCoord1f)(data->s);
    return PC + sizeof(struct __gllc_TexCoord1f_Rec);
}

const GLubyte * FASTCALL __glle_TexCoord2f(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_TexCoord2f_Rec *data;

    data = (struct __gllc_TexCoord2f_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexCoord2f)(data->s, data->t);
    return PC + sizeof(struct __gllc_TexCoord2f_Rec);
}

const GLubyte * FASTCALL __glle_TexCoord3fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_TexCoord3fv_Rec *data;

    data = (struct __gllc_TexCoord3fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexCoord3fv)(data->v);
    return PC + sizeof(struct __gllc_TexCoord3fv_Rec);
}

const GLubyte * FASTCALL __glle_TexCoord4fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_TexCoord4fv_Rec *data;

    data = (struct __gllc_TexCoord4fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexCoord4fv)(data->v);
    return PC + sizeof(struct __gllc_TexCoord4fv_Rec);
}

/***************************************************************************/
// Vertex functions.

const GLubyte * FASTCALL __glle_Vertex2f(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Vertex2f_Rec *data;

    data = (struct __gllc_Vertex2f_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glVertex2f)(data->x, data->y);
    return PC + sizeof(struct __gllc_Vertex2f_Rec);
}

const GLubyte * FASTCALL __glle_Vertex3fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Vertex3fv_Rec *data;

    data = (struct __gllc_Vertex3fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glVertex3fv)(data->v);
    return PC + sizeof(struct __gllc_Vertex3fv_Rec);
}

const GLubyte * FASTCALL __glle_Vertex4fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Vertex4fv_Rec *data;

    data = (struct __gllc_Vertex4fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glVertex4fv)(data->v);
    return PC + sizeof(struct __gllc_Vertex4fv_Rec);
}

/***************************************************************************/
// Fogfv function.

const GLubyte * FASTCALL __glle_Fogfv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_Fogfv_Rec *data;

    data = (struct __gllc_Fogfv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glFogfv)(data->pname, 
	    (GLfloat *) (PC + sizeof(struct __gllc_Fogfv_Rec)));
    arraySize = __glFogfv_size(data->pname) * 4;
    size = sizeof(struct __gllc_Fogfv_Rec) + arraySize;
    return PC + size;
}

/***************************************************************************/
// Lightfv function.

const GLubyte * FASTCALL __glle_Lightfv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_Lightfv_Rec *data;

    data = (struct __gllc_Lightfv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glLightfv)(data->light, data->pname, 
	    (GLfloat *) (PC + sizeof(struct __gllc_Lightfv_Rec)));
    arraySize = __glLightfv_size(data->pname) * 4;
    size = sizeof(struct __gllc_Lightfv_Rec) + arraySize;
    return PC + size;
}

/***************************************************************************/
// LightModelfv function.

const GLubyte * FASTCALL __glle_LightModelfv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_LightModelfv_Rec *data;

    data = (struct __gllc_LightModelfv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glLightModelfv)(data->pname, 
	    (GLfloat *) (PC + sizeof(struct __gllc_LightModelfv_Rec)));
    arraySize = __glLightModelfv_size(data->pname) * 4;
    size = sizeof(struct __gllc_LightModelfv_Rec) + arraySize;
    return PC + size;
}

/***************************************************************************/
// Materialfv function.

const GLubyte * FASTCALL __glle_Materialfv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_Materialfv_Rec *data;

    data = (struct __gllc_Materialfv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glMaterialfv)(data->face, data->pname, 
	    (GLfloat *) (PC + sizeof(struct __gllc_Materialfv_Rec)));
    arraySize = __glMaterialfv_size(data->pname) * 4;
    size = sizeof(struct __gllc_Materialfv_Rec) + arraySize;
    return PC + size;
}

/***************************************************************************/
// TexParameter functions.

const GLubyte * FASTCALL __glle_TexParameterfv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_TexParameterfv_Rec *data;

    data = (struct __gllc_TexParameterfv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexParameterfv)(data->target, data->pname, 
	    (GLfloat *) (PC + sizeof(struct __gllc_TexParameterfv_Rec)));
    arraySize = __glTexParameterfv_size(data->pname) * 4;
    size = sizeof(struct __gllc_TexParameterfv_Rec) + arraySize;
    return PC + size;
}

const GLubyte * FASTCALL __glle_TexParameteriv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_TexParameteriv_Rec *data;

    data = (struct __gllc_TexParameteriv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexParameteriv)(data->target, data->pname, 
	    (GLint *) (PC + sizeof(struct __gllc_TexParameteriv_Rec)));
    arraySize = __glTexParameteriv_size(data->pname) * 4;
    size = sizeof(struct __gllc_TexParameteriv_Rec) + arraySize;
    return PC + size;
}

/***************************************************************************/
// TexEnv functions.

const GLubyte * FASTCALL __glle_TexEnvfv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_TexEnvfv_Rec *data;

    data = (struct __gllc_TexEnvfv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexEnvfv)(data->target, data->pname, 
	    (GLfloat *) (PC + sizeof(struct __gllc_TexEnvfv_Rec)));
    arraySize = __glTexEnvfv_size(data->pname) * 4;
    size = sizeof(struct __gllc_TexEnvfv_Rec) + arraySize;
    return PC + size;
}

const GLubyte * FASTCALL __glle_TexEnviv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_TexEnviv_Rec *data;

    data = (struct __gllc_TexEnviv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexEnviv)(data->target, data->pname, 
	    (GLint *) (PC + sizeof(struct __gllc_TexEnviv_Rec)));
    arraySize = __glTexEnviv_size(data->pname) * 4;
    size = sizeof(struct __gllc_TexEnviv_Rec) + arraySize;
    return PC + size;
}

/***************************************************************************/
// TexGenfv function.

const GLubyte * FASTCALL __glle_TexGenfv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_TexGenfv_Rec *data;

    data = (struct __gllc_TexGenfv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexGenfv)(data->coord, data->pname, 
	    (GLfloat *) (PC + sizeof(struct __gllc_TexGenfv_Rec)));
    arraySize = __glTexGenfv_size(data->pname) * 4;
    size = sizeof(struct __gllc_TexGenfv_Rec) + arraySize;
    return PC + size;
}

/***************************************************************************/
// MapGrid functions.

const GLubyte * FASTCALL __glle_MapGrid1f(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_MapGrid1f_Rec *data;

    data = (struct __gllc_MapGrid1f_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glMapGrid1f)(data->un, data->u1, data->u2);
    return PC + sizeof(struct __gllc_MapGrid1f_Rec);
}

const GLubyte * FASTCALL __glle_MapGrid2f(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_MapGrid2f_Rec *data;

    data = (struct __gllc_MapGrid2f_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glMapGrid2f)(data->un, data->u1, data->u2, data->vn, 
	    data->v1, data->v2);
    return PC + sizeof(struct __gllc_MapGrid2f_Rec);
}

/***************************************************************************/
// EvalCoord functions.

const GLubyte * FASTCALL __glle_EvalCoord1f(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_EvalCoord1f_Rec *data;

    data = (struct __gllc_EvalCoord1f_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glEvalCoord1f)(data->u);
    return PC + sizeof(struct __gllc_EvalCoord1f_Rec);
}

const GLubyte * FASTCALL __glle_EvalCoord2f(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_EvalCoord2f_Rec *data;

    data = (struct __gllc_EvalCoord2f_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glEvalCoord2f)(data->u, data->v);
    return PC + sizeof(struct __gllc_EvalCoord2f_Rec);
}

/***************************************************************************/
// LoadMatrixf function.

const GLubyte * FASTCALL __glle_LoadMatrixf(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_LoadMatrixf_Rec *data;

    data = (struct __gllc_LoadMatrixf_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glLoadMatrixf)(data->m);
    return PC + sizeof(struct __gllc_LoadMatrixf_Rec);
}

/***************************************************************************/
// MultMatrixf function.

const GLubyte * FASTCALL __glle_MultMatrixf(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_MultMatrixf_Rec *data;

    data = (struct __gllc_MultMatrixf_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glMultMatrixf)(data->m);
    return PC + sizeof(struct __gllc_MultMatrixf_Rec);
}

/***************************************************************************/
// Rotatef functions.

const GLubyte * FASTCALL __glle_Rotatef(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Rotatef_Rec *data;

    data = (struct __gllc_Rotatef_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glRotatef)(data->angle, data->x, data->y, data->z);
    return PC + sizeof(struct __gllc_Rotatef_Rec);
}

/***************************************************************************/
// Scalef functions.

const GLubyte * FASTCALL __glle_Scalef(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Scalef_Rec *data;

    data = (struct __gllc_Scalef_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glScalef)(data->x, data->y, data->z);
    return PC + sizeof(struct __gllc_Scalef_Rec);
}

/***************************************************************************/
// Translatef functions.

const GLubyte * FASTCALL __glle_Translatef(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Translatef_Rec *data;

    data = (struct __gllc_Translatef_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTranslatef)(data->x, data->y, data->z);
    return PC + sizeof(struct __gllc_Translatef_Rec);
}

/***************************************************************************/
// Other functions.

const GLubyte * FASTCALL __glle_ListBase(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ListBase_Rec *data;

    data = (struct __gllc_ListBase_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glListBase)(data->base);
    return PC + sizeof(struct __gllc_ListBase_Rec);
}

const GLubyte * FASTCALL __glle_ClipPlane(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ClipPlane_Rec *data;

    data = (struct __gllc_ClipPlane_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glClipPlane)(data->plane, data->equation);
    return PC + sizeof(struct __gllc_ClipPlane_Rec);
}

const GLubyte * FASTCALL __glle_ColorMaterial(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ColorMaterial_Rec *data;

    data = (struct __gllc_ColorMaterial_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glColorMaterial)(data->face, data->mode);
    return PC + sizeof(struct __gllc_ColorMaterial_Rec);
}

const GLubyte * FASTCALL __glle_CullFace(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_CullFace_Rec *data;

    data = (struct __gllc_CullFace_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glCullFace)(data->mode);
    return PC + sizeof(struct __gllc_CullFace_Rec);
}

const GLubyte * FASTCALL __glle_FrontFace(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_FrontFace_Rec *data;

    data = (struct __gllc_FrontFace_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glFrontFace)(data->mode);
    return PC + sizeof(struct __gllc_FrontFace_Rec);
}

const GLubyte * FASTCALL __glle_Hint(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Hint_Rec *data;

    data = (struct __gllc_Hint_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glHint)(data->target, data->mode);
    return PC + sizeof(struct __gllc_Hint_Rec);
}

const GLubyte * FASTCALL __glle_LineStipple(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_LineStipple_Rec *data;

    data = (struct __gllc_LineStipple_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glLineStipple)(data->factor, data->pattern);
    return PC + sizeof(struct __gllc_LineStipple_Rec);
}

const GLubyte * FASTCALL __glle_LineWidth(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_LineWidth_Rec *data;

    data = (struct __gllc_LineWidth_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glLineWidth)(data->width);
    return PC + sizeof(struct __gllc_LineWidth_Rec);
}

const GLubyte * FASTCALL __glle_PointSize(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PointSize_Rec *data;

    data = (struct __gllc_PointSize_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPointSize)(data->size);
    return PC + sizeof(struct __gllc_PointSize_Rec);
}

const GLubyte * FASTCALL __glle_PolygonMode(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PolygonMode_Rec *data;

    data = (struct __gllc_PolygonMode_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPolygonMode)(data->face, data->mode);
    return PC + sizeof(struct __gllc_PolygonMode_Rec);
}

const GLubyte * FASTCALL __glle_Scissor(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Scissor_Rec *data;

    data = (struct __gllc_Scissor_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glScissor)(data->x, data->y, data->width, data->height);
    return PC + sizeof(struct __gllc_Scissor_Rec);
}

const GLubyte * FASTCALL __glle_ShadeModel(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ShadeModel_Rec *data;

    data = (struct __gllc_ShadeModel_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glShadeModel)(data->mode);
    return PC + sizeof(struct __gllc_ShadeModel_Rec);
}

const GLubyte * FASTCALL __glle_InitNames(__GLcontext *gc, const GLubyte *PC)
{

    (*gc->savedCltProcTable.glDispatchTable.glInitNames)();
    return PC;
}

const GLubyte * FASTCALL __glle_LoadName(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_LoadName_Rec *data;

    data = (struct __gllc_LoadName_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glLoadName)(data->name);
    return PC + sizeof(struct __gllc_LoadName_Rec);
}

const GLubyte * FASTCALL __glle_PassThrough(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PassThrough_Rec *data;

    data = (struct __gllc_PassThrough_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPassThrough)(data->token);
    return PC + sizeof(struct __gllc_PassThrough_Rec);
}

const GLubyte * FASTCALL __glle_PopName(__GLcontext *gc, const GLubyte *PC)
{

    (*gc->savedCltProcTable.glDispatchTable.glPopName)();
    return PC;
}

const GLubyte * FASTCALL __glle_PushName(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PushName_Rec *data;

    data = (struct __gllc_PushName_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPushName)(data->name);
    return PC + sizeof(struct __gllc_PushName_Rec);
}

const GLubyte * FASTCALL __glle_DrawBuffer(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_DrawBuffer_Rec *data;

    data = (struct __gllc_DrawBuffer_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glDrawBuffer)(data->mode);
    return PC + sizeof(struct __gllc_DrawBuffer_Rec);
}

const GLubyte * FASTCALL __glle_Clear(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Clear_Rec *data;

    data = (struct __gllc_Clear_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glClear)(data->mask);
    return PC + sizeof(struct __gllc_Clear_Rec);
}

const GLubyte * FASTCALL __glle_ClearAccum(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ClearAccum_Rec *data;

    data = (struct __gllc_ClearAccum_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glClearAccum)(data->red, data->green, data->blue, data->alpha);
    return PC + sizeof(struct __gllc_ClearAccum_Rec);
}

const GLubyte * FASTCALL __glle_ClearIndex(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ClearIndex_Rec *data;

    data = (struct __gllc_ClearIndex_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glClearIndex)(data->c);
    return PC + sizeof(struct __gllc_ClearIndex_Rec);
}

const GLubyte * FASTCALL __glle_ClearColor(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ClearColor_Rec *data;

    data = (struct __gllc_ClearColor_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glClearColor)(data->red, data->green, data->blue, data->alpha);
    return PC + sizeof(struct __gllc_ClearColor_Rec);
}

const GLubyte * FASTCALL __glle_ClearStencil(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ClearStencil_Rec *data;

    data = (struct __gllc_ClearStencil_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glClearStencil)(data->s);
    return PC + sizeof(struct __gllc_ClearStencil_Rec);
}

const GLubyte * FASTCALL __glle_ClearDepth(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ClearDepth_Rec *data;

    data = (struct __gllc_ClearDepth_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glClearDepth)(data->depth);
    return PC + sizeof(struct __gllc_ClearDepth_Rec);
}

const GLubyte * FASTCALL __glle_StencilMask(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_StencilMask_Rec *data;

    data = (struct __gllc_StencilMask_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glStencilMask)(data->mask);
    return PC + sizeof(struct __gllc_StencilMask_Rec);
}

const GLubyte * FASTCALL __glle_ColorMask(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ColorMask_Rec *data;

    data = (struct __gllc_ColorMask_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glColorMask)(data->red, data->green, data->blue, data->alpha);
    return PC + sizeof(struct __gllc_ColorMask_Rec);
}

const GLubyte * FASTCALL __glle_DepthMask(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_DepthMask_Rec *data;

    data = (struct __gllc_DepthMask_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glDepthMask)(data->flag);
    return PC + sizeof(struct __gllc_DepthMask_Rec);
}

const GLubyte * FASTCALL __glle_IndexMask(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_IndexMask_Rec *data;

    data = (struct __gllc_IndexMask_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glIndexMask)(data->mask);
    return PC + sizeof(struct __gllc_IndexMask_Rec);
}

const GLubyte * FASTCALL __glle_Accum(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Accum_Rec *data;

    data = (struct __gllc_Accum_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glAccum)(data->op, data->value);
    return PC + sizeof(struct __gllc_Accum_Rec);
}

const GLubyte * FASTCALL __glle_Disable(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Disable_Rec *data;

    data = (struct __gllc_Disable_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glDisable)(data->cap);
    return PC + sizeof(struct __gllc_Disable_Rec);
}

const GLubyte * FASTCALL __glle_Enable(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Enable_Rec *data;

    data = (struct __gllc_Enable_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glEnable)(data->cap);
    return PC + sizeof(struct __gllc_Enable_Rec);
}

const GLubyte * FASTCALL __glle_PopAttrib(__GLcontext *gc, const GLubyte *PC)
{

    (*gc->savedCltProcTable.glDispatchTable.glPopAttrib)();
    return PC;
}

const GLubyte * FASTCALL __glle_PushAttrib(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PushAttrib_Rec *data;

    data = (struct __gllc_PushAttrib_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPushAttrib)(data->mask);
    return PC + sizeof(struct __gllc_PushAttrib_Rec);
}

const GLubyte * FASTCALL __glle_EvalMesh1(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_EvalMesh1_Rec *data;

    data = (struct __gllc_EvalMesh1_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glEvalMesh1)(data->mode, data->i1, data->i2);
    return PC + sizeof(struct __gllc_EvalMesh1_Rec);
}

const GLubyte * FASTCALL __glle_EvalPoint1(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_EvalPoint1_Rec *data;

    data = (struct __gllc_EvalPoint1_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glEvalPoint1)(data->i);
    return PC + sizeof(struct __gllc_EvalPoint1_Rec);
}

const GLubyte * FASTCALL __glle_EvalMesh2(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_EvalMesh2_Rec *data;

    data = (struct __gllc_EvalMesh2_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glEvalMesh2)(data->mode, data->i1, data->i2, data->j1, 
	    data->j2);
    return PC + sizeof(struct __gllc_EvalMesh2_Rec);
}

const GLubyte * FASTCALL __glle_EvalPoint2(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_EvalPoint2_Rec *data;

    data = (struct __gllc_EvalPoint2_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glEvalPoint2)(data->i, data->j);
    return PC + sizeof(struct __gllc_EvalPoint2_Rec);
}

const GLubyte * FASTCALL __glle_AlphaFunc(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_AlphaFunc_Rec *data;

    data = (struct __gllc_AlphaFunc_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glAlphaFunc)(data->func, data->ref);
    return PC + sizeof(struct __gllc_AlphaFunc_Rec);
}

const GLubyte * FASTCALL __glle_BlendFunc(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_BlendFunc_Rec *data;

    data = (struct __gllc_BlendFunc_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glBlendFunc)(data->sfactor, data->dfactor);
    return PC + sizeof(struct __gllc_BlendFunc_Rec);
}

const GLubyte * FASTCALL __glle_LogicOp(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_LogicOp_Rec *data;

    data = (struct __gllc_LogicOp_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glLogicOp)(data->opcode);
    return PC + sizeof(struct __gllc_LogicOp_Rec);
}

const GLubyte * FASTCALL __glle_StencilFunc(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_StencilFunc_Rec *data;

    data = (struct __gllc_StencilFunc_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glStencilFunc)(data->func, data->ref, data->mask);
    return PC + sizeof(struct __gllc_StencilFunc_Rec);
}

const GLubyte * FASTCALL __glle_StencilOp(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_StencilOp_Rec *data;

    data = (struct __gllc_StencilOp_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glStencilOp)(data->fail, data->zfail, data->zpass);
    return PC + sizeof(struct __gllc_StencilOp_Rec);
}

const GLubyte * FASTCALL __glle_DepthFunc(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_DepthFunc_Rec *data;

    data = (struct __gllc_DepthFunc_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glDepthFunc)(data->func);
    return PC + sizeof(struct __gllc_DepthFunc_Rec);
}

const GLubyte * FASTCALL __glle_PixelZoom(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PixelZoom_Rec *data;

    data = (struct __gllc_PixelZoom_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPixelZoom)(data->xfactor, data->yfactor);
    return PC + sizeof(struct __gllc_PixelZoom_Rec);
}

const GLubyte * FASTCALL __glle_PixelTransferf(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PixelTransferf_Rec *data;

    data = (struct __gllc_PixelTransferf_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPixelTransferf)(data->pname, data->param);
    return PC + sizeof(struct __gllc_PixelTransferf_Rec);
}

const GLubyte * FASTCALL __glle_PixelTransferi(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PixelTransferi_Rec *data;

    data = (struct __gllc_PixelTransferi_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPixelTransferi)(data->pname, data->param);
    return PC + sizeof(struct __gllc_PixelTransferi_Rec);
}

const GLubyte * FASTCALL __glle_PixelMapfv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_PixelMapfv_Rec *data;

    data = (struct __gllc_PixelMapfv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPixelMapfv)(data->map, data->mapsize, 
	    (GLfloat *) (PC + sizeof(struct __gllc_PixelMapfv_Rec)));
    arraySize = data->mapsize * 4;
    size = sizeof(struct __gllc_PixelMapfv_Rec) + arraySize;
    return PC + size;
}

const GLubyte * FASTCALL __glle_PixelMapuiv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_PixelMapuiv_Rec *data;

    data = (struct __gllc_PixelMapuiv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPixelMapuiv)(data->map, data->mapsize, 
	    (GLuint *) (PC + sizeof(struct __gllc_PixelMapuiv_Rec)));
    arraySize = data->mapsize * 4;
    size = sizeof(struct __gllc_PixelMapuiv_Rec) + arraySize;
    return PC + size;
}

const GLubyte * FASTCALL __glle_PixelMapusv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_PixelMapusv_Rec *data;

    data = (struct __gllc_PixelMapusv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPixelMapusv)(data->map, data->mapsize, 
	    (GLushort *) (PC + sizeof(struct __gllc_PixelMapusv_Rec)));
    arraySize = __GL_PAD(data->mapsize * 2);
    size = sizeof(struct __gllc_PixelMapusv_Rec) + arraySize;
    return PC + size;
}

const GLubyte * FASTCALL __glle_ReadBuffer(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ReadBuffer_Rec *data;

    data = (struct __gllc_ReadBuffer_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glReadBuffer)(data->mode);
    return PC + sizeof(struct __gllc_ReadBuffer_Rec);
}

const GLubyte * FASTCALL __glle_CopyPixels(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_CopyPixels_Rec *data;

    data = (struct __gllc_CopyPixels_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glCopyPixels)(data->x, data->y, data->width, data->height, 
	    data->type);
    return PC + sizeof(struct __gllc_CopyPixels_Rec);
}

const GLubyte * FASTCALL __glle_DepthRange(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_DepthRange_Rec *data;

    data = (struct __gllc_DepthRange_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glDepthRange)(data->zNear, data->zFar);
    return PC + sizeof(struct __gllc_DepthRange_Rec);
}

const GLubyte * FASTCALL __glle_Frustum(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Frustum_Rec *data;

    data = (struct __gllc_Frustum_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glFrustum)(data->left, data->right, data->bottom, data->top, 
	    data->zNear, data->zFar);
    return PC + sizeof(struct __gllc_Frustum_Rec);
}

const GLubyte * FASTCALL __glle_LoadIdentity(__GLcontext *gc, const GLubyte *PC)
{

    (*gc->savedCltProcTable.glDispatchTable.glLoadIdentity)();
    return PC;
}

const GLubyte * FASTCALL __glle_MatrixMode(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_MatrixMode_Rec *data;

    data = (struct __gllc_MatrixMode_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glMatrixMode)(data->mode);
    return PC + sizeof(struct __gllc_MatrixMode_Rec);
}

const GLubyte * FASTCALL __glle_Ortho(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Ortho_Rec *data;

    data = (struct __gllc_Ortho_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glOrtho)(data->left, data->right, data->bottom, data->top, 
	    data->zNear, data->zFar);
    return PC + sizeof(struct __gllc_Ortho_Rec);
}

const GLubyte * FASTCALL __glle_PopMatrix(__GLcontext *gc, const GLubyte *PC)
{

    (*gc->savedCltProcTable.glDispatchTable.glPopMatrix)();
    return PC;
}

const GLubyte * FASTCALL __glle_PushMatrix(__GLcontext *gc, const GLubyte *PC)
{

    (*gc->savedCltProcTable.glDispatchTable.glPushMatrix)();
    return PC;
}

const GLubyte * FASTCALL __glle_Viewport(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Viewport_Rec *data;

    data = (struct __gllc_Viewport_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glViewport)(data->x, data->y, data->width, data->height);
    return PC + sizeof(struct __gllc_Viewport_Rec);
}

const GLubyte * FASTCALL __glle_BindTexture(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_BindTexture_Rec *data;

    data = (struct __gllc_BindTexture_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glBindTexture)(data->target, data->texture);
    return PC + sizeof(struct __gllc_BindTexture_Rec);
}

const GLubyte * FASTCALL __glle_PrioritizeTextures(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PrioritizeTextures_Rec *data;

    data = (struct __gllc_PrioritizeTextures_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPrioritizeTextures)
        (data->n,
         (const GLuint *)(PC + sizeof(struct __gllc_PrioritizeTextures_Rec)),
         (const GLclampf *)(PC + sizeof(struct __gllc_PrioritizeTextures_Rec)+
                            data->n*sizeof(GLuint)));
    return PC + sizeof(struct __gllc_PrioritizeTextures_Rec) +
	    data->n*(sizeof(GLuint)+sizeof(GLclampf));
}

const GLubyte * FASTCALL __glle_CopyTexImage1D(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_CopyTexImage1D_Rec *data;

    data = (struct __gllc_CopyTexImage1D_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glCopyTexImage1D)(data->target, data->level, data->internalformat, data->x, data->y, data->width, data->border);
    return PC + sizeof(struct __gllc_CopyTexImage1D_Rec);
}

const GLubyte * FASTCALL __glle_CopyTexImage2D(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_CopyTexImage2D_Rec *data;

    data = (struct __gllc_CopyTexImage2D_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glCopyTexImage2D)(data->target, data->level, data->internalformat, data->x, data->y, data->width, data->height, data->border);
    return PC + sizeof(struct __gllc_CopyTexImage2D_Rec);
}

const GLubyte * FASTCALL __glle_CopyTexSubImage1D(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_CopyTexSubImage1D_Rec *data;

    data = (struct __gllc_CopyTexSubImage1D_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glCopyTexSubImage1D)(data->target, data->level, data->xoffset, data->x, data->y, data->width);
    return PC + sizeof(struct __gllc_CopyTexSubImage1D_Rec);
}

const GLubyte * FASTCALL __glle_CopyTexSubImage2D(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_CopyTexSubImage2D_Rec *data;

    data = (struct __gllc_CopyTexSubImage2D_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glCopyTexSubImage2D)(data->target, data->level, data->xoffset, data->yoffset, data->x, data->y, data->width, data->height);
    return PC + sizeof(struct __gllc_CopyTexSubImage2D_Rec);
}

const GLubyte * FASTCALL __glle_PolygonOffset(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PolygonOffset_Rec *data;

    data = (struct __gllc_PolygonOffset_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPolygonOffset)(data->factor, data->units);
    return PC + sizeof(struct __gllc_PolygonOffset_Rec);
}

#ifdef GL_WIN_multiple_textures
const GLubyte * FASTCALL __glle_CurrentTextureIndexWIN(__GLcontext *gc,
                                                       const GLubyte *PC)
{
    struct __gllc_CurrentTextureIndexWIN_Rec *data;

    data = (struct __gllc_CurrentTextureIndexWIN_Rec *) PC;
    (*gc->savedExtProcTable.glDispatchTable.glCurrentTextureIndexWIN)
        (data->index);
    return PC + sizeof(struct __gllc_CurrentTextureIndexWIN_Rec);
}

const GLubyte * FASTCALL __glle_BindNthTextureWIN(__GLcontext *gc,
                                                  const GLubyte *PC)
{
    struct __gllc_BindNthTextureWIN_Rec *data;

    data = (struct __gllc_BindNthTextureWIN_Rec *) PC;
    (*gc->savedExtProcTable.glDispatchTable.glBindNthTextureWIN)
        (data->index, data->target, data->texture);
    return PC + sizeof(struct __gllc_BindNthTextureWIN_Rec);
}

const GLubyte * FASTCALL __glle_NthTexCombineFuncWIN(__GLcontext *gc,
                                                     const GLubyte *PC)
{
    struct __gllc_NthTexCombineFuncWIN_Rec *data;

    data = (struct __gllc_NthTexCombineFuncWIN_Rec *) PC;
    (*gc->savedExtProcTable.glDispatchTable.glNthTexCombineFuncWIN)
        (data->index, data->leftColorFactor, data->colorOp,
         data->rightColorFactor, data->leftAlphaFactor, data->alphaOp,
         data->leftAlphaFactor);
    return PC + sizeof(struct __gllc_NthTexCombineFuncWIN_Rec);
}
#endif // GL_WIN_multiple_textures
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\dlist\dl_lcomp.c ===
/******************************Module*Header*******************************\
* Module Name: dl_lcomp.c
*
* Display list compilation routines.
*
* Created: 12-24-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995-96 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

/*
** Compilation routines for building display lists for all of the basic
** OpenGL commands.  These were automatically generated at one point, 
** but now the basic format has stabilized, and we make minor changes to
** individual routines from time to time.
*/

/***************************************************************************/
// Color functions.
// Compile only Color3ub, Color3f, Color4ub, and Color4f functions.
// Convert the other functions to one of the compiled Color functions.

void APIENTRY
__gllc_Color3ub ( IN GLubyte red, IN GLubyte green, IN GLubyte blue )
{
    struct __gllc_Color3ubv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glColor3ub)(red, green, blue);

	// Record "otherColor" here
	if (gc->modes.colorIndexMode)
	{
	    gc->dlist.beginRec->flags |= DLIST_BEGIN_HAS_OTHER_COLOR;
	    gc->dlist.beginRec->otherColor = gc->paTeb->otherColor;
	}
	return;
    }

    data = (struct __gllc_Color3ubv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Color3ubv_Rec)),
                                DLIST_GENERIC_OP(Color3ubv));
    if (data == NULL) return;
    data->v[0] = red;
    data->v[1] = green;
    data->v[2] = blue;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_COLOR;
#endif
    __glDlistAppendOp(gc, data, __glle_Color3ubv);
}

void APIENTRY
__gllc_Color3ubv ( IN const GLubyte v[3] )
{
    __gllc_Color3ub(v[0], v[1], v[2]);
}

void APIENTRY
__gllc_Color3f ( IN GLfloat red, IN GLfloat green, IN GLfloat blue )
{
    struct __gllc_Color3fv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glColor3f)(red, green, blue);

	// Record "otherColor" here
	if (gc->modes.colorIndexMode)
	{
	    gc->dlist.beginRec->flags |= DLIST_BEGIN_HAS_OTHER_COLOR;
	    gc->dlist.beginRec->otherColor = gc->paTeb->otherColor;
	}
	return;
    }

    data = (struct __gllc_Color3fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Color3fv_Rec)),
                                DLIST_GENERIC_OP(Color3fv));
    if (data == NULL) return;
    data->v[0] = red;
    data->v[1] = green;
    data->v[2] = blue;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_COLOR;
#endif
    __glDlistAppendOp(gc, data, __glle_Color3fv);
}

void APIENTRY
__gllc_Color3fv ( IN const GLfloat v[3] )
{
    __gllc_Color3f(v[0], v[1], v[2]);
}

void APIENTRY
__gllc_Color3b ( IN GLbyte red, IN GLbyte green, IN GLbyte blue )
{
    __gllc_Color3f(__GL_B_TO_FLOAT(red), __GL_B_TO_FLOAT(green),
	           __GL_B_TO_FLOAT(blue));
}

void APIENTRY
__gllc_Color3bv ( IN const GLbyte v[3] )
{
    __gllc_Color3f(__GL_B_TO_FLOAT(v[0]), __GL_B_TO_FLOAT(v[1]),
	           __GL_B_TO_FLOAT(v[2]));
}

void APIENTRY
__gllc_Color3d ( IN GLdouble red, IN GLdouble green, IN GLdouble blue )
{
    __gllc_Color3f((GLfloat) red, (GLfloat) green, (GLfloat) blue);
}

void APIENTRY
__gllc_Color3dv ( IN const GLdouble v[3] )
{
    __gllc_Color3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_Color3i ( IN GLint red, IN GLint green, IN GLint blue )
{
    __gllc_Color3f(__GL_I_TO_FLOAT(red), __GL_I_TO_FLOAT(green),
		   __GL_I_TO_FLOAT(blue));
}

void APIENTRY
__gllc_Color3iv ( IN const GLint v[3] )
{
    __gllc_Color3f(__GL_I_TO_FLOAT(v[0]), __GL_I_TO_FLOAT(v[1]),
		   __GL_I_TO_FLOAT(v[2]));
}

void APIENTRY
__gllc_Color3s ( IN GLshort red, IN GLshort green, IN GLshort blue )
{
    __gllc_Color3f(__GL_S_TO_FLOAT(red), __GL_S_TO_FLOAT(green),
		   __GL_S_TO_FLOAT(blue));
}

void APIENTRY
__gllc_Color3sv ( IN const GLshort v[3] )
{
    __gllc_Color3f(__GL_S_TO_FLOAT(v[0]), __GL_S_TO_FLOAT(v[1]),
		   __GL_S_TO_FLOAT(v[2]));
}

void APIENTRY
__gllc_Color3ui ( IN GLuint red, IN GLuint green, IN GLuint blue )
{
    __gllc_Color3f(__GL_UI_TO_FLOAT(red), __GL_UI_TO_FLOAT(green),
		   __GL_UI_TO_FLOAT(blue));
}

void APIENTRY
__gllc_Color3uiv ( IN const GLuint v[3] )
{
    __gllc_Color3f(__GL_UI_TO_FLOAT(v[0]), __GL_UI_TO_FLOAT(v[1]),
		   __GL_UI_TO_FLOAT(v[2]));
}

void APIENTRY
__gllc_Color3us ( IN GLushort red, IN GLushort green, IN GLushort blue )
{
    __gllc_Color3f(__GL_US_TO_FLOAT(red), __GL_US_TO_FLOAT(green),
		   __GL_US_TO_FLOAT(blue));
}

void APIENTRY
__gllc_Color3usv ( IN const GLushort v[3] )
{
    __gllc_Color3f(__GL_US_TO_FLOAT(v[0]), __GL_US_TO_FLOAT(v[1]),
		   __GL_US_TO_FLOAT(v[2]));
}

void APIENTRY
__gllc_Color4ub ( IN GLubyte red, IN GLubyte green, IN GLubyte blue, IN GLubyte alpha )
{
    struct __gllc_Color4ubv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glColor4ub)(red, green, blue, alpha);

	// Record "otherColor" here
	if (gc->modes.colorIndexMode)
	{
	    gc->dlist.beginRec->flags |= DLIST_BEGIN_HAS_OTHER_COLOR;
	    gc->dlist.beginRec->otherColor = gc->paTeb->otherColor;
	}
	return;
    }

    data = (struct __gllc_Color4ubv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Color4ubv_Rec)),
                                DLIST_GENERIC_OP(Color4ubv));
    if (data == NULL) return;
    data->v[0] = red;
    data->v[1] = green;
    data->v[2] = blue;
    data->v[3] = alpha;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_COLOR;
#endif
    __glDlistAppendOp(gc, data, __glle_Color4ubv);
}

void APIENTRY
__gllc_Color4ubv ( IN const GLubyte v[4] )
{
    __gllc_Color4ub(v[0], v[1], v[2], v[3]);
}

void APIENTRY
__gllc_Color4f ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    struct __gllc_Color4fv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glColor4f)(red, green, blue, alpha);

	// Record "otherColor" here
	if (gc->modes.colorIndexMode)
	{
	    gc->dlist.beginRec->flags |= DLIST_BEGIN_HAS_OTHER_COLOR;
	    gc->dlist.beginRec->otherColor = gc->paTeb->otherColor;
	}
	return;
    }

    data = (struct __gllc_Color4fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Color4fv_Rec)),
                                DLIST_GENERIC_OP(Color4fv));
    if (data == NULL) return;
    data->v[0] = red;
    data->v[1] = green;
    data->v[2] = blue;
    data->v[3] = alpha;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_COLOR;
#endif
    __glDlistAppendOp(gc, data, __glle_Color4fv);
}

void APIENTRY
__gllc_Color4fv ( IN const GLfloat v[4] )
{
    __gllc_Color4f(v[0], v[1], v[2], v[3]);
}

void APIENTRY
__gllc_Color4b ( IN GLbyte red, IN GLbyte green, IN GLbyte blue, IN GLbyte alpha )
{
    __gllc_Color4f(__GL_B_TO_FLOAT(red),  __GL_B_TO_FLOAT(green),
	           __GL_B_TO_FLOAT(blue), __GL_B_TO_FLOAT(alpha));
}

void APIENTRY
__gllc_Color4bv ( IN const GLbyte v[4] )
{
    __gllc_Color4f(__GL_B_TO_FLOAT(v[0]), __GL_B_TO_FLOAT(v[1]),
	           __GL_B_TO_FLOAT(v[2]), __GL_B_TO_FLOAT(v[3]));
}

void APIENTRY
__gllc_Color4d ( IN GLdouble red, IN GLdouble green, IN GLdouble blue, IN GLdouble alpha )
{
    __gllc_Color4f((GLfloat) red, (GLfloat) green, (GLfloat) blue, (GLfloat) alpha);
}

void APIENTRY
__gllc_Color4dv ( IN const GLdouble v[4] )
{
    __gllc_Color4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
__gllc_Color4i ( IN GLint red, IN GLint green, IN GLint blue, IN GLint alpha )
{
    __gllc_Color4f(__GL_I_TO_FLOAT(red),  __GL_I_TO_FLOAT(green),
	           __GL_I_TO_FLOAT(blue), __GL_I_TO_FLOAT(alpha));
}

void APIENTRY
__gllc_Color4iv ( IN const GLint v[4] )
{
    __gllc_Color4f(__GL_I_TO_FLOAT(v[0]), __GL_I_TO_FLOAT(v[1]),
	           __GL_I_TO_FLOAT(v[2]), __GL_I_TO_FLOAT(v[3]));
}

void APIENTRY
__gllc_Color4s ( IN GLshort red, IN GLshort green, IN GLshort blue, IN GLshort alpha )
{
    __gllc_Color4f(__GL_S_TO_FLOAT(red),  __GL_S_TO_FLOAT(green),
	           __GL_S_TO_FLOAT(blue), __GL_S_TO_FLOAT(alpha));
}

void APIENTRY
__gllc_Color4sv ( IN const GLshort v[4] )
{
    __gllc_Color4f(__GL_S_TO_FLOAT(v[0]), __GL_S_TO_FLOAT(v[1]),
	           __GL_S_TO_FLOAT(v[2]), __GL_S_TO_FLOAT(v[3]));
}

void APIENTRY
__gllc_Color4ui ( IN GLuint red, IN GLuint green, IN GLuint blue, IN GLuint alpha )
{
    __gllc_Color4f(__GL_UI_TO_FLOAT(red),  __GL_UI_TO_FLOAT(green),
	           __GL_UI_TO_FLOAT(blue), __GL_UI_TO_FLOAT(alpha));
}

void APIENTRY
__gllc_Color4uiv ( IN const GLuint v[4] )
{
    __gllc_Color4f(__GL_UI_TO_FLOAT(v[0]), __GL_UI_TO_FLOAT(v[1]),
	           __GL_UI_TO_FLOAT(v[2]), __GL_UI_TO_FLOAT(v[3]));
}

void APIENTRY
__gllc_Color4us ( IN GLushort red, IN GLushort green, IN GLushort blue, IN GLushort alpha )
{
    __gllc_Color4f(__GL_US_TO_FLOAT(red),  __GL_US_TO_FLOAT(green),
	           __GL_US_TO_FLOAT(blue), __GL_US_TO_FLOAT(alpha));
}

void APIENTRY
__gllc_Color4usv ( IN const GLushort v[4] )
{
    __gllc_Color4f(__GL_US_TO_FLOAT(v[0]), __GL_US_TO_FLOAT(v[1]),
	           __GL_US_TO_FLOAT(v[2]), __GL_US_TO_FLOAT(v[3]));
}

/***************************************************************************/
// EdgeFlag functions.
// Compile only EdgeFlag function.
// Convert the other function to the compiled EdgeFlag function.

void APIENTRY
__gllc_EdgeFlag ( IN GLboolean flag )
{
    struct __gllc_EdgeFlag_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glEdgeFlag)(flag);
	return;
    }

    data = (struct __gllc_EdgeFlag_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_EdgeFlag_Rec)),
                                DLIST_GENERIC_OP(EdgeFlag));
    if (data == NULL) return;
    data->flag = flag;
    __glDlistAppendOp(gc, data, __glle_EdgeFlag);
}

void APIENTRY
__gllc_EdgeFlagv ( IN const GLboolean flag[1] )
{
    __gllc_EdgeFlag(flag[0]);
}

/***************************************************************************/
// Index functions.
// Compile only Indexf function.
// Convert the other functions to the compiled Indexf function.

void APIENTRY
__gllc_Indexf ( IN GLfloat c )
{
    struct __gllc_Indexf_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glIndexf)(c);

	// Record "otherColor" here
	if (!gc->modes.colorIndexMode)
	{
	    gc->dlist.beginRec->flags |= DLIST_BEGIN_HAS_OTHER_COLOR;
	    gc->dlist.beginRec->otherColor.r = gc->paTeb->otherColor.r;
	}
	return;
    }

    data = (struct __gllc_Indexf_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Indexf_Rec)),
                                DLIST_GENERIC_OP(Indexf));
    if (data == NULL) return;
    data->c = c;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_INDEX;
#endif
    __glDlistAppendOp(gc, data, __glle_Indexf);
}

void APIENTRY
__gllc_Indexfv ( IN const GLfloat c[1] )
{
    __gllc_Indexf(c[0]);
}

void APIENTRY
__gllc_Indexd ( IN GLdouble c )
{
    __gllc_Indexf((GLfloat) c);
}

void APIENTRY
__gllc_Indexdv ( IN const GLdouble c[1] )
{
    __gllc_Indexf((GLfloat) c[0]);
}

void APIENTRY
__gllc_Indexi ( IN GLint c )
{
    __gllc_Indexf((GLfloat) c);
}

void APIENTRY
__gllc_Indexiv ( IN const GLint c[1] )
{
    __gllc_Indexf((GLfloat) c[0]);
}

void APIENTRY
__gllc_Indexs ( IN GLshort c )
{
    __gllc_Indexf((GLfloat) c);
}

void APIENTRY
__gllc_Indexsv ( IN const GLshort c[1] )
{
    __gllc_Indexf((GLfloat) c[0]);
}

void APIENTRY
__gllc_Indexub ( IN GLubyte c )
{
    __gllc_Indexf((GLfloat) c);
}

void APIENTRY
__gllc_Indexubv ( IN const GLubyte c[1] )
{
    __gllc_Indexf((GLfloat) c[0]);
}

/***************************************************************************/
// Normal functions.
// Compile only Normal3b and Normal3f functions.
// Convert the other functions to one of the compiled Normal functions.

void APIENTRY
__gllc_Normal3b ( IN GLbyte nx, IN GLbyte ny, IN GLbyte nz )
{
    struct __gllc_Normal3bv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glNormal3b)(nx, ny, nz);
	return;
    }

    data = (struct __gllc_Normal3bv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Normal3bv_Rec)),
                                DLIST_GENERIC_OP(Normal3bv));
    if (data == NULL) return;
    data->v[0] = nx;
    data->v[1] = ny;
    data->v[2] = nz;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_NORMAL;
#endif
    __glDlistAppendOp(gc, data, __glle_Normal3bv);
}

void APIENTRY
__gllc_Normal3bv ( IN const GLbyte v[3] )
{
    __gllc_Normal3b(v[0], v[1], v[2]);
}

void APIENTRY
__gllc_Normal3f ( IN GLfloat nx, IN GLfloat ny, IN GLfloat nz )
{
    struct __gllc_Normal3fv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glNormal3f)(nx, ny, nz);
	return;
    }

    data = (struct __gllc_Normal3fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Normal3fv_Rec)),
                                DLIST_GENERIC_OP(Normal3fv));
    if (data == NULL) return;
    data->v[0] = nx;
    data->v[1] = ny;
    data->v[2] = nz;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_NORMAL;
#endif
    __glDlistAppendOp(gc, data, __glle_Normal3fv);
}

void APIENTRY
__gllc_Normal3fv ( IN const GLfloat v[3] )
{
    __gllc_Normal3f(v[0], v[1], v[2]);
}

void APIENTRY
__gllc_Normal3d ( IN GLdouble nx, IN GLdouble ny, IN GLdouble nz )
{
    __gllc_Normal3f((GLfloat) nx, (GLfloat) ny, (GLfloat) nz);
}

void APIENTRY
__gllc_Normal3dv ( IN const GLdouble v[3] )
{
    __gllc_Normal3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_Normal3i ( IN GLint nx, IN GLint ny, IN GLint nz )
{
    __gllc_Normal3f(__GL_I_TO_FLOAT(nx), __GL_I_TO_FLOAT(ny),
		    __GL_I_TO_FLOAT(nz));
}

void APIENTRY
__gllc_Normal3iv ( IN const GLint v[3] )
{
    __gllc_Normal3f(__GL_I_TO_FLOAT(v[0]), __GL_I_TO_FLOAT(v[1]),
		    __GL_I_TO_FLOAT(v[2]));
}

void APIENTRY
__gllc_Normal3s ( IN GLshort nx, IN GLshort ny, IN GLshort nz )
{
    __gllc_Normal3f(__GL_S_TO_FLOAT(nx), __GL_S_TO_FLOAT(ny),
		    __GL_S_TO_FLOAT(nz));
}

void APIENTRY
__gllc_Normal3sv ( IN const GLshort v[3] )
{
    __gllc_Normal3f(__GL_S_TO_FLOAT(v[0]), __GL_S_TO_FLOAT(v[1]),
		    __GL_S_TO_FLOAT(v[2]));
}

/***************************************************************************/
// RasterPos functions.
// Compile only RasterPos2f, RasterPos3f and RasterPos4f functions.
// Convert the other functions to one of the compiled RasterPos functions.

void APIENTRY
__gllc_RasterPos2f ( IN GLfloat x, IN GLfloat y )
{
    struct __gllc_RasterPos2f_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_RasterPos2f_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_RasterPos2f_Rec)),
                                DLIST_GENERIC_OP(RasterPos2f));
    if (data == NULL) return;
    data->x = x;
    data->y = y;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_RASTERPOS;
#endif
    __glDlistAppendOp(gc, data, __glle_RasterPos2f);
}

void APIENTRY
__gllc_RasterPos2fv ( IN const GLfloat v[2] )
{
    __gllc_RasterPos2f(v[0], v[1]);
}

void APIENTRY
__gllc_RasterPos2d ( IN GLdouble x, IN GLdouble y )
{
    __gllc_RasterPos2f((GLfloat) x, (GLfloat) y);
}

void APIENTRY
__gllc_RasterPos2dv ( IN const GLdouble v[2] )
{
    __gllc_RasterPos2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_RasterPos2i ( IN GLint x, IN GLint y )
{
    __gllc_RasterPos2f((GLfloat) x, (GLfloat) y);
}

void APIENTRY
__gllc_RasterPos2iv ( IN const GLint v[2] )
{
    __gllc_RasterPos2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_RasterPos2s ( IN GLshort x, IN GLshort y )
{
    __gllc_RasterPos2f((GLfloat) x, (GLfloat) y);
}

void APIENTRY
__gllc_RasterPos2sv ( IN const GLshort v[2] )
{
    __gllc_RasterPos2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_RasterPos3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    struct __gllc_RasterPos3fv_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_RasterPos3fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_RasterPos3fv_Rec)),
                                DLIST_GENERIC_OP(RasterPos3fv));
    if (data == NULL) return;
    data->v[0] = x;
    data->v[1] = y;
    data->v[2] = z;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_RASTERPOS;
#endif
    __glDlistAppendOp(gc, data, __glle_RasterPos3fv);
}

void APIENTRY
__gllc_RasterPos3fv ( IN const GLfloat v[3] )
{
    __gllc_RasterPos3f(v[0], v[1], v[2]);
}

void APIENTRY
__gllc_RasterPos3d ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    __gllc_RasterPos3f((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
__gllc_RasterPos3dv ( IN const GLdouble v[3] )
{
    __gllc_RasterPos3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_RasterPos3i ( IN GLint x, IN GLint y, IN GLint z )
{
    __gllc_RasterPos3f((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
__gllc_RasterPos3iv ( IN const GLint v[3] )
{
    __gllc_RasterPos3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_RasterPos3s ( IN GLshort x, IN GLshort y, IN GLshort z )
{
    __gllc_RasterPos3f((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
__gllc_RasterPos3sv ( IN const GLshort v[3] )
{
    __gllc_RasterPos3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_RasterPos4f ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w )
{
    struct __gllc_RasterPos4fv_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_RasterPos4fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_RasterPos4fv_Rec)),
                                DLIST_GENERIC_OP(RasterPos4fv));
    if (data == NULL) return;
    data->v[0] = x;
    data->v[1] = y;
    data->v[2] = z;
    data->v[3] = w;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_RASTERPOS;
#endif
    __glDlistAppendOp(gc, data, __glle_RasterPos4fv);
}

void APIENTRY
__gllc_RasterPos4fv ( IN const GLfloat v[4] )
{
    __gllc_RasterPos4f(v[0], v[1], v[2], v[3]);
}

void APIENTRY
__gllc_RasterPos4d ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w )
{
    __gllc_RasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
__gllc_RasterPos4dv ( IN const GLdouble v[4] )
{
    __gllc_RasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
__gllc_RasterPos4i ( IN GLint x, IN GLint y, IN GLint z, IN GLint w )
{
    __gllc_RasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
__gllc_RasterPos4iv ( IN const GLint v[4] )
{
    __gllc_RasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
__gllc_RasterPos4s ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w )
{
    __gllc_RasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
__gllc_RasterPos4sv ( IN const GLshort v[4] )
{
    __gllc_RasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

/***************************************************************************/
// Rect functions.
// Compile only Rectf function.
// Convert the other functions to the compiled Rectf function.

void APIENTRY
__gllc_Rectf ( IN GLfloat x1, IN GLfloat y1, IN GLfloat x2, IN GLfloat y2 )
{
    struct __gllc_Rectf_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Rectf_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Rectf_Rec)),
                                DLIST_GENERIC_OP(Rectf));
    if (data == NULL) return;
    data->x1 = x1;
    data->y1 = y1;
    data->x2 = x2;
    data->y2 = y2;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_RECT;
#endif
    __glDlistAppendOp(gc, data, __glle_Rectf);
}

void APIENTRY
__gllc_Rectfv ( IN const GLfloat v1[2], IN const GLfloat v2[2] )
{
    __gllc_Rectf(v1[0], v1[1], v2[0], v2[1]);
}

void APIENTRY
__gllc_Rectd ( IN GLdouble x1, IN GLdouble y1, IN GLdouble x2, IN GLdouble y2 )
{
    __gllc_Rectf((GLfloat) x1, (GLfloat) y1, (GLfloat) x2, (GLfloat) y2);
}

void APIENTRY
__gllc_Rectdv ( IN const GLdouble v1[2], IN const GLdouble v2[2] )
{
    __gllc_Rectf((GLfloat) v1[0], (GLfloat) v1[1], (GLfloat) v2[0], (GLfloat) v2[1]);
}

void APIENTRY
__gllc_Recti ( IN GLint x1, IN GLint y1, IN GLint x2, IN GLint y2 )
{
    __gllc_Rectf((GLfloat) x1, (GLfloat) y1, (GLfloat) x2, (GLfloat) y2);
}

void APIENTRY
__gllc_Rectiv ( IN const GLint v1[2], IN const GLint v2[2] )
{
    __gllc_Rectf((GLfloat) v1[0], (GLfloat) v1[1], (GLfloat) v2[0], (GLfloat) v2[1]);
}

void APIENTRY
__gllc_Rects ( IN GLshort x1, IN GLshort y1, IN GLshort x2, IN GLshort y2 )
{
    __gllc_Rectf((GLfloat) x1, (GLfloat) y1, (GLfloat) x2, (GLfloat) y2);
}

void APIENTRY
__gllc_Rectsv ( IN const GLshort v1[2], IN const GLshort v2[2] )
{
    __gllc_Rectf((GLfloat) v1[0], (GLfloat) v1[1], (GLfloat) v2[0], (GLfloat) v2[1]);
}

/***************************************************************************/
// TexCoord functions.
// Compile only TexCoord1f, TexCoord2f, TexCoord3f and TexCoord4f functions.
// Convert the other functions to one of the compiled TexCoord functions.

void APIENTRY
__gllc_TexCoord1f ( IN GLfloat s )
{
    struct __gllc_TexCoord1f_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glTexCoord1f)(s);
	return;
    }

    data = (struct __gllc_TexCoord1f_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_TexCoord1f_Rec)),
                                DLIST_GENERIC_OP(TexCoord1f));
    if (data == NULL) return;
    data->s = s;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_TEXCOORDS;
#endif
    __glDlistAppendOp(gc, data, __glle_TexCoord1f);
}

void APIENTRY
__gllc_TexCoord1fv ( IN const GLfloat v[1] )
{
    __gllc_TexCoord1f(v[0]);
}

void APIENTRY
__gllc_TexCoord1d ( IN GLdouble s )
{
    __gllc_TexCoord1f((GLfloat) s);
}

void APIENTRY
__gllc_TexCoord1dv ( IN const GLdouble v[1] )
{
    __gllc_TexCoord1f((GLfloat) v[0]);
}

void APIENTRY
__gllc_TexCoord1i ( IN GLint s )
{
    __gllc_TexCoord1f((GLfloat) s);
}

void APIENTRY
__gllc_TexCoord1iv ( IN const GLint v[1] )
{
    __gllc_TexCoord1f((GLfloat) v[0]);
}

void APIENTRY
__gllc_TexCoord1s ( IN GLshort s )
{
    __gllc_TexCoord1f((GLfloat) s);
}

void APIENTRY
__gllc_TexCoord1sv ( IN const GLshort v[1] )
{
    __gllc_TexCoord1f((GLfloat) v[0]);
}

void APIENTRY
__gllc_TexCoord2f ( IN GLfloat s, IN GLfloat t )
{
    struct __gllc_TexCoord2f_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glTexCoord2f)(s, t);
	return;
    }

    data = (struct __gllc_TexCoord2f_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_TexCoord2f_Rec)),
                                DLIST_GENERIC_OP(TexCoord2f));
    if (data == NULL) return;
    data->s = s;
    data->t = t;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_TEXCOORDS;
#endif
    __glDlistAppendOp(gc, data, __glle_TexCoord2f);
}

void APIENTRY
__gllc_TexCoord2fv ( IN const GLfloat v[2] )
{
    __gllc_TexCoord2f(v[0], v[1]);
}

void APIENTRY
__gllc_TexCoord2d ( IN GLdouble s, IN GLdouble t )
{
    __gllc_TexCoord2f((GLfloat) s, (GLfloat) t);
}

void APIENTRY
__gllc_TexCoord2dv ( IN const GLdouble v[2] )
{
    __gllc_TexCoord2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_TexCoord2i ( IN GLint s, IN GLint t )
{
    __gllc_TexCoord2f((GLfloat) s, (GLfloat) t);
}

void APIENTRY
__gllc_TexCoord2iv ( IN const GLint v[2] )
{
    __gllc_TexCoord2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_TexCoord2s ( IN GLshort s, IN GLshort t )
{
    __gllc_TexCoord2f((GLfloat) s, (GLfloat) t);
}

void APIENTRY
__gllc_TexCoord2sv ( IN const GLshort v[2] )
{
    __gllc_TexCoord2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_TexCoord3f ( IN GLfloat s, IN GLfloat t, IN GLfloat r )
{
    struct __gllc_TexCoord3fv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glTexCoord3f)(s, t, r);
	return;
    }

    data = (struct __gllc_TexCoord3fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_TexCoord3fv_Rec)),
                                DLIST_GENERIC_OP(TexCoord3fv));
    if (data == NULL) return;
    data->v[0] = s;
    data->v[1] = t;
    data->v[2] = r;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_TEXCOORDS;
#endif
    __glDlistAppendOp(gc, data, __glle_TexCoord3fv);
}

void APIENTRY
__gllc_TexCoord3fv ( IN const GLfloat v[3] )
{
    __gllc_TexCoord3f(v[0], v[1], v[2]);
}

void APIENTRY
__gllc_TexCoord3d ( IN GLdouble s, IN GLdouble t, IN GLdouble r )
{
    __gllc_TexCoord3f((GLfloat) s, (GLfloat) t, (GLfloat) r);
}

void APIENTRY
__gllc_TexCoord3dv ( IN const GLdouble v[3] )
{
    __gllc_TexCoord3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_TexCoord3i ( IN GLint s, IN GLint t, IN GLint r )
{
    __gllc_TexCoord3f((GLfloat) s, (GLfloat) t, (GLfloat) r);
}

void APIENTRY
__gllc_TexCoord3iv ( IN const GLint v[3] )
{
    __gllc_TexCoord3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_TexCoord3s ( IN GLshort s, IN GLshort t, IN GLshort r )
{
    __gllc_TexCoord3f((GLfloat) s, (GLfloat) t, (GLfloat) r);
}

void APIENTRY
__gllc_TexCoord3sv ( IN const GLshort v[3] )
{
    __gllc_TexCoord3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_TexCoord4f ( IN GLfloat s, IN GLfloat t, IN GLfloat r, IN GLfloat q )
{
    struct __gllc_TexCoord4fv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glTexCoord4f)(s, t, r, q);
	return;
    }

    data = (struct __gllc_TexCoord4fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_TexCoord4fv_Rec)),
                                DLIST_GENERIC_OP(TexCoord4fv));
    if (data == NULL) return;
    data->v[0] = s;
    data->v[1] = t;
    data->v[2] = r;
    data->v[3] = q;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_TEXCOORDS;
#endif
    __glDlistAppendOp(gc, data, __glle_TexCoord4fv);
}

void APIENTRY
__gllc_TexCoord4fv ( IN const GLfloat v[4] )
{
    __gllc_TexCoord4f(v[0], v[1], v[2], v[3]);
}

void APIENTRY
__gllc_TexCoord4d ( IN GLdouble s, IN GLdouble t, IN GLdouble r, IN GLdouble q )
{
    __gllc_TexCoord4f((GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
}

void APIENTRY
__gllc_TexCoord4dv ( IN const GLdouble v[4] )
{
    __gllc_TexCoord4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
__gllc_TexCoord4i ( IN GLint s, IN GLint t, IN GLint r, IN GLint q )
{
    __gllc_TexCoord4f((GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
}

void APIENTRY
__gllc_TexCoord4iv ( IN const GLint v[4] )
{
    __gllc_TexCoord4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
__gllc_TexCoord4s ( IN GLshort s, IN GLshort t, IN GLshort r, IN GLshort q )
{
    __gllc_TexCoord4f((GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
}

void APIENTRY
__gllc_TexCoord4sv ( IN const GLshort v[4] )
{
    __gllc_TexCoord4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

#ifdef GL_WIN_multiple_textures
void APIENTRY __gllc_MultiTexCoord1dWIN
    (GLbitfield mask, GLdouble s)
{
}

void APIENTRY __gllc_MultiTexCoord1dvWIN
    (GLbitfield mask, const GLdouble *v)
{
}

void APIENTRY __gllc_MultiTexCoord1fWIN
    (GLbitfield mask, GLfloat s)
{
}

void APIENTRY __gllc_MultiTexCoord1fvWIN
    (GLbitfield mask, const GLfloat *v)
{
}

void APIENTRY __gllc_MultiTexCoord1iWIN
    (GLbitfield mask, GLint s)
{
}

void APIENTRY __gllc_MultiTexCoord1ivWIN
    (GLbitfield mask, const GLint *v)
{
}

void APIENTRY __gllc_MultiTexCoord1sWIN
    (GLbitfield mask, GLshort s)
{
}

void APIENTRY __gllc_MultiTexCoord1svWIN
    (GLbitfield mask, const GLshort *v)
{
}

void APIENTRY __gllc_MultiTexCoord2dWIN
    (GLbitfield mask, GLdouble s, GLdouble t)
{
}

void APIENTRY __gllc_MultiTexCoord2dvWIN
    (GLbitfield mask, const GLdouble *v)
{
}

void APIENTRY __gllc_MultiTexCoord2fWIN
    (GLbitfield mask, GLfloat s, GLfloat t)
{
}

void APIENTRY __gllc_MultiTexCoord2fvWIN
    (GLbitfield mask, const GLfloat *v)
{
}

void APIENTRY __gllc_MultiTexCoord2iWIN
    (GLbitfield mask, GLint s, GLint t)
{
}

void APIENTRY __gllc_MultiTexCoord2ivWIN
    (GLbitfield mask, const GLint *v)
{
}

void APIENTRY __gllc_MultiTexCoord2sWIN
    (GLbitfield mask, GLshort s, GLshort t)
{
}

void APIENTRY __gllc_MultiTexCoord2svWIN
    (GLbitfield mask, const GLshort *v)
{
}

void APIENTRY __gllc_MultiTexCoord3dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r)
{
}

void APIENTRY __gllc_MultiTexCoord3dvWIN
    (GLbitfield mask, const GLdouble *v)
{
}

void APIENTRY __gllc_MultiTexCoord3fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r)
{
}

void APIENTRY __gllc_MultiTexCoord3fvWIN
    (GLbitfield mask, const GLfloat *v)
{
}

void APIENTRY __gllc_MultiTexCoord3iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r)
{
}

void APIENTRY __gllc_MultiTexCoord3ivWIN
    (GLbitfield mask, const GLint *v)
{
}

void APIENTRY __gllc_MultiTexCoord3sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r)
{
}

void APIENTRY __gllc_MultiTexCoord3svWIN
    (GLbitfield mask, const GLshort *v)
{
}

void APIENTRY __gllc_MultiTexCoord4dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
}

void APIENTRY __gllc_MultiTexCoord4dvWIN
    (GLbitfield mask, const GLdouble *v)
{
}

void APIENTRY __gllc_MultiTexCoord4fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
}

void APIENTRY __gllc_MultiTexCoord4fvWIN
    (GLbitfield mask, const GLfloat *v)
{
}

void APIENTRY __gllc_MultiTexCoord4iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r, GLint q)
{
}

void APIENTRY __gllc_MultiTexCoord4ivWIN
    (GLbitfield mask, const GLint *v)
{
}

void APIENTRY __gllc_MultiTexCoord4sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r, GLshort q)
{
}

void APIENTRY __gllc_MultiTexCoord4svWIN
    (GLbitfield mask, const GLshort *v)
{
}
#endif // GL_WIN_multiple_textures

/***************************************************************************/
// Vertex functions.
// Compile only Vertex2f, Vertex3f and Vertex4f functions.
// Convert the other functions to one of the compiled Vertex functions.

void APIENTRY
__gllc_Vertex2f ( IN GLfloat x, IN GLfloat y )
{
    struct __gllc_Vertex2f_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update and record the poly data
// record.

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

	// If we are in COMPILE_AND_EXECUTE mode or there are attribute
	// changes associated with the vertex, process the poly data.
	if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE
	 || pa->pdNextVertex->flags)
	{
	    (*gc->savedCltProcTable.glDispatchTable.glVertex2f)(x, y);
	    __glDlistCompilePolyData(gc, GL_FALSE);
	    return;
	}

	// Otherwise, increment vertex count and compile a Vertex record
	// instead.
	gc->dlist.beginRec->nVertices++;
    }

    data = (struct __gllc_Vertex2f_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Vertex2f_Rec)),
                                DLIST_GENERIC_OP(Vertex2f));
    if (data == NULL) return;
    data->x = x;
    data->y = y;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_VERTEX;
#endif
    __glDlistAppendOp(gc, data, __glle_Vertex2f);
}

void APIENTRY
__gllc_Vertex2fv ( IN const GLfloat v[2] )
{
    __gllc_Vertex2f(v[0], v[1]);
}

void APIENTRY
__gllc_Vertex2d ( IN GLdouble x, IN GLdouble y )
{
    __gllc_Vertex2f((GLfloat) x, (GLfloat) y);
}

void APIENTRY
__gllc_Vertex2dv ( IN const GLdouble v[2] )
{
    __gllc_Vertex2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_Vertex2i ( IN GLint x, IN GLint y )
{
    __gllc_Vertex2f((GLfloat) x, (GLfloat) y);
}

void APIENTRY
__gllc_Vertex2iv ( IN const GLint v[2] )
{
    __gllc_Vertex2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_Vertex2s ( IN GLshort x, IN GLshort y )
{
    __gllc_Vertex2f((GLfloat) x, (GLfloat) y);
}

void APIENTRY
__gllc_Vertex2sv ( IN const GLshort v[2] )
{
    __gllc_Vertex2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_Vertex3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    struct __gllc_Vertex3fv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update and record the poly data
// record.

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

	// If we are in COMPILE_AND_EXECUTE mode or there are attribute
	// changes associated with the vertex, process the poly data.
	if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE
	 || pa->pdNextVertex->flags)
	{
	    (*gc->savedCltProcTable.glDispatchTable.glVertex3f)(x, y, z);
	    __glDlistCompilePolyData(gc, GL_FALSE);
	    return;
	}

	// Otherwise, increment vertex count and compile a Vertex record
	// instead.
	gc->dlist.beginRec->nVertices++;
    }

    data = (struct __gllc_Vertex3fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Vertex3fv_Rec)),
                                DLIST_GENERIC_OP(Vertex3fv));
    if (data == NULL) return;
    data->v[0] = x;
    data->v[1] = y;
    data->v[2] = z;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_VERTEX;
#endif
    __glDlistAppendOp(gc, data, __glle_Vertex3fv);
}

void APIENTRY
__gllc_Vertex3fv ( IN const GLfloat v[3] )
{
    __gllc_Vertex3f(v[0], v[1], v[2]);
}

void APIENTRY
__gllc_Vertex3d ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    __gllc_Vertex3f((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
__gllc_Vertex3dv ( IN const GLdouble v[3] )
{
    __gllc_Vertex3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_Vertex3i ( IN GLint x, IN GLint y, IN GLint z )
{
    __gllc_Vertex3f((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
__gllc_Vertex3iv ( IN const GLint v[3] )
{
    __gllc_Vertex3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_Vertex3s ( IN GLshort x, IN GLshort y, IN GLshort z )
{
    __gllc_Vertex3f((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
__gllc_Vertex3sv ( IN const GLshort v[3] )
{
    __gllc_Vertex3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_Vertex4f ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w )
{
    struct __gllc_Vertex4fv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update and record the poly data
// record.

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

	// If we are in COMPILE_AND_EXECUTE mode or there are attribute
	// changes associated with the vertex, process the poly data.
	if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE
	 || pa->pdNextVertex->flags)
	{
	    (*gc->savedCltProcTable.glDispatchTable.glVertex4f)(x, y, z, w);
	    __glDlistCompilePolyData(gc, GL_FALSE);
	    return;
	}

	// Otherwise, increment vertex count and compile a Vertex record
	// instead.
	gc->dlist.beginRec->nVertices++;
    }

    data = (struct __gllc_Vertex4fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Vertex4fv_Rec)),
                                DLIST_GENERIC_OP(Vertex4fv));
    if (data == NULL) return;
    data->v[0] = x;
    data->v[1] = y;
    data->v[2] = z;
    data->v[3] = w;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_VERTEX;
#endif
    __glDlistAppendOp(gc, data, __glle_Vertex4fv);
}

void APIENTRY
__gllc_Vertex4fv ( IN const GLfloat v[4] )
{
    __gllc_Vertex4f(v[0], v[1], v[2], v[3]);
}

void APIENTRY
__gllc_Vertex4d ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w )
{
    __gllc_Vertex4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
__gllc_Vertex4dv ( IN const GLdouble v[4] )
{
    __gllc_Vertex4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
__gllc_Vertex4i ( IN GLint x, IN GLint y, IN GLint z, IN GLint w )
{
    __gllc_Vertex4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
__gllc_Vertex4iv ( IN const GLint v[4] )
{
    __gllc_Vertex4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
__gllc_Vertex4s ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w )
{
    __gllc_Vertex4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
__gllc_Vertex4sv ( IN const GLshort v[4] )
{
    __gllc_Vertex4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

/***************************************************************************/
// Fog functions.
// Compile only Fogfv function.
// Convert the other functions to the compiled Fogfv function.

void APIENTRY
__gllc_Fogfv ( IN GLenum pname, IN const GLfloat params[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_Fogfv_Rec *data;
    __GL_SETUP();

    arraySize = __glFogfv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
    size = sizeof(struct __gllc_Fogfv_Rec) + arraySize;
    data = (struct __gllc_Fogfv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(Fogfv));
    if (data == NULL) return;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_Fogfv_Rec),
		 params, arraySize);
    __glDlistAppendOp(gc, data, __glle_Fogfv);
}

void APIENTRY
__gllc_Fogf ( IN GLenum pname, IN GLfloat param )
{
// FOG_ASSERT

    if (!RANGE(pname,GL_FOG_INDEX,GL_FOG_MODE))
    {
	__gllc_InvalidEnum();
	return;
    }

    __gllc_Fogfv(pname, &param);
}

void APIENTRY
__gllc_Fogi ( IN GLenum pname, IN GLint param )
{
    GLfloat fParam;

// FOG_ASSERT

    if (!RANGE(pname,GL_FOG_INDEX,GL_FOG_MODE))
    {
	__gllc_InvalidEnum();
	return;
    }

    fParam = (GLfloat) param;
    __gllc_Fogfv(pname, &fParam);
}

void APIENTRY
__gllc_Fogiv ( IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_FOG_INDEX:
      case GL_FOG_DENSITY:
      case GL_FOG_START:
      case GL_FOG_END:
      case GL_FOG_MODE:
	fParams[0] = (GLfloat) params[0];
        break;
      case GL_FOG_COLOR:
	fParams[0] = __GL_I_TO_FLOAT(params[0]);
	fParams[1] = __GL_I_TO_FLOAT(params[1]);
	fParams[2] = __GL_I_TO_FLOAT(params[2]);
	fParams[3] = __GL_I_TO_FLOAT(params[3]);
        break;
    }

    __gllc_Fogfv(pname, fParams);
}

/***************************************************************************/
// Light functions.
// Compile only Lightfv function.
// Convert the other functions to the compiled Lightfv function.

void APIENTRY
__gllc_Lightfv ( IN GLenum light, IN GLenum pname, IN const GLfloat params[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_Lightfv_Rec *data;
    __GL_SETUP();

    arraySize = __glLightfv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
    size = sizeof(struct __gllc_Lightfv_Rec) + arraySize;
    data = (struct __gllc_Lightfv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(Lightfv));
    if (data == NULL) return;
    data->light = light;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_Lightfv_Rec),
		 params, arraySize);
    __glDlistAppendOp(gc, data, __glle_Lightfv);
}

void APIENTRY
__gllc_Lightf ( IN GLenum light, IN GLenum pname, IN GLfloat param )
{
// LIGHT_SOURCE_ASSERT

    if (!RANGE(pname,GL_SPOT_EXPONENT,GL_QUADRATIC_ATTENUATION))
    {
	__gllc_InvalidEnum();
	return;
    }

    __gllc_Lightfv(light, pname, &param);
}

void APIENTRY
__gllc_Lighti ( IN GLenum light, IN GLenum pname, IN GLint param )
{
    GLfloat fParam;

// LIGHT_SOURCE_ASSERT

    if (!RANGE(pname,GL_SPOT_EXPONENT,GL_QUADRATIC_ATTENUATION))
    {
	__gllc_InvalidEnum();
	return;
    }

    fParam = (GLfloat) param;
    __gllc_Lightfv(light, pname, &fParam);
}

void APIENTRY
__gllc_Lightiv ( IN GLenum light, IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_SPECULAR:
	fParams[0] = __GL_I_TO_FLOAT(params[0]);
	fParams[1] = __GL_I_TO_FLOAT(params[1]);
	fParams[2] = __GL_I_TO_FLOAT(params[2]);
	fParams[3] = __GL_I_TO_FLOAT(params[3]);
        break;
      case GL_POSITION:
	fParams[3] = (GLfloat) params[3];
      case GL_SPOT_DIRECTION:
	fParams[2] = (GLfloat) params[2];
	fParams[1] = (GLfloat) params[1];
      case GL_SPOT_EXPONENT:
      case GL_SPOT_CUTOFF:
      case GL_CONSTANT_ATTENUATION:
      case GL_LINEAR_ATTENUATION:
      case GL_QUADRATIC_ATTENUATION:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    __gllc_Lightfv(light, pname, fParams);
}

/***************************************************************************/
// LightModel functions.
// Compile only LightModelfv function.
// Convert the other functions to the compiled LightModelfv function.

void APIENTRY
__gllc_LightModelfv ( IN GLenum pname, IN const GLfloat params[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_LightModelfv_Rec *data;
    __GL_SETUP();

    arraySize = __glLightModelfv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
    size = sizeof(struct __gllc_LightModelfv_Rec) + arraySize;
    data = (struct __gllc_LightModelfv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(LightModelfv));
    if (data == NULL) return;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_LightModelfv_Rec),
		 params, arraySize);
    __glDlistAppendOp(gc, data, __glle_LightModelfv);
}

void APIENTRY
__gllc_LightModelf ( IN GLenum pname, IN GLfloat param )
{
// LIGHT_MODEL_ASSERT

    if (!RANGE(pname,GL_LIGHT_MODEL_LOCAL_VIEWER,GL_LIGHT_MODEL_TWO_SIDE))
    {
	__gllc_InvalidEnum();
        return;
    }

    __gllc_LightModelfv(pname, &param);
}

void APIENTRY
__gllc_LightModeli ( IN GLenum pname, IN GLint param )
{
    GLfloat fParam;

// LIGHT_MODEL_ASSERT

    if (!RANGE(pname,GL_LIGHT_MODEL_LOCAL_VIEWER,GL_LIGHT_MODEL_TWO_SIDE))
    {
	__gllc_InvalidEnum();
        return;
    }

    fParam = (GLfloat) param;
    __gllc_LightModelfv(pname, &fParam);
}

void APIENTRY
__gllc_LightModeliv ( IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_LIGHT_MODEL_AMBIENT:
	fParams[0] = __GL_I_TO_FLOAT(params[0]);
	fParams[1] = __GL_I_TO_FLOAT(params[1]);
	fParams[2] = __GL_I_TO_FLOAT(params[2]);
	fParams[3] = __GL_I_TO_FLOAT(params[3]);
        break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
      case GL_LIGHT_MODEL_TWO_SIDE:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    __gllc_LightModelfv(pname, fParams);
}

/***************************************************************************/
// Material functions.
// Compile only Materialfv function.
// Convert the other functions to the compiled Materialfv function.

void APIENTRY
__gllc_Materialfv ( IN GLenum face, IN GLenum pname, IN const GLfloat params[] )
{
    GLuint size;
    GLint arraySize;
    GLenum error;
    struct __gllc_Materialfv_Rec *data;
    __GL_SETUP();

#ifdef SGI
// Check this at playback time
    error = __glErrorCheckMaterial(face, pname, params[0]);
    if (error != GL_NO_ERROR) {
	__gllc_Error(gc, error);
	return;
    }
#endif
    arraySize = __glMaterialfv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glMaterialfv)(face, pname, params);
	return;
    }

    size = sizeof(struct __gllc_Materialfv_Rec) + arraySize;
    data = (struct __gllc_Materialfv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(Materialfv));
    if (data == NULL) return;
    data->face = face;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_Materialfv_Rec),
		 params, arraySize);
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_MATERIAL;
#endif
    __glDlistAppendOp(gc, data, __glle_Materialfv);
}

void APIENTRY
__gllc_Materialf ( IN GLenum face, IN GLenum pname, IN GLfloat param )
{
    if (pname != GL_SHININESS)
    {
	__gllc_InvalidEnum();
	return;
    }

    __gllc_Materialfv(face, pname, &param);
}

void APIENTRY
__gllc_Materiali ( IN GLenum face, IN GLenum pname, IN GLint param )
{
    GLfloat fParams[1];

    if (pname != GL_SHININESS)
    {
	__gllc_InvalidEnum();
        return;
    }

    fParams[0] = (GLfloat) param;
    __gllc_Materialfv(face, pname, fParams);
}

void APIENTRY
__gllc_Materialiv ( IN GLenum face, IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_EMISSION:
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_SPECULAR:
      case GL_AMBIENT_AND_DIFFUSE:
	fParams[0] = __GL_I_TO_FLOAT(params[0]);
	fParams[1] = __GL_I_TO_FLOAT(params[1]);
	fParams[2] = __GL_I_TO_FLOAT(params[2]);
	fParams[3] = __GL_I_TO_FLOAT(params[3]);
        break;
      case GL_COLOR_INDEXES:
	fParams[2] = (GLfloat) params[2];
	fParams[1] = (GLfloat) params[1];
      case GL_SHININESS:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    __gllc_Materialfv(face, pname, fParams);
}

/***************************************************************************/
// TexParameter functions.
// Compile only TexParameterfv and TexParameteriv functions.
// Convert the other functions to one of the compiled TexParameter functions.

void APIENTRY
__gllc_TexParameterfv ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_TexParameterfv_Rec *data;
    __GL_SETUP();

    arraySize = __glTexParameterfv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
    size = sizeof(struct __gllc_TexParameterfv_Rec) + arraySize;
    data = (struct __gllc_TexParameterfv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(TexParameterfv));
    if (data == NULL) return;
    data->target = target;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_TexParameterfv_Rec),
		 params, arraySize);
    __glDlistAppendOp(gc, data, __glle_TexParameterfv);
}

void APIENTRY
__gllc_TexParameterf ( IN GLenum target, IN GLenum pname, IN GLfloat param )
{
// TEX_PARAMETER_ASSERT

    if (!RANGE(pname,GL_TEXTURE_MAG_FILTER,GL_TEXTURE_WRAP_T) &&
        pname != GL_TEXTURE_PRIORITY)
    {
	__gllc_InvalidEnum();
	return;
    }

    __gllc_TexParameterfv(target, pname, &param);
}

void APIENTRY
__gllc_TexParameteriv ( IN GLenum target, IN GLenum pname, IN const GLint params[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_TexParameteriv_Rec *data;
    __GL_SETUP();

    arraySize = __glTexParameteriv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
    size = sizeof(struct __gllc_TexParameteriv_Rec) + arraySize;
    data = (struct __gllc_TexParameteriv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(TexParameteriv));
    if (data == NULL) return;
    data->target = target;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_TexParameteriv_Rec),
		 params, arraySize);
    __glDlistAppendOp(gc, data, __glle_TexParameteriv);
}

void APIENTRY
__gllc_TexParameteri ( IN GLenum target, IN GLenum pname, IN GLint param )
{
// TEX_PARAMETER_ASSERT

    if (!RANGE(pname,GL_TEXTURE_MAG_FILTER,GL_TEXTURE_WRAP_T) &&
        pname != GL_TEXTURE_PRIORITY)
    {
	__gllc_InvalidEnum();
	return;
    }

    __gllc_TexParameteriv(target, pname, &param);
}

/***************************************************************************/
// TexEnv functions.
// Compile only TexEnvfv and TexEnviv functions.
// Convert the other functions to one of the compiled TexEnv functions.

void APIENTRY
__gllc_TexEnvfv ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_TexEnvfv_Rec *data;
    __GL_SETUP();

    arraySize = __glTexEnvfv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
    size = sizeof(struct __gllc_TexEnvfv_Rec) + arraySize;
    data = (struct __gllc_TexEnvfv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(TexEnvfv));
    if (data == NULL) return;
    data->target = target;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_TexEnvfv_Rec),
		 params, arraySize);
    __glDlistAppendOp(gc, data, __glle_TexEnvfv);
}

void APIENTRY
__gllc_TexEnvf ( IN GLenum target, IN GLenum pname, IN GLfloat param )
{
    if (pname != GL_TEXTURE_ENV_MODE)
    {
	__gllc_InvalidEnum();
	return;
    }

    __gllc_TexEnvfv(target, pname, &param);
}

void APIENTRY
__gllc_TexEnviv ( IN GLenum target, IN GLenum pname, IN const GLint params[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_TexEnviv_Rec *data;
    __GL_SETUP();

    arraySize = __glTexEnviv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
    size = sizeof(struct __gllc_TexEnviv_Rec) + arraySize;
    data = (struct __gllc_TexEnviv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(TexEnviv));
    if (data == NULL) return;
    data->target = target;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_TexEnviv_Rec),
		 params, arraySize);
    __glDlistAppendOp(gc, data, __glle_TexEnviv);
}

void APIENTRY
__gllc_TexEnvi ( IN GLenum target, IN GLenum pname, IN GLint param )
{
    if (pname != GL_TEXTURE_ENV_MODE)
    {
	__gllc_InvalidEnum();
	return;
    }

    __gllc_TexEnviv(target, pname, &param);
}

/***************************************************************************/
// TexGen functions.
// Compile only TexGenfv function.
// Convert the other functions to the compiled TexGenfv function.

void APIENTRY
__gllc_TexGenfv ( IN GLenum coord, IN GLenum pname, IN const GLfloat params[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_TexGenfv_Rec *data;
    __GL_SETUP();

    arraySize = __glTexGenfv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
    size = sizeof(struct __gllc_TexGenfv_Rec) + arraySize;
    data = (struct __gllc_TexGenfv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(TexGenfv));
    if (data == NULL) return;
    data->coord = coord;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_TexGenfv_Rec),
		 params, arraySize);
    __glDlistAppendOp(gc, data, __glle_TexGenfv);
}

void APIENTRY
__gllc_TexGend ( IN GLenum coord, IN GLenum pname, IN GLdouble param )
{
    GLfloat fParam;

    if (pname != GL_TEXTURE_GEN_MODE)
    {
	__gllc_InvalidEnum();
	return;
    }

    fParam = (GLfloat) param;
    __gllc_TexGenfv(coord, pname, &fParam);
}

void APIENTRY
__gllc_TexGendv ( IN GLenum coord, IN GLenum pname, IN const GLdouble params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_OBJECT_PLANE:
      case GL_EYE_PLANE:
	fParams[3] = (GLfloat) params[3];
	fParams[2] = (GLfloat) params[2];
	fParams[1] = (GLfloat) params[1];
	// fall through
      case GL_TEXTURE_GEN_MODE:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    __gllc_TexGenfv(coord, pname, fParams);
}

void APIENTRY
__gllc_TexGenf ( IN GLenum coord, IN GLenum pname, IN GLfloat param )
{
    if (pname != GL_TEXTURE_GEN_MODE)
    {
	__gllc_InvalidEnum();
	return;
    }

    __gllc_TexGenfv(coord, pname, &param);
}

void APIENTRY
__gllc_TexGeni ( IN GLenum coord, IN GLenum pname, IN GLint param )
{
    GLfloat fParam;

    if (pname != GL_TEXTURE_GEN_MODE)
    {
	__gllc_InvalidEnum();
	return;
    }

    fParam = (GLfloat) param;
    __gllc_TexGenfv(coord, pname, &fParam);
}

void APIENTRY
__gllc_TexGeniv ( IN GLenum coord, IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_OBJECT_PLANE:
      case GL_EYE_PLANE:
	fParams[3] = (GLfloat) params[3];
	fParams[2] = (GLfloat) params[2];
	fParams[1] = (GLfloat) params[1];
	// fall through
      case GL_TEXTURE_GEN_MODE:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    __gllc_TexGenfv(coord, pname, fParams);
}

/***************************************************************************/
// MapGrid functions.
// Compile only MapGrid1f and MapGrid2f functions.
// Convert the other functions to one of the compiled MapGrid functions.

void APIENTRY
__gllc_MapGrid1f ( IN GLint un, IN GLfloat u1, IN GLfloat u2 )
{
    struct __gllc_MapGrid1f_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_MapGrid1f_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_MapGrid1f_Rec)),
                                DLIST_GENERIC_OP(MapGrid1f));
    if (data == NULL) return;
    data->un = un;
    data->u1 = u1;
    data->u2 = u2;
    __glDlistAppendOp(gc, data, __glle_MapGrid1f);
}

void APIENTRY
__gllc_MapGrid1d ( IN GLint un, IN GLdouble u1, IN GLdouble u2 )
{
    __gllc_MapGrid1f(un, (GLfloat) u1, (GLfloat) u2);
}

void APIENTRY
__gllc_MapGrid2f ( IN GLint un, IN GLfloat u1, IN GLfloat u2, IN GLint vn, IN GLfloat v1, IN GLfloat v2 )
{
    struct __gllc_MapGrid2f_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_MapGrid2f_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_MapGrid2f_Rec)),
                                DLIST_GENERIC_OP(MapGrid2f));
    if (data == NULL) return;
    data->un = un;
    data->u1 = u1;
    data->u2 = u2;
    data->vn = vn;
    data->v1 = v1;
    data->v2 = v2;
    __glDlistAppendOp(gc, data, __glle_MapGrid2f);
}

void APIENTRY
__gllc_MapGrid2d ( IN GLint un, IN GLdouble u1, IN GLdouble u2, IN GLint vn, IN GLdouble v1, IN GLdouble v2 )
{
    __gllc_MapGrid2f(un, (GLfloat) u1, (GLfloat) u2, vn, (GLfloat) v1, (GLfloat) v2);
}

/***************************************************************************/
// EvalCoord functions.
// Compile only EvalCoord1f and EvalCoord2f functions.
// Convert the other functions to one of the compiled EvalCoord functions.

void APIENTRY
__gllc_EvalCoord1f ( IN GLfloat u )
{
    struct __gllc_EvalCoord1f_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update and record the poly data
// record.

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

	// If we are in COMPILE_AND_EXECUTE mode or there are attribute
	// changes associated with the vertex, process the poly data.
	if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE
	 || pa->pdNextVertex->flags)
	{
	    (*gc->savedCltProcTable.glDispatchTable.glEvalCoord1f)(u);
	    __glDlistCompilePolyData(gc, GL_FALSE);
	    return;
	}

	// Otherwise, increment vertex count and compile a EvalCoord record
	// instead.
	gc->dlist.beginRec->nVertices++;
    }

    data = (struct __gllc_EvalCoord1f_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_EvalCoord1f_Rec)),
                                DLIST_GENERIC_OP(EvalCoord1f));
    if (data == NULL) return;
    data->u = u;
    __glDlistAppendOp(gc, data, __glle_EvalCoord1f);
}

void APIENTRY
__gllc_EvalCoord1d ( IN GLdouble u )
{
    __gllc_EvalCoord1f((GLfloat) u);
}

void APIENTRY
__gllc_EvalCoord1dv ( IN const GLdouble u[1] )
{
    __gllc_EvalCoord1f((GLfloat) u[0]);
}

void APIENTRY
__gllc_EvalCoord1fv ( IN const GLfloat u[1] )
{
    __gllc_EvalCoord1f((GLfloat) u[0]);
}

void APIENTRY
__gllc_EvalCoord2f ( IN GLfloat u, IN GLfloat v )
{
    struct __gllc_EvalCoord2f_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update and record the poly data
// record.

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

	// If we are in COMPILE_AND_EXECUTE mode or there are attribute
	// changes associated with the vertex, process the poly data.
	if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE
	 || pa->pdNextVertex->flags)
	{
	    (*gc->savedCltProcTable.glDispatchTable.glEvalCoord2f)(u, v);
	    __glDlistCompilePolyData(gc, GL_FALSE);
	    return;
	}

	// Otherwise, increment vertex count and compile a EvalCoord record
	// instead.
	gc->dlist.beginRec->nVertices++;
    }

    data = (struct __gllc_EvalCoord2f_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_EvalCoord2f_Rec)),
                                DLIST_GENERIC_OP(EvalCoord2f));
    if (data == NULL) return;
    data->u = u;
    data->v = v;
    __glDlistAppendOp(gc, data, __glle_EvalCoord2f);
}

void APIENTRY
__gllc_EvalCoord2d ( IN GLdouble u, IN GLdouble v )
{
    __gllc_EvalCoord2f((GLfloat) u, (GLfloat) v);
}

void APIENTRY
__gllc_EvalCoord2dv ( IN const GLdouble u[2] )
{
    __gllc_EvalCoord2f((GLfloat) u[0], (GLfloat) u[1]);
}

void APIENTRY
__gllc_EvalCoord2fv ( IN const GLfloat u[2] )
{
    __gllc_EvalCoord2f((GLfloat) u[0], (GLfloat) u[1]);
}

/***************************************************************************/
// LoadMatrix functions.
// Compile only LoadMatrixf function.
// Convert the other functions to the compiled LoadMatrixf function.

void APIENTRY
__gllc_LoadMatrixf ( IN const GLfloat m[16] )
{
    struct __gllc_LoadMatrixf_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_LoadMatrixf_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_LoadMatrixf_Rec)),
                                DLIST_GENERIC_OP(LoadMatrixf));
    if (data == NULL) return;
    __GL_MEMCOPY(data->m, m, sizeof(data->m));
    __glDlistAppendOp(gc, data, __glle_LoadMatrixf);
}

void APIENTRY
__gllc_LoadMatrixd ( IN const GLdouble m[16] )
{
    GLfloat fm[16];

    fm[ 0] = (GLfloat) m[ 0];
    fm[ 1] = (GLfloat) m[ 1];
    fm[ 2] = (GLfloat) m[ 2];
    fm[ 3] = (GLfloat) m[ 3];
    fm[ 4] = (GLfloat) m[ 4];
    fm[ 5] = (GLfloat) m[ 5];
    fm[ 6] = (GLfloat) m[ 6];
    fm[ 7] = (GLfloat) m[ 7];
    fm[ 8] = (GLfloat) m[ 8];
    fm[ 9] = (GLfloat) m[ 9];
    fm[10] = (GLfloat) m[10];
    fm[11] = (GLfloat) m[11];
    fm[12] = (GLfloat) m[12];
    fm[13] = (GLfloat) m[13];
    fm[14] = (GLfloat) m[14];
    fm[15] = (GLfloat) m[15];

    __gllc_LoadMatrixf(fm);
}

/***************************************************************************/
// MultMatrix functions.
// Compile only MultMatrixf function.
// Convert the other functions to the compiled MultMatrixf function.

void APIENTRY
__gllc_MultMatrixf ( IN const GLfloat m[16] )
{
    struct __gllc_MultMatrixf_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_MultMatrixf_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_MultMatrixf_Rec)),
                                DLIST_GENERIC_OP(MultMatrixf));
    if (data == NULL) return;
    __GL_MEMCOPY(data->m, m, sizeof(data->m));
    __glDlistAppendOp(gc, data, __glle_MultMatrixf);
}

void APIENTRY
__gllc_MultMatrixd ( IN const GLdouble m[16] )
{
    GLfloat fm[16];

    fm[ 0] = (GLfloat) m[ 0];
    fm[ 1] = (GLfloat) m[ 1];
    fm[ 2] = (GLfloat) m[ 2];
    fm[ 3] = (GLfloat) m[ 3];
    fm[ 4] = (GLfloat) m[ 4];
    fm[ 5] = (GLfloat) m[ 5];
    fm[ 6] = (GLfloat) m[ 6];
    fm[ 7] = (GLfloat) m[ 7];
    fm[ 8] = (GLfloat) m[ 8];
    fm[ 9] = (GLfloat) m[ 9];
    fm[10] = (GLfloat) m[10];
    fm[11] = (GLfloat) m[11];
    fm[12] = (GLfloat) m[12];
    fm[13] = (GLfloat) m[13];
    fm[14] = (GLfloat) m[14];
    fm[15] = (GLfloat) m[15];

    __gllc_MultMatrixf(fm);
}

/***************************************************************************/
// Rotate functions.
// Compile only Rotatef function.
// Convert the other functions to the compiled Rotatef function.

void APIENTRY
__gllc_Rotatef ( IN GLfloat angle, IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    struct __gllc_Rotatef_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Rotatef_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Rotatef_Rec)),
                                DLIST_GENERIC_OP(Rotatef));
    if (data == NULL) return;
    data->angle = angle;
    data->x = x;
    data->y = y;
    data->z = z;
    __glDlistAppendOp(gc, data, __glle_Rotatef);
}

void APIENTRY
__gllc_Rotated ( IN GLdouble angle, IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    __gllc_Rotatef((GLfloat) angle, (GLfloat) x, (GLfloat) y, (GLfloat) z);
}

/***************************************************************************/
// Scale functions.
// Compile only Scalef function.
// Convert the other functions to the compiled Scalef function.

void APIENTRY
__gllc_Scalef ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    struct __gllc_Scalef_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Scalef_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Scalef_Rec)),
                                DLIST_GENERIC_OP(Scalef));
    if (data == NULL) return;
    data->x = x;
    data->y = y;
    data->z = z;
    __glDlistAppendOp(gc, data, __glle_Scalef);
}

void APIENTRY
__gllc_Scaled ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    __gllc_Scalef((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

/***************************************************************************/
// Translate functions.
// Compile only Translatef function.
// Convert the other functions to the compiled Translatef function.

void APIENTRY
__gllc_Translatef ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    struct __gllc_Translatef_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Translatef_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Translatef_Rec)),
                                DLIST_GENERIC_OP(Translatef));
    if (data == NULL) return;
    data->x = x;
    data->y = y;
    data->z = z;
    __glDlistAppendOp(gc, data, __glle_Translatef);
}

void APIENTRY
__gllc_Translated ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    __gllc_Translatef((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

/***************************************************************************/
// Other functions.

void APIENTRY
__gllc_ListBase ( IN GLuint base )
{
    struct __gllc_ListBase_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ListBase_Rec *)
        __glDlistAddOpUnaligned(gc,
                                DLIST_SIZE(sizeof(struct __gllc_ListBase_Rec)),
                                DLIST_GENERIC_OP(ListBase));
    if (data == NULL) return;
    data->base = base;
    __glDlistAppendOp(gc, data, __glle_ListBase);
}

void APIENTRY
__gllc_ClipPlane ( IN GLenum plane, IN const GLdouble equation[4] )
{
    struct __gllc_ClipPlane_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ClipPlane_Rec *)
        __glDlistAddOpAligned(gc, DLIST_SIZE(sizeof(struct __gllc_ClipPlane_Rec)),
                              DLIST_GENERIC_OP(ClipPlane));
    if (data == NULL) return;
    data->plane = plane;
    data->equation[0] = equation[0];
    data->equation[1] = equation[1];
    data->equation[2] = equation[2];
    data->equation[3] = equation[3];
    __glDlistAppendOp(gc, data, __glle_ClipPlane);
}

void APIENTRY
__gllc_ColorMaterial ( IN GLenum face, IN GLenum mode )
{
    struct __gllc_ColorMaterial_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ColorMaterial_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ColorMaterial_Rec)),
                                DLIST_GENERIC_OP(ColorMaterial));
    if (data == NULL) return;
    data->face = face;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_ColorMaterial);
}

void APIENTRY
__gllc_CullFace ( IN GLenum mode )
{
    struct __gllc_CullFace_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_CullFace_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_CullFace_Rec)),
                                DLIST_GENERIC_OP(CullFace));
    if (data == NULL) return;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_CullFace);
}

void APIENTRY
__gllc_FrontFace ( IN GLenum mode )
{
    struct __gllc_FrontFace_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_FrontFace_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_FrontFace_Rec)),
                                DLIST_GENERIC_OP(FrontFace));
    if (data == NULL) return;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_FrontFace);
}

void APIENTRY
__gllc_Hint ( IN GLenum target, IN GLenum mode )
{
    struct __gllc_Hint_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Hint_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Hint_Rec)),
                                DLIST_GENERIC_OP(Hint));
    if (data == NULL) return;
    data->target = target;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_Hint);
}

void APIENTRY
__gllc_LineStipple ( IN GLint factor, IN GLushort pattern )
{
    struct __gllc_LineStipple_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_LineStipple_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_LineStipple_Rec)),
                                DLIST_GENERIC_OP(LineStipple));
    if (data == NULL) return;
    data->factor = factor;
    data->pattern = pattern;
    __glDlistAppendOp(gc, data, __glle_LineStipple);
}

void APIENTRY
__gllc_LineWidth ( IN GLfloat width )
{
    struct __gllc_LineWidth_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_LineWidth_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_LineWidth_Rec)),
                                DLIST_GENERIC_OP(LineWidth));
    if (data == NULL) return;
    data->width = width;
    __glDlistAppendOp(gc, data, __glle_LineWidth);
}

void APIENTRY
__gllc_PointSize ( IN GLfloat size )
{
    struct __gllc_PointSize_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PointSize_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PointSize_Rec)),
                                DLIST_GENERIC_OP(PointSize));
    if (data == NULL) return;
    data->size = size;
    __glDlistAppendOp(gc, data, __glle_PointSize);
}

void APIENTRY
__gllc_PolygonMode ( IN GLenum face, IN GLenum mode )
{
    struct __gllc_PolygonMode_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PolygonMode_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PolygonMode_Rec)),
                                DLIST_GENERIC_OP(PolygonMode));
    if (data == NULL) return;
    data->face = face;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_PolygonMode);
}

void APIENTRY
__gllc_Scissor ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height )
{
    struct __gllc_Scissor_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Scissor_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Scissor_Rec)),
                                DLIST_GENERIC_OP(Scissor));
    if (data == NULL) return;
    data->x = x;
    data->y = y;
    data->width = width;
    data->height = height;
    __glDlistAppendOp(gc, data, __glle_Scissor);
}

void APIENTRY
__gllc_ShadeModel ( IN GLenum mode )
{
    struct __gllc_ShadeModel_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ShadeModel_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ShadeModel_Rec)),
                                DLIST_GENERIC_OP(ShadeModel));
    if (data == NULL) return;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_ShadeModel);
}

void APIENTRY
__gllc_InitNames ( void )
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(InitNames));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_InitNames);
}

void APIENTRY
__gllc_LoadName ( IN GLuint name )
{
    struct __gllc_LoadName_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_LoadName_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_LoadName_Rec)),
                                DLIST_GENERIC_OP(LoadName));
    if (data == NULL) return;
    data->name = name;
    __glDlistAppendOp(gc, data, __glle_LoadName);
}

void APIENTRY
__gllc_PassThrough ( IN GLfloat token )
{
    struct __gllc_PassThrough_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PassThrough_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PassThrough_Rec)),
                                DLIST_GENERIC_OP(PassThrough));
    if (data == NULL) return;
    data->token = token;
    __glDlistAppendOp(gc, data, __glle_PassThrough);
}

void APIENTRY
__gllc_PopName ( void )
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(PopName));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_PopName);
}

void APIENTRY
__gllc_PushName ( IN GLuint name )
{
    struct __gllc_PushName_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PushName_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PushName_Rec)),
                                DLIST_GENERIC_OP(PushName));
    if (data == NULL) return;
    data->name = name;
    __glDlistAppendOp(gc, data, __glle_PushName);
}

void APIENTRY
__gllc_DrawBuffer ( IN GLenum mode )
{
    struct __gllc_DrawBuffer_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_DrawBuffer_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_DrawBuffer_Rec)),
                                DLIST_GENERIC_OP(DrawBuffer));
    if (data == NULL) return;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_DrawBuffer);
#if 0
#ifdef NT
    gc->dlist.drawBuffer = GL_TRUE;
#endif
#endif
}

void APIENTRY
__gllc_Clear ( IN GLbitfield mask )
{
    struct __gllc_Clear_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Clear_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Clear_Rec)),
                                DLIST_GENERIC_OP(Clear));
    if (data == NULL) return;
    data->mask = mask;
    __glDlistAppendOp(gc, data, __glle_Clear);
}

void APIENTRY
__gllc_ClearAccum ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    struct __gllc_ClearAccum_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ClearAccum_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ClearAccum_Rec)),
                                DLIST_GENERIC_OP(ClearAccum));
    if (data == NULL) return;
    data->red = red;
    data->green = green;
    data->blue = blue;
    data->alpha = alpha;
    __glDlistAppendOp(gc, data, __glle_ClearAccum);
}

void APIENTRY
__gllc_ClearIndex ( IN GLfloat c )
{
    struct __gllc_ClearIndex_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ClearIndex_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ClearIndex_Rec)),
                                DLIST_GENERIC_OP(ClearIndex));
    if (data == NULL) return;
    data->c = c;
    __glDlistAppendOp(gc, data, __glle_ClearIndex);
}

void APIENTRY
__gllc_ClearColor ( IN GLclampf red, IN GLclampf green, IN GLclampf blue, IN GLclampf alpha )
{
    struct __gllc_ClearColor_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ClearColor_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ClearColor_Rec)),
                                DLIST_GENERIC_OP(ClearColor));
    if (data == NULL) return;
    data->red = red;
    data->green = green;
    data->blue = blue;
    data->alpha = alpha;
    __glDlistAppendOp(gc, data, __glle_ClearColor);
}

void APIENTRY
__gllc_ClearStencil ( IN GLint s )
{
    struct __gllc_ClearStencil_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ClearStencil_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ClearStencil_Rec)),
                                DLIST_GENERIC_OP(ClearStencil));
    if (data == NULL) return;
    data->s = s;
    __glDlistAppendOp(gc, data, __glle_ClearStencil);
}

void APIENTRY
__gllc_ClearDepth ( IN GLclampd depth )
{
    struct __gllc_ClearDepth_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ClearDepth_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ClearDepth_Rec)),
                                DLIST_GENERIC_OP(ClearDepth));
    if (data == NULL) return;
    data->depth = depth;
    __glDlistAppendOp(gc, data, __glle_ClearDepth);
}

void APIENTRY
__gllc_StencilMask ( IN GLuint mask )
{
    struct __gllc_StencilMask_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_StencilMask_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_StencilMask_Rec)),
                                DLIST_GENERIC_OP(StencilMask));
    if (data == NULL) return;
    data->mask = mask;
    __glDlistAppendOp(gc, data, __glle_StencilMask);
}

void APIENTRY
__gllc_ColorMask ( IN GLboolean red, IN GLboolean green, IN GLboolean blue, IN GLboolean alpha )
{
    struct __gllc_ColorMask_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ColorMask_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ColorMask_Rec)),
                                DLIST_GENERIC_OP(ColorMask));
    if (data == NULL) return;
    data->red = red;
    data->green = green;
    data->blue = blue;
    data->alpha = alpha;
    __glDlistAppendOp(gc, data, __glle_ColorMask);
}

void APIENTRY
__gllc_DepthMask ( IN GLboolean flag )
{
    struct __gllc_DepthMask_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_DepthMask_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_DepthMask_Rec)),
                                DLIST_GENERIC_OP(DepthMask));
    if (data == NULL) return;
    data->flag = flag;
    __glDlistAppendOp(gc, data, __glle_DepthMask);
}

void APIENTRY
__gllc_IndexMask ( IN GLuint mask )
{
    struct __gllc_IndexMask_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_IndexMask_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_IndexMask_Rec)),
                                DLIST_GENERIC_OP(IndexMask));
    if (data == NULL) return;
    data->mask = mask;
    __glDlistAppendOp(gc, data, __glle_IndexMask);
}

void APIENTRY
__gllc_Accum ( IN GLenum op, IN GLfloat value )
{
    struct __gllc_Accum_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Accum_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Accum_Rec)),
                                DLIST_GENERIC_OP(Accum));
    if (data == NULL) return;
    data->op = op;
    data->value = value;
    __glDlistAppendOp(gc, data, __glle_Accum);
}

void APIENTRY
__gllc_Disable ( IN GLenum cap )
{
    struct __gllc_Disable_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Disable_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Disable_Rec)),
                                DLIST_GENERIC_OP(Disable));
    if (data == NULL) return;
    data->cap = cap;
    __glDlistAppendOp(gc, data, __glle_Disable);
}

void APIENTRY
__gllc_Enable ( IN GLenum cap )
{
    struct __gllc_Enable_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Enable_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Enable_Rec)),
                                DLIST_GENERIC_OP(Enable));
    if (data == NULL) return;
    data->cap = cap;
    __glDlistAppendOp(gc, data, __glle_Enable);
}

void APIENTRY
__gllc_PopAttrib ( void )
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(PopAttrib));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_PopAttrib);
}

void APIENTRY
__gllc_PushAttrib ( IN GLbitfield mask )
{
    struct __gllc_PushAttrib_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PushAttrib_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PushAttrib_Rec)),
                                DLIST_GENERIC_OP(PushAttrib));
    if (data == NULL) return;
    data->mask = mask;
    __glDlistAppendOp(gc, data, __glle_PushAttrib);
}

void APIENTRY
__gllc_EvalMesh1 ( IN GLenum mode, IN GLint i1, IN GLint i2 )
{
    struct __gllc_EvalMesh1_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_EvalMesh1_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_EvalMesh1_Rec)),
                                DLIST_GENERIC_OP(EvalMesh1));
    if (data == NULL) return;
    data->mode = mode;
    data->i1 = i1;
    data->i2 = i2;
    __glDlistAppendOp(gc, data, __glle_EvalMesh1);
}

void APIENTRY
__gllc_EvalPoint1 ( IN GLint i )
{
    struct __gllc_EvalPoint1_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update and record the poly data
// record.

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

	// If we are in COMPILE_AND_EXECUTE mode or there are attribute
	// changes associated with the vertex, process the poly data.
	if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE
	 || pa->pdNextVertex->flags)
	{
	    (*gc->savedCltProcTable.glDispatchTable.glEvalPoint1)(i);
	    __glDlistCompilePolyData(gc, GL_FALSE);
	    return;
	}

	// Otherwise, increment vertex count and compile a EvalPoint record
	// instead.
	gc->dlist.beginRec->nVertices++;
    }

    data = (struct __gllc_EvalPoint1_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_EvalPoint1_Rec)),
                                DLIST_GENERIC_OP(EvalPoint1));
    if (data == NULL) return;
    data->i = i;
    __glDlistAppendOp(gc, data, __glle_EvalPoint1);
}

void APIENTRY
__gllc_EvalMesh2 ( IN GLenum mode, IN GLint i1, IN GLint i2, IN GLint j1, IN GLint j2 )
{
    struct __gllc_EvalMesh2_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_EvalMesh2_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_EvalMesh2_Rec)),
                                DLIST_GENERIC_OP(EvalMesh2));
    if (data == NULL) return;
    data->mode = mode;
    data->i1 = i1;
    data->i2 = i2;
    data->j1 = j1;
    data->j2 = j2;
    __glDlistAppendOp(gc, data, __glle_EvalMesh2);
}

void APIENTRY
__gllc_EvalPoint2 ( IN GLint i, IN GLint j )
{
    struct __gllc_EvalPoint2_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update and record the poly data
// record.

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

	// If we are in COMPILE_AND_EXECUTE mode or there are attribute
	// changes associated with the vertex, process the poly data.
	if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE
	 || pa->pdNextVertex->flags)
	{
	    (*gc->savedCltProcTable.glDispatchTable.glEvalPoint2)(i, j);
	    __glDlistCompilePolyData(gc, GL_FALSE);
	    return;
	}

	// Otherwise, increment vertex count and compile a EvalPoint record
	// instead.
	gc->dlist.beginRec->nVertices++;
    }

    data = (struct __gllc_EvalPoint2_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_EvalPoint2_Rec)),
                                DLIST_GENERIC_OP(EvalPoint2));
    if (data == NULL) return;
    data->i = i;
    data->j = j;
    __glDlistAppendOp(gc, data, __glle_EvalPoint2);
}

void APIENTRY
__gllc_AlphaFunc ( IN GLenum func, IN GLclampf ref )
{
    struct __gllc_AlphaFunc_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_AlphaFunc_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_AlphaFunc_Rec)),
                                DLIST_GENERIC_OP(AlphaFunc));
    if (data == NULL) return;
    data->func = func;
    data->ref = ref;
    __glDlistAppendOp(gc, data, __glle_AlphaFunc);
}

void APIENTRY
__gllc_BlendFunc ( IN GLenum sfactor, IN GLenum dfactor )
{
    struct __gllc_BlendFunc_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_BlendFunc_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_BlendFunc_Rec)),
                                DLIST_GENERIC_OP(BlendFunc));
    if (data == NULL) return;
    data->sfactor = sfactor;
    data->dfactor = dfactor;
    __glDlistAppendOp(gc, data, __glle_BlendFunc);
}

void APIENTRY
__gllc_LogicOp ( IN GLenum opcode )
{
    struct __gllc_LogicOp_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_LogicOp_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_LogicOp_Rec)),
                                DLIST_GENERIC_OP(LogicOp));
    if (data == NULL) return;
    data->opcode = opcode;
    __glDlistAppendOp(gc, data, __glle_LogicOp);
}

void APIENTRY
__gllc_StencilFunc ( IN GLenum func, IN GLint ref, IN GLuint mask )
{
    struct __gllc_StencilFunc_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_StencilFunc_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_StencilFunc_Rec)),
                                DLIST_GENERIC_OP(StencilFunc));
    if (data == NULL) return;
    data->func = func;
    data->ref = ref;
    data->mask = mask;
    __glDlistAppendOp(gc, data, __glle_StencilFunc);
}

void APIENTRY
__gllc_StencilOp ( IN GLenum fail, IN GLenum zfail, IN GLenum zpass )
{
    struct __gllc_StencilOp_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_StencilOp_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_StencilOp_Rec)),
                                DLIST_GENERIC_OP(StencilOp));
    if (data == NULL) return;
    data->fail = fail;
    data->zfail = zfail;
    data->zpass = zpass;
    __glDlistAppendOp(gc, data, __glle_StencilOp);
}

void APIENTRY
__gllc_DepthFunc ( IN GLenum func )
{
    struct __gllc_DepthFunc_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_DepthFunc_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_DepthFunc_Rec)),
                                DLIST_GENERIC_OP(DepthFunc));
    if (data == NULL) return;
    data->func = func;
    __glDlistAppendOp(gc, data, __glle_DepthFunc);
}

void APIENTRY
__gllc_PixelZoom ( IN GLfloat xfactor, IN GLfloat yfactor )
{
    struct __gllc_PixelZoom_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PixelZoom_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PixelZoom_Rec)),
                                DLIST_GENERIC_OP(PixelZoom));
    if (data == NULL) return;
    data->xfactor = xfactor;
    data->yfactor = yfactor;
    __glDlistAppendOp(gc, data, __glle_PixelZoom);
}

void APIENTRY
__gllc_PixelTransferf ( IN GLenum pname, IN GLfloat param )
{
    struct __gllc_PixelTransferf_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PixelTransferf_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PixelTransferf_Rec)),
                                DLIST_GENERIC_OP(PixelTransferf));
    if (data == NULL) return;
    data->pname = pname;
    data->param = param;
    __glDlistAppendOp(gc, data, __glle_PixelTransferf);
}

void APIENTRY
__gllc_PixelTransferi ( IN GLenum pname, IN GLint param )
{
    struct __gllc_PixelTransferi_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PixelTransferi_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PixelTransferi_Rec)),
                                DLIST_GENERIC_OP(PixelTransferi));
    if (data == NULL) return;
    data->pname = pname;
    data->param = param;
    __glDlistAppendOp(gc, data, __glle_PixelTransferi);
}

void APIENTRY
__gllc_PixelMapfv ( IN GLenum map, IN GLint mapsize, IN const GLfloat values[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_PixelMapfv_Rec *data;
    __GL_SETUP();

    arraySize = mapsize * 4;
    if (arraySize < 0) {
	__gllc_InvalidValue();
	return;
    }
    size = sizeof(struct __gllc_PixelMapfv_Rec) + arraySize;
    data = (struct __gllc_PixelMapfv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(PixelMapfv));
    if (data == NULL) return;
    data->map = map;
    data->mapsize = mapsize;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_PixelMapfv_Rec),
		 values, arraySize);
    __glDlistAppendOp(gc, data, __glle_PixelMapfv);
}

void APIENTRY
__gllc_PixelMapuiv ( IN GLenum map, IN GLint mapsize, IN const GLuint values[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_PixelMapuiv_Rec *data;
    __GL_SETUP();

    arraySize = mapsize * 4;
    if (arraySize < 0) {
	__gllc_InvalidValue();
	return;
    }
    size = sizeof(struct __gllc_PixelMapuiv_Rec) + arraySize;
    data = (struct __gllc_PixelMapuiv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(PixelMapuiv));
    if (data == NULL) return;
    data->map = map;
    data->mapsize = mapsize;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_PixelMapuiv_Rec),
		 values, arraySize);
    __glDlistAppendOp(gc, data, __glle_PixelMapuiv);
}

void APIENTRY
__gllc_PixelMapusv ( IN GLenum map, IN GLint mapsize, IN const GLushort values[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_PixelMapusv_Rec *data;
    __GL_SETUP();

    arraySize = mapsize * 2;
    if (arraySize < 0) {
	__gllc_InvalidValue();
	return;
    }
#ifdef NT
    size = sizeof(struct __gllc_PixelMapusv_Rec) + __GL_PAD(arraySize);
#else
    arraySize = __GL_PAD(arraySize);
    size = sizeof(struct __gllc_PixelMapusv_Rec) + arraySize;
#endif
    data = (struct __gllc_PixelMapusv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(PixelMapusv));
    if (data == NULL) return;
    data->map = map;
    data->mapsize = mapsize;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_PixelMapusv_Rec),
		 values, arraySize);
    __glDlistAppendOp(gc, data, __glle_PixelMapusv);
}

void APIENTRY
__gllc_ReadBuffer ( IN GLenum mode )
{
    struct __gllc_ReadBuffer_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ReadBuffer_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ReadBuffer_Rec)),
                                DLIST_GENERIC_OP(ReadBuffer));
    if (data == NULL) return;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_ReadBuffer);
}

void APIENTRY
__gllc_CopyPixels ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum type )
{
    struct __gllc_CopyPixels_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_CopyPixels_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_CopyPixels_Rec)),
                                DLIST_GENERIC_OP(CopyPixels));
    if (data == NULL) return;
    data->x = x;
    data->y = y;
    data->width = width;
    data->height = height;
    data->type = type;
    __glDlistAppendOp(gc, data, __glle_CopyPixels);
}

void APIENTRY
__gllc_DepthRange ( IN GLclampd zNear, IN GLclampd zFar )
{
    struct __gllc_DepthRange_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_DepthRange_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_DepthRange_Rec)),
                                DLIST_GENERIC_OP(DepthRange));
    if (data == NULL) return;
    data->zNear = zNear;
    data->zFar = zFar;
    __glDlistAppendOp(gc, data, __glle_DepthRange);
}

void APIENTRY
__gllc_Frustum ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar )
{
    struct __gllc_Frustum_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Frustum_Rec *)
        __glDlistAddOpAligned(gc, DLIST_SIZE(sizeof(struct __gllc_Frustum_Rec)),
                              DLIST_GENERIC_OP(Frustum));
    if (data == NULL) return;
    data->left = left;
    data->right = right;
    data->bottom = bottom;
    data->top = top;
    data->zNear = zNear;
    data->zFar = zFar;
    __glDlistAppendOp(gc, data, __glle_Frustum);
}

void APIENTRY
__gllc_LoadIdentity ( void )
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(LoadIdentity));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_LoadIdentity);
}

void APIENTRY
__gllc_MatrixMode ( IN GLenum mode )
{
    struct __gllc_MatrixMode_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_MatrixMode_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_MatrixMode_Rec)),
                                DLIST_GENERIC_OP(MatrixMode));
    if (data == NULL) return;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_MatrixMode);
}

void APIENTRY
__gllc_Ortho ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar )
{
    struct __gllc_Ortho_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Ortho_Rec *)
        __glDlistAddOpAligned(gc, DLIST_SIZE(sizeof(struct __gllc_Ortho_Rec)),
                              DLIST_GENERIC_OP(Ortho));
    if (data == NULL) return;
    data->left = left;
    data->right = right;
    data->bottom = bottom;
    data->top = top;
    data->zNear = zNear;
    data->zFar = zFar;
    __glDlistAppendOp(gc, data, __glle_Ortho);
}

void APIENTRY
__gllc_PopMatrix ( void )
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(PopMatrix));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_PopMatrix);
}

void APIENTRY
__gllc_PushMatrix ( void )
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(PushMatrix));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_PushMatrix);
}

void APIENTRY
__gllc_Viewport ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height )
{
    struct __gllc_Viewport_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Viewport_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Viewport_Rec)),
                                DLIST_GENERIC_OP(Viewport));
    if (data == NULL) return;
    data->x = x;
    data->y = y;
    data->width = width;
    data->height = height;
    __glDlistAppendOp(gc, data, __glle_Viewport);
}

void APIENTRY __gllc_BindTexture(GLenum target, GLuint texture)
{
    struct __gllc_BindTexture_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_BindTexture_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_BindTexture_Rec)),
                                DLIST_GENERIC_OP(BindTexture));
    if (data == NULL) return;
    data->target = target;
    data->texture = texture;
    __glDlistAppendOp(gc, data, __glle_BindTexture);
}

void APIENTRY __gllc_PrioritizeTextures(GLsizei n, const GLuint *textures,
                                      const GLclampf *priorities)
{
    struct __gllc_PrioritizeTextures_Rec *data;
    __GL_SETUP();
    GLuint size;
    GLubyte *extra;

    size = DLIST_SIZE(sizeof(struct __gllc_PrioritizeTextures_Rec)+
                      n*(sizeof(GLuint)+sizeof(GLclampf)));
    data = (struct __gllc_PrioritizeTextures_Rec *)
        __glDlistAddOpUnaligned(gc, size,
                                DLIST_GENERIC_OP(PrioritizeTextures));
    if (data == NULL) return;
    data->n = n;
    extra = (GLubyte *)data+sizeof(struct __gllc_PrioritizeTextures_Rec);
    __GL_MEMCOPY(extra, textures, n*sizeof(GLuint));
    extra += n*sizeof(GLuint);
    __GL_MEMCOPY(extra, priorities, n*sizeof(GLclampf));
    __glDlistAppendOp(gc, data, __glle_PrioritizeTextures);
}

void APIENTRY __gllc_CopyTexImage1D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLint border)
{
    struct __gllc_CopyTexImage1D_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_CopyTexImage1D_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_CopyTexImage1D_Rec)),
                                DLIST_GENERIC_OP(CopyTexImage1D));
    if (data == NULL) return;
    data->target = target;
    data->level = level;
    data->internalformat = internalformat;
    data->x = x;
    data->y = y;
    data->width = width;
    data->border = border;
    __glDlistAppendOp(gc, data, __glle_CopyTexImage1D);
}

void APIENTRY __gllc_CopyTexImage2D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLsizei height, GLint border)
{
    struct __gllc_CopyTexImage2D_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_CopyTexImage2D_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_CopyTexImage2D_Rec)),
                                DLIST_GENERIC_OP(CopyTexImage2D));
    if (data == NULL) return;
    data->target = target;
    data->level = level;
    data->internalformat = internalformat;
    data->x = x;
    data->y = y;
    data->width = width;
    data->height = height;
    data->border = border;
    __glDlistAppendOp(gc, data, __glle_CopyTexImage2D);
}

void APIENTRY __gllc_CopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                     GLint x, GLint y, GLsizei width)
{
    struct __gllc_CopyTexSubImage1D_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_CopyTexSubImage1D_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_CopyTexSubImage1D_Rec)),
                                DLIST_GENERIC_OP(CopyTexSubImage1D));
    if (data == NULL) return;
    data->target = target;
    data->level = level;
    data->xoffset = xoffset;
    data->x = x;
    data->y = y;
    data->width = width;
    __glDlistAppendOp(gc, data, __glle_CopyTexSubImage1D);
}

void APIENTRY __gllc_CopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                     GLint yoffset, GLint x, GLint y,
                                     GLsizei width, GLsizei height)
{
    struct __gllc_CopyTexSubImage2D_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_CopyTexSubImage2D_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_CopyTexSubImage2D_Rec)),
                                DLIST_GENERIC_OP(CopyTexSubImage2D));
    if (data == NULL) return;
    data->target = target;
    data->level = level;
    data->xoffset = xoffset;
    data->yoffset = yoffset;
    data->x = x;
    data->y = y;
    data->width = width;
    data->height = height;
    __glDlistAppendOp(gc, data, __glle_CopyTexSubImage2D);
}

void APIENTRY __gllc_PolygonOffset(GLfloat factor, GLfloat units)
{
    struct __gllc_PolygonOffset_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PolygonOffset_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PolygonOffset_Rec)),
                                DLIST_GENERIC_OP(PolygonOffset));
    if (data == NULL) return;
    data->factor = factor;
    data->units = units;
    __glDlistAppendOp(gc, data, __glle_PolygonOffset);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\dlist\dl_list.c ===
/******************************Module*Header*******************************\
* Module Name: dl_list.c
*
* Display list management rountines.
*
* Copyright (c) 1995-96 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Basic display list routines.
**
*/
#include "precomp.h"
#pragma hdrstop

extern GLCLTPROCTABLE ListCompCltProcTable;
extern GLEXTPROCTABLE ListCompExtProcTable;

__GLdlist *__glShrinkDlist(__GLcontext *gc, __GLdlist *dlist);

// #define DL_HEAP_VERBOSE

#ifdef DL_HEAP_VERBOSE
int cbDlistTotal = 0;
extern ULONG glSize;

#ifdef DBG
#define GL_MSIZE(pv) _msize((BYTE *)(pv)-16)
#else
#define GL_MSIZE(pv) _msize(pv)
#endif
#endif

#if defined(DL_BLOCK_VERBOSE) || defined(DL_HEAP_VERBOSE)
#include "malloc.h"
#endif

/*
** Arbitrary limit for looking up multiple display lists at once 
** (with glCallLists()).  Any number from 128 to 1024 should work well.
** This value doesn't change the functionality of OpenGL at all, but
** will make minor variations to the performance characteristics.
*/
#define MAX_LISTS_CACHE 256

const GLubyte __GLdlsize_tab[] = {
      /* GL_BYTE		*/	1,
      /* GL_UNSIGNED_BYTE	*/	1,
      /* GL_SHORT		*/	2,
      /* GL_UNSIGNED_SHORT	*/	2,
      /* GL_INT			*/	4,
      /* GL_UNSIGNED_INT	*/	4,
      /* GL_FLOAT		*/	4,
      /* GL_2_BYTES		*/	2,
      /* GL_3_BYTES		*/	3,
      /* GL_4_BYTES		*/	4,
};

#define __glCallListsSize(type)				\
	((type) >= GL_BYTE && (type) <= GL_4_BYTES ?	\
	__GLdlsize_tab[(type)-GL_BYTE] : -1)

#define DL_LINK_SIZE            (sizeof(__GLlistExecFunc *)+sizeof(GLubyte *))
#define DL_TERMINATOR_SIZE      sizeof(GLubyte *)
#define DL_OVERHEAD             (offsetof(__GLdlist, head)+DL_LINK_SIZE+\
                                 DL_TERMINATOR_SIZE)

// This value should be a power of two
#define DL_BLOCK_SIZE           (256 * 1024)

// This value is chosen specifically to give the initial total size
// of the dlist an even block size
#define DL_INITIAL_SIZE         (DL_BLOCK_SIZE-DL_OVERHEAD)

// Skip to the next block in the display list block chain
const GLubyte * FASTCALL __glle_NextBlock(__GLcontext *gc, const GLubyte *PC)
{
#ifdef DL_BLOCK_VERBOSE
    DbgPrint("NextBlock: %08lX\n", *(const GLubyte * UNALIGNED64 *)PC);
#endif
    
    return *(const GLubyte * UNALIGNED64 *)PC;
}

/*
** Used to pad display list entries to double word boundaries where needed
** (for those few OpenGL commands which take double precision values).
*/
const GLubyte * FASTCALL __glle_Nop(__GLcontext *gc, const GLubyte *PC)
{
    return PC;
}

void APIENTRY
glcltNewList ( IN GLuint list, IN GLenum mode )
{
    __GLdlistMachine *dlstate;
    __GL_SETUP();

    // Must use the client side begin state
    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    dlstate = &gc->dlist;

    /* Valid mode? */
    switch(mode) {
      case GL_COMPILE:
      case GL_COMPILE_AND_EXECUTE:
	break;
      default:
	GLSETERROR(GL_INVALID_ENUM);
	return;
    }

    if (dlstate->currentList) {
	/* Must call EndList before calling NewList again! */
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    if (list == 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

// If we are in COMPILE mode, we need to clear the command buffer,
// the poly array buffer, and the poly material buffer so that we
// can use them to compile poly array.  Otherwise, previously batched
// commands may be lost.

    if (mode == GL_COMPILE)
	glsbAttention();

    ASSERTOPENGL((DL_BLOCK_SIZE & (DL_BLOCK_SIZE-1)) == 0,
                 "DL_BLOCK_SIZE is not a power of two\n");
    ASSERTOPENGL(dlstate->listData == NULL,
                 "listData non-NULL in NewList\n");
    
    dlstate->listData = __glAllocDlist(gc, DL_INITIAL_SIZE);
    if (dlstate->listData == NULL)
    {
        GLSETERROR(GL_OUT_OF_MEMORY);
        return;
    }
    
    /*
    ** Save current client dispatch pointers into saved state in context.  Then
    ** switch to the list tables.
    */
    gc->savedCltProcTable.cEntries = ListCompCltProcTable.cEntries;
    gc->savedExtProcTable.cEntries = ListCompExtProcTable.cEntries;
    GetCltProcTable(&gc->savedCltProcTable, &gc->savedExtProcTable, FALSE);
    SetCltProcTable(&ListCompCltProcTable, &ListCompExtProcTable, FALSE);

    dlstate->currentList = list;
    dlstate->mode = mode;
    dlstate->nesting = 0;
#if 0
    dlstate->drawBuffer = GL_FALSE;
#endif
    dlstate->beginRec = NULL;

    (*dlstate->initState)(gc);
}

void APIENTRY
glcltEndList ( void )
{
    __GLdlistMachine *dlstate;
    __GLdlist *dlist;
    __GLdlist *newDlist;
    __GLdlist *prevDlist;
    GLubyte *allEnd;
    GLubyte *data;
    GLuint totalSize;
    GLuint currentList;
    POLYARRAY *pa;
    __GL_SETUP();

    pa = gc->paTeb;

    dlstate = &gc->dlist;

    /* Must call NewList() first! */
    if (dlstate->currentList == 0) {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

// In COMPILE_AND_EXECUTE mode, EndList must not be called in Begin.
// In COMPILE mode, however, this flag should be clear (enforced in NewList)
// unless it was set in the poly array compilation code.

    if (dlstate->mode == GL_COMPILE_AND_EXECUTE &&
        pa->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

// If we are in the middle of compiling poly array, end the poly array
// compilation.

    if (gc->dlist.beginRec)
    {
	ASSERTOPENGL(pa->flags & POLYARRAY_IN_BEGIN, "not in begin!\n");

	gc->dlist.beginRec->flags |= DLIST_BEGIN_NO_MATCHING_END;

// Record the last POLYDATA since it may contain attribute changes.

	__glDlistCompilePolyData(gc, GL_TRUE);

	// Terminate poly array compilation
	gc->dlist.beginRec = NULL;
    }

// If we are in COMPILE mode, we need to reset the command buffer,
// the poly array buffer, and the poly material buffer.

    if (gc->dlist.mode == GL_COMPILE)
    {
	glsbResetBuffers(gc->dlist.beginRec ? TRUE : FALSE);

	// Clear begin flag too
        pa->flags &= ~POLYARRAY_IN_BEGIN;
    }

    dlist = dlstate->listData;
    
#if 0
    // Copy over the DrawBuffer flag
    dlist->drawBuffer = dlstate->drawBuffer;
#endif

    // Shrink this block to remove wasted space
    dlist = __glShrinkDlist(gc, dlist);

    // Remember the true end of the list
    allEnd = dlist->head+dlist->used;
    
    // Reverse the order of the list
    prevDlist = NULL;
    while (dlist->nextBlock != NULL)
    {
        newDlist = dlist->nextBlock;
        dlist->nextBlock = prevDlist;
        prevDlist = dlist;
        dlist = newDlist;
    }
    dlist->nextBlock = prevDlist;
    
    // Set the end pointer correctly
    dlist->end = allEnd;
    // Mark the end of the display list data with 0:
    *((DWORD *)dlist->end) = 0;

    dlstate->listData = NULL;

    currentList = dlstate->currentList;
    dlstate->currentList = 0;
    
#ifdef DL_HEAP_VERBOSE
    DbgPrint("Dlists using %8d, total %8d\n",
             cbDlistTotal, glSize);
#endif

#ifdef DL_BLOCK_VERBOSE
    DbgPrint("List %d: start %08lX, end %08lX\n", currentList,
             dlist->head, dlist->end);
    DbgPrint("Blocks at:");
    newDlist = dlist;
    while (newDlist != NULL)
    {
        DbgPrint(" %08lX:%d", newDlist, GL_MSIZE(newDlist));
        newDlist = newDlist->nextBlock;
    }
    DbgPrint("\n");
#endif

    // __glNamesNewData sets dlist refcount to 1.
    if (!__glNamesNewData(gc, gc->dlist.namesArray, currentList, dlist))
    {
	/* 
	** No memory!
	** Nuke the list! 
	*/
	__glFreeDlist(gc, dlist);
    }
    
    /* Switch back to saved dispatch state */
    SetCltProcTable(&gc->savedCltProcTable, &gc->savedExtProcTable, FALSE);
}

#ifdef NT_SERVER_SHARE_LISTS

/******************************Public*Routine******************************\
*
* DlLockLists
*
* Remember the locked lists for possible later cleanup
*
* History:
*  Mon Dec 12 18:58:32 1994	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

// Number of locks to allocate when the lock list needs to grow
// Must be a power of two
#define DL_LOCK_LIST_BLOCK 32

GLboolean DlLockLists(__GLcontext *gc, GLsizei n, __GLdlist **dlists)
{
    DlLockArray *pdla;
    DlLockEntry *pdle;
    GLsizei nNewSize;

    pdla = &gc->dla;
    
    // Extend current lock array if needed
    if (pdla->nAllocated-pdla->nFilled < n)
    {
        // Round the needed size up to the block size
        nNewSize = (pdla->nAllocated+n+DL_LOCK_LIST_BLOCK-1) &
            ~(DL_LOCK_LIST_BLOCK-1);
        
        pdle = GCREALLOC(gc, pdla->pdleEntries, sizeof(DlLockEntry)*nNewSize);
        if (pdle == NULL)
        {
            return 0;
        }

        pdla->nAllocated = nNewSize;
        pdla->pdleEntries = pdle;
    }

    // We must have enough space now
    ASSERTOPENGL(pdla->nAllocated-pdla->nFilled >= n, "no enough space!\n");

    // Lock down dlists and remember them
    pdle = pdla->pdleEntries+pdla->nFilled;
    pdla->nFilled += n;
    
    while (n-- > 0)
    {
        pdle->dlist = *dlists;

        DBGLEVEL3(LEVEL_INFO, "Locked %p for %p, ref %d\n", *dlists, gc,
                  (*dlists)->refcount);
        
        dlists++;
        pdle++;
    }
    
    return (GLboolean) (pdla->nFilled != 0);	// return high water mark
}

/******************************Public*Routine******************************\
*
* DlUnlockLists
*
* Remove list lock entries.
*
* History:
*  Mon Dec 12 18:58:54 1994	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void DlUnlockLists(__GLcontext *gc, GLsizei n)
{
    DlLockArray *pdla;
    DlLockEntry *pdle;
    GLsizei i;
    __GLdlist *dlist;

// Since DlLockLists and DlUnlockLists are called in a recursive manner,
// we can simply decrement the filled count.

    pdla = &gc->dla;
    
    pdla->nFilled -= n;

    // Lock list doesn't shrink.  This would be fairly easy since realloc
    // is guaranteed not to fail when the memory block shrinks
    // Is this important?
}

/******************************Public*Routine******************************\
*
* DlReleaseLocks
*
* Releases any locks in the lock list and frees the lock list
*
* Must be executed under the dlist semaphore
*
* History:
*  Tue Dec 13 11:45:26 1994	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void DlReleaseLocks(__GLcontext *gc)
{
    DlLockArray *pdla;
    DlLockEntry *pdle;

    __GL_NAMES_ASSERT_LOCKED(gc->dlist.namesArray);
    
    pdla = &gc->dla;

    DBGLEVEL3(LEVEL_INFO, "Cleaning up %p, locks %d (%d)\n", gc,
              pdla->nFilled, pdla->nAllocated);

    // Sanity check the counts
    ASSERTOPENGL(pdla->nFilled <= pdla->nAllocated, "bad nFilled!\n");
    
    pdle = pdla->pdleEntries;
    while (pdla->nFilled)
    {
	pdla->nFilled--;

// This function is called to clean up display list locks held by
// glCallList or glCallLists when it dies.  We need to release the
// locks here and free the dlists if their refcounts reach 0.
// The refcounts will reach 0 here only when the dlists were deleted
// by another thread while this thread was also holding the locks.

	__glDisposeDlist(gc, pdle->dlist);
	pdle++;
    }

    pdla->nAllocated = 0;
    if (pdla->pdleEntries)
    {
	GCFREE(gc, pdla->pdleEntries);
    }
}

#endif // NT_SERVER_SIDE

// If the a dlist was deleted by another thread while we have it locked,
// we need to free the dlist here.
void FASTCALL DlCleanup(__GLcontext *gc, void *pData)
{
    __glFreeDlist(gc, (__GLdlist *)pData);
}

void FASTCALL DoCallList(GLuint list)
{
    __GLdlist *dlist;
    __GLdlistMachine *dlstate;
    const GLubyte *end, *PC;
    __GLlistExecFunc *fp;
    __GL_SETUP();

    dlstate = &gc->dlist;

    if (dlstate->nesting >= __GL_MAX_LIST_NESTING) {
	/* Force unwinding of the display list */
	dlstate->nesting = __GL_MAX_LIST_NESTING*2;
	return;
    }

    /* Increment dlist refcount */
    dlist = __glNamesLockData(gc, gc->dlist.namesArray, list);

    /* No list, no action! */
    if (!dlist) {
	return;
    }

#ifdef NT_SERVER_SHARE_LISTS
    if (!DlLockLists(gc, 1, &dlist))
    {
	/* Decrement dlist refcount */
        __glNamesUnlockData(gc, (void *)dlist, DlCleanup);
	GLSETERROR(GL_OUT_OF_MEMORY);
        return;
    }
#endif
    
    dlstate->nesting++;

    end = dlist->end;
    PC = dlist->head;

    while (PC != end)
    {
	// Get the current function pointer.
	fp = *((__GLlistExecFunc * const UNALIGNED64 *) PC);

	// Execute the current function.  Return value is pointer to
	// next function/parameter block in the display list.

	PC = (*fp)(gc, PC+sizeof(__GLlistExecFunc * const *));
    }

    dlstate->nesting--;

    /* Decrement dlist refcount */
    // Will perform cleanup if necessary
    __glNamesUnlockData(gc, (void *)dlist, DlCleanup);
    
#ifdef NT_SERVER_SHARE_LISTS
    DlUnlockLists(gc, 1);
#endif
}

/*
** Display list compilation and execution versions of CallList and CallLists
** are maintained here for the sake of sanity.  Note that __glle_CallList
** may not call glcltCallList or it will break the infinite recursive
** display list prevention code.
*/
void APIENTRY
__gllc_CallList ( IN GLuint list )
{
    struct __gllc_CallList_Rec *data;
    __GL_SETUP();

    if (list == 0) {
	__gllc_InvalidValue();
	return;
    }

// It is extremely difficult to make CallList(s) work with poly array
// compilation.  For example, in the call sequence in COMPILE_AND_EXECUTE
// mode [Begin, TexCoord, CallList, Vertex, ...], it is difficult to record
// the partial POLYDATA in both COMPILE and COMPILE_AND_EXECUTE modes.
// That is, we may end up recording and playing back TexCoord twice in the
// above example.  As a result, we may have to stop building poly array in
// some cases.  Fortunately, this situation is rare.

    if (gc->dlist.beginRec)
    {
	gc->dlist.beginRec->flags |= DLIST_BEGIN_HAS_CALLLIST;

// Record the last POLYDATA since it may contain attribute changes.

	__glDlistCompilePolyData(gc, GL_TRUE);
    }

    data = (struct __gllc_CallList_Rec *)
        __glDlistAddOpUnaligned(gc,
                                DLIST_SIZE(sizeof(struct __gllc_CallList_Rec)),
                                DLIST_GENERIC_OP(CallList));
    if (data == NULL) return;
    data->list = list;
    __glDlistAppendOp(gc, data, __glle_CallList);

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

// In COMPILE_AND_EXECUTE mode, we can actually get out of the Begin mode.
// Although it is an application error, we need to terminate poly array
// compilation!

	if (!(pa->flags & POLYARRAY_IN_BEGIN))
	    gc->dlist.beginRec = NULL;
	else
	{
// If there is a partial vertex record after CallList(s), we will terminate
// the poly array compilation.  Otherwise, it is safe to continue the
// processing.

	    if (pa->pdNextVertex->flags)
	    {
		// Terminate poly array compilation
		gc->dlist.beginRec = NULL;

		if (gc->dlist.mode == GL_COMPILE)
		{
		    glsbResetBuffers(TRUE);

		    // Clear begin flag too
		    pa->flags &= ~POLYARRAY_IN_BEGIN;
		}

	    }
	}
    }
}

const GLubyte * FASTCALL __glle_CallList(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_CallList_Rec *data;

    data = (struct __gllc_CallList_Rec *) PC;
    DoCallList(data->list);
    return PC + sizeof(struct __gllc_CallList_Rec);
}

void APIENTRY
glcltCallList ( IN GLuint list )
{
    __GL_SETUP();
    
    if (list == 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    gc->dlist.nesting = 0;
    DoCallList(list);
}

void FASTCALL DoCallLists(GLsizei n, GLenum type, const GLvoid *lists)
{
    __GLdlist *dlists[MAX_LISTS_CACHE];
    __GLdlist *dlist;
    __GLdlistMachine *dlstate;
    GLint i, dlcount, datasize;
    const GLubyte *listiter;
    const GLubyte *end, *PC;
    __GLlistExecFunc *fp;
    __GL_SETUP();

    dlstate = &gc->dlist;

    datasize = __glCallListsSize(type);

    if (dlstate->nesting >= __GL_MAX_LIST_NESTING) {
	/* Force unwinding of the display list */
	dlstate->nesting = __GL_MAX_LIST_NESTING*2;
	return;
    }
    dlstate->nesting++;

    listiter = (const GLubyte *) lists;
    while (n) {
	dlcount = n;
	if (dlcount > MAX_LISTS_CACHE) dlcount = MAX_LISTS_CACHE;

#ifdef NT_SERVER_SHARE_LISTS
        // Is there anything we can do here in the failure case besides
        // just skip the lists?  This is more or less consistent
        // with the behavior for not-found lists
        
	/* Increment dlist refcount */
	__glNamesLockDataList(gc, gc->dlist.namesArray, dlcount, type, 
                              gc->state.list.listBase, 
                              (const GLvoid *) listiter, (void **)dlists);

        if (!DlLockLists(gc, dlcount, dlists))
        {
	    /* Decrement dlist refcount */
            __glNamesUnlockDataList(gc, dlcount, (void **)dlists, DlCleanup);
	    GLSETERROR(GL_OUT_OF_MEMORY);
        }
        else
        {
#else
	__glNamesLockDataList(gc, gc->dlist.namesArray, dlcount, type, 
		gc->state.list.listBase, 
		(const GLvoid *) listiter, (void **)dlists);
#endif

	i = 0;
	while (i < dlcount) {
	    dlist = dlists[i];
	    end = dlist->end;
	    PC = dlist->head;
                     
	    while (PC != end)
	    {
		// Get the current function pointer.
		fp = *((__GLlistExecFunc * const UNALIGNED64 *) PC);

		// Execute the current function.  Return value is pointer to
		// next function/parameter block in the display list.

		PC = (*fp)(gc, PC+sizeof(__GLlistExecFunc * const *));
	    }
	    i++;
	}

	/* Decrement dlist refcount */
	// Will perform cleanup if necessary
	__glNamesUnlockDataList(gc, dlcount, (void **)dlists, DlCleanup);

#ifdef NT_SERVER_SHARE_LISTS
        DlUnlockLists(gc, dlcount);
        
        }
#endif

	listiter += dlcount * datasize;
	n -= dlcount;
    }

    dlstate->nesting--;
}

/*
** Display list compilation and execution versions of CallList and CallLists
** are maintained here for the sake of sanity.  Note that __glle_CallLists
** may not call glcltCallLists or it will break the infinite recursive
** display list prevention code.
*/
void APIENTRY
__gllc_CallLists ( IN GLsizei n, IN GLenum type, IN const GLvoid *lists )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_CallLists_Rec *data;
    __GL_SETUP();

    if (n < 0) {
	__gllc_InvalidValue();
	return;
    }
    else if (n == 0) {
	return;
    }

// It is extremely difficult to make CallList(s) work with poly array
// compilation.  For example, in the call sequence in COMPILE_AND_EXECUTE
// mode [Begin, TexCoord, CallList, Vertex, ...], it is difficult to record
// the partial POLYDATA in both COMPILE and COMPILE_AND_EXECUTE modes.
// That is, we may end up recording and playing back TexCoord twice in the
// above example.  As a result, we may have to stop building poly array in
// some cases.  Fortunately, this situation is rare.

    if (gc->dlist.beginRec)
    {
	gc->dlist.beginRec->flags |= DLIST_BEGIN_HAS_CALLLIST;

// Record the last POLYDATA since it may contain attribute changes.

	__glDlistCompilePolyData(gc, GL_TRUE);
    }

    arraySize = __glCallListsSize(type)*n;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
#ifdef NT
    size = sizeof(struct __gllc_CallLists_Rec) + __GL_PAD(arraySize);
#else
    arraySize = __GL_PAD(arraySize);
    size = sizeof(struct __gllc_CallLists_Rec) + arraySize;
#endif
    data = (struct __gllc_CallLists_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size),
                                DLIST_GENERIC_OP(CallLists));
    if (data == NULL) return;
    data->n = n;
    data->type = type;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_CallLists_Rec),
		 lists, arraySize);
    __glDlistAppendOp(gc, data, __glle_CallLists);

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

// In COMPILE_AND_EXECUTE mode, we can actually get out of the Begin mode.
// Although it is an application error, we need to terminate poly array
// compilation!

	if (!(pa->flags & POLYARRAY_IN_BEGIN))
	    gc->dlist.beginRec = NULL;
	else
	{
// If there is a partial vertex record after CallList(s), we will terminate
// the poly array compilation.  Otherwise, it is safe to continue the
// processing.

	    if (pa->pdNextVertex->flags)
	    {
		// Terminate poly array compilation
		gc->dlist.beginRec = NULL;

		if (gc->dlist.mode == GL_COMPILE)
		{
		    glsbResetBuffers(TRUE);

		    // Clear begin flag too
		    pa->flags &= ~POLYARRAY_IN_BEGIN;
		}

	    }
	}
    }
}

const GLubyte * FASTCALL __glle_CallLists(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_CallLists_Rec *data;

    data = (struct __gllc_CallLists_Rec *) PC;
    DoCallLists(data->n, data->type, (GLvoid *) (data+1));
    arraySize = __GL_PAD(__glCallListsSize(data->type)*data->n);
    size = sizeof(struct __gllc_CallLists_Rec) + arraySize;
    return PC + size;
}

void APIENTRY
glcltCallLists ( IN GLsizei n, IN GLenum type, IN const GLvoid *lists )
{
    __GL_SETUP();

    if (n < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }
    else if (n == 0) {
	return;
    }

    if ((GLint) __glCallListsSize(type) < 0) {
	GLSETERROR(GL_INVALID_ENUM);
	return;
    }

    gc->dlist.nesting = 0;
    DoCallLists(n, type, lists);
}

/************************************************************************/

// Expand a dlist
__GLdlist *__glDlistGrow(GLuint size)
{
    __GLdlist *dlist, *newDlist;
    GLubyte * UNALIGNED64 *op;
    __GL_SETUP();
        
    newDlist = __glAllocDlist(gc, size);
    if (newDlist == NULL)
    {
        GLSETERROR(GL_OUT_OF_MEMORY);
        return NULL;
    }

    // Add on record to link old block to new block
    dlist = gc->dlist.listData;

    op = (GLubyte **)(dlist->head+dlist->used);
    *(__GLlistExecFunc * UNALIGNED64 *)op = __glle_NextBlock;
    *(op+1) = newDlist->head;

    // Shrink old block down to remove any wasted space at the end of it
    dlist = __glShrinkDlist(gc, dlist);
    
    // Link new block into chain
    newDlist->nextBlock = dlist;
    gc->dlist.listData = newDlist;

    return newDlist;
}

// Shrink a dlist block down to the minimum size
// Guaranteed not to fail since we can always just use the overly
// large block if the realloc fails
// NOTE: This function should only be used during build time
// where the nextBlock links are in the opposite direction of
// the __glle_NextBlock link record links
__GLdlist *__glShrinkDlist(__GLcontext *gc, __GLdlist *dlist)
{
    __GLdlist *newDlist, *prevDlist;
    
// If the amount of unused space is small, don't bother shrinking the block.

    if (dlist->size - dlist->used < 4096)
	return dlist;

// If it is in COMPILE_AND_EXECUTE mode, flush the command buffer before
// reallocating listData.  Shrinking listData may invalidate the memory
// pointers placed in the command buffer by the the display list execution
// code.  When we are in the middle of building POLYARRAY, glsbAttention
// will not flush commands batched before the Begin call.  As a result,
// we also need to flush the command buffer before compiling the Begin call.

    if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE)
	glsbAttention();

#ifdef DL_HEAP_VERBOSE
    cbDlistTotal -= GL_MSIZE(dlist);
#endif
    
    newDlist = (__GLdlist *)GCREALLOC(gc, dlist, dlist->used+DL_OVERHEAD);

    // If the realloc fails, just use the original list
    if (newDlist != NULL)
    {
        // If the realloc moved the block, fix up the link from the
        // previous block.  This should be relatively rare
        if (newDlist != dlist && newDlist->nextBlock != NULL)
        {
            prevDlist = newDlist->nextBlock;

            ASSERTOPENGL(*(__GLlistExecFunc * UNALIGNED64 *)
                         (prevDlist->head+prevDlist->used) == __glle_NextBlock,
                         "Link not found where expected\n");
            
            *(GLubyte * UNALIGNED64 *)(prevDlist->head+prevDlist->used+
                          sizeof(__GLlistExecFunc *)) = newDlist->head;
        }

	// If we are compiling the poly array record, we need to fix up
	// the Begin pointer!  Note that if beginRec is not in the moved
	// block, the pointer does not change!
        if (newDlist != dlist && gc->dlist.beginRec &&
	    (GLubyte *) gc->dlist.beginRec >= dlist->head &&
	    (GLubyte *) gc->dlist.beginRec <= dlist->head + dlist->used)
        {
	    gc->dlist.beginRec += newDlist->head - dlist->head;
        }
        
        dlist = newDlist;
        dlist->size = dlist->used;
    }

#ifdef DL_HEAP_VERBOSE
    cbDlistTotal += GL_MSIZE(dlist);
#endif
    
    return dlist;
}

__GLdlist *__glAllocDlist(__GLcontext *gc, GLuint size)
{
    __GLdlist *dlist;
    __GLdlist temp;
    GLuint memsize;

    // Add on overhead and round size to an even block
    memsize = (size+DL_OVERHEAD+DL_BLOCK_SIZE-1) & ~(DL_BLOCK_SIZE-1);
    // Check overflow
    if (memsize < size)
	return NULL;
    size = memsize-DL_OVERHEAD;

    dlist = (__GLdlist *)GCALLOC(gc, memsize);
    if (dlist == NULL)
        return NULL;
#if 0 // NT_SERVER_SHARE_LISTS
    dlist->refcount = 1;
#else
// refcount is set to 1 in __glNamesNewData.
    dlist->refcount = 0;
#endif
    dlist->size = size;
    dlist->used = 0;
    dlist->nextBlock = NULL;
    
#ifdef DL_HEAP_VERBOSE
    cbDlistTotal += GL_MSIZE(dlist);
#endif
    
    return dlist;
}

void FASTCALL __glFreeDlist(__GLcontext *gc, __GLdlist *dlist)
{
    __GLdlist *dlistNext;
    
#ifdef NT_SERVER_SHARE_LISTS
    if (dlist->refcount != 0)
    {
        WARNING2("dlist %p refcount on free is %d\n", dlist, dlist->refcount);
    }
#endif

    while (dlist != NULL)
    {
        dlistNext = dlist->nextBlock;

#ifdef DL_HEAP_VERBOSE
        cbDlistTotal -= GL_MSIZE(dlist);
#endif
        
        GCFREE(gc, dlist);
        dlist = dlistNext;
    }

#ifdef DL_HEAP_VERBOSE
    DbgPrint("Dlists using %8d, total %8d\n",
             cbDlistTotal, glSize);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\dlist\dl_listc.c ===
/******************************Module*Header*******************************\
* Module Name: dl_listc.c (formerly soft\so_listc.c)
*
* Display list compilation routines.
*
* Created: 12-27-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.15 $
** $Date: 1993/10/23 00:34:54 $
*/
#include "precomp.h"
#pragma hdrstop

/* Generic OpenGL Client using subbatching. */

#include "glsbmsg.h"
#include "glsbmsgh.h"
#include "glsrvspt.h"
#include "subbatch.h"
#include "batchinf.h"

#include "image.h"            // __glFillImage and __glImageSize definitions

#include "listcomp.h"
#include "lcfuncs.h"
#include "dlist.h"
#include "dlistopt.h"
#include "glclt.h"

/*
** The code in here makes a lot of assumptions about the size of the 
** various user types (GLfloat, GLint, etcetra).  
*/

void APIENTRY
__gllc_Bitmap ( IN GLsizei width,
                IN GLsizei height,
                IN GLfloat xorig,
                IN GLfloat yorig,
                IN GLfloat xmove,
                IN GLfloat ymove,
                IN const GLubyte oldbits[]
              )
{
    __GLbitmap *bitmap;
    GLubyte *newbits;
    GLint imageSize;
    __GL_SETUP();

// Flush the command buffer before accessing server side gc states.

    glsbAttention();

    if ((width < 0) || (height < 0)) {
	__gllc_InvalidValue();
	return;
    }

    imageSize = height * ((width + 7) >> 3);
    imageSize = __GL_PAD(imageSize);

    bitmap = (__GLbitmap *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(imageSize + sizeof(__GLbitmap)),
                                DLIST_GENERIC_OP(Bitmap));
    if (bitmap == NULL) return;

    bitmap->width = width;
    bitmap->height = height;
    bitmap->xorig = xorig;
    bitmap->yorig = yorig;
    bitmap->xmove = xmove;
    bitmap->ymove = ymove;
    bitmap->imageSize = imageSize;

    newbits = (GLubyte *)bitmap + sizeof(__GLbitmap); 
    __glFillImage(gc, width, height, GL_COLOR_INDEX, GL_BITMAP, 
                  oldbits, newbits);

    __glDlistAppendOp(gc, bitmap, __glle_Bitmap);
}

const GLubyte * FASTCALL __glle_Bitmap(__GLcontext *gc, const GLubyte *PC)
{
    const __GLbitmap *bitmap;

// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    bitmap = (const __GLbitmap *) PC;
    GLCLIENT_BEGIN( Bitmap, BITMAP )
        pMsg->width     = bitmap->width  ;
        pMsg->height    = bitmap->height ;
        pMsg->xorig     = bitmap->xorig  ;
        pMsg->yorig     = bitmap->yorig  ;
        pMsg->xmove     = bitmap->xmove  ;
        pMsg->ymove     = bitmap->ymove  ;
        pMsg->bitmapOff = (ULONG_PTR) bitmap ;
        pMsg->_IsDlist  = GL_TRUE        ;
    GLCLIENT_END
    return PC + sizeof(__GLbitmap) + bitmap->imageSize;
}

void APIENTRY
__gllc_PolygonStipple ( const GLubyte *mask )
{
    void *data;
    __GL_SETUP();
    GLubyte *newbits;

// Flush the command buffer before accessing server side gc states.

    glsbAttention();

    newbits = (GLubyte *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(__glImageSize(32, 32, GL_COLOR_INDEX, GL_BITMAP)),
                                DLIST_GENERIC_OP(PolygonStipple));
    if (newbits == NULL) return;

    __glFillImage(gc, 32, 32, GL_COLOR_INDEX, GL_BITMAP, mask, newbits);

    __glDlistAppendOp(gc, newbits, __glle_PolygonStipple);
}

const GLubyte * FASTCALL __glle_PolygonStipple(__GLcontext *gc, const GLubyte *PC)
{
// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    GLCLIENT_BEGIN( PolygonStipple, POLYGONSTIPPLE )
        pMsg->maskOff  = (ULONG_PTR) PC ;
        pMsg->_IsDlist = GL_TRUE    ;
    GLCLIENT_END
    return PC + __glImageSize(32, 32, GL_COLOR_INDEX, GL_BITMAP);
}

void
__gllc_Map1_Internal ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint stride, IN GLint order, IN const void *points , GLboolean bDouble )
{
    __GLmap1 *map1data;
    GLint k;
    GLint cmdsize;
    __GLfloat *data;
    __GL_SETUP();
    
    k=__glEvalComputeK(target);
    if (k < 0) {
	    __gllc_InvalidEnum();
	    return;
    }

    if (order > gc->constants.maxEvalOrder || stride < k ||
	    order < 1 || u1 == u2) {
	    __gllc_InvalidValue();
	    return;
    }

    cmdsize = sizeof(__GLmap1) + 
	    __glMap1_size(k, order) * sizeof(__GLfloat);

    map1data = (__GLmap1 *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(cmdsize), DLIST_GENERIC_OP(Map1));
    if (map1data == NULL) return;

    map1data->target = target;
    map1data->u1 = u1;
    map1data->u2 = u2;
    map1data->order = order;
    data = (__GLfloat *) ((GLubyte *)map1data + sizeof(__GLmap1));
    if (bDouble)
	    __glFillMap1d(k, order, stride, (const GLdouble *) points, data);
    else
	    __glFillMap1f(k, order, stride, (const GLfloat *) points, data);

    __glDlistAppendOp(gc, map1data, __glle_Map1);
}

void APIENTRY
__gllc_Map1f ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint stride, IN GLint order, IN const GLfloat points[] )
{
    __gllc_Map1_Internal(target, u1, u2, stride, order,
	(const void *) points, GL_FALSE);
}

void APIENTRY
__gllc_Map1d ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint stride, IN GLint order, IN const GLdouble points[] )
{
    __gllc_Map1_Internal(target, (GLfloat) u1, (GLfloat) u2, stride, order,
	(const void *) points, GL_TRUE);
}

const GLubyte * FASTCALL __glle_Map1(__GLcontext *gc, const GLubyte *PC)
{
    const __GLmap1 *map1data;
    GLint k, dataSize;
    __GLevaluator1 *ev;
    __GLfloat *gc_data;
    POLYARRAY *pa;

    map1data = (const __GLmap1 *) PC;
    k = __glEvalComputeK(map1data->target);
	dataSize = __glMap1_size(k, map1data->order) * sizeof(__GLfloat);

	// Check if it is called inside a Begin-End block
    // If we are already in the begin/end bracket, return an error.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	    GLSETERROR(GL_INVALID_OPERATION);
        return PC + sizeof(__GLmap1) + dataSize;
    }

    ev = __glSetUpMap1 (gc, map1data->target, map1data->order, 
						map1data->u1, map1data->u2);
		
    if (ev != 0) 
	{
	    gc_data = gc->eval.eval1Data[__GL_EVAL1D_INDEX(map1data->target)];
		memcpy (gc_data, (GLfloat *) (PC + sizeof(__GLmap1)), dataSize);
	}

    return PC + sizeof(__GLmap1) + dataSize;
}

void
__gllc_Map2_Internal ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint ustride, IN GLint uorder, IN GLfloat v1, IN GLfloat v2, IN GLint vstride, IN GLint vorder, IN const void *points , GLboolean bDouble )
{
    __GLmap2 *map2data;
    GLint k;
    GLint cmdsize;
    __GLfloat *data;
    __GL_SETUP();

    k=__glEvalComputeK(target);
    if (k < 0) {
	__gllc_InvalidEnum();
	return;
    }

    if (vorder > gc->constants.maxEvalOrder || vstride < k ||
	    vorder < 1 || u1 == u2 || ustride < k ||
	    uorder > gc->constants.maxEvalOrder || uorder < 1 ||
	    v1 == v2) {
	__gllc_InvalidValue();
	return;
    }

    cmdsize = sizeof(__GLmap2) + 
	    __glMap2_size(k, uorder, vorder) * sizeof(__GLfloat);

    map2data = (__GLmap2 *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(cmdsize), DLIST_GENERIC_OP(Map2));
    if (map2data == NULL) return;

    map2data->target = target;
    map2data->u1 = u1;
    map2data->u2 = u2;
    map2data->uorder = uorder;
    map2data->v1 = v1;
    map2data->v2 = v2;
    map2data->vorder = vorder;

    data = (__GLfloat *) ((GLubyte *)map2data + sizeof(__GLmap2));
    if (bDouble)
	__glFillMap2d(k, uorder, vorder, ustride, vstride,
	    (const GLdouble *) points, data);
    else
	__glFillMap2f(k, uorder, vorder, ustride, vstride,
	    (const GLfloat *) points, data);

    __glDlistAppendOp(gc, map2data, __glle_Map2);
}

void APIENTRY
__gllc_Map2f ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint ustride, IN GLint uorder, IN GLfloat v1, IN GLfloat v2, IN GLint vstride, IN GLint vorder, IN const GLfloat points[] )
{
    __gllc_Map2_Internal(target, u1, u2, ustride, uorder,
	v1, v2, vstride, vorder, (const void *) points, GL_FALSE);
}

void APIENTRY
__gllc_Map2d ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint ustride, IN GLint uorder, IN GLdouble v1, IN GLdouble v2, IN GLint vstride, IN GLint vorder, IN const GLdouble points[] )
{
    __gllc_Map2_Internal(target, (GLfloat) u1, (GLfloat) u2, ustride, uorder,
	(GLfloat) v1, (GLfloat) v2, vstride, vorder, (const void *) points, GL_TRUE);
}

const GLubyte * FASTCALL __glle_Map2(__GLcontext *gc, const GLubyte *PC)
{
    const __GLmap2 *map2data;
    GLint k, dataSize;
    __GLevaluator2 *ev;
    __GLfloat *gc_data;
    POLYARRAY *pa;

    map2data = (const __GLmap2 *) PC;

    k = __glEvalComputeK (map2data->target);
	dataSize = __glMap2_size(k, map2data->uorder, map2data->vorder) * 
	                                                      sizeof(__GLfloat);
	// Check if it is called inside a Begin-End block
    // If we are already in the begin/end bracket, return an error.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	    GLSETERROR(GL_INVALID_OPERATION);
        return PC + sizeof(__GLmap2) + dataSize;
    }

    ev = __glSetUpMap2 (gc, map2data->target, 
						map2data->uorder, map2data->vorder,
						map2data->u1, map2data->u2, 
						map2data->v1, map2data->v2);
	
    if (ev != 0) 
	{
	    gc_data = gc->eval.eval2Data[__GL_EVAL2D_INDEX(map2data->target)];
		memcpy (gc_data, (GLfloat *) (PC + sizeof(__GLmap2)), dataSize);
	}
	
    return PC + sizeof(__GLmap2) + dataSize;
}


void APIENTRY
__gllc_DrawPixels ( IN GLsizei width,
                    IN GLsizei height,
                    IN GLenum format,
                    IN GLenum type,
                    IN const GLvoid *pixels
                  )
{
    __GLdrawPixels *pixdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

// Flush the command buffer before accessing server side gc states.

    glsbAttention();

    if ((width < 0) || (height < 0)) {
	__gllc_InvalidValue();
	return;
    }
    switch (format) {
      case GL_STENCIL_INDEX:
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
      case GL_DEPTH_COMPONENT:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum();
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }

    imageSize = __glImageSize(width, height, format, type);
    imageSize = __GL_PAD(imageSize);

    pixdata = (__GLdrawPixels *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLdrawPixels) + imageSize),
                                DLIST_GENERIC_OP(DrawPixels));
    if (pixdata == NULL) return;

    pixdata->width = width;
    pixdata->height = height;
    pixdata->format = format;
    pixdata->type = type;

    __glFillImage(gc, width, height, format, type, pixels, 
                  (GLubyte *)pixdata + sizeof(__GLdrawPixels));

    __glDlistAppendOp(gc, pixdata, __glle_DrawPixels);
}

const GLubyte * FASTCALL __glle_DrawPixels(__GLcontext *gc, const GLubyte *PC)
{
    const __GLdrawPixels *pixdata;
    GLint imageSize;

// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    pixdata = (const __GLdrawPixels *) PC;
    imageSize = __glImageSize(pixdata->width, pixdata->height, 
			      pixdata->format, pixdata->type);

    GLCLIENT_BEGIN( DrawPixels, DRAWPIXELS )
        pMsg->width     = pixdata->width      ;
        pMsg->height    = pixdata->height     ;
        pMsg->format    = pixdata->format     ;
        pMsg->type      = pixdata->type       ;
        pMsg->pixelsOff = (ULONG_PTR) (pixdata+1) ;
        pMsg->_IsDlist  = GL_TRUE             ;
    GLCLIENT_END
    return PC + sizeof(__GLdrawPixels) + __GL_PAD(imageSize);
}

void APIENTRY
__gllc_TexImage1D ( IN GLenum target,
                    IN GLint level,
                    IN GLint components,
                    IN GLsizei width,
                    IN GLint border,
                    IN GLenum format,
                    IN GLenum type,
                    IN const GLvoid *pixels
                  )
{
    __GLtexImage1D *texdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

// Flush the command buffer before accessing server side gc states.

    glsbAttention();

    if (border < 0 || border > 1) {
	__gllc_InvalidValue();
	return;
    }
    if (width < 0) {
	__gllc_InvalidValue();
	return;
    }
    switch (format) {
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum();
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }

    if (target == GL_PROXY_TEXTURE_1D) {
	glcltTexImage1D(target, level, components, width, border, format,
                        type, pixels);
	return;
    } else if (target != GL_TEXTURE_1D) {
	__gllc_InvalidEnum();
	return;
    } else if (pixels == NULL) {
        imageSize = 0;
    } else {
	imageSize = __glImageSize(width, 1, format, type);
    }
    imageSize = __GL_PAD(imageSize);

    texdata = (__GLtexImage1D *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLtexImage1D)+imageSize),
                                DLIST_GENERIC_OP(TexImage1D));
    if (texdata == NULL) return;

    texdata->target = target;
    texdata->level = level;
    texdata->components = components;
    texdata->width = width;
    texdata->border = border;
    texdata->format = format;
    texdata->type = type;
    texdata->imageSize = imageSize;

    if (imageSize > 0)
    {
        __glFillImage(gc, width, 1, format, type, pixels, 
                      (GLubyte *)texdata + sizeof(__GLtexImage1D));
    }

    __glDlistAppendOp(gc, texdata, __glle_TexImage1D);
}

void APIENTRY
__gllc_TexImage2D ( IN GLenum target,
                    IN GLint level,
                    IN GLint components,
                    IN GLsizei width,
                    IN GLsizei height,
                    IN GLint border,
                    IN GLenum format,
                    IN GLenum type,
                    IN const GLvoid *pixels
                  )
{
    __GLtexImage2D *texdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

// Flush the command buffer before accessing server side gc states.

    glsbAttention();

    if (border < 0 || border > 1) {
	__gllc_InvalidValue();
	return;
    }
    if ((width < 0) || (height < 0)) {
	__gllc_InvalidValue();
	return;
    }
    switch (format) {
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum();
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }

    if (target == GL_PROXY_TEXTURE_2D) {
        glcltTexImage2D(target, level, components, width, height, border,
                        format, type, pixels);
	return;
    } else if (target != GL_TEXTURE_2D) {
	__gllc_InvalidEnum();
	return;
    } else if (pixels == NULL) {
        imageSize = 0;
    } else {
        imageSize = __glImageSize(width, height, format, type);
    }
    imageSize = __GL_PAD(imageSize);

    texdata = (__GLtexImage2D *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLtexImage2D) + imageSize),
                                DLIST_GENERIC_OP(TexImage2D));
    if (texdata == NULL) return;

    texdata->target = target;
    texdata->level = level;
    texdata->components = components;
    texdata->width = width;
    texdata->height = height;
    texdata->border = border;
    texdata->format = format;
    texdata->type = type;
    texdata->imageSize = imageSize;

    if (imageSize > 0)
    {
        __glFillImage(gc, width, height, format, type, pixels, 
                      (GLubyte *) (GLubyte *)texdata + sizeof(__GLtexImage2D));
    }

    __glDlistAppendOp(gc, texdata, __glle_TexImage2D);
}

const GLubyte * FASTCALL __glle_TexImage1D(__GLcontext *gc, const GLubyte *PC)
{
    const __GLtexImage1D *data;

// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    data = (const __GLtexImage1D *) PC;
    GLCLIENT_BEGIN( TexImage1D, TEXIMAGE1D )
        pMsg->target        = data->target     ;
        pMsg->level         = data->level      ;
        pMsg->components    = data->components ;
        pMsg->width         = data->width      ;
        pMsg->border        = data->border     ;
        pMsg->format        = data->format     ;
        pMsg->type          = data->type       ;
        pMsg->pixelsOff     = data->imageSize > 0 ? (ULONG_PTR) (data+1) : 0;
        pMsg->_IsDlist      = GL_TRUE          ;
    GLCLIENT_END
    return PC + sizeof(__GLtexImage1D) + data->imageSize;
}

const GLubyte * FASTCALL __glle_TexImage2D(__GLcontext *gc, const GLubyte *PC)
{
    const __GLtexImage2D *data;

// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    data = (const __GLtexImage2D *) PC;
    GLCLIENT_BEGIN( TexImage2D, TEXIMAGE2D )
        pMsg->target        = data->target     ;
        pMsg->level         = data->level      ;
        pMsg->components    = data->components ;
        pMsg->width         = data->width      ;
        pMsg->height        = data->height     ;
        pMsg->border        = data->border     ;
        pMsg->format        = data->format     ;
        pMsg->type          = data->type       ;
        pMsg->pixelsOff     = data->imageSize > 0 ? (ULONG_PTR) (data+1) : 0;
        pMsg->_IsDlist      = GL_TRUE          ;
    GLCLIENT_END
    return PC + sizeof(__GLtexImage2D) + data->imageSize;
}

void APIENTRY __gllc_TexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                   GLsizei width, GLenum format, GLenum type,
                                   const GLvoid *pixels)
{
    __GLtexSubImage1D *texdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

// Flush the command buffer before accessing server side gc states.

    glsbAttention();

    if (width < 0) {
	__gllc_InvalidValue();
	return;
    }
    switch (format) {
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum();
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }

    imageSize = __glImageSize(width, 1, format, type);
    imageSize = __GL_PAD(imageSize);

    texdata = (__GLtexSubImage1D *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLtexSubImage1D) + imageSize),
                                DLIST_GENERIC_OP(TexSubImage1D));
    if (texdata == NULL) return;

    texdata->target = target;
    texdata->level = level;
    texdata->xoffset = xoffset;
    texdata->width = width;
    texdata->format = format;
    texdata->type = type;
    texdata->imageSize = imageSize;

    if (imageSize > 0) {
	__glFillImage(gc, width, 1, format, type, pixels, 
		(GLubyte *)texdata + sizeof(__GLtexSubImage1D));
    }

    __glDlistAppendOp(gc, texdata, __glle_TexSubImage1D);
}

void APIENTRY __gllc_TexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                   GLint yoffset, GLsizei width, GLsizei height,
                                   GLenum format, GLenum type,
                                   const GLvoid *pixels)
{
    __GLtexSubImage2D *texdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

// Flush the command buffer before accessing server side gc states.

    glsbAttention();

    if ((width < 0) || (height < 0)) {
	__gllc_InvalidValue();
	return;
    }
    switch (format) {
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum();
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }

    imageSize = __glImageSize(width, height, format, type);
    imageSize = __GL_PAD(imageSize);

    texdata = (__GLtexSubImage2D *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLtexSubImage2D) + imageSize),
                                DLIST_GENERIC_OP(TexSubImage2D));
    if (texdata == NULL) return;

    texdata->target = target;
    texdata->level = level;
    texdata->xoffset = xoffset;
    texdata->yoffset = yoffset;
    texdata->width = width;
    texdata->height = height;
    texdata->format = format;
    texdata->type = type;
    texdata->imageSize = imageSize;

    if (imageSize > 0) {
	__glFillImage(gc, width, height, format, type, pixels, 
		(GLubyte *) texdata + sizeof(__GLtexSubImage2D));
    }

    __glDlistAppendOp(gc, texdata, __glle_TexSubImage2D);
}

const GLubyte * FASTCALL __glle_TexSubImage1D(__GLcontext *gc, const GLubyte *PC)
{
    const __GLtexSubImage1D *data;

// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    data = (const __GLtexSubImage1D *) PC;
    GLCLIENT_BEGIN( TexSubImage1D, TEXSUBIMAGE1D )
        pMsg->target        = data->target     ;
        pMsg->level         = data->level      ;
        pMsg->xoffset       = data->xoffset    ;
        pMsg->width         = data->width      ;
        pMsg->format        = data->format     ;
        pMsg->type          = data->type       ;
        pMsg->pixelsOff     = (ULONG_PTR) (data+1) ;
        pMsg->_IsDlist      = GL_TRUE          ;
    GLCLIENT_END
    return PC + sizeof(__GLtexSubImage1D) + data->imageSize;
}

const GLubyte * FASTCALL __glle_TexSubImage2D(__GLcontext *gc, const GLubyte *PC)
{
    const __GLtexSubImage2D *data;

// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    data = (const __GLtexSubImage2D *) PC;
    GLCLIENT_BEGIN( TexSubImage2D, TEXSUBIMAGE2D )
        pMsg->target        = data->target     ;
        pMsg->level         = data->level      ;
        pMsg->xoffset       = data->xoffset    ;
        pMsg->yoffset       = data->yoffset    ;
        pMsg->width         = data->width      ;
        pMsg->height        = data->height     ;
        pMsg->format        = data->format     ;
        pMsg->type          = data->type       ;
        pMsg->pixelsOff     = (ULONG_PTR) (data+1) ;
        pMsg->_IsDlist      = GL_TRUE          ;
    GLCLIENT_END
    return PC + sizeof(__GLtexSubImage2D) + data->imageSize;
}

GLint __gllc_CheckColorTableArgs(GLenum target, GLsizei count,
                                 GLenum format, GLenum type)
{
    GLint imageSize;
    
    switch (type) {
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
        __gllc_InvalidEnum();
        return -1;
    }

    switch (format)
    {
      case GL_RED:
      case GL_GREEN:		case GL_BLUE:
      case GL_ALPHA:		case GL_RGB:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	break;
    default:
        __gllc_InvalidEnum();
        return -1;
    }
    
    if (target != GL_TEXTURE_1D && target != GL_TEXTURE_2D &&
        target != GL_PROXY_TEXTURE_1D && target != GL_PROXY_TEXTURE_2D)
    {
	__gllc_InvalidEnum();
	return -1;
    }
    else
    {
	imageSize = __glImageSize(count, 1, format, type);
    }
    imageSize = __GL_PAD(imageSize);
    return imageSize;
}

void APIENTRY
__gllc_ColorTableEXT ( IN GLenum target,
                       IN GLenum internalFormat,
                       IN GLsizei width,
                       IN GLenum format,
                       IN GLenum type,
                       IN const GLvoid *data
                     )
{
    __GLcolorTableEXT *record;
    GLint imageSize;
    __GL_SETUP();

    // Flush the command buffer before accessing server side gc states.
    glsbAttention();

    imageSize = __gllc_CheckColorTableArgs(target, width, format, type);
    if (imageSize < 0)
    {
        return;
    }

    switch(internalFormat)
    {
    case GL_RGB:		case 3:
    case GL_R3_G3_B2:		case GL_RGB4:
    case GL_RGB5:		case GL_RGB8:
    case GL_RGB10:	        case GL_RGB12:
    case GL_RGB16:
#ifdef GL_EXT_bgra
    case GL_BGR_EXT:
#endif
        break;
    case GL_RGBA:		case 4:
    case GL_RGBA2:	        case GL_RGBA4:
    case GL_RGBA8:              case GL_RGB5_A1:
    case GL_RGBA12:             case GL_RGBA16:
    case GL_RGB10_A2:
#ifdef GL_EXT_bgra
    case GL_BGRA_EXT:
#endif
        break;
    default:
        __gllc_InvalidEnum();
        return;
    }

    record = (__GLcolorTableEXT *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLcolorTableEXT)+imageSize),
                                DLIST_GENERIC_OP(ColorTableEXT));
    if (record == NULL) return;

    record->target = target;
    record->internalFormat = internalFormat;
    record->width = width;
    record->format = format;
    record->type = type;
    record->imageSize = imageSize;

    if (imageSize > 0)
    {
        __glFillImage(gc, width, 1, format, type, data, 
                      (GLubyte *)record + sizeof(__GLcolorTableEXT));
    }

    __glDlistAppendOp(gc, record, __glle_ColorTableEXT);
}

const GLubyte * FASTCALL __glle_ColorTableEXT(__GLcontext *gc,
                                              const GLubyte *PC)
{
    const __GLcolorTableEXT *data;

// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    data = (const __GLcolorTableEXT *) PC;
    GLCLIENT_BEGIN( ColorTableEXT, COLORTABLEEXT )
        pMsg->target        = data->target     ;
        pMsg->internalFormat = data->internalFormat;
        pMsg->width         = data->width      ;
        pMsg->format        = data->format     ;
        pMsg->type          = data->type       ;
        pMsg->data          = (const GLvoid *) (data+1);
        pMsg->_IsDlist      = GL_TRUE          ;
    GLCLIENT_END
    return PC + sizeof(__GLcolorTableEXT) + data->imageSize;
}

void APIENTRY
__gllc_ColorSubTableEXT ( IN GLenum target,
                          IN GLsizei start,
                          IN GLsizei count,
                          IN GLenum format,
                          IN GLenum type,
                          IN const GLvoid *data
                          )
{
    __GLcolorSubTableEXT *record;
    GLint imageSize;
    __GL_SETUP();

    // Flush the command buffer before accessing server side gc states.
    glsbAttention();

    imageSize = __gllc_CheckColorTableArgs(target, count, format, type);
    if (imageSize < 0)
    {
        return;
    }

    record = (__GLcolorSubTableEXT *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLcolorSubTableEXT)+imageSize),
                                DLIST_GENERIC_OP(ColorSubTableEXT));
    if (record == NULL) return;

    record->target = target;
    record->start = start;
    record->count = count;
    record->format = format;
    record->type = type;
    record->imageSize = imageSize;

    if (imageSize > 0)
    {
        __glFillImage(gc, count, 1, format, type, data, 
                      (GLubyte *)record + sizeof(__GLcolorSubTableEXT));
    }

    __glDlistAppendOp(gc, record, __glle_ColorSubTableEXT);
}

const GLubyte * FASTCALL __glle_ColorSubTableEXT(__GLcontext *gc,
                                                 const GLubyte *PC)
{
    const __GLcolorSubTableEXT *data;

// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    data = (const __GLcolorSubTableEXT *) PC;
    GLCLIENT_BEGIN( ColorSubTableEXT, COLORSUBTABLEEXT )
        pMsg->target        = data->target     ;
        pMsg->start         = data->start      ;
        pMsg->count         = data->count      ;
        pMsg->format        = data->format     ;
        pMsg->type          = data->type       ;
        pMsg->data          = (const GLvoid *) (data+1);
        pMsg->_IsDlist      = GL_TRUE          ;
    GLCLIENT_END
    return PC + sizeof(__GLcolorSubTableEXT) + data->imageSize;
}

#ifdef GL_WIN_multiple_textures
void APIENTRY __gllc_CurrentTextureIndexWIN
    (GLuint index)
{
    struct __gllc_CurrentTextureIndexWIN_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_CurrentTextureIndexWIN_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_CurrentTextureIndexWIN_Rec)),
                                DLIST_GENERIC_OP(CurrentTextureIndexWIN));
    if (data == NULL) return;
    data->index = index;
    __glDlistAppendOp(gc, data, __glle_CurrentTextureIndexWIN);
}

void APIENTRY __gllc_BindNthTextureWIN
    (GLuint index, GLenum target, GLuint texture)
{
    struct __gllc_BindNthTextureWIN_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_BindNthTextureWIN_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_BindNthTextureWIN_Rec)),
                                DLIST_GENERIC_OP(BindNthTextureWIN));
    if (data == NULL) return;
    data->index = index;
    data->target = target;
    data->texture = texture;
    __glDlistAppendOp(gc, data, __glle_BindNthTextureWIN);
}

void APIENTRY __gllc_NthTexCombineFuncWIN
    (GLuint index,
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor)
{
    struct __gllc_NthTexCombineFuncWIN_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_NthTexCombineFuncWIN_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_NthTexCombineFuncWIN_Rec)),
                                DLIST_GENERIC_OP(NthTexCombineFuncWIN));
    if (data == NULL) return;
    data->index = index;
    data->leftColorFactor = leftColorFactor;
    data->colorOp = colorOp;
    data->rightColorFactor = rightColorFactor;
    data->leftAlphaFactor = leftAlphaFactor;
    data->alphaOp = alphaOp;
    data->rightAlphaFactor = rightAlphaFactor;
    __glDlistAppendOp(gc, data, __glle_NthTexCombineFuncWIN);
}
#endif // GL_WIN_multiple_textures
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\dlist\dl_opt.c ===
/******************************Module*Header*******************************\
* Module Name: dl_opt.c
*
* Display list compilation error routines.
*
* Created: 12-24-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995-96 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1991, 1922, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop

#include "glclt.h"

void FASTCALL VA_ArrayElementCompile(__GLcontext *gc, GLint i);

/************************************************************************/

/*
** Optimized errors.  Strange but true.  These are called to save an error
** in the display list.
*/
void __gllc_InvalidValue()
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(InvalidValue));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_InvalidValue);
}

void __gllc_InvalidEnum()
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(InvalidEnum));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_InvalidEnum);
}

void __gllc_InvalidOperation()
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(InvalidOperation));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_InvalidOperation);
}

/*
** These routines execute an error stored in a display list.
*/
const GLubyte * FASTCALL __glle_InvalidValue(__GLcontext *gc, const GLubyte *PC)
{
    GLSETERROR(GL_INVALID_VALUE);
    return PC;
}

const GLubyte * FASTCALL __glle_InvalidEnum(__GLcontext *gc, const GLubyte *PC)
{
    GLSETERROR(GL_INVALID_ENUM);
    return PC;
}

const GLubyte * FASTCALL __glle_InvalidOperation(__GLcontext *gc, const GLubyte *PC)
{
    GLSETERROR(GL_INVALID_OPERATION);
    return PC;
}

/***************************************************************************/
// This function compiles a poly material structure.  It does not
// execute the record in COMPILE_AND_EXECUTE mode.  The execution is done
// when the poly array buffer is flushed.
void APIENTRY __gllc_PolyMaterial(GLuint faceName, __GLmatChange *pdMat)
{
    GLubyte *data, *data0;
    GLuint  dirtyBits;
    GLuint  size, newSize;
    __GL_SETUP();

    ASSERTOPENGL(faceName == POLYDATA_MATERIAL_FRONT ||
		 faceName == POLYDATA_MATERIAL_BACK, "bad faceName\n");

    // Allocate big enough record and resize it later
    size = sizeof(__GLmatChange) + sizeof(GLuint) + sizeof(GLuint);
    data = (GLubyte *) __glDlistAddOpUnaligned(gc, DLIST_SIZE(size),
		DLIST_GENERIC_OP(PolyMaterial));
    if (data == NULL) return;
    data0 = data;
    dirtyBits = pdMat->dirtyBits;

    // Skip size field to be filled in last
    ((GLuint *)data)++;

    // Record face name
    *((GLuint *) data)++ = faceName;

    *((GLuint *) data)++ = dirtyBits;

    if (dirtyBits & __GL_MATERIAL_AMBIENT)
	*((__GLcolor *) data)++ = pdMat->ambient;

    if (dirtyBits & __GL_MATERIAL_DIFFUSE)
	*((__GLcolor *) data)++ = pdMat->diffuse;

    if (dirtyBits & __GL_MATERIAL_SPECULAR)
	*((__GLcolor *) data)++ = pdMat->specular;

    if (dirtyBits & __GL_MATERIAL_EMISSIVE)
	*((__GLcolor *) data)++ = pdMat->emissive;

    if (dirtyBits & __GL_MATERIAL_SHININESS)
	*((__GLfloat *) data)++ = pdMat->shininess;

    if (dirtyBits & __GL_MATERIAL_COLORINDEXES)
    {
	*((__GLfloat *) data)++ = pdMat->cmapa;
	*((__GLfloat *) data)++ = pdMat->cmapd;
	*((__GLfloat *) data)++ = pdMat->cmaps;
    }

    // Now fill in the size field
    newSize = (GLuint) (data - data0);
    *((GLuint *) data0) = newSize;

    // Resize the record
    __glDlistResizeCurrentOp(gc, DLIST_SIZE(size), DLIST_SIZE(newSize));
}

// Playback a PolyMaterial record in Begin.
const GLubyte * FASTCALL __glle_PolyMaterial(__GLcontext *gc, const GLubyte *PC)
{
    GLubyte   *data;
    POLYARRAY *pa;
    POLYDATA  *pd;
    GLuint    size, faceName, dirtyBits;
    __GLmatChange *pdMat;
    POLYMATERIAL *pm;

    data = (GLubyte *) PC;

    size      = *((GLuint *) data)++;
    faceName  = *((GLuint *) data)++;
    dirtyBits = *((GLuint *) data)++;

    ASSERTOPENGL(faceName == POLYDATA_MATERIAL_FRONT ||
		 faceName == POLYDATA_MATERIAL_BACK, "bad faceName\n");

    pa = gc->paTeb;
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
// Update pa flags POLYARRAY_MATERIAL_FRONT and POLYARRAY_MATERIAL_BACK.

	pa->flags |= faceName;

// Do front or back material for this vertex.
// Overwrite the previous material changes for this vertex if they exist since
// only the last material changes matter.

	pd = pa->pdNextVertex;

	// allocate __GLmatChange structure if this vertex hasn't got one
	if (!(pd->flags & faceName))
	{
	    if (!(pdMat = PAMatAlloc()))
		return PC + size;

	    // Get POLYMATERIAL pointer after PAMatAlloc!
	    pm = GLTEB_CLTPOLYMATERIAL();
	    if (faceName == POLYDATA_MATERIAL_FRONT)
		pm->pdMaterial0[pd - pa->pdBuffer0].front = pdMat;
	    else
		pm->pdMaterial0[pd - pa->pdBuffer0].back  = pdMat;

	    pdMat->dirtyBits = dirtyBits;
	}
	else
	{
	    pm = GLTEB_CLTPOLYMATERIAL();
	    if (faceName == POLYDATA_MATERIAL_FRONT)
		pdMat = pm->pdMaterial0[pd - pa->pdBuffer0].front;
	    else
		pdMat = pm->pdMaterial0[pd - pa->pdBuffer0].back;

	    pdMat->dirtyBits |= dirtyBits;
	}

	if (dirtyBits & __GL_MATERIAL_AMBIENT)
	    pdMat->ambient = *((__GLcolor *) data)++;

	if (dirtyBits & __GL_MATERIAL_DIFFUSE)
	    pdMat->diffuse = *((__GLcolor *) data)++;

	if (dirtyBits & __GL_MATERIAL_SPECULAR)
	    pdMat->specular = *((__GLcolor *) data)++;

	if (dirtyBits & __GL_MATERIAL_EMISSIVE)
	    pdMat->emissive = *((__GLcolor *) data)++;

	if (dirtyBits & __GL_MATERIAL_SHININESS)
	    pdMat->shininess = *((__GLfloat *) data)++;

	if (dirtyBits & __GL_MATERIAL_COLORINDEXES)
	{
	    pdMat->cmapa = *((__GLfloat *) data)++;
	    pdMat->cmapd = *((__GLfloat *) data)++;
	    pdMat->cmaps = *((__GLfloat *) data)++;
	}

// Finally, update pd flags

	pd->flags |= faceName;
    }
    else
    {
// Something went wrong at playback time!  We can either try to playback
// this record using the regular API or punt it altogether.  I cannot think
// of a situation when this can happen, so we will punt it for now.

	WARNING("Display list: playing back POLYMATERIAL outside BEGIN!\n");
    }

    return PC + size;
}

// Compile a PolyData structure in Begin.  If the poly data contains
// material changes, it will call __gllc_PolyMaterial to compile the material
// changes.  This function does not execute the record in COMPILE_AND_EXECUTE
// mode.  The execution is done when the poly array buffer is flushed.
void APIENTRY __glDlistCompilePolyData(__GLcontext *gc, GLboolean bPartial)
{
    POLYARRAY *pa;
    POLYDATA  *pd;
    GLubyte *data, *data0;
    GLuint  pdflags;
    GLuint  size, newSize;
    __GLlistExecFunc *fp;

    ASSERTOPENGL(gc->dlist.beginRec, "not in being!\n");

// If we have already recorded it in PolyArrayFlushPartialPrimitive, skip it.

    if (gc->dlist.skipPolyData)
    {
	gc->dlist.skipPolyData = GL_FALSE;
	return;
    }

    pa = gc->paTeb;
    if (bPartial)
    {
	// Record only current attribute changes
	pd = pa->pdNextVertex;
	if (!pd->flags)
	    return;
    }
    else
    {
	pd = pa->pdNextVertex - 1;
    }

// Record material changes first.

    if (pd->flags & (POLYDATA_MATERIAL_FRONT | POLYDATA_MATERIAL_BACK))
    {
	POLYMATERIAL *pm;

	pm = GLTEB_CLTPOLYMATERIAL();

	if (pd->flags & POLYDATA_MATERIAL_FRONT)
	    __gllc_PolyMaterial(POLYDATA_MATERIAL_FRONT,
		pm->pdMaterial0[pd - pa->pdBuffer0].front);

	if (pd->flags & POLYDATA_MATERIAL_BACK)
	    __gllc_PolyMaterial(POLYDATA_MATERIAL_BACK,
		pm->pdMaterial0[pd - pa->pdBuffer0].back);

	if (bPartial)
	{
	    if (!(pd->flags & ~(POLYDATA_MATERIAL_FRONT | POLYDATA_MATERIAL_BACK)))
		return;
	}
    }

// Record POLYARRAY_CLAMP_COLOR flag in the begin record.

    if (pa->flags & POLYARRAY_CLAMP_COLOR)
	gc->dlist.beginRec->flags |= DLIST_BEGIN_HAS_CLAMP_COLOR;

// Make sure that we handle all the flags!

    ASSERTOPENGL(
    !(pd->flags &
      ~(POLYDATA_EDGEFLAG_BOUNDARY |
        POLYDATA_EDGEFLAG_VALID |
        POLYDATA_COLOR_VALID |
        POLYDATA_NORMAL_VALID |
        POLYDATA_TEXTURE_VALID |
        POLYDATA_VERTEX2 |
        POLYDATA_VERTEX3 |
        POLYDATA_VERTEX4 |
        POLYDATA_DLIST_COLOR_4 |
        POLYDATA_FOG_VALID   |
        POLYDATA_DLIST_TEXTURE1 |
        POLYDATA_DLIST_TEXTURE2 |
        POLYDATA_DLIST_TEXTURE3 |
        POLYDATA_DLIST_TEXTURE4 |
        POLYDATA_MATERIAL_FRONT |
        POLYDATA_MATERIAL_BACK)),
    "Unknown POLYDATA flags!\n");

// Get the flags that we are interested.

    pdflags = pd->flags &
	   (POLYDATA_EDGEFLAG_BOUNDARY |
	    POLYDATA_EDGEFLAG_VALID |
	    POLYDATA_COLOR_VALID |
	    POLYDATA_NORMAL_VALID |
	    POLYDATA_TEXTURE_VALID |
	    POLYDATA_VERTEX2 |
	    POLYDATA_VERTEX3 |
	    POLYDATA_VERTEX4 |
	    POLYDATA_DLIST_COLOR_4 |
	    POLYDATA_DLIST_TEXTURE1 |
	    POLYDATA_DLIST_TEXTURE2 |
	    POLYDATA_DLIST_TEXTURE3 |
	    POLYDATA_DLIST_TEXTURE4);

// Find out if it matches one of the following packed data structure for
// fast playback.
//   C3F_V3F
//   N3F_V3F
//   C3F_N3F_V3F (non 1.1 format)
//   C4F_N3F_V3F
//   T2F_V3F
//   T2F_C3F_V3F
//   T2F_N3F_V3F
//   T2F_C3F_N3F_V3F (non 1.1 format)
//   T2F_C4F_N3F_V3F

#define VTYPE_V2F	      (POLYDATA_VERTEX2)
#define VTYPE_V3F	      (POLYDATA_VERTEX3)
#define VTYPE_V4F	      (POLYDATA_VERTEX4)
#define VTYPE_C3F	      (POLYDATA_COLOR_VALID)
#define VTYPE_C4F	      (POLYDATA_COLOR_VALID | POLYDATA_DLIST_COLOR_4)
#define VTYPE_N3F	      (POLYDATA_NORMAL_VALID)
#define VTYPE_T2F	      (POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE2)
#define VTYPE_C3F_V3F         (VTYPE_C3F | VTYPE_V3F)
#define VTYPE_N3F_V3F         (VTYPE_N3F | VTYPE_V3F)
#define VTYPE_C3F_N3F_V3F     (VTYPE_C3F | VTYPE_N3F | VTYPE_V3F)
#define VTYPE_C4F_N3F_V3F     (VTYPE_C4F | VTYPE_N3F | VTYPE_V3F)
#define VTYPE_T2F_V3F         (VTYPE_T2F | VTYPE_V3F)
#define VTYPE_T2F_C3F_V3F     (VTYPE_T2F | VTYPE_C3F | VTYPE_V3F)
#define VTYPE_T2F_N3F_V3F     (VTYPE_T2F | VTYPE_N3F | VTYPE_V3F)
#define VTYPE_T2F_C3F_N3F_V3F (VTYPE_T2F | VTYPE_C3F | VTYPE_N3F | VTYPE_V3F)
#define VTYPE_T2F_C4F_N3F_V3F (VTYPE_T2F | VTYPE_C4F | VTYPE_N3F | VTYPE_V3F)

    // Default playback routine
    fp = __glle_PolyData;

    if (!gc->modes.colorIndexMode &&
	!(pdflags & (POLYDATA_EDGEFLAG_BOUNDARY |
		     POLYDATA_EDGEFLAG_VALID)))
    {
	switch (pdflags)
	{
	  case VTYPE_V2F:
	  case VTYPE_V3F:
	  case VTYPE_V4F:
	    ASSERTOPENGL(gc->dlist.mode != GL_COMPILE,
		"should have been recorded as a Vertex call\n");
	    break;
	  case VTYPE_C3F_V3F:
	    fp = __glle_PolyData_C3F_V3F;
	    break;
	  case VTYPE_N3F_V3F:
            fp = __glle_PolyData_N3F_V3F;
	    break;
	  case VTYPE_C3F_N3F_V3F:
            fp = __glle_PolyData_C3F_N3F_V3F;
	    break;
	  case VTYPE_C4F_N3F_V3F:
            fp = __glle_PolyData_C4F_N3F_V3F;
	    break;
	  case VTYPE_T2F_V3F:
            fp = __glle_PolyData_T2F_V3F;
	    break;
	  case VTYPE_T2F_C3F_V3F:
            fp = __glle_PolyData_T2F_C3F_V3F;
	    break;
	  case VTYPE_T2F_N3F_V3F:
            fp = __glle_PolyData_T2F_N3F_V3F;
	    break;
	  case VTYPE_T2F_C3F_N3F_V3F:
            fp = __glle_PolyData_T2F_C3F_N3F_V3F;
	    break;
	  case VTYPE_T2F_C4F_N3F_V3F:
            fp = __glle_PolyData_T2F_C4F_N3F_V3F;
	    break;
	}
    }

// Allocate the dlist record.  Allocate big enough record and resize it later.

    size = sizeof(POLYDATA) + sizeof(GLuint);
    data = (GLubyte *) __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), fp);
    if (data == NULL) return;
    data0 = data;
  
// Increment vertex count.

    if (!bPartial)
	gc->dlist.beginRec->nVertices++;

// Compile the poly data record.
// The fast poly data records do not include size and flags fields.

    if (fp == __glle_PolyData)
    {
	// Skip size field to be filled in last
	((GLuint *) data)++;

	// flags and edge flag
	*((GLuint *) data)++ = pdflags;
    }

    // Texture coord
    if (pdflags & (POLYDATA_DLIST_TEXTURE4 | POLYDATA_DLIST_TEXTURE3
		 | POLYDATA_DLIST_TEXTURE2 | POLYDATA_DLIST_TEXTURE1))
    {
	*((__GLfloat *) data)++ = pd->texture.x;
	if (pdflags & (POLYDATA_DLIST_TEXTURE4 | POLYDATA_DLIST_TEXTURE3
		     | POLYDATA_DLIST_TEXTURE2))
	{
	    *((__GLfloat *) data)++ = pd->texture.y;
	    if (pdflags & (POLYDATA_DLIST_TEXTURE4 | POLYDATA_DLIST_TEXTURE3))
	    {
		*((__GLfloat *) data)++ = pd->texture.z;
		if (pdflags & (POLYDATA_DLIST_TEXTURE4))
		    *((__GLfloat *) data)++ = pd->texture.w;
	    }
	}
    }

    // Color
    if (pdflags & POLYDATA_COLOR_VALID)
    {
	*((__GLfloat *) data)++ = pd->colors[0].r;
	if (!gc->modes.colorIndexMode)
	{
	    *((__GLfloat *) data)++ = pd->colors[0].g;
	    *((__GLfloat *) data)++ = pd->colors[0].b;
	    if (pdflags & POLYDATA_DLIST_COLOR_4)
		*((__GLfloat *) data)++ = pd->colors[0].a;
	}
    }

    // Normal
    if (pdflags & POLYDATA_NORMAL_VALID)
    {
	*((__GLfloat *) data)++ = pd->normal.x;
	*((__GLfloat *) data)++ = pd->normal.y;
	*((__GLfloat *) data)++ = pd->normal.z;
    }

    // Vertex, evalcoord1, evalcoord2, evapoint1, or evalpoint2
    if (pdflags & (POLYDATA_VERTEX2 | POLYDATA_VERTEX3 | POLYDATA_VERTEX4)) 
    {
	    ASSERTOPENGL(!bPartial, "vertex unexpected\n");
	    *((__GLfloat *) data)++ = pd->obj.x;
	    if (pdflags & (POLYDATA_VERTEX2 | POLYDATA_VERTEX3 | POLYDATA_VERTEX4))
	    {
	        *((__GLfloat *) data)++ = pd->obj.y;
	        if (pdflags & (POLYDATA_VERTEX3 | POLYDATA_VERTEX4))
	        {
		        *((__GLfloat *) data)++ = pd->obj.z;
		        if (pdflags & (POLYDATA_VERTEX4))
		            *((__GLfloat *) data)++ = pd->obj.w;
	        }
	    }
    }
    else
    {
	    ASSERTOPENGL(bPartial, "vertex expected\n");
    }

    // Now fill in the size field
    newSize = (GLuint) (data - data0);
    if (fp == __glle_PolyData)
	*((GLuint *) data0) = newSize;

    // Resize the record
    __glDlistResizeCurrentOp(gc, DLIST_SIZE(size), DLIST_SIZE(newSize));
}

#ifndef __GL_ASM_FAST_DLIST_PLAYBACK

// Define fast playback routines for PolyData records.
#define __GLLE_POLYDATA_C3F_V3F		1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_C3F_V3F
#define __GLLE_POLYDATA_N3F_V3F		1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_N3F_V3F
#define __GLLE_POLYDATA_C3F_N3F_V3F	1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_C3F_N3F_V3F
#define __GLLE_POLYDATA_C4F_N3F_V3F	1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_C4F_N3F_V3F
#define __GLLE_POLYDATA_T2F_V3F		1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_T2F_V3F
#define __GLLE_POLYDATA_T2F_C3F_V3F	1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_T2F_C3F_V3F
#define __GLLE_POLYDATA_T2F_N3F_V3F	1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_T2F_N3F_V3F
#define __GLLE_POLYDATA_T2F_C3F_N3F_V3F	1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_T2F_C3F_N3F_V3F
#define __GLLE_POLYDATA_T2F_C4F_N3F_V3F	1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_T2F_C4F_N3F_V3F

#endif	// __GL_ASM_FAST_DLIST_PLAYBACK

// Playback a PolyData record in Begin.
const GLubyte * FASTCALL __glle_PolyData(__GLcontext *gc, const GLubyte *PC)
{
    GLubyte   *data;
    POLYARRAY *pa;
    POLYDATA  *pd;
    GLuint    size, pdflags;

    data = (GLubyte *) PC;

    size = *((GLuint *) data)++;

    pa = gc->paTeb;
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	pdflags = *((GLuint *) data)++;

// Make sure that we handle all the flags!

	ASSERTOPENGL(
	    !(pdflags &
	      ~(POLYDATA_EDGEFLAG_BOUNDARY |
		POLYDATA_EDGEFLAG_VALID |
		POLYDATA_COLOR_VALID |
		POLYDATA_NORMAL_VALID |
		POLYDATA_TEXTURE_VALID |
		POLYDATA_VERTEX2 |
		POLYDATA_VERTEX3 |
		POLYDATA_VERTEX4 |
		POLYDATA_DLIST_COLOR_4 |
		POLYDATA_DLIST_TEXTURE1 |
		POLYDATA_DLIST_TEXTURE2 |
		POLYDATA_DLIST_TEXTURE3 |
		POLYDATA_DLIST_TEXTURE4)),
	    "Unknown POLYDATA flags!\n");

// Update pa flags.

	pa->flags |= pdflags &
		    (POLYARRAY_VERTEX2 | POLYARRAY_VERTEX3 | POLYARRAY_VERTEX4 |
		     POLYARRAY_TEXTURE1 | POLYARRAY_TEXTURE2 |
		     POLYARRAY_TEXTURE3 | POLYARRAY_TEXTURE4);

// Update pd attributes.

	pd = pa->pdNextVertex;
	pd->flags |= (pdflags & ~POLYDATA_EDGEFLAG_BOUNDARY);

	// Edge flag
	if (pdflags & POLYDATA_EDGEFLAG_VALID)
	{
	    // Clear the edge flag here since they may be a previous edge flag
	    pd->flags &= ~POLYDATA_EDGEFLAG_BOUNDARY;
	    pd->flags |= pdflags;
	    pa->pdCurEdgeFlag = pd;
	}

	// Texture coord
	// We need to be careful here if it has 2 TexCoord calls with
	// different sizes.
	if (pdflags & (POLYDATA_DLIST_TEXTURE4 | POLYDATA_DLIST_TEXTURE3
		     | POLYDATA_DLIST_TEXTURE2 | POLYDATA_DLIST_TEXTURE1))
	{
	    pd->texture.x = *((__GLfloat *) data)++;
	    pa->pdCurTexture = pd;

	    if (pdflags & (POLYDATA_DLIST_TEXTURE4 | POLYDATA_DLIST_TEXTURE3
			 | POLYDATA_DLIST_TEXTURE2))
		pd->texture.y = *((__GLfloat *) data)++;
	    else
		pd->texture.y = __glZero;
	    if (pdflags & (POLYDATA_DLIST_TEXTURE4 | POLYDATA_DLIST_TEXTURE3))
		pd->texture.z = *((__GLfloat *) data)++;
	    else
		pd->texture.z = __glZero;
	    if (pdflags & (POLYDATA_DLIST_TEXTURE4))
		pd->texture.w = *((__GLfloat *) data)++;
	    else
		pd->texture.w = __glOne;
	}

	// Color
	if (pdflags & POLYDATA_COLOR_VALID)
	{
	    pd->color[0].r = *((__GLfloat *) data)++;
	    if (!gc->modes.colorIndexMode)
	    {
		pd->color[0].g = *((__GLfloat *) data)++;
		pd->color[0].b = *((__GLfloat *) data)++;
		if (pdflags & POLYDATA_DLIST_COLOR_4)
		    pd->color[0].a = *((__GLfloat *) data)++;
		else
		    pd->color[0].a = gc->alphaVertexScale;
	    }
	    pa->pdCurColor = pd;
	}

	// Normal
	if (pdflags & POLYDATA_NORMAL_VALID)
	{
	    pd->normal.x = *((__GLfloat *) data)++;
	    pd->normal.y = *((__GLfloat *) data)++;
	    pd->normal.z = *((__GLfloat *) data)++;
	    pa->pdCurNormal = pd;
	}

	// Vertex, evalcoord1, evalcoord2, evapoint1, or evalpoint2
	if (pdflags &
	    (POLYARRAY_VERTEX2 | POLYARRAY_VERTEX3 | POLYARRAY_VERTEX4))
	{
	    pd->obj.x = *((__GLfloat *) data)++;

	    if (pdflags & (POLYDATA_VERTEX2 | POLYDATA_VERTEX3 | POLYDATA_VERTEX4))
		    pd->obj.y = *((__GLfloat *) data)++;
	    if (pdflags & (POLYDATA_VERTEX3 | POLYDATA_VERTEX4))
		    pd->obj.z = *((__GLfloat *) data)++;
	    else
		    pd->obj.z = __glZero;
	    if (pdflags & (POLYDATA_VERTEX4))
		    pd->obj.w = *((__GLfloat *) data)++;
	    else
		    pd->obj.w = __glOne;

	    // Advance vertex pointer
	    pa->pdNextVertex++;
	    pd[1].flags = 0;

	    if (pd >= pa->pdFlush)
		    PolyArrayFlushPartialPrimitive();
	}
    }
    else
    {
// Something went wrong at playback time!  We can either try to playback
// this record using the regular API or punt it altogether.  I cannot think
// of a situation when this can happen, so we will punt it for now.

	WARNING("Display list: playing back POLYDATA outside BEGIN!\n");
    }

    return PC + size;
}

void APIENTRY __gllc_ArrayElement(GLint i)
{
    __GL_SETUP();

    if (gc->vertexArray.flags & __GL_VERTEX_ARRAY_DIRTY)
	VA_ValidateArrayPointers(gc);

    VA_ArrayElementCompile(gc, i);
}

#define COMPILEARRAYPOINTER(ap, i) \
    ((*(ap).pfnCompile)((ap).pointer + (i) * (ap).ibytes))

void FASTCALL VA_ArrayElementCompile(__GLcontext *gc, GLint i)
{
    GLuint vaMask = gc->vertexArray.mask;

// Call the individual compilation routines.  They handle Begin mode,
// color mode, and COMPILE_AND_EXECUTE mode correctly.

    if (vaMask & VAMASK_EDGEFLAG_ENABLE_MASK)
	COMPILEARRAYPOINTER(gc->vertexArray.edgeFlag, i);
    if (vaMask & VAMASK_TEXCOORD_ENABLE_MASK)
        COMPILEARRAYPOINTER(gc->vertexArray.texCoord, i);
    if (vaMask & VAMASK_COLOR_ENABLE_MASK)
        COMPILEARRAYPOINTER(gc->vertexArray.color, i);
    if (vaMask & VAMASK_INDEX_ENABLE_MASK)
        COMPILEARRAYPOINTER(gc->vertexArray.index, i);
    if (vaMask & VAMASK_NORMAL_ENABLE_MASK)
        COMPILEARRAYPOINTER(gc->vertexArray.normal, i);
    if (vaMask & VAMASK_VERTEX_ENABLE_MASK)
        COMPILEARRAYPOINTER(gc->vertexArray.vertex, i);
}

// Compile DrawArrays into Begin/End records.  Since Begin/End records
// contain optimized POLYDATA records, execution speed of these records
// is optimal.  However, it takes longer to compile this function using
// this approach.  But with this method, we don't have to deal with color
// mode and COMPILE_AND_EXECUTE mode here.
void APIENTRY __gllc_DrawArrays(GLenum mode, GLint first, GLsizei count)
{
    int i;
    POLYARRAY    *pa;
    __GL_SETUP();

    pa = gc->paTeb;

// Not allowed in begin/end.

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	__gllc_InvalidOperation();
	return;
    }

    if ((GLuint) mode > GL_POLYGON)
    {
	__gllc_InvalidEnum();
	return;
    }

    if (count < 0)
    {
	__gllc_InvalidValue();
        return;
    } else if (!count)
        return;

// Find array element function to use.

    if (gc->vertexArray.flags & __GL_VERTEX_ARRAY_DIRTY)
	VA_ValidateArrayPointers(gc);

// Draw the array elements.

    __gllc_Begin(mode);
    gc->dlist.beginRec->flags |= DLIST_BEGIN_DRAWARRAYS;

    for (i = 0; i < count; i++)
	VA_ArrayElementCompile(gc, first + i);

    __gllc_End();
}

#define __GL_PAD8(x)    (((x) + 7) & ~7)

GLuint FASTCALL __glDrawElements_size(__GLcontext *gc, GLsizei nVertices,
    GLsizei nElements, struct __gllc_DrawElements_Rec *rec)
{
    GLuint size;
    GLuint vaMask;

// Compute the size of each of the six arrays.  Always keep size and address
// QWORD aligned since some arrays may use GLdouble.

    size = __GL_PAD8(sizeof(struct __gllc_DrawElements_Rec));
    vaMask = gc->vertexArray.mask;

    if (vaMask & VAMASK_EDGEFLAG_ENABLE_MASK)
    {
	rec->edgeFlagOff = size;
	size += __GL_PAD8(nVertices * sizeof(GLboolean));
    }
    else
	rec->edgeFlagOff = 0;

    if (vaMask & VAMASK_TEXCOORD_ENABLE_MASK)
    {
	rec->texCoordOff = size;
	size += __GL_PAD8(nVertices * gc->vertexArray.texCoord.size *
			  __GLTYPESIZE(gc->vertexArray.texCoord.type));
    }
    else
	rec->texCoordOff = 0;

    if (vaMask & VAMASK_COLOR_ENABLE_MASK)
    {
	rec->colorOff = size;
	size += __GL_PAD8(nVertices * gc->vertexArray.color.size *
			  __GLTYPESIZE(gc->vertexArray.color.type));
    }
    else
	rec->colorOff = 0;

    if (vaMask & VAMASK_INDEX_ENABLE_MASK)
    {
	rec->indexOff = size;
	size += __GL_PAD8(nVertices * __GLTYPESIZE(gc->vertexArray.index.type));
    }
    else
	rec->indexOff = 0;

    if (vaMask & VAMASK_NORMAL_ENABLE_MASK)
    {
	rec->normalOff = size;
	size += __GL_PAD8(nVertices * 3 *
			  __GLTYPESIZE(gc->vertexArray.normal.type));
    }
    else
	rec->normalOff = 0;

    if (vaMask & VAMASK_VERTEX_ENABLE_MASK)
    {
	rec->vertexOff = size;
	size += __GL_PAD8(nVertices * gc->vertexArray.vertex.size *
			  __GLTYPESIZE(gc->vertexArray.vertex.type));
    }
    else
	rec->vertexOff = 0;

    rec->mapOff = size;
    size += __GL_PAD8(nElements * sizeof(GLubyte));

    return(size);
}

void FASTCALL __gllc_ReducedElementsHandler(__GLcontext *gc,
                                            GLenum mode,
                                            GLsizei iVertexCount,
                                            GLsizei iVertexBase,
                                            VAMAP *pvmVertices,
                                            GLsizei iElementCount,
                                            GLubyte *pbElements,
                                            GLboolean fPartial)
{
    GLuint       vaMask;
    GLuint       size;
    GLubyte      *pv1, *pv2;
    GLsizei      stride;
    GLsizei      i;
    struct __gllc_DrawElements_Rec *data, drawElementsRec;

    ASSERTOPENGL(pvmVertices != NULL,
                 "__gllc_ReducedElementsHandler requires mapped vertices\n");
    
// Allocate the record.

    size = __glDrawElements_size(gc, iVertexCount, iElementCount,
                                 &drawElementsRec);
    data = (struct __gllc_DrawElements_Rec *)
        __glDlistAddOpAligned(gc, DLIST_SIZE(size),
			      DLIST_GENERIC_OP(DrawElements));
    if (data == NULL)
    {
	return;
    }

#ifndef _IA64_
    ASSERTOPENGL((UINT_PTR) data == __GL_PAD8((UINT_PTR) data),
	"data not qword aligned\n");
#endif

    vaMask = gc->vertexArray.mask;
    
    data->mode        = mode;
    data->iElementCount = iElementCount;
    data->iVertexCount = iVertexCount;
    data->vaMask      = vaMask;
    data->partial     = fPartial;
    data->recSize     = size;
    data->edgeFlagOff = drawElementsRec.edgeFlagOff;
    data->texCoordOff = drawElementsRec.texCoordOff;
    data->indexOff    = drawElementsRec.indexOff;
    data->colorOff    = drawElementsRec.colorOff;
    data->normalOff   = drawElementsRec.normalOff;
    data->vertexOff   = drawElementsRec.vertexOff;
    data->mapOff      = drawElementsRec.mapOff;

// Record the vertex arrays.

// Note that iVertexBase parameter is not used, since all accesses here are
// 0-based.  It is there for function ptr compatibility with glcltReducedElementHandler
    if (vaMask & VAMASK_EDGEFLAG_ENABLE_MASK)
    {
	pv2    = &((GLubyte *) data)[data->edgeFlagOff];
	pv1    = (GLubyte *) gc->vertexArray.edgeFlag.pointer;
	stride = gc->vertexArray.edgeFlag.ibytes;

	for (i = 0; i < iVertexCount; i++)
	{
	    *((GLboolean *) pv2) = *((GLboolean *)
                                     (pv1 + pvmVertices[i].iIn * stride));
	    pv2 += sizeof(GLboolean);
	}
    }

    if (vaMask & VAMASK_TEXCOORD_ENABLE_MASK)
    {
	pv2    = &((GLubyte *) data)[data->texCoordOff];
	size   = gc->vertexArray.texCoord.size *
	         __GLTYPESIZE(gc->vertexArray.texCoord.type);
	pv1    = (GLubyte *) gc->vertexArray.texCoord.pointer;
	stride = gc->vertexArray.texCoord.ibytes;
	data->texCoordSize = gc->vertexArray.texCoord.size;
	data->texCoordType = gc->vertexArray.texCoord.type;

	for (i = 0; i < iVertexCount; i++)
	{
	    memcpy(pv2, pv1 + pvmVertices[i].iIn * stride, size);
	    pv2 += size;
	}
    }

    if (vaMask & VAMASK_COLOR_ENABLE_MASK)
    {
	pv2    = &((GLubyte *) data)[data->colorOff];
	size   = gc->vertexArray.color.size *
	         __GLTYPESIZE(gc->vertexArray.color.type);
	pv1    = (GLubyte *) gc->vertexArray.color.pointer;
	stride = gc->vertexArray.color.ibytes;
	data->colorSize = gc->vertexArray.color.size;
	data->colorType = gc->vertexArray.color.type;

	for (i = 0; i < iVertexCount; i++)
	{
	    memcpy(pv2, pv1 + pvmVertices[i].iIn * stride, size);
	    pv2 += size;
	}
    }

    if (vaMask & VAMASK_INDEX_ENABLE_MASK)
    {
	pv2    = &((GLubyte *) data)[data->indexOff];
	size   = __GLTYPESIZE(gc->vertexArray.index.type);
	pv1    = (GLubyte *) gc->vertexArray.index.pointer;
	stride = gc->vertexArray.index.ibytes;
	data->indexType = gc->vertexArray.index.type;

	for (i = 0; i < iVertexCount; i++)
	{
	    memcpy(pv2, pv1 + pvmVertices[i].iIn * stride, size);
	    pv2 += size;
	}
    }

    if (vaMask & VAMASK_NORMAL_ENABLE_MASK)
    {
	pv2    = &((GLubyte *) data)[data->normalOff];
	size   = 3 * __GLTYPESIZE(gc->vertexArray.normal.type);
	pv1    = (GLubyte *) gc->vertexArray.normal.pointer;
	stride = gc->vertexArray.normal.ibytes;
	data->normalType = gc->vertexArray.normal.type;

	for (i = 0; i < iVertexCount; i++)
	{
	    memcpy(pv2, pv1 + pvmVertices[i].iIn * stride, size);
	    pv2 += size;
	}
    }

    if (vaMask & VAMASK_VERTEX_ENABLE_MASK)
    {
	pv2    = &((GLubyte *) data)[data->vertexOff];
	size   = gc->vertexArray.vertex.size *
	         __GLTYPESIZE(gc->vertexArray.vertex.type);
	pv1    = (GLubyte *) gc->vertexArray.vertex.pointer;
	stride = gc->vertexArray.vertex.ibytes;
	data->vertexSize = gc->vertexArray.vertex.size;
	data->vertexType = gc->vertexArray.vertex.type;

	for (i = 0; i < iVertexCount; i++)
	{
	    memcpy(pv2, pv1 + pvmVertices[i].iIn * stride, size);
	    pv2 += size;
	}
    }

// Record new index mapping array.

    pv2 = &((GLubyte *) data)[data->mapOff];
    memcpy(pv2, pbElements, iElementCount*sizeof(GLubyte));

    __glDlistAppendOp(gc, data, __glle_DrawElements);
}

void APIENTRY __gllc_DrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *pIn)
{
    POLYARRAY    *pa;
    GLuint       iIn;
    GLsizei      iCount;
    struct __gllc_DrawElementsBegin_Rec *dataBegin;

    __GL_SETUP();

// Flush the cached memory pointers if we are in COMPILE_AND_EXECUTE mode.
// See __glShrinkDlist for details.

    if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE)
	glsbAttention();

    pa = gc->paTeb;

// If we are already in the begin/end bracket, return an error.

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	__gllc_InvalidOperation();
	return;
    }

    if ((GLuint) mode > GL_POLYGON)
    {
	__gllc_InvalidEnum();
	return;
    }

    if (count < 0)
    {
	__gllc_InvalidValue();
        return;
    } else if (!count)
        return;

    switch (type)
    {
      case GL_UNSIGNED_BYTE:
      case GL_UNSIGNED_SHORT:
      case GL_UNSIGNED_INT:
	break;
      default:
	__gllc_InvalidEnum();
        return;
    }

// Find array element function to use.

    if (gc->vertexArray.flags & __GL_VERTEX_ARRAY_DIRTY)
	VA_ValidateArrayPointers(gc);

// Convert Points, Line Loop and Polygon to DrawArrays call.  Points and Polygon
// don't benefit from optimization in this function.  Further, Polygon and
// Line Loop are too tricky to deal with in this function.

    if (mode == GL_POINTS || mode == GL_LINE_LOOP || mode == GL_POLYGON)
    {
	__gllc_Begin(mode);
	gc->dlist.beginRec->flags |= DLIST_BEGIN_DRAWARRAYS;

	for (iCount = 0; iCount < count; iCount++)
	{
	    // Get next input index.
	    if (type == GL_UNSIGNED_BYTE)
		iIn = (GLuint) ((GLubyte *)  pIn)[iCount];
	    else if (type == GL_UNSIGNED_SHORT)
		iIn = (GLuint) ((GLushort *) pIn)[iCount];
	    else
		iIn = (GLuint) ((GLuint *)   pIn)[iCount];

	    VA_ArrayElementCompile(gc, iIn);
	}

	__gllc_End();
	return;
    }

    // Allocate begin record
    dataBegin = (struct __gllc_DrawElementsBegin_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_DrawElementsBegin_Rec)),
                                DLIST_GENERIC_OP(DrawElementsBegin));
    if (dataBegin == NULL)
    {
	return;
    }

    dataBegin->mode = mode;
    dataBegin->count = min(count, VA_DRAWELEM_MAP_SIZE);
    dataBegin->vaMask = gc->vertexArray.mask;
        
    __glDlistAppendOp(gc, dataBegin, __glle_DrawElementsBegin);

    // Reduce input data into easily processed chunks
    ReduceDrawElements(gc, mode, count, type, pIn,
                       __gllc_ReducedElementsHandler);
}

const GLubyte * FASTCALL __glle_DrawElementsBegin(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_DrawElementsBegin_Rec *data;

// Not allowed in begin/end.

    // Must use the client side begin state
    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
        // Mark saved state as invalid
        gc->savedVertexArray.flags = 0xffffffff;
	goto __glle_DrawElementsBegin_exit;
    }

    data = (struct __gllc_DrawElementsBegin_Rec *) PC;

// Save vertex array states.

    gc->savedVertexArray = gc->vertexArray;

// Set up temporary vertex arrays.
// By setting up the mask value in gc, we don't need to call EnableClientState
// and DisableClientState.  We still need to set up pointers for the enabled
// arrays.

    gc->vertexArray.mask = data->vaMask;
    // Force validation since we just completely changed the vertex array
    // enable state
    VA_ValidateArrayPointers(gc);

    // Begin primitive
    VA_DrawElementsBegin(gc->paTeb, data->mode, data->count);
    
__glle_DrawElementsBegin_exit:
    return PC + sizeof(struct __gllc_DrawElementsBegin_Rec);
}

void APIENTRY __gllc_DrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *pIn)
{
    // !!! Currently we call the DrawElements function here when in lc mode.  
    // If compile time performance for DrawRangeElements becomes an issue, then
    // we can flesh out this function.
    __gllc_DrawElements( mode, count, type, pIn );
}

const GLubyte * FASTCALL __glle_DrawElements(__GLcontext *gc, const GLubyte *PC)
{
    GLuint vaMask;
    POLYARRAY *pa;
    struct __gllc_DrawElements_Rec *data;

    data = (struct __gllc_DrawElements_Rec *) PC;
    pa = gc->paTeb;
    
// Must be in begin since DrawElementsBegin has started the primitive

    // Must use the client side begin state
    if ((pa->flags & POLYARRAY_IN_BEGIN) == 0 ||
        gc->savedVertexArray.flags == 0xffffffff)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	goto __glle_DrawElements_exit;
    }

    vaMask = data->vaMask;

// Set up temporary vertex arrays.
// We need to temporarily mask off the begin flag so that these
// calls can succeed.  We probably want to do something smarter
// that avoids parameter validation but this is good enough for now
// Note that in immediate mode, the array function pointers are set up
// once in __glle_DrawElementsBegin and remain unchanged until all
// sub-batches are processed.  In COMPILE_AND_EXECUTE mode, the array
// function pointers are also set up once in __glle_DrawElementsBegin.
// Since these function pointers are the same for compilation and
// execution, we don't need to re-validate them for each sub-batch here.

    pa->flags ^= POLYARRAY_IN_BEGIN;
    
    if (vaMask & VAMASK_EDGEFLAG_ENABLE_MASK)
        glcltEdgeFlagPointer(0, &((GLubyte *) data)[data->edgeFlagOff]);

    if (vaMask & VAMASK_TEXCOORD_ENABLE_MASK)
        glcltTexCoordPointer(data->texCoordSize, data->texCoordType,
	    0, &((GLubyte *) data)[data->texCoordOff]);

    if (vaMask & VAMASK_COLOR_ENABLE_MASK)
        glcltColorPointer(data->colorSize, data->colorType,
	    0, &((GLubyte *) data)[data->colorOff]);

    if (vaMask & VAMASK_INDEX_ENABLE_MASK)
        glcltIndexPointer(data->indexType,
	    0, &((GLubyte *) data)[data->indexOff]);

    if (vaMask & VAMASK_NORMAL_ENABLE_MASK)
        glcltNormalPointer(data->normalType,
	    0, &((GLubyte *) data)[data->normalOff]);

    if (vaMask & VAMASK_VERTEX_ENABLE_MASK)
        glcltVertexPointer(data->vertexSize, data->vertexType,
	    0, &((GLubyte *) data)[data->vertexOff]);

    pa->flags ^= POLYARRAY_IN_BEGIN;
    
    // Call immediate mode chunk handler
    glcltReducedElementsHandler(gc, data->mode,
                                data->iVertexCount, 0, NULL,
                                data->iElementCount,
                                (GLubyte *)data+data->mapOff,
                                data->partial);

// Restore vertex array states in the following conditions:
// 1. The DrawElements record is completed
// 2. It is in COMPILE_AND_EXECUTE mode and it is not called as a result
//    of executing a CallList record.  That is, the record is being
//    compile *and* executed at the same time.

    if ((!data->partial) ||
	((gc->dlist.mode == GL_COMPILE_AND_EXECUTE) && !gc->dlist.nesting))
    {
        gc->vertexArray = gc->savedVertexArray;
    }

__glle_DrawElements_exit:
    return PC + data->recSize;
}

void APIENTRY
__gllc_Begin ( IN GLenum mode )
{
    POLYARRAY *pa;
    struct __gllc_Begin_Rec *data;
    __GL_SETUP();

// Flush the cached memory pointers if we are in COMPILE_AND_EXECUTE mode.
// See __glShrinkDlist for details.

    if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE)
	glsbAttention();

// If we are already in the begin/end bracket, return an error.

    pa = gc->paTeb;
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	__gllc_InvalidOperation();
	return;
    }

    if ((GLuint) mode > GL_POLYGON)
    {
	__gllc_InvalidEnum();
	return;
    }

// Add the Begin record.

    data = (struct __gllc_Begin_Rec *)
        __glDlistAddOpUnaligned(gc,
                                DLIST_SIZE(sizeof(struct __gllc_Begin_Rec)),
                                DLIST_GENERIC_OP(Begin));
    if (data == NULL) return;
    data->mode = mode;
    data->flags = 0;
    data->nVertices = 0;

    gc->dlist.skipPolyData = GL_FALSE;

// Use poly array code to compile the data structure for this primitive.

    (*gc->savedCltProcTable.glDispatchTable.glBegin)(mode);

// Save the Begin record pointer.  We are now compiling the poly array
// primitive.  It is set to NULL in End.

    gc->dlist.beginRec = data;
}

const GLubyte * FASTCALL __glle_Begin(__GLcontext *gc, const GLubyte *PC)
{
    POLYARRAY *pa;
    struct __gllc_Begin_Rec *data;

    data = (struct __gllc_Begin_Rec *) PC;

    pa = gc->paTeb;

    // try not to break the poly data records into batches!  The number 8
    // is loosely chosen to allow for the poly array entry, the reserved
    // polygon entries, and the flush limit.  At worst, it causes an
    // unnecessary attention!
    if (data->nVertices <= (GLint) gc->vertex.pdBufSize - 8
     && data->nVertices >= (GLint) (pa->pdBufferMax - pa->pdBufferNext + 1 - 8))
	glsbAttention();

    // call glcltBegin first
    (*gc->savedCltProcTable.glDispatchTable.glBegin)(data->mode);
    if (data->flags & DLIST_BEGIN_DRAWARRAYS)
	pa->flags |= POLYARRAY_SAME_POLYDATA_TYPE;

// Set POLYARRAY_CLAMP_COLOR flag.

    if (data->flags & DLIST_BEGIN_HAS_CLAMP_COLOR)
	pa->flags |= POLYARRAY_CLAMP_COLOR;

    // handle "otherColor"
    if (data->flags & DLIST_BEGIN_HAS_OTHER_COLOR)
    {
	if (gc->modes.colorIndexMode)
	    (*gc->savedCltProcTable.glDispatchTable.glColor4fv)((GLfloat *) &data->otherColor);
	else
	    (*gc->savedCltProcTable.glDispatchTable.glIndexf)(data->otherColor.r);
    }

    return PC + sizeof(struct __gllc_Begin_Rec);
}

void APIENTRY
__gllc_End ( void )
{
    GLuint size;
    POLYARRAY *pa;
    void *data;
    __GL_SETUP();

    pa = gc->paTeb;

// If we are compiling poly array, finish the poly array processing.
// Note that we may have aborted poly array compilation in CallList(s).
// In that case, we need to compile an End record.

    if (gc->dlist.beginRec)
    {
	ASSERTOPENGL(pa->flags & POLYARRAY_IN_BEGIN, "not in begin!\n");

// Record the last POLYDATA since it may contain attribute changes.

	__glDlistCompilePolyData(gc, GL_TRUE);

// Call glcltEnd to finish the primitive.

	(*gc->savedCltProcTable.glDispatchTable.glEnd)();

// Record the End call.

	__glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(End));

// If we are in COMPILE mode, we need to reset the command buffer,
// the poly array buffer, and the poly material buffer.

	if (gc->dlist.mode == GL_COMPILE)
	{
	    glsbResetBuffers(TRUE);

	    // Clear begin flag too
	    pa->flags &= ~POLYARRAY_IN_BEGIN;
	}

	// Terminate poly array compilation
	gc->dlist.beginRec = NULL;
    }
    else
    {
// Record the call.

	data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(End));
	if (data == NULL) return;
	__glDlistAppendOp(gc, data, __glle_End);
    }
}

const GLubyte * FASTCALL __glle_End(__GLcontext *gc, const GLubyte *PC)
{

    (*gc->savedCltProcTable.glDispatchTable.glEnd)();
    return PC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\dlist\dlistopt.h ===
#ifndef __gldlistopt_h_
#define __gldlistopt_h_

/*
** Copyright 1991, 1922, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Display list state descriptions.
**
*/

#ifndef NT

/*
** Generic optimizer.  This optimizer simply uses all of the generic
** optimizations.
*/
void FASTCALL __glDlistOptimizer(__GLcontext *gc, __GLcompiledDlist *cdlist);

/*
** Optimizer for multiple consecutive material changes.  This routine 
** combines a bunch of material changes into one quick material change.
*/
void FASTCALL __glDlistOptimizeMaterial(__GLcontext *gc, __GLcompiledDlist *cdlist);


/*
** Generic flags used for optimization (during gllc routines).
*/
#define __GL_DLFLAG_HAS_VERTEX		0x00000001
#define __GL_DLFLAG_HAS_NORMAL		0x00000002
#define __GL_DLFLAG_HAS_COLOR		0x00000004
#define __GL_DLFLAG_HAS_TEXCOORDS	0x00000008
#define __GL_DLFLAG_HAS_INDEX		0x00000010
#define __GL_DLFLAG_HAS_RASTERPOS	0x00000020
#define __GL_DLFLAG_HAS_RECT		0x00000040
#define __GL_DLFLAG_HAS_BEGIN		0x00000080
#define __GL_DLFLAG_HAS_MATERIAL	0x00000100

/*
** Generic opcodes created during generic dlist optimizations.
*/
#define __GL_GENERIC_DLIST_OPCODE	1000
#define __glop_Begin_LineLoop		1000
#define __glop_Begin_LineStrip		1001
#define __glop_Begin_Lines		1002
#define __glop_Begin_Points		1003
#define __glop_Begin_Polygon		1004
#define __glop_Begin_TriangleStrip	1005
#define __glop_Begin_TriangleFan	1006
#define __glop_Begin_Triangles		1007
#define __glop_Begin_QuadStrip		1008
#define __glop_Begin_Quads		1009
#define __glop_InvalidValue		1010
#define __glop_InvalidEnum		1011
#define __glop_InvalidOperation		1012
#define __glop_FastMaterial		1013

/*
** List execution functions.
*/
extern __GLlistExecFunc *__gl_GenericDlOps[];
extern const GLubyte * FASTCALL __glle_Begin_LineLoop(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_LineStrip(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_Lines(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_Points(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_Polygon(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_TriangleStrip(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_TriangleFan(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_Triangles(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_QuadStrip(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_Quads(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_FastMaterial(__GLcontext *gc, const GLubyte *);
extern void __gllc_Error(GLenum error);
#endif // !NT

extern const GLubyte * FASTCALL __glle_InvalidValue(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_InvalidEnum(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_InvalidOperation(__GLcontext *gc, const GLubyte *);
extern void __gllc_InvalidValue();
extern void __gllc_InvalidEnum();
extern void __gllc_InvalidOperation();

#ifdef NT
extern const GLubyte * FASTCALL __glle_PolyData_C3F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData_N3F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData_C3F_N3F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData_C4F_N3F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData_T2F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData_T2F_C3F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData_T2F_N3F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData_T2F_C3F_N3F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData_T2F_C4F_N3F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyMaterial(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_Begin(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_End(__GLcontext *gc, const GLubyte *PC);

void APIENTRY __gllc_PolyMaterial(GLuint faceName, __GLmatChange *pdMat);
void APIENTRY __glDlistCompilePolyData(__GLcontext *gc, GLboolean bPartial);

#define DLIST_BEGIN_HAS_OTHER_COLOR	0x0001
#define DLIST_BEGIN_NO_MATCHING_END	0x0002
#define DLIST_BEGIN_HAS_CALLLIST	0x0004
#define DLIST_BEGIN_DRAWARRAYS  	0x0008
#define DLIST_BEGIN_DRAWELEMENTS	0x0010
#define DLIST_BEGIN_HAS_CLAMP_COLOR	0x0020
#endif // NT

#endif /* __gldlistopt_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\dlist\dl_proc.c ===
/******************************Module*Header*******************************\
* Module Name: dl_proc.c
*
* Display list compilation routines.
*
* Created: 12-26-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

/* Client Side Display List Compilation Procedure Table */

#include "precomp.h"
#pragma hdrstop

#include "glclt.h"
#include "exttable.h"

GLCLTPROCTABLE ListCompCltProcTable =
{

/* Number of function entries in the table */

     sizeof(GLDISPATCHTABLE) / sizeof(PROC),

/* gl Entry points */
  {
     glcltNewList                ,
     glcltEndList                ,
     __gllc_CallList               ,
     __gllc_CallLists              ,
     glcltDeleteLists            ,
     glcltGenLists               ,
     __gllc_ListBase               ,
     __gllc_Begin                  ,
     __gllc_Bitmap                 ,
     __gllc_Color3b                ,
     __gllc_Color3bv               ,
     __gllc_Color3d                ,
     __gllc_Color3dv               ,
     __gllc_Color3f                ,
     __gllc_Color3fv               ,
     __gllc_Color3i                ,
     __gllc_Color3iv               ,
     __gllc_Color3s                ,
     __gllc_Color3sv               ,
     __gllc_Color3ub               ,
     __gllc_Color3ubv              ,
     __gllc_Color3ui               ,
     __gllc_Color3uiv              ,
     __gllc_Color3us               ,
     __gllc_Color3usv              ,
     __gllc_Color4b                ,
     __gllc_Color4bv               ,
     __gllc_Color4d                ,
     __gllc_Color4dv               ,
     __gllc_Color4f                ,
     __gllc_Color4fv               ,
     __gllc_Color4i                ,
     __gllc_Color4iv               ,
     __gllc_Color4s                ,
     __gllc_Color4sv               ,
     __gllc_Color4ub               ,
     __gllc_Color4ubv              ,
     __gllc_Color4ui               ,
     __gllc_Color4uiv              ,
     __gllc_Color4us               ,
     __gllc_Color4usv              ,
     __gllc_EdgeFlag               ,
     __gllc_EdgeFlagv              ,
     __gllc_End                    ,
     __gllc_Indexd                 ,
     __gllc_Indexdv                ,
     __gllc_Indexf                 ,
     __gllc_Indexfv                ,
     __gllc_Indexi                 ,
     __gllc_Indexiv                ,
     __gllc_Indexs                 ,
     __gllc_Indexsv                ,
     __gllc_Normal3b               ,
     __gllc_Normal3bv              ,
     __gllc_Normal3d               ,
     __gllc_Normal3dv              ,
     __gllc_Normal3f               ,
     __gllc_Normal3fv              ,
     __gllc_Normal3i               ,
     __gllc_Normal3iv              ,
     __gllc_Normal3s               ,
     __gllc_Normal3sv              ,
     __gllc_RasterPos2d            ,
     __gllc_RasterPos2dv           ,
     __gllc_RasterPos2f            ,
     __gllc_RasterPos2fv           ,
     __gllc_RasterPos2i            ,
     __gllc_RasterPos2iv           ,
     __gllc_RasterPos2s            ,
     __gllc_RasterPos2sv           ,
     __gllc_RasterPos3d            ,
     __gllc_RasterPos3dv           ,
     __gllc_RasterPos3f            ,
     __gllc_RasterPos3fv           ,
     __gllc_RasterPos3i            ,
     __gllc_RasterPos3iv           ,
     __gllc_RasterPos3s            ,
     __gllc_RasterPos3sv           ,
     __gllc_RasterPos4d            ,
     __gllc_RasterPos4dv           ,
     __gllc_RasterPos4f            ,
     __gllc_RasterPos4fv           ,
     __gllc_RasterPos4i            ,
     __gllc_RasterPos4iv           ,
     __gllc_RasterPos4s            ,
     __gllc_RasterPos4sv           ,
     __gllc_Rectd                  ,
     __gllc_Rectdv                 ,
     __gllc_Rectf                  ,
     __gllc_Rectfv                 ,
     __gllc_Recti                  ,
     __gllc_Rectiv                 ,
     __gllc_Rects                  ,
     __gllc_Rectsv                 ,
     __gllc_TexCoord1d             ,
     __gllc_TexCoord1dv            ,
     __gllc_TexCoord1f             ,
     __gllc_TexCoord1fv            ,
     __gllc_TexCoord1i             ,
     __gllc_TexCoord1iv            ,
     __gllc_TexCoord1s             ,
     __gllc_TexCoord1sv            ,
     __gllc_TexCoord2d             ,
     __gllc_TexCoord2dv            ,
     __gllc_TexCoord2f             ,
     __gllc_TexCoord2fv            ,
     __gllc_TexCoord2i             ,
     __gllc_TexCoord2iv            ,
     __gllc_TexCoord2s             ,
     __gllc_TexCoord2sv            ,
     __gllc_TexCoord3d             ,
     __gllc_TexCoord3dv            ,
     __gllc_TexCoord3f             ,
     __gllc_TexCoord3fv            ,
     __gllc_TexCoord3i             ,
     __gllc_TexCoord3iv            ,
     __gllc_TexCoord3s             ,
     __gllc_TexCoord3sv            ,
     __gllc_TexCoord4d             ,
     __gllc_TexCoord4dv            ,
     __gllc_TexCoord4f             ,
     __gllc_TexCoord4fv            ,
     __gllc_TexCoord4i             ,
     __gllc_TexCoord4iv            ,
     __gllc_TexCoord4s             ,
     __gllc_TexCoord4sv            ,
     __gllc_Vertex2d               ,
     __gllc_Vertex2dv              ,
     __gllc_Vertex2f               ,
     __gllc_Vertex2fv              ,
     __gllc_Vertex2i               ,
     __gllc_Vertex2iv              ,
     __gllc_Vertex2s               ,
     __gllc_Vertex2sv              ,
     __gllc_Vertex3d               ,
     __gllc_Vertex3dv              ,
     __gllc_Vertex3f               ,
     __gllc_Vertex3fv              ,
     __gllc_Vertex3i               ,
     __gllc_Vertex3iv              ,
     __gllc_Vertex3s               ,
     __gllc_Vertex3sv              ,
     __gllc_Vertex4d               ,
     __gllc_Vertex4dv              ,
     __gllc_Vertex4f               ,
     __gllc_Vertex4fv              ,
     __gllc_Vertex4i               ,
     __gllc_Vertex4iv              ,
     __gllc_Vertex4s               ,
     __gllc_Vertex4sv              ,
     __gllc_ClipPlane              ,
     __gllc_ColorMaterial          ,
     __gllc_CullFace               ,
     __gllc_Fogf                   ,
     __gllc_Fogfv                  ,
     __gllc_Fogi                   ,
     __gllc_Fogiv                  ,
     __gllc_FrontFace              ,
     __gllc_Hint                   ,
     __gllc_Lightf                 ,
     __gllc_Lightfv                ,
     __gllc_Lighti                 ,
     __gllc_Lightiv                ,
     __gllc_LightModelf            ,
     __gllc_LightModelfv           ,
     __gllc_LightModeli            ,
     __gllc_LightModeliv           ,
     __gllc_LineStipple            ,
     __gllc_LineWidth              ,
     __gllc_Materialf              ,
     __gllc_Materialfv             ,
     __gllc_Materiali              ,
     __gllc_Materialiv             ,
     __gllc_PointSize              ,
     __gllc_PolygonMode            ,
     __gllc_PolygonStipple         ,
     __gllc_Scissor                ,
     __gllc_ShadeModel             ,
     __gllc_TexParameterf          ,
     __gllc_TexParameterfv         ,
     __gllc_TexParameteri          ,
     __gllc_TexParameteriv         ,
     __gllc_TexImage1D             ,
     __gllc_TexImage2D             ,
     __gllc_TexEnvf                ,
     __gllc_TexEnvfv               ,
     __gllc_TexEnvi                ,
     __gllc_TexEnviv               ,
     __gllc_TexGend                ,
     __gllc_TexGendv               ,
     __gllc_TexGenf                ,
     __gllc_TexGenfv               ,
     __gllc_TexGeni                ,
     __gllc_TexGeniv               ,
     glcltFeedbackBuffer         ,
     glcltSelectBuffer           ,
     glcltRenderMode             ,
     __gllc_InitNames              ,
     __gllc_LoadName               ,
     __gllc_PassThrough            ,
     __gllc_PopName                ,
     __gllc_PushName               ,
     __gllc_DrawBuffer             ,
     __gllc_Clear                  ,
     __gllc_ClearAccum             ,
     __gllc_ClearIndex             ,
     __gllc_ClearColor             ,
     __gllc_ClearStencil           ,
     __gllc_ClearDepth             ,
     __gllc_StencilMask            ,
     __gllc_ColorMask              ,
     __gllc_DepthMask              ,
     __gllc_IndexMask              ,
     __gllc_Accum                  ,
     __gllc_Disable                ,
     __gllc_Enable                 ,
     glcltFinish                 ,
     glcltFlush                  ,
     __gllc_PopAttrib              ,
     __gllc_PushAttrib             ,
     __gllc_Map1d                  ,
     __gllc_Map1f                  ,
     __gllc_Map2d                  ,
     __gllc_Map2f                  ,
     __gllc_MapGrid1d              ,
     __gllc_MapGrid1f              ,
     __gllc_MapGrid2d              ,
     __gllc_MapGrid2f              ,
     __gllc_EvalCoord1d            ,
     __gllc_EvalCoord1dv           ,
     __gllc_EvalCoord1f            ,
     __gllc_EvalCoord1fv           ,
     __gllc_EvalCoord2d            ,
     __gllc_EvalCoord2dv           ,
     __gllc_EvalCoord2f            ,
     __gllc_EvalCoord2fv           ,
     __gllc_EvalMesh1              ,
     __gllc_EvalPoint1             ,
     __gllc_EvalMesh2              ,
     __gllc_EvalPoint2             ,
     __gllc_AlphaFunc              ,
     __gllc_BlendFunc              ,
     __gllc_LogicOp                ,
     __gllc_StencilFunc            ,
     __gllc_StencilOp              ,
     __gllc_DepthFunc              ,
     __gllc_PixelZoom              ,
     __gllc_PixelTransferf         ,
     __gllc_PixelTransferi         ,
     glcltPixelStoref            ,
     glcltPixelStorei            ,
     __gllc_PixelMapfv             ,
     __gllc_PixelMapuiv            ,
     __gllc_PixelMapusv            ,
     __gllc_ReadBuffer             ,
     __gllc_CopyPixels             ,
     glcltReadPixels             ,
     __gllc_DrawPixels             ,
     glcltGetBooleanv            ,
     glcltGetClipPlane           ,
     glcltGetDoublev             ,
     glcltGetError               ,
     glcltGetFloatv              ,
     glcltGetIntegerv            ,
     glcltGetLightfv             ,
     glcltGetLightiv             ,
     glcltGetMapdv               ,
     glcltGetMapfv               ,
     glcltGetMapiv               ,
     glcltGetMaterialfv          ,
     glcltGetMaterialiv          ,
     glcltGetPixelMapfv          ,
     glcltGetPixelMapuiv         ,
     glcltGetPixelMapusv         ,
     glcltGetPolygonStipple      ,
     glcltGetString              ,
     glcltGetTexEnvfv            ,
     glcltGetTexEnviv            ,
     glcltGetTexGendv            ,
     glcltGetTexGenfv            ,
     glcltGetTexGeniv            ,
     glcltGetTexImage            ,
     glcltGetTexParameterfv      ,
     glcltGetTexParameteriv      ,
     glcltGetTexLevelParameterfv ,
     glcltGetTexLevelParameteriv ,
     glcltIsEnabled              ,
     glcltIsList                 ,
     __gllc_DepthRange             ,
     __gllc_Frustum                ,
     __gllc_LoadIdentity           ,
     __gllc_LoadMatrixf            ,
     __gllc_LoadMatrixd            ,
     __gllc_MatrixMode             ,
     __gllc_MultMatrixf            ,
     __gllc_MultMatrixd            ,
     __gllc_Ortho                  ,
     __gllc_PopMatrix              ,
     __gllc_PushMatrix             ,
     __gllc_Rotated                ,
     __gllc_Rotatef                ,
     __gllc_Scaled                 ,
     __gllc_Scalef                 ,
     __gllc_Translated             ,
     __gllc_Translatef             ,
     __gllc_Viewport               ,
     __gllc_ArrayElement           ,
     __gllc_BindTexture            ,
     glcltColorPointer             ,
     glcltDisableClientState       ,
     __gllc_DrawArrays             ,
     __gllc_DrawElements           ,
     glcltEdgeFlagPointer          ,
     glcltEnableClientState        ,
     glcltIndexPointer             ,
     __gllc_Indexub                ,
     __gllc_Indexubv               ,
     glcltInterleavedArrays        ,
     glcltNormalPointer            ,
     __gllc_PolygonOffset          ,
     glcltTexCoordPointer          ,
     glcltVertexPointer            ,
     glcltAreTexturesResident      ,
     __gllc_CopyTexImage1D         ,
     __gllc_CopyTexImage2D         ,
     __gllc_CopyTexSubImage1D      ,
     __gllc_CopyTexSubImage2D      ,
     glcltDeleteTextures           ,
     glcltGenTextures              ,
     glcltGetPointerv              ,
     glcltIsTexture                ,
     __gllc_PrioritizeTextures     ,
     __gllc_TexSubImage1D          ,
     __gllc_TexSubImage2D          ,
     glcltPopClientAttrib          ,
     glcltPushClientAttrib         ,
  }

};

GLEXTPROCTABLE ListCompExtProcTable =
{
    /* Number of function entries in the table */
    sizeof(GLEXTDISPATCHTABLE) / sizeof(PROC),

    /* gl EXT Entry points */
  {
      __gllc_DrawRangeElementsWIN,
      __gllc_ColorTableEXT,
      __gllc_ColorSubTableEXT,
      glcltGetColorTableEXT,
      glcltGetColorTableParameterivEXT,
      glcltGetColorTableParameterfvEXT,
#ifdef GL_WIN_multiple_textures
      __gllc_CurrentTextureIndexWIN,
      __gllc_MultiTexCoord1dWIN,
      __gllc_MultiTexCoord1dvWIN,
      __gllc_MultiTexCoord1fWIN,
      __gllc_MultiTexCoord1fvWIN,
      __gllc_MultiTexCoord1iWIN,
      __gllc_MultiTexCoord1ivWIN,
      __gllc_MultiTexCoord1sWIN,
      __gllc_MultiTexCoord1svWIN,
      __gllc_MultiTexCoord2dWIN,
      __gllc_MultiTexCoord2dvWIN,
      __gllc_MultiTexCoord2fWIN,
      __gllc_MultiTexCoord2fvWIN,
      __gllc_MultiTexCoord2iWIN,
      __gllc_MultiTexCoord2ivWIN,
      __gllc_MultiTexCoord2sWIN,
      __gllc_MultiTexCoord2svWIN,
      __gllc_MultiTexCoord3dWIN,
      __gllc_MultiTexCoord3dvWIN,
      __gllc_MultiTexCoord3fWIN,
      __gllc_MultiTexCoord3fvWIN,
      __gllc_MultiTexCoord3iWIN,
      __gllc_MultiTexCoord3ivWIN,
      __gllc_MultiTexCoord3sWIN,
      __gllc_MultiTexCoord3svWIN,
      __gllc_MultiTexCoord4dWIN,
      __gllc_MultiTexCoord4dvWIN,
      __gllc_MultiTexCoord4fWIN,
      __gllc_MultiTexCoord4fvWIN,
      __gllc_MultiTexCoord4iWIN,
      __gllc_MultiTexCoord4ivWIN,
      __gllc_MultiTexCoord4sWIN,
      __gllc_MultiTexCoord4svWIN,
      __gllc_BindNthTextureWIN,
      __gllc_NthTexCombineFuncWIN,
#endif // GL_WIN_multiple_textures
  }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\dlist\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <ddraw.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <glp.h>
#include <global.h>
#include <imports.h>
#include <dlist.h>
#include "dlistopt.h"
#include <listcomp.h>
#include <namesint.h>
#include <glsize.h>
#include "glsbcltu.h"
#include "compsize.h"

#include "dlistint.h"
#include "dlistfn.h"
#include "lcfuncs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\dlist\dl_pdata.h ===
/******************************Module*Header*******************************\
* Module Name: dl_pdata.h
*
* Routines to execute fast PolyData primitives.
*
* Created: 1-10-1996
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#ifndef __dl_pdata_h_
#define __dl_pdata_h_

#define __PDATA_SIZE_T2F         (2 * sizeof(__GLfloat))
#define __PDATA_SIZE_C3F         (3 * sizeof(__GLfloat))
#define __PDATA_SIZE_C4F         (sizeof(__GLcolor))
#define __PDATA_SIZE_N3F         (3 * sizeof(__GLfloat))
//#define __PDATA_SIZE_V2F       (2 * sizeof(__GLfloat))
#define __PDATA_SIZE_V3F         (3 * sizeof(__GLfloat))

// We always set the POLYDATA_DLIST_COLOR_SLOW flag for colors.  It allows us
// to eliminate the flags field in the fast PolyData records.
#define __PDATA_PD_FLAGS_T2F     (POLYDATA_TEXTURE_VALID|POLYDATA_DLIST_TEXTURE2)
#define __PDATA_PD_FLAGS_C3F     (POLYDATA_COLOR_VALID)
#define __PDATA_PD_FLAGS_C4F     (POLYDATA_COLOR_VALID|POLYDATA_DLIST_COLOR_4)
#define __PDATA_PD_FLAGS_N3F     (POLYDATA_NORMAL_VALID)
//#define __PDATA_PD_FLAGS_V2F   (POLYDATA_VERTEX2)
#define __PDATA_PD_FLAGS_V3F     (POLYDATA_VERTEX3)

#define __PDATA_PA_FLAGS_T2F     (POLYARRAY_TEXTURE2)
#define __PDATA_PA_FLAGS_C3F     (0)
#define __PDATA_PA_FLAGS_C4F     (0)
#define __PDATA_PA_FLAGS_N3F     (0)
//#define __PDATA_PA_FLAGS_V2F   (POLYARRAY_VERTEX2)
#define __PDATA_PA_FLAGS_V3F     (POLYARRAY_VERTEX3)

#endif // __dl_pdata_h_

#ifndef __BUILD_GLI386__

#ifdef __GLLE_POLYDATA_C3F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_C3F_V3F
    #define __DL_PDATA_T2F         0
    #define __DL_PDATA_C3F         1
    #define __DL_PDATA_C4F         0
    #define __DL_PDATA_N3F         0
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif
#ifdef __GLLE_POLYDATA_N3F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_N3F_V3F
    #define __DL_PDATA_T2F         0
    #define __DL_PDATA_C3F         0
    #define __DL_PDATA_C4F         0
    #define __DL_PDATA_N3F         1
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif
#ifdef __GLLE_POLYDATA_C3F_N3F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_C3F_N3F_V3F
    #define __DL_PDATA_T2F         0
    #define __DL_PDATA_C3F         1
    #define __DL_PDATA_C4F         0
    #define __DL_PDATA_N3F         1
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif
#ifdef __GLLE_POLYDATA_C4F_N3F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_C4F_N3F_V3F
    #define __DL_PDATA_T2F         0
    #define __DL_PDATA_C3F         0
    #define __DL_PDATA_C4F         1
    #define __DL_PDATA_N3F         1
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif
#ifdef __GLLE_POLYDATA_T2F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_T2F_V3F
    #define __DL_PDATA_T2F         1
    #define __DL_PDATA_C3F         0
    #define __DL_PDATA_C4F         0
    #define __DL_PDATA_N3F         0
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif
#ifdef __GLLE_POLYDATA_T2F_C3F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_T2F_C3F_V3F
    #define __DL_PDATA_T2F         1
    #define __DL_PDATA_C3F         1
    #define __DL_PDATA_C4F         0
    #define __DL_PDATA_N3F         0
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif
#ifdef __GLLE_POLYDATA_T2F_N3F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_T2F_N3F_V3F
    #define __DL_PDATA_T2F         1
    #define __DL_PDATA_C3F         0
    #define __DL_PDATA_C4F         0
    #define __DL_PDATA_N3F         1
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif
#ifdef __GLLE_POLYDATA_T2F_C3F_N3F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_T2F_C3F_N3F_V3F
    #define __DL_PDATA_T2F         1
    #define __DL_PDATA_C3F         1
    #define __DL_PDATA_C4F         0
    #define __DL_PDATA_N3F         1
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif
#ifdef __GLLE_POLYDATA_T2F_C4F_N3F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_T2F_C4F_N3F_V3F
    #define __DL_PDATA_T2F         1
    #define __DL_PDATA_C3F         0
    #define __DL_PDATA_C4F         1
    #define __DL_PDATA_N3F         1
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif

/*************************************************************************/
// Compute record size, pd flags and pa flags

#if __DL_PDATA_T2F
    #define __DL_PDATA_SIZE_T       __PDATA_SIZE_T2F
    #define __DL_PDATA_PD_FLAGS_T   __PDATA_PD_FLAGS_T2F
    #define __DL_PDATA_PA_FLAGS_T   __PDATA_PA_FLAGS_T2F
#else
    #define __DL_PDATA_SIZE_T       0
    #define __DL_PDATA_PD_FLAGS_T   0
    #define __DL_PDATA_PA_FLAGS_T   0
#endif

#if __DL_PDATA_C3F
    #define __DL_PDATA_SIZE_C       __PDATA_SIZE_C3F
    #define __DL_PDATA_PD_FLAGS_C   __PDATA_PD_FLAGS_C3F
    #define __DL_PDATA_PA_FLAGS_C   __PDATA_PA_FLAGS_C3F
#elif __DL_PDATA_C4F
    #define __DL_PDATA_SIZE_C       __PDATA_SIZE_C4F
    #define __DL_PDATA_PD_FLAGS_C   __PDATA_PD_FLAGS_C4F
    #define __DL_PDATA_PA_FLAGS_C   __PDATA_PA_FLAGS_C4F
#else
    #define __DL_PDATA_SIZE_C       0
    #define __DL_PDATA_PD_FLAGS_C   0
    #define __DL_PDATA_PA_FLAGS_C   0
#endif

#if __DL_PDATA_N3F
    #define __DL_PDATA_SIZE_N       __PDATA_SIZE_N3F
    #define __DL_PDATA_PD_FLAGS_N   __PDATA_PD_FLAGS_N3F
    #define __DL_PDATA_PA_FLAGS_N   __PDATA_PA_FLAGS_N3F
#else
    #define __DL_PDATA_SIZE_N       0
    #define __DL_PDATA_PD_FLAGS_N   0
    #define __DL_PDATA_PA_FLAGS_N   0
#endif

#if __DL_PDATA_V2F
    #define __DL_PDATA_SIZE_V       __PDATA_SIZE_V2F
    #define __DL_PDATA_PD_FLAGS_V   __PDATA_PD_FLAGS_V2F
    #define __DL_PDATA_PA_FLAGS_V   __PDATA_PA_FLAGS_V2F
#elif __DL_PDATA_V3F
    #define __DL_PDATA_SIZE_V       __PDATA_SIZE_V3F
    #define __DL_PDATA_PD_FLAGS_V   __PDATA_PD_FLAGS_V3F
    #define __DL_PDATA_PA_FLAGS_V   __PDATA_PA_FLAGS_V3F
#else
    #define __DL_PDATA_SIZE_V       0
    #define __DL_PDATA_PD_FLAGS_V   0
    #define __DL_PDATA_PA_FLAGS_V   0
#endif

#define __DL_PDATA_SIZE     \
    (__DL_PDATA_SIZE_T+__DL_PDATA_SIZE_C+__DL_PDATA_SIZE_N+__DL_PDATA_SIZE_V)
#define __DL_PDATA_PD_FLAGS \
    (__DL_PDATA_PD_FLAGS_T|__DL_PDATA_PD_FLAGS_C|__DL_PDATA_PD_FLAGS_N|__DL_PDATA_PD_FLAGS_V)
#define __DL_PDATA_PA_FLAGS \
    (__DL_PDATA_PA_FLAGS_T|__DL_PDATA_PA_FLAGS_C|__DL_PDATA_PA_FLAGS_N|__DL_PDATA_PA_FLAGS_V)

/*************************************************************************/
// Compute data offsets.  This is here only because our compiler generates
// better x86 assembly output!

#define __DL_PDATA_TEXTURE_OFFSET    (0)
#define __DL_PDATA_COLOR_OFFSET	     (__DL_PDATA_SIZE_T)
#define __DL_PDATA_NORMAL_OFFSET     (__DL_PDATA_SIZE_T+__DL_PDATA_SIZE_C)
#define __DL_PDATA_VERTEX_OFFSET     (__DL_PDATA_SIZE_T+__DL_PDATA_SIZE_C+__DL_PDATA_SIZE_N)

/*************************************************************************/
// Playback a fast __glle_PolyData record in Begin.
const GLubyte * FASTCALL __DL_PDATA_NAME(__GLcontext *gc, const GLubyte *PC)
{
    POLYARRAY *pa;
    POLYDATA  *pd;

    pa = gc->paTeb;
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
// Update pa fields.

	pa->flags |= __DL_PDATA_PA_FLAGS;
	pd = pa->pdNextVertex++;

#if __DL_PDATA_T2F
	pa->pdCurTexture = pd;
#endif
#if __DL_PDATA_C3F || __DL_PDATA_C4F
	pa->pdCurColor   = pd;
#endif
#if __DL_PDATA_N3F
	pa->pdCurNormal  = pd;
#endif

// Update pd attributes.

	pd->flags |= __DL_PDATA_PD_FLAGS;

#if __DL_PDATA_V2F
	// Vertex
	pd->obj.x = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->x;
	pd->obj.y = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->y;
	pd->obj.z = __glZero;
	pd->obj.w = __glOne;
#elif __DL_PDATA_V3F
	// Vertex
	pd->obj.x = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->x;
	pd->obj.y = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->y;
	pd->obj.z = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->z;
	pd->obj.w = __glOne;
#endif

#if __DL_PDATA_T2F
	// Texture coord
	pd->texture.x = ((__GLcoord *) &PC[__DL_PDATA_TEXTURE_OFFSET])->x;
	pd->texture.y = ((__GLcoord *) &PC[__DL_PDATA_TEXTURE_OFFSET])->y;
	pd->texture.z = __glZero;
	pd->texture.w = __glOne;
#endif

#if __DL_PDATA_C3F
	// Color
	pd->color[0].r = ((__GLcolor *) &PC[__DL_PDATA_COLOR_OFFSET])->r;
	pd->color[0].g = ((__GLcolor *) &PC[__DL_PDATA_COLOR_OFFSET])->g;
	pd->color[0].b = ((__GLcolor *) &PC[__DL_PDATA_COLOR_OFFSET])->b;
	pd->color[0].a = gc->alphaVertexScale;
#elif __DL_PDATA_C4F
	// Color
	pd->color[0] = *((__GLcolor *) &PC[__DL_PDATA_COLOR_OFFSET]);
#endif

#if __DL_PDATA_N3F
	// Normal
	pd->normal.x = ((__GLcoord *) &PC[__DL_PDATA_NORMAL_OFFSET])->x;
	pd->normal.y = ((__GLcoord *) &PC[__DL_PDATA_NORMAL_OFFSET])->y;
	pd->normal.z = ((__GLcoord *) &PC[__DL_PDATA_NORMAL_OFFSET])->z;
#endif

	pd[1].flags = 0;
	if (pd >= pa->pdFlush)
	    PolyArrayFlushPartialPrimitive();
    }
    else
    {
// Something went wrong at playback time!  We can either try to playback
// this record using the regular API or punt it altogether.  I cannot think
// of a situation when this can happen, so we will punt it for now.

	WARNING("Display list: playing back POLYDATA outside BEGIN!\n");
    }

    return PC + __DL_PDATA_SIZE;
}
    #undef __DL_PDATA_NAME
    #undef __DL_PDATA_T2F
    #undef __DL_PDATA_C3F
    #undef __DL_PDATA_C4F
    #undef __DL_PDATA_N3F
    #undef __DL_PDATA_V2F
    #undef __DL_PDATA_V3F
    #undef __DL_PDATA_SIZE_T
    #undef __DL_PDATA_SIZE_C
    #undef __DL_PDATA_SIZE_N
    #undef __DL_PDATA_SIZE_V
    #undef __DL_PDATA_PD_FLAGS_T
    #undef __DL_PDATA_PD_FLAGS_C
    #undef __DL_PDATA_PD_FLAGS_N
    #undef __DL_PDATA_PD_FLAGS_V
    #undef __DL_PDATA_PA_FLAGS_T
    #undef __DL_PDATA_PA_FLAGS_C
    #undef __DL_PDATA_PA_FLAGS_N
    #undef __DL_PDATA_PA_FLAGS_V
    #undef __DL_PDATA_SIZE
    #undef __DL_PDATA_PD_FLAGS
    #undef __DL_PDATA_PA_FLAGS
    #undef __DL_PDATA_TEXTURE_OFFSET
    #undef __DL_PDATA_COLOR_OFFSET
    #undef __DL_PDATA_NORMAL_OFFSET
    #undef __DL_PDATA_VERTEX_OFFSET
#endif	// __BUILD_GLI386__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\dlist\dl_table.c ===
/******************************Module*Header*******************************\
* Module Name: dl_table.c
*
* Display list API rountines.
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1991, 1922, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Display list table management routines.
**
** $Revision: 1.12 $
** $Date: 1993/10/30 00:06:54 $
*/
#include "precomp.h"
#pragma hdrstop

/*
** The next three routines are used as callbacks by the 
** name space management code.
*/

/*
** Delete the specified display list.  This typically just means free it,
** but if it is refcounted we just decrement the ref count.
*/
void WINAPIV __glDisposeDlist(__GLcontext *gc, void *pData)
{
    __GLdlist *list = pData;

    __GL_NAMES_ASSERT_LOCKED(gc->dlist.namesArray);
    
    list->refcount--;
    
    /* less than zero references? */
    ASSERTOPENGL((GLint) list->refcount >= 0, "negative refcount!\n");
    
    if (list->refcount == 0)
	__glFreeDlist(gc, list);
}

GLboolean APIENTRY
glcltIsList ( IN GLuint list )
{
    __GL_SETUP();

    // Must use the client side begin state
    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return FALSE;
    }

    return __glNamesIsName(gc, gc->dlist.namesArray, list);
}

GLuint APIENTRY
glcltGenLists ( IN GLsizei range )
{
    __GL_SETUP();

    // Must use the client side begin state
    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return 0;
    }

    if (range < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return 0;
    }
    if (range == 0) {
	return 0;
    }

    return __glNamesGenRange(gc, gc->dlist.namesArray, range);
}

void APIENTRY
glcltListBase ( IN GLuint base )
{ 
    __GL_SETUP();

    // Must use the client side begin state
    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    gc->state.list.listBase = base;
}

void APIENTRY
glcltDeleteLists ( IN GLuint list, IN GLsizei range )
{
    __GL_SETUP();

    // Must use the client side begin state
    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }


    if (range < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }
    if (range == 0) return;

    __glNamesDeleteRange(gc, gc->dlist.namesArray, list, range);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\dlist\i386\dl_optx.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: dl_opt.asm
;
; OpenGL display-list function entries for i386.
;
; Created: 09/20/1996
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1996 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small, pascal

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include ks386.inc
        include gli386.inc
	PROFILE = 0
	include profile.inc
        .list

	OPTION PROLOGUE:NONE
	OPTION EPILOGUE:NONE

@PolyArrayFlushPartialPrimitive@0 PROTO SYSCALL
__imp__OutputDebugStringA@4 PROTO SYSCALL

    .data

ifdef DBG
    warningStr  db  'Display list: playing back POLYDATA outside BEGIN!', 13, 10, 0
endif

    .code

__GL_PDATA_FUNC MACRO name
public @&name&@8
@&name&@8 PROC

        PROF_ENTRY

        mov     eax, [ecx].GC_paTeb   ;; eax = pa
        push    ebx
        push    esi
        push    edi

if __DL_PDATA_C3F
        mov     ecx, [ecx].GC_alphaVertexScale
endif

@again:

        ;; if (pa->flags & POLYARRAY_IN_BEGIN) {
        ;;      pd = pa->pdNextVertex++;
        ;;      pa->flags |= __DL_PDATA_PA_FLAGS;

        mov     ebx, [eax].PA_flags         ;; ebx = flags
        mov     esi, [eax].PA_pdNextVertex  ;; esi = pd
        test    ebx, POLYARRAY_IN_BEGIN
        lea     edi, [esi + sizeof_POLYDATA]
        je      @notInBegin

        mov     [eax].PA_pdNextVertex, edi
        or      ebx, __DL_PDATA_PA_FLAGS

        ;; pd->flags |= __DL_PDATA_PD_FLAGS;

        mov     edi, [esi].PD_flags
        mov     [eax].PA_flags, ebx
        or      edi, __DL_PDATA_PD_FLAGS


if __DL_PDATA_C3F
        ;; pd->color[0].a = gc->alphaVertexScale;

        mov     [esi][PD_colors0 + 12], ecx
endif


;;
;; CACHE !!!
;;
;; In the logic below, we try to fill cache lines before we need them
;; by reading into registers that to not use the contents that they
;; fetched.  Unfortunatly, the data in the display list is not cached-
;; aligned, so this will be hit-and-miss.  It does, however, make a
;; measurable difference.
;;


if __DL_PDATA_T2F
        ;; pa->pdCurTexture = pd;
        mov      [eax].PA_pdCurTexture, esi
        mov      ecx, [edx][__DL_PDATA_TEXTURE_OFFSET + 0]  ;; fill cache
endif

if __DL_PDATA_C3F OR __DL_PDATA_C4F
        ;; pa->pdCurColor   = pd;
        mov      [eax].PA_pdCurColor, esi
        mov      ebx, [edx][__DL_PDATA_COLOR_OFFSET + 0]    ;; fill cache
endif

if __DL_PDATA_N3F
        ;; pa->pdCurNormal  = pd;
        mov      [eax].PA_pdCurNormal, esi
        mov      ecx, [edx][__DL_PDATA_NORMAL_OFFSET + 0]   ;; fill cache
endif

if __DL_PDATA_V2F or __DL_PDATA_V3F
        mov      ebx, [edx][__DL_PDATA_VERTEX_OFFSET + 0]   ;; fill cache
endif

        ;; finally, store pd flags:
    
        mov    [esi].PD_flags, edi

;; Update pd attributes.

        ;; constant: esi, edi, eax, edx
        ;; free:     ebx, ecx

if __DL_PDATA_T2F
	;; Texture coord
	;; pd->texture.x = ((__GLcoord *) &PC[__DL_PDATA_TEXTURE_OFFSET])->x;
	;; pd->texture.y = ((__GLcoord *) &PC[__DL_PDATA_TEXTURE_OFFSET])->y;
	;; pd->texture.z = __glZero;
	;; pd->texture.w = __glOne;

        mov     ebx, [edx][__DL_PDATA_TEXTURE_OFFSET + 0]
        mov     ecx, [edx][__DL_PDATA_TEXTURE_OFFSET + 4]
        mov     [esi][PD_texture + 0 ], ebx
        mov     [esi][PD_texture + 4 ], ecx
        mov     DWORD PTR [esi][PD_texture + 8 ], 0
        mov     DWORD PTR [esi][PD_texture + 12], __FLOAT_ONE;
endif

if __DL_PDATA_C3F
	;; Color
	;; pd->color[0].r = ((__GLcolor *) &PC[__DL_PDATA_COLOR_OFFSET])->r;
	;; pd->color[0].g = ((__GLcolor *) &PC[__DL_PDATA_COLOR_OFFSET])->g;
	;; pd->color[0].b = ((__GLcolor *) &PC[__DL_PDATA_COLOR_OFFSET])->b;

        mov     ebx, [edx][__DL_PDATA_COLOR_OFFSET + 0]
        mov     ecx, [edx][__DL_PDATA_COLOR_OFFSET + 4]
        mov     edi, [edx][__DL_PDATA_COLOR_OFFSET + 8]
        mov     [esi][PD_colors0 + 0 ], ebx
        mov     [esi][PD_colors0 + 4 ], ecx
        mov     [esi][PD_colors0 + 8 ], edi
elseif __DL_PDATA_C4F
	;; Color
	;; pd->color[0] = *((__GLcolor *) &PC[__DL_PDATA_COLOR_OFFSET]);

        mov     ebx, [edx][__DL_PDATA_COLOR_OFFSET + 0]
        mov     ecx, [edx][__DL_PDATA_COLOR_OFFSET + 4]
        mov     [esi][PD_colors0 + 0 ], ebx
        mov     [esi][PD_colors0 + 4 ], ecx
        mov     ebx, [edx][__DL_PDATA_COLOR_OFFSET + 8]
        mov     ecx, [edx][__DL_PDATA_COLOR_OFFSET + 12]
        mov     [esi][PD_colors0 + 8 ], ebx
        mov     [esi][PD_colors0 + 12], ecx

endif

if __DL_PDATA_N3F
	;; Normal
	;; pd->normal.x = ((__GLcoord *) &PC[__DL_PDATA_NORMAL_OFFSET])->x;
	;; pd->normal.y = ((__GLcoord *) &PC[__DL_PDATA_NORMAL_OFFSET])->y;
	;; pd->normal.z = ((__GLcoord *) &PC[__DL_PDATA_NORMAL_OFFSET])->z;

        mov     ebx, [edx][__DL_PDATA_NORMAL_OFFSET + 0]
        mov     ecx, [edx][__DL_PDATA_NORMAL_OFFSET + 4]
        mov     edi, [edx][__DL_PDATA_NORMAL_OFFSET + 8]
        mov     [esi][PD_normal + 0 ], ebx
        mov     [esi][PD_normal + 4 ], ecx
        mov     [esi][PD_normal + 8 ], edi            
endif

if __DL_PDATA_V2F
        ;; Vertex
        ;; pd->obj.x = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->x;
	;; pd->obj.y = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->y;
	;; pd->obj.z = __glZero;
	;; pd->obj.w = __glOne;

        mov     ebx, [edx][__DL_PDATA_VERTEX_OFFSET + 0]
        mov     ecx, [edx][__DL_PDATA_VERTEX_OFFSET + 4]
        mov     [esi][PD_obj + 0 ], ebx
        mov     [esi][PD_obj + 4 ], ecx
        mov     DWORD PTR [esi][PD_OBJ + 8 ], 0
        mov     DWORD PTR [esi][PD_obj + 12], __FLOAT_ONE

elseif __DL_PDATA_V3F
	;; Vertex
	;; pd->obj.x = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->x;
	;; pd->obj.y = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->y;
	;; pd->obj.z = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->z;
	;; pd->obj.w = __glOne;

        mov     ebx, [__DL_PDATA_VERTEX_OFFSET + 0][edx]
        mov     ecx, [__DL_PDATA_VERTEX_OFFSET + 4][edx]
        mov     edi, [__DL_PDATA_VERTEX_OFFSET + 8][edx]
        mov     [esi][PD_obj + 0 ], ebx
        mov     [esi][PD_obj + 4 ], ecx
        mov     [esi][PD_obj + 8 ], edi
        mov     DWORD PTR [esi][PD_obj + 12], __FLOAT_ONE
endif

	;; pd[1].flags = 0;
	;; if (pd >= pa->pdFlush)
	;;    PolyArrayFlushPartialPrimitive();

        mov     ebx, [eax].PA_pdFlush
        mov     DWORD PTR [esi][sizeof_POLYDATA + PD_flags], 0
        cmp     ebx, esi

        mov ebx, [edx - 4]
        mov ecx, [edx + __DL_PDATA_SIZE]

        ja      @noFlush


        push    esi
	push    edi
	push    eax
	push    ebx
	push    ecx
        push    edx
        call    @PolyArrayFlushPartialPrimitive@0
        pop     edx
	pop     ecx
	pop     ebx
	pop     eax
	pop     edi
	pop     esi

@noFlush:

        cmp     ebx, ecx
        jne     @doExit

        lea     edx, [edx + __DL_PDATA_SIZE + 4]
if __DL_PDATA_C3F
        mov     ecx, [esi][PD_colors0 + 12]
endif

        jmp     @again


@doExit:
        lea     eax, [edx + __DL_PDATA_SIZE]
        pop     edi
        pop     esi
        pop     ebx
        ret     0

@notInBegin:

ifdef DBG
        push    edx

        push    offset warningStr
        call    DWORD PTR __imp__OutputDebugStringA@4

        pop     edx
endif

        lea     eax, [edx + __DL_PDATA_SIZE]
        pop     edi
        pop     esi
        pop     ebx
        ret     0

@&name&@8 ENDP

ENDM


;; Define fast playback routines for PolyData records.

__GLLE_POLYDATA_C3F_V3F         =     0
__GLLE_POLYDATA_N3F_V3F         =     0
__GLLE_POLYDATA_C3F_N3F_V3F     =     0
__GLLE_POLYDATA_C4F_N3F_V3F     =     0
__GLLE_POLYDATA_T2F_V3F         =     0
__GLLE_POLYDATA_T2F_C3F_V3F     =     0
__GLLE_POLYDATA_T2F_N3F_V3F     =     0
__GLLE_POLYDATA_T2F_C3F_N3F_V3F =     0
__GLLE_POLYDATA_T2F_C4F_N3F_V3F =     0


__GLLE_POLYDATA_C3F_V3F		=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_C3F_V3F>
__GLLE_POLYDATA_C3F_V3F         =     0

__GLLE_POLYDATA_N3F_V3F		=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_N3F_V3F>
__GLLE_POLYDATA_N3F_V3F         =     0

__GLLE_POLYDATA_C3F_N3F_V3F	=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_C3F_N3F_V3F>
__GLLE_POLYDATA_C3F_N3F_V3F     =     0

__GLLE_POLYDATA_C4F_N3F_V3F	=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_C4F_N3F_V3F>
__GLLE_POLYDATA_C4F_N3F_V3F     =     0

__GLLE_POLYDATA_T2F_V3F		=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_T2F_V3F>
__GLLE_POLYDATA_T2F_V3F         =     0

__GLLE_POLYDATA_T2F_C3F_V3F	=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_T2F_C3F_V3F>
__GLLE_POLYDATA_T2F_C3F_V3F     =     0

__GLLE_POLYDATA_T2F_N3F_V3F	=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_T2F_N3F_V3F>
__GLLE_POLYDATA_T2F_N3F_V3F     =     0

__GLLE_POLYDATA_T2F_C3F_N3F_V3F	=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_T2F_C3F_N3F_V3F>
__GLLE_POLYDATA_T2F_C3F_N3F_V3F =     0

__GLLE_POLYDATA_T2F_C4F_N3F_V3F	=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_T2F_C4F_N3F_V3F>
__GLLE_POLYDATA_T2F_C4F_N3F_V3F =     0


end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\dlist\i386\profile.inc ===
IFNDEF __PROFILE_INC__
__PROFILE_INC EQU 1

IF PROFILE
EXTRN __penter:NEAR
	
PROF_ENTRY MACRO
	call __penter
	ENDM
ELSE
PROF_ENTRY MACRO
	ENDM
ENDIF
	
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\dlist\i386\dl_pdata.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: dl_pdata.inc
;
; OpenGL display-list macros/equates for i386.
;
; Created: 09/20/1996
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1996 Microsoft Corporation
;----------------------------------------------------------------------;

if __GLLE_POLYDATA_C3F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_C3F_V3F
    __DL_PDATA_T2F      =        0
    __DL_PDATA_C3F      =        1
    __DL_PDATA_C4F      =        0
    __DL_PDATA_N3F      =        0
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

if __GLLE_POLYDATA_N3F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_N3F_V3F
    __DL_PDATA_T2F      =        0
    __DL_PDATA_C3F      =        0
    __DL_PDATA_C4F      =        0
    __DL_PDATA_N3F      =        1
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

if __GLLE_POLYDATA_C3F_N3F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_C3F_N3F_V3F
    __DL_PDATA_T2F      =        0
    __DL_PDATA_C3F      =        1
    __DL_PDATA_C4F      =        0
    __DL_PDATA_N3F      =        1
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

if __GLLE_POLYDATA_C4F_N3F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_C4F_N3F_V3F
    __DL_PDATA_T2F      =        0
    __DL_PDATA_C3F      =        0
    __DL_PDATA_C4F      =        1
    __DL_PDATA_N3F      =        1
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

if __GLLE_POLYDATA_T2F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_T2F_V3F
    __DL_PDATA_T2F      =        1
    __DL_PDATA_C3F      =        0
    __DL_PDATA_C4F      =        0
    __DL_PDATA_N3F      =        0
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

if __GLLE_POLYDATA_T2F_C3F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_T2F_C3F_V3F
    __DL_PDATA_T2F      =        1
    __DL_PDATA_C3F      =        1
    __DL_PDATA_C4F      =        0
    __DL_PDATA_N3F      =        0
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

if __GLLE_POLYDATA_T2F_N3F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_T2F_N3F_V3F
    __DL_PDATA_T2F      =        1
    __DL_PDATA_C3F      =        0
    __DL_PDATA_C4F      =        0
    __DL_PDATA_N3F      =        1
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

if __GLLE_POLYDATA_T2F_C3F_N3F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_T2F_C3F_N3F_V3F
    __DL_PDATA_T2F      =        1
    __DL_PDATA_C3F      =        1
    __DL_PDATA_C4F      =        0
    __DL_PDATA_N3F      =        1
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

if __GLLE_POLYDATA_T2F_C4F_N3F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_T2F_C4F_N3F_V3F
    __DL_PDATA_T2F      =        1
    __DL_PDATA_C3F      =        0
    __DL_PDATA_C4F      =        1
    __DL_PDATA_N3F      =        1
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

;; Compute record size, pd flags and pa flags

if __DL_PDATA_T2F
    __DL_PDATA_SIZE_T       =     __PDATA_SIZE_T2F
    __DL_PDATA_PD_FLAGS_T   =     __PDATA_PD_FLAGS_T2F
    __DL_PDATA_PA_FLAGS_T   =     __PDATA_PA_FLAGS_T2F
else
    __DL_PDATA_SIZE_T       =     0
    __DL_PDATA_PD_FLAGS_T   =     0
    __DL_PDATA_PA_FLAGS_T   =     0
endif

if __DL_PDATA_C3F
    __DL_PDATA_SIZE_C       =     __PDATA_SIZE_C3F
    __DL_PDATA_PD_FLAGS_C   =     __PDATA_PD_FLAGS_C3F
    __DL_PDATA_PA_FLAGS_C   =     __PDATA_PA_FLAGS_C3F
elseif __DL_PDATA_C4F
    __DL_PDATA_SIZE_C       =     __PDATA_SIZE_C4F
    __DL_PDATA_PD_FLAGS_C   =     __PDATA_PD_FLAGS_C4F
    __DL_PDATA_PA_FLAGS_C   =     __PDATA_PA_FLAGS_C4F
else
    __DL_PDATA_SIZE_C       =     0
    __DL_PDATA_PD_FLAGS_C   =     0
    __DL_PDATA_PA_FLAGS_C   =     0
endif

if __DL_PDATA_N3F
    __DL_PDATA_SIZE_N       =     __PDATA_SIZE_N3F
    __DL_PDATA_PD_FLAGS_N   =     __PDATA_PD_FLAGS_N3F
    __DL_PDATA_PA_FLAGS_N   =     __PDATA_PA_FLAGS_N3F
else
    __DL_PDATA_SIZE_N       =     0
    __DL_PDATA_PD_FLAGS_N   =     0
    __DL_PDATA_PA_FLAGS_N   =     0
endif

if __DL_PDATA_V2F
    __DL_PDATA_SIZE_V       =     __PDATA_SIZE_V2F
    __DL_PDATA_PD_FLAGS_V   =     __PDATA_PD_FLAGS_V2F
    __DL_PDATA_PA_FLAGS_V   =     __PDATA_PA_FLAGS_V2F
elseif __DL_PDATA_V3F
    __DL_PDATA_SIZE_V       =     __PDATA_SIZE_V3F
    __DL_PDATA_PD_FLAGS_V   =     __PDATA_PD_FLAGS_V3F
    __DL_PDATA_PA_FLAGS_V   =     __PDATA_PA_FLAGS_V3F
else
    __DL_PDATA_SIZE_V       =     0
    __DL_PDATA_PD_FLAGS_V   =     0
    __DL_PDATA_PA_FLAGS_V   =     0
endif

__DL_PDATA_SIZE             =     (__DL_PDATA_SIZE_T+__DL_PDATA_SIZE_C+__DL_PDATA_SIZE_N+__DL_PDATA_SIZE_V)
__DL_PDATA_PD_FLAGS         =     (__DL_PDATA_PD_FLAGS_T OR __DL_PDATA_PD_FLAGS_C OR __DL_PDATA_PD_FLAGS_N OR __DL_PDATA_PD_FLAGS_V)
__DL_PDATA_PA_FLAGS         =     (__DL_PDATA_PA_FLAGS_T OR __DL_PDATA_PA_FLAGS_C OR __DL_PDATA_PA_FLAGS_N OR __DL_PDATA_PA_FLAGS_V)

__DL_PDATA_TEXTURE_OFFSET   =     (0)
__DL_PDATA_COLOR_OFFSET	    =     (__DL_PDATA_SIZE_T)
__DL_PDATA_NORMAL_OFFSET    =     (__DL_PDATA_SIZE_T+__DL_PDATA_SIZE_C)
__DL_PDATA_VERTEX_OFFSET    =     (__DL_PDATA_SIZE_T+__DL_PDATA_SIZE_C+__DL_PDATA_SIZE_N)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\inc\glsint.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#define __GL_ATTRIB_MASK_COUNT                  23

#define __GLS_IMAGE_FLAGS_COUNT                 2
#define __GLS_API_COUNT                         2

#define __GL_ENUM_PAGE_COUNT                    130
#define __GLS_ENUM_PAGE_COUNT                   65

#define __GL_ENUMS_PER_PAGE                     256
#define __GLS_ENUMS_PER_PAGE                    16

#define __GLS_OPCODES_PER_PAGE                  16

#define __GLS_OPCODE_PAGE_INTERNAL0             0

#define __GLS_OPCODE_PAGE_GLS0                  1
#define __GLS_OPCODE_PAGE_GLS1                  2
#define __GLS_OPCODE_PAGE_GLS2                  3

#define __GLS_OPCODE_PAGE_GL0                   4
#define __GLS_OPCODE_PAGE_GL1                   5
#define __GLS_OPCODE_PAGE_GL2                   6
#define __GLS_OPCODE_PAGE_GL3                   7
#define __GLS_OPCODE_PAGE_GL4                   8
#define __GLS_OPCODE_PAGE_GL5                   9
#define __GLS_OPCODE_PAGE_GL6                   10
#define __GLS_OPCODE_PAGE_GL7                   11
#define __GLS_OPCODE_PAGE_GL8                   12
#define __GLS_OPCODE_PAGE_GL9                   13
#define __GLS_OPCODE_PAGE_GL10                  14
#define __GLS_OPCODE_PAGE_GL11                  15
#define __GLS_OPCODE_PAGE_GL12                  16
#define __GLS_OPCODE_PAGE_GL13                  17
#define __GLS_OPCODE_PAGE_GL14                  18
#define __GLS_OPCODE_PAGE_GL15                  19
#define __GLS_OPCODE_PAGE_GL16                  20
#define __GLS_OPCODE_PAGE_GL17                  21
#define __GLS_OPCODE_PAGE_GL18                  22
#define __GLS_OPCODE_PAGE_GL19                  23
#define __GLS_OPCODE_PAGE_GL20                  24

#define __GLS_OPCODE_PAGE_MAPPED0               25
#define __GLS_OPCODE_PAGE_EXTEND0               64

#define __GLS_OPCODE_PAGE_GL_SGI0               4095
#define __GLS_OPCODE_PAGE_GL_SGI1               4094
#define __GLS_OPCODE_PAGE_GL_SGI2               4093
#define __GLS_OPCODE_PAGE_GL_SGI3               4092
#define __GLS_OPCODE_PAGE_GL_SGI4               4091
#define __GLS_OPCODE_PAGE_GL_SGI5               4090
#define __GLS_OPCODE_PAGE_GL_MSFT0              4089

#define __GLS_MAPPED_OPCODE_PAGE_COUNT          7
#define __GLS_MAPPED_OPCODE_PAGE0               __GLS_OPCODE_PAGE_GL_SGI0
#define __GLS_MAPPED_OPCODE_PAGE1               __GLS_OPCODE_PAGE_GL_SGI1
#define __GLS_MAPPED_OPCODE_PAGE2               __GLS_OPCODE_PAGE_GL_SGI2
#define __GLS_MAPPED_OPCODE_PAGE3               __GLS_OPCODE_PAGE_GL_SGI3
#define __GLS_MAPPED_OPCODE_PAGE4               __GLS_OPCODE_PAGE_GL_SGI4
#define __GLS_MAPPED_OPCODE_PAGE5               __GLS_OPCODE_PAGE_GL_SGI5
#define __GLS_MAPPED_OPCODE_PAGE6               __GLS_OPCODE_PAGE_GL_MSFT0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\inc\encoding.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

extern const GLubyte __glsCharType[256];

#define __GLS_CHAR_GRAPHIC_BIT 0x01
#define __GLS_CHAR_SPACE_BIT 0x02
#define __GLS_CHAR_TOKEN_BIT 0x04

#define __GLS_CHAR_IS_GRAPHIC(inChar) \
    (__glsCharType[inChar] & __GLS_CHAR_GRAPHIC_BIT)
#define __GLS_CHAR_IS_SPACE(inChar) \
    (__glsCharType[inChar] & __GLS_CHAR_SPACE_BIT)
#define __GLS_CHAR_IS_TOKEN(inChar) \
    (__glsCharType[inChar] & __GLS_CHAR_TOKEN_BIT)

#if __GLS_MSB_FIRST
    #define __GLS_BINARY_SWAP0 GLS_BINARY_MSB_FIRST
    #define __GLS_BINARY_SWAP1 GLS_BINARY_LSB_FIRST
    #define __GLS_COUNT_SMALL(inWord) (inWord & 0x0000ffff)
    #define __GLS_OP_SMALL(inWord) (inWord >> 16)
#else /* !__GLS_MSB_FIRST */
    #define __GLS_BINARY_SWAP0 GLS_BINARY_LSB_FIRST
    #define __GLS_BINARY_SWAP1 GLS_BINARY_MSB_FIRST
    #define __GLS_COUNT_SMALL(inWord) (inWord >> 16)
    #define __GLS_OP_SMALL(inWord) (inWord & 0x0000ffff)
#endif /* __GLS_MSB_FIRST */

#define __GLS_COMMAND_JUMP(inPC) ((__GLSbinCommand_jump *)inPC)
#define __GLS_HEAD_LARGE(inPC) ((__GLSbinCommandHead_large *)inPC)
#define __GLS_JUMP_ALLOC (sizeof(__GLSbinCommand_jump) + 4)

typedef struct {
    GLushort opSmall;
    GLushort countSmall;
} __GLSbinCommandHead_small;

typedef struct {
    GLushort opSmall;
    GLushort countSmall;
    GLuint opLarge;
    GLuint countLarge;
} __GLSbinCommandHead_large;

typedef struct {
    GLint major;
    GLint minor;
} __GLSversion;

typedef struct {
    __GLSbinCommandHead_large head;
    __GLSversion version;
} __GLSbinCommand_BeginGLS;

extern GLSenum __glsBinCommand_BeginGLS_getType(
    __GLSbinCommand_BeginGLS *inCommand, __GLSversion *outVersion
);

typedef struct {
    __GLSbinCommandHead_large head;
    GLuint pad;
    GLubyte *dest;
} __GLSbinCommand_jump;

typedef struct {
    __GLSbinCommandHead_small head;
} __GLSbinCommand_pad;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\cmd\glscat.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glsutil.h"
#include <stdlib.h>
#include <string.h>

#if __GLS_PLATFORM_WIN32
    #include <fcntl.h>
    #include <io.h>
    #define __MAIN_LINKAGE __cdecl
#else /* !__GLS_PLATFORM_WIN32 */
    #define __MAIN_LINKAGE
#endif /* __GLS_PLATFORM_WIN32 */

static struct {
    GLubyte **argv;
} global;

static void glscat_configStdio(void) {
    setbuf(stdin, GLS_NONE);
    setbuf(stdout, GLS_NONE);
    #if __GLS_PLATFORM_WIN32
        _setmode(_fileno(stdin), _O_BINARY);
        _setmode(_fileno(stdout), _O_BINARY);
        _setmode(_fileno(stderr), _O_BINARY);
    #endif /* __GLS_PLATFORM_WIN32 */
}

static void glscat_checkError(void) {
    const GLSenum error = glsGetError(GL_TRUE);

    if (error) {
        fprintf(
            stderr,
            "%s fatal: %s\n",
            global.argv[0],
            glsEnumString(GLS_API_GLS, error)
        );
        exit(EXIT_FAILURE);
    }
}

static void glscat_usage(void) {
    fprintf(
        stderr,
        "usage: %s "
        "[-a] [-c] [-d dir]* [-h] [-o out] [-r] [-t type] [in]*\n"
        "    -a: append\n"
        "    -c: copy through context\n"
        "    -d: prepend dir to search path\n"
        "    -h: help\n"
        "    -o: output stream (default: standard output)\n"
        "    -r: recursive copy\n"
        "    -t: type of output stream, one of:\n"
        "            GLS_NONE              (default: same as input stream)\n"
        "            GLS_BINARY_LSB_FIRST  (little-endian binary)\n"
        "            GLS_BINARY_MSB_FIRST  (big-endian binary)\n"
        "            GLS_BINARY_SWAP0      (native binary)\n"
        "            GLS_BINARY_SWAP1      (swapped binary)\n"
        "            GLS_TEXT              (human-editable)\n",
        global.argv[0]
    );
    exit(EXIT_FAILURE);
}

int __MAIN_LINKAGE main(const GLsizei inArgc, GLubyte *inArgv[]) {
    GLint arg;
    GLboolean context = GL_FALSE;
    __GLSstring dir;
    __GLSstring inStream;
    __GLSstring outStream;
    GLboolean recursive = GL_FALSE;
    GLSenum type = GLS_NONE;
    GLbitfield writeFlags = GLS_NONE;

    glscat_configStdio();
    __glsString_init(&dir);
    __glsString_init(&inStream);
    __glsString_init(&outStream);
    global.argv = inArgv;
    glsContext(glsGenContext());
    for (arg = 1 ; arg < inArgc && inArgv[arg][0] == '-' ; ++arg) {
        if (inArgv[arg][2]) glscat_usage();
        switch (inArgv[arg][1]) {
            case 'a':
                writeFlags |= GLS_WRITE_APPEND_BIT;
                break;
            case 'c':
                context = GL_TRUE;
                break;
            case 'd':
                if (++arg >= inArgc) glscat_usage();
                __glsString_assign(&dir, inArgv[arg]);
                __glsString_appendChar(&dir, '/');
                glsReadPrefix(GLS_PREPEND, dir.head);
                break;
            case 'o':
                if (++arg >= inArgc) glscat_usage();
                __glsString_assign(&outStream, inArgv[arg]);
                break;
            case 'r':
                recursive = GL_TRUE;
                break;
            case 't':
                if (++arg >= inArgc) glscat_usage();
                if (
                    !strcmp((const char *)inArgv[arg], "GLS_NONE")
                ) {
                    type = GLS_NONE;
                } else if (
                    !strcmp((const char *)inArgv[arg], "GLS_BINARY_LSB_FIRST")
                ) {
                    type = GLS_BINARY_LSB_FIRST;
                } else if (
                    !strcmp((const char *)inArgv[arg], "GLS_BINARY_MSB_FIRST")
                ) {
                    type = GLS_BINARY_MSB_FIRST;
                } else if (
                    !strcmp((const char *)inArgv[arg], "GLS_BINARY_SWAP0")
                ) {
                    type = glsBinary(GL_FALSE);
                } else if (
                    !strcmp((const char *)inArgv[arg], "GLS_BINARY_SWAP1")
                ) {
                    type = glsBinary(GL_TRUE);
                } else if (
                    !strcmp((const char *)inArgv[arg], "GLS_TEXT")
                ) {
                    type = GLS_TEXT;
                } else {
                    glscat_usage();
                }
                break;
            case 'h':
            default:
                glscat_usage();
        }
    }
    glscat_checkError();
    if (recursive) {
        glsCaptureFlags(GLS_OP_glsCallStream, GLS_CAPTURE_EXECUTE_BIT);
    }
    do {
        if (arg < inArgc) __glsString_assign(&inStream, inArgv[arg]);
        if (context) {
            GLSenum copyType = glsCopyStream(
                inStream.head, glsCSTR(""), GLS_CONTEXT, GLS_NONE
            );

            if (type != GLS_NONE) copyType = type;
            glsCopyStream(glsCSTR(""), outStream.head, copyType, writeFlags);
        } else {
            glsCopyStream(inStream.head, outStream.head, type, writeFlags);
        }
        glscat_checkError();
        writeFlags |= GLS_WRITE_APPEND_BIT;
    } while (++arg < inArgc);
    return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\inc\glslib.h ===
#if !defined(__glslib_h_)
#define __glslib_h_

/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/******************************************************************************
Constants
******************************************************************************/

#define __GLS_BOOLEAN 0x0001

#define __GLS_MAX_ALIGN_BYTES 8
#define __GLS_MAX_CALL_NESTING 64
#define __GLS_MAX_CAPTURE_NESTING 16
#define __GLS_MAX_OUT_ARGS 4
#define __GLS_VERSION_MAJOR 1
#define __GLS_VERSION_MINOR 0

#define __GLS_COMMAND_ALIGN_EVEN32_BIT  0x80000000
#define __GLS_COMMAND_ALIGN_ODD32_BIT   0x40000000
#define __GLS_COMMAND_0_PARAMS_BIT      0x20000000
#define __GLS_COMMAND_ATTRIB_MASK       0x0000FFFF

/******************************************************************************
Extensions
******************************************************************************/

// DrewB
#ifndef __GLS_PLATFORM_WIN32
#define __GL_EXT_abgr 1
#define __GL_EXT_blend_color 1
#define __GL_EXT_blend_logic_op 1
#define __GL_EXT_blend_minmax 1
#define __GL_EXT_blend_subtract 1
#define __GL_EXT_cmyka 1
#define __GL_EXT_convolution 1
#define __GL_EXT_copy_texture 1
#define __GL_EXT_histogram 1
#define __GL_EXT_packed_pixels 1
#define __GL_EXT_polygon_offset 1
#define __GL_EXT_rescale_normal 1
#define __GL_EXT_subtexture 1
#define __GL_EXT_texture 1
#define __GL_EXT_texture_object 1
#define __GL_EXT_texture3D 1
#define __GL_EXT_vertex_array 1
#else
#define __GL_EXT_paletted_texture 1
#define __GL_EXT_bgra 1
#define __GL_WIN_draw_range_elements 1
#endif

#if __GLS_PLATFORM_IRIX

    #define __GL_SGI_color_matrix 1
    #define __GL_SGI_color_table 1
    #define __GL_SGI_texture_color_table 1
    #define __GL_SGIS_component_select 1
    #define __GL_SGIS_detail_texture 1
    #define __GL_SGIS_multisample 1
    #define __GL_SGIS_sharpen_texture 1
    #define __GL_SGIS_texture_border_clamp 1
    #define __GL_SGIS_texture4D 1
    #define __GL_SGIX_interlace 1
    #define __GL_SGIX_multisample 1
    #define __GL_SGIX_pixel_texture 1
    #define __GL_SGIX_pixel_tiles 1
    #define __GL_SGIX_texture_multi_buffer 1

    #if __GLS_PLATFORM_IRIX_FUTURE
        #define __GL_SGIS_texture_edge_clamp 1
        #define __GL_SGIS_texture_filter4 0
        #define __GL_SGIS_texture_lod 1
        #define __GL_SGIX_multipass 0
        #define __GL_SGIX_sprite 0
    #endif /* __GLS_PLATFORM_IRIX_FUTURE */

#endif /* __GLS_PLATFORM_IRIX */

/******************************************************************************
Macros
******************************************************************************/

#define __GL_ENUM_OFFSET(inEnum) (GLint)(inEnum % __GL_ENUMS_PER_PAGE)
#define __GL_ENUM_PAGE(inEnum) (GLint)(inEnum / __GL_ENUMS_PER_PAGE)

#define __GL_ENUM(inPage, inOffset) ( \
    (inPage) * __GL_ENUMS_PER_PAGE + (inOffset) \
)

#define __GLS_ENUM_OFFSET(inEnum) (GLint)(inEnum % __GLS_ENUMS_PER_PAGE)
#define __GLS_ENUM_PAGE(inEnum) (GLint)(inEnum / __GLS_ENUMS_PER_PAGE)

#define __GLS_ENUM(inPage, inOffset) ( \
    (inPage) * __GLS_ENUMS_PER_PAGE + (inOffset) \
)

#define __GLS_FORWARD

/******************************************************************************
Includes
******************************************************************************/

#include <glmf.h>
#include "glsint.h"
#include "glsutil.h"
#include "encoding.h"
#include "opcode.h"
#include "pixel.h"
#include "read.h"
#include "parser.h"
#include "ctx.h"
#include "platform.h"
#include "write.h"
#ifdef __GLS_PLATFORM_WIN32
// DrewB
#include "glssize.h"
#endif

/******************************************************************************
Global data
******************************************************************************/

extern const GLSenum __glsAllAPIs[__GLS_API_COUNT + 1];
extern const GLubyte *const __glAttribMaskString[__GL_ATTRIB_MASK_COUNT];
extern const GLbitfield __glAttribMaskVal[__GL_ATTRIB_MASK_COUNT];
extern __GLSdict *__glsContextDict;
extern __GLScontextList __glsContextList;
extern const GLubyte *const *const __glEnumString[__GL_ENUM_PAGE_COUNT];
extern const GLint __glEnumStringCount[__GL_ENUM_PAGE_COUNT];
extern const GLSfunc __glsDispatchCapture[__GLS_OPCODE_COUNT];
extern __GLSdecodeBinFunc __glsDispatchDecode_bin_default[__GLS_OPCODE_COUNT];

extern const __GLSdecodeBinFunc __glsDispatchDecode_bin_swap[
    __GLS_OPCODE_COUNT
];

extern const __GLSdecodeTextFunc __glsDispatchDecode_text[__GLS_OPCODE_COUNT];
extern GLSfunc __glsDispatchExec[__GLS_OPCODE_COUNT];
extern const GLubyte *const *const __glsEnumString[__GLS_ENUM_PAGE_COUNT];
extern const GLint __glsEnumStringCount[__GLS_ENUM_PAGE_COUNT];
extern const GLubyte *const __glsExtensions;
extern const GLubyte *const __glsImageFlagsString[__GLS_IMAGE_FLAGS_COUNT];
extern const GLbitfield __glsImageFlagsVal[__GLS_IMAGE_FLAGS_COUNT];
extern const GLbitfield __glsOpcodeAttrib[__GLS_OPCODE_COUNT];
extern const GLubyte *const __glsOpcodeString[__GLS_OPCODE_COUNT];
extern const GLSopcode __glsOpcodesGL[];
extern const GLSopcode __glsOpcodesGLS[];
extern const GLint __glsOpcodesGLCount;
extern const GLint __glsOpcodesGLSCount;
extern __GLSparser *__glsParser;

#if __GLS_MAPPED_OPCODE_PAGE_COUNT
extern const GLint __glsOpPageMap[__GLS_MAPPED_OPCODE_PAGE_COUNT];
#endif /* __GLS_MAPPED_OPCODE_PAGE_COUNT */

/******************************************************************************
Global functions
******************************************************************************/

#define __GLS_RAISE_ERROR(inError) if (!__GLS_ERROR) __GLS_PUT_ERROR(inError)

#ifndef __GLS_PLATFORM_WIN32
// DrewB
extern void __glsCallError(GLSopcode inOpcode, GLSenum inError);
#define __GLS_CALL_ERROR(ctx, inOpcode, inError) \
    __glsCallError(inOpcode, inError)
extern void __glsCallUnsupportedCommand(void);
#define __GLS_CALL_UNSUPPORTED_COMMAND(ctx) \
    __glsCallUnsupportedCommand()
#else
extern void __glsCallError(__GLScontext *ctx,
                           GLSopcode inOpcode, GLSenum inError);
#define __GLS_CALL_ERROR(ctx, inOpcode, inError) \
    __glsCallError(ctx, inOpcode, inError)
extern void __glsCallUnsupportedCommand(__GLScontext *ctx);
#define __GLS_CALL_UNSUPPORTED_COMMAND(ctx) \
    __glsCallUnsupportedCommand(ctx)
#endif

#endif /* __glslib_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\inc\ctx.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/******************************************************************************
Locale
******************************************************************************/

#define __GLS_C_LOCALE_DECLARE \
    const GLubyte *const __locale = glsCSTR(setlocale(LC_NUMERIC, GLS_NONE)); \
    GLboolean __saveLocale = (GLboolean)(__locale[0] != 'C' || __locale[1])

#define __GLS_C_LOCALE_BEGIN \
    if ( \
        __saveLocale && \
        __glsString_assign(&__GLS_CONTEXT->savedLocale, __locale) \
    ) { \
        setlocale(LC_NUMERIC, "C"); \
    } else { \
        __saveLocale = GL_FALSE; \
    }

#define __GLS_C_LOCALE_END \
    if (__saveLocale) setlocale( \
        LC_NUMERIC, (const char *)__GLS_CONTEXT->savedLocale.head \
    )

/******************************************************************************
__GLSglrc
******************************************************************************/

typedef struct {
    GLvoid *base;
    size_t byteCount;
} __GLSglrcBuf;

typedef struct __GLSglrc __GLSglrc;

struct __GLSglrc {
    GLuint layer;
    GLuint readLayer;
    GLuint shareGLRC;
    __GLSglrcBuf feedbackBuf;
    __GLSglrcBuf selectBuf;
    #if __GL_EXT_vertex_array
        __GLSglrcBuf colorBuf;
        __GLSglrcBuf edgeFlagBuf;
        __GLSglrcBuf indexBuf;
        __GLSglrcBuf normalBuf;
        __GLSglrcBuf texCoordBuf;
        __GLSglrcBuf vertexBuf;
    #endif /* __GL_EXT_vertex_array */
};

extern void __glsGLRC_final(__GLSglrc *inoutGLRC);
extern void __glsGLRC_init(__GLSglrc *outGLRC);

/******************************************************************************
__GLSlayer
******************************************************************************/

typedef struct __GLSlayer __GLSlayer;

struct __GLSlayer {
    GLfloat invisibleAspect;
    GLSenum displayFormat;
    GLint doubleBuffer;
    GLint invisible;
    GLint invisibleHeightPixels;
    GLint level;
    GLint stereo;
    GLint transparent;
    GLint indexBits;
    GLint redBits;
    GLint greenBits;
    GLint blueBits;
    GLint alphaBits;
    GLint depthBits;
    GLint stencilBits;
    GLint accumRedBits;
    GLint accumGreenBits;
    GLint accumBlueBits;
    GLint accumAlphaBits;
    GLint auxBuffers;
    #if __GL_SGIS_multisample
        GLint sampleBuffers;
        GLint samples;
    #endif /* __GL_SGIS_multisample */
};

extern void __glsLayer_init(__GLSlayer *outLayer);

/******************************************************************************
__GLSheader
******************************************************************************/

typedef struct __GLSheader __GLSheader;

struct __GLSheader {
    GLfloat aspect;
    GLfloat borderWidth;
    GLfloat contrastRatio;
    GLfloat heightMM;
    GLfloat borderColor[4];
    GLfloat gamma[4];
    GLfloat origin[2];
    GLfloat pageColor[4];
    GLfloat pageSize[2];
    GLfloat redPoint[2];
    GLfloat greenPoint[2];
    GLfloat bluePoint[2];
    GLfloat whitePoint[2];
    GLint frameCount;
    GLint glrcCount;
    __GLSglrc *glrcs;
    GLint heightPixels;
    GLint layerCount;
    GLint tileable;
    __GLSlayer *layers;
    GLint createTime[6];
    GLint modifyTime[6];
    __GLSstring extensions;
    __GLSstring author;
    __GLSstring description;
    __GLSstring notes;
    __GLSstring title;
    __GLSstring tools;
    __GLSstring version;
};

extern void __glsHeader_final(__GLSheader *inoutHeader);
extern GLboolean __glsHeader_init(__GLSheader *outHeader);
extern GLboolean __glsHeader_reset(__GLSheader *inoutHeader);

/******************************************************************************
__GLScontext
******************************************************************************/

#if !__GLS_PLATFORM_WIN32
// DrewB
typedef void (*__GLSdecodeBinFunc)(GLubyte *inoutPtr);
typedef void (*__GLSdecodeTextFunc)(__GLSreader *inoutReader);
#else
typedef void (*__GLSdecodeBinFunc)(struct __GLScontext *ctx,
                                   GLubyte *inoutPtr);
typedef void (*__GLSdecodeTextFunc)(struct __GLScontext *ctx,
                                    __GLSreader *inoutReader);
#endif

typedef struct __GLScontextStream __GLScontextStream;
typedef struct __GLSlistString __GLSlistString;

typedef struct {
    GLint count;
    GLulong vals[__GLS_MAX_OUT_ARGS];
} __GLSoutArgs;

typedef struct __GLScontext {
    __GLS_LIST_ELEM;
    GLSenum abortMode;
    GLSenum blockType;
    GLint callNesting;
    GLint captureEntryCount;
    GLScaptureFunc captureEntryFunc;
    GLScaptureFunc captureExitFunc;
    GLubyte captureFlags[__GLS_OPCODE_COUNT];
    GLint captureNesting;
    GLSfunc commandFuncs[__GLS_OPCODE_COUNT];
    GLboolean contextCall;
    __GLSdict *contextStreamDict;
    __GLS_ITERLIST(__GLScontextStream) contextStreamList;
    GLboolean current;
    GLuint currentGLRC;
    GLvoid *dataPointer;
    FILE *defaultReadChannel;
    FILE *defaultWriteChannel;
    GLboolean deleted;
    GLSfunc dispatchAPI[__GLS_OPCODE_COUNT];
    GLSfunc dispatchCall[__GLS_OPCODE_COUNT];
    __GLSdecodeBinFunc dispatchDecode_bin[__GLS_OPCODE_COUNT];
    __GLSheader header;
    GLuint name;
    __GLSoutArgs outArgs;
    GLboolean pixelSetupGen;
    GLSreadFunc readFunc;
    __GLS_ITERLIST(__GLSlistString) readPrefixList;
    __GLSstring returnString;
    __GLSstring savedLocale;
    __GLSversion streamVersion;
    GLSwriteFunc unreadFunc;
    struct __GLSwriter *writer;
    struct __GLSwriter *writers[__GLS_MAX_CAPTURE_NESTING];
    GLSwriteFunc writeFunc;
    __GLSlistString *writePrefix;
#if __GLS_PLATFORM_WIN32
    // DrewB
    GLboolean captureExecOverride;
    GLSfunc captureExec[__GLS_OPCODE_COUNT];
#endif
} __GLScontext;

typedef __GLS_LIST(__GLScontext) __GLScontextList;

extern GLvoid* __glsContext_allocFeedbackBuf(
    __GLScontext *inoutContext, size_t inByteCount
);

extern GLvoid* __glsContext_allocSelectBuf(
    __GLScontext *inoutContext, size_t inByteCount
);

#if __GL_EXT_vertex_array
    extern GLvoid* __glsContext_allocVertexArrayBuf(
        __GLScontext *inoutContext, GLSopcode inOpcode, size_t inByteCount
    );
#endif /* __GL_EXT_vertex_array */

extern __GLScontext* __glsContext_create(GLuint inName);
extern __GLScontext* __glsContext_destroy(__GLScontext *inContext);
extern void __glsContext_updateDispatchDecode_bin(__GLScontext *inoutContext);
extern void __glsContext_updateDispatchTables(__GLScontext *inoutContext);

/******************************************************************************
__GLScontextStream
******************************************************************************/

typedef struct __GLScontextStreamBlock __GLScontextStreamBlock;

struct __GLScontextStream {
    __GLS_LIST_ELEM;
    __GLS_LIST(__GLScontextStreamBlock) blockList;
    GLint callCount;
    __GLSstring name;
    GLboolean deleted;
};

typedef __GLS_LIST_ITER(__GLScontextStreamBlock) __GLScontextStreamBlockIter;

extern __GLScontextStream* __glsContextStream_create(const GLubyte *inName);

extern __GLScontextStream* __glsContextStream_destroy(
    __GLScontextStream *inStream
);

extern __GLScontextStreamBlock* __glsContextStream_appendBlock(
    __GLScontextStream *inoutStream, size_t inBufSize
);

extern void __glsContextStream_call(__GLScontextStream *inoutStream);

extern __GLScontextStreamBlock* __glsContextStream_firstBlock(
    __GLScontextStream *inoutStream
);

extern size_t __glsContextStream_getByteCount(__GLScontextStream *inoutStream);
extern GLuint __glsContextStream_getCRC32(__GLScontextStream *inoutStream);

extern __GLScontextStreamBlock* __glsContextStream_lastBlock(
    __GLScontextStream *inoutStream
);

extern void __glsContextStream_truncate(
    __GLScontextStream *inoutStream,
    __GLScontextStreamBlock *inBlock,
    size_t inOffset
);

#define __GLS_FULL_CONTEXT_STREAM_BLOCK 0.9f

struct __GLScontextStreamBlock {
    __GLS_LIST_ELEM;
    GLubyte *buf;
    GLubyte *bufTail;
    GLubyte *writeTail;
};

extern __GLScontextStreamBlock* __glsContextStreamBlock_create(
    size_t inBufSize
);

extern __GLScontextStreamBlock* __glsContextStreamBlock_destroy(
    __GLScontextStreamBlock *inBlock
);

extern GLboolean __glsContextStreamBlock_addJump(
    __GLScontextStreamBlock *inoutBlock, GLubyte *inDest
);

extern GLboolean __glsContextStreamBlock_addPad(
    __GLScontextStreamBlock *inoutBlock
);

extern GLboolean __glsContextStreamBlock_hasJump(
    __GLScontextStreamBlock *inBlock
);

extern GLboolean __glsContextStreamBlock_removeJump(
    __GLScontextStreamBlock *inoutBlock
);

/******************************************************************************
__GLSlistString
******************************************************************************/

struct __GLSlistString {
    __GLS_LIST_ELEM;
    __GLSstring val;
};

extern GLboolean __glsListString_prefix(
    const __GLSlistString *inString,
    const GLubyte *inName,
    __GLSstring *outPath
);

extern __GLSlistString* __glsListString_create(const GLubyte *inVal);
extern __GLSlistString* __glsListString_destroy(__GLSlistString *inString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\inc\glsutil.h ===
#if !defined(__glsutil_h_)
#define __glsutil_h_

/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <glmf.h>
#include <assert.h>

#if defined(__cplusplus)
    extern "C" {
#endif

/******************************************************************************
Array
******************************************************************************/

#define __GLS_ARRAY(inType) \
    struct { \
        inType *base; \
        size_t count; \
        size_t bufCount; \
    }

typedef __GLS_ARRAY(GLvoid) __GLSarray;

#define __GLS_ARRAY_CHECK(inArray) \
    assert( \
        sizeof((inArray)->base) && \
        sizeof(*(inArray)) == sizeof(__GLSarray) \
    )

#define __GLS_ARRAY_APPEND(inoutArray, inCount, inInit) \
    __GLS_ARRAY_CHECK(inoutArray); \
    __glsArray_insert( \
        (__GLSarray *)inoutArray, \
        inoutArray->count, \
        inCount, \
        inInit, \
        sizeof(*(inoutArray)->base) \
    )

#define __GLS_ARRAY_FINAL(inoutArray) \
    __GLS_ARRAY_CHECK(inoutArray); \
    __glsArray_final((__GLSarray *)inoutArray)

#define __GLS_ARRAY_INIT(outArray) \
    __GLS_ARRAY_CHECK(outArray); \
    __glsArray_init((__GLSarray *)outArray)

#define __GLS_ARRAY_COMPACT(inoutArray) \
    __GLS_ARRAY_CHECK(inoutArray); \
    __glsArray_compact((__GLSarray *)inoutArray, sizeof(*(inoutArray)->base))

#define __GLS_ARRAY_DELETE(inoutArray, inIndex, inCount) \
    __GLS_ARRAY_CHECK(inoutArray); \
    __glsArray_delete( \
        (__GLSarray *)inoutArray, \
        inIndex, \
        inCount, \
        sizeof(*(inoutArray)->base) \
    )

#define __GLS_ARRAY_INSERT(inoutArray, inIndex, inCount, inInit) \
    __GLS_ARRAY_CHECK(inoutArray); \
    __glsArray_insert( \
        (__GLSarray *)inoutArray, \
        inIndex, \
        inCount, \
        inInit, \
        sizeof(*(inoutArray)->base) \
    )

extern void __glsArray_final(__GLSarray *inoutArray);
extern void __glsArray_init(__GLSarray *outArray);
extern void __glsArray_compact(__GLSarray *inoutArray, size_t inElemSize);

extern void __glsArray_delete(
    __GLSarray *inoutArray,
    size_t inIndex,
    size_t inCount,
    size_t inElemSize
);

extern GLboolean __glsArray_insert(
    __GLSarray *inoutArray,
    size_t inIndex,
    size_t inCount,
    GLboolean inInit,
    size_t inElemSize
);

/******************************************************************************
Checksum
******************************************************************************/

#define __GLS_CRC32_STEP(inCRC, inByte) \
    inCRC = (inCRC << 8) ^ __glsCRC32table[(inCRC >> 24) ^ inByte];

extern const GLuint __glsCRC32table[256];

/******************************************************************************
Dict
******************************************************************************/

typedef struct __GLSdict __GLSdict;

extern __GLSdict* __glsIntDict_create(size_t inTableCount);
extern __GLSdict* __glsIntDict_destroy(__GLSdict *inDict);
extern void __glsIntDict_print(__GLSdict *inoutDict, const GLubyte *inName);
extern void __glsIntDict_remove(__GLSdict *inoutDict, GLint inKey);

extern GLboolean __glsInt2IntDict_add(
    __GLSdict *inoutDict, GLint inKey, GLint inVal
);

extern GLboolean __glsInt2IntDict_find(
    const __GLSdict *inDict, GLint inKey, GLint *optoutVal
);

extern GLboolean __glsInt2IntDict_replace(
    __GLSdict *inoutDict, GLint inKey, GLint inVal
);

extern GLboolean __glsInt2PtrDict_add(
    __GLSdict *inoutDict, GLint inKey, GLvoid *inVal
);

extern GLvoid* __glsInt2PtrDict_find(
    const __GLSdict *inDict, GLint inKey
);

extern GLboolean __glsInt2PtrDict_replace(
    __GLSdict *inoutDict, GLint inKey, GLvoid *inVal
);

extern __GLSdict* __glsStrDict_create(
    size_t inTableCount, GLboolean inStaticKeys
);

extern __GLSdict* __glsStrDict_destroy(__GLSdict *inDict);
extern void __glsStrDict_print(__GLSdict *inoutDict, const GLubyte *inName);
extern void __glsStrDict_remove(__GLSdict *inoutDict, const GLubyte *inKey);

extern GLboolean __glsStr2IntDict_add(
    __GLSdict *inoutDict, const GLubyte *inKey, GLint inVal
);

extern GLboolean __glsStr2IntDict_find(
    const __GLSdict *inDict, const GLubyte *inKey, GLint *optoutVal
);

extern GLboolean __glsStr2IntDict_replace(
    __GLSdict *inoutDict, const GLubyte *inKey, GLint inVal
);

extern GLboolean __glsStr2PtrDict_add(
    __GLSdict *inoutDict, const GLubyte *inKey, GLvoid *inVal
);

extern GLvoid* __glsStr2PtrDict_find(
    const __GLSdict *inDict, const GLubyte *inKey
);

extern GLboolean __glsStr2PtrDict_replace(
    __GLSdict *inoutDict, const GLubyte *inKey, GLvoid *inVal
);

/******************************************************************************
List
******************************************************************************/

#define __GLS_LIST(inType) \
    struct { \
        inType *head; \
    }

#define __GLS_LIST_ITER(inType) \
    struct { \
        inType *elem; \
    }

typedef struct __GLSlistElem __GLSlistElem;
typedef void (*__GLSlistElemDestructor)(__GLSlistElem *inElem);
typedef __GLS_LIST(__GLSlistElem) __GLSlist;
typedef __GLS_LIST_ITER(__GLSlistElem) __GLSlistIter;

struct __GLSlistElem {
    __GLSlistElem *next;
    __GLSlistElem *prev;
};

#define __GLS_LIST_ELEM \
    __GLSlistElem __glsListElem

#define __GLS_LIST_CHECK(inList) \
    assert(sizeof((inList)->head) && sizeof(*(inList)) == sizeof(__GLSlist))

#define __GLS_LIST_ELEM_CHECK(inElem) \
    assert(sizeof((inElem)->__glsListElem.next))

#define __GLS_LIST_ITER_CHECK(inIter) \
    assert( \
        sizeof((inIter)->elem) && sizeof(*(inIter)) == sizeof(__GLSlistIter) \
    )

#define __GLS_LIST_APPEND(inoutList, inoutElem) \
    __GLS_LIST_CHECK(inoutList); \
    __GLS_LIST_ELEM_CHECK(inoutElem); \
    __glsListAppend((__GLSlist *)(inoutList), (__GLSlistElem *)(inoutElem))

#define __GLS_LIST_CLEAR_DESTROY(inoutList, inDestructor) \
    __GLS_LIST_CHECK(inoutList); \
    __glsListClearDestroy( \
        (__GLSlist *)(inoutList), (__GLSlistElemDestructor)(inDestructor) \
    )

#define __GLS_LIST_FIRST(inList, inoutIter) \
    __GLS_LIST_CHECK(inList); \
    __GLS_LIST_ITER_CHECK(inoutIter); \
    __glsListFirst((__GLSlist *)(inList), (__GLSlistIter *)(inoutIter))

#define __GLS_LIST_LAST(inList, inoutIter) \
    __GLS_LIST_CHECK(inList); \
    __GLS_LIST_ITER_CHECK(inoutIter); \
    __glsListLast((__GLSlist *)(inList), (__GLSlistIter *)(inoutIter))

#define __GLS_LIST_NEXT(inList, inoutIter) \
    __GLS_LIST_CHECK(inList); \
    __GLS_LIST_ITER_CHECK(inoutIter); \
    __glsListNext((__GLSlist *)(inList), (__GLSlistIter *)(inoutIter))

#define __GLS_LIST_PREPEND(inoutList, inoutElem) \
    __GLS_LIST_CHECK(inoutList); \
    __GLS_LIST_ELEM_CHECK(inoutElem); \
    __glsListPrepend((__GLSlist *)(inoutList), (__GLSlistElem *)(inoutElem))

#define __GLS_LIST_PREV(inList, inoutIter) \
    __GLS_LIST_CHECK(inList); \
    __GLS_LIST_ITER_CHECK(inoutIter); \
    __glsListPrev((__GLSlist *)(inList), (__GLSlistIter *)(inoutIter))

#define __GLS_LIST_REMOVE(inoutList, inoutElem) \
    __GLS_LIST_CHECK(inoutList); \
    __GLS_LIST_ELEM_CHECK(inoutElem); \
    __glsListRemove((__GLSlist *)(inoutList), (__GLSlistElem*)(inoutElem))

#define __GLS_LIST_REMOVE_DESTROY(inoutList, inElem, inDestructor) \
    __GLS_LIST_CHECK(inoutList); \
    __GLS_LIST_ELEM_CHECK(inElem); \
    __glsListRemoveDestroy( \
        (__GLSlist *)(inoutList), \
        (__GLSlistElem *)(inElem), \
        (__GLSlistElemDestructor)(inDestructor) \
    )

extern void __glsListAppend(__GLSlist *inoutList, __GLSlistElem *inoutElem);

extern void __glsListClearDestroy(
    __GLSlist *inoutList, __GLSlistElemDestructor inDestructor
);

extern void __glsListFirst(__GLSlist *inList, __GLSlistIter *inoutIter);
extern void __glsListLast(__GLSlist *inList, __GLSlistIter *inoutIter);
extern void __glsListNext(__GLSlist *inList, __GLSlistIter *inoutIter);
extern void __glsListPrepend(__GLSlist *inoutList, __GLSlistElem *inoutElem);
extern void __glsListPrev(__GLSlist *inList, __GLSlistIter *inoutIter);
extern void __glsListRemove(__GLSlist *inoutList, __GLSlistElem *inoutElem);

extern void __glsListRemoveDestroy(
    __GLSlist *inoutList,
    __GLSlistElem *inElem,
    __GLSlistElemDestructor inDestructor
);

/******************************************************************************
IterList
******************************************************************************/

#define __GLS_ITERLIST(inType) \
    struct { \
        inType *head; \
        size_t count; \
        inType *iterElem; \
        size_t iterIndex; \
    }

typedef __GLS_ITERLIST(__GLSlistElem) __GLSiterList;

#define __GLS_ITERLIST_CHECK(inList) \
    assert( \
        sizeof((inList)->head) && sizeof(*(inList)) == sizeof(__GLSiterList) \
    )

#define __GLS_ITERLIST_APPEND(inoutList, inoutElem) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __GLS_LIST_ELEM_CHECK(inoutElem); \
    __glsIterListAppend( \
        (__GLSiterList *)(inoutList), (__GLSlistElem *)(inoutElem) \
    )

#define __GLS_ITERLIST_CLEAR_DESTROY(inoutList, inDestructor) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __glsIterListClearDestroy( \
        (__GLSiterList *)(inoutList), (__GLSlistElemDestructor)(inDestructor) \
    )

#define __GLS_ITERLIST_FIRST(inoutList) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __glsIterListFirst((__GLSiterList *)(inoutList))

#define __GLS_ITERLIST_LAST(inoutList) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __glsIterListLast((__GLSiterList *)(inoutList))

#define __GLS_ITERLIST_NEXT(inoutList) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __glsIterListNext((__GLSiterList *)(inoutList))

#define __GLS_ITERLIST_PREPEND(inoutList, inoutElem) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __GLS_LIST_ELEM_CHECK(inoutElem); \
    __glsIterListPrepend( \
        (__GLSiterList *)(inoutList), (__GLSlistElem *)(inoutElem) \
    )

#define __GLS_ITERLIST_PREV(inoutList) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __glsIterListPrev((__GLSiterList *)(inoutList))

#define __GLS_ITERLIST_REMOVE(inoutList, inoutElem) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __GLS_LIST_ELEM_CHECK(inoutElem); \
    __glsIterListRemove( \
        (__GLSiterList *)(inoutList), (__GLSlistElem*)(inoutElem) \
    )

#define __GLS_ITERLIST_REMOVE_DESTROY(inoutList, inElem, inDestructor) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __GLS_LIST_ELEM_CHECK(inElem); \
    __glsIterListRemoveDestroy( \
        (__GLSiterList *)(inoutList), \
        (__GLSlistElem *)(inElem), \
        (__GLSlistElemDestructor)(inDestructor) \
    )

#define __GLS_ITERLIST_SEEK(inoutList, inIndex) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __glsIterListSeek((__GLSiterList *)(inoutList), inIndex)

extern void __glsIterListAppend(
    __GLSiterList *inoutList, __GLSlistElem *inoutElem
);

extern void __glsIterListClearDestroy(
    __GLSiterList *inoutList, __GLSlistElemDestructor inDestructor
);

extern void __glsIterListFirst(__GLSiterList *inoutList);
extern void __glsIterListLast(__GLSiterList *inoutList);
extern void __glsIterListNext(__GLSiterList *inoutList);

extern void __glsIterListPrepend(
    __GLSiterList *inoutList, __GLSlistElem *inoutElem
);

extern void __glsIterListPrev(__GLSiterList *inoutList);

extern void __glsIterListRemove(
    __GLSiterList *inoutList, __GLSlistElem *inoutElem
);

extern void __glsIterListRemoveDestroy(
    __GLSiterList *inoutList,
    __GLSlistElem *inElem,
    __GLSlistElemDestructor inDestructor
);

extern void __glsIterListSeek(__GLSiterList *inoutList, size_t inIndex);

/******************************************************************************
Memory
******************************************************************************/

extern GLvoid* __glsCalloc(size_t inCount, size_t inSize);
extern GLvoid* __glsMalloc(size_t inSize);

/******************************************************************************
Nop
******************************************************************************/

#define __GLS_NULL

extern void __glsNop(void);

/******************************************************************************
Number
******************************************************************************/

#define __GLS_MAX(in1, in2) ((in1) > (in2) ? (in1) : (in2))
#define __GLS_MIN(in1, in2) ((in1) < (in2) ? (in1) : (in2))

#define __GLS_SWAP_DECLARE \
    GLubyte __swapSave

#define __GLS_SWAP(inPtr, in1, in2) \
    __swapSave = ((GLubyte*)(inPtr))[in1]; \
    ((GLubyte *)(inPtr))[in1] = ((GLubyte *)(inPtr))[in2]; \
    ((GLubyte *)(inPtr))[in2] = __swapSave;

#define __GLS_SWAP1(inPtr)

#define __GLS_SWAP2(inPtr) \
    __GLS_SWAP(inPtr, 0, 1);

#define __GLS_SWAP4(inPtr) \
    __GLS_SWAP(inPtr, 0, 3); \
    __GLS_SWAP(inPtr, 1, 2);

#define __GLS_SWAP8(inPtr) \
    __GLS_SWAP(inPtr, 0, 7); \
    __GLS_SWAP(inPtr, 1, 6); \
    __GLS_SWAP(inPtr, 2, 5); \
    __GLS_SWAP(inPtr, 3, 4);

extern const GLubyte __glsBitReverse[256];
extern const GLubyte __glsQuietNaN[8];

extern size_t __glsCeilBase2(size_t inVal);
extern size_t __glsLogBase2(size_t inVal);
GLulong __glsPtrToULong(const GLvoid *inPtr);
GLlong __glsSizeToLong(size_t inSize);
#define __glsSwap1(inoutVec)
extern void __glsSwap2(GLvoid *inoutVec);
extern void __glsSwap2v(size_t inCount, GLvoid *inoutVec);
extern void __glsSwap4(GLvoid *inoutVec);
extern void __glsSwap4v(size_t inCount, GLvoid *inoutVec);
extern void __glsSwap8(GLvoid *inoutVec);
extern void __glsSwap8v(size_t inCount, GLvoid *inoutVec);
extern GLint __glsSwapi(GLint inVal);
extern GLshort __glsSwaps(GLshort inVal);
extern void __glsSwapv(GLenum inType, size_t inBytes, GLvoid *inoutVec);

/******************************************************************************
String
******************************************************************************/

#define __GLS_STRING_BUF_BYTES 32

typedef GLubyte __GLSstringBuf[__GLS_STRING_BUF_BYTES];

typedef struct {
    GLubyte *head;
    GLubyte *tail;
    GLubyte *bufTail;
    __GLSstringBuf buf;
} __GLSstring;

extern GLboolean __glsString_append(
    __GLSstring *inoutString, const GLubyte* inAppend
);

extern GLboolean __glsString_appendChar(
    __GLSstring *inoutString, GLubyte inAppend
);

extern GLboolean __glsString_appendCounted(
    __GLSstring *inoutString, const GLubyte* inAppend, size_t inCount
);

extern GLboolean __glsString_appendInt(
    __GLSstring *inoutString, const GLubyte *inFormat, GLint inVal
);

extern GLboolean __glsString_assign(
    __GLSstring *inoutString, const GLubyte *inAssign
);

extern GLboolean __glsString_assignCounted(
    __GLSstring *inoutString, const GLubyte *inAssign, size_t inCount
);

extern void __glsString_final(__GLSstring *inoutString);
extern void __glsString_init(__GLSstring *outString);
extern size_t __glsString_length(const __GLSstring *inString);
extern void __glsString_reset(__GLSstring *inoutString);

extern const GLubyte* __glsUCS1String(const GLubyte *inUTF8String);
extern GLboolean __glsValidateString(const GLubyte *inString);

/******************************************************************************
Vertex array
******************************************************************************/

#define __GLS_PAD_EIGHT(v) (((v) + 7) & ~7)

#define __GLS_EXACT_ARRAY_SIZE(count, size, type) \
    ((count) * (size) * __glsTypeSize(type))
#define __GLS_ARRAY_SIZE(count, size, type) \
    __GLS_PAD_EIGHT(__GLS_EXACT_ARRAY_SIZE(count, size, type))

typedef struct
{
    GLint size;
    GLenum type;
    GLsizei stride;
    const GLvoid *data;
} __GLSsingleArrayState;

#define __GLS_VERTEX_ARRAY_ENABLE               0x00000001
#define __GLS_NORMAL_ARRAY_ENABLE               0x00000002
#define __GLS_COLOR_ARRAY_ENABLE                0x00000004
#define __GLS_INDEX_ARRAY_ENABLE                0x00000008
#define __GLS_TEXTURE_COORD_ARRAY_ENABLE        0x00000010
#define __GLS_EDGE_FLAG_ARRAY_ENABLE            0x00000020

#define __GLS_ARRAY_COUNT                       6

typedef struct
{
    GLuint enabled;
    __GLSsingleArrayState vertex;
    __GLSsingleArrayState normal;
    __GLSsingleArrayState color;
    __GLSsingleArrayState index;
    __GLSsingleArrayState textureCoord;
    __GLSsingleArrayState edgeFlag;
} __GLSarrayState;

extern void __glsGetArrayState(struct __GLScontext *ctx,
                               __GLSarrayState *arrayState);
extern GLint __glsArrayDataSize(GLsizei count, __GLSarrayState *arrayState);
extern void __glsWriteArrayData(struct __GLSwriter *writer, GLint size,
                                GLint first, GLsizei count,
                                GLenum type, const GLvoid *indices,
                                __GLSarrayState *arrayState);
extern void __glsSetArrayState(struct __GLScontext *ctx, GLubyte *data);
extern GLvoid *__glsSetArrayStateText(struct __GLScontext *ctx,
                                      struct __GLSreader *reader,
                                      GLuint *enabled, GLsizei *count);
extern void __glsDisableArrayState(struct __GLScontext *ctx, GLuint enabled);
extern void __glsSwapArrayData(GLubyte *data);

typedef struct
{
    void *freePtr;
    GLuint *indices;
    GLuint *vertices;
    GLint vtxCount;
} __GLSdrawElementsState;

extern GLint __glsDrawElementsDataSize(GLsizei count, GLenum type,
                                       const GLvoid *indices,
                                       __GLSarrayState *arrayState,
                                       __GLSdrawElementsState *deState);
extern void __glsWriteDrawElementsData(struct __GLSwriter *writer, GLint size,
                                       GLsizei count,
                                       __GLSarrayState *arrayState,
                                       __GLSdrawElementsState *deState);

#if defined(__cplusplus)
    }
#endif

#endif /* __glsutil_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\inc\glssize.h ===
#ifndef __GLSSIZE_H__
#define __GLSSIZE_H__

GLint __glsTypeSize(GLenum type);
GLint __glsEvalComputeK(GLenum inTarget);
GLint __gls_glBitmap_bitmap_size(GLint inWidth, GLint inHeight);
GLint __gls_glCallLists_lists_size(GLint inCount, GLenum inType);
GLint __gls_glDrawPixels_pixels_size(
        GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight);
GLint __gls_glFogfv_params_size(GLenum inPname);
GLint __gls_glFogiv_params_size(GLenum inPname);
GLint __gls_glGetBooleanv_params_size(GLenum inPname);
GLint __gls_glGetDoublev_params_size(GLenum inPname);
GLint __gls_glGetFloatv_params_size(GLenum inPname);
GLint __gls_glGetIntegerv_params_size(GLenum inPname);
GLint __gls_glGetLightfv_params_size(GLenum inPname);
GLint __gls_glGetLightiv_params_size(GLenum inPname);
GLint __gls_glGetMapdv_v_size(__GLScontext *ctx, GLenum inTarget, GLenum inQuery);
GLint __gls_glGetMapfv_v_size(__GLScontext *ctx, GLenum inTarget, GLenum inQuery);
GLint __gls_glGetMapiv_v_size(__GLScontext *ctx, GLenum inTarget, GLenum inQuery);
GLint __gls_glGetMaterialfv_params_size(GLenum inPname);
GLint __gls_glGetMaterialiv_params_size(GLenum inPname);
GLint __gls_glGetPixelMapfv_values_size(__GLScontext *ctx, GLenum inMap);
GLint __gls_glGetPixelMapuiv_values_size(__GLScontext *ctx, GLenum inMap);
GLint __gls_glGetPixelMapusv_values_size(__GLScontext *ctx, GLenum inMap);
GLint __gls_glGetPolygonStipple_mask_size(void);
GLint __gls_glGetTexEnvfv_params_size(GLenum inPname);
GLint __gls_glGetTexEnviv_params_size(GLenum inPname);
GLint __gls_glGetTexGendv_params_size(GLenum inPname);
GLint __gls_glGetTexGenfv_params_size(GLenum inPname);
GLint __gls_glGetTexGeniv_params_size(GLenum inPname);
GLint __gls_glGetTexImage_pixels_size(
        __GLScontext *ctx,
        GLenum inTarget, GLint inLevel, GLenum inFormat, GLenum inType);
GLint __gls_glGetTexLevelParameterfv_params_size(GLenum inPname);
GLint __gls_glGetTexLevelParameteriv_params_size(GLenum inPname);
GLint __gls_glGetTexParameterfv_params_size(GLenum inPname);
GLint __gls_glGetTexParameteriv_params_size(GLenum inPname);
GLint __gls_glLightfv_params_size(GLenum inPname);
GLint __gls_glLightiv_params_size(GLenum inPname);
GLint __gls_glLightModelfv_params_size(GLenum inPname);
GLint __gls_glLightModeliv_params_size(GLenum inPname);
GLint __gls_glMap1d_points_size(
        GLenum inTarget, GLint inStride, GLint inOrder);
GLint __gls_glMap1f_points_size(
        GLenum inTarget, GLint inStride, GLint inOrder);
GLint __gls_glMap2d_points_size(
        GLenum inTarget, GLint inUstride, GLint inUorder, GLint inVstride,
        GLint inVorder);
GLint __gls_glMap2f_points_size(
        GLenum inTarget, GLint inUstride, GLint inUorder, GLint inVstride,
        GLint inVorder);
GLint __gls_glMaterialfv_params_size(GLenum inPname);
GLint __gls_glMaterialiv_params_size(GLenum inPname);
GLint __gls_glPolygonStipple_mask_size(void);
GLint __gls_glReadPixels_pixels_size(
        GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight);
GLint __gls_glTexEnvfv_params_size(GLenum inPname);
GLint __gls_glTexEnviv_params_size(GLenum inPname);
GLint __gls_glTexGendv_params_size(GLenum inPname);
GLint __gls_glTexGenfv_params_size(GLenum inPname);
GLint __gls_glTexGeniv_params_size(GLenum inPname);
GLint __gls_glTexImage1D_pixels_size(
        GLenum inFormat, GLenum inType, GLint inWidth);
GLint __gls_glColorSubTableEXT_entries_size(
        GLenum inFormat, GLenum inType, GLint inCount);
GLint __gls_glTexImage2D_pixels_size(
        GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight);
GLint __gls_glTexParameterfv_params_size(GLenum inPname);
GLint __gls_glTexParameteriv_params_size(GLenum inPname);
GLint __gls_glsHeaderfv_inVec_size(GLenum inAttrib);
GLint __gls_glsHeaderiv_inVec_size(GLenum inAttrib);
GLint __gls_glConvolutionFilter1DEXT_image_size(
        GLenum inFormat, GLenum inType, GLint inWidth);
GLint __gls_glConvolutionFilter2DEXT_image_size(
        GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight);
GLint __gls_glConvolutionParameterfvEXT_params_size(GLenum inPname);
GLint __gls_glConvolutionParameterivEXT_params_size(GLenum inPname);
GLint __gls_glGetConvolutionFilterEXT_image_size(
        __GLScontext *ctx,
        GLenum inTarget, GLenum inFormat, GLenum inType);
GLint __gls_glGetConvolutionParameterfvEXT_params_size(GLenum inPname);
GLint __gls_glGetConvolutionParameterivEXT_params_size(GLenum inPname);
GLint __gls_glGetSeparableFilterEXT_row_size(
        __GLScontext *ctx,
        GLenum inTarget, GLenum inFormat, GLenum inType);
GLint __gls_glGetSeparableFilterEXT_column_size(
        __GLScontext *ctx,
        GLenum inTarget, GLenum inFormat, GLenum inType);
GLint __gls_glGetSeparableFilterEXT_span_size(
        GLenum inTarget, GLenum inFormat, GLenum inType);
GLint __gls_glSeparableFilter2DEXT_row_size(
        GLenum inTarget, GLenum inFormat, GLenum inType, GLint inWidth);
GLint __gls_glSeparableFilter2DEXT_column_size(
        GLenum inTarget, GLenum inFormat, GLenum inType, GLint inHeight);
GLint __gls_glGetHistogramEXT_values_size(
        __GLScontext *ctx,
        GLenum inTarget, GLenum inFormat, GLenum inType);
GLint __gls_glGetHistogramParameterfvEXT_params_size(GLenum inPname);
GLint __gls_glGetHistogramParameterivEXT_params_size(GLenum inPname);
GLint __gls_glGetMinmaxEXT_values_siz;
GLint __gls_glGetMinmaxParameterfvEXT_params_size(GLenum inPname);
GLint __gls_glGetMinmaxParameterivEXT_params_size(GLenum inPname);
GLint __gls_glTexSubImage1DEXT_pixels_size(
        GLenum inFormat, GLenum inType, GLint inWidth);
GLint __gls_glTexSubImage1D_pixels_size(
        GLenum inFormat, GLenum inType, GLint inWidth);
GLint __gls_glTexSubImage2DEXT_pixels_size(
        GLenum inFormat,
        GLenum inType,
        GLint inWidth,
        GLint inHeight);
GLint __gls_glTexSubImage2D_pixels_size(
        GLenum inFormat,
        GLenum inType,
        GLint inWidth,
        GLint inHeight);
GLint __gls_glTexSubImage3DEXT_pixels_size(
        GLenum inFormat,
        GLenum inType,
        GLint inWidth,
        GLint inHeight,
        GLint inDepth);
GLint __gls_glTexImage3DEXT_pixels_size(
        GLenum inFormat,
        GLenum inType,
        GLint inWidth,
        GLint inHeight,
        GLint inDepth);
GLint __gls_glColorPointerEXT_pointer_size(
        GLint inSize, GLenum inType, GLint inStride, GLint inCount);
GLint __gls_glEdgeFlagPointerEXT_pointer_size(
        GLint inStride, GLint inCount);
GLint __gls_glIndexPointerEXT_pointer_size(
        GLenum inType, GLint inStride, GLint inCount);
GLint __gls_glNormalPointerEXT_pointer_size(
        GLenum inType, GLint inStride, GLint inCount);
GLint __gls_glTexCoordPointerEXT_pointer_size(
        GLint inSize, GLenum inType, GLint inStride, GLint inCount);
GLint __gls_glVertexPointerEXT_pointer_size(
        GLint inSize, GLenum inType, GLint inStride, GLint inCount);
GLint __gls_glColorTableEXT_table_size(
        GLenum inFormat, GLenum inType, GLint inWidth);
GLint __gls_glColorTableParameterfvSGI_params_size(GLenum inPname);
GLint __gls_glColorTableParameterivSGI_params_size(GLenum inPname);
GLint __gls_glGetColorTableEXT_table_size(
        __GLScontext *ctx,
        GLenum inTarget, GLenum inFormat, GLenum inType);
GLint __gls_glGetColorTableParameterfvEXT_params_size(GLenum inPname);
GLint __gls_glGetColorTableParameterivEXT_params_size(GLenum inPname);
GLint __gls_glTexColorTableParameterfvSGI_params_size(GLenum inPname);
GLint __gls_glTexColorTableParameterivSGI_params_size(GLenum inPname);
GLint __gls_glGetTexColorTableParameterfvSGI_params_size(GLenum inPname);
GLint __gls_glGetTexColorTableParameterivSGI_params_size(GLenum inPname);
GLint __gls_glGetDetailTexFuncSGIS_points_size(__GLScontext *ctx, GLenum inTarget);
GLint __gls_glGetSharpenTexFuncSGIS_points_size(__GLScontext *ctx, GLenum inTarget);
GLint __gls_glTexImage4DSGIS_pixels_size(
        GLenum inFormat,
        GLenum inType,
        GLint inWidth,
        GLint inHeight,
        GLint inDepth,
        GLint inSize4d);
GLint __gls_glTexSubImage4DSGIS_pixels_size(
        GLenum inFormat,
        GLenum inType,
        GLint inWidth,
        GLint inHeight,
        GLint inDepth,
        GLint inSize4d);

#endif // __GLSSIZE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\inc\gls_ll.h ===
#if !defined(__gls_h_)
#define __gls_h_

/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#define GLS_LINKAGE

#include <GL/gl.h>
#include <stddef.h>
#include <stdio.h>

#if defined(__cplusplus)
    extern "C" {
#endif /* defined(__cplusplus) */

typedef long long GLlong;
typedef unsigned long long GLulong;

typedef GLuint GLSenum;
typedef GLuint GLSopcode;

typedef struct {
    GLuint mask;
    GLuint value;
} GLScommandAlignment;

typedef void (*GLScaptureFunc)(GLSopcode inOpcode);
typedef size_t (*GLSreadFunc)(size_t inCount, GLubyte *outBuf);
typedef size_t (*GLSwriteFunc)(size_t inCount, const GLubyte *inBuf);

#if defined(__cplusplus)
    typedef void (*GLSfunc)(...);
#else /* !defined(__cplusplus) */
    typedef void (*GLSfunc)();
#endif /* defined(__cplusplus) */

#define glsCSTR(p) ((const GLubyte*)(p))
#define glsSTR(p)  ((GLubyte*)(p))

/*************************************************************/

/* CaptureFlags */
/*      GLS_NONE */
#define GLS_CAPTURE_EXECUTE_BIT                   0x00000001
#define GLS_CAPTURE_WRITE_BIT                     0x00000002

/* CommandAttrib */
/*      GLS_NONE */
#define GLS_COMMAND_GEN_BIT                       0x00000001
#define GLS_COMMAND_GET_BIT                       0x00000002
#define GLS_COMMAND_REPLY_BIT                     0x00000004

/* ImageFlags */
/*      GLS_NONE */
#define GLS_IMAGE_NULL_BIT                        0x00000001

/* StreamAttrib */
/*      GLS_NONE */
#define GLS_STREAM_CONTEXT_BIT                    0x00000001
#define GLS_STREAM_NAMED_BIT                      0x00000002
#define GLS_STREAM_READABLE_BIT                   0x00000004
#define GLS_STREAM_SEEKABLE_BIT                   0x00000008
#define GLS_STREAM_WRITABLE_BIT                   0x00000010

/* WriteFlags */
/*      GLS_NONE */
#define GLS_WRITE_APPEND_BIT                      0x00000001

/* Fundamental */
#define GLS_NONE                                  0x0000

/* AbortMode */
/*      GLS_NONE */
#define GLS_ALL                                   0x0010
#define GLS_LAST                                  0x0011

/* API */
#define GLS_API_GLS                               0x0020
#define GLS_API_GL                                0x0021

/* BlockType */
#define GLS_FRAME                                 0x0030
#define GLS_HEADER                                0x0031
#define GLS_INIT                                  0x0032
#define GLS_STATIC                                0x0033

/* CaptureFuncTarget */
#define GLS_CAPTURE_ENTRY_FUNC                    0x0040
#define GLS_CAPTURE_EXIT_FUNC                     0x0041

/* CaptureStreamType */
#define GLS_CONTEXT                               0x0050
#define GLS_BINARY_LSB_FIRST                      0x0051
#define GLS_BINARY_MSB_FIRST                      0x0052
#define GLS_TEXT                                  0x0053

/* ChannelTarget */
#define GLS_DEFAULT_READ_CHANNEL                  0x0060
#define GLS_DEFAULT_WRITE_CHANNEL                 0x0061

/* Consti */
#define GLS_API_COUNT                             0x0070
#define GLS_MAX_CALL_NESTING                      0x0071
#define GLS_MAX_CAPTURE_NESTING                   0x0072
#define GLS_VERSION_MAJOR                         0x0073
#define GLS_VERSION_MINOR                         0x0074

/* Constiv */
#define GLS_ALL_APIS                              0x0080

/* Constubz */
#define GLS_EXTENSIONS                            0x0090
#define GLS_PLATFORM                              0x0091
#define GLS_RELEASE                               0x0092
#define GLS_VENDOR                                0x0093

/* ContextFunc */
/*      GLS_CAPTURE_ENTRY_FUNC */
/*      GLS_CAPTURE_EXIT_FUNC */
#define GLS_READ_FUNC                             0x00A1
#define GLS_UNREAD_FUNC                           0x00A2
#define GLS_WRITE_FUNC                            0x00A3

/* ContextListl */
#define GLS_OUT_ARG_LIST                          0x00B0

/* ContextListubz */
#define GLS_CONTEXT_STREAM_LIST                   0x00C0
#define GLS_READ_PREFIX_LIST                      0x00C1

/* ContextPointer */
/*      GLS_DEFAULT_READ_CHANNEL */
/*      GLS_DEFAULT_WRITE_CHANNEL */
#define GLS_DATA_POINTER                          0x00E0

/* Contexti */
#define GLS_ABORT_MODE                            0x00E0
#define GLS_BLOCK_TYPE                            0x00E1
#define GLS_CALL_NESTING                          0x00E2
#define GLS_CAPTURE_NESTING                       0x00E3
#define GLS_CONTEXT_STREAM_COUNT                  0x00E4
#define GLS_CURRENT_GLRC                          0x00E5
#define GLS_OUT_ARG_COUNT                         0x00E6
#define GLS_PIXEL_SETUP_GEN                       0x00E7
#define GLS_READ_PREFIX_COUNT                     0x00E8
#define GLS_STREAM_VERSION_MAJOR                  0x00E9
#define GLS_STREAM_VERSION_MINOR                  0x00EA

/* Contextubz */
#define GLS_WRITE_PREFIX                          0x0100

/* CopyStreamType */
/*      GLS_NONE */
/*      GLS_CONTEXT */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */

/* DisplayFormat */
#define GLS_IIII                                  0x0110
#define GLS_RGBA                                  0x0111
#define GLS_RRRA                                  0x0112

/* DisplayMap */
#define GLS_DISPLAY_MAP_I_TO_R                    0x0120
#define GLS_DISPLAY_MAP_I_TO_G                    0x0121
#define GLS_DISPLAY_MAP_I_TO_B                    0x0122
#define GLS_DISPLAY_MAP_I_TO_A                    0x0123

/* ErrorCode */
/*      GLS_NONE */
#define GLS_CALL_OVERFLOW                         0x0130
#define GLS_DECODE_ERROR                          0x0131
#define GLS_ENCODE_ERROR                          0x0132
#define GLS_INVALID_ENUM                          0x0133
#define GLS_INVALID_OPERATION                     0x0134
#define GLS_INVALID_STREAM                        0x0135
#define GLS_INVALID_STRING                        0x0136
#define GLS_INVALID_VALUE                         0x0137
#define GLS_NOT_FOUND                             0x0138
#define GLS_OUT_OF_MEMORY                         0x0139
#define GLS_STREAM_CLOSE_ERROR                    0x013A
#define GLS_STREAM_DELETE_ERROR                   0x013B
#define GLS_STREAM_OPEN_ERROR                     0x013C
#define GLS_STREAM_READ_ERROR                     0x013D
#define GLS_STREAM_WRITE_ERROR                    0x013E
#define GLS_UNSUPPORTED_COMMAND                   0x013F
#define GLS_UNSUPPORTED_EXTENSION                 0x0140

/* ExternStreamType */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */

/* FlushType */
/*      GLS_ALL */
/*      GLS_LAST */

/* GetStreamType */
/*      GLS_NONE */
/*      GLS_CONTEXT */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */
#define GLS_UNKNOWN                               0x0150

/* GLRCi */
#define GLS_LAYER                                 0x0160
#define GLS_READ_LAYER                            0x0161
#define GLS_SHARE_GLRC                            0x0162

/* Headerf */
#define GLS_ASPECT                                0x0170
#define GLS_BORDER_WIDTH                          0x0171
#define GLS_CONTRAST_RATIO                        0x0172
#define GLS_HEIGHT_MM                             0x0173

/* Headerfv */
#define GLS_BORDER_COLOR                          0x0180
#define GLS_GAMMA                                 0x0181
#define GLS_ORIGIN                                0x0182
#define GLS_PAGE_COLOR                            0x0183
#define GLS_PAGE_SIZE                             0x0184
#define GLS_RED_POINT                             0x0185
#define GLS_GREEN_POINT                           0x0186
#define GLS_BLUE_POINT                            0x0187
#define GLS_WHITE_POINT                           0x0188

/* Headeri */
#define GLS_FRAME_COUNT                           0x01A0
#define GLS_GLRC_COUNT                            0x01A1
#define GLS_HEIGHT_PIXELS                         0x01A2
#define GLS_LAYER_COUNT                           0x01A3
#define GLS_TILEABLE                              0x01A4

/* Headeriv */
#define GLS_CREATE_TIME                           0x01B0
#define GLS_MODIFY_TIME                           0x01B1

/* Headerubz */
/*      GLS_EXTENSIONS */
#define GLS_AUTHOR                                0x01C0
#define GLS_DESCRIPTION                           0x01C1
#define GLS_NOTES                                 0x01C2
#define GLS_TITLE                                 0x01C3
#define GLS_TOOLS                                 0x01C4
#define GLS_VERSION                               0x01C5

/* Layerf */
#define GLS_INVISIBLE_ASPECT                      0x01D0

/* Layeri */
#define GLS_DISPLAY_FORMAT                        0x01E0
#define GLS_DOUBLEBUFFER                          0x01E1
#define GLS_INVISIBLE                             0x01E2
#define GLS_INVISIBLE_HEIGHT_PIXELS               0x01E3
#define GLS_LEVEL                                 0x01E4
#define GLS_STEREO                                0x01E5
#define GLS_TRANSPARENT                           0x01E6
#define GLS_INDEX_BITS                            0x01E7
#define GLS_RED_BITS                              0x01E8
#define GLS_GREEN_BITS                            0x01E9
#define GLS_BLUE_BITS                             0x01EA
#define GLS_ALPHA_BITS                            0x01EB
#define GLS_DEPTH_BITS                            0x01EC
#define GLS_STENCIL_BITS                          0x01ED
#define GLS_ACCUM_RED_BITS                        0x01EE
#define GLS_ACCUM_GREEN_BITS                      0x01EF
#define GLS_ACCUM_BLUE_BITS                       0x01F0
#define GLS_ACCUM_ALPHA_BITS                      0x01F1
#define GLS_AUX_BUFFERS                           0x01F2
/*      GLS_SAMPLE_BUFFERS_SGIS */
/*      GLS_SAMPLES_SGIS */

/* ListOp */
#define GLS_APPEND                                0x0200
#define GLS_PREPEND                               0x0201

/* GL_SGIS_multisample */
#define GLS_SAMPLE_BUFFERS_SGIS                   0x0400
#define GLS_SAMPLES_SGIS                          0x0401

/* GLS opcodes */
#define GLS_OP_glsBeginGLS                        16
#define GLS_OP_glsBlock                           17
#define GLS_OP_glsCallStream                      18
#define GLS_OP_glsEndGLS                          19
#define GLS_OP_glsError                           20
#define GLS_OP_glsGLRC                            21
#define GLS_OP_glsGLRCLayer                       22
#define GLS_OP_glsHeaderGLRCi                     23
#define GLS_OP_glsHeaderLayerf                    24
#define GLS_OP_glsHeaderLayeri                    25
#define GLS_OP_glsHeaderf                         26
#define GLS_OP_glsHeaderfv                        27
#define GLS_OP_glsHeaderi                         28
#define GLS_OP_glsHeaderiv                        29
#define GLS_OP_glsHeaderubz                       30
#define GLS_OP_glsRequireExtension                31
#define GLS_OP_glsUnsupportedCommand              32
#define GLS_OP_glsAppRef                          33
#define GLS_OP_glsBeginObj                        34
#define GLS_OP_glsCharubz                         35
#define GLS_OP_glsComment                         36
#define GLS_OP_glsDisplayMapfv                    37
#define GLS_OP_glsEndObj                          38
#define GLS_OP_glsNumb                            39
#define GLS_OP_glsNumbv                           40
#define GLS_OP_glsNumd                            41
#define GLS_OP_glsNumdv                           42
#define GLS_OP_glsNumf                            43
#define GLS_OP_glsNumfv                           44
#define GLS_OP_glsNumi                            45
#define GLS_OP_glsNumiv                           46
#define GLS_OP_glsNuml                            47
#define GLS_OP_glsNumlv                           48
#define GLS_OP_glsNums                            49
#define GLS_OP_glsNumsv                           50
#define GLS_OP_glsNumub                           51
#define GLS_OP_glsNumubv                          52
#define GLS_OP_glsNumui                           53
#define GLS_OP_glsNumuiv                          54
#define GLS_OP_glsNumul                           55
#define GLS_OP_glsNumulv                          56
#define GLS_OP_glsNumus                           57
#define GLS_OP_glsNumusv                          58
#define GLS_OP_glsPad                             59
#define GLS_OP_glsSwapBuffers                     60

/* GL opcodes */
#define GLS_OP_glAccum                            277
#define GLS_OP_glAlphaFunc                        304
#define GLS_OP_glAreTexturesResidentEXT           65502
#define GLS_OP_glArrayElementEXT                  65493
#define GLS_OP_glBegin                            71
#define GLS_OP_glBindTextureEXT                   65503
#define GLS_OP_glBitmap                           72
#define GLS_OP_glBlendColorEXT                    65520
#define GLS_OP_glBlendEquationEXT                 65521
#define GLS_OP_glBlendFunc                        305
#define GLS_OP_glCallList                         66
#define GLS_OP_glCallLists                        67
#define GLS_OP_glClear                            267
#define GLS_OP_glClearAccum                       268
#define GLS_OP_glClearColor                       270
#define GLS_OP_glClearDepth                       272
#define GLS_OP_glClearIndex                       269
#define GLS_OP_glClearStencil                     271
#define GLS_OP_glClipPlane                        214
#define GLS_OP_glColor3b                          73
#define GLS_OP_glColor3bv                         74
#define GLS_OP_glColor3d                          75
#define GLS_OP_glColor3dv                         76
#define GLS_OP_glColor3f                          77
#define GLS_OP_glColor3fv                         78
#define GLS_OP_glColor3i                          79
#define GLS_OP_glColor3iv                         80
#define GLS_OP_glColor3s                          81
#define GLS_OP_glColor3sv                         82
#define GLS_OP_glColor3ub                         83
#define GLS_OP_glColor3ubv                        84
#define GLS_OP_glColor3ui                         85
#define GLS_OP_glColor3uiv                        86
#define GLS_OP_glColor3us                         87
#define GLS_OP_glColor3usv                        88
#define GLS_OP_glColor4b                          89
#define GLS_OP_glColor4bv                         90
#define GLS_OP_glColor4d                          91
#define GLS_OP_glColor4dv                         92
#define GLS_OP_glColor4f                          93
#define GLS_OP_glColor4fv                         94
#define GLS_OP_glColor4i                          95
#define GLS_OP_glColor4iv                         96
#define GLS_OP_glColor4s                          97
#define GLS_OP_glColor4sv                         98
#define GLS_OP_glColor4ub                         99
#define GLS_OP_glColor4ubv                        100
#define GLS_OP_glColor4ui                         101
#define GLS_OP_glColor4uiv                        102
#define GLS_OP_glColor4us                         103
#define GLS_OP_glColor4usv                        104
#define GLS_OP_glColorMask                        274
#define GLS_OP_glColorMaterial                    215
#define GLS_OP_glColorPointerEXT                  65494
#define GLS_OP_glColorTableParameterfvSGI         65477
#define GLS_OP_glColorTableParameterivSGI         65478
#define GLS_OP_glColorTableSGI                    65476
#define GLS_OP_glConvolutionFilter1DEXT           65528
#define GLS_OP_glConvolutionFilter2DEXT           65529
#define GLS_OP_glConvolutionParameterfEXT         65530
#define GLS_OP_glConvolutionParameterfvEXT        65531
#define GLS_OP_glConvolutionParameteriEXT         65532
#define GLS_OP_glConvolutionParameterivEXT        65533
#define GLS_OP_glCopyColorTableSGI                65479
#define GLS_OP_glCopyConvolutionFilter1DEXT       65534
#define GLS_OP_glCopyConvolutionFilter2DEXT       65535
#define GLS_OP_glCopyPixels                       319
#define GLS_OP_glCopyTexImage1DEXT                65487
#define GLS_OP_glCopyTexImage2DEXT                65456
#define GLS_OP_glCopyTexSubImage1DEXT             65457
#define GLS_OP_glCopyTexSubImage2DEXT             65458
#define GLS_OP_glCopyTexSubImage3DEXT             65459
#define GLS_OP_glCullFace                         216
#define GLS_OP_glDeleteLists                      68
#define GLS_OP_glDeleteTexturesEXT                65472
#define GLS_OP_glDepthFunc                        309
#define GLS_OP_glDepthMask                        275
#define GLS_OP_glDepthRange                       352
#define GLS_OP_glDetailTexFuncSGIS                65489
#define GLS_OP_glDisable                          278
#define GLS_OP_glDrawArraysEXT                    65495
#define GLS_OP_glDrawBuffer                       266
#define GLS_OP_glDrawPixels                       321
#define GLS_OP_glEdgeFlag                         105
#define GLS_OP_glEdgeFlagPointerEXT               65496
#define GLS_OP_glEdgeFlagv                        106
#define GLS_OP_glEnable                           279
#define GLS_OP_glEnd                              107
#define GLS_OP_glEndList                          65
#define GLS_OP_glEvalCoord1d                      292
#define GLS_OP_glEvalCoord1dv                     293
#define GLS_OP_glEvalCoord1f                      294
#define GLS_OP_glEvalCoord1fv                     295
#define GLS_OP_glEvalCoord2d                      296
#define GLS_OP_glEvalCoord2dv                     297
#define GLS_OP_glEvalCoord2f                      298
#define GLS_OP_glEvalCoord2fv                     299
#define GLS_OP_glEvalMesh1                        300
#define GLS_OP_glEvalMesh2                        302
#define GLS_OP_glEvalPoint1                       301
#define GLS_OP_glEvalPoint2                       303
#define GLS_OP_glFeedbackBuffer                   258
#define GLS_OP_glFinish                           280
#define GLS_OP_glFlush                            281
#define GLS_OP_glFogf                             217
#define GLS_OP_glFogfv                            218
#define GLS_OP_glFogi                             219
#define GLS_OP_glFogiv                            220
#define GLS_OP_glFrontFace                        221
#define GLS_OP_glFrustum                          353
#define GLS_OP_glGenLists                         69
#define GLS_OP_glGenTexturesEXT                   65473
#define GLS_OP_glGetBooleanv                      322
#define GLS_OP_glGetClipPlane                     323
#define GLS_OP_glGetColorTableParameterfvSGI      65481
#define GLS_OP_glGetColorTableParameterivSGI      65482
#define GLS_OP_glGetColorTableSGI                 65480
#define GLS_OP_glGetConvolutionFilterEXT          65504
#define GLS_OP_glGetConvolutionParameterfvEXT     65505
#define GLS_OP_glGetConvolutionParameterivEXT     65506
#define GLS_OP_glGetDetailTexFuncSGIS             65490
#define GLS_OP_glGetDoublev                       324
#define GLS_OP_glGetError                         325
#define GLS_OP_glGetFloatv                        326
#define GLS_OP_glGetHistogramEXT                  65509
#define GLS_OP_glGetHistogramParameterfvEXT       65510
#define GLS_OP_glGetHistogramParameterivEXT       65511
#define GLS_OP_glGetIntegerv                      327
#define GLS_OP_glGetLightfv                       328
#define GLS_OP_glGetLightiv                       329
#define GLS_OP_glGetMapdv                         330
#define GLS_OP_glGetMapfv                         331
#define GLS_OP_glGetMapiv                         332
#define GLS_OP_glGetMaterialfv                    333
#define GLS_OP_glGetMaterialiv                    334
#define GLS_OP_glGetMinmaxEXT                     65512
#define GLS_OP_glGetMinmaxParameterfvEXT          65513
#define GLS_OP_glGetMinmaxParameterivEXT          65514
#define GLS_OP_glGetPixelMapfv                    335
#define GLS_OP_glGetPixelMapuiv                   336
#define GLS_OP_glGetPixelMapusv                   337
#define GLS_OP_glGetPointervEXT                   65497
#define GLS_OP_glGetPolygonStipple                338
#define GLS_OP_glGetSeparableFilterEXT            65507
#define GLS_OP_glGetSharpenTexFuncSGIS            65492
#define GLS_OP_glGetString                        339
#define GLS_OP_glGetTexColorTableParameterfvSGI   65483
#define GLS_OP_glGetTexColorTableParameterivSGI   65484
#define GLS_OP_glGetTexEnvfv                      340
#define GLS_OP_glGetTexEnviv                      341
#define GLS_OP_glGetTexGendv                      342
#define GLS_OP_glGetTexGenfv                      343
#define GLS_OP_glGetTexGeniv                      344
#define GLS_OP_glGetTexImage                      345
#define GLS_OP_glGetTexLevelParameterfv           348
#define GLS_OP_glGetTexLevelParameteriv           349
#define GLS_OP_glGetTexParameterfv                346
#define GLS_OP_glGetTexParameteriv                347
#define GLS_OP_glHint                             222
#define GLS_OP_glHistogramEXT                     65515
#define GLS_OP_glIndexMask                        276
#define GLS_OP_glIndexPointerEXT                  65498
#define GLS_OP_glIndexd                           108
#define GLS_OP_glIndexdv                          109
#define GLS_OP_glIndexf                           110
#define GLS_OP_glIndexfv                          111
#define GLS_OP_glIndexi                           112
#define GLS_OP_glIndexiv                          113
#define GLS_OP_glIndexs                           114
#define GLS_OP_glIndexsv                          115
#define GLS_OP_glInitNames                        261
#define GLS_OP_glIsEnabled                        350
#define GLS_OP_glIsList                           351
#define GLS_OP_glIsTextureEXT                     65474
#define GLS_OP_glLightModelf                      227
#define GLS_OP_glLightModelfv                     228
#define GLS_OP_glLightModeli                      229
#define GLS_OP_glLightModeliv                     230
#define GLS_OP_glLightf                           223
#define GLS_OP_glLightfv                          224
#define GLS_OP_glLighti                           225
#define GLS_OP_glLightiv                          226
#define GLS_OP_glLineStipple                      231
#define GLS_OP_glLineWidth                        232
#define GLS_OP_glListBase                         70
#define GLS_OP_glLoadIdentity                     354
#define GLS_OP_glLoadMatrixd                      356
#define GLS_OP_glLoadMatrixf                      355
#define GLS_OP_glLoadName                         262
#define GLS_OP_glLogicOp                          306
#define GLS_OP_glMap1d                            284
#define GLS_OP_glMap1f                            285
#define GLS_OP_glMap2d                            286
#define GLS_OP_glMap2f                            287
#define GLS_OP_glMapGrid1d                        288
#define GLS_OP_glMapGrid1f                        289
#define GLS_OP_glMapGrid2d                        290
#define GLS_OP_glMapGrid2f                        291
#define GLS_OP_glMaterialf                        233
#define GLS_OP_glMaterialfv                       234
#define GLS_OP_glMateriali                        235
#define GLS_OP_glMaterialiv                       236
#define GLS_OP_glMatrixMode                       357
#define GLS_OP_glMinmaxEXT                        65516
#define GLS_OP_glMultMatrixd                      359
#define GLS_OP_glMultMatrixf                      358
#define GLS_OP_glNewList                          64
#define GLS_OP_glNormal3b                         116
#define GLS_OP_glNormal3bv                        117
#define GLS_OP_glNormal3d                         118
#define GLS_OP_glNormal3dv                        119
#define GLS_OP_glNormal3f                         120
#define GLS_OP_glNormal3fv                        121
#define GLS_OP_glNormal3i                         122
#define GLS_OP_glNormal3iv                        123
#define GLS_OP_glNormal3s                         124
#define GLS_OP_glNormal3sv                        125
#define GLS_OP_glNormalPointerEXT                 65499
#define GLS_OP_glOrtho                            360
#define GLS_OP_glPassThrough                      263
#define GLS_OP_glPixelMapfv                       315
#define GLS_OP_glPixelMapuiv                      316
#define GLS_OP_glPixelMapusv                      317
#define GLS_OP_glPixelStoref                      313
#define GLS_OP_glPixelStorei                      314
#define GLS_OP_glPixelTexGenSGIX                  65462
#define GLS_OP_glPixelTransferf                   311
#define GLS_OP_glPixelTransferi                   312
#define GLS_OP_glPixelZoom                        310
#define GLS_OP_glPointSize                        237
#define GLS_OP_glPolygonMode                      238
#define GLS_OP_glPolygonOffsetEXT                 65522
#define GLS_OP_glPolygonStipple                   239
#define GLS_OP_glPopAttrib                        282
#define GLS_OP_glPopMatrix                        361
#define GLS_OP_glPopName                          264
#define GLS_OP_glPrioritizeTexturesEXT            65475
#define GLS_OP_glPushAttrib                       283
#define GLS_OP_glPushMatrix                       362
#define GLS_OP_glPushName                         265
#define GLS_OP_glRasterPos2d                      126
#define GLS_OP_glRasterPos2dv                     127
#define GLS_OP_glRasterPos2f                      128
#define GLS_OP_glRasterPos2fv                     129
#define GLS_OP_glRasterPos2i                      130
#define GLS_OP_glRasterPos2iv                     131
#define GLS_OP_glRasterPos2s                      132
#define GLS_OP_glRasterPos2sv                     133
#define GLS_OP_glRasterPos3d                      134
#define GLS_OP_glRasterPos3dv                     135
#define GLS_OP_glRasterPos3f                      136
#define GLS_OP_glRasterPos3fv                     137
#define GLS_OP_glRasterPos3i                      138
#define GLS_OP_glRasterPos3iv                     139
#define GLS_OP_glRasterPos3s                      140
#define GLS_OP_glRasterPos3sv                     141
#define GLS_OP_glRasterPos4d                      142
#define GLS_OP_glRasterPos4dv                     143
#define GLS_OP_glRasterPos4f                      144
#define GLS_OP_glRasterPos4fv                     145
#define GLS_OP_glRasterPos4i                      146
#define GLS_OP_glRasterPos4iv                     147
#define GLS_OP_glRasterPos4s                      148
#define GLS_OP_glRasterPos4sv                     149
#define GLS_OP_glReadBuffer                       318
#define GLS_OP_glReadPixels                       320
#define GLS_OP_glRectd                            150
#define GLS_OP_glRectdv                           151
#define GLS_OP_glRectf                            152
#define GLS_OP_glRectfv                           153
#define GLS_OP_glRecti                            154
#define GLS_OP_glRectiv                           155
#define GLS_OP_glRects                            156
#define GLS_OP_glRectsv                           157
#define GLS_OP_glRenderMode                       260
#define GLS_OP_glResetHistogramEXT                65517
#define GLS_OP_glResetMinmaxEXT                   65518
#define GLS_OP_glRotated                          363
#define GLS_OP_glRotatef                          364
#define GLS_OP_glSampleMaskSGIS                   65525
#define GLS_OP_glSamplePatternSGIS                65526
#define GLS_OP_glScaled                           365
#define GLS_OP_glScalef                           366
#define GLS_OP_glScissor                          240
#define GLS_OP_glSelectBuffer                     259
#define GLS_OP_glSeparableFilter2DEXT             65508
#define GLS_OP_glShadeModel                       241
#define GLS_OP_glSharpenTexFuncSGIS               65491
#define GLS_OP_glStencilFunc                      307
#define GLS_OP_glStencilMask                      273
#define GLS_OP_glStencilOp                        308
#define GLS_OP_glTagSampleBufferSGIX              65527
#define GLS_OP_glTexColorTableParameterfvSGI      65485
#define GLS_OP_glTexColorTableParameterivSGI      65486
#define GLS_OP_glTexCoord1d                       158
#define GLS_OP_glTexCoord1dv                      159
#define GLS_OP_glTexCoord1f                       160
#define GLS_OP_glTexCoord1fv                      161
#define GLS_OP_glTexCoord1i                       162
#define GLS_OP_glTexCoord1iv                      163
#define GLS_OP_glTexCoord1s                       164
#define GLS_OP_glTexCoord1sv                      165
#define GLS_OP_glTexCoord2d                       166
#define GLS_OP_glTexCoord2dv                      167
#define GLS_OP_glTexCoord2f                       168
#define GLS_OP_glTexCoord2fv                      169
#define GLS_OP_glTexCoord2i                       170
#define GLS_OP_glTexCoord2iv                      171
#define GLS_OP_glTexCoord2s                       172
#define GLS_OP_glTexCoord2sv                      173
#define GLS_OP_glTexCoord3d                       174
#define GLS_OP_glTexCoord3dv                      175
#define GLS_OP_glTexCoord3f                       176
#define GLS_OP_glTexCoord3fv                      177
#define GLS_OP_glTexCoord3i                       178
#define GLS_OP_glTexCoord3iv                      179
#define GLS_OP_glTexCoord3s                       180
#define GLS_OP_glTexCoord3sv                      181
#define GLS_OP_glTexCoord4d                       182
#define GLS_OP_glTexCoord4dv                      183
#define GLS_OP_glTexCoord4f                       184
#define GLS_OP_glTexCoord4fv                      185
#define GLS_OP_glTexCoord4i                       186
#define GLS_OP_glTexCoord4iv                      187
#define GLS_OP_glTexCoord4s                       188
#define GLS_OP_glTexCoord4sv                      189
#define GLS_OP_glTexCoordPointerEXT               65500
#define GLS_OP_glTexEnvf                          248
#define GLS_OP_glTexEnvfv                         249
#define GLS_OP_glTexEnvi                          250
#define GLS_OP_glTexEnviv                         251
#define GLS_OP_glTexGend                          252
#define GLS_OP_glTexGendv                         253
#define GLS_OP_glTexGenf                          254
#define GLS_OP_glTexGenfv                         255
#define GLS_OP_glTexGeni                          256
#define GLS_OP_glTexGeniv                         257
#define GLS_OP_glTexImage1D                       246
#define GLS_OP_glTexImage2D                       247
#define GLS_OP_glTexImage3DEXT                    65519
#define GLS_OP_glTexImage4DSGIS                   65460
#define GLS_OP_glTexParameterf                    242
#define GLS_OP_glTexParameterfv                   243
#define GLS_OP_glTexParameteri                    244
#define GLS_OP_glTexParameteriv                   245
#define GLS_OP_glTexSubImage1DEXT                 65523
#define GLS_OP_glTexSubImage2DEXT                 65524
#define GLS_OP_glTexSubImage3DEXT                 65488
#define GLS_OP_glTexSubImage4DSGIS                65461
#define GLS_OP_glTranslated                       367
#define GLS_OP_glTranslatef                       368
#define GLS_OP_glVertex2d                         190
#define GLS_OP_glVertex2dv                        191
#define GLS_OP_glVertex2f                         192
#define GLS_OP_glVertex2fv                        193
#define GLS_OP_glVertex2i                         194
#define GLS_OP_glVertex2iv                        195
#define GLS_OP_glVertex2s                         196
#define GLS_OP_glVertex2sv                        197
#define GLS_OP_glVertex3d                         198
#define GLS_OP_glVertex3dv                        199
#define GLS_OP_glVertex3f                         200
#define GLS_OP_glVertex3fv                        201
#define GLS_OP_glVertex3i                         202
#define GLS_OP_glVertex3iv                        203
#define GLS_OP_glVertex3s                         204
#define GLS_OP_glVertex3sv                        205
#define GLS_OP_glVertex4d                         206
#define GLS_OP_glVertex4dv                        207
#define GLS_OP_glVertex4f                         208
#define GLS_OP_glVertex4fv                        209
#define GLS_OP_glVertex4i                         210
#define GLS_OP_glVertex4iv                        211
#define GLS_OP_glVertex4s                         212
#define GLS_OP_glVertex4sv                        213
#define GLS_OP_glVertexPointerEXT                 65501
#define GLS_OP_glViewport                         369

/*************************************************************/

/* GLS global commands */
extern GLSenum glsBinary (GLboolean inSwapped);
extern GLSenum glsCommandAPI (GLSopcode inOpcode);
extern const GLubyte* glsCommandString (GLSopcode inOpcode);
extern void glsContext (GLuint inContext);
extern void glsDeleteContext (GLuint inContext);
extern const GLubyte* glsEnumString (GLSenum inAPI, GLSenum inEnum);
extern GLuint glsGenContext (void);
extern GLuint* glsGetAllContexts (void);
extern GLScommandAlignment* glsGetCommandAlignment (GLSopcode inOpcode, GLSenum inExternStreamType, GLScommandAlignment *outAlignment);
extern GLbitfield glsGetCommandAttrib (GLSopcode inOpcode);
extern GLint glsGetConsti (GLSenum inAttrib);
extern const GLint* glsGetConstiv (GLSenum inAttrib);
extern const GLubyte* glsGetConstubz (GLSenum inAttrib);
extern GLuint glsGetCurrentContext (void);
extern GLint* glsGetCurrentTime (GLint *outTime);
extern GLSenum glsGetError (GLboolean inClear);
extern GLint glsGetOpcodeCount (GLSenum inAPI);
extern const GLSopcode* glsGetOpcodes (GLSenum inAPI);
extern GLboolean glsIsContext (GLuint inContext);
extern GLboolean glsIsExtensionSupported (const GLubyte *inExtension);
extern GLboolean glsIsUTF8String (const GLubyte *inString);
extern GLlong glsLong (GLint inHigh, GLuint inLow);
extern GLint glsLongHigh (GLlong inVal);
extern GLuint glsLongLow (GLlong inVal);
extern GLSfunc glsNullCommandFunc (GLSopcode inOpcode);
extern void glsPixelSetup (void);
extern GLulong glsULong (GLuint inHigh, GLuint inLow);
extern GLuint glsULongHigh (GLulong inVal);
extern GLuint glsULongLow (GLulong inVal);
extern GLint glsUCS4toUTF8 (GLuint inUCS4, GLubyte *outUTF8);
extern GLubyte* glsUCStoUTF8z (size_t inUCSbytes, const GLvoid *inUCSz, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* glsUCS1toUTF8z (const GLubyte *inUCS1z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* glsUCS2toUTF8z (const GLushort *inUCS2z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* glsUCS4toUTF8z (const GLuint *inUCS4z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLint glsUTF8toUCS4 (const GLubyte *inUTF8, GLuint *outUCS4);
extern GLboolean glsUTF8toUCSz (size_t inUCSbytes, const GLubyte *inUTF8z, size_t inUCSmax, GLvoid *outUCSz);
extern GLboolean glsUTF8toUCS1z (const GLubyte *inUTF8z, size_t inUCS1max, GLubyte *outUCS1z);
extern GLboolean glsUTF8toUCS2z (const GLubyte *inUTF8z, size_t inUCS2max, GLushort *outUCS2z);
extern GLboolean glsUTF8toUCS4z (const GLubyte *inUTF8z, size_t inUCS4max, GLuint *outUCS4z);

/* GLS immediate commands */
extern void glsAbortCall (GLSenum inMode);
extern GLboolean glsBeginCapture (const GLubyte *inStreamName, GLSenum inCaptureStreamType, GLbitfield inWriteFlags);
extern void glsCallArray (GLSenum inExternStreamType, size_t inCount, const GLubyte *inArray);
extern void glsCaptureFlags (GLSopcode inOpcode, GLbitfield inFlags);
extern void glsCaptureFunc (GLSenum inTarget, GLScaptureFunc inFunc);
extern void glsChannel (GLSenum inTarget, FILE *inChannel);
extern void glsCommandFunc (GLSopcode inOpcode, GLSfunc inFunc);
extern GLSenum glsCopyStream (const GLubyte *inSource, const GLubyte *inDest, GLSenum inDestType, GLbitfield inWriteFlags);
extern void glsDataPointer (GLvoid *inPointer);
extern void glsDeleteReadPrefix (GLuint inIndex);
extern void glsDeleteStream (const GLubyte *inName);
extern void glsEndCapture (void);
extern void glsFlush (GLSenum inFlushType);
extern GLbitfield glsGetCaptureFlags (GLSopcode inOpcode);
extern GLSfunc glsGetCommandFunc (GLSopcode inOpcode);
extern GLSfunc glsGetContextFunc (GLSenum inAttrib);
extern GLlong glsGetContextListl (GLSenum inAttrib, GLuint inIndex);
extern const GLubyte* glsGetContextListubz (GLSenum inAttrib, GLuint inIndex);
extern GLvoid* glsGetContextPointer (GLSenum inAttrib);
extern GLint glsGetContexti (GLSenum inAttrib);
extern const GLubyte* glsGetContextubz (GLSenum inAttrib);
extern GLint glsGetGLRCi (GLuint inGLRC, GLSenum inAttrib);
extern GLfloat glsGetHeaderf (GLSenum inAttrib);
extern GLfloat* glsGetHeaderfv (GLSenum inAttrib, GLfloat *outVec);
extern GLint glsGetHeaderi (GLSenum inAttrib);
extern GLint* glsGetHeaderiv (GLSenum inAttrib, GLint *outVec);
extern const GLubyte* glsGetHeaderubz (GLSenum inAttrib);
extern GLfloat glsGetLayerf (GLuint inLayer, GLSenum inAttrib);
extern GLint glsGetLayeri (GLuint inLayer, GLSenum inAttrib);
extern GLbitfield glsGetStreamAttrib (const GLubyte *inName);
extern GLuint glsGetStreamCRC32 (const GLubyte *inName);
extern const GLubyte* glsGetStreamReadName (const GLubyte *inName);
extern size_t glsGetStreamSize (const GLubyte *inName);
extern GLSenum glsGetStreamType (const GLubyte *inName);
extern GLboolean glsIsContextStream (const GLubyte *inName);
extern void glsPixelSetupGen (GLboolean inEnabled);
extern void glsReadFunc (GLSreadFunc inFunc);
extern void glsReadPrefix (GLSenum inListOp, const GLubyte *inPrefix);
extern void glsUnreadFunc (GLSwriteFunc inFunc);
extern void glsWriteFunc (GLSwriteFunc inFunc);
extern void glsWritePrefix (const GLubyte *inPrefix);

/* GLS encodable commands */
extern void glsBeginGLS (GLint inVersionMajor, GLint inVersionMinor);
extern void glsBlock (GLSenum inBlockType);
extern GLSenum glsCallStream (const GLubyte *inName);
extern void glsEndGLS (void);
extern void glsError (GLSopcode inOpcode, GLSenum inError);
extern void glsGLRC (GLuint inGLRC);
extern void glsGLRCLayer (GLuint inGLRC, GLuint inLayer, GLuint inReadLayer);
extern void glsHeaderGLRCi (GLuint inGLRC, GLSenum inAttrib, GLint inVal);
extern void glsHeaderLayerf (GLuint inLayer, GLSenum inAttrib, GLfloat inVal);
extern void glsHeaderLayeri (GLuint inLayer, GLSenum inAttrib, GLint inVal);
extern void glsHeaderf (GLSenum inAttrib, GLfloat inVal);
extern void glsHeaderfv (GLSenum inAttrib, const GLfloat *inVec);
extern void glsHeaderi (GLSenum inAttrib, GLint inVal);
extern void glsHeaderiv (GLSenum inAttrib, const GLint *inVec);
extern void glsHeaderubz (GLSenum inAttrib, const GLubyte *inString);
extern void glsRequireExtension (const GLubyte *inExtension);
extern void glsUnsupportedCommand (void);

/* GLS encodable-nop commands */
extern void glsAppRef (GLulong inAddress, GLuint inCount);
extern void glsBeginObj (const GLubyte *inTag);
extern void glsCharubz (const GLubyte *inTag, const GLubyte *inString);
extern void glsComment (const GLubyte *inComment);
extern void glsDisplayMapfv (GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec);
extern void glsEndObj (void);
extern void glsNumb (const GLubyte *inTag, GLbyte inVal);
extern void glsNumbv (const GLubyte *inTag, GLuint inCount, const GLbyte *inVec);
extern void glsNumd (const GLubyte *inTag, GLdouble inVal);
extern void glsNumdv (const GLubyte *inTag, GLuint inCount, const GLdouble *inVec);
extern void glsNumf (const GLubyte *inTag, GLfloat inVal);
extern void glsNumfv (const GLubyte *inTag, GLuint inCount, const GLfloat *inVec);
extern void glsNumi (const GLubyte *inTag, GLint inVal);
extern void glsNumiv (const GLubyte *inTag, GLuint inCount, const GLint *inVec);
extern void glsNuml (const GLubyte *inTag, GLlong inVal);
extern void glsNumlv (const GLubyte *inTag, GLuint inCount, const GLlong *inVec);
extern void glsNums (const GLubyte *inTag, GLshort inVal);
extern void glsNumsv (const GLubyte *inTag, GLuint inCount, const GLshort *inVec);
extern void glsNumub (const GLubyte *inTag, GLubyte inVal);
extern void glsNumubv (const GLubyte *inTag, GLuint inCount, const GLubyte *inVec);
extern void glsNumui (const GLubyte *inTag, GLuint inVal);
extern void glsNumuiv (const GLubyte *inTag, GLuint inCount, const GLuint *inVec);
extern void glsNumul (const GLubyte *inTag, GLulong inVal);
extern void glsNumulv (const GLubyte *inTag, GLuint inCount, const GLulong *inVec);
extern void glsNumus (const GLubyte *inTag, GLushort inVal);
extern void glsNumusv (const GLubyte *inTag, GLuint inCount, const GLushort *inVec);
extern void glsPad (void);
extern void glsSwapBuffers (GLuint inLayer);

#if defined(__cplusplus)
    }
#endif /* defined(__cplusplus) */

#endif /* defined(__gls_h_) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\inc\opcode.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#define __GLS_OPCODE(inPage, inOffset) ( \
    (inPage) * __GLS_OPCODES_PER_PAGE + (inOffset) \
)

#define __GLS_OPCODE_COUNT ( \
    (__GLS_OPCODE_PAGE_MAPPED0 + __GLS_MAPPED_OPCODE_PAGE_COUNT) * \
    __GLS_OPCODES_PER_PAGE \
)

#define __GLS_OPCODE_OFFSET(inOpcode) (inOpcode % __GLS_OPCODES_PER_PAGE)
#define __GLS_OPCODE_PAGE(inOpcode) (inOpcode / __GLS_OPCODES_PER_PAGE)

extern GLSopcode __glsMapOpcode(GLSopcode inOpcode);
extern GLSenum __glsOpcodeAPI(GLSopcode inOpcode);
extern GLSopcode __glsUnmapOpcode(GLSopcode inOpcode);
extern GLboolean __glsValidateOpcode(GLSopcode inOpcode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\inc\gls_wnt.h ===
#if !defined(__gls_h_)
#define __gls_h_

/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#define GLS_LINKAGE APIENTRY

#include <windef.h>
#include <wingdi.h>
#include <GL/gl.h>
#include <stddef.h>
#include <stdio.h>

#if defined(__cplusplus)
    extern "C" {
#endif /* defined(__cplusplus) */

typedef __int64 GLlong;
typedef unsigned __int64 GLulong;

typedef GLuint GLSenum;
typedef GLuint GLSopcode;

typedef struct {
    GLuint mask;
    GLuint value;
} GLScommandAlignment;

typedef void (GLS_LINKAGE *GLScaptureFunc)(GLSopcode inOpcode);
typedef size_t (GLS_LINKAGE *GLSreadFunc)(size_t inCount, GLubyte *outBuf);
typedef size_t (GLS_LINKAGE *GLSwriteFunc)(size_t inCount, const GLubyte *inBuf);

#if defined(__cplusplus)
    typedef void (GLS_LINKAGE *GLSfunc)(...);
#else /* !defined(__cplusplus) */
    typedef void (GLS_LINKAGE *GLSfunc)();
#endif /* defined(__cplusplus) */

#define glsCSTR(p) ((const GLubyte*)(p))
#define glsSTR(p)  ((GLubyte*)(p))

/*************************************************************/

/* CaptureFlags */
/*      GLS_NONE */
#define GLS_CAPTURE_EXECUTE_BIT                   0x00000001
#define GLS_CAPTURE_WRITE_BIT                     0x00000002

/* CommandAttrib */
/*      GLS_NONE */
#define GLS_COMMAND_GEN_BIT                       0x00000001
#define GLS_COMMAND_GET_BIT                       0x00000002
#define GLS_COMMAND_REPLY_BIT                     0x00000004

/* ImageFlags */
/*      GLS_NONE */
#define GLS_IMAGE_NULL_BIT                        0x00000001

/* StreamAttrib */
/*      GLS_NONE */
#define GLS_STREAM_CONTEXT_BIT                    0x00000001
#define GLS_STREAM_NAMED_BIT                      0x00000002
#define GLS_STREAM_READABLE_BIT                   0x00000004
#define GLS_STREAM_SEEKABLE_BIT                   0x00000008
#define GLS_STREAM_WRITABLE_BIT                   0x00000010

/* WriteFlags */
/*      GLS_NONE */
#define GLS_WRITE_APPEND_BIT                      0x00000001

/* Fundamental */
#define GLS_NONE                                  0x0000

/* AbortMode */
/*      GLS_NONE */
#define GLS_ALL                                   0x0010
#define GLS_LAST                                  0x0011

/* API */
#define GLS_API_GLS                               0x0020
#define GLS_API_GL                                0x0021

/* BlockType */
#define GLS_FRAME                                 0x0030
#define GLS_HEADER                                0x0031
#define GLS_INIT                                  0x0032
#define GLS_STATIC                                0x0033

/* CaptureFuncTarget */
#define GLS_CAPTURE_ENTRY_FUNC                    0x0040
#define GLS_CAPTURE_EXIT_FUNC                     0x0041

/* CaptureStreamType */
#define GLS_CONTEXT                               0x0050
#define GLS_BINARY_LSB_FIRST                      0x0051
#define GLS_BINARY_MSB_FIRST                      0x0052
#define GLS_TEXT                                  0x0053

/* ChannelTarget */
#define GLS_DEFAULT_READ_CHANNEL                  0x0060
#define GLS_DEFAULT_WRITE_CHANNEL                 0x0061

/* Consti */
#define GLS_API_COUNT                             0x0070
#define GLS_MAX_CALL_NESTING                      0x0071
#define GLS_MAX_CAPTURE_NESTING                   0x0072
#define GLS_VERSION_MAJOR                         0x0073
#define GLS_VERSION_MINOR                         0x0074

/* Constiv */
#define GLS_ALL_APIS                              0x0080

/* Constubz */
#define GLS_EXTENSIONS                            0x0090
#define GLS_PLATFORM                              0x0091
#define GLS_RELEASE                               0x0092
#define GLS_VENDOR                                0x0093

/* ContextFunc */
/*      GLS_CAPTURE_ENTRY_FUNC */
/*      GLS_CAPTURE_EXIT_FUNC */
#define GLS_READ_FUNC                             0x00A1
#define GLS_UNREAD_FUNC                           0x00A2
#define GLS_WRITE_FUNC                            0x00A3

/* ContextListl */
#define GLS_OUT_ARG_LIST                          0x00B0

/* ContextListubz */
#define GLS_CONTEXT_STREAM_LIST                   0x00C0
#define GLS_READ_PREFIX_LIST                      0x00C1

/* ContextPointer */
/*      GLS_DEFAULT_READ_CHANNEL */
/*      GLS_DEFAULT_WRITE_CHANNEL */
#define GLS_DATA_POINTER                          0x00E0

/* Contexti */
#define GLS_ABORT_MODE                            0x00E0
#define GLS_BLOCK_TYPE                            0x00E1
#define GLS_CALL_NESTING                          0x00E2
#define GLS_CAPTURE_NESTING                       0x00E3
#define GLS_CONTEXT_STREAM_COUNT                  0x00E4
#define GLS_CURRENT_GLRC                          0x00E5
#define GLS_OUT_ARG_COUNT                         0x00E6
#define GLS_PIXEL_SETUP_GEN                       0x00E7
#define GLS_READ_PREFIX_COUNT                     0x00E8
#define GLS_STREAM_VERSION_MAJOR                  0x00E9
#define GLS_STREAM_VERSION_MINOR                  0x00EA

/* Contextubz */
#define GLS_WRITE_PREFIX                          0x0100

/* CopyStreamType */
/*      GLS_NONE */
/*      GLS_CONTEXT */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */

/* DisplayFormat */
#define GLS_IIII                                  0x0110
#define GLS_RGBA                                  0x0111
#define GLS_RRRA                                  0x0112

/* DisplayMap */
#define GLS_DISPLAY_MAP_I_TO_R                    0x0120
#define GLS_DISPLAY_MAP_I_TO_G                    0x0121
#define GLS_DISPLAY_MAP_I_TO_B                    0x0122
#define GLS_DISPLAY_MAP_I_TO_A                    0x0123

/* ErrorCode */
/*      GLS_NONE */
#define GLS_CALL_OVERFLOW                         0x0130
#define GLS_DECODE_ERROR                          0x0131
#define GLS_ENCODE_ERROR                          0x0132
#define GLS_INVALID_ENUM                          0x0133
#define GLS_INVALID_OPERATION                     0x0134
#define GLS_INVALID_STREAM                        0x0135
#define GLS_INVALID_STRING                        0x0136
#define GLS_INVALID_VALUE                         0x0137
#define GLS_NOT_FOUND                             0x0138
#define GLS_OUT_OF_MEMORY                         0x0139
#define GLS_STREAM_CLOSE_ERROR                    0x013A
#define GLS_STREAM_DELETE_ERROR                   0x013B
#define GLS_STREAM_OPEN_ERROR                     0x013C
#define GLS_STREAM_READ_ERROR                     0x013D
#define GLS_STREAM_WRITE_ERROR                    0x013E
#define GLS_UNSUPPORTED_COMMAND                   0x013F
#define GLS_UNSUPPORTED_EXTENSION                 0x0140

/* ExternStreamType */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */

/* FlushType */
/*      GLS_ALL */
/*      GLS_LAST */

/* GetStreamType */
/*      GLS_NONE */
/*      GLS_CONTEXT */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */
#define GLS_UNKNOWN                               0x0150

/* GLRCi */
#define GLS_LAYER                                 0x0160
#define GLS_READ_LAYER                            0x0161
#define GLS_SHARE_GLRC                            0x0162

/* Headerf */
#define GLS_ASPECT                                0x0170
#define GLS_BORDER_WIDTH                          0x0171
#define GLS_CONTRAST_RATIO                        0x0172
#define GLS_HEIGHT_MM                             0x0173

/* Headerfv */
#define GLS_BORDER_COLOR                          0x0180
#define GLS_GAMMA                                 0x0181
#define GLS_ORIGIN                                0x0182
#define GLS_PAGE_COLOR                            0x0183
#define GLS_PAGE_SIZE                             0x0184
#define GLS_RED_POINT                             0x0185
#define GLS_GREEN_POINT                           0x0186
#define GLS_BLUE_POINT                            0x0187
#define GLS_WHITE_POINT                           0x0188

/* Headeri */
#define GLS_FRAME_COUNT                           0x01A0
#define GLS_GLRC_COUNT                            0x01A1
#define GLS_HEIGHT_PIXELS                         0x01A2
#define GLS_LAYER_COUNT                           0x01A3
#define GLS_TILEABLE                              0x01A4

/* Headeriv */
#define GLS_CREATE_TIME                           0x01B0
#define GLS_MODIFY_TIME                           0x01B1

/* Headerubz */
/*      GLS_EXTENSIONS */
#define GLS_AUTHOR                                0x01C0
#define GLS_DESCRIPTION                           0x01C1
#define GLS_NOTES                                 0x01C2
#define GLS_TITLE                                 0x01C3
#define GLS_TOOLS                                 0x01C4
#define GLS_VERSION                               0x01C5

/* Layerf */
#define GLS_INVISIBLE_ASPECT                      0x01D0

/* Layeri */
#define GLS_DISPLAY_FORMAT                        0x01E0
#define GLS_DOUBLEBUFFER                          0x01E1
#define GLS_INVISIBLE                             0x01E2
#define GLS_INVISIBLE_HEIGHT_PIXELS               0x01E3
#define GLS_LEVEL                                 0x01E4
#define GLS_STEREO                                0x01E5
#define GLS_TRANSPARENT                           0x01E6
#define GLS_INDEX_BITS                            0x01E7
#define GLS_RED_BITS                              0x01E8
#define GLS_GREEN_BITS                            0x01E9
#define GLS_BLUE_BITS                             0x01EA
#define GLS_ALPHA_BITS                            0x01EB
#define GLS_DEPTH_BITS                            0x01EC
#define GLS_STENCIL_BITS                          0x01ED
#define GLS_ACCUM_RED_BITS                        0x01EE
#define GLS_ACCUM_GREEN_BITS                      0x01EF
#define GLS_ACCUM_BLUE_BITS                       0x01F0
#define GLS_ACCUM_ALPHA_BITS                      0x01F1
#define GLS_AUX_BUFFERS                           0x01F2
/*      GLS_SAMPLE_BUFFERS_SGIS */
/*      GLS_SAMPLES_SGIS */

/* ListOp */
#define GLS_APPEND                                0x0200
#define GLS_PREPEND                               0x0201

/* GL_SGIS_multisample */
#define GLS_SAMPLE_BUFFERS_SGIS                   0x0400
#define GLS_SAMPLES_SGIS                          0x0401

/* GLS opcodes */
#define GLS_OP_glsBeginGLS                        16
#define GLS_OP_glsBlock                           17
#define GLS_OP_glsCallStream                      18
#define GLS_OP_glsEndGLS                          19
#define GLS_OP_glsError                           20
#define GLS_OP_glsGLRC                            21
#define GLS_OP_glsGLRCLayer                       22
#define GLS_OP_glsHeaderGLRCi                     23
#define GLS_OP_glsHeaderLayerf                    24
#define GLS_OP_glsHeaderLayeri                    25
#define GLS_OP_glsHeaderf                         26
#define GLS_OP_glsHeaderfv                        27
#define GLS_OP_glsHeaderi                         28
#define GLS_OP_glsHeaderiv                        29
#define GLS_OP_glsHeaderubz                       30
#define GLS_OP_glsRequireExtension                31
#define GLS_OP_glsUnsupportedCommand              32
#define GLS_OP_glsAppRef                          33
#define GLS_OP_glsBeginObj                        34
#define GLS_OP_glsCharubz                         35
#define GLS_OP_glsComment                         36
#define GLS_OP_glsDisplayMapfv                    37
#define GLS_OP_glsEndObj                          38
#define GLS_OP_glsNumb                            39
#define GLS_OP_glsNumbv                           40
#define GLS_OP_glsNumd                            41
#define GLS_OP_glsNumdv                           42
#define GLS_OP_glsNumf                            43
#define GLS_OP_glsNumfv                           44
#define GLS_OP_glsNumi                            45
#define GLS_OP_glsNumiv                           46
#define GLS_OP_glsNuml                            47
#define GLS_OP_glsNumlv                           48
#define GLS_OP_glsNums                            49
#define GLS_OP_glsNumsv                           50
#define GLS_OP_glsNumub                           51
#define GLS_OP_glsNumubv                          52
#define GLS_OP_glsNumui                           53
#define GLS_OP_glsNumuiv                          54
#define GLS_OP_glsNumul                           55
#define GLS_OP_glsNumulv                          56
#define GLS_OP_glsNumus                           57
#define GLS_OP_glsNumusv                          58
#define GLS_OP_glsPad                             59
#define GLS_OP_glsSwapBuffers                     60

/* GL opcodes */
#define GLS_OP_glAccum                            277
#define GLS_OP_glAlphaFunc                        304
#define GLS_OP_glAreTexturesResidentEXT           65502
#define GLS_OP_glArrayElementEXT                  65493
#define GLS_OP_glBegin                            71
#define GLS_OP_glBindTextureEXT                   65503
#define GLS_OP_glBitmap                           72
#define GLS_OP_glBlendColorEXT                    65520
#define GLS_OP_glBlendEquationEXT                 65521
#define GLS_OP_glBlendFunc                        305
#define GLS_OP_glCallList                         66
#define GLS_OP_glCallLists                        67
#define GLS_OP_glClear                            267
#define GLS_OP_glClearAccum                       268
#define GLS_OP_glClearColor                       270
#define GLS_OP_glClearDepth                       272
#define GLS_OP_glClearIndex                       269
#define GLS_OP_glClearStencil                     271
#define GLS_OP_glClipPlane                        214
#define GLS_OP_glColor3b                          73
#define GLS_OP_glColor3bv                         74
#define GLS_OP_glColor3d                          75
#define GLS_OP_glColor3dv                         76
#define GLS_OP_glColor3f                          77
#define GLS_OP_glColor3fv                         78
#define GLS_OP_glColor3i                          79
#define GLS_OP_glColor3iv                         80
#define GLS_OP_glColor3s                          81
#define GLS_OP_glColor3sv                         82
#define GLS_OP_glColor3ub                         83
#define GLS_OP_glColor3ubv                        84
#define GLS_OP_glColor3ui                         85
#define GLS_OP_glColor3uiv                        86
#define GLS_OP_glColor3us                         87
#define GLS_OP_glColor3usv                        88
#define GLS_OP_glColor4b                          89
#define GLS_OP_glColor4bv                         90
#define GLS_OP_glColor4d                          91
#define GLS_OP_glColor4dv                         92
#define GLS_OP_glColor4f                          93
#define GLS_OP_glColor4fv                         94
#define GLS_OP_glColor4i                          95
#define GLS_OP_glColor4iv                         96
#define GLS_OP_glColor4s                          97
#define GLS_OP_glColor4sv                         98
#define GLS_OP_glColor4ub                         99
#define GLS_OP_glColor4ubv                        100
#define GLS_OP_glColor4ui                         101
#define GLS_OP_glColor4uiv                        102
#define GLS_OP_glColor4us                         103
#define GLS_OP_glColor4usv                        104
#define GLS_OP_glColorMask                        274
#define GLS_OP_glColorMaterial                    215
#define GLS_OP_glColorPointerEXT                  65494
#define GLS_OP_glColorTableParameterfvSGI         65477
#define GLS_OP_glColorTableParameterivSGI         65478
#define GLS_OP_glColorTableSGI                    65476
#define GLS_OP_glConvolutionFilter1DEXT           65528
#define GLS_OP_glConvolutionFilter2DEXT           65529
#define GLS_OP_glConvolutionParameterfEXT         65530
#define GLS_OP_glConvolutionParameterfvEXT        65531
#define GLS_OP_glConvolutionParameteriEXT         65532
#define GLS_OP_glConvolutionParameterivEXT        65533
#define GLS_OP_glCopyColorTableSGI                65479
#define GLS_OP_glCopyConvolutionFilter1DEXT       65534
#define GLS_OP_glCopyConvolutionFilter2DEXT       65535
#define GLS_OP_glCopyPixels                       319
#define GLS_OP_glCopyTexImage1DEXT                65487
#define GLS_OP_glCopyTexImage2DEXT                65456
#define GLS_OP_glCopyTexSubImage1DEXT             65457
#define GLS_OP_glCopyTexSubImage2DEXT             65458
#define GLS_OP_glCopyTexSubImage3DEXT             65459
#define GLS_OP_glCullFace                         216
#define GLS_OP_glDeleteLists                      68
#define GLS_OP_glDeleteTexturesEXT                65472
#define GLS_OP_glDepthFunc                        309
#define GLS_OP_glDepthMask                        275
#define GLS_OP_glDepthRange                       352
#define GLS_OP_glDetailTexFuncSGIS                65489
#define GLS_OP_glDisable                          278
#define GLS_OP_glDrawArraysEXT                    65495
#define GLS_OP_glDrawBuffer                       266
#define GLS_OP_glDrawPixels                       321
#define GLS_OP_glEdgeFlag                         105
#define GLS_OP_glEdgeFlagPointerEXT               65496
#define GLS_OP_glEdgeFlagv                        106
#define GLS_OP_glEnable                           279
#define GLS_OP_glEnd                              107
#define GLS_OP_glEndList                          65
#define GLS_OP_glEvalCoord1d                      292
#define GLS_OP_glEvalCoord1dv                     293
#define GLS_OP_glEvalCoord1f                      294
#define GLS_OP_glEvalCoord1fv                     295
#define GLS_OP_glEvalCoord2d                      296
#define GLS_OP_glEvalCoord2dv                     297
#define GLS_OP_glEvalCoord2f                      298
#define GLS_OP_glEvalCoord2fv                     299
#define GLS_OP_glEvalMesh1                        300
#define GLS_OP_glEvalMesh2                        302
#define GLS_OP_glEvalPoint1                       301
#define GLS_OP_glEvalPoint2                       303
#define GLS_OP_glFeedbackBuffer                   258
#define GLS_OP_glFinish                           280
#define GLS_OP_glFlush                            281
#define GLS_OP_glFogf                             217
#define GLS_OP_glFogfv                            218
#define GLS_OP_glFogi                             219
#define GLS_OP_glFogiv                            220
#define GLS_OP_glFrontFace                        221
#define GLS_OP_glFrustum                          353
#define GLS_OP_glGenLists                         69
#define GLS_OP_glGenTexturesEXT                   65473
#define GLS_OP_glGetBooleanv                      322
#define GLS_OP_glGetClipPlane                     323
#define GLS_OP_glGetColorTableParameterfvSGI      65481
#define GLS_OP_glGetColorTableParameterivSGI      65482
#define GLS_OP_glGetColorTableSGI                 65480
#define GLS_OP_glGetConvolutionFilterEXT          65504
#define GLS_OP_glGetConvolutionParameterfvEXT     65505
#define GLS_OP_glGetConvolutionParameterivEXT     65506
#define GLS_OP_glGetDetailTexFuncSGIS             65490
#define GLS_OP_glGetDoublev                       324
#define GLS_OP_glGetError                         325
#define GLS_OP_glGetFloatv                        326
#define GLS_OP_glGetHistogramEXT                  65509
#define GLS_OP_glGetHistogramParameterfvEXT       65510
#define GLS_OP_glGetHistogramParameterivEXT       65511
#define GLS_OP_glGetIntegerv                      327
#define GLS_OP_glGetLightfv                       328
#define GLS_OP_glGetLightiv                       329
#define GLS_OP_glGetMapdv                         330
#define GLS_OP_glGetMapfv                         331
#define GLS_OP_glGetMapiv                         332
#define GLS_OP_glGetMaterialfv                    333
#define GLS_OP_glGetMaterialiv                    334
#define GLS_OP_glGetMinmaxEXT                     65512
#define GLS_OP_glGetMinmaxParameterfvEXT          65513
#define GLS_OP_glGetMinmaxParameterivEXT          65514
#define GLS_OP_glGetPixelMapfv                    335
#define GLS_OP_glGetPixelMapuiv                   336
#define GLS_OP_glGetPixelMapusv                   337
#define GLS_OP_glGetPointervEXT                   65497
#define GLS_OP_glGetPolygonStipple                338
#define GLS_OP_glGetSeparableFilterEXT            65507
#define GLS_OP_glGetSharpenTexFuncSGIS            65492
#define GLS_OP_glGetString                        339
#define GLS_OP_glGetTexColorTableParameterfvSGI   65483
#define GLS_OP_glGetTexColorTableParameterivSGI   65484
#define GLS_OP_glGetTexEnvfv                      340
#define GLS_OP_glGetTexEnviv                      341
#define GLS_OP_glGetTexGendv                      342
#define GLS_OP_glGetTexGenfv                      343
#define GLS_OP_glGetTexGeniv                      344
#define GLS_OP_glGetTexImage                      345
#define GLS_OP_glGetTexLevelParameterfv           348
#define GLS_OP_glGetTexLevelParameteriv           349
#define GLS_OP_glGetTexParameterfv                346
#define GLS_OP_glGetTexParameteriv                347
#define GLS_OP_glHint                             222
#define GLS_OP_glHistogramEXT                     65515
#define GLS_OP_glIndexMask                        276
#define GLS_OP_glIndexPointerEXT                  65498
#define GLS_OP_glIndexd                           108
#define GLS_OP_glIndexdv                          109
#define GLS_OP_glIndexf                           110
#define GLS_OP_glIndexfv                          111
#define GLS_OP_glIndexi                           112
#define GLS_OP_glIndexiv                          113
#define GLS_OP_glIndexs                           114
#define GLS_OP_glIndexsv                          115
#define GLS_OP_glInitNames                        261
#define GLS_OP_glIsEnabled                        350
#define GLS_OP_glIsList                           351
#define GLS_OP_glIsTextureEXT                     65474
#define GLS_OP_glLightModelf                      227
#define GLS_OP_glLightModelfv                     228
#define GLS_OP_glLightModeli                      229
#define GLS_OP_glLightModeliv                     230
#define GLS_OP_glLightf                           223
#define GLS_OP_glLightfv                          224
#define GLS_OP_glLighti                           225
#define GLS_OP_glLightiv                          226
#define GLS_OP_glLineStipple                      231
#define GLS_OP_glLineWidth                        232
#define GLS_OP_glListBase                         70
#define GLS_OP_glLoadIdentity                     354
#define GLS_OP_glLoadMatrixd                      356
#define GLS_OP_glLoadMatrixf                      355
#define GLS_OP_glLoadName                         262
#define GLS_OP_glLogicOp                          306
#define GLS_OP_glMap1d                            284
#define GLS_OP_glMap1f                            285
#define GLS_OP_glMap2d                            286
#define GLS_OP_glMap2f                            287
#define GLS_OP_glMapGrid1d                        288
#define GLS_OP_glMapGrid1f                        289
#define GLS_OP_glMapGrid2d                        290
#define GLS_OP_glMapGrid2f                        291
#define GLS_OP_glMaterialf                        233
#define GLS_OP_glMaterialfv                       234
#define GLS_OP_glMateriali                        235
#define GLS_OP_glMaterialiv                       236
#define GLS_OP_glMatrixMode                       357
#define GLS_OP_glMinmaxEXT                        65516
#define GLS_OP_glMultMatrixd                      359
#define GLS_OP_glMultMatrixf                      358
#define GLS_OP_glNewList                          64
#define GLS_OP_glNormal3b                         116
#define GLS_OP_glNormal3bv                        117
#define GLS_OP_glNormal3d                         118
#define GLS_OP_glNormal3dv                        119
#define GLS_OP_glNormal3f                         120
#define GLS_OP_glNormal3fv                        121
#define GLS_OP_glNormal3i                         122
#define GLS_OP_glNormal3iv                        123
#define GLS_OP_glNormal3s                         124
#define GLS_OP_glNormal3sv                        125
#define GLS_OP_glNormalPointerEXT                 65499
#define GLS_OP_glOrtho                            360
#define GLS_OP_glPassThrough                      263
#define GLS_OP_glPixelMapfv                       315
#define GLS_OP_glPixelMapuiv                      316
#define GLS_OP_glPixelMapusv                      317
#define GLS_OP_glPixelStoref                      313
#define GLS_OP_glPixelStorei                      314
#define GLS_OP_glPixelTexGenSGIX                  65462
#define GLS_OP_glPixelTransferf                   311
#define GLS_OP_glPixelTransferi                   312
#define GLS_OP_glPixelZoom                        310
#define GLS_OP_glPointSize                        237
#define GLS_OP_glPolygonMode                      238
#define GLS_OP_glPolygonOffsetEXT                 65522
#define GLS_OP_glPolygonStipple                   239
#define GLS_OP_glPopAttrib                        282
#define GLS_OP_glPopMatrix                        361
#define GLS_OP_glPopName                          264
#define GLS_OP_glPrioritizeTexturesEXT            65475
#define GLS_OP_glPushAttrib                       283
#define GLS_OP_glPushMatrix                       362
#define GLS_OP_glPushName                         265
#define GLS_OP_glRasterPos2d                      126
#define GLS_OP_glRasterPos2dv                     127
#define GLS_OP_glRasterPos2f                      128
#define GLS_OP_glRasterPos2fv                     129
#define GLS_OP_glRasterPos2i                      130
#define GLS_OP_glRasterPos2iv                     131
#define GLS_OP_glRasterPos2s                      132
#define GLS_OP_glRasterPos2sv                     133
#define GLS_OP_glRasterPos3d                      134
#define GLS_OP_glRasterPos3dv                     135
#define GLS_OP_glRasterPos3f                      136
#define GLS_OP_glRasterPos3fv                     137
#define GLS_OP_glRasterPos3i                      138
#define GLS_OP_glRasterPos3iv                     139
#define GLS_OP_glRasterPos3s                      140
#define GLS_OP_glRasterPos3sv                     141
#define GLS_OP_glRasterPos4d                      142
#define GLS_OP_glRasterPos4dv                     143
#define GLS_OP_glRasterPos4f                      144
#define GLS_OP_glRasterPos4fv                     145
#define GLS_OP_glRasterPos4i                      146
#define GLS_OP_glRasterPos4iv                     147
#define GLS_OP_glRasterPos4s                      148
#define GLS_OP_glRasterPos4sv                     149
#define GLS_OP_glReadBuffer                       318
#define GLS_OP_glReadPixels                       320
#define GLS_OP_glRectd                            150
#define GLS_OP_glRectdv                           151
#define GLS_OP_glRectf                            152
#define GLS_OP_glRectfv                           153
#define GLS_OP_glRecti                            154
#define GLS_OP_glRectiv                           155
#define GLS_OP_glRects                            156
#define GLS_OP_glRectsv                           157
#define GLS_OP_glRenderMode                       260
#define GLS_OP_glResetHistogramEXT                65517
#define GLS_OP_glResetMinmaxEXT                   65518
#define GLS_OP_glRotated                          363
#define GLS_OP_glRotatef                          364
#define GLS_OP_glSampleMaskSGIS                   65525
#define GLS_OP_glSamplePatternSGIS                65526
#define GLS_OP_glScaled                           365
#define GLS_OP_glScalef                           366
#define GLS_OP_glScissor                          240
#define GLS_OP_glSelectBuffer                     259
#define GLS_OP_glSeparableFilter2DEXT             65508
#define GLS_OP_glShadeModel                       241
#define GLS_OP_glSharpenTexFuncSGIS               65491
#define GLS_OP_glStencilFunc                      307
#define GLS_OP_glStencilMask                      273
#define GLS_OP_glStencilOp                        308
#define GLS_OP_glTagSampleBufferSGIX              65527
#define GLS_OP_glTexColorTableParameterfvSGI      65485
#define GLS_OP_glTexColorTableParameterivSGI      65486
#define GLS_OP_glTexCoord1d                       158
#define GLS_OP_glTexCoord1dv                      159
#define GLS_OP_glTexCoord1f                       160
#define GLS_OP_glTexCoord1fv                      161
#define GLS_OP_glTexCoord1i                       162
#define GLS_OP_glTexCoord1iv                      163
#define GLS_OP_glTexCoord1s                       164
#define GLS_OP_glTexCoord1sv                      165
#define GLS_OP_glTexCoord2d                       166
#define GLS_OP_glTexCoord2dv                      167
#define GLS_OP_glTexCoord2f                       168
#define GLS_OP_glTexCoord2fv                      169
#define GLS_OP_glTexCoord2i                       170
#define GLS_OP_glTexCoord2iv                      171
#define GLS_OP_glTexCoord2s                       172
#define GLS_OP_glTexCoord2sv                      173
#define GLS_OP_glTexCoord3d                       174
#define GLS_OP_glTexCoord3dv                      175
#define GLS_OP_glTexCoord3f                       176
#define GLS_OP_glTexCoord3fv                      177
#define GLS_OP_glTexCoord3i                       178
#define GLS_OP_glTexCoord3iv                      179
#define GLS_OP_glTexCoord3s                       180
#define GLS_OP_glTexCoord3sv                      181
#define GLS_OP_glTexCoord4d                       182
#define GLS_OP_glTexCoord4dv                      183
#define GLS_OP_glTexCoord4f                       184
#define GLS_OP_glTexCoord4fv                      185
#define GLS_OP_glTexCoord4i                       186
#define GLS_OP_glTexCoord4iv                      187
#define GLS_OP_glTexCoord4s                       188
#define GLS_OP_glTexCoord4sv                      189
#define GLS_OP_glTexCoordPointerEXT               65500
#define GLS_OP_glTexEnvf                          248
#define GLS_OP_glTexEnvfv                         249
#define GLS_OP_glTexEnvi                          250
#define GLS_OP_glTexEnviv                         251
#define GLS_OP_glTexGend                          252
#define GLS_OP_glTexGendv                         253
#define GLS_OP_glTexGenf                          254
#define GLS_OP_glTexGenfv                         255
#define GLS_OP_glTexGeni                          256
#define GLS_OP_glTexGeniv                         257
#define GLS_OP_glTexImage1D                       246
#define GLS_OP_glTexImage2D                       247
#define GLS_OP_glTexImage3DEXT                    65519
#define GLS_OP_glTexImage4DSGIS                   65460
#define GLS_OP_glTexParameterf                    242
#define GLS_OP_glTexParameterfv                   243
#define GLS_OP_glTexParameteri                    244
#define GLS_OP_glTexParameteriv                   245
#define GLS_OP_glTexSubImage1DEXT                 65523
#define GLS_OP_glTexSubImage2DEXT                 65524
#define GLS_OP_glTexSubImage3DEXT                 65488
#define GLS_OP_glTexSubImage4DSGIS                65461
#define GLS_OP_glTranslated                       367
#define GLS_OP_glTranslatef                       368
#define GLS_OP_glVertex2d                         190
#define GLS_OP_glVertex2dv                        191
#define GLS_OP_glVertex2f                         192
#define GLS_OP_glVertex2fv                        193
#define GLS_OP_glVertex2i                         194
#define GLS_OP_glVertex2iv                        195
#define GLS_OP_glVertex2s                         196
#define GLS_OP_glVertex2sv                        197
#define GLS_OP_glVertex3d                         198
#define GLS_OP_glVertex3dv                        199
#define GLS_OP_glVertex3f                         200
#define GLS_OP_glVertex3fv                        201
#define GLS_OP_glVertex3i                         202
#define GLS_OP_glVertex3iv                        203
#define GLS_OP_glVertex3s                         204
#define GLS_OP_glVertex3sv                        205
#define GLS_OP_glVertex4d                         206
#define GLS_OP_glVertex4dv                        207
#define GLS_OP_glVertex4f                         208
#define GLS_OP_glVertex4fv                        209
#define GLS_OP_glVertex4i                         210
#define GLS_OP_glVertex4iv                        211
#define GLS_OP_glVertex4s                         212
#define GLS_OP_glVertex4sv                        213
#define GLS_OP_glVertexPointerEXT                 65501
#define GLS_OP_glViewport                         369

/*************************************************************/

/* GLS global commands */
extern GLSenum GLS_LINKAGE glsBinary (GLboolean inSwapped);
extern GLSenum GLS_LINKAGE glsCommandAPI (GLSopcode inOpcode);
extern const GLubyte* GLS_LINKAGE glsCommandString (GLSopcode inOpcode);
extern void GLS_LINKAGE glsContext (GLuint inContext);
extern void GLS_LINKAGE glsDeleteContext (GLuint inContext);
extern const GLubyte* GLS_LINKAGE glsEnumString (GLSenum inAPI, GLSenum inEnum);
extern GLuint GLS_LINKAGE glsGenContext (void);
extern GLuint* GLS_LINKAGE glsGetAllContexts (void);
extern GLScommandAlignment* GLS_LINKAGE glsGetCommandAlignment (GLSopcode inOpcode, GLSenum inExternStreamType, GLScommandAlignment *outAlignment);
extern GLbitfield GLS_LINKAGE glsGetCommandAttrib (GLSopcode inOpcode);
extern GLint GLS_LINKAGE glsGetConsti (GLSenum inAttrib);
extern const GLint* GLS_LINKAGE glsGetConstiv (GLSenum inAttrib);
extern const GLubyte* GLS_LINKAGE glsGetConstubz (GLSenum inAttrib);
extern GLuint GLS_LINKAGE glsGetCurrentContext (void);
extern GLint* GLS_LINKAGE glsGetCurrentTime (GLint *outTime);
extern GLSenum GLS_LINKAGE glsGetError (GLboolean inClear);
extern GLint GLS_LINKAGE glsGetOpcodeCount (GLSenum inAPI);
extern const GLSopcode* GLS_LINKAGE glsGetOpcodes (GLSenum inAPI);
extern GLboolean GLS_LINKAGE glsIsContext (GLuint inContext);
extern GLboolean GLS_LINKAGE glsIsExtensionSupported (const GLubyte *inExtension);
extern GLboolean GLS_LINKAGE glsIsUTF8String (const GLubyte *inString);
extern GLlong GLS_LINKAGE glsLong (GLint inHigh, GLuint inLow);
extern GLint GLS_LINKAGE glsLongHigh (GLlong inVal);
extern GLuint GLS_LINKAGE glsLongLow (GLlong inVal);
extern GLSfunc GLS_LINKAGE glsNullCommandFunc (GLSopcode inOpcode);
extern void GLS_LINKAGE glsPixelSetup (void);
extern GLulong GLS_LINKAGE glsULong (GLuint inHigh, GLuint inLow);
extern GLuint GLS_LINKAGE glsULongHigh (GLulong inVal);
extern GLuint GLS_LINKAGE glsULongLow (GLulong inVal);
extern GLint GLS_LINKAGE glsUCS4toUTF8 (GLuint inUCS4, GLubyte *outUTF8);
extern GLubyte* GLS_LINKAGE glsUCStoUTF8z (size_t inUCSbytes, const GLvoid *inUCSz, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* GLS_LINKAGE glsUCS1toUTF8z (const GLubyte *inUCS1z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* GLS_LINKAGE glsUCS2toUTF8z (const GLushort *inUCS2z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* GLS_LINKAGE glsUCS4toUTF8z (const GLuint *inUCS4z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLint GLS_LINKAGE glsUTF8toUCS4 (const GLubyte *inUTF8, GLuint *outUCS4);
extern GLboolean GLS_LINKAGE glsUTF8toUCSz (size_t inUCSbytes, const GLubyte *inUTF8z, size_t inUCSmax, GLvoid *outUCSz);
extern GLboolean GLS_LINKAGE glsUTF8toUCS1z (const GLubyte *inUTF8z, size_t inUCS1max, GLubyte *outUCS1z);
extern GLboolean GLS_LINKAGE glsUTF8toUCS2z (const GLubyte *inUTF8z, size_t inUCS2max, GLushort *outUCS2z);
extern GLboolean GLS_LINKAGE glsUTF8toUCS4z (const GLubyte *inUTF8z, size_t inUCS4max, GLuint *outUCS4z);

/* GLS immediate commands */
extern void GLS_LINKAGE glsAbortCall (GLSenum inMode);
extern GLboolean GLS_LINKAGE glsBeginCapture (const GLubyte *inStreamName, GLSenum inCaptureStreamType, GLbitfield inWriteFlags);
extern void GLS_LINKAGE glsCallArray (GLSenum inExternStreamType, size_t inCount, const GLubyte *inArray);
extern void GLS_LINKAGE glsCaptureFlags (GLSopcode inOpcode, GLbitfield inFlags);
extern void GLS_LINKAGE glsCaptureFunc (GLSenum inTarget, GLScaptureFunc inFunc);
extern void GLS_LINKAGE glsChannel (GLSenum inTarget, FILE *inChannel);
extern void GLS_LINKAGE glsCommandFunc (GLSopcode inOpcode, GLSfunc inFunc);
extern GLSenum GLS_LINKAGE glsCopyStream (const GLubyte *inSource, const GLubyte *inDest, GLSenum inDestType, GLbitfield inWriteFlags);
extern void GLS_LINKAGE glsDataPointer (GLvoid *inPointer);
extern void GLS_LINKAGE glsDeleteReadPrefix (GLuint inIndex);
extern void GLS_LINKAGE glsDeleteStream (const GLubyte *inName);
extern void GLS_LINKAGE glsEndCapture (void);
extern void GLS_LINKAGE glsFlush (GLSenum inFlushType);
extern GLSfunc *GLS_LINKAGE glsGetCaptureDispatchTable(void);
extern GLbitfield GLS_LINKAGE glsGetCaptureFlags (GLSopcode inOpcode);
extern GLSfunc GLS_LINKAGE glsGetCommandFunc (GLSopcode inOpcode);
extern GLSfunc GLS_LINKAGE glsGetContextFunc (GLSenum inAttrib);
extern GLlong GLS_LINKAGE glsGetContextListl (GLSenum inAttrib, GLuint inIndex);
extern const GLubyte* GLS_LINKAGE glsGetContextListubz (GLSenum inAttrib, GLuint inIndex);
extern GLvoid* GLS_LINKAGE glsGetContextPointer (GLSenum inAttrib);
extern GLint GLS_LINKAGE glsGetContexti (GLSenum inAttrib);
extern const GLubyte* GLS_LINKAGE glsGetContextubz (GLSenum inAttrib);
extern GLint GLS_LINKAGE glsGetGLRCi (GLuint inGLRC, GLSenum inAttrib);
extern GLfloat GLS_LINKAGE glsGetHeaderf (GLSenum inAttrib);
extern GLfloat* GLS_LINKAGE glsGetHeaderfv (GLSenum inAttrib, GLfloat *outVec);
extern GLint GLS_LINKAGE glsGetHeaderi (GLSenum inAttrib);
extern GLint* GLS_LINKAGE glsGetHeaderiv (GLSenum inAttrib, GLint *outVec);
extern const GLubyte* GLS_LINKAGE glsGetHeaderubz (GLSenum inAttrib);
extern GLfloat GLS_LINKAGE glsGetLayerf (GLuint inLayer, GLSenum inAttrib);
extern GLint GLS_LINKAGE glsGetLayeri (GLuint inLayer, GLSenum inAttrib);
extern GLbitfield GLS_LINKAGE glsGetStreamAttrib (const GLubyte *inName);
extern GLuint GLS_LINKAGE glsGetStreamCRC32 (const GLubyte *inName);
extern const GLubyte* GLS_LINKAGE glsGetStreamReadName (const GLubyte *inName);
extern size_t GLS_LINKAGE glsGetStreamSize (const GLubyte *inName);
extern GLSenum GLS_LINKAGE glsGetStreamType (const GLubyte *inName);
extern GLboolean GLS_LINKAGE glsIsContextStream (const GLubyte *inName);
extern void GLS_LINKAGE glsPixelSetupGen (GLboolean inEnabled);
extern void GLS_LINKAGE glsReadFunc (GLSreadFunc inFunc);
extern void GLS_LINKAGE glsReadPrefix (GLSenum inListOp, const GLubyte *inPrefix);
extern void GLS_LINKAGE glsUnreadFunc (GLSwriteFunc inFunc);
extern void GLS_LINKAGE glsWriteFunc (GLSwriteFunc inFunc);
extern void GLS_LINKAGE glsWritePrefix (const GLubyte *inPrefix);

/* GLS encodable commands */
extern void GLS_LINKAGE glsBeginGLS (GLint inVersionMajor, GLint inVersionMinor);
extern void GLS_LINKAGE glsBlock (GLSenum inBlockType);
extern GLSenum GLS_LINKAGE glsCallStream (const GLubyte *inName);
extern void GLS_LINKAGE glsEndGLS (void);
extern void GLS_LINKAGE glsError (GLSopcode inOpcode, GLSenum inError);
extern void GLS_LINKAGE glsGLRC (GLuint inGLRC);
extern void GLS_LINKAGE glsGLRCLayer (GLuint inGLRC, GLuint inLayer, GLuint inReadLayer);
extern void GLS_LINKAGE glsHeaderGLRCi (GLuint inGLRC, GLSenum inAttrib, GLint inVal);
extern void GLS_LINKAGE glsHeaderLayerf (GLuint inLayer, GLSenum inAttrib, GLfloat inVal);
extern void GLS_LINKAGE glsHeaderLayeri (GLuint inLayer, GLSenum inAttrib, GLint inVal);
extern void GLS_LINKAGE glsHeaderf (GLSenum inAttrib, GLfloat inVal);
extern void GLS_LINKAGE glsHeaderfv (GLSenum inAttrib, const GLfloat *inVec);
extern void GLS_LINKAGE glsHeaderi (GLSenum inAttrib, GLint inVal);
extern void GLS_LINKAGE glsHeaderiv (GLSenum inAttrib, const GLint *inVec);
extern void GLS_LINKAGE glsHeaderubz (GLSenum inAttrib, const GLubyte *inString);
extern void GLS_LINKAGE glsRequireExtension (const GLubyte *inExtension);
extern void GLS_LINKAGE glsUnsupportedCommand (void);

/* GLS encodable-nop commands */
extern void GLS_LINKAGE glsAppRef (GLulong inAddress, GLuint inCount);
extern void GLS_LINKAGE glsBeginObj (const GLubyte *inTag);
extern void GLS_LINKAGE glsCharubz (const GLubyte *inTag, const GLubyte *inString);
extern void GLS_LINKAGE glsComment (const GLubyte *inComment);
extern void GLS_LINKAGE glsDisplayMapfv (GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec);
extern void GLS_LINKAGE glsEndObj (void);
extern void GLS_LINKAGE glsNumb (const GLubyte *inTag, GLbyte inVal);
extern void GLS_LINKAGE glsNumbv (const GLubyte *inTag, GLuint inCount, const GLbyte *inVec);
extern void GLS_LINKAGE glsNumd (const GLubyte *inTag, GLdouble inVal);
extern void GLS_LINKAGE glsNumdv (const GLubyte *inTag, GLuint inCount, const GLdouble *inVec);
extern void GLS_LINKAGE glsNumf (const GLubyte *inTag, GLfloat inVal);
extern void GLS_LINKAGE glsNumfv (const GLubyte *inTag, GLuint inCount, const GLfloat *inVec);
extern void GLS_LINKAGE glsNumi (const GLubyte *inTag, GLint inVal);
extern void GLS_LINKAGE glsNumiv (const GLubyte *inTag, GLuint inCount, const GLint *inVec);
extern void GLS_LINKAGE glsNuml (const GLubyte *inTag, GLlong inVal);
extern void GLS_LINKAGE glsNumlv (const GLubyte *inTag, GLuint inCount, const GLlong *inVec);
extern void GLS_LINKAGE glsNums (const GLubyte *inTag, GLshort inVal);
extern void GLS_LINKAGE glsNumsv (const GLubyte *inTag, GLuint inCount, const GLshort *inVec);
extern void GLS_LINKAGE glsNumub (const GLubyte *inTag, GLubyte inVal);
extern void GLS_LINKAGE glsNumubv (const GLubyte *inTag, GLuint inCount, const GLubyte *inVec);
extern void GLS_LINKAGE glsNumui (const GLubyte *inTag, GLuint inVal);
extern void GLS_LINKAGE glsNumuiv (const GLubyte *inTag, GLuint inCount, const GLuint *inVec);
extern void GLS_LINKAGE glsNumul (const GLubyte *inTag, GLulong inVal);
extern void GLS_LINKAGE glsNumulv (const GLubyte *inTag, GLuint inCount, const GLulong *inVec);
extern void GLS_LINKAGE glsNumus (const GLubyte *inTag, GLushort inVal);
extern void GLS_LINKAGE glsNumusv (const GLubyte *inTag, GLuint inCount, const GLushort *inVec);
extern void GLS_LINKAGE glsPad (void);
extern void GLS_LINKAGE glsSwapBuffers (GLuint inLayer);

#if defined(__cplusplus)
    }
#endif /* defined(__cplusplus) */

#endif /* defined(__gls_h_) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\inc\gls_ref.h ===
#if !defined(__gls_h_)
#define __gls_h_

/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#define GLS_LINKAGE

#include <GL/gl.h>
#include <stddef.h>
#include <stdio.h>

#if defined(__cplusplus)
    extern "C" {
#endif /* defined(__cplusplus) */

typedef struct {GLuint uint0; GLuint uint1;} GLlong;
typedef struct {GLuint uint0; GLuint uint1;} GLulong;

typedef GLuint GLSenum;
typedef GLuint GLSopcode;

typedef struct {
    GLuint mask;
    GLuint value;
} GLScommandAlignment;

typedef void (*GLScaptureFunc)(GLSopcode inOpcode);
typedef size_t (*GLSreadFunc)(size_t inCount, GLubyte *outBuf);
typedef size_t (*GLSwriteFunc)(size_t inCount, const GLubyte *inBuf);

#if defined(__cplusplus)
    typedef void (*GLSfunc)(...);
#else /* !defined(__cplusplus) */
    typedef void (*GLSfunc)();
#endif /* defined(__cplusplus) */

#define glsCSTR(p) ((const GLubyte*)(p))
#define glsSTR(p)  ((GLubyte*)(p))

/*************************************************************/

/* CaptureFlags */
/*      GLS_NONE */
#define GLS_CAPTURE_EXECUTE_BIT                   0x00000001
#define GLS_CAPTURE_WRITE_BIT                     0x00000002

/* CommandAttrib */
/*      GLS_NONE */
#define GLS_COMMAND_GEN_BIT                       0x00000001
#define GLS_COMMAND_GET_BIT                       0x00000002
#define GLS_COMMAND_REPLY_BIT                     0x00000004

/* ImageFlags */
/*      GLS_NONE */
#define GLS_IMAGE_NULL_BIT                        0x00000001

/* StreamAttrib */
/*      GLS_NONE */
#define GLS_STREAM_CONTEXT_BIT                    0x00000001
#define GLS_STREAM_NAMED_BIT                      0x00000002
#define GLS_STREAM_READABLE_BIT                   0x00000004
#define GLS_STREAM_SEEKABLE_BIT                   0x00000008
#define GLS_STREAM_WRITABLE_BIT                   0x00000010

/* WriteFlags */
/*      GLS_NONE */
#define GLS_WRITE_APPEND_BIT                      0x00000001

/* Fundamental */
#define GLS_NONE                                  0x0000

/* AbortMode */
/*      GLS_NONE */
#define GLS_ALL                                   0x0010
#define GLS_LAST                                  0x0011

/* API */
#define GLS_API_GLS                               0x0020
#define GLS_API_GL                                0x0021

/* BlockType */
#define GLS_FRAME                                 0x0030
#define GLS_HEADER                                0x0031
#define GLS_INIT                                  0x0032
#define GLS_STATIC                                0x0033

/* CaptureFuncTarget */
#define GLS_CAPTURE_ENTRY_FUNC                    0x0040
#define GLS_CAPTURE_EXIT_FUNC                     0x0041

/* CaptureStreamType */
#define GLS_CONTEXT                               0x0050
#define GLS_BINARY_LSB_FIRST                      0x0051
#define GLS_BINARY_MSB_FIRST                      0x0052
#define GLS_TEXT                                  0x0053

/* ChannelTarget */
#define GLS_DEFAULT_READ_CHANNEL                  0x0060
#define GLS_DEFAULT_WRITE_CHANNEL                 0x0061

/* Consti */
#define GLS_API_COUNT                             0x0070
#define GLS_MAX_CALL_NESTING                      0x0071
#define GLS_MAX_CAPTURE_NESTING                   0x0072
#define GLS_VERSION_MAJOR                         0x0073
#define GLS_VERSION_MINOR                         0x0074

/* Constiv */
#define GLS_ALL_APIS                              0x0080

/* Constubz */
#define GLS_EXTENSIONS                            0x0090
#define GLS_PLATFORM                              0x0091
#define GLS_RELEASE                               0x0092
#define GLS_VENDOR                                0x0093

/* ContextFunc */
/*      GLS_CAPTURE_ENTRY_FUNC */
/*      GLS_CAPTURE_EXIT_FUNC */
#define GLS_READ_FUNC                             0x00A1
#define GLS_UNREAD_FUNC                           0x00A2
#define GLS_WRITE_FUNC                            0x00A3

/* ContextListl */
#define GLS_OUT_ARG_LIST                          0x00B0

/* ContextListubz */
#define GLS_CONTEXT_STREAM_LIST                   0x00C0
#define GLS_READ_PREFIX_LIST                      0x00C1

/* ContextPointer */
/*      GLS_DEFAULT_READ_CHANNEL */
/*      GLS_DEFAULT_WRITE_CHANNEL */
#define GLS_DATA_POINTER                          0x00E0

/* Contexti */
#define GLS_ABORT_MODE                            0x00E0
#define GLS_BLOCK_TYPE                            0x00E1
#define GLS_CALL_NESTING                          0x00E2
#define GLS_CAPTURE_NESTING                       0x00E3
#define GLS_CONTEXT_STREAM_COUNT                  0x00E4
#define GLS_CURRENT_GLRC                          0x00E5
#define GLS_OUT_ARG_COUNT                         0x00E6
#define GLS_PIXEL_SETUP_GEN                       0x00E7
#define GLS_READ_PREFIX_COUNT                     0x00E8
#define GLS_STREAM_VERSION_MAJOR                  0x00E9
#define GLS_STREAM_VERSION_MINOR                  0x00EA

/* Contextubz */
#define GLS_WRITE_PREFIX                          0x0100

/* CopyStreamType */
/*      GLS_NONE */
/*      GLS_CONTEXT */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */

/* DisplayFormat */
#define GLS_IIII                                  0x0110
#define GLS_RGBA                                  0x0111
#define GLS_RRRA                                  0x0112

/* DisplayMap */
#define GLS_DISPLAY_MAP_I_TO_R                    0x0120
#define GLS_DISPLAY_MAP_I_TO_G                    0x0121
#define GLS_DISPLAY_MAP_I_TO_B                    0x0122
#define GLS_DISPLAY_MAP_I_TO_A                    0x0123

/* ErrorCode */
/*      GLS_NONE */
#define GLS_CALL_OVERFLOW                         0x0130
#define GLS_DECODE_ERROR                          0x0131
#define GLS_ENCODE_ERROR                          0x0132
#define GLS_INVALID_ENUM                          0x0133
#define GLS_INVALID_OPERATION                     0x0134
#define GLS_INVALID_STREAM                        0x0135
#define GLS_INVALID_STRING                        0x0136
#define GLS_INVALID_VALUE                         0x0137
#define GLS_NOT_FOUND                             0x0138
#define GLS_OUT_OF_MEMORY                         0x0139
#define GLS_STREAM_CLOSE_ERROR                    0x013A
#define GLS_STREAM_DELETE_ERROR                   0x013B
#define GLS_STREAM_OPEN_ERROR                     0x013C
#define GLS_STREAM_READ_ERROR                     0x013D
#define GLS_STREAM_WRITE_ERROR                    0x013E
#define GLS_UNSUPPORTED_COMMAND                   0x013F
#define GLS_UNSUPPORTED_EXTENSION                 0x0140

/* ExternStreamType */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */

/* FlushType */
/*      GLS_ALL */
/*      GLS_LAST */

/* GetStreamType */
/*      GLS_NONE */
/*      GLS_CONTEXT */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */
#define GLS_UNKNOWN                               0x0150

/* GLRCi */
#define GLS_LAYER                                 0x0160
#define GLS_READ_LAYER                            0x0161
#define GLS_SHARE_GLRC                            0x0162

/* Headerf */
#define GLS_ASPECT                                0x0170
#define GLS_BORDER_WIDTH                          0x0171
#define GLS_CONTRAST_RATIO                        0x0172
#define GLS_HEIGHT_MM                             0x0173

/* Headerfv */
#define GLS_BORDER_COLOR                          0x0180
#define GLS_GAMMA                                 0x0181
#define GLS_ORIGIN                                0x0182
#define GLS_PAGE_COLOR                            0x0183
#define GLS_PAGE_SIZE                             0x0184
#define GLS_RED_POINT                             0x0185
#define GLS_GREEN_POINT                           0x0186
#define GLS_BLUE_POINT                            0x0187
#define GLS_WHITE_POINT                           0x0188

/* Headeri */
#define GLS_FRAME_COUNT                           0x01A0
#define GLS_GLRC_COUNT                            0x01A1
#define GLS_HEIGHT_PIXELS                         0x01A2
#define GLS_LAYER_COUNT                           0x01A3
#define GLS_TILEABLE                              0x01A4

/* Headeriv */
#define GLS_CREATE_TIME                           0x01B0
#define GLS_MODIFY_TIME                           0x01B1

/* Headerubz */
/*      GLS_EXTENSIONS */
#define GLS_AUTHOR                                0x01C0
#define GLS_DESCRIPTION                           0x01C1
#define GLS_NOTES                                 0x01C2
#define GLS_TITLE                                 0x01C3
#define GLS_TOOLS                                 0x01C4
#define GLS_VERSION                               0x01C5

/* Layerf */
#define GLS_INVISIBLE_ASPECT                      0x01D0

/* Layeri */
#define GLS_DISPLAY_FORMAT                        0x01E0
#define GLS_DOUBLEBUFFER                          0x01E1
#define GLS_INVISIBLE                             0x01E2
#define GLS_INVISIBLE_HEIGHT_PIXELS               0x01E3
#define GLS_LEVEL                                 0x01E4
#define GLS_STEREO                                0x01E5
#define GLS_TRANSPARENT                           0x01E6
#define GLS_INDEX_BITS                            0x01E7
#define GLS_RED_BITS                              0x01E8
#define GLS_GREEN_BITS                            0x01E9
#define GLS_BLUE_BITS                             0x01EA
#define GLS_ALPHA_BITS                            0x01EB
#define GLS_DEPTH_BITS                            0x01EC
#define GLS_STENCIL_BITS                          0x01ED
#define GLS_ACCUM_RED_BITS                        0x01EE
#define GLS_ACCUM_GREEN_BITS                      0x01EF
#define GLS_ACCUM_BLUE_BITS                       0x01F0
#define GLS_ACCUM_ALPHA_BITS                      0x01F1
#define GLS_AUX_BUFFERS                           0x01F2
/*      GLS_SAMPLE_BUFFERS_SGIS */
/*      GLS_SAMPLES_SGIS */

/* ListOp */
#define GLS_APPEND                                0x0200
#define GLS_PREPEND                               0x0201

/* GL_SGIS_multisample */
#define GLS_SAMPLE_BUFFERS_SGIS                   0x0400
#define GLS_SAMPLES_SGIS                          0x0401

/* GLS opcodes */
#define GLS_OP_glsBeginGLS                        16
#define GLS_OP_glsBlock                           17
#define GLS_OP_glsCallStream                      18
#define GLS_OP_glsEndGLS                          19
#define GLS_OP_glsError                           20
#define GLS_OP_glsGLRC                            21
#define GLS_OP_glsGLRCLayer                       22
#define GLS_OP_glsHeaderGLRCi                     23
#define GLS_OP_glsHeaderLayerf                    24
#define GLS_OP_glsHeaderLayeri                    25
#define GLS_OP_glsHeaderf                         26
#define GLS_OP_glsHeaderfv                        27
#define GLS_OP_glsHeaderi                         28
#define GLS_OP_glsHeaderiv                        29
#define GLS_OP_glsHeaderubz                       30
#define GLS_OP_glsRequireExtension                31
#define GLS_OP_glsUnsupportedCommand              32
#define GLS_OP_glsAppRef                          33
#define GLS_OP_glsBeginObj                        34
#define GLS_OP_glsCharubz                         35
#define GLS_OP_glsComment                         36
#define GLS_OP_glsDisplayMapfv                    37
#define GLS_OP_glsEndObj                          38
#define GLS_OP_glsNumb                            39
#define GLS_OP_glsNumbv                           40
#define GLS_OP_glsNumd                            41
#define GLS_OP_glsNumdv                           42
#define GLS_OP_glsNumf                            43
#define GLS_OP_glsNumfv                           44
#define GLS_OP_glsNumi                            45
#define GLS_OP_glsNumiv                           46
#define GLS_OP_glsNuml                            47
#define GLS_OP_glsNumlv                           48
#define GLS_OP_glsNums                            49
#define GLS_OP_glsNumsv                           50
#define GLS_OP_glsNumub                           51
#define GLS_OP_glsNumubv                          52
#define GLS_OP_glsNumui                           53
#define GLS_OP_glsNumuiv                          54
#define GLS_OP_glsNumul                           55
#define GLS_OP_glsNumulv                          56
#define GLS_OP_glsNumus                           57
#define GLS_OP_glsNumusv                          58
#define GLS_OP_glsPad                             59
#define GLS_OP_glsSwapBuffers                     60

/* GL opcodes */
#define GLS_OP_glAccum                            277
#define GLS_OP_glAlphaFunc                        304
#define GLS_OP_glAreTexturesResidentEXT           65502
#define GLS_OP_glArrayElementEXT                  65493
#define GLS_OP_glBegin                            71
#define GLS_OP_glBindTextureEXT                   65503
#define GLS_OP_glBitmap                           72
#define GLS_OP_glBlendColorEXT                    65520
#define GLS_OP_glBlendEquationEXT                 65521
#define GLS_OP_glBlendFunc                        305
#define GLS_OP_glCallList                         66
#define GLS_OP_glCallLists                        67
#define GLS_OP_glClear                            267
#define GLS_OP_glClearAccum                       268
#define GLS_OP_glClearColor                       270
#define GLS_OP_glClearDepth                       272
#define GLS_OP_glClearIndex                       269
#define GLS_OP_glClearStencil                     271
#define GLS_OP_glClipPlane                        214
#define GLS_OP_glColor3b                          73
#define GLS_OP_glColor3bv                         74
#define GLS_OP_glColor3d                          75
#define GLS_OP_glColor3dv                         76
#define GLS_OP_glColor3f                          77
#define GLS_OP_glColor3fv                         78
#define GLS_OP_glColor3i                          79
#define GLS_OP_glColor3iv                         80
#define GLS_OP_glColor3s                          81
#define GLS_OP_glColor3sv                         82
#define GLS_OP_glColor3ub                         83
#define GLS_OP_glColor3ubv                        84
#define GLS_OP_glColor3ui                         85
#define GLS_OP_glColor3uiv                        86
#define GLS_OP_glColor3us                         87
#define GLS_OP_glColor3usv                        88
#define GLS_OP_glColor4b                          89
#define GLS_OP_glColor4bv                         90
#define GLS_OP_glColor4d                          91
#define GLS_OP_glColor4dv                         92
#define GLS_OP_glColor4f                          93
#define GLS_OP_glColor4fv                         94
#define GLS_OP_glColor4i                          95
#define GLS_OP_glColor4iv                         96
#define GLS_OP_glColor4s                          97
#define GLS_OP_glColor4sv                         98
#define GLS_OP_glColor4ub                         99
#define GLS_OP_glColor4ubv                        100
#define GLS_OP_glColor4ui                         101
#define GLS_OP_glColor4uiv                        102
#define GLS_OP_glColor4us                         103
#define GLS_OP_glColor4usv                        104
#define GLS_OP_glColorMask                        274
#define GLS_OP_glColorMaterial                    215
#define GLS_OP_glColorPointerEXT                  65494
#define GLS_OP_glColorTableParameterfvSGI         65477
#define GLS_OP_glColorTableParameterivSGI         65478
#define GLS_OP_glColorTableSGI                    65476
#define GLS_OP_glConvolutionFilter1DEXT           65528
#define GLS_OP_glConvolutionFilter2DEXT           65529
#define GLS_OP_glConvolutionParameterfEXT         65530
#define GLS_OP_glConvolutionParameterfvEXT        65531
#define GLS_OP_glConvolutionParameteriEXT         65532
#define GLS_OP_glConvolutionParameterivEXT        65533
#define GLS_OP_glCopyColorTableSGI                65479
#define GLS_OP_glCopyConvolutionFilter1DEXT       65534
#define GLS_OP_glCopyConvolutionFilter2DEXT       65535
#define GLS_OP_glCopyPixels                       319
#define GLS_OP_glCopyTexImage1DEXT                65487
#define GLS_OP_glCopyTexImage2DEXT                65456
#define GLS_OP_glCopyTexSubImage1DEXT             65457
#define GLS_OP_glCopyTexSubImage2DEXT             65458
#define GLS_OP_glCopyTexSubImage3DEXT             65459
#define GLS_OP_glCullFace                         216
#define GLS_OP_glDeleteLists                      68
#define GLS_OP_glDeleteTexturesEXT                65472
#define GLS_OP_glDepthFunc                        309
#define GLS_OP_glDepthMask                        275
#define GLS_OP_glDepthRange                       352
#define GLS_OP_glDetailTexFuncSGIS                65489
#define GLS_OP_glDisable                          278
#define GLS_OP_glDrawArraysEXT                    65495
#define GLS_OP_glDrawBuffer                       266
#define GLS_OP_glDrawPixels                       321
#define GLS_OP_glEdgeFlag                         105
#define GLS_OP_glEdgeFlagPointerEXT               65496
#define GLS_OP_glEdgeFlagv                        106
#define GLS_OP_glEnable                           279
#define GLS_OP_glEnd                              107
#define GLS_OP_glEndList                          65
#define GLS_OP_glEvalCoord1d                      292
#define GLS_OP_glEvalCoord1dv                     293
#define GLS_OP_glEvalCoord1f                      294
#define GLS_OP_glEvalCoord1fv                     295
#define GLS_OP_glEvalCoord2d                      296
#define GLS_OP_glEvalCoord2dv                     297
#define GLS_OP_glEvalCoord2f                      298
#define GLS_OP_glEvalCoord2fv                     299
#define GLS_OP_glEvalMesh1                        300
#define GLS_OP_glEvalMesh2                        302
#define GLS_OP_glEvalPoint1                       301
#define GLS_OP_glEvalPoint2                       303
#define GLS_OP_glFeedbackBuffer                   258
#define GLS_OP_glFinish                           280
#define GLS_OP_glFlush                            281
#define GLS_OP_glFogf                             217
#define GLS_OP_glFogfv                            218
#define GLS_OP_glFogi                             219
#define GLS_OP_glFogiv                            220
#define GLS_OP_glFrontFace                        221
#define GLS_OP_glFrustum                          353
#define GLS_OP_glGenLists                         69
#define GLS_OP_glGenTexturesEXT                   65473
#define GLS_OP_glGetBooleanv                      322
#define GLS_OP_glGetClipPlane                     323
#define GLS_OP_glGetColorTableParameterfvSGI      65481
#define GLS_OP_glGetColorTableParameterivSGI      65482
#define GLS_OP_glGetColorTableSGI                 65480
#define GLS_OP_glGetConvolutionFilterEXT          65504
#define GLS_OP_glGetConvolutionParameterfvEXT     65505
#define GLS_OP_glGetConvolutionParameterivEXT     65506
#define GLS_OP_glGetDetailTexFuncSGIS             65490
#define GLS_OP_glGetDoublev                       324
#define GLS_OP_glGetError                         325
#define GLS_OP_glGetFloatv                        326
#define GLS_OP_glGetHistogramEXT                  65509
#define GLS_OP_glGetHistogramParameterfvEXT       65510
#define GLS_OP_glGetHistogramParameterivEXT       65511
#define GLS_OP_glGetIntegerv                      327
#define GLS_OP_glGetLightfv                       328
#define GLS_OP_glGetLightiv                       329
#define GLS_OP_glGetMapdv                         330
#define GLS_OP_glGetMapfv                         331
#define GLS_OP_glGetMapiv                         332
#define GLS_OP_glGetMaterialfv                    333
#define GLS_OP_glGetMaterialiv                    334
#define GLS_OP_glGetMinmaxEXT                     65512
#define GLS_OP_glGetMinmaxParameterfvEXT          65513
#define GLS_OP_glGetMinmaxParameterivEXT          65514
#define GLS_OP_glGetPixelMapfv                    335
#define GLS_OP_glGetPixelMapuiv                   336
#define GLS_OP_glGetPixelMapusv                   337
#define GLS_OP_glGetPointervEXT                   65497
#define GLS_OP_glGetPolygonStipple                338
#define GLS_OP_glGetSeparableFilterEXT            65507
#define GLS_OP_glGetSharpenTexFuncSGIS            65492
#define GLS_OP_glGetString                        339
#define GLS_OP_glGetTexColorTableParameterfvSGI   65483
#define GLS_OP_glGetTexColorTableParameterivSGI   65484
#define GLS_OP_glGetTexEnvfv                      340
#define GLS_OP_glGetTexEnviv                      341
#define GLS_OP_glGetTexGendv                      342
#define GLS_OP_glGetTexGenfv                      343
#define GLS_OP_glGetTexGeniv                      344
#define GLS_OP_glGetTexImage                      345
#define GLS_OP_glGetTexLevelParameterfv           348
#define GLS_OP_glGetTexLevelParameteriv           349
#define GLS_OP_glGetTexParameterfv                346
#define GLS_OP_glGetTexParameteriv                347
#define GLS_OP_glHint                             222
#define GLS_OP_glHistogramEXT                     65515
#define GLS_OP_glIndexMask                        276
#define GLS_OP_glIndexPointerEXT                  65498
#define GLS_OP_glIndexd                           108
#define GLS_OP_glIndexdv                          109
#define GLS_OP_glIndexf                           110
#define GLS_OP_glIndexfv                          111
#define GLS_OP_glIndexi                           112
#define GLS_OP_glIndexiv                          113
#define GLS_OP_glIndexs                           114
#define GLS_OP_glIndexsv                          115
#define GLS_OP_glInitNames                        261
#define GLS_OP_glIsEnabled                        350
#define GLS_OP_glIsList                           351
#define GLS_OP_glIsTextureEXT                     65474
#define GLS_OP_glLightModelf                      227
#define GLS_OP_glLightModelfv                     228
#define GLS_OP_glLightModeli                      229
#define GLS_OP_glLightModeliv                     230
#define GLS_OP_glLightf                           223
#define GLS_OP_glLightfv                          224
#define GLS_OP_glLighti                           225
#define GLS_OP_glLightiv                          226
#define GLS_OP_glLineStipple                      231
#define GLS_OP_glLineWidth                        232
#define GLS_OP_glListBase                         70
#define GLS_OP_glLoadIdentity                     354
#define GLS_OP_glLoadMatrixd                      356
#define GLS_OP_glLoadMatrixf                      355
#define GLS_OP_glLoadName                         262
#define GLS_OP_glLogicOp                          306
#define GLS_OP_glMap1d                            284
#define GLS_OP_glMap1f                            285
#define GLS_OP_glMap2d                            286
#define GLS_OP_glMap2f                            287
#define GLS_OP_glMapGrid1d                        288
#define GLS_OP_glMapGrid1f                        289
#define GLS_OP_glMapGrid2d                        290
#define GLS_OP_glMapGrid2f                        291
#define GLS_OP_glMaterialf                        233
#define GLS_OP_glMaterialfv                       234
#define GLS_OP_glMateriali                        235
#define GLS_OP_glMaterialiv                       236
#define GLS_OP_glMatrixMode                       357
#define GLS_OP_glMinmaxEXT                        65516
#define GLS_OP_glMultMatrixd                      359
#define GLS_OP_glMultMatrixf                      358
#define GLS_OP_glNewList                          64
#define GLS_OP_glNormal3b                         116
#define GLS_OP_glNormal3bv                        117
#define GLS_OP_glNormal3d                         118
#define GLS_OP_glNormal3dv                        119
#define GLS_OP_glNormal3f                         120
#define GLS_OP_glNormal3fv                        121
#define GLS_OP_glNormal3i                         122
#define GLS_OP_glNormal3iv                        123
#define GLS_OP_glNormal3s                         124
#define GLS_OP_glNormal3sv                        125
#define GLS_OP_glNormalPointerEXT                 65499
#define GLS_OP_glOrtho                            360
#define GLS_OP_glPassThrough                      263
#define GLS_OP_glPixelMapfv                       315
#define GLS_OP_glPixelMapuiv                      316
#define GLS_OP_glPixelMapusv                      317
#define GLS_OP_glPixelStoref                      313
#define GLS_OP_glPixelStorei                      314
#define GLS_OP_glPixelTexGenSGIX                  65462
#define GLS_OP_glPixelTransferf                   311
#define GLS_OP_glPixelTransferi                   312
#define GLS_OP_glPixelZoom                        310
#define GLS_OP_glPointSize                        237
#define GLS_OP_glPolygonMode                      238
#define GLS_OP_glPolygonOffsetEXT                 65522
#define GLS_OP_glPolygonStipple                   239
#define GLS_OP_glPopAttrib                        282
#define GLS_OP_glPopMatrix                        361
#define GLS_OP_glPopName                          264
#define GLS_OP_glPrioritizeTexturesEXT            65475
#define GLS_OP_glPushAttrib                       283
#define GLS_OP_glPushMatrix                       362
#define GLS_OP_glPushName                         265
#define GLS_OP_glRasterPos2d                      126
#define GLS_OP_glRasterPos2dv                     127
#define GLS_OP_glRasterPos2f                      128
#define GLS_OP_glRasterPos2fv                     129
#define GLS_OP_glRasterPos2i                      130
#define GLS_OP_glRasterPos2iv                     131
#define GLS_OP_glRasterPos2s                      132
#define GLS_OP_glRasterPos2sv                     133
#define GLS_OP_glRasterPos3d                      134
#define GLS_OP_glRasterPos3dv                     135
#define GLS_OP_glRasterPos3f                      136
#define GLS_OP_glRasterPos3fv                     137
#define GLS_OP_glRasterPos3i                      138
#define GLS_OP_glRasterPos3iv                     139
#define GLS_OP_glRasterPos3s                      140
#define GLS_OP_glRasterPos3sv                     141
#define GLS_OP_glRasterPos4d                      142
#define GLS_OP_glRasterPos4dv                     143
#define GLS_OP_glRasterPos4f                      144
#define GLS_OP_glRasterPos4fv                     145
#define GLS_OP_glRasterPos4i                      146
#define GLS_OP_glRasterPos4iv                     147
#define GLS_OP_glRasterPos4s                      148
#define GLS_OP_glRasterPos4sv                     149
#define GLS_OP_glReadBuffer                       318
#define GLS_OP_glReadPixels                       320
#define GLS_OP_glRectd                            150
#define GLS_OP_glRectdv                           151
#define GLS_OP_glRectf                            152
#define GLS_OP_glRectfv                           153
#define GLS_OP_glRecti                            154
#define GLS_OP_glRectiv                           155
#define GLS_OP_glRects                            156
#define GLS_OP_glRectsv                           157
#define GLS_OP_glRenderMode                       260
#define GLS_OP_glResetHistogramEXT                65517
#define GLS_OP_glResetMinmaxEXT                   65518
#define GLS_OP_glRotated                          363
#define GLS_OP_glRotatef                          364
#define GLS_OP_glSampleMaskSGIS                   65525
#define GLS_OP_glSamplePatternSGIS                65526
#define GLS_OP_glScaled                           365
#define GLS_OP_glScalef                           366
#define GLS_OP_glScissor                          240
#define GLS_OP_glSelectBuffer                     259
#define GLS_OP_glSeparableFilter2DEXT             65508
#define GLS_OP_glShadeModel                       241
#define GLS_OP_glSharpenTexFuncSGIS               65491
#define GLS_OP_glStencilFunc                      307
#define GLS_OP_glStencilMask                      273
#define GLS_OP_glStencilOp                        308
#define GLS_OP_glTagSampleBufferSGIX              65527
#define GLS_OP_glTexColorTableParameterfvSGI      65485
#define GLS_OP_glTexColorTableParameterivSGI      65486
#define GLS_OP_glTexCoord1d                       158
#define GLS_OP_glTexCoord1dv                      159
#define GLS_OP_glTexCoord1f                       160
#define GLS_OP_glTexCoord1fv                      161
#define GLS_OP_glTexCoord1i                       162
#define GLS_OP_glTexCoord1iv                      163
#define GLS_OP_glTexCoord1s                       164
#define GLS_OP_glTexCoord1sv                      165
#define GLS_OP_glTexCoord2d                       166
#define GLS_OP_glTexCoord2dv                      167
#define GLS_OP_glTexCoord2f                       168
#define GLS_OP_glTexCoord2fv                      169
#define GLS_OP_glTexCoord2i                       170
#define GLS_OP_glTexCoord2iv                      171
#define GLS_OP_glTexCoord2s                       172
#define GLS_OP_glTexCoord2sv                      173
#define GLS_OP_glTexCoord3d                       174
#define GLS_OP_glTexCoord3dv                      175
#define GLS_OP_glTexCoord3f                       176
#define GLS_OP_glTexCoord3fv                      177
#define GLS_OP_glTexCoord3i                       178
#define GLS_OP_glTexCoord3iv                      179
#define GLS_OP_glTexCoord3s                       180
#define GLS_OP_glTexCoord3sv                      181
#define GLS_OP_glTexCoord4d                       182
#define GLS_OP_glTexCoord4dv                      183
#define GLS_OP_glTexCoord4f                       184
#define GLS_OP_glTexCoord4fv                      185
#define GLS_OP_glTexCoord4i                       186
#define GLS_OP_glTexCoord4iv                      187
#define GLS_OP_glTexCoord4s                       188
#define GLS_OP_glTexCoord4sv                      189
#define GLS_OP_glTexCoordPointerEXT               65500
#define GLS_OP_glTexEnvf                          248
#define GLS_OP_glTexEnvfv                         249
#define GLS_OP_glTexEnvi                          250
#define GLS_OP_glTexEnviv                         251
#define GLS_OP_glTexGend                          252
#define GLS_OP_glTexGendv                         253
#define GLS_OP_glTexGenf                          254
#define GLS_OP_glTexGenfv                         255
#define GLS_OP_glTexGeni                          256
#define GLS_OP_glTexGeniv                         257
#define GLS_OP_glTexImage1D                       246
#define GLS_OP_glTexImage2D                       247
#define GLS_OP_glTexImage3DEXT                    65519
#define GLS_OP_glTexImage4DSGIS                   65460
#define GLS_OP_glTexParameterf                    242
#define GLS_OP_glTexParameterfv                   243
#define GLS_OP_glTexParameteri                    244
#define GLS_OP_glTexParameteriv                   245
#define GLS_OP_glTexSubImage1DEXT                 65523
#define GLS_OP_glTexSubImage2DEXT                 65524
#define GLS_OP_glTexSubImage3DEXT                 65488
#define GLS_OP_glTexSubImage4DSGIS                65461
#define GLS_OP_glTranslated                       367
#define GLS_OP_glTranslatef                       368
#define GLS_OP_glVertex2d                         190
#define GLS_OP_glVertex2dv                        191
#define GLS_OP_glVertex2f                         192
#define GLS_OP_glVertex2fv                        193
#define GLS_OP_glVertex2i                         194
#define GLS_OP_glVertex2iv                        195
#define GLS_OP_glVertex2s                         196
#define GLS_OP_glVertex2sv                        197
#define GLS_OP_glVertex3d                         198
#define GLS_OP_glVertex3dv                        199
#define GLS_OP_glVertex3f                         200
#define GLS_OP_glVertex3fv                        201
#define GLS_OP_glVertex3i                         202
#define GLS_OP_glVertex3iv                        203
#define GLS_OP_glVertex3s                         204
#define GLS_OP_glVertex3sv                        205
#define GLS_OP_glVertex4d                         206
#define GLS_OP_glVertex4dv                        207
#define GLS_OP_glVertex4f                         208
#define GLS_OP_glVertex4fv                        209
#define GLS_OP_glVertex4i                         210
#define GLS_OP_glVertex4iv                        211
#define GLS_OP_glVertex4s                         212
#define GLS_OP_glVertex4sv                        213
#define GLS_OP_glVertexPointerEXT                 65501
#define GLS_OP_glViewport                         369

/*************************************************************/

/* GLS global commands */
extern GLSenum glsBinary (GLboolean inSwapped);
extern GLSenum glsCommandAPI (GLSopcode inOpcode);
extern const GLubyte* glsCommandString (GLSopcode inOpcode);
extern void glsContext (GLuint inContext);
extern void glsDeleteContext (GLuint inContext);
extern const GLubyte* glsEnumString (GLSenum inAPI, GLSenum inEnum);
extern GLuint glsGenContext (void);
extern GLuint* glsGetAllContexts (void);
extern GLScommandAlignment* glsGetCommandAlignment (GLSopcode inOpcode, GLSenum inExternStreamType, GLScommandAlignment *outAlignment);
extern GLbitfield glsGetCommandAttrib (GLSopcode inOpcode);
extern GLint glsGetConsti (GLSenum inAttrib);
extern const GLint* glsGetConstiv (GLSenum inAttrib);
extern const GLubyte* glsGetConstubz (GLSenum inAttrib);
extern GLuint glsGetCurrentContext (void);
extern GLint* glsGetCurrentTime (GLint *outTime);
extern GLSenum glsGetError (GLboolean inClear);
extern GLint glsGetOpcodeCount (GLSenum inAPI);
extern const GLSopcode* glsGetOpcodes (GLSenum inAPI);
extern GLboolean glsIsContext (GLuint inContext);
extern GLboolean glsIsExtensionSupported (const GLubyte *inExtension);
extern GLboolean glsIsUTF8String (const GLubyte *inString);
extern GLlong glsLong (GLint inHigh, GLuint inLow);
extern GLint glsLongHigh (GLlong inVal);
extern GLuint glsLongLow (GLlong inVal);
extern GLSfunc glsNullCommandFunc (GLSopcode inOpcode);
extern void glsPixelSetup (void);
extern GLulong glsULong (GLuint inHigh, GLuint inLow);
extern GLuint glsULongHigh (GLulong inVal);
extern GLuint glsULongLow (GLulong inVal);
extern GLint glsUCS4toUTF8 (GLuint inUCS4, GLubyte *outUTF8);
extern GLubyte* glsUCStoUTF8z (size_t inUCSbytes, const GLvoid *inUCSz, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* glsUCS1toUTF8z (const GLubyte *inUCS1z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* glsUCS2toUTF8z (const GLushort *inUCS2z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* glsUCS4toUTF8z (const GLuint *inUCS4z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLint glsUTF8toUCS4 (const GLubyte *inUTF8, GLuint *outUCS4);
extern GLboolean glsUTF8toUCSz (size_t inUCSbytes, const GLubyte *inUTF8z, size_t inUCSmax, GLvoid *outUCSz);
extern GLboolean glsUTF8toUCS1z (const GLubyte *inUTF8z, size_t inUCS1max, GLubyte *outUCS1z);
extern GLboolean glsUTF8toUCS2z (const GLubyte *inUTF8z, size_t inUCS2max, GLushort *outUCS2z);
extern GLboolean glsUTF8toUCS4z (const GLubyte *inUTF8z, size_t inUCS4max, GLuint *outUCS4z);

/* GLS immediate commands */
extern void glsAbortCall (GLSenum inMode);
extern GLboolean glsBeginCapture (const GLubyte *inStreamName, GLSenum inCaptureStreamType, GLbitfield inWriteFlags);
extern void glsCallArray (GLSenum inExternStreamType, size_t inCount, const GLubyte *inArray);
extern void glsCaptureFlags (GLSopcode inOpcode, GLbitfield inFlags);
extern void glsCaptureFunc (GLSenum inTarget, GLScaptureFunc inFunc);
extern void glsChannel (GLSenum inTarget, FILE *inChannel);
extern void glsCommandFunc (GLSopcode inOpcode, GLSfunc inFunc);
extern GLSenum glsCopyStream (const GLubyte *inSource, const GLubyte *inDest, GLSenum inDestType, GLbitfield inWriteFlags);
extern void glsDataPointer (GLvoid *inPointer);
extern void glsDeleteReadPrefix (GLuint inIndex);
extern void glsDeleteStream (const GLubyte *inName);
extern void glsEndCapture (void);
extern void glsFlush (GLSenum inFlushType);
extern GLbitfield glsGetCaptureFlags (GLSopcode inOpcode);
extern GLSfunc glsGetCommandFunc (GLSopcode inOpcode);
extern GLSfunc glsGetContextFunc (GLSenum inAttrib);
extern GLlong glsGetContextListl (GLSenum inAttrib, GLuint inIndex);
extern const GLubyte* glsGetContextListubz (GLSenum inAttrib, GLuint inIndex);
extern GLvoid* glsGetContextPointer (GLSenum inAttrib);
extern GLint glsGetContexti (GLSenum inAttrib);
extern const GLubyte* glsGetContextubz (GLSenum inAttrib);
extern GLint glsGetGLRCi (GLuint inGLRC, GLSenum inAttrib);
extern GLfloat glsGetHeaderf (GLSenum inAttrib);
extern GLfloat* glsGetHeaderfv (GLSenum inAttrib, GLfloat *outVec);
extern GLint glsGetHeaderi (GLSenum inAttrib);
extern GLint* glsGetHeaderiv (GLSenum inAttrib, GLint *outVec);
extern const GLubyte* glsGetHeaderubz (GLSenum inAttrib);
extern GLfloat glsGetLayerf (GLuint inLayer, GLSenum inAttrib);
extern GLint glsGetLayeri (GLuint inLayer, GLSenum inAttrib);
extern GLbitfield glsGetStreamAttrib (const GLubyte *inName);
extern GLuint glsGetStreamCRC32 (const GLubyte *inName);
extern const GLubyte* glsGetStreamReadName (const GLubyte *inName);
extern size_t glsGetStreamSize (const GLubyte *inName);
extern GLSenum glsGetStreamType (const GLubyte *inName);
extern GLboolean glsIsContextStream (const GLubyte *inName);
extern void glsPixelSetupGen (GLboolean inEnabled);
extern void glsReadFunc (GLSreadFunc inFunc);
extern void glsReadPrefix (GLSenum inListOp, const GLubyte *inPrefix);
extern void glsUnreadFunc (GLSwriteFunc inFunc);
extern void glsWriteFunc (GLSwriteFunc inFunc);
extern void glsWritePrefix (const GLubyte *inPrefix);

/* GLS encodable commands */
extern void glsBeginGLS (GLint inVersionMajor, GLint inVersionMinor);
extern void glsBlock (GLSenum inBlockType);
extern GLSenum glsCallStream (const GLubyte *inName);
extern void glsEndGLS (void);
extern void glsError (GLSopcode inOpcode, GLSenum inError);
extern void glsGLRC (GLuint inGLRC);
extern void glsGLRCLayer (GLuint inGLRC, GLuint inLayer, GLuint inReadLayer);
extern void glsHeaderGLRCi (GLuint inGLRC, GLSenum inAttrib, GLint inVal);
extern void glsHeaderLayerf (GLuint inLayer, GLSenum inAttrib, GLfloat inVal);
extern void glsHeaderLayeri (GLuint inLayer, GLSenum inAttrib, GLint inVal);
extern void glsHeaderf (GLSenum inAttrib, GLfloat inVal);
extern void glsHeaderfv (GLSenum inAttrib, const GLfloat *inVec);
extern void glsHeaderi (GLSenum inAttrib, GLint inVal);
extern void glsHeaderiv (GLSenum inAttrib, const GLint *inVec);
extern void glsHeaderubz (GLSenum inAttrib, const GLubyte *inString);
extern void glsRequireExtension (const GLubyte *inExtension);
extern void glsUnsupportedCommand (void);

/* GLS encodable-nop commands */
extern void glsAppRef (GLulong inAddress, GLuint inCount);
extern void glsBeginObj (const GLubyte *inTag);
extern void glsCharubz (const GLubyte *inTag, const GLubyte *inString);
extern void glsComment (const GLubyte *inComment);
extern void glsDisplayMapfv (GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec);
extern void glsEndObj (void);
extern void glsNumb (const GLubyte *inTag, GLbyte inVal);
extern void glsNumbv (const GLubyte *inTag, GLuint inCount, const GLbyte *inVec);
extern void glsNumd (const GLubyte *inTag, GLdouble inVal);
extern void glsNumdv (const GLubyte *inTag, GLuint inCount, const GLdouble *inVec);
extern void glsNumf (const GLubyte *inTag, GLfloat inVal);
extern void glsNumfv (const GLubyte *inTag, GLuint inCount, const GLfloat *inVec);
extern void glsNumi (const GLubyte *inTag, GLint inVal);
extern void glsNumiv (const GLubyte *inTag, GLuint inCount, const GLint *inVec);
extern void glsNuml (const GLubyte *inTag, GLlong inVal);
extern void glsNumlv (const GLubyte *inTag, GLuint inCount, const GLlong *inVec);
extern void glsNums (const GLubyte *inTag, GLshort inVal);
extern void glsNumsv (const GLubyte *inTag, GLuint inCount, const GLshort *inVec);
extern void glsNumub (const GLubyte *inTag, GLubyte inVal);
extern void glsNumubv (const GLubyte *inTag, GLuint inCount, const GLubyte *inVec);
extern void glsNumui (const GLubyte *inTag, GLuint inVal);
extern void glsNumuiv (const GLubyte *inTag, GLuint inCount, const GLuint *inVec);
extern void glsNumul (const GLubyte *inTag, GLulong inVal);
extern void glsNumulv (const GLubyte *inTag, GLuint inCount, const GLulong *inVec);
extern void glsNumus (const GLubyte *inTag, GLushort inVal);
extern void glsNumusv (const GLubyte *inTag, GLuint inCount, const GLushort *inVec);
extern void glsPad (void);
extern void glsSwapBuffers (GLuint inLayer);

#if defined(__cplusplus)
    }
#endif /* defined(__cplusplus) */

#endif /* defined(__gls_h_) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\inc\platform.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/******************************************************************************
AIX
******************************************************************************/

#if __GLS_PLATFORM_AIX

    #pragma alloca

    #define __GL_LIB_NAME "libGL.a"
    #define __GLS_FAKE_THREAD_LOCAL_STORAGE 1
    #define __GLS_GL_DISPATCH 1
    #define __GLS_MAX_ALLOCA_BYTES 65536
    #define __GLS_PLATFORM "AIX"

    #if !__GLS_FAKE_FINITE_FUNC
        extern int finite(double);
        #define __GLS_FINITE(inDouble) finite(inDouble)
    #endif /* !__GLS_FAKE_FINITE_FUNC */

    #if !__GLS_FAKE_TRUNCATE_FUNC
        #include <unistd.h>
        #define __GLS_TRUNCATE_EXTERN(inChannel, inByteCount) \
            ftruncate(fileno(inChannel), inByteCount)
    #endif /* !__GLS_FAKE_TRUNCATE_FUNC */

#endif /* __GLS_PLATFORM_AIX */

/******************************************************************************
DECUNIX
******************************************************************************/

#if __GLS_PLATFORM_DECUNIX

    #include <alloca.h>
    #include <errno.h>

    #define __GL_LIB_NAME "libGL.so"
    #define __GLS_GL_DISPATCH 1
    #define __GLS_GL_DISPATCH_DSO 1
    #define __GLS_INT64 1
    #define __GLS_MAX_ALLOCA_BYTES 65536
    #define __GLS_OUT_FORMAT_INT64 "%ld"
    #define __GLS_OUT_FORMAT_INT64HEX "0x%.16lx"
    #define __GLS_OUT_FORMAT_INT64U "%lu"
    #define __GLS_PLATFORM "Digital UNIX"
    #define __GLS_SPRINTF_INT64 1
    #define __GLS_STR_TO_INT64 strtol
    #define __GLS_STR_TO_INT64U strtoul

    #if !__GLS_FAKE_FINITE_FUNC
        #include <math.h>
        #define __GLS_FINITE(inDouble) finite(inDouble)
    #endif /* !__GLS_FAKE_FINITE_FUNC */

    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        #include <pthread.h>

        extern pthread_key_t __gls_contextTLS;
        extern __GLScontext* __glsGetContext(void);
        #define __GLS_CONTEXT __glsGetContext()
        #define __GLS_PUT_CONTEXT(inContext) \
            pthread_setspecific(__gls_contextTLS, (pthread_addr_t)inContext)

        extern pthread_key_t __gls_errorTLS;
        extern GLSenum __glsGetError(void);
        #define __GLS_ERROR __glsGetError()
        #define __GLS_PUT_ERROR(inError) \
            pthread_setspecific(__gls_errorTLS, (pthread_addr_t)inError)
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */

    #if !__GLS_FAKE_TRUNCATE_FUNC
        #include <unistd.h>
        #define __GLS_TRUNCATE_EXTERN(inChannel, inByteCount) \
            ftruncate(fileno(inChannel), inByteCount)
    #endif /* !__GLS_FAKE_TRUNCATE_FUNC */

    #define __GLS_ERRNO _Geterrno()
    #define __GLS_PUT_ERRNO(inError) _Seterrno(inError)

#endif /* __GLS_PLATFORM_DECUNIX */

/******************************************************************************
HPUX
******************************************************************************/

#if __GLS_PLATFORM_HPUX

    #define __GL_LIB_NAME "libGL.sl"
    #define __GLS_FAKE_MUTEX 1
    #define __GLS_FAKE_THREAD_LOCAL_STORAGE 1
    #define __GLS_GL_DISPATCH 1
    #define __GLS_INT64 1
    #define __GLS_PLATFORM "HP-UX"

    #if !__GLS_FAKE_FINITE_FUNC
        extern int finite(double);
        #define __GLS_FINITE(inDouble) finite(inDouble)
    #endif /* !__GLS_FAKE_FINITE_FUNC */

    #if !__GLS_FAKE_TRUNCATE_FUNC
        #include <unistd.h>
        #define __GLS_TRUNCATE_EXTERN(inChannel, inByteCount) \
            ftruncate(fileno(inChannel), inByteCount)
    #endif /* !__GLS_FAKE_TRUNCATE_FUNC */

#endif /* __GLS_PLATFORM_HPUX */

/******************************************************************************
IRIX
******************************************************************************/

#if __GLS_PLATFORM_IRIX

    #include <alloca.h>

    #define __GL_LIB_NAME "libGL.so"
    #define __GLS_INT64 1
    #define __GLS_MAX_ALLOCA_BYTES 65536
    #define __GLS_OUT_FORMAT_INT64 "%lld"
    #define __GLS_OUT_FORMAT_INT64HEX "0x%.16llx"
    #define __GLS_OUT_FORMAT_INT64U "%llu"
    #define __GLS_PLATFORM "IRIX"
    #define __GLS_SPRINTF_INT64 1
    #define __GLS_STR_TO_INT64 strtoll
    #define __GLS_STR_TO_INT64U strtoull

    extern GLlong strtoll(const char *, char **, int);
    extern GLulong strtoull(const char *, char **, int);

    #if !__GLS_FAKE_FINITE_FUNC
        #include <ieeefp.h>
        #define __GLS_FINITE(inDouble) finite(inDouble)
    #endif /* !__GLS_FAKE_FINITE_FUNC */

    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        #include "os.h"

        #define __GLS_CONTEXT \
            (PAGE_ONE->glsContext)
        #define __GLS_PUT_CONTEXT(inContext) \
            __GLS_CONTEXT = inContext

        #define __GLS_ERROR \
            (PAGE_ONE->glsError)
        #define __GLS_PUT_ERROR(inError) \
            __GLS_ERROR = inError
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */

    #if !__GLS_FAKE_TRUNCATE_FUNC
        #include <sys/types.h>
        extern int fileno(FILE *inChannel);
        extern int ftruncate(int, off_t);
        #define __GLS_TRUNCATE_EXTERN(inChannel, inByteCount) \
            ftruncate(fileno(inChannel), (off_t)inByteCount)
    #endif /* !__GLS_FAKE_TRUNCATE_FUNC */

    extern GLint oserror(void);
    #define __GLS_ERRNO oserror()

    extern GLint setoserror(GLint inError);
    #define __GLS_PUT_ERRNO(inError) setoserror(inError)

#endif /* __GLS_PLATFORM_IRIX */

/******************************************************************************
LINUX
******************************************************************************/

#if __GLS_PLATFORM_LINUX

    #include <alloca.h>

    #define __GL_LIB_NAME "libGL.so"
    #define __GLS_GL_DISPATCH 1
    #define __GLS_GL_DISPATCH_DSO 1
    #define __GLS_INT64 1
    #define __GLS_OUT_FORMAT_INT64 "%qd"
    #define __GLS_OUT_FORMAT_INT64HEX "0x%.16qx"
    #define __GLS_OUT_FORMAT_INT64U "%qu"
    #define __GLS_MAX_ALLOCA_BYTES 65536
    #define __GLS_PLATFORM "Linux"
    #define __GLS_POSIX_THREADS 0
    #define __GLS_SPRINTF_INT64 1
    #define __GLS_STR_TO_INT64 strtoq
    #define __GLS_STR_TO_INT64U strtouq

    extern GLlong strtoq(const char *, char **, int);
    extern GLulong strtouq(const char *, char **, int);

    #if !__GLS_FAKE_FINITE_FUNC
        #include <math.h>
        #define __GLS_FINITE(inDouble) __finite(inDouble)
    #endif /* !__GLS_FAKE_FINITE_FUNC */

    #if !__GLS_FAKE_TRUNCATE_FUNC
        extern int fileno(FILE *inChannel);
        extern int ftruncate(int, size_t);
        #define __GLS_TRUNCATE_EXTERN(inChannel, inByteCount) \
            ftruncate(fileno(inChannel), inByteCount)
    #endif /* !__GLS_FAKE_TRUNCATE_FUNC */

    #if !__GLS_POSIX_THREADS
        #define __GLS_FAKE_MUTEX 1
        #define __GLS_FAKE_THREAD_LOCAL_STORAGE 1
    #endif /* !__GLS_POSIX_THREADS */

#endif /* __GLS_PLATFORM_LINUX */

/******************************************************************************
SOLARIS
******************************************************************************/

#if __GLS_PLATFORM_SOLARIS

    #include <errno.h>

    #define __GL_LIB_NAME "libGL.so"
    #define __GLS_GL_DISPATCH 1
    #define __GLS_GL_DISPATCH_DSO 1
    #define __GLS_INT64 1
    #define __GLS_INT64_TO_STR lltostr
    #define __GLS_INT64U_TO_STR ulltostr
    #define __GLS_PLATFORM "Solaris"
    #define __GLS_STR_TO_INT64 strtoll
    #define __GLS_STR_TO_INT64U strtoull

    extern char *lltostr(GLlong, char *);
    extern char *ulltostr(GLulong, char *);
    extern GLlong strtoll(const char *, char **, int);
    extern GLulong strtoull(const char *, char **, int);

    #if !__GLS_FAKE_FINITE_FUNC
        extern int finite(double);
        #define __GLS_FINITE(inDouble) finite(inDouble)
    #endif /* !__GLS_FAKE_FINITE_FUNC */

    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        #include <thread.h>

        extern thread_key_t __gls_contextTLS;
        extern __GLScontext* __glsGetContext(void);
        #define __GLS_CONTEXT __glsGetContext()
        #define __GLS_PUT_CONTEXT(inContext) \
            thr_setspecific(__gls_contextTLS, inContext)

        extern thread_key_t __gls_errorTLS;
        extern GLSenum __glsGetError(void);
        #define __GLS_ERROR __glsGetError()
        #define __GLS_PUT_ERROR(inError) \
            thr_setspecific(__gls_errorTLS, (void *)inError)
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */

    #if !__GLS_FAKE_TRUNCATE_FUNC
        #include <unistd.h>
        #define __GLS_TRUNCATE_EXTERN(inChannel, inByteCount) \
            ftruncate(fileno(inChannel), inByteCount)
    #endif /* !__GLS_FAKE_TRUNCATE_FUNC */

#endif /* __GLS_PLATFORM_SOLARIS */

/******************************************************************************
WIN32
******************************************************************************/

#if __GLS_PLATFORM_WIN32

    #pragma warning(disable:4769)

    #include <excpt.h>
    #include <malloc.h>
    #include <winbase.h>

    #define __GL_LIB_NAME "opengl32.dll"
    #define __GLS_GL_DISPATCH 1
    #define __GLS_INT64 1
    #define __GLS_MAX_ALLOCA_BYTES 65536
    #define __GLS_OUT_FORMAT_INT64 "%I64d"
    #define __GLS_OUT_FORMAT_INT64HEX "0x%.16I64x"
    #define __GLS_OUT_FORMAT_INT64U "%I64u"
    #define __GLS_PLATFORM "Win32"
    #define __GLS_SINGLE_NULL_COMMAND_FUNC 0
    #define __GLS_SPRINTF_INT64 1
    #define __GLS_STR_TO_INT64 __gls_strtoi64
    #define __GLS_STR_TO_INT64U __gls_strtoui64

    #define __GLS_DEC_ALLOC_BIN(inParam, inType, inByteCount) \
        if (inByteCount <= __GLS_MAX_ALLOCA_BYTES) __try { \
            inParam = (inType *)_alloca(inByteCount); \
        } __except(EXCEPTION_CONTINUE_EXECUTION) {} \
        if (!inParam) { \
            inParam = (inType *)__glsMalloc(inByteCount); \
            inParam##_malloc = GL_TRUE; \
        }

    #define __GLS_DEC_ALLOC_TEXT(inoutReader, inParam, inType, inByteCount) \
        if (inByteCount <= __GLS_MAX_ALLOCA_BYTES) __try { \
            inParam = (inType *)_alloca(inByteCount); \
        } __except(EXCEPTION_CONTINUE_EXECUTION) {} \
        if (!inParam) { \
            inParam = (inType *)__glsReader_allocCallBuf( \
                inoutReader, inByteCount \
            ); \
            inParam##_malloc = GL_TRUE; \
        }

    extern GLlong __gls_strtoi64(const char *, char **, int);
    extern GLulong __gls_strtoui64(const char *, char **, int);

    #if !__GLS_FAKE_FINITE_FUNC
        #include <float.h>
        #define __GLS_FINITE(inDouble) _finite(inDouble)
    #endif /* !__GLS_FAKE_FINITE_FUNC */

    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        extern GLint __gls_contextTLS;
        #define __GLS_CONTEXT \
            ((__GLScontext *)TlsGetValue(__gls_contextTLS))
        #define __GLS_PUT_CONTEXT(inContext) \
            TlsSetValue(__gls_contextTLS, inContext)

        extern GLint __gls_errorTLS;
        #define __GLS_ERROR \
            ((GLSenum)((ULONG_PTR)TlsGetValue(__gls_errorTLS)))
        #define __GLS_PUT_ERROR(inError) \
            TlsSetValue(__gls_errorTLS, (GLvoid *)inError)
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */

    #if !__GLS_FAKE_TRUNCATE_FUNC
        #include <io.h>
        #define __GLS_TRUNCATE_EXTERN(inChannel, inByteCount) \
            _chsize(_fileno(inChannel), inByteCount)
    #endif /* !__GLS_FAKE_TRUNCATE_FUNC */

#endif /* __GLS_PLATFORM_WIN32 */

/******************************************************************************
Default definitions
******************************************************************************/

#if !defined(__GLS_CHECKSUM_BUF_BYTES)
    #define __GLS_CHECKSUM_BUF_BYTES 4096
#endif /* !defined(__GLS_CHECKSUM_BUF_BYTES) */

#if !defined(__GLS_CONTEXT_STREAM_BLOCK_BYTES)
    #define __GLS_CONTEXT_STREAM_BLOCK_BYTES 65536
#endif /* !defined(__GLS_CONTEXT_STREAM_BLOCK_BYTES) */

#if !defined(__GLS_READER_BUF_BYTES)
    #define __GLS_READER_BUF_BYTES 16384
#endif /* !defined(__GLS_READER_BUF_BYTES) */

#if !defined(__GLS_PLATFORM)
    #define __GLS_PLATFORM "Unknown"
#endif /* !defined(__GLS_PLATFORM) */

#if !defined(__GLS_RELEASE)
    #define __GLS_RELEASE "Unknown"
#endif /* !defined(__GLS_RELEASE) */

#if !defined(__GLS_SINGLE_NULL_COMMAND_FUNC)
    #define __GLS_SINGLE_NULL_COMMAND_FUNC 1
#endif /* !defined(__GLS_SINGLE_NULL_COMMAND_FUNC) */

#if !defined(__GLS_VENDOR)
    #define __GLS_VENDOR "ARB"
#endif /* !defined(__GLS_VENDOR) */

#if !defined(__GLS_WRITER_EXTERN_BUF_BYTES)
    #define __GLS_WRITER_EXTERN_BUF_BYTES 16384
#endif /* !defined(__GLS_WRIER_EXTERN_BUF_BYTES) */

#if !defined(__GLS_WRITER_EXTERN_BUF_SLOP)
    #define __GLS_WRITER_EXTERN_BUF_SLOP 256
#endif /* !defined(__GLS_WRITER_EXTERN_BUF_SLOP) */

#if !defined(__GLS_ERRNO)
    #define __GLS_ERRNO errno
#endif /* !defined(__GLS_ERRNO) */

#if !defined(__GLS_PUT_ERRNO)
    #define __GLS_PUT_ERRNO(inError) errno = inError
#endif /* !defined(__GLS_PUT_ERRNO) */

/******************************************************************************
Required platform-specific functions
******************************************************************************/

extern void __glsBeginCriticalSection(void);
extern void __glsEndCriticalSection(void);
extern void __glsUpdateDispatchTables(void);

#ifndef __GLS_PLATFORM_WIN32
// DrewB
extern void __glsBeginCaptureExec(GLSopcode inOpcode);
extern void __glsEndCaptureExec(GLSopcode inOpcode);
#define __GLS_BEGIN_CAPTURE_EXEC(ctx, op) __glsBeginCaptureExec(op)
#define __GLS_END_CAPTURE_EXEC(ctx, op) __glsEndCaptureExec(op)
#else
extern void __glsBeginCaptureExec(__GLScontext *ctx, GLSopcode inOpcode);
extern void __glsEndCaptureExec(__GLScontext *ctx, GLSopcode inOpcode);
#define __GLS_BEGIN_CAPTURE_EXEC(ctx, op) __glsBeginCaptureExec(ctx, op)
#define __GLS_END_CAPTURE_EXEC(ctx, op) __glsEndCaptureExec(ctx, op)
#endif

/******************************************************************************
Alloca
******************************************************************************/

#if defined(__GLS_MAX_ALLOCA_BYTES)

    #define __GLS_DEC_ALLOC_DECLARE(inParam) \
        GLboolean inParam##_malloc = GL_FALSE;

    #if !defined(__GLS_DEC_ALLOC_BIN)
        #define __GLS_DEC_ALLOC_BIN(inParam, inType, inByteCount) \
            if (inByteCount <= __GLS_MAX_ALLOCA_BYTES) { \
                inParam = (inType *)alloca(inByteCount); \
            } \
            if (!inParam) { \
                inParam = (inType *)__glsMalloc(inByteCount); \
                inParam##_malloc = GL_TRUE; \
            }
    #endif /* !defined(__GLS_DEC_ALLOC_BIN) */

    #if !defined(__GLS_DEC_ALLOC_TEXT)
        #define __GLS_DEC_ALLOC_TEXT( \
            inoutReader, inParam, inType, inByteCount \
        ) \
            if (inByteCount <= __GLS_MAX_ALLOCA_BYTES) { \
                inParam = (inType *)alloca(inByteCount); \
            } \
            if (!inParam) { \
                inParam = (inType *)__glsReader_allocCallBuf( \
                    inoutReader, inByteCount \
                ); \
                inParam##_malloc = GL_TRUE; \
            }
    #endif /* !defined(__GLS_DEC_ALLOC_TEXT) */

    #define __GLS_DEC_FREE(inParam) \
        if (inParam##_malloc) free(inParam)

#else /* !defined(__GLS_MAX_ALLOCA_BYTES) */

    #define __GLS_DEC_ALLOC_DECLARE(inParam)

    #define __GLS_DEC_ALLOC_BIN(inParam, inType, inByteCount) \
        inParam = (inType *)__glsMalloc(inByteCount)

    #define __GLS_DEC_ALLOC_TEXT(inoutReader, inParam, inType, inByteCount) \
        inParam = (inType *)__glsReader_allocCallBuf(inoutReader, inByteCount)

    #define __GLS_DEC_FREE(inParam) \
        free(inParam)

#endif /* defined(__GLS_MAX_ALLOCA_BYTES) */

/******************************************************************************
POSIX threads
******************************************************************************/

#if __GLS_POSIX_THREADS
    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        #include <pthread.h>

        extern pthread_key_t __gls_contextTLS;
        extern __GLScontext* __glsGetContext(void);
        #define __GLS_CONTEXT __glsGetContext()
        #define __GLS_PUT_CONTEXT(inContext) \
            pthread_setspecific(__gls_contextTLS, inContext)

        extern pthread_key_t __gls_errorTLS;
        extern GLSenum __glsGetError(void);
        #define __GLS_ERROR __glsGetError()
        #define __GLS_PUT_ERROR(inError) \
            pthread_setspecific(__gls_errorTLS, (GLvoid *)inError)
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */
#endif /* __GLS_POSIX_THREADS */

/******************************************************************************
Fake finite function
******************************************************************************/

#if __GLS_FAKE_FINITE_FUNC
    #define __GLS_FINITE(inDouble) GL_TRUE
#endif /* __GLS_FAKE_FINITE_FUNC */

/******************************************************************************
Fake thread-local storage
******************************************************************************/

#if __GLS_FAKE_THREAD_LOCAL_STORAGE
    extern __GLScontext *__gls_context;
    #define __GLS_CONTEXT \
        __gls_context
    #define __GLS_PUT_CONTEXT(inContext) \
        __gls_context = inContext

    extern GLSenum __gls_error;
    #define __GLS_ERROR \
        __gls_error
    #define __GLS_PUT_ERROR(inError) \
        __gls_error = inError
#endif /* __GLS_FAKE_THREAD_LOCAL_STORAGE */

/******************************************************************************
Fake truncate function
******************************************************************************/

#if __GLS_FAKE_TRUNCATE_FUNC
    #define __GLS_TRUNCATE_EXTERN(inChannel, inByteCount) -1
#endif /* __GLS_FAKE_TRUNCATE_FUNC */

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\inc\write.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/******************************************************************************
__GLSwriteStream
******************************************************************************/

typedef struct {
    FILE *channel;
    __GLSstring name;
    GLboolean created;
    GLboolean opened;
    GLSwriteFunc writeFunc;
} __GLSwriteStream;

extern __GLSwriteStream* __glsWriteStream_create(
    const GLubyte *inName, GLboolean inAppend
);

extern __GLSwriteStream* __glsWriteStream_destroy(__GLSwriteStream *inStream);
extern size_t __glsWriteStream_getByteCount(const __GLSwriteStream *inStream);

/******************************************************************************
__GLSwriter
******************************************************************************/

typedef struct __GLSwriter __GLSwriter;

struct __GLSwriter {
    GLboolean (*alloc)(
        __GLSwriter *inoutWriter, size_t inWordCount
    );
    GLboolean (*beginCommand)(
        __GLSwriter *inoutWriter, GLSopcode inOpcode, size_t inByteCount
    );
    void (*endCommand)(
        __GLSwriter *inoutWriter
    );
    void (*nextList)(
        __GLSwriter *inoutWriter
    );
    GLboolean (*padWordCount)(
        __GLSwriter *inoutWriter, GLboolean inCountMod2
    );
    void (*putGLSenum)(
        __GLSwriter *inoutWriter, GLSenum inVal
    );
    void (*putGLSimageFlags)(
        __GLSwriter *inoutWriter, GLbitfield inVal
    );
    void (*putGLSopcode)(
        __GLSwriter *inoutWriter, GLSopcode inVal
    );
    void (*putGLattribMask)(
        __GLSwriter *inoutWriter, GLbitfield inVal
    );
    void (*putGLbitvs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inItemLeftShift,
        GLint inStrideDataItems,
        GLint inStridePadItems,
        GLint inStrideCount,
        const GLubyte *inVec
    );
    void (*putGLblendingFactor)(
        __GLSwriter *inoutWriter, GLenum inVal
    );
    void (*putGLboolean)(
        __GLSwriter *inoutWriter, GLboolean inVal
    );
    void (*putGLbooleanv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLboolean *inVec
    );
    void (*putGLbooleanvs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLboolean *inVec
    );
    void (*putGLbyte)(
        __GLSwriter *inoutWriter, GLbyte inVal
    );
    void (*putGLbytev)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLbyte *inVec
    );
    void (*putGLbytevs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLbyte *inVec
    );
    void (*putGLcharv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLubyte *inVec
    );
    void (*putGLclearBufferMask)(
        __GLSwriter *inoutWriter, GLbitfield inVal
    );
    void (*putGLdouble)(
        __GLSwriter *inoutWriter, GLdouble inVal
    );
    void (*putGLdoubleOrGLenum)(
        __GLSwriter *inoutWriter, GLenum inParam, GLdouble inVal
    );
    void (*putGLdoubleOrGLenumv)(
        __GLSwriter *inoutWriter,
        GLenum inParam, GLuint inCount, const GLdouble *inVec
    );
    void (*putGLdoublem)(
        __GLSwriter *inoutWriter, const GLdouble *inMat
    );
    void (*putGLdoublev)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLdouble *inVec
    );
    void (*putGLdoublevs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLdouble *inVec
    );
    void (*putGLdrawBufferMode)(
        __GLSwriter *inoutWriter, GLenum inVal
    );
    void (*putGLenum)(
        __GLSwriter *inoutWriter, GLenum inVal
    );
    void (*putGLfloat)(
        __GLSwriter *inoutWriter, GLfloat inVal
    );
    void (*putGLfloatOrGLenum)(
        __GLSwriter *inoutWriter, GLenum inParam, GLfloat inVal
    );
    void (*putGLfloatOrGLenumv)(
        __GLSwriter *inoutWriter,
        GLenum inParam, GLuint inCount, const GLfloat *inVec
    );
    void (*putGLfloatm)(
        __GLSwriter *inoutWriter, const GLfloat *inMat
    );
    void (*putGLfloatv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLfloat *inVec
    );
    void (*putGLfloatvs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLfloat *inVec
    );
    void (*putGLint)(
        __GLSwriter *inoutWriter, GLint inVal
    );
    void (*putGLintOrGLSenum)(
        __GLSwriter *inoutWriter, GLenum inParam, GLint inVal
    );
    void (*putGLintOrGLenum)(
        __GLSwriter *inoutWriter, GLenum inParam, GLint inVal
    );
    void (*putGLintOrGLenumv)(
        __GLSwriter *inoutWriter,
        GLenum inParam, GLuint inCount, const GLint *inVec
    );
    void (*putGLintv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLint *inVec
    );
    void (*putGLintvs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLint *inVec
    );
    void (*putGLlong)(
        __GLSwriter *inoutWriter, GLlong inVal
    );
    void (*putGLlongv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLlong *inVec
    );
    void (*putGLoutArg)(
        __GLSwriter *inoutWriter, GLuint inIndex, const GLvoid *inVal
    );
    void (*putGLshort)(
        __GLSwriter *inoutWriter, GLshort inVal
    );
    void (*putGLshortv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLshort *inVec
    );
    void (*putGLshortvs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLshort *inVec
    );
    void (*putGLstencilOp)(
        __GLSwriter *inoutWriter, GLenum inVal
    );
    void (*putGLtextureComponentCount)(
        __GLSwriter *inoutWriter, GLint inVal
    );
    void (*putGLubyte)(
        __GLSwriter *inoutWriter, GLubyte inVal
    );
    void (*putGLubytev)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLubyte *inVec
    );
    void (*putGLubytevs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLubyte *inVec
    );
    void (*putGLuint)(
        __GLSwriter *inoutWriter, GLuint inVal
    );
    void (*putGLuinthex)(
        __GLSwriter *inoutWriter, GLuint inVal
    );
    void (*putGLuintv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLuint *inVec
    );
    void (*putGLuintvs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLuint *inVec
    );
    void (*putGLulong)(
        __GLSwriter *inoutWriter, GLulong inVal
    );
    void (*putGLulonghex)(
        __GLSwriter *inoutWriter, GLulong inVal
    );
    void (*putGLulongv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLulong *inVec
    );
    void (*putGLushort)(
        __GLSwriter *inoutWriter, GLushort inVal
    );
    void (*putGLushorthex)(
        __GLSwriter *inoutWriter, GLushort inVal
    );
    void (*putGLushortv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLushort *inVec
    );
    void (*putGLushortvs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLushort *inVec
    );
    GLubyte *bufPtr;
    GLubyte *bufTail;
    GLSopcode commandOpcode;
    GLubyte *commandHead;
    GLubyte *commandTail;
    GLboolean contextCreated;
    __GLScontextStream *contextStream;
    GLboolean error;
    GLubyte *externBuf;
    GLubyte *externBufHead;
    __GLSwriteStream *externStream;
    GLint paramCount;
    __GLSbinCommandHead_large *prevCommand;
    __GLScontextStreamBlock *startBlock;
    size_t startOffset;
    GLSenum type;
    size_t wordCount;
};

extern __GLSwriter* __glsWriter_create(
    const GLubyte *inStreamName, GLSenum inStreamType, GLbitfield inWriteFlags
);

extern __GLSwriter* __glsWriter_destroy(__GLSwriter *inWriter);
extern GLboolean __glsWriter_flush(__GLSwriter *inoutWriter);

extern void __glsWriter_putListv(
    __GLSwriter *inoutWriter,
    GLenum inType,
    GLint inCount,
    const GLvoid *inVec
);

extern void __glsWriter_putPixelv(
    __GLSwriter *inoutWriter,
    GLenum inFormat,
    GLenum inType,
    GLint inWidth,
    GLint inHeight,
    const GLvoid *inVec
);

// DrewB - Always enabled for 1.1 support
extern void __glsWriter_putVertexv(
        __GLSwriter *inoutWriter,
        GLint inSize,
        GLenum inType,
        GLint inStride,
        GLint inCount,
        const GLvoid *inVec
    );

/******************************************************************************
__GLSwriter binary
******************************************************************************/

extern void __glsWriter_initDispatch_bin(
    __GLSwriter *inoutWriter, GLSenum inStreamType
);

/******************************************************************************
__GLSwriter text
******************************************************************************/

extern void __glsWriter_initDispatch_text(
    __GLSwriter *inoutWriter
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\inc\parser.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

typedef struct {
    __GLSdict *glAttribMaskDict;
    __GLSdict *glEnumDict;
    __GLSdict *glsEnumDict;
    __GLSdict *glsImageFlagsDict;
    __GLSdict *glsOpDict;
} __GLSparser;

extern __GLSparser* __glsParser_create(void);
extern __GLSparser* __glsParser_destroy(__GLSparser *inParser);

extern GLboolean __glsParser_findCommand(
    const __GLSparser *inParser,
    const GLubyte *inCommand,
    GLSopcode *outOpcode
);

extern void __glsParser_print(const __GLSparser *inParser);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\inc\pixel.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

extern void __glsGenPixelSetup_pack(struct __GLScontext *ctx);
extern void __glsGenPixelSetup_unpack(struct __GLScontext *ctx);
extern void __glsPixelSetup_pack(void);
extern void __glsPixelSetup_unpack(void);

typedef struct {
    GLint alignment;
    GLint lsbFirst;
    GLint rowLength;
    GLint skipRows;
    GLint skipPixels;
    GLint swapBytes;
    #if __GL_EXT_texture3D
        GLint imageHeight;
        GLint skipImages;
    #endif /* __GL_EXT_texture3D */
    #if __GL_SGIS_texture4D
        GLint imageDepth;
        GLint skipVolumes;
    #endif /* __GL_SGIS_texture4D */
} __GLSpixelStoreConfig;

extern void __glsPixelStoreConfig_get_pack(
    __GLSpixelStoreConfig *outConfig
);
extern void __glsPixelStoreConfig_get_unpack(
    __GLSpixelStoreConfig *outConfig
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\inc\read.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/******************************************************************************
__GLSreadStream
******************************************************************************/

typedef struct {
    FILE *channel;
    __GLSstring name;
    GLboolean opened;
    GLSreadFunc readFunc;
    GLSwriteFunc unreadFunc;
} __GLSreadStream;

extern __GLSreadStream* __glsReadStream_create(const GLubyte *inName);
extern __GLSreadStream* __glsReadStream_destroy(__GLSreadStream *inStream);
extern GLbitfield __glsReadStream_getAttrib(const __GLSreadStream *inStream);
extern size_t __glsReadStream_getByteCount(const __GLSreadStream *inStream);
extern GLuint __glsReadStream_getCRC32(const __GLSreadStream *inStream);
extern GLSenum __glsReadStream_getType(const __GLSreadStream *inStream);

/******************************************************************************
__GLSreader
******************************************************************************/

#define __GLS_GET_SPACE(inoutReader) { \
    GLboolean __comment = GL_FALSE; \
    GLubyte __spaceChar; \
    do { \
        __GLS_READ_CHAR(inoutReader, __spaceChar); \
        switch (__spaceChar) { \
            case '#': \
                __comment = GL_TRUE; \
                break; \
            case '\n': \
            case '\r': \
                __comment = GL_FALSE; \
                break; \
        } \
    } while (__GLS_CHAR_IS_SPACE(__spaceChar) || __comment); \
    __GLS_UNREAD_CHAR(inoutReader); \
}

#define __GLS_READ_CHAR(inoutReader, outChar) \
    if ( \
        inoutReader->readPtr >= inoutReader->readTail && \
        !__glsReader_fillBuf(inoutReader, 1, GL_FALSE) \
    ) { \
        outChar = 0; \
    } else { \
        outChar = *inoutReader->readPtr++; \
    }

#define __GLS_UNREAD_CHAR(inoutReader) \
    if (inoutReader->readPtr > inoutReader->buf) --inoutReader->readPtr;

typedef struct __GLSreader {
    GLubyte *buf;
    size_t bufSize;
    GLSenum error;
    GLint paramCount;
    GLubyte *readHead;
    GLubyte *readPtr;
    GLubyte *readTail;
    const __GLSreadStream *stream;
    GLSenum type;
    __GLSversion version;
} __GLSreader;

extern GLvoid* __glsReader_allocCallBuf(
    __GLSreader *inoutReader, size_t inByteCount
);

extern GLvoid* __glsReader_allocFeedbackBuf(
    __GLSreader *inoutReader, size_t inByteCount
);

extern GLvoid* __glsReader_allocSelectBuf(
    __GLSreader *inoutReader, size_t inByteCount
);

#if __GL_EXT_vertex_array
    extern GLvoid* __glsReader_allocVertexArrayBuf(
        __GLSreader *inoutReader, GLSopcode inOpcode, size_t inByteCount
    );
#endif /* __GL_EXT_vertex_array */

extern void __glsReader_call(__GLSreader *inoutReader);

extern __GLSreader* __glsReader_final(__GLSreader *inoutReader);

extern GLboolean __glsReader_fillBuf(
    __GLSreader *inoutReader, size_t inMinBytes, GLboolean inRealign
);

extern __GLSreader* __glsReader_init_array(
    __GLSreader *outReader, const GLubyte *inArray, size_t inCount
);

extern __GLSreader* __glsReader_init_stream(
    __GLSreader *outReader, const __GLSreadStream *inStream, size_t inBufSize
);

extern void __glsReader_raiseError(__GLSreader *inoutReader, GLSenum inError);

/******************************************************************************
__GLSreader binary
******************************************************************************/

extern GLboolean __glsReader_call_bin(__GLSreader *inoutReader);
extern GLboolean __glsReader_call_bin_swap(__GLSreader *inoutReader);

extern GLSenum __glsReader_readBeginGLS_bin(
    __GLSreader *inoutReader, __GLSversion *outVersion
);

/******************************************************************************
__GLSreader text
******************************************************************************/

extern GLboolean __glsReader_abortCommand_text(__GLSreader *inoutReader);

extern GLboolean __glsReader_beginCommand_text(
    __GLSreader *inoutReader, __GLSstring *outCommand
);

extern GLboolean __glsReader_call_text(__GLSreader *inoutReader);
extern GLboolean __glsReader_endCommand_text(__GLSreader *inoutReader);

extern GLboolean __glsReader_getGLSenum_text(
    __GLSreader *inoutReader, GLSenum *outVal
);

extern GLboolean __glsReader_getGLSimageFlags_text(
    __GLSreader *inoutReader, GLbitfield *outVal
);

extern GLboolean __glsReader_getGLSopcode_text(
    __GLSreader *inoutReader, GLSopcode *outVal
);

extern GLboolean __glsReader_getGLattribMask_text(
    __GLSreader *inoutReader, GLbitfield *outVal
);

extern GLboolean __glsReader_getGLblendingFactor_text(
    __GLSreader *inoutReader, GLenum *outVal
);

extern GLboolean __glsReader_getGLboolean_text(
    __GLSreader *inoutReader, GLboolean *outVal
);

extern GLboolean __glsReader_getGLbooleanv_text(
    __GLSreader *inoutReader, GLuint inCount, GLboolean *outVec
);

extern GLboolean __glsReader_getGLbyte_text(
    __GLSreader *inoutReader, GLbyte *outVal
);

extern GLboolean __glsReader_getGLbytev_text(
    __GLSreader *inoutReader, GLuint inCount, GLbyte *outVec
);

extern GLboolean __glsReader_getGLcharv_text(
    __GLSreader *inoutReader, __GLSstring *outString
);

extern GLboolean __glsReader_getGLclearBufferMask_text(
    __GLSreader *inoutReader, GLbitfield *outVal
);

extern GLboolean __glsReader_getGLcompv_text(
    __GLSreader *inoutReader, GLenum inType, GLuint inBytes, GLvoid *outVec
);

extern GLboolean __glsReader_getGLdouble_text(
    __GLSreader *inoutReader, GLdouble *outVal
);

extern GLboolean __glsReader_getGLdoublev_text(
    __GLSreader *inoutReader, GLuint inCount, GLdouble *outVec
);

extern GLboolean __glsReader_getGLdrawBufferMode_text(
    __GLSreader *inoutReader, GLenum *outVal
);

extern GLboolean __glsReader_getGLenum_text(
    __GLSreader *inoutReader, GLenum *outVal
);

extern GLboolean __glsReader_getGLfloat_text(
    __GLSreader *inoutReader, GLfloat *outVal
);

extern GLboolean __glsReader_getGLfloatv_text(
    __GLSreader *inoutReader, GLuint inCount, GLfloat *outVec
);

extern GLboolean __glsReader_getGLint_text(
    __GLSreader *inoutReader, GLint *outVal
);

extern GLboolean __glsReader_getGLintv_text(
    __GLSreader *inoutReader, GLuint inCount, GLint *outVec
);

extern GLboolean __glsReader_getGLlong_text(
    __GLSreader *inoutReader, GLlong *outVal
);

extern GLboolean __glsR