OutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\snyaitmc\snyaitmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    snyaitmc.c

Abstract:

    This module contains device-specific routines for Sony AIT medium changers:
    SEAGATE AIT-LDR -- Seagate Sidewinder 200 AIT Loader (manufactured by Sony)
        STA4200000W  (Internal full height 5 1/4")
        STA6200000W  (External)

Author:

    Based on sonymc.c by chuckp (Chuck Park)
    Adapted for SEAGATE AIT-LDR by Bruce Janiszewski

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "snyaitmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, SonyBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the Sony changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PSERIAL_NUMBER  serialBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);


    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    ExFreePool(dataBuffer);

    //
    // Build address mapping.
    //

    status = SonyBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    serialBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(SERIAL_NUMBER));
    if (!serialBuffer) {

        ExFreePool(dataBuffer);

        DebugPrint((1,
                    "Sonyaitmc.ChangerInitialize: Error allocating serial number buffer. %x\n",
                    status));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Get serial number.
    //

    RtlZeroMemory(serialBuffer, sizeof(SERIAL_NUMBER));

    //
    // Get serial number page.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set EVPD
    //

    cdb->CDB6INQUIRY.Reserved1 = 1;

    //
    // Unit serial number page.
    //

    cdb->CDB6INQUIRY.PageCode = 0x80;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(SERIAL_NUMBER);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         serialBuffer,
                                         sizeof(SERIAL_NUMBER),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        RtlMoveMemory(changerData->SerialNumber, serialBuffer->ControllerSerialNumber, SONY_SERIAL_NUMBER_LENGTH);

    }

    ExFreePool(serialBuffer);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_UNIT_ATTENTION:

            //
            // Zero the lock count, as any prevents are now gone.
            //

            InterlockedExchange(&changerData->LockCount, 0);
            break;

        case SCSI_SENSE_HARDWARE_ERROR: {
            if ((senseBuffer->AdditionalSenseCode == 0x44) &&
                (senseBuffer->AdditionalSenseCodeQualifier == 0)) {
                changerData->DeviceStatus = SNYAITMC_HW_ERROR;
            }
           break;
        }

        case SCSI_SENSE_NOT_READY: {
            if ((senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_NO_MEDIA_IN_DEVICE) &&
                (senseBuffer->AdditionalSenseCodeQualifier == 0x00)) {

                //
                // Indicates there's no magazine in the changer
                //
                *Status = STATUS_MAGAZINE_NOT_PRESENT;
            }

            break;
        }

        default:
            break;
        }

        DebugPrint((1,
                   "ChangerError: Sense Key - %x\n",
                   senseBuffer->SenseKey & 0x0f));
        DebugPrint((1,
                   "              AdditionalSenseCode - %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "              AdditionalSenseCodeQualifier - %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    Sony changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    bufferLength;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ExFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ExFreePool(srb);
        ExFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = SONY_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;


    changerParameters->MagazineSize = 4;

    //
    // Free buffer.
    //

    ExFreePool(modeBuffer);

    changerParameters->Features0 = 0;

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->DriveCleanTimeout = 0;

    changerParameters->Features0 |= CHANGER_LOCK_UNLOCK                     |
                                    CHANGER_CARTRIDGE_MAGAZINE              |
                                    CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS;

    changerParameters->LockUnlockCapabilities = (LOCK_UNLOCK_DOOR);

    //
    // build device capability mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ExFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ExFreePool(srb);
        ExFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    ExFreePool(srb);
    ExFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ExFreePool(srb);
    // Return success if magazine not present.
    if (status == STATUS_NO_MEDIA_IN_DEVICE)
        return STATUS_SUCCESS;
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);
    RtlMoveMemory(productData->SerialNumber, changerData->SerialNumber, SONY_SERIAL_NUMBER_LENGTH);

    //
    // Indicate drive type and whether media is two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    LONG                lockValue = 0;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;


    if (ElementOutOfRange(addressMapping, (USHORT)setAccess->Element.ElementAddress, setAccess->Element.ElementType)) {
        DebugPrint((1,
                   "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    if (controlOperation == LOCK_ELEMENT) {

        //
        // Set the state to locked.
        //

        InterlockedIncrement(&changerData->LockCount);

    } else if (controlOperation == UNLOCK_ELEMENT) {

        //
        // Clear the state.
        //

        InterlockedExchange(&changerData->LockCount, 0);

    } else {

        //
        // Get the current state.
        //

        lockValue = (LONG)InterlockedCompareExchange((PVOID)&changerData->LockCount,
                                                     0,
                                                     0);

        DebugPrint((1,
                   "SetAccess: Current lock count - %x\n",
                   lockValue));
    }

    if (setAccess->Element.ElementType == ChangerDoor) {

        if (controlOperation == LOCK_ELEMENT) {

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue prevent media removal command to lock the door.
            //

            cdb->MEDIA_REMOVAL.Prevent = 1;

        } else if (controlOperation == UNLOCK_ELEMENT) {

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue allow media removal.
            //

            cdb->MEDIA_REMOVAL.Prevent = 0;
        } else {
            status = STATUS_INVALID_PARAMETER;
        }

    } else if (setAccess->Element.ElementType == ChangerIEPort) {

        if (controlOperation == LOCK_ELEMENT) {

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue prevent media removal command to lock the ie port.
            //

            cdb->MEDIA_REMOVAL.Prevent = 1;

        } else if (controlOperation == UNLOCK_ELEMENT) {

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue allow media removal.
            //

            cdb->MEDIA_REMOVAL.Prevent = 0;

        } else {
            status = STATUS_INVALID_PARAMETER;
        }
    } else {

        //
        // No keypad selectivity programatically.
        //

        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    }

    ExFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    totalElements = 0;
    NTSTATUS status;
    PVOID    statusBuffer;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    if (elementType == AllElements) {

        ULONG i;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;
            totalElements += addressMapping->NumberOfElements[i];
        }

        if (totalElements != readElementStatus->ElementList.NumberOfElements) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) AllElements\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements));

            return STATUS_INVALID_PARAMETER;
        }

        //
        // Account for length of the descriptors expected for the drives.
        //


        if (readElementStatus->VolumeTagInfo) {

            return STATUS_INVALID_PARAMETER;

        } else {

            length = sizeof(SONY_ELEMENT_DESCRIPTOR) * totalElements;

            //
            // Add in header and status pages.
            //

            length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);

        }

    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        totalElements = readElementStatus->ElementList.NumberOfElements;
        if (totalElements > addressMapping->NumberOfElements[elementType]) {

            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) for type (%x)\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements,
                       elementType));

            return STATUS_INVALID_PARAMETER;
        }

        length = (sizeof(SONY_ELEMENT_DESCRIPTOR) * totalElements);

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);

    }

    DebugPrint((3,
               "ChangerGetElementStatus: Allocation Length %x, for %x elements of type %x\n",
               length,
               totalElements,
               elementType));

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ExFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // These devices may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (NT_SUCCESS(status)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        LONG remainingElements;
        LONG typeCount;
        LONG i;
        ULONG descriptorLength;

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        if (remainingElements < 0 ) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Returned elements less than zero - %x\n",
                       remainingElements));

            ExFreePool(srb);
            ExFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        if (typeCount < 0) {
            DebugPrint((1,
                       "ChangerGetElementStatus (1): Count of type %x less than zero - %x\n",
                       elementType,
                       typeCount));

            ExFreePool(srb);
            ExFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                //
                // Source address
                //

                if (elementDescriptor->SValid) {
                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];
                    elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                }

#if NO_FIX_BUSADDRESS
                if (elementDescriptor->IdValid) {
                    elementStatus->Flags |= ELEMENT_STATUS_ID_VALID;
                    elementStatus->TargetId = elementDescriptor->BusAddress;
                }
#else
                if (statusPage->ElementType == ChangerDrive) {
                    // Seagate U1j6 firmware returns
                    //   IdValid=1 and BussAddress=0
                    elementStatus->Flags |= ELEMENT_STATUS_ID_VALID;
                    elementStatus->TargetId = srb->TargetId;
                }
#endif

                if (elementDescriptor->LunValid) {
                    elementStatus->Flags |= ELEMENT_STATUS_LUN_VALID;
                    elementStatus->Lun = elementDescriptor->Lun;
                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);

                //
                // Map any exceptions reported directly.
                //

                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                    //
                    // Map the exception.
                    //

                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                }

                //
                // Get next descriptor.
                //

                (ULONG_PTR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }

                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }

                DebugPrint((1,
                           "ChangerGetElementStatus(2): Count of type %x less than zero - %x\n",
                           elementType,
                           typeCount));
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * totalElements;

    }

    ExFreePool(srb);
    ExFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ExFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.
    SCSIOP_POSITION_TO_ELEMENT is not supported by:
       SEAGATE Sidewinder 200 AIT Loader.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.
    SCSIOP_EXCHANGE_MEDIUM is not supported by:
       SEAGATE Sidewinder 200 AIT Loader.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport;
    USHORT source;
    USHORT destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    LONG                lockValue = 0;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    if ((moveMedium->Destination.ElementType == ChangerIEPort) ||
        (moveMedium->Source.ElementType == ChangerIEPort)) {

        //
        // Determine value of LockCount.
        //

        lockValue = (LONG)InterlockedCompareExchange((PVOID)&changerData->LockCount,
                                                     0,
                                                     0);

        DebugPrint((1,
                   "MoveMedium: LockCount is %x\n",
                   lockValue));

        if (lockValue) {

            //
            // Send an allow to clear the prevent for IEPORT extend/retract.
            //

            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            //
            // Ignore errors at this point. If this fails and the move doesn't happen, the LM will
            // clean things up.
            //

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
            DebugPrint((1,
                       "MoveMedium: Allow sent. Status %x\n",
                       status));

            status = STATUS_SUCCESS;
        }
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
#if FIX_CDB12
    srb->CdbLength = CDB10GENERIC_LENGTH;
#endif
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    } else {
        DebugPrint((1,
                   "MoveMedium: Status of Move %x\n",
                   status));
    }


    if ((moveMedium->Destination.ElementType == ChangerIEPort) ||
        (moveMedium->Source.ElementType == ChangerIEPort)) {

        if (lockValue) {

            NTSTATUS preventStatus;

            //
            // Send the prevent to re-lock down the unit.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 1;

            //
            // Ignore any errors at this point. The LM will fixup any problems with
            // prevent/allow
            //

            preventStatus = ChangerClassSendSrbSynchronous(DeviceObject,
                                    srb,
                                    NULL,
                                    0,
                                    FALSE);
            DebugPrint((1,
                       "MoveMedium: Prevent sent. Status %x\n",
                       preventStatus));
        }
    }

    ExFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    SCSIOP_REZERO_UNIT is not supported by:
       SEAGATE Sidewinder 200 AIT Loader.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Volume Tags are not supported by:
       SEAGATE Sidewinder 200 AIT Loader.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
SonyBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    ULONG                  bufferLength;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);


    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = SONY_NO_ELEMENT;
    }

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];

        //
        // Determine lowest address of all elements.
        //


        addressMapping->LowAddress = SONY_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }

    //
    // Free buffer.
    //

    ExFreePool(modeBuffer);
    ExFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{

    ULONG exceptionCode = 0;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;


    switch (asc) {
        case 0x0:
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    DebugPrint((1,
               "Sonyaitmc.MapExceptionCode: ASC %x, ASCQ %x, exceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == SONY_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{

   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize DeviceStatusin the device extension to 
   // SNYAITMC_DEVICE_PROBLEM_NONE. If the changer returns sense code 
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set appropriate 
   // DeviceStatus in ChangerError routine.
   //
   changerData->DeviceStatus = SNYAITMC_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "SNYAITMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set SelfTest bit
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) == SNYAITMC_HW_ERROR) {
       //
       // Diagnostic test failed. Do ReceiveDiagnostic to receive
       // the results of the diagnostic test
       //  
       RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

       cdb = (PCDB)srb->Cdb;
       cdb->CDB6GENERIC.OperationCode = SCSIOP_RECEIVE_DIAGNOSTIC;       
       cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(SNYAITMC_RECV_DIAG);

       resultBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                               sizeof(SNYAITMC_RECV_DIAG));
       if (resultBuffer == NULL) {
           //
           // No memory. Just set the generic error code (DeviceProblemHardware)
           // and return STATUS_SUCCESS.
           //
           changerDeviceError->ChangerProblemType = DeviceProblemHardware;
           DebugPrint((1, "SEADDSMC:PerformDiagnostics - Not enough memory to ",
                       "receive diagnostic results\n"));

           ChangerClassFreePool(srb);
           return STATUS_SUCCESS;
       }

       srb->DataTransferLength = sizeof(SNYAITMC_RECV_DIAG);;
       srb->DataBuffer = resultBuffer;
       srb->CdbLength = CDB6GENERIC_LENGTH;
       srb->TimeOutValue = 120;

       status = ChangerClassSendSrbSynchronous(DeviceObject,
                                    srb,
                                    srb->DataBuffer,
                                    srb->DataTransferLength,
                                    FALSE);
       if (NT_SUCCESS(status)) {
           ProcessDiagnosticResult(changerDeviceError,
                                   resultBuffer);
       }

       ChangerClassFreePool(resultBuffer);
       status = STATUS_SUCCESS;
   }

   ChangerClassFreePool(srb);

   return status;
}


VOID
ProcessDiagnosticResult(
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError,
    IN PUCHAR resultBuffer
    )
/*+++

Routine Description :

   This routine parses the data returned by the device on
   Receive Diagnostic command, and returns appropriate
   value for the problem type.
   
Arguements :

   changerDeviceError - Output buffer with diagnostic info
   
   resultBuffer - Buffer in which the data returned by the device
                  Receive Diagnostic command is stored.
   
Return Value :

   DeviceProblemNone - If there is no problem with the device
   Appropriate status code indicating the changer problem type.   
--*/
{
   PSNYAITMC_RECV_DIAG diagBuffer;
   UCHAR errorSet;
   UCHAR errorCode;

   diagBuffer = (PSNYAITMC_RECV_DIAG)resultBuffer;
   errorSet = diagBuffer->ErrorSet;
   errorCode = diagBuffer->ErrorCode;
   DebugPrint((1, "snyaitmc\\ProcessDiagResult : ErrorSet %x, ErrorCode %x\n",
               errorSet, errorCode));

   //
   // ISSUE: 02/24/2000 - nramas
   // All errorCodes given in the manual indicate somekind of
   // hardware failure. For now, just return  DeviceProblemHardware.
   //
   changerDeviceError->ChangerProblemType = DeviceProblemHardware;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\sonymc\sonymc.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sonymc.c

Abstract:

    This module contains device-specific routines for Sony CD changers

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "sonymc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, SonyBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the Sony changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PSERIAL_NUMBER  serialBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);


    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Determine drive type.
    //

    if (RtlCompareMemory(dataBuffer->ProductId,"CDL1100",7) == 7) {
        changerData->DriveType = SONY_CD;
        changerData->DriveID = CDL1100;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"CDL5000",7) == 7) {
        changerData->DriveID = CDL5000;
        changerData->DriveType = SONY_CD;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"CDL2200",7) == 7) {
        changerData->DriveID = CDL5000;
        changerData->DriveType = SONY_CD;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"CDL2100",7) == 7) {
        changerData->DriveID = CDL5000;
        changerData->DriveType = SONY_CD;

    }

    ChangerClassFreePool(dataBuffer);

    //
    // Build address mapping.
    //

    status = SonyBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // SONY_MO changers (OSL-6000, OSL-2500) are no more supported, but
    // we'll keep SONY_MO specific code anyways
    //
    if (changerData->DriveType == SONY_MO) {
        serialBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(SERIAL_NUMBER));
        if (!serialBuffer) {

            DebugPrint((1,
                        "Sonymc.ChangerInitialize: Error allocating serial number buffer. %x\n",
                        status));

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Get serial number.
        //

        RtlZeroMemory(serialBuffer, sizeof(SERIAL_NUMBER));

        //
        // Get serial number page.
        //

        RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

        //
        // Set timeout value.
        //

        srb.TimeOutValue = 10;

        srb.CdbLength = 6;

        cdb = (PCDB)srb.Cdb;

        //
        // Set CDB operation code.
        //

        cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

        //
        // Set EVPD
        //

        cdb->CDB6INQUIRY.Reserved1 = 1;

        //
        // Unit serial number page.
        //

        cdb->CDB6INQUIRY.PageCode = 0x80;

        //
        // Set allocation length to inquiry data buffer size.
        //

        cdb->CDB6INQUIRY.AllocationLength = sizeof(SERIAL_NUMBER);

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             &srb,
                                             serialBuffer,
                                             sizeof(SERIAL_NUMBER),
                                             FALSE);

        if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
            SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

            RtlMoveMemory(changerData->SerialNumber, serialBuffer->ControllerSerialNumber, SONY_SERIAL_NUMBER_LENGTH);

        }

        ChangerClassFreePool(serialBuffer);

    }

    //
    // Send an allow to the unit to ensure that the LockCount and state of the unit
    // are in sync.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb.Cdb;
    srb.CdbLength = CDB6GENERIC_LENGTH;
    srb.DataTransferLength = 0;
    srb.TimeOutValue = 10;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
    cdb->MEDIA_REMOVAL.Prevent = 0;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     NULL,
                                     0,
                                     FALSE);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    
    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_UNIT_ATTENTION:

            if (senseBuffer->AdditionalSenseCode != SCSI_ADSENSE_MEDIUM_CHANGED) {

                //
                // Reset/power-on clears any prevents.
                //

                InterlockedExchange(&changerData->LockCount, 0);
            }
            break;

        case SCSI_SENSE_HARDWARE_ERROR: {
           changerData->DeviceStatus = SONYMC_HW_ERROR;
           break;
        }

        default:
            break;
        }
        DebugPrint((1,
                   "ChangerError: Sense Key - %x\n",
                   senseBuffer->SenseKey & 0x0f));
        DebugPrint((1,
                   "              AdditionalSenseCode - %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "              AdditionalSenseCodeQualifier - %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));
    } else {
        DebugPrint((1,
                   "ChangerError: Autosense not valid. SrbStatus %x\n",
                   Srb->SrbStatus));
    }


    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    Sony changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    bufferLength;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = SONY_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    if (changerData->DriveType == SONY_MO) {
        changerParameters->NumberOfDoors = 1;
        changerParameters->MagazineSize = 10;
    }

    changerParameters->NumberCleanerSlots = 0;
    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (PCHAR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Determine if mc has 2-sided media.
    //

    changerParameters->Features0 = transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->DriveCleanTimeout = 0;

    changerParameters->Features0 |= CHANGER_LOCK_UNLOCK                     |
                                    CHANGER_STATUS_NON_VOLATILE             |
                                    CHANGER_EXCHANGE_MEDIA                  |
                                    CHANGER_POSITION_TO_ELEMENT             |
                                    CHANGER_CARTRIDGE_MAGAZINE              |
                                    CHANGER_REPORT_IEPORT_STATE             |
                                    CHANGER_DEVICE_REINITIALIZE_CAPABLE     |
                                    CHANGER_SERIAL_NUMBER_VALID             |
                                    CHANGER_VOLUME_IDENTIFICATION           |
                                    CHANGER_VOLUME_REPLACE                  |
                                    CHANGER_VOLUME_SEARCH;

    changerParameters->PositionCapabilities = (CHANGER_TO_DRIVE | CHANGER_TO_SLOT | CHANGER_TO_IEPORT);
    changerParameters->LockUnlockCapabilities = (LOCK_UNLOCK_IEPORT);

    if (changerData->DriveType == SONY_CD) {
        changerParameters->Features0 &= ~(CHANGER_CARTRIDGE_MAGAZINE    |
                                          CHANGER_VOLUME_IDENTIFICATION |
                                          CHANGER_VOLUME_REPLACE        |
                                          CHANGER_VOLUME_SEARCH         |
                                          CHANGER_SERIAL_NUMBER_VALID   |
                                          CHANGER_BAR_CODE_SCANNER_INSTALLED);
        if (changerData->DriveID == CDL1100) {
            changerParameters->Features0 |= CHANGER_CLOSE_IEPORT | CHANGER_OPEN_IEPORT;
        } else {
            changerParameters->Features1 |= CHANGER_SLOTS_USE_TRAYS |
                                            CHANGER_MOVE_EXTENDS_IEPORT |
                                            CHANGER_MOVE_RETRACTS_IEPORT;
            changerParameters->Features0 &= ~CHANGER_REPORT_IEPORT_STATE;
        }
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);

    if (changerData->DriveType == SONY_MO) {
        RtlMoveMemory(productData->SerialNumber, changerData->SerialNumber, SONY_SERIAL_NUMBER_LENGTH);
    }

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;


    if (ElementOutOfRange(addressMapping, (USHORT)setAccess->Element.ElementAddress, setAccess->Element.ElementType)) {
        DebugPrint((1,
                   "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    if (setAccess->Element.ElementType == ChangerIEPort) {

        if (controlOperation == LOCK_ELEMENT) {


            //
            // Inc the lock count to indicate that a prevent is on the device.
            //

            InterlockedIncrement(&changerData->LockCount);

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue prevent media removal command to lock the ie port.
            //

            cdb->MEDIA_REMOVAL.Prevent = 1;

        } else if (controlOperation == UNLOCK_ELEMENT) {

            InterlockedExchange(&changerData->LockCount, 0);

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue allow media removal.
            //

            cdb->MEDIA_REMOVAL.Prevent = 0;

        } else {
            if (changerData->DriveType == SONY_MO) {
                status = STATUS_INVALID_PARAMETER;
            } else {

                if (controlOperation == EXTEND_IEPORT) {

                    srb->TimeOutValue = fdoExtension->TimeOutValue;

                    //
                    // Sony uses a vendor unique mailslot command.
                    // bytes 0/1 need to be the address of the mailslot (0x000A)
                    //

                    cdb->CDB6GENERIC.OperationCode = SCSIOP_ROTATE_MAILSLOT;

                    cdb->CDB6GENERIC.CommandUniqueBytes[0] = 0x00;
                    cdb->CDB6GENERIC.CommandUniqueBytes[1] = 0x0A;
                    cdb->CDB6GENERIC.CommandUniqueBytes[2] = SONY_MAILSLOT_OPEN;

                } else if (controlOperation == RETRACT_IEPORT) {

                    srb->TimeOutValue = fdoExtension->TimeOutValue;

                    //
                    // Sony uses a vendor unique mailslot command.
                    // bytes 0/1 need to be the address of the mailslot (0x000A)
                    //

                    cdb->CDB6GENERIC.OperationCode = SCSIOP_ROTATE_MAILSLOT;


                    cdb->CDB6GENERIC.CommandUniqueBytes[0] = 0x00;
                    cdb->CDB6GENERIC.CommandUniqueBytes[1] = 0x0A;
                    cdb->CDB6GENERIC.CommandUniqueBytes[2] = SONY_MAILSLOT_CLOSE;

                } else {
                    status = STATUS_INVALID_PARAMETER;
                }
            }
        }
    } else {

        //
        // No door/keypad selectivity programatically.
        //

        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    totalElements = 0;
    NTSTATUS status;
    PVOID    statusBuffer;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    if (elementType == AllElements) {

        ULONG i;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;
            totalElements += addressMapping->NumberOfElements[i];
        }

        if (totalElements != readElementStatus->ElementList.NumberOfElements) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) AllElements\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements));

            return STATUS_INVALID_PARAMETER;
        }

        //
        // Account for length of the descriptors expected for the drives.
        //


        if (readElementStatus->VolumeTagInfo) {

            length = sizeof(SONY_ELEMENT_DESCRIPTOR_PLUS) * totalElements;

            //
            // Add in header and status pages.
            //

            length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);

        } else {

            length = sizeof(SONY_ELEMENT_DESCRIPTOR) * totalElements;

            //
            // Add in header and status pages.
            //

            length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);

        }

    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        totalElements = readElementStatus->ElementList.NumberOfElements;
        if (totalElements > addressMapping->NumberOfElements[elementType]) {

            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) for type (%x)\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements,
                       elementType));

            return STATUS_INVALID_PARAMETER;
        }

        if (readElementStatus->VolumeTagInfo) {

            length = (sizeof(SONY_ELEMENT_DESCRIPTOR_PLUS) * totalElements);

        } else {

            length = (sizeof(SONY_ELEMENT_DESCRIPTOR) * totalElements);
        }

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);

    }

    DebugPrint((3,
               "ChangerGetElementStatus: Allocation Length %x, for %x elements of type %x\n",
               length,
               totalElements,
               elementType));

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // These devices may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG remainingElements;
        ULONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        ULONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        if (remainingElements > totalElements ) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Returned elements incorrect - %x\n",
                       remainingElements));

            ChangerClassFreePool(srb);
            ChangerClassFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                if (tagInfo) {

                    PSONY_ELEMENT_DESCRIPTOR_PLUS tmpDescriptor =
                                                            (PSONY_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor;

                    if (statusPage->PVolTag) {

                        RtlZeroMemory(elementStatus->PrimaryVolumeID, MAX_VOLUME_ID_SIZE);
                        RtlMoveMemory(elementStatus->PrimaryVolumeID, tmpDescriptor->PVolTagInformation, MAX_VOLUME_ID_SIZE);

                        elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                    }
                    if (statusPage->AVolTag) {

                        RtlZeroMemory(elementStatus->AlternateVolumeID, MAX_VOLUME_ID_SIZE);
                        //RtlMoveMemory(elementStatus->AlternateVolumeID, tmpDescriptor->AVolTagInformation, MAX_VOLUME_ID_SIZE);

                        elementStatus->Flags |= ELEMENT_STATUS_AVOLTAG;
                    }


                    if (elementDescriptor->IdValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_ID_VALID;
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }

                    if (elementDescriptor->LunValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_LUN_VALID;
                        elementStatus->Lun = elementDescriptor->Lun;
                    }

                    //
                    // Source address
                    //

                    if (elementDescriptor->SValid) {

                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                    }

                } else {

                    //
                    // Source address
                    //

                    if (elementDescriptor->SValid) {
                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];
                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                    }

                    if (elementDescriptor->IdValid) {
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }
                    if (elementDescriptor->LunValid) {
                        elementStatus->Lun = elementDescriptor->Lun;
                    }
                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);

                //
                // Map any exceptions reported directly.
                // If there is volume info returned ensure that it's not all spaces
                // as this indicates that the label is missing or unreadable.
                //

                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                    //
                    // Map the exception.
                    //

                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                } else if (elementStatus->Flags & ELEMENT_STATUS_PVOLTAG) {

                    ULONG index;

                    //
                    // Ensure that the tag info isn't all spaces. This indicates an error.
                    //

                    for (index = 0; index < MAX_VOLUME_ID_SIZE; index++) {
                        if (elementStatus->PrimaryVolumeID[index] != ' ') {
                            break;
                        }
                    }

                    //
                    // Determine if the volume id was all spaces. Do an extra check to see if media is
                    // actually present, for the unit will set the PVOLTAG flag whether media is present or not.
                    //

                    if ((index == MAX_VOLUME_ID_SIZE) && (elementStatus->Flags & ELEMENT_STATUS_FULL)) {

                        DebugPrint((1,
                                   "Sonymc.GetElementStatus: Setting exception to LABEL_UNREADABLE\n"));

                        elementStatus->Flags &= ~ELEMENT_STATUS_PVOLTAG;
                        elementStatus->Flags |= ELEMENT_STATUS_EXCEPT;
                        elementStatus->ExceptionCode = ERROR_LABEL_UNREADABLE;
                    }
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * totalElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue * 10;
        srb->DataTransferLength = 0;

    } else {

        ChangerClassFreePool(srb);
        return STATUS_INVALID_PARAMETER;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += addressMapping->FirstElement[setPosition->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{


    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_EXCHANGE_MEDIUM exchangeMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination1, destination2;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    LONG                lockValue = 0;
    NTSTATUS            status;


    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(exchangeMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(exchangeMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, exchangeMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination1 = (USHORT)(exchangeMedium->Destination1.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination1, exchangeMedium->Destination1.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination2 = (USHORT)(exchangeMedium->Destination2.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination2, exchangeMedium->Destination2.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[exchangeMedium->Source.ElementType];
    destination1 += addressMapping->FirstElement[exchangeMedium->Destination1.ElementType];
    destination2 += addressMapping->FirstElement[exchangeMedium->Destination2.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    if ((exchangeMedium->Destination1.ElementType == ChangerIEPort) ||
        (exchangeMedium->Destination2.ElementType == ChangerIEPort) ||
        (exchangeMedium->Source.ElementType == ChangerIEPort)) {

        //
        // Determine value of LockCount.
        // Note that if other functionality is added to this routine, EXTEND/RETRACT
        // will have to be split out from this else.
        //

        lockValue = changerData->LockCount;
        DebugPrint((1,
                   "ExchangeMedium: LockCount is %x\n",
                   lockValue));

        if (lockValue) {

            //
            // Send an allow to clear the prevent for IEPORT extend/retract.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            //
            // Ignore errors at this point. If this fails and the move doesn't happen, the LM will
            // clean things up.
            //

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
            DebugPrint((1,
                       "ExchangeMedium: Allow sent. Status %x\n",
                       status));

            status = STATUS_SUCCESS;
        }
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->EXCHANGE_MEDIUM.OperationCode = SCSIOP_EXCHANGE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->EXCHANGE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->EXCHANGE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->EXCHANGE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->EXCHANGE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[0] = (UCHAR)(destination1 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[1] = (UCHAR)(destination1 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[0] = (UCHAR)(destination2 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[1] = (UCHAR)(destination2 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Flip1 = exchangeMedium->Flip1;
    cdb->EXCHANGE_MEDIUM.Flip2 = exchangeMedium->Flip2;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_EXCHANGE_MEDIUM);
    }


    if ((exchangeMedium->Destination1.ElementType == ChangerIEPort) ||
        (exchangeMedium->Destination2.ElementType == ChangerIEPort) ||
        (exchangeMedium->Source.ElementType == ChangerIEPort)) {

        if (lockValue) {

            NTSTATUS preventStatus;

            //
            // Send the prevent to re-lock down the unit.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 1;

            //
            // Ignore any errors at this point. The calling layer will need to fixup any problems with
            // prevent/allow.
            //

            preventStatus = ChangerClassSendSrbSynchronous(DeviceObject,
                                                    srb,
                                                    NULL,
                                                    0,
                                                    FALSE);

            DebugPrint((1,
                       "ExchangeMedium: Prevent sent. Status %x\n",
                       preventStatus));
        }
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport;
    USHORT source;
    USHORT destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    LONG                lockValue = 0;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Check if an attempt is being made to move the medium from an element to
    // itself (drive1 to drive1, slot1 to slot1, etc). If so, just return
    // SUCCESS. Do nothing else unless Flip is set to TRUE. Flip is true
    // when the user just wants to flip the media, and not move per se.
    //
    if ((moveMedium->Flip == FALSE) &&
        (moveMedium->Source.ElementType == moveMedium->Destination.ElementType)) {
       if (source == destination) {
          DebugPrint((1, 
                      "Attempt to move from an element to itself. \n"));
          DebugPrint((1, 
                      "Element Type : %d, Source : %d, Destination %d. \n",
                      moveMedium->Source.ElementType, source, destination));
          return STATUS_SUCCESS;
       }
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    if ((moveMedium->Destination.ElementType == ChangerIEPort) ||
        (moveMedium->Source.ElementType == ChangerIEPort)) {

        //
        // Determine value of LockCount.
        // Note that if other functionality is added to this routine, EXTEND/RETRACT
        // will have to be split out from this else.
        //

        lockValue = changerData->LockCount;
        DebugPrint((1,
                   "MoveMedium: LockCount is %x\n",
                   lockValue));

        if (lockValue) {

            //
            // Send an allow to clear the prevent for IEPORT extend/retract.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            //
            // Ignore errors at this point. If this fails and the move doesn't happen, the LM will
            // clean things up.
            //

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
            DebugPrint((1,
                       "MoveMedium: Allow sent. Status %x\n",
                       status));

            status = STATUS_SUCCESS;
        }
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    } else {
        DebugPrint((1,
                   "MoveMedium: Status of Move %x\n",
                   status));
    }

    if ((moveMedium->Destination.ElementType == ChangerIEPort) ||
        (moveMedium->Source.ElementType == ChangerIEPort)) {

        if (lockValue) {

            NTSTATUS preventStatus;

            //
            // Send the prevent to re-lock down the unit.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 1;

            //
            // Ignore any errors at this point. The LM will fixup any problems with
            // prevent/allow
            //

            preventStatus = ChangerClassSendSrbSynchronous(DeviceObject,
                                    srb,
                                    NULL,
                                    0,
                                    FALSE);
            DebugPrint((1,
                       "MoveMedium: Prevent sent. Status %x\n",
                       preventStatus));
        }
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Issue a rezero unit to the device.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_REZERO_UNIT;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;


    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{


    PCHANGER_SEND_VOLUME_TAG_INFORMATION volTagInfo = Irp->AssociatedIrp.SystemBuffer;
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_ELEMENT    element = &volTagInfo->StartingElement;
    PSCSI_REQUEST_BLOCK srb;
    PVOID    tagBuffer;
    PCDB     cdb;
    NTSTATUS status;

    //
    // Do some validation.
    //

    if (changerData->DriveType == SONY_CD) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    switch (volTagInfo->ActionCode) {
        case SEARCH_ALL      :
        case SEARCH_PRIMARY  :
        case SEARCH_ALTERNATE:
        case SEARCH_ALL_NO_SEQ:
        case SEARCH_PRI_NO_SEQ:
        case SEARCH_ALT_NO_SEQ:
        case UNDEFINE_PRIMARY:
        case UNDEFINE_ALTERNATE:
        case ASSERT_PRIMARY:
        case ASSERT_ALTERNATE:
             break;

        case REPLACE_PRIMARY:
        case REPLACE_ALTERNATE:

            //
            // Ensure that only one element is being specified.
            //

            if (element->ElementType == AllElements) {

                DebugPrint((1,
                           "QueryVolumeTags: Attempting REPLACE on AllElements\n"));

                return STATUS_INVALID_DEVICE_REQUEST;
            }
            break;
        default:

            DebugPrint((1,
                       "QueryVolumeTags: Unsupported operation. ActionCode %x\n",
                       volTagInfo->ActionCode));

            return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    tagBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, MAX_VOLUME_TEMPLATE_SIZE);

    if (!srb || !tagBuffer) {

        if (srb) {
            ChangerClassFreePool(srb);
        }
        if (tagBuffer) {
            ChangerClassFreePool(tagBuffer);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    RtlZeroMemory(tagBuffer, MAX_VOLUME_TEMPLATE_SIZE);

    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataTransferLength = MAX_VOLUME_TEMPLATE_SIZE;

    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->SEND_VOLUME_TAG.OperationCode = SCSIOP_SEND_VOLUME_TAG;


    if ((volTagInfo->ActionCode == SEARCH_ALL)        ||
        (volTagInfo->ActionCode == SEARCH_PRIMARY)    ||
        (volTagInfo->ActionCode == SEARCH_ALTERNATE)  ||
        (volTagInfo->ActionCode == SEARCH_ALL_NO_SEQ) ||
        (volTagInfo->ActionCode == SEARCH_PRI_NO_SEQ) ||
        (volTagInfo->ActionCode == SEARCH_ALT_NO_SEQ)) {

        //
        // This is reserved for all other action codes.
        //

        cdb->SEND_VOLUME_TAG.ElementType = (UCHAR)element->ElementType;

        cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
        cdb->SEND_VOLUME_TAG.ParameterListLength[1] = MAX_VOLUME_TEMPLATE_SIZE;

        //
        // Load buffer with template.
        //

        RtlMoveMemory(tagBuffer, volTagInfo->VolumeIDTemplate, MAX_VOLUME_TEMPLATE_SIZE);


    } else if ((volTagInfo->ActionCode == UNDEFINE_PRIMARY)   ||
               (volTagInfo->ActionCode == UNDEFINE_ALTERNATE)) {

        cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
        cdb->SEND_VOLUME_TAG.ParameterListLength[1] = 0;

    } else if ((volTagInfo->ActionCode == REPLACE_PRIMARY)   ||
               (volTagInfo->ActionCode == REPLACE_ALTERNATE) ||
               (volTagInfo->ActionCode == ASSERT_PRIMARY)    ||
               (volTagInfo->ActionCode == ASSERT_ALTERNATE)) {


        cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
        cdb->SEND_VOLUME_TAG.ParameterListLength[1] = MAX_VOLUME_TEMPLATE_SIZE;

        //
        // Load buffer with template.
        //

        RtlMoveMemory(tagBuffer, volTagInfo->VolumeIDTemplate, MAX_VOLUME_TEMPLATE_SIZE);
    }


    if (element->ElementType == AllElements) {
        cdb->SEND_VOLUME_TAG.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->SEND_VOLUME_TAG.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {
        cdb->SEND_VOLUME_TAG.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->SEND_VOLUME_TAG.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    }

    cdb->SEND_VOLUME_TAG.ActionCode = (UCHAR)volTagInfo->ActionCode;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         tagBuffer,
                                         MAX_VOLUME_TEMPLATE_SIZE,
                                         TRUE);

    ChangerClassFreePool(tagBuffer);

    if (NT_SUCCESS(status)) {

        PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
        PVOID statusBuffer;
        ULONG returnElements = irpStack->Parameters.DeviceIoControl.OutputBufferLength / sizeof(READ_ELEMENT_ADDRESS_INFO);
        ULONG requestLength;

        //
        // Size of buffer returned is based on the size of the user buffer. If it's incorrectly
        // sized, the IoStatus.Information will be updated to indicate how large it should really be.
        //

        requestLength = sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE) +
                              (sizeof(SONY_ELEMENT_DESCRIPTOR_PLUS) * returnElements);

        statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, requestLength);
        if (!statusBuffer) {
            ChangerClassFreePool(srb);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(statusBuffer, requestLength);

        //
        // Build read volume element command.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB12GENERIC_LENGTH;
        srb->DataTransferLength = requestLength;

        srb->TimeOutValue = fdoExtension->TimeOutValue;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.OperationCode = SCSIOP_REQUEST_VOL_ELEMENT;
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.ElementType = (UCHAR)element->ElementType;

        if (element->ElementType == AllElements) {
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[0] =
                (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[1] =
                (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

        } else {
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[0] =
                (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[1] =
                (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
        }

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[0] = (UCHAR)(returnElements >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[1] = (UCHAR)(returnElements & 0xFF);

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.VolTag = 1;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[0] = (UCHAR)(requestLength >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[1] = (UCHAR)(requestLength & 0xFF);


        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             statusBuffer,
                                             requestLength,
                                             TRUE);


        if ((status == STATUS_SUCCESS) || (status == STATUS_DATA_OVERRUN)) {

            PREAD_ELEMENT_ADDRESS_INFO readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
            PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
            PELEMENT_STATUS_PAGE   statusPage;
            PCHANGER_ELEMENT_STATUS elementStatus;
            PELEMENT_DESCRIPTOR elementDescriptor;
            ULONG i;
            ULONG descriptorLength;
            ULONG numberElements;
            ULONG dataTransferLength = srb->DataTransferLength;

            //
            // Make it success.
            //

            status = STATUS_SUCCESS;

            //
            // Determine if ANY matches were found.
            //

            if (dataTransferLength <= sizeof(ELEMENT_STATUS_HEADER)) {
                numberElements = 0;
            } else {

                //
                // Subtract out header and page info.
                //

                dataTransferLength -= sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);
                numberElements = dataTransferLength / sizeof(SONY_ELEMENT_DESCRIPTOR_PLUS);

            }

            DebugPrint((1,
                       "QueryVolumeTags: Matches found - %x\n",
                       numberElements));

            //
            // Update IoStatus.Information to indicate the correct buffer size.
            // Account for the fact that READ_ELEMENT_ADDRESS_INFO is declared
            // with a one-element array of CHANGER_ELEMENT_STATUS.
            //

            Irp->IoStatus.Information = sizeof(READ_ELEMENT_ADDRESS_INFO) +
                                        ((numberElements - 1) *
                                         sizeof(CHANGER_ELEMENT_STATUS));

            //
            // Fill in user buffer.
            //

            readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
            RtlZeroMemory(readElementAddressInfo, irpStack->Parameters.DeviceIoControl.OutputBufferLength);

            readElementAddressInfo->NumberOfElements = numberElements;

            if (numberElements) {

                ELEMENT_TYPE        elementType;

                //
                // The buffer is composed of a header, status page, and element descriptors.
                // Point each element to it's respective place in the buffer.
                //


                (PCHAR)statusPage = (PCHAR)statusHeader;
                (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

                elementType = statusPage->ElementType;

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                elementStatus = &readElementAddressInfo->ElementStatus[0];

                //
                // Set values for each element descriptor.
                //

                for (i = 0; i < numberElements; i++ ) {

                    PSONY_ELEMENT_DESCRIPTOR_PLUS tmpDescriptor =
                                                            (PSONY_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor;

                    //
                    // Get the address for this element.
                    //

                    elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                    elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                    //
                    // Account for address mapping.
                    //

                    elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                    //
                    // Set the element type.
                    //

                    elementStatus->Element.ElementType = elementType;
                    elementStatus->Flags = 0;

                    //
                    // Source address
                    //

                    if (elementDescriptor->SValid) {

                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                    }


                    //
                    // Build Flags field.
                    //

                    elementStatus->Flags |= elementDescriptor->Full;
                    elementStatus->Flags |= (elementDescriptor->Exception << 2);
                    elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                    elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                    elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                    elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                    elementStatus->Flags |= (elementDescriptor->Invert << 22);
                    elementStatus->Flags |= (elementDescriptor->SValid << 23);

                    //
                    // Map any exceptions reported directly.
                    // If there is volume info returned ensure that it's not all spaces
                    // as this indicates that the label is missing or unreadable.
                    //

                    if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                        //
                        // Map the exception.
                        //

                        elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                    }

                    if (elementDescriptor->IdValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_ID_VALID;
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }

                    if (elementDescriptor->LunValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_LUN_VALID;
                        elementStatus->Lun = elementDescriptor->Lun;
                    }

                    if (statusPage->PVolTag) {

                        RtlZeroMemory(elementStatus->PrimaryVolumeID, MAX_VOLUME_ID_SIZE);
                        RtlMoveMemory(elementStatus->PrimaryVolumeID, tmpDescriptor->PVolTagInformation, MAX_VOLUME_ID_SIZE);

                        elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                    }
                    if (statusPage->AVolTag) {
                        RtlZeroMemory(elementStatus->AlternateVolumeID, MAX_VOLUME_ID_SIZE);
                        //RtlMoveMemory(elementStatus->AlternateVolumeID, tmpDescriptor->AVolTagInformation, MAX_VOLUME_ID_SIZE);

                        elementStatus->Flags |= ELEMENT_STATUS_AVOLTAG;
                    }

                    //
                    // Advance to the next entry in the user buffer and element descriptor array.
                    //

                    elementStatus += 1;
                    (PCHAR)elementDescriptor += descriptorLength;
                }
            }
        } else {
            DebugPrint((1,
                       "QueryVolumeTags: RequestElementAddress failed. %x\n",
                       status));
        }

        ChangerClassFreePool(statusBuffer);

    } else {
        DebugPrint((1,
                   "QueryVolumeTags: Send Volume Tag failed. %x\n",
                   status));
    }
    if (srb) {
        ChangerClassFreePool(srb);
    }
    return status;
}


NTSTATUS
SonyBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    ULONG                  bufferLength;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);


    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = SONY_NO_ELEMENT;
    }

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];

        //
        // Determine lowest address of all elements.
        //


        addressMapping->LowAddress = SONY_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{

    ULONG exceptionCode = 0;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;


    switch (asc) {
        case 0x0:
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    DebugPrint((1,
               "Sonymc.MapExceptionCode: ASC %x, ASCQ %x, exceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == SONY_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{

   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize DeviceStatusin the device extension to 
   // SONYMC_DEVICE_PROBLEM_NONE. If the changer returns sense code 
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set appropriate 
   // DeviceStatus in ChangerError routine.
   //
   changerData->DeviceStatus = SONYMC_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "SONYMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set SelfTest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) == SONYMC_DEVICE_PROBLEM_NONE) {
      switch (changerData->DeviceStatus) {
         case SONYMC_HW_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }

         default: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }
      } // switch(changerData->DeviceStatus)
   }

   ChangerClassFreePool(srb);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\sonymc\sonymc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    sonymc.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _SONYMC_H_
#define _SONYMC_H_

typedef struct _SONY_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
} SONY_ELEMENT_DESCRIPTOR, *PSONY_ELEMENT_DESCRIPTOR;

typedef struct _SONY_ELEMENT_DESCRIPTOR_PLUS {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR PVolTagInformation[36];
    UCHAR AVolTagInformation[36];
} SONY_ELEMENT_DESCRIPTOR_PLUS, *PSONY_ELEMENT_DESCRIPTOR_PLUS;

#define SONY_NO_ELEMENT          0xFFFF

#define SONY_SERIAL_NUMBER_LENGTH 16

typedef struct _SERIAL_NUMBER {
    UCHAR DeviceType;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR ControllerSerialNumber[SONY_SERIAL_NUMBER_LENGTH];
    UCHAR MechanicalSerialNumber[SONY_SERIAL_NUMBER_LENGTH];
} SERIAL_NUMBER, *PSERIAL_NUMBER;

#define SCSIOP_ROTATE_MAILSLOT 0xC0
#define SONY_MAILSLOT_CLOSE 0x00
#define SONY_MAILSLOT_OPEN 0x01

#define SONY_MO 0x01
#define SONY_CD 0x02

#define CDL1100 0x01
#define CDL5000 0x02

//
// Diagnostic related defines
//
#define SONYMC_DEVICE_PROBLEM_NONE      0x00
#define SONYMC_HW_ERROR                 0x01

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type, either optical or dlt.
    //

    ULONG DriveType;

    //
    // Drive Id. Based on inquiry.
    //

    ULONG DriveID;

    //
    // INTERLOCKED counter of the number of prevent/allows.
    // As the Sony units lock the IEPort on these operations
    // MoveMedium/SetAccess might need to clear a prevent
    // to do the operation.
    //

    LONG LockCount;

    //
    // Device Status after diagnostic test is completed.
    //
    ULONG DeviceStatus;

    //
    // Cached unique serial number.
    //

    UCHAR SerialNumber[SONY_SERIAL_NUMBER_LENGTH];

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;


//
// Internal routines
//
NTSTATUS
SonyBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );


#endif // _SONYMC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\snyaitmc\snyaitmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    hpmc.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _SNYAIT_MC_
#define _SNYAIT_MC_

typedef struct _SONY_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
} SONY_ELEMENT_DESCRIPTOR, *PSONY_ELEMENT_DESCRIPTOR;

typedef struct _SONY_ELEMENT_DESCRIPTOR_PLUS {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR PVolTagInformation[36];
    UCHAR AVolTagInformation[36];
} SONY_ELEMENT_DESCRIPTOR_PLUS, *PSONY_ELEMENT_DESCRIPTOR_PLUS;

#define SONY_NO_ELEMENT          0xFFFF

#define SONY_SERIAL_NUMBER_LENGTH 16

typedef struct _SERIAL_NUMBER {
    UCHAR DeviceType;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR ControllerSerialNumber[SONY_SERIAL_NUMBER_LENGTH];
    UCHAR MechanicalSerialNumber[SONY_SERIAL_NUMBER_LENGTH];
} SERIAL_NUMBER, *PSERIAL_NUMBER;


//
// Diagnostic related defines
//
typedef struct _SNYAITMC_RECV_DIAG {
    UCHAR ErrorSet : 4;
    UCHAR Reserved1 : 2;
    UCHAR TimeReSync : 1;
    UCHAR ResetError : 1;
    UCHAR ErrorCode;
    UCHAR ResultA;
    UCHAR ResultB;
    UCHAR TestNumber;
} SNYAITMC_RECV_DIAG, *PSNYAITMC_RECV_DIAG;

#define SNYAITMC_DEVICE_PROBLEM_NONE    0x00
#define SNYAITMC_HW_ERROR               0x01


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type, either optical or dlt.
    //

    ULONG DriveType;

    //
    // Drive Id. Based on inquiry.
    //

    ULONG DriveID;

    //
    // INTERLOCKED counter of the number of prevent/allows.
    // As these units lock the IEPort on these operations
    // Move/ExchangeMedium might need to clear a prevent
    // to do the operation.
    //

    LONG LockCount;

    //
    // Device Status after diagnostic command
    //
    ULONG DeviceStatus;

    //
    // Cached unique serial number.
    //

    UCHAR SerialNumber[SONY_SERIAL_NUMBER_LENGTH];

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif    

} CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS
SonyBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

VOID
ProcessDiagnosticResult(   
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError,
    IN PUCHAR resultBuffer
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\spectra\spctramc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    spctramc.c

Abstract:

    This module contains device-specific routines for the following
    Spectralogic medium changers: 
            - Spectra 4000, 5000, 9000, 10000

Author:

    davet (Dave Therrien - HighGround Systems)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "spctramc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, ExaBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


typedef struct _SERIALNUMBER {
    UCHAR DeviceType;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SerialNumber[VPD_SERIAL_NUMBER_LENGTH];
} SERIALNUMBER, *PSERIALNUMBER;



NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PSERIALNUMBER  serialBuffer;
    PVUPL_MODE_PAGE modeBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = ExaBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "BuildAddressMapping failed. %x\n", status));
        // Don't fail this here , this unit has a problem with 
        // being not ready for a long time 

        // return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                                sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Now get the full inquiry information for the device.

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
    srb.TimeOutValue = 10;
    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;
    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;
    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         dataBuffer,
                                         sizeof(INQUIRYDATA),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength +
                             FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }

        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        if (RtlCompareMemory(dataBuffer->ProductId,"4000",4) == 4) {
            changerData->DriveID = S_4mm_4000;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"5000",4) == 4) {
            changerData->DriveID = S_4mm_5000;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"9000",4) == 4) {
            changerData->DriveID = S_8mm_EXB;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"10000",5) == 5) {
            changerData->DriveID = S_8mm_SONY;
        } else if (RtlCompareMemory(dataBuffer->ProductId, "215", 3)) {
            changerData->DriveID = S_8mm_AIT;
        }
    }

    // -------------------------------------------------------------------
    // 
    // Get serial number page for the 10000 and Treefrog units only
    // not supported on 4000, 5000 and 9000 units !

    if (changerData->DriveID == S_8mm_SONY) {

        serialBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(SERIALNUMBER));
        if (!serialBuffer) {
            ChangerClassFreePool(dataBuffer);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(serialBuffer, sizeof(SERIALNUMBER));

        RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
        srb.TimeOutValue = 10;
        srb.CdbLength = 6;

        cdb = (PCDB)srb.Cdb;
        cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

        // Set EVPD
        cdb->CDB6INQUIRY.Reserved1 = 1;

        // Unit serial number page.
        cdb->CDB6INQUIRY.PageCode = 0x80;

        // Set allocation length to inquiry data buffer size.
        cdb->CDB6INQUIRY.AllocationLength = sizeof(SERIALNUMBER);

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         serialBuffer,
                                         sizeof(SERIALNUMBER),
                                         FALSE);

        if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
            SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

            RtlMoveMemory(changerData->SerialNumber, serialBuffer->SerialNumber, 
                          VPD_SERIAL_NUMBER_LENGTH);

            ChangerClassFreePool(serialBuffer);
        }
    }

    ChangerClassFreePool(dataBuffer);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PIRP irp = Srb->OriginalRequest;


    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_NOT_READY:
           if (senseBuffer->AdditionalSenseCode == 0x04) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x84:
                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;
                    default:
                        break;
                }
            }
            break;

        case SCSI_SENSE_HARDWARE_ERROR:
           changerData->DeviceStatus = SPECTRA_HW_ERROR;
           if (senseBuffer->AdditionalSenseCode == 0x85) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x23:
                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_NOT_CONNECTED;
                        break;
                    default:
                        break;
                }
            }
            break;

        default:
            break;
        }
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    PVUPL_MODE_PAGE vuplModePage;
    NTSTATUS status;
    ULONG    length;
    PVOID    modeBuffer;
    PCDB     cdb;

    if (addressMapping->Initialized != TRUE) {
        status = ExaBuildAddressMapping(DeviceObject);
        if (status != STATUS_SUCCESS) {
            DebugPrint((1,
                       "Spctrmc: InitElementStatus: Build address map failed %x\n",
                       status));
            return status;
        }
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (srb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1D - Element address assignment page.

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                sizeof(MODE_PARAMETER_HEADER) +
                                sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    // Send the request.
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    // Fill in values.

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = 
                 elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= 
                 (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = 
                 elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= 
                 (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = 
                 elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= 
                 (elementAddressPage->NumberIEPortElements[0] << 8);
    
    changerParameters->NumberDataTransferElements = 
                 elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= 
                 (elementAddressPage->NumberDataXFerElements[0] << 8);

    changerParameters->NumberOfDoors = 0;
    if (changerData->DriveID == S_8mm_AIT) {
        changerParameters->NumberOfDoors = 1;
    }

    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;
    changerParameters->FirstCleanerSlotAddress = 0;

    changerParameters->MagazineSize = 
                     changerParameters->NumberStorageElements;

    changerParameters->DriveCleanTimeout = 600;

    ChangerClassFreePool(modeBuffer);

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1E - transport geometry mode sense.

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                             sizeof(MODE_PARAMETER_HEADER) +
                             sizeof(MODE_PAGE_TRANSPORT_GEOMETRY));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_TRANSPORT_GEOMETRY_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    // Send the request.
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (ULONG_PTR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

    // initialize Features1  
        changerParameters->Features1 = CHANGER_IEPORT_USER_CONTROL_OPEN |
                                                                   CHANGER_IEPORT_USER_CONTROL_CLOSE ;

    // initialize Features 0 and then set flip bit... 
    changerParameters->Features0 = 
             transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

    // Features based on manual, nothing programatic.
    changerParameters->Features0 |= 
               CHANGER_STATUS_NON_VOLATILE           | 
               CHANGER_LOCK_UNLOCK                   |                                   
               CHANGER_POSITION_TO_ELEMENT           |
               CHANGER_REPORT_IEPORT_STATE           |
               CHANGER_DRIVE_CLEANING_REQUIRED       |
               CHANGER_PREDISMOUNT_EJECT_REQUIRED;

        // Only the IEPORT can be locked and unlocked
    changerParameters->LockUnlockCapabilities = LOCK_UNLOCK_IEPORT;

    // Serial number not supported on 4000 and 9000 libraries
    // Serial number is supported on 5000, 10000 and Treefrog units
    if (changerData->DriveID == S_8mm_SONY) {
        changerParameters->Features0 |= 
               CHANGER_SERIAL_NUMBER_VALID;
    } 
   
    ChangerClassFreePool(modeBuffer);

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 00 - Vendor Unique Parameter List Page
    //                          Is Barcode reader installed ? 

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    length =  sizeof(MODE_PARAMETER_HEADER) + 
              sizeof(VUPL_MODE_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = 0;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    vuplModePage = modeBuffer;
    (ULONG_PTR)vuplModePage += sizeof(MODE_PARAMETER_HEADER);

    // EBarCo is set if there is a barcode reader installed
    if (vuplModePage->EBarCo == 1) { 
         changerParameters->Features0 |=
                             CHANGER_BAR_CODE_SCANNER_INSTALLED; 
    }

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1F - Device Capabilities Page

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    length =  sizeof(MODE_PARAMETER_HEADER) + 
              sizeof(MODE_DEVICE_CAPABILITIES_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    // Fill in values in Features that are contained in this page.

    changerParameters->Features0 |= 
     capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= 
     capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= 
     capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= 
     capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    // Determine all the move from and exchange from 
    // capabilities of this device.

    changerParameters->MoveFromTransport = 
     capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= 
     capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= 
     capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= 
     capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = 
     capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= 
     capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= 
     capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= 
     capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = 
     capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= 
     capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= 
     capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= 
     capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = 
     capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= 
     capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= 
     capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= 
     capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = 
     capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= 
     capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= 
     capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= 
     capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = 
     capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= 
     capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= 
     capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= 
     capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = 
     capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= 
     capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= 
     capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= 
     capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = 
     capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= 
     capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= 
     capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= 
     capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

        
        // legal Position capabilities... 
        changerParameters->PositionCapabilities = 
                        CHANGER_TO_SLOT | 
                        CHANGER_TO_IEPORT | 
                        CHANGER_TO_DRIVE;
                

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}



NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);
    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    //
    // Copy cached inquiry data fields into the system buffer.
    //
    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA)); 

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, 
                  VENDOR_ID_LENGTH);

    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, 
                  PRODUCT_ID_LENGTH);

    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, 
                  REVISION_LENGTH);

    RtlMoveMemory(productData->SerialNumber, changerData->SerialNumber, 
                  VPD_SERIAL_NUMBER_LENGTH);

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the Door or IEPort. 

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    BOOLEAN             writeToDevice = FALSE;

    // could lock the front panel, but it may be needed for other 
    // operator tasks. 
    if ((setAccess->Element.ElementType == ChangerKeypad) ||
        (setAccess->Element.ElementType == ChangerDoor)) {
              return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (setAccess->Element.ElementType == ChangerIEPort) {

        // Do Prevent/Allow Medium  Removal... 
        srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
        if (!srb) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

        srb->DataBuffer = NULL;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = 10;

        if (controlOperation == LOCK_ELEMENT) {
            cdb->MEDIA_REMOVAL.Prevent = 1;
        } else if (controlOperation == UNLOCK_ELEMENT) {
            cdb->MEDIA_REMOVAL.Prevent = 0;
        } else {
            status = STATUS_INVALID_PARAMETER;
        }
    } else {
       return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (NT_SUCCESS(status)) {
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             FALSE);
    }

    if (srb->DataBuffer) {
        ChangerClassFreePool(srb->DataBuffer);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command 
    for either all elements or the
    specified element type. The buffer returned is used to build 
    the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    NTSTATUS status;
    PVOID    statusBuffer;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    // Get the element type.
    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    // Q215 does not report IEPORT status

    if (elementType == AllElements) {
        statusPages = 4;
    } else {
        statusPages = 1;
    } 

    if (readElementStatus->VolumeTagInfo) {
        length = sizeof(ELEMENT_STATUS_HEADER) + 
            (statusPages * sizeof(ELEMENT_STATUS_PAGE)) +
            (SPC_FULL_SIZE * 
                readElementStatus->ElementList.NumberOfElements);
    } else {
        length = sizeof(ELEMENT_STATUS_HEADER) + 
            (statusPages * sizeof(ELEMENT_STATUS_PAGE)) +
            (SPC_PARTIAL_SIZE * 
                readElementStatus->ElementList.NumberOfElements);
    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
        (UCHAR)((element->ElementAddress + 
        addressMapping->FirstElement[element->ElementType]) >> 8);
    cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
        (UCHAR)((element->ElementAddress + 
        addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] =         
        (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] =         (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] =
                                      (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] =
                                      (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] =
                                      (UCHAR)(length & 0xFF);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {
        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PSPC_ED elementDescriptor;
        ULONG numberElements = 
             readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        // Determine total number elements returned.
        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        // The buffer is composed of a header, status page, 
        // and element descriptors.
        // Point each element to it's respective place in the buffer.

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = 
           statusPage->ElementDescriptorLength[1];
        descriptorLength |= 
           (statusPage->ElementDescriptorLength[0] << 8);

        // Determine the number of elements of this type reported.
        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        // Fill in user buffer.
        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, outputBuffLen);

        do {
            for (i = 0; i < typeCount; i++, remainingElements--) {

                // Get the address for this element.

                elementStatus->Element.ElementAddress =
                 elementDescriptor->SPC_FED.ElementAddress[1];

                elementStatus->Element.ElementAddress |=
                  (elementDescriptor->SPC_FED.ElementAddress[0] << 8);

                // Account for address mapping.
                elementStatus->Element.ElementAddress -= 
                   addressMapping->FirstElement[elementType];

                // Set the element type.
                elementStatus->Element.ElementType = elementType;

                if (elementDescriptor->SPC_FED.SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    // Source address is valid. 
                    // Determine the device specific address.
                    tmpAddress = elementDescriptor->SPC_FED.SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SPC_FED.SourceStorageElementAddress[0] << 8);

                    // Now convert to 0-based values.
                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress =
                         tmpAddress - addressMapping->FirstElement[j];

                }

                // Build Flags field.

                elementStatus->Flags = 
                 elementDescriptor->SPC_FED.Full;
                elementStatus->Flags |= 
                 (elementDescriptor->SPC_FED.Exception << 2);
                elementStatus->Flags |= 
                 (elementDescriptor->SPC_FED.Accessible << 3);

                elementStatus->Flags |= 
                 (elementDescriptor->SPC_FED.LunValid << 12);
                elementStatus->Flags |= 
                 (elementDescriptor->SPC_FED.IdValid << 13);
                elementStatus->Flags |= 
                 (elementDescriptor->SPC_FED.NotThisBus << 15);

                elementStatus->Flags |= 
                 (elementDescriptor->SPC_FED.Invert << 22);
                elementStatus->Flags |= 
                 (elementDescriptor->SPC_FED.SValid << 23);


                if (tagInfo) {
                    RtlMoveMemory(elementStatus->PrimaryVolumeID, 
                        elementDescriptor->SPC_FED.PrimaryVolumeTag, 
                        MAX_VOLUME_ID_SIZE);
                    elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                }

                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {
                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                }

                // if the Pvoltag field is all nulls, this indicates a missing 
                // barcode label as well. 

                if (elementStatus->Flags & ELEMENT_STATUS_PVOLTAG) {

                    ULONG index;
                    for (index = 0; index < MAX_VOLUME_ID_SIZE; index++) {
                        if (elementStatus->PrimaryVolumeID[index] != '\0') {
                            break;
                        }
                    }

                    //
                    // Determine if the volume id was all spaces. Do an extra check to see if media is
                    // actually present, for the unit will set the PVOLTAG flag whether media is present or not.
                    //

                    if ((index == MAX_VOLUME_ID_SIZE) && 
                        (elementStatus->Flags & ELEMENT_STATUS_FULL)) {

                        elementStatus->Flags &= ~ELEMENT_STATUS_PVOLTAG;
                        elementStatus->Flags |= ELEMENT_STATUS_EXCEPT;
                        elementStatus->ExceptionCode = ERROR_LABEL_UNREADABLE;
                    }
                }


                if (elementDescriptor->SPC_FED.IdValid) {
                    elementStatus->TargetId = 
                     elementDescriptor->SPC_FED.BusAddress;
                }
                if (elementDescriptor->SPC_FED.LunValid) {
                    elementStatus->Lun = elementDescriptor->SPC_FED.Lun;
                }



                // Get next descriptor.
                (ULONG_PTR)elementDescriptor += descriptorLength;

                // Advance to the next entry in the user 
                // buffer and element descriptor array.
                elementStatus += 1;
            }

            if (remainingElements > 0) {
                // Get next status page.
                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;
                elementType = statusPage->ElementType;

                // Point to decriptors.
                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = 
                   statusPage->ElementDescriptorLength[1];
                descriptorLength |= 
                   (statusPage->ElementDescriptorLength[0] << 8);

                // Determine the number of this element type reported.
                typeCount = statusPage->DescriptorByteCount[2];
                typeCount |= (statusPage->DescriptorByteCount[1] << 8);
                typeCount |= (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = 
                sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}



NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either 
    initialize all elements or the specified range of elements 
    using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    if (addressMapping->Initialized != TRUE) {
        status = ExaBuildAddressMapping(DeviceObject);
        if (status != STATUS_SUCCESS) {
            DebugPrint((1,
                       "Spctrmc: InitElementStatus: Build address map failed %x\n",
                       status));
            return status;
        }
    }

    // IES w/Range is only supported on Q215
    // 
    if (initElementStatus->ElementList.Element.ElementType != 
                                                 AllElements) {
        return STATUS_INVALID_DEVICE_REQUEST;
    } 

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    // All elements requested...
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;
    srb->DataTransferLength = 0;

    cdb->INIT_ELEMENT_STATUS.OperationCode = 
                                  SCSIOP_INIT_ELEMENT_STATUS;
    cdb->INIT_ELEMENT_STATUS.NoBarCode = 
        initElementStatus->BarCodeScan ? 0 : 1;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 
                     sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the 
    robotic mechanism to the specified
    element address. Normally used to optimize moves or 
    exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    if ((setPosition->Destination.ElementType == ChangerKeypad) ||
        (setPosition->Destination.ElementType == ChangerDoor)   ||
        (setPosition->Destination.ElementType == ChangerMaxElement)) {
        return STATUS_INVALID_PARAMETER;
    }

    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.

    transport = (USHORT)(setPosition->Transport.ElementAddress);
    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);
    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    // Convert to device addresses.

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += 
     addressMapping->FirstElement[setPosition->Destination.ElementType];

    if (setPosition->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    // Build srb and cdb.

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    // Build device-specific addressing.

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] =
                    (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = 
                    (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = 
                    (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = 
                    (UCHAR)(destination & 0xFF);

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    None of the units support exchange medium.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }


    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // If the source or destination is an IEPORT,
    // do an allow before the move and a prevent after the move.
    // This works around the behaviour of the device whereby a PreventMediumRemoval
    // inhibits a MoveMedium to/from the IEPORT.
    //

    if ((moveMedium->Destination.ElementType == ChangerIEPort) ||
        (moveMedium->Source.ElementType == ChangerIEPort)) {

        //
        // Send an allow to clear the prevent for IEPORT extend/retract.
        //

        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = fdoExtension->TimeOutValue;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 0;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
        status = STATUS_SUCCESS;
    }

    // Convert to device addresses.
    //
    transport += 
      addressMapping->FirstElement[ChangerTransport];
    source += 
      addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += 
      addressMapping->FirstElement[moveMedium->Destination.ElementType];

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;
    srb->DataTransferLength = 0;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = 
      (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = 
      (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = 
      (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = 
      (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = 
      (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = 
      (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }


    if ((moveMedium->Destination.ElementType == ChangerIEPort) ||
        (moveMedium->Source.ElementType == ChangerIEPort)) {

        //
        // Send a prevent to prevent further IEPORT extend/retract.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = fdoExtension->TimeOutValue;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 1;

        ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
    }


    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    // there is no command on these libraries to home or reinit the 
    // changer mechanism

    return STATUS_INVALID_DEVICE_REQUEST;
}




NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = SPC_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                sizeof(MODE_PARAMETER_HEADER) +
                                sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = 
         (elementAddressPage->MediumTransportElementAddress[0] << 8) |
         elementAddressPage->MediumTransportElementAddress[1];

        addressMapping->FirstElement[ChangerDrive] = 
         (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
         elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = 
         (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
         elementAddressPage->FirstIEPortElementAddress[1];

        addressMapping->FirstElement[ChangerSlot] = 
         (elementAddressPage->FirstStorageElementAddress[0] << 8) |
         elementAddressPage->FirstStorageElementAddress[1];

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = 
         elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= 
         (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = 
         elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= 
         (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = 
         elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= 
         (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = 
         elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= 
         (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 1;

        addressMapping->Initialized = TRUE;
    }


    // Determine the lowest element address for use with AllElements.
    //
    for (i = 0; i < ChangerDrive; i++) {
        if (addressMapping->FirstElement[i] < 
                         addressMapping->FirstElement[AllElements]) {
            addressMapping->FirstElement[AllElements] = 
                                     addressMapping->FirstElement[i];
        }
    }

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



ULONG
MapExceptionCodes(
    IN PSPC_ED ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor 
    and creates the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asc = ElementDescriptor->SPC_FED.AdditionalSenseCode;
    UCHAR asq = ElementDescriptor->SPC_FED.AddSenseCodeQualifier;
    ULONG exceptionCode = 0;

    if (asc == 0x85) {
        switch (asq) {
                case 0x33:
                    exceptionCode = ERROR_LABEL_UNREADABLE;
                    break;

                case 0x23:
                    exceptionCode = ERROR_DRIVE_NOT_INSTALLED;
                    break;

                default:
                    exceptionCode = ERROR_UNHANDLED_ERROR;

        }
    }

    if (asc == 0x83) {    
        switch (asq) {
                case 0x00:
                case 0x01:
                    exceptionCode = ERROR_LABEL_UNREADABLE;
                    break;

                default:
                    exceptionCode = ERROR_UNHANDLED_ERROR;
        }
    }

    return exceptionCode;
}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == SPC_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the devicestatus in the device extension to
   // SPECTRA_DEVICE_PROBLEM_NONE. If the changer returns sense code
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set an appropriate
   // devicestatus.
   //
   changerData->DeviceStatus = SPECTRA_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "SPCTRAMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set selftest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) != SPECTRA_DEVICE_PROBLEM_NONE) {
         changerDeviceError->ChangerProblemType = DeviceProblemHardware;
   }
   
   ChangerClassFreePool(srb);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\drivers\spectra\spctramc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    spctra.h

Abstract:

Authors:

    davet (Dave Therrien)

Revision History:

--*/
#ifndef _SPCTRA_MC_
#define _SPCTRA_MC_


typedef union _SPC_ED {

    struct _SPC_FED {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR PrimaryVolumeTag[36];
        UCHAR Reserved8[4];
    } SPC_FED, *PSPC_FED;

    struct _SPC_PED {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved8[4];
    } SPC_PED, *PSPC_PED;

} SPC_ED, *PSPC_ED;

#define SPC_PARTIAL_SIZE sizeof(struct _SPC_PED)
#define SPC_FULL_SIZE sizeof(struct _SPC_FED)

#define SPC_DISPLAY_LINES        4
#define SPC_DISPLAY_LINE_LENGTH  20

// LCD Mode Page - Page 0x22

typedef struct _LCD_MODE_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR WriteLine : 4;
    UCHAR Reserved2 : 2;
    UCHAR FrontPanelLock : 1;
    UCHAR DoorUnlock : 1;
    UCHAR Reserved4;
    UCHAR DisplayLine[SPC_DISPLAY_LINES][SPC_DISPLAY_LINE_LENGTH];
} LCD_MODE_PAGE, *PLCD_MODE_PAGE;


// Vendor Unique Parameter List Mode Page - 00 

typedef struct _VUPL_MODE_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR EBarCo : 1;
    UCHAR ChkSum : 1;
    UCHAR Auto : 1;
    UCHAR QueuedUnload;
    UCHAR LockTouchScreen;
    UCHAR Reserved[5];
} VUPL_MODE_PAGE, *PVUPL_MODE_PAGE;


#define SPC_NO_ELEMENT 0xFFFF


#define S_4mm_4000    1
#define S_8mm_EXB     2
#define S_8mm_SONY    3
#define S_4mm_5000    4
#define S_8mm_AIT     5

#define VPD_SERIAL_NUMBER_LENGTH 10

//
// DeviceStatus codes for diagnostic tests
//
#define SPECTRA_DEVICE_PROBLEM_NONE     0x00
#define SPECTRA_HW_ERROR                0x01

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Unique identifier for the supported models. See above.
    //

    ULONG DriveID;

    //
    // Device Status after diagnostic test is completed
    //
    ULONG DeviceStatus;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached unique serial number.
    //

    UCHAR SerialNumber[VPD_SERIAL_NUMBER_LENGTH];

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PSPC_ED ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\tools\mct.h ===
#ifndef _MCT_H
#define _MCT_H

typedef DWORD MCT_STATUS;

VOID
mctDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

//
// Switch chars for calling Changer IOCTLs
//
#define INIT_ELEMENT_STATUS          'i'
#define GET_ELEMENT_STATUS           'e'
#define GET_PARAMETERS               'p'
#define GET_STATUS                   's'
#define GET_PRODUCT_DATA             'd'
#define SET_ACCESS                   'a'
#define SET_POSITION                 'o'
#define EXCHANGE_MEDIUM              'x'
#define MOVE_MEDIUM                  'm'
#define REINITIALIZE_TRANSPORT       'r'
#define QUERY_VOLUME_TAG             'q'

//
// Changer Element Types
//
#define CHANGER_ALL_ELEMENTS 'A'
#define CHANGER_SLOT         'S'
#define CHANGER_DRIVE        'D'
#define CHANGER_TRANSPORT    'T'
#define CHANGER_KEYPAD       'K'
#define CHANGER_IEPORT       'I'
#define CHANGER_DOOR         'O'

//
// Control codes for SetAccess 
//
#define CHANGER_EXTEND_IEPORT   'E'
#define CHANGER_RETRACT_IEPORT  'R'
#define CHANGER_LOCK_ELEMENT    'L'
#define CHANGER_UNLOCK_ELEMENT  'U'

//
// MCT_STATUS Codes
//
#define MCT_STATUS_SUCCESS 0
#define MCT_STATUS_FAILED 1

#define PRINT_MOVE_CAPABILITIES(Element, Name)  \
   if ((Element) != 0) { \
      printf("\n Changer can move from %s to :\n", Name); \
      if ((Element) & CHANGER_TO_TRANSPORT) \
         printf("\t\t Transport\n"); \
      if ((Element) & CHANGER_TO_SLOT) \
         printf("\t\t Slot\n"); \
      if ((Element) & CHANGER_TO_IEPORT) \
         printf("\t\t IEPort\n"); \
      if ((Element) & CHANGER_TO_DRIVE) \
         printf("\t\t Drive\n"); \
      printf("\n"); \
   }

#define PRINT_EXCHANGE_CAPABILITIES(Element, Name) \
   if ((Element) != 0) { \
      printf("\n Changer can exchange between %s and :\n", Name); \
      if ((Element) & CHANGER_TO_TRANSPORT) \
         printf("\t\t Transport\n"); \
      if ((Element) & CHANGER_TO_SLOT) \
         printf("\t\t Slot\n"); \
      if ((Element) & CHANGER_TO_IEPORT) \
         printf("\t\t IEPort\n"); \
      if ((Element) & CHANGER_TO_DRIVE) \
         printf("\t\t Drive\n"); \
      printf("\n"); \
   }

#define PRINT_LOCK_UNLOCK_CAPABILITY(Value, Element, Name) \
      if ((Value) & Element) { \
         printf(" Changer is Capable of Locking\\Unlocking %s.\n", Name); \
      } 

#define PRINT_POSITION_CAPABILITY(Value, Element, Name) \
      if ((Value) & Element) { \
         printf(" Changer is Capable of positioning transport to %s.\n", Name); \
      } 

//
// Function prototypes
//
VOID mctPrintUsage();
BOOLEAN mctOpenChanger();
VOID mctCloseChanger();
MCT_STATUS mctInitElementStatus();
MCT_STATUS mctGetElementStatus(CHAR, USHORT);
MCT_STATUS mctGetParameters(BOOLEAN);
MCT_STATUS mctGetStatus();
MCT_STATUS mctGetProductData();
MCT_STATUS mctSetAccess(CHAR, USHORT, CHAR);
MCT_STATUS mctSetPosition(CHAR, USHORT);
MCT_STATUS mctExchangeMedium(CHAR, USHORT, CHAR, USHORT, 
                              CHAR, USHORT, CHAR, USHORT);
MCT_STATUS mctMoveMedium(CHAR, USHORT, CHAR, USHORT, CHAR, USHORT);
MCT_STATUS mctReinitTransport();
MCT_STATUS mctQueryVolumeTag();

#endif // _MCT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\espprot.cxx ===
extern "C" {
    #include <ntosp.h>
    #include <zwapi.h>
}

#include <ftdisk.h>


NTSTATUS
FtpApplyESPProtection(
    IN  PUNICODE_STRING PartitionName
    )

{
    ULONG               length;
    PACL                acl;
    NTSTATUS            status;
    SECURITY_DESCRIPTOR sd;
    OBJECT_ATTRIBUTES   oa;
    HANDLE              h;
    IO_STATUS_BLOCK     ioStatus;

    length = sizeof(ACL) + 3*sizeof(ACCESS_ALLOWED_ACE) +
             RtlLengthSid(SeExports->SeLocalSystemSid) +
             RtlLengthSid(SeExports->SeAliasAdminsSid) +
             RtlLengthSid(SeExports->SeWorldSid) +
             8; // The 8 is just for good measure.

    acl = (PACL) ExAllocatePool(PagedPool, length);
    if (!acl) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlCreateAcl(acl, length, ACL_REVISION2);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        return status;
    }

    status = RtlAddAccessAllowedAce(acl, ACL_REVISION2, FILE_READ_ATTRIBUTES |
                                    SYNCHRONIZE | READ_CONTROL,
                                    SeExports->SeWorldSid);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        return status;
    }

    status = RtlAddAccessAllowedAce(acl, ACL_REVISION2, GENERIC_ALL,
                                    SeExports->SeLocalSystemSid);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        return status;
    }

    status = RtlAddAccessAllowedAce(acl, ACL_REVISION2, GENERIC_READ |
                                    GENERIC_WRITE | GENERIC_EXECUTE |
                                    READ_CONTROL, SeExports->SeAliasAdminsSid);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        return status;
    }

    status = RtlCreateSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        return status;
    }

    status = RtlSetDaclSecurityDescriptor(&sd, TRUE, acl, FALSE);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        return status;
    }

    InitializeObjectAttributes(&oa, PartitionName, OBJ_CASE_INSENSITIVE |
                               OBJ_KERNEL_HANDLE, NULL, NULL);

    status = ZwOpenFile(&h, WRITE_DAC, &oa, &ioStatus, FILE_SHARE_READ |
                        FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_ALERT);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        return status;
    }

    status = ZwSetSecurityObject(h, DACL_SECURITY_INFORMATION, &sd);

    ZwClose(h);
    ExFreePool(acl);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\composit.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    composit.cxx

Abstract:

    This module contains the code specific to all composite volume objects.

Author:

    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

    This code assumes that the volume array is static.  If these values
    changes (as in Stripes or Mirrors) then it is up to the subclass to
    provide the proper synchronization.

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>

VOID
SimpleFtCompletionRoutine(
    IN  PVOID       CompletionContext,
    IN  NTSTATUS    Status
    );


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
COMPOSITE_FT_VOLUME::Initialize(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN OUT  PFT_VOLUME*         VolumeArray,
    IN      USHORT              ArraySize,
    IN      PVOID               ConfigInfo,
    IN      PVOID               StateInfo
    )

/*++

Routine Description:

    Initialize routine for FT_VOLUME of type COMPOSITE_FT_VOLUME.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id for this volume.

    VolumeArray     - Supplies the array of volumes for this volume set.

    ArraySize       - Supplies the number of volumes in the volume array.

    ConfigInfo      - Supplies the configuration information.

    StateInfo       - Supplies the state information.

Return Value:

    STATUS_SUCCESS

--*/

{
    ULONG   i, secsize;

    FT_VOLUME::Initialize(RootExtension, LogicalDiskId);

    _volumeArray = VolumeArray;
    _arraySize = ArraySize;

    _sectorSize = 0;
    for (i = 0; i < _arraySize; i++) {
        if (_volumeArray[i]) {
            secsize = _volumeArray[i]->QuerySectorSize();
            if (_sectorSize < secsize) {
                _sectorSize = secsize;
            }
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
COMPOSITE_FT_VOLUME::OrphanMember(
    IN  USHORT                  MemberNumber,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine tries to orphan the given member of this logical disk.
    A completion routine will be called if and only if this attempt is successful.

Arguments:

    MemberNumber        - Supplies the member number to orphan.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_PARAMETER;
}

NTSTATUS
COMPOSITE_FT_VOLUME::RegenerateMember(
    IN      USHORT                  MemberNumber,
    IN OUT  PFT_VOLUME              NewMember,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This routine regenerates the given member of this volume with
    the given volume.

Arguments:

    MemberNumber        - Supplies the member number to regenerate.

    NewMember           - Supplies the new member to regenerate to.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_PARAMETER;
}

VOID
COMPOSITE_FT_VOLUME::StopSyncOperations(
    )

/*++

Routine Description:

    This routine stops all sync operations.

Arguments:

    None.

Return Value:

    None.

--*/

{
    USHORT     i;
    PFT_VOLUME vol;

    for (i = 0; i < _arraySize; i++) {
        if (vol = GetMember(i)) {
            vol->StopSyncOperations();
        }
    }
}

VOID
COMPOSITE_FT_VOLUME::BroadcastIrp(
    IN  PIRP                    Irp,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )


/*++

Routine Description:

    This routine broadcasts a copy of the given IRP to every partition that
    is a member of the logical disk.

Arguments:

    Irp                 - Supplies the I/O request packet.

    CompletionRoutine   - Supplies the routine to be called when the operation
                            completes.

    Context             - Supplies the completion routine context.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  completionContext;
    USHORT                          i;
    PFT_VOLUME                      vol;

    completionContext = (PFT_COMPLETION_ROUTINE_CONTEXT)
                        ExAllocatePool(NonPagedPool,
                                       sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    if (!completionContext) {
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    KeInitializeSpinLock(&completionContext->SpinLock);
    completionContext->Status = STATUS_SUCCESS;
    completionContext->RefCount = _arraySize;
    completionContext->CompletionRoutine = CompletionRoutine;
    completionContext->Context = Context;

    for (i = 0; i < _arraySize; i++) {
        if (vol = GetMember(i)) {
            vol->BroadcastIrp(Irp, SimpleFtCompletionRoutine,
                              completionContext);
        } else {
            SimpleFtCompletionRoutine(completionContext, STATUS_SUCCESS);
        }
    }
}

PFT_VOLUME
COMPOSITE_FT_VOLUME::GetParentLogicalDisk(
    IN  PFT_VOLUME  Volume
    )

/*++

Routine Description:

    This routine returns the parent of the given logical disk within
    this volume.

Arguments:

    Volume  - Supplies the sub-volume of which we are looking for the parent.

Return Value:

    The parent volume or NULL;

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if (!(vol = GetMember(i))) {
            continue;
        }

        if (vol == Volume) {
            return this;
        }

        vol = vol->GetParentLogicalDisk(Volume);
        if (vol) {
            return vol;
        }
    }

    return NULL;
}

NTSTATUS
COMPOSITE_FT_VOLUME::SetPartitionType(
    IN  UCHAR   PartitionType
    )

/*++

Routine Description:

    This routine sets the partition type on all the members of the
    FT set.

Arguments:

    PartitionType   - Supplies the partition type.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS    status, finalStatus;
    USHORT      n, i;
    PFT_VOLUME  vol;

    finalStatus = STATUS_SUCCESS;
    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if (!(vol = GetMember(i))) {
            continue;
        }

        status = vol->SetPartitionType(PartitionType);
        if (!NT_SUCCESS(status)) {
            finalStatus = status;
        }
    }

    return finalStatus;
}

UCHAR
COMPOSITE_FT_VOLUME::QueryPartitionType(
    )

/*++

Routine Description:

    This routine queries the partition type.

Arguments:

    None.

Return Value:

    The partition type.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;
    UCHAR       type;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if (!(vol = GetMember(i))) {
            continue;
        }

        type = vol->QueryPartitionType();
        if (type) {
            return type;
        }
    }

    return 0;
}

UCHAR
COMPOSITE_FT_VOLUME::QueryStackSize(
    )

/*++

Routine Description:

    This routine queries IRP stack size.

Arguments:

    None.

Return Value:

    The IRP stack size.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;
    UCHAR       stackSize, t;

    stackSize = 0;
    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if (!(vol = GetMember(i))) {
            continue;
        }

        t = vol->QueryStackSize();
        if (t > stackSize) {
            stackSize = t;
        }
    }

    return stackSize;
}

VOID
COMPOSITE_FT_VOLUME::CreateLegacyNameLinks(
    IN  PUNICODE_STRING DeviceName
    )

/*++

Routine Description:

    This routine creates the \Device\HarddiskN\PartitionM links for
    this object to the given device name.

Arguments:

    DeviceName  - Supplies the device name.

Return Value:

    None.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if (!(vol = GetMember(i))) {
            continue;
        }

        vol->CreateLegacyNameLinks(DeviceName);
    }
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

USHORT
COMPOSITE_FT_VOLUME::QueryNumberOfMembers(
    )

/*++

Routine Description:

    This routine returns the number of members in this volume.

Arguments:

    None.

Return Value:

    The number of members in this volume.

--*/

{
    return _arraySize;
}

VOID
COMPOSITE_FT_VOLUME::SetDirtyBit(
    IN  BOOLEAN                 IsDirty,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine sets the dirty bit on the volume.  This bit is used at
    startup to determine whether or not there was a clean shutdown.

Arguments:

    IsDirty - Supplies the value of the dirty bit.

Return Value:

    None.

--*/

{
    USHORT                          n, i;
    PFT_VOLUME                      vol;
    PFT_COMPLETION_ROUTINE_CONTEXT  completionContext;

    if (!CompletionRoutine) {
        n = QueryNumMembers();
        for (i = 0; i < n; i++) {
            if (vol = GetMember(i)) {
                vol->SetDirtyBit(IsDirty, NULL, NULL);
            }
        }
        return;
    }

    completionContext = (PFT_COMPLETION_ROUTINE_CONTEXT)
                        ExAllocatePool(NonPagedPool,
                                       sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    if (!completionContext) {
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    KeInitializeSpinLock(&completionContext->SpinLock);
    completionContext->Status = STATUS_SUCCESS;
    completionContext->RefCount = _arraySize;
    completionContext->CompletionRoutine = CompletionRoutine;
    completionContext->Context = Context;

    for (i = 0; i < _arraySize; i++) {
        if (vol = GetMember(i)) {
            vol->SetDirtyBit(IsDirty, SimpleFtCompletionRoutine,
                             completionContext);
        } else {
            SimpleFtCompletionRoutine(completionContext, STATUS_SUCCESS);
        }
    }
}

PFT_VOLUME
COMPOSITE_FT_VOLUME::GetMember(
    IN  USHORT  MemberNumber
    )

/*++

Routine Description:

    This routine returns the 'MemberNumber'th member of this volume.

Arguments:

    MemberNumber    - Supplies the zero based member number desired.

Return Value:

    A pointer to the 'MemberNumber'th member or NULL if no such member.

--*/

{
    KIRQL       irql;
    PFT_VOLUME  r;

    ASSERT(MemberNumber < _arraySize);

    KeAcquireSpinLock(&_spinLock, &irql);
    r = _volumeArray[MemberNumber];
    KeReleaseSpinLock(&_spinLock, irql);
    return r;
}

VOID
SimpleFtCompletionRoutine(
    IN  PVOID       CompletionContext,
    IN  NTSTATUS    Status
    )

/*++

Routine Description:

    This is a simple completion routine that expects the CompletionContext
    to be a FT_COMPLETION_ROUTINE_CONTEXT.  It decrements the ref count and
    consolidates all of the status codes.  When the ref count goes to zero it
    call the original completion routine with the result.

Arguments:

    CompletionContext   - Supplies the completion context.

    Status              - Supplies the status of the request.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  completionContext;
    KIRQL                           oldIrql;
    LONG                            count;

    completionContext = (PFT_COMPLETION_ROUTINE_CONTEXT) CompletionContext;

    KeAcquireSpinLock(&completionContext->SpinLock, &oldIrql);

    if (!NT_SUCCESS(Status) &&
        FtpIsWorseStatus(Status, completionContext->Status)) {

        completionContext->Status = Status;
    }

    count = --completionContext->RefCount;

    KeReleaseSpinLock(&completionContext->SpinLock, oldIrql);

    if (!count) {
        completionContext->CompletionRoutine(completionContext->Context,
                                             completionContext->Status);
        ExFreePool(completionContext);
    }
}

VOID
COMPOSITE_FT_VOLUME::StartSyncOperations(
    IN      BOOLEAN                 RegenerateOrphans,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This routine restarts any regenerate and initialize requests that were
    suspended because of a reboot.  The volume examines the member state of
    all of its constituents and restarts any regenerations pending.

Arguments:

    RegenerateOrphans   - Supplies whether or not to try and regenerate
                            orphaned members.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the context for the completion routine.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  completionContext;
    USHORT                          i;
    PFT_VOLUME                      vol;

    completionContext = (PFT_COMPLETION_ROUTINE_CONTEXT)
                        ExAllocatePool(NonPagedPool,
                                       sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    if (!completionContext) {
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    KeInitializeSpinLock(&completionContext->SpinLock);
    completionContext->Status = STATUS_SUCCESS;
    completionContext->RefCount = _arraySize;
    completionContext->CompletionRoutine = CompletionRoutine;
    completionContext->Context = Context;

    for (i = 0; i < _arraySize; i++) {
        if (vol = GetMember(i)) {
            vol->StartSyncOperations(RegenerateOrphans,
                                     SimpleFtCompletionRoutine,
                                     completionContext);
        } else {
            SimpleFtCompletionRoutine(completionContext, STATUS_SUCCESS);
        }
    }
}

ULONG
COMPOSITE_FT_VOLUME::QuerySectorSize(
    )

/*++

Routine Description:

    Returns the sector size for the volume.

Arguments:

    None.

Return Value:

    The volume sector size in bytes.

--*/

{
    return _sectorSize;
}

PFT_VOLUME
COMPOSITE_FT_VOLUME::GetContainedLogicalDisk(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine returns TRUE if the given logical disk id
    represents this logical disk or if this logical disk contains
    the given logical disk id either directly or indirectly.

Arguments:

    LogicalDiskId   - Supplies the logical disk id that we are searching for.

Return Value:

    FALSE   - The given logical disk id is not contained in this logical disk.

    TRUE    - The given logical disk id is contained in this logical disk.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    if (LogicalDiskId == QueryLogicalDiskId()) {
        return this;
    }

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if ((vol = GetMember(i)) &&
            (vol = vol->GetContainedLogicalDisk(LogicalDiskId))) {

            return vol;
        }
    }

    return NULL;
}

PFT_VOLUME
COMPOSITE_FT_VOLUME::GetContainedLogicalDisk(
    IN  PDEVICE_OBJECT  TargetObject
    )

/*++

Routine Description:

    This routine returns TRUE if the given logical disk id
    represents this logical disk or if this logical disk contains
    the given logical disk id either directly or indirectly.

Arguments:

    TargetObject    - Supplies the target object.

Return Value:

    FALSE   - The given logical disk id is not contained in this logical disk.

    TRUE    - The given logical disk id is contained in this logical disk.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if ((vol = GetMember(i)) &&
            (vol = vol->GetContainedLogicalDisk(TargetObject))) {

            return vol;
        }
    }

    return NULL;
}

PFT_VOLUME
COMPOSITE_FT_VOLUME::GetContainedLogicalDisk(
    IN  ULONG       Signature,
    IN  LONGLONG    Offset
    )

/*++

Routine Description:

    This routine returns TRUE if the given logical disk id
    represents this logical disk or if this logical disk contains
    the given logical disk id either directly or indirectly.

Arguments:

    TargetObject    - Supplies the target object.

Return Value:

    FALSE   - The given logical disk id is not contained in this logical disk.

    TRUE    - The given logical disk id is contained in this logical disk.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }

        vol = vol->GetContainedLogicalDisk(Signature, Offset);
        if (vol) {
            return vol;
        }
    }

    return NULL;
}

VOID
COMPOSITE_FT_VOLUME::SetMember(
    IN  USHORT      MemberNumber,
    IN  PFT_VOLUME  Member
    )

/*++

Routine Description:

    This routine sets the given member in this volume.

Arguments:

    MemberNumber    - Supplies the member number.

    Member          - Supplies the member.

Return Value:

    None.

--*/

{
    KIRQL   irql;

    KeAcquireSpinLock(&_spinLock, &irql);
    SetMemberUnprotected(MemberNumber, Member);
    KeReleaseSpinLock(&_spinLock, irql);
}

BOOLEAN
COMPOSITE_FT_VOLUME::IsComplete(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine computes whether or not this volume has either all
    (if IoPending is FALSE) of its members or enough (if IoPending is TRUE) of
    its members.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;
    ULONG       secsize;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol || !vol->IsComplete(IoPending)) {
            return FALSE;
        }
    }

    return TRUE;
}

VOID
COMPOSITE_FT_VOLUME::CompleteNotification(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine is called to notify the volume that it is complete and
    to therefore prepare for incoming requests.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;
    ULONG       secsize;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }
        if (vol->IsComplete(IoPending)) {
            vol->CompleteNotification(IoPending);
            secsize = vol->QuerySectorSize();
            if (secsize > _sectorSize) {
                _sectorSize = secsize;
            }
        }
    }
}

ULONG
COMPOSITE_FT_VOLUME::QueryNumberOfPartitions(
    )

/*++

Routine Description:

    This routine returns the number of partitions covered by this volume
    set.

Arguments:

    None.

Return Value:

    The number of partitions covered by this volume set.

--*/

{
    ULONG       r;
    USHORT      n, i;
    PFT_VOLUME  vol;

    r = 0;
    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if (!(vol = GetMember(i))) {
            continue;
        }

        r += vol->QueryNumberOfPartitions();
    }

    return r;
}

PDEVICE_OBJECT
COMPOSITE_FT_VOLUME::GetLeftmostPartitionObject(
    )

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (vol) {
            return vol->GetLeftmostPartitionObject();
        }
    }

    return NULL;
}

NTSTATUS
COMPOSITE_FT_VOLUME::QueryDiskExtents(
    OUT PDISK_EXTENT*   DiskExtents,
    OUT PULONG          NumberOfDiskExtents
    )

/*++

Routine Description:

    This routine returns an array of disk extents that describe the
    location of this volume.

Arguments:

    DiskExtents         - Returns the disk extents.

    NumberOfDiskExtents - Returns the number of disk extents.

Return Value:

    NTSTATUS

--*/

{
    ULONG           totalExtents, numExtents, newTotal;
    USHORT          n, i;
    PFT_VOLUME      vol;
    NTSTATUS        status;
    PDISK_EXTENT    extents, allExtents;

Restart:

    totalExtents = 0;
    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if (!(vol = GetMember(i))) {
            continue;
        }

        status = vol->QueryDiskExtents(&extents, &numExtents);
        if (!NT_SUCCESS(status)) {
            return status;
        }
        ExFreePool(extents);

        totalExtents += numExtents;
    }

    allExtents = (PDISK_EXTENT) ExAllocatePool(PagedPool, totalExtents*
                                               sizeof(DISK_EXTENT));
    if (!allExtents) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    newTotal = 0;
    for (i = 0; i < n; i++) {
        if (!(vol = GetMember(i))) {
            continue;
        }

        status = vol->QueryDiskExtents(&extents, &numExtents);
        if (!NT_SUCCESS(status)) {
            ExFreePool(allExtents);
            return status;
        }

        if (newTotal + numExtents > totalExtents) {
            ExFreePool(extents);
            ExFreePool(allExtents);
            goto Restart;
        }

        RtlCopyMemory(&allExtents[newTotal], extents,
                      numExtents*sizeof(DISK_EXTENT));
        ExFreePool(extents);

        newTotal += numExtents;
    }

    *DiskExtents = allExtents;
    *NumberOfDiskExtents = newTotal;

    return STATUS_SUCCESS;
}

BOOLEAN
COMPOSITE_FT_VOLUME::QueryVolumeState(
    IN  PFT_VOLUME          Volume,
    OUT PFT_MEMBER_STATE    State
    )

/*++

Routine Description:

    This routine returns the state of the given volume considered as a
    member of this volume.

Arguments:

    Volume  - Supplies the volume to query the state for.

    State   - Returns the state.

Return Value:

    FALSE   - The given Volume is not a member of this volume.

    TRUE    - The state was successfully computed.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }

        if (vol->QueryVolumeState(Volume, State)) {
            return TRUE;
        }
    }

    return FALSE;
}

COMPOSITE_FT_VOLUME::~COMPOSITE_FT_VOLUME(
    )

/*++

Routine Description:

    Routine called to cleanup resources being used by the object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (_volumeArray) {
        ExFreePool(_volumeArray);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\mcd\tools\mct.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    mct.c

Abstract:

   Test program for testing Medium Changer drivers. It calls the appropriate
   dispatch routines of the changer driver based on the user input, and displays
   the output from the driver.

Environment:

    User mode

Revision History :

--*/
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include <assert.h>

#include <windows.h>
#include <devioctl.h>
#include <ntddchgr.h>

#define _NTSRB_     // to keep srb.h from being included
#include <scsi.h>

#include "mct.h"   // Header file for thie file

HANDLE hChanger = INVALID_HANDLE_VALUE; // Handle to the open device

GET_CHANGER_PARAMETERS ChangerParams; // Changer Parameters
BOOLEAN ChangerParamsRead;  // Flag to indicate if the changer params 
                            // have been read.

//
// Changer's features flag corresponding to the
// bits set in Features0 and Features1 in the
// changer driver.
//
PUCHAR ChangerFlagStrings0[] = {
   "CHANGER_BAR_CODE_SCANNER_INSTALLED",
   "CHANGER_INIT_ELEM_STAT_WITH_RANGE",
   "CHANGER_CLOSE_IEPORT",
   "CHANGER_OPEN_IEPORT",
   "CHANGER_STATUS_NON_VOLATILE",
   "CHANGER_EXCHANGE_MEDIA",
   "CHANGER_CLEANER_SLOT",
   "CHANGER_LOCK_UNLOCK",
   "CHANGER_CARTRIDGE_MAGAZINE",
   "CHANGER_MEDIUM_FLIP",
   "CHANGER_POSITION_TO_ELEMENT",
   "CHANGER_REPORT_IEPORT_STATE",
   "CHANGER_STORAGE_DRIVE",
   "CHANGER_STORAGE_IEPORT",
   "CHANGER_STORAGE_SLOT",
   "CHANGER_STORAGE_TRANSPORT",
   "CHANGER_DRIVE_CLEANING_REQUIRED",
   "CHANGER_PREDISMOUNT_EJECT_REQUIRED",
   "CHANGER_CLEANER_ACCESS_NOT_VALID",
   "CHANGER_PREMOUNT_EJECT_REQUIRED",
   "CHANGER_VOLUME_IDENTIFICATION",
   "CHANGER_VOLUME_SEARCH",
   "CHANGER_VOLUME_ASSERT",
   "CHANGER_VOLUME_REPLACE",
   "CHANGER_VOLUME_UNDEFINE",
   "",
   "CHANGER_SERIAL_NUMBER_VALID",
   "CHANGER_DEVICE_REINITIALIZE_CAPABLE",
   "CHANGER_KEYPAD_ENABLE_DISABLE",
   "CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS"
};

PUCHAR ChangerFlagStrings1[] = {
   "CHANGER_PREDISMOUNT_ALIGN_TO_SLOT",
   "CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE",
   "CHANGER_CLEANER_AUTODISMOUNT",
   "CHANGER_TRUE_EXCHANGE_CAPABLE",
   "CHANGER_SLOTS_USE_TRAYS",
   "CHANGER_RTN_MEDIA_TO_ORIGINAL_ADDR",
   "CHANGER_CLEANER_OPS_NOT_SUPPORTED",
   "CHANGER_IEPORT_USER_CONTROL_OPEN",
   "CHANGER_IEPORT_USER_CONTROL_CLOSE",
   "CHANGER_MOVE_EXTENDS_IEPORT",
   "CHANGER_MOVE_RETRACTS_IEPORT",
};


int __cdecl main(int argc, char *argv[])
{
   char switchChar;
   BOOLEAN changerOpened;

   if (argc == 1) {
      mctPrintUsage();
      return 0;
   }

   if (*argv[1] != '-') {
      mctPrintUsage();
      return 0;
   }


   //
   // If the changer is not open,
   // try to open the changer device.
   //
   if (hChanger == INVALID_HANDLE_VALUE) {
      changerOpened = mctOpenChanger();
   }

   if (changerOpened == FALSE) {
      mctDebugPrint(1, "Could not open changer. Aborting!\n");
      return 0;
   }

   //
   // Read the changer parameters.
   //
   /*
   if (mctGetParameters(FALSE) != MCT_STATUS_SUCCESS) {
      mctDebugPrint(0, "Unable to read changer parameters.\n");
      ChangerParamsRead = FALSE;
   } else {
      ChangerParamsRead = TRUE;
   }
   */

   //
   // Get the function to be called.
   //
   switchChar = *(argv[1]+1);
   switch (switchChar) {
      case INIT_ELEMENT_STATUS: {
         if (mctInitElementStatus() != MCT_STATUS_SUCCESS) {
            mctDebugPrint(1, "Error doing InitElement.\n");
         }

         break;
      }

      case GET_ELEMENT_STATUS: {
         CHAR ElemType;
         USHORT ElemAddress;

         if (argc != 4) {
            mctDebugPrint(0, "GetElementStatus : mct -e ElemType ElemAddress\n");
            break;
         }

         ElemType = (CHAR)toupper(*argv[2]);
         ElemAddress = (USHORT)atoi(argv[3]);
         if (mctGetElementStatus(ElemType, ElemAddress) != MCT_STATUS_SUCCESS) {
            mctDebugPrint(1, "Error doing GetElementStatus.\n");
         }

         break;
      }

      case GET_PARAMETERS: {
         if (mctGetParameters(TRUE) != MCT_STATUS_SUCCESS) {
            mctDebugPrint(1, "Error reading changer parameters.\n");
         }

         break;
      }


      case GET_STATUS: {
         if (mctGetStatus() != MCT_STATUS_SUCCESS) {
            mctDebugPrint(1, "Error doing GetStatus.\n");
         }

      break;
      }

      case GET_PRODUCT_DATA: {   
         if (mctGetProductData() != MCT_STATUS_SUCCESS) {
            mctDebugPrint(1, "Error doing GetProductData.\n");
         }

         break;
      }

      case SET_ACCESS: {
         CHAR ElemType, Control;
         USHORT ElemAddr;

         if (argc != 5) {
            mctDebugPrint(0, "SetAccess : mct -a ElemType ElemAddr Control\n");
            break;
         }

         ElemType = (CHAR)toupper(*argv[2]);
         ElemAddr = (USHORT)atoi(argv[3]);
         Control = (CHAR)toupper(*argv[4]);
         if (mctSetAccess(ElemType, ElemAddr, Control) != MCT_STATUS_SUCCESS) {
            mctDebugPrint(1, "Error doing SetAccess.\n");
         }

         break;
      }

      case SET_POSITION: {
         USHORT Dest;
         CHAR ElemType;

         if (argc != 4) {
            mctDebugPrint(0, "SetPosition: mct -o ElemType Dest\n");
            break;
         }

         ElemType = (CHAR)toupper(*argv[2]);
         Dest = (USHORT)atoi(argv[3]);
         if (mctSetPosition(ElemType, Dest) != MCT_STATUS_SUCCESS) {
            mctDebugPrint(1, "Error doing SetPosition.\n");
         }

         break;
      }

      case EXCHANGE_MEDIUM: {
         USHORT Transport, Source, Dest1, Dest2;
         CHAR TransType, SrcType, Dest1Type, Dest2Type;

         if (argc != 10) {
            mctDebugPrint(0, "ExchangeMedium: mct -x ElemType Trans ElemType Src ElemType"); 
            mctDebugPrint(0, " Dest1 ElemType Dest2\n");
            break;
         }
         
         TransType = (CHAR)toupper(*argv[2]);
         Transport = (USHORT)atoi(argv[3]);
         SrcType = (CHAR)toupper(*argv[4]);
         Source = (USHORT)atoi(argv[5]);
         Dest1Type = (CHAR)toupper(*argv[6]);
         Dest1 = (USHORT)atoi(argv[7]);
         Dest2Type = (CHAR)toupper(*argv[8]);
         Dest2 = (USHORT)atoi(argv[9]);
         if (mctExchangeMedium(TransType, Transport, 
                                SrcType, Source, 
                                 Dest1Type, Dest1,
                                   Dest2Type, Dest2) != MCT_STATUS_SUCCESS) {
            mctDebugPrint(1, "Error doing Exchange Medium.\n");
         }

         break;
      }

      case MOVE_MEDIUM: {
         USHORT Transport, Source, Dest;
         CHAR TransType, SourceType, DestType;

         if (argc != 8) {
            mctDebugPrint(0, "MoveMedium : mct -m t N s\\d N s\\d N\n");
            break;
         }
         
         Transport = (USHORT)atoi(argv[3]);
         Source = (USHORT)atoi(argv[5]);
         Dest = (USHORT)atoi(argv[7]);

         TransType = (CHAR)toupper(*argv[2]);
         SourceType = (CHAR)toupper(*argv[4]);
         DestType = (CHAR)toupper(*argv[6]);
         if (mctMoveMedium(TransType, Transport, SourceType, Source,
                              DestType, Dest) != MCT_STATUS_SUCCESS) {
            mctDebugPrint(1, "Error doing Move Medium.\n");
         }

         break;
      }

      case REINITIALIZE_TRANSPORT: {
         if (mctReinitTransport() != MCT_STATUS_SUCCESS) {
            mctDebugPrint(1, "Error doing Reinitialize Transport.\n");
         }

         break;
      }

      case QUERY_VOLUME_TAG: {
         if (mctQueryVolumeTag() != MCT_STATUS_SUCCESS) {
            mctDebugPrint(1, "Error doing QueryVolumeTag.\n");
         }

         break;
      }

      default: mctPrintUsage();
      break;
   }

   mctCloseChanger();
   return 0;

}

VOID
mctPrintUsage()
{
   printf("\nUsage : MCT\n");
   printf("   -i [InitializeElementStatus]\n");
   printf("   -e ElemType ElemAddress [GetElementStatus]\n");
   printf("   -s [GetStatus]\n");
   printf("   -p [GetParameters]\n");
   printf("   -d [GetProductData]\n");
   printf("   -a ElemType ElemAddr Control [SetAccess]\n");
   printf("   -o ElemType Dest [SetPosition]\n");
   printf("   -r [ReinitializeTransport]\n");
   printf("   -q [QueryVolumeTag]\n");
   printf("   -m ElemType Trans ElemType Src ElemType ");
   printf("Dest [MoveMedium]\n");
   printf("   -x ElemType Trans ElemType Src ElemType "); 
   printf("Dest1 ElemType Dest2 [ExchangeMedium]\n");

   return;
}

BOOLEAN
mctOpenChanger()
{
   DWORD nBytes = 0, nBlockSize;
   ULONG retVal;
   DWORD status;
   UINT  ChangerId;
   CHAR ChangerName[128];

   ChangerId = 0;
   //printf("Enter the changer number (0, 1, 2,.., N) : ");
   //scanf("%d", &ChangerId);
   sprintf(ChangerName, "\\\\.\\Changer%d", ChangerId);
   mctDebugPrint(3, "\nOpening changer %s\n", ChangerName);
   hChanger = CreateFile(ChangerName, (GENERIC_READ | GENERIC_WRITE),
                          (FILE_SHARE_READ | FILE_SHARE_WRITE),
                              NULL, OPEN_EXISTING, 
                                    FILE_ATTRIBUTE_NORMAL, NULL);
   if (hChanger == INVALID_HANDLE_VALUE) {
      mctDebugPrint(0, "Unable to open changer - Error %d. ", GetLastError());
      mctDebugPrint(0, "Aborting test!\n");
      return FALSE;
   }
             
   return TRUE;
}

VOID
mctCloseChanger()
{
   if (hChanger != INVALID_HANDLE_VALUE) {
      CloseHandle(hChanger);
   } else {
      mctDebugPrint(0, "Changer not open or invalid handle value.\n");
   }
}

MCT_STATUS
mctInitElementStatus()
{
   CHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus;
   ULONG retVal;
   DWORD nBytes;

   initElementStatus.ElementList.Element.ElementType = AllElements;
   if ((ChangerParams.Features0) & CHANGER_BAR_CODE_SCANNER_INSTALLED) {
      initElementStatus.BarCodeScan = TRUE;
   } else {
      initElementStatus.BarCodeScan = FALSE;
   }

   retVal = DeviceIoControl(hChanger, IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS,
                              &initElementStatus, 
                                 sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS),
                                    NULL, 0, &nBytes, NULL);
   if (retVal == FALSE) {
      mctDebugPrint(0, "Error doing Initialize Element Status : %d.\n",
                      GetLastError());
      return MCT_STATUS_FAILED;
   }

   return MCT_STATUS_SUCCESS;
}


MCT_STATUS
mctGetElementStatus(CHAR ElementType, USHORT ElemAddress)
{
   CHANGER_READ_ELEMENT_STATUS readElementStat;
   PCHANGER_ELEMENT_STATUS_EX ChangerElementStat, tmpChangerElementStat;
   DWORD nBytes;
   ULONG retVal;
   USHORT NoOfElems;
   int i, inx;

   readElementStat.VolumeTagInfo = FALSE;
   switch (ElementType) {
      case CHANGER_ALL_ELEMENTS : {
         readElementStat.ElementList.Element.ElementType = AllElements;
         readElementStat.ElementList.Element.ElementAddress = 0;
         NoOfElems = ChangerParams.NumberTransportElements +
                        ChangerParams.NumberStorageElements +
                           ChangerParams.NumberIEElements + 1;
         readElementStat.ElementList.NumberOfElements = NoOfElems;
         break;
      }

      case CHANGER_TRANSPORT : {
         readElementStat.ElementList.Element.ElementType = ChangerTransport;
         readElementStat.ElementList.Element.ElementAddress = ElemAddress;
         readElementStat.ElementList.NumberOfElements = 1;
         NoOfElems = 1;
         break;
      }

      case CHANGER_SLOT : {
         readElementStat.ElementList.Element.ElementType = ChangerSlot;
         readElementStat.ElementList.Element.ElementAddress = ElemAddress;
         readElementStat.ElementList.NumberOfElements = 1;
         NoOfElems = 1;
         break;
      }
      case CHANGER_DRIVE : {
         readElementStat.ElementList.Element.ElementType = ChangerDrive;
         readElementStat.ElementList.Element.ElementAddress = ElemAddress;
         readElementStat.ElementList.NumberOfElements = 1;
         readElementStat.VolumeTagInfo = TRUE;
         NoOfElems = 1;
         break;
      }
      case CHANGER_IEPORT: {
         readElementStat.ElementList.Element.ElementType = ChangerIEPort;
         readElementStat.ElementList.Element.ElementAddress = ElemAddress;
         readElementStat.ElementList.NumberOfElements = 1;
         NoOfElems = 1;
         break;
      }
      default: {
         mctDebugPrint(0, "Invalid Element Type. \n");
         mctDebugPrint(0, "Valid Types :\n");
         mctDebugPrint(0, "   All Elements : A or a\n");
         mctDebugPrint(0, "   Transport    : T or t\n");
         mctDebugPrint(0, "   Slot         : S or s\n");
         mctDebugPrint(0, "   Drive        : D or d\n");
         mctDebugPrint(0, "   IEPort       : I or i\n");

         return MCT_STATUS_FAILED;
      }
      
   } // switch (ElementType) 


   ChangerElementStat = (PCHANGER_ELEMENT_STATUS_EX)malloc(NoOfElems * 
                                                sizeof(CHANGER_ELEMENT_STATUS_EX));
   if (ChangerElementStat == NULL) {
      mctDebugPrint(0, "Malloc failed for ReadElementStatus.\n");
      return MCT_STATUS_FAILED;
   }
   
   retVal = DeviceIoControl(hChanger, IOCTL_CHANGER_GET_ELEMENT_STATUS,
                              &readElementStat, 
                                 sizeof(CHANGER_READ_ELEMENT_STATUS),
                                    ChangerElementStat,
                                 (NoOfElems * sizeof(CHANGER_ELEMENT_STATUS_EX)),
                                    &nBytes,
                                       NULL);
   if (retVal == FALSE) {
      mctDebugPrint(0, "ReadElementStatus failed : %d \n",
                           GetLastError());
      free(ChangerElementStat);
      return MCT_STATUS_FAILED;
   }

   //
   // Print Element Status information
   //
   tmpChangerElementStat = ChangerElementStat;
   for (i = 0; i < NoOfElems; i++) {
      printf("Element Type : %d,  ",
               ChangerElementStat->Element.ElementType);

      printf("Element Status Flag : 0x%08x\n", ChangerElementStat->Flags);
      if ((ChangerElementStat->Flags) & ELEMENT_STATUS_EXCEPT) {
          printf("Exception occured. Error %x\n",
                 ChangerElementStat->ExceptionCode);
      }
      if ((ChangerElementStat->Flags) & ELEMENT_STATUS_FULL) {
         printf("Element has Media.\n");
      } else {
         printf("Element has no media.\n");
      }

      if ((ChangerElementStat->Flags) & ELEMENT_STATUS_SVALID) {
         printf("SourceElementAddress Type : %d, Address : %ul\n", 
                  ChangerElementStat->SrcElementAddress.ElementType,
                     ChangerElementStat->SrcElementAddress.ElementAddress);
      } else {
         printf("SourceElementAddress is not valid.\n");
      }

      if ((ChangerElementStat->Flags) & ELEMENT_STATUS_ID_VALID) {
          printf("Target Id : %x\t", ChangerElementStat->TargetId);
      }

      if ((ChangerElementStat->Flags) & ELEMENT_STATUS_LUN_VALID) {
          printf("LUN : %x", ChangerElementStat->Lun);
      } 
      printf("\n");
      if ((ChangerElementStat->Flags) & ELEMENT_STATUS_PVOLTAG) {
         printf("Primary Volume Tag : ");
         for (inx = 0; inx < MAX_VOLUME_ID_SIZE; inx++) {
             printf("%d ", ChangerElementStat->PrimaryVolumeID[inx]);
         }
         printf("\n");
         //
         // Add code to print Primary volume tag.
         //

      } else {
         printf("Primary Volume Tag information is not set.\n");
      }

      if ((ChangerElementStat->Flags) & ELEMENT_STATUS_AVOLTAG) {
         printf("Alternate Volume Tag information is valid.\n");
         //
         // Add code to print Alternate volume tag.
         //
      } else {
         printf("Alternate Volume Tag information is not set.\n");
      }

      ChangerElementStat++;
   }
   
   free(tmpChangerElementStat);
   return MCT_STATUS_SUCCESS;
}

MCT_STATUS
mctGetStatus()
{
   ULONG retVal;
   DWORD nBytes;

   retVal = DeviceIoControl(hChanger, IOCTL_CHANGER_GET_STATUS,
                              NULL, 0, NULL, 0, &nBytes, NULL);
   if (retVal == FALSE) {
      mctDebugPrint(0, "Error reading changer status : %d\n",
                        GetLastError());
      return MCT_STATUS_FAILED;
   }

   return MCT_STATUS_SUCCESS;
}


MCT_STATUS
mctGetProductData()
{
   PCHANGER_PRODUCT_DATA productData;
   ULONG retVal;
   DWORD nBytes;
   CHAR SerialNum[SERIAL_NUMBER_LENGTH+1];

   productData = (PCHANGER_PRODUCT_DATA)calloc(1, sizeof(CHANGER_PRODUCT_DATA));
   retVal = DeviceIoControl(hChanger, IOCTL_CHANGER_GET_PRODUCT_DATA,
                              NULL, 0,
                                 productData,
                                    sizeof(CHANGER_PRODUCT_DATA),
                                       &nBytes, NULL);
   if (retVal == FALSE) {
      mctDebugPrint(0, "Error reading product data : %d\n",
                           GetLastError());
      free(productData);
      return MCT_STATUS_FAILED;
   }
   

   productData->VendorId[VENDOR_ID_LENGTH - 1] = '\0';
   productData->ProductId[PRODUCT_ID_LENGTH - 1] = '\0';
   productData->Revision[REVISION_LENGTH - 1] = '\0';
   strncpy(SerialNum, productData->SerialNumber, SERIAL_NUMBER_LENGTH);
   
   printf("Product Data for Medium Changer device : \n");
 
   printf("  Vendor Id    : %s\n", productData->VendorId);
   printf("  Product Id   : %s\n", productData->ProductId);
   printf("  Revision     : %s\n", productData->Revision);
   printf("  SerialNumber : %s\n", SerialNum);

   free(productData);
   return MCT_STATUS_SUCCESS;
}


MCT_STATUS
mctSetAccess(CHAR ElementType, USHORT ElemAddr, CHAR Control)
{
   CHANGER_SET_ACCESS setAccess;
   DWORD nBytes;
   ULONG retVal;

   switch (ElementType) {
      case CHANGER_IEPORT : {
         setAccess.Element.ElementType = ChangerIEPort;
         setAccess.Element.ElementAddress = ElemAddr;
         if (Control == CHANGER_RETRACT_IEPORT) {
            setAccess.Control = RETRACT_IEPORT;
         } else if (Control == CHANGER_EXTEND_IEPORT) {
            setAccess.Control = EXTEND_IEPORT;
         } else if (Control == CHANGER_LOCK_ELEMENT) {
            setAccess.Control = LOCK_ELEMENT;
         } else if ((Control == CHANGER_UNLOCK_ELEMENT)) {
            setAccess.Control = UNLOCK_ELEMENT;
         } else {
            mctDebugPrint(0, "Invalid Control type in SetAccess\n");
            mctDebugPrint(0, "Valid types are R\\r or E\\e or L\\l or U\\u \n");
            return MCT_STATUS_FAILED;
         }

         break;
      }

      case CHANGER_DOOR : {
         setAccess.Element.ElementType = ChangerDoor;
         setAccess.Element.ElementAddress = ElemAddr;
         if (Control == CHANGER_LOCK_ELEMENT) {
            setAccess.Control = LOCK_ELEMENT;
         } else if (Control == CHANGER_UNLOCK_ELEMENT) {
            setAccess.Control = UNLOCK_ELEMENT;
         } else {
            mctDebugPrint(0, "Invalid Control type in SetAccess\n");
            mctDebugPrint(0, "  Valid types are L\\l or U\\u \n");
            return MCT_STATUS_FAILED;
         }
         break;
      }

      case CHANGER_KEYPAD :  {
         setAccess.Element.ElementType = ChangerKeypad;
         setAccess.Element.ElementAddress = ElemAddr;
         if (Control == CHANGER_LOCK_ELEMENT) {
            setAccess.Control = LOCK_ELEMENT;
         } else if (Control == CHANGER_UNLOCK_ELEMENT) {
            setAccess.Control = UNLOCK_ELEMENT;
         } else {
            mctDebugPrint(0, "Invalid Control type in SetAccess\n");
            mctDebugPrint(0, "  Valid types are L\\l or U\\u \n");
            return MCT_STATUS_FAILED;
         }
         break;
      }

      default: {
         mctDebugPrint(0, "Invalid ElementType for SetAccess.\n");
         mctDebugPrint(0, "Valid Type : \n");
         mctDebugPrint(0, "  IEPort : I or i\n");
         mctDebugPrint(0, "  Door   : O or o\n");
         mctDebugPrint(0, "  KeyPad : K or k\n");

         return MCT_STATUS_FAILED;
      }
   } // switch (ElementType)

   retVal = DeviceIoControl(hChanger, IOCTL_CHANGER_SET_ACCESS,
                              &setAccess, sizeof(CHANGER_SET_ACCESS),
                                 NULL, 0, &nBytes, NULL);
   if (retVal == FALSE) {
      mctDebugPrint(0, "Error doing SetAccess : %d\n",
                        GetLastError());
      return MCT_STATUS_FAILED;
   }

   return MCT_STATUS_SUCCESS;
}


MCT_STATUS
mctSetPosition(CHAR ElemType, USHORT Dest)
{
   CHANGER_SET_POSITION setPosition;
   DWORD nBytes;
   ULONG retVal;

   setPosition.Transport.ElementType = ChangerTransport;
   setPosition.Transport.ElementAddress = 0;

   if (ElemType == CHANGER_SLOT) {
      setPosition.Destination.ElementType = ChangerSlot;
   } else if (ElemType == CHANGER_DRIVE) {
      setPosition.Destination.ElementType = ChangerDrive;
   } else if (ElemType == CHANGER_IEPORT) {
       setPosition.Destination.ElementType = ChangerIEPort;
   } else {
      mctDebugPrint(0, "Invalid element type in SetPosition\n");
      mctDebugPrint(0, " Valid element types are S\\s or D\\d \n");
      return MCT_STATUS_FAILED;
   }
   setPosition.Destination.ElementAddress = Dest;

   retVal = DeviceIoControl(hChanger, IOCTL_CHANGER_SET_POSITION,
                              &setPosition, 
                                 sizeof (CHANGER_SET_POSITION),
                                    NULL, 0, &nBytes, NULL);
   if (retVal == FALSE) {
      mctDebugPrint(0, "SetPosition failed : %d \n", GetLastError());
      return MCT_STATUS_FAILED;
   }

   return MCT_STATUS_SUCCESS;
}


MCT_STATUS
mctReinitTransport()
{
   CHANGER_ELEMENT changerElem;
   ULONG retVal;
   DWORD nBytes;

   changerElem.ElementType = ChangerTransport;
   changerElem.ElementAddress = 0;

   retVal = DeviceIoControl(hChanger, IOCTL_CHANGER_REINITIALIZE_TRANSPORT,
                              &changerElem, sizeof(CHANGER_ELEMENT),
                                 NULL, 0, &nBytes, NULL);
   if (retVal == FALSE) {
      mctDebugPrint(0, "Error reinitializing transport : %d\n",
                           GetLastError());
      return MCT_STATUS_FAILED;
   }

   return MCT_STATUS_SUCCESS;
}

MCT_STATUS
mctQueryVolumeTag()
{
   mctDebugPrint(0, "QueryVolumeTag function to be implemented.\n");
   return MCT_STATUS_SUCCESS;
}

MCT_STATUS
mctExchangeMedium(
                  CHAR TransType,
                  USHORT Transport,
                  CHAR SrcType,
                  USHORT Source,
                  CHAR Dest1Type,
                  USHORT Dest1,
                  CHAR Dest2Type,
                  USHORT Dest2)
{
   CHANGER_EXCHANGE_MEDIUM ExchangeMedium;
   DWORD nBytes;
   ULONG retVal;
   CHAR ElemType;

   if(hChanger == INVALID_HANDLE_VALUE) {
      mctDebugPrint(0, "Invalid handle to changer. Aborting!\n");
      return MCT_STATUS_FAILED;
   }

   if (TransType != CHANGER_TRANSPORT) {
      mctDebugPrint(0, "Invalid Transport ElementType to ExchangeMedium.\n");
      mctDebugPrint(0, "  Valid type is T\\t \n");
      return MCT_STATUS_FAILED;
   }

   ExchangeMedium.Transport.ElementType = ChangerTransport;
   ExchangeMedium.Transport.ElementAddress = Transport;

   if (SrcType == CHANGER_SLOT) {
      ExchangeMedium.Source.ElementType = ChangerSlot;
   } else if (SrcType == CHANGER_DRIVE) {
      ExchangeMedium.Source.ElementType = ChangerDrive;
   } else {
      mctDebugPrint(0, "Invalid Source ElementType to ExchangeMedium.\n");
      mctDebugPrint(0, "  Valid types are S\\s or D\\d \n");
      return MCT_STATUS_FAILED;
   }
   ExchangeMedium.Source.ElementAddress = Source;
   
   if (Dest1Type == CHANGER_SLOT) {
      ExchangeMedium.Destination1.ElementType = ChangerSlot;
   } else if (Dest1Type == CHANGER_DRIVE) {
      ExchangeMedium.Destination1.ElementType = ChangerDrive;
   } else {
      mctDebugPrint(0, "Invalid Destination1 ElementType to ExchangeMedium.\n");
      mctDebugPrint(0, "  Valid types are S\\s or D\\d \n");
      return MCT_STATUS_FAILED;
   }
   ExchangeMedium.Destination1.ElementAddress = Dest1;
   
   if (Dest2Type == CHANGER_SLOT) {
      ExchangeMedium.Destination2.ElementType = ChangerSlot;
   } else if (Dest2Type == CHANGER_DRIVE) {
      ExchangeMedium.Destination2.ElementType = ChangerDrive;
   } else {
      mctDebugPrint(0, "Invalid Destination2 ElementType to ExchangeMedium.\n");
      mctDebugPrint(0, "  Valid types are S\\s or D\\d \n");
      return MCT_STATUS_FAILED;
   }
   ExchangeMedium.Destination2.ElementAddress = Dest2;

   ExchangeMedium.Flip1 = FALSE;
   ExchangeMedium.Flip2 = FALSE;

   mctDebugPrint(3, "Exchange : Source - %d, Dest1 - %d, Dest2 - %d",
                     Source, Dest1, Dest2);
   mctDebugPrint(3, " using Transport %d.\n", Transport);
                 
   retVal = DeviceIoControl(hChanger, IOCTL_CHANGER_EXCHANGE_MEDIUM,
                              &ExchangeMedium, sizeof(CHANGER_EXCHANGE_MEDIUM),
                                NULL, 0, &nBytes, NULL);
   if (retVal == FALSE) {
      mctDebugPrint(0, "Error doing exchange medium : %d\n", GetLastError());
      return MCT_STATUS_FAILED;
   }  

   return MCT_STATUS_SUCCESS;
}


MCT_STATUS
mctMoveMedium(
              CHAR TransType,
              USHORT Transport,
              CHAR SourceType,
              USHORT Source,
              CHAR DestType,
              USHORT Dest)
{
   CHANGER_MOVE_MEDIUM MoveMedium;
   DWORD nBytes;
   ULONG retVal;
   USHORT ElemType;

   if(hChanger == INVALID_HANDLE_VALUE) {
      mctDebugPrint(0, "Invalid handle to changer. Aborting!\n");
      return MCT_STATUS_FAILED;
   }

   if (TransType != CHANGER_TRANSPORT) {
      mctDebugPrint(0, "Invalid Transport ElementType to MoveMedium.\n");
      mctDebugPrint(0, "  Valid type is T\\t \n");
      return MCT_STATUS_FAILED;
   }

   MoveMedium.Transport.ElementType = ChangerTransport;
   MoveMedium.Transport.ElementAddress = Transport;

   if (SourceType == CHANGER_SLOT) {
      mctDebugPrint(3, "Source is a Slot\n");
      MoveMedium.Source.ElementType = ChangerSlot;
   } else if (SourceType == CHANGER_DRIVE) {
      mctDebugPrint(3, "Source is a Drive\n");
      MoveMedium.Source.ElementType = ChangerDrive;
   } else if (SourceType == CHANGER_IEPORT) {
      mctDebugPrint(3, "Source is a IEPort\n");
      MoveMedium.Source.ElementType = ChangerIEPort;
   }
   else {
      mctDebugPrint(0, "Invalid Source ElementType to MoveMedium.\n");
      mctDebugPrint(0, "  Valid types are S\\s or D\\d \n");
      return MCT_STATUS_FAILED;
   }
   MoveMedium.Source.ElementAddress = Source;
   
   if (DestType == CHANGER_SLOT) {
      mctDebugPrint(3, "Destination is a Slot\n");
      MoveMedium.Destination.ElementType = ChangerSlot;
   } else if (DestType == CHANGER_DRIVE) {
      mctDebugPrint(3, "Destination is a Drive\n");
      MoveMedium.Destination.ElementType = ChangerDrive;
   } else if (DestType == CHANGER_IEPORT) {
      mctDebugPrint(3, "Destination is a IEPort\n");
      MoveMedium.Destination.ElementType = ChangerIEPort;
   } else {
      mctDebugPrint(0, "Invalid Destination ElementType to MoveMedium.\n");
      mctDebugPrint(0, "  Valid types are S\\s or D\\d \n");
      return MCT_STATUS_FAILED;
   }
   MoveMedium.Destination.ElementAddress = Dest;

   MoveMedium.Flip = FALSE;

   mctDebugPrint(3, "Move : Transport - %d, Src - %d, Dest - %d\n",
                     Transport, Source, Dest);

   retVal = DeviceIoControl(hChanger, IOCTL_CHANGER_MOVE_MEDIUM,
                              &MoveMedium, sizeof(CHANGER_MOVE_MEDIUM),
                                NULL, 0, &nBytes, NULL);
   if (retVal == FALSE) {
      mctDebugPrint(0, "Error doing move medium : %d\n", GetLastError());
      return MCT_STATUS_FAILED;
   } 

   return MCT_STATUS_SUCCESS;
}

MCT_STATUS
mctGetParameters(BOOLEAN PrintParams)
{
   ULONG retVal;
   DWORD nBytes;
   int i;
   DWORD Features;


   if(hChanger == INVALID_HANDLE_VALUE) {
      mctDebugPrint(0, "Invalid handle to changer. Aborting!\n");
      return MCT_STATUS_FAILED;
   }

   //
   // Read changer params only if it hasn't been done already.
   //
   if (ChangerParamsRead == FALSE) {
      // 
      // Get the parameters for this changer device.
      //
      retVal = DeviceIoControl(hChanger, IOCTL_CHANGER_GET_PARAMETERS,
                                 NULL, 0, &ChangerParams, sizeof(GET_CHANGER_PARAMETERS),
                                      &nBytes, NULL);
      if (retVal == FALSE) {
         mctDebugPrint(0, "Error reading changer parametes : %d.\n",
                          GetLastError());
         return MCT_STATUS_FAILED;
      }  
   }

   if (PrintParams == FALSE) {
      return MCT_STATUS_SUCCESS;
   }

   //
   // Read the parameters of the changer. Display it.
   //
   
   printf("\n     ********** Changer Parameters ********** \n\n");

   printf("\t Number of Transport Elements : %d\n",
          ChangerParams.NumberTransportElements);
   printf("\t Number of Storage Elements : %d\n", 
          ChangerParams.NumberStorageElements);
   printf("\t Number of Cleaner Slots : %d\n", 
          ChangerParams.NumberCleanerSlots);
   printf("\t Number of of IE Elements : %d\n", 
          ChangerParams.NumberIEElements);
   printf("\t Number of NumberDataTransferElements : %d\n", 
          ChangerParams.NumberDataTransferElements);
   printf("\t Number of Doors : %d\n", ChangerParams.NumberOfDoors);

   printf("\n\t First Slot Number : %d\n", ChangerParams.FirstSlotNumber);
   printf("\t First Drive Number : %d\n", ChangerParams.FirstDriveNumber);
   printf("\t First Transport Number : %d\n", 
          ChangerParams.FirstTransportNumber);
   printf("\t First IEPort number : %d\n", ChangerParams.FirstIEPortNumber);
   printf("\t First Cleaner Slot Address : %d\n", 
          ChangerParams.FirstCleanerSlotAddress);
   printf("\n\t Magazine Size : %d\n", ChangerParams.MagazineSize);

   printf("\n\t Drive Clean Timeout : %u\n", ChangerParams.DriveCleanTimeout);
   
   
   printf("\n  Flags set for the changer : \n");
   Features = ChangerParams.Features0;
   for (i = 0; i < 30; i++) {
      if (Features & 1) {
         printf("\t %s\n", ChangerFlagStrings0[i]);
      }
      Features >>= 1;
   }

   Features = ChangerParams.Features1;
   for (i = 0; i < 11; i++) {
      if (Features & 1) {
         printf("\t %s\n", ChangerFlagStrings1[i]);
      }
      Features >>= 1;
   }

   PRINT_MOVE_CAPABILITIES(ChangerParams.MoveFromTransport, "Transport");
   PRINT_MOVE_CAPABILITIES(ChangerParams.MoveFromSlot, "Slot");
   PRINT_MOVE_CAPABILITIES(ChangerParams.MoveFromIePort, "IEPort");
   PRINT_MOVE_CAPABILITIES(ChangerParams.MoveFromDrive, "Drive");


   PRINT_EXCHANGE_CAPABILITIES(ChangerParams.ExchangeFromTransport, "Transport");
   PRINT_EXCHANGE_CAPABILITIES(ChangerParams.ExchangeFromSlot, "Slot");
   PRINT_EXCHANGE_CAPABILITIES(ChangerParams.ExchangeFromIePort, "IEPort");
   PRINT_EXCHANGE_CAPABILITIES(ChangerParams.ExchangeFromDrive, "Drive");

   
   if ((ChangerParams.Features0) & CHANGER_LOCK_UNLOCK) {
      PRINT_LOCK_UNLOCK_CAPABILITY(ChangerParams.LockUnlockCapabilities, 
                                       LOCK_UNLOCK_IEPORT, "IEport");
      PRINT_LOCK_UNLOCK_CAPABILITY(ChangerParams.LockUnlockCapabilities, 
                                    LOCK_UNLOCK_DOOR, "Drive");
      PRINT_LOCK_UNLOCK_CAPABILITY(ChangerParams.LockUnlockCapabilities, 
                                    LOCK_UNLOCK_KEYPAD, "Keypad");
   }

   if ((ChangerParams.Features0) & CHANGER_POSITION_TO_ELEMENT) {
      PRINT_POSITION_CAPABILITY(ChangerParams.PositionCapabilities, 
                                    CHANGER_TO_TRANSPORT, "Transport");
      PRINT_POSITION_CAPABILITY(ChangerParams.PositionCapabilities, 
                                 CHANGER_TO_SLOT, "Slot");
      PRINT_POSITION_CAPABILITY(ChangerParams.PositionCapabilities, 
                                    CHANGER_TO_DRIVE, "Drive");
      PRINT_POSITION_CAPABILITY(ChangerParams.PositionCapabilities, 
                                    CHANGER_TO_IEPORT, "IEPort");
   }

   return MCT_STATUS_SUCCESS;
}

#if DBG
ULONG mctDebug = 8;
UCHAR DebugBuffer[128];
#endif

#if DBG
VOID
mctDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all medium changer drivers

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= mctDebug) {

        vsprintf(DebugBuffer, DebugMessage, ap);

        printf(DebugBuffer);
    }

    va_end(ap);

} // end mctDebugPrint()

#else

//
// DebugPrint stub
//

VOID
mctDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\ftdisk.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    ftdisk.c

Abstract:

    This driver provides fault tolerance through disk mirroring and striping.
    This module contains routines that support calls from the NT I/O system.

Author:

    Bob Rinne   (bobri)  2-Feb-1992
    Mike Glass  (mglass)
    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntosp.h>
    #include <ntddscsi.h>
    #include <initguid.h>
    #include <mountmgr.h>
    #include <ioevent.h>
    #include <partmgrp.h>
    #include <zwapi.h>
    #include <ntioapi.h>

}

#include <ftdisk.h>

extern "C" {

#include "wmiguid.h"
#include "ntdddisk.h"
#include "ftwmireg.h"

}

//
// Global Sequence number for error log.
//

ULONG FtErrorLogSequence = 0;

extern "C" {

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
FtDiskAddDevice(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  PhysicalDeviceObject,
    IN  PUNICODE_STRING RegistryPath
    );

}

NTSTATUS
FtpCreateLogicalDiskHelper(
    IN OUT  PROOT_EXTENSION         RootExtension,
    IN      FT_LOGICAL_DISK_TYPE    LogicalDiskType,
    IN      USHORT                  NumberOfMembers,
    IN      PFT_LOGICAL_DISK_ID     ArrayOfMembers,
    IN      USHORT                  ConfigurationInformationSize,
    IN      PVOID                   ConfigurationInformation,
    IN      USHORT                  StateInformationSize,
    IN      PVOID                   StateInformation,
    OUT     PFT_LOGICAL_DISK_ID     NewLogicalDiskId
    );

NTSTATUS
FtpBreakLogicalDiskHelper(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  RootLogicalDiskId
    );

NTSTATUS
FtpCreatePartitionLogicalDiskHelper(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN      LONGLONG            PartitionSize,
    OUT     PFT_LOGICAL_DISK_ID NewLogicalDiskId
    );

NTSTATUS
FtpAddPartition(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PDEVICE_OBJECT      Partition,
    IN  PDEVICE_OBJECT      WholeDiskPdo
    );

NTSTATUS
FtpPartitionRemovedHelper(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN      PDEVICE_OBJECT  Partition,
    IN      PDEVICE_OBJECT  WholeDiskPdo
    );

NTSTATUS
FtpSignalCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Event
    );

VOID
FtpRefCountCompletion(
    IN  PVOID       Extension,
    IN  NTSTATUS    Status
    );

VOID
FtpDecrementRefCount(
    IN OUT  PVOLUME_EXTENSION   Extension
    );

NTSTATUS
FtpAllSystemsGo(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp,
    IN  BOOLEAN             MustBeComplete,
    IN  BOOLEAN             MustHaveVolume,
    IN  BOOLEAN             MustBeOnline
    );

NTSTATUS
FtpSetGptAttributesOnDisk(
    IN  PDEVICE_OBJECT  Partition,
    IN  ULONGLONG       GptAttributes
    );

typedef struct _SET_TARGET_CONTEXT {
    KEVENT          Event;
    PDEVICE_OBJECT  TargetObject;
    PFT_VOLUME      FtVolume;
    PDEVICE_OBJECT  WholeDiskPdo;
} SET_TARGET_CONTEXT, *PSET_TARGET_CONTEXT;

VOID
FtpSetTargetCallback(
    IN  PVOLUME_EXTENSION   Extension
    );

VOID
FtpVolumeReadOnlyCallback(
    IN  PVOLUME_EXTENSION   Extension
    );

VOID
FtpZeroRefCallback(
    IN  PVOLUME_EXTENSION   Extension,
    IN  ZERO_REF_CALLBACK   ZeroRefCallback,
    IN  PVOID               ZeroRefContext,
    IN  BOOLEAN             AcquireSemaphore
    );

NTSTATUS
FtpRefCountCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Extension
    );

VOID
FtDiskShutdownFlushCompletionRoutine(
    IN  PVOID       Irp,
    IN  NTSTATUS    Status
    );

typedef struct _FT_PARTITION_OFFLINE_CONTEXT {

    PFT_VOLUME      Root;
    PFT_VOLUME      Parent;
    PFT_VOLUME      Child;
    PKEVENT         Event;

} FT_PARTITION_OFFLINE_CONTEXT, *PFT_PARTITION_OFFLINE_CONTEXT;

VOID
FtpMemberOfflineCallback(
    IN  PVOLUME_EXTENSION   Extension
    );

NTSTATUS
FtpChangeNotify(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    );

VOID
FtpReadWriteCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    );

typedef struct _INSERT_MEMBER_CONTEXT {
    KEVENT      Event;
    PFT_VOLUME  Parent;
    USHORT      MemberNumber;
    PFT_VOLUME  Member;
} INSERT_MEMBER_CONTEXT, *PINSERT_MEMBER_CONTEXT;

VOID
FtpInsertMemberCallback(
    IN  PVOLUME_EXTENSION   Extension
    );

VOID
FtpVolumeOnlineCallback(
    IN  PVOLUME_EXTENSION   Extension
    );

VOID
FtpVolumeOfflineCallback(
    IN  PVOLUME_EXTENSION   Extension
    );

VOID
FtpPropogateRegistryState(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PFT_VOLUME          Volume
    );

VOID
FtpQueryRemoveCallback(
    IN  PVOLUME_EXTENSION   Extension
    );

VOID
FtDiskShutdownCompletionRoutine(
    IN  PVOID       Context,
    IN  NTSTATUS    Status
    );

NTSTATUS
FtpCheckForQueryRemove(
    IN OUT  PVOLUME_EXTENSION   Extension
    );

BOOLEAN
FtpCheckForCancelRemove(
    IN OUT  PVOLUME_EXTENSION   Extension
    );

VOID
FtpRemoveHelper(
    IN OUT  PVOLUME_EXTENSION   Extension
    );

VOID
FtpStartCallback(
    IN  PVOLUME_EXTENSION   Extension
    );

VOID
FtpWorkerThread(
    IN  PVOID   RootExtension
    );

VOID
FtpEventSignalCompletion(
    IN  PVOID       Event,
    IN  NTSTATUS    Status
    );

NTSTATUS
FtWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FtWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    );

NTSTATUS
FtpPmWmiCounterLibContext(
    IN OUT PROOT_EXTENSION RootExtension,
    IN     PIRP            Irp
    );

NTSTATUS
FtpCheckForCompleteVolume(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PFT_VOLUME          FtVolume
    );

VOID
FtpCancelChangeNotify(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PVOLUME_EXTENSION
FtpFindExtensionCoveringPartition(
    IN  PROOT_EXTENSION RootExtension,
    IN  PDEVICE_OBJECT  Partition
    );

VOID
FtpCleanupVolumeExtension(
    IN OUT  PVOLUME_EXTENSION   Extension
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, FtDiskAddDevice)
#endif

#define IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS_ADMIN  CTL_CODE(IOCTL_VOLUME_BASE, 0, METHOD_BUFFERED, FILE_READ_ACCESS)

#define UNIQUE_ID_MAX_BUFFER_SIZE           50
#define REVERT_GPT_ATTRIBUTES_REGISTRY_NAME (L"GptAttributeRevertEntries")


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
FtpAcquireWithTimeout(
    IN OUT  PROOT_EXTENSION RootExtension
    )

/*++

Routine Description:

    This routine grabs the root semaphore.  This routine will timeout
    after 10 seconds.

Arguments:

    RootExtension   - Supplies the root extension.

Return Value:

    None.

--*/

{
    LARGE_INTEGER   timeout;
    NTSTATUS        status;

    timeout.QuadPart = -10*(10*1000*1000);
    status = KeWaitForSingleObject(&RootExtension->Mutex, Executive,
                                   KernelMode, FALSE, &timeout);
    if (status == STATUS_TIMEOUT) {
        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}

VOID
FtpDeleteVolume(
    IN  PFT_VOLUME  Volume
    )

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    n = Volume->QueryNumberOfMembers();
    for (i = 0; i < n; i++) {
        vol = Volume->GetMember(i);
        if (vol) {
            FtpDeleteVolume(vol);
        }
    }

    if (!InterlockedDecrement(&Volume->_refCount)) {
        delete Volume;
    }
}

PFT_VOLUME
FtpBuildFtVolume(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN OUT  PDEVICE_OBJECT      Partition,
    IN OUT  PDEVICE_OBJECT      WholeDiskPdo
    )

/*++

Routine Description:

    This routine builds up an FT volume object for the given logical
    disk id.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id.

    Partition       - Supplies the first partition for this volume.

    WholeDiskPdo    - Supplies the whole disk PDO.

Return Value:

    A new FT volume object or NULL.

--*/

{
    PFT_LOGICAL_DISK_INFORMATION_SET    diskInfoSet = RootExtension->DiskInfoSet;
    FT_LOGICAL_DISK_TYPE                diskType;
    LONGLONG                            offset;
    ULONG                               sectorSize;
    PPARTITION                          partition;
    NTSTATUS                            status;
    USHORT                              numMembers, i;
    PFT_VOLUME*                         volArray;
    PCOMPOSITE_FT_VOLUME                comp;

    if (!LogicalDiskId) {
        return NULL;
    }

    diskType = diskInfoSet->QueryLogicalDiskType(LogicalDiskId);
    if (diskType == FtPartition) {

        partition = new PARTITION;
        if (!partition) {
            return NULL;
        }

        status = partition->Initialize(RootExtension, LogicalDiskId,
                                       Partition, WholeDiskPdo);
        if (!NT_SUCCESS(status)) {
            delete partition;
            return NULL;
        }

        return partition;
    }

    switch (diskType) {

        case FtVolumeSet:
            comp = new VOLUME_SET;
            break;

        case FtStripeSet:
            comp = new STRIPE;
            break;

        case FtMirrorSet:
            comp = new MIRROR;
            break;

        case FtStripeSetWithParity:
            comp = new STRIPE_WP;
            break;

        case FtRedistribution:
            comp = new REDISTRIBUTION;
            break;

        default:
            comp = NULL;
            break;

    }

    if (!comp) {
        return comp;
    }

    numMembers = diskInfoSet->QueryNumberOfMembersInLogicalDisk(LogicalDiskId);
    ASSERT(numMembers);

    volArray = (PFT_VOLUME*)
               ExAllocatePool(NonPagedPool, numMembers*sizeof(PFT_VOLUME));
    if (!volArray) {
        delete comp;
        return NULL;
    }

    for (i = 0; i < numMembers; i++) {
        volArray[i] = FtpBuildFtVolume(RootExtension,
                      diskInfoSet->QueryMemberLogicalDiskId(LogicalDiskId, i),
                      Partition, WholeDiskPdo);
    }

    status = comp->Initialize(RootExtension, LogicalDiskId, volArray,
                              numMembers, diskInfoSet->
                              GetConfigurationInformation(LogicalDiskId),
                              diskInfoSet->GetStateInformation(LogicalDiskId));

    if (!NT_SUCCESS(status)) {
        for (i = 0; i < numMembers; i++) {
            if (volArray[i]) {
                FtpDeleteVolume(volArray[i]);
            }
        }
        delete comp;
        return NULL;
    }

    return comp;
}

VOID
FtpCheckForRevertGptAttributes(
    IN  PROOT_EXTENSION                 RootExtension,
    IN  PDEVICE_OBJECT                  Partition,
    IN  ULONG                           MbrSignature,
    IN  GUID*                           GptPartitionGuid,
    IN  PFT_LOGICAL_DISK_INFORMATION    DiskInfo
    )

{
    ULONG                           i, n;
    PFTP_GPT_ATTRIBUTE_REVERT_ENTRY p;

    n = RootExtension->NumberOfAttributeRevertEntries;
    p = RootExtension->GptAttributeRevertEntries;
    for (i = 0; i < n; i++) {

        if (MbrSignature) {
            if (MbrSignature == p[i].MbrSignature) {
                break;
            }
        } else {
            if (IsEqualGUID(p[i].PartitionUniqueId, *GptPartitionGuid)) {
                break;
            }
        }
    }

    if (i == n) {
        return;
    }

    if (MbrSignature) {
        DiskInfo->SetGptAttributes(p[i].GptAttributes);
    } else {
        FtpSetGptAttributesOnDisk(Partition, p[i].GptAttributes);
    }

    RootExtension->NumberOfAttributeRevertEntries--;

    if (i + 1 == n) {
        if (!RootExtension->NumberOfAttributeRevertEntries) {
            ExFreePool(RootExtension->GptAttributeRevertEntries);
            RootExtension->GptAttributeRevertEntries = NULL;
        }
        return;
    }

    RtlMoveMemory(&p[i], &p[i + 1],
                  (n - i - 1)*sizeof(FTP_GPT_ATTRIBUTE_REVERT_ENTRY));
}

NTSTATUS
FtpQueryPartitionInformation(
    IN  PROOT_EXTENSION RootExtension,
    IN  PDEVICE_OBJECT  Partition,
    OUT PULONG          DiskNumber,
    OUT PLONGLONG       Offset,
    OUT PULONG          PartitionNumber,
    OUT PUCHAR          PartitionType,
    OUT PLONGLONG       PartitionLength,
    OUT GUID*           PartitionTypeGuid,
    OUT GUID*           PartitionUniqueIdGuid,
    OUT PBOOLEAN        IsGpt,
    OUT PULONGLONG      GptAttributes
    )

/*++

Routine Description:

    This routine returns the disk number and offset for the given partition.

Arguments:

    Partition       - Supplies the partition.

    DiskNumber      - Returns the disk number.

    Offset          - Returns the offset.

    PartitionNumber - Returns the partition number.

    PartitionType   - Returns the partition type.

    PartitionLength - Returns the partition length.

Return Value:

    NTSTATUS

--*/

{
    KEVENT                      event;
    PIRP                        irp;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;
    STORAGE_DEVICE_NUMBER       number;
    PLIST_ENTRY                 l;
    PARTITION_INFORMATION_EX    partInfo;

    if (DiskNumber || PartitionNumber) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        irp = IoBuildDeviceIoControlRequest(IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                            Partition, NULL, 0, &number,
                                            sizeof(number), FALSE, &event,
                                            &ioStatus);
        if (!irp) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = IoCallDriver(Partition, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (DiskNumber) {
            *DiskNumber = number.DeviceNumber;
        }

        if (PartitionNumber) {
            *PartitionNumber = number.PartitionNumber;
        }
    }

    if (Offset || PartitionType || PartitionLength || PartitionTypeGuid ||
        PartitionUniqueIdGuid || IsGpt || GptAttributes) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO_EX,
                                            Partition, NULL, 0, &partInfo,
                                            sizeof(partInfo), FALSE, &event,
                                            &ioStatus);
        if (!irp) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = IoCallDriver(Partition, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (Offset) {
            *Offset = partInfo.StartingOffset.QuadPart;
        }

        if (PartitionType) {
            if (partInfo.PartitionStyle == PARTITION_STYLE_MBR) {
                *PartitionType = partInfo.Mbr.PartitionType;
            } else {
                *PartitionType = 0;
            }
        }

        if (PartitionLength) {
            *PartitionLength = partInfo.PartitionLength.QuadPart;
        }

        if (PartitionTypeGuid) {
            if (partInfo.PartitionStyle == PARTITION_STYLE_GPT) {
                *PartitionTypeGuid = partInfo.Gpt.PartitionType;
            }
        }

        if (PartitionUniqueIdGuid) {
            if (partInfo.PartitionStyle == PARTITION_STYLE_GPT) {
                *PartitionUniqueIdGuid = partInfo.Gpt.PartitionId;
            }
        }

        if (IsGpt) {
            if (partInfo.PartitionStyle == PARTITION_STYLE_GPT) {
                *IsGpt = TRUE;
            } else {
                *IsGpt = FALSE;
            }
        }

        if (GptAttributes) {
            if (partInfo.PartitionStyle == PARTITION_STYLE_GPT) {
                *GptAttributes = partInfo.Gpt.Attributes;
            } else {
                *GptAttributes = 0;
            }
        }
    }

    return STATUS_SUCCESS;
}

PVOLUME_EXTENSION
FtpFindExtensionCoveringDiskId(
    IN  PROOT_EXTENSION     RootExtension,
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine finds the device extension for the given root logical
    disk id.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id.

Return Value:

    A volume extension or NULL.

--*/

{
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;

    for (l = RootExtension->VolumeList.Flink; l != &RootExtension->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        if (extension->FtVolume &&
            extension->FtVolume->GetContainedLogicalDisk(LogicalDiskId)) {

            return extension;
        }
    }

    return NULL;
}

PVOLUME_EXTENSION
FtpFindExtension(
    IN  PROOT_EXTENSION     RootExtension,
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine finds the device extension for the given root logical
    disk id.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id.

Return Value:

    A volume extension or NULL.

--*/

{
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;

    for (l = RootExtension->VolumeList.Flink; l != &RootExtension->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        if (extension->FtVolume &&
            extension->FtVolume->QueryLogicalDiskId() == LogicalDiskId) {

            return extension;
        }
    }

    return NULL;
}

class EMPTY_IRP_QUEUE_WORK_ITEM : public WORK_QUEUE_ITEM {

    public:

        LIST_ENTRY          IrpQueue;
        PVOLUME_EXTENSION   Extension;

};

typedef EMPTY_IRP_QUEUE_WORK_ITEM *PEMPTY_IRP_QUEUE_WORK_ITEM;

VOID
FtpEmptyQueueWorkerRoutine(
    IN  PVOID   WorkItem
    )

/*++

Routine Description:

    This routine empties the given queue of irps by calling their respective
    dispatch routines.

Arguments:

    WorkItem    - Supplies the work item.

Return Value:

    None.

--*/

{
    PEMPTY_IRP_QUEUE_WORK_ITEM  workItem = (PEMPTY_IRP_QUEUE_WORK_ITEM) WorkItem;
    PLIST_ENTRY                 q, l;
    PDRIVER_OBJECT              driverObject;
    PDEVICE_OBJECT              deviceObject;
    PIRP                        irp;
    PIO_STACK_LOCATION          irpSp;

    q = &workItem->IrpQueue;
    driverObject = workItem->Extension->Root->DriverObject;
    deviceObject = workItem->Extension->DeviceObject;

    while (!IsListEmpty(q)) {
        l = RemoveHeadList(q);
        irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
        irpSp = IoGetCurrentIrpStackLocation(irp);
        driverObject->MajorFunction[irpSp->MajorFunction](deviceObject, irp);
    }

    ExFreePool(WorkItem);
}

ULONG
FtpQueryDiskSignature(
    IN  PDEVICE_OBJECT  WholeDiskPdo
    )

/*++

Routine Description:

    This routine queries the disk signature for the given disk.

Arguments:

    WholeDisk   - Supplies the whole disk.

Return Value:

    The disk signature.

--*/

{
    PDEVICE_OBJECT              wholeDisk;
    KEVENT                      event;
    PIRP                        irp;
    PARTMGR_DISK_SIGNATURE      partSig;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;

    wholeDisk = IoGetAttachedDeviceReference(WholeDiskPdo);
    if (!wholeDisk) {
        return 0;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_PARTMGR_QUERY_DISK_SIGNATURE,
                                        wholeDisk, NULL, 0, &partSig,
                                        sizeof(partSig), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        ObDereferenceObject(wholeDisk);
        return 0;
    }

    status = IoCallDriver(wholeDisk, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        ObDereferenceObject(wholeDisk);
        return 0;
    }

    ObDereferenceObject(wholeDisk);

    return partSig.Signature;
}

ULONG
FtpQueryDiskSignatureCache(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    if (!Extension->Signature) {
        Extension->Signature = FtpQueryDiskSignature(Extension->WholeDiskPdo);
    }

    return Extension->Signature;

}

BOOLEAN
FtpQueryUniqueIdBuffer(
    IN  PVOLUME_EXTENSION   Extension,
    OUT PUCHAR              UniqueId,
    OUT PUSHORT             UniqueIdLength
    )

{
    GUID                uniqueGuid;
    ULONG               signature;
    NTSTATUS            status;
    LONGLONG            offset;
    FT_LOGICAL_DISK_ID  diskId;

    if (Extension->IsGpt) {
        *UniqueIdLength = sizeof(GUID) + 8;
    } else if (Extension->TargetObject) {
        *UniqueIdLength = sizeof(ULONG) + sizeof(LONGLONG);
    } else if (Extension->FtVolume) {
        *UniqueIdLength = sizeof(FT_LOGICAL_DISK_ID);
    } else {
        return FALSE;
    }

    if (!UniqueId) {
        return TRUE;
    }

    if (Extension->IsGpt) {

        RtlCopyMemory(UniqueId, "DMIO:ID:", 8);
        RtlCopyMemory(UniqueId + 8, &Extension->UniqueIdGuid, sizeof(GUID));

    } else if (Extension->TargetObject) {

        ASSERT(Extension->WholeDiskPdo);

        signature = FtpQueryDiskSignatureCache(Extension);
        if (!signature) {
            return FALSE;
        }

        status = FtpQueryPartitionInformation(Extension->Root,
                                              Extension->TargetObject,
                                              NULL, &offset, NULL, NULL, NULL,
                                              NULL, NULL, NULL, NULL);

        if (!NT_SUCCESS(status)) {
            return FALSE;
        }

        RtlCopyMemory(UniqueId, &signature, sizeof(signature));
        RtlCopyMemory(UniqueId + sizeof(signature), &offset, sizeof(offset));

    } else {
        diskId = Extension->FtVolume->QueryLogicalDiskId();
        RtlCopyMemory(UniqueId, &diskId, sizeof(diskId));
    }

    return TRUE;
}

UCHAR
FtpQueryMountLetter(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine queries the drive letter from the mount point manager.

Arguments:

    Extension   - Supplies the volume extension.

    Delete      - Supplies whether or not to delete the drive letter.

Return Value:

    A mount point drive letter or 0.

--*/

{
    USHORT                  uniqueIdLength;
    ULONG                   mountPointSize;
    PMOUNTMGR_MOUNT_POINT   mountPoint;
    UNICODE_STRING          name;
    NTSTATUS                status;
    PFILE_OBJECT            fileObject;
    PDEVICE_OBJECT          deviceObject;
    KEVENT                  event;
    PIRP                    irp;
    MOUNTMGR_MOUNT_POINTS   points;
    IO_STATUS_BLOCK         ioStatus;
    ULONG                   mountPointsSize;
    PMOUNTMGR_MOUNT_POINTS  mountPoints;
    BOOLEAN                 freeMountPoints;
    UNICODE_STRING          dosDevices;
    UCHAR                   driveLetter;
    ULONG                   i;
    UNICODE_STRING          subString;
    WCHAR                   c;

    if (!FtpQueryUniqueIdBuffer(Extension, NULL, &uniqueIdLength)) {
        return 0;
    }

    mountPointSize = sizeof(MOUNTMGR_MOUNT_POINT) + uniqueIdLength;
    mountPoint = (PMOUNTMGR_MOUNT_POINT)
                 ExAllocatePool(PagedPool, mountPointSize);
    if (!mountPoint) {
        return 0;
    }

    if (!FtpQueryUniqueIdBuffer(Extension, (PUCHAR) (mountPoint + 1),
                                &uniqueIdLength)) {

        ExFreePool(mountPoint);
        return 0;
    }

    RtlZeroMemory(mountPoint, sizeof(MOUNTMGR_MOUNT_POINT));
    mountPoint->UniqueIdOffset = (USHORT) sizeof(MOUNTMGR_MOUNT_POINT);
    mountPoint->UniqueIdLength = uniqueIdLength;

    RtlInitUnicodeString(&name, MOUNTMGR_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(&name, FILE_READ_ATTRIBUTES, &fileObject,
                                      &deviceObject);
    if (!NT_SUCCESS(status)) {
        ExFreePool(mountPoint);
        return 0;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_QUERY_POINTS,
                                        deviceObject, mountPoint,
                                        mountPointSize, &points,
                                        sizeof(points), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        ObDereferenceObject(fileObject);
        ExFreePool(mountPoint);
        return 0;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (status == STATUS_BUFFER_OVERFLOW) {

        mountPointsSize = points.Size;
        mountPoints = (PMOUNTMGR_MOUNT_POINTS)
                      ExAllocatePool(PagedPool, mountPointsSize);
        if (!mountPoints) {
            ObDereferenceObject(fileObject);
            ExFreePool(mountPoint);
            return 0;
        }

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_QUERY_POINTS,
                                            deviceObject, mountPoint,
                                            mountPointSize, mountPoints,
                                            mountPointsSize, FALSE, &event,
                                            &ioStatus);
        if (!irp) {
            ExFreePool(mountPoints);
            ObDereferenceObject(fileObject);
            ExFreePool(mountPoint);
            return 0;
        }

        status = IoCallDriver(deviceObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        freeMountPoints = TRUE;

    } else {
        mountPoints = &points;
        freeMountPoints = FALSE;
    }

    ExFreePool(mountPoint);
    ObDereferenceObject(fileObject);

    if (!NT_SUCCESS(status)) {
        if (freeMountPoints) {
            ExFreePool(mountPoints);
        }
        return 0;
    }

    RtlInitUnicodeString(&dosDevices, L"\\DosDevices\\");

    driveLetter = 0;
    for (i = 0; i < mountPoints->NumberOfMountPoints; i++) {

        if (mountPoints->MountPoints[i].SymbolicLinkNameLength !=
            dosDevices.Length + 2*sizeof(WCHAR)) {

            continue;
        }

        subString.Length = subString.MaximumLength = dosDevices.Length;
        subString.Buffer = (PWSTR) ((PCHAR) mountPoints +
                mountPoints->MountPoints[i].SymbolicLinkNameOffset);

        if (RtlCompareUnicodeString(&dosDevices, &subString, TRUE)) {
            continue;
        }

        c = subString.Buffer[subString.Length/sizeof(WCHAR) + 1];

        if (c != ':') {
            continue;
        }

        c = subString.Buffer[subString.Length/sizeof(WCHAR)];

        if (c < FirstDriveLetter || c > LastDriveLetter) {
            continue;
        }

        driveLetter = (UCHAR) c;
        break;
    }

    if (freeMountPoints) {
        ExFreePool(mountPoints);
    }

    return driveLetter;
}

NTSTATUS
FtpDiskRegistryQueryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine is a query routine for the disk registry entry.  It allocates
    space for the disk registry and copies it to the given context.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Returns the disk registry entry.

    EntryContext    - Returns the disk registry size.

Return Value:

    NTSTATUS

--*/

{
    PVOID                   p;
    PDISK_CONFIG_HEADER*    reg;
    PULONG                  size;

    p = ExAllocatePool(PagedPool, ValueLength);
    if (!p) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(p, ValueData, ValueLength);

    reg = (PDISK_CONFIG_HEADER*) Context;
    *reg = (PDISK_CONFIG_HEADER) p;

    size = (PULONG) EntryContext;
    if (size) {
        *size = ValueLength;
    }

    return STATUS_SUCCESS;
}

PDISK_PARTITION
FtpFindDiskPartition(
    IN  PDISK_REGISTRY  DiskRegistry,
    IN  ULONG           Signature,
    IN  LONGLONG        Offset
    )

{
    PDISK_DESCRIPTION   diskDescription;
    USHORT              i, j;
    PDISK_PARTITION     diskPartition;
    LONGLONG            tmp;

    diskDescription = &DiskRegistry->Disks[0];
    for (i = 0; i < DiskRegistry->NumberOfDisks; i++) {
        if (diskDescription->Signature == Signature) {
            for (j = 0; j < diskDescription->NumberOfPartitions; j++) {
                diskPartition = &diskDescription->Partitions[j];
                tmp = *((LONGLONG UNALIGNED*)
                        &diskPartition->StartingOffset.QuadPart);
                if (tmp == Offset) {
                    return diskPartition;
                }
            }
        }

        diskDescription = (PDISK_DESCRIPTION) &diskDescription->
                          Partitions[diskDescription->NumberOfPartitions];
    }

    return NULL;
}

UCHAR
FtpQueryDriveLetterFromRegistry(
    IN  PROOT_EXTENSION     RootExtension,
    IN  PVOLUME_EXTENSION   Extension,
    IN  PDEVICE_OBJECT      TargetObject,
    IN  PDEVICE_OBJECT      WholeDiskPdo,
    IN  BOOLEAN             DeleteLetter
    )

/*++

Routine Description:

    This routine queries the sticky drive letter from the old registry.

Arguments:

    RootExtension   - Supplies the root extension.

    TargetObject    - Supplies the device object for the partition.

    WholeDiskPdo    - Supplies the whole disk PDO.

    DeleteLetter    - Supplies whether or not to delete the drive letter.

Return Value:

    A sticky drive letter.
    0 to represent no drive letter.

--*/

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    ULONG                       registrySize;
    NTSTATUS                    status;
    PDISK_CONFIG_HEADER         registry;
    PDISK_REGISTRY              diskRegistry;
    ULONG                       signature;
    LONGLONG                    offset;
    PDISK_PARTITION             diskPartition;
    UCHAR                       driveLetter;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = FtpDiskRegistryQueryRoutine;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = L"Information";
    queryTable[0].EntryContext = &registrySize;

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, DISK_REGISTRY_KEY_W,
                                    queryTable, &registry, NULL);
    if (!NT_SUCCESS(status)) {
        return 0;
    }

    ObReferenceObject(TargetObject);
    ObReferenceObject(WholeDiskPdo);

    FtpRelease(RootExtension);

    diskRegistry = (PDISK_REGISTRY)
                   ((PUCHAR) registry + registry->DiskInformationOffset);

    signature = FtpQueryDiskSignatureCache(Extension);
    if (signature) {
        status = FtpQueryPartitionInformation(RootExtension, TargetObject,
                                              NULL, &offset, NULL, NULL, NULL,
                                              NULL, NULL, NULL, NULL);
    } else {
        status = STATUS_UNSUCCESSFUL;
    }

    FtpAcquire(RootExtension);
    ObDereferenceObject(WholeDiskPdo);
    ObDereferenceObject(TargetObject);
    ExFreePool(registry);

    if (!NT_SUCCESS(status)) {
        return 0;
    }

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = FtpDiskRegistryQueryRoutine;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = L"Information";
    queryTable[0].EntryContext = &registrySize;

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, DISK_REGISTRY_KEY_W,
                                    queryTable, &registry, NULL);
    if (!NT_SUCCESS(status)) {
        return 0;
    }

    diskRegistry = (PDISK_REGISTRY)
                   ((PUCHAR) registry + registry->DiskInformationOffset);

    diskPartition = FtpFindDiskPartition(diskRegistry, signature, offset);
    if (!diskPartition) {
        ExFreePool(registry);
        return 0;
    }

    if (diskPartition->AssignDriveLetter) {
        driveLetter = diskPartition->DriveLetter;
    } else {
        driveLetter = 0xFF;
    }

    if (DeleteLetter) {
        diskPartition->DriveLetter = 0;
        diskPartition->AssignDriveLetter = TRUE;
        RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, DISK_REGISTRY_KEY_W,
                              L"Information", REG_BINARY, registry,
                              registrySize);
    }

    ExFreePool(registry);

    return driveLetter;
}

UCHAR
FtpQueryDriveLetterFromRegistry(
    IN  PVOLUME_EXTENSION   Extension,
    IN  BOOLEAN             DeleteLetter
    )

/*++

Routine Description:

    This routine queries the sticky drive letter from the old registry.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    A sticky drive letter.
    0 to represent no drive letter.

--*/

{
    if (Extension->TargetObject) {
        return FtpQueryDriveLetterFromRegistry(Extension->Root,
                                               Extension,
                                               Extension->TargetObject,
                                               Extension->WholeDiskPdo,
                                               DeleteLetter);
    }

    return 0;
}

BOOLEAN
FtpSetMountLetter(
    IN  PVOLUME_EXTENSION   Extension,
    IN  UCHAR               DriveLetter
    )

/*++

Routine Description:

    This routine sets a drive letter to the given device in the mount table.

Arguments:

    Extension   - Supplies the volume extension.

    DriveLetter - Supplies the drive letter.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    WCHAR                           dosBuffer[30];
    UNICODE_STRING                  dosName;
    WCHAR                           ntBuffer[40];
    UNICODE_STRING                  ntName;
    ULONG                           createPointSize;
    PMOUNTMGR_CREATE_POINT_INPUT    createPoint;
    UNICODE_STRING                  name;
    NTSTATUS                        status;
    PFILE_OBJECT                    fileObject;
    PDEVICE_OBJECT                  deviceObject;
    KEVENT                          event;
    PIRP                            irp;
    IO_STATUS_BLOCK                 ioStatus;

    swprintf(dosBuffer, L"\\DosDevices\\%c:", DriveLetter);
    RtlInitUnicodeString(&dosName, dosBuffer);

    swprintf(ntBuffer, L"\\Device\\HarddiskVolume%d", Extension->VolumeNumber);
    RtlInitUnicodeString(&ntName, ntBuffer);

    createPointSize = sizeof(MOUNTMGR_CREATE_POINT_INPUT) +
                      dosName.Length + ntName.Length;

    createPoint = (PMOUNTMGR_CREATE_POINT_INPUT)
                  ExAllocatePool(PagedPool, createPointSize);
    if (!createPoint) {
        return FALSE;
    }

    createPoint->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    createPoint->SymbolicLinkNameLength = dosName.Length;
    createPoint->DeviceNameOffset = createPoint->SymbolicLinkNameOffset +
                                    createPoint->SymbolicLinkNameLength;
    createPoint->DeviceNameLength = ntName.Length;

    RtlCopyMemory((PCHAR) createPoint + createPoint->SymbolicLinkNameOffset,
                  dosName.Buffer, dosName.Length);
    RtlCopyMemory((PCHAR) createPoint + createPoint->DeviceNameOffset,
                  ntName.Buffer, ntName.Length);

    RtlInitUnicodeString(&name, MOUNTMGR_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(&name, FILE_READ_ATTRIBUTES, &fileObject,
                                      &deviceObject);
    if (!NT_SUCCESS(status)) {
        ExFreePool(createPoint);
        return 0;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_CREATE_POINT,
                                        deviceObject, createPoint,
                                        createPointSize, NULL, 0, FALSE,
                                        &event, &ioStatus);
    if (!irp) {
        ObDereferenceObject(fileObject);
        ExFreePool(createPoint);
        return FALSE;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ObDereferenceObject(fileObject);
    ExFreePool(createPoint);

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    return TRUE;
}

VOID
FtpCreateOldNameLinks(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine creates a \Device\Harddisk%d\Partition%d name for the
    given target device for legacy devices.  If successful, it stores the
    name in the device extension.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    None.

--*/

{
    WCHAR           deviceNameBuffer[64];
    UNICODE_STRING  deviceName;
    NTSTATUS        status;
    ULONG           diskNumber, partitionNumber, i;
    WCHAR           oldNameBuffer[80];
    UNICODE_STRING  oldName;

    swprintf(deviceNameBuffer, L"\\Device\\HarddiskVolume%d", Extension->VolumeNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);

    if (Extension->TargetObject) {

        status = FtpQueryPartitionInformation(Extension->Root,
                                              Extension->TargetObject,
                                              &diskNumber, NULL,
                                              &partitionNumber, NULL, NULL,
                                              NULL, NULL, NULL, NULL);
        if (!NT_SUCCESS(status)) {
            return;
        }

        swprintf(oldNameBuffer, L"\\Device\\Harddisk%d\\Partition%d",
                 diskNumber, partitionNumber);
        RtlInitUnicodeString(&oldName, oldNameBuffer);

        IoDeleteSymbolicLink(&oldName);
        for (i = 0; i < 1000; i++) {
            status = IoCreateSymbolicLink(&oldName, &deviceName);
            if (NT_SUCCESS(status)) {
                break;
            }
        }

    } else {
        Extension->FtVolume->CreateLegacyNameLinks(&deviceName);
    }
}

NTSTATUS
FtpQuerySuperFloppyDevnodeName(
    IN  PVOLUME_EXTENSION   Extension,
    OUT PWCHAR*             DevnodeName
    )

{
    NTSTATUS        status;
    UNICODE_STRING  string;
    PWCHAR          result;
    ULONG           n, i;
    WCHAR           c;

    status = IoRegisterDeviceInterface(Extension->WholeDiskPdo, &DiskClassGuid,
                                       NULL, &string);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    result = (PWCHAR) ExAllocatePool(PagedPool, string.Length + sizeof(WCHAR));
    if (!result) {
        ExFreePool(string.Buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    n = string.Length/sizeof(WCHAR);
    for (i = 0; i < n; i++) {
        c = string.Buffer[i];
        if (c <= ' ' || c >= 0x80 || c == ',' || c == '\\') {
            c = '_';
        }
        result[i] = c;
    }
    result[n] = 0;
    ExFreePool(string.Buffer);

    *DevnodeName = result;

    return STATUS_SUCCESS;
}

BOOLEAN
FtpCreateNewDevice(
    IN  PROOT_EXTENSION     RootExtension,
    IN  PDEVICE_OBJECT      TargetObject,
    IN  PFT_VOLUME          FtVolume,
    IN  PDEVICE_OBJECT      WholeDiskPdo,
    IN  ULONG               AlignmentRequirement,
    IN  BOOLEAN             IsPreExposure,
    IN  BOOLEAN             IsHidden,
    IN  BOOLEAN             IsReadOnly,
    IN  BOOLEAN             IsEspType,
    IN  ULONGLONG           MbrGptAttributes
    )

/*++

Routine Description:

    This routine creates a new device object with the next available
    device name using the given target object of ft volume.

Arguments:

    RootExtension   - Supplies the root extension.

    TargetObject    - Supplies the partition.

    FtVolume        - Supplies the FT volume.

    WholeDiskPdo    - Supplies the whole disk PDO.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    WCHAR               volumeName[30];
    UNICODE_STRING      volumeString;
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PVOLUME_EXTENSION   extension, e;
    PWCHAR              buf;
    ULONG               signature;
    LONGLONG            offset, size;
    PLIST_ENTRY         l;
    LONG                r;
    GUID                uniqueGuid;
    UNICODE_STRING      guidString;
    BOOLEAN             IsGpt;

    ASSERT(TargetObject || FtVolume);
    ASSERT(!(TargetObject && FtVolume));
    ASSERT(!TargetObject || WholeDiskPdo);

    swprintf(volumeName, L"\\Device\\HarddiskVolume%d",
             RootExtension->NextVolumeNumber);
    RtlInitUnicodeString(&volumeString, volumeName);

    status = IoCreateDevice(RootExtension->DriverObject,
                            sizeof(VOLUME_EXTENSION),
                            &volumeString, FILE_DEVICE_DISK, 0,
                            FALSE, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    extension = (PVOLUME_EXTENSION) deviceObject->DeviceExtension;
    RtlZeroMemory(extension, sizeof(VOLUME_EXTENSION));
    extension->DeviceObject = deviceObject;
    extension->Root = RootExtension;
    extension->DeviceExtensionType = DEVICE_EXTENSION_VOLUME;
    KeInitializeSpinLock(&extension->SpinLock);
    extension->TargetObject = TargetObject;
    extension->FtVolume = FtVolume;
    extension->RefCount = 1;
    InitializeListHead(&extension->ZeroRefHoldQueue);
    extension->IsStarted = FALSE;
    extension->IsOffline = TRUE;
    extension->IsHidden = IsHidden;
    extension->IsReadOnly = IsReadOnly;
    extension->IsEspType = IsEspType;
    extension->VolumeNumber = RootExtension->NextVolumeNumber++;
    extension->EmergencyTransferPacket = new DISPATCH_TP;
    InitializeListHead(&extension->EmergencyTransferPacketQueue);
    extension->MbrGptAttributes = MbrGptAttributes;

    if (!extension->EmergencyTransferPacket) {
        IoDeleteDevice(deviceObject);
        return FALSE;
    }

    InitializeListHead(&extension->ChangeNotifyIrps);

    buf = (PWCHAR) ExAllocatePool(PagedPool, 80*sizeof(WCHAR));
    if (!buf) {
        delete extension->EmergencyTransferPacket;
        IoDeleteDevice(deviceObject);
        return FALSE;
    }

    if (TargetObject) {

        extension->WholeDiskPdo = WholeDiskPdo;
        extension->WholeDisk = IoGetAttachedDeviceReference(WholeDiskPdo);
        ObDereferenceObject(extension->WholeDisk);

        status = FtpQueryPartitionInformation(RootExtension, TargetObject,
                                              NULL, &offset, NULL, NULL,
                                              &size, NULL, &uniqueGuid,
                                              &IsGpt, NULL);
        if (!NT_SUCCESS(status)) {
            delete extension->EmergencyTransferPacket;
            IoDeleteDevice(deviceObject);
            return FALSE;
        }

        extension->PartitionOffset = offset;
        extension->PartitionLength = size;

        if (IsGpt) {
            extension->IsGpt = TRUE;
            extension->UniqueIdGuid = uniqueGuid;

            if (IsEspType &&
                IsEqualGUID(uniqueGuid,
                            RootExtension->ESPUniquePartitionGUID)) {

                IoSetSystemPartition(&volumeString);
            }

            status = RtlStringFromGUID(uniqueGuid, &guidString);
            if (!NT_SUCCESS(status)) {
                delete extension->EmergencyTransferPacket;
                IoDeleteDevice(deviceObject);
                return FALSE;
            }

            swprintf(buf, L"GptPartition%s", guidString.Buffer);
            ExFreePool(guidString.Buffer);

        } else if (offset == 0) {

            extension->IsSuperFloppy = TRUE;
            ExFreePool(buf);

            status = FtpQuerySuperFloppyDevnodeName(extension, &buf);
            if (!NT_SUCCESS(status)) {
                delete extension->EmergencyTransferPacket;
                IoDeleteDevice(deviceObject);
                return FALSE;
            }

        } else {

            signature = FtpQueryDiskSignatureCache(extension);
            if (!signature) {
                delete extension->EmergencyTransferPacket;
                IoDeleteDevice(deviceObject);
                return FALSE;
            }

            swprintf(buf, L"Signature%XOffset%I64XLength%I64X", signature,
                     offset, size);
        }

    } else {
        swprintf(buf, L"Ft%I64X", FtVolume->QueryLogicalDiskId());
    }

    RtlInitUnicodeString(&extension->DeviceNodeName, buf);
    KeInitializeSemaphore(&extension->Semaphore, 1, 1);
    InsertTailList(&RootExtension->VolumeList, &extension->ListEntry);

    deviceObject->Flags |= DO_DIRECT_IO;
    deviceObject->AlignmentRequirement = AlignmentRequirement;
    if (FtVolume) {
        deviceObject->StackSize = FtVolume->QueryStackSize() + 1;
    } else {
        deviceObject->StackSize = TargetObject->StackSize + 1;
    }

    if (IsPreExposure) {
        extension->TargetObject = NULL;
        extension->FtVolume = NULL;
        extension->IsPreExposure = TRUE;
        extension->WholeDiskPdo = NULL;
        extension->WholeDisk = NULL;
        extension->PartitionOffset = 0;
        extension->PartitionLength = 0;

        r = 1;
        for (l = RootExtension->VolumeList.Flink;
             l != &RootExtension->VolumeList; l = l->Flink) {

            e = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
            if (e == extension) {
                continue;
            }
            r = RtlCompareUnicodeString(&e->DeviceNodeName,
                                        &extension->DeviceNodeName, TRUE);
            if (!r) {
                break;
            }
        }

        if (!r) {
            RemoveEntryList(&extension->ListEntry);
            ExFreePool(extension->DeviceNodeName.Buffer);
            delete extension->EmergencyTransferPacket;
            IoDeleteDevice(deviceObject);
            return FALSE;
        }

        RootExtension->PreExposureCount++;

    } else {
        FtpCreateOldNameLinks(extension);
    }

    if (!IsPreExposure && RootExtension->PreExposureCount) {
        r = 1;
        for (l = RootExtension->VolumeList.Flink;
             l != &RootExtension->VolumeList; l = l->Flink) {

            e = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
            if (e == extension) {
                continue;
            }
            if (!e->IsPreExposure) {
                continue;
            }

            r = RtlCompareUnicodeString(&e->DeviceNodeName,
                                        &extension->DeviceNodeName, TRUE);
            if (!r) {
                break;
            }
        }

        if (!r) {
            RootExtension->PreExposureCount--;
            RemoveEntryList(&e->ListEntry);
            InsertTailList(&RootExtension->DeadVolumeList, &e->ListEntry);
            FtpCleanupVolumeExtension(e);
        }
    }

    // Allocate WMI library context

    extension->WmilibContext = (PWMILIB_CONTEXT)
        ExAllocatePool(PagedPool, sizeof(WMILIB_CONTEXT));
    if (extension->WmilibContext != NULL) {
        RtlZeroMemory(extension->WmilibContext, sizeof(WMILIB_CONTEXT));
        extension->WmilibContext->GuidCount          = DiskperfGuidCount;
        extension->WmilibContext->GuidList           = DiskperfGuidList;
        extension->WmilibContext->QueryWmiRegInfo    = FtQueryWmiRegInfo;
        extension->WmilibContext->QueryWmiDataBlock  = FtQueryWmiDataBlock;
        extension->WmilibContext->WmiFunctionControl = FtWmiFunctionControl;
    }

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return TRUE;
}

PVOLUME_EXTENSION
FtpFindExtension(
    IN  PROOT_EXTENSION     RootExtension,
    IN  ULONG               Signature,
    IN  LONGLONG            Offset
    )

/*++

Routine Description:

    This routine finds the device extension for the given partition.

Arguments:

    RootExtension   - Supplies the root device extension.

    Signature       - Supplies the partition's disk signature.

    Offset          - Supplies the partition's offset.

Return Value:

    A volume extension or NULL.

--*/

{
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;
    ULONG               signature;
    NTSTATUS            status;
    LONGLONG            offset;

    for (l = RootExtension->VolumeList.Flink; l != &RootExtension->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        if (!extension->TargetObject) {
            continue;
        }

        signature = FtpQueryDiskSignatureCache(extension);
        if (Signature != signature) {
            continue;
        }

        status = FtpQueryPartitionInformation(RootExtension,
                                              extension->TargetObject,
                                              NULL, &offset, NULL, NULL, NULL,
                                              NULL, NULL, NULL, NULL);
        if (!NT_SUCCESS(status)) {
            continue;
        }

        if (offset != Offset) {
            continue;
        }

        return extension;
    }

    return NULL;
}

BOOLEAN
FtpQueryNtDeviceNameString(
    IN  PROOT_EXTENSION     RootExtension,
    IN  ULONG               Signature,
    IN  LONGLONG            Offset,
    OUT PUNICODE_STRING     String
    )

{
    PVOLUME_EXTENSION   extension;
    PWSTR               stringBuffer;

    extension = FtpFindExtension(RootExtension, Signature, Offset);
    if (!extension) {
        return FALSE;
    }

    stringBuffer = (PWSTR) ExAllocatePool(PagedPool, 128);
    if (!stringBuffer) {
        return FALSE;
    }

    swprintf(stringBuffer, L"\\Device\\HarddiskVolume%d", extension->VolumeNumber);
    RtlInitUnicodeString(String, stringBuffer);

    return TRUE;
}

BOOLEAN
FtpQueryNtDeviceNameString(
    IN  PROOT_EXTENSION     RootExtension,
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId,
    OUT PUNICODE_STRING     String
    )

{
    PVOLUME_EXTENSION   extension;
    PWSTR               stringBuffer;

    extension = FtpFindExtension(RootExtension, RootLogicalDiskId);
    if (!extension) {
        return FALSE;
    }

    stringBuffer = (PWSTR) ExAllocatePool(PagedPool, 128);
    if (!stringBuffer) {
        return FALSE;
    }

    swprintf(stringBuffer, L"\\Device\\HarddiskVolume%d", extension->VolumeNumber);
    RtlInitUnicodeString(String, stringBuffer);

    return TRUE;
}

BOOLEAN
FtpLockLogicalDisk(
    IN  PROOT_EXTENSION     RootExtension,
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    OUT PHANDLE             Handle
    )

/*++

Routine Description:

    This routine attempts to lock the given logical disk id by going through
    the file system.  If it is successful then it returns the handle to the
    locked volume.

Arguments:

    RootExtension   - Supplies the root extension.

    LogicalDiskId   - Supplies the logical disk id.

    Handle          - Returns a handle to the locked volume.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    UNICODE_STRING      string;
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    IO_STATUS_BLOCK     ioStatus;

    if (!FtpQueryNtDeviceNameString(RootExtension, LogicalDiskId, &string)) {
        return FALSE;
    }

    FtpRelease(RootExtension);

    InitializeObjectAttributes(&oa, &string, OBJ_CASE_INSENSITIVE |
                               OBJ_KERNEL_HANDLE, 0, 0);

    status = ZwOpenFile(Handle, SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                        &oa, &ioStatus, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    ExFreePool(string.Buffer);

    if (!NT_SUCCESS(status)) {
        FtpAcquire(RootExtension);
        return FALSE;
    }

    status = ZwFsControlFile(*Handle, 0, NULL, NULL, &ioStatus,
                             FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0);

    if (!NT_SUCCESS(status)) {
        ZwClose(*Handle);
        FtpAcquire(RootExtension);
        return FALSE;
    }

    FtpAcquire(RootExtension);

    return TRUE;
}

VOID
FtpUniqueIdNotify(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PMOUNTDEV_UNIQUE_ID NewUniqueId
    )

/*++

Routine Description:

    This routine goes through all of the mount manager clients that
    have registered to be aware of unique id changes to devices.

Arguments:

    Extension   - Supplies the volume extension.

    NewUniqueId - Supplies the new unique id.

Return Value:

    None.

--*/

{
    PMOUNTDEV_UNIQUE_ID                         oldUniqueId;
    UCHAR                                       oldUniqueIdBuffer[UNIQUE_ID_MAX_BUFFER_SIZE];
    PLIST_ENTRY                                 l;
    PIRP                                        irp;
    PIO_STACK_LOCATION                          irpSp;
    PMOUNTDEV_UNIQUE_ID                         input;
    ULONG                                       inputLength, outputLength;
    PMOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT    output;

    oldUniqueId = (PMOUNTDEV_UNIQUE_ID) oldUniqueIdBuffer;

    while (!IsListEmpty(&Extension->ChangeNotifyIrps)) {

        l = RemoveHeadList(&Extension->ChangeNotifyIrps);

        irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);

        //
        // Remove cancel routine. If cancel is active let it complete this IRP.
        //
        if (IoSetCancelRoutine (irp, NULL) == NULL) {
            InitializeListHead (&irp->Tail.Overlay.ListEntry);
            continue;
        }

        irpSp = IoGetCurrentIrpStackLocation(irp);
        input = (PMOUNTDEV_UNIQUE_ID) irp->AssociatedIrp.SystemBuffer;

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(MOUNTDEV_UNIQUE_ID)) {

            irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Information = 0;
            IoCompleteRequest(irp, IO_NO_INCREMENT);
            continue;
        }

        inputLength = FIELD_OFFSET(MOUNTDEV_UNIQUE_ID, UniqueId) +
                      input->UniqueIdLength;

        if (inputLength >
            irpSp->Parameters.DeviceIoControl.InputBufferLength) {

            irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Information = 0;
            IoCompleteRequest(irp, IO_NO_INCREMENT);
            continue;
        }

        if (inputLength > 20) {
            irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Information = 0;
            IoCompleteRequest(irp, IO_NO_INCREMENT);
            continue;
        }

        RtlCopyMemory(oldUniqueId, input, inputLength);

        outputLength = sizeof(MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT) +
                       oldUniqueId->UniqueIdLength +
                       NewUniqueId->UniqueIdLength;

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT)) {

            irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Information = 0;
            IoCompleteRequest(irp, IO_NO_INCREMENT);
            continue;
        }

        output = (PMOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT)
                 irp->AssociatedIrp.SystemBuffer;
        output->Size = outputLength;

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            outputLength) {

            irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
            irp->IoStatus.Information =
                    sizeof(MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT);
            IoCompleteRequest(irp, IO_NO_INCREMENT);
            continue;
        }

        output->OldUniqueIdOffset =
                sizeof(MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT);
        output->OldUniqueIdLength = oldUniqueId->UniqueIdLength;
        output->NewUniqueIdOffset = output->OldUniqueIdOffset +
                                    output->OldUniqueIdLength;
        output->NewUniqueIdLength = NewUniqueId->UniqueIdLength;

        RtlCopyMemory((PCHAR) output + output->OldUniqueIdOffset,
                      oldUniqueId->UniqueId, output->OldUniqueIdLength);
        RtlCopyMemory((PCHAR) output + output->NewUniqueIdOffset,
                      NewUniqueId->UniqueId, output->NewUniqueIdLength);

        irp->IoStatus.Status = STATUS_SUCCESS;
        irp->IoStatus.Information = output->Size;

        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    // Perform a pre-exposure of the new devnode to avoid the PNP reboot
    // pop-up.

    if (FtpCreateNewDevice(Extension->Root, Extension->TargetObject,
                           Extension->FtVolume, Extension->WholeDiskPdo,
                           Extension->DeviceObject->AlignmentRequirement,
                           TRUE, TRUE, FALSE, FALSE, 0)) {

        IoInvalidateDeviceRelations(Extension->Root->Pdo, BusRelations);
    }
}

NTSTATUS
FtpDeleteMountPoints(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine deletes the all of the entries in the mount table that
    are pointing to the given unique id.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING          name;
    NTSTATUS                status;
    PFILE_OBJECT            fileObject;
    PDEVICE_OBJECT          deviceObject;
    WCHAR                   deviceNameBuffer[30];
    UNICODE_STRING          deviceName;
    PMOUNTMGR_MOUNT_POINT   point;
    UCHAR                   buffer[sizeof(MOUNTMGR_MOUNT_POINT) + 60];
    PVOID                   mountPoints;
    KEVENT                  event;
    PIRP                    irp;
    IO_STATUS_BLOCK         ioStatus;

    RtlInitUnicodeString(&name, MOUNTMGR_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(&name, FILE_READ_ATTRIBUTES, &fileObject,
                                      &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    swprintf(deviceNameBuffer, L"\\Device\\HarddiskVolume%d", Extension->VolumeNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);

    point = (PMOUNTMGR_MOUNT_POINT) buffer;
    RtlZeroMemory(point, sizeof(MOUNTMGR_MOUNT_POINT));
    point->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    point->DeviceNameLength = deviceName.Length;
    RtlCopyMemory((PCHAR) point + point->DeviceNameOffset, deviceName.Buffer,
                  point->DeviceNameLength);

    mountPoints = ExAllocatePool(PagedPool, PAGE_SIZE);
    if (!mountPoints) {
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_DELETE_POINTS,
                                        deviceObject, point,
                                        sizeof(MOUNTMGR_MOUNT_POINT) +
                                        point->DeviceNameLength, mountPoints,
                                        PAGE_SIZE, FALSE, &event, &ioStatus);
    if (!irp) {
        ExFreePool(mountPoints);
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ExFreePool(mountPoints);
    ObDereferenceObject(fileObject);

    return status;
}

VOID
FtpCleanupVolumeExtension(
    IN OUT  PVOLUME_EXTENSION   Extension
    )

{
    PLIST_ENTRY              l;
    PIRP                     irp;
    PPMWMICOUNTERLIB_CONTEXT counterLib;

    if (Extension->EmergencyTransferPacket) {
        delete Extension->EmergencyTransferPacket;
        Extension->EmergencyTransferPacket = NULL;
    }

    if (Extension->OfflineOwner) {
        ExFreePool(Extension->OfflineOwner);
        Extension->OfflineOwner = NULL;
    }

    while (!IsListEmpty(&Extension->ChangeNotifyIrps)) {

        l = RemoveHeadList(&Extension->ChangeNotifyIrps);
        irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);

        //
        // Remove cancel routine. If cancel is active let it complete this IRP.
        //
        if (IoSetCancelRoutine (irp, NULL) == NULL) {
            InitializeListHead (&irp->Tail.Overlay.ListEntry);
            continue;
        }

        irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        irp->IoStatus.Information = 0;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    if (Extension->WmilibContext != NULL) {
        IoWMIRegistrationControl(Extension->DeviceObject,
                                 WMIREG_ACTION_DEREGISTER);
        ExFreePool(Extension->WmilibContext);
        Extension->WmilibContext = NULL;

        counterLib = &Extension->Root->PmWmiCounterLibContext;
        counterLib->PmWmiCounterDisable(&Extension->PmWmiCounterContext,
                                        TRUE, TRUE);
        Extension->CountersEnabled = FALSE;
    }
}


NTSTATUS
FtpStartSystemThread(
    IN  PROOT_EXTENSION RootExtension
    )

{
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    HANDLE              handle;

    if (!RootExtension->TerminateThread) {
        return STATUS_SUCCESS;
    }

    InterlockedExchange(&RootExtension->TerminateThread, FALSE);

    InitializeObjectAttributes(&oa, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

    status = PsCreateSystemThread(&handle, 0, &oa, 0, NULL, FtpWorkerThread,
                                  RootExtension);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = ObReferenceObjectByHandle(handle, THREAD_ALL_ACCESS, NULL,
                                       KernelMode,
                                       &RootExtension->WorkerThread, NULL);
    ZwClose(handle);

    if (!NT_SUCCESS(status)) {
        InterlockedExchange(&RootExtension->TerminateThread, TRUE);
    }

    return status;
}

NTSTATUS
FtpCreateLogicalDisk(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine creates the given logical disk.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_CREATE_LOGICAL_DISK_INPUT       createDisk;
    ULONG                               inputSize;
    PVOID                               configInfo;
    NTSTATUS                            status;
    FT_LOGICAL_DISK_ID                  newLogicalDiskId;
    PFT_CREATE_LOGICAL_DISK_OUTPUT      createDiskOutput;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_CREATE_LOGICAL_DISK_INPUT) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_CREATE_LOGICAL_DISK_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    createDisk = (PFT_CREATE_LOGICAL_DISK_INPUT)
                 Irp->AssociatedIrp.SystemBuffer;

    inputSize = FIELD_OFFSET(FT_CREATE_LOGICAL_DISK_INPUT, MemberArray) +
                createDisk->NumberOfMembers*sizeof(FT_LOGICAL_DISK_ID) +
                createDisk->ConfigurationInformationSize;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < inputSize) {
        return STATUS_INVALID_PARAMETER;
    }

    configInfo = &createDisk->MemberArray[createDisk->NumberOfMembers];

    if (!RootExtension->FtCodeLocked) {
        MmLockPagableCodeSection(FtpComputeParity);
        status = FtpStartSystemThread(RootExtension);
        if (!NT_SUCCESS(status)) {
            return status;
        }
        RootExtension->FtCodeLocked = TRUE;
    }

    status = FtpCreateLogicalDiskHelper(RootExtension,
                                        createDisk->LogicalDiskType,
                                        createDisk->NumberOfMembers,
                                        createDisk->MemberArray,
                                        createDisk->ConfigurationInformationSize,
                                        configInfo, 0, NULL, &newLogicalDiskId);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    createDiskOutput = (PFT_CREATE_LOGICAL_DISK_OUTPUT)
                       Irp->AssociatedIrp.SystemBuffer;

    createDiskOutput->NewLogicalDiskId = newLogicalDiskId;
    Irp->IoStatus.Information = sizeof(FT_CREATE_LOGICAL_DISK_OUTPUT);

    return status;
}

VOID
FtpResetPartitionType(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine resets the FT bit in the partition type.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT              targetObject;
    KEVENT                      event;
    PIRP                        irp;
    PARTITION_INFORMATION       partInfo;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;
    SET_PARTITION_INFORMATION   setPartInfo;

    targetObject = Extension->TargetObject;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO,
                                        targetObject, NULL, 0, &partInfo,
                                        sizeof(partInfo), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return;
    }

    status = IoCallDriver(targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return;
    }

    setPartInfo.PartitionType = (partInfo.PartitionType & ~(0x80));

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_SET_PARTITION_INFO,
                                        targetObject, &setPartInfo,
                                        sizeof(setPartInfo), NULL, 0, FALSE,
                                        &event, &ioStatus);
    if (!irp) {
        return;
    }

    status = IoCallDriver(targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }
}

NTSTATUS
FtpBreakLogicalDisk(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine breaks a given logical disk.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_BREAK_LOGICAL_DISK_INPUT            input;
    FT_LOGICAL_DISK_ID                      diskId;
    NTSTATUS                                status;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_BREAK_LOGICAL_DISK_INPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_BREAK_LOGICAL_DISK_INPUT) Irp->AssociatedIrp.SystemBuffer;
    diskId = input->RootLogicalDiskId;

    status = FtpBreakLogicalDiskHelper(RootExtension, diskId);

    return status;
}

NTSTATUS
FtpEnumerateLogicalDisks(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine enumerates all of the logical disks in the system.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_LOGICAL_DISK_INFORMATION_SET    diskInfoSet;
    PFT_ENUMERATE_LOGICAL_DISKS_OUTPUT  output;
    ULONG                               i;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_ENUMERATE_LOGICAL_DISKS_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    diskInfoSet = RootExtension->DiskInfoSet;
    output = (PFT_ENUMERATE_LOGICAL_DISKS_OUTPUT)
             Irp->AssociatedIrp.SystemBuffer;

    output->NumberOfRootLogicalDisks =
            diskInfoSet->QueryNumberOfRootLogicalDiskIds();
    Irp->IoStatus.Information = FIELD_OFFSET(FT_ENUMERATE_LOGICAL_DISKS_OUTPUT,
                                             RootLogicalDiskIds) +
                                output->NumberOfRootLogicalDisks*
                                sizeof(FT_LOGICAL_DISK_ID);
    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        Irp->IoStatus.Information =
                FIELD_OFFSET(FT_ENUMERATE_LOGICAL_DISKS_OUTPUT,
                             RootLogicalDiskIds);
        return STATUS_BUFFER_OVERFLOW;
    }

    for (i = 0; i < output->NumberOfRootLogicalDisks; i++) {
        output->RootLogicalDiskIds[i] = diskInfoSet->QueryRootLogicalDiskId(i);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryLogicalDiskInformation(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine returns the logical disk information.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_QUERY_LOGICAL_DISK_INFORMATION_INPUT    input;
    PFT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT   output;
    FT_LOGICAL_DISK_ID                          diskId;
    PFT_LOGICAL_DISK_INFORMATION_SET            diskInfoSet;
    PVOLUME_EXTENSION                           extension;
    PFT_VOLUME                                  topVol, vol;
    PFT_LOGICAL_DISK_DESCRIPTION                diskDescription;
    PFT_PARTITION_CONFIGURATION_INFORMATION     partInfo;
    LONGLONG                                    offset;
    PDEVICE_OBJECT                              wholeDisk;
    ULONG                                       diskNumber, sectorSize;
    PDRIVE_LAYOUT_INFORMATION_EX                layout;
    NTSTATUS                                    status;
    USHORT                                      i;
    PCHAR                                       p, q;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_QUERY_LOGICAL_DISK_INFORMATION_INPUT) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_QUERY_LOGICAL_DISK_INFORMATION_INPUT)
            Irp->AssociatedIrp.SystemBuffer;
    output = (PFT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT)
             Irp->AssociatedIrp.SystemBuffer;
    diskId = input->LogicalDiskId;

    diskInfoSet = RootExtension->DiskInfoSet;
    diskDescription = diskInfoSet->GetLogicalDiskDescription(diskId, 0);
    if (!diskDescription) {
        return STATUS_INVALID_PARAMETER;
    }

    output->LogicalDiskType = diskDescription->LogicalDiskType;
    output->VolumeSize = 0;

    extension = FtpFindExtensionCoveringDiskId(RootExtension, diskId);
    if (extension) {
        topVol = extension->FtVolume;
        vol = topVol->GetContainedLogicalDisk(diskId);
        output->VolumeSize = vol->QueryVolumeSize();
    }

    if (output->LogicalDiskType == FtPartition) {

        if (!diskInfoSet->QueryFtPartitionInformation(diskId, &offset,
                                                      &wholeDisk, &diskNumber,
                                                      &sectorSize, NULL)) {

            Irp->IoStatus.Information = 0;
            return STATUS_INVALID_PARAMETER;
        }

        status = FtpReadPartitionTableEx(wholeDisk, &layout);
        if (!NT_SUCCESS(status)) {
            Irp->IoStatus.Information = 0;
            return status;
        }

        output->NumberOfMembers = 0;
        output->ConfigurationInformationSize =
                sizeof(FT_PARTITION_CONFIGURATION_INFORMATION);
        output->StateInformationSize = 0;
        output->Reserved = 0;

        Irp->IoStatus.Information =
                FIELD_OFFSET(FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT,
                             MemberArray) +
                output->ConfigurationInformationSize;

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            Irp->IoStatus.Information) {

            Irp->IoStatus.Information =
                    FIELD_OFFSET(FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT,
                                 MemberArray);
            ExFreePool(layout);
            return STATUS_BUFFER_OVERFLOW;
        }

        partInfo = (PFT_PARTITION_CONFIGURATION_INFORMATION)
                   ((PCHAR) output +
                    FIELD_OFFSET(FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT,
                                 MemberArray));

        partInfo->Signature = layout->Mbr.Signature;
        partInfo->DiskNumber = diskNumber;
        partInfo->ByteOffset = offset;

        ExFreePool(layout);

    } else {

        output->NumberOfMembers = diskDescription->u.Other.NumberOfMembers;
        if (diskDescription->u.Other.ByteOffsetToConfigurationInformation) {
            if (diskDescription->u.Other.ByteOffsetToStateInformation) {
                output->ConfigurationInformationSize =
                        diskDescription->u.Other.ByteOffsetToStateInformation -
                        diskDescription->u.Other.ByteOffsetToConfigurationInformation;
            } else {
                output->ConfigurationInformationSize =
                        diskDescription->DiskDescriptionSize -
                        diskDescription->u.Other.ByteOffsetToConfigurationInformation;
            }
        } else {
            output->ConfigurationInformationSize = 0;
        }
        if (diskDescription->u.Other.ByteOffsetToStateInformation) {
            output->StateInformationSize =
                    diskDescription->DiskDescriptionSize -
                    diskDescription->u.Other.ByteOffsetToStateInformation;
        } else {
            output->StateInformationSize = 0;
        }
        diskDescription->Reserved = 0;

        Irp->IoStatus.Information =
                FIELD_OFFSET(FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT,
                             MemberArray) +
                output->NumberOfMembers*sizeof(FT_LOGICAL_DISK_ID) +
                output->ConfigurationInformationSize +
                output->StateInformationSize;

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            Irp->IoStatus.Information) {

            Irp->IoStatus.Information =
                    FIELD_OFFSET(FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT,
                                 MemberArray);
            return STATUS_BUFFER_OVERFLOW;
        }

        for (i = 0; i < output->NumberOfMembers; i++) {
            output->MemberArray[i] =
                    diskInfoSet->QueryMemberLogicalDiskId(diskId, i);
        }

        if (output->ConfigurationInformationSize) {
            p = (PCHAR) &output->MemberArray[output->NumberOfMembers];
            q = (PCHAR) diskDescription +
                diskDescription->u.Other.ByteOffsetToConfigurationInformation;
            RtlCopyMemory(p, q, output->ConfigurationInformationSize);
        }

        if (output->StateInformationSize) {
            p = (PCHAR) &output->MemberArray[output->NumberOfMembers] +
                output->ConfigurationInformationSize;
            q = (PCHAR) diskDescription +
                diskDescription->u.Other.ByteOffsetToStateInformation;
            RtlCopyMemory(p, q, output->StateInformationSize);
            vol->ModifyStateForUser(p);
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpOrphanLogicalDiskMember(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine orphans the given logical disk member.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_ORPHAN_LOGICAL_DISK_MEMBER_INPUT    input;
    FT_LOGICAL_DISK_ID                      diskId;
    USHORT                                  member;
    PVOLUME_EXTENSION                       extension;
    PFT_VOLUME                              vol;
    NTSTATUS                                status;
    KEVENT                                  event;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_ORPHAN_LOGICAL_DISK_MEMBER_INPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_ORPHAN_LOGICAL_DISK_MEMBER_INPUT)
            Irp->AssociatedIrp.SystemBuffer;
    diskId = input->LogicalDiskId;
    member = input->MemberNumberToOrphan;

    extension = FtpFindExtensionCoveringDiskId(RootExtension, diskId);
    if (!extension || !extension->FtVolume) {
        return STATUS_INVALID_PARAMETER;
    }

    vol = extension->FtVolume->GetContainedLogicalDisk(diskId);
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    status = vol->OrphanMember(member, FtpEventSignalCompletion, &event);
    if (NT_SUCCESS(status)) {
        FtpRelease(RootExtension);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        FtpAcquire(RootExtension);
    }

    return status;
}

NTSTATUS
FtpQueryNtDeviceNameForLogicalDisk(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine returns the nt device name for the given logical partition.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                                  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_INPUT     input;
    PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT    output;
    FT_LOGICAL_DISK_ID                                  diskId;
    UNICODE_STRING                                      targetName;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_INPUT) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_INPUT)
            Irp->AssociatedIrp.SystemBuffer;
    output = (PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT)
             Irp->AssociatedIrp.SystemBuffer;

    diskId = input->RootLogicalDiskId;
    if (!FtpQueryNtDeviceNameString(RootExtension, diskId, &targetName)) {
        return STATUS_INVALID_PARAMETER;
    }

    output->NumberOfCharactersInNtDeviceName = targetName.Length/sizeof(WCHAR);

    Irp->IoStatus.Information =
            FIELD_OFFSET(FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT,
                         NtDeviceName) +
            output->NumberOfCharactersInNtDeviceName*sizeof(WCHAR);

    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        Irp->IoStatus.Information =
            FIELD_OFFSET(FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT,
                         NtDeviceName);

        ExFreePool(targetName.Buffer);
        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(output->NtDeviceName, targetName.Buffer,
                  targetName.Length);

    ExFreePool(targetName.Buffer);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryDriveLetterForLogicalDisk(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine queries the drive letter for the given root logical disk.

Arguments:

    Extension   - Supplies the root extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT   input;
    PFT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_OUTPUT  output;
    PFT_LOGICAL_DISK_INFORMATION_SET                diskInfoSet;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT)
            Irp->AssociatedIrp.SystemBuffer;
    output = (PFT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_OUTPUT)
             Irp->AssociatedIrp.SystemBuffer;

    diskInfoSet = RootExtension->DiskInfoSet;

    output->DriveLetter = diskInfoSet->QueryDriveLetter(
                          input->RootLogicalDiskId);
    if (output->DriveLetter == 0xFF) {
        output->DriveLetter = 0;
    }

    Irp->IoStatus.Information =
            sizeof(FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_OUTPUT);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpDeleteMountLetter(
    IN  UCHAR   DriveLetter
    )

/*++

Routine Description:

    This routine deletes the given drive letter from the mount point
    manager.

Arguments:

    DriveLetter - Supplies the drive letter.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING          name;
    NTSTATUS                status;
    PFILE_OBJECT            fileObject;
    PDEVICE_OBJECT          deviceObject;
    PMOUNTMGR_MOUNT_POINT   point;
    UCHAR                   buffer[sizeof(MOUNTMGR_MOUNT_POINT) + 50];
    PWSTR                   s;
    UNICODE_STRING          symName;
    PVOID                   mountPoints;
    KEVENT                  event;
    PIRP                    irp;
    IO_STATUS_BLOCK         ioStatus;

    RtlInitUnicodeString(&name, MOUNTMGR_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(&name, FILE_READ_ATTRIBUTES, &fileObject,
                                      &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    point = (PMOUNTMGR_MOUNT_POINT) buffer;
    RtlZeroMemory(point, sizeof(MOUNTMGR_MOUNT_POINT));
    s = (PWSTR) ((PCHAR) point + sizeof(MOUNTMGR_MOUNT_POINT));
    swprintf(s, L"\\DosDevices\\%c:", DriveLetter);
    RtlInitUnicodeString(&symName, s);
    point->SymbolicLinkNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    point->SymbolicLinkNameLength = symName.Length;

    mountPoints = ExAllocatePool(PagedPool, PAGE_SIZE);
    if (!mountPoints) {
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_DELETE_POINTS,
                                        deviceObject, point,
                                        sizeof(MOUNTMGR_MOUNT_POINT) +
                                        symName.Length, mountPoints, PAGE_SIZE,
                                        FALSE, &event, &ioStatus);
    if (!irp) {
        ExFreePool(mountPoints);
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ExFreePool(mountPoints);
    ObDereferenceObject(fileObject);

    return status;
}

NTSTATUS
FtpSetDriveLetterForLogicalDisk(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine sets the drive letter for the given root logical disk.

Arguments:

    Extension   - Supplies the root extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT input;
    FT_LOGICAL_DISK_ID                          diskId;
    UCHAR                                       driveLetter, currentLetter;
    PVOLUME_EXTENSION                           extension;
    PFT_LOGICAL_DISK_INFORMATION_SET            diskInfoSet;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT)
            Irp->AssociatedIrp.SystemBuffer;

    diskId = input->RootLogicalDiskId;
    driveLetter = input->DriveLetter;
    if (driveLetter < FirstDriveLetter || driveLetter > LastDriveLetter) {
        if (driveLetter) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    extension = FtpFindExtension(RootExtension, diskId);
    if (!extension) {
        return STATUS_INVALID_PARAMETER;
    }

    currentLetter = FtpQueryMountLetter(extension);
    if (currentLetter) {
        FtpDeleteMountLetter(currentLetter);
    }

    if (driveLetter && !FtpSetMountLetter(extension, driveLetter)) {
        return STATUS_INVALID_PARAMETER;
    }

    diskInfoSet = RootExtension->DiskInfoSet;
    diskInfoSet->SetDriveLetter(diskId, driveLetter);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryNtDeviceNameForPartition(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine returns the nt device name for the given partition.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_INPUT    input;
    PFT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT   output;
    UNICODE_STRING                                  targetName;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_INPUT) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_INPUT)
            Irp->AssociatedIrp.SystemBuffer;
    output = (PFT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT)
             Irp->AssociatedIrp.SystemBuffer;

    if (!FtpQueryNtDeviceNameString(RootExtension, input->Signature,
                                    input->Offset, &targetName)) {
        return STATUS_INVALID_PARAMETER;
    }

    output->NumberOfCharactersInNtDeviceName = targetName.Length/sizeof(WCHAR);

    Irp->IoStatus.Information =
            FIELD_OFFSET(FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT,
                         NtDeviceName) +
            output->NumberOfCharactersInNtDeviceName*sizeof(WCHAR);

    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        Irp->IoStatus.Information =
            FIELD_OFFSET(FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT,
                         NtDeviceName);

        ExFreePool(targetName.Buffer);
        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(output->NtDeviceName, targetName.Buffer,
                  targetName.Length);

    ExFreePool(targetName.Buffer);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpStopSyncOperations(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine stops all sync operations on the given root logical disk.

Arguments:

    Extension   - Supplies the root extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_STOP_SYNC_OPERATIONS_INPUT  input;
    FT_LOGICAL_DISK_ID              diskId;
    PVOLUME_EXTENSION               extension;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_STOP_SYNC_OPERATIONS_INPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_STOP_SYNC_OPERATIONS_INPUT) Irp->AssociatedIrp.SystemBuffer;
    diskId = input->RootLogicalDiskId;

    extension = FtpFindExtension(RootExtension, diskId);
    if (!extension || !extension->FtVolume) {
        return STATUS_INVALID_PARAMETER;
    }

    extension->FtVolume->StopSyncOperations();

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryStableGuid(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine is called to query the stable guid for this volume.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTDEV_STABLE_GUID   output;

    if (!Extension->IsGpt) {
        return STATUS_UNSUCCESSFUL;
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTDEV_STABLE_GUID)) {

        return STATUS_INVALID_PARAMETER;
    }

    output = (PMOUNTDEV_STABLE_GUID) Irp->AssociatedIrp.SystemBuffer;
    output->StableGuid = Extension->UniqueIdGuid;
    Irp->IoStatus.Information = sizeof(MOUNTDEV_STABLE_GUID);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryUniqueId(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine is called to query the unique id for this volume.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTDEV_UNIQUE_ID output;
    NTSTATUS            status;
    ULONG               diskNumber;
    LONGLONG            offset;
    FT_LOGICAL_DISK_ID  diskId;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTDEV_UNIQUE_ID)) {

        return STATUS_INVALID_PARAMETER;
    }

    output = (PMOUNTDEV_UNIQUE_ID) Irp->AssociatedIrp.SystemBuffer;

    if (Extension->IsSuperFloppy) {

        output->UniqueIdLength = Extension->DeviceNodeName.Length;

    } else {
        if (!FtpQueryUniqueIdBuffer(Extension, NULL,
                                    &output->UniqueIdLength)) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    Irp->IoStatus.Information = sizeof(USHORT) + output->UniqueIdLength;

    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        Irp->IoStatus.Information = sizeof(MOUNTDEV_UNIQUE_ID);
        return STATUS_BUFFER_OVERFLOW;
    }

    if (Extension->IsSuperFloppy) {

        RtlCopyMemory(output->UniqueId, Extension->DeviceNodeName.Buffer,
                      output->UniqueIdLength);

    } else {
        if (!FtpQueryUniqueIdBuffer(Extension, output->UniqueId,
                                    &output->UniqueIdLength)) {

            Irp->IoStatus.Information = 0;
            return STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpUniqueIdChangeNotify(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine is to give a notify callback routine.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTDEV_UNIQUE_ID input;
    ULONG               len;
    PMOUNTDEV_UNIQUE_ID currentId;
    UCHAR               idBuffer[UNIQUE_ID_MAX_BUFFER_SIZE];

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTDEV_UNIQUE_ID)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (!Extension->TargetObject && !Extension->FtVolume) {
        return STATUS_INVALID_PARAMETER;
    }

    if (Extension->IsSuperFloppy) {
        return STATUS_INVALID_PARAMETER;
    }

    input = (PMOUNTDEV_UNIQUE_ID) Irp->AssociatedIrp.SystemBuffer;
    len = FIELD_OFFSET(MOUNTDEV_UNIQUE_ID, UniqueId) +
          input->UniqueIdLength;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < len) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!IsListEmpty(&Extension->ChangeNotifyIrps)) {
        return STATUS_INVALID_PARAMETER;
    }

    currentId = (PMOUNTDEV_UNIQUE_ID) idBuffer;
    if (!FtpQueryUniqueIdBuffer(Extension, currentId->UniqueId,
                                &currentId->UniqueIdLength)) {

        return STATUS_INVALID_PARAMETER;
    }

    Irp->Tail.Overlay.DriverContext[0] = Extension;

    IoSetCancelRoutine (Irp, FtpCancelChangeNotify);

    if (Irp->Cancel && IoSetCancelRoutine (Irp, NULL) == NULL) {
        return STATUS_CANCELLED;
    }

    IoMarkIrpPending(Irp);

    InsertTailList(&Extension->ChangeNotifyIrps, &Irp->Tail.Overlay.ListEntry);

    if (input->UniqueIdLength != currentId->UniqueIdLength ||
        RtlCompareMemory(input->UniqueId, currentId->UniqueId,
                         input->UniqueIdLength) != input->UniqueIdLength) {

        FtpUniqueIdNotify(Extension, currentId);
    }

    return STATUS_PENDING;
}

NTSTATUS
FtpCreatePartitionLogicalDisk(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine creates assigns a logical disk id to a partition.

Arguments:

    Extension   - Supplies the partition extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                          irpSp = IoGetCurrentIrpStackLocation(Irp);
    LONGLONG                                    partitionSize;
    NTSTATUS                                    status;
    FT_LOGICAL_DISK_ID                          diskId;
    PFT_CREATE_PARTITION_LOGICAL_DISK_OUTPUT    output;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_CREATE_PARTITION_LOGICAL_DISK_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength >=
        sizeof(LONGLONG)) {

        partitionSize = *((PLONGLONG) Irp->AssociatedIrp.SystemBuffer);
    } else {
        partitionSize = 0;
    }

    status = FtpCreatePartitionLogicalDiskHelper(Extension, partitionSize,
                                                 &diskId);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    Irp->IoStatus.Information =
            sizeof(FT_CREATE_PARTITION_LOGICAL_DISK_OUTPUT);

    output = (PFT_CREATE_PARTITION_LOGICAL_DISK_OUTPUT)
             Irp->AssociatedIrp.SystemBuffer;

    output->NewLogicalDiskId = diskId;

    return status;
}

NTSTATUS
FtpQueryDeviceName(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the device name for the given device.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    WCHAR               nameBuffer[100];
    UNICODE_STRING      nameString;
    PMOUNTDEV_NAME      name;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTDEV_NAME)) {

        return STATUS_INVALID_PARAMETER;
    }

    swprintf(nameBuffer, L"\\Device\\HarddiskVolume%d", Extension->VolumeNumber);
    RtlInitUnicodeString(&nameString, nameBuffer);

    name = (PMOUNTDEV_NAME) Irp->AssociatedIrp.SystemBuffer;
    name->NameLength = nameString.Length;
    Irp->IoStatus.Information = name->NameLength + sizeof(USHORT);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = sizeof(MOUNTDEV_NAME);
        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(name->Name, nameString.Buffer, name->NameLength);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQuerySuggestedLinkName(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the suggested link name for the given device.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    BOOLEAN                         deleteLetter;
    UCHAR                           driveLetter;
    PFT_VOLUME                      vol;
    FT_LOGICAL_DISK_ID              diskId;
    WCHAR                           nameBuffer[30];
    UNICODE_STRING                  nameString;
    PMOUNTDEV_SUGGESTED_LINK_NAME   name;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTDEV_SUGGESTED_LINK_NAME)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength >=
        FIELD_OFFSET(MOUNTDEV_SUGGESTED_LINK_NAME, Name) + 28) {

        deleteLetter = TRUE;
    } else {
        deleteLetter = FALSE;
    }

    driveLetter = FtpQueryDriveLetterFromRegistry(Extension, deleteLetter);
    vol = Extension->FtVolume;
    if (vol) {
        diskId = vol->QueryLogicalDiskId();
        driveLetter = Extension->Root->DiskInfoSet->QueryDriveLetter(diskId);
    }

    if (!driveLetter) {
        return STATUS_NOT_FOUND;
    }

    swprintf(nameBuffer, L"\\DosDevices\\%c:", driveLetter);
    RtlInitUnicodeString(&nameString, nameBuffer);

    name = (PMOUNTDEV_SUGGESTED_LINK_NAME) Irp->AssociatedIrp.SystemBuffer;
    name->UseOnlyIfThereAreNoOtherLinks = TRUE;
    name->NameLength = nameString.Length;
    Irp->IoStatus.Information =
            name->NameLength + FIELD_OFFSET(MOUNTDEV_SUGGESTED_LINK_NAME, Name);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = sizeof(MOUNTDEV_SUGGESTED_LINK_NAME);
        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(name->Name, nameString.Buffer, name->NameLength);

    return STATUS_SUCCESS;
}

class CHANGE_DRIVE_LETTER_WORK_ITEM : public WORK_QUEUE_ITEM {

    public:

        PROOT_EXTENSION     RootExtension;
        FT_LOGICAL_DISK_ID  LogicalDiskId;
        UCHAR               OldDriveLetter;
        UCHAR               NewDriveLetter;

};

typedef CHANGE_DRIVE_LETTER_WORK_ITEM *PCHANGE_DRIVE_LETTER_WORK_ITEM;

VOID
FtpChangeDriveLetterWorkerRoutine(
    IN  PVOID   WorkItem
    )

/*++

Routine Description:

    This routine changes the drive letter.

Arguments:

    WorkItem    - Supplies the work item.

Return Value:

    None.

--*/

{
    PCHANGE_DRIVE_LETTER_WORK_ITEM      workItem = (PCHANGE_DRIVE_LETTER_WORK_ITEM) WorkItem;
    PROOT_EXTENSION                     rootExtension = workItem->RootExtension;
    PFT_LOGICAL_DISK_INFORMATION_SET    diskInfoSet = rootExtension->DiskInfoSet;

    FtpAcquire(rootExtension);
    if (workItem->OldDriveLetter &&
        diskInfoSet->QueryDriveLetter(workItem->LogicalDiskId) !=
        workItem->OldDriveLetter) {

        FtpRelease(rootExtension);
        ExFreePool(WorkItem);
        return;
    }
    diskInfoSet->SetDriveLetter(workItem->LogicalDiskId,
                                workItem->NewDriveLetter);
    FtpRelease(rootExtension);

    ExFreePool(WorkItem);
}

NTSTATUS
FtpLinkCreated(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine is called when the mount manager changes the link.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_VOLUME                      vol;
    PMOUNTDEV_NAME                  name;
    ULONG                           nameLen;
    UNICODE_STRING                  nameString;
    UNICODE_STRING                  dosDevices;
    UCHAR                           driveLetter;
    PCHANGE_DRIVE_LETTER_WORK_ITEM  workItem;

    vol = Extension->FtVolume;
    if (!vol) {
        return STATUS_SUCCESS;
    }

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTDEV_NAME)) {

        return STATUS_INVALID_PARAMETER;
    }

    name = (PMOUNTDEV_NAME) Irp->AssociatedIrp.SystemBuffer;
    nameLen = name->NameLength + sizeof(USHORT);

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < nameLen) {
        return STATUS_INVALID_PARAMETER;
    }

    nameString.Buffer = name->Name;
    nameString.Length = nameString.MaximumLength = name->NameLength;

    if (nameString.Length != 28 || nameString.Buffer[13] != ':' ||
        nameString.Buffer[12] < FirstDriveLetter || nameString.Buffer[12] > LastDriveLetter) {
        return STATUS_SUCCESS;
    }

    nameString.Length -= 2*sizeof(WCHAR);

    RtlInitUnicodeString(&dosDevices, L"\\DosDevices\\");

    if (!RtlEqualUnicodeString(&dosDevices, &nameString, TRUE)) {
        return STATUS_SUCCESS;
    }

    driveLetter = (UCHAR) nameString.Buffer[12];

    workItem = (PCHANGE_DRIVE_LETTER_WORK_ITEM)
               ExAllocatePool(NonPagedPool, sizeof(CHANGE_DRIVE_LETTER_WORK_ITEM));
    if (!workItem) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ExInitializeWorkItem(workItem, FtpChangeDriveLetterWorkerRoutine, workItem);
    workItem->RootExtension = Extension->Root;
    workItem->LogicalDiskId = vol->QueryLogicalDiskId();
    workItem->OldDriveLetter = 0;
    workItem->NewDriveLetter = driveLetter;

    ExQueueWorkItem(workItem, DelayedWorkQueue);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpLinkDeleted(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine is called when the mount manager deletes a link.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_VOLUME                      vol;
    PMOUNTDEV_NAME                  name;
    ULONG                           nameLen;
    UNICODE_STRING                  nameString;
    UNICODE_STRING                  dosDevices;
    UCHAR                           driveLetter;
    PCHANGE_DRIVE_LETTER_WORK_ITEM  workItem;

    vol = Extension->FtVolume;
    if (!vol) {
        return STATUS_SUCCESS;
    }

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTDEV_NAME)) {

        return STATUS_INVALID_PARAMETER;
    }

    name = (PMOUNTDEV_NAME) Irp->AssociatedIrp.SystemBuffer;
    nameLen = name->NameLength + sizeof(USHORT);

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < nameLen) {
        return STATUS_INVALID_PARAMETER;
    }

    nameString.Buffer = name->Name;
    nameString.Length = nameString.MaximumLength = name->NameLength;

    if (nameString.Length != 28 || nameString.Buffer[13] != ':' ||
        nameString.Buffer[12] < FirstDriveLetter || nameString.Buffer[12] > LastDriveLetter) {
        return STATUS_SUCCESS;
    }

    nameString.Length -= 2*sizeof(WCHAR);

    RtlInitUnicodeString(&dosDevices, L"\\DosDevices\\");

    if (!RtlEqualUnicodeString(&dosDevices, &nameString, TRUE)) {
        return STATUS_SUCCESS;
    }

    driveLetter = (UCHAR) nameString.Buffer[12];

    workItem = (PCHANGE_DRIVE_LETTER_WORK_ITEM)
               ExAllocatePool(NonPagedPool, sizeof(CHANGE_DRIVE_LETTER_WORK_ITEM));
    if (!workItem) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ExInitializeWorkItem(workItem, FtpChangeDriveLetterWorkerRoutine, workItem);
    workItem->RootExtension = Extension->Root;
    workItem->LogicalDiskId = vol->QueryLogicalDiskId();
    workItem->OldDriveLetter = driveLetter;
    workItem->NewDriveLetter = 0;

    ExQueueWorkItem(workItem, DelayedWorkQueue);

    return STATUS_SUCCESS;
}

VOID
FtpSyncLogicalDiskIds(
    IN      PFT_LOGICAL_DISK_INFORMATION_SET    DiskInfoSet,
    IN OUT  PFT_VOLUME                          RootVolume,
    IN OUT  PFT_VOLUME                          Volume
    )

/*++

Routine Description:

    This routine syncs up the logical disk ids in the given FT_VOLUME object
    with the on disk logical disk ids.

Arguments:

    DiskInfoSet - Supplies the disk info set.

    RootVolume  - Supplies the root volume.

    Volume      - Supplies the volume.

Return Value:

    None.

--*/

{
    FT_LOGICAL_DISK_ID              diskId;
    PFT_LOGICAL_DISK_DESCRIPTION    p;
    USHORT                          n, i;
    PFT_VOLUME                      vol;

    if (Volume->QueryLogicalDiskType() == FtPartition) {

        for (;;) {

            diskId = Volume->QueryLogicalDiskId();
            p = DiskInfoSet->GetParentLogicalDiskDescription(diskId);
            if (!p) {
                break;
            }

            Volume = RootVolume->GetParentLogicalDisk(Volume);
            if (!Volume) {
                break;
            }

            Volume->SetLogicalDiskId(p->LogicalDiskId);
        }
        return;
    }

    n = Volume->QueryNumberOfMembers();
    for (i = 0; i < n; i++) {
        vol = Volume->GetMember(i);
        if (vol) {
            FtpSyncLogicalDiskIds(DiskInfoSet, RootVolume, vol);
        }
    }
}

VOID
FtpSyncLogicalDiskIds(
    IN  PROOT_EXTENSION RootExtension
    )

/*++

Routine Description:

    This routine syncs up the logical disk ids in the FT_VOLUME objects
    with the on disk logical disk ids.

Arguments:

    RootExtension   - Supplies the root extension.

Return Value:

    None.

--*/

{
    PLIST_ENTRY                         l;
    PVOLUME_EXTENSION                   extension;
    PFT_VOLUME                          vol;

    for (l = RootExtension->VolumeList.Flink;
         l != &RootExtension->VolumeList; l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        vol = extension->FtVolume;
        if (!vol) {
            continue;
        }

        FtpSyncLogicalDiskIds(RootExtension->DiskInfoSet, vol, vol);
    }
}

NTSTATUS
FtpPartitionArrivedHelper(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      PDEVICE_OBJECT      Partition,
    IN      PDEVICE_OBJECT      WholeDiskPdo
    )

{
    ULONG                               diskNumber;
    LONGLONG                            offset;
    UCHAR                               partitionType;
    PFT_LOGICAL_DISK_INFORMATION_SET    diskInfoSet;
    PFT_LOGICAL_DISK_INFORMATION        diskInfo;
    NTSTATUS                            status;
    BOOLEAN                             changedLogicalDiskIds;
    FT_LOGICAL_DISK_ID                  diskId, partitionDiskId;
    PVOLUME_EXTENSION                   extension;
    PFT_VOLUME                          vol, c;
    PFT_LOGICAL_DISK_DESCRIPTION        parentDesc;
    ULONG                               n;
    UCHAR                               registryState[100];
    USHORT                              registryStateSize;
    BOOLEAN                             IsGpt, isHidden, isReadOnly, isEspType;
    GUID                                partitionTypeGuid, partitionUniqueId;
    ULONGLONG                           gptAttributes;
    ULONG                               signature;

    status = FtpQueryPartitionInformation(RootExtension, Partition,
                                          &diskNumber, &offset, NULL,
                                          &partitionType, NULL,
                                          &partitionTypeGuid,
                                          &partitionUniqueId, &IsGpt,
                                          &gptAttributes);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    isHidden = FALSE;
    isReadOnly = FALSE;
    isEspType = FALSE;

    if (IsGpt) {
        if (IsEqualGUID(partitionTypeGuid, PARTITION_LDM_DATA_GUID)) {
            return STATUS_INVALID_PARAMETER;
        }

        if (RootExtension->GptAttributeRevertEntries) {
            FtpCheckForRevertGptAttributes(RootExtension, Partition, 0,
                                           &partitionUniqueId, NULL);
            status = FtpQueryPartitionInformation(
                     RootExtension, Partition, NULL, NULL, NULL, NULL, NULL,
                     NULL, NULL, NULL, &gptAttributes);
            if (!NT_SUCCESS(status)) {
                return status;
            }
        }

        if (IsEqualGUID(partitionTypeGuid, PARTITION_BASIC_DATA_GUID)) {
            if (gptAttributes&GPT_BASIC_DATA_ATTRIBUTE_HIDDEN) {
                isHidden = TRUE;
            }
            if (gptAttributes&GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY) {
                isReadOnly = TRUE;
            }
        } else {
            if (IsEqualGUID(partitionTypeGuid, PARTITION_SYSTEM_GUID)) {
                isEspType = TRUE;
            }
            isHidden = TRUE;
        }

        if (!FtpCreateNewDevice(RootExtension, Partition, NULL, WholeDiskPdo,
                                Partition->AlignmentRequirement, FALSE,
                                isHidden, isReadOnly, isEspType, 0)) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);

        return STATUS_SUCCESS;
    }

    if (partitionType == PARTITION_LDM) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!IsRecognizedPartition(partitionType)) {
        isHidden = TRUE;
    }

    diskInfoSet = RootExtension->DiskInfoSet;
    if (!diskInfoSet->IsDiskInSet(WholeDiskPdo)) {

        diskInfo = new FT_LOGICAL_DISK_INFORMATION;
        if (!diskInfo) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = diskInfo->Initialize(RootExtension, WholeDiskPdo);
        if (!NT_SUCCESS(status)) {
            delete diskInfo;
            return status;
        }

        status = diskInfoSet->AddLogicalDiskInformation(diskInfo,
                                                        &changedLogicalDiskIds);
        if (!NT_SUCCESS(status)) {
            delete diskInfo;
            return status;
        }

        if (changedLogicalDiskIds) {
            FtpSyncLogicalDiskIds(RootExtension);
        }

        if (RootExtension->GptAttributeRevertEntries) {
            signature = FtpQueryDiskSignature(WholeDiskPdo);
            if (signature) {
                FtpCheckForRevertGptAttributes(RootExtension, Partition,
                                               signature, NULL, diskInfo);
            }
        }

    } else {
        diskInfo = diskInfoSet->FindLogicalDiskInformation(WholeDiskPdo);
    }

    if (diskInfo) {
        if (IsRecognizedPartition(partitionType)) {
            gptAttributes = diskInfo->GetGptAttributes();
            if (gptAttributes&GPT_BASIC_DATA_ATTRIBUTE_HIDDEN) {
                isHidden = TRUE;
            }
            if (gptAttributes&GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY) {
                isReadOnly = TRUE;
            }
        } else {
            gptAttributes = 0;
        }
    }

    // Make sure that the on disk reflects the state of the registry.

    diskInfoSet->MigrateRegistryInformation(Partition, diskNumber, offset);

    diskId = diskInfoSet->QueryRootLogicalDiskIdForContainedPartition(
             diskNumber, offset);
    if (diskId) {

        if (!RootExtension->FtCodeLocked) {
            MmLockPagableCodeSection(FtpComputeParity);
            status = FtpStartSystemThread(RootExtension);
            if (!NT_SUCCESS(status)) {
                return status;
            }
            RootExtension->FtCodeLocked = TRUE;
        }

        extension = FtpFindExtension(RootExtension, diskId);
        if (extension) {
            status = FtpAddPartition(extension, Partition, WholeDiskPdo);
            if (!NT_SUCCESS(status)) {
                return status;
            }

            FtpNotify(RootExtension, extension);

        } else {

            vol = FtpBuildFtVolume(RootExtension, diskId, Partition,
                                   WholeDiskPdo);

            if (!vol) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            partitionDiskId = diskInfoSet->QueryPartitionLogicalDiskId(
                              diskNumber, offset);
            parentDesc = diskInfoSet->GetParentLogicalDiskDescription(
                         partitionDiskId, &n);
            while (parentDesc) {

                if (parentDesc->u.Other.ByteOffsetToStateInformation &&
                    (c = vol->GetContainedLogicalDisk(
                         parentDesc->LogicalDiskId))) {

                    c->NewStateArrival((PCHAR) parentDesc +
                            parentDesc->u.Other.ByteOffsetToStateInformation);
                }

                parentDesc = diskInfoSet->GetParentLogicalDiskDescription(
                             parentDesc, n);
            }

            if (!FtpCreateNewDevice(RootExtension, NULL, vol, NULL,
                                    Partition->AlignmentRequirement, FALSE,
                                    isHidden, isReadOnly, FALSE, 0)) {

                FtpDeleteVolume(vol);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);
        }

    } else {

        if (!FtpCreateNewDevice(RootExtension, Partition, NULL, WholeDiskPdo,
                                Partition->AlignmentRequirement, FALSE,
                                isHidden, isReadOnly, FALSE, gptAttributes)) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpPartitionArrived(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine is called when a new partition is introduced into the
    system.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLMGR_PARTITION_INFORMATION       input;
    PDEVICE_OBJECT                      partition, wholeDiskPdo;
    NTSTATUS                            status;
    ULONG                               diskNumber;
    LONGLONG                            offset;
    UCHAR                               partitionType;
    PVOLUME_EXTENSION                   extension;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLMGR_PARTITION_INFORMATION)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLMGR_PARTITION_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
    partition = input->PartitionDeviceObject;
    wholeDiskPdo = input->WholeDiskPdo;

    status = FtpPartitionArrivedHelper(RootExtension, partition, wholeDiskPdo);

    return status;
}

VOID
FtpTotalBreakUp(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId
    )

{
    PFT_LOGICAL_DISK_INFORMATION_SET    diskInfoSet = RootExtension->DiskInfoSet;
    USHORT                              numDiskIds, i;
    PFT_LOGICAL_DISK_ID                 diskIds;

    if (!LogicalDiskId) {
        return;
    }

    numDiskIds = diskInfoSet->QueryNumberOfMembersInLogicalDisk(LogicalDiskId);
    if (numDiskIds) {
        diskIds = (PFT_LOGICAL_DISK_ID)
                  ExAllocatePool(PagedPool, numDiskIds*sizeof(FT_LOGICAL_DISK_ID));
        if (!diskIds) {
            return;
        }

        for (i = 0; i < numDiskIds; i++) {
            diskIds[i] = diskInfoSet->QueryMemberLogicalDiskId(LogicalDiskId, i);
        }
    }

    diskInfoSet->BreakLogicalDisk(LogicalDiskId);

    if (numDiskIds) {
        for (i = 0; i < numDiskIds; i++) {
            FtpTotalBreakUp(RootExtension, diskIds[i]);
        }

        ExFreePool(diskIds);
    }
}

NTSTATUS
FtpWholeDiskRemoved(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine is called when a whole disk is removed from the system.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLMGR_WHOLE_DISK_INFORMATION  input;
    PDEVICE_OBJECT                  pdo, wholeDisk;
    NTSTATUS                        status;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLMGR_WHOLE_DISK_INFORMATION)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLMGR_WHOLE_DISK_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
    pdo = input->WholeDiskPdo;

    status = RootExtension->DiskInfoSet->RemoveLogicalDiskInformation(pdo);

    return status;
}

NTSTATUS
FtpReferenceDependantVolume(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine references the volume dependant to the given partition.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLMGR_PARTITION_INFORMATION           input;
    PDEVICE_OBJECT                          partition;
    PVOLUME_EXTENSION                       extension;
    PVOLMGR_DEPENDANT_VOLUMES_INFORMATION   output;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLMGR_PARTITION_INFORMATION) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(VOLMGR_DEPENDANT_VOLUMES_INFORMATION)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLMGR_PARTITION_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
    partition = input->PartitionDeviceObject;
    output = (PVOLMGR_DEPENDANT_VOLUMES_INFORMATION)
             Irp->AssociatedIrp.SystemBuffer;

    output->DependantVolumeReferences = (PDEVICE_RELATIONS)
                                        ExAllocatePool(PagedPool,
                                        sizeof(DEVICE_RELATIONS));
    if (!output->DependantVolumeReferences) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    extension = FtpFindExtensionCoveringPartition(RootExtension, partition);
    if (!extension) {
        ExFreePool(output->DependantVolumeReferences);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (extension->IsStarted) {
        output->DependantVolumeReferences->Count = 1;
        output->DependantVolumeReferences->Objects[0] =
                extension->DeviceObject;
        ObReferenceObject(extension->DeviceObject);
    } else {
        output->DependantVolumeReferences->Count = 0;
    }

    Irp->IoStatus.Information = sizeof(VOLMGR_DEPENDANT_VOLUMES_INFORMATION);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpPartitionRemoved(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine is called when a partition is removed from the system.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLMGR_PARTITION_INFORMATION   input;
    PDEVICE_OBJECT                  partition;
    PDEVICE_OBJECT                  wholeDiskPdo;
    NTSTATUS                        status;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLMGR_PARTITION_INFORMATION)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLMGR_PARTITION_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
    partition = input->PartitionDeviceObject;
    wholeDiskPdo = input->WholeDiskPdo;

    status = FtpPartitionRemovedHelper(RootExtension, partition, wholeDiskPdo);

    return status;
}

NTSTATUS
FtpQueryChangePartition(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine checks to see if the given partition can be grown.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLMGR_PARTITION_INFORMATION           input;
    PVOLUME_EXTENSION                       extension;
    NTSTATUS                                status;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLMGR_PARTITION_INFORMATION)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLMGR_PARTITION_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

    extension = FtpFindExtensionCoveringPartition(
            RootExtension, input->PartitionDeviceObject);
    if (!extension) {
        return STATUS_INVALID_PARAMETER;
    }

    if (extension->TargetObject) {
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    return status;
}

NTSTATUS
FtpPartitionChanged(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine does a notification because the given partition has
    changed.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLMGR_PARTITION_INFORMATION           input;
    PVOLUME_EXTENSION                       extension;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLMGR_PARTITION_INFORMATION)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLMGR_PARTITION_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

    extension = FtpFindExtensionCoveringPartition(
            RootExtension, input->PartitionDeviceObject);
    if (!extension) {
        return STATUS_INVALID_PARAMETER;
    }

    extension->WholeDisk = NULL;
    extension->PartitionOffset = 0;
    extension->PartitionLength = 0;

    FtpNotify(RootExtension, extension);

    // Perform a pre-exposure of the new devnode to avoid the PNP reboot
    // pop-up.

    if (!extension->IsGpt &&
        FtpCreateNewDevice(extension->Root, extension->TargetObject,
                           extension->FtVolume, extension->WholeDiskPdo,
                           extension->DeviceObject->AlignmentRequirement,
                           TRUE, TRUE, FALSE, FALSE, 0)) {

        IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryRootId(
    IN  PROOT_EXTENSION Extension,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine queries the ID for the given PDO.

Arguments:

    Extension   - Supplies the root extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    UNICODE_STRING      string;
    NTSTATUS            status;
    ULONG               diskNumber;
    LONGLONG            offset;
    WCHAR               buffer[100];
    FT_LOGICAL_DISK_ID  diskId;
    PWSTR               id;

    switch (irpSp->Parameters.QueryId.IdType) {

        case BusQueryDeviceID:
            RtlInitUnicodeString(&string, L"ROOT\\FTDISK");
            break;

        case BusQueryHardwareIDs:
            RtlInitUnicodeString(&string, L"ROOT\\FTDISK");
            break;

        case BusQueryInstanceID:
            RtlInitUnicodeString(&string, L"0000");
            break;

        default:
            return STATUS_NOT_SUPPORTED ;

    }

    id = (PWSTR) ExAllocatePool(PagedPool, string.Length + 2*sizeof(WCHAR));
    if (!id) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(id, string.Buffer, string.Length);
    id[string.Length/sizeof(WCHAR)] = 0;
    id[string.Length/sizeof(WCHAR) + 1] = 0;

    Irp->IoStatus.Information = (ULONG_PTR) id;

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryId(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine queries the ID for the given PDO.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    UNICODE_STRING      string;
    NTSTATUS            status;
    PWSTR               id;

    switch (irpSp->Parameters.QueryId.IdType) {

        case BusQueryDeviceID:
            RtlInitUnicodeString(&string, L"STORAGE\\Volume");
            break;

        case BusQueryHardwareIDs:
            RtlInitUnicodeString(&string, L"STORAGE\\Volume");
            break;

        case BusQueryInstanceID:
            string = Extension->DeviceNodeName;
            break;

        default:
            return STATUS_NOT_SUPPORTED ;

    }

    id = (PWSTR) ExAllocatePool(PagedPool, string.Length + 2*sizeof(WCHAR));
    if (!id) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(id, string.Buffer, string.Length);
    id[string.Length/sizeof(WCHAR)] = 0;
    id[string.Length/sizeof(WCHAR) + 1] = 0;

    Irp->IoStatus.Information = (ULONG_PTR) id;

    return STATUS_SUCCESS;
}

class FTP_LOG_ERROR_CONTEXT : public WORK_QUEUE_ITEM {

    public:

        PDEVICE_EXTENSION   Extension;
        FT_LOGICAL_DISK_ID  LogicalDiskId;
        NTSTATUS            SpecificIoStatus;
        NTSTATUS            FinalStatus;
        ULONG               UniqueErrorValue;

};

typedef FTP_LOG_ERROR_CONTEXT *PFTP_LOG_ERROR_CONTEXT;

VOID
FtpLogErrorWorker(
    IN  PVOID   Context
    )

{
    PFTP_LOG_ERROR_CONTEXT  context = (PFTP_LOG_ERROR_CONTEXT) Context;
    PDEVICE_EXTENSION       Extension;
    PDEVICE_OBJECT          deviceObject;
    ULONG                   volumeNumber;
    FT_LOGICAL_DISK_ID      LogicalDiskId;
    NTSTATUS                SpecificIoStatus;
    NTSTATUS                FinalStatus;
    ULONG                   UniqueErrorValue;
    PDEVICE_EXTENSION       extension;
    NTSTATUS                status;
    UNICODE_STRING          dosName;
    ULONG                   extraSpace;
    PIO_ERROR_LOG_PACKET    errorLogPacket;
    PWCHAR                  p;

    Extension = context->Extension;
    LogicalDiskId = context->LogicalDiskId;
    SpecificIoStatus = context->SpecificIoStatus;
    FinalStatus = context->FinalStatus;
    UniqueErrorValue = context->UniqueErrorValue;

    if (LogicalDiskId) {
        FtpAcquire(Extension->Root);
        extension = FtpFindExtensionCoveringDiskId(Extension->Root,
                                                   LogicalDiskId);
        if (extension) {
            deviceObject = extension->DeviceObject;
            volumeNumber = ((PVOLUME_EXTENSION) extension)->VolumeNumber;
            ObReferenceObject(deviceObject);
        } else {
            deviceObject = NULL;
        }
        FtpRelease(Extension->Root);

        if (!extension) {
            extension = Extension->Root;
        }
    } else {
        extension = Extension;
        deviceObject = NULL;
    }

    if (deviceObject) {
        status = RtlVolumeDeviceToDosName(deviceObject, &dosName);
        ObDereferenceObject(deviceObject);
        if (!NT_SUCCESS(status)) {
            dosName.Buffer = (PWCHAR) ExAllocatePool(PagedPool, 100*sizeof(WCHAR));
            if (dosName.Buffer) {
                swprintf(dosName.Buffer, L"\\Device\\HarddiskVolume%d",
                         volumeNumber);
                RtlInitUnicodeString(&dosName, dosName.Buffer);
            }
        }
    } else {
        dosName.Buffer = NULL;
    }

    if (dosName.Buffer) {
        extraSpace = dosName.Length + sizeof(WCHAR);
    } else {
        extraSpace = 34;
    }

    errorLogPacket = (PIO_ERROR_LOG_PACKET)
                     IoAllocateErrorLogEntry(extension->DeviceObject,
                                             sizeof(IO_ERROR_LOG_PACKET) +
                                             (UCHAR)extraSpace);
    if (!errorLogPacket) {
        if (dosName.Buffer) {
            ExFreePool(dosName.Buffer);
        }
        return;
    }

    errorLogPacket->ErrorCode = SpecificIoStatus;
    errorLogPacket->SequenceNumber = FtErrorLogSequence++;
    errorLogPacket->FinalStatus = FinalStatus;
    errorLogPacket->UniqueErrorValue = UniqueErrorValue;
    errorLogPacket->DumpDataSize = 0;
    errorLogPacket->RetryCount = 0;

    errorLogPacket->NumberOfStrings = 1;
    errorLogPacket->StringOffset = sizeof(IO_ERROR_LOG_PACKET);
    p = (PWCHAR) ((PCHAR) errorLogPacket + sizeof(IO_ERROR_LOG_PACKET));
    if (dosName.Buffer) {
        RtlCopyMemory(p, dosName.Buffer, dosName.Length);
        p[dosName.Length/sizeof(WCHAR)] = 0;
        ExFreePool(dosName.Buffer);
    } else if (LogicalDiskId <= 0xFFFF && LogicalDiskId >= 0) {
        swprintf(p, L"%d", LogicalDiskId);
    } else {
        swprintf(p, L"%I64X", LogicalDiskId);
    }

    IoWriteErrorLogEntry(errorLogPacket);

    ExFreePool(Context);
}

VOID
FtpSendPagingNotification(
    IN  PDEVICE_OBJECT  Partition
    )

/*++

Routine Description:

    This routine sends a paging path IRP to the given partition.

Arguments:

    Partition   - Supplies the partition.

Return Value:

    None.

--*/

{
    KEVENT              event;
    PIRP                irp;
    IO_STATUS_BLOCK     ioStatus;
    PIO_STACK_LOCATION  irpSp;
    NTSTATUS            status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(0, Partition, NULL, 0, NULL, 0,
                                        FALSE, &event, &ioStatus);
    if (!irp) {
        return;
    }

    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = IRP_MJ_PNP;
    irpSp->MinorFunction = IRP_MN_DEVICE_USAGE_NOTIFICATION;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
    irpSp->Parameters.UsageNotification.InPath = TRUE;
    irpSp->Parameters.UsageNotification.Type = DeviceUsageTypePaging;

    status = IoCallDriver(Partition, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
}

NTSTATUS
FtpInitializeLogicalDisk(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine initializes a given logical disk.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_INITIALIZE_LOGICAL_DISK_INPUT   input;
    FT_LOGICAL_DISK_ID                  diskId;
    PVOLUME_EXTENSION                   extension;
    PFT_VOLUME                          vol;
    NTSTATUS                            status;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_INITIALIZE_LOGICAL_DISK_INPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_INITIALIZE_LOGICAL_DISK_INPUT) Irp->AssociatedIrp.SystemBuffer;
    diskId = input->RootLogicalDiskId;

    extension = FtpFindExtension(RootExtension, diskId);
    if (!extension || !extension->FtVolume) {
        return STATUS_INVALID_PARAMETER;
    }

    vol = extension->FtVolume;
    ASSERT(vol);

    KeWaitForSingleObject(&extension->Semaphore, Executive, KernelMode, FALSE,
                          NULL);
    status = FtpAllSystemsGo(extension, NULL, TRUE, TRUE, TRUE);
    KeReleaseSemaphore(&extension->Semaphore, IO_NO_INCREMENT, 1, FALSE);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    vol->StartSyncOperations(input->RegenerateOrphans,
                             FtpRefCountCompletion, extension);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpCheckIo(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine checks the io path for the given logical disk.

Arguments:

    Extension   - Supplies the root extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_CHECK_IO_INPUT  input;
    PFT_CHECK_IO_OUTPUT output;
    FT_LOGICAL_DISK_ID  diskId;
    PVOLUME_EXTENSION   extension;
    PFT_VOLUME          vol;
    NTSTATUS            status;
    BOOLEAN             ok;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_CHECK_IO_INPUT) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_CHECK_IO_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_CHECK_IO_INPUT) Irp->AssociatedIrp.SystemBuffer;
    output = (PFT_CHECK_IO_OUTPUT) Irp->AssociatedIrp.SystemBuffer;
    diskId = input->LogicalDiskId;

    extension = FtpFindExtensionCoveringDiskId(RootExtension, diskId);
    if (!extension || !extension->FtVolume) {
        return STATUS_INVALID_PARAMETER;
    }

    KeWaitForSingleObject(&extension->Semaphore, Executive, KernelMode, FALSE,
                          NULL);
    status = FtpAllSystemsGo(extension, NULL, FALSE, TRUE, TRUE);
    KeReleaseSemaphore(&extension->Semaphore, IO_NO_INCREMENT, 1, FALSE);

    if (!NT_SUCCESS(status)) {
        output->IsIoOk = FALSE;
        Irp->IoStatus.Information = sizeof(FT_CHECK_IO_OUTPUT);
        return STATUS_SUCCESS;
    }

    vol = extension->FtVolume->GetContainedLogicalDisk(diskId);
    status = vol->CheckIo(&ok);

    FtpDecrementRefCount(extension);

    if (NT_SUCCESS(status)) {
        output->IsIoOk = ok;
        Irp->IoStatus.Information = sizeof(FT_CHECK_IO_OUTPUT);
    }

    return status;
}

NTSTATUS
FtpBreakLogicalDiskHelper(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  RootLogicalDiskId
    )

/*++

Routine Description:

    This routine breaks a given logical disk.

Arguments:

    RootExtension       - Supplies the root extension.

    RootLogicalDiskId   - Supplies the root logical disk id.

Return Value:

    NTSTATUS

--*/

{
    FT_LOGICAL_DISK_ID                      diskId;
    PFT_LOGICAL_DISK_INFORMATION_SET        diskInfoSet;
    PVOLUME_EXTENSION                       extension;
    FT_LOGICAL_DISK_TYPE                    diskType;
    UCHAR                                   newUniqueIdBuffer[UNIQUE_ID_MAX_BUFFER_SIZE];
    PMOUNTDEV_UNIQUE_ID                     newUniqueId;
    PPARTITION                              partition;
    BOOLEAN                                 closeHandle;
    PFT_VOLUME                              vol, member, m;
    HANDLE                                  handle;
    PFT_MIRROR_AND_SWP_STATE_INFORMATION    state;
    USHORT                                  n, i;
    NTSTATUS                                status;
    KEVENT                                  event;
    SET_TARGET_CONTEXT                      context;
    ULONG                                   alignment;

    diskId = RootLogicalDiskId;
    diskInfoSet = RootExtension->DiskInfoSet;

    extension = FtpFindExtension(RootExtension, diskId);
    if (!extension) {
        return STATUS_INVALID_PARAMETER;
    }
    alignment = extension->DeviceObject->AlignmentRequirement;

    diskType = diskInfoSet->QueryLogicalDiskType(diskId);
    newUniqueId = (PMOUNTDEV_UNIQUE_ID) newUniqueIdBuffer;

    vol = extension->FtVolume;

    if (diskType == FtPartition) {

        partition = (PPARTITION) vol;
        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = partition->GetTargetObject();
        context.FtVolume = NULL;
        context.WholeDiskPdo = partition->GetWholeDiskPdo();
        FtpZeroRefCallback(extension, FtpSetTargetCallback, &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);

        member = NULL;
        closeHandle = FALSE;
        FtpResetPartitionType(extension);

        FtpQueryUniqueIdBuffer(extension, newUniqueId->UniqueId,
                               &newUniqueId->UniqueIdLength);
        FtpUniqueIdNotify(extension, newUniqueId);

    } else if (diskType == FtMirrorSet) {

        state = (PFT_MIRROR_AND_SWP_STATE_INFORMATION)
                diskInfoSet->GetStateInformation(diskId);
        if (!state) {
            return STATUS_INVALID_PARAMETER;
        }

        if (state->UnhealthyMemberState == FtMemberHealthy ||
            state->UnhealthyMemberNumber != 0) {

            member = vol->GetMember(0);
            if (!member) {
                member = vol->GetMember(1);
            }

        } else {
            member = vol->GetMember(1);
            if (!member) {
                member = vol->GetMember(0);
            }
        }

        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = NULL;
        context.FtVolume = member;
        context.WholeDiskPdo = NULL;
        FtpZeroRefCallback(extension, FtpSetTargetCallback, &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);

        closeHandle = FALSE;

        FtpQueryUniqueIdBuffer(extension, newUniqueId->UniqueId,
                               &newUniqueId->UniqueIdLength);
        FtpUniqueIdNotify(extension, newUniqueId);

    } else {
        if (!FtpLockLogicalDisk(RootExtension, diskId, &handle)) {
            return STATUS_ACCESS_DENIED;
        }
        closeHandle = TRUE;
        member = NULL;
    }

    status = diskInfoSet->BreakLogicalDisk(diskId);
    if (!NT_SUCCESS(status)) {
        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = NULL;
        context.FtVolume = vol;
        context.WholeDiskPdo = NULL;
        FtpZeroRefCallback(extension, FtpSetTargetCallback, &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);

        if (closeHandle) {
            ZwClose(handle);
        }
        return status;
    }

    if (closeHandle) {

        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = NULL;
        context.FtVolume = NULL;
        context.WholeDiskPdo = NULL;
        FtpZeroRefCallback(extension, FtpSetTargetCallback, &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);

        RemoveEntryList(&extension->ListEntry);
        InsertTailList(&RootExtension->DeadVolumeList, &extension->ListEntry);
        FtpDeleteMountPoints(extension);
        FtpCleanupVolumeExtension(extension);
    }

    n = vol->QueryNumberOfMembers();
    for (i = 0; i < n; i++) {
        m = vol->GetMember(i);
        if (!m || m == member) {
            continue;
        }
        FtpCreateNewDevice(RootExtension, NULL, m, NULL, alignment, FALSE,
                           FALSE, FALSE, FALSE, 0);
    }
    if (!InterlockedDecrement(&vol->_refCount)) {
        delete vol;
    }

    if (member) {
        FtpNotify(RootExtension, extension);
    } else if (!closeHandle) {
        FtpNotify(RootExtension, extension);
    }

    if (closeHandle) {
        ZwClose(handle);
    }

    if (diskType != FtPartition) {
        IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpReplaceLogicalDiskMember(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine replaces the given logical disk member.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_REPLACE_LOGICAL_DISK_MEMBER_INPUT   input;
    PFT_REPLACE_LOGICAL_DISK_MEMBER_OUTPUT  output;
    FT_LOGICAL_DISK_ID                      diskId, newMemberDiskId, newDiskId;
    USHORT                                  member;
    HANDLE                                  handle;
    PVOLUME_EXTENSION                       replacementExtension, extension;
    PFT_VOLUME                              replacementVolume, vol, oldVol, root;
    NTSTATUS                                status;
    PFT_LOGICAL_DISK_INFORMATION_SET        diskInfoSet;
    PVOLUME_EXTENSION                       oldVolExtension;
    PFT_LOGICAL_DISK_DESCRIPTION            p;
    WCHAR                                   deviceNameBuffer[64];
    UNICODE_STRING                          deviceName;
    UCHAR                                   newUniqueIdBuffer[UNIQUE_ID_MAX_BUFFER_SIZE];
    PMOUNTDEV_UNIQUE_ID                     newUniqueId;
    KEVENT                                  event;
    SET_TARGET_CONTEXT                      context;
    ULONG                                   alignment;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_REPLACE_LOGICAL_DISK_MEMBER_INPUT) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_REPLACE_LOGICAL_DISK_MEMBER_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_REPLACE_LOGICAL_DISK_MEMBER_INPUT)
            Irp->AssociatedIrp.SystemBuffer;
    output = (PFT_REPLACE_LOGICAL_DISK_MEMBER_OUTPUT)
             Irp->AssociatedIrp.SystemBuffer;

    diskId = input->LogicalDiskId;
    member = input->MemberNumberToReplace;
    newMemberDiskId = input->NewMemberLogicalDiskId;

    if (!FtpLockLogicalDisk(RootExtension, newMemberDiskId, &handle)) {
        return STATUS_ACCESS_DENIED;
    }

    replacementExtension = FtpFindExtension(RootExtension, newMemberDiskId);
    extension = FtpFindExtensionCoveringDiskId(RootExtension, diskId);
    if (!extension || !extension->FtVolume || !replacementExtension ||
        !replacementExtension->FtVolume) {

        ZwClose(handle);
        return STATUS_INVALID_PARAMETER;
    }

    alignment = extension->DeviceObject->AlignmentRequirement;
    extension->DeviceObject->AlignmentRequirement |=
            replacementExtension->DeviceObject->AlignmentRequirement;

    newUniqueId = (PMOUNTDEV_UNIQUE_ID) newUniqueIdBuffer;

    replacementVolume = replacementExtension->FtVolume;
    root = extension->FtVolume;
    vol = root->GetContainedLogicalDisk(diskId);

    // Flush the QUEUE so that no IRPs in transit have incorrect alignment.
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    FtpZeroRefCallback(extension, FtpQueryRemoveCallback, &event,
                       TRUE);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                          NULL);

    KeWaitForSingleObject(&extension->Semaphore, Executive, KernelMode, FALSE,
                          NULL);
    status = FtpAllSystemsGo(extension, NULL, FALSE, TRUE, TRUE);
    KeReleaseSemaphore(&extension->Semaphore, IO_NO_INCREMENT, 1, FALSE);

    if (!NT_SUCCESS(status)) {
        ZwClose(handle);
        return status;
    }

    status = FtpCheckForCompleteVolume(extension, vol);
    if (!NT_SUCCESS(status)) {
        FtpDecrementRefCount(extension);
        ZwClose(handle);
        return status;
    }

    status = FtpAllSystemsGo(replacementExtension, NULL, TRUE, TRUE, TRUE);
    if (!NT_SUCCESS(status)) {
        FtpDecrementRefCount(extension);
        ZwClose(handle);
        return status;
    }

    FtpDecrementRefCount(replacementExtension);

    KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
    context.TargetObject = NULL;
    context.FtVolume = NULL;
    context.WholeDiskPdo = NULL;
    FtpZeroRefCallback(replacementExtension, FtpSetTargetCallback, &context,
                       TRUE);
    KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE, NULL);

    oldVol = vol->GetMember(member);

    if (!vol->IsVolumeSuitableForRegenerate(member, replacementVolume)) {
        FtpDecrementRefCount(extension);

        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = NULL;
        context.FtVolume = replacementVolume;
        context.WholeDiskPdo = NULL;
        FtpZeroRefCallback(replacementExtension, FtpSetTargetCallback,
                           &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);

        ZwClose(handle);
        return STATUS_INVALID_PARAMETER;
    }

    diskInfoSet = RootExtension->DiskInfoSet;
    status = diskInfoSet->ReplaceLogicalDiskMember(diskId, member,
                                                   newMemberDiskId,
                                                   &newDiskId);
    if (!NT_SUCCESS(status)) {
        FtpDecrementRefCount(extension);

        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = NULL;
        context.FtVolume = replacementVolume;
        context.WholeDiskPdo = NULL;
        FtpZeroRefCallback(replacementExtension, FtpSetTargetCallback,
                           &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);

        ZwClose(handle);
        return status;
    }

    InterlockedIncrement(&extension->RefCount);
    vol->RegenerateMember(member, replacementVolume,
                          FtpRefCountCompletion, extension);
    vol->StartSyncOperations(FALSE, FtpRefCountCompletion, extension);

    RemoveEntryList(&replacementExtension->ListEntry);
    InsertTailList(&RootExtension->DeadVolumeList,
                   &replacementExtension->ListEntry);
    FtpDeleteMountPoints(replacementExtension);
    FtpCleanupVolumeExtension(replacementExtension);

    Irp->IoStatus.Information =
            sizeof(FT_REPLACE_LOGICAL_DISK_MEMBER_OUTPUT);
    output->NewLogicalDiskId = newDiskId;

    vol->SetLogicalDiskId(newDiskId);

    while (p = diskInfoSet->GetParentLogicalDiskDescription(
           vol->QueryLogicalDiskId())) {

        if (vol = root->GetParentLogicalDisk(vol)) {
            vol->SetLogicalDiskId(p->LogicalDiskId);
        }
    }

    if (oldVol) {
        FtpCreateNewDevice(RootExtension, NULL, oldVol, NULL, alignment, FALSE,
                           FALSE, FALSE, FALSE, 0);
    }

    swprintf(deviceNameBuffer, L"\\Device\\HarddiskVolume%d", extension->VolumeNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);
    replacementVolume->CreateLegacyNameLinks(&deviceName);

    FtpQueryUniqueIdBuffer(extension, newUniqueId->UniqueId,
                           &newUniqueId->UniqueIdLength);
    FtpUniqueIdNotify(extension, newUniqueId);

    IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);

    ZwClose(handle);

    return status;
}

NTSTATUS
FtDiskPagingNotification(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine handles the PnP paging notification IRP.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION                   extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION                  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                            status;
    PFT_VOLUME                          vol;

    ASSERT(extension->DeviceExtensionType != DEVICE_EXTENSION_ROOT);

    status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
    if (status == STATUS_PENDING) {
        return status;
    }
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging) {
        extension->InPagingPath = irpSp->Parameters.UsageNotification.InPath;
        IoInvalidateDeviceState(extension->DeviceObject);
    }

    if (extension->TargetObject) {
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, FtpRefCountCompletionRoutine,
                               extension, TRUE, TRUE, TRUE);
        IoMarkIrpPending(Irp);

        IoCallDriver(extension->TargetObject, Irp);

        return STATUS_PENDING;
    }

    vol = extension->FtVolume;
    ASSERT(vol);

    IoMarkIrpPending(Irp);
    irpSp->DeviceObject = DeviceObject;

    vol->BroadcastIrp(Irp, FtDiskShutdownFlushCompletionRoutine, Irp);

    return STATUS_PENDING;
}

VOID
FtpDereferenceMbrGptAttributes(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PDEVICE_OBJECT      WholeDiskPdo
    )

{
    PLIST_ENTRY                     l;
    PVOLUME_EXTENSION               extension;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;

    for (l = Extension->Root->VolumeList.Flink;
         l != &Extension->Root->VolumeList; l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        if (extension == Extension ||
            extension->WholeDiskPdo != WholeDiskPdo ||
            !extension->MbrGptAttributes) {

            continue;
        }

        return;
    }

    diskInfo = Extension->Root->DiskInfoSet->FindLogicalDiskInformation(
               WholeDiskPdo);
    if (diskInfo) {
        diskInfo->SetGptAttributes(0);
    }
}

NTSTATUS
FtpPartitionRemovedHelper(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN      PDEVICE_OBJECT  Partition,
    IN      PDEVICE_OBJECT  WholeDiskPdo
    )

{
    PVOLUME_EXTENSION               extension;
    KEVENT                          event;
    PFT_VOLUME                      vol, part, parent;
    FT_PARTITION_OFFLINE_CONTEXT    offlineContext;
    USHORT                          n, i;
    SET_TARGET_CONTEXT              context;

    extension = FtpFindExtensionCoveringPartition(RootExtension, Partition);
    if (!extension) {
        return STATUS_INVALID_PARAMETER;
    }

    if (extension->TargetObject) {
        ASSERT(extension->TargetObject == Partition);

        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = NULL;
        context.FtVolume = NULL;
        context.WholeDiskPdo = NULL;
        FtpZeroRefCallback(extension, FtpSetTargetCallback, &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);

        if (WholeDiskPdo) {
            FtpDeleteMountPoints(extension);
            if (!extension->IsGpt && extension->MbrGptAttributes) {
                FtpDereferenceMbrGptAttributes(extension, WholeDiskPdo);
            }
        }

        RemoveEntryList(&extension->ListEntry);
        InsertTailList(&RootExtension->DeadVolumeList, &extension->ListEntry);
        FtpCleanupVolumeExtension(extension);

        IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);

    } else {

        vol = extension->FtVolume;
        ASSERT(vol);
        part = vol->GetContainedLogicalDisk(Partition);
        parent = vol->GetParentLogicalDisk(part);
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        offlineContext.Root = vol;
        offlineContext.Parent = parent;
        offlineContext.Child = part;
        offlineContext.Event = &event;
        FtpZeroRefCallback(extension, FtpMemberOfflineCallback,
                           &offlineContext, TRUE);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

        if (extension->FtVolume) {
            FtpNotify(RootExtension, extension);
        } else {
            if (WholeDiskPdo) {
                FtpDeleteMountPoints(extension);
                FtpTotalBreakUp(RootExtension, vol->QueryLogicalDiskId());
            }
            FtpDeleteVolume(vol);
            RemoveEntryList(&extension->ListEntry);
            InsertTailList(&RootExtension->DeadVolumeList, &extension->ListEntry);
            FtpCleanupVolumeExtension(extension);
            IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);
        }

        if (parent) {
            if (!InterlockedDecrement(&part->_refCount)) {
                delete part;
            }
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpGetVolumeDiskExtents(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the disk extents for the given volume.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLUME_DISK_EXTENTS    output = (PVOLUME_DISK_EXTENTS) Irp->AssociatedIrp.SystemBuffer;
    NTSTATUS                status;
    ULONG                   diskNumber, numExtents;
    LONGLONG                offset, length;
    PDISK_EXTENT            extents;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(VOLUME_DISK_EXTENTS)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (Extension->TargetObject) {
        status = FtpQueryPartitionInformation(Extension->Root,
                                              Extension->TargetObject,
                                              &diskNumber, &offset, NULL,
                                              NULL, &length, NULL, NULL, NULL,
                                              NULL);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        Irp->IoStatus.Information = sizeof(VOLUME_DISK_EXTENTS);
        output->NumberOfDiskExtents = 1;
        output->Extents[0].DiskNumber = diskNumber;
        output->Extents[0].StartingOffset.QuadPart = offset;
        output->Extents[0].ExtentLength.QuadPart = length;

        return STATUS_SUCCESS;
    }

    status = Extension->FtVolume->QueryDiskExtents(&extents, &numExtents);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    output->NumberOfDiskExtents = numExtents;
    Irp->IoStatus.Information = FIELD_OFFSET(VOLUME_DISK_EXTENTS, Extents) +
                                numExtents*sizeof(DISK_EXTENT);
    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = FIELD_OFFSET(VOLUME_DISK_EXTENTS, Extents);
        ExFreePool(extents);
        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(output->Extents, extents, numExtents*sizeof(DISK_EXTENT));
    ExFreePool(extents);

    return status;
}

NTSTATUS
FtpDisksFromFtVolume(
    IN  PFT_VOLUME          FtVolume,
    OUT PDEVICE_OBJECT**    DiskPdos,
    OUT PULONG              NumDiskPdos
    )

{
    PDEVICE_OBJECT* diskPdos;
    ULONG           numDisks, nd, j, k;
    USHORT          n, i;
    PFT_VOLUME      vol;
    PDEVICE_OBJECT* dp;
    NTSTATUS        status;
    PDEVICE_OBJECT* diskPdos2;

    if (FtVolume->QueryLogicalDiskType() == FtPartition) {
        numDisks = 1;
        diskPdos = (PDEVICE_OBJECT*)
                   ExAllocatePool(PagedPool, numDisks*sizeof(PDEVICE_OBJECT));
        if (!diskPdos) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        diskPdos[0] = ((PPARTITION) FtVolume)->GetWholeDiskPdo();
        *DiskPdos = diskPdos;
        *NumDiskPdos = numDisks;
        return STATUS_SUCCESS;
    }

    diskPdos = NULL;
    numDisks = 0;

    n = FtVolume->QueryNumberOfMembers();
    for (i = 0; i < n; i++) {
        vol = FtVolume->GetMember(i);
        if (!vol) {
            continue;
        }

        status = FtpDisksFromFtVolume(vol, &dp, &nd);
        if (!NT_SUCCESS(status)) {
            if (diskPdos) {
                ExFreePool(diskPdos);
            }
            return status;
        }

        diskPdos2 = diskPdos;
        diskPdos = (PDEVICE_OBJECT*) ExAllocatePool(PagedPool,
                   (numDisks + nd)*sizeof(PDEVICE_OBJECT));
        if (!diskPdos) {
            ExFreePool(dp);
            if (diskPdos2) {
                ExFreePool(diskPdos2);
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        if (diskPdos2) {
            RtlCopyMemory(diskPdos, diskPdos2,
                          numDisks*sizeof(PDEVICE_OBJECT));
            ExFreePool(diskPdos2);
        }

        for (j = 0; j < nd; j++) {
            for (k = 0; k < numDisks; k++) {
                if (dp[j] == diskPdos[k]) {
                    break;
                }
            }
            if (k == numDisks) {
                diskPdos[numDisks++] = dp[j];
            }
        }

        ExFreePool(dp);
    }

    *DiskPdos = diskPdos;
    *NumDiskPdos = numDisks;

    return STATUS_SUCCESS;
}

NTSTATUS
FtpDisksFromVolumes(
    IN  PVOLUME_EXTENSION*  Extensions,
    IN  ULONG               NumVolumes,
    OUT PDEVICE_OBJECT**    WholeDiskPdos,
    OUT PULONG              NumDisks
    )

/*++

Routine Description:

    This routine computes the disks that are used by the given volumes
    and returns the list of whole disk pdos.

Arguments:

    Extensions      - Supplies the list of volumes.

    NumVolumes      - Supplies the number of volumes.

    WholeDiskPdos   - Returns the list of disks.

    NumDisks        - Returns the number of disks.

Return Value:

    NTSTATUS

--*/

{
    ULONG           numDisks, i, j, k;
    PDEVICE_OBJECT* diskPdos;
    PDEVICE_OBJECT* diskPdos2;
    NTSTATUS        status;
    PDEVICE_OBJECT* volumeDiskPdos;
    ULONG           numVolumeDisks;

    numDisks = 0;
    diskPdos = NULL;

    for (i = 0; i < NumVolumes; i++) {

        if (Extensions[i]->TargetObject) {
            for (j = 0; j < numDisks; j++) {
                if (Extensions[i]->WholeDiskPdo == diskPdos[j]) {
                    break;
                }
            }
            if (j == numDisks) {
                diskPdos2 = diskPdos;
                numDisks++;
                diskPdos = (PDEVICE_OBJECT*)
                           ExAllocatePool(PagedPool,
                                          numDisks*sizeof(PDEVICE_OBJECT));
                if (!diskPdos) {
                    if (diskPdos2) {
                        ExFreePool(diskPdos2);
                    }
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
                if (diskPdos2) {
                    RtlCopyMemory(diskPdos, diskPdos2,
                                  (numDisks - 1)*sizeof(PDEVICE_OBJECT));
                    ExFreePool(diskPdos2);
                }
                diskPdos[numDisks - 1] = Extensions[i]->WholeDiskPdo;
            }

        } else if (Extensions[i]->FtVolume) {

            status = FtpDisksFromFtVolume(Extensions[i]->FtVolume,
                                          &volumeDiskPdos, &numVolumeDisks);
            if (!NT_SUCCESS(status)) {
                if (diskPdos) {
                    ExFreePool(diskPdos);
                }
                return status;
            }

            diskPdos2 = diskPdos;
            diskPdos = (PDEVICE_OBJECT*) ExAllocatePool(PagedPool,
                       (numDisks + numVolumeDisks)*sizeof(PDEVICE_OBJECT));
            if (!diskPdos) {
                ExFreePool(volumeDiskPdos);
                if (diskPdos2) {
                    ExFreePool(diskPdos2);
                }
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            if (diskPdos2) {
                RtlCopyMemory(diskPdos, diskPdos2,
                              numDisks*sizeof(PDEVICE_OBJECT));
                ExFreePool(diskPdos2);
            }

            for (j = 0; j < numVolumeDisks; j++) {
                for (k = 0; k < numDisks; k++) {
                    if (volumeDiskPdos[j] == diskPdos[k]) {
                        break;
                    }
                }
                if (k == numDisks) {
                    diskPdos[numDisks++] = volumeDiskPdos[j];
                }
            }

            ExFreePool(volumeDiskPdos);
        }
    }

    *WholeDiskPdos = diskPdos;
    *NumDisks = numDisks;

    return STATUS_SUCCESS;
}

BOOLEAN
FtpVolumeContainsDisks(
    IN  PFT_VOLUME          FtVolume,
    IN  PDEVICE_OBJECT*     WholeDiskPdos,
    IN  ULONG               NumDisks
    )

/*++

Routine Description:

    This routine determines whether or not the given volume contains
    any of the given disks.

Arguments:

    FtVolume    - Supplies the FT volumes.

    WholeDiskPdos   - Supplies the list of disks.

    NumDisks        - Supplies the number of disks.

Return Value:

    FALSE   - The given volume does not contain any of the given disks.

    TRUE    - The given volume contains at least one of the given disks.

--*/

{
    PDEVICE_OBJECT  wholeDiskPdo;
    ULONG           i;
    USHORT          n, j;
    PFT_VOLUME      vol;

    if (FtVolume->QueryLogicalDiskType() == FtPartition) {
        wholeDiskPdo = ((PPARTITION) FtVolume)->GetWholeDiskPdo();
        for (i = 0; i < NumDisks; i++) {
            if (wholeDiskPdo == WholeDiskPdos[i]) {
                return TRUE;
            }
        }

        return FALSE;
    }

    n = FtVolume->QueryNumberOfMembers();
    for (j = 0; j < n; j++) {
        vol = FtVolume->GetMember(j);
        if (!vol) {
            continue;
        }

        if (FtpVolumeContainsDisks(vol, WholeDiskPdos, NumDisks)) {
            return TRUE;
        }
    }

    return FALSE;
}

NTSTATUS
FtpVolumesFromDisks(
    IN  PROOT_EXTENSION     RootExtension,
    IN  PDEVICE_OBJECT*     WholeDiskPdos,
    IN  ULONG               NumDisks,
    OUT PVOLUME_EXTENSION** Extensions,
    OUT PULONG              NumVolumes
    )

/*++

Routine Description:

    This routine computes the volumes that use the given set of disks
    and returns the list of volume device extensions.

Arguments:

    RootExtension   - Supplies the root extension.

    WholeDiskPdos   - Supplies the list of disks.

    NumDisks        - Supplies the number of disks.

    Extensions      - Returns the list of volumes.

    NumVolumes      - Returns the number of volumes.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION*  extensions;
    ULONG               numVolumes;
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;
    ULONG               i;

    extensions = (PVOLUME_EXTENSION*)
                 ExAllocatePool(PagedPool, RootExtension->NextVolumeNumber*
                                sizeof(PVOLUME_EXTENSION));
    if (!extensions) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    numVolumes = 0;
    for (l = RootExtension->VolumeList.Flink;
         l != &RootExtension->VolumeList; l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        if (extension->TargetObject) {
            for (i = 0; i < NumDisks; i++) {
                if (WholeDiskPdos[i] == extension->WholeDiskPdo) {
                    break;
                }
            }
            if (i == NumDisks) {
                continue;
            }
        } else if (extension->FtVolume) {
            if (!FtpVolumeContainsDisks(extension->FtVolume, WholeDiskPdos,
                                        NumDisks)) {

                continue;
            }
        } else {
            continue;
        }

        extensions[numVolumes++] = extension;
    }

    *Extensions = extensions;
    *NumVolumes = numVolumes;

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryFailoverSet(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the list of disks which include the given volume
    and which make up a failover set.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG                   numVolumes, numVolumes2, numDisks, numDisks2;
    PVOLUME_EXTENSION*      extensions;
    PDEVICE_OBJECT*         diskPdos;
    NTSTATUS                status;
    PVOLUME_FAILOVER_SET    output;
    ULONG                   i;
    PDEVICE_OBJECT          deviceObject;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(VOLUME_FAILOVER_SET)) {

        return STATUS_INVALID_PARAMETER;
    }

    numVolumes = 1;
    extensions = (PVOLUME_EXTENSION*)
                 ExAllocatePool(PagedPool,
                                numVolumes*sizeof(PVOLUME_EXTENSION));
    if (!extensions) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    extensions[0] = Extension;

    diskPdos = NULL;
    numDisks = 0;

    for (;;) {

        numDisks2 = numDisks;
        if (diskPdos) {
            ExFreePool(diskPdos);
            diskPdos = NULL;
        }

        status = FtpDisksFromVolumes(extensions, numVolumes, &diskPdos,
                                     &numDisks);
        if (!NT_SUCCESS(status)) {
            break;
        }

        if (numDisks == numDisks2) {
            status = STATUS_SUCCESS;
            break;
        }

        numVolumes2 = numVolumes;
        if (extensions) {
            ExFreePool(extensions);
            extensions = NULL;
        }

        status = FtpVolumesFromDisks(Extension->Root, diskPdos, numDisks,
                                     &extensions, &numVolumes);
        if (!NT_SUCCESS(status)) {
            break;
        }

        if (numVolumes == numVolumes2) {
            status = STATUS_SUCCESS;
            break;
        }
    }

    if (extensions) {
        ExFreePool(extensions);
    }

    if (!NT_SUCCESS(status)) {
        if (diskPdos) {
            ExFreePool(diskPdos);
        }
        return status;
    }

    output = (PVOLUME_FAILOVER_SET) Irp->AssociatedIrp.SystemBuffer;
    output->NumberOfDisks = numDisks;
    Irp->IoStatus.Information =
            FIELD_OFFSET(VOLUME_FAILOVER_SET, DiskNumbers) +
            numDisks*sizeof(ULONG);
    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        Irp->IoStatus.Information = sizeof(VOLUME_FAILOVER_SET);
        if (diskPdos) {
            ExFreePool(diskPdos);
        }
        return STATUS_BUFFER_OVERFLOW;
    }

    for (i = 0; i < numDisks; i++) {
        deviceObject = IoGetAttachedDeviceReference(diskPdos[i]);
        status = FtpQueryPartitionInformation(Extension->Root, deviceObject,
                                              &output->DiskNumbers[i],
                                              NULL, NULL, NULL, NULL, NULL,
                                              NULL, NULL, NULL);
        ObDereferenceObject(deviceObject);
        if (!NT_SUCCESS(status)) {
            Irp->IoStatus.Information = 0;
            if (diskPdos) {
                ExFreePool(diskPdos);
            }
            return status;
        }
    }

    if (diskPdos) {
        ExFreePool(diskPdos);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryVolumeNumber(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the volume number for the given volume.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLUME_NUMBER      output;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(VOLUME_NUMBER)) {

        return STATUS_INVALID_PARAMETER;
    }

    output = (PVOLUME_NUMBER) Irp->AssociatedIrp.SystemBuffer;
    output->VolumeNumber = Extension->VolumeNumber;
    RtlCopyMemory(output->VolumeManagerName, L"FTDISK  ", 16);

    Irp->IoStatus.Information = sizeof(VOLUME_NUMBER);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpLogicalToPhysical(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns physical disk and offset for a given volume
    logical offset.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLUME_LOGICAL_OFFSET      input;
    LONGLONG                    logicalOffset;
    PVOLUME_PHYSICAL_OFFSETS    output;
    NTSTATUS                    status;
    ULONG                       diskNumber;
    LONGLONG                    partitionOffset, partitionLength;
    PFT_VOLUME                  vol;
    PVOLUME_PHYSICAL_OFFSET     physicalOffsets;
    ULONG                       numPhysicalOffsets;
    ULONG                       i;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLUME_LOGICAL_OFFSET) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(VOLUME_PHYSICAL_OFFSETS)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLUME_LOGICAL_OFFSET) Irp->AssociatedIrp.SystemBuffer;
    logicalOffset = input->LogicalOffset;
    output = (PVOLUME_PHYSICAL_OFFSETS) Irp->AssociatedIrp.SystemBuffer;

    if (Extension->TargetObject) {
        status = FtpQueryPartitionInformation(Extension->Root,
                                              Extension->TargetObject,
                                              &diskNumber,
                                              &partitionOffset, NULL, NULL,
                                              &partitionLength, NULL, NULL,
                                              NULL, NULL);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (logicalOffset < 0 ||
            partitionLength <= logicalOffset) {
            return STATUS_INVALID_PARAMETER;
        }

        output->NumberOfPhysicalOffsets = 1;
        output->PhysicalOffset[0].DiskNumber = diskNumber;
        output->PhysicalOffset[0].Offset = partitionOffset + logicalOffset;

        Irp->IoStatus.Information = sizeof(VOLUME_PHYSICAL_OFFSETS);

        return status;
    }

    vol = Extension->FtVolume;
    ASSERT(vol);

    status = vol->QueryPhysicalOffsets(logicalOffset, &physicalOffsets,
                                       &numPhysicalOffsets);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    Irp->IoStatus.Information = FIELD_OFFSET(VOLUME_PHYSICAL_OFFSETS,
                                             PhysicalOffset) +
                                numPhysicalOffsets*
                                sizeof(VOLUME_PHYSICAL_OFFSET);

    output->NumberOfPhysicalOffsets = numPhysicalOffsets;

    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        Irp->IoStatus.Information = FIELD_OFFSET(VOLUME_PHYSICAL_OFFSETS,
                                                 PhysicalOffset);
        ExFreePool(physicalOffsets);
        return STATUS_BUFFER_OVERFLOW;
    }

    for (i = 0; i < numPhysicalOffsets; i++) {
        output->PhysicalOffset[i] = physicalOffsets[i];
    }

    ExFreePool(physicalOffsets);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpPhysicalToLogical(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the volume logical offset for a given disk number
    and physical offset.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLUME_PHYSICAL_OFFSET     input;
    ULONG                       diskNumber, otherDiskNumber;
    LONGLONG                    physicalOffset;
    PVOLUME_LOGICAL_OFFSET      output;
    NTSTATUS                    status;
    LONGLONG                    partitionOffset, partitionLength;
    PFT_VOLUME                  vol;
    LONGLONG                    logicalOffset;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLUME_PHYSICAL_OFFSET) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(VOLUME_LOGICAL_OFFSET)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLUME_PHYSICAL_OFFSET) Irp->AssociatedIrp.SystemBuffer;
    diskNumber = input->DiskNumber;
    physicalOffset = input->Offset;
    output = (PVOLUME_LOGICAL_OFFSET) Irp->AssociatedIrp.SystemBuffer;

    if (Extension->TargetObject) {
        status = FtpQueryPartitionInformation(Extension->Root,
                                              Extension->TargetObject,
                                              &otherDiskNumber,
                                              &partitionOffset, NULL, NULL,
                                              &partitionLength, NULL, NULL,
                                              NULL, NULL);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (diskNumber != otherDiskNumber ||
            physicalOffset < partitionOffset ||
            partitionOffset + partitionLength <= physicalOffset) {

            return STATUS_INVALID_PARAMETER;
        }

        output->LogicalOffset = physicalOffset - partitionOffset;

        Irp->IoStatus.Information = sizeof(VOLUME_LOGICAL_OFFSET);

        return status;
    }

    vol = Extension->FtVolume;
    ASSERT(vol);

    status = vol->QueryLogicalOffset(input, &logicalOffset);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    output->LogicalOffset = logicalOffset;
    Irp->IoStatus.Information = sizeof(VOLUME_LOGICAL_OFFSET);

    return status;
}

BOOLEAN
FtpIsReplicatedPartition(
    IN  PFT_VOLUME  FtVolume
    )

{
    PFT_VOLUME  m0, m1;

    if (FtVolume->QueryLogicalDiskType() == FtPartition) {
        return TRUE;
    }

    if (FtVolume->QueryLogicalDiskType() != FtMirrorSet) {
        return FALSE;
    }

    m0 = FtVolume->GetMember(0);
    m1 = FtVolume->GetMember(1);

    if (m0 && !FtpIsReplicatedPartition(m0)) {
        return FALSE;
    }

    if (m1 && !FtpIsReplicatedPartition(m1)) {
        return FALSE;
    }

    if (!m0 && !m1) {
        return FALSE;
    }

    return TRUE;
}

NTSTATUS
FtpIsPartition(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine determines whether the given volume is installable. 
    To be an installable volume on Whistler, the volume must be a basic 
    partition. 

    We will disallow installing to Ft mirrors on Whistler, because we will
    offline Ft volumes after a Whistler install\upgrade.
    
    This call will return STATUS_UNSUCCESSFUL for all volumes that are
    not a simple basic partition, e.g., mirrors, RAID5, stripe sets
    and volume sets.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS    status;

    if (Extension->TargetObject) {
        status = STATUS_SUCCESS;
    } 
    else if (Extension->FtVolume && FtpIsReplicatedPartition(Extension->FtVolume)) {
        status = STATUS_SUCCESS;
    } 
    else {
        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}

NTSTATUS
FtpSetGptAttributesOnDisk(
    IN  PDEVICE_OBJECT  Partition,
    IN  ULONGLONG       GptAttributes
    )

{
    KEVENT                          event;
    PIRP                            irp;
    PARTITION_INFORMATION_EX        partInfo;
    IO_STATUS_BLOCK                 ioStatus;
    NTSTATUS                        status;
    SET_PARTITION_INFORMATION_EX    setPartInfo;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO_EX,
                                        Partition, NULL, 0, &partInfo,
                                        sizeof(partInfo), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(Partition, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        return status;
    }

    ASSERT(partInfo.PartitionStyle == PARTITION_STYLE_GPT);

    setPartInfo.PartitionStyle = partInfo.PartitionStyle;
    setPartInfo.Gpt = partInfo.Gpt;
    setPartInfo.Gpt.Attributes = GptAttributes;

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_SET_PARTITION_INFO_EX,
                                        Partition, &setPartInfo,
                                        sizeof(setPartInfo), NULL, 0, FALSE,
                                        &event, &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(Partition, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        return status;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpCheckSecurity(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    SECURITY_SUBJECT_CONTEXT    securityContext;
    BOOLEAN                     accessGranted;
    NTSTATUS                    status;
    ACCESS_MASK                 grantedAccess;

    SeCaptureSubjectContext(&securityContext);
    SeLockSubjectContext(&securityContext);

    accessGranted = FALSE;
    status = STATUS_ACCESS_DENIED;

    _try {

        accessGranted = SeAccessCheck(
                        Extension->DeviceObject->SecurityDescriptor,
                        &securityContext, TRUE, FILE_READ_DATA, 0, NULL,
                        IoGetFileObjectGenericMapping(), Irp->RequestorMode,
                        &grantedAccess, &status);

    } _finally {
        SeUnlockSubjectContext(&securityContext);
        SeReleaseSubjectContext(&securityContext);
    }

    if (!accessGranted) {
        return status;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryRegistryRevertEntriesCallback(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   RevertEntries,
    IN  PVOID   NumberOfRevertEntries
    )

{
    PFTP_GPT_ATTRIBUTE_REVERT_ENTRY*    revertEntries = (PFTP_GPT_ATTRIBUTE_REVERT_ENTRY*) RevertEntries;
    PULONG                              pn = (PULONG) NumberOfRevertEntries;

    if (ValueType != REG_BINARY) {
        return STATUS_SUCCESS;
    }

    (*revertEntries) = (PFTP_GPT_ATTRIBUTE_REVERT_ENTRY)
                       ExAllocatePool(PagedPool, ValueLength);
    if (!(*revertEntries)) {
        return STATUS_SUCCESS;
    }

    RtlCopyMemory((*revertEntries), ValueData, ValueLength);
    *pn = ValueLength/sizeof(FTP_GPT_ATTRIBUTE_REVERT_ENTRY);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryRegistryRevertEntries(
    IN  PROOT_EXTENSION                     RootExtension,
    OUT PFTP_GPT_ATTRIBUTE_REVERT_ENTRY*    RevertEntries,
    OUT PULONG                              NumberOfRevertEntries
    )

{
    RTL_QUERY_REGISTRY_TABLE        queryTable[2];
    PFTP_GPT_ATTRIBUTE_REVERT_ENTRY revertEntries;
    ULONG                           n;

    revertEntries = NULL;
    n = 0;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = FtpQueryRegistryRevertEntriesCallback;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = REVERT_GPT_ATTRIBUTES_REGISTRY_NAME;
    queryTable[0].EntryContext = &n;

    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                           RootExtension->DiskPerfRegistryPath.Buffer,
                           queryTable, &revertEntries, NULL);

    if (!revertEntries) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *RevertEntries = revertEntries;
    *NumberOfRevertEntries = n;

    return STATUS_SUCCESS;
}

NTSTATUS
FtpStoreGptAttributeRevertRecord(
    IN  PROOT_EXTENSION RootExtension,
    IN  ULONG           MbrSignature,
    IN  GUID*           GptPartitionGuid,
    IN  ULONGLONG       GptAttributes
    )

{
    NTSTATUS                        status;
    PFTP_GPT_ATTRIBUTE_REVERT_ENTRY p, q;
    ULONG                           n, i;

    status = FtpQueryRegistryRevertEntries(RootExtension, &p, &n);
    if (!NT_SUCCESS(status)) {
        p = NULL;
        n = 0;
    }

    for (i = 0; i < n; i++) {
        if (MbrSignature) {
            if (MbrSignature == p[i].MbrSignature) {
                break;
            }
        } else {
            if (IsEqualGUID(*GptPartitionGuid, p[i].PartitionUniqueId)) {
                break;
            }
        }
    }

    if (i == n) {
        q = (PFTP_GPT_ATTRIBUTE_REVERT_ENTRY)
            ExAllocatePool(PagedPool,
                           (n + 1)*sizeof(FTP_GPT_ATTRIBUTE_REVERT_ENTRY));
        if (!q) {
            if (p) {
                ExFreePool(p);
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        if (n && p) {
            RtlCopyMemory(q, p, n*sizeof(FTP_GPT_ATTRIBUTE_REVERT_ENTRY));
        }
        if (p) {
            ExFreePool(p);
        }

        p = q;
        n++;
    }

    RtlZeroMemory(&p[i], sizeof(FTP_GPT_ATTRIBUTE_REVERT_ENTRY));
    if (GptPartitionGuid) {
        p[i].PartitionUniqueId = *GptPartitionGuid;
    }
    p[i].GptAttributes = GptAttributes;
    p[i].MbrSignature = MbrSignature;

    status = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                   RootExtension->DiskPerfRegistryPath.Buffer,
                                   REVERT_GPT_ATTRIBUTES_REGISTRY_NAME,
                                   REG_BINARY, p,
                                   n*sizeof(FTP_GPT_ATTRIBUTE_REVERT_ENTRY));

    ExFreePool(p);

    return status;
}

VOID
FtpDeleteGptAttributeRevertRecord(
    IN  PROOT_EXTENSION RootExtension,
    IN  ULONG           MbrSignature,
    IN  GUID*           GptPartitionGuid
    )

{
    NTSTATUS                        status;
    PFTP_GPT_ATTRIBUTE_REVERT_ENTRY p, q;
    ULONG                           n, i;

    status = FtpQueryRegistryRevertEntries(RootExtension, &p, &n);
    if (!NT_SUCCESS(status)) {
        return;
    }

    for (i = 0; i < n; i++) {
        if (MbrSignature) {
            if (MbrSignature == p[i].MbrSignature) {
                break;
            }
        } else {
            if (IsEqualGUID(*GptPartitionGuid, p[i].PartitionUniqueId)) {
                break;
            }
        }
    }

    if (i == n) {
        return;
    }

    if (i + 1 < n) {
        RtlMoveMemory(&p[i], &p[i + 1],
                      (n - i - 1)*sizeof(FTP_GPT_ATTRIBUTE_REVERT_ENTRY));
    }

    n--;

    if (n) {
        RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                              RootExtension->DiskPerfRegistryPath.Buffer,
                              REVERT_GPT_ATTRIBUTES_REGISTRY_NAME,
                              REG_BINARY, p,
                              n*sizeof(FTP_GPT_ATTRIBUTE_REVERT_ENTRY));
    } else {
        RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                               RootExtension->DiskPerfRegistryPath.Buffer,
                               REVERT_GPT_ATTRIBUTES_REGISTRY_NAME);
    }

    ExFreePool(p);

    return;
}

VOID
FtpApplyGptAttributes(
    IN  PVOLUME_EXTENSION   Extension,
    IN  ULONGLONG           GptAttributes
    )

{
    NTSTATUS    status;

    if (GptAttributes&GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY) {
        if (!Extension->IsReadOnly) {
            FtpZeroRefCallback(Extension, FtpVolumeReadOnlyCallback,
                               (PVOID) TRUE, TRUE);
        }
    } else {
        if (Extension->IsReadOnly) {
            FtpZeroRefCallback(Extension, FtpVolumeReadOnlyCallback,
                               (PVOID) FALSE, TRUE);
        }
    }

    if (GptAttributes&GPT_BASIC_DATA_ATTRIBUTE_HIDDEN) {
        if (!Extension->IsHidden) {
            Extension->IsHidden = TRUE;
            if (Extension->MountedDeviceInterfaceName.Buffer) {
                IoSetDeviceInterfaceState(
                        &Extension->MountedDeviceInterfaceName, FALSE);
            }
        }
    } else {
        if (Extension->IsHidden) {
            Extension->IsHidden = FALSE;

            if (!Extension->MountedDeviceInterfaceName.Buffer) {
                if (!Extension->IsStarted) {
                    return;
                }
                status = IoRegisterDeviceInterface(
                         Extension->DeviceObject,
                         &MOUNTDEV_MOUNTED_DEVICE_GUID, NULL,
                         &Extension->MountedDeviceInterfaceName);
                if (!NT_SUCCESS(status)) {
                    return;
                }
            }

            IoSetDeviceInterfaceState(
                    &Extension->MountedDeviceInterfaceName, TRUE);
        }
    }
}

VOID
FtpRevertGptAttributes(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    ULONG                           signature;
    PLIST_ENTRY                     l;
    PVOLUME_EXTENSION               extension;

    Extension->RevertOnCloseFileObject = NULL;

    if (!Extension->IsGpt) {

        diskInfo = Extension->Root->DiskInfoSet->FindLogicalDiskInformation(
                   Extension->WholeDiskPdo);
        if (diskInfo) {
            diskInfo->SetGptAttributes(Extension->GptAttributesToRevertTo);
        }

        signature = FtpQueryDiskSignatureCache(Extension);
        if (signature) {
            FtpDeleteGptAttributeRevertRecord(Extension->Root, signature,
                                              NULL);
        }

        return;
    }

    l = &Extension->Root->VolumeList;
    extension = Extension;

    for (;;) {

        FtpSetGptAttributesOnDisk(extension->TargetObject,
                                  Extension->GptAttributesToRevertTo);

        FtpDeleteGptAttributeRevertRecord(Extension->Root, 0,
                                          &extension->UniqueIdGuid);

        if (!Extension->ApplyToAllConnectedVolumes) {
            break;
        }

        for (l = l->Flink; l != &Extension->Root->VolumeList; l = l->Flink) {

            extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
            if (extension == Extension ||
                extension->WholeDiskPdo != Extension->WholeDiskPdo) {

                continue;
            }
        }

        if (l == &Extension->Root->VolumeList) {
            break;
        }
    }
}

NTSTATUS
FtpSetGptAttributes(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine sets the given GPT attributes on the given volume.  If the
    'RevertOnClose' bit is set then the GPT attributes will go back to
    their original state when the handle that this IOCTL was sent using
    gets an IRP_MJ_CLEANUP.  In order for this driver to get the CLEANUP, the
    handle must not be opened with read or write access but just
    read_attributes.  If the 'RevertOnClose' bit is set then the effect of
    the bit changes will not be applied to this volume and every effort will
    be made so that if the system crashes, the bits will be properly reverted.

    If the 'RevertOnClose' bit is clear then the effect of the bit changes will
    be immediate.  If READ_ONLY is set, for example, the volume will instantly
    become read only and all writes will fail.  The caller should normally
    only issue READ_ONLY request after issueing an
    IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES and before issueing the corresponding
    IOCTL_VOLSNAP_RELEASE_WRITES.  If HIDDEN is set, then the volume will
    take itself out of the list of volumes used by the MOUNTMGR.  Similarly,
    if the HIDDEN bit is cleared then the volume will put itself back in
    the list of volumes used by the MOUNTMGR.

    If the 'ApplyToAllConnectedVolumes' bit is set then the GPT attributes
    will be set for all volumes that are joined by a disk relation.  In
    the basic disk case, this means all partitions on the disk.  In the
    dynamic disk case, this means all volumes in the group.  This IOCTL will
    fail on MBR basic disks unless this is set because MBR basic disks do
    not support the GPT attributes per partition but per disk.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLUME_SET_GPT_ATTRIBUTES_INFORMATION  input = (PVOLUME_SET_GPT_ATTRIBUTES_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
    NTSTATUS                                status;
    UCHAR                                   partitionType;
    PFT_LOGICAL_DISK_INFORMATION            diskInfo;
    ULONGLONG                               gptAttributes;
    ULONG                                   signature;
    PLIST_ENTRY                             l;
    PVOLUME_EXTENSION                       extension;
    GUID                                    partitionTypeGuid;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLUME_SET_GPT_ATTRIBUTES_INFORMATION)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (input->Reserved1 || input->Reserved2 || !Extension->TargetObject) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!Extension->IsGpt) {
        if (!input->ApplyToAllConnectedVolumes) {
            return STATUS_INVALID_PARAMETER;
        }

        status = FtpQueryPartitionInformation(Extension->Root,
                                              Extension->TargetObject,
                                              NULL, NULL, NULL, &partitionType,
                                              NULL, NULL, NULL, NULL, NULL);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (!IsRecognizedPartition(partitionType)) {
            return STATUS_INVALID_PARAMETER;
        }

        diskInfo = Extension->Root->DiskInfoSet->
                   FindLogicalDiskInformation(Extension->WholeDiskPdo);
        if (!diskInfo) {
            return STATUS_INVALID_PARAMETER;
        }

        if (input->RevertOnClose) {
            gptAttributes = diskInfo->GetGptAttributes();
            Extension->GptAttributesToRevertTo = gptAttributes;
            Extension->RevertOnCloseFileObject = irpSp->FileObject;
            Extension->ApplyToAllConnectedVolumes =
                    input->ApplyToAllConnectedVolumes;
            signature = FtpQueryDiskSignatureCache(Extension);
            if (!signature) {
                Extension->RevertOnCloseFileObject = NULL;
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            status = FtpStoreGptAttributeRevertRecord(Extension->Root,
                                                      signature, NULL,
                                                      gptAttributes);
            if (!NT_SUCCESS(status)) {
                Extension->RevertOnCloseFileObject = NULL;
                return status;
            }
        }

        status = diskInfo->SetGptAttributes(input->GptAttributes);
        if (!NT_SUCCESS(status)) {
            if (input->RevertOnClose) {
                Extension->RevertOnCloseFileObject = NULL;
                FtpDeleteGptAttributeRevertRecord(Extension->Root, signature,
                                                  NULL);
            }
            return status;
        }

        if (!input->RevertOnClose) {

            FtpApplyGptAttributes(Extension, input->GptAttributes);
            Extension->MbrGptAttributes = input->GptAttributes;

            for (l = Extension->Root->VolumeList.Flink;
                 l != &Extension->Root->VolumeList; l = l->Flink) {

                extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
                if (extension == Extension ||
                    extension->WholeDiskPdo != Extension->WholeDiskPdo) {

                    continue;
                }

                status = FtpQueryPartitionInformation(extension->Root,
                                                      extension->TargetObject,
                                                      NULL, NULL, NULL,
                                                      &partitionType, NULL,
                                                      NULL, NULL, NULL, NULL);
                if (!NT_SUCCESS(status) ||
                    !IsRecognizedPartition(partitionType)) {

                    continue;
                }

                FtpApplyGptAttributes(extension, input->GptAttributes);
                extension->MbrGptAttributes = input->GptAttributes;
            }
        }

        return STATUS_SUCCESS;
    }

    l = &Extension->Root->VolumeList;
    extension = Extension;

    for (;;) {

        status = FtpQueryPartitionInformation(Extension->Root,
                                              extension->TargetObject,
                                              NULL, NULL, NULL, NULL, NULL,
                                              &partitionTypeGuid, NULL,
                                              NULL, &gptAttributes);
        if (!NT_SUCCESS(status)) {
            return status;
        }
        if (!IsEqualGUID(partitionTypeGuid, PARTITION_BASIC_DATA_GUID)) {
            if (extension == Extension) {
                return STATUS_INVALID_PARAMETER;
            }
            goto NextVolume;
        }

        if (input->RevertOnClose) {

            if (extension == Extension) {
                Extension->RevertOnCloseFileObject = irpSp->FileObject;
                Extension->GptAttributesToRevertTo = gptAttributes;
                Extension->ApplyToAllConnectedVolumes =
                        input->ApplyToAllConnectedVolumes;
            }

            status = FtpStoreGptAttributeRevertRecord(
                        Extension->Root, 0, &extension->UniqueIdGuid,
                        gptAttributes);
            if (!NT_SUCCESS(status)) {
                if (input->RevertOnClose) {
                    FtpRevertGptAttributes(Extension);
                }
                return status;
            }
        }

        status = FtpSetGptAttributesOnDisk(extension->TargetObject,
                                           input->GptAttributes);
        if (!NT_SUCCESS(status)) {
            if (input->RevertOnClose) {
                FtpRevertGptAttributes(Extension);
            }
            return status;
        }

        if (!input->RevertOnClose) {
            FtpApplyGptAttributes(extension, input->GptAttributes);
        }

NextVolume:
        if (!input->ApplyToAllConnectedVolumes) {
            break;
        }

        for (l = l->Flink; l != &Extension->Root->VolumeList; l = l->Flink) {

            extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
            if (extension == Extension ||
                extension->WholeDiskPdo != Extension->WholeDiskPdo) {

                continue;
            }
        }

        if (l == &Extension->Root->VolumeList) {
            break;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpGetGptAttributes(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the current GPT attributes definitions for the volume.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLUME_GET_GPT_ATTRIBUTES_INFORMATION  output = (PVOLUME_GET_GPT_ATTRIBUTES_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
    NTSTATUS                                status;
    UCHAR                                   partitionType;
    GUID                                    gptPartitionType;
    ULONGLONG                               gptAttributes;
    PFT_LOGICAL_DISK_INFORMATION            diskInfo;

    Irp->IoStatus.Information = sizeof(VOLUME_GET_GPT_ATTRIBUTES_INFORMATION);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }


    if (!Extension->TargetObject) {
        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    status = FtpQueryPartitionInformation(Extension->Root,
                                          Extension->TargetObject, NULL, NULL,
                                          NULL, &partitionType, NULL,
                                          &gptPartitionType, NULL, NULL,
                                          &gptAttributes);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 0;
        return status;
    }

    if (Extension->IsGpt) {
        if (!IsEqualGUID(gptPartitionType, PARTITION_BASIC_DATA_GUID)) {
            Irp->IoStatus.Information = 0;
            return STATUS_INVALID_PARAMETER;
        }
        output->GptAttributes = gptAttributes;
        return STATUS_SUCCESS;
    }

    if (!IsRecognizedPartition(partitionType)) {
        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    diskInfo = Extension->Root->DiskInfoSet->
               FindLogicalDiskInformation(Extension->WholeDiskPdo);
    if (!diskInfo) {
        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    gptAttributes = diskInfo->GetGptAttributes();
    output->GptAttributes = gptAttributes;

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryHiddenVolumes(
    IN  PROOT_EXTENSION RootExtension,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine returns a list of hidden volumes.  Hidden volumes are those
    that do not give PNP VolumeClassGuid notification.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

-*/

{
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLMGR_HIDDEN_VOLUMES  output;
    PLIST_ENTRY             l;
    PVOLUME_EXTENSION       extension;
    WCHAR                   buffer[100];
    UNICODE_STRING          name;
    PWCHAR                  buf;

    Irp->IoStatus.Information = FIELD_OFFSET(VOLMGR_HIDDEN_VOLUMES, MultiSz);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    output = (PVOLMGR_HIDDEN_VOLUMES) Irp->AssociatedIrp.SystemBuffer;

    output->MultiSzLength = sizeof(WCHAR);

    for (l = RootExtension->VolumeList.Flink; l != &RootExtension->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        if (!extension->IsHidden || !extension->IsInstalled) {
            continue;
        }

        swprintf(buffer, L"\\Device\\HarddiskVolume%d",
                 extension->VolumeNumber);
        RtlInitUnicodeString(&name, buffer);

        output->MultiSzLength += name.Length + sizeof(WCHAR);
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information + output->MultiSzLength) {

        return STATUS_BUFFER_OVERFLOW;
    }

    Irp->IoStatus.Information += output->MultiSzLength;
    buf = output->MultiSz;

    for (l = RootExtension->VolumeList.Flink; l != &RootExtension->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        if (!extension->IsHidden || !extension->IsInstalled) {
            continue;
        }

        swprintf(buf, L"\\Device\\HarddiskVolume%d", extension->VolumeNumber);
        RtlInitUnicodeString(&name, buf);

        buf += name.Length/sizeof(WCHAR) + 1;
    }

    *buf = 0;

    return STATUS_SUCCESS;
}

NTSTATUS
FtpCheckOfflineOwner(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    GUID*               guid = (GUID*) Irp->AssociatedIrp.SystemBuffer;

    if (!Extension->OfflineOwner) {
        return STATUS_SUCCESS;
    }

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(GUID)) {
        return STATUS_FILE_LOCK_CONFLICT;
    }

    if (!IsEqualGUID(*guid, *(Extension->OfflineOwner))) {
        return STATUS_FILE_LOCK_CONFLICT;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpAddOfflineOwner(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    GUID*               guid = (GUID*) Irp->AssociatedIrp.SystemBuffer;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(GUID)) {
        if (Extension->OfflineOwner) {
            ExFreePool(Extension->OfflineOwner);
            Extension->OfflineOwner = NULL;
        }
        return STATUS_SUCCESS;
    }

    if (!Extension->OfflineOwner) {
        Extension->OfflineOwner = (GUID*)
                                  ExAllocatePool(NonPagedPool, sizeof(GUID));
        if (!Extension->OfflineOwner) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    *(Extension->OfflineOwner) = *guid;

    return STATUS_SUCCESS;
}

NTSTATUS
FtDiskDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_DEVICE_CONTROL.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION                       extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    PROOT_EXTENSION                         rootExtension = extension->Root;
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                                status;
    PFT_VOLUME                              vol;
    PDISPATCH_TP                            packet;
    PVERIFY_INFORMATION                     verifyInfo;
    PSET_PARTITION_INFORMATION              setPartitionInfo;
    PSET_PARTITION_INFORMATION_EX           setPartitionInfoEx;
    PDEVICE_OBJECT                          targetObject;
    KEVENT                                  event;
    PPARTITION_INFORMATION                  partInfo;
    PPARTITION_INFORMATION_EX               partInfoEx;
    PDISK_GEOMETRY                          diskGeometry;
    PFT_LOGICAL_DISK_INFORMATION_SET        diskInfoSet;
    PFT_SET_INFORMATION                     setInfo;
    FT_LOGICAL_DISK_ID                      diskId;
    PFT_MIRROR_AND_SWP_STATE_INFORMATION    stateInfo;
    PFT_SPECIAL_READ                        specialRead;
    PFT_QUERY_LOGICAL_DISK_ID_OUTPUT        queryLogicalDiskIdOutput;
    PGET_LENGTH_INFORMATION                 lengthInfo;
    ULONG                                   cylinderSize;

    Irp->IoStatus.Information = 0;

    if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {

        switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

            case FT_CONFIGURE:
                status = STATUS_INVALID_PARAMETER;
                break;

            case FT_CREATE_LOGICAL_DISK:
                FtpAcquire(rootExtension);
                status = FtpCreateLogicalDisk(rootExtension, Irp);
                FtpRelease(rootExtension);
                break;

            case FT_BREAK_LOGICAL_DISK:
                FtpAcquire(rootExtension);
                status = FtpBreakLogicalDisk(rootExtension, Irp);
                FtpRelease(rootExtension);
                break;

            case FT_ENUMERATE_LOGICAL_DISKS:
                FtpAcquire(rootExtension);
                status = FtpEnumerateLogicalDisks(rootExtension, Irp);
                FtpRelease(rootExtension);
                break;

            case FT_QUERY_LOGICAL_DISK_INFORMATION:
                FtpAcquire(rootExtension);
                status = FtpQueryLogicalDiskInformation(rootExtension, Irp);
                FtpRelease(rootExtension);
                break;

            case FT_ORPHAN_LOGICAL_DISK_MEMBER:
                FtpAcquire(rootExtension);
                status = FtpOrphanLogicalDiskMember(rootExtension, Irp);
                FtpRelease(rootExtension);
                break;

            case FT_REPLACE_LOGICAL_DISK_MEMBER:
                FtpAcquire(rootExtension);
                status = FtpReplaceLogicalDiskMember(rootExtension, Irp);
                FtpRelease(rootExtension);
                break;

            case FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK:
                FtpAcquire(rootExtension);
                status = FtpQueryNtDeviceNameForLogicalDisk(rootExtension, Irp);
                FtpRelease(rootExtension);
                break;

            case FT_INITIALIZE_LOGICAL_DISK:
                FtpAcquire(rootExtension);
                status = FtpInitializeLogicalDisk(rootExtension, Irp);
                FtpRelease(rootExtension);
                break;

            case FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK:
                FtpAcquire(rootExtension);
                status = FtpQueryDriveLetterForLogicalDisk(rootExtension, Irp);
                FtpRelease(rootExtension);
                break;

            case FT_CHECK_IO:
                FtpAcquire(rootExtension);
                status = FtpCheckIo(rootExtension, Irp);
                FtpRelease(rootExtension);
                break;

            case FT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK:
                FtpAcquire(rootExtension);
                status = FtpSetDriveLetterForLogicalDisk(rootExtension, Irp);
                FtpRelease(rootExtension);
                break;

            case FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION:
                FtpAcquire(rootExtension);
                status = FtpQueryNtDeviceNameForPartition(rootExtension, Irp);
                FtpRelease(rootExtension);
                break;

            case FT_CHANGE_NOTIFY:
                FtpAcquire(rootExtension);
                status = FtpChangeNotify(rootExtension, Irp);
                FtpRelease(rootExtension);
                break;

            case FT_STOP_SYNC_OPERATIONS:
                FtpAcquire(rootExtension);
                status = FtpStopSyncOperations(rootExtension, Irp);
                FtpRelease(rootExtension);
                break;

            case IOCTL_VOLMGR_QUERY_HIDDEN_VOLUMES:
                KeEnterCriticalRegion();
                FtpAcquire(rootExtension);
                status = FtpQueryHiddenVolumes(rootExtension, Irp);
                FtpRelease(rootExtension);
                KeLeaveCriticalRegion();
                break;

            default:
                status = STATUS_INVALID_PARAMETER;
                break;

        }

        if (status != STATUS_PENDING) {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }

        return status;
    }

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpQueryUniqueId(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_MOUNTDEV_QUERY_STABLE_GUID:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpQueryStableGuid(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY:
            FtpAcquire(extension->Root);
            status = FtpUniqueIdChangeNotify(extension, Irp);
            FtpRelease(extension->Root);
            if (status != STATUS_PENDING) {
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            return status;

        case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:
            status = FtpAllSystemsGo(extension, Irp, FALSE, FALSE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpQueryDeviceName(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:
            FtpAcquire(extension->Root);
            status = FtpQuerySuggestedLinkName(extension, Irp);
            FtpRelease(extension->Root);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_MOUNTDEV_LINK_CREATED:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, TRUE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpLinkCreated(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_MOUNTDEV_LINK_DELETED:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, TRUE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpLinkDeleted(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS:
        case IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS_ADMIN:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpGetVolumeDiskExtents(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE:
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_SUCCESS;

        case IOCTL_VOLUME_ONLINE:
            FtpAcquire(extension->Root);

            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                FtpRelease(extension->Root);
                return status;
            }
            if (!NT_SUCCESS(status)) {
                FtpRelease(extension->Root);
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return status;
            }

            status = FtpCheckOfflineOwner(extension, Irp);
            if (!NT_SUCCESS(status)) {
                FtpDecrementRefCount(extension);
                FtpRelease(extension->Root);
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return status;
            }

            if (extension->FtVolume) {
                FtpPropogateRegistryState(extension, extension->FtVolume);
            }

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            FtpZeroRefCallback(extension, FtpVolumeOnlineCallback, &event,
                               TRUE);
            FtpDecrementRefCount(extension);
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

            FtpRelease(extension->Root);

            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_SUCCESS;

        case IOCTL_VOLUME_OFFLINE:
            FtpAcquire(extension->Root);

            status = FtpAddOfflineOwner(extension, Irp);
            if (!NT_SUCCESS(status)) {
                FtpRelease(extension->Root);
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return status;
            }

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            FtpZeroRefCallback(extension, FtpVolumeOfflineCallback, &event,
                               TRUE);
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

            FtpRelease(extension->Root);

            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_SUCCESS;

        case IOCTL_VOLUME_IS_OFFLINE:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                if (!extension->IsOffline) {
                    status = STATUS_UNSUCCESSFUL;
                }
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_IS_IO_CAPABLE:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                if (!extension->TargetObject &&
                    !extension->FtVolume->IsComplete(TRUE)) {

                    status = STATUS_UNSUCCESSFUL;
                }
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_QUERY_FAILOVER_SET:
            KeEnterCriticalRegion();
            FtpAcquire(extension->Root);
            status = FtpQueryFailoverSet(extension, Irp);
            FtpRelease(extension->Root);
            KeLeaveCriticalRegion();
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_QUERY_VOLUME_NUMBER:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpQueryVolumeNumber(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_LOGICAL_TO_PHYSICAL:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpLogicalToPhysical(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_PHYSICAL_TO_LOGICAL:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpPhysicalToLogical(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_IS_PARTITION:
            status = FtpAllSystemsGo(extension, Irp, TRUE, TRUE, TRUE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpIsPartition(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_SET_GPT_ATTRIBUTES:
            status = FtpCheckSecurity(extension, Irp);
            if (!NT_SUCCESS(status)) {
                break;
            }
            FtpAcquire(extension->Root);
            status = FtpSetGptAttributes(extension, Irp);
            FtpRelease(extension->Root);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_GET_GPT_ATTRIBUTES:
            KeEnterCriticalRegion();
            FtpAcquire(extension->Root);
            status = FtpGetGptAttributes(extension, Irp);
            FtpRelease(extension->Root);
            KeLeaveCriticalRegion();
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_PARTMGR_EJECT_VOLUME_MANAGERS:
        case IOCTL_DISK_COPY_DATA:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case IOCTL_DISK_GET_PARTITION_INFO:
        case IOCTL_DISK_GET_PARTITION_INFO_EX:
        case IOCTL_STORAGE_GET_DEVICE_NUMBER:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            break;

        case IOCTL_DISK_IS_WRITABLE:
            if (extension->IsReadOnly) {
                status = STATUS_MEDIA_WRITE_PROTECTED;
            } else {
                status = FtpAllSystemsGo(extension, Irp, TRUE, TRUE, TRUE);
            }
            break;

        case IOCTL_DISK_PERFORMANCE:
            //
            // Verify user buffer is large enough for the performance data.
            //

            status = STATUS_SUCCESS;
            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(DISK_PERFORMANCE)) {

                //
                // Indicate unsuccessful status and no data transferred.
                //

                status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = 0;
            }
            else if (!(extension->CountersEnabled)) {
                if (!FtQueryEnableAlways(DeviceObject)) {
                    status = STATUS_UNSUCCESSFUL;
                    Irp->IoStatus.Information = 0;
                }
            }
            if (status == STATUS_SUCCESS) {
                extension->Root->PmWmiCounterLibContext.
                PmWmiCounterQuery(extension->PmWmiCounterContext,
                                  (PDISK_PERFORMANCE) Irp->AssociatedIrp.SystemBuffer,
                                  L"FTDISK  ",
                                  extension->VolumeNumber);
                Irp->IoStatus.Information = sizeof(DISK_PERFORMANCE);
            }

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_DISK_PERFORMANCE_OFF:
            //
            // Turns off counting
            //
            if (extension->CountersEnabled) {
                if (InterlockedCompareExchange(&extension->EnableAlways, 0, 1) == 1) {
                    if (!(extension->Root->PmWmiCounterLibContext.
                          PmWmiCounterDisable(&extension->PmWmiCounterContext, FALSE, FALSE))) {
                        extension->CountersEnabled = FALSE;
                    }
                }
            }
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_SUCCESS;

        default:
            status = FtpAllSystemsGo(extension, Irp, TRUE, TRUE, TRUE);
            break;

    }

    if (status == STATUS_PENDING) {
        return status;
    }
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (extension->TargetObject) {
        if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
            FT_CREATE_PARTITION_LOGICAL_DISK) {

            FtpDecrementRefCount(extension);

            Irp->IoStatus.Information = 0;

            FtpAcquire(extension->Root);

            if (!extension->Root->FtCodeLocked) {
                MmLockPagableCodeSection(FtpComputeParity);
                status = FtpStartSystemThread(extension->Root);
                if (!NT_SUCCESS(status)) {
                    FtpRelease(extension->Root);
                    Irp->IoStatus.Status = status;
                    IoCompleteRequest(Irp, IO_NO_INCREMENT);
                    return status;
                }
                extension->Root->FtCodeLocked = TRUE;
            }
            status = FtpCreatePartitionLogicalDisk(extension, Irp);

            FtpRelease(extension->Root);

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;
        }

        if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_DISK_UPDATE_PROPERTIES) {

            targetObject = extension->TargetObject;
            ObReferenceObject(targetObject);

            FtpDecrementRefCount(extension);

            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(targetObject, Irp);

            ObDereferenceObject(targetObject);

            return status;
        }

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, FtpRefCountCompletionRoutine,
                               extension, TRUE, TRUE, TRUE);
        IoMarkIrpPending(Irp);

        IoCallDriver(extension->TargetObject, Irp);

        return STATUS_PENDING;
    }

    vol = extension->FtVolume;
    ASSERT(vol);

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_DISK_GET_DRIVE_LAYOUT:
        case IOCTL_DISK_GET_DRIVE_LAYOUT_EX:
        case IOCTL_SCSI_GET_ADDRESS:
        case IOCTL_SCSI_GET_DUMP_POINTERS:
        case IOCTL_SCSI_FREE_DUMP_POINTERS:
            if (FtpIsReplicatedPartition(vol)) {
                targetObject = vol->GetLeftmostPartitionObject();
                ASSERT(targetObject);

                KeInitializeEvent(&event, NotificationEvent, FALSE);
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp, FtpSignalCompletion, &event, TRUE,
                                       TRUE, TRUE);
                IoCallDriver(targetObject, Irp);
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);

                status = Irp->IoStatus.Status;

            } else {
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;

        case IOCTL_DISK_VERIFY:

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(VERIFY_INFORMATION)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            packet = new DISPATCH_TP;
            if (!packet) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            verifyInfo = (PVERIFY_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

            if (verifyInfo->StartingOffset.QuadPart < 0) {
                delete packet;
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            packet->Mdl = NULL;
            packet->Offset = verifyInfo->StartingOffset.QuadPart;
            packet->Length = verifyInfo->Length;
            packet->CompletionRoutine = FtpReadWriteCompletionRoutine;
            packet->TargetVolume = vol;
            packet->Thread = Irp->Tail.Overlay.Thread;
            packet->IrpFlags = irpSp->Flags;
            packet->ReadPacket = TRUE;
            packet->Irp = Irp;
            packet->Extension = extension;

            IoMarkIrpPending(Irp);

            TRANSFER(packet);

            return STATUS_PENDING;

        case IOCTL_DISK_SET_PARTITION_INFO:

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SET_PARTITION_INFORMATION)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            setPartitionInfo = (PSET_PARTITION_INFORMATION)
                               Irp->AssociatedIrp.SystemBuffer;

            status = vol->SetPartitionType(setPartitionInfo->PartitionType);
            break;

        case IOCTL_DISK_SET_PARTITION_INFO_EX:

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SET_PARTITION_INFORMATION_EX)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            setPartitionInfoEx = (PSET_PARTITION_INFORMATION_EX)
                                 Irp->AssociatedIrp.SystemBuffer;
            if (setPartitionInfoEx->PartitionStyle != PARTITION_STYLE_MBR) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            status = vol->SetPartitionType(
                     setPartitionInfoEx->Mbr.PartitionType);
            break;

        case IOCTL_DISK_GET_PARTITION_INFO_EX:

            if (extension->IsGpt) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Fall through.
            //

        case IOCTL_DISK_GET_PARTITION_INFO:

            targetObject = vol->GetLeftmostPartitionObject();
            if (!targetObject) {
                status = STATUS_NO_SUCH_DEVICE;
                break;
            }

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp, FtpSignalCompletion, &event, TRUE,
                                   TRUE, TRUE);
            IoCallDriver(targetObject, Irp);
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

            status = Irp->IoStatus.Status;
            if (!NT_SUCCESS(status)) {
                break;
            }

            if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_DISK_GET_PARTITION_INFO) {

                partInfo = (PPARTITION_INFORMATION)
                           Irp->AssociatedIrp.SystemBuffer;
                partInfo->PartitionLength.QuadPart = vol->QueryVolumeSize();
                break;
            }

            partInfoEx = (PPARTITION_INFORMATION_EX)
                         Irp->AssociatedIrp.SystemBuffer;
            if (partInfoEx->PartitionStyle != PARTITION_STYLE_MBR) {
                ASSERT(FALSE);
                status = STATUS_INVALID_PARAMETER;
                break;
            }
            partInfoEx->PartitionLength.QuadPart = vol->QueryVolumeSize();
            break;

        case IOCTL_DISK_GET_LENGTH_INFO:

            Irp->IoStatus.Information = sizeof(GET_LENGTH_INFORMATION);

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                Irp->IoStatus.Information) {

                Irp->IoStatus.Information = 0;
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            lengthInfo = (PGET_LENGTH_INFORMATION)
                         Irp->AssociatedIrp.SystemBuffer;

            lengthInfo->Length.QuadPart = vol->QueryVolumeSize();
            status = STATUS_SUCCESS;
            break;

        case IOCTL_DISK_GET_DRIVE_GEOMETRY:

            targetObject = vol->GetLeftmostPartitionObject();
            if (!targetObject) {
                status = STATUS_NO_SUCH_DEVICE;
                break;
            }

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp, FtpSignalCompletion, &event, TRUE,
                                   TRUE, TRUE);
            IoCallDriver(targetObject, Irp);
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

            status = Irp->IoStatus.Status;
            if (!NT_SUCCESS(status)) {
                break;
            }

            diskGeometry = (PDISK_GEOMETRY) Irp->AssociatedIrp.SystemBuffer;
            diskGeometry->BytesPerSector = vol->QuerySectorSize();
            cylinderSize = diskGeometry->TracksPerCylinder*
                           diskGeometry->SectorsPerTrack*
                           diskGeometry->BytesPerSector;
            if (cylinderSize) {
                diskGeometry->Cylinders.QuadPart =
                        vol->QueryVolumeSize()/cylinderSize;
            }
            break;

        case IOCTL_DISK_CHECK_VERIFY:
            status = STATUS_SUCCESS;
            break;

        case FT_QUERY_SET_STATE:

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(FT_SET_INFORMATION)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            KeEnterCriticalRegion();
            FtpAcquire(rootExtension);
            diskInfoSet = rootExtension->DiskInfoSet;
            setInfo = (PFT_SET_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
            diskId = vol->QueryLogicalDiskId();
            setInfo->NumberOfMembers =
                    diskInfoSet->QueryNumberOfMembersInLogicalDisk(diskId);
            switch (diskInfoSet->QueryLogicalDiskType(diskId)) {
                case FtVolumeSet:
                    setInfo->Type = VolumeSet;
                    break;

                case FtStripeSet:
                    setInfo->Type = Stripe;
                    break;

                case FtMirrorSet:
                    setInfo->Type = Mirror;
                    break;

                case FtStripeSetWithParity:
                    setInfo->Type = StripeWithParity;
                    break;

                default:
                    setInfo->Type = NotAnFtMember;
                    break;

            }

            stateInfo = (PFT_MIRROR_AND_SWP_STATE_INFORMATION)
                        diskInfoSet->GetStateInformation(diskId);
            if (stateInfo) {
                if (stateInfo->IsInitializing) {
                    setInfo->SetState = FtInitializing;
                } else {
                    switch (stateInfo->UnhealthyMemberState) {
                        case FtMemberHealthy:
                            setInfo->SetState = FtStateOk;
                            break;

                        case FtMemberRegenerating:
                            setInfo->SetState = FtRegenerating;
                            break;

                        case FtMemberOrphaned:
                            setInfo->SetState = FtHasOrphan;
                            break;

                    }
                }
            } else {
                setInfo->SetState = FtStateOk;
            }
            FtpRelease(rootExtension);
            KeLeaveCriticalRegion();

            Irp->IoStatus.Information = sizeof(FT_SET_INFORMATION);
            status = STATUS_SUCCESS;
            break;

        case FT_SECONDARY_READ:
        case FT_PRIMARY_READ:

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(FT_SPECIAL_READ)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            specialRead = (PFT_SPECIAL_READ) Irp->AssociatedIrp.SystemBuffer;
            if (specialRead->ByteOffset.QuadPart <= 0) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            if (specialRead->Length >
                irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            packet = new DISPATCH_TP;
            if (!packet) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            packet->Mdl = Irp->MdlAddress;
            packet->Offset = specialRead->ByteOffset.QuadPart;
            packet->Length = specialRead->Length;
            packet->CompletionRoutine = FtpReadWriteCompletionRoutine;
            packet->TargetVolume = vol;
            packet->Thread = Irp->Tail.Overlay.Thread;
            packet->IrpFlags = irpSp->Flags;
            packet->ReadPacket = TRUE;
            if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                FT_SECONDARY_READ) {

                packet->SpecialRead = TP_SPECIAL_READ_SECONDARY;
            } else {
                packet->SpecialRead = TP_SPECIAL_READ_PRIMARY;
            }
            packet->Irp = Irp;
            packet->Extension = extension;

            IoMarkIrpPending(Irp);

            TRANSFER(packet);

            return STATUS_PENDING;

        case FT_BALANCED_READ_MODE:
        case FT_SEQUENTIAL_WRITE_MODE:
        case FT_PARALLEL_WRITE_MODE:

            status = STATUS_SUCCESS;
            break;

        case FT_QUERY_LOGICAL_DISK_ID:

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(FT_QUERY_LOGICAL_DISK_ID_OUTPUT)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            queryLogicalDiskIdOutput = (PFT_QUERY_LOGICAL_DISK_ID_OUTPUT)
                                       Irp->AssociatedIrp.SystemBuffer;

            queryLogicalDiskIdOutput->RootLogicalDiskId =
                    vol->QueryLogicalDiskId();

            Irp->IoStatus.Information = sizeof(FT_QUERY_LOGICAL_DISK_ID_OUTPUT);
            status = STATUS_SUCCESS;
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

    }

    FtpDecrementRefCount(extension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
FtpCreatePartitionLogicalDiskHelper(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN      LONGLONG            PartitionSize,
    OUT     PFT_LOGICAL_DISK_ID NewLogicalDiskId
    )

{
    PMOUNTDEV_UNIQUE_ID                 newUniqueId;
    UCHAR                               newUniqueIdBuffer[UNIQUE_ID_MAX_BUFFER_SIZE];
    NTSTATUS                            status;
    ULONG                               diskNumber;
    LONGLONG                            offset;
    PFT_LOGICAL_DISK_INFORMATION_SET    diskInfoSet;
    FT_LOGICAL_DISK_ID                  diskId;
    PPARTITION                          partition;
    UCHAR                               type;
    SET_TARGET_CONTEXT                  context;

    if (Extension->IsGpt) {
        return STATUS_INVALID_PARAMETER;
    }

    newUniqueId = (PMOUNTDEV_UNIQUE_ID) newUniqueIdBuffer;

    status = FtpQueryPartitionInformation(Extension->Root,
                                          Extension->TargetObject, &diskNumber,
                                          &offset, NULL, NULL, NULL, NULL,
                                          NULL, NULL, NULL);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    diskInfoSet = Extension->Root->DiskInfoSet;
    status = diskInfoSet->CreatePartitionLogicalDisk(diskNumber, offset,
                                                     PartitionSize, &diskId);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    partition = new PARTITION;
    if (!partition) {
        diskInfoSet->BreakLogicalDisk(diskId);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    status = partition->Initialize(Extension->Root, diskId,
                                   Extension->TargetObject,
                                   Extension->WholeDiskPdo);
    if (!NT_SUCCESS(status)) {
        if (!InterlockedDecrement(&partition->_refCount)) {
            delete partition;
        }
        diskInfoSet->BreakLogicalDisk(diskId);
        return status;
    }

    type = partition->QueryPartitionType();
    if (!type) {
        if (!InterlockedDecrement(&partition->_refCount)) {
            delete partition;
        }
        diskInfoSet->BreakLogicalDisk(diskId);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = partition->SetPartitionType(type);
    if (!NT_SUCCESS(status)) {
        if (!InterlockedDecrement(&partition->_refCount)) {
            delete partition;
        }
        diskInfoSet->BreakLogicalDisk(diskId);
        return status;
    }

    KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
    context.TargetObject = NULL;
    context.FtVolume = partition;
    context.WholeDiskPdo = NULL;
    FtpZeroRefCallback(Extension, FtpSetTargetCallback, &context, TRUE);
    KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                          NULL);

    FtpQueryUniqueIdBuffer(Extension, newUniqueId->UniqueId,
                           &newUniqueId->UniqueIdLength);
    FtpUniqueIdNotify(Extension, newUniqueId);

    *NewLogicalDiskId = diskId;

    FtpNotify(Extension->Root, Extension);

    return status;
}

NTSTATUS
FtpInsertMirror(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      PFT_LOGICAL_DISK_ID ArrayOfMembers,
    OUT     PFT_LOGICAL_DISK_ID NewLogicalDiskId
    )

{
    PFT_LOGICAL_DISK_INFORMATION_SET        diskInfoSet;
    ULONG                                   i;
    NTSTATUS                                status;
    PVOLUME_EXTENSION                       extension, shadowExtension;
    PFT_VOLUME                              topVol, vol, shadowVol, parentVol;
    FT_LOGICAL_DISK_ID                      fakeDiskId, mirrorDiskId, parentDiskId;
    FT_LOGICAL_DISK_ID                      mirrorMembers[2];
    FT_MIRROR_SET_CONFIGURATION_INFORMATION config;
    FT_MIRROR_AND_SWP_STATE_INFORMATION     state;
    USHORT                                  n, j;
    PMIRROR                                 mirror;
    PFT_VOLUME*                             arrayOfVolumes;
    KEVENT                                  event;
    INSERT_MEMBER_CONTEXT                   context;
    UCHAR                                   newUniqueIdBuffer[UNIQUE_ID_MAX_BUFFER_SIZE];
    PMOUNTDEV_UNIQUE_ID                     newUniqueId;
    PFT_LOGICAL_DISK_DESCRIPTION            p;
    WCHAR                                   deviceNameBuffer[64];
    UNICODE_STRING                          deviceName;
    SET_TARGET_CONTEXT                      setContext;

    diskInfoSet = RootExtension->DiskInfoSet;
    for (i = 0; i < 100; i++) {
        status = diskInfoSet->CreatePartitionLogicalDisk(i, 0, 0, &fakeDiskId);
        if (NT_SUCCESS(status)) {
            break;
        }
    }

    if (i == 100) {
        return status;
    }

    extension = FtpFindExtensionCoveringDiskId(RootExtension,
                                               ArrayOfMembers[0]);
    ASSERT(extension);

    topVol = extension->FtVolume;
    vol = topVol->GetContainedLogicalDisk(ArrayOfMembers[0]);

    shadowExtension = FtpFindExtension(RootExtension, ArrayOfMembers[1]);
    ASSERT(shadowExtension);
    shadowVol = shadowExtension->FtVolume;

    if (shadowVol->QueryVolumeSize() < vol->QueryVolumeSize()) {
        return STATUS_INVALID_PARAMETER;
    }

    mirrorMembers[0] = fakeDiskId;
    mirrorMembers[1] = ArrayOfMembers[1];
    config.MemberSize = vol->QueryVolumeSize();
    state.IsInitializing = FALSE;
    state.IsDirty = TRUE;
    state.UnhealthyMemberNumber = 1;
    state.UnhealthyMemberState = FtMemberRegenerating;

    status = diskInfoSet->AddNewLogicalDisk(FtMirrorSet, 2, mirrorMembers,
                                            sizeof(config), &config,
                                            sizeof(state), &state,
                                            &mirrorDiskId);
    if (!NT_SUCCESS(status)) {
        diskInfoSet->BreakLogicalDisk(fakeDiskId);
        return status;
    }

    parentVol = topVol->GetParentLogicalDisk(vol);
    if (!parentVol) {
        diskInfoSet->BreakLogicalDisk(mirrorDiskId);
        diskInfoSet->BreakLogicalDisk(fakeDiskId);
        return STATUS_INVALID_PARAMETER;
    }

    n = parentVol->QueryNumberOfMembers();
    for (j = 0; j < n; j++) {
        if (parentVol->GetMember(j) == vol) {
            break;
        }
    }

    status = diskInfoSet->ReplaceLogicalDiskMember(
             parentVol->QueryLogicalDiskId(), j, mirrorDiskId, &parentDiskId);
    if (!NT_SUCCESS(status)) {
        diskInfoSet->BreakLogicalDisk(mirrorDiskId);
        diskInfoSet->BreakLogicalDisk(fakeDiskId);
        return status;
    }

    status = diskInfoSet->ReplaceLogicalDiskMember(
             mirrorDiskId, 0, ArrayOfMembers[0], &mirrorDiskId);
    if (!NT_SUCCESS(status)) {
        diskInfoSet->ReplaceLogicalDiskMember(
                 parentDiskId, j, ArrayOfMembers[0], &parentDiskId);
        diskInfoSet->BreakLogicalDisk(mirrorDiskId);
        diskInfoSet->BreakLogicalDisk(fakeDiskId);
        return status;
    }

    *NewLogicalDiskId = mirrorDiskId;
    diskInfoSet->BreakLogicalDisk(fakeDiskId);

    arrayOfVolumes = (PFT_VOLUME*) ExAllocatePool(NonPagedPool, 2*sizeof(PFT_VOLUME));
    if (!arrayOfVolumes) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    mirror = new MIRROR;
    if (!mirror) {
        ExFreePool(arrayOfVolumes);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    arrayOfVolumes[0] = vol;
    arrayOfVolumes[1] = shadowVol;

    status = mirror->Initialize(RootExtension, mirrorDiskId, arrayOfVolumes, 2,
                                &config, &state);
    if (!NT_SUCCESS(status)) {
        if (!InterlockedDecrement(&mirror->_refCount)) {
            delete mirror;
        }
        return status;
    }

    KeInitializeEvent(&setContext.Event, NotificationEvent, FALSE);
    setContext.TargetObject = NULL;
    setContext.FtVolume = NULL;
    setContext.WholeDiskPdo = NULL;
    FtpZeroRefCallback(shadowExtension, FtpSetTargetCallback, &setContext,
                       TRUE);
    KeWaitForSingleObject(&setContext.Event, Executive, KernelMode, FALSE,
                          NULL);

    RemoveEntryList(&shadowExtension->ListEntry);
    InsertTailList(&RootExtension->DeadVolumeList,
                   &shadowExtension->ListEntry);
    FtpDeleteMountPoints(shadowExtension);
    FtpCleanupVolumeExtension(shadowExtension);

    KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
    context.Parent = parentVol;
    context.MemberNumber = j;
    context.Member = mirror;
    FtpZeroRefCallback(extension, FtpInsertMemberCallback, &context, TRUE);
    KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE, NULL);

    parentVol = mirror;
    while (p = diskInfoSet->GetParentLogicalDiskDescription(
           parentVol->QueryLogicalDiskId())) {

        if (parentVol = topVol->GetParentLogicalDisk(parentVol)) {
            parentVol->SetLogicalDiskId(p->LogicalDiskId);
        }
    }

    swprintf(deviceNameBuffer, L"\\Device\\HarddiskVolume%d", extension->VolumeNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);
    mirror->CreateLegacyNameLinks(&deviceName);

    newUniqueId = (PMOUNTDEV_UNIQUE_ID) newUniqueIdBuffer;
    FtpQueryUniqueIdBuffer(extension, newUniqueId->UniqueId,
                           &newUniqueId->UniqueIdLength);

    FtpUniqueIdNotify(extension, newUniqueId);

    IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);
    FtpNotify(RootExtension, extension);

    return STATUS_SUCCESS;
}

VOID
FtpBootDriverReinitialization(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PVOID           RootExtension,
    IN  ULONG           Count
    )

/*++

Routine Description:

    This routine is called after all of the boot drivers are loaded and it
    checks to make sure that we did not boot off of the stale half of a
    mirror.

Arguments:

    DriverObject    - Supplies the drive object.

    RootExtension   - Supplies the root extension.

    Count           - Supplies the count.

Return Value:

    None.

--*/

{
    PROOT_EXTENSION         rootExtension = (PROOT_EXTENSION) RootExtension;
    NTSTATUS                status;
    BOOTDISK_INFORMATION    bootInfo;
    BOOLEAN                 onlyOne, skipBoot, skipSystem;
    PLIST_ENTRY             l;
    PVOLUME_EXTENSION       extension;
    PFT_VOLUME              vol, partition;
    FT_MEMBER_STATE         state;

    status = IoGetBootDiskInformation(&bootInfo, sizeof(bootInfo));
    if (!NT_SUCCESS(status)) {
        return;
    }

    if (bootInfo.BootDeviceSignature == bootInfo.SystemDeviceSignature &&
        bootInfo.BootPartitionOffset == bootInfo.SystemPartitionOffset) {

        onlyOne = TRUE;
    } else {
        onlyOne = FALSE;
    }

    if (!bootInfo.BootDeviceSignature || !bootInfo.BootPartitionOffset) {
        skipBoot = TRUE;
    } else {
        skipBoot = FALSE;
    }

    if (!bootInfo.SystemDeviceSignature || !bootInfo.SystemPartitionOffset) {
        skipSystem = TRUE;
    } else {
        skipSystem = FALSE;
    }

    if (skipBoot && skipSystem) {
        return;
    }

    FtpAcquire(rootExtension);

    for (l = rootExtension->VolumeList.Flink;
         l != &rootExtension->VolumeList; l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        vol = extension->FtVolume;
        if (!vol) {
            continue;
        }

        if (!skipBoot) {
            partition = vol->GetContainedLogicalDisk(
                        bootInfo.BootDeviceSignature,
                        bootInfo.BootPartitionOffset);
            if (partition) {
                if (vol->QueryVolumeState(partition, &state) &&
                    state != FtMemberHealthy) {

                    KeBugCheckEx(FTDISK_INTERNAL_ERROR,
                                 (ULONG_PTR) extension,
                                 bootInfo.BootDeviceSignature,
                                 (ULONG_PTR) bootInfo.BootPartitionOffset,
                                 state);
                }
            }
        }

        if (onlyOne) {
            continue;
        }

        if (!skipSystem) {
            partition = vol->GetContainedLogicalDisk(
                        bootInfo.SystemDeviceSignature,
                        bootInfo.SystemPartitionOffset);
            if (partition) {
                if (vol->QueryVolumeState(partition, &state) &&
                    state != FtMemberHealthy) {

                    KeBugCheckEx(FTDISK_INTERNAL_ERROR,
                                 (ULONG_PTR) extension,
                                 bootInfo.BootDeviceSignature,
                                 (ULONG_PTR) bootInfo.BootPartitionOffset,
                                 state);
                }
            }
        }
    }

    rootExtension->PastBootReinitialize = TRUE;

    FtpRelease(rootExtension);
}

NTSTATUS
FtpQuerySystemVolumeNameQueryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine queries the unique id for the given value.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Returns the system volume name.

    EntryContext    - Not used.

Return Value:

    NTSTATUS

--*/

{
    PUNICODE_STRING systemVolumeName = (PUNICODE_STRING) Context;
    UNICODE_STRING  string;

    if (ValueType != REG_SZ) {
        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString(&string, (PWSTR) ValueData);

    systemVolumeName->Length = string.Length;
    systemVolumeName->MaximumLength = systemVolumeName->Length + sizeof(WCHAR);
    systemVolumeName->Buffer = (PWSTR) ExAllocatePool(PagedPool,
                                              systemVolumeName->MaximumLength);
    if (!systemVolumeName->Buffer) {
        return STATUS_SUCCESS;
    }

    RtlCopyMemory(systemVolumeName->Buffer, ValueData,
                  systemVolumeName->Length);
    systemVolumeName->Buffer[systemVolumeName->Length/sizeof(WCHAR)] = 0;

    return STATUS_SUCCESS;
}

VOID
FtpDriverReinitialization(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PVOID           RootExtension,
    IN  ULONG           Count
    )

/*++

Routine Description:

    This routine is called after all of the disk drivers are loaded

Arguments:

    DriverObject    - Supplies the drive object.

    RootExtension   - Supplies the root extension.

    Count           - Supplies the count.

Return Value:

    None.

--*/

{
    PROOT_EXTENSION             rootExtension = (PROOT_EXTENSION) RootExtension;
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    UNICODE_STRING              systemVolumeName, s;
    PLIST_ENTRY                 l;
    PVOLUME_EXTENSION           extension;
    WCHAR                       buffer[100];

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = FtpQuerySystemVolumeNameQueryRoutine;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = L"SystemPartition";

    systemVolumeName.Buffer = NULL;

    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                           L"\\Registry\\Machine\\System\\Setup",
                           queryTable, &systemVolumeName, NULL);

    FtpAcquire(rootExtension);

    for (l = rootExtension->VolumeList.Flink;
         l != &rootExtension->VolumeList; l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

        if (!extension->IsEspType) {
            continue;
        }

        swprintf(buffer, L"\\Device\\HarddiskVolume%d", extension->VolumeNumber);
        RtlInitUnicodeString(&s, buffer);

        if (systemVolumeName.Buffer &&
            RtlEqualUnicodeString(&s, &systemVolumeName, TRUE)) {

            rootExtension->ESPUniquePartitionGUID = extension->UniqueIdGuid;
        }

        FtpApplyESPProtection(&s);
    }

    rootExtension->PastReinitialize = TRUE;

    FtpRelease(rootExtension);

    if (systemVolumeName.Buffer) {
        ExFreePool(systemVolumeName.Buffer);
    }
}

VOID
FtpCopyStateToRegistry(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  PVOID               LogicalDiskState,
    IN  USHORT              LogicalDiskStateSize
    )

/*++

Routine Description:

    This routine writes the given state to the registry so that it can
    be retrieved to solve some of the so called split brain problems.

Arguments:

    LogicalDiskId           - Supplies the logical disk id.

    LogicalDiskState        - Supplies the logical disk state.

    LogicalDiskStateSize    - Supplies the logical disk state size.

Return Value:

    None.

--*/

{
    WCHAR   registryName[50];

    RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, FT_STATE_REGISTRY_KEY);

    swprintf(registryName, L"%I64X", LogicalDiskId);

    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, FT_STATE_REGISTRY_KEY,
                          registryName, REG_BINARY, LogicalDiskState,
                          LogicalDiskStateSize);
}

NTSTATUS
FtpQueryStateFromRegistryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine fetches the binary data for the given regitry entry.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Returns the registry data.

    EntryContext    - Supplies the length of the registry data buffer.

Return Value:

    NTSTATUS

--*/

{
    if (ValueLength > *((PUSHORT) EntryContext)) {
        return STATUS_INVALID_PARAMETER;
    }

    *((PUSHORT) EntryContext) = (USHORT) ValueLength;
    RtlCopyMemory(Context, ValueData, ValueLength);

    return STATUS_SUCCESS;
}

BOOLEAN
FtpQueryStateFromRegistry(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  PVOID               LogicalDiskState,
    IN  USHORT              BufferSize,
    OUT PUSHORT             LogicalDiskStateSize
    )

/*++

Routine Description:

    This routine queries the given state from the registry so that it can
    be retrieved to solve some of the so called split brain problems.

Arguments:

    LogicalDiskId           - Supplies the logical disk id.

    LogicalDiskState        - Supplies the logical disk state.

    LogicalDiskStateSize    - Supplie the logical disk state size.

Return Value:

    None.

--*/

{
    WCHAR                       registryName[50];
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    NTSTATUS                    status;

    *LogicalDiskStateSize = BufferSize;

    swprintf(registryName, L"%I64X", LogicalDiskId);

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = FtpQueryStateFromRegistryRoutine;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = registryName;
    queryTable[0].EntryContext = LogicalDiskStateSize;

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    FT_STATE_REGISTRY_KEY, queryTable,
                                    LogicalDiskState, NULL);

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    return TRUE;
}

VOID
FtpDeleteStateInRegistry(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine deletes the given registry state in the registry.

Arguments:

    LogicalDiskId           - Supplies the logical disk id.

Return Value:

    None.

--*/

{
    WCHAR                       registryName[50];

    swprintf(registryName, L"%I64X", LogicalDiskId);

    RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE, FT_STATE_REGISTRY_KEY,
                           registryName);
}


NTSTATUS
FtWmi(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine handles any WMI requests for information.

Arguments:

    DeviceObject - Context for the activity.

    Irp          - The device control argument block.

Return Value:

    Status is returned.

--*/

{
    PVOLUME_EXTENSION       extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status;
    SYSCTL_IRP_DISPOSITION  disposition;

    if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(extension->Root->TargetObject, Irp);
    }

    ASSERT(extension->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);

    status = WmiSystemControl(extension->WmilibContext, DeviceObject,
                              Irp, &disposition);

    switch (disposition) {
        case IrpProcessed:
            break;

        case IrpNotCompleted:
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;

        default:
            status = Irp->IoStatus.Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
    }

    return status;
}


NTSTATUS
FtWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for enabling or
    disabling events and data collection.  When the driver has finished it
    must call WmiCompleteRequest to complete the irp. The driver can return
    STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose events or data collection are being
        enabled or disabled

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function differentiates between event and data collection operations

    Enable indicates whether to enable or disable


Return Value:

    status

--*/
{
    NTSTATUS status;
    PVOLUME_EXTENSION extension;
    PPMWMICOUNTERLIB_CONTEXT counterLib;

    extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    counterLib = &extension->Root->PmWmiCounterLibContext;

    if (GuidIndex == 0)
    {
        status = STATUS_SUCCESS;
        if (Function == WmiDataBlockControl) {
            if (!Enable) {
                extension->CountersEnabled =
                    counterLib->PmWmiCounterDisable(
                        &extension->PmWmiCounterContext,FALSE,FALSE);
            } else {
                status = counterLib->PmWmiCounterEnable(
                            &extension->PmWmiCounterContext);
                if (NT_SUCCESS(status)) {
                    extension->CountersEnabled = TRUE;
                }
            }
        }
    } else {
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(
                                 DeviceObject,
                                 Irp,
                                 status,
                                 0,
                                 IO_NO_INCREMENT);
    return(status);
}



NTSTATUS
FtpPmWmiCounterLibContext(
    IN OUT PROOT_EXTENSION RootExtension,
    IN PIRP            Irp
    )

/*++

Routine Description:

    This routine is called from the partition manager to enable access to
    the performance counter maintenance routines.

Arguments:

    RootExtension   - Supplies the device extension.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PPMWMICOUNTERLIB_CONTEXT            input;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(PMWMICOUNTERLIB_CONTEXT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PPMWMICOUNTERLIB_CONTEXT) Irp->AssociatedIrp.SystemBuffer;
    RootExtension->PmWmiCounterLibContext = *input;

    return STATUS_SUCCESS;
}


VOID
FtDiskUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )

/*++

Routine Description:

    This routine unloads.

Arguments:

    DriverObject    - Supplies the driver object.

Return Value:

    None.

--*/

{
    ObDereferenceObject(DriverObject);
}

VOID
FtpApplyESPSecurityWorker(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           WorkItem
    )

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    PIO_WORKITEM        workItem = (PIO_WORKITEM) WorkItem;
    WCHAR               buffer[100];
    UNICODE_STRING      s;

    swprintf(buffer, L"\\Device\\HarddiskVolume%d", extension->VolumeNumber);
    RtlInitUnicodeString(&s, buffer);

    FtpApplyESPProtection(&s);

    IoFreeWorkItem(workItem);
}

VOID
FtpPostApplyESPSecurity(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PIO_WORKITEM    workItem;

    workItem = IoAllocateWorkItem(Extension->DeviceObject);
    if (!workItem) {
        return;
    }

    IoQueueWorkItem(workItem, FtpApplyESPSecurityWorker, DelayedWorkQueue,
                    workItem);
}

NTSTATUS
FtDiskPnp(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_PNP.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION       extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PROOT_EXTENSION         rootExtension;
    PDEVICE_OBJECT          targetObject;
    NTSTATUS                status;
    UNICODE_STRING          interfaceName;
    PLIST_ENTRY             l;
    PVOLUME_EXTENSION       e;
    UNICODE_STRING          dosName;
    KEVENT                  event;
    ULONG                   n, size;
    PDEVICE_RELATIONS       deviceRelations;
    PDEVICE_CAPABILITIES    capabilities;
    DEVICE_INSTALL_STATE    deviceInstallState;
    ULONG                   bytes;
    BOOLEAN                 deletePdo;
    BOOLEAN                 dontAssertGuid;
    BOOLEAN                 removeInProgress;

    if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {

        rootExtension = (PROOT_EXTENSION) extension;
        targetObject = rootExtension->TargetObject;

        switch (irpSp->MinorFunction) {

            case IRP_MN_START_DEVICE:
            case IRP_MN_CANCEL_REMOVE_DEVICE:
            case IRP_MN_CANCEL_STOP_DEVICE:
            case IRP_MN_QUERY_RESOURCES:
            case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
                Irp->IoStatus.Status = STATUS_SUCCESS ;
                IoSkipCurrentIrpStackLocation(Irp);
                return IoCallDriver(targetObject, Irp);

            case IRP_MN_QUERY_DEVICE_RELATIONS:
                if (irpSp->Parameters.QueryDeviceRelations.Type != BusRelations) {
                    IoSkipCurrentIrpStackLocation(Irp);
                    return IoCallDriver(targetObject, Irp);
                }

                FtpAcquire(rootExtension);

                n = 0;
                for (l = rootExtension->VolumeList.Flink;
                     l != &rootExtension->VolumeList; l = l->Flink) {

                    n++;
                }

                size = FIELD_OFFSET(DEVICE_RELATIONS, Objects) +
                       n*sizeof(PDEVICE_OBJECT);

                deviceRelations = (PDEVICE_RELATIONS)
                                  ExAllocatePool(PagedPool, size);
                if (!deviceRelations) {
                    FtpRelease(rootExtension);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    Irp->IoStatus.Information = 0;
                    break;
                }

                deviceRelations->Count = n;
                n = 0;
                for (l = rootExtension->VolumeList.Flink;
                     l != &rootExtension->VolumeList; l = l->Flink) {

                    e = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
                    deviceRelations->Objects[n++] = e->DeviceObject;
                    ObReferenceObject(e->DeviceObject);
                }

                while (!IsListEmpty(&rootExtension->DeadVolumeList)) {
                    l = RemoveHeadList(&rootExtension->DeadVolumeList);
                    e = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
                    e->DeadToPnp = TRUE;
                }

                FtpRelease(rootExtension);

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

                IoSkipCurrentIrpStackLocation(Irp);
                return IoCallDriver(targetObject, Irp);

            case IRP_MN_QUERY_ID:
                status = FtpQueryRootId(rootExtension, Irp);

                if (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED)) {
                    if (NT_SUCCESS(status)) {
                        Irp->IoStatus.Status = status;
                    }

                    IoSkipCurrentIrpStackLocation(Irp);
                    return IoCallDriver(targetObject, Irp);
                }
                break;

            case IRP_MN_REMOVE_DEVICE:
            case IRP_MN_SURPRISE_REMOVAL:

                FtpAcquire(rootExtension);

                if (rootExtension->VolumeManagerInterfaceName.Buffer) {
                    IoSetDeviceInterfaceState(
                            &rootExtension->VolumeManagerInterfaceName, FALSE);
                    ExFreePool(rootExtension->VolumeManagerInterfaceName.Buffer);
                    rootExtension->VolumeManagerInterfaceName.Buffer = NULL;
                }

                if (irpSp->MinorFunction == IRP_MN_REMOVE_DEVICE) {

                    ASSERT(IsListEmpty(&rootExtension->VolumeList));

                    while (!IsListEmpty(&rootExtension->VolumeList)) {

                        l = RemoveHeadList(&rootExtension->VolumeList);
                        e = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

                        FtpCleanupVolumeExtension(e);
                        ExFreePool(e->DeviceNodeName.Buffer);
                        IoDeleteDevice(e->DeviceObject);
                    }

                    delete rootExtension->DiskInfoSet;
                    rootExtension->DiskInfoSet = NULL;

                    FtpRelease(rootExtension);

                    InterlockedExchange(&rootExtension->TerminateThread, TRUE);

                    KeReleaseSemaphore(&rootExtension->WorkerSemaphore,
                                       IO_NO_INCREMENT, 1, FALSE);

                    KeWaitForSingleObject(rootExtension->WorkerThread, Executive,
                                          KernelMode, FALSE, NULL);

                    ObDereferenceObject(rootExtension->WorkerThread);

                    ASSERT(IsListEmpty(&rootExtension->ChangeNotifyIrpList));

                    IoDetachDevice(targetObject);
                    IoUnregisterShutdownNotification(rootExtension->DeviceObject);
                    IoDeleteDevice(rootExtension->DeviceObject);
                } else {
                    FtpRelease(rootExtension);
                }

                Irp->IoStatus.Status = STATUS_SUCCESS;
                IoSkipCurrentIrpStackLocation(Irp);
                return IoCallDriver(targetObject, Irp);

            case IRP_MN_QUERY_REMOVE_DEVICE:
            case IRP_MN_DEVICE_USAGE_NOTIFICATION:
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;

            case IRP_MN_QUERY_CAPABILITIES:
                KeInitializeEvent(&event, NotificationEvent, FALSE);
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp, FtpSignalCompletion,
                                       &event, TRUE, TRUE, TRUE);
                IoCallDriver(targetObject, Irp);
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);

                capabilities = irpSp->Parameters.DeviceCapabilities.Capabilities;
                capabilities->SilentInstall = 1;
                capabilities->RawDeviceOK = 1;
                status = Irp->IoStatus.Status;
                break;

            case IRP_MN_QUERY_PNP_DEVICE_STATE:
                KeInitializeEvent(&event, NotificationEvent, FALSE);
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp, FtpSignalCompletion,
                                       &event, TRUE, TRUE, TRUE);
                IoCallDriver(targetObject, Irp);
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);

                status = Irp->IoStatus.Status;
                if (NT_SUCCESS(status)) {
                    Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE |
                                                 PNP_DEVICE_DONT_DISPLAY_IN_UI;
                } else {
                    status = STATUS_SUCCESS;
                    Irp->IoStatus.Information = PNP_DEVICE_NOT_DISABLEABLE |
                                                PNP_DEVICE_DONT_DISPLAY_IN_UI;
                }
                break;

            default:
                IoSkipCurrentIrpStackLocation(Irp);
                return IoCallDriver(targetObject, Irp);

        }

    } else if (extension->DeviceExtensionType == DEVICE_EXTENSION_VOLUME) {

        switch (irpSp->MinorFunction) {

            case IRP_MN_START_DEVICE:
                FtpAcquire(extension->Root);

                KeInitializeEvent(&event, NotificationEvent, FALSE);
                FtpZeroRefCallback(extension, FtpStartCallback, &event, TRUE);
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);

                dontAssertGuid = FALSE;
                if (extension->Root->PastBootReinitialize) {

                    status = IoGetDeviceProperty(extension->DeviceObject,
                                                 DevicePropertyInstallState,
                                                 sizeof(deviceInstallState),
                                                 &deviceInstallState, &bytes);
                    if (NT_SUCCESS(status)) {
                        if (deviceInstallState == InstallStateInstalled) {
                            extension->IsInstalled = TRUE;
                            if (extension->IsPreExposure) {
                                extension->Root->PreExposureCount--;
                                RemoveEntryList(&extension->ListEntry);
                                InsertTailList(
                                        &extension->Root->DeadVolumeList,
                                        &extension->ListEntry);
                                FtpCleanupVolumeExtension(extension);
                                status = STATUS_UNSUCCESSFUL;
                                dontAssertGuid = TRUE;
                            } else if (extension->IsHidden) {
                                status = STATUS_UNSUCCESSFUL;
                                dontAssertGuid = TRUE;
                                if (extension->IsEspType &&
                                    extension->Root->PastReinitialize) {

                                    FtpPostApplyESPSecurity(extension);
                                }
                            } else {
                                status = IoRegisterDeviceInterface(
                                         extension->DeviceObject,
                                         &MOUNTDEV_MOUNTED_DEVICE_GUID, NULL,
                                         &extension->MountedDeviceInterfaceName);
                            }
                        } else {
                            status = STATUS_UNSUCCESSFUL;
                            dontAssertGuid = TRUE;
                        }
                    } else {
                        dontAssertGuid = TRUE;
                    }
                } else {
                    extension->IsInstalled = TRUE;
                    if (extension->IsPreExposure || extension->IsHidden) {
                        status = STATUS_UNSUCCESSFUL;
                        dontAssertGuid = TRUE;
                    } else {
                        status = IoRegisterDeviceInterface(
                                 extension->DeviceObject,
                                 &MOUNTDEV_MOUNTED_DEVICE_GUID, NULL,
                                 &extension->MountedDeviceInterfaceName);
                    }
                }

                if (NT_SUCCESS(status)) {
                    status = IoSetDeviceInterfaceState(
                             &extension->MountedDeviceInterfaceName, TRUE);
                }

                if (!NT_SUCCESS(status)) {
                    if (extension->MountedDeviceInterfaceName.Buffer) {
                        ExFreePool(extension->MountedDeviceInterfaceName.Buffer);
                        extension->MountedDeviceInterfaceName.Buffer = NULL;
                    }
                    KeInitializeEvent(&event, NotificationEvent, FALSE);
                    FtpZeroRefCallback(extension, FtpVolumeOnlineCallback,
                                       &event, TRUE);
                    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                          NULL);
                }

                if (!extension->IsHidden) {
                    FtRegisterDevice(DeviceObject);
                }

                FtpRelease(extension->Root);
                if (dontAssertGuid) {
                    status = STATUS_SUCCESS;
                }
                break;

            case IRP_MN_QUERY_REMOVE_DEVICE:
                if (extension->DeviceObject->Flags&DO_SYSTEM_BOOT_PARTITION) {
                    status = STATUS_INVALID_DEVICE_REQUEST;
                    break;
                }

                status = FtpCheckForQueryRemove(extension);
                break;

            case IRP_MN_CANCEL_REMOVE_DEVICE:
                removeInProgress = FtpCheckForCancelRemove(extension);

                if (removeInProgress) {
                    KeInitializeEvent(&event, NotificationEvent, FALSE);
                    FtpZeroRefCallback(extension, FtpQueryRemoveCallback,
                                       &event, TRUE);
                    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                          NULL);
                }
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_QUERY_STOP_DEVICE:
                status = STATUS_UNSUCCESSFUL;
                break;

            case IRP_MN_CANCEL_STOP_DEVICE:
            case IRP_MN_QUERY_RESOURCES:
            case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_REMOVE_DEVICE:
            case IRP_MN_SURPRISE_REMOVAL:

                FtpAcquire(extension->Root);

                FtpRemoveHelper(extension);

                KeInitializeEvent(&event, NotificationEvent, FALSE);
                FtpZeroRefCallback(extension, FtpQueryRemoveCallback, &event,
                                   TRUE);
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);

                if (extension->MountedDeviceInterfaceName.Buffer) {
                    IoSetDeviceInterfaceState(
                            &extension->MountedDeviceInterfaceName, FALSE);
                    ExFreePool(extension->MountedDeviceInterfaceName.Buffer);
                    extension->MountedDeviceInterfaceName.Buffer = NULL;
                }

                if (irpSp->MinorFunction == IRP_MN_REMOVE_DEVICE) {
                    if (extension->DeadToPnp && !extension->DeviceDeleted) {
                        extension->DeviceDeleted = TRUE;
                        ExFreePool(extension->DeviceNodeName.Buffer);
                        deletePdo = TRUE;
                    } else {
                        deletePdo = FALSE;
                    }
                } else {
                    deletePdo = FALSE;
                }

                FtpRelease(extension->Root);

                // If this device is still being enumerated then don't
                // delete it and wait for a start instead.  If it is not
                // being enumerated then blow it away.

                if (deletePdo) {
                    IoDeleteDevice(extension->DeviceObject);
                }
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_QUERY_DEVICE_RELATIONS:
                if (irpSp->Parameters.QueryDeviceRelations.Type !=
                    TargetDeviceRelation) {

                    status = STATUS_NOT_SUPPORTED;
                    break;
                }

                deviceRelations = (PDEVICE_RELATIONS)
                                  ExAllocatePool(PagedPool,
                                                 sizeof(DEVICE_RELATIONS));
                if (!deviceRelations) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                ObReferenceObject(DeviceObject);
                deviceRelations->Count = 1;
                deviceRelations->Objects[0] = DeviceObject;
                Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_QUERY_INTERFACE:
                status = STATUS_NOT_SUPPORTED ;
                break;

            case IRP_MN_QUERY_CAPABILITIES:
                capabilities = irpSp->Parameters.DeviceCapabilities.Capabilities;
                capabilities->SilentInstall = 1;
                capabilities->RawDeviceOK = 1;
                capabilities->SurpriseRemovalOK = 1;
                capabilities->Address = extension->VolumeNumber;
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_QUERY_ID:
                status = FtpQueryId(extension, Irp);
                break;

            case IRP_MN_QUERY_PNP_DEVICE_STATE:
                Irp->IoStatus.Information = PNP_DEVICE_DONT_DISPLAY_IN_UI;
                if ((extension->DeviceObject->Flags&DO_SYSTEM_BOOT_PARTITION) ||
                    extension->InPagingPath) {

                    Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
                }
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_DEVICE_USAGE_NOTIFICATION:
                return FtDiskPagingNotification(DeviceObject, Irp);

            default:
                status = STATUS_NOT_SUPPORTED;
                break;

        }
    } else {
        Irp->IoStatus.Information = 0;
        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    if (status != STATUS_NOT_SUPPORTED) {
        Irp->IoStatus.Status = status;
    } else {
        status = Irp->IoStatus.Status;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

class DELETE_FT_REGISTRY_WORK_ITEM : public WORK_QUEUE_ITEM {

    public:

        PROOT_EXTENSION     RootExtension;
        FT_LOGICAL_DISK_ID  LogicalDiskId;

};

typedef DELETE_FT_REGISTRY_WORK_ITEM *PDELETE_FT_REGISTRY_WORK_ITEM;

VOID
FtpDeleteFtRegistryWorker(
    IN  PVOID   WorkItem
    )

{
    PDELETE_FT_REGISTRY_WORK_ITEM       workItem = (PDELETE_FT_REGISTRY_WORK_ITEM) WorkItem;
    PROOT_EXTENSION                     rootExtension = workItem->RootExtension;
    PFT_LOGICAL_DISK_INFORMATION_SET    diskInfoSet = rootExtension->DiskInfoSet;

    FtpAcquire(rootExtension);
    diskInfoSet->DeleteFtRegistryInfo(workItem->LogicalDiskId);
    FtpRelease(rootExtension);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif

PVOLUME_EXTENSION
FtpFindExtensionCoveringPartition(
    IN  PROOT_EXTENSION RootExtension,
    IN  PDEVICE_OBJECT  Partition
    )

/*++

Routine Description:

    This routine finds the device extension covering the given partition.

Arguments:

    RootExtension   - Supplies the root extension.

    Partition       - Supplies the partition.

Return Value:

    The volume extension covering the given partition.

--*/

{
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;
    PFT_VOLUME          vol;

    for (l = RootExtension->VolumeList.Flink; l != &RootExtension->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

        if (extension->TargetObject) {
            if (extension->TargetObject == Partition) {
                return extension;
            }
            continue;
        }

        vol = extension->FtVolume;
        if (vol && vol->GetContainedLogicalDisk(Partition)) {
            return extension;
        }
    }

    return NULL;
}

VOID
FtpAcquire(
    IN OUT  PROOT_EXTENSION RootExtension
    )

/*++

Routine Description:

    This routine grabs the root semaphore.

Arguments:

    RootExtension   - Supplies the root extension.

Return Value:

    None.

--*/

{
    KeWaitForSingleObject(&RootExtension->Mutex, Executive, KernelMode,
                          FALSE, NULL);
}

VOID
FtpRelease(
    IN OUT  PROOT_EXTENSION RootExtension
    )

/*++

Routine Description:

    This routine releases the root semaphore.

Arguments:

    RootExtension   - Supplies the root extension.

Return Value:

    None.

--*/

{
    KeReleaseSemaphore(&RootExtension->Mutex, IO_NO_INCREMENT, 1, FALSE);
}

VOID
FtpCancelChangeNotify(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the cancel routine for notification IRPs.

Arguments:

    DeviceObject   - Supplies the device object.

    Irp            - Supplies the IO request packet.

Return Value:

    None

--*/
{
    PVOLUME_EXTENSION   Extension;

    IoReleaseCancelSpinLock (Irp->CancelIrql);

    Extension = (PVOLUME_EXTENSION) Irp->Tail.Overlay.DriverContext[0];

    FtpAcquire(Extension->Root);
    RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
    FtpRelease(Extension->Root);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}


NTSTATUS
FtDiskCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_CREATE.

Arguments:

    DeviceObject - Supplies the device object.

    Irp          - Supplies the IO request block.

Return Value:

    NTSTATUS

--*/

{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

VOID
FtpEventSignalCompletion(
    IN  PVOID       Event,
    IN  NTSTATUS    Status
    )

/*++

Routine Description:

    Completion routine of type FT_COMPLETION_ROUTINE that sets
    the status of the given event to Signaled

Arguments:

    Event       - Supplies the event

    Status      - Supplies the status of the operation.

Return Value:

    None.

--*/

{
    KeSetEvent( (PKEVENT) Event, IO_NO_INCREMENT, FALSE );
}

VOID
FtpVolumeOnlineCallback(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    if (Extension->IsOffline) {
        Extension->IsOffline = FALSE;
        Extension->IsComplete = FALSE;
    }
    KeSetEvent((PKEVENT) Extension->ZeroRefContext, IO_NO_INCREMENT, FALSE);
}

VOID
FtpVolumeOfflineCallback(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    if (!Extension->IsOffline) {
        Extension->IsOffline = TRUE;
        if (Extension->FtVolume) {
            Extension->FtVolume->SetDirtyBit(FALSE, NULL, NULL);
        }
    }
    KeSetEvent((PKEVENT) Extension->ZeroRefContext, IO_NO_INCREMENT, FALSE);
}

NTSTATUS
FtpAllSystemsGo(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp,
    IN  BOOLEAN             MustBeComplete,
    IN  BOOLEAN             MustHaveVolume,
    IN  BOOLEAN             MustBeOnline
    )

/*++

Routine Description:

    This routine checks the device extension states to make sure that the
    IRP can proceed.  If the IRP can proceed then the device extension ref
    count is incremented.  If the IRP is queued then STATUS_PENDING returned.

Arguments:

    Extension       - Supplies the device extension.

    Irp             - Supplies the I/O request packet.

    MustBeComplete  - Supplies whether or not the FT set must be complete.

    MustHaveVolume  - Supplies whether or not the PDO still refers to an
                        existing volume.

    MustBeOnline    - Supplies whether or not the volume must be online.

Return Value:

    STATUS_PENDING      - The IRP was put on the ZeroRef queue.

    STATUS_SUCCESS      - The IRP can proceed.  The ref count was incremented.

    !NT_SUCCESS(status) - The IRP must fail with the status returned.

--*/

{
    KIRQL                           irql;
    PFT_VOLUME                      vol;
    BOOLEAN                         deleteFtRegistryInfo;
    PDELETE_FT_REGISTRY_WORK_ITEM   workItem;

    if (MustBeComplete) {
        MustHaveVolume = TRUE;
        MustBeOnline = TRUE;
    }

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (MustHaveVolume && !Extension->TargetObject && !Extension->FtVolume) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return STATUS_NO_SUCH_DEVICE;
    }

    if (!Extension->IsStarted) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return STATUS_NO_SUCH_DEVICE;
    }

    if (MustBeOnline && Extension->IsOffline) {
        if (Extension->DeviceObject->Flags&DO_SYSTEM_BOOT_PARTITION) {
            Extension->IsOffline = FALSE;
        } else {
            KeReleaseSpinLock(&Extension->SpinLock, irql);
            if (Irp) {
                Irp->IoStatus.Information = 0;
            }
            return STATUS_DEVICE_OFF_LINE;
        }
    }

    if (Extension->ZeroRefCallback || Extension->RemoveInProgress) {
        ASSERT(Irp);
        IoMarkIrpPending(Irp);
        InsertTailList(&Extension->ZeroRefHoldQueue,
                       &Irp->Tail.Overlay.ListEntry);
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return STATUS_PENDING;
    }

    if (Extension->TargetObject) {
        InterlockedIncrement(&Extension->RefCount);
        if (!Extension->IsOffline) {
            InterlockedExchange(&Extension->AllSystemsGo, TRUE);
        }
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return STATUS_SUCCESS;
    }

    if (!MustBeComplete || Extension->IsComplete) {
        InterlockedIncrement(&Extension->RefCount);
        if (Extension->IsComplete && MustHaveVolume && !Extension->IsOffline) {
            InterlockedExchange(&Extension->AllSystemsGo, TRUE);
        }
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return STATUS_SUCCESS;
    }

    vol = Extension->FtVolume;
    ASSERT(vol);

    if (!vol->IsComplete(TRUE)) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return STATUS_NO_SUCH_DEVICE;
    }
    vol->CompleteNotification(TRUE);

    if (vol->IsComplete(FALSE)) {
        deleteFtRegistryInfo = FALSE;
    } else {
        deleteFtRegistryInfo = TRUE;
    }

    Extension->IsComplete = TRUE;
    InterlockedIncrement(&Extension->RefCount);
    InterlockedIncrement(&Extension->RefCount);
    InterlockedExchange(&Extension->AllSystemsGo, TRUE);
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    vol->StartSyncOperations(FALSE, FtpRefCountCompletion, Extension);
    vol->SetDirtyBit(TRUE, NULL, NULL);

    if (deleteFtRegistryInfo) {

        workItem = (PDELETE_FT_REGISTRY_WORK_ITEM)
                   ExAllocatePool(NonPagedPool,
                                  sizeof(DELETE_FT_REGISTRY_WORK_ITEM));
        if (!workItem) {
            return STATUS_SUCCESS;
        }

        ExInitializeWorkItem(workItem, FtpDeleteFtRegistryWorker, workItem);
        workItem->RootExtension = Extension->Root;
        workItem->LogicalDiskId = vol->QueryLogicalDiskId();

        FtpQueueWorkItem(Extension->Root, workItem);
    }

    return STATUS_SUCCESS;
}

VOID
FtpZeroRefCallback(
    IN  PVOLUME_EXTENSION   Extension,
    IN  ZERO_REF_CALLBACK   ZeroRefCallback,
    IN  PVOID               ZeroRefContext,
    IN  BOOLEAN             AcquireSemaphore
    )

/*++

Routine Description:

    This routine sets up the given zero ref callback and state.

Arguments:

    Extension           - Supplies the device extension.

    ZeroRefCallback     - Supplies the zero ref callback.

    ZeroRefContext      - Supplies the zero ref context.

    AcquireSemaphore    - Supplies whether or not to acquire the semaphore.

Return Value:

    None.

--*/

{
    KIRQL   irql;

    if (AcquireSemaphore) {
        KeWaitForSingleObject(&Extension->Semaphore, Executive, KernelMode,
                              FALSE, NULL);
    }

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    InterlockedExchange(&Extension->AllSystemsGo, FALSE);
    ASSERT(!Extension->ZeroRefCallback);
    Extension->ZeroRefCallback = ZeroRefCallback;
    Extension->ZeroRefContext = ZeroRefContext;
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    if (Extension->FtVolume) {
        Extension->FtVolume->StopSyncOperations();
    }

    FtpDecrementRefCount(Extension);
}

NTSTATUS
FtDiskPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_PNP.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION       extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    PROOT_EXTENSION         rootExtension = extension->Root;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status;

    if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        return PoCallDriver(rootExtension->TargetObject, Irp);
    }

    switch (irpSp->MinorFunction) {
        case IRP_MN_WAIT_WAKE:
        case IRP_MN_POWER_SEQUENCE:
        case IRP_MN_SET_POWER:
        case IRP_MN_QUERY_POWER:
            status = STATUS_SUCCESS;
            break;

        default:
            status = Irp->IoStatus.Status;
            break;

    }

    Irp->IoStatus.Status = status;
    PoStartNextPowerIrp(Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

VOID
FtpWorkerThread(
    IN  PVOID   RootExtension
    )

/*++

Routine Description:

    This is a worker thread to process work queue items.

Arguments:

    RootExtension   - Supplies the root device extension.

Return Value:

    None.

--*/

{
    PROOT_EXTENSION     extension = (PROOT_EXTENSION) RootExtension;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PWORK_QUEUE_ITEM    queueItem;

    for (;;) {

        KeWaitForSingleObject(&extension->WorkerSemaphore,
                              Executive, KernelMode, FALSE, NULL);

        KeAcquireSpinLock(&extension->SpinLock, &irql);
        if (extension->TerminateThread) {
            KeReleaseSpinLock(&extension->SpinLock, irql);
            PsTerminateSystemThread(STATUS_SUCCESS);
            return;
        }

        ASSERT(!IsListEmpty(&extension->WorkerQueue));
        l = RemoveHeadList(&extension->WorkerQueue);
        KeReleaseSpinLock(&extension->SpinLock, irql);

        queueItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
        queueItem->WorkerRoutine(queueItem->Parameter);

        ExFreePool(queueItem);
    }
}

VOID
FtpEmptyQueueAtDispatchLevel(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PLIST_ENTRY         IrpQueue
    )

/*++

Routine Description:

    This routine empties the given queue of irps that are callable at
    dispatch level by calling their respective dispatch routines.

Arguments:

    Extension   - Supplies the device extension.

    IrpQueue    - Supplies the queue of IRPs.

Return Value:

    None.

--*/

{
    PDRIVER_OBJECT      driverObject;
    PDEVICE_OBJECT      deviceObject;
    PLIST_ENTRY         l, tmp;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;

    driverObject = Extension->Root->DriverObject;
    deviceObject = Extension->DeviceObject;

    for (l = IrpQueue->Flink; l != IrpQueue; l = l->Flink) {
        irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
        irpSp = IoGetCurrentIrpStackLocation(irp);
        switch (irpSp->MajorFunction) {
            case IRP_MJ_POWER:
            case IRP_MJ_READ:
            case IRP_MJ_WRITE:
                tmp = l->Blink;
                RemoveEntryList(l);
                l = tmp;
                driverObject->MajorFunction[irpSp->MajorFunction](
                        deviceObject, irp);
                break;

        }
    }
}

VOID
FtpDecrementRefCount(
    IN OUT  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine decrements the ref count and handles the case
    when the ref count goes to zero.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    None.

--*/

{
    LONG                        count;
    KIRQL                       irql;
    BOOLEAN                     startSync, list;
    LIST_ENTRY                  q;
    PEMPTY_IRP_QUEUE_WORK_ITEM  workItem;
    PLIST_ENTRY                 l;
    PIRP                        irp;

    count = InterlockedDecrement(&Extension->RefCount);
    if (count) {
        return;
    }

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (!Extension->ZeroRefCallback) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return;
    }

    Extension->ZeroRefCallback(Extension);
    Extension->ZeroRefCallback = NULL;
    InterlockedIncrement(&Extension->RefCount);

    if (Extension->FtVolume && Extension->IsComplete && Extension->IsStarted &&
        !Extension->IsOffline) {

        startSync = TRUE;
        InterlockedIncrement(&Extension->RefCount);
    } else {
        startSync = FALSE;
    }

    if (IsListEmpty(&Extension->ZeroRefHoldQueue) ||
        Extension->RemoveInProgress) {

        list = FALSE;
    } else {
        list = TRUE;
        q = Extension->ZeroRefHoldQueue;
        InitializeListHead(&Extension->ZeroRefHoldQueue);
    }
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    KeReleaseSemaphore(&Extension->Semaphore, IO_NO_INCREMENT, 1, FALSE);

    if (startSync) {
        Extension->FtVolume->StartSyncOperations(FALSE, FtpRefCountCompletion,
                                                 Extension);
    }

    if (!list) {
        return;
    }

    q.Flink->Blink = &q;
    q.Blink->Flink = &q;

    FtpEmptyQueueAtDispatchLevel(Extension, &q);

    if (IsListEmpty(&q)) {
        return;
    }

    workItem = (PEMPTY_IRP_QUEUE_WORK_ITEM)
               ExAllocatePool(NonPagedPool,
                              sizeof(EMPTY_IRP_QUEUE_WORK_ITEM));
    if (!workItem) {
        workItem = (PEMPTY_IRP_QUEUE_WORK_ITEM)
                   ExAllocatePool(NonPagedPool,
                                  sizeof(EMPTY_IRP_QUEUE_WORK_ITEM));
        if (!workItem) {
            while (!IsListEmpty(&q)) {
                l = RemoveHeadList(&q);
                irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
                irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                irp->IoStatus.Information = 0;
                IoCompleteRequest(irp, IO_NO_INCREMENT);
            }
            return;
        }
    }

    ExInitializeWorkItem(workItem, FtpEmptyQueueWorkerRoutine, workItem);
    workItem->IrpQueue = q;
    workItem->IrpQueue.Flink->Blink = &workItem->IrpQueue;
    workItem->IrpQueue.Blink->Flink = &workItem->IrpQueue;
    workItem->Extension = Extension;

    ExQueueWorkItem(workItem, CriticalWorkQueue);
}

NTSTATUS
FtDiskAddDevice(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  PhysicalDeviceObject,
    IN  PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine creates and initializes a new FDO for the corresponding
    PDO.

Arguments:

    DriverObject            - Supplies the FTDISK driver object.

    PhysicalDeviceObject    - Supplies the physical device object.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING      deviceName, dosName;
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PROOT_EXTENSION     rootExtension;
    HANDLE              handle;
    KIRQL               irql;

    RtlInitUnicodeString(&deviceName, DD_FT_CONTROL_DEVICE_NAME);

    status = IoCreateDevice(DriverObject, sizeof(ROOT_EXTENSION),
                            &deviceName, FILE_DEVICE_NETWORK,
                            FILE_DEVICE_SECURE_OPEN, FALSE,
                            &deviceObject);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    RtlInitUnicodeString(&dosName, L"\\DosDevices\\FtControl");
    IoCreateSymbolicLink(&dosName, &deviceName);

    rootExtension = (PROOT_EXTENSION) deviceObject->DeviceExtension;
    RtlZeroMemory(rootExtension, sizeof(ROOT_EXTENSION));
    rootExtension->DeviceObject = deviceObject;
    rootExtension->Root = rootExtension;
    rootExtension->DeviceExtensionType = DEVICE_EXTENSION_ROOT;
    KeInitializeSpinLock(&rootExtension->SpinLock);
    rootExtension->DriverObject = DriverObject;

    rootExtension->TargetObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);
    if (!rootExtension->TargetObject) {
        IoDeleteSymbolicLink(&dosName);
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }

    rootExtension->Pdo = PhysicalDeviceObject;
    InitializeListHead(&rootExtension->VolumeList);
    InitializeListHead(&rootExtension->DeadVolumeList);
    rootExtension->NextVolumeNumber = 1;

    rootExtension->DiskInfoSet = new FT_LOGICAL_DISK_INFORMATION_SET;
    if (!rootExtension->DiskInfoSet) {
        IoDeleteSymbolicLink(&dosName);
        IoDetachDevice(rootExtension->TargetObject);
        IoDeleteDevice(deviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    status = rootExtension->DiskInfoSet->Initialize();
    if (!NT_SUCCESS(status)) {
        delete rootExtension->DiskInfoSet;
        IoDeleteSymbolicLink(&dosName);
        IoDetachDevice(rootExtension->TargetObject);
        IoDeleteDevice(deviceObject);
        return status;
    }

    InitializeListHead(&rootExtension->WorkerQueue);
    KeInitializeSemaphore(&rootExtension->WorkerSemaphore, 0, MAXLONG);
    rootExtension->TerminateThread = TRUE;
    InitializeListHead(&rootExtension->ChangeNotifyIrpList);
    KeInitializeSemaphore(&rootExtension->Mutex, 1, 1);

    rootExtension->DiskPerfRegistryPath.MaximumLength =
            RegistryPath->Length + sizeof(UNICODE_NULL);
    rootExtension->DiskPerfRegistryPath.Buffer = (PWSTR)
            ExAllocatePool(PagedPool,
                           rootExtension->DiskPerfRegistryPath.MaximumLength);
    if (!rootExtension->DiskPerfRegistryPath.Buffer) {
        delete rootExtension->DiskInfoSet;
        IoDeleteSymbolicLink(&dosName);
        IoDetachDevice(rootExtension->TargetObject);
        IoDeleteDevice(deviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyUnicodeString(&rootExtension->DiskPerfRegistryPath,
                         RegistryPath);

    status = IoRegisterShutdownNotification(deviceObject);
    if (!NT_SUCCESS(status)) {
        ExFreePool(rootExtension->DiskPerfRegistryPath.Buffer);
        delete rootExtension->DiskInfoSet;
        IoDeleteSymbolicLink(&dosName);
        IoDetachDevice(rootExtension->TargetObject);
        IoDeleteDevice(deviceObject);
        return status;
    }

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;
}

NTSTATUS
FtpRefCountCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Extension
    )

/*++

Routine Description:

    This routine decrements the ref count in the device extension.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

    Extension       - Supplies the device extension.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) Extension;

    if (extension->CountersEnabled) {
        PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
        if (irpStack->MajorFunction == IRP_MJ_READ ||
            irpStack->MajorFunction == IRP_MJ_WRITE) {
            PPMWMICOUNTERLIB_CONTEXT counterLib;
    
            counterLib = &extension->Root->PmWmiCounterLibContext;
            counterLib->PmWmiCounterIoComplete(
                extension->PmWmiCounterContext, Irp,
                (PLARGE_INTEGER) &irpStack->Parameters.Read);
        }
    }

    FtpDecrementRefCount(extension);
    return STATUS_SUCCESS;
}

NTSTATUS
FtDiskReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_READ and IRP_MJ_WRITE.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION   extension;
    NTSTATUS            status;
    PFT_VOLUME          vol;
    PDISPATCH_TP        packet;
    KIRQL               irql;
    PIO_STACK_LOCATION  irpSp;
    LONGLONG            offset;
    ULONG               length;

    extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;

    if (extension->DeviceExtensionType != DEVICE_EXTENSION_VOLUME) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    InterlockedIncrement(&extension->RefCount);
    if (!extension->AllSystemsGo) {
        FtpDecrementRefCount(extension);

        status = FtpAllSystemsGo(extension, Irp, TRUE, TRUE, TRUE);
        if (status == STATUS_PENDING) {
            return STATUS_PENDING;
        }

        if (!NT_SUCCESS(status)) {
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;
        }
    }

    if (extension->IsReadOnly) {
        irpSp = IoGetCurrentIrpStackLocation(Irp);
        if (irpSp->MajorFunction == IRP_MJ_WRITE) {
            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    if (extension->TargetObject) {
        IoCopyCurrentIrpStackLocationToNext(Irp);

        if (extension->WholeDisk) {
            irpSp = IoGetNextIrpStackLocation(Irp);
            offset = irpSp->Parameters.Read.ByteOffset.QuadPart;
            length = irpSp->Parameters.Read.Length;
            if (offset < 0 || offset + length > extension->PartitionLength) {
                FtpDecrementRefCount(extension);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return STATUS_INVALID_PARAMETER;
            }

            if (extension->CountersEnabled) {
                PIO_STACK_LOCATION currentIrpStack =
                    IoGetCurrentIrpStackLocation(Irp);
                PPMWMICOUNTERLIB_CONTEXT counterLib;
    
                counterLib = &extension->Root->PmWmiCounterLibContext;
                counterLib->PmWmiCounterIoStart(
                    extension->PmWmiCounterContext,
                    (PLARGE_INTEGER) &currentIrpStack->Parameters.Read);
            }

            irpSp->Parameters.Read.ByteOffset.QuadPart +=
                    extension->PartitionOffset;

            IoSetCompletionRoutine(Irp, FtpRefCountCompletionRoutine,
                                   extension, TRUE, TRUE, TRUE);

            IoMarkIrpPending(Irp);

            IoCallDriver(extension->WholeDisk, Irp);

        } else {

            if (extension->CountersEnabled) {
                PIO_STACK_LOCATION currentIrpStack =
                    IoGetCurrentIrpStackLocation(Irp);
                PPMWMICOUNTERLIB_CONTEXT counterLib;
    
                counterLib = &extension->Root->PmWmiCounterLibContext;
                counterLib->PmWmiCounterIoStart(
                    extension->PmWmiCounterContext,
                    (PLARGE_INTEGER) &currentIrpStack->Parameters.Read);
            }

            IoSetCompletionRoutine(Irp, FtpRefCountCompletionRoutine,
                                   extension, TRUE, TRUE, TRUE);

            IoMarkIrpPending(Irp);

            IoCallDriver(extension->TargetObject, Irp);
        }

        return STATUS_PENDING;
    }

    vol = extension->FtVolume;
    ASSERT(vol);

    packet = new DISPATCH_TP;
    if (!packet) {
        KeAcquireSpinLock(&extension->SpinLock, &irql);
        if (extension->EmergencyTransferPacketInUse) {
            IoMarkIrpPending(Irp);
            InsertTailList(&extension->
                           EmergencyTransferPacketQueue,
                           &Irp->Tail.Overlay.ListEntry);
            KeReleaseSpinLock(&extension->SpinLock, irql);
            return STATUS_PENDING;
        }
        packet = extension->EmergencyTransferPacket;
        extension->EmergencyTransferPacketInUse = TRUE;
        KeReleaseSpinLock(&extension->SpinLock, irql);
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    packet->Mdl = Irp->MdlAddress;
    packet->OriginalIrp = Irp;
    packet->Offset = irpSp->Parameters.Read.ByteOffset.QuadPart;
    packet->Length = irpSp->Parameters.Read.Length;
    packet->CompletionRoutine = FtpReadWriteCompletionRoutine;
    packet->TargetVolume = vol;
    packet->Thread = Irp->Tail.Overlay.Thread;
    packet->IrpFlags = irpSp->Flags;
    if (irpSp->MajorFunction == IRP_MJ_READ) {
        packet->ReadPacket = TRUE;
    } else {
        packet->ReadPacket = FALSE;
    }
    packet->Irp = Irp;
    packet->Extension = extension;

    if (extension->CountersEnabled) {
        PPMWMICOUNTERLIB_CONTEXT counterLib;

        counterLib = &extension->Root->PmWmiCounterLibContext;
        counterLib->PmWmiCounterIoStart(
            extension->PmWmiCounterContext,
            (PLARGE_INTEGER) &irpSp->Parameters.Read);
    }

    IoMarkIrpPending(Irp);

    TRANSFER(packet);

    return STATUS_PENDING;
}

NTSTATUS
FtpSetPowerState(
    IN  PROOT_EXTENSION RootExtension,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine sets the power state for the volume from the power state
    given to it by the disk.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLMGR_POWER_STATE input = (PVOLMGR_POWER_STATE) Irp->AssociatedIrp.SystemBuffer;
    PVOLUME_EXTENSION   extension;
    KIRQL               irql;
    POWER_STATE         powerState;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLMGR_POWER_STATE)) {

        return STATUS_INVALID_PARAMETER;
    }

    extension = FtpFindExtensionCoveringPartition(
                RootExtension, input->PartitionDeviceObject);
    if (!extension) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    if (extension->PowerState == input->PowerState) {
        KeReleaseSpinLock(&extension->SpinLock, irql);
        return STATUS_SUCCESS;
    }
    extension->PowerState = input->PowerState;
    KeReleaseSpinLock(&extension->SpinLock, irql);

    powerState.DeviceState = input->PowerState;
    PoSetPowerState(extension->DeviceObject, DevicePowerState, powerState);
    PoRequestPowerIrp(extension->DeviceObject, IRP_MN_SET_POWER,
                      powerState, NULL, NULL, NULL);

    return STATUS_SUCCESS;
}

NTSTATUS
FtDiskInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_DEVICE_CONTROL.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;

    Irp->IoStatus.Information = 0;

    FtpAcquire(extension->Root);

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_INTERNAL_VOLMGR_PARTITION_ARRIVED:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = FtpPartitionArrived(extension->Root, Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;

        case IOCTL_INTERNAL_VOLMGR_PARTITION_REMOVED:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = FtpPartitionRemoved(extension->Root, Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;

        case IOCTL_INTERNAL_VOLMGR_WHOLE_DISK_REMOVED:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = FtpWholeDiskRemoved(extension->Root, Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;

        case IOCTL_INTERNAL_VOLMGR_REFERENCE_DEPENDANT_VOLUMES:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = FtpReferenceDependantVolume(extension->Root, Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;

        case IOCTL_INTERNAL_VOLMGR_QUERY_CHANGE_PARTITION:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = FtpQueryChangePartition(extension->Root, Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;

        case IOCTL_INTERNAL_VOLMGR_CANCEL_CHANGE_PARTITION:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;

        case IOCTL_INTERNAL_VOLMGR_PARTITION_CHANGED:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = FtpPartitionChanged(extension->Root, Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;

        case IOCTL_INTERNAL_VOLMGR_PMWMICOUNTERLIB_CONTEXT:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = FtpPmWmiCounterLibContext(extension->Root, Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;

        case IOCTL_INTERNAL_VOLMGR_SET_POWER_STATE:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = FtpSetPowerState(extension->Root, Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;


        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

    }

    FtpRelease(extension->Root);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}
VOID
FtpVolumeReadOnlyCallback(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    if (Extension->ZeroRefContext) {
        Extension->IsReadOnly = TRUE;
    } else {
        Extension->IsReadOnly = FALSE;
    }
}

VOID
FtpSetTargetCallback(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine sets the given target object.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    None.

--*/

{
    PSET_TARGET_CONTEXT context = (PSET_TARGET_CONTEXT) Extension->ZeroRefContext;

    Extension->OldWholeDiskPdo = Extension->WholeDiskPdo;
    Extension->TargetObject = context->TargetObject;
    Extension->FtVolume = context->FtVolume;
    Extension->WholeDiskPdo = context->WholeDiskPdo;
    Extension->WholeDisk = NULL;
    Extension->PartitionOffset = 0;
    Extension->PartitionLength = 0;
    KeSetEvent(&context->Event, IO_NO_INCREMENT, FALSE);
}

VOID
FtpCancelRoutine(
    IN OUT  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine is called on when the given IRP is cancelled.  It
    will dequeue this IRP off the work queue and complete the
    request as CANCELLED.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IRP.

Return Value:

    None.

--*/

{
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

NTSTATUS
FtpChangeNotify(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine queues up a change notify IRP to be completed when
    a change occurs in the FT state.

Arguments:

    Extension   - Supplies the root extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    KIRQL       irql;
    NTSTATUS    status;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoAcquireCancelSpinLock(&irql);
    if (Irp->Cancel) {
        status = STATUS_CANCELLED;
    } else {
        InsertTailList(&RootExtension->ChangeNotifyIrpList,
                       &Irp->Tail.Overlay.ListEntry);
        status = STATUS_PENDING;
        IoMarkIrpPending(Irp);
        IoSetCancelRoutine(Irp, FtpCancelRoutine);
    }
    IoReleaseCancelSpinLock(irql);

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}

VOID
FtDiskShutdownFlushCompletionRoutine(
    IN  PVOID       Irp,
    IN  NTSTATUS    Status
    )

/*++

Routine Description:

    This is the completion routine for FtDiskShutdownFlush and
    FtDiskPagingNotification.

Arguments:

    Irp         - IRP involved.

    Status      - Status of operation.

Return Value:

    None.

--*/

{
    PIRP                irp = (PIRP) Irp;
    PIO_STACK_LOCATION  irpSp;
    PVOLUME_EXTENSION   extension;

    irpSp = IoGetCurrentIrpStackLocation(irp);
    extension = (PVOLUME_EXTENSION) irpSp->DeviceObject->DeviceExtension;

    FtpDecrementRefCount(extension);

    irp->IoStatus.Status = Status;
    irp->IoStatus.Information = 0;

    if (irpSp->MajorFunction == IRP_MJ_POWER) {
        PoStartNextPowerIrp(irp);
    }

    IoCompleteRequest(irp, IO_DISK_INCREMENT);
}

typedef struct _FTP_SHUTDOWN_CONTEXT {
    PIRP    Irp;
    LONG    RefCount;
} FTP_SHUTDOWN_CONTEXT, *PFTP_SHUTDOWN_CONTEXT;

NTSTATUS
FtDiskShutdownFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_SHUTDOWN and IRP_MJ_FLUSH.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION                   extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    PROOT_EXTENSION                     rootExtension;
    ULONG                               numVolumes, i;
    PVOLUME_EXTENSION*                  arrayOfVolumes;
    PLIST_ENTRY                         l;
    NTSTATUS                            status;
    PFT_VOLUME                          vol;
    PFTP_SHUTDOWN_CONTEXT               context;
    PIO_STACK_LOCATION                  irpSp;

    if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {

        rootExtension = (PROOT_EXTENSION) extension;
        FtpAcquire(rootExtension);

        numVolumes = rootExtension->NextVolumeNumber;
        arrayOfVolumes = (PVOLUME_EXTENSION*)
                         ExAllocatePool(PagedPool,
                                        numVolumes*sizeof(PVOLUME_EXTENSION));
        if (!arrayOfVolumes) {
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        numVolumes = 0;
        for (l = rootExtension->VolumeList.Flink;
             l != &rootExtension->VolumeList; l = l->Flink) {

            extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

            KeWaitForSingleObject(&extension->Semaphore, Executive, KernelMode,
                                  FALSE, NULL);
            status = FtpAllSystemsGo(extension, NULL, FALSE, TRUE, TRUE);
            KeReleaseSemaphore(&extension->Semaphore, IO_NO_INCREMENT, 1,
                               FALSE);

            if (!NT_SUCCESS(status)) {
                continue;
            }

            vol = extension->FtVolume;
            if (vol) {
                arrayOfVolumes[numVolumes++] = extension;
            } else {
                FtpDecrementRefCount(extension);
            }
        }

        FtpRelease(rootExtension);

        if (numVolumes) {

            context = (PFTP_SHUTDOWN_CONTEXT)
                      ExAllocatePool(NonPagedPool,
                                     sizeof(FTP_SHUTDOWN_CONTEXT));
            if (!context) {
                for (i = 0; i < numVolumes; i++) {
                    FtpDecrementRefCount(extension);
                }
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            Irp->IoStatus.Status = STATUS_SUCCESS;

            context->Irp = Irp;
            context->RefCount = (LONG) numVolumes;

            IoMarkIrpPending(Irp);

            for (i = 0; i < numVolumes; i++) {
                vol = arrayOfVolumes[i]->FtVolume;
                vol->SetDirtyBit(FALSE, FtDiskShutdownCompletionRoutine,
                                 context);
            }

            ExFreePool(arrayOfVolumes);

            return STATUS_PENDING;
        }

        ExFreePool(arrayOfVolumes);

        //
        // Complete this request.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_SUCCESS;
    }

    status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, TRUE);
    if (status == STATUS_PENDING) {
        return status;
    }
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (extension->TargetObject) {
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, FtpRefCountCompletionRoutine,
                               extension, TRUE, TRUE, TRUE);
        IoMarkIrpPending(Irp);

        IoCallDriver(extension->TargetObject, Irp);

        return STATUS_PENDING;
    }

    vol = extension->FtVolume;
    ASSERT(vol);

    IoMarkIrpPending(Irp);
    irpSp = IoGetCurrentIrpStackLocation(Irp);
    irpSp->DeviceObject = DeviceObject;

    vol->BroadcastIrp(Irp, FtDiskShutdownFlushCompletionRoutine, Irp);

    return STATUS_PENDING;
}

NTSTATUS
FtpSignalCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Event
    )

{
    KeSetEvent((PKEVENT) Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
FtpQueryRemoveCallback(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine sets the ZeroRef event.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    None.

--*/

{
    KeSetEvent((PKEVENT) Extension->ZeroRefContext, IO_NO_INCREMENT, FALSE);
}

VOID
FtpStartCallback(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine sets the ZeroRef event.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    None.

--*/

{
    Extension->IsStarted = TRUE;
    KeSetEvent((PKEVENT) Extension->ZeroRefContext, IO_NO_INCREMENT, FALSE);
}

NTSTATUS
FtpCheckForQueryRemove(
    IN OUT  PVOLUME_EXTENSION   Extension
    )

{
    KIRQL       irql;
    NTSTATUS    status;

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (Extension->InPagingPath || Extension->RemoveInProgress) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        status = STATUS_INVALID_DEVICE_REQUEST;
    } else {
        InterlockedExchange(&Extension->AllSystemsGo, FALSE);
        Extension->RemoveInProgress = TRUE;
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        status = STATUS_SUCCESS;
    }

    return status;
}

BOOLEAN
FtpCheckForCancelRemove(
    IN OUT  PVOLUME_EXTENSION   Extension
    )

{
    KIRQL   irql;
    BOOLEAN removeInProgress;

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    removeInProgress = Extension->RemoveInProgress;
    Extension->RemoveInProgress = FALSE;
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    return removeInProgress;
}

VOID
FtpRemoveHelper(
    IN OUT  PVOLUME_EXTENSION   Extension
    )

{
    KIRQL   irql;

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    InterlockedExchange(&Extension->AllSystemsGo, FALSE);
    Extension->IsStarted = FALSE;
    Extension->RemoveInProgress = FALSE;
    KeReleaseSpinLock(&Extension->SpinLock, irql);
}

NTSTATUS
FtDiskCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine cancels all of the IRPs currently queued on
    the given device.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the cleanup IRP.

Return Value:

    STATUS_SUCCESS  - Success.

--*/

{
    PROOT_EXTENSION     rootExtension = (PROOT_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT        file = irpSp->FileObject;
    PVOLUME_EXTENSION   extension;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PIRP                irp;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    if (rootExtension->DeviceExtensionType != DEVICE_EXTENSION_ROOT) {
        ASSERT(rootExtension->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);
        extension = (PVOLUME_EXTENSION) rootExtension;
        if (extension->RevertOnCloseFileObject == file) {
            FtpAcquire(extension->Root);
            FtpRevertGptAttributes(extension);
            FtpRelease(extension->Root);
        }
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_SUCCESS;
    }

    IoAcquireCancelSpinLock(&irql);

    for (;;) {

        for (l = rootExtension->ChangeNotifyIrpList.Flink;
             l != &rootExtension->ChangeNotifyIrpList; l = l->Flink) {

            irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
            if (IoGetCurrentIrpStackLocation(irp)->FileObject == file) {
                break;
            }
        }

        if (l == &rootExtension->ChangeNotifyIrpList) {
            break;
        }

        irp->Cancel = TRUE;
        irp->CancelIrql = irql;
        irp->CancelRoutine = NULL;
        FtpCancelRoutine(DeviceObject, irp);

        IoAcquireCancelSpinLock(&irql);
    }

    IoReleaseCancelSpinLock(irql);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called when the driver loads loads.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                    status;
    PDEVICE_OBJECT              pdo = 0, fdo;
    PROOT_EXTENSION             rootExtension;

    DriverObject->DriverUnload = FtDiskUnload;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = FtDiskCreate;
    DriverObject->MajorFunction[IRP_MJ_READ] = FtDiskReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = FtDiskReadWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = FtDiskDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = FtDiskInternalDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = FtDiskShutdownFlush;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS] = FtDiskShutdownFlush;
    DriverObject->MajorFunction[IRP_MJ_PNP] = FtDiskPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = FtDiskPower;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = FtDiskCleanup;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = FtWmi;

    ObReferenceObject(DriverObject);

    status = IoReportDetectedDevice(
                 DriverObject,
                 InterfaceTypeUndefined,
                 -1,
                 -1,
                 NULL,
                 NULL,
                 TRUE,
                 &pdo
             );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = FtDiskAddDevice(DriverObject, pdo, RegistryPath);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    fdo = IoGetAttachedDeviceReference(pdo);
    ObDereferenceObject(fdo);

    rootExtension = (PROOT_EXTENSION) fdo->DeviceExtension;

    status = IoRegisterDeviceInterface(rootExtension->Pdo,
                                       &VOLMGR_VOLUME_MANAGER_GUID, NULL,
                                       &rootExtension->VolumeManagerInterfaceName);
    if (NT_SUCCESS(status)) {
        status = IoSetDeviceInterfaceState(
                 &rootExtension->VolumeManagerInterfaceName, TRUE);
    } else {
        rootExtension->VolumeManagerInterfaceName.Buffer = NULL;
    }

    IoRegisterBootDriverReinitialization(DriverObject,
                                         FtpBootDriverReinitialization,
                                         rootExtension);

    IoRegisterDriverReinitialization(DriverObject, FtpDriverReinitialization,
                                     rootExtension);

    FtpQueryRegistryRevertEntries(rootExtension,
                                  &rootExtension->GptAttributeRevertEntries,
                                  &rootExtension->NumberOfAttributeRevertEntries);

    RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE, RegistryPath->Buffer,
                           REVERT_GPT_ATTRIBUTES_REGISTRY_NAME);

    IoInvalidateDeviceState(rootExtension->Pdo);

    return STATUS_SUCCESS;
}

VOID
FtpLogError(
    IN  PDEVICE_EXTENSION   Extension,
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  NTSTATUS            SpecificIoStatus,
    IN  NTSTATUS            FinalStatus,
    IN  ULONG               UniqueErrorValue
    )

/*++

Routine Description:

    This routine performs error logging for the FT driver.

Arguments:

    Extension        - Extension.
    LogicalDiskId    - Logical disk id representing failing device.
    SpecificIoStatus - IO error status value.
    FinalStatus      - Status returned for failure.
    UniqueErrorValue - Values defined to uniquely identify error location.

Return Value:

    None

--*/

{
    PFTP_LOG_ERROR_CONTEXT  context;

    context = (PFTP_LOG_ERROR_CONTEXT)
              ExAllocatePool(NonPagedPool, sizeof(FTP_LOG_ERROR_CONTEXT));
    if (!context) {
        return;
    }

    ExInitializeWorkItem(context, FtpLogErrorWorker, context);
    context->Extension = Extension;
    context->LogicalDiskId = LogicalDiskId;
    context->SpecificIoStatus = SpecificIoStatus;
    context->FinalStatus = FinalStatus;
    context->UniqueErrorValue = UniqueErrorValue;

    ExQueueWorkItem(context, CriticalWorkQueue);
}

VOID
FtpQueueWorkItem(
    IN  PROOT_EXTENSION     RootExtension,
    IN  PWORK_QUEUE_ITEM    WorkItem
    )

/*++

Routine Description:

    This routine queues a work item to a private worker thread.

Arguments:

    RootExtension       - Supplies the root device extension.

    WorkItem            - The work item to be queued.

Return Value:

    None.

--*/

{
    KIRQL   irql;

    KeAcquireSpinLock(&RootExtension->SpinLock, &irql);
    InsertTailList(&RootExtension->WorkerQueue, &WorkItem->List);
    KeReleaseSpinLock(&RootExtension->SpinLock, irql);

    KeReleaseSemaphore(&RootExtension->WorkerSemaphore, 0, 1, FALSE);
}

VOID
FtpNotify(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine completes all of the change notify irps in the queue.

Arguments:

    RootExtension   - Supplies the root extension.

    Extension       - Supplies the specific extension being changed.

Return Value:

    None.

--*/

{
    LIST_ENTRY                          q;
    KIRQL                               irql;
    PLIST_ENTRY                         p;
    PIRP                                irp;
    TARGET_DEVICE_CUSTOM_NOTIFICATION   notification;

    InitializeListHead(&q);
    IoAcquireCancelSpinLock(&irql);
    while (!IsListEmpty(&RootExtension->ChangeNotifyIrpList)) {
        p = RemoveHeadList(&RootExtension->ChangeNotifyIrpList);
        irp = CONTAINING_RECORD(p, IRP, Tail.Overlay.ListEntry);
        IoSetCancelRoutine(irp, NULL);
        InsertTailList(&q, p);
    }
    IoReleaseCancelSpinLock(irql);

    while (!IsListEmpty(&q)) {
        p = RemoveHeadList(&q);
        irp = CONTAINING_RECORD(p, IRP, Tail.Overlay.ListEntry);
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    if (Extension->IsStarted) {
        notification.Version = 1;
        notification.Size = (USHORT)
                            FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION,
                                         CustomDataBuffer);
        RtlCopyMemory(&notification.Event,
                      &GUID_IO_VOLUME_PHYSICAL_CONFIGURATION_CHANGE,
                      sizeof(GUID_IO_VOLUME_PHYSICAL_CONFIGURATION_CHANGE));
        notification.FileObject = NULL;
        notification.NameBufferOffset = -1;

        IoReportTargetDeviceChangeAsynchronous(Extension->DeviceObject,
                                               &notification, NULL, NULL);
    }
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

NTSTATUS
FtpCheckForCompleteVolume(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PFT_VOLUME          FtVolume
    )

{
    KIRQL   irql;

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (!FtVolume->IsComplete(TRUE)) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return STATUS_NO_SUCH_DEVICE;
    }
    FtVolume->CompleteNotification(TRUE);
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    return STATUS_SUCCESS;
}

BOOLEAN
FsRtlIsTotalDeviceFailure(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine is given an NTSTATUS value and make a determination as to
    if this value indicates that the complete device has failed and therefore
    should no longer be used, or if the failure is one that indicates that
    continued use of the device is ok (i.e. a sector failure).

Arguments:

    Status - the NTSTATUS value to test.

Return Value:

    TRUE  - The status value given is believed to be a fatal device error.
    FALSE - The status value given is believed to be a sector failure, but not
            a complete device failure.
--*/

{
    if (NT_SUCCESS(Status)) {

        //
        // All warning and informational errors will be resolved here.
        //

        return FALSE;
    }

    switch (Status) {
    case STATUS_CRC_ERROR:
    case STATUS_DEVICE_DATA_ERROR:
        return FALSE;
    default:
        return TRUE;
    }
}

BOOLEAN
FtpIsWorseStatus(
    IN  NTSTATUS    Status1,
    IN  NTSTATUS    Status2
    )

/*++

Routine Description:

    This routine compares two NTSTATUS codes and decides if Status1 is
    worse than Status2.

Arguments:

    Status1 - Supplies the first status.

    Status2 - Supplies the second status.

Return Value:

    FALSE   - Status1 is not worse than Status2.

    TRUE    - Status1 is worse than Status2.


--*/

{
    if (NT_ERROR(Status2) && FsRtlIsTotalDeviceFailure(Status2)) {
        return FALSE;
    }

    if (NT_ERROR(Status1) && FsRtlIsTotalDeviceFailure(Status1)) {
        return TRUE;
    }

    if (NT_ERROR(Status2)) {
        return FALSE;
    }

    if (NT_ERROR(Status1)) {
        return TRUE;
    }

    if (NT_WARNING(Status2)) {
        return FALSE;
    }

    if (NT_WARNING(Status1)) {
        return TRUE;
    }

    if (NT_INFORMATION(Status2)) {
        return FALSE;
    }

    if (NT_INFORMATION(Status1)) {
        return TRUE;
    }

    return FALSE;
}

VOID
FtDiskShutdownCompletionRoutine(
    IN  PVOID       Context,
    IN  NTSTATUS    Status
    )

{
    PFTP_SHUTDOWN_CONTEXT   context = (PFTP_SHUTDOWN_CONTEXT) Context;

    if (InterlockedDecrement(&context->RefCount)) {
        return;
    }

    IoCompleteRequest(context->Irp, IO_NO_INCREMENT);
    ExFreePool(context);
}

NTSTATUS
FtpCreateLogicalDiskHelper(
    IN OUT  PROOT_EXTENSION         RootExtension,
    IN      FT_LOGICAL_DISK_TYPE    LogicalDiskType,
    IN      USHORT                  NumberOfMembers,
    IN      PFT_LOGICAL_DISK_ID     ArrayOfMembers,
    IN      USHORT                  ConfigurationInformationSize,
    IN      PVOID                   ConfigurationInformation,
    IN      USHORT                  StateInformationSize,
    IN      PVOID                   StateInformation,
    OUT     PFT_LOGICAL_DISK_ID     NewLogicalDiskId
    )

{
    BOOLEAN                                         lockZero;
    FT_MIRROR_AND_SWP_STATE_INFORMATION             actualStateInfo;
    FT_REDISTRIBUTION_STATE_INFORMATION             redistStateInfo;
    PHANDLE                                         handleArray;
    PFT_LOGICAL_DISK_INFORMATION_SET                diskInfoSet;
    NTSTATUS                                        status;
    FT_LOGICAL_DISK_ID                              newLogicalDiskId;
    PFT_VOLUME*                                     volArray;
    PVOLUME_EXTENSION*                              extArray;
    PVOLUME_EXTENSION                               extension;
    KIRQL                                           irql;
    USHORT                                          i, j;
    KEVENT                                          event;
    PCOMPOSITE_FT_VOLUME                            comp;
    WCHAR                                           deviceNameBuffer[64];
    UNICODE_STRING                                  deviceName;
    UCHAR                                           newUniqueIdBuffer[UNIQUE_ID_MAX_BUFFER_SIZE];
    PMOUNTDEV_UNIQUE_ID                             newUniqueId;
    SET_TARGET_CONTEXT                              context;
    ULONG                                           alignment;
    PFT_REDISTRIBUTION_CONFIGURATION_INFORMATION    redistConfig;
    PFT_REDISTRIBUTION_STATE_INFORMATION            redistState;
    PFT_MIRROR_AND_SWP_STATE_INFORMATION            mirrorState;

    switch (LogicalDiskType) {

        case FtVolumeSet:
            ConfigurationInformation = NULL;
            ConfigurationInformationSize = 0;
            StateInformation = NULL;
            StateInformationSize = 0;
            lockZero = FALSE;
            if (NumberOfMembers == 0) {
                return STATUS_INVALID_PARAMETER;
            }
            break;

        case FtStripeSet:
            if (ConfigurationInformationSize <
                sizeof(FT_STRIPE_SET_CONFIGURATION_INFORMATION)) {

                return STATUS_INVALID_PARAMETER;
            }
            ConfigurationInformationSize =
                    sizeof(FT_STRIPE_SET_CONFIGURATION_INFORMATION);
            StateInformation = NULL;
            StateInformationSize = 0;
            lockZero = TRUE;
            if (NumberOfMembers == 0) {
                return STATUS_INVALID_PARAMETER;
            }
            break;

        case FtMirrorSet:
            if (ConfigurationInformationSize <
                sizeof(FT_MIRROR_SET_CONFIGURATION_INFORMATION)) {

                return STATUS_INVALID_PARAMETER;
            }
            ConfigurationInformationSize =
                    sizeof(FT_MIRROR_SET_CONFIGURATION_INFORMATION);
            if (!StateInformation) {
                actualStateInfo.IsDirty = TRUE;
                actualStateInfo.IsInitializing = FALSE;
                actualStateInfo.UnhealthyMemberNumber = 1;
                actualStateInfo.UnhealthyMemberState = FtMemberRegenerating;
                StateInformation = &actualStateInfo;
                StateInformationSize = sizeof(actualStateInfo);
            }
            lockZero = FALSE;
            if (NumberOfMembers != 2) {
                return STATUS_INVALID_PARAMETER;
            }
            j = NumberOfMembers;
            for (i = 0; i < NumberOfMembers; i++) {
                if (!ArrayOfMembers[i]) {
                    if (j < NumberOfMembers) {
                        return STATUS_INVALID_PARAMETER;
                    }
                    j = i;
                    mirrorState = (PFT_MIRROR_AND_SWP_STATE_INFORMATION)
                                  StateInformation;
                    mirrorState->UnhealthyMemberNumber = i;
                    mirrorState->UnhealthyMemberState = FtMemberOrphaned;
                }
            }
            break;

        case FtStripeSetWithParity:
            if (ConfigurationInformationSize <
                sizeof(FT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION)) {

                return STATUS_INVALID_PARAMETER;
            }
            ConfigurationInformationSize =
                    sizeof(FT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION);
            if (!StateInformation) {
                actualStateInfo.IsDirty = TRUE;
                actualStateInfo.IsInitializing = TRUE;
                actualStateInfo.UnhealthyMemberNumber = 0;
                actualStateInfo.UnhealthyMemberState = FtMemberHealthy;
                StateInformation = &actualStateInfo;
                StateInformationSize = sizeof(actualStateInfo);
            }
            lockZero = TRUE;
            if (NumberOfMembers < 3) {
                return STATUS_INVALID_PARAMETER;
            }
            j = NumberOfMembers;
            for (i = 0; i < NumberOfMembers; i++) {
                if (!ArrayOfMembers[i]) {
                    if (j < NumberOfMembers) {
                        return STATUS_INVALID_PARAMETER;
                    }
                    j = i;
                    mirrorState = (PFT_MIRROR_AND_SWP_STATE_INFORMATION)
                                  StateInformation;
                    mirrorState->IsInitializing = FALSE;
                    mirrorState->UnhealthyMemberNumber = i;
                    mirrorState->UnhealthyMemberState = FtMemberOrphaned;
                }
            }
            break;

        case FtRedistribution:
            if (ConfigurationInformationSize <
                sizeof(FT_REDISTRIBUTION_CONFIGURATION_INFORMATION)) {

                return STATUS_INVALID_PARAMETER;
            }
            ConfigurationInformationSize =
                    sizeof(FT_REDISTRIBUTION_CONFIGURATION_INFORMATION);
            if (!StateInformation) {
                redistStateInfo.BytesRedistributed = 0;
                StateInformation = &redistStateInfo;
                StateInformationSize = sizeof(redistStateInfo);
            }
            redistConfig = (PFT_REDISTRIBUTION_CONFIGURATION_INFORMATION)
                           ConfigurationInformation;
            if (redistConfig->StripeSize&0x80000000) {
                lockZero = TRUE;
                redistConfig->StripeSize &= (~0x80000000);
                redistState = (PFT_REDISTRIBUTION_STATE_INFORMATION)
                              StateInformation;
                redistState->BytesRedistributed = 0x7FFFFFFFFFFFFFFF;
            } else {
                lockZero = FALSE;
            }
            if (NumberOfMembers != 2) {
                return STATUS_INVALID_PARAMETER;
            }
            break;

        default:
            return STATUS_INVALID_PARAMETER;

    }

    handleArray = (PHANDLE)
                  ExAllocatePool(NonPagedPool, NumberOfMembers*sizeof(HANDLE));
    if (!handleArray) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (i = lockZero ? 0 : 1; i < NumberOfMembers; i++) {
        if (!ArrayOfMembers[i]) {
            continue;
        }
        if (!FtpLockLogicalDisk(RootExtension, ArrayOfMembers[i],
                                &handleArray[i])) {
            break;
        }
    }

    if (i < NumberOfMembers) {
        for (j = lockZero ? 0 : 1; j < i; j++) {
            if (ArrayOfMembers[j]) {
                ZwClose(handleArray[j]);
            }
        }
        ExFreePool(handleArray);
        return STATUS_ACCESS_DENIED;
    }

    if (LogicalDiskType == FtMirrorSet &&
        ArrayOfMembers[0] &&
        !(extension = FtpFindExtension(RootExtension, ArrayOfMembers[0])) &&
        (extension = FtpFindExtensionCoveringDiskId(RootExtension,
                                                    ArrayOfMembers[0]))) {

        status = FtpInsertMirror(RootExtension, ArrayOfMembers,
                                 NewLogicalDiskId);

        if (ArrayOfMembers[1]) {
            ZwClose(handleArray[1]);
        }
        ExFreePool(handleArray);
        return status;
    }

    diskInfoSet = RootExtension->DiskInfoSet;
    status = diskInfoSet->AddNewLogicalDisk(LogicalDiskType,
                                            NumberOfMembers,
                                            ArrayOfMembers,
                                            ConfigurationInformationSize,
                                            ConfigurationInformation,
                                            StateInformationSize,
                                            StateInformation,
                                            &newLogicalDiskId);
    if (!NT_SUCCESS(status)) {
        for (i = lockZero ? 0 : 1; i < NumberOfMembers; i++) {
            if (ArrayOfMembers[i]) {
                ZwClose(handleArray[i]);
            }
        }
        ExFreePool(handleArray);
        return status;
    }

    volArray = (PFT_VOLUME*)
               ExAllocatePool(NonPagedPool, NumberOfMembers*sizeof(PFT_VOLUME));
    if (!volArray) {
        for (i = lockZero ? 0 : 1; i < NumberOfMembers; i++) {
            if (ArrayOfMembers[i]) {
                ZwClose(handleArray[i]);
            }
        }
        ExFreePool(handleArray);
        diskInfoSet->BreakLogicalDisk(newLogicalDiskId);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    extArray = (PVOLUME_EXTENSION*)
               ExAllocatePool(NonPagedPool, NumberOfMembers*
                              sizeof(PVOLUME_EXTENSION));
    if (!extArray) {
        for (i = lockZero ? 0 : 1; i < NumberOfMembers; i++) {
            if (ArrayOfMembers[i]) {
                ZwClose(handleArray[i]);
            }
        }
        ExFreePool(handleArray);
        ExFreePool(volArray);
        diskInfoSet->BreakLogicalDisk(newLogicalDiskId);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    alignment = 0;
    for (i = 0; i < NumberOfMembers; i++) {

        if (!ArrayOfMembers[i]) {
            extArray[i] = NULL;
            volArray[i] = NULL;
            continue;
        }

        extension = FtpFindExtension(RootExtension, ArrayOfMembers[i]);
        extArray[i] = extension;
        if (!extension || !extension->FtVolume) {
            break;
        }

        alignment |= extension->DeviceObject->AlignmentRequirement;

        volArray[i] = extension->FtVolume;
        if (!lockZero && i == 0) {
            continue;
        }

        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = NULL;
        context.FtVolume = NULL;
        context.WholeDiskPdo = NULL;
        FtpZeroRefCallback(extension, FtpSetTargetCallback, &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);
    }

    if (i < NumberOfMembers) {
        for (j = 0; j < i; j++) {
            if (ArrayOfMembers[j]) {
                KeAcquireSpinLock(&extArray[j]->SpinLock, &irql);
                extArray[j]->FtVolume = volArray[j];
                KeReleaseSpinLock(&extArray[j]->SpinLock, irql);
            }
        }
        for (i = lockZero ? 0 : 1; i < NumberOfMembers; i++) {
            if (ArrayOfMembers[i]) {
                ZwClose(handleArray[i]);
            }
        }
        ExFreePool(handleArray);
        ExFreePool(extArray);
        ExFreePool(volArray);
        diskInfoSet->BreakLogicalDisk(newLogicalDiskId);
        return STATUS_INVALID_PARAMETER;
    }

    switch (LogicalDiskType) {

        case FtVolumeSet:
            comp = new VOLUME_SET;
            break;

        case FtStripeSet:
            comp = new STRIPE;
            break;

        case FtMirrorSet:
            comp = new MIRROR;
            break;

        case FtStripeSetWithParity:
            comp = new STRIPE_WP;
            break;

        case FtRedistribution:
            comp = new REDISTRIBUTION;
            break;

        default:
            comp = NULL;
            break;

    }

    if (!comp) {
        for (j = 0; j < NumberOfMembers; j++) {
            if (ArrayOfMembers[j]) {
                KeAcquireSpinLock(&extArray[j]->SpinLock, &irql);
                extArray[j]->FtVolume = volArray[j];
                KeReleaseSpinLock(&extArray[j]->SpinLock, irql);
            }
        }
        for (i = lockZero ? 0 : 1; i < NumberOfMembers; i++) {
            if (ArrayOfMembers[i]) {
                ZwClose(handleArray[i]);
            }
        }
        ExFreePool(handleArray);
        ExFreePool(extArray);
        ExFreePool(volArray);
        diskInfoSet->BreakLogicalDisk(newLogicalDiskId);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = comp->Initialize(RootExtension, newLogicalDiskId,
                              volArray, NumberOfMembers,
                              ConfigurationInformation, StateInformation);
    if (!NT_SUCCESS(status)) {
        for (j = 0; j < NumberOfMembers; j++) {
            if (ArrayOfMembers[j]) {
                KeAcquireSpinLock(&extArray[j]->SpinLock, &irql);
                extArray[j]->FtVolume = volArray[j];
                KeReleaseSpinLock(&extArray[j]->SpinLock, irql);
            }
        }
        for (i = lockZero ? 0 : 1; i < NumberOfMembers; i++) {
            if (ArrayOfMembers[i]) {
                ZwClose(handleArray[i]);
            }
        }
        delete comp;
        ExFreePool(handleArray);
        ExFreePool(extArray);
        diskInfoSet->BreakLogicalDisk(newLogicalDiskId);
        return status;
    }

    for (i = lockZero ? 0 : 1; i < NumberOfMembers; i++) {
        extension = extArray[i];
        if (!extension) {
            continue;
        }
        RemoveEntryList(&extension->ListEntry);
        InsertTailList(&RootExtension->DeadVolumeList, &extension->ListEntry);
        FtpDeleteMountPoints(extension);
        FtpCleanupVolumeExtension(extension);
        ZwClose(handleArray[i]);
    }
    ExFreePool(handleArray);

    extension = extArray[0];
    ExFreePool(extArray);

    if (lockZero || !extension) {

        if (!FtpCreateNewDevice(RootExtension, NULL, comp, NULL, alignment,
                                FALSE, FALSE, FALSE, FALSE, 0)) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        swprintf(deviceNameBuffer, L"\\Device\\HarddiskVolume%d", extension->VolumeNumber);
        RtlInitUnicodeString(&deviceName, deviceNameBuffer);
        comp->CreateLegacyNameLinks(&deviceName);

        extension->DeviceObject->AlignmentRequirement = alignment;

        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = NULL;
        context.FtVolume = comp;
        context.WholeDiskPdo = NULL;
        FtpZeroRefCallback(extension, FtpSetTargetCallback, &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);

        newUniqueId = (PMOUNTDEV_UNIQUE_ID) newUniqueIdBuffer;
        FtpQueryUniqueIdBuffer(extension, newUniqueId->UniqueId,
                               &newUniqueId->UniqueIdLength);

        FtpUniqueIdNotify(extension, newUniqueId);

        FtpNotify(RootExtension, extension);
    }

    *NewLogicalDiskId = newLogicalDiskId;

    IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);

    return STATUS_SUCCESS;
}

VOID
FtpMemberOfflineCallback(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine is called to offline a partition after disk activity
    has stopped.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    None.

--*/

{
    PFT_PARTITION_OFFLINE_CONTEXT   offline = (PFT_PARTITION_OFFLINE_CONTEXT) Extension->ZeroRefContext;
    USHORT                          n, i;

    if (offline->Parent) {
        Extension->IsComplete = FALSE;
        n = offline->Parent->QueryNumberOfMembers();
        for (i = 0; i < n; i++) {
            if (offline->Parent->GetMember(i) == offline->Child) {
                offline->Parent->SetMember(i, NULL);
                break;
            }
        }
        if (!offline->Root->QueryNumberOfPartitions()) {
            Extension->FtVolume = NULL;
        }
    } else {
        Extension->FtVolume = NULL;
        Extension->IsComplete = FALSE;
    }

    KeSetEvent(offline->Event, IO_NO_INCREMENT, FALSE);
}

VOID
FtpInsertMemberCallback(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine inserts the given member into the given set.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    None.

--*/

{
    PINSERT_MEMBER_CONTEXT  context = (PINSERT_MEMBER_CONTEXT) Extension->ZeroRefContext;

    context->Parent->SetMember(context->MemberNumber, context->Member);
    KeSetEvent(&context->Event, IO_NO_INCREMENT, FALSE);
}

VOID
FtpReadWriteCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for FtDiskReadWrite dispatch routine.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PDISPATCH_TP                transferPacket = (PDISPATCH_TP) TransferPacket;
    PIRP                        irp = transferPacket->Irp;
    PVOLUME_EXTENSION           extension = transferPacket->Extension;
    KIRQL                       irql;
    PLIST_ENTRY                 l;
    PDISPATCH_TP                p;
    PIO_STACK_LOCATION          irpSp;
    PIRP                        nextIrp;

    irp->IoStatus = transferPacket->IoStatus;
    if (transferPacket == extension->EmergencyTransferPacket) {

        for (;;) {

            KeAcquireSpinLock(&extension->SpinLock, &irql);
            if (IsListEmpty(&extension->EmergencyTransferPacketQueue)) {
                extension->EmergencyTransferPacketInUse = FALSE;
                KeReleaseSpinLock(&extension->SpinLock, irql);
                break;
            }

            l = RemoveHeadList(&extension->EmergencyTransferPacketQueue);
            KeReleaseSpinLock(&extension->SpinLock, irql);

            nextIrp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);

            p = new DISPATCH_TP;
            if (!p) {
                p = transferPacket;
            }

            irpSp = IoGetCurrentIrpStackLocation(nextIrp);

            p->Mdl = nextIrp->MdlAddress;
            p->Offset = irpSp->Parameters.Read.ByteOffset.QuadPart;
            p->Length = irpSp->Parameters.Read.Length;
            p->CompletionRoutine = FtpReadWriteCompletionRoutine;
            p->TargetVolume = extension->FtVolume;
            p->Thread = nextIrp->Tail.Overlay.Thread;
            p->IrpFlags = irpSp->Flags;
            if (irpSp->MajorFunction == IRP_MJ_READ) {
                p->ReadPacket = TRUE;
            } else {
                p->ReadPacket = FALSE;
            }
            p->Irp = nextIrp;
            p->Extension = extension;

            if (p == transferPacket) {
                TRANSFER(p);
                break;
            } else {
                TRANSFER(p);
            }
        }

    } else {
        delete transferPacket;
    }

    if (extension->CountersEnabled) {
        PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);
        if (irpStack->MajorFunction == IRP_MJ_READ ||
            irpStack->MajorFunction == IRP_MJ_WRITE) {
            PPMWMICOUNTERLIB_CONTEXT counterLib;
    
            counterLib = &extension->Root->PmWmiCounterLibContext;
            counterLib->PmWmiCounterIoComplete(
                extension->PmWmiCounterContext, irp,
                (PLARGE_INTEGER) &irpStack->Parameters.Read);
        }
    }

    IoCompleteRequest(irp, IO_DISK_INCREMENT);

    FtpDecrementRefCount(extension);
}

VOID
FtpRefCountCompletion(
    IN  PVOID       Extension,
    IN  NTSTATUS    Status
    )

/*++

Routine Description:

    Completion routine of type FT_COMPLETION_ROUTINE that decrements
    the ref count.

Arguments:

    Extension   - Supplies the device extension.

    Status      - Supplies the status of the operation.

Return Value:

    None.

--*/

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) Extension;

    FtpDecrementRefCount(extension);
}

NTSTATUS
FtpAddPartition(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PDEVICE_OBJECT      Partition,
    IN  PDEVICE_OBJECT      WholeDiskPdo
    )

/*++

Routine Description:

    This routine adds the given partition to the given ft set.

Arguments:

    Extension       - Supplies the extension where the FT set is rooted.

    Partition       - Supplies the new partition.

    WholeDiskPdo    - Supplies the whole disk PDO.

Return Value:

    NTSTATUS

--*/

{
    PFT_VOLUME                          vol = Extension->FtVolume;
    PROOT_EXTENSION                     rootExtension = Extension->Root;
    PFT_LOGICAL_DISK_INFORMATION_SET    diskInfoSet = rootExtension->DiskInfoSet;
    NTSTATUS                            status;
    ULONG                               diskNumber, n;
    LONGLONG                            offset;
    FT_LOGICAL_DISK_ID                  partitionDiskId, diskId;
    PFT_LOGICAL_DISK_DESCRIPTION        parentDesc;
    PFT_VOLUME                          parent, child, c;
    BOOLEAN                             inPagingPath, wasStarted;
    KIRQL                               irql;
    PDEVICE_OBJECT                      leftmost;
    BOOLEAN                             nameChange;
    WCHAR                               deviceNameBuffer[64];
    UNICODE_STRING                      deviceName;
    UCHAR                               registryState[100];
    USHORT                              registryStateSize;

    status = FtpQueryPartitionInformation(Extension->Root,
                                          Partition, &diskNumber, &offset,
                                          NULL, NULL, NULL, NULL, NULL, NULL,
                                          NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    partitionDiskId = diskId =
            diskInfoSet->QueryPartitionLogicalDiskId(diskNumber, offset);
    if (!diskId) {
        return STATUS_INVALID_PARAMETER;
    }

    for (;;) {
        parentDesc = diskInfoSet->GetParentLogicalDiskDescription(diskId);
        if (!parentDesc) {
            return STATUS_INVALID_PARAMETER;
        }
        parent = vol->GetContainedLogicalDisk(parentDesc->LogicalDiskId);
        if (parent) {
            break;
        }
        diskId = parentDesc->LogicalDiskId;
    }

    child = FtpBuildFtVolume(rootExtension, diskId, Partition, WholeDiskPdo);
    if (!child) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    parent->SetMember(parentDesc->u.Other.ThisMemberNumber, child);
    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (!Extension->IsComplete) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);

        leftmost = Extension->FtVolume->GetLeftmostPartitionObject();

        KeAcquireSpinLock(&Extension->SpinLock, &irql);
        if (!Extension->IsComplete) {

            parentDesc = diskInfoSet->GetParentLogicalDiskDescription(
                         partitionDiskId, &n);
            while (parentDesc) {

                if (parentDesc->u.Other.ByteOffsetToStateInformation &&
                    (c = vol->GetContainedLogicalDisk(parentDesc->LogicalDiskId))) {

                    c->NewStateArrival((PCHAR) parentDesc +
                            parentDesc->u.Other.ByteOffsetToStateInformation);

                    KeReleaseSpinLock(&Extension->SpinLock, irql);

                    if (FtpQueryStateFromRegistry(parentDesc->LogicalDiskId,
                                                  registryState,
                                                  sizeof(registryState),
                                                  &registryStateSize)) {

                        KeAcquireSpinLock(&Extension->SpinLock, &irql);
                        if (Extension->IsComplete) {
                            break;
                        }

                        if (!Extension->IsOffline) {
                            c->NewStateArrival(registryState);
                        }

                    } else {
                        KeAcquireSpinLock(&Extension->SpinLock, &irql);
                        if (Extension->IsComplete) {
                            break;
                        }
                    }
                }

                parentDesc = diskInfoSet->GetParentLogicalDiskDescription(
                             parentDesc, n);
            }
        }
    }

    if (Extension->IsComplete) {

        KeReleaseSpinLock(&Extension->SpinLock, irql);

        KeWaitForSingleObject(&Extension->Semaphore, Executive, KernelMode,
                              FALSE, NULL);
        status = FtpAllSystemsGo(Extension, NULL, TRUE, TRUE, TRUE);
        KeReleaseSemaphore(&Extension->Semaphore, IO_NO_INCREMENT, 1, FALSE);

        if (NT_SUCCESS(status)) {
            vol->StartSyncOperations(FALSE, FtpRefCountCompletion,
                                     Extension);
        }

        KeAcquireSpinLock(&Extension->SpinLock, &irql);
    }

    inPagingPath = Extension->InPagingPath;
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    if (inPagingPath) {
        FtpSendPagingNotification(Partition);
    }

    swprintf(deviceNameBuffer, L"\\Device\\HarddiskVolume%d", Extension->VolumeNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);
    child->CreateLegacyNameLinks(&deviceName);

    Extension->DeviceObject->AlignmentRequirement |=
            Partition->AlignmentRequirement;

    return STATUS_SUCCESS;
}

VOID
FtpPropogateRegistryState(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PFT_VOLUME          Volume
    )

{
    UCHAR       state[100];
    USHORT      stateSize;
    KIRQL       irql;
    USHORT      n, i;
    PFT_VOLUME  vol;

    if (Volume->QueryLogicalDiskType() == FtPartition) {
        return;
    }

    if (FtpQueryStateFromRegistry(Volume->QueryLogicalDiskId(), state,
                                  100, &stateSize)) {

        KeAcquireSpinLock(&Extension->SpinLock, &irql);
        if (!Extension->IsComplete) {
            Volume->NewStateArrival(state);
        }
        KeReleaseSpinLock(&Extension->SpinLock, irql);
    }

    n = Volume->QueryNumberOfMembers();
    for (i = 0; i < n; i++) {
        vol = Volume->GetMember(i);
        if (!vol) {
            continue;
        }

        FtpPropogateRegistryState(Extension, vol);

    }
}

VOID
FtpComputeParity(
    IN  PVOID   TargetBuffer,
    IN  PVOID   SourceBuffer,
    IN  ULONG   BufferLength
    )

/*++

Routine Description:

    This routine computes the parity of the source and target buffers
    and places the result of the computation into the target buffer.
    I.E.  TargetBuffer ^= SourceBuffer.

Arguments:

    TargetBuffer    - Supplies the target buffer.

    SourceBuffer    - Supplies the source buffer.

    BufferLength    - Supplies the buffer length.

Return Value:

    None.

--*/

{
    PULONGLONG  p, q;
    ULONG       i, n;

    ASSERT(sizeof(ULONGLONG) == 8);

    p = (PULONGLONG) TargetBuffer;
    q = (PULONGLONG) SourceBuffer;
    n = BufferLength/128;
    ASSERT(BufferLength%128 == 0);
    for (i = 0; i < n; i++) {
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
    }
}

NTSTATUS
FtpReadPartitionTableEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRIVE_LAYOUT_INFORMATION_EX* DriveLayout
    )

/*++

Routine Description:

    This routine reads the partition table for the disk.

    The partition list is built in nonpaged pool that is allocated by this
    routine. It is the caller's responsability to free this memory when it
    is finished with the data.

Arguments:

    DeviceObject - Pointer for device object for this disk.

    DriveLayout - Pointer to the pointer that will return the patition list.
            This buffer is allocated in nonpaged pool by this routine. It is
            the responsability of the caller to free this memory if this
            routine is successful.

Return Values:

    Status.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    PIRP Irp;
    KEVENT Event;
    PVOID IoCtlBuffer;
    ULONG IoCtlBufferSize;
    ULONG NewAllocationSize;
    ULONG NumTries;

    //
    // Initialize locals.
    //

    NumTries = 0;
    IoCtlBuffer = NULL;
    IoCtlBufferSize = 0;
    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    //
    // Initialize the IOCTL buffer.
    //

    IoCtlBuffer = ExAllocatePoolWithTag(NonPagedPool, 
                                        PAGE_SIZE,
                                        FTDISK_TAG_IOCTL_BUFFER);
    
    if (!IoCtlBuffer) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }
    
    IoCtlBufferSize = PAGE_SIZE;

    //
    // First try to get the partition table by issuing an IOCTL.
    //
    
    do {

        //
        // Make sure the event is reset.
        //

        KeClearEvent(&Event);

        //
        // Build an IOCTL Irp.
        //

        Irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                            DeviceObject,
                                            NULL, 
                                            0, 
                                            IoCtlBuffer, 
                                            IoCtlBufferSize, 
                                            FALSE,
                                            &Event, 
                                            &IoStatus);
        if (!Irp) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        //
        // Call the driver.
        //

        Status = IoCallDriver(DeviceObject, Irp);

        if (Status == STATUS_PENDING) {
            KeWaitForSingleObject(&Event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            //
            // Update status.
            //
            
            Status = IoStatus.Status;
        }
    
        if (NT_SUCCESS(Status)) {
            
            //
            // We got it!
            //

            break;
        }

        if (Status != STATUS_BUFFER_TOO_SMALL) {
            
            //
            // It is a real error.
            //

            goto cleanup;
        }

        //
        // Resize IOCTL buffer. We should not enter the loop with a
        // NULL buffer.
        //

        ASSERT(IoCtlBuffer && IoCtlBufferSize);

        NewAllocationSize = IoCtlBufferSize * 2;

        ExFreePool(IoCtlBuffer);
        IoCtlBufferSize = 0;
        
        IoCtlBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                            NewAllocationSize,
                                            FTDISK_TAG_IOCTL_BUFFER);
        
        if (!IoCtlBuffer) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }
        
        IoCtlBufferSize = NewAllocationSize;

        //
        // Try again with the new buffer but do not loop forever.
        //

        NumTries++;

        if (NumTries > 32) {
            Status = STATUS_UNSUCCESSFUL;
            goto cleanup;
        }

    } while (TRUE);

    //
    // If we came here we should have acquired the partition tables in
    // IoCtlBuffer.
    //
    
    ASSERT(NT_SUCCESS(Status));
    ASSERT(IoCtlBuffer && IoCtlBufferSize);
    
    //
    // Set the output parameter and clear IoCtlBuffer so we don't free
    // it when we are cleaning up.
    //

    (*DriveLayout) = (PDRIVE_LAYOUT_INFORMATION_EX) IoCtlBuffer;

    IoCtlBuffer = NULL;
    IoCtlBufferSize = 0;

    Status = STATUS_SUCCESS;

 cleanup:
    
    if (IoCtlBuffer) {
        ASSERT(IoCtlBufferSize);
        ExFreePool(IoCtlBuffer);
    }

    //
    // If we were not successful with the IOCTL, pass the request off
    // to IoReadPartitionTableEx.
    //

    if (!NT_SUCCESS(Status)) {
        
        Status = IoReadPartitionTableEx(DeviceObject,
                                        DriveLayout);

    }
    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\ftdisk.h ===
/*++

Copyright (C) 1991-5 Microsoft Corporation

Module Name:

    ftdisk.h

Abstract:

    These are the structures that FtDisk driver
    uses to support IO to NTFT volumes.

Notes:

Revision History:

--*/

extern "C" {
    #include "stdio.h"
    #include <ntdskreg.h>
    #include <ntddft.h>
    #include <ntddft2.h>
    #include <ntdddisk.h>
    #include "ftlog.h"
    #include <wdmguid.h>
    #include <devguid.h>
    #include <stdarg.h>
    #include <volmgr.h>
    #include <mountdev.h>
    #include <ntddvol.h>
    #include <wmilib.h>
}

#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'tFcS')
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,'tFcS')

#define FTDISK_TAG_IOCTL_BUFFER 'iFcS'

#endif

#define STRIPE_SIZE ((ULONG) 0x00010000)

#define DISK_REGISTRY_KEY_W     L"\\Registry\\Machine\\System\\DISK"
#define FT_STATE_REGISTRY_KEY   L"\\Registry\\Machine\\System\\DISK\\FtState"

//
// NEC98 machines have drive-letter A and B which are non FD too.
//
#define FirstDriveLetter (IsNEC_98 ? 'A' : 'C')
#define LastDriveLetter  'Z'

class TRANSFER_PACKET;
typedef TRANSFER_PACKET* PTRANSFER_PACKET;

typedef
VOID
(*FT_TRANSFER_COMPLETION_ROUTINE)(
    IN  PTRANSFER_PACKET    TransferPacket
    );

typedef
VOID
(*FT_COMPLETION_ROUTINE)(
    IN  PVOID       Context,
    IN  NTSTATUS    Status
    );

class FT_VOLUME;
typedef FT_VOLUME* PFT_VOLUME;

typedef struct _FT_COMPLETION_ROUTINE_CONTEXT {
    KSPIN_LOCK              SpinLock;
    NTSTATUS                Status;
    LONG                    RefCount;
    FT_COMPLETION_ROUTINE   CompletionRoutine;
    PVOID                   Context;
    PFT_VOLUME              ParentVolume;
} FT_COMPLETION_ROUTINE_CONTEXT, *PFT_COMPLETION_ROUTINE_CONTEXT;

class FT_BASE_CLASS;
typedef FT_BASE_CLASS* PFT_BASE_CLASS;
class FT_BASE_CLASS {

    public:

        static
        PVOID
        operator new(
            IN  size_t    Size
            );

        static
        VOID
        operator delete(
            IN  PVOID   MemPtr
            );

};

class VOLUME_EXTENSION;
typedef VOLUME_EXTENSION* PVOLUME_EXTENSION;

class ROOT_EXTENSION;
typedef ROOT_EXTENSION* PROOT_EXTENSION;

#include <ondisk.hxx>

class TRANSFER_PACKET : public FT_BASE_CLASS {

    public:

        static
        PVOID
        operator new(
            IN  size_t    Size
            );

        static
        VOID
        operator delete(
            IN  PVOID   MemPtr
            );

        TRANSFER_PACKET(
            ) { _freeMdl = FALSE; _freeBuffer = FALSE; SpecialRead = 0;
                OriginalIrp = NULL; };

        virtual
        ~TRANSFER_PACKET(
            );

        BOOLEAN
        AllocateMdl(
            IN  PVOID   Buffer,
            IN  ULONG   Length
            );

        BOOLEAN
        AllocateMdl(
            IN  ULONG   Length
            );

        VOID
        FreeMdl(
            );

        // These fields must be filled in by the caller.

        PMDL                            Mdl;
        PIRP                            OriginalIrp;
        ULONG                           Length;
        LONGLONG                        Offset;
        FT_TRANSFER_COMPLETION_ROUTINE  CompletionRoutine;
        PFT_VOLUME                      TargetVolume;
        PETHREAD                        Thread;
        UCHAR                           IrpFlags;
        BOOLEAN                         ReadPacket;
        UCHAR                           SpecialRead;

        // A spin lock which may be used to resolve contention for the
        // fields below.  This spin lock must be initialized by the callee.

        KSPIN_LOCK                      SpinLock;

        // This field must be filled in by the callee.

        IO_STATUS_BLOCK                 IoStatus;

        // These fields are for use by the callee.

        LONG                            RefCount;
        LIST_ENTRY                      QueueEntry;

    private:

        BOOLEAN _freeMdl;
        BOOLEAN _freeBuffer;
        UCHAR   _allocationType;

};

#define TP_SPECIAL_READ_PRIMARY     (1)
#define TP_SPECIAL_READ_SECONDARY   (2)

#define TP_ALLOCATION_STRIPE_POOL   (1)
#define TP_ALLOCATION_MIRROR_POOL   (2)

class DISPATCH_TP;
typedef DISPATCH_TP* PDISPATCH_TP;
class DISPATCH_TP : public TRANSFER_PACKET {

    public:

        DISPATCH_TP(
            ) {};

        PIRP                Irp;
        PVOLUME_EXTENSION   Extension;

};

class VOLUME_SET;
typedef VOLUME_SET* PVOLUME_SET;

class VOLSET_TP;
typedef VOLSET_TP* PVOLSET_TP;
class VOLSET_TP : public TRANSFER_PACKET {

    public:

        VOLSET_TP(
            ) {};

        PTRANSFER_PACKET    MasterPacket;
        PVOLUME_SET         VolumeSet;
        USHORT              WhichMember;

};

class STRIPE;
typedef STRIPE* PSTRIPE;

class STRIPE_TP;
typedef STRIPE_TP* PSTRIPE_TP;
class STRIPE_TP : public TRANSFER_PACKET {

    public:

        STRIPE_TP(
            ) {};

        PTRANSFER_PACKET    MasterPacket;
        PSTRIPE             Stripe;
        USHORT              WhichMember;

};

class OVERLAPPED_IO_MANAGER;
typedef OVERLAPPED_IO_MANAGER* POVERLAPPED_IO_MANAGER;

class OVERLAP_TP;
typedef OVERLAP_TP* POVERLAP_TP;
class OVERLAP_TP : public TRANSFER_PACKET {

    friend class OVERLAPPED_IO_MANAGER;

    public:

        OVERLAP_TP(
            ) { InQueue = FALSE; };

        virtual
        ~OVERLAP_TP(
            );

    private:

        BOOLEAN                 AllMembers;
        BOOLEAN                 InQueue;
        LIST_ENTRY              OverlapQueue;
        LIST_ENTRY              CompletionList;
        POVERLAPPED_IO_MANAGER  OverlappedIoManager;

};

class MIRROR;
typedef MIRROR* PMIRROR;

class MIRROR_TP;
typedef MIRROR_TP* PMIRROR_TP;
class MIRROR_TP : public OVERLAP_TP {

    public:

        MIRROR_TP(
            ) { OneReadFailed = FALSE; };

        PTRANSFER_PACKET                MasterPacket;
        PMIRROR                         Mirror;
        USHORT                          WhichMember;
        BOOLEAN                         OneReadFailed;
        PMIRROR_TP                      SecondWritePacket;
        FT_TRANSFER_COMPLETION_ROUTINE  SavedCompletionRoutine;

};

class MIRROR_RECOVER_TP;
typedef MIRROR_RECOVER_TP* PMIRROR_RECOVER_TP;
class MIRROR_RECOVER_TP : public MIRROR_TP {

    public:

        MIRROR_RECOVER_TP(
            ) { PartialMdl = NULL; VerifyMdl = NULL; };

        virtual
        ~MIRROR_RECOVER_TP(
            );

        BOOLEAN
        AllocateMdls(
            IN  ULONG   Length
            );

        VOID
        FreeMdls(
            );

        PMDL    PartialMdl;
        PMDL    VerifyMdl;

};

class PARITY_IO_MANAGER;
typedef PARITY_IO_MANAGER* PPARITY_IO_MANAGER;

class PARITY_TP;
typedef PARITY_TP* PPARITY_TP;
class PARITY_TP : public TRANSFER_PACKET {

    friend class PARITY_IO_MANAGER;

    friend
    VOID
    UpdateParityCompletionRoutine(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    ParityCarefulWritePhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    public:

        PARITY_TP(
            ) {};

    private:

        BOOLEAN                         Idle;
        BOOLEAN                         OneWriteFailed;
        LIST_ENTRY                      OverlapQueue;
        LIST_ENTRY                      UpdateQueue;
        PPARITY_IO_MANAGER              ParityIoManager;
        LONGLONG                        BucketNumber;

};

class PARITY_RECOVER_TP;
typedef PARITY_RECOVER_TP* PPARITY_RECOVER_TP;
class PARITY_RECOVER_TP : public PARITY_TP {

    public:

        PARITY_RECOVER_TP(
            ) {};

        PPARITY_TP  MasterPacket;

};

class STRIPE_WP;
typedef STRIPE_WP* PSTRIPE_WP;

class SWP_TP;
typedef SWP_TP* PSWP_TP;
class SWP_TP : public OVERLAP_TP {

    public:

        SWP_TP(
            ) {};

        PTRANSFER_PACKET                MasterPacket;
        PSTRIPE_WP                      StripeWithParity;
        USHORT                          WhichMember;
        FT_TRANSFER_COMPLETION_ROUTINE  SavedCompletionRoutine;
        BOOLEAN                         OneReadFailed;

};

class SWP_RECOVER_TP;
typedef SWP_RECOVER_TP* PSWP_RECOVER_TP;
class SWP_RECOVER_TP : public SWP_TP {

    public:

        SWP_RECOVER_TP(
            ) { PartialMdl = NULL; VerifyMdl = NULL; };

        virtual
        ~SWP_RECOVER_TP(
            );

        BOOLEAN
        AllocateMdls(
            IN  ULONG   Length
            );

        VOID
        FreeMdls(
            );

        PMDL        PartialMdl;
        PMDL        VerifyMdl;
        PARITY_TP   ParityPacket;

};

class SWP_WRITE_TP;
typedef SWP_WRITE_TP* PSWP_WRITE_TP;
class SWP_WRITE_TP : public SWP_TP {

    public:

        SWP_WRITE_TP(
            ) { ReadAndParityMdl = NULL; WriteMdl = NULL; };

        virtual
        ~SWP_WRITE_TP(
            );

        BOOLEAN
        AllocateMdls(
            IN  ULONG   Length
            );

        VOID
        FreeMdls(
            );

        PMDL            ReadAndParityMdl;
        PMDL            WriteMdl;
        FT_MEMBER_STATE TargetState;
        USHORT          ParityMember;
        SWP_TP          ReadWritePacket;
        PARITY_TP       ParityPacket;

};

class SWP_REGENERATE_TP;
typedef SWP_REGENERATE_TP *PSWP_REGENERATE_TP;
class SWP_REGENERATE_TP : public TRANSFER_PACKET {

    public:

        SWP_REGENERATE_TP(
            ) {};

        PSWP_TP     MasterPacket;
        USHORT      WhichMember;
        LIST_ENTRY  RegenPacketList;

};

class SWP_REBUILD_TP;
typedef SWP_REBUILD_TP *PSWP_REBUILD_TP;
class SWP_REBUILD_TP : public SWP_TP {

    public:

        SWP_REBUILD_TP(
            ) {};

        PFT_COMPLETION_ROUTINE_CONTEXT  Context;
        BOOLEAN                         Initialize;

};

class REDISTRIBUTION;
typedef REDISTRIBUTION *PREDISTRIBUTION;

class REDISTRIBUTION_TP;
typedef REDISTRIBUTION_TP* PREDISTRIBUTION_TP;
class REDISTRIBUTION_TP : public TRANSFER_PACKET {

    public:

        REDISTRIBUTION_TP(
            ) {};

        PTRANSFER_PACKET        MasterPacket;
        PREDISTRIBUTION         Redistribution;
        USHORT                  WhichMember;

};

class REDISTRIBUTION_LOCK_TP;
typedef REDISTRIBUTION_LOCK_TP* PREDISTRIBUTION_LOCK_TP;
class REDISTRIBUTION_LOCK_TP : public OVERLAP_TP {

    public:

        REDISTRIBUTION_LOCK_TP(
            ) {};

        PTRANSFER_PACKET    MasterPacket;
        PREDISTRIBUTION     Redistribution;

};

class REDISTRIBUTION_SYNC_TP;
typedef REDISTRIBUTION_SYNC_TP* PREDISTRIBUTION_SYNC_TP;
class REDISTRIBUTION_SYNC_TP : public OVERLAP_TP {

    public:

        REDISTRIBUTION_SYNC_TP(
            ) {};

        PFT_COMPLETION_ROUTINE_CONTEXT  Context;
        PREDISTRIBUTION                 Redistribution;
        REDISTRIBUTION_TP               IoPacket;

};

class REDISTRIBUTION_CW_TP;
typedef REDISTRIBUTION_CW_TP* PREDISTRIBUTION_CW_TP;
class REDISTRIBUTION_CW_TP : public REDISTRIBUTION_TP {

    public:

        REDISTRIBUTION_CW_TP(
            ) { PartialMdl = NULL; VerifyMdl = NULL; };

        virtual
        ~REDISTRIBUTION_CW_TP(
            );

        BOOLEAN
        AllocateMdls(
            IN  ULONG   Length
            );

        VOID
        FreeMdls(
            );

        PMDL    PartialMdl;
        PMDL    VerifyMdl;

};

class OVERLAPPED_IO_MANAGER : public FT_BASE_CLASS {

    public:

        NTSTATUS
        Initialize(
            IN  ULONG   BucketSize
            );

        VOID
        AcquireIoRegion(
            IN OUT  POVERLAP_TP TransferPacket,
            IN      BOOLEAN     AllMembers
            );

        VOID
        ReleaseIoRegion(
            IN OUT  POVERLAP_TP TransferPacket
            );

        VOID
        PromoteToAllMembers(
            IN OUT  POVERLAP_TP TransferPacket
            );

        OVERLAPPED_IO_MANAGER(
            ) { _spinLock = NULL; _ioQueue = NULL; };

        ~OVERLAPPED_IO_MANAGER(
            );

    private:

        ULONG       _numQueues;
        ULONG       _bucketSize;
        PKSPIN_LOCK _spinLock;
        PLIST_ENTRY _ioQueue;

};

class PARITY_IO_MANAGER : public FT_BASE_CLASS {

    friend
    VOID
    UpdateParityCompletionRoutine(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    ParityCarefulWritePhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    public:

        NTSTATUS
        Initialize(
            IN  ULONG   BucketSize,
            IN  ULONG   SectorSize
            );

        VOID
        StartReadForUpdateParity(
            IN  LONGLONG    Offset,
            IN  ULONG       Length,
            IN  PFT_VOLUME  TargetVolume,
            IN  PETHREAD    Thread,
            IN  UCHAR       IrpFlags
            );

        VOID
        UpdateParity(
            IN OUT  PPARITY_TP  TransferPacket
            );

        PARITY_IO_MANAGER(
            ) { _spinLock = NULL; _ioQueue = NULL; _ePacket = NULL; };

        ~PARITY_IO_MANAGER(
            );

    private:

        VOID
        CarefulWrite(
            IN OUT  PPARITY_TP  TransferPacket
            );

        ULONG       _numQueues;
        ULONG       _bucketSize;
        ULONG       _sectorSize;
        PKSPIN_LOCK _spinLock;
        PLIST_ENTRY _ioQueue;

        //
        // Emergency packet.
        //

        PPARITY_TP  _ePacket;
        BOOLEAN     _ePacketInUse;
        BOOLEAN     _ePacketQueueBeingServiced;
        LIST_ENTRY  _ePacketQueue;
        KSPIN_LOCK  _ePacketSpinLock;

};

class PARTITION;
typedef PARTITION* PPARTITION;

class FT_VOLUME : public FT_BASE_CLASS {

    friend
    VOID
    SetMemberStateWorker(
        IN  PVOID   Context
        );

    friend
    VOID
    FtVolumeNotifyWorker(
        IN  PVOID   FtVolume
        );

    public:

        VOID
        Initialize(
            IN OUT  PROOT_EXTENSION     RootExtension,
            IN      FT_LOGICAL_DISK_ID  LogicalDiskId
            );

        FT_LOGICAL_DISK_ID
        QueryLogicalDiskId(
            );

        VOID
        SetLogicalDiskId(
            IN  FT_LOGICAL_DISK_ID  NewLogicalDiskId
            );

        virtual
        VOID
        Notify(
            );

        virtual
        FT_LOGICAL_DISK_TYPE
        QueryLogicalDiskType(
            ) = 0;

        virtual
        USHORT
        QueryNumberOfMembers(
            ) = 0;

        virtual
        PFT_VOLUME
        GetMember(
            IN  USHORT  MemberNumber
            ) = 0;

        virtual
        NTSTATUS
        OrphanMember(
            IN  USHORT                  MemberNumber,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            ) = 0;

        virtual
        NTSTATUS
        RegenerateMember(
            IN      USHORT                  MemberNumber,
            IN OUT  PFT_VOLUME              NewMember,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            ) = 0;

        virtual
        VOID
        Transfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            ) = 0;

        virtual
        VOID
        ReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            ) = 0;

        virtual
        VOID
        StartSyncOperations(
            IN      BOOLEAN                 RegenerateOrphans,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            ) = 0;

        virtual
        VOID
        StopSyncOperations(
            ) = 0;

        virtual
        VOID
        BroadcastIrp(
            IN  PIRP                    Irp,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            ) = 0;

        virtual
        ULONG
        QuerySectorSize(
            ) = 0;

        virtual
        LONGLONG
        QueryVolumeSize(
            ) = 0;

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  FT_LOGICAL_DISK_ID  LogicalDiskId
            ) = 0;

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  PDEVICE_OBJECT  TargetObject
            ) = 0;

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  ULONG       Signature,
            IN  LONGLONG    Offset
            ) = 0;

        virtual
        PFT_VOLUME
        GetParentLogicalDisk(
            IN  PFT_VOLUME  Volume
            ) = 0;

        virtual
        VOID
        SetDirtyBit(
            IN  BOOLEAN                 IsDirty,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            ) = 0;

        virtual
        VOID
        SetMember(
            IN  USHORT      MemberNumber,
            IN  PFT_VOLUME  Member
            ) = 0;

        virtual
        BOOLEAN
        IsComplete(
            IN  BOOLEAN IoPending
            ) = 0;

        virtual
        VOID
        CompleteNotification(
            IN  BOOLEAN IoPending
            ) = 0;

        virtual
        NTSTATUS
        CheckIo(
            OUT PBOOLEAN    IsIoOk
            ) = 0;

        virtual
        ULONG
        QueryNumberOfPartitions(
            ) = 0;

        virtual
        NTSTATUS
        SetPartitionType(
            IN  UCHAR   PartitionType
            ) = 0;

        virtual
        UCHAR
        QueryPartitionType(
            ) = 0;

        virtual
        UCHAR
        QueryStackSize(
            ) = 0;

        virtual
        VOID
        CreateLegacyNameLinks(
            IN  PUNICODE_STRING DeviceName
            ) = 0;

        virtual
        BOOLEAN
        IsVolumeSuitableForRegenerate(
            IN  USHORT      MemberNumber,
            IN  PFT_VOLUME  Volume
            );

        virtual
        VOID
        NewStateArrival(
            IN  PVOID   NewStateInstance
            );

        virtual
        PDEVICE_OBJECT
        GetLeftmostPartitionObject(
            ) = 0;

        virtual
        NTSTATUS
        QueryDiskExtents(
            OUT PDISK_EXTENT*   DiskExtents,
            OUT PULONG          NumberOfDiskExtents
            ) = 0;

        virtual
        BOOLEAN
        QueryVolumeState(
            IN  PFT_VOLUME          Volume,
            OUT PFT_MEMBER_STATE    State
            ) = 0;

        virtual
        NTSTATUS
        QueryPhysicalOffsets(
            IN  LONGLONG                    LogicalOffset,
            OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
            OUT PULONG                      NumberOfPhysicalOffsets
            ) = 0;

        virtual
        NTSTATUS
        QueryLogicalOffset(
            IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
            OUT PLONGLONG               LogicalOffset
            ) = 0;

        virtual
        VOID
        ModifyStateForUser(
            IN OUT  PVOID   State
            );

        virtual
        ~FT_VOLUME(
            );

        FT_VOLUME(
            ) { _refCount = 1; };

        LONG                                _refCount;

    protected:

        KSPIN_LOCK                          _spinLock;
        PFT_LOGICAL_DISK_INFORMATION_SET    _diskInfoSet;
        PROOT_EXTENSION                     _rootExtension;

    private:

        FT_LOGICAL_DISK_ID                  _logicalDiskId;

};

#define TRANSFER(a) ((a)->TargetVolume->Transfer((a)))

class PARTITION : public FT_VOLUME {

    friend
    NTSTATUS
    PartitionTransferCompletionRoutine(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp,
        IN  PVOID           TransferPacket
        );

    public:

        PARTITION(
            ) { _emergencyIrp = NULL; };

        virtual
        ~PARTITION(
            );

        NTSTATUS
        Initialize(
            IN OUT  PROOT_EXTENSION     RootExtension,
            IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
            IN OUT  PDEVICE_OBJECT      TargetObject,
            IN OUT  PDEVICE_OBJECT      WholeDiskPdo
            );

        virtual
        FT_LOGICAL_DISK_TYPE
        QueryLogicalDiskType(
            );

        virtual
        USHORT
        QueryNumberOfMembers(
            );

        virtual
        PFT_VOLUME
        GetMember(
            IN  USHORT  MemberNumber
            );

        virtual
        NTSTATUS
        OrphanMember(
            IN  USHORT                  MemberNumber,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        NTSTATUS
        RegenerateMember(
            IN      USHORT                  MemberNumber,
            IN OUT  PFT_VOLUME              NewMember,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        Transfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        ReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        StartSyncOperations(
            IN      BOOLEAN                 RegenerateOrphans,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        StopSyncOperations(
            );

        virtual
        VOID
        BroadcastIrp(
            IN  PIRP                    Irp,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        ULONG
        QuerySectorSize(
            );

        virtual
        LONGLONG
        QueryVolumeSize(
            );

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  FT_LOGICAL_DISK_ID  LogicalDiskId
            );

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  PDEVICE_OBJECT  TargetObject
            );

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  ULONG       Signature,
            IN  LONGLONG    Offset
            );

        virtual
        PFT_VOLUME
        GetParentLogicalDisk(
            IN  PFT_VOLUME  Volume
            );

        virtual
        VOID
        SetDirtyBit(
            IN  BOOLEAN                 IsDirty,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        VOID
        SetMember(
            IN  USHORT      MemberNumber,
            IN  PFT_VOLUME  Member
            );

        virtual
        BOOLEAN
        IsComplete(
            IN  BOOLEAN IoPending
            );

        virtual
        VOID
        CompleteNotification(
            IN  BOOLEAN IoPending
            );

        virtual
        NTSTATUS
        CheckIo(
            OUT PBOOLEAN    IsIoOk
            );

        virtual
        ULONG
        QueryNumberOfPartitions(
            );

        virtual
        NTSTATUS
        SetPartitionType(
            IN  UCHAR   PartitionType
            );

        virtual
        UCHAR
        QueryPartitionType(
            );

        virtual
        UCHAR
        QueryStackSize(
            );

        virtual
        VOID
        CreateLegacyNameLinks(
            IN  PUNICODE_STRING DeviceName
            );

        virtual
        PDEVICE_OBJECT
        GetLeftmostPartitionObject(
            );

        virtual
        NTSTATUS
        QueryDiskExtents(
            OUT PDISK_EXTENT*   DiskExtents,
            OUT PULONG          NumberOfDiskExtents
            );

        virtual
        BOOLEAN
        QueryVolumeState(
            IN  PFT_VOLUME          Volume,
            OUT PFT_MEMBER_STATE    State
            );

        virtual
        NTSTATUS
        QueryPhysicalOffsets(
            IN  LONGLONG                    LogicalOffset,
            OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
            OUT PULONG                      NumberOfPhysicalOffsets
            );

        virtual
        NTSTATUS
        QueryLogicalOffset(
            IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
            OUT PLONGLONG               LogicalOffset
            );

        PDEVICE_OBJECT
        GetTargetObject(
            ) { return _targetObject; };

        PDEVICE_OBJECT
        GetWholeDiskPdo(
            ) { return _wholeDiskPdo; };

    private:

        PDEVICE_OBJECT  _targetObject;
        PDEVICE_OBJECT  _wholeDiskPdo;
        ULONG           _sectorSize;
        LONGLONG        _partitionOffset;
        LONGLONG        _partitionLength;

        PIRP            _emergencyIrp;
        BOOLEAN         _emergencyIrpInUse;
        LIST_ENTRY      _emergencyIrpQueue;

};

class COMPOSITE_FT_VOLUME;
typedef COMPOSITE_FT_VOLUME *PCOMPOSITE_FT_VOLUME;
class COMPOSITE_FT_VOLUME : public FT_VOLUME {

    public:

        virtual
        NTSTATUS
        Initialize(
            IN OUT  PROOT_EXTENSION     RootExtension,
            IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
            IN OUT  PFT_VOLUME*         VolumeArray,
            IN      USHORT              ArraySize,
            IN      PVOID               ConfigInfo,
            IN      PVOID               StateInfo
            );

        virtual
        FT_LOGICAL_DISK_TYPE
        QueryLogicalDiskType(
            ) = 0;

        virtual
        USHORT
        QueryNumberOfMembers(
            );

        virtual
        PFT_VOLUME
        GetMember(
            IN  USHORT  MemberNumber
            );

        virtual
        NTSTATUS
        OrphanMember(
            IN  USHORT                  MemberNumber,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        NTSTATUS
        RegenerateMember(
            IN      USHORT                  MemberNumber,
            IN OUT  PFT_VOLUME              NewMember,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        Transfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            ) = 0;

        virtual
        VOID
        ReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            ) = 0;

        virtual
        VOID
        StartSyncOperations(
            IN      BOOLEAN                 RegenerateOrphans,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        StopSyncOperations(
            );

        virtual
        VOID
        BroadcastIrp(
            IN  PIRP                    Irp,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        ULONG
        QuerySectorSize(
            );

        virtual
        LONGLONG
        QueryVolumeSize(
            ) = 0;

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  FT_LOGICAL_DISK_ID  LogicalDiskId
            );

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  PDEVICE_OBJECT  TargetObject
            );

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  ULONG       Signature,
            IN  LONGLONG    Offset
            );

        virtual
        PFT_VOLUME
        GetParentLogicalDisk(
            IN  PFT_VOLUME  Volume
            );

        virtual
        VOID
        SetDirtyBit(
            IN  BOOLEAN                 IsDirty,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        VOID
        SetMember(
            IN  USHORT      MemberNumber,
            IN  PFT_VOLUME  Member
            );

        virtual
        BOOLEAN
        IsComplete(
            IN  BOOLEAN IoPending
            );

        virtual
        VOID
        CompleteNotification(
            IN  BOOLEAN IoPending
            );

        virtual
        NTSTATUS
        CheckIo(
            OUT PBOOLEAN    IsIoOk
            ) = 0;

        virtual
        ULONG
        QueryNumberOfPartitions(
            );

        virtual
        NTSTATUS
        SetPartitionType(
            IN  UCHAR   PartitionType
            );

        virtual
        UCHAR
        QueryPartitionType(
            );

        virtual
        UCHAR
        QueryStackSize(
            );

        virtual
        VOID
        CreateLegacyNameLinks(
            IN  PUNICODE_STRING DeviceName
            );

        virtual
        PDEVICE_OBJECT
        GetLeftmostPartitionObject(
            );

        virtual
        NTSTATUS
        QueryDiskExtents(
            OUT PDISK_EXTENT*   DiskExtents,
            OUT PULONG          NumberOfDiskExtents
            );

        virtual
        BOOLEAN
        QueryVolumeState(
            IN  PFT_VOLUME          Volume,
            OUT PFT_MEMBER_STATE    State
            );

        virtual
        NTSTATUS
        QueryPhysicalOffsets(
            IN  LONGLONG                    LogicalOffset,
            OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
            OUT PULONG                      NumberOfPhysicalOffsets
            ) = 0;

        virtual
        NTSTATUS
        QueryLogicalOffset(
            IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
            OUT PLONGLONG               LogicalOffset
            ) = 0;

        COMPOSITE_FT_VOLUME(
           ) { _volumeArray = NULL; };

        virtual
        ~COMPOSITE_FT_VOLUME(
            );

    protected:

        PFT_VOLUME
        GetMemberUnprotected(
            IN  USHORT  MemberNumber
            ) { return _volumeArray[MemberNumber]; };

        VOID
        SetMemberUnprotected(
            IN  USHORT      MemberNumber,
            IN  PFT_VOLUME  NewVolume
            ) { _volumeArray[MemberNumber] = NewVolume; };

        USHORT
        QueryNumMembers(
            ) { return _arraySize; };

        VOID
        SetSectorSize(
            IN  ULONG   SectorSize
            ) { _sectorSize = SectorSize; };

    private:

        PFT_VOLUME* _volumeArray;
        USHORT      _arraySize;
        ULONG       _sectorSize;

};

class VOLUME_SET : public COMPOSITE_FT_VOLUME {

    friend
    VOID
    VolsetTransferSequentialCompletionRoutine(
        IN  PTRANSFER_PACKET    TransferPacket
        );

    public:

        VOLUME_SET(
            ) { _ePacket = NULL; };

        virtual
        ~VOLUME_SET(
            );

        virtual
        NTSTATUS
        Initialize(
            IN OUT  PROOT_EXTENSION     RootExtension,
            IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
            IN OUT  PFT_VOLUME*         VolumeArray,
            IN      USHORT              ArraySize,
            IN      PVOID               ConfigInfo,
            IN      PVOID               StateInfo
            );

        virtual
        FT_LOGICAL_DISK_TYPE
        QueryLogicalDiskType(
            );

        virtual
        VOID
        Transfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        ReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        LONGLONG
        QueryVolumeSize(
            );

        virtual
        VOID
        CompleteNotification(
            IN  BOOLEAN IoPending
            );

        virtual
        NTSTATUS
        CheckIo(
            OUT PBOOLEAN    IsIoOk
            );

        virtual
        NTSTATUS
        QueryPhysicalOffsets(
            IN  LONGLONG                    LogicalOffset,
            OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
            OUT PULONG                      NumberOfPhysicalOffsets
            );

        virtual
        NTSTATUS
        QueryLogicalOffset(
            IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
            OUT PLONGLONG               LogicalOffset
            );

    private:

        BOOLEAN
        LaunchParallel(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        VOID
        LaunchSequential(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        LONGLONG    _volumeSize;

        PVOLSET_TP  _ePacket;
        BOOLEAN     _ePacketInUse;
        LIST_ENTRY  _ePacketQueue;

};

class STRIPE : public COMPOSITE_FT_VOLUME {

    friend
    VOID
    StripeSequentialTransferCompletionRoutine(
        IN  PTRANSFER_PACKET    TransferPacket
        );

    public:

        STRIPE(
            ) { _ePacket = NULL; };

        virtual
        ~STRIPE(
            );

        virtual
        NTSTATUS
        Initialize(
            IN OUT  PROOT_EXTENSION     RootExtension,
            IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
            IN OUT  PFT_VOLUME*         VolumeArray,
            IN      USHORT              ArraySize,
            IN      PVOID               ConfigInfo,
            IN      PVOID               StateInfo
            );

        virtual
        FT_LOGICAL_DISK_TYPE
        QueryLogicalDiskType(
            );

        virtual
        VOID
        Transfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        ReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        LONGLONG
        QueryVolumeSize(
            );

        virtual
        VOID
        CompleteNotification(
            IN  BOOLEAN IoPending
            );

        virtual
        NTSTATUS
        CheckIo(
            OUT PBOOLEAN    IsIoOk
            );

        virtual
        NTSTATUS
        QueryPhysicalOffsets(
            IN  LONGLONG                    LogicalOffset,
            OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
            OUT PULONG                      NumberOfPhysicalOffsets
            );

        virtual
        NTSTATUS
        QueryLogicalOffset(
            IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
            OUT PLONGLONG               LogicalOffset
            );

    private:

        BOOLEAN
        LaunchParallel(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        VOID
        LaunchSequential(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        ULONG       _stripeSize;
        ULONG       _stripeShift;
        ULONG       _stripeMask;
        LONGLONG    _memberSize;
        LONGLONG    _volumeSize;

        PSTRIPE_TP  _ePacket;
        BOOLEAN     _ePacketInUse;
        LIST_ENTRY  _ePacketQueue;

};

class MIRROR : public COMPOSITE_FT_VOLUME {

    friend
    VOID
    FinishRegenerate(
        IN  PMIRROR                         Mirror,
        IN  PFT_COMPLETION_ROUTINE_CONTEXT  RegenContext,
        IN  PMIRROR_TP                      TransferPacket
        );

    friend
    VOID
    MirrorRegenerateCompletionRoutine(
        IN  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StartRegeneration(
        IN  PVOID       Context,
        IN  NTSTATUS    Status
        );

    friend
    VOID
    MirrorTransferCompletionRoutine(
        IN  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverPhase8(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverPhase7(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverPhase6(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverPhase5(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverPhase4(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverPhase3(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverPhase2(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverEmergencyCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverPhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorMaxTransferCompletionRoutine(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorMaxTransferEmergencyCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorPropogateStateChangesWorker(
        IN  PVOID   Mirror
        );

    friend
    VOID
    MirrorCarefulWritePhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorCarefulWritePhase2(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorCarefulWriteEmergencyCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    public:

        virtual
        ~MIRROR(
            );

        virtual
        NTSTATUS
        Initialize(
            IN OUT  PROOT_EXTENSION     RootExtension,
            IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
            IN OUT  PFT_VOLUME*         VolumeArray,
            IN      USHORT              ArraySize,
            IN      PVOID               ConfigInfo,
            IN      PVOID               StateInfo
            );

        virtual
        FT_LOGICAL_DISK_TYPE
        QueryLogicalDiskType(
            );

        virtual
        NTSTATUS
        OrphanMember(
            IN  USHORT                  MemberNumber,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        NTSTATUS
        RegenerateMember(
            IN      USHORT                  MemberNumber,
            IN OUT  PFT_VOLUME              NewMember,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        Transfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        ReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        StartSyncOperations(
            IN      BOOLEAN                 RegenerateOrphans,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        StopSyncOperations(
            );

        virtual
        LONGLONG
        QueryVolumeSize(
            );

        virtual
        VOID
        SetDirtyBit(
            IN  BOOLEAN                 IsDirty,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        BOOLEAN
        IsComplete(
            IN  BOOLEAN IoPending
            );

        virtual
        VOID
        CompleteNotification(
            IN  BOOLEAN IoPending
            );

        virtual
        NTSTATUS
        CheckIo(
            OUT PBOOLEAN    IsIoOk
            );

        virtual
        BOOLEAN
        IsVolumeSuitableForRegenerate(
            IN  USHORT      MemberNumber,
            IN  PFT_VOLUME  Volume
            );

        virtual
        VOID
        NewStateArrival(
            IN  PVOID   NewStateInstance
            );

        virtual
        PDEVICE_OBJECT
        GetLeftmostPartitionObject(
            );

        virtual
        BOOLEAN
        QueryVolumeState(
            IN  PFT_VOLUME          Volume,
            OUT PFT_MEMBER_STATE    State
            );

        virtual
        NTSTATUS
        QueryPhysicalOffsets(
            IN  LONGLONG                    LogicalOffset,
            OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
            OUT PULONG                      NumberOfPhysicalOffsets
            );

        virtual
        NTSTATUS
        QueryLogicalOffset(
            IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
            OUT PLONGLONG               LogicalOffset
            );

        virtual
        VOID
        ModifyStateForUser(
            IN OUT  PVOID   State
            );

        MIRROR(
            ) { _ePacket = NULL; _ePacket2 = NULL; _eRecoverPacket = NULL; };

    private:

        FT_MEMBER_STATE
        QueryMemberState(
            IN  USHORT  MemberNumber
            ) { return MemberNumber == _state.UnhealthyMemberNumber ?
                       _state.UnhealthyMemberState : FtMemberHealthy; }

        BOOLEAN
        SetMemberState(
            IN  USHORT          MemberNumber,
            IN  FT_MEMBER_STATE MemberState
            );

        BOOLEAN
        LaunchRead(
            IN OUT  PTRANSFER_PACKET    TransferPacket,
            IN OUT  PMIRROR_TP          Packet1
            );

        BOOLEAN
        LaunchWrite(
            IN OUT  PTRANSFER_PACKET    TransferPacket,
            IN OUT  PMIRROR_TP          Packet1,
            IN OUT  PMIRROR_TP          Packet2
            );

        VOID
        Recycle(
            IN OUT  PMIRROR_TP  TransferPacket,
            IN      BOOLEAN     ServiceEmergencyQueue
            );

        VOID
        Recover(
            IN OUT  PMIRROR_TP  TransferPacket
            );

        VOID
        MaxTransfer(
            IN OUT  PMIRROR_TP  TransferPacket
            );

        VOID
        PropogateStateChanges(
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        VOID
        CarefulWrite(
            IN OUT  PMIRROR_TP  TransferPacket
            );

        LONGLONG    _volumeSize;

        //
        // Keep track of requests for load balancing.
        //
        LONG _requestCount[2];
        LONGLONG _lastPosition[2];

        //
        // The dynamic state of this volume.
        //

        FT_MIRROR_AND_SWP_STATE_INFORMATION _state;
        BOOLEAN _originalDirtyBit;
        BOOLEAN _orphanedBecauseOfMissingMember;

        //
        // Indicates whether or not 'StartSyncOperations' or
        // 'RegenerateMember' is ok.
        //

        BOOLEAN _syncOk;

        //
        // Indicate whether or not balanced reads are allowed.
        //

        BOOLEAN _balancedReads;

        //
        // Indicates whether or not to stop syncs.
        //

        BOOLEAN _stopSyncs;

        //
        // Emergency packet.
        //

        PMIRROR_TP  _ePacket, _ePacket2;
        BOOLEAN     _ePacketInUse;
        LIST_ENTRY  _ePacketQueue;

        //
        // Emergency recover packet.
        //

        PMIRROR_RECOVER_TP  _eRecoverPacket;
        BOOLEAN             _eRecoverPacketInUse;
        LIST_ENTRY          _eRecoverPacketQueue;

        //
        // Overlapped io manager.
        //

        OVERLAPPED_IO_MANAGER   _overlappedIoManager;

};

class STRIPE_WP : public COMPOSITE_FT_VOLUME {

    friend
    VOID
    StripeWpSyncFinalCompletion(
        IN  PVOID       Context,
        IN  NTSTATUS    Status
        );

    friend
    VOID
    StripeWpSyncCompletionRoutine(
        IN  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StartStripeRegeneration(
        IN  PVOID       Context,
        IN  NTSTATUS    Status
        );

    friend
    VOID
    StripeWpParallelTransferCompletionRoutine(
        IN  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpSequentialTransferCompletionRoutine(
        IN  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpWritePhase31(
        IN OUT  PTRANSFER_PACKET    Packet
        );

    friend
    VOID
    StripeWpWritePhase30(
        IN OUT  PTRANSFER_PACKET    Packet
        );

    friend
    VOID
    StripeWpWriteRecover(
        IN OUT  PTRANSFER_PACKET    MasterPacket
        );

    friend
    VOID
    StripeWpWritePhase2(
        IN OUT  PTRANSFER_PACKET    ReadPacket
        );

    friend
    VOID
    StripeWpWritePhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpSequentialRegenerateCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpSequentialEmergencyCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpParallelRegenerateCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRegeneratePacketPhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverPhase8(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverPhase7(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverPhase6(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverPhase5(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverPhase4(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverPhase3(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverPhase2(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverEmergencyCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverPhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpMaxTransferCompletionRoutine(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpMaxTransferEmergencyCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpPropogateStateChangesWorker(
        IN  PVOID   StripeWp
        );

    friend
    VOID
    StripeWpCompleteWritePhase4(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpCompleteWritePhase3(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpCompleteWritePhase2(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpCompleteWritePhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpCarefulWritePhase2(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpCarefulWritePhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpCarefulWriteEmergencyCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpCarefulUpdateCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpCarefulUpdateEmergencyCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    public:

        virtual
        NTSTATUS
        Initialize(
            IN OUT  PROOT_EXTENSION     RootExtension,
            IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
            IN OUT  PFT_VOLUME*         VolumeArray,
            IN      USHORT              ArraySize,
            IN      PVOID               ConfigInfo,
            IN      PVOID               StateInfo
            );

        virtual
        FT_LOGICAL_DISK_TYPE
        QueryLogicalDiskType(
            );

        virtual
        NTSTATUS
        OrphanMember(
            IN  USHORT                  MemberNumber,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        NTSTATUS
        RegenerateMember(
            IN      USHORT                  MemberNumber,
            IN OUT  PFT_VOLUME              NewMember,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        Transfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        ReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        StartSyncOperations(
            IN      BOOLEAN                 RegenerateOrphans,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        StopSyncOperations(
            );

        virtual
        LONGLONG
        QueryVolumeSize(
            );

        virtual
        VOID
        SetDirtyBit(
            IN  BOOLEAN                 IsDirty,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        BOOLEAN
        IsComplete(
            IN  BOOLEAN IoPending
            );

        virtual
        VOID
        CompleteNotification(
            IN  BOOLEAN IoPending
            );

        virtual
        NTSTATUS
        CheckIo(
            OUT PBOOLEAN    IsIoOk
            );

        virtual
        BOOLEAN
        IsVolumeSuitableForRegenerate(
            IN  USHORT      MemberNumber,
            IN  PFT_VOLUME  Volume
            );

        virtual
        VOID
        NewStateArrival(
            IN  PVOID   NewStateInstance
            );

        virtual
        BOOLEAN
        QueryVolumeState(
            IN  PFT_VOLUME          Volume,
            OUT PFT_MEMBER_STATE    State
            );

        virtual
        NTSTATUS
        QueryPhysicalOffsets(
            IN  LONGLONG                    LogicalOffset,
            OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
            OUT PULONG                      NumberOfPhysicalOffsets
            );

        virtual
        NTSTATUS
        QueryLogicalOffset(
            IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
            OUT PLONGLONG               LogicalOffset
            );

        virtual
        VOID
        ModifyStateForUser(
            IN OUT  PVOID   State
            );

        STRIPE_WP(
            );

        virtual
        ~STRIPE_WP(
            );

    private:

        FT_MEMBER_STATE
        QueryMemberState(
            IN  USHORT  MemberNumber
            ) { return MemberNumber == _state.UnhealthyMemberNumber ?
                       _state.UnhealthyMemberState : FtMemberHealthy; }

        BOOLEAN
        SetMemberState(
            IN  USHORT          MemberNumber,
            IN  FT_MEMBER_STATE MemberState
            );

        BOOLEAN
        LaunchParallel(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        VOID
        LaunchSequential(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        VOID
        ReadPacket(
            IN OUT  PSWP_TP TransferPacket
            );

        VOID
        WritePacket(
            IN OUT  PSWP_WRITE_TP   TransferPacket
            );

        VOID
        RegeneratePacket(
            IN OUT  PSWP_TP TransferPacket,
            IN      BOOLEAN AllocateRegion
            );

        VOID
        Recover(
            IN OUT  PSWP_TP TransferPacket,
            IN      BOOLEAN NeedAcquire
            );

        VOID
        MaxTransfer(
            IN OUT  PSWP_TP TransferPacket
            );

        VOID
        RecycleRecoverTp(
            IN OUT  PSWP_RECOVER_TP TransferPacket
            );

        VOID
        PropogateStateChanges(
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        VOID
        CompleteWrite(
            IN OUT  PSWP_WRITE_TP   TransferPacket
            );

        VOID
        CarefulWrite(
            IN OUT  PSWP_TP TransferPacket
            );

        VOID
        CarefulUpdate(
            IN OUT  PSWP_TP ParityPacket
            );

        ULONG               _stripeSize;
        LONGLONG            _memberSize;
        LONGLONG            _volumeSize;

        //
        // The dynamic state of this volume.
        //

        FT_MIRROR_AND_SWP_STATE_INFORMATION _state;
        BOOLEAN _originalDirtyBit;
        BOOLEAN _orphanedBecauseOfMissingMember;

        //
        // Indicates whether or not 'StartSyncOperations' or
        // 'RegenerateMember' is ok.
        //

        BOOLEAN                     _syncOk;

        //
        // Indicates whether or not to stop syncs.
        //

        BOOLEAN                     _stopSyncs;

        //
        // State for keeping track of overlapping write requests.
        // One OVERLAPPED_IO_MANAGER for each member.
        //

        OVERLAPPED_IO_MANAGER       _overlappedIoManager;

        //
        // State for serializing parity I/O.
        //

        PARITY_IO_MANAGER           _parityIoManager;

        //
        // Emergency read/write packet.
        //

        PSWP_WRITE_TP               _ePacket;
        BOOLEAN                     _ePacketInUse;
        BOOLEAN                     _ePacketQueueBeingServiced;
        LIST_ENTRY                  _ePacketQueue;

        //
        // Emergency regenerate packet.
        //

        PSWP_REGENERATE_TP          _eRegeneratePacket;
        BOOLEAN                     _eRegeneratePacketInUse;
        LIST_ENTRY                  _eRegeneratePacketQueue;

        //
        // Emergency recover packet.
        //

        PSWP_RECOVER_TP             _eRecoverPacket;
        BOOLEAN                     _eRecoverPacketInUse;
        LIST_ENTRY                  _eRecoverPacketQueue;

};

class REDISTRIBUTION : public COMPOSITE_FT_VOLUME {

    friend
    VOID
    RedistributionSyncPhase6(
        IN OUT  PVOID       SyncPacket,
        IN      NTSTATUS    Status
        );

    friend
    VOID
    RedistributionSyncPhase5(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    RedistributionSyncPhase4(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    RedistributionSyncPhase3(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    RedistributionSyncPhase2(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    RedistributionSyncPhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    RedistributionRegionLockCompletion(
        IN OUT  PTRANSFER_PACKET    LockPacket
        );

    friend
    VOID
    RedistributionLockReplaceCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    RedistributionPropogateStateChangesWorker(
        IN  PVOID   WorkItem
        );

    public:

        virtual
        ~REDISTRIBUTION(
            );

        virtual
        NTSTATUS
        Initialize(
            IN OUT  PROOT_EXTENSION     RootExtension,
            IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
            IN OUT  PFT_VOLUME*         VolumeArray,
            IN      USHORT              ArraySize,
            IN      PVOID               ConfigInfo,
            IN      PVOID               StateInfo
            );

        virtual
        FT_LOGICAL_DISK_TYPE
        QueryLogicalDiskType(
            );

        virtual
        VOID
        Transfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        ReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        StartSyncOperations(
            IN      BOOLEAN                 RegenerateOrphans,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        StopSyncOperations(
            );

        virtual
        LONGLONG
        QueryVolumeSize(
            );

        virtual
        VOID
        CompleteNotification(
            IN  BOOLEAN IoPending
            );

        virtual
        NTSTATUS
        CheckIo(
            OUT PBOOLEAN    IsIoOk
            );

        virtual
        VOID
        NewStateArrival(
            IN  PVOID   NewStateInstance
            );

        virtual
        NTSTATUS
        QueryPhysicalOffsets(
            IN  LONGLONG                    LogicalOffset,
            OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
            OUT PULONG                      NumberOfPhysicalOffsets
            );

        virtual
        NTSTATUS
        QueryLogicalOffset(
            IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
            OUT PLONGLONG               LogicalOffset
            );

    private:

        VOID
        RedistributeTransfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        VOID
        RedistributeReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        VOID
        PropogateStateChanges(
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        VOID
        MaxTransfer(
            IN OUT  PREDISTRIBUTION_TP  TransferPacket
            );

        VOID
        VerifyWrite(
            IN OUT  PREDISTRIBUTION_TP  TransferPacket
            );

        VOID
        CarefulWrite(
            IN OUT  PREDISTRIBUTION_TP  TransferPacket
            );

        ULONG       _stripeSize;
        USHORT      _firstWidth;
        USHORT      _totalWidth;
        LONGLONG    _firstSize;
        LONGLONG    _totalSize;
        BOOLEAN     _syncOk;
        BOOLEAN     _stopSyncs;

        FT_REDISTRIBUTION_STATE_INFORMATION _state;
        BOOLEAN                             _redistributionComplete;

        OVERLAPPED_IO_MANAGER   _overlappedIoManager;

};

typedef struct _FTP_GPT_ATTRIBUTE_REVERT_ENTRY {
    GUID        PartitionUniqueId;
    ULONGLONG   GptAttributes;
    ULONG       MbrSignature;
    ULONG       Reserved;
} FTP_GPT_ATTRIBUTE_REVERT_ENTRY, *PFTP_GPT_ATTRIBUTE_REVERT_ENTRY;

struct DEVICE_EXTENSION {

    //
    // Pointer to the device object for this extension.
    //

    PDEVICE_OBJECT DeviceObject;    // 00

    //
    // Pointer to the root device extension.
    //

    PROOT_EXTENSION Root; // 04

    //
    // The type of device extension.
    //

    ULONG DeviceExtensionType;  // 08

    //
    // A spinlock for synchronization.
    //

    KSPIN_LOCK SpinLock;    // 0C

};

class ROOT_EXTENSION : public DEVICE_EXTENSION {

    public:

        //
        // Pointer to the driver object.
        //

        PDRIVER_OBJECT DriverObject;    // 10

        //
        // Pointer to the next device in the stack.
        //

        PDEVICE_OBJECT TargetObject;    // 14

        //
        // Pointer to the PDO.
        //

        PDEVICE_OBJECT Pdo; // 18

        //
        // List of volumes in the system.  Protect with 'Semaphore'.
        //

        LIST_ENTRY VolumeList;  // 1C

        //
        // List of dead volumes.  Protect with 'Semaphore'.
        //

        LIST_ENTRY DeadVolumeList;  // 2C

        //
        // The next volume number.  Protect with 'Semaphore'.
        //

        ULONG NextVolumeNumber; // 34

        //
        // The disk information set for the on disk storage of FT sets.
        // Protect with 'Semaphore'.
        //

        PFT_LOGICAL_DISK_INFORMATION_SET DiskInfoSet;   // 38

        //
        // Private worker thread and queue.  Protect queue with 'SpinLock'.
        //

        PVOID WorkerThread;         // 3C
        LIST_ENTRY WorkerQueue;     // 40
        KSEMAPHORE WorkerSemaphore; // 44
        LONG TerminateThread;       // 58

        //
        // Change notify Irp list.  Protect with cancel spin lock.
        //

        LIST_ENTRY ChangeNotifyIrpList; // 5C

        //
        // A semaphore for synchronization.
        //

        KSEMAPHORE Mutex;   // 64

        //
        // Device Interface name.
        //

        UNICODE_STRING VolumeManagerInterfaceName; // 78

        //
        // Whether or not we are past the boot reinitialize code.
        //

        BOOLEAN PastBootReinitialize; // 80

        //
        // Whether or not the FT specific code has been locked down.
        //

        BOOLEAN FtCodeLocked;   // 81

        //
        // Whether or not we are past the reinitialize code.
        //

        BOOLEAN PastReinitialize;   // 82

        //
        // Registry Path.
        //

        UNICODE_STRING DiskPerfRegistryPath;

        //
        // Table of PmWmiCounter Functions.
        //

        PMWMICOUNTERLIB_CONTEXT PmWmiCounterLibContext;

        //
        // The Unique partition type GUID of the ESP.
        //

        GUID ESPUniquePartitionGUID;

        //
        // An array of gpt attribute revert records retrieved from the
        // registry at boot up.
        //

        ULONG NumberOfAttributeRevertEntries;
        PFTP_GPT_ATTRIBUTE_REVERT_ENTRY GptAttributeRevertEntries;

        //
        // The number of pre-exposures.  Protect with 'Semaphore'.
        //

        ULONG PreExposureCount;

};

typedef DEVICE_EXTENSION *PDEVICE_EXTENSION;

typedef
VOID
(*ZERO_REF_CALLBACK)(
    IN  PVOLUME_EXTENSION   VolumeExtension
    );

class VOLUME_EXTENSION : public DEVICE_EXTENSION {

    public:

        //
        // A pointer to the target object or the FT volume for this
        // volume.  Protect these with 'SpinLock'.
        //

        PDEVICE_OBJECT TargetObject;        // 10
        PFT_VOLUME FtVolume;                // 14
        LONG RefCount;                      // 18
        ZERO_REF_CALLBACK ZeroRefCallback;  // 1C
        PVOID ZeroRefContext;               // 20
        LIST_ENTRY ZeroRefHoldQueue;        // 24
        BOOLEAN IsStarted;                  // 2C
        BOOLEAN IsComplete;                 // 2D
        BOOLEAN InPagingPath;               // 2E
        BOOLEAN RemoveInProgress;           // 2F
        BOOLEAN IsOffline;                  // 30
        BOOLEAN DeadToPnp;                  // 31
        BOOLEAN DeviceDeleted;              // 32
        BOOLEAN IsPreExposure;              // 33
        BOOLEAN IsGpt;                      // 34
        BOOLEAN IsHidden;                   // 35
        BOOLEAN IsSuperFloppy;              // 36
        BOOLEAN IsReadOnly;                 // 37
        BOOLEAN IsEspType;                  // 38
        BOOLEAN IsInstalled;
        LONG AllSystemsGo;                  // 38
        GUID* OfflineOwner;

        //
        // List entry for volume list or dead volume list.
        // Protect with 'Root->Semaphore'.
        //

        LIST_ENTRY ListEntry;   // 3C

        //
        // The volume number.
        //

        ULONG VolumeNumber; // 44

        //
        // Emergency queue for a transfer packet.  Protect with 'SpinLock'.
        //

        PDISPATCH_TP EmergencyTransferPacket;       // 48
        LIST_ENTRY EmergencyTransferPacketQueue;    // 4C
        BOOLEAN EmergencyTransferPacketInUse;       // 54

        //
        // List of unique id change notify IRPs.
        //

        LIST_ENTRY ChangeNotifyIrps; // 58

        //
        // The dev node name for this device.
        //

        UNICODE_STRING DeviceNodeName;  // 60

        //
        // Whole disk PDO, if this extension is a partition and
        // not an FT volume.
        //

        PDEVICE_OBJECT WholeDiskPdo;    // 68
        PDEVICE_OBJECT WholeDisk;       // 6C
        LONGLONG PartitionOffset;       // 70
        LONGLONG PartitionLength;       // 78
        ULONG Signature;

        //
        // Device Interface name.
        //

        UNICODE_STRING MountedDeviceInterfaceName;  // 80

        //
        // A semaphore to protect 'ZeroRefCallback'.
        //

        KSEMAPHORE Semaphore;   // 8C

        //
        // Old whole disk PDO to facilitate debugging.
        //

        PDEVICE_OBJECT OldWholeDiskPdo; // A0

        //
        // Unique Id Guid in the GPT case.
        //

        GUID UniqueIdGuid;  // A4

        //
        // A copy of the current power state.  Protect with 'SpinLock'.
        //

        DEVICE_POWER_STATE PowerState;  // B4

        //
        // Whether or not the counters are running.
        //

        BOOLEAN CountersEnabled;

        //
        // Leave counters always enabled if we see IOCTL_DISK_PERFORMANCE
        //

        LONG EnableAlways;

        //
        // Counter structure.
        //

        PVOID PmWmiCounterContext;

        //
        // Table of Wmi Functions.
        //

        PWMILIB_CONTEXT WmilibContext;

        //
        // State for reverting GPT attributes.  Protect with 'Root->Semaphore'.
        //

        ULONGLONG GptAttributesToRevertTo;
        PFILE_OBJECT RevertOnCloseFileObject;
        BOOLEAN ApplyToAllConnectedVolumes;

        //
        // Cached MBR GPT attributes.
        //

        ULONGLONG MbrGptAttributes;

};

#define DEVICE_EXTENSION_ROOT   (0)
#define DEVICE_EXTENSION_VOLUME (1)

BOOLEAN
FtpIsWorseStatus(
    IN  NTSTATUS    Status1,
    IN  NTSTATUS    Status2
    );

VOID
FtpComputeParity(
    IN  PVOID   TargetBuffer,
    IN  PVOID   SourceBuffer,
    IN  ULONG   BufferLength
    );

VOID
FtpLogError(
    IN  PDEVICE_EXTENSION   Extension,
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  NTSTATUS            SpecificIoStatus,
    IN  NTSTATUS            FinalStatus,
    IN  ULONG               UniqueErrorValue
    );

VOID
FtpQueueWorkItem(
    IN  PROOT_EXTENSION     RootExtension,
    IN  PWORK_QUEUE_ITEM    WorkItem
    );

VOID
FtpNotify(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      PVOLUME_EXTENSION   Extension
    );

VOID
FtpAcquire(
    IN OUT  PROOT_EXTENSION RootExtension
    );

NTSTATUS
FtpAcquireWithTimeout(
    IN OUT  PROOT_EXTENSION RootExtension
    );

VOID
FtpRelease(
    IN OUT  PROOT_EXTENSION RootExtension
    );

VOID
FtpDecrementRefCount(
    IN OUT  PVOLUME_EXTENSION   Extension
    );

FT_LOGICAL_DISK_ID
GenerateNewLogicalDiskId(
    );

NTSTATUS
FtpQueryPartitionInformation(
    IN  PROOT_EXTENSION RootExtension,
    IN  PDEVICE_OBJECT  Partition,
    OUT PULONG          DiskNumber,
    OUT PLONGLONG       Offset,
    OUT PULONG          PartitionNumber,
    OUT PUCHAR          PartitionType,
    OUT PLONGLONG       PartitionLength,
    OUT GUID*           PartitionTypeGuid,
    OUT GUID*           PartitionUniqueIdGuid,
    OUT PBOOLEAN        IsGpt,
    OUT PULONGLONG      GptAttributes
    );

ULONG
FtpQueryDiskSignature(
    IN  PDEVICE_OBJECT  WholeDiskPdo
    );

NTSTATUS
FtpDiskRegistryQueryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    );

PDISK_PARTITION
FtpFindDiskPartition(
    IN  PDISK_REGISTRY  DiskRegistry,
    IN  ULONG           Signature,
    IN  LONGLONG        Offset
    );

VOID
FtpCopyStateToRegistry(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  PVOID               LogicalDiskState,
    IN  USHORT              LogicalDiskStateSize
    );

BOOLEAN
FtpQueryStateFromRegistry(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  PVOID               LogicalDiskState,
    IN  USHORT              BufferSize,
    OUT PUSHORT             LogicalDiskStateSize
    );

VOID
FtpDeleteStateInRegistry(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    );

PVOLUME_EXTENSION
FtpFindExtensionCoveringDiskId(
    IN  PROOT_EXTENSION     RootExtension,
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    );

NTSTATUS
FtpReadPartitionTableEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRIVE_LAYOUT_INFORMATION_EX* DriveLayout
    );

NTSTATUS
FtpApplyESPProtection(
    IN  PUNICODE_STRING PartitionName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\ondisk.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    ondisk.h

Abstract:

    This header file defines the ondisk structures for storing FT
    information on disk.

Author:

    Norbert Kusters 15-July-1996

Notes:

Revision History:

--*/

#include <fttypes.h>

//
// Define an on disk signature so that we can recognize valid FT on disk
// structures.
//

#define FT_ON_DISK_SIGNATURE                    ((ULONG) 'TFTN')
#define FT_ON_DISK_DESCRIPTION_VERSION_NUMBER   (1)

//
// Define the preamble for the on disk structures which contains the
// signature and a pointer to the first FT disk description.
//

typedef struct _FT_ON_DISK_PREAMBLE {
    ULONG   FtOnDiskSignature;
    ULONG   DiskDescriptionVersionNumber;
    ULONG   ByteOffsetToFirstFtLogicalDiskDescription;
    ULONG   ByteOffsetToReplaceLog;
} FT_ON_DISK_PREAMBLE, *PFT_ON_DISK_PREAMBLE;

//
// Define the FT logical disk description structure.
//

typedef struct _FT_LOGICAL_DISK_DESCRIPTION {
    USHORT                  DiskDescriptionSize;
    UCHAR                   DriveLetter;
    UCHAR                   Reserved;
    FT_LOGICAL_DISK_TYPE    LogicalDiskType;
    FT_LOGICAL_DISK_ID      LogicalDiskId;

    union {

        struct {
            LONGLONG    ByteOffset;
            LONGLONG    PartitionSize;  // 0 indicates full size.
        } FtPartition;

        struct {
            FT_LOGICAL_DISK_ID  ThisMemberLogicalDiskId;
            USHORT              ThisMemberNumber;
            USHORT              NumberOfMembers;
            USHORT              ByteOffsetToConfigurationInformation;
            USHORT              ByteOffsetToStateInformation;
        } Other;

    } u;

} FT_LOGICAL_DISK_DESCRIPTION, *PFT_LOGICAL_DISK_DESCRIPTION;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\ftvol.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    ftvol.cxx

Abstract:

    This module contains the code specific to all volume objects.

Author:

    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

VOID
FT_VOLUME::Initialize(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This is the init routine for an FT_VOLUME.  It must be called before
    the FT_VOLUME is used.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id for this volume.

Return Value:

    None.

--*/

{
    KeInitializeSpinLock(&_spinLock);
    _diskInfoSet = RootExtension->DiskInfoSet;
    _rootExtension = RootExtension;
    _logicalDiskId = LogicalDiskId;
}

BOOLEAN
FT_VOLUME::IsVolumeSuitableForRegenerate(
    IN  USHORT      MemberNumber,
    IN  PFT_VOLUME  Volume
    )

/*++

Routine Description:

    This routine computes whether or not the given volume is suitable
    for a regenerate operation.

Arguments:

    MemberNumber    - Supplies the member number.

    Volume          - Supplies the volume.

Return Value:

    FALSE   - The volume is not suitable.

    TRUE    - The volume is suitable.

--*/

{
    return FALSE;
}

VOID
FT_VOLUME::ModifyStateForUser(
    IN OUT  PVOID   State
    )

/*++

Routine Description:

    This routine modifies the state for the user to see, possibly adding
    non-persistant state different than what is stored on disk.

Arguments:

    State   - Supplies and returns the state for the logical disk.

Return Value:

    None.

--*/

{
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

PVOID
FT_BASE_CLASS::operator new(
    IN  size_t    Size
    )

/*++

Routine Description:

    This routine is the memory allocator for all classes derived from
    FT_VOLUME.

Arguments:

    Size    - Supplies the number of bytes to allocate.

Return Value:

    A pointer to Size bytes of non-paged pool.

--*/

{
    return ExAllocatePool(NonPagedPool, Size);
}

VOID
FT_BASE_CLASS::operator delete(
    IN  PVOID   MemPtr
    )

/*++

Routine Description:

    This routine frees memory allocated for all classes derived from
    FT_VOLUME.

Arguments:

    MemPtr  - Supplies a pointer to the memory to free.

Return Value:

    None.

--*/

{
    if (MemPtr) {
        ExFreePool(MemPtr);
    }
}


FT_LOGICAL_DISK_ID
FT_VOLUME::QueryLogicalDiskId(
    )
{
    KIRQL               irql;
    FT_LOGICAL_DISK_ID  r;

    KeAcquireSpinLock(&_spinLock, &irql);
    r = _logicalDiskId;
    KeReleaseSpinLock(&_spinLock, irql);

    return r;
}

VOID
FT_VOLUME::SetLogicalDiskId(
    IN  FT_LOGICAL_DISK_ID  NewLogicalDiskId
    )
{
    KIRQL   irql;

    KeAcquireSpinLock(&_spinLock, &irql);
    _logicalDiskId = NewLogicalDiskId;
    KeReleaseSpinLock(&_spinLock, irql);
}

VOID
FtVolumeNotifyWorker(
    IN  PVOID   FtVolume
    )

/*++

Routine Description:

    This is the worker routine to signal a notify on the given volume
    object.

Arguments:

    FtVolume    - Supplies the FT volume.

Return Value:

    None.

--*/

{
    PFT_VOLUME          vol = (PFT_VOLUME) FtVolume;
    PVOLUME_EXTENSION   extension;

    FtpAcquire(vol->_rootExtension);
    extension = FtpFindExtensionCoveringDiskId(vol->_rootExtension,
                                               vol->QueryLogicalDiskId());
    FtpRelease(vol->_rootExtension);

    if (extension) {
        FtpNotify(extension->Root, extension);
    }

    if (!InterlockedDecrement(&vol->_refCount)) {
        delete vol;
    }
}

VOID
FT_VOLUME::Notify(
    )

/*++

Routine Description:

    This routine is called when a sub class would like to post notification
    about a state change.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PWORK_QUEUE_ITEM    workItem;

    workItem = (PWORK_QUEUE_ITEM)
               ExAllocatePool(NonPagedPool, sizeof(WORK_QUEUE_ITEM));
    if (!workItem) {
        return;
    }
    ExInitializeWorkItem(workItem, FtVolumeNotifyWorker, this);

    InterlockedIncrement(&_refCount);

    FtpQueueWorkItem(_rootExtension, workItem);
}

VOID
FT_VOLUME::NewStateArrival(
    IN  PVOID   NewStateInstance
    )

/*++

Routine Description:

    This routine takes the new state instance arrival combined with its
    current state to come up with the new current state for the volume.
    If the two states cannot be reconciled then this routine returns FALSE
    indicating that the volume is invalid and should be broken into its
    constituant parts.

Arguments:

    NewStateInstance    - Supplies the new state instance.

Return Value:

    None.

--*/

{
}

FT_VOLUME::~FT_VOLUME(
    )

/*++

Routine Description:

    Desctructor for FT_VOLUME.

Arguments:

    None.

Return Value:

    None.

--*/

{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\ftwmireg.h ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    ftwmireg.h

Abstract:

    This file contains prototypes for routines to register for and response 
    to WMI queries.

Author:

    Bruce Worthington      26-Oct-1998

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {

#include <ntddk.h>


NTSTATUS FtRegisterDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
FtQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
FtQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

BOOLEAN
FtQueryEnableAlways(
    IN PDEVICE_OBJECT DeviceObject
    );

extern WMIGUIDREGINFO DiskperfGuidList[];

extern ULONG DiskperfGuidCount;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\overlap.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    overlap.cxx

Abstract:

    This module contains code specific to the overlapped io manager.

    The purpose of this module is to help serialize io that overlaps with
    each other.  This class is used by stripes with parity to help prevent
    corruption caused by race conditions when computing parity.

Author:

    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
OVERLAPPED_IO_MANAGER::Initialize(
    IN  ULONG   BucketSize
    )

/*++

Routine Description:

    This routine initializes an overlapped io manager.

Arguments:

    BucketSize  - Supplies the bucket size.  Any I/O to this class may
                    not span more than one bucket.  In the case of stripes
                    with parity, the bucket size is the stripe size.  A
                    bucket size of 0 means that there are no buckets by
                    which requests would be partitioned (alt. an "infinite"
                    bucket size).

Return Value:

    NTSTATUS

--*/

{
    ULONG   i;

    _numQueues = 256;
    _bucketSize = BucketSize;
    if (!_bucketSize) {
        _bucketSize = STRIPE_SIZE;
        _numQueues = 1;
    }
    _spinLock = (PKSPIN_LOCK)
                ExAllocatePool(NonPagedPool, _numQueues*sizeof(KSPIN_LOCK));
    if (!_spinLock) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _ioQueue = (PLIST_ENTRY)
               ExAllocatePool(NonPagedPool, _numQueues*sizeof(LIST_ENTRY));
    if (!_ioQueue) {
        ExFreePool(_spinLock);
        _spinLock = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (i = 0; i < _numQueues; i++) {
        KeInitializeSpinLock(&_spinLock[i]);
        InitializeListHead(&_ioQueue[i]);
    }

    return STATUS_SUCCESS;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

VOID
OVERLAPPED_IO_MANAGER::AcquireIoRegion(
    IN OUT  POVERLAP_TP TransferPacket,
    IN      BOOLEAN     AllMembers
    )

/*++

Routine Description:

    This routine queues the given transfer packet for its desired region.
    The transfer packet completion routine will be called when the region
    is free.  'ReleaseIoRegion' must be called to allow other transfer packets
    to pass for a region that overlaps with one that is acquired.

Arguments:

    TransferPacket  - Supplies the IO region and completion routine.

    AllMembers      - Supplies whether or not to allocate this region
                        on all members.

Return Value:

    None.

--*/

{
    ULONG       queueNumber;
    PLIST_ENTRY q;
    PKSPIN_LOCK spin;
    KIRQL       irql;
    PLIST_ENTRY l;
    POVERLAP_TP p;

    ASSERT(!TransferPacket->InQueue);

    TransferPacket->AllMembers = AllMembers;
    TransferPacket->OverlappedIoManager = this;

    // Search the queue for a request that overlaps with this one.
    // If there is no overlap then call the completion routine
    // for this transfer packet.  Either way, queue this transfer
    // packet at the end of the queue.

    queueNumber = (ULONG) ((TransferPacket->Offset/_bucketSize)%_numQueues);
    q = &_ioQueue[queueNumber];
    spin = &_spinLock[queueNumber];
    KeAcquireSpinLock(spin, &irql);
    for (l = q->Blink; l != q; l = l->Blink) {

        p = CONTAINING_RECORD(l, OVERLAP_TP, OverlapQueue);

        if ((TransferPacket->AllMembers || p->AllMembers ||
             p->TargetVolume == TransferPacket->TargetVolume) &&
            p->Offset < TransferPacket->Offset + TransferPacket->Length &&
            TransferPacket->Offset < p->Offset + p->Length) {

            break;
        }
    }
    InsertTailList(q, &TransferPacket->OverlapQueue);
    TransferPacket->InQueue = TRUE;
    KeReleaseSpinLock(spin, irql);

    if (l == q) {
        TransferPacket->CompletionRoutine(TransferPacket);
    } else {
        // DbgPrint("Overlap: Transfer packet %x stuck in behind %x\n", TransferPacket, p);
    }
}

VOID
OVERLAPPED_IO_MANAGER::ReleaseIoRegion(
    IN OUT  POVERLAP_TP TransferPacket
    )

/*++

Routine Description:

    This routine releases the IO region held by this packet and
    wakes up waiting transfer packets.

Arguments:

    TransferPacket  - Supplies the TransferPacket whose region is to be
                        released.

Return Value:

    None.

--*/

{
    ULONG               queueNumber;
    PLIST_ENTRY         q;
    PKSPIN_LOCK         spin;
    LIST_ENTRY          completionList;
    KIRQL               irql;
    PLIST_ENTRY         l, ll;
    POVERLAP_TP         p, pp;

    if (!TransferPacket->InQueue) {
        return;
    }

    queueNumber = (ULONG) ((TransferPacket->Offset/_bucketSize)%_numQueues);
    q = &_ioQueue[queueNumber];
    spin = &_spinLock[queueNumber];
    InitializeListHead(&completionList);

    KeAcquireSpinLock(spin, &irql);
    l = TransferPacket->OverlapQueue.Flink;
    RemoveEntryList(&TransferPacket->OverlapQueue);
    TransferPacket->InQueue = FALSE;
    for (; l != q; l = l->Flink) {

        p = CONTAINING_RECORD(l, OVERLAP_TP, OverlapQueue);

        if ((TransferPacket->AllMembers || p->AllMembers ||
             p->TargetVolume == TransferPacket->TargetVolume) &&
            TransferPacket->Offset < p->Offset + p->Length &&
            p->Offset < TransferPacket->Offset + TransferPacket->Length) {

            // This is a candidate for allocation, make sure that it
            // is clear to run by checking for any other contention.

            for (ll = p->OverlapQueue.Blink; ll != q; ll = ll->Blink) {

                pp = CONTAINING_RECORD(ll, OVERLAP_TP, OverlapQueue);

                if ((p->AllMembers || pp->AllMembers ||
                     p->TargetVolume == pp->TargetVolume) &&
                    pp->Offset < p->Offset + p->Length &&
                    p->Offset < pp->Offset + pp->Length) {

                    break;
                }
            }

            if (ll == q) {
                InsertTailList(&completionList, &p->CompletionList);
                // DbgPrint("Overlap: Releasing packet %x that was behind %x\n", p, TransferPacket);
            }
        }
    }
    KeReleaseSpinLock(spin, irql);

    while (!IsListEmpty(&completionList)) {
        l = RemoveHeadList(&completionList);
        p = CONTAINING_RECORD(l, OVERLAP_TP, CompletionList);
        p->CompletionRoutine(p);
    }
}

VOID
OVERLAPPED_IO_MANAGER::PromoteToAllMembers(
    IN OUT  POVERLAP_TP TransferPacket
    )

/*++

Routine Description:

    This routine promotes an already allocated transfer packet to
    all members.

Arguments:

    TransferPacket  - Supplies a transfer packet that is already in
                        the overlapped io queue.

Return Value:

    None.

--*/

{
    ULONG       queueNumber;
    PLIST_ENTRY q;
    PKSPIN_LOCK spin;
    KIRQL       irql;
    PLIST_ENTRY l;
    POVERLAP_TP p;

    if (TransferPacket->AllMembers) {
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    // DbgPrint("Overlap: Promoting %x to all members.\n", TransferPacket);

    queueNumber = (ULONG) ((TransferPacket->Offset/_bucketSize)%_numQueues);
    q = &_ioQueue[queueNumber];
    spin = &_spinLock[queueNumber];
    KeAcquireSpinLock(spin, &irql);
    ASSERT(!TransferPacket->AllMembers);
    TransferPacket->AllMembers = TRUE;
    for (l = q->Blink; l != &TransferPacket->OverlapQueue; l = l->Blink) {

        p = CONTAINING_RECORD(l, OVERLAP_TP, OverlapQueue);

        if (!p->AllMembers &&
            p->TargetVolume != TransferPacket->TargetVolume &&
            TransferPacket->Offset < p->Offset + p->Length &&
            p->Offset < TransferPacket->Offset + TransferPacket->Length) {

            break;
        }
    }
    if (l != &TransferPacket->OverlapQueue) {
        RemoveEntryList(&TransferPacket->OverlapQueue);
        InsertHeadList(l, &TransferPacket->OverlapQueue);
        // DbgPrint("Moving behind %x.\n", p);
    }
    for (l = TransferPacket->OverlapQueue.Blink; l != q; l = l->Blink) {

        p = CONTAINING_RECORD(l, OVERLAP_TP, OverlapQueue);

        if (TransferPacket->Offset < p->Offset + p->Length &&
            p->Offset < TransferPacket->Offset + TransferPacket->Length) {

            break;
        }
    }
    KeReleaseSpinLock(spin, irql);

    if (l == q) {
        TransferPacket->CompletionRoutine(TransferPacket);
    } else {
        // DbgPrint("Overlap: Waiting for %x.\n", p);
    }
}

OVERLAPPED_IO_MANAGER::~OVERLAPPED_IO_MANAGER(
            )

{
    if (_spinLock) {
        ExFreePool(_spinLock);
        _spinLock = NULL;
    }
    if (_ioQueue) {
        ExFreePool(_ioQueue);
        _ioQueue = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\ftwmireg.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    ftwmireg.cxx

Abstract:

    This file contains routines to register for and response to WMI queries.

Author:

    Bruce Worthington      26-Oct-1998

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
    #include <mountmgr.h>
}

#include <ftdisk.h>

extern "C" {

#define INITGUID

#include "wmistr.h"
#include "wmiguid.h"
#include "ntdddisk.h"

NTSTATUS FtRegisterDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
FtQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
FtQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

BOOLEAN
FtQueryEnableAlways(
    IN PDEVICE_OBJECT DeviceObject
    );

WMIGUIDREGINFO DiskperfGuidList[] =
{
    { &DiskPerfGuid,
      1,
      0
    }
};

ULONG DiskperfGuidCount = (sizeof(DiskperfGuidList) / sizeof(WMIGUIDREGINFO));
}


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif



NTSTATUS
FtRegisterDevice(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Routine to initialize a proper name for the device object, and
    register it with WMI

Arguments:

    DeviceObject - pointer to a device object to be initialized.

Return Value:

    Status of the initialization. NOTE: If the registration fails,
    the device name in the DeviceExtension will be left as empty.

--*/

{
    NTSTATUS                status;
    PVOLUME_EXTENSION       deviceExtension;
    KEVENT                  event;
    PIRP                    irp;
    IO_STATUS_BLOCK         ioStatus;

    PAGED_CODE();

    deviceExtension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;

    status = IoWMIRegistrationControl(DeviceObject, WMIREG_ACTION_REGISTER);

    if (NT_SUCCESS(status) && (deviceExtension->Root->PmWmiCounterLibContext.PmWmiCounterEnable != NULL)) {
        deviceExtension->Root->PmWmiCounterLibContext.PmWmiCounterEnable(&deviceExtension->PmWmiCounterContext);
        deviceExtension->Root->PmWmiCounterLibContext.PmWmiCounterDisable(&deviceExtension->PmWmiCounterContext,FALSE,FALSE);
    }

    return status;
}



NTSTATUS
FtQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned unmodified. If a value is returned then
        it is NOT freed.
        The MOF file is assumed to be already included in wmicore.mof

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    NTSTATUS status;
    PVOLUME_EXTENSION  deviceExtension;

    deviceExtension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;

    PAGED_CODE();

    InstanceName->Buffer = (PWSTR) NULL;
    *RegistryPath = &deviceExtension->Root->DiskPerfRegistryPath;
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO | WMIREG_FLAG_EXPENSIVE;
    *Pdo = DeviceObject;
    status = STATUS_SUCCESS;

    return(status);
}



NTSTATUS
FtQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. When the driver has finished filling the
    data block it must call WmiCompleteRequest to complete the irp. The
    driver can return STATUS_PENDING if the irp cannot be completed
    immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instances expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry.


Return Value:

    status

--*/
{
    NTSTATUS status;
    PVOLUME_EXTENSION deviceExtension;
    ULONG sizeNeeded = 0;
    KIRQL        currentIrql;
    WCHAR stringBuffer[40];
    USHORT stringSize;
    PWCHAR diskNamePtr;

    PAGED_CODE();

    deviceExtension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;

    if (GuidIndex == 0)
    {
        if (!(deviceExtension->CountersEnabled)) {
            status = STATUS_UNSUCCESSFUL;
        } else {
            swprintf(stringBuffer, L"\\Device\\HarddiskVolume%d", 
                     deviceExtension->VolumeNumber);
            stringSize = (USHORT) (wcslen(stringBuffer) * sizeof(WCHAR));
        
            sizeNeeded = ((sizeof(DISK_PERFORMANCE) + 1) & ~1) 
                         + stringSize + sizeof(UNICODE_NULL);
            if (BufferAvail >= sizeNeeded) {
                deviceExtension->Root->PmWmiCounterLibContext.
                  PmWmiCounterQuery(deviceExtension->PmWmiCounterContext, 
                                    (PDISK_PERFORMANCE) Buffer, 
                                    L"FTDISK  ", 
                                    deviceExtension->VolumeNumber);
                diskNamePtr = (PWCHAR)(Buffer +
                              ((sizeof(DISK_PERFORMANCE) + 1) & ~1));
                *diskNamePtr++ = stringSize;
                RtlCopyMemory(diskNamePtr,
                              stringBuffer,
                              stringSize);
                *InstanceLengthArray = sizeNeeded;
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    } else {
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest( DeviceObject, Irp, status, sizeNeeded,
                                 IO_NO_INCREMENT);
    return status;
}


BOOLEAN
FtQueryEnableAlways(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    NTSTATUS status;
    UNICODE_STRING uString;
    OBJECT_ATTRIBUTES objAttributes;
    PKEY_VALUE_PARTIAL_INFORMATION keyValue;
    ULONG Buffer[4];        // sizeof keyValue + ULONG
    ULONG enableAlways = 0;
    PVOLUME_EXTENSION extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    HANDLE keyHandle;
    ULONG returnLength;

    PAGED_CODE();

    RtlInitUnicodeString(&uString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Partmgr");
    InitializeObjectAttributes(
        &objAttributes,
        &uString,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    status = ZwOpenKey(&keyHandle, KEY_READ, &objAttributes);
    if (NT_SUCCESS(status)) {
        RtlInitUnicodeString(&uString, L"EnableCounterForIoctl");
        status = ZwQueryValueKey(keyHandle, &uString,
                    KeyValuePartialInformation,
                    Buffer,
                    sizeof(Buffer),
                    &returnLength);
        keyValue = (PKEY_VALUE_PARTIAL_INFORMATION) &Buffer[0];
        if (NT_SUCCESS(status) && (keyValue->DataLength == sizeof(ULONG))) {
            enableAlways = *((PULONG) keyValue->Data);
        }
        ZwClose(keyHandle);
    }

    if (enableAlways == 1) {
        if (InterlockedCompareExchange(&extension->EnableAlways, 1, 0) == 0) {
            status = extension->Root->PmWmiCounterLibContext.
                        PmWmiCounterEnable(&extension->PmWmiCounterContext);
            if (NT_SUCCESS(status)) {
                extension->CountersEnabled = TRUE;
                return TRUE;
            }
            else {
                InterlockedExchange(&extension->EnableAlways, 0);
            }
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\packet.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    packet.cxx

Abstract:

    This module contains the code specific to all types of TRANSFER_PACKETS
    objects.

Author:

    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>

static PNPAGED_LOOKASIDE_LIST   StripeLookasidePackets = NULL;
static PNPAGED_LOOKASIDE_LIST   MirrorLookasidePackets = NULL;


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

PVOID
TRANSFER_PACKET::operator new(
    IN  size_t    Size
    )

/*++

Routine Description:

    This routine is the memory allocator for all classes derived from
    FT_VOLUME.

Arguments:

    Size    - Supplies the number of bytes to allocate.

Return Value:

    A pointer to Size bytes of non-paged pool.

--*/

{
    PTRANSFER_PACKET    p;

    if (Size <= sizeof(STRIPE_TP)) {
        if (!StripeLookasidePackets) {
            StripeLookasidePackets = (PNPAGED_LOOKASIDE_LIST)
                    ExAllocatePool(NonPagedPool,
                                   sizeof(NPAGED_LOOKASIDE_LIST));
            if (!StripeLookasidePackets) {
                return NULL;
            }

            ExInitializeNPagedLookasideList(StripeLookasidePackets, NULL, NULL,
                                            0, sizeof(STRIPE_TP), 'sFcS', 32);
        }

        p = (PTRANSFER_PACKET)
            ExAllocateFromNPagedLookasideList(StripeLookasidePackets);
        if (p) {
            p->_allocationType = TP_ALLOCATION_STRIPE_POOL;
        }
        return p;
    }

    if (Size <= sizeof(MIRROR_TP)) {
        if (!MirrorLookasidePackets) {
            MirrorLookasidePackets = (PNPAGED_LOOKASIDE_LIST)
                    ExAllocatePool(NonPagedPool,
                                   sizeof(NPAGED_LOOKASIDE_LIST));
            if (!MirrorLookasidePackets) {
                return NULL;
            }

            ExInitializeNPagedLookasideList(MirrorLookasidePackets, NULL, NULL,
                                            0, sizeof(MIRROR_TP), 'mFcS', 32);
        }

        p = (PTRANSFER_PACKET)
            ExAllocateFromNPagedLookasideList(MirrorLookasidePackets);
        if (p) {
            p->_allocationType = TP_ALLOCATION_MIRROR_POOL;
        }
        return p;
    }

    p = (PTRANSFER_PACKET) ExAllocatePool(NonPagedPool, Size);
    if (p) {
        p->_allocationType = 0;
    }
    return p;
}

VOID
TRANSFER_PACKET::operator delete(
    IN  PVOID   MemPtr
    )

/*++

Routine Description:

    This routine frees memory allocated for all classes derived from
    FT_VOLUME.

Arguments:

    MemPtr  - Supplies a pointer to the memory to free.

Return Value:

    None.

--*/

{
    PTRANSFER_PACKET    p = (PTRANSFER_PACKET) MemPtr;

    if (!p) {
        return;
    }

    if (p->_allocationType == TP_ALLOCATION_STRIPE_POOL) {
        ExFreeToNPagedLookasideList(StripeLookasidePackets, MemPtr);
    } else if (p->_allocationType == TP_ALLOCATION_MIRROR_POOL) {
        ExFreeToNPagedLookasideList(MirrorLookasidePackets, MemPtr);
    } else {
        ExFreePool(MemPtr);
    }
}

TRANSFER_PACKET::~TRANSFER_PACKET(
    )

/*++

Routine Description:

    This is the destructor for a transfer packet.  It frees up any allocated
    MDL and buffer.

Arguments:

    None.

Return Value:

    None.

--*/

{
    FreeMdl();
}

BOOLEAN
TRANSFER_PACKET::AllocateMdl(
    IN  PVOID   Buffer,
    IN  ULONG   Length
    )

/*++

Routine Description:

    This routine allocates an MDL and for this transfer packet.

Arguments:

    Buffer  - Supplies the buffer.

    Length  - Supplies the buffer length.

Return Value:

    FALSE   - Insufficient resources.

    TRUE    - Success.

--*/

{
    FreeMdl();

    Mdl = IoAllocateMdl(Buffer, Length, FALSE, FALSE, NULL);
    if (!Mdl) {
        return FALSE;
    }
    _freeMdl = TRUE;

    return TRUE;
}

BOOLEAN
TRANSFER_PACKET::AllocateMdl(
    IN  ULONG   Length
    )

/*++

Routine Description:

    This routine allocates an MDL and buffer for this transfer packet.

Arguments:

    Length  - Supplies the buffer length.

Return Value:

    FALSE   - Insufficient resources.

    TRUE    - Success.

--*/

{
    PVOID   buffer;

    FreeMdl();

    buffer = ExAllocatePool(NonPagedPoolCacheAligned,
                            Length < PAGE_SIZE ? PAGE_SIZE : Length);
    if (!buffer) {
        return FALSE;
    }
    _freeBuffer = TRUE;

    Mdl = IoAllocateMdl(buffer, Length, FALSE, FALSE, NULL);
    if (!Mdl) {
        ExFreePool(buffer);
        _freeBuffer = FALSE;
        return FALSE;
    }
    _freeMdl = TRUE;
    MmBuildMdlForNonPagedPool(Mdl);

    return TRUE;
}

VOID
TRANSFER_PACKET::FreeMdl(
    )

/*++

Routine Description:

    It frees up any allocated MDL and buffer.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (_freeBuffer) {
        ExFreePool(MmGetMdlVirtualAddress(Mdl));
        _freeBuffer = FALSE;
    }
    if (_freeMdl) {
        IoFreeMdl(Mdl);
        _freeMdl = FALSE;
    }
}

OVERLAP_TP::~OVERLAP_TP(
    )

{
    if (InQueue) {
        OverlappedIoManager->ReleaseIoRegion(this);
    }
}

MIRROR_RECOVER_TP::~MIRROR_RECOVER_TP(
    )

{
    FreeMdls();
}

BOOLEAN
MIRROR_RECOVER_TP::AllocateMdls(
    IN  ULONG   Length
    )

{
    PVOID   buffer;

    FreeMdls();

    PartialMdl = IoAllocateMdl((PVOID) (PAGE_SIZE - 1), Length,
                               FALSE, FALSE, NULL);

    if (!PartialMdl) {
        FreeMdls();
        return FALSE;
    }

    buffer = ExAllocatePool(NonPagedPoolCacheAligned,
                            Length < PAGE_SIZE ? PAGE_SIZE : Length);
    if (!buffer) {
        FreeMdls();
        return FALSE;
    }

    VerifyMdl = IoAllocateMdl(buffer, Length, FALSE, FALSE, NULL);
    if (!VerifyMdl) {
        ExFreePool(buffer);
        FreeMdls();
        return FALSE;
    }
    MmBuildMdlForNonPagedPool(VerifyMdl);

    return TRUE;
}

VOID
MIRROR_RECOVER_TP::FreeMdls(
    )

{
    if (PartialMdl)  {
        IoFreeMdl(PartialMdl);
        PartialMdl = NULL;
    }
    if (VerifyMdl) {
        ExFreePool(MmGetMdlVirtualAddress(VerifyMdl));
        IoFreeMdl(VerifyMdl);
        VerifyMdl = NULL;
    }
}

SWP_RECOVER_TP::~SWP_RECOVER_TP(
    )

{
    FreeMdls();
}

BOOLEAN
SWP_RECOVER_TP::AllocateMdls(
    IN  ULONG   Length
    )

{
    PVOID   buffer;

    FreeMdls();

    PartialMdl = IoAllocateMdl((PVOID) (PAGE_SIZE - 1), Length,
                               FALSE, FALSE, NULL);

    if (!PartialMdl) {
        FreeMdls();
        return FALSE;
    }

    buffer = ExAllocatePool(NonPagedPoolCacheAligned,
                            Length < PAGE_SIZE ? PAGE_SIZE : Length);
    if (!buffer) {
        FreeMdls();
        return FALSE;
    }

    VerifyMdl = IoAllocateMdl(buffer, Length, FALSE, FALSE, NULL);
    if (!VerifyMdl) {
        ExFreePool(buffer);
        FreeMdls();
        return FALSE;
    }
    MmBuildMdlForNonPagedPool(VerifyMdl);

    return TRUE;
}

VOID
SWP_RECOVER_TP::FreeMdls(
    )

{
    if (PartialMdl)  {
        IoFreeMdl(PartialMdl);
        PartialMdl = NULL;
    }
    if (VerifyMdl) {
        ExFreePool(MmGetMdlVirtualAddress(VerifyMdl));
        IoFreeMdl(VerifyMdl);
        VerifyMdl = NULL;
    }
}

SWP_WRITE_TP::~SWP_WRITE_TP(
    )

{
    FreeMdls();
}

BOOLEAN
SWP_WRITE_TP::AllocateMdls(
    IN  ULONG   Length
    )

{
    PVOID   buffer;

    FreeMdls();

    buffer = ExAllocatePool(NonPagedPoolCacheAligned,
                            Length < PAGE_SIZE ? PAGE_SIZE : Length);
    if (!buffer) {
        return FALSE;
    }

    ReadAndParityMdl = IoAllocateMdl(buffer, Length, FALSE, FALSE, NULL);
    if (!ReadAndParityMdl) {
        ExFreePool(buffer);
        return FALSE;
    }
    MmBuildMdlForNonPagedPool(ReadAndParityMdl);

    buffer = ExAllocatePool(NonPagedPoolCacheAligned,
                            Length < PAGE_SIZE ? PAGE_SIZE : Length);
    if (!buffer) {
        FreeMdls();
        return FALSE;
    }

    WriteMdl = IoAllocateMdl(buffer, Length, FALSE, FALSE, NULL);
    if (!WriteMdl) {
        ExFreePool(buffer);
        FreeMdls();
        return FALSE;
    }
    MmBuildMdlForNonPagedPool(WriteMdl);

    return TRUE;
}

VOID
SWP_WRITE_TP::FreeMdls(
    )

{
    if (ReadAndParityMdl)  {
        ExFreePool(MmGetMdlVirtualAddress(ReadAndParityMdl));
        IoFreeMdl(ReadAndParityMdl);
        ReadAndParityMdl = NULL;
    }
    if (WriteMdl) {
        ExFreePool(MmGetMdlVirtualAddress(WriteMdl));
        IoFreeMdl(WriteMdl);
        WriteMdl = NULL;
    }
}

REDISTRIBUTION_CW_TP::~REDISTRIBUTION_CW_TP(
    )

{
    FreeMdls();
}

BOOLEAN
REDISTRIBUTION_CW_TP::AllocateMdls(
    IN  ULONG   Length
    )

{
    PVOID   buffer;

    FreeMdls();

    PartialMdl = IoAllocateMdl((PVOID) (PAGE_SIZE - 1), Length,
                               FALSE, FALSE, NULL);

    if (!PartialMdl) {
        FreeMdls();
        return FALSE;
    }

    buffer = ExAllocatePool(NonPagedPoolCacheAligned,
                            Length < PAGE_SIZE ? PAGE_SIZE : Length);
    if (!buffer) {
        FreeMdls();
        return FALSE;
    }

    VerifyMdl = IoAllocateMdl(buffer, Length, FALSE, FALSE, NULL);
    if (!VerifyMdl) {
        ExFreePool(buffer);
        FreeMdls();
        return FALSE;
    }
    MmBuildMdlForNonPagedPool(VerifyMdl);

    return TRUE;
}

VOID
REDISTRIBUTION_CW_TP::FreeMdls(
    )

{
    if (PartialMdl)  {
        IoFreeMdl(PartialMdl);
        PartialMdl = NULL;
    }
    if (VerifyMdl) {
        ExFreePool(MmGetMdlVirtualAddress(VerifyMdl));
        IoFreeMdl(VerifyMdl);
        VerifyMdl = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\mirror.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    mirror.cxx

Abstract:

    This module contains the code specific to mirrors for the fault
    tolerance driver.

Author:

    Bob Rinne   (bobri)  2-Feb-1992
    Mike Glass  (mglass)
    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
MIRROR::Initialize(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN OUT  PFT_VOLUME*         VolumeArray,
    IN      USHORT              ArraySize,
    IN      PVOID               ConfigInfo,
    IN      PVOID               StateInfo
    )

/*++

Routine Description:

    Initialize routine for FT_VOLUME of type MIRROR.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id for this volume.

    VolumeArray     - Supplies the array of volumes for this volume set.

    ArraySize       - Supplies the number of volumes in the volume array.

    ConfigInfo      - Supplies the configuration information.

    StateInfo       - Supplies the state information.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                                    status;
    PFT_MIRROR_SET_CONFIGURATION_INFORMATION    config;

    if (ArraySize != 2) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!VolumeArray[0] && !VolumeArray[1]) {
        return STATUS_INVALID_PARAMETER;
    }

    status = COMPOSITE_FT_VOLUME::Initialize(RootExtension, LogicalDiskId,
                                             VolumeArray, ArraySize,
                                             ConfigInfo, StateInfo);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    config = (PFT_MIRROR_SET_CONFIGURATION_INFORMATION) ConfigInfo;

    _volumeSize = config->MemberSize;
    _requestCount[0] = 0;
    _requestCount[1] = 0;
    _lastPosition[0] = 0;
    _lastPosition[1] = 0;

    if (VolumeArray[0] && VolumeArray[0]->QueryVolumeSize() < _volumeSize) {
        return STATUS_INVALID_PARAMETER;
    }
    if (VolumeArray[1] && VolumeArray[1]->QueryVolumeSize() < _volumeSize) {
        return STATUS_INVALID_PARAMETER;
    }

    RtlCopyMemory(&_state, StateInfo,
                  sizeof(FT_MIRROR_AND_SWP_STATE_INFORMATION));

    _originalDirtyBit = _state.IsDirty;
    _orphanedBecauseOfMissingMember = FALSE;
    _syncOk = TRUE;
    _balancedReads = _state.IsDirty ? FALSE : TRUE;
    _stopSyncs = FALSE;

    _ePacket = new MIRROR_TP;
    if (!_ePacket) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _ePacket2 = new MIRROR_TP;
    if (!_ePacket2) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _ePacketInUse = FALSE;
    InitializeListHead(&_ePacketQueue);

    _eRecoverPacket = new MIRROR_RECOVER_TP;
    if (!_eRecoverPacket) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!_eRecoverPacket->AllocateMdls(QuerySectorSize())) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _eRecoverPacketInUse = FALSE;
    InitializeListHead(&_eRecoverPacketQueue);

    status = _overlappedIoManager.Initialize(0);

    return status;
}

FT_LOGICAL_DISK_TYPE
MIRROR::QueryLogicalDiskType(
    )

/*++

Routine Description:

    This routine returns the type of the logical disk.

Arguments:

    None.

Return Value:

    The type of the logical disk.

--*/

{
    return FtMirrorSet;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

MIRROR::~MIRROR(
    )

{
    if (_ePacket) {
        delete _ePacket;
        _ePacket = NULL;
    }
    if (_ePacket2) {
        delete _ePacket2;
        _ePacket2 = NULL;
    }
    if (_eRecoverPacket) {
        delete _eRecoverPacket;
        _eRecoverPacket = NULL;
    }
}

NTSTATUS
MIRROR::OrphanMember(
    IN  USHORT                  MemberNumber,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine tries to orphan the given member of this logical disk. 
    A completion routine will be called if and only if this attempt is successful.

Arguments:

    MemberNumber        - Supplies the member number to orphan.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    NTSTATUS

--*/

{
    KIRQL       irql;
    NTSTATUS    status = STATUS_SUCCESS;
    BOOLEAN     b;

    if (MemberNumber >= 2) {
        return STATUS_INVALID_PARAMETER;
    }

    KeAcquireSpinLock(&_spinLock, &irql);
    b = SetMemberState(MemberNumber, FtMemberOrphaned);
    KeReleaseSpinLock(&_spinLock, irql);

    if (b) {
        PropogateStateChanges(CompletionRoutine, Context);
        Notify();
        FtpLogError(_rootExtension, QueryLogicalDiskId(),
                    FT_ORPHANING, STATUS_SUCCESS, 2);
    }

    return b ? STATUS_SUCCESS : STATUS_INVALID_PARAMETER;
}

VOID
MirrorCompositeVolumeCompletionRoutine(
    IN  PVOID       Context,
    IN  NTSTATUS    Status
    )

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    KIRQL                           irql;
    LONG                            count;

    context = (PFT_COMPLETION_ROUTINE_CONTEXT) Context;

    KeAcquireSpinLock(&context->SpinLock, &irql);
    if (!NT_SUCCESS(Status) &&
        FtpIsWorseStatus(Status, context->Status)) {

        context->Status = Status;
    }

    count = --context->RefCount;
    KeReleaseSpinLock(&context->SpinLock, irql);

    if (!count) {
        context->CompletionRoutine(context->Context, STATUS_SUCCESS);
        ExFreePool(context);
    }
}

VOID
FinishRegenerate(
    IN  PMIRROR                         Mirror,
    IN  PFT_COMPLETION_ROUTINE_CONTEXT  RegenContext,
    IN  PMIRROR_TP                      TransferPacket
    )

{
    PMIRROR     t = Mirror;

    delete TransferPacket;
    MirrorCompositeVolumeCompletionRoutine(RegenContext, STATUS_SUCCESS);
}

VOID
MirrorRegenerateCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    );

VOID
MirrorRegeneratePhase1(
    IN  PTRANSFER_PACKET    TransferPacket
    )

{
    TransferPacket->CompletionRoutine = MirrorRegenerateCompletionRoutine;
    TRANSFER(TransferPacket);
}

VOID
MirrorRegenerateCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for MIRROR::RestartRegenerations routine.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_TP                      transferPacket = (PMIRROR_TP) TransferPacket;
    PFT_COMPLETION_ROUTINE_CONTEXT  context = (PFT_COMPLETION_ROUTINE_CONTEXT) transferPacket->MasterPacket;
    PMIRROR                         t = transferPacket->Mirror;
    KIRQL                           irql;
    PLIST_ENTRY                     l;
    PMIRROR_TP                      packet;
    BOOLEAN                         b;

    if (!NT_SUCCESS(transferPacket->IoStatus.Status)) {

        // We can't get a VERIFY_REQUIRED because we put IrpFlags equal
        // to SL_OVERRIDE_VERIFY_VOLUME.

        ASSERT(transferPacket->IoStatus.Status != STATUS_VERIFY_REQUIRED);

        if (FsRtlIsTotalDeviceFailure(transferPacket->IoStatus.Status)) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            b = t->SetMemberState(transferPacket->WhichMember, FtMemberOrphaned);
            t->_syncOk = TRUE;
            KeReleaseSpinLock(&t->_spinLock, irql);

            if (b) {
                t->PropogateStateChanges(NULL, NULL);
                t->Notify();
                FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                            FT_ORPHANING, STATUS_SUCCESS, 3);
                IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
            }

            FinishRegenerate(t, context, transferPacket);
            return;
        }

        // Transfer the maximum amount that we can.  This will always
        // complete successfully.

        t->MaxTransfer(transferPacket);
        return;
    }

    // Set up for the next packet.

    transferPacket->Thread = PsGetCurrentThread();
    transferPacket->ReadPacket = !transferPacket->ReadPacket;
    transferPacket->WhichMember = (transferPacket->WhichMember + 1)%2;
    transferPacket->TargetVolume = t->GetMemberUnprotected(
                                   transferPacket->WhichMember);

    KeAcquireSpinLock(&t->_spinLock, &irql);
    if (t->QueryMemberState(transferPacket->WhichMember) == FtMemberOrphaned ||
        t->_stopSyncs) {

        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        FinishRegenerate(t, context, transferPacket);
        return;
    }
    KeReleaseSpinLock(&t->_spinLock, irql);

    if (transferPacket->ReadPacket) {

        t->_overlappedIoManager.ReleaseIoRegion(transferPacket);

        if (transferPacket->Offset + STRIPE_SIZE >= t->_volumeSize) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            b = t->SetMemberState((transferPacket->WhichMember + 1)%2,
                                  FtMemberHealthy);
            t->_balancedReads = TRUE;
            t->_syncOk = TRUE;
            t->_originalDirtyBit = FALSE;
            KeReleaseSpinLock(&t->_spinLock, irql);

            if (b) {
                t->PropogateStateChanges(NULL, NULL);
                t->Notify();
                FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                            FT_MIRROR_COPY_ENDED, STATUS_SUCCESS, 0);
            }

            FinishRegenerate(t, context, transferPacket);
            return;
        }

        transferPacket->Offset += STRIPE_SIZE;
        if (t->_volumeSize - transferPacket->Offset < STRIPE_SIZE) {
            transferPacket->Length = (ULONG) (t->_volumeSize -
                                              transferPacket->Offset);
        }

        transferPacket->CompletionRoutine = MirrorRegeneratePhase1;
        t->_overlappedIoManager.AcquireIoRegion(transferPacket, TRUE);

    } else {
        TRANSFER(transferPacket);
    }
}

NTSTATUS
MIRROR::RegenerateMember(
    IN      USHORT                  MemberNumber,
    IN OUT  PFT_VOLUME              NewMember,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This routine regenerates the given member of this volume with
    the given volume.

Arguments:

    MemberNumber        - Supplies the member number to regenerate.

    NewMember           - Supplies the new member to regenerate to.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    NTSTATUS

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    PMIRROR_TP                      packet;
    NTSTATUS                        status;
    KIRQL                           irql;
    BOOLEAN                         b;

    if (MemberNumber >= 2 ||
        NewMember->QueryVolumeSize() < _volumeSize) {

        return STATUS_INVALID_PARAMETER;
    }

    context = (PFT_COMPLETION_ROUTINE_CONTEXT)
              ExAllocatePool(NonPagedPool,
                             sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    packet = new MIRROR_TP;
    if (packet && !packet->AllocateMdl(STRIPE_SIZE)) {
        delete packet;
        packet = NULL;
    }
    if (!context || !packet) {
        if (context) {
            ExFreePool(context);
        }
        if (packet) {
            delete packet;
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeSpinLock(&context->SpinLock);
    context->Status = STATUS_SUCCESS;
    context->RefCount = 1;
    context->CompletionRoutine = CompletionRoutine;
    context->Context = Context;
    context->ParentVolume = this;

    packet->Length = STRIPE_SIZE;
    packet->Offset = 0;
    packet->CompletionRoutine = MirrorRegeneratePhase1;
    packet->Thread = PsGetCurrentThread();
    packet->IrpFlags = SL_OVERRIDE_VERIFY_VOLUME;
    packet->ReadPacket = TRUE;
    packet->MasterPacket = (PTRANSFER_PACKET) context;
    packet->Mirror = this;

    status = STATUS_SUCCESS;
    KeAcquireSpinLock(&_spinLock, &irql);
    if (_syncOk) {
        _syncOk = FALSE;
        _stopSyncs = FALSE;
    } else {
        KeReleaseSpinLock(&_spinLock, irql);
        delete packet;
        ExFreePool(context);
        return STATUS_INVALID_PARAMETER;
    }

    if (_state.UnhealthyMemberState != FtMemberHealthy) {
        if (MemberNumber == _state.UnhealthyMemberNumber) {
            if (_state.UnhealthyMemberState == FtMemberRegenerating) {
                status = STATUS_INVALID_PARAMETER;
            }
        } else {
            status = STATUS_INVALID_PARAMETER;
        }
    }

    if (!NT_SUCCESS(status)) {
        _syncOk = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);
        ExFreePool(context);
        delete packet;
        return status;
    }

    packet->WhichMember = (MemberNumber + 1)%2;
    packet->TargetVolume = GetMemberUnprotected(packet->WhichMember);

    SetMemberUnprotected(MemberNumber, NewMember);
    b = SetMemberState(MemberNumber, FtMemberRegenerating);
    KeReleaseSpinLock(&_spinLock, irql);

    ASSERT(b);

    PropogateStateChanges(NULL, NULL);
    Notify();
    FtpLogError(_rootExtension, QueryLogicalDiskId(),
                FT_MIRROR_COPY_STARTED, STATUS_SUCCESS, 2);

    _overlappedIoManager.AcquireIoRegion(packet, TRUE);

    return status;
}

VOID
MIRROR::Transfer(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Transfer routine for MIRROR type FT_VOLUME.  Balance READs as
    much as possible and propogate WRITEs to both the primary and
    secondary volumes.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    KIRQL       irql;
    PMIRROR_TP  packet1, packet2;

    if (TransferPacket->Offset + TransferPacket->Length > _volumeSize) {
        TransferPacket->IoStatus.Status = STATUS_INVALID_PARAMETER;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    if (!TransferPacket->Mdl) {
        TransferPacket->ReadPacket = FALSE;
    }

    packet1 = new MIRROR_TP;
    if (packet1 && !TransferPacket->ReadPacket) {
        packet2 = new MIRROR_TP;
        if (!packet2) {
            delete packet1;
            packet1 = NULL;
        }
    } else {
        packet2 = NULL;
    }

    if (!packet1) {
        if (!TransferPacket->Mdl) {
            TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }

        KeAcquireSpinLock(&_spinLock, &irql);
        if (_ePacketInUse) {
            InsertTailList(&_ePacketQueue, &TransferPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _ePacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        packet1 = _ePacket;
        packet2 = _ePacket2;
    }

    if (TransferPacket->ReadPacket) {
        if (!LaunchRead(TransferPacket, packet1)) {
            Recycle(packet1, TRUE);
        }
    } else {
        if (!LaunchWrite(TransferPacket, packet1, packet2)) {
            Recycle(packet1, FALSE);
            Recycle(packet2, TRUE);
        }
    }
}

VOID
MIRROR::ReplaceBadSector(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is a no-op since replacing bad sectors doesn't make sense
    on an FT component with redundancy built in to it.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    TransferPacket->IoStatus.Status = STATUS_UNSUCCESSFUL;
    TransferPacket->IoStatus.Information = 0;
    TransferPacket->CompletionRoutine(TransferPacket);
}

VOID
MIRROR::StartSyncOperations(
    IN      BOOLEAN                 RegenerateOrphans,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This routine restarts any regenerate or initialize requests that were
    suspended because of a reboot.  The volume examines the member state of
    all of its constituents and restarts any regenerations pending.

Arguments:

    RegenerateOrphans   - Supplies whether or not to try and regenerate
                            orphaned members.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the context for the completion routine.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    BOOLEAN                         dirty, b;
    KIRQL                           irql;
    USHORT                          srcIndex;
    PMIRROR_TP                      packet;

    context = (PFT_COMPLETION_ROUTINE_CONTEXT)
              ExAllocatePool(NonPagedPool,
                             sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    if (!context) {
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    KeInitializeSpinLock(&context->SpinLock);
    context->Status = STATUS_SUCCESS;
    context->RefCount = 2;
    context->CompletionRoutine = CompletionRoutine;
    context->Context = Context;
    context->ParentVolume = this;

    COMPOSITE_FT_VOLUME::StartSyncOperations(
            RegenerateOrphans, MirrorCompositeVolumeCompletionRoutine, context);

    if (_orphanedBecauseOfMissingMember) {
        RegenerateOrphans = TRUE;
        _orphanedBecauseOfMissingMember = FALSE;
    }

    dirty = FALSE;
    b = FALSE;
    KeAcquireSpinLock(&_spinLock, &irql);
    if (_syncOk) {
        _syncOk = FALSE;
        _stopSyncs = FALSE;
    } else {
        KeReleaseSpinLock(&_spinLock, irql);
        MirrorCompositeVolumeCompletionRoutine(context, STATUS_SUCCESS);
        return;
    }
    if (_state.UnhealthyMemberState == FtMemberOrphaned &&
        RegenerateOrphans &&
        GetMemberUnprotected(_state.UnhealthyMemberNumber)) {

        _state.UnhealthyMemberState = FtMemberRegenerating;
        b = TRUE;
    }
    if (_state.UnhealthyMemberState == FtMemberHealthy) {
        if (_originalDirtyBit) {
            srcIndex = 0;
            dirty = TRUE;
        } else {
            _syncOk = TRUE;
            KeReleaseSpinLock(&_spinLock, irql);
            MirrorCompositeVolumeCompletionRoutine(context, STATUS_SUCCESS);
            return;
        }
    } else if (_state.UnhealthyMemberState == FtMemberRegenerating) {
        srcIndex = (_state.UnhealthyMemberNumber + 1)%2;
        b = TRUE;
    } else {
        _syncOk = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);
        MirrorCompositeVolumeCompletionRoutine(context, STATUS_SUCCESS);
        return;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (dirty) {
        FtpLogError(_rootExtension, QueryLogicalDiskId(),
                    FT_DIRTY_SHUTDOWN, STATUS_SUCCESS, 0);
    }

    if (b) {
        PropogateStateChanges(NULL, NULL);
        Notify();
        FtpLogError(_rootExtension, QueryLogicalDiskId(),
                    FT_MIRROR_COPY_STARTED, STATUS_SUCCESS, 3);
    }

    packet = new MIRROR_TP;
    if (packet && !packet->AllocateMdl(STRIPE_SIZE)) {
        delete packet;
        packet = NULL;
    }
    if (!packet) {
        MirrorCompositeVolumeCompletionRoutine(context,
                                               STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    packet->Length = STRIPE_SIZE;
    packet->Offset = 0;
    packet->CompletionRoutine = MirrorRegeneratePhase1;
    packet->Thread = PsGetCurrentThread();
    packet->IrpFlags = SL_OVERRIDE_VERIFY_VOLUME;
    packet->ReadPacket = TRUE;
    packet->MasterPacket = (PMIRROR_TP) context;
    packet->Mirror = this;
    packet->WhichMember = srcIndex;
    packet->TargetVolume = GetMemberUnprotected(packet->WhichMember);

    _overlappedIoManager.AcquireIoRegion(packet, TRUE);
}

VOID
MIRROR::StopSyncOperations(
    )

/*++

Routine Description:

    This routine stops all sync operations.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KIRQL   irql;

    COMPOSITE_FT_VOLUME::StopSyncOperations();

    KeAcquireSpinLock(&_spinLock, &irql);
    _stopSyncs = TRUE;
    KeReleaseSpinLock(&_spinLock, irql);
}

LONGLONG
MIRROR::QueryVolumeSize(
    )

/*++

Routine Description:

    Returns the number of bytes on the entire volume.

Arguments:

    None.

Return Value:

    The volume size in bytes.

--*/

{
    return _volumeSize;
}

VOID
MIRROR::SetDirtyBit(
    IN  BOOLEAN                 IsDirty,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine sets the dirty bit on the volume.  This bit is used at
    startup to determine whether or not there was a clean shutdown.

Arguments:

    IsDirty - Supplies the value of the dirty bit.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    KIRQL                           irql;

    if (CompletionRoutine) {

        context = (PFT_COMPLETION_ROUTINE_CONTEXT)
                  ExAllocatePool(NonPagedPool,
                                 sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
        if (!context) {
            CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
            return;
        }

        KeInitializeSpinLock(&context->SpinLock);
        context->Status = STATUS_SUCCESS;
        context->RefCount = 2;
        context->CompletionRoutine = CompletionRoutine;
        context->Context = Context;
        context->ParentVolume = this;

        COMPOSITE_FT_VOLUME::SetDirtyBit(IsDirty,
                MirrorCompositeVolumeCompletionRoutine, context);

    } else {
        COMPOSITE_FT_VOLUME::SetDirtyBit(IsDirty, NULL, NULL);
    }

    KeAcquireSpinLock(&_spinLock, &irql);
    if (IsDirty || _syncOk) {
        if (!_stopSyncs) {
            _state.IsDirty = IsDirty;
        }
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (CompletionRoutine) {
        PropogateStateChanges(MirrorCompositeVolumeCompletionRoutine, context);
    } else {
        PropogateStateChanges(NULL, NULL);
    }
}

BOOLEAN
MIRROR::IsComplete(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine computes whether or not this volume has either all
    (if IoPending is FALSE) of its members or enough (if IoPending is TRUE) of
    its members.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    BOOLEAN     b;
    USHORT      n, i, orphanMember;
    PFT_VOLUME  vol;

    b = COMPOSITE_FT_VOLUME::IsComplete(IoPending);
    if (b) {
        return TRUE;
    }

    if (!IoPending) {
        return FALSE;
    }

    n = QueryNumMembers();
    orphanMember = n;
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol || !vol->IsComplete(IoPending)) {
            if (orphanMember < n) {
                return FALSE;
            }
            orphanMember = i;
        }
    }

    if (orphanMember < n) {
        if (_state.UnhealthyMemberState != FtMemberHealthy &&
            _state.UnhealthyMemberNumber != orphanMember) {

            return FALSE;
        }
    }

    return TRUE;
}

VOID
MIRROR::CompleteNotification(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine is called to notify the volume that it is complete and
    to therefore prepare for incoming requests.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    USHORT      n, i, orphanMember;
    PFT_VOLUME  vol;

    COMPOSITE_FT_VOLUME::CompleteNotification(IoPending);

    n = QueryNumMembers();
    orphanMember = n;
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol || !vol->IsComplete(IoPending)) {
            orphanMember = i;
            break;
        }
    }

    if (orphanMember < n) {
        if (SetMemberState(orphanMember, FtMemberOrphaned)) {
            PropogateStateChanges(NULL, NULL);
            Notify();
            FtpLogError(_rootExtension, QueryLogicalDiskId(),
                        FT_ORPHANING, STATUS_SUCCESS, 1);
            IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
            _orphanedBecauseOfMissingMember = TRUE;
       }
    }
}

NTSTATUS
MIRROR::CheckIo(
    OUT PBOOLEAN    IsIoOk
    )

/*++

Routine Description:

    This routine returns whether or not IO is possible on the given
    logical disk.

Arguments:

    IsIoOk  - Returns the state of IO.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS    status;
    KIRQL       irql;
    USHORT      n, numOk, skipVol, i;
    PFT_VOLUME  vol;
    BOOLEAN     ok, b;

    n = QueryNumMembers();
    numOk = 0;
    KeAcquireSpinLock(&_spinLock, &irql);
    if (_state.UnhealthyMemberState == FtMemberHealthy) {
        skipVol = n;
    } else {
        skipVol = _state.UnhealthyMemberNumber;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    for (i = 0; i < n; i++) {
        if (i == skipVol) {
            continue;
        }
        vol = GetMemberUnprotected(i);
        if (!vol) {
            continue;
        }

        status = vol->CheckIo(&ok);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (ok) {
            numOk++;
        }
    }

    if (numOk >= n - 1) {
        *IsIoOk = TRUE;
    } else {
        *IsIoOk = FALSE;
    }

    return STATUS_SUCCESS;
}

BOOLEAN
MIRROR::IsVolumeSuitableForRegenerate(
    IN  USHORT      MemberNumber,
    IN  PFT_VOLUME  Volume
    )

/*++

Routine Description:

    This routine computes whether or not the given volume is suitable
    for a regenerate operation.

Arguments:

    MemberNumber    - Supplies the member number.

    Volume          - Supplies the volume.

Return Value:

    FALSE   - The volume is not suitable.

    TRUE    - The volume is suitable.

--*/

{
    KIRQL   irql;

    if (Volume->QueryVolumeSize() < _volumeSize) {
        return FALSE;
    }

    KeAcquireSpinLock(&_spinLock, &irql);
    if (!_syncOk ||
        _state.UnhealthyMemberState != FtMemberOrphaned ||
        _state.UnhealthyMemberNumber != MemberNumber) {

        KeReleaseSpinLock(&_spinLock, irql);
        return FALSE;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    return TRUE;
}

VOID
MIRROR::NewStateArrival(
    IN  PVOID   NewStateInstance
    )

/*++

Routine Description:

    This routine takes the new state instance arrival combined with its
    current state to come up with the new current state for the volume.
    If the two states cannot be reconciled then this routine returns FALSE
    indicating that the volume is invalid and should be broken into its
    constituant parts.

Arguments:

    NewStateInstance    - Supplies the new state instance.

Return Value:

    None.

--*/

{
    BOOLEAN                                 changed = FALSE;
    PFT_MIRROR_AND_SWP_STATE_INFORMATION    state;

    state = (PFT_MIRROR_AND_SWP_STATE_INFORMATION) NewStateInstance;
    if (state->IsDirty) {
        if (!_state.IsDirty) {
            _originalDirtyBit = _state.IsDirty = state->IsDirty;
            _balancedReads = FALSE;
            changed = TRUE;
        }
    }

    if (state->UnhealthyMemberState != FtMemberHealthy) {
        if (state->UnhealthyMemberNumber >= QueryNumMembers()) {

            _state.UnhealthyMemberNumber = 1;
            _state.UnhealthyMemberState = FtMemberOrphaned;
            changed = TRUE;

            FtpLogError(_rootExtension, QueryLogicalDiskId(),
                        FT_MIRROR_STATE_CORRUPTION,
                        STATUS_SUCCESS, 0);

        } else if (_state.UnhealthyMemberState == FtMemberHealthy) {
            _state.UnhealthyMemberState = state->UnhealthyMemberState;
            _state.UnhealthyMemberNumber = state->UnhealthyMemberNumber;
            changed = TRUE;
        } else {
            if (_state.UnhealthyMemberNumber == state->UnhealthyMemberNumber) {
                if (state->UnhealthyMemberState == FtMemberOrphaned) {
                    if (_state.UnhealthyMemberState != FtMemberOrphaned) {
                        _state.UnhealthyMemberState = FtMemberOrphaned;
                        changed = TRUE;
                    }
                }
            } else {
                _state.UnhealthyMemberNumber = 1;
                _state.UnhealthyMemberState = FtMemberOrphaned;
                changed = TRUE;

                FtpLogError(_rootExtension, QueryLogicalDiskId(),
                            FT_MIRROR_STATE_CORRUPTION,
                            STATUS_SUCCESS, 0);
            }
        }
    }

    if (changed) {
        PropogateStateChanges(NULL, NULL);
    }
}

PDEVICE_OBJECT
MIRROR::GetLeftmostPartitionObject(
    )

{
    KIRQL       irql;
    USHORT      memberNumber;
    PFT_VOLUME  vol;

    KeAcquireSpinLock(&_spinLock, &irql);
    if (_state.UnhealthyMemberState != FtMemberHealthy &&
        _state.UnhealthyMemberNumber == 0) {

        memberNumber = 1;
    } else {
        memberNumber = 0;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    vol = GetMember(memberNumber);
    if (!vol) {
        return NULL;
    }

    return vol->GetLeftmostPartitionObject();
}

BOOLEAN
MIRROR::QueryVolumeState(
    IN  PFT_VOLUME          Volume,
    OUT PFT_MEMBER_STATE    State
    )

/*++

Routine Description:

    This routine returns the state of the given volume considered as a
    member of this volume.

Arguments:

    Volume  - Supplies the volume to query the state for.

    State   - Returns the state.

Return Value:

    FALSE   - The given Volume is not a member of this volume.

    TRUE    - The state was successfully computed.

--*/

{
    USHORT          n, i;
    PFT_VOLUME      vol;
    KIRQL           irql;
    FT_MEMBER_STATE state;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }

        if (!vol->QueryVolumeState(Volume, State)) {
            continue;
        }

        KeAcquireSpinLock(&_spinLock, &irql);
        state = QueryMemberState(i);
        if (state != FtMemberHealthy) {
            if (*State != FtMemberOrphaned) {
                *State = state;
            }
        }
        KeReleaseSpinLock(&_spinLock, irql);

        return TRUE;
    }

    return FALSE;
}

BOOLEAN
MIRROR::SetMemberState(
    IN  USHORT          MemberNumber,
    IN  FT_MEMBER_STATE MemberState
    )

/*++

Routine Description:

    This routine sets the given member to the given state.

Arguments:

    MemberNumber    - Supplies the member number.

    MemberState     - Supplies the member state.

Return Value:

    FALSE   - There was no state change.

    TRUE    - A state change took place.

Notes:

    The caller must be holding the class spin lock.

--*/

{
    if (_state.UnhealthyMemberState == FtMemberHealthy) {
        if (MemberNumber >= QueryNumMembers()) {
            KeBugCheckEx(FTDISK_INTERNAL_ERROR, (ULONG_PTR) this,
                         MemberNumber, MemberState, 0);
        }
        _state.UnhealthyMemberNumber = MemberNumber;
        _state.UnhealthyMemberState = MemberState;
        return TRUE;
    }

    if (_state.UnhealthyMemberNumber == MemberNumber &&
        _state.UnhealthyMemberState != MemberState) {

        _state.UnhealthyMemberState = MemberState;
        return TRUE;
    }

    return FALSE;
}

VOID
MirrorTransferCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for MIRROR::Transfer function.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_TP          transferPacket = (PMIRROR_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    PMIRROR             t = transferPacket->Mirror;
    KIRQL               irql;
    LONG                count;
    BOOLEAN             b;
    PMIRROR_TP          otherPacket;


    // Check for the read completion case.

    if (transferPacket->ReadPacket) {

        KeAcquireSpinLock(&t->_spinLock, &irql);
        t->_requestCount[transferPacket->WhichMember]--;
        KeReleaseSpinLock(&t->_spinLock, irql);

        if (!NT_SUCCESS(status) && status != STATUS_VERIFY_REQUIRED) {

            if (FsRtlIsTotalDeviceFailure(status)) {

                // Device failure case.

                KeAcquireSpinLock(&t->_spinLock, &irql);
                b = t->SetMemberState(transferPacket->WhichMember,
                                      FtMemberOrphaned);
                KeReleaseSpinLock(&t->_spinLock, irql);

                if (b) {
                    t->PropogateStateChanges(NULL, NULL);
                    t->Notify();
                    FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                                FT_ORPHANING, STATUS_SUCCESS, 4);
                    IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL,
                                                  NULL);
                }

                if (!transferPacket->OneReadFailed) {

                    transferPacket->OneReadFailed = TRUE;
                    transferPacket->WhichMember =
                            (transferPacket->WhichMember + 1) % 2;
                    transferPacket->TargetVolume = t->GetMemberUnprotected(
                                                   transferPacket->WhichMember);

                    if (t->_state.UnhealthyMemberNumber !=
                        transferPacket->WhichMember) {

                        TRANSFER(transferPacket);
                        return;
                    }
                }

            } else {

                // Bad sector case.

                if (!transferPacket->OneReadFailed) {
                    transferPacket->OneReadFailed = TRUE;
                    t->Recover(transferPacket);
                    return;
                }
            }
        }

        masterPacket->IoStatus = transferPacket->IoStatus;
        masterPacket->CompletionRoutine(masterPacket);

        t->Recycle(transferPacket, TRUE);
        return;
    }


    // This a write or a verify in which two requests may have been sent.

    KeAcquireSpinLock(&masterPacket->SpinLock, &irql);

    if (NT_SUCCESS(status)) {

        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
             masterPacket->IoStatus.Information =
                    transferPacket->IoStatus.Information;
        }

    } else {

        if (status == STATUS_VERIFY_REQUIRED) {
            masterPacket->IoStatus.Information = 0;
            if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
                masterPacket->IoStatus.Status = status;
            }

        } else if (FsRtlIsTotalDeviceFailure(status)) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            b = t->SetMemberState(transferPacket->WhichMember,
                                  FtMemberOrphaned);
            KeReleaseSpinLock(&t->_spinLock, irql);

            if (b) {
                t->PropogateStateChanges(NULL, NULL);
                t->Notify();
                FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                            FT_ORPHANING, STATUS_SUCCESS, 5);
                IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
            } else {
                masterPacket->IoStatus.Information = 0;
                if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
                    masterPacket->IoStatus.Status = status;
                }
            }

        } else if (!transferPacket->OneReadFailed && transferPacket->Mdl) {

            KeReleaseSpinLock(&masterPacket->SpinLock, irql);

            transferPacket->OneReadFailed = TRUE;
            t->CarefulWrite(transferPacket);
            return;

        } else {
            masterPacket->IoStatus.Information = 0;
            if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
                masterPacket->IoStatus.Status = status;
            }
        }
    }

    count = --masterPacket->RefCount;
    b = (masterPacket->IrpFlags&SL_FT_SEQUENTIAL_WRITE) ? TRUE : FALSE;

    KeReleaseSpinLock(&masterPacket->SpinLock, irql);

    if (count) {
        if (b) {
            otherPacket = transferPacket->SecondWritePacket;
            otherPacket->CompletionRoutine = MirrorTransferCompletionRoutine;
            TRANSFER(otherPacket);
        }
    } else {
        masterPacket->CompletionRoutine(masterPacket);
        if (transferPacket->SecondWritePacket) {
            t->Recycle(transferPacket->SecondWritePacket, FALSE);
        }
        t->Recycle(transferPacket, TRUE);
    }
}

BOOLEAN
MIRROR::LaunchRead(
    IN OUT  PTRANSFER_PACKET    TransferPacket,
    IN OUT  PMIRROR_TP          Packet1
    )

/*++

Routine Description:

    This routine lauches the given read transfer packet in parallel accross
    all members using the given mirror transfer packet.

Arguments:

    TransferPacket  - Supplies the transfer packet to launch.

    Packet1         - Supplies a worker transfer packet.

Return Value:

    FALSE   - The read request was not launched.

    TRUE    - The read request was launched.

--*/

{
    PMIRROR_TP          packet;
    KIRQL               irql;
    LONG                diff;
    LONGLONG            seek0, seek1;

    packet = Packet1;

    packet->Mdl = TransferPacket->Mdl;
    packet->OriginalIrp = TransferPacket->OriginalIrp;
    packet->Length = TransferPacket->Length;
    packet->Offset = TransferPacket->Offset;
    packet->CompletionRoutine = MirrorTransferCompletionRoutine;
    packet->Thread = TransferPacket->Thread;
    packet->IrpFlags = TransferPacket->IrpFlags;
    packet->ReadPacket = TransferPacket->ReadPacket;
    packet->MasterPacket = TransferPacket;
    packet->Mirror = this;

    // Determine which member to dispatch this read request to.
    // Balance the load if both members are healthy.

    KeAcquireSpinLock(&_spinLock, &irql);
    if (TransferPacket->SpecialRead) {

        if (TransferPacket->SpecialRead == TP_SPECIAL_READ_PRIMARY) {
            packet->WhichMember = 0;
        } else {
            packet->WhichMember = 1;
        }

        if (QueryMemberState(packet->WhichMember) != FtMemberHealthy) {
            packet->WhichMember = 2;
        }

    } else if (_state.UnhealthyMemberState == FtMemberHealthy) {

        if (!_balancedReads) {
            packet->WhichMember = 0;
        } else {
            diff = _requestCount[1] - _requestCount[0];
            if (diff < -4) {
                packet->WhichMember = 1;
            } else if (diff > 4) {
                packet->WhichMember = 0;
            } else {
                seek0 = _lastPosition[0] - packet->Offset;
                seek1 = _lastPosition[1] - packet->Offset;
                if (seek0 < 0) {
                    seek0 = -seek0;
                }
                if (seek1 < 0) {
                    seek1 = -seek1;
                }
                if (seek1 < seek0) {
                    packet->WhichMember = 1;
                } else {
                    packet->WhichMember = 0;
                }
            }
        }

    } else {
        packet->WhichMember = (_state.UnhealthyMemberNumber + 1)%2;
    }
    if (packet->WhichMember < 2) {
        _requestCount[packet->WhichMember]++;
        _lastPosition[packet->WhichMember] = packet->Offset + packet->Length;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (packet->WhichMember >= 2) {
        TransferPacket->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return FALSE;
    }

    packet->TargetVolume = GetMemberUnprotected(packet->WhichMember);
    TRANSFER(packet);

    return TRUE;
}

VOID
MirrorWritePhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine sends down the given transfer packets for a write to
    the volumes.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PTRANSFER_PACKET    p;

    p = ((PMIRROR_TP) TransferPacket)->SecondWritePacket;
    if (p) {
        p->CompletionRoutine = MirrorTransferCompletionRoutine;
        if (TransferPacket->IrpFlags&SL_FT_SEQUENTIAL_WRITE) {
            TRANSFER(p);
            return;
        }
        TRANSFER(p);
    }

    TransferPacket->CompletionRoutine = MirrorTransferCompletionRoutine;
    TRANSFER(TransferPacket);
}

BOOLEAN
MIRROR::LaunchWrite(
    IN OUT  PTRANSFER_PACKET    TransferPacket,
    IN OUT  PMIRROR_TP          Packet1,
    IN OUT  PMIRROR_TP          Packet2
    )

/*++

Routine Description:

    This routine lauches the given write transfer packet in parallel accross
    all members using the given mirror transfer packets.

Arguments:

    TransferPacket  - Supplies the transfer packet to launch.

    Packet1         - Supplies a worker transfer packet.

    Packet2         - Supplies a worker transfer packet.

Return Value:

    FALSE   - The read request was not launched.

    TRUE    - The read request was launched.

--*/

{
    PMIRROR_TP          packet;
    KIRQL               irql;
    PFT_VOLUME          pri, sec;
    FT_PARTITION_STATE  priState, secState;
    LONGLONG            rowStart;
    ULONG               numRows, length, remainder;
    USHORT              source;
    LONG                count;
    BOOLEAN             b;

    KeInitializeSpinLock(&TransferPacket->SpinLock);
    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = 0;
    TransferPacket->RefCount = 2;

    // Send down the first request to the primary or to the source
    // if we're doing a regenerate.

    KeAcquireSpinLock(&_spinLock, &irql);
    if (_state.UnhealthyMemberState == FtMemberHealthy) {
        source = 0;
    } else if (_state.UnhealthyMemberState == FtMemberRegenerating) {
        source = (_state.UnhealthyMemberNumber + 1)%2;
    } else {
        TransferPacket->RefCount = 1;
        source = (_state.UnhealthyMemberNumber + 1)%2;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    packet = Packet1;

    packet->Mdl = TransferPacket->Mdl;
    packet->Length = TransferPacket->Length;
    packet->Offset = TransferPacket->Offset;
    packet->CompletionRoutine = MirrorWritePhase1;
    packet->Thread = TransferPacket->Thread;
    packet->IrpFlags = TransferPacket->IrpFlags;
    packet->ReadPacket = TransferPacket->ReadPacket;
    packet->MasterPacket = TransferPacket;
    packet->Mirror = this;
    packet->WhichMember = source;
    packet->SecondWritePacket = NULL;
    packet->TargetVolume = GetMemberUnprotected(packet->WhichMember);

    if (TransferPacket->RefCount == 1) {
        _overlappedIoManager.AcquireIoRegion(packet, TRUE);
        if (Packet2 != _ePacket && Packet2 != _ePacket2) {
            delete Packet2;
        }
        return TRUE;
    }

    packet->SecondWritePacket = Packet2;

    packet = Packet2;

    packet->Mdl = TransferPacket->Mdl;
    packet->Length = TransferPacket->Length;
    packet->Offset = TransferPacket->Offset;
    packet->CompletionRoutine = MirrorWritePhase1;
    packet->Thread = TransferPacket->Thread;
    packet->IrpFlags = TransferPacket->IrpFlags;
    packet->ReadPacket = TransferPacket->ReadPacket;
    packet->MasterPacket = TransferPacket;
    packet->Mirror = this;
    packet->WhichMember = (source + 1)%2;
    packet->SecondWritePacket = Packet1;
    packet->TargetVolume = GetMemberUnprotected(packet->WhichMember);

    _overlappedIoManager.AcquireIoRegion(packet, TRUE);

    return TRUE;
}

VOID
MIRROR::Recycle(
    IN OUT  PMIRROR_TP  TransferPacket,
    IN      BOOLEAN     ServiceEmergencyQueue
    )

/*++

Routine Description:

    This routine recycles the given transfer packet and services
    the emergency queue if need be.

Arguments:

    TransferPacket          - Supplies the transfer packet.

    ServiceEmergencyQueue   - Supplies whether or not to service the
                                emergency queue.

Return Value:

    None.

--*/

{
    KIRQL               irql;
    PLIST_ENTRY         l;
    PTRANSFER_PACKET    p;
    PMIRROR_TP          packet1, packet2;

    if (TransferPacket != _ePacket &&
        TransferPacket != _ePacket2 &&
        TransferPacket != _eRecoverPacket) {

        delete TransferPacket;
        return;
    }

    TransferPacket->OriginalIrp = NULL;
    TransferPacket->SpecialRead = 0;
    TransferPacket->OneReadFailed = FALSE;
    _overlappedIoManager.ReleaseIoRegion(TransferPacket);

    if (TransferPacket == _eRecoverPacket) {
        MmPrepareMdlForReuse(_eRecoverPacket->PartialMdl);
        KeAcquireSpinLock(&_spinLock, &irql);
        if (IsListEmpty(&_eRecoverPacketQueue)) {
            _eRecoverPacketInUse = FALSE;
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        l = RemoveHeadList(&_eRecoverPacketQueue);
        KeReleaseSpinLock(&_spinLock, irql);
        p = CONTAINING_RECORD(l, TRANSFER_PACKET, QueueEntry);
        p->CompletionRoutine(p);
        return;
    }

    if (!ServiceEmergencyQueue) {
        return;
    }

    for (;;) {

        KeAcquireSpinLock(&_spinLock, &irql);
        if (IsListEmpty(&_ePacketQueue)) {
            _ePacketInUse = FALSE;
            KeReleaseSpinLock(&_spinLock, irql);
            break;
        }
        l = RemoveHeadList(&_ePacketQueue);
        KeReleaseSpinLock(&_spinLock, irql);

        p = CONTAINING_RECORD(l, TRANSFER_PACKET, QueueEntry);

        packet1 = new MIRROR_TP;
        if (packet1 && !TransferPacket->ReadPacket) {
            packet2 = new MIRROR_TP;
            if (!packet2) {
                delete packet1;
                packet1 = NULL;
            }
        } else {
            packet2 = NULL;
        }

        if (!packet1) {
            packet1 = _ePacket;
            packet2 = _ePacket2;
        }

        if (TransferPacket->ReadPacket) {
            if (!LaunchRead(TransferPacket, packet1)) {
                if (packet1 != _ePacket) {
                    delete packet1;
                    packet1 = NULL;
                }
            }
        } else {
            if (!LaunchWrite(TransferPacket, packet1, packet2)) {
                if (packet1 != _ePacket) {
                    delete packet1;
                    delete packet2;
                    packet1 = NULL;
                }
            }
        }

        if (packet1 == _ePacket) {
            break;
        }
    }
}

VOID
MirrorRecoverPhase8(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector read
    of the main member after a write was done to check for
    data integrity.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket = (PMIRROR_RECOVER_TP) TransferPacket;
    PMIRROR_TP          masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR             t = masterPacket->Mirror;
    NTSTATUS            status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status) ||
        RtlCompareMemory(MmGetSystemAddressForMdl(subPacket->PartialMdl),
                         MmGetSystemAddressForMdl(subPacket->VerifyMdl),
                         subPacket->Length) != subPacket->Length) {

        masterPacket->IoStatus.Status = STATUS_FT_READ_RECOVERY_FROM_BACKUP;

        FtpLogError(t->_rootExtension,
                    subPacket->TargetVolume->QueryLogicalDiskId(),
                    FT_SECTOR_FAILURE, status,
                    (ULONG) (subPacket->Offset/t->QuerySectorSize()));
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    subPacket->Offset += subPacket->Length;
    subPacket->CompletionRoutine = MirrorRecoverPhase2;
    subPacket->ReadPacket = TRUE;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
MirrorRecoverPhase7(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector write
    of the main member after a replace sector was done.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket = (PMIRROR_RECOVER_TP) TransferPacket;
    PMIRROR_TP          masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR             t = masterPacket->Mirror;
    NTSTATUS            status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status)) {

        masterPacket->IoStatus.Status = STATUS_FT_READ_RECOVERY_FROM_BACKUP;

        FtpLogError(t->_rootExtension,
                    subPacket->TargetVolume->QueryLogicalDiskId(),
                    FT_SECTOR_FAILURE, status,
                    (ULONG) (subPacket->Offset/t->QuerySectorSize()));

        if (subPacket->Offset + subPacket->Length ==
            masterPacket->Offset + masterPacket->Length) {

            t->Recycle(subPacket, TRUE);
            masterPacket->CompletionRoutine(masterPacket);
            return;
        }

        subPacket->Mdl = subPacket->PartialMdl;
        subPacket->Offset += subPacket->Length;
        subPacket->CompletionRoutine = MirrorRecoverPhase2;
        subPacket->ReadPacket = TRUE;
        MmPrepareMdlForReuse(subPacket->Mdl);
        IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                          (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                          (ULONG) (subPacket->Offset - masterPacket->Offset),
                          subPacket->Length);

        TRANSFER(subPacket);
        return;
    }

    subPacket->Mdl = subPacket->VerifyMdl;
    subPacket->CompletionRoutine = MirrorRecoverPhase8;
    subPacket->ReadPacket = TRUE;

    TRANSFER(subPacket);
}

VOID
MirrorRecoverPhase6(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector replace
    of the main member.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket = (PMIRROR_RECOVER_TP) TransferPacket;
    PMIRROR_TP          masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR             t = masterPacket->Mirror;
    NTSTATUS            status = subPacket->IoStatus.Status;

    if (!NT_SUCCESS(status)) {

        masterPacket->IoStatus.Status = STATUS_FT_READ_RECOVERY_FROM_BACKUP;

        FtpLogError(t->_rootExtension,
                    subPacket->TargetVolume->QueryLogicalDiskId(),
                    FT_SECTOR_FAILURE, status,
                    (ULONG) (subPacket->Offset/t->QuerySectorSize()));

        if (subPacket->Offset + subPacket->Length ==
            masterPacket->Offset + masterPacket->Length) {

            t->Recycle(subPacket, TRUE);
            masterPacket->CompletionRoutine(masterPacket);
            return;
        }

        subPacket->Mdl = subPacket->PartialMdl;
        subPacket->Offset += subPacket->Length;
        subPacket->CompletionRoutine = MirrorRecoverPhase2;
        subPacket->ReadPacket = TRUE;
        MmPrepareMdlForReuse(subPacket->Mdl);
        IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                          (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                          (ULONG) (subPacket->Offset - masterPacket->Offset),
                          subPacket->Length);

        TRANSFER(subPacket);
        return;
    }

    // We were able to relocate the bad sector so now do a write and
    // then read to make sure it's ok.

    subPacket->Mdl = subPacket->PartialMdl;
    subPacket->CompletionRoutine = MirrorRecoverPhase7;
    subPacket->ReadPacket = FALSE;

    TRANSFER(subPacket);
}

VOID
MirrorRecoverPhase5(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector read
    of the main member after a successful write to check and
    see if the write was successful.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket = (PMIRROR_RECOVER_TP) TransferPacket;
    PMIRROR_TP          masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR             t = masterPacket->Mirror;
    NTSTATUS            status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status) ||
        RtlCompareMemory(MmGetSystemAddressForMdl(subPacket->PartialMdl),
                         MmGetSystemAddressForMdl(subPacket->VerifyMdl),
                         subPacket->Length) != subPacket->Length) {

        subPacket->Mdl = subPacket->PartialMdl;
        subPacket->CompletionRoutine = MirrorRecoverPhase6;
        subPacket->TargetVolume->ReplaceBadSector(subPacket);
        return;
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    subPacket->Offset += subPacket->Length;
    subPacket->CompletionRoutine = MirrorRecoverPhase2;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
MirrorRecoverPhase4(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector write
    of the main member.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket = (PMIRROR_RECOVER_TP) TransferPacket;
    PMIRROR_TP          masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR             t = masterPacket->Mirror;
    NTSTATUS            status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status)) {
        subPacket->CompletionRoutine = MirrorRecoverPhase6;
        subPacket->TargetVolume->ReplaceBadSector(subPacket);
        return;
    }

    // Write was successful so try a read and then compare.

    subPacket->Mdl = subPacket->VerifyMdl;
    subPacket->CompletionRoutine = MirrorRecoverPhase5;
    subPacket->ReadPacket = TRUE;

    TRANSFER(subPacket);
}

VOID
MirrorRecoverPhase3(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector read
    of the other member.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket = (PMIRROR_RECOVER_TP) TransferPacket;
    PMIRROR_TP          masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR             t = masterPacket->Mirror;
    NTSTATUS            status = subPacket->IoStatus.Status;
    KIRQL               irql;
    BOOLEAN             b;

    if (!NT_SUCCESS(status)) {

        if (FsRtlIsTotalDeviceFailure(status) &&
            status != STATUS_VERIFY_REQUIRED) {

            masterPacket->IoStatus.Status = STATUS_DEVICE_DATA_ERROR;
            masterPacket->IoStatus.Information = 0;

            KeAcquireSpinLock(&t->_spinLock, &irql);
            b = t->SetMemberState(subPacket->WhichMember, FtMemberOrphaned);
            KeReleaseSpinLock(&t->_spinLock, irql);

            if (b) {
                t->PropogateStateChanges(NULL, NULL);
                t->Notify();
                FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                            FT_ORPHANING, STATUS_SUCCESS, 6);
                IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
            }

        } else {
            masterPacket->IoStatus = subPacket->IoStatus;
            if (status != STATUS_VERIFY_REQUIRED) {
                FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                            FT_DOUBLE_FAILURE, status,
                            (ULONG) (subPacket->Offset/t->QuerySectorSize()));
            }
        }

        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    // We have the data required in the subpacket partial mdl.
    // Try writting it back to where the read failed and see
    // if the sector just fixes itself.

    subPacket->WhichMember = (subPacket->WhichMember + 1)%2;
    subPacket->CompletionRoutine = MirrorRecoverPhase4;
    subPacket->TargetVolume = t->GetMemberUnprotected(subPacket->WhichMember);
    subPacket->ReadPacket = FALSE;

    TRANSFER(subPacket);
}

VOID
MirrorRecoverPhase2(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector transfer
    that is part of a larger recover operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket = (PMIRROR_RECOVER_TP) TransferPacket;
    PMIRROR_TP          masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR             t = masterPacket->Mirror;
    NTSTATUS            status = subPacket->IoStatus.Status;
    KIRQL               irql;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (NT_SUCCESS(status)) {
        if (subPacket->Offset + subPacket->Length ==
            masterPacket->Offset + masterPacket->Length) {

            t->Recycle(subPacket, TRUE);
            masterPacket->CompletionRoutine(masterPacket);
            return;
        }

        subPacket->Offset += subPacket->Length;
        MmPrepareMdlForReuse(subPacket->Mdl);
        IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                          (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                          (ULONG) (subPacket->Offset - masterPacket->Offset),
                          subPacket->Length);

        TRANSFER(subPacket);
        return;
    }

    // This read sector failed from a bad sector error.  Try
    // reading the data from the other member.

    subPacket->WhichMember = (subPacket->WhichMember + 1)%2;
    subPacket->TargetVolume = t->GetMemberUnprotected(subPacket->WhichMember);

    KeAcquireSpinLock(&t->_spinLock, &irql);
    if (t->QueryMemberState(subPacket->WhichMember) != FtMemberHealthy) {
        KeReleaseSpinLock(&t->_spinLock, irql);
        masterPacket->IoStatus = subPacket->IoStatus;
        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }
    KeReleaseSpinLock(&t->_spinLock, irql);

    subPacket->CompletionRoutine = MirrorRecoverPhase3;
    TRANSFER(subPacket);
}

VOID
MirrorRecoverEmergencyCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for use of the emergency recover packet
    in a recover operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_TP          transferPacket = (PMIRROR_TP) TransferPacket;
    PMIRROR             t = transferPacket->Mirror;
    PMIRROR_RECOVER_TP  subPacket = t->_eRecoverPacket;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(transferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(transferPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = transferPacket->Offset;
    subPacket->CompletionRoutine = MirrorRecoverPhase2;
    subPacket->TargetVolume = transferPacket->TargetVolume;
    subPacket->Thread = transferPacket->Thread;
    subPacket->IrpFlags = transferPacket->IrpFlags;
    subPacket->ReadPacket = TRUE;
    subPacket->MasterPacket = transferPacket;
    subPacket->Mirror = t;
    subPacket->WhichMember = transferPacket->WhichMember;

    TRANSFER(subPacket);
}

VOID
MirrorRecoverPhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for an acquire io region
    to a recover operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_TP          transferPacket = (PMIRROR_TP) TransferPacket;
    PMIRROR             t = transferPacket->Mirror;
    PMIRROR_RECOVER_TP  subPacket;
    KIRQL               irql;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;
    transferPacket->IoStatus.Status = STATUS_SUCCESS;
    transferPacket->IoStatus.Information = transferPacket->Length;

    subPacket = new MIRROR_RECOVER_TP;
    if (subPacket && !subPacket->AllocateMdls(t->QuerySectorSize())) {
        delete subPacket;
        subPacket = NULL;
    }
    if (!subPacket) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        if (t->_eRecoverPacketInUse) {
            transferPacket->SavedCompletionRoutine =
                    transferPacket->CompletionRoutine;
            transferPacket->CompletionRoutine = MirrorRecoverEmergencyCompletion;
            InsertTailList(&t->_eRecoverPacketQueue, &transferPacket->QueueEntry);
            KeReleaseSpinLock(&t->_spinLock, irql);
            return;
        }
        t->_eRecoverPacketInUse = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);

        subPacket = t->_eRecoverPacket;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(transferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(transferPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = transferPacket->Offset;
    subPacket->CompletionRoutine = MirrorRecoverPhase2;
    subPacket->TargetVolume = transferPacket->TargetVolume;
    subPacket->Thread = transferPacket->Thread;
    subPacket->IrpFlags = transferPacket->IrpFlags;
    subPacket->ReadPacket = TRUE;
    subPacket->MasterPacket = transferPacket;
    subPacket->Mirror = t;
    subPacket->WhichMember = transferPacket->WhichMember;

    TRANSFER(subPacket);
}

VOID
MIRROR::Recover(
    IN OUT  PMIRROR_TP  TransferPacket
    )

/*++

Routine Description:

    This routine attempts the given read packet sector by sector.  Every
    sector that fails to read because of a bad sector error is retried
    on the other member and then the good data is written back to the
    failed sector if possible.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    ASSERT(TransferPacket->ReadPacket);
    TransferPacket->SavedCompletionRoutine = TransferPacket->CompletionRoutine;
    TransferPacket->CompletionRoutine = MirrorRecoverPhase1;
    _overlappedIoManager.AcquireIoRegion(TransferPacket, TRUE);
}

VOID
MirrorMaxTransferCompletionRoutine(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a sector transfer subordinate
    to a MAX transfer operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket = (PMIRROR_RECOVER_TP) TransferPacket;
    PMIRROR_TP          masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR             t = masterPacket->Mirror;
    NTSTATUS            status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Offset += subPacket->Length;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
MirrorMaxTransferEmergencyCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for use of the emergency recover packet
    in a max transfer operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_TP          transferPacket = (PMIRROR_TP) TransferPacket;
    PMIRROR             t = transferPacket->Mirror;
    PMIRROR_RECOVER_TP  subPacket = t->_eRecoverPacket;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(transferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(transferPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = transferPacket->Offset;
    subPacket->CompletionRoutine = MirrorMaxTransferCompletionRoutine;
    subPacket->TargetVolume = transferPacket->TargetVolume;
    subPacket->Thread = transferPacket->Thread;
    subPacket->IrpFlags = transferPacket->IrpFlags;
    subPacket->ReadPacket = transferPacket->ReadPacket;
    subPacket->MasterPacket = transferPacket;
    subPacket->Mirror = t;
    subPacket->WhichMember = transferPacket->WhichMember;

    TRANSFER(subPacket);
}

VOID
MIRROR::MaxTransfer(
    IN OUT  PMIRROR_TP  TransferPacket
    )

/*++

Routine Description:

    This routine transfers the maximum possible subset of the given transfer
    by doing it one sector at a time.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket;
    KIRQL               irql;

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;

    subPacket = new MIRROR_RECOVER_TP;
    if (subPacket && !subPacket->AllocateMdls(QuerySectorSize())) {
        delete subPacket;
        subPacket = NULL;
    }
    if (!subPacket) {
        KeAcquireSpinLock(&_spinLock, &irql);
        if (_eRecoverPacketInUse) {
            TransferPacket->SavedCompletionRoutine =
                    TransferPacket->CompletionRoutine;
            TransferPacket->CompletionRoutine = MirrorMaxTransferEmergencyCompletion;
            InsertTailList(&_eRecoverPacketQueue, &TransferPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _eRecoverPacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        subPacket = _eRecoverPacket;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(TransferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl),
                      QuerySectorSize());

    subPacket->Length = QuerySectorSize();
    subPacket->Offset = TransferPacket->Offset;
    subPacket->CompletionRoutine = MirrorMaxTransferCompletionRoutine;
    subPacket->TargetVolume = TransferPacket->TargetVolume;
    subPacket->Thread = TransferPacket->Thread;
    subPacket->IrpFlags = TransferPacket->IrpFlags;
    subPacket->ReadPacket = TransferPacket->ReadPacket;
    subPacket->MasterPacket = TransferPacket;
    subPacket->Mirror = this;
    subPacket->WhichMember = TransferPacket->WhichMember;

    TRANSFER(subPacket);
}

class FTP_MIRROR_STATE_WORK_ITEM : public WORK_QUEUE_ITEM {

    public:

        FT_COMPLETION_ROUTINE   CompletionRoutine;
        PVOID                   Context;
        PMIRROR                 Mirror;

};

typedef FTP_MIRROR_STATE_WORK_ITEM* PFTP_MIRROR_STATE_WORK_ITEM;

VOID
MirrorPropogateStateChangesWorker(
    IN  PVOID   Context
    )

/*++

Routine Description:

    This routine is a worker thread routine for propogating state changes.

Arguments:

    Mirror  - Supplies a pointer to the mirror object.

Return Value:

    None.

--*/

{
    PFTP_MIRROR_STATE_WORK_ITEM         context = (PFTP_MIRROR_STATE_WORK_ITEM) Context;
    PMIRROR                             t = context->Mirror;
    KIRQL                               irql;
    FT_MIRROR_AND_SWP_STATE_INFORMATION state;
    NTSTATUS                            status;

    FtpAcquire(t->_rootExtension);

    KeAcquireSpinLock(&t->_spinLock, &irql);
    RtlCopyMemory(&state, &t->_state, sizeof(state));
    KeReleaseSpinLock(&t->_spinLock, irql);

    status = t->_diskInfoSet->WriteStateInformation(t->QueryLogicalDiskId(),
                                                    &state, sizeof(state));

    FtpRelease(t->_rootExtension);

    if (context->CompletionRoutine) {
        context->CompletionRoutine(context->Context, status);
    }
}

VOID
MIRROR::PropogateStateChanges(
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine propogates the changes in the local memory state to
    the on disk state.

Arguments:

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    None.

--*/

{
    PFTP_MIRROR_STATE_WORK_ITEM  workItem;

    workItem = (PFTP_MIRROR_STATE_WORK_ITEM)
               ExAllocatePool(NonPagedPool,
                              sizeof(FTP_MIRROR_STATE_WORK_ITEM));
    if (!workItem) {
        return;
    }
    ExInitializeWorkItem(workItem, MirrorPropogateStateChangesWorker, workItem);

    workItem->CompletionRoutine = CompletionRoutine;
    workItem->Context = Context;
    workItem->Mirror = this;

    FtpQueueWorkItem(_rootExtension, workItem);
}

VOID
MirrorCarefulWritePhase2(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a sector replacement
    for a careful write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_TP  subPacket = (PMIRROR_TP) TransferPacket;

    subPacket->CompletionRoutine = MirrorCarefulWritePhase1;
    TRANSFER(subPacket);
}

VOID
MirrorCarefulWritePhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a first attempt of a single sector write
    for a careful write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_TP  subPacket = (PMIRROR_TP) TransferPacket;
    NTSTATUS    status = subPacket->IoStatus.Status;
    PMIRROR_TP  masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR     t = subPacket->Mirror;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        masterPacket->CompletionRoutine(masterPacket);
        t->Recycle(subPacket, TRUE);
        return;
    }

    if (!NT_SUCCESS(status)) {
        if (!subPacket->OneReadFailed) {
            subPacket->CompletionRoutine = MirrorCarefulWritePhase2;
            subPacket->OneReadFailed = TRUE;
            subPacket->TargetVolume->ReplaceBadSector(subPacket);
            return;
        }

        masterPacket->IoStatus = subPacket->IoStatus;
    }

    if (masterPacket->Offset + masterPacket->Length ==
        subPacket->Offset + subPacket->Length) {

        masterPacket->CompletionRoutine(masterPacket);
        t->Recycle(subPacket, TRUE);
        return;
    }

    subPacket->Offset += subPacket->Length;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);
    subPacket->OneReadFailed = FALSE;

    TRANSFER(subPacket);
}

VOID
MirrorCarefulWriteEmergencyCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for use of the emergency recover packet
    in a careful write operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_TP          transferPacket = (PMIRROR_TP) TransferPacket;
    PMIRROR             t = transferPacket->Mirror;
    PMIRROR_RECOVER_TP  subPacket = t->_eRecoverPacket;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(transferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(transferPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = transferPacket->Offset;
    subPacket->CompletionRoutine = MirrorCarefulWritePhase1;
    subPacket->TargetVolume = transferPacket->TargetVolume;
    subPacket->Thread = transferPacket->Thread;
    subPacket->IrpFlags = transferPacket->IrpFlags;
    subPacket->ReadPacket = FALSE;
    subPacket->MasterPacket = transferPacket;
    subPacket->Mirror = t;
    subPacket->WhichMember = transferPacket->WhichMember;
    subPacket->OneReadFailed = FALSE;

    TRANSFER(subPacket);
}

VOID
MIRROR::CarefulWrite(
    IN OUT  PMIRROR_TP  TransferPacket
    )

/*++

Routine Description:

    This routine goes through the transfer packet sector by sector
    and fixes write failures when possible.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket;
    KIRQL               irql;

    ASSERT(!TransferPacket->ReadPacket);

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;

    subPacket = new MIRROR_RECOVER_TP;
    if (subPacket && !subPacket->AllocateMdls(QuerySectorSize())) {
        delete subPacket;
        subPacket = NULL;
    }
    if (!subPacket) {
        KeAcquireSpinLock(&_spinLock, &irql);
        if (_eRecoverPacketInUse) {
            TransferPacket->SavedCompletionRoutine =
                    TransferPacket->CompletionRoutine;
            TransferPacket->CompletionRoutine = MirrorCarefulWriteEmergencyCompletion;
            InsertTailList(&_eRecoverPacketQueue, &TransferPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _eRecoverPacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        subPacket = _eRecoverPacket;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(TransferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl),
                      QuerySectorSize());

    subPacket->Length = QuerySectorSize();
    subPacket->Offset = TransferPacket->Offset;
    subPacket->CompletionRoutine = MirrorCarefulWritePhase1;
    subPacket->TargetVolume = TransferPacket->TargetVolume;
    subPacket->Thread = TransferPacket->Thread;
    subPacket->IrpFlags = TransferPacket->IrpFlags;
    subPacket->ReadPacket = FALSE;
    subPacket->MasterPacket = TransferPacket;
    subPacket->Mirror = this;
    subPacket->WhichMember = TransferPacket->WhichMember;
    subPacket->OneReadFailed = FALSE;

    TRANSFER(subPacket);
}

NTSTATUS
MIRROR::QueryPhysicalOffsets(
    IN  LONGLONG                    LogicalOffset,
    OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
    OUT PULONG                      NumberOfPhysicalOffsets
    )
/*++

Routine Description:

    This routine returns physical disk and offset for a given volume
    logical offset.

Arguments:

    LogicalOffset           - Supplies the logical offset

    PhysicalOffsets         - Returns the physical offsets

    NumberOfPhysicalOffsets - Returns the number of physical offsets

Return Value:

    NTSTATUS

--*/
{
    PFT_VOLUME                  vol;
    KIRQL                       irql;
    USHORT                      n, i, numberOfArrays = 0;
    PVOLUME_PHYSICAL_OFFSET*    arrayOfArrays;    
    PULONG                      arrayOfSizes;
    ULONG                       currentSize = 0;
    NTSTATUS                    status;
    FT_MEMBER_STATE             memberState;
    
    if (LogicalOffset < 0 ||
        _volumeSize <= LogicalOffset) {
        return STATUS_INVALID_PARAMETER;
    }
    
    n = QueryNumMembers();

    arrayOfArrays = (PVOLUME_PHYSICAL_OFFSET*) ExAllocatePool(PagedPool, n*sizeof(PVOLUME_PHYSICAL_OFFSET));
    if (!arrayOfArrays) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    arrayOfSizes = (PULONG) ExAllocatePool(PagedPool, n*sizeof(ULONG));
    if (!arrayOfSizes) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }

        KeAcquireSpinLock(&_spinLock, &irql);
        memberState = QueryMemberState(i);
        KeReleaseSpinLock(&_spinLock, irql);
        if (memberState != FtMemberHealthy) {
            continue;
        }
        
        status = vol->QueryPhysicalOffsets(LogicalOffset, &(arrayOfArrays[numberOfArrays]), 
                                           &(arrayOfSizes[numberOfArrays]) );
        if (NT_SUCCESS(status)) {
            currentSize += arrayOfSizes[numberOfArrays++];
        }       
    }

    if (numberOfArrays > 1) {

        *PhysicalOffsets = (PVOLUME_PHYSICAL_OFFSET) ExAllocatePool(PagedPool, currentSize*sizeof(VOLUME_PHYSICAL_OFFSET));
        if (!(*PhysicalOffsets)) {
            for (i = 0; i < numberOfArrays; i++) {
                ExFreePool(arrayOfArrays[i]);
            }
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }
        *NumberOfPhysicalOffsets = currentSize;
        
        currentSize = 0;
        for (i = 0; i < numberOfArrays; i++) {
            RtlCopyMemory(&((*PhysicalOffsets)[currentSize]), arrayOfArrays[i], arrayOfSizes[i]*sizeof(VOLUME_PHYSICAL_OFFSET));
            currentSize += arrayOfSizes[i];
            ExFreePool(arrayOfArrays[i]);
        }

        status = STATUS_SUCCESS;
        goto cleanup;
    }

    if (numberOfArrays == 1) {
        *PhysicalOffsets = arrayOfArrays[0];
        ASSERT(arrayOfSizes[0] == currentSize);
        *NumberOfPhysicalOffsets = currentSize;
        status = STATUS_SUCCESS;
        goto cleanup;
    }

    ASSERT(numberOfArrays == 0);
    status = STATUS_INVALID_PARAMETER;

cleanup:
    ExFreePool(arrayOfArrays);
    ExFreePool(arrayOfSizes);
    return status;
}

NTSTATUS
MIRROR::QueryLogicalOffset(
    IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
    OUT PLONGLONG               LogicalOffset
    )
/*++

Routine Description:

    This routine returns the volume logical offset for a given disk number
    and physical offset.

Arguments:

    PhysicalOffset          - Supplies the physical offset

    LogicalOffset           - Returns the logical offset

Return Value:

    NTSTATUS

--*/
{    
    USHORT          n, i;
    LONGLONG        logicalOffsetInMember;
    NTSTATUS        status;
    PFT_VOLUME      vol;
    KIRQL           irql;
    FT_MEMBER_STATE memberState;
    
    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }

        KeAcquireSpinLock(&_spinLock, &irql);
        memberState = QueryMemberState(i);
        KeReleaseSpinLock(&_spinLock, irql);
        if (memberState != FtMemberHealthy) {
            continue;
        }

        status = vol->QueryLogicalOffset(PhysicalOffset, &logicalOffsetInMember);
        if (NT_SUCCESS(status)) {
            if (_volumeSize <= logicalOffsetInMember) {
                return STATUS_INVALID_PARAMETER;
            }

            *LogicalOffset = logicalOffsetInMember;
            return status;
        }        
    }

    return STATUS_INVALID_PARAMETER;
}

VOID
MIRROR::ModifyStateForUser(
    IN OUT  PVOID   State
    )

/*++

Routine Description:

    This routine modifies the state for the user to see, possibly adding
    non-persistant state different than what is stored on disk.

Arguments:

    State   - Supplies and returns the state for the logical disk.

Return Value:

    None.

--*/

{
    KIRQL                                   irql;
    BOOLEAN                                 isDirty;
    PFT_MIRROR_AND_SWP_STATE_INFORMATION    state;

    KeAcquireSpinLock(&_spinLock, &irql);
    if (_syncOk && !_stopSyncs) {
        isDirty = FALSE;
    } else {
        isDirty = TRUE;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (!isDirty) {
        return;
    }

    state = (PFT_MIRROR_AND_SWP_STATE_INFORMATION) State;
    if (state->UnhealthyMemberState == FtMemberHealthy) {
        state->UnhealthyMemberState = FtMemberRegenerating;
        state->UnhealthyMemberNumber = 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\ondisk.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ondisk.cxx

Abstract:

    This file contains the implementation for the classes defined in
    ondisk.hxx

Author:

    Norbert Kusters 15-July-1996

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
IsFormatMediaTypeNEC_98(
    IN  PDEVICE_OBJECT      WholeDisk,
    IN  ULONG               SectorSize,
    OUT PBOOLEAN            FormatMediaTypeIsNEC_98
    )
/*++

Routine Description:

    Determine format media type, PC-9800 architecture or PC/AT architecture
    Logic of determination:
      [removable]                                      - PC/AT architecture
      [fixed] and [0x55AA exist] and [non "IPL1"]    - PC/AT architecture
      [fixed] and [0x55AA exist] and ["IPL1" exist]  - PC-9800 architecture
      [fixed] and [non 0x55AA  ]                     - PC-9800 architecture

Arguments:

    WholeDisk               - Supplies the device object.

    SectorSize              - Supplies the sector size.

    FormatMediaTypeIsNEC_98 - Return format type
                                TRUE   - The media was formated by PC-9800 architecture
                                FALSE  - The media was formated by PC/AT architecture
                                          or it was not formated

Return Value:

--*/
{
    KEVENT              event;
    IO_STATUS_BLOCK     ioStatus;
    PIRP                irp;
    NTSTATUS            status;
    ULONG               readSize;
    PVOID               readBuffer;
    LARGE_INTEGER       byteOffset;

#define IPL1_OFFSET             4
#define BOOT_SIGNATURE_OFFSET   ((0x200 / 2) -1)
#define BOOT_RECORD_SIGNATURE   (0xAA55)

    *FormatMediaTypeIsNEC_98 = FALSE;

    // Is this removable?

    if (WholeDisk->Characteristics&FILE_REMOVABLE_MEDIA) {

        // Removable media is PC/AT architecture.
        return STATUS_SUCCESS;
    }

    // Start at sector 0 of the device.

    readSize = SectorSize;
    byteOffset.QuadPart = 0;

    if (readSize < 512) {
        readSize = 512;
    }

    readBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                readSize < PAGE_SIZE ? PAGE_SIZE : readSize);
    if (!readBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildSynchronousFsdRequest(IRP_MJ_READ, WholeDisk,
                                       readBuffer, readSize, &byteOffset,
                                       &event, &ioStatus);

    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(WholeDisk, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        ExFreePool(readBuffer);
        return status;
    }

    if (((PUSHORT) readBuffer)[BOOT_SIGNATURE_OFFSET] ==
        BOOT_RECORD_SIGNATURE) {

        if (!strncmp((PCHAR) readBuffer + IPL1_OFFSET, "IPL1",
                     sizeof("IPL1") - 1)) {

            // It's PC-9800 Architecture.
            *FormatMediaTypeIsNEC_98 = TRUE;
        }
    } else {

        // It's PC-9800 Architecture.
        *FormatMediaTypeIsNEC_98 = TRUE;
    }

    ExFreePool(readBuffer);
    return STATUS_SUCCESS;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION::Initialize(
    IN      PROOT_EXTENSION RootExtension,
    IN OUT  PDEVICE_OBJECT  WholeDiskPdo
    )

/*++

Routine Description:

    This routine reads in the on disk information on the given device
    into memory.

Arguments:

    RootExtension   - Supplies the root extension.

    WholeDiskPdo    - Supplies the device object for the whole physical disk PDO.

Return Value:

    NTSTATUS

--*/

{
    KEVENT                      event;
    PIRP                        irp;
    STORAGE_DEVICE_NUMBER       deviceNumber;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;
    DISK_GEOMETRY               geometry;
    PDRIVE_LAYOUT_INFORMATION_EX layout;
    ULONG                       i;
    LONGLONG                    offset, minStartingOffset;
    PVOID                       buffer;
    BOOLEAN                     formatMediaTypeIsNEC_98;

    _rootExtension = RootExtension;
    _wholeDisk = IoGetAttachedDeviceReference(WholeDiskPdo);
    _wholeDiskPdo = WholeDiskPdo;
    _diskBuffer = NULL;
    _isDiskSuitableForFtOnDisk = TRUE;

    status = FtpQueryPartitionInformation(RootExtension, _wholeDisk,
                                          &_diskNumber, NULL, NULL, NULL,
                                          NULL, NULL, NULL, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        _wholeDisk, NULL, 0, &geometry,
                                        sizeof(geometry), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(_wholeDisk, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        return status;
    }

    _sectorSize = geometry.BytesPerSector;

    _byteOffset.QuadPart = 1024;

    HalExamineMBR(_wholeDisk, _sectorSize, 0x55, &buffer);
    if (buffer) {
        _byteOffset.QuadPart = 0x3000;
        ExFreePool(buffer);
    }

    if (IsNEC_98) {
        status = IsFormatMediaTypeNEC_98(_wholeDisk, _sectorSize,
                                         &formatMediaTypeIsNEC_98);

        if (!NT_SUCCESS(status)) {
            FtpLogError(_rootExtension, _diskNumber, FT_CANT_READ_ON_DISK,
                        status, 0);
            _isDiskSuitableForFtOnDisk = FALSE;
            return status;
        }

        if (formatMediaTypeIsNEC_98) {
            _byteOffset.QuadPart = 17*_sectorSize;
        }
    }


    if (_byteOffset.QuadPart < _sectorSize) {
        _byteOffset.QuadPart = _sectorSize;
    }

    status = FtpReadPartitionTableEx(_wholeDisk, &layout);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    minStartingOffset = 0x4000;
    for (i = 0; i < layout->PartitionCount; i++) {
        offset = layout->PartitionEntry[i].StartingOffset.QuadPart;
        if (!offset) {
            continue;
        }
        if (offset < minStartingOffset) {
            minStartingOffset = offset;
        }
    }

    ExFreePool(layout);

    _length = (4095/_sectorSize + 1)*_sectorSize;
    if (_byteOffset.QuadPart + _length > minStartingOffset) {
        if (_byteOffset.QuadPart < minStartingOffset) {
            _length = (ULONG) (minStartingOffset - _byteOffset.QuadPart);
        } else {
            _length = 0;
        }
    }

    if (_length) {
        _diskBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                     _length < PAGE_SIZE ? PAGE_SIZE : _length);
        if (!_diskBuffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        irp = IoBuildSynchronousFsdRequest(IRP_MJ_READ, _wholeDisk,
                                           _diskBuffer, _length, &_byteOffset,
                                           &event, &ioStatus);

        if (!irp) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = IoCallDriver(_wholeDisk, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        if (!NT_SUCCESS(status)) {
            if (status != STATUS_DEVICE_OFF_LINE) {
                FtpLogError(_rootExtension, _diskNumber,
                            FT_CANT_READ_ON_DISK, status, 0);
            }
            _isDiskSuitableForFtOnDisk = FALSE;
            RtlZeroMemory(_diskBuffer, _length);
            status = STATUS_SUCCESS;
        }

    } else {
        _diskBuffer = NULL;
    }

    return status;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION::Write(
    )

/*++

Routine Description:

    This routine writes out the changes in the disk buffer
    back out to disk.

Arguments:

    None.

Return Value:

    NTSTATUS

--*/

{
    KEVENT                  event;
    PIRP                    irp;
    IO_STATUS_BLOCK         ioStatus;
    NTSTATUS                status;

    if (!_length) {
        return STATUS_SUCCESS;
    }

    if (!_isDiskSuitableForFtOnDisk) {
        ASSERT(FALSE);
        return STATUS_SUCCESS;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildSynchronousFsdRequest(IRP_MJ_WRITE, _wholeDisk,
                                       _diskBuffer, _length, &_byteOffset,
                                       &event, &ioStatus);

    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(_wholeDisk, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        FtpLogError(GetRootExtension(), QueryDiskNumber(),
                    FT_CANT_WRITE_ON_DISK, status, 0);
    }

    return status;
}

PFT_LOGICAL_DISK_DESCRIPTION
FT_LOGICAL_DISK_INFORMATION::AddLogicalDiskDescription(
    IN  PFT_LOGICAL_DISK_DESCRIPTION    LogicalDiskDescription
    )

/*++

Routine Description:

    This routine adds a new logical disk description at the end of the
    list of logical disk descriptions.

Arguments:

    LogicalDiskDescription  - Supplies a new logical disk description.

Return Value:

    A pointer into the on disk buffer where the new logical disk
    description was added or NULL.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p, last;
    PFT_ON_DISK_PREAMBLE            preamble;

    if (!_length) {
        return NULL;
    }

    if (!_isDiskSuitableForFtOnDisk) {
        FtpLogError(GetRootExtension(), QueryDiskNumber(), FT_NOT_FT_CAPABLE,
                    STATUS_SUCCESS, 0);
        return NULL;
    }

    last = NULL;
    for (p = GetFirstLogicalDiskDescription(); p;
         p = GetNextLogicalDiskDescription(p)) {

        last = p;
    }

    preamble = (PFT_ON_DISK_PREAMBLE) _diskBuffer;

    if (preamble->FtOnDiskSignature == FT_ON_DISK_SIGNATURE &&
        preamble->DiskDescriptionVersionNumber !=
        FT_ON_DISK_DESCRIPTION_VERSION_NUMBER) {

        FtpLogError(GetRootExtension(), QueryDiskNumber(), FT_WRONG_VERSION,
                    STATUS_SUCCESS, 0);
        return NULL;
    }

    if (last) {
        p = (PFT_LOGICAL_DISK_DESCRIPTION)
            ((PCHAR) last + last->DiskDescriptionSize);
    } else {

        preamble->FtOnDiskSignature = FT_ON_DISK_SIGNATURE;
        preamble->DiskDescriptionVersionNumber =
                FT_ON_DISK_DESCRIPTION_VERSION_NUMBER;

        preamble->ByteOffsetToFirstFtLogicalDiskDescription =
                sizeof(FT_ON_DISK_PREAMBLE);
        preamble->ByteOffsetToReplaceLog = 0;

        p = (PFT_LOGICAL_DISK_DESCRIPTION)
            ((PCHAR) preamble +
             preamble->ByteOffsetToFirstFtLogicalDiskDescription);
    }

    if ((PCHAR) p - (PCHAR) preamble +
        LogicalDiskDescription->DiskDescriptionSize + sizeof(USHORT) >
        _length) {

        return NULL;
    }

    ClearReplaceLog();

    RtlMoveMemory(p, LogicalDiskDescription,
                  LogicalDiskDescription->DiskDescriptionSize);

    last = (PFT_LOGICAL_DISK_DESCRIPTION) ((PCHAR) p + p->DiskDescriptionSize);
    last->DiskDescriptionSize = 0;

    return p;
}

ULONG
FT_LOGICAL_DISK_INFORMATION::QueryDiskDescriptionFreeSpace(
    )

/*++

Routine Description:

    This routine returns the free space for new disk
    descriptions.

Arguments:

    None.

Return Value:

    The free space for new disk descriptions.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p, last;

    if (!_length) {
        return 0;
    }

    if (!_isDiskSuitableForFtOnDisk) {
        FtpLogError(GetRootExtension(), QueryDiskNumber(), FT_NOT_FT_CAPABLE,
                    STATUS_SUCCESS, 0);
        return 0;
    }

    last = NULL;
    for (p = GetFirstLogicalDiskDescription(); p;
         p = GetNextLogicalDiskDescription(p)) {

        last = p;
    }

    if (last) {
        return _length - ((ULONG)((PCHAR) last - (PCHAR) _diskBuffer) +
                          last->DiskDescriptionSize + sizeof(USHORT));
    } else {
        return _length - sizeof(USHORT) - sizeof(FT_ON_DISK_PREAMBLE);
    }
}

VOID
FT_LOGICAL_DISK_INFORMATION::DeleteLogicalDiskDescription(
    IN  PFT_LOGICAL_DISK_DESCRIPTION    LogicalDiskDescription
    )

/*++

Routine Description:

    This routine deletes the given logical disk description from the
    logical disk description list.

Arguments:

    LogicalDiskDescription  - Supplies the logical disk description to
                                delete.

Return Value:

    None.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p, last;
    BOOLEAN                         exists;
    ULONG                           moveLength;
    PFT_ON_DISK_PREAMBLE            preamble;

    exists = FALSE;
    last = NULL;
    for (p = GetFirstLogicalDiskDescription(); p;
         p = GetNextLogicalDiskDescription(p)) {

        if (p == LogicalDiskDescription) {
            exists = TRUE;
        }

        last = p;
    }

    if (!exists) {
        ASSERT(FALSE);
        return;
    }

    moveLength = (ULONG)((PCHAR) last - (PCHAR) LogicalDiskDescription) +
                 last->DiskDescriptionSize + sizeof(USHORT) -
                 LogicalDiskDescription->DiskDescriptionSize;

    RtlMoveMemory(LogicalDiskDescription,
                  (PCHAR) LogicalDiskDescription +
                  LogicalDiskDescription->DiskDescriptionSize,
                  moveLength);

    if (!GetFirstLogicalDiskDescription()) {
        preamble = (PFT_ON_DISK_PREAMBLE) _diskBuffer;
        preamble->FtOnDiskSignature = 0;
    }
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION::AddReplaceLog(
    IN  FT_LOGICAL_DISK_ID  ReplacedMemberLogicalDiskId,
    IN  FT_LOGICAL_DISK_ID  NewMemberLogicalDiskId,
    IN  ULONG               NumberOfChangedDiskIds,
    IN  PFT_LOGICAL_DISK_ID OldLogicalDiskIds,
    IN  PFT_LOGICAL_DISK_ID NewLogicalDiskIds
    )

/*++

Routine Description:

    This routine adds the given replace log to the on disk structure.

Arguments:

    NumberOfChangedDiskIds - Supplies the number of replaced disk ids.

    OldLogicalDiskIds       - Supplies the old logical disk ids.

    NewLogicalDiskIds       - Supplies the new logical disk ids.

Return Value:

    FALSE   - Insufficient disk space.

    TRUE    - Success.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p, last = NULL;
    PFT_LOGICAL_DISK_ID             diskId;
    ULONG                           offset, freeSpace, i;
    PFT_ON_DISK_PREAMBLE            preamble;

    for (p = GetFirstLogicalDiskDescription(); p;
         p = GetNextLogicalDiskDescription(p)) {

        last = p;
    }

    if (!last) {
        return TRUE;
    }

    diskId = (PFT_LOGICAL_DISK_ID)
             ((ULONG_PTR) ((PCHAR) last + last->DiskDescriptionSize +
                       2*sizeof(FT_LOGICAL_DISK_ID))/
              (2*sizeof(FT_LOGICAL_DISK_ID))*
              (2*sizeof(FT_LOGICAL_DISK_ID)));

    offset = (ULONG) ((PCHAR) diskId - (PCHAR) _diskBuffer);
    freeSpace = _length - offset;
    if (freeSpace <
        2*(NumberOfChangedDiskIds + 2)*sizeof(FT_LOGICAL_DISK_ID)) {

        return FALSE;
    }

    preamble = (PFT_ON_DISK_PREAMBLE) _diskBuffer;
    preamble->ByteOffsetToReplaceLog = offset;
    diskId[0] = ReplacedMemberLogicalDiskId;
    diskId[1] = NewMemberLogicalDiskId;
    for (i = 0; i < NumberOfChangedDiskIds; i++) {
        diskId[2*(i + 1)] = OldLogicalDiskIds[i];
        diskId[2*(i + 1) + 1] = NewLogicalDiskIds[i];
    }
    diskId[2*(i + 1)] = 0;

    return TRUE;
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION::ClearReplaceLog(
    )

/*++

Routine Description:

    This routine clears the replace log.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PFT_ON_DISK_PREAMBLE    preamble;

    preamble = (PFT_ON_DISK_PREAMBLE) _diskBuffer;
    if (preamble->FtOnDiskSignature != FT_ON_DISK_SIGNATURE ||
        preamble->DiskDescriptionVersionNumber !=
        FT_ON_DISK_DESCRIPTION_VERSION_NUMBER ||
        !preamble->ByteOffsetToReplaceLog) {

        return FALSE;
    }

    preamble->ByteOffsetToReplaceLog = 0;

    return TRUE;
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION::BackOutReplaceOperation(
    )

/*++

Routine Description:

    This routine backs out the given replace operation.

Arguments:

    None.

Return Value:

    FALSE   - No change was made to the on disk structures.

    TRUE    - A change was made to the on disk structures.

--*/

{
    PFT_ON_DISK_PREAMBLE            preamble;
    PFT_LOGICAL_DISK_ID             diskId;
    PFT_LOGICAL_DISK_DESCRIPTION    partition;
    FT_LOGICAL_DISK_ID              child;
    BOOLEAN                         needsBackout;
    PFT_LOGICAL_DISK_DESCRIPTION    other;
    ULONG                           i;

    preamble = (PFT_ON_DISK_PREAMBLE) _diskBuffer;
    if (preamble->FtOnDiskSignature != FT_ON_DISK_SIGNATURE ||
        preamble->DiskDescriptionVersionNumber !=
        FT_ON_DISK_DESCRIPTION_VERSION_NUMBER ||
        !preamble->ByteOffsetToReplaceLog) {

        return FALSE;
    }

    diskId = (PFT_LOGICAL_DISK_ID)
             ((PCHAR) _diskBuffer + preamble->ByteOffsetToReplaceLog);

    for (partition = GetFirstLogicalDiskDescription(); partition;
         partition = GetNextLogicalDiskDescription(partition)) {

        if (partition->LogicalDiskType != FtPartition) {
            continue;
        }

        child = partition->LogicalDiskId;
        needsBackout = TRUE;

        for (other = GetNextLogicalDiskDescription(partition); other;
             other = GetNextLogicalDiskDescription(other)) {

            if (other->LogicalDiskType == FtPartition ||
                other->u.Other.ThisMemberLogicalDiskId != child) {

                continue;
            }

            if (child == diskId[1]) {
                needsBackout = FALSE;
                break;
            }

            child = other->LogicalDiskId;
        }

        if (!needsBackout) {
            continue;
        }

        child = partition->LogicalDiskId;

        for (other = GetNextLogicalDiskDescription(partition); other;
             other = GetNextLogicalDiskDescription(other)) {

            if (other->LogicalDiskType == FtPartition ||
                other->u.Other.ThisMemberLogicalDiskId != child) {

                continue;
            }

            child = other->LogicalDiskId;

            for (i = 2; diskId[i]; i += 2) {
                if (other->LogicalDiskId == diskId[i + 1]) {
                    other->LogicalDiskId = diskId[i];
                } else if (other->u.Other.ThisMemberLogicalDiskId ==
                           diskId[i + 1]) {

                    other->u.Other.ThisMemberLogicalDiskId = diskId[i];
                }
            }
        }
    }

    preamble->ByteOffsetToReplaceLog = 0;

    return TRUE;
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION::BackOutReplaceOperationIf(
    IN  PFT_LOGICAL_DISK_INFORMATION    LogicalDiskInformation
    )

/*++

Routine Description:

    This routine backs out the given replace operation on this
    logical disk information if there is evidence from the given
    logical disk information that this logical disk information is
    invalid.

Arguments:

    LogicalDiskInformation  - Supplies the logical disk information.

Return Value:

    FALSE   - No change was made to the on disk structures.

    TRUE    - A change was made to the on disk structures.

--*/

{
    PFT_ON_DISK_PREAMBLE            preamble;
    PFT_LOGICAL_DISK_ID             diskId;
    ULONG                           i;
    FT_LOGICAL_DISK_ID              oldRootDiskId, replacedDiskId;
    PFT_LOGICAL_DISK_DESCRIPTION    partition;
    FT_LOGICAL_DISK_ID              child;
    PFT_LOGICAL_DISK_DESCRIPTION    other;

    preamble = (PFT_ON_DISK_PREAMBLE) _diskBuffer;
    if (!preamble ||
        preamble->FtOnDiskSignature != FT_ON_DISK_SIGNATURE ||
        preamble->DiskDescriptionVersionNumber !=
        FT_ON_DISK_DESCRIPTION_VERSION_NUMBER ||
        !preamble->ByteOffsetToReplaceLog) {

        return FALSE;
    }

    diskId = (PFT_LOGICAL_DISK_ID)
             ((PCHAR) _diskBuffer + preamble->ByteOffsetToReplaceLog);

    for (i = 0; ; i++) {
        if (!diskId[i]) {
            break;
        }
    }

    oldRootDiskId = diskId[i - 2];
    replacedDiskId = diskId[0];

    for (partition = LogicalDiskInformation->GetFirstLogicalDiskDescription();
         partition; partition =
         LogicalDiskInformation->GetNextLogicalDiskDescription(partition)) {

        if (partition->LogicalDiskType != FtPartition) {
            continue;
        }

        child = partition->LogicalDiskId;

        for (other =
             LogicalDiskInformation->GetNextLogicalDiskDescription(partition);
             other; other =
             LogicalDiskInformation->GetNextLogicalDiskDescription(other)) {

            if (other->LogicalDiskType == FtPartition ||
                other->u.Other.ThisMemberLogicalDiskId != child) {

                continue;
            }

            if (child == replacedDiskId) {
                break;
            }

            child = other->LogicalDiskId;
        }

        if (child == oldRootDiskId) {
            return BackOutReplaceOperation();
        }
    }

    return FALSE;
}

ULONGLONG
FT_LOGICAL_DISK_INFORMATION::GetGptAttributes(
    )

/*++

Routine Description:

    This routine returns the simulated GPT attribute bits on sector 2 if
    present, otherwise it returns 0.

Arguments:

    None.

Return Value:

    GPT attribute bits.

--*/

{
    GUID*       pguid;
    PULONGLONG  p;

    pguid = (GUID*) _diskBuffer;
    if (!pguid) {
        return 0;
    }

    if (!IsEqualGUID(*pguid, PARTITION_BASIC_DATA_GUID)) {
        return 0;
    }

    p = (PULONGLONG) ((PCHAR) _diskBuffer + sizeof(GUID));

    return *p;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION::SetGptAttributes(
    IN  ULONGLONG   GptAttributes
    )

/*++

Routine Description:

    This routine sets the GPT simulated attributes bits on sector 2 of this
    MBR disk.

Arguments:

    GptAttributes   - Supplies the GPT attributes.

Return Value:

    NTSTATUS

--*/

{
    LONGLONG                offset;
    PFT_ON_DISK_PREAMBLE    preamble;
    GUID*                   pguid;
    PULONGLONG              p;

    offset = 1024;
    if (offset < _sectorSize) {
        offset = _sectorSize;
    }
    preamble = (PFT_ON_DISK_PREAMBLE) _diskBuffer;
    if (!_diskBuffer || !_isDiskSuitableForFtOnDisk ||
        _byteOffset.QuadPart != offset ||
        preamble->FtOnDiskSignature == FT_ON_DISK_SIGNATURE) {

        return STATUS_INVALID_PARAMETER;
    }

    pguid = (GUID*) _diskBuffer;
    *pguid = PARTITION_BASIC_DATA_GUID;
    p = (PULONGLONG) ((PCHAR) _diskBuffer + sizeof(GUID));
    *p = GptAttributes;

    return Write();
}

FT_LOGICAL_DISK_INFORMATION::~FT_LOGICAL_DISK_INFORMATION(
    )

/*++

Routine Description:

    This routine is the destructor for this class.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (_wholeDisk != _wholeDiskPdo) {
        ObDereferenceObject(_wholeDisk);
    }
    if (_diskBuffer) {
        ExFreePool(_diskBuffer);
    }
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::Initialize(
    )

/*++

Routine Description:

    This routine initializes the class for use.

Arguments:

    None.

Return Value:

    NTSTATUS

--*/

{
    _numberOfLogicalDiskInformations = 0;
    _arrayOfLogicalDiskInformations = NULL;
    _numberOfRootLogicalDisksIds = 0;
    _arrayOfRootLogicalDiskIds = NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::AddLogicalDiskInformation(
    IN  PFT_LOGICAL_DISK_INFORMATION    LogicalDiskInformation,
    OUT PBOOLEAN                        ChangedLogicalDiskIds
    )

/*++

Routine Description:

    This routine adds a logical disk information structure to this
    set of logical disk information structures.

Arguments:

    LogicalDiskInformation  - Supplies the disk information to add.

    ChangedLogicalDiskIds   - Returns whether or not any existing logical
                                disk ids have changed.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                        status;
    PDRIVE_LAYOUT_INFORMATION_EX    layout;
    PFT_LOGICAL_DISK_DESCRIPTION    p, q, r;
    ULONG                           numEntries, i, j;
    PFT_LOGICAL_DISK_INFORMATION*   n;
    BOOLEAN                         error;
    PPARTITION_INFORMATION_EX       partInfo;
    ULONG                           configLength, stateLength;
    PCHAR                           pc, qc;
    ULONG                           uniqueError;

    if (ChangedLogicalDiskIds) {
        *ChangedLogicalDiskIds = FALSE;
    }


    // Check for any partial replace operations that need to be backed out.

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        if (_arrayOfLogicalDiskInformations[i]->BackOutReplaceOperationIf(
            LogicalDiskInformation)) {

            _arrayOfLogicalDiskInformations[i]->Write();

            if (ChangedLogicalDiskIds) {
                *ChangedLogicalDiskIds = TRUE;
            }
        }

        if (LogicalDiskInformation->BackOutReplaceOperationIf(
            _arrayOfLogicalDiskInformations[i])) {

            LogicalDiskInformation->Write();
        }
    }


    // Read in the partition table for future reference.

    status = FtpReadPartitionTableEx(LogicalDiskInformation->GetWholeDisk(),
                                     &layout);
    if (!NT_SUCCESS(status)) {
        return status;
    }


    // First count how many entries are in the given list and also perform
    // a sanity check on these entries.

    numEntries = 0;
    for (p = LogicalDiskInformation->GetFirstLogicalDiskDescription(); p; ) {

        if (!p->DiskDescriptionSize) {
            break;
        }

        error = FALSE;

        if (p->DiskDescriptionSize < sizeof(FT_LOGICAL_DISK_DESCRIPTION) ||
            p->LogicalDiskId == 0) {

            DbgPrint("Disk Description too small, %x, or no logical disk id %I64x\n",
                     p->DiskDescriptionSize, p->LogicalDiskId);
            error = TRUE;
            uniqueError = 1;
        }

        if (!error && p->LogicalDiskType == FtPartition) {

            for (i = 0; i < layout->PartitionCount; i++) {
                partInfo = &layout->PartitionEntry[i];
                if (partInfo->StartingOffset.QuadPart ==
                    p->u.FtPartition.ByteOffset &&
                    (partInfo->Mbr.PartitionType&0x80)) {

                    break;
                }
            }

            if (i == layout->PartitionCount) {
                error = TRUE;
                uniqueError = 2;
                DbgPrint("Partition not found in partition table.\n");
                DbgPrint("Partition start = %I64x\n", p->u.FtPartition.ByteOffset);
                DbgPrint("Drive layout partition count = %d\n", layout->PartitionCount);
            } else if (GetLogicalDiskDescription(p->LogicalDiskId, 0)) {
                error = TRUE;
                uniqueError = 3;
                DbgPrint("Duplicate logical disk description on other disk: %I64x\n",
                         p->LogicalDiskId);
            } else {

                for (q = LogicalDiskInformation->GetFirstLogicalDiskDescription();
                     q != p;
                     q = LogicalDiskInformation->GetNextLogicalDiskDescription(q)) {

                    if (p->LogicalDiskId == q->LogicalDiskId) {
                        error = TRUE;
                        uniqueError = 4;
                        DbgPrint("Duplicate logical disk description on same disk: %I64x\n",
                                 p->LogicalDiskId);
                    } else if (q->LogicalDiskType == FtPartition &&
                               p->u.FtPartition.ByteOffset ==
                               q->u.FtPartition.ByteOffset) {

                        error = TRUE;
                        uniqueError = 100;
                        DbgPrint("%I64x and %I64x are FtPartitions pointing to offset %x\n",
                                 p->LogicalDiskId, q->LogicalDiskId,
                                 p->u.FtPartition.ByteOffset);
                    }
                }
            }

        } else if (!error) {

            for (q = LogicalDiskInformation->GetFirstLogicalDiskDescription();
                 q != p;
                 q = LogicalDiskInformation->GetNextLogicalDiskDescription(q)) {

                if (p->u.Other.ThisMemberLogicalDiskId == q->LogicalDiskId) {
                    break;
                }
            }

            if (p == q) {
                error = TRUE;
                uniqueError = 5;
                DbgPrint("This member logical disk id not found %I64x\n",
                         p->u.Other.ThisMemberLogicalDiskId);
            }

            if (p->u.Other.ThisMemberNumber >= p->u.Other.NumberOfMembers) {
                error = TRUE;
                uniqueError = 6;
                DbgPrint("This member number %d >= number of members %d\n",
                         p->u.Other.ThisMemberNumber, p->u.Other.NumberOfMembers);
            }

            if (p->u.Other.ThisMemberLogicalDiskId == p->LogicalDiskId) {
                error = TRUE;
                uniqueError = 7;
                DbgPrint("This member logical disk == logical disk == %I64x\n",
                         p->LogicalDiskId);
            }

            if (p->u.Other.ByteOffsetToConfigurationInformation &&
                p->u.Other.ByteOffsetToConfigurationInformation <
                sizeof(FT_LOGICAL_DISK_DESCRIPTION)) {

                error = TRUE;
                uniqueError = 8;
                DbgPrint("Byte offset to config info too small: %d\n",
                         p->u.Other.ByteOffsetToConfigurationInformation);
            }

            if (p->u.Other.ByteOffsetToStateInformation &&
                p->u.Other.ByteOffsetToStateInformation <
                sizeof(FT_LOGICAL_DISK_DESCRIPTION)) {

                error = TRUE;
                uniqueError = 9;
                DbgPrint("Byte offset to state info too small: %d\n",
                         p->u.Other.ByteOffsetToStateInformation);
            }

            if (p->u.Other.ByteOffsetToConfigurationInformation &&
                p->u.Other.ByteOffsetToStateInformation &&
                p->u.Other.ByteOffsetToConfigurationInformation >=
                p->u.Other.ByteOffsetToStateInformation) {

                error = TRUE;
                uniqueError = 10;
                DbgPrint("Config info %d past state info %d\n",
                         p->u.Other.ByteOffsetToConfigurationInformation,
                         p->u.Other.ByteOffsetToStateInformation);
            }

            if (p->u.Other.ByteOffsetToConfigurationInformation >=
                p->DiskDescriptionSize) {

                error = TRUE;
                uniqueError = 11;
                DbgPrint("Byte offset to config info too large: %d vs. %d\n",
                         p->u.Other.ByteOffsetToConfigurationInformation,
                         p->DiskDescriptionSize);
            }

            if (p->u.Other.ByteOffsetToStateInformation >=
                p->DiskDescriptionSize) {

                error = TRUE;
                uniqueError = 12;
                DbgPrint("Byte offset to state info too large: %d vs. %d\n",
                         p->u.Other.ByteOffsetToStateInformation,
                         p->DiskDescriptionSize);
            }

            if (!error && p->u.Other.ByteOffsetToConfigurationInformation) {
                if (p->u.Other.ByteOffsetToStateInformation) {
                    configLength = p->u.Other.ByteOffsetToStateInformation -
                                   p->u.Other.ByteOffsetToConfigurationInformation;
                } else {
                    configLength = p->DiskDescriptionSize -
                                   p->u.Other.ByteOffsetToConfigurationInformation;
                }

                switch (p->LogicalDiskType) {
                    case FtStripeSet:
                        if (configLength <
                            sizeof(FT_STRIPE_SET_CONFIGURATION_INFORMATION)) {

                            error = TRUE;
                            uniqueError = 13;
                            DbgPrint("Stripe config too small: %d\n",
                                     configLength);
                        }
                        break;

                    case FtMirrorSet:
                        if (configLength <
                            sizeof(FT_MIRROR_SET_CONFIGURATION_INFORMATION)) {

                            error = TRUE;
                            uniqueError = 14;
                            DbgPrint("Mirror config too small: %d\n",
                                     configLength);
                        }
                        break;

                    case FtStripeSetWithParity:
                        if (configLength <
                            sizeof(FT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION)) {

                            error = TRUE;
                            uniqueError = 15;
                            DbgPrint("SWP config too small: %d\n",
                                     configLength);
                        }
                        break;

                    case FtRedistribution:
                        if (configLength <
                            sizeof(FT_REDISTRIBUTION_CONFIGURATION_INFORMATION)) {

                            error = TRUE;
                            uniqueError = 16;
                            DbgPrint("Redistrubution config too small: %d\n",
                                     configLength);
                        }
                        break;

                }
            }


            if (!error && p->u.Other.ByteOffsetToStateInformation) {
                stateLength = p->DiskDescriptionSize -
                              p->u.Other.ByteOffsetToStateInformation;

                switch (p->LogicalDiskType) {
                    case FtMirrorSet:
                    case FtStripeSetWithParity:
                        if (stateLength <
                            sizeof(FT_MIRROR_AND_SWP_STATE_INFORMATION)) {

                            error = TRUE;
                            uniqueError = 17;
                            DbgPrint("State too small: %d\n", stateLength);
                        }
                        break;

                    case FtRedistribution:
                        if (stateLength <
                            sizeof(FT_REDISTRIBUTION_STATE_INFORMATION)) {

                            error = TRUE;
                            uniqueError = 18;
                            DbgPrint("Redist State too small: %d\n", stateLength);
                        }
                        break;

                }
            }

            if (error) {
                q = NULL;
            } else {
                if (!(q = GetLogicalDiskDescription(p->LogicalDiskId, 0))) {

                    for (q = LogicalDiskInformation->GetFirstLogicalDiskDescription();
                         q != p;
                         q = LogicalDiskInformation->GetNextLogicalDiskDescription(q)) {

                        if (q->LogicalDiskId == p->LogicalDiskId) {
                            break;
                        }
                    }

                    if (q == p) {
                        q = NULL;
                    }

                    if (q) {
                        for (r = q; r != p;
                             r = LogicalDiskInformation->
                             GetNextLogicalDiskDescription(r)) {

                            if (r->LogicalDiskId == p->LogicalDiskId) {
                                if (p->u.Other.ThisMemberNumber ==
                                    r->u.Other.ThisMemberNumber ||
                                    p->u.Other.ThisMemberLogicalDiskId ==
                                    r->u.Other.ThisMemberLogicalDiskId) {

                                    error = TRUE;
                                    uniqueError = 19;
                                    DbgPrint("Matching logical disks %I64x\n",
                                             p->LogicalDiskId);
                                    DbgPrint("have same member number %d, %d\n",
                                             p->u.Other.ThisMemberNumber,
                                             r->u.Other.ThisMemberNumber);
                                    DbgPrint("or same member disk id %I64x, %I64x\n",
                                             p->u.Other.ThisMemberLogicalDiskId,
                                             r->u.Other.ThisMemberLogicalDiskId);
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            if (q) {
                if (p->DiskDescriptionSize != q->DiskDescriptionSize ||
                    p->LogicalDiskType != q->LogicalDiskType ||
                    p->u.Other.NumberOfMembers !=
                    q->u.Other.NumberOfMembers ||
                    p->u.Other.ByteOffsetToConfigurationInformation !=
                    q->u.Other.ByteOffsetToConfigurationInformation ||
                    p->u.Other.ByteOffsetToStateInformation !=
                    q->u.Other.ByteOffsetToStateInformation) {

                    error = TRUE;
                    uniqueError = 20;
                    DbgPrint("Matching logical disks %I64x\n", p->LogicalDiskId);
                    DbgPrint("have different description size %d, %d\n",
                             p->DiskDescriptionSize, q->DiskDescriptionSize);
                    DbgPrint("or different logical disk type %d, %d\n",
                             p->LogicalDiskType, q->LogicalDiskType);
                    DbgPrint("or different number of members %d, %d\n",
                             p->u.Other.NumberOfMembers, q->u.Other.NumberOfMembers);
                    DbgPrint("or different offsets to config %d, %d\n",
                             p->u.Other.ByteOffsetToConfigurationInformation,
                             q->u.Other.ByteOffsetToConfigurationInformation);
                    DbgPrint("or different offsets to state %d, %d\n",
                             p->u.Other.ByteOffsetToStateInformation,
                             q->u.Other.ByteOffsetToStateInformation);
                }

                if (!error &&
                    p->u.Other.ByteOffsetToConfigurationInformation) {

                    pc = (PCHAR) p +
                         p->u.Other.ByteOffsetToConfigurationInformation;
                    qc = (PCHAR) q +
                         q->u.Other.ByteOffsetToConfigurationInformation;

                    if (RtlCompareMemory(pc, qc, configLength) !=
                        configLength) {

                        error = TRUE;
                        uniqueError = 21;
                        DbgPrint("Matching logical disks %I64x\n",
                                 p->LogicalDiskId);
                        DbgPrint("have different configuration information\n");
                    }
                }
            }

            if (!error) {

                for (i = 0; q = GetLogicalDiskDescription(p->LogicalDiskId, i);
                     i++) {

                    if (q->u.Other.ThisMemberLogicalDiskId ==
                        p->u.Other.ThisMemberLogicalDiskId &&
                        q->u.Other.ThisMemberNumber !=
                        p->u.Other.ThisMemberNumber) {

                        error = TRUE;
                        uniqueError = 22;
                        DbgPrint("Different members map to the same disk\n");
                        DbgPrint("--- %I64x, member %d and member %d\n",
                                 p->u.Other.ThisMemberLogicalDiskId,
                                 q->u.Other.ThisMemberNumber,
                                 p->u.Other.ThisMemberNumber);
                    }

                    if (q->u.Other.ThisMemberNumber ==
                        p->u.Other.ThisMemberNumber &&
                        q->u.Other.ThisMemberLogicalDiskId !=
                        p->u.Other.ThisMemberLogicalDiskId) {

                        error = TRUE;
                        uniqueError = 23;
                        DbgPrint("Member %d of %I64x is defined twice.\n",
                                 q->u.Other.ThisMemberNumber,
                                 p->LogicalDiskId);
                        DbgPrint("---- once as %I64x and then as %I64x.\n",
                                 q->u.Other.ThisMemberLogicalDiskId,
                                 p->u.Other.ThisMemberLogicalDiskId);
                    }
                }
            }
        }

        if (!error) {

            q = GetParentLogicalDiskDescription(p->LogicalDiskId);
            for (r = LogicalDiskInformation->
                 GetNextLogicalDiskDescription(p); r;
                 r = LogicalDiskInformation->
                 GetNextLogicalDiskDescription(r)) {

                if (r->LogicalDiskType != FtPartition &&
                    r->u.Other.ThisMemberLogicalDiskId ==
                    p->LogicalDiskId) {

                    break;
                }
            }

            if (q) {

                if (!r) {

                    // The set indicates that p->LogicalDiskId has a parent
                    // but this logical disk information does not have a
                    // parent.  Therefore, add a parent to match.

                    LogicalDiskInformation->AddLogicalDiskDescription(q);
                    LogicalDiskInformation->Write();

                } else if (q->LogicalDiskId != r->LogicalDiskId ||
                           q->u.Other.ThisMemberNumber !=
                           r->u.Other.ThisMemberNumber) {

                    error = TRUE;
                    uniqueError = 24;
                    DbgPrint("No parent on this disk info for %I64x\n",
                             p->LogicalDiskId);
                }

            } else if (r && GetLogicalDiskDescription(p->LogicalDiskId, 0)) {

                error = TRUE;
                uniqueError = 25;
                DbgPrint("Parent on this disk info that doesn't exist\n");
                DbgPrint("in the set.  %I64x\n", p->LogicalDiskId,
                r->LogicalDiskId);
            }
        }

        if (error) {

            FtpLogError(LogicalDiskInformation->GetRootExtension(),
                        LogicalDiskInformation->QueryDiskNumber(),
                        FT_CORRUPT_DISK_DESCRIPTION, STATUS_SUCCESS,
                        uniqueError);

            DbgPrint("Deleting logical disk description %I64x\n",
                     p->LogicalDiskId);
            DbgPrint("Description size = %d\n", p->DiskDescriptionSize);
            DbgPrint("Disk type = %d\n", p->LogicalDiskType);
            if (p->LogicalDiskType == FtPartition) {
                DbgPrint("Byte offset = %I64x\n", p->u.FtPartition.ByteOffset);
            } else {
                DbgPrint("This member = %I64x\n", p->u.Other.ThisMemberLogicalDiskId);
                DbgPrint("This member number = %d\n", p->u.Other.ThisMemberNumber);
                DbgPrint("Number of members = %d\n", p->u.Other.NumberOfMembers);
                DbgPrint("Offset to config = %d\n", p->u.Other.ByteOffsetToConfigurationInformation);
                DbgPrint("Offset to state = %d\n", p->u.Other.ByteOffsetToStateInformation);
            }

            LogicalDiskInformation->DeleteLogicalDiskDescription(p);
            LogicalDiskInformation->Write();
        } else {
            p = LogicalDiskInformation->GetNextLogicalDiskDescription(p);
            numEntries++;
        }
    }

    ExFreePool(layout);


    // Realloc the logical disk informations array.

    n = (PFT_LOGICAL_DISK_INFORMATION*)
        ExAllocatePool(NonPagedPool, sizeof(PFT_LOGICAL_DISK_INFORMATION)*
                       (_numberOfLogicalDiskInformations + 1));
    if (!n) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (_numberOfLogicalDiskInformations) {
        RtlMoveMemory(n, _arrayOfLogicalDiskInformations,
                      sizeof(PFT_LOGICAL_DISK_INFORMATION)*
                      _numberOfLogicalDiskInformations);
        ExFreePool(_arrayOfLogicalDiskInformations);
    }
    _arrayOfLogicalDiskInformations = n;


    // Realloc the root array so that it is at least large enough.

    if (!ReallocRootLogicalDiskIds(_numberOfRootLogicalDisksIds + numEntries)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    // Now add the logical disk information to this list.

    _arrayOfLogicalDiskInformations[_numberOfLogicalDiskInformations++] =
            LogicalDiskInformation;


    // Recompute the list of root disk ids.

    RecomputeArrayOfRootLogicalDiskIds();

    return STATUS_SUCCESS;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::RemoveLogicalDiskInformation(
    IN OUT  PDEVICE_OBJECT  WholeDiskPdo
    )

/*++

Routine Description:

    This routine removes the logical disk information associated with the
    given whole disk device object from the disk information set.

Arguments:

    WholeDiskPdo    - Supplies the device object.

Return Value:

    NTSTATUS

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        if (diskInfo->GetWholeDiskPdo() == WholeDiskPdo) {
            break;
        }
    }

    if (i == _numberOfLogicalDiskInformations) {
        return STATUS_NOT_FOUND;
    }

    _numberOfLogicalDiskInformations--;

    RtlMoveMemory(&_arrayOfLogicalDiskInformations[i],
                  &_arrayOfLogicalDiskInformations[i + 1],
                  (_numberOfLogicalDiskInformations - i)*
                  sizeof(PFT_LOGICAL_DISK_INFORMATION));

    RecomputeArrayOfRootLogicalDiskIds();

    delete diskInfo;

    return STATUS_SUCCESS;
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION_SET::IsDiskInSet(
    IN OUT  PDEVICE_OBJECT  WholeDiskPdo
    )

/*++

Routine Description:

    This routine removes the logical disk information associated with the
    given whole disk device object from the disk information set.

Arguments:

    WholeDiskPdo    - Supplies the device object.

Return Value:

    FALSE   - The PDO is not in the set.

    TRUE    - The PDO is in the set.

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        if (diskInfo->GetWholeDiskPdo() == WholeDiskPdo) {
            return TRUE;
        }
    }

    return FALSE;
}

PFT_LOGICAL_DISK_DESCRIPTION
FT_LOGICAL_DISK_INFORMATION_SET::GetLogicalDiskDescription(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  ULONG               InstanceNumber
    )

/*++

Routine Description:

    This routine returns the logical disk description for the given
    instance number and logical disk id.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

    InstanceNumber  - Supplies the instance number.

Return Value:

    A logical disk decription.

--*/

{
    ULONG                           i, instanceNumber;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    instanceNumber = 0;
    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
             p = diskInfo->GetNextLogicalDiskDescription(p)) {

            if (p->LogicalDiskId == LogicalDiskId) {
                if (InstanceNumber == instanceNumber) {
                    return p;
                } else {
                    instanceNumber++;
                }
            }
        }
    }

    return NULL;
}

ULONG
FT_LOGICAL_DISK_INFORMATION_SET::QueryNumberOfRootLogicalDiskIds(
    )

/*++

Routine Description:

    This routine returns the number of root logical disk ids.

Arguments:

    None.

Return Value:

    The number of root logical disk ids.

--*/

{
    return _numberOfRootLogicalDisksIds;
}

FT_LOGICAL_DISK_ID
FT_LOGICAL_DISK_INFORMATION_SET::QueryRootLogicalDiskId(
    IN  ULONG   Index
    )

/*++

Routine Description:

    This routine returns the 'Index'th root logical disk id.

Arguments:

    Index   - Supplies the 0 based index.

Return Value:

    The 'Index'th root logical disk id.

--*/

{
    if (Index >= _numberOfRootLogicalDisksIds) {
        return 0;
    }

    return _arrayOfRootLogicalDiskIds[Index];
}

FT_LOGICAL_DISK_ID
FT_LOGICAL_DISK_INFORMATION_SET::QueryRootLogicalDiskIdForContainedPartition(
    IN  ULONG       DiskNumber,
    IN  LONGLONG    Offset
    )

/*++

Routine Description:

    This routine returns the root logical disk id of the logical disk that
    contains the given partition.

Arguments:

    DiskNumber  - Supplies the disk number of the whole disk
                    of the partition.

    Offset      - Supplies the offset of the partition.

Return Value:

    The logical disk id of the root disk containing the given partition or 0.

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;
    FT_LOGICAL_DISK_ID              id;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        if (diskInfo->QueryDiskNumber() == DiskNumber) {
            break;
        }
    }

    if (i == _numberOfLogicalDiskInformations) {
        return 0;
    }

    id = 0;
    for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
         p = diskInfo->GetNextLogicalDiskDescription(p)) {

        if (id) {
            if (p->LogicalDiskType != FtPartition &&
                p->u.Other.ThisMemberLogicalDiskId == id) {

                id = p->LogicalDiskId;
            }
        } else {
            if (p->LogicalDiskType == FtPartition &&
                p->u.FtPartition.ByteOffset == Offset) {

                id = p->LogicalDiskId;
            }
        }
    }

    return id;
}

FT_LOGICAL_DISK_ID
FT_LOGICAL_DISK_INFORMATION_SET::QueryPartitionLogicalDiskId(
    IN  ULONG       DiskNumber,
    IN  LONGLONG    Offset
    )

/*++

Routine Description:

    This routine returns the logical disk id for the given partition.

Arguments:

    DiskNumber  - Supplies the disk number of the whole disk
                    of the partition.

    Offset      - Supplies the offset of the partition.

Return Value:

    A logical disk id or 0.

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        if (diskInfo->QueryDiskNumber() == DiskNumber) {
            break;
        }
    }

    if (i == _numberOfLogicalDiskInformations) {
        return 0;
    }

    for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
         p = diskInfo->GetNextLogicalDiskDescription(p)) {

        if (p->LogicalDiskType == FtPartition &&
            p->u.FtPartition.ByteOffset == Offset) {

            return p->LogicalDiskId;
        }
    }

    return 0;
}

USHORT
FT_LOGICAL_DISK_INFORMATION_SET::QueryNumberOfMembersInLogicalDisk(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine returns the number of members in a logical disk.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

Return Value:

    The number of members in a logical disk.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    p = GetLogicalDiskDescription(LogicalDiskId, 0);
    if (!p) {
        ASSERT(FALSE);
        return 0;
    }

    if (p->LogicalDiskType == FtPartition) {
        return 0;
    }

    return p->u.Other.NumberOfMembers;
}

FT_LOGICAL_DISK_ID
FT_LOGICAL_DISK_INFORMATION_SET::QueryMemberLogicalDiskId(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  USHORT              MemberNumber
    )

/*++

Routine Description:

    This routine returns the logical disk id for the given member number.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

    MemberNumber    - Supplies the requested member number.

Return Value:

    The logical disk id of the given member number.

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
             p = diskInfo->GetNextLogicalDiskDescription(p)) {

            if (p->LogicalDiskId == LogicalDiskId) {
                ASSERT(p->LogicalDiskType != FtPartition);
                if (p->u.Other.ThisMemberNumber == MemberNumber) {
                    return p->u.Other.ThisMemberLogicalDiskId;
                }
            }
        }
    }

    return 0;
}

FT_LOGICAL_DISK_TYPE
FT_LOGICAL_DISK_INFORMATION_SET::QueryLogicalDiskType(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine returns the logical disk type for the given logical disk
    id.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

Return Value:

    The logical disk type for the given logical disk id.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    p = GetLogicalDiskDescription(LogicalDiskId, 0);
    if (!p) {
        ASSERT(FALSE);
        return FtPartition;
    }

    return p->LogicalDiskType;
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION_SET::QueryFtPartitionInformation(
    IN  FT_LOGICAL_DISK_ID  PartitionLogicalDiskId,
    OUT PLONGLONG           Offset,
    OUT PDEVICE_OBJECT*     WholeDisk,
    OUT PULONG              DiskNumber,
    OUT PULONG              SectorSize,
    OUT PLONGLONG           PartitionSize
    )

/*++

Routine Description:

    This routine returns information about the given partition.

Arguments:

    PartitionLogicalDiskId  - Supplies the logical disk id.

    Offset                  - Returns the partition offset.

    WholeDisk               - Returns the whole disk device object.

    DiskNumber              - Returns the disk number.

    SectorSize              - Returns the sector size.

    PartitionSize           - Returns the partition size.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    ULONG                           i, instanceNumber;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    instanceNumber = 0;
    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
             p = diskInfo->GetNextLogicalDiskDescription(p)) {

            if (p->LogicalDiskId == PartitionLogicalDiskId) {
                if (p->LogicalDiskType != FtPartition) {
                    return FALSE;
                }
                if (Offset) {
                    *Offset = p->u.FtPartition.ByteOffset;
                }
                if (WholeDisk) {
                    *WholeDisk = diskInfo->GetWholeDisk();
                }
                if (DiskNumber) {
                    *DiskNumber = diskInfo->QueryDiskNumber();
                }
                if (SectorSize) {
                    *SectorSize = diskInfo->QuerySectorSize();
                }
                if (PartitionSize) {
                    *PartitionSize = p->u.FtPartition.PartitionSize;
                }
                return TRUE;
            }
        }
    }

    return FALSE;
}

PVOID
FT_LOGICAL_DISK_INFORMATION_SET::GetConfigurationInformation(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine returns a pointer to the configuration information
    for the given logical disk.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

Return Value:

    A pointer to the configuration information for the given logical disk.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    p = GetLogicalDiskDescription(LogicalDiskId, 0);
    if (!p) {
        ASSERT(FALSE);
        return NULL;
    }

    if (p->LogicalDiskType == FtPartition) {
        ASSERT(FALSE);
        return NULL;
    }

    if (!p->u.Other.ByteOffsetToConfigurationInformation) {
        return NULL;
    }

    return ((PCHAR) p + p->u.Other.ByteOffsetToConfigurationInformation);
}

PVOID
FT_LOGICAL_DISK_INFORMATION_SET::GetStateInformation(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine returns a pointer to the state information
    for the given logical disk.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

Return Value:

    A pointer to the state information for the given logical disk.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    p = GetLogicalDiskDescription(LogicalDiskId, 0);
    if (!p) {
        ASSERT(FALSE);
        return NULL;
    }

    if (p->LogicalDiskType == FtPartition ||
        !p->u.Other.ByteOffsetToStateInformation) {

        return NULL;
    }

    return ((PCHAR) p + p->u.Other.ByteOffsetToStateInformation);
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION_SET::IsLogicalDiskComplete(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine computes whether or not a given logical disk is
    complete.  In other words, whether or not it has all of its members
    and its members' members etc...

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

Return Value:

    FALSE   - This logical disk is not complete.

    TRUE    - This logical disk is complete.

--*/

{
    USHORT              numMembers, i;
    FT_LOGICAL_DISK_ID  memberDiskId;

    numMembers = QueryNumberOfMembersInLogicalDisk(LogicalDiskId);
    for (i = 0; i < numMembers; i++) {
        memberDiskId = QueryMemberLogicalDiskId(LogicalDiskId, i);
        if (!memberDiskId || !IsLogicalDiskComplete(memberDiskId)) {
            return FALSE;
        }
    }

    return TRUE;
}

UCHAR
FT_LOGICAL_DISK_INFORMATION_SET::QueryDriveLetter(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine returns the drive letter for the given logical disk.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

Return Value:

    The drive letter or 0.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    p = GetLogicalDiskDescription(LogicalDiskId, 0);
    if (!p) {
        return 0;
    }

    return p->DriveLetter;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::SetDriveLetter(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  UCHAR               DriveLetter
    )

/*++

Routine Description:

    This routine sets the drive letter for the given logical disk.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

    DriveLetter     - Supplies the drive letter.

Return Value:

    NTSTATUS

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;
    BOOLEAN                         found;

    found = FALSE;
    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
             p = diskInfo->GetNextLogicalDiskDescription(p)) {

            if (p->LogicalDiskId == LogicalDiskId) {
                p->DriveLetter = DriveLetter;
                diskInfo->Write();
                found = TRUE;
            }
        }
    }

    return found ? STATUS_SUCCESS : STATUS_OBJECT_NAME_NOT_FOUND;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::WriteStateInformation(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  PVOID               LogicalDiskState,
    IN  USHORT              LogicalDiskStateSize
    )

/*++

Routine Description:

    This routine writes out the given state information to all on
    disk instances of the given logical disk.  If one of the instances
    fails to commit to disk, this routine will continue to write out
    all that it can and then return the error that it received.

Arguments:

    LogicalDiskId           - Supplies the logical disk id.

    LogicalDiskState        - Supplies the logical disk state to write.

    LogicalDiskStateSize    - Supplies the number of bytes in the given
                                logical disk state.

Return Value:

    NTSTATUS

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
             p = diskInfo->GetNextLogicalDiskDescription(p)) {

            if (p->LogicalDiskId == LogicalDiskId) {
                ASSERT(p->LogicalDiskType != FtPartition);
                ASSERT(p->u.Other.ByteOffsetToStateInformation);

                RtlMoveMemory((PCHAR) p +
                              p->u.Other.ByteOffsetToStateInformation,
                              LogicalDiskState,
                              LogicalDiskStateSize);

                diskInfo->Write();
            }
        }
    }

    FtpCopyStateToRegistry(LogicalDiskId, LogicalDiskState,
                           LogicalDiskStateSize);

    return STATUS_SUCCESS;
}

FT_LOGICAL_DISK_ID
GenerateNewLogicalDiskId(
    )

/*++

Routine Description:

    This routine computes a new, random, unique, logical disk id for
    use to identify a new logical disk.

Arguments:

    None.

Return Value:

    A new logical disk id.

--*/

{
    NTSTATUS                status;
    UUID                    uuid;
    PUCHAR                  p;
    FT_LOGICAL_DISK_ID      diskId;
    static LARGE_INTEGER    lastSystemTime;
    LARGE_INTEGER           x;
    ULONG                   i;

    status = ExUuidCreate(&uuid);
    if (NT_SUCCESS(status)) {

        p = (PUCHAR) &uuid;
        diskId = (*((PFT_LOGICAL_DISK_ID) p)) ^
                 (*((PFT_LOGICAL_DISK_ID) (p + sizeof(FT_LOGICAL_DISK_ID))));

        return diskId;
    }

    x.QuadPart = 0;
    while (x.QuadPart == 0) {
        for (;;) {
            KeQuerySystemTime(&x);
            if (x.QuadPart != lastSystemTime.QuadPart) {
                break;
            }
        }
        lastSystemTime.QuadPart = x.QuadPart;
        p = (PUCHAR) &x.QuadPart;
        for (i = 0; i < sizeof(LONGLONG); i++) {
            x.QuadPart += *p++;
            x.QuadPart = (x.QuadPart >> 2) + (x.QuadPart << 62);
        }
    }

    return x.QuadPart;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::CreatePartitionLogicalDisk(
    IN  ULONG               DiskNumber,
    IN  LONGLONG            PartitionOffset,
    IN  LONGLONG            PartitionSize,
    OUT PFT_LOGICAL_DISK_ID NewLogicalDiskId
    )

/*++

Routine Description:

    This routine takes a DOS partition and assigns it a logical disk id.

Arguments:

    DiskNumber          - Supplies the disk number where the partition
                                resides.

    PartitionOffset     - Supplies the partition offset.

    PartitionSize       - Supplies the partition size.

    NewLogicalDiskId    - Returns the logical disk id.

Return Value:

    NTSTATUS

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    newLogicalDiskDescription, p;
    NTSTATUS                        status;

    // Find the disk information for the given device object.

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        if (diskInfo->QueryDiskNumber() == DiskNumber) {
            break;
        }
    }

    if (i == _numberOfLogicalDiskInformations) {
        return STATUS_INVALID_PARAMETER;
    }


    // Generate a new logical disk id for this one.

    *NewLogicalDiskId = GenerateNewLogicalDiskId();


    // Allocate and set up a new logical disk description.

    newLogicalDiskDescription = (PFT_LOGICAL_DISK_DESCRIPTION)
            ExAllocatePool(PagedPool, sizeof(FT_LOGICAL_DISK_DESCRIPTION));
    if (!newLogicalDiskDescription) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    newLogicalDiskDescription->DiskDescriptionSize =
            sizeof(FT_LOGICAL_DISK_DESCRIPTION);
    newLogicalDiskDescription->DriveLetter = 0;
    newLogicalDiskDescription->Reserved = 0;
    newLogicalDiskDescription->LogicalDiskType = FtPartition;
    newLogicalDiskDescription->LogicalDiskId = *NewLogicalDiskId;
    newLogicalDiskDescription->u.FtPartition.ByteOffset = PartitionOffset;
    newLogicalDiskDescription->u.FtPartition.PartitionSize = PartitionSize;


    // Check for enough free disk space.

    if (newLogicalDiskDescription->DiskDescriptionSize >
        diskInfo->QueryDiskDescriptionFreeSpace()) {

        FtpLogError(diskInfo->GetRootExtension(),
                    diskInfo->QueryDiskNumber(),
                    FT_NOT_ENOUGH_ON_DISK_SPACE, STATUS_DISK_FULL, 0);

        ExFreePool(newLogicalDiskDescription);
        return STATUS_DISK_FULL;
    }


    // Now allocate the memory that we need to store this new logical
    // disk.

    if (!ReallocRootLogicalDiskIds(_numberOfRootLogicalDisksIds + 1)) {
        ExFreePool(newLogicalDiskDescription);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    // Write out the disk description.

    p = diskInfo->AddLogicalDiskDescription(newLogicalDiskDescription);
    ASSERT(p);

    ExFreePool(newLogicalDiskDescription);

    status = diskInfo->Write();
    if (!NT_SUCCESS(status)) {
        BreakLogicalDisk(*NewLogicalDiskId);
        return status;
    }


    // Fix up the list of root entries.

    RecomputeArrayOfRootLogicalDiskIds();

    return status;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::AddNewLogicalDisk(
    IN  FT_LOGICAL_DISK_TYPE    NewLogicalDiskType,
    IN  USHORT                  NumberOfMembers,
    IN  PFT_LOGICAL_DISK_ID     ArrayOfMembers,
    IN  USHORT                  ConfigurationInformationSize,
    IN  PVOID                   ConfigurationInformation,
    IN  USHORT                  StateInformationSize,
    IN  PVOID                   StateInformation,
    OUT PFT_LOGICAL_DISK_ID     NewLogicalDiskId
    )

/*++

Routine Description:

    This routine adds the given logical disk to the system.

Arguments:

    NewLogicalDiskType              - Supplies the logical disk type of the
                                        new logical disk.

    NumberOfMembers                 - Supplies the number of members contained
                                        in the new logical disk.

    ArrayOfMembers                  - Supplies the array of members.

    ConfigurationInformationSize    - Supplies the configuration information
                                        size.

    ConfigurationInformation        - Supplies the configuration information.

    StateInformationSize            - Supplies the state information size.

    StateInformation                - Supplies the state information.

    NewLogicalDiskId                - Returns the new logical disk id.

Return Value:

    NTSTATUS

--*/

{
    ULONG                                   i, j;
    USHORT                                  size;
    UCHAR                                   driveLetter;
    PFT_LOGICAL_DISK_DESCRIPTION            newLogicalDiskDescription;
    PFT_LOGICAL_DISK_INFORMATION            diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION            p, q;
    NTSTATUS                                status;
    ULONG                                   numInstancesInThisInfo;
    WCHAR                                   name[3];

    if (NewLogicalDiskType == FtPartition) {
        return STATUS_INVALID_PARAMETER;
    }


    // First make sure that the members are all root logical disks and
    // are complete.

    for (i = 0; i < NumberOfMembers; i++) {
        if (!ArrayOfMembers[i]) {
            continue;
        }

        for (j = 0; j < _numberOfRootLogicalDisksIds; j++) {
            if (ArrayOfMembers[i] == _arrayOfRootLogicalDiskIds[j]) {
                break;
            }
        }

        if (j == _numberOfRootLogicalDisksIds) {
            return STATUS_INVALID_PARAMETER;
        }

        if (!IsLogicalDiskComplete(ArrayOfMembers[i])) {
            return STATUS_INVALID_PARAMETER;
        }
    }


    // In the mirror, volume set, and redist cases.  Save the
    // drive letter of the first member.

    if (NewLogicalDiskType == FtVolumeSet ||
        NewLogicalDiskType == FtMirrorSet ||
        NewLogicalDiskType == FtRedistribution) {

        driveLetter = QueryDriveLetter(ArrayOfMembers[0]);

    } else {
        driveLetter = 0;
    }

    for (i = 0; i < NumberOfMembers; i++) {
        SetDriveLetter(ArrayOfMembers[i], 0);
    }

    *NewLogicalDiskId = GenerateNewLogicalDiskId();


    // Construct the disk description record.

    size = sizeof(FT_LOGICAL_DISK_DESCRIPTION) +
           ConfigurationInformationSize + StateInformationSize;

    size = (size + FILE_QUAD_ALIGNMENT)&(~FILE_QUAD_ALIGNMENT);

    newLogicalDiskDescription = (PFT_LOGICAL_DISK_DESCRIPTION)
                                ExAllocatePool(PagedPool, size);
    if (!newLogicalDiskDescription) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    newLogicalDiskDescription->DiskDescriptionSize = size;
    newLogicalDiskDescription->DriveLetter = driveLetter;
    newLogicalDiskDescription->Reserved = 0;
    newLogicalDiskDescription->LogicalDiskType = NewLogicalDiskType;
    newLogicalDiskDescription->LogicalDiskId = *NewLogicalDiskId;
    newLogicalDiskDescription->u.Other.ThisMemberLogicalDiskId = 0;
    newLogicalDiskDescription->u.Other.ThisMemberNumber = 0;
    newLogicalDiskDescription->u.Other.NumberOfMembers = NumberOfMembers;
    if (ConfigurationInformationSize) {
        newLogicalDiskDescription->u.Other.
                ByteOffsetToConfigurationInformation =
                sizeof(FT_LOGICAL_DISK_DESCRIPTION);
        RtlMoveMemory((PCHAR) newLogicalDiskDescription +
                      newLogicalDiskDescription->u.Other.
                      ByteOffsetToConfigurationInformation,
                      ConfigurationInformation,
                      ConfigurationInformationSize);
    } else {
        newLogicalDiskDescription->u.Other.
                ByteOffsetToConfigurationInformation = 0;
    }
    if (StateInformationSize) {
        newLogicalDiskDescription->u.Other.ByteOffsetToStateInformation =
                sizeof(FT_LOGICAL_DISK_DESCRIPTION) +
                ConfigurationInformationSize;
        RtlMoveMemory((PCHAR) newLogicalDiskDescription +
                      newLogicalDiskDescription->u.Other.
                      ByteOffsetToStateInformation,
                      StateInformation,
                      StateInformationSize);
    } else {
        newLogicalDiskDescription->u.Other.ByteOffsetToStateInformation = 0;
    }


    // Figure out how many instances we're going to need and check to make
    // sure that there is enough disk space for all of the instances.

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];

        numInstancesInThisInfo = 0;
        for (j = 0; j < NumberOfMembers; j++) {
            for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
                 p = diskInfo->GetNextLogicalDiskDescription(p)) {

                if (p->LogicalDiskId == ArrayOfMembers[j]) {
                    break;
                }
            }

            if (p) {
                numInstancesInThisInfo++;
            }
        }

        if (numInstancesInThisInfo) {
            if (numInstancesInThisInfo*
                newLogicalDiskDescription->DiskDescriptionSize >
                diskInfo->QueryDiskDescriptionFreeSpace()) {

                FtpLogError(diskInfo->GetRootExtension(),
                            diskInfo->QueryDiskNumber(),
                            FT_NOT_ENOUGH_ON_DISK_SPACE, STATUS_DISK_FULL, 0);

                ExFreePool(newLogicalDiskDescription);
                return STATUS_DISK_FULL;
            }
        }
    }


    // Now allocate the memory that we need to store this new logical
    // disk.

    if (!ReallocRootLogicalDiskIds(_numberOfRootLogicalDisksIds + 1)) {
        ExFreePool(newLogicalDiskDescription);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    // Now that we have the memory and disk space we can proceed with
    // the changes.  First fix up the logical disk entries and write out
    // the structures to disk.

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];

        for (j = 0; j < NumberOfMembers; j++) {
            for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
                 p = diskInfo->GetNextLogicalDiskDescription(p)) {

                if (p->LogicalDiskId == ArrayOfMembers[j]) {
                    break;
                }
            }

            if (p) {
                newLogicalDiskDescription->u.Other.
                        ThisMemberLogicalDiskId = ArrayOfMembers[j];
                newLogicalDiskDescription->u.Other.ThisMemberNumber =
                    (USHORT) j;

                q = diskInfo->AddLogicalDiskDescription(
                        newLogicalDiskDescription);
                ASSERT(q);

                status = diskInfo->Write();
                if (!NT_SUCCESS(status)) {
                    BreakLogicalDisk(*NewLogicalDiskId);
                    ExFreePool(newLogicalDiskDescription);
                    return status;
                }
            }
        }
    }

    ExFreePool(newLogicalDiskDescription);


    // Fix up the list of root entries.

    RecomputeArrayOfRootLogicalDiskIds();

    return STATUS_SUCCESS;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::BreakLogicalDisk(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine breaks the given logical disk into its members.

Arguments:

    LogicalDiskId   - Supplies the root logical disk id to break.

Return Value:

    NTSTATUS

--*/

{
    ULONG                                   i, j, numMembers;
    PFT_LOGICAL_DISK_DESCRIPTION            p;
    FT_LOGICAL_DISK_TYPE                    diskType;
    UCHAR                                   driveLetter;
    PFT_MIRROR_AND_SWP_STATE_INFORMATION    state;
    FT_LOGICAL_DISK_ID                      mainMember;
    NTSTATUS                                status;
    PFT_LOGICAL_DISK_INFORMATION            diskInfo;

    // First make sure that the given logical disk id is a root.

    for (i = 0; i < _numberOfRootLogicalDisksIds; i++) {
        if (LogicalDiskId == _arrayOfRootLogicalDiskIds[i]) {
            break;
        }
    }

    if (i == _numberOfRootLogicalDisksIds) {
        return STATUS_INVALID_PARAMETER;
    }


    // Allocate the memory needed to grow the list of roots.

    p = GetLogicalDiskDescription(LogicalDiskId, 0);
    ASSERT(p);

    diskType = p->LogicalDiskType;
    driveLetter = p->DriveLetter;
    if (diskType == FtPartition) {
        numMembers = 0;
    } else {
        numMembers = p->u.Other.NumberOfMembers;
    }

    if (!ReallocRootLogicalDiskIds(_numberOfRootLogicalDisksIds + numMembers)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    DeleteFtRegistryInfo(LogicalDiskId);

    if (diskType == FtMirrorSet) {

        state = (PFT_MIRROR_AND_SWP_STATE_INFORMATION)
                GetStateInformation(LogicalDiskId);
        ASSERT(state);

        if (state->UnhealthyMemberState == FtMemberHealthy ||
            state->UnhealthyMemberNumber == 1) {

            mainMember = QueryMemberLogicalDiskId(LogicalDiskId, 0);
        } else {
            mainMember = QueryMemberLogicalDiskId(LogicalDiskId, 1);
        }

        SetDriveLetter(mainMember, driveLetter);
    }

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];

        p = diskInfo->GetFirstLogicalDiskDescription();
        while (p) {
            if (p->LogicalDiskId == LogicalDiskId) {

                diskInfo->DeleteLogicalDiskDescription(p);
                if (!p->DiskDescriptionSize) {
                    p = NULL;
                }
                diskInfo->Write();

            } else {
                p = diskInfo->GetNextLogicalDiskDescription(p);
            }
        }
    }

    FtpDeleteStateInRegistry(LogicalDiskId);


    // Recompute the list of roots.

    RecomputeArrayOfRootLogicalDiskIds();

    return STATUS_SUCCESS;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::ReplaceLogicalDiskMember(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  USHORT              MemberNumberToReplace,
    IN  FT_LOGICAL_DISK_ID  NewMemberLogicalDiskId,
    OUT PFT_LOGICAL_DISK_ID NewLogicalDiskId
    )

/*++

Routine Description:

    This routine replaces the given member with the new given member.

Arguments:

    LogicalDiskId           - Supplies the logical disk whose member we are
                                going to replace.

    MemberNumberToReplace   - Supplies the member number to replace.

    NewMemberLogicalDiskId  - Supplies the new member.

    NewLogicalDiskId        - Returns the new logical disk id for the set
                                containing the new member.

Return Value:

    NTSTATUS

--*/

{
    ULONG                               i, j, numInstances, n;
    PFT_LOGICAL_DISK_ID                 oldLogicalDiskIds;
    PFT_LOGICAL_DISK_ID                 newLogicalDiskIds;
    PFT_LOGICAL_DISK_DESCRIPTION        p, q, newDiskDescription;
    PFT_LOGICAL_DISK_INFORMATION        diskInfo;
    NTSTATUS                            status;
    BOOLEAN                             wroteLog;
    FT_LOGICAL_DISK_ID                  replacedMemberDiskId, child;
    UCHAR                               state[100];
    USHORT                              stateSize;


    // Make sure that the replacement is a root and is complete.

    for (i = 0; i < _numberOfRootLogicalDisksIds; i++) {
        if (NewMemberLogicalDiskId == _arrayOfRootLogicalDiskIds[i]) {
            break;
        }
    }

    if (i == _numberOfRootLogicalDisksIds ||
        !IsLogicalDiskComplete(NewMemberLogicalDiskId)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (!ReallocRootLogicalDiskIds(_numberOfRootLogicalDisksIds + 1)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    DeleteFtRegistryInfo(LogicalDiskId);


    // Figure out 'n' where n is how many new logical disk ids we need.

    if (!ComputeNewParentLogicalDiskIds(LogicalDiskId, &n,
                                        &oldLogicalDiskIds,
                                        &newLogicalDiskIds)) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    // Copy back the new logical disk id.

    *NewLogicalDiskId = newLogicalDiskIds[0];


    // Figure out the logical disk id of the member to replace.

    replacedMemberDiskId = QueryMemberLogicalDiskId(LogicalDiskId,
                                                    MemberNumberToReplace);


    // Build up the new member into a new tree that will eventually
    // replace the old tree of which this logical disk is a member.

    for (i = 0; i < n; i++) {

        if (i == 0) {
            p = GetLogicalDiskDescription(oldLogicalDiskIds[i], 0);
        } else {
            p = GetParentLogicalDiskDescription(oldLogicalDiskIds[i - 1]);
        }
        if (!p || p->LogicalDiskType == FtPartition) {
            ExFreePool(oldLogicalDiskIds);
            ExFreePool(newLogicalDiskIds);
            return STATUS_INVALID_PARAMETER;
        }

        newDiskDescription = (PFT_LOGICAL_DISK_DESCRIPTION)
                             ExAllocatePool(PagedPool, p->DiskDescriptionSize);
        if (!newDiskDescription) {
            ExFreePool(oldLogicalDiskIds);
            ExFreePool(newLogicalDiskIds);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlMoveMemory(newDiskDescription, p, p->DiskDescriptionSize);
        newDiskDescription->LogicalDiskId = newLogicalDiskIds[i];
        if (i == 0) {
            newDiskDescription->u.Other.ThisMemberLogicalDiskId =
                    NewMemberLogicalDiskId;
            newDiskDescription->u.Other.ThisMemberNumber =
                    MemberNumberToReplace;
        } else {
            newDiskDescription->u.Other.ThisMemberLogicalDiskId =
                    newLogicalDiskIds[i - 1];
        }

        for (j = 0; j < _numberOfLogicalDiskInformations; j++) {

            diskInfo = _arrayOfLogicalDiskInformations[j];

            for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
                 p = diskInfo->GetNextLogicalDiskDescription(p)) {

                if (p->LogicalDiskId !=
                    newDiskDescription->u.Other.ThisMemberLogicalDiskId) {

                    continue;
                }

                if (!diskInfo->AddLogicalDiskDescription(newDiskDescription)) {

                    FtpLogError(diskInfo->GetRootExtension(),
                                diskInfo->QueryDiskNumber(),
                                FT_NOT_ENOUGH_ON_DISK_SPACE, STATUS_DISK_FULL,
                                0);

                    ExFreePool(newDiskDescription);
                    ExFreePool(oldLogicalDiskIds);
                    ExFreePool(newLogicalDiskIds);
                    return STATUS_DISK_FULL;
                }

                status = diskInfo->Write();
                if (!NT_SUCCESS(status)) {
                    ExFreePool(newDiskDescription);
                    ExFreePool(oldLogicalDiskIds);
                    ExFreePool(newLogicalDiskIds);
                    return status;
                }
                break;
            }
        }

        ExFreePool(newDiskDescription);
    }


    // Substitute new logical disk ids for old ones, logging the operation
    // for a safe backout in the event of a crash.

    status = STATUS_SUCCESS;
    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        wroteLog = FALSE;
        for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
             p = diskInfo->GetNextLogicalDiskDescription(p)) {

            if (p->LogicalDiskType != FtPartition) {
                continue;
            }

            child = p->LogicalDiskId;

            for (q = diskInfo->GetNextLogicalDiskDescription(p); q;
                 q = diskInfo->GetNextLogicalDiskDescription(q)) {

                if (q->LogicalDiskType == FtPartition ||
                    q->u.Other.ThisMemberLogicalDiskId != child) {

                    continue;
                }

                if (q->LogicalDiskId == LogicalDiskId &&
                    q->u.Other.ThisMemberNumber == MemberNumberToReplace) {

                    break;
                }

                child = q->LogicalDiskId;
            }

            if (q) {
                continue;
            }

            child = p->LogicalDiskId;

            for (q = diskInfo->GetNextLogicalDiskDescription(p); q;
                 q = diskInfo->GetNextLogicalDiskDescription(q)) {

                if (q->LogicalDiskType == FtPartition ||
                    q->u.Other.ThisMemberLogicalDiskId != child) {

                    continue;
                }

                child = q->LogicalDiskId;

                for (j = 0; j < n; j++) {
                    if (q->LogicalDiskId == oldLogicalDiskIds[j]) {
                        if (!wroteLog) {
                            diskInfo->AddReplaceLog(replacedMemberDiskId,
                                                    NewMemberLogicalDiskId,
                                                    n, oldLogicalDiskIds,
                                                    newLogicalDiskIds);
                            wroteLog = TRUE;
                        }
                        q->LogicalDiskId = newLogicalDiskIds[j];
                    } else if (q->u.Other.ThisMemberLogicalDiskId ==
                               oldLogicalDiskIds[j]) {
                        if (!wroteLog) {
                            diskInfo->AddReplaceLog(replacedMemberDiskId,
                                                    NewMemberLogicalDiskId,
                                                    n, oldLogicalDiskIds,
                                                    newLogicalDiskIds);
                            wroteLog = TRUE;
                        }
                        q->u.Other.ThisMemberLogicalDiskId =
                                newLogicalDiskIds[j];
                    }
                }
            }
        }

        if (wroteLog) {
            status = diskInfo->Write();
            if (!NT_SUCCESS(status)) {
                break;
            }
        }
    }

    if (NT_SUCCESS(status)) {
        for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
            diskInfo = _arrayOfLogicalDiskInformations[i];
            if (diskInfo->ClearReplaceLog()) {
                diskInfo->Write();
            }
        }

        // Erase all logical disk descriptions that contain the old
        // logical disk ids.

        for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
            diskInfo = _arrayOfLogicalDiskInformations[i];

            for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
                 p = diskInfo->GetNextLogicalDiskDescription(p)) {

                for (j = 0; j < n; j++) {
                    if (p->LogicalDiskId == oldLogicalDiskIds[j]) {
                        diskInfo->DeleteLogicalDiskDescription(p);
                        diskInfo->Write();
                    }
                }
            }
        }

        for (i = 0; i < n; i++) {
            if (FtpQueryStateFromRegistry(oldLogicalDiskIds[i], state, 100,
                                          &stateSize)) {

                FtpDeleteStateInRegistry(oldLogicalDiskIds[i]);
                FtpCopyStateToRegistry(newLogicalDiskIds[i], state, stateSize);
            }
        }

    } else {
        for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
            diskInfo = _arrayOfLogicalDiskInformations[i];
            if (diskInfo->BackOutReplaceOperation()) {
                diskInfo->Write();
            }
        }

        RecomputeArrayOfRootLogicalDiskIds();
        for (i = n; i > 0; i--) {
            BreakLogicalDisk(newLogicalDiskIds[i - 1]);
        }
    }

    ExFreePool(oldLogicalDiskIds);
    ExFreePool(newLogicalDiskIds);


    // Recompute list of root entries.

    RecomputeArrayOfRootLogicalDiskIds();

    return status;
}

FT_LOGICAL_DISK_TYPE
TranslateFtDiskType(
    IN  FT_TYPE FtType
    )

{
    switch (FtType) {
        case Mirror:
            return FtMirrorSet;

        case Stripe:
            return FtStripeSet;

        case StripeWithParity:
            return FtStripeSetWithParity;

        case VolumeSet:
            return FtVolumeSet;

    }

    return FtPartition;
}

PFT_DESCRIPTION
GetFtDescription(
    IN  PDISK_CONFIG_HEADER Registry,
    IN  PDISK_PARTITION     DiskPartition
    )

{
    ULONG                   diskPartitionOffset;
    PFT_REGISTRY            ftRegistry;
    PFT_DESCRIPTION         ftDescription;
    USHORT                  i, j;
    PFT_MEMBER_DESCRIPTION  ftMember;

    diskPartitionOffset = (ULONG) ((PUCHAR) DiskPartition - (PUCHAR) Registry);
    ftRegistry = (PFT_REGISTRY) ((PUCHAR) Registry +
                                 Registry->FtInformationOffset);
    ftDescription = &ftRegistry->FtDescription[0];
    for (i = 0; i < ftRegistry->NumberOfComponents; i++) {
        for (j = 0; j < ftDescription->NumberOfMembers; j++) {
            ftMember = &ftDescription->FtMemberDescription[j];
            if (ftMember->OffsetToPartitionInfo == diskPartitionOffset) {
                return ftDescription;
            }
        }
        ftDescription = (PFT_DESCRIPTION) &ftDescription->FtMemberDescription[
                        ftDescription->NumberOfMembers];
    }

    return NULL;
}

USHORT
GetRegistryNumberOfMembers(
    IN  PDISK_CONFIG_HEADER Registry,
    IN  PDISK_PARTITION     DiskPartition
    )

{
    PFT_DESCRIPTION ftDescription;

    ftDescription = GetFtDescription(Registry, DiskPartition);
    if (!ftDescription) {
        return 0;
    }

    return ftDescription->NumberOfMembers;
}

ULONG
FT_LOGICAL_DISK_INFORMATION_SET::DiskNumberFromSignature(
    IN  ULONG   Signature
    )

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        if (Signature == FtpQueryDiskSignature(diskInfo->GetWholeDiskPdo())) {
            return diskInfo->QueryDiskNumber();
        }
    }

    return 0xFFFFFFFF;
}

VOID
DeleteFtRegistryInformation(
    IN  PDISK_CONFIG_HEADER Registry,
    IN  PDISK_PARTITION     DiskPartition
    )

{
    PFT_DESCRIPTION         ftDescription, next;
    USHORT                  i;
    PFT_MEMBER_DESCRIPTION  ftMember;
    PDISK_PARTITION         diskPartition;
    PFT_REGISTRY            ftRegistry;

    ftDescription = GetFtDescription(Registry, DiskPartition);
    if (!ftDescription) {
        return;
    }

    for (i = 0; i < ftDescription->NumberOfMembers; i++) {
        ftMember = &ftDescription->FtMemberDescription[i];
        diskPartition = (PDISK_PARTITION) ((PUCHAR) Registry +
                        ftMember->OffsetToPartitionInfo);

        diskPartition->FtType = NotAnFtMember;
        diskPartition->FtState = Healthy;
        RtlZeroMemory(&diskPartition->FtLength.QuadPart, sizeof(LONGLONG));
        diskPartition->FtGroup = (USHORT) -1;
        diskPartition->FtMember = 0;
        diskPartition->DriveLetter = 0;
    }

    next = (PFT_DESCRIPTION) &ftDescription->FtMemberDescription[
           ftDescription->NumberOfMembers];

    ftRegistry = (PFT_REGISTRY) ((PUCHAR) Registry +
                                 Registry->FtInformationOffset);

    RtlMoveMemory(ftDescription, next,
                  (PCHAR) ftRegistry + Registry->FtInformationSize -
                  (PCHAR) next);

    ftRegistry->NumberOfComponents--;
}

VOID
FT_LOGICAL_DISK_INFORMATION_SET::DeleteFtRegistryInfo(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

{
    USHORT                      n, i, j;
    FT_LOGICAL_DISK_ID          diskId;
    LONGLONG                    offset;
    PDEVICE_OBJECT              wholeDisk;
    ULONG                       diskNumber, signature;
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    ULONG                       registrySize;
    NTSTATUS                    status;
    PDISK_CONFIG_HEADER         registry;
    PFT_REGISTRY                ftRegistry;
    PFT_DESCRIPTION             ftDescription;
    PFT_MEMBER_DESCRIPTION      ftMember;
    PDISK_PARTITION             diskPartition;
    LONGLONG                    tmp;

    n = QueryNumberOfMembersInLogicalDisk(LogicalDiskId);
    if (!n) {
        return;
    }

    for (i = 0; i < n; i++) {
        diskId = QueryMemberLogicalDiskId(LogicalDiskId, i);
        if (diskId) {
            break;
        }
    }

    if (!diskId) {
        return;
    }

    if (!QueryFtPartitionInformation(diskId, &offset, &wholeDisk, NULL, NULL,
                                     NULL)) {

        return;
    }

    signature = FtpQueryDiskSignature(wholeDisk);
    if (!signature) {
        return;
    }

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = FtpDiskRegistryQueryRoutine;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = L"Information";
    queryTable[0].EntryContext = &registrySize;

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, DISK_REGISTRY_KEY_W,
                                    queryTable, &registry, NULL);

    if (!NT_SUCCESS(status)) {
        return;
    }

    if (!registry->FtInformationSize) {
        ExFreePool(registry);
        return;
    }

    ftRegistry = (PFT_REGISTRY) ((PUCHAR) registry +
                                 registry->FtInformationOffset);
    ftDescription = &ftRegistry->FtDescription[0];
    for (i = 0; i < ftRegistry->NumberOfComponents; i++) {
        for (j = 0; j < ftDescription->NumberOfMembers; j++) {
            ftMember = &ftDescription->FtMemberDescription[j];
            diskPartition = (PDISK_PARTITION) ((PUCHAR) registry +
                            ftMember->OffsetToPartitionInfo);

            tmp = *((LONGLONG UNALIGNED*)
                    &diskPartition->StartingOffset.QuadPart);
            if (ftMember->Signature == signature && tmp == offset) {
                DeleteFtRegistryInformation(registry, diskPartition);
                goto Finish;
            }
        }
        ftDescription = (PFT_DESCRIPTION) &ftDescription->FtMemberDescription[
                        ftDescription->NumberOfMembers];
    }

Finish:
    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, DISK_REGISTRY_KEY_W,
                          L"Information", REG_BINARY, registry,
                          registrySize);

    ExFreePool(registry);
}

PFT_LOGICAL_DISK_INFORMATION
FT_LOGICAL_DISK_INFORMATION_SET::FindLogicalDiskInformation(
    IN  PDEVICE_OBJECT  WholeDiskPdo
    )

{
    ULONG   i;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        if (_arrayOfLogicalDiskInformations[i]->GetWholeDiskPdo() ==
            WholeDiskPdo) {

            return _arrayOfLogicalDiskInformations[i];
        }
    }

    return NULL;
}

LONGLONG
GetMemberSize(
    IN  PDISK_CONFIG_HEADER Registry,
    IN  PDISK_PARTITION     DiskPartition
    )

{
    PFT_DESCRIPTION         ftDescription;
    LONGLONG                memberSize;
    USHORT                  i;
    PFT_MEMBER_DESCRIPTION  ftMember;
    PDISK_PARTITION         diskPartition;
    LONGLONG                tmp;

    ftDescription = GetFtDescription(Registry, DiskPartition);
    if (!ftDescription) {
        return 0;
    }

    memberSize = 0;

    for (i = 0; i < ftDescription->NumberOfMembers; i++) {
        ftMember = &ftDescription->FtMemberDescription[i];
        diskPartition = (PDISK_PARTITION) ((PUCHAR) Registry +
                        ftMember->OffsetToPartitionInfo);

        tmp = *((LONGLONG UNALIGNED*) &diskPartition->Length.QuadPart);
        if (!memberSize || memberSize > tmp) {
            memberSize = *((LONGLONG UNALIGNED*)
                           &diskPartition->Length.QuadPart);

        }
    }

    return memberSize;
}

VOID
SetStateInfo(
    IN  PDISK_CONFIG_HEADER                     Registry,
    IN  PDISK_PARTITION                         DiskPartition,
    OUT PFT_MIRROR_AND_SWP_STATE_INFORMATION    State
    )

{
    PFT_DESCRIPTION         ftDescription;
    USHORT                  i;
    PFT_MEMBER_DESCRIPTION  ftMember;
    PDISK_PARTITION         diskPartition;

    RtlZeroMemory(State, sizeof(FT_MIRROR_AND_SWP_STATE_INFORMATION));
    if (Registry->DirtyShutdown) {
        State->IsDirty = TRUE;
    }

    ftDescription = GetFtDescription(Registry, DiskPartition);
    if (!ftDescription) {
        return;
    }

    for (i = 0; i < ftDescription->NumberOfMembers; i++) {
        ftMember = &ftDescription->FtMemberDescription[i];
        diskPartition = (PDISK_PARTITION) ((PUCHAR) Registry +
                        ftMember->OffsetToPartitionInfo);

        switch (diskPartition->FtState) {
            case Orphaned:
                State->UnhealthyMemberNumber = i;
                State->UnhealthyMemberState = FtMemberOrphaned;
                break;

            case Regenerating:
                State->UnhealthyMemberNumber = i;
                State->UnhealthyMemberState = FtMemberRegenerating;
                break;

            case Initializing:
                State->IsInitializing = TRUE;
                break;

        }
    }
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION_SET::GetDiskDescription(
    IN  PDISK_CONFIG_HEADER             Registry,
    IN  PDISK_PARTITION                 DiskPartition,
    IN  PFT_LOGICAL_DISK_DESCRIPTION    CheckDiskDescription,
    OUT PFT_LOGICAL_DISK_DESCRIPTION*   DiskDescription
    )

{
    PFT_DESCRIPTION                 ftDescription;
    USHORT                          i;
    PFT_MEMBER_DESCRIPTION          ftMember;
    PDISK_PARTITION                 diskPartition;
    FT_LOGICAL_DISK_ID              partitionDiskId;
    PFT_LOGICAL_DISK_DESCRIPTION    diskDesc;
    LONGLONG                        tmp;

    ftDescription = GetFtDescription(Registry, DiskPartition);
    if (!ftDescription) {
        return FALSE;
    }

    for (i = 0; i < ftDescription->NumberOfMembers; i++) {
        ftMember = &ftDescription->FtMemberDescription[i];
        diskPartition = (PDISK_PARTITION) ((PUCHAR) Registry +
                        ftMember->OffsetToPartitionInfo);

        tmp = *((LONGLONG UNALIGNED*) &diskPartition->StartingOffset.QuadPart);
        partitionDiskId = QueryPartitionLogicalDiskId(
                          DiskNumberFromSignature(ftMember->Signature), tmp);
        if (!partitionDiskId) {
            continue;
        }

        diskDesc = GetParentLogicalDiskDescription(partitionDiskId);
        if (!diskDesc) {
            continue;
        }

        if (GetParentLogicalDiskDescription(diskDesc->LogicalDiskId)) {
            continue;
        }

        if (diskDesc != CheckDiskDescription) {
            *DiskDescription = diskDesc;
            return TRUE;
        }
    }

    return FALSE;
}

UCHAR
GetDriveLetter(
    IN  PDISK_CONFIG_HEADER             Registry,
    IN  PDISK_PARTITION                 DiskPartition
    )

{
    PFT_DESCRIPTION                 ftDescription;
    USHORT                          i;
    PFT_MEMBER_DESCRIPTION          ftMember;
    PDISK_PARTITION                 diskPartition;

    ftDescription = GetFtDescription(Registry, DiskPartition);
    if (!ftDescription) {
        return 0;
    }

    for (i = 0; i < ftDescription->NumberOfMembers; i++) {
        ftMember = &ftDescription->FtMemberDescription[i];
        diskPartition = (PDISK_PARTITION) ((PUCHAR) Registry +
                        ftMember->OffsetToPartitionInfo);

        if (diskPartition->AssignDriveLetter) {
            if (diskPartition->DriveLetter >= 'A' &&
                diskPartition->DriveLetter <= 'Z') {

                return diskPartition->DriveLetter;
            } else if (!diskPartition->DriveLetter) {
                if (IsNEC_98) return 0; //For fresh assigning drive letter on NEC98.
            }
        }
    }

    return 0xFF;
}

PFT_LOGICAL_DISK_DESCRIPTION
CreateDiskDescription(
    IN  PDISK_CONFIG_HEADER             Registry,
    IN  PDISK_PARTITION                 DiskPartition,
    IN  FT_LOGICAL_DISK_ID              PartitionDiskId
    )

{
    FT_LOGICAL_DISK_TYPE                                diskType;
    USHORT                                              configInfoSize, stateInfoSize, size;
    PVOID                                               configInfo, stateInfo;
    FT_STRIPE_SET_CONFIGURATION_INFORMATION             stripeConfig;
    FT_MIRROR_SET_CONFIGURATION_INFORMATION             mirrorConfig;
    FT_MIRROR_AND_SWP_STATE_INFORMATION                 state;
    FT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION swpConfig;
    PFT_LOGICAL_DISK_DESCRIPTION                        diskDesc;

    diskType = TranslateFtDiskType(DiskPartition->FtType);

    switch (diskType) {
        case FtVolumeSet:
            configInfoSize = 0;
            configInfo = NULL;
            stateInfoSize = 0;
            stateInfo = NULL;
            break;

        case FtStripeSet:
            RtlZeroMemory(&stripeConfig, sizeof(stripeConfig));
            stripeConfig.StripeSize = STRIPE_SIZE;
            configInfoSize = sizeof(stripeConfig);
            configInfo = &stripeConfig;
            stateInfoSize = 0;
            stateInfo = NULL;
            break;

        case FtMirrorSet:
            RtlZeroMemory(&mirrorConfig, sizeof(mirrorConfig));
            mirrorConfig.MemberSize = GetMemberSize(Registry, DiskPartition);
            configInfoSize = sizeof(mirrorConfig);
            configInfo = &mirrorConfig;
            stateInfoSize = sizeof(state);
            stateInfo = &state;
            SetStateInfo(Registry, DiskPartition, &state);
            break;

        case FtStripeSetWithParity:
            RtlZeroMemory(&swpConfig, sizeof(swpConfig));
            swpConfig.MemberSize = GetMemberSize(Registry, DiskPartition);
            swpConfig.StripeSize = STRIPE_SIZE;
            configInfoSize = sizeof(swpConfig);
            configInfo = &swpConfig;
            stateInfoSize = sizeof(state);
            stateInfo = &state;
            SetStateInfo(Registry, DiskPartition, &state);
            break;

        default:
            return NULL;

    }

    size = sizeof(FT_LOGICAL_DISK_DESCRIPTION) + configInfoSize +
           stateInfoSize;

    size = (size + FILE_QUAD_ALIGNMENT)&(~FILE_QUAD_ALIGNMENT);

    diskDesc = (PFT_LOGICAL_DISK_DESCRIPTION) ExAllocatePool(PagedPool, size);
    if (!diskDesc) {
        return NULL;
    }

    RtlZeroMemory(diskDesc, size);
    diskDesc->DiskDescriptionSize = size;
    diskDesc->DriveLetter = GetDriveLetter(Registry, DiskPartition);
    diskDesc->LogicalDiskType = diskType;
    diskDesc->LogicalDiskId = GenerateNewLogicalDiskId();
    diskDesc->u.Other.ThisMemberLogicalDiskId = PartitionDiskId;
    diskDesc->u.Other.ThisMemberNumber = DiskPartition->FtMember;
    diskDesc->u.Other.NumberOfMembers = GetRegistryNumberOfMembers(Registry,
                                        DiskPartition);
    if (diskDesc->u.Other.ThisMemberNumber >=
        diskDesc->u.Other.NumberOfMembers) {

        return NULL;
    }

    if (configInfo) {
        diskDesc->u.Other.ByteOffsetToConfigurationInformation =
                sizeof(FT_LOGICAL_DISK_DESCRIPTION);
        RtlMoveMemory((PCHAR) diskDesc +
                      diskDesc->u.Other.ByteOffsetToConfigurationInformation,
                      configInfo, configInfoSize);
    } else {
        diskDesc->u.Other.ByteOffsetToConfigurationInformation = 0;
    }

    if (stateInfo) {
        diskDesc->u.Other.ByteOffsetToStateInformation =
                diskDesc->u.Other.ByteOffsetToConfigurationInformation +
                configInfoSize;
        RtlMoveMemory((PCHAR) diskDesc +
                      diskDesc->u.Other.ByteOffsetToStateInformation,
                      stateInfo, stateInfoSize);
    } else {
        diskDesc->u.Other.ByteOffsetToStateInformation = 0;
    }

    return diskDesc;
}

VOID
SetPartitionType(
    IN  PDEVICE_OBJECT  Partition
    )

{
    KEVENT                      event;
    PIRP                        irp;
    PARTITION_INFORMATION       partInfo;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;
    SET_PARTITION_INFORMATION   setPartInfo;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO,
                                        Partition, NULL, 0, &partInfo,
                                        sizeof(partInfo), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return;
    }

    status = IoCallDriver(Partition, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return;
    }

    setPartInfo.PartitionType = (partInfo.PartitionType | (0x80));

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_SET_PARTITION_INFO,
                                        Partition, &setPartInfo,
                                        sizeof(setPartInfo), NULL, 0, FALSE,
                                        &event, &ioStatus);
    if (!irp) {
        return;
    }

    status = IoCallDriver(Partition, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }
}

VOID
DeleteAncestors(
    IN  PFT_LOGICAL_DISK_INFORMATION    LogicalDiskInformation,
    IN  FT_LOGICAL_DISK_ID              PartitionLogicalDiskId
    )

/*++

Routine Description:

    This routine deletes the disk descriptions which are ancestors
    to the given partition disk description on the given logical
    disk information.

Arguments:

    LogicalDiskInformation  - Supplies the logical disk information.

    PartitionLogicalDiskId  - Supplies the partition logical disk id.

Return Value:

    None.

--*/

{
    PFT_LOGICAL_DISK_INFORMATION    diskInfo = LogicalDiskInformation;
    FT_LOGICAL_DISK_ID              diskId = PartitionLogicalDiskId;
    PFT_LOGICAL_DISK_DESCRIPTION    diskDesc;

    diskDesc = diskInfo->GetFirstLogicalDiskDescription();
    while (diskDesc && diskDesc->DiskDescriptionSize) {

        if (diskDesc->LogicalDiskType == FtPartition ||
            diskDesc->u.Other.ThisMemberLogicalDiskId != diskId) {

            diskDesc = diskInfo->GetNextLogicalDiskDescription(diskDesc);
            continue;
        }

        diskId = diskDesc->LogicalDiskId;
        diskInfo->DeleteLogicalDiskDescription(diskDesc);
    }

    FtpLogError(diskInfo->GetRootExtension(), diskInfo->QueryDiskNumber(),
                FT_STALE_ONDISK, STATUS_SUCCESS, 0);
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::MigrateRegistryInformation(
    IN  PDEVICE_OBJECT  Partition,
    IN  ULONG           DiskNumber,
    IN  LONGLONG        Offset
    )

/*++

Routine Description:

    This routine migrates the registry information for the given partition to
    on disk structures.  If all members of the FT set being migrated are on
    disk then the registry information pertaining to the FT set is deleted.

Arguments:

    DiskNumber  - Supplies the disk number of the partition.

    Offset      - Supplies the partition offset.

Return Value:

    NTSTATUS

--*/

{
    ULONG                           i, signature, registrySize, length;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    RTL_QUERY_REGISTRY_TABLE        queryTable[2];
    NTSTATUS                        status;
    PDISK_CONFIG_HEADER             registry;
    PDISK_REGISTRY                  diskRegistry;
    PDISK_PARTITION                 diskPartition;
    FT_LOGICAL_DISK_ID              partitionDiskId;
    PFT_LOGICAL_DISK_DESCRIPTION    diskDesc, newDesc, otherDesc;
    PVOID                           config, newConfig;
    PVOID                           state, newState;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        if (diskInfo->QueryDiskNumber() == DiskNumber) {
            break;
        }
    }

    if (i == _numberOfLogicalDiskInformations) {
        return STATUS_INVALID_PARAMETER;
    }

    signature = FtpQueryDiskSignature(diskInfo->GetWholeDiskPdo());
    if (!signature) {
        return STATUS_SUCCESS;
    }

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = FtpDiskRegistryQueryRoutine;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = L"Information";
    queryTable[0].EntryContext = &registrySize;

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, DISK_REGISTRY_KEY_W,
                                    queryTable, &registry, NULL);

    if (!NT_SUCCESS(status)) {
        return STATUS_SUCCESS;
    }

    if (!registry->FtInformationSize) {
        ExFreePool(registry);
        return STATUS_SUCCESS;
    }

    diskRegistry = (PDISK_REGISTRY)
                   ((PUCHAR) registry + registry->DiskInformationOffset);

    diskPartition = FtpFindDiskPartition(diskRegistry, signature, Offset);
    if (!diskPartition || diskPartition->FtType == NotAnFtMember) {
        ExFreePool(registry);
        return STATUS_SUCCESS;
    }

    if (!ReallocRootLogicalDiskIds(_numberOfRootLogicalDisksIds + 1)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    partitionDiskId = QueryPartitionLogicalDiskId(DiskNumber, Offset);
    if (!partitionDiskId) {
        status = CreatePartitionLogicalDisk(DiskNumber, Offset, 0,
                                            &partitionDiskId);
        if (!NT_SUCCESS(status)) {
            ExFreePool(registry);
            return status;
        }

        SetPartitionType(Partition);
    }

    diskDesc = GetParentLogicalDiskDescription(partitionDiskId);
    newDesc = CreateDiskDescription(registry, diskPartition, partitionDiskId);
    if (!newDesc) {
        ExFreePool(registry);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (diskDesc && GetParentLogicalDiskDescription(diskDesc->LogicalDiskId)) {
        DeleteAncestors(diskInfo, partitionDiskId);
        diskDesc = NULL;
    }

    if (diskDesc) {
        if (diskDesc->DiskDescriptionSize != newDesc->DiskDescriptionSize ||
            diskDesc->LogicalDiskType != newDesc->LogicalDiskType ||
            diskDesc->u.Other.ThisMemberNumber !=
                    newDesc->u.Other.ThisMemberNumber ||
            diskDesc->u.Other.NumberOfMembers !=
                    newDesc->u.Other.NumberOfMembers ||
            diskDesc->u.Other.ByteOffsetToConfigurationInformation !=
                    newDesc->u.Other.ByteOffsetToConfigurationInformation ||
            diskDesc->u.Other.ByteOffsetToStateInformation !=
                    newDesc->u.Other.ByteOffsetToStateInformation) {

            DeleteAncestors(diskInfo, partitionDiskId);
            diskDesc = NULL;
        } else {
            diskDesc->DriveLetter = newDesc->DriveLetter;
        }
    }

    if (diskDesc && diskDesc->u.Other.ByteOffsetToConfigurationInformation) {
        if (diskDesc->u.Other.ByteOffsetToStateInformation) {
            length = diskDesc->u.Other.ByteOffsetToStateInformation -
                     diskDesc->u.Other.ByteOffsetToConfigurationInformation;
        } else {
            length = diskDesc->DiskDescriptionSize -
                     diskDesc->u.Other.ByteOffsetToConfigurationInformation;
        }

        config = (PCHAR) diskDesc +
                 diskDesc->u.Other.ByteOffsetToConfigurationInformation;
        newConfig = (PCHAR) newDesc +
                    newDesc->u.Other.ByteOffsetToConfigurationInformation;

        if (RtlCompareMemory(config, newConfig, length) != length) {
            DeleteAncestors(diskInfo, partitionDiskId);
            diskDesc = NULL;
        }
    }

    if (diskDesc && diskDesc->u.Other.ByteOffsetToStateInformation) {
        length = diskDesc->DiskDescriptionSize -
                 diskDesc->u.Other.ByteOffsetToStateInformation;
        state = (PCHAR) diskDesc +
                diskDesc->u.Other.ByteOffsetToStateInformation;
        newState = (PCHAR) newDesc +
                   newDesc->u.Other.ByteOffsetToStateInformation;

        RtlCopyMemory(state, newState, length);
    }

    if (!GetDiskDescription(registry, diskPartition, diskDesc, &otherDesc)) {
        otherDesc = NULL;
    }

    if (diskDesc) {
        diskDesc->DriveLetter = newDesc->DriveLetter;
    } else {
        diskDesc = diskInfo->AddLogicalDiskDescription(newDesc);
    }

    if (otherDesc &&
        !QueryMemberLogicalDiskId(otherDesc->LogicalDiskId,
                                  diskPartition->FtMember)) {

        diskDesc->LogicalDiskId = otherDesc->LogicalDiskId;
    }

    if (IsLogicalDiskComplete(diskDesc->LogicalDiskId)) {
        DeleteFtRegistryInformation(registry, diskPartition);
    }

    RecomputeArrayOfRootLogicalDiskIds();

    diskInfo->Write();
    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, DISK_REGISTRY_KEY_W,
                          L"Information", REG_BINARY, registry,
                          registrySize);

    ExFreePool(newDesc);
    ExFreePool(registry);

    return STATUS_SUCCESS;
}

FT_LOGICAL_DISK_INFORMATION_SET::~FT_LOGICAL_DISK_INFORMATION_SET(
    )

{
    ULONG   i;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        delete _arrayOfLogicalDiskInformations[i];
    }
    if (_arrayOfLogicalDiskInformations) {
        ExFreePool(_arrayOfLogicalDiskInformations);
    }

    if (_arrayOfRootLogicalDiskIds) {
        ExFreePool(_arrayOfRootLogicalDiskIds);
    }
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION_SET::ReallocRootLogicalDiskIds(
    IN  ULONG   NewNumberOfEntries
    )

/*++

Routine Description;

    This routine reallocs the root logical disk ids buffer to contain
    the given number of entries.  It does not change the number of
    disk ids private member, it just enlarges the buffer.

Arguments:

    NewNumberOfEntries  - Supplies the new size of the buffer.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    PFT_LOGICAL_DISK_ID newLogicalDiskIdArray;

    if (NewNumberOfEntries <= _numberOfRootLogicalDisksIds) {
        return TRUE;
    }

    newLogicalDiskIdArray = (PFT_LOGICAL_DISK_ID)
                            ExAllocatePool(NonPagedPool, NewNumberOfEntries*
                                           sizeof(FT_LOGICAL_DISK_ID));
    if (!newLogicalDiskIdArray) {
        return FALSE;
    }

    if (_arrayOfRootLogicalDiskIds) {
        RtlMoveMemory(newLogicalDiskIdArray, _arrayOfRootLogicalDiskIds,
                      _numberOfRootLogicalDisksIds*sizeof(FT_LOGICAL_DISK_ID));
        ExFreePool(_arrayOfRootLogicalDiskIds);
    }

    _arrayOfRootLogicalDiskIds = newLogicalDiskIdArray;

    return TRUE;
}

VOID
FT_LOGICAL_DISK_INFORMATION_SET::RecomputeArrayOfRootLogicalDiskIds(
    )

/*++

Routine Description:

    This routine computes the array of root logical disk ids.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG                           i, j;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p, q;

    _numberOfRootLogicalDisksIds = 0;
    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {

        diskInfo = _arrayOfLogicalDiskInformations[i];

        for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
             p = diskInfo->GetNextLogicalDiskDescription(p)) {

            for (q = diskInfo->GetFirstLogicalDiskDescription(); q;
                 q = diskInfo->GetNextLogicalDiskDescription(q)) {

                if (q->LogicalDiskType != FtPartition &&
                    q->u.Other.ThisMemberLogicalDiskId == p->LogicalDiskId) {

                    break;
                }
            }

            if (!q) {
                for (j = 0; j < _numberOfRootLogicalDisksIds; j++) {
                    if (_arrayOfRootLogicalDiskIds[j] == p->LogicalDiskId) {
                        break;
                    }
                }

                if (j == _numberOfRootLogicalDisksIds) {
                    _arrayOfRootLogicalDiskIds[j] = p->LogicalDiskId;
                    _numberOfRootLogicalDisksIds++;
                }
            }
        }
    }
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION_SET::ComputeNewParentLogicalDiskIds(
    IN  FT_LOGICAL_DISK_ID      LogicalDiskId,
    OUT PULONG                  NumLogicalDiskIds,
    OUT PFT_LOGICAL_DISK_ID*    OldLogicalDiskIds,
    OUT PFT_LOGICAL_DISK_ID*    NewLogicalDiskIds
    )

/*++

Routine Description:

    This routine finds all of the parents of the given logical disk id and
    computes replacement logical disk ids for them.

Arguments:

    LogicalDiskId       - Supplies the logical disk id.

    NumLogicalDiskIds   - Returns the number of parents.

    OldLogicalDiskIds   - Returns the existing geneology for the given
                            logical disk id.

    NewLogicalDiskIds   - Returns the new geneology for the given
                            logical disk id.

Return Value:

    FALSE   - Insufficient resources.

    TRUE    - Success.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p;
    ULONG                           n, i;

    n = 1;
    for (p = GetParentLogicalDiskDescription(LogicalDiskId); p;
         p = GetParentLogicalDiskDescription(p->LogicalDiskId)) {

        n++;
    }

    *NumLogicalDiskIds = n;
    *OldLogicalDiskIds = (PFT_LOGICAL_DISK_ID)
                         ExAllocatePool(PagedPool,
                                        n*sizeof(FT_LOGICAL_DISK_ID));
    if (!*OldLogicalDiskIds) {
        return FALSE;
    }

    *NewLogicalDiskIds = (PFT_LOGICAL_DISK_ID)
                         ExAllocatePool(PagedPool,
                                        n*sizeof(FT_LOGICAL_DISK_ID));
    if (!*NewLogicalDiskIds) {
        ExFreePool(*OldLogicalDiskIds);
        return FALSE;
    }

    (*OldLogicalDiskIds)[0] = LogicalDiskId;
    (*NewLogicalDiskIds)[0] = GenerateNewLogicalDiskId();

    i = 1;
    for (p = GetParentLogicalDiskDescription(LogicalDiskId); p;
         p = GetParentLogicalDiskDescription(p->LogicalDiskId)) {

        (*OldLogicalDiskIds)[i] = p->LogicalDiskId;
        (*NewLogicalDiskIds)[i] = GenerateNewLogicalDiskId();
        i++;
    }

    ASSERT(i == n);

    return TRUE;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif

PFT_LOGICAL_DISK_DESCRIPTION
FT_LOGICAL_DISK_INFORMATION::GetNextLogicalDiskDescription(
    IN  PFT_LOGICAL_DISK_DESCRIPTION    CurrentDiskDescription
    )

/*++

Routine Description:

    This routine returns the next logical disk description for a
    given logical disk description.

Arguments:

    CurrentDiskDescription  - Supplies the current disk description.

Return Value:

    The next disk description or NULL if no more disk descriptions
    are present.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    next;

    next = (PFT_LOGICAL_DISK_DESCRIPTION)
           ((PCHAR) CurrentDiskDescription +
            CurrentDiskDescription->DiskDescriptionSize);

    if ((ULONG) ((PCHAR) next - (PCHAR) _diskBuffer) >
        _length - sizeof(USHORT)) {

        return NULL;
    }

    if ((ULONG) ((PCHAR) next - (PCHAR) _diskBuffer +
                 next->DiskDescriptionSize) > _length) {

        return NULL;
    }

    if (next->DiskDescriptionSize < sizeof(FT_LOGICAL_DISK_DESCRIPTION)) {
        return NULL;
    }

    return next;
}

PFT_LOGICAL_DISK_DESCRIPTION
FT_LOGICAL_DISK_INFORMATION_SET::GetParentLogicalDiskDescription(
    IN  PFT_LOGICAL_DISK_DESCRIPTION    LogicalDiskDescription,
    IN  ULONG                           DiskInformationNumber
    )

/*++

Routine Description:

    This routine gets the parent logical disk description.

Arguments:

    LogicalDiskDescription  - Supplies the child logical disk description.

    DiskInformationNumber   - Supplies the disk information number.

Return Value:

    The parent logical disk description or NULL.

--*/

{
    FT_LOGICAL_DISK_ID              diskId;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    diskId = LogicalDiskDescription->LogicalDiskId;
    diskInfo = _arrayOfLogicalDiskInformations[DiskInformationNumber];
    for (p = diskInfo->GetNextLogicalDiskDescription(LogicalDiskDescription);
         p; p = diskInfo->GetNextLogicalDiskDescription(p)) {

        if (p->LogicalDiskType != FtPartition &&
            p->u.Other.ThisMemberLogicalDiskId == diskId) {

            return p;
        }
    }

    return NULL;
}

PFT_LOGICAL_DISK_DESCRIPTION
FT_LOGICAL_DISK_INFORMATION_SET::GetParentLogicalDiskDescription(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    OUT PULONG              DiskInformationNumber
    )

/*++

Routine Description:

    This routine gets the parent logical disk description for the
    given logical disk id.

Arguments:

    LogicalDiskId           - Supplies the logical disk id.

    DiskInformationNumber   - Returns the disk information number.

Return Value:

    The parent logical disk description or NULL.

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
             p = diskInfo->GetNextLogicalDiskDescription(p)) {

            if (p->LogicalDiskType != FtPartition &&
                p->u.Other.ThisMemberLogicalDiskId == LogicalDiskId) {

                if (DiskInformationNumber) {
                    *DiskInformationNumber = i;
                }
                return p;
            }
        }
    }

    return NULL;
}

PFT_LOGICAL_DISK_DESCRIPTION
FT_LOGICAL_DISK_INFORMATION::GetFirstLogicalDiskDescription(
    )

/*++

Routine Description:

    This routine returns the first logical disk description in the
    list.

Arguments:

    None.

Return Value:

    A pointer inside the buffer for the first logical disk description or
    NULL if there are no logical disk descriptions.

--*/

{
    PFT_ON_DISK_PREAMBLE            preamble;
    PFT_LOGICAL_DISK_DESCRIPTION    diskDescription;

    if (!_length) {
        return NULL;
    }

    preamble = (PFT_ON_DISK_PREAMBLE) _diskBuffer;
    if (preamble->FtOnDiskSignature != FT_ON_DISK_SIGNATURE ||
        preamble->DiskDescriptionVersionNumber != FT_ON_DISK_DESCRIPTION_VERSION_NUMBER ||
        preamble->ByteOffsetToFirstFtLogicalDiskDescription <
        sizeof(FT_ON_DISK_PREAMBLE) ||
        preamble->ByteOffsetToFirstFtLogicalDiskDescription >
        _length - sizeof(ULONG)) {

        return NULL;
    }

    diskDescription = (PFT_LOGICAL_DISK_DESCRIPTION)
                      ((PCHAR) preamble +
                       preamble->ByteOffsetToFirstFtLogicalDiskDescription);

    if (diskDescription->DiskDescriptionSize <
        sizeof(FT_LOGICAL_DISK_DESCRIPTION)) {

        return NULL;
    }

    if ((ULONG) ((PCHAR) diskDescription - (PCHAR) _diskBuffer +
                 diskDescription->DiskDescriptionSize) > _length) {

        return NULL;
    }

    return diskDescription;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\redist.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    redist.cxx

Abstract:

    This module contains the code specific to redistributions for the fault
    tolerance driver.

Author:

    Norbert Kusters      6-Feb-1997

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>

class PROPOGATE_CHANGES_WORK_ITEM : public WORK_QUEUE_ITEM {

    public:

        PREDISTRIBUTION         Redistribution;
        FT_COMPLETION_ROUTINE   CompletionRoutine;
        PVOID                   Context;

};

typedef PROPOGATE_CHANGES_WORK_ITEM *PPROPOGATE_CHANGES_WORK_ITEM;

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
REDISTRIBUTION::Initialize(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN OUT  PFT_VOLUME*         VolumeArray,
    IN      USHORT              ArraySize,
    IN      PVOID               ConfigInfo,
    IN      PVOID               StateInfo
    )

/*++

Routine Description:

    Initialize routine for FT_VOLUME of type REDISTRIBUTION.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id for this volume.

    VolumeArray     - Supplies the array of volumes for this volume set.

    ArraySize       - Supplies the number of volumes in the volume array.

    ConfigInfo      - Supplies the configuration information.

    StateInfo       - Supplies the state information.

Return Value:

    NTSTATUS

--*/

{
    BOOLEAN                                         oneGood;
    USHORT                                          i;
    NTSTATUS                                        status;
    PFT_REDISTRIBUTION_CONFIGURATION_INFORMATION    configInfo;
    LONGLONG                                        firstRowSize;
    LONGLONG                                        secondRowSize;
    LONGLONG                                        numRows;
    LONGLONG                                        tmpNumRows;

    if (ArraySize != 2) {
        return STATUS_INVALID_PARAMETER;
    }

    oneGood = FALSE;
    for (i = 0; i < ArraySize; i++) {
        if (VolumeArray[i]) {
            oneGood = TRUE;
        }
    }

    if (!oneGood) {
        return STATUS_INVALID_PARAMETER;
    }

    status = COMPOSITE_FT_VOLUME::Initialize(RootExtension, LogicalDiskId,
                                             VolumeArray, ArraySize,
                                             ConfigInfo, StateInfo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    configInfo = (PFT_REDISTRIBUTION_CONFIGURATION_INFORMATION) ConfigInfo;
    _stripeSize = configInfo->StripeSize;
    if (_stripeSize < QuerySectorSize()) {
        return STATUS_INVALID_PARAMETER;
    }
    for (i = 0; _stripeSize%2 == 0; i++) {
        _stripeSize /= 2;
    }
    if (_stripeSize != 1) {
        return STATUS_INVALID_PARAMETER;
    }
    _stripeSize = configInfo->StripeSize;    
    
    if( !configInfo->FirstMemberWidth || !configInfo->SecondMemberWidth) {
        return STATUS_INVALID_PARAMETER;
    }
    _firstWidth = configInfo->FirstMemberWidth;
    _totalWidth = _firstWidth + configInfo->SecondMemberWidth;
    
    if (VolumeArray[0]) {
        _firstSize = VolumeArray[0]->QueryVolumeSize();
    } else {
        _firstSize = 0;
    }

    if (_firstSize && VolumeArray[1]) {
        firstRowSize = _firstWidth*_stripeSize;
        numRows = _firstSize/firstRowSize;
        secondRowSize = configInfo->SecondMemberWidth*_stripeSize;
        tmpNumRows = VolumeArray[1]->QueryVolumeSize()/secondRowSize;
        if (tmpNumRows < numRows) {
            numRows = tmpNumRows;
        }
        _totalSize = numRows*_totalWidth*_stripeSize;
        if (_totalSize < _firstSize) {
            return STATUS_INVALID_PARAMETER;
        }
    } else {
        _totalSize = 0;
    }
    _syncOk = TRUE;
    _stopSyncs = FALSE;

    RtlCopyMemory(&_state, StateInfo, sizeof(_state));

    if (_state.BytesRedistributed < _firstSize) {
        _redistributionComplete = FALSE;
    } else {
        _redistributionComplete = TRUE;
    }

    status = _overlappedIoManager.Initialize(0);

    return status;
}

FT_LOGICAL_DISK_TYPE
REDISTRIBUTION::QueryLogicalDiskType(
    )

/*++

Routine Description:

    This routine returns the type of the logical disk.

Arguments:

    None.

Return Value:

    The type of the logical disk.

--*/

{
    return FtRedistribution;
}

NTSTATUS
REDISTRIBUTION::CheckIo(
    OUT PBOOLEAN    IsIoOk
    )

/*++

Routine Description:

    This routine returns whether or not IO is possible on the given
    logical disk.

Arguments:

    IsIoOk  - Returns the state of IO.

Return Value:

    NTSTATUS

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;
    NTSTATUS    status;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMemberUnprotected(i);
        if (!vol) {
            *IsIoOk = FALSE;
            return STATUS_SUCCESS;
        }
        status = vol->CheckIo(IsIoOk);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (!(*IsIoOk)) {
            return STATUS_SUCCESS;
        }
    }

    return STATUS_SUCCESS;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

REDISTRIBUTION::~REDISTRIBUTION(
    )

{
}

VOID
RedistributionTwoPartCompletionRoutine(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion of a two part operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP      transferPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PREDISTRIBUTION_LOCK_TP lockPacket = (PREDISTRIBUTION_LOCK_TP) transferPacket->MasterPacket;
    PTRANSFER_PACKET        masterPacket = lockPacket->MasterPacket;
    NTSTATUS                status = transferPacket->IoStatus.Status;
    KIRQL                   irql;
    LONG                    count;

    KeAcquireSpinLock(&lockPacket->SpinLock, &irql);

    if (NT_SUCCESS(status)) {

        if (NT_SUCCESS(lockPacket->IoStatus.Status)) {
            lockPacket->IoStatus.Information +=
                    transferPacket->IoStatus.Information;
        }

    } else {

        if (FtpIsWorseStatus(status, lockPacket->IoStatus.Status)) {
            lockPacket->IoStatus.Status = status;
        }
    }

    count = --lockPacket->RefCount;

    KeReleaseSpinLock(&lockPacket->SpinLock, irql);

    delete transferPacket;

    if (!count) {
        masterPacket->IoStatus = lockPacket->IoStatus;
        delete lockPacket;
        masterPacket->CompletionRoutine(masterPacket);
    }
}

VOID
RedistributionRegionLockCompletion(
    IN OUT  PTRANSFER_PACKET    LockPacket
    )

/*++

Routine Description:

    This routine is the completion of a region lock operation.

Arguments:

    LockPacket  - Supplies the lock packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_LOCK_TP lockPacket = (PREDISTRIBUTION_LOCK_TP) LockPacket;
    PREDISTRIBUTION         t = lockPacket->Redistribution;
    PTRANSFER_PACKET        masterPacket = lockPacket->MasterPacket;
    KIRQL                   irql;
    LONGLONG                bytesRedistributed;
    LONGLONG                redistOffset, regularOffset;
    ULONG                   redistLength, regularLength;
    PREDISTRIBUTION_TP      redistPacket, regularPacket;
    PCHAR                   vp;

    KeAcquireSpinLock(&t->_spinLock, &irql);
    bytesRedistributed = t->_state.BytesRedistributed;
    KeReleaseSpinLock(&t->_spinLock, irql);

    if (lockPacket->Offset < bytesRedistributed) {
        redistOffset = lockPacket->Offset;
        redistLength = lockPacket->Length;
        if (redistOffset + redistLength > bytesRedistributed) {
            redistLength = (ULONG) (bytesRedistributed - redistOffset);
        }
    } else {
        redistLength = 0;
    }

    if (redistLength < lockPacket->Length) {
        regularLength = lockPacket->Length - redistLength;
        regularOffset = lockPacket->Offset + redistLength;
    } else {
        regularLength = 0;
    }

    KeInitializeSpinLock(&lockPacket->SpinLock);
    lockPacket->IoStatus.Status = STATUS_SUCCESS;
    lockPacket->IoStatus.Information = 0;
    lockPacket->RefCount = 0;

    if (lockPacket->Mdl && redistLength && regularLength) {
        vp = (PCHAR) MmGetMdlVirtualAddress(lockPacket->Mdl);
    }

    if (redistLength) {
        lockPacket->RefCount++;
        redistPacket = new REDISTRIBUTION_TP;
        if (!redistPacket) {
            delete lockPacket;
            masterPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            masterPacket->IoStatus.Information = 0;
            masterPacket->CompletionRoutine(masterPacket);
            return;
        }
        if (regularLength) {
            if (lockPacket->Mdl) {
                if (redistPacket->AllocateMdl(vp, redistLength)) {
                    IoBuildPartialMdl(lockPacket->Mdl, redistPacket->Mdl,
                                      vp, redistLength);
                } else {
                    delete redistPacket;
                    delete lockPacket;
                    masterPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                    masterPacket->IoStatus.Information = 0;
                    masterPacket->CompletionRoutine(masterPacket);
                    return;
                }
            } else {
                redistPacket->Mdl = lockPacket->Mdl;
            }
        } else {
            redistPacket->Mdl = lockPacket->Mdl;
        }
        redistPacket->Length = redistLength;
        redistPacket->Offset = redistOffset;
        redistPacket->CompletionRoutine = RedistributionTwoPartCompletionRoutine;
        redistPacket->TargetVolume = t;
        redistPacket->Thread = lockPacket->Thread;
        redistPacket->IrpFlags = lockPacket->IrpFlags;
        redistPacket->ReadPacket = lockPacket->ReadPacket;
        redistPacket->MasterPacket = lockPacket;
        redistPacket->Redistribution = t;
        redistPacket->WhichMember = 0;
    }

    if (regularLength) {
        lockPacket->RefCount++;
        regularPacket = new REDISTRIBUTION_TP;
        if (!regularPacket) {
            if (redistLength) {
                delete redistPacket;
            }
            delete lockPacket;
            masterPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            masterPacket->IoStatus.Information = 0;
            masterPacket->CompletionRoutine(masterPacket);
            return;
        }
        if (redistLength) {
            if (lockPacket->Mdl) {
                if (regularPacket->AllocateMdl(vp, regularLength)) {
                    IoBuildPartialMdl(lockPacket->Mdl, regularPacket->Mdl,
                                      vp, regularLength);
                } else {
                    if (redistLength) {
                        delete redistPacket;
                    }
                    delete regularPacket;
                    delete lockPacket;
                    masterPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                    masterPacket->IoStatus.Information = 0;
                    masterPacket->CompletionRoutine(masterPacket);
                    return;
                }
            } else {
                regularPacket->Mdl = lockPacket->Mdl;
            }
        } else {
            regularPacket->Mdl = lockPacket->Mdl;
        }
        regularPacket->Length = regularLength;
        regularPacket->Offset = regularOffset;
        regularPacket->CompletionRoutine = RedistributionTwoPartCompletionRoutine;
        regularPacket->TargetVolume = t->GetMemberUnprotected(0);
        regularPacket->Thread = lockPacket->Thread;
        regularPacket->IrpFlags = lockPacket->IrpFlags;
        regularPacket->ReadPacket = lockPacket->ReadPacket;
        regularPacket->MasterPacket = lockPacket;
        regularPacket->Redistribution = t;
        regularPacket->WhichMember = 0;
    }

    if (redistLength) {
        t->RedistributeTransfer(redistPacket);
    }

    if (regularLength) {
        TRANSFER(regularPacket);
    }
}

VOID
REDISTRIBUTION::Transfer(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Transfer routine for REDISTRIBUTION type FT_VOLUME.  Figure out
    which volumes this request needs to be dispatched to.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_LOCK_TP lockPacket;

    if (!_redistributionComplete) {
        if (TransferPacket->Offset + TransferPacket->Length > _firstSize) {
            TransferPacket->IoStatus.Status = STATUS_INVALID_PARAMETER;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }

        lockPacket = new REDISTRIBUTION_LOCK_TP;
        if (!lockPacket) {
            TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }
        lockPacket->Mdl = TransferPacket->Mdl;
        lockPacket->Length = TransferPacket->Length;
        lockPacket->Offset = TransferPacket->Offset;
        lockPacket->CompletionRoutine = RedistributionRegionLockCompletion;
        lockPacket->TargetVolume = TransferPacket->TargetVolume;
        lockPacket->Thread = TransferPacket->Thread;
        lockPacket->IrpFlags = TransferPacket->IrpFlags;
        lockPacket->ReadPacket = TransferPacket->ReadPacket;
        lockPacket->MasterPacket = TransferPacket;
        lockPacket->Redistribution = this;

        _overlappedIoManager.AcquireIoRegion(lockPacket, TRUE);
        return;
    }

    if (TransferPacket->Offset + TransferPacket->Length > _totalSize) {
        TransferPacket->IoStatus.Status = STATUS_INVALID_PARAMETER;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    RedistributeTransfer(TransferPacket);
}

VOID
RedistributionReplaceCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a replace request.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_LOCK_TP transferPacket = (PREDISTRIBUTION_LOCK_TP) TransferPacket;
    PTRANSFER_PACKET        masterPacket = transferPacket->MasterPacket;

    masterPacket->IoStatus = transferPacket->IoStatus;
    delete transferPacket;
    masterPacket->CompletionRoutine(masterPacket);
}

VOID
RedistributionLockReplaceCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a lock request.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_LOCK_TP transferPacket = (PREDISTRIBUTION_LOCK_TP) TransferPacket;
    PREDISTRIBUTION         t = transferPacket->Redistribution;
    KIRQL                   irql;
    LONGLONG                bytesRedistributed;

    KeAcquireSpinLock(&t->_spinLock, &irql);
    bytesRedistributed = t->_state.BytesRedistributed;
    KeReleaseSpinLock(&t->_spinLock, irql);

    transferPacket->CompletionRoutine = RedistributionReplaceCompletion;
    if (transferPacket->Offset < bytesRedistributed) {
        t->RedistributeReplaceBadSector(transferPacket);
    } else {
        transferPacket->TargetVolume = t->GetMemberUnprotected(0);
        transferPacket->TargetVolume->ReplaceBadSector(transferPacket);
    }
}

VOID
REDISTRIBUTION::ReplaceBadSector(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine attempts to fix the given bad sector by routing
    the request to the appropriate sub-volume.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_LOCK_TP lockPacket;

    if (!_redistributionComplete) {
        if (TransferPacket->Offset + TransferPacket->Length > _firstSize) {
            TransferPacket->IoStatus.Status = STATUS_INVALID_PARAMETER;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }

        lockPacket = new REDISTRIBUTION_LOCK_TP;
        if (!lockPacket) {
            TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }

        lockPacket->Mdl = TransferPacket->Mdl;
        lockPacket->Length = TransferPacket->Length;
        lockPacket->Offset = TransferPacket->Offset;
        lockPacket->CompletionRoutine = RedistributionLockReplaceCompletion;
        lockPacket->TargetVolume = TransferPacket->TargetVolume;
        lockPacket->Thread = TransferPacket->Thread;
        lockPacket->IrpFlags = TransferPacket->IrpFlags;
        lockPacket->ReadPacket = TransferPacket->ReadPacket;
        lockPacket->MasterPacket = TransferPacket;
        lockPacket->Redistribution = this;

        _overlappedIoManager.AcquireIoRegion(lockPacket, TRUE);
        return;
    }

    if (TransferPacket->Offset + TransferPacket->Length > _totalSize) {
        TransferPacket->IoStatus.Status = STATUS_INVALID_PARAMETER;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    RedistributeReplaceBadSector(TransferPacket);
}

VOID
RedistributionCompositeVolumeCompletionRoutine(
    IN  PVOID       Context,
    IN  NTSTATUS    Status
    )

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    KIRQL                           irql;
    LONG                            count;

    context = (PFT_COMPLETION_ROUTINE_CONTEXT) Context;

    KeAcquireSpinLock(&context->SpinLock, &irql);
    if (!NT_SUCCESS(Status) && FtpIsWorseStatus(Status, context->Status)) {
        context->Status = Status;
    }
    count = --context->RefCount;
    KeReleaseSpinLock(&context->SpinLock, irql);

    if (!count) {
        context->CompletionRoutine(context->Context, STATUS_SUCCESS);
        ExFreePool(context);
    }
}

VOID
RedistributionSyncPhase6(
    IN OUT  PVOID       SyncPacket,
    IN      NTSTATUS    Status
    )

/*++

Routine Description:

    This is the completion routine for the update state part of a sync.

Arguments:

    SyncPacket  - Supplies the transfer packet.

    Status      - Supplies the status.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_SYNC_TP syncPacket = (PREDISTRIBUTION_SYNC_TP) SyncPacket;
    PREDISTRIBUTION_TP      ioPacket = &syncPacket->IoPacket;
    PREDISTRIBUTION         t = syncPacket->Redistribution;
    KIRQL                   irql;
    BOOLEAN                 allDone;

    if (!NT_SUCCESS(Status)) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        t->_state.BytesRedistributed -= ioPacket->Length;
        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        t->_overlappedIoManager.ReleaseIoRegion(syncPacket);
        RedistributionCompositeVolumeCompletionRoutine(syncPacket->Context,
                                                       STATUS_SUCCESS);
        delete syncPacket;
        return;
    }

    if (t->_state.BytesRedistributed == t->_firstSize) {
        t->_redistributionComplete = TRUE;
        allDone = TRUE;
    } else {
        allDone = FALSE;
    }
    t->_overlappedIoManager.ReleaseIoRegion(syncPacket);

    if (allDone) {
        RedistributionCompositeVolumeCompletionRoutine(syncPacket->Context,
                                                       STATUS_SUCCESS);
        delete syncPacket;
        return;
    }

    syncPacket->Offset = t->_state.BytesRedistributed;

    t->_overlappedIoManager.AcquireIoRegion(syncPacket, TRUE);
}

VOID
RedistributionSyncPhase5(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for the write verify part of a sync.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP      ioPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PREDISTRIBUTION_SYNC_TP syncPacket = (PREDISTRIBUTION_SYNC_TP) ioPacket->MasterPacket;
    PREDISTRIBUTION         t = syncPacket->Redistribution;
    NTSTATUS                status = ioPacket->IoStatus.Status;
    KIRQL                   irql;

    if (FsRtlIsTotalDeviceFailure(status)) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        RedistributionCompositeVolumeCompletionRoutine(syncPacket->Context,
                                                       status);
        delete syncPacket;
        return;
    }

    if (!NT_SUCCESS(status)) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        RedistributionCompositeVolumeCompletionRoutine(syncPacket->Context, status);
        delete syncPacket;
        FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                    FT_REDISTRIBUTION_ERROR, status, 0);
        return;
    }

    KeAcquireSpinLock(&t->_spinLock, &irql);
    t->_state.BytesRedistributed += ioPacket->Length;
    KeReleaseSpinLock(&t->_spinLock, irql);

    t->PropogateStateChanges(RedistributionSyncPhase6, syncPacket);
}

VOID
RedistributionSyncPhase4(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for the verify write part of a sync.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP      ioPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PREDISTRIBUTION_SYNC_TP syncPacket = (PREDISTRIBUTION_SYNC_TP) ioPacket->MasterPacket;
    PREDISTRIBUTION         t = syncPacket->Redistribution;
    NTSTATUS                status = ioPacket->IoStatus.Status;
    KIRQL                   irql;

    if (FsRtlIsTotalDeviceFailure(status)) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        RedistributionCompositeVolumeCompletionRoutine(syncPacket->Context,
                                                       status);
        delete syncPacket;
        return;
    }

    if (!NT_SUCCESS(status)) {
        ioPacket->CompletionRoutine = RedistributionSyncPhase5;
        t->CarefulWrite(ioPacket);
        return;
    }

    KeAcquireSpinLock(&t->_spinLock, &irql);
    t->_state.BytesRedistributed += ioPacket->Length;
    KeReleaseSpinLock(&t->_spinLock, irql);

    t->PropogateStateChanges(RedistributionSyncPhase6, syncPacket);
}

VOID
RedistributionSyncPhase3(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for the initial write part of a sync.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP      ioPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PREDISTRIBUTION_SYNC_TP syncPacket = (PREDISTRIBUTION_SYNC_TP) ioPacket->MasterPacket;
    PREDISTRIBUTION         t = syncPacket->Redistribution;
    NTSTATUS                status = ioPacket->IoStatus.Status;
    KIRQL                   irql;

    if (FsRtlIsTotalDeviceFailure(status)) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        RedistributionCompositeVolumeCompletionRoutine(syncPacket->Context,
                                                       status);
        delete syncPacket;
        return;
    }

    if (!NT_SUCCESS(status)) {
        ioPacket->CompletionRoutine = RedistributionSyncPhase5;
        t->CarefulWrite(ioPacket);
        return;
    }

    ioPacket->CompletionRoutine = RedistributionSyncPhase4;
    t->VerifyWrite(ioPacket);
}

VOID
RedistributionSyncPhase2(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for the read part of a sync.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP      ioPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PREDISTRIBUTION_SYNC_TP syncPacket = (PREDISTRIBUTION_SYNC_TP) ioPacket->MasterPacket;
    PREDISTRIBUTION         t = syncPacket->Redistribution;
    NTSTATUS                status = ioPacket->IoStatus.Status;
    LONGLONG                rowSize, rowNum, rowOffset, firstSize;
    KIRQL                   irql;

    KeAcquireSpinLock(&t->_spinLock, &irql);
    if (t->_stopSyncs) {
        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        RedistributionCompositeVolumeCompletionRoutine(syncPacket->Context,
                                                       STATUS_SUCCESS);
        delete syncPacket;
        return;
    }
    KeReleaseSpinLock(&t->_spinLock, irql);

    if (FsRtlIsTotalDeviceFailure(status)) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        RedistributionCompositeVolumeCompletionRoutine(syncPacket->Context,
                                                       status);
        delete syncPacket;
        return;
    }

    if (!NT_SUCCESS(status)) {
        t->MaxTransfer(ioPacket);
        return;
    }

    rowSize = t->_totalWidth*t->_stripeSize;
    rowNum = ioPacket->Offset/rowSize;
    rowOffset = ioPacket->Offset%rowSize;
    firstSize = t->_firstWidth*t->_stripeSize;

    ioPacket->CompletionRoutine = RedistributionSyncPhase3;
    ioPacket->ReadPacket = FALSE;

    if (rowOffset < firstSize) {
        ioPacket->Offset = rowNum*firstSize + rowOffset;
    } else {
        ioPacket->Offset = rowNum*(rowSize - firstSize) + rowOffset - firstSize;
        ioPacket->TargetVolume = t->GetMemberUnprotected(1);
        ioPacket->WhichMember = 1;
    }

    TRANSFER(ioPacket);
}

VOID
RedistributionSyncPhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for the lock part of a sync.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_SYNC_TP syncPacket = (PREDISTRIBUTION_SYNC_TP) TransferPacket;
    PREDISTRIBUTION         t = syncPacket->Redistribution;
    PREDISTRIBUTION_TP      packet = &syncPacket->IoPacket;

    packet->Offset = t->_state.BytesRedistributed;
    if (packet->Offset + packet->Length > t->_firstSize) {
        packet->Length = (ULONG) (t->_firstSize - packet->Offset);
    }

    packet->CompletionRoutine = RedistributionSyncPhase2;
    packet->TargetVolume = t->GetMemberUnprotected(0);
    packet->Thread = PsGetCurrentThread();
    packet->ReadPacket = TRUE;
    packet->WhichMember = 0;

    TRANSFER(packet);
}

VOID
REDISTRIBUTION::StartSyncOperations(
    IN      BOOLEAN                 RegenerateOrphans,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This routine starts off the redistribution of the data.

Arguments:

    RegenerateOrphans   - Supplies whether or not to try and regenerate
                            orphaned members.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the context for the completion routine.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    PREDISTRIBUTION_SYNC_TP         syncPacket;
    KIRQL                           irql;
    PREDISTRIBUTION_TP              packet;

    if (_redistributionComplete) {
        COMPOSITE_FT_VOLUME::StartSyncOperations(RegenerateOrphans,
                                                 CompletionRoutine, Context);
        return;
    }

    context = (PFT_COMPLETION_ROUTINE_CONTEXT)
              ExAllocatePool(NonPagedPool,
                             sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    if (!context) {
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    syncPacket = new REDISTRIBUTION_SYNC_TP;
    if (!syncPacket) {
        ExFreePool(context);
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    if (!syncPacket->IoPacket.AllocateMdl(_stripeSize)) {
        delete syncPacket;
        ExFreePool(context);
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    KeInitializeSpinLock(&context->SpinLock);
    context->Status = STATUS_SUCCESS;
    context->RefCount = 2;
    context->CompletionRoutine = CompletionRoutine;
    context->Context = Context;
    context->ParentVolume = this;

    COMPOSITE_FT_VOLUME::StartSyncOperations(
            RegenerateOrphans, RedistributionCompositeVolumeCompletionRoutine,
            context);

    KeAcquireSpinLock(&_spinLock, &irql);
    if (_syncOk) {
        _syncOk = FALSE;
        _stopSyncs = FALSE;
    } else {
        KeReleaseSpinLock(&_spinLock, irql);
        RedistributionCompositeVolumeCompletionRoutine(context, STATUS_SUCCESS);
        return;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    syncPacket->Mdl = NULL;
    syncPacket->Offset = _state.BytesRedistributed;
    syncPacket->Length = _stripeSize;
    syncPacket->CompletionRoutine = RedistributionSyncPhase1;
    syncPacket->TargetVolume = this;
    syncPacket->Thread = PsGetCurrentThread();
    syncPacket->IrpFlags = SL_OVERRIDE_VERIFY_VOLUME;
    syncPacket->ReadPacket = TRUE;
    syncPacket->Context = context;
    syncPacket->Redistribution = this;

    packet = &syncPacket->IoPacket;
    packet->Length = _stripeSize;
    packet->IrpFlags = SL_OVERRIDE_VERIFY_VOLUME;
    packet->MasterPacket = syncPacket;
    packet->Redistribution = this;

    _overlappedIoManager.AcquireIoRegion(syncPacket, TRUE);
}

VOID
REDISTRIBUTION::StopSyncOperations(
    )

/*++

Routine Description:

    This routine stops all sync operations.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KIRQL   irql;

    COMPOSITE_FT_VOLUME::StopSyncOperations();

    KeAcquireSpinLock(&_spinLock, &irql);
    _stopSyncs = TRUE;
    KeReleaseSpinLock(&_spinLock, irql);
}

LONGLONG
REDISTRIBUTION::QueryVolumeSize(
    )

/*++

Routine Description:

    Returns the number of bytes on the entire volume.

Arguments:

    None.

Return Value:

    The volume size in bytes.

--*/

{
    return _redistributionComplete ? _totalSize : _firstSize;
}

VOID
REDISTRIBUTION::CompleteNotification(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine is called to notify the volume that it is complete and
    to therefore prepare for incoming requests.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    LONGLONG    firstRowSize, numRows, secondRowSize, tmpNumRows;

    COMPOSITE_FT_VOLUME::CompleteNotification(IoPending);

    _firstSize = GetMember(0)->QueryVolumeSize();
    firstRowSize = _firstWidth*_stripeSize;
    numRows = _firstSize/firstRowSize;
    secondRowSize = (_totalWidth - _firstWidth)*_stripeSize;
    tmpNumRows = GetMember(1)->QueryVolumeSize()/secondRowSize;
    if (tmpNumRows < numRows) {
        numRows = tmpNumRows;
    }
    _totalSize = numRows*_totalWidth*_stripeSize;

    if (_state.BytesRedistributed >= _firstSize) {
        _redistributionComplete = TRUE;
    }
}

VOID
REDISTRIBUTION::NewStateArrival(
    IN  PVOID   NewStateInstance
    )

/*++

Routine Description:

    This routine takes the new state instance arrival combined with its
    current state to come up with the new current state for the volume.
    If the two states cannot be reconciled then this routine returns FALSE
    indicating that the volume is invalid and should be broken into its
    constituant parts.

Arguments:

    NewStateInstance    - Supplies the new state instance.

Return Value:

    None.

--*/

{
    BOOLEAN                                 changed = FALSE;
    PFT_REDISTRIBUTION_STATE_INFORMATION    state;

    state = (PFT_REDISTRIBUTION_STATE_INFORMATION) NewStateInstance;
    if (state->BytesRedistributed > _state.BytesRedistributed) {
        _state.BytesRedistributed = state->BytesRedistributed;
        changed = TRUE;
    }

    if (changed) {
        PropogateStateChanges(NULL, NULL);
    }
}

VOID
RedistributionTransferCompletionRoutine(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for REDISTRIBUTION::RedistributionDispatch.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP  transferPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    KIRQL               irql;


    if (!NT_SUCCESS(status)) {
        KeAcquireSpinLock(&masterPacket->SpinLock, &irql);
        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
        }
        KeReleaseSpinLock(&masterPacket->SpinLock, irql);
    }

    delete transferPacket;

    if (!InterlockedDecrement(&masterPacket->RefCount)) {
        masterPacket->CompletionRoutine(masterPacket);
    }
}

VOID
REDISTRIBUTION::RedistributeTransfer(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine launches the given transfer packet using the new
    redistributed data allocation scheme.

Arguments:

    TransferPacket      - Supplies the transfer packet to launch.

Return Value:

    None.

--*/

{
    LONGLONG                begin, end;
    LONGLONG                rowSize, firstSize, rowBegin, rowOffsetBegin, rowEnd, rowOffsetEnd;
    ULONG                   numRequests, i, numRows;
    PCHAR                   vp;
    LIST_ENTRY              q;
    LONGLONG                off, off2;
    ULONG                   len, len2;
    USHORT                  whichMember;
    BOOLEAN                 two;
    PREDISTRIBUTION_TP      p;
    PLIST_ENTRY             l;

    begin = TransferPacket->Offset;
    end = TransferPacket->Offset + TransferPacket->Length;
    rowSize = _totalWidth*_stripeSize;
    rowBegin = begin/rowSize;
    rowOffsetBegin = begin%rowSize;
    rowEnd = end/rowSize;
    rowOffsetEnd = end%rowSize;
    firstSize = _firstWidth*_stripeSize;

    if (TransferPacket->Mdl) {
        vp = (PCHAR) MmGetMdlVirtualAddress(TransferPacket->Mdl);
    }
    InitializeListHead(&q);
    numRows = (ULONG) (rowEnd - rowBegin + 1);
    numRequests = 0;
    for (i = 0; i < numRows; i++) {

        if (i == 0) {
            if (numRows == 1) {
                if (rowOffsetBegin < firstSize) {
                    if (rowOffsetEnd > firstSize) {
                        two = TRUE;
                        whichMember = 0;
                        off = rowBegin*firstSize + rowOffsetBegin;
                        len = (ULONG) (firstSize - rowOffsetBegin);
                        off2 = rowBegin*(rowSize - firstSize);
                        len2 = (ULONG) (rowOffsetEnd - firstSize);
                    } else {
                        two = FALSE;
                        whichMember = 0;
                        off = rowBegin*firstSize + rowOffsetBegin;
                        len = (ULONG) (rowOffsetEnd - rowOffsetBegin);
                    }
                } else {
                    two = FALSE;
                    whichMember = 1;
                    off = rowBegin*(rowSize - firstSize) + rowOffsetBegin -
                          firstSize;
                    len = (ULONG) (rowOffsetEnd - rowOffsetBegin);
                }
            } else {
                if (rowOffsetBegin < firstSize) {
                    two = TRUE;
                    whichMember = 0;
                    off = rowBegin*firstSize + rowOffsetBegin;
                    len = (ULONG) (firstSize - rowOffsetBegin);
                    off2 = rowBegin*(rowSize - firstSize);
                    len2 = (ULONG) (rowSize - firstSize);
                } else {
                    two = FALSE;
                    whichMember = 1;
                    off = rowBegin*(rowSize - firstSize) + rowOffsetBegin -
                          firstSize;
                    len = (ULONG) (rowSize - rowOffsetBegin);
                }
            }
        } else if (i == numRows - 1) {
            if (!rowOffsetEnd) {
                continue;
            }
            if (rowOffsetEnd > firstSize) {
                two = TRUE;
                whichMember = 0;
                off = rowEnd*firstSize;
                len = (ULONG) firstSize;
                off2 = rowEnd*(rowSize - firstSize);
                len2 = (ULONG) (rowOffsetEnd - firstSize);
            } else {
                two = FALSE;
                whichMember = 0;
                off = rowEnd*firstSize;
                len = (ULONG) rowOffsetEnd;
            }
        } else {
            two = TRUE;
            whichMember = 0;
            len = (ULONG) firstSize;
            len2 = (ULONG) (rowSize - firstSize);
            off = (rowBegin + i)*len;
            off2 = (rowBegin + i)*len2;
        }

        p = new REDISTRIBUTION_TP;
        if (!p) {
            break;
        }
        if (!two && numRows == 1) {
            p->Mdl = TransferPacket->Mdl;
        } else {
            if (TransferPacket->Mdl) {
                if (p->AllocateMdl(vp, len)) {
                    IoBuildPartialMdl(TransferPacket->Mdl, p->Mdl, vp, len);
                } else {
                    delete p;
                    break;
                }
                vp += len;
            } else {
                p->Mdl = TransferPacket->Mdl;
            }
        }

        p->Length = len;
        p->Offset = off;
        p->CompletionRoutine = RedistributionTransferCompletionRoutine;
        p->TargetVolume = GetMemberUnprotected(whichMember);
        p->Thread = TransferPacket->Thread;
        p->IrpFlags = TransferPacket->IrpFlags;
        p->ReadPacket = TransferPacket->ReadPacket;
        p->SpecialRead = TransferPacket->SpecialRead;
        p->MasterPacket = TransferPacket;
        p->Redistribution = this;
        p->WhichMember = whichMember;

        InsertTailList(&q, &p->QueueEntry);
        numRequests++;

        if (!two) {
            continue;
        }

        p = new REDISTRIBUTION_TP;
        if (!p) {
            break;
        }
        if (TransferPacket->Mdl) {
            if (p->AllocateMdl(vp, len2)) {
                IoBuildPartialMdl(TransferPacket->Mdl, p->Mdl, vp, len2);
            } else {
                delete p;
                break;
            }
            vp += len2;
        } else {
            p->Mdl = TransferPacket->Mdl;
        }

        p->Length = len2;
        p->Offset = off2;
        p->CompletionRoutine = RedistributionTransferCompletionRoutine;
        p->TargetVolume = GetMemberUnprotected(1);
        p->Thread = TransferPacket->Thread;
        p->IrpFlags = TransferPacket->IrpFlags;
        p->ReadPacket = TransferPacket->ReadPacket;
        p->SpecialRead = TransferPacket->SpecialRead;
        p->MasterPacket = TransferPacket;
        p->Redistribution = this;
        p->WhichMember = 1;

        InsertTailList(&q, &p->QueueEntry);
        numRequests++;
    }

    if (i < numRows) {
        while (!IsListEmpty(&q)) {
            l = RemoveHeadList(&q);
            p = CONTAINING_RECORD(l, REDISTRIBUTION_TP, QueueEntry);
            delete p;
        }
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    KeInitializeSpinLock(&TransferPacket->SpinLock);
    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;
    TransferPacket->RefCount = numRequests;

    while (!IsListEmpty(&q)) {
        l = RemoveHeadList(&q);
        p = CONTAINING_RECORD(l, REDISTRIBUTION_TP, QueueEntry);
        TRANSFER(p);
    }
}

VOID
RedistributeReplaceBadSectorCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for REDISTRIBUTION::RedistributionReplaceBadSector.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP  transferPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;

    masterPacket->IoStatus = transferPacket->IoStatus;
    delete transferPacket;
    masterPacket->CompletionRoutine(masterPacket);
}

VOID
REDISTRIBUTION::RedistributeReplaceBadSector(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine launches the given transfer packet using the new
    redistributed data allocation scheme.

Arguments:

    TransferPacket      - Supplies the transfer packet to launch.

Return Value:

    None.

--*/

{
    LONGLONG            begin, rowSize, rowBegin, rowOffsetBegin, firstSize, offset;
    USHORT              whichMember;
    PREDISTRIBUTION_TP  p;

    begin = TransferPacket->Offset;
    rowSize = _totalWidth*_stripeSize;
    rowBegin = begin/rowSize;
    rowOffsetBegin = begin%rowSize;
    firstSize = _firstWidth*_stripeSize;

    if (rowOffsetBegin < firstSize) {
        offset = rowBegin*firstSize + rowOffsetBegin;
        whichMember = 0;
    } else {
        offset = rowBegin*(rowSize - firstSize) + rowOffsetBegin - firstSize;
        whichMember = 1;
    }

    p = new REDISTRIBUTION_TP;
    if (!p) {
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    p->Mdl = TransferPacket->Mdl;
    p->Length = TransferPacket->Length;
    p->Offset = offset;
    p->CompletionRoutine = RedistributeReplaceBadSectorCompletion;
    p->TargetVolume = GetMemberUnprotected(whichMember);
    p->Thread = TransferPacket->Thread;
    p->IrpFlags = TransferPacket->IrpFlags;
    p->ReadPacket = TransferPacket->ReadPacket;
    p->SpecialRead = TransferPacket->SpecialRead;
    p->MasterPacket = TransferPacket;
    p->Redistribution = this;
    p->WhichMember = whichMember;

    p->TargetVolume->ReplaceBadSector(p);
}

VOID
RedistributionPropogateStateChangesWorker(
    IN  PVOID   WorkItem
    )

/*++

Routine Description:

    This routine is a worker thread routine for propogating state changes.

Arguments:

    Mirror  - Supplies a pointer to the mirror object.

Return Value:

    None.

--*/

{
    PPROPOGATE_CHANGES_WORK_ITEM        workItem = (PPROPOGATE_CHANGES_WORK_ITEM) WorkItem;
    PREDISTRIBUTION                     t = workItem->Redistribution;
    NTSTATUS                            status;
    KIRQL                               irql;
    FT_REDISTRIBUTION_STATE_INFORMATION state;

    status = FtpAcquireWithTimeout(t->_rootExtension);
    if (!NT_SUCCESS(status)) {
        if (workItem->CompletionRoutine) {
            workItem->CompletionRoutine(workItem->Context, status);
        }
        return;
    }

    KeAcquireSpinLock(&t->_spinLock, &irql);
    RtlCopyMemory(&state, &t->_state, sizeof(state));
    KeReleaseSpinLock(&t->_spinLock, irql);

    status = t->_diskInfoSet->WriteStateInformation(t->QueryLogicalDiskId(),
                                                    &state, sizeof(state));

    FtpRelease(t->_rootExtension);

    if (workItem->CompletionRoutine) {
        workItem->CompletionRoutine(workItem->Context, status);
    }
}

VOID
REDISTRIBUTION::PropogateStateChanges(
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine propogates the changes in the local memory state to
    the on disk state.

Arguments:

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the context.

Return Value:

    None.

--*/

{
    PPROPOGATE_CHANGES_WORK_ITEM    workItem;

    workItem = (PPROPOGATE_CHANGES_WORK_ITEM)
               ExAllocatePool(NonPagedPool,
                              sizeof(PROPOGATE_CHANGES_WORK_ITEM));
    if (!workItem) {
        return;
    }
    workItem->Redistribution = this;
    workItem->CompletionRoutine = CompletionRoutine;
    workItem->Context = Context;

    ExInitializeWorkItem(workItem, RedistributionPropogateStateChangesWorker,
                         workItem);

    FtpQueueWorkItem(_rootExtension, workItem);
}

VOID
RedistributionMaxTransferCompletionRoutine(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a sector transfer subordinate
    to a MAX transfer operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP  subPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PREDISTRIBUTION_TP  masterPacket = (PREDISTRIBUTION_TP) subPacket->MasterPacket;
    NTSTATUS            status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        delete subPacket;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        delete subPacket;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Offset += subPacket->Length;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
REDISTRIBUTION::MaxTransfer(
    IN OUT  PREDISTRIBUTION_TP  TransferPacket
    )

/*++

Routine Description:

    This routine propogates sector by sector the given transfer packet,
    ignoring errors.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP  subPacket;

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;

    subPacket = new REDISTRIBUTION_TP;
    if (!subPacket) {
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    subPacket->Length = QuerySectorSize();
    subPacket->Offset = TransferPacket->Offset;
    subPacket->CompletionRoutine = RedistributionMaxTransferCompletionRoutine;
    subPacket->TargetVolume = TransferPacket->TargetVolume;
    subPacket->Thread = TransferPacket->Thread;
    subPacket->IrpFlags = TransferPacket->IrpFlags;
    subPacket->ReadPacket = TransferPacket->ReadPacket;
    subPacket->MasterPacket = TransferPacket;
    subPacket->Redistribution = this;
    subPacket->WhichMember = TransferPacket->WhichMember;

    if (!subPacket->AllocateMdl((PVOID) (PAGE_SIZE - 1), subPacket->Length)) {
        delete subPacket;
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    IoBuildPartialMdl(TransferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
RedistributionVerifyWriteCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a verify write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP  verifyPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PREDISTRIBUTION_TP  masterPacket = (PREDISTRIBUTION_TP) verifyPacket->MasterPacket;
    NTSTATUS            status = verifyPacket->IoStatus.Status;
    PVOID               p, q;
    ULONG               l;

    if (!NT_SUCCESS(status)) {
        masterPacket->IoStatus = verifyPacket->IoStatus;
        delete verifyPacket;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    p = MmGetSystemAddressForMdl(verifyPacket->Mdl);
    q = MmGetSystemAddressForMdl(masterPacket->Mdl);
    l = (ULONG)RtlCompareMemory(p, q, verifyPacket->Length);
    if (l != verifyPacket->Length) {
        masterPacket->IoStatus.Status = STATUS_DEVICE_DATA_ERROR;
        masterPacket->IoStatus.Information = 0;
    }

    delete verifyPacket;
    masterPacket->CompletionRoutine(masterPacket);
}

VOID
REDISTRIBUTION::VerifyWrite(
    IN OUT  PREDISTRIBUTION_TP  TransferPacket
    )

/*++

Routine Description:

    This routine verifies that the given write was success by reading
    and comparing.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP  verifyPacket;

    verifyPacket = new REDISTRIBUTION_TP;
    if (!verifyPacket) {
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    if (!verifyPacket->AllocateMdl(TransferPacket->Length)) {
        delete verifyPacket;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    verifyPacket->Length = TransferPacket->Length;
    verifyPacket->Offset = TransferPacket->Offset;
    verifyPacket->CompletionRoutine = RedistributionVerifyWriteCompletion;
    verifyPacket->TargetVolume = TransferPacket->TargetVolume;
    verifyPacket->Thread = TransferPacket->Thread;
    verifyPacket->IrpFlags = TransferPacket->IrpFlags;
    verifyPacket->ReadPacket = TRUE;
    verifyPacket->MasterPacket = TransferPacket;
    verifyPacket->Redistribution = this;
    verifyPacket->WhichMember = TransferPacket->WhichMember;

    TRANSFER(verifyPacket);
}

VOID
RedistributionCarefulWritePhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    );

VOID
RedistributionCarefulWritePhase5(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a sector read subordinate
    to a carefule write operation after a replace bad sector.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_CW_TP   subPacket = (PREDISTRIBUTION_CW_TP) TransferPacket;
    PREDISTRIBUTION_TP      masterPacket = (PREDISTRIBUTION_TP) subPacket->MasterPacket;
    NTSTATUS                status = subPacket->IoStatus.Status;
    PVOID                   p, q;
    ULONG                   l;

    if (NT_SUCCESS(status)) {
        p = MmGetSystemAddressForMdl(subPacket->PartialMdl);
        q = MmGetSystemAddressForMdl(subPacket->VerifyMdl);
        l = (ULONG)RtlCompareMemory(p, q, subPacket->Length);
    } else {
        l = 0;
    }

    if (l != subPacket->Length) {
        masterPacket->IoStatus = subPacket->IoStatus;
        delete subPacket;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        delete subPacket;
        masterPacket->IoStatus.Status = STATUS_SUCCESS;
        masterPacket->IoStatus.Information = masterPacket->Length;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Offset += subPacket->Length;
    subPacket->CompletionRoutine = RedistributionCarefulWritePhase1;
    subPacket->ReadPacket = FALSE;

    subPacket->Mdl = subPacket->PartialMdl;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
RedistributionCarefulWritePhase4(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a sector write subordinate
    to a carefule write operation after a sector replace operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_CW_TP   subPacket = (PREDISTRIBUTION_CW_TP) TransferPacket;
    PREDISTRIBUTION_TP      masterPacket = (PREDISTRIBUTION_TP) subPacket->MasterPacket;
    NTSTATUS                status = subPacket->IoStatus.Status;

    if (!NT_SUCCESS(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        delete subPacket;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Mdl = subPacket->VerifyMdl;
    subPacket->CompletionRoutine = RedistributionCarefulWritePhase5;
    subPacket->ReadPacket = TRUE;

    TRANSFER(subPacket);
}

VOID
RedistributionCarefulWritePhase3(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a sector replace subordinate
    to a carefule write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_CW_TP   subPacket = (PREDISTRIBUTION_CW_TP) TransferPacket;
    PREDISTRIBUTION_TP      masterPacket = (PREDISTRIBUTION_TP) subPacket->MasterPacket;

    subPacket->CompletionRoutine = RedistributionCarefulWritePhase4;
    subPacket->ReadPacket = FALSE;

    subPacket->Mdl = subPacket->PartialMdl;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
RedistributionCarefulWritePhase2(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a sector read subordinate
    to a carefule write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_CW_TP   subPacket = (PREDISTRIBUTION_CW_TP) TransferPacket;
    PREDISTRIBUTION_TP      masterPacket = (PREDISTRIBUTION_TP) subPacket->MasterPacket;
    NTSTATUS                status = subPacket->IoStatus.Status;
    PVOID                   p, q;
    ULONG                   l;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        delete subPacket;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (NT_SUCCESS(status)) {
        p = MmGetSystemAddressForMdl(subPacket->PartialMdl);
        q = MmGetSystemAddressForMdl(subPacket->VerifyMdl);
        l = (ULONG)RtlCompareMemory(p, q, subPacket->Length);
    } else {
        l = 0;
    }

    if (l != subPacket->Length) {
        subPacket->CompletionRoutine = RedistributionCarefulWritePhase3;
        subPacket->TargetVolume->ReplaceBadSector(subPacket);
        return;
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        delete subPacket;
        masterPacket->IoStatus.Status = STATUS_SUCCESS;
        masterPacket->IoStatus.Information = masterPacket->Length;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Offset += subPacket->Length;
    subPacket->CompletionRoutine = RedistributionCarefulWritePhase1;
    subPacket->ReadPacket = FALSE;

    subPacket->Mdl = subPacket->PartialMdl;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
RedistributionCarefulWritePhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a sector write subordinate
    to a carefule write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_CW_TP   subPacket = (PREDISTRIBUTION_CW_TP) TransferPacket;
    PREDISTRIBUTION_TP      masterPacket = (PREDISTRIBUTION_TP) subPacket->MasterPacket;
    NTSTATUS                status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        delete subPacket;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status)) {
        subPacket->CompletionRoutine = RedistributionCarefulWritePhase3;
        subPacket->TargetVolume->ReplaceBadSector(subPacket);
        return;
    }

    subPacket->Mdl = subPacket->VerifyMdl;
    subPacket->CompletionRoutine = RedistributionCarefulWritePhase2;
    subPacket->ReadPacket = TRUE;

    TRANSFER(subPacket);
}

VOID
REDISTRIBUTION::CarefulWrite(
    IN OUT  PREDISTRIBUTION_TP  TransferPacket
    )

/*++

Routine Description:

    This routine writes the given packet, sector by sector, replacing
    bad sectors if need be.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_CW_TP   subPacket;

    ASSERT(!TransferPacket->ReadPacket);

    subPacket = new REDISTRIBUTION_CW_TP;
    if (!subPacket) {
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    subPacket->Length = QuerySectorSize();
    subPacket->Offset = TransferPacket->Offset;
    subPacket->CompletionRoutine = RedistributionCarefulWritePhase1;
    subPacket->TargetVolume = TransferPacket->TargetVolume;
    subPacket->Thread = TransferPacket->Thread;
    subPacket->IrpFlags = TransferPacket->IrpFlags;
    subPacket->ReadPacket = FALSE;
    subPacket->MasterPacket = TransferPacket;
    subPacket->Redistribution = TransferPacket->Redistribution;
    subPacket->WhichMember = TransferPacket->WhichMember;

    if (!subPacket->AllocateMdls(subPacket->Length)) {
        delete subPacket;
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(TransferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl),
                      subPacket->Length);

    TRANSFER(subPacket);
}

NTSTATUS
REDISTRIBUTION::QueryPhysicalOffsets(
    IN  LONGLONG                    LogicalOffset,
    OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
    OUT PULONG                      NumberOfPhysicalOffsets
    )
/*++

Routine Description:

    This routine returns physical disk and offset for a given volume
    logical offset.

Arguments:

    LogicalOffset           - Supplies the logical offset

    PhysicalOffsets         - Returns the physical offsets

    NumberOfPhysicalOffsets - Returns the number of physical offsets

Return Value:

    NTSTATUS

--*/
{
    USHORT      n, whichMember, whichStripeInSet;
    LONGLONG    whichStripe, whichSet, whichRow; 
    LONGLONG    bytesRedistributed, logicalOffsetInMember;
    PFT_VOLUME  vol;
    KIRQL       irql;

    if (LogicalOffset < 0) {
        return STATUS_INVALID_PARAMETER;
    }

    if (_redistributionComplete) {
        if (_totalSize <= LogicalOffset) {
            return STATUS_INVALID_PARAMETER;
        }
    } else {
        KeAcquireSpinLock(&_spinLock, &irql);
        bytesRedistributed = _state.BytesRedistributed;
        KeReleaseSpinLock(&_spinLock, irql);
        if (bytesRedistributed <= LogicalOffset) {
            return STATUS_INVALID_PARAMETER;
        }
    }
       
    ASSERT(_stripeSize);
    ASSERT(_totalWidth);

    whichStripe = LogicalOffset/_stripeSize;
    whichSet = whichStripe/_totalWidth;
    whichStripeInSet = (USHORT) (whichStripe%_totalWidth);
    if (whichStripeInSet < _firstWidth) {
        whichMember = 0;
        whichRow = whichSet*_firstWidth + whichStripeInSet;
    } else {
        whichMember = 1;
        whichRow = whichSet*(_totalWidth-_firstWidth) + whichStripeInSet - _firstWidth;
    }

    vol = GetMember(whichMember);
    if (!vol) {
        return STATUS_INVALID_PARAMETER;
    }

    logicalOffsetInMember = whichRow*_stripeSize + LogicalOffset%_stripeSize;
    
    return vol->QueryPhysicalOffsets(logicalOffsetInMember, PhysicalOffsets, NumberOfPhysicalOffsets);
}

NTSTATUS
REDISTRIBUTION::QueryLogicalOffset(
    IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
    OUT PLONGLONG               LogicalOffset
    )
/*++

Routine Description:

    This routine returns the volume logical offset for a given disk number
    and physical offset.

Arguments:

    PhysicalOffset          - Supplies the physical offset

    LogicalOffset           - Returns the logical offset

Return Value:

    NTSTATUS

--*/
{    
    USHORT      n, i, whichStripeInSet;
    LONGLONG    whichStripe, whichSet, whichRow, bytesRedistributed; 
    LONGLONG    logicalOffset, logicalOffsetInMember;
    NTSTATUS    status;
    PFT_VOLUME  vol;
    KIRQL       irql;
    
    n = QueryNumMembers();
    
    ASSERT(n == 2);
    ASSERT(_stripeSize);
    ASSERT(_firstWidth);
    ASSERT(_totalWidth > _firstWidth);

    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }
        status = vol->QueryLogicalOffset(PhysicalOffset, &logicalOffsetInMember);
        if (NT_SUCCESS(status)) {
            whichRow = logicalOffsetInMember/_stripeSize;
            if (i == 0) {
                whichSet = whichRow/_firstWidth; 
                whichStripeInSet = (USHORT) (whichRow%_firstWidth); 
            } else {
                ASSERT(i == 1);
                whichSet = whichRow/(_totalWidth-_firstWidth);
                whichStripeInSet = (USHORT) (whichRow%(_totalWidth-_firstWidth)) + _firstWidth;
            }
            whichStripe = whichSet*_totalWidth + whichStripeInSet;
            logicalOffset = whichStripe*_stripeSize + logicalOffsetInMember%_stripeSize;
            
            if (_redistributionComplete) {
                if (_totalSize <= logicalOffset) {
                    return STATUS_INVALID_PARAMETER;
                }
            } else {
                KeAcquireSpinLock(&_spinLock, &irql);
                bytesRedistributed = _state.BytesRedistributed;
                KeReleaseSpinLock(&_spinLock, irql);
                if (bytesRedistributed <= logicalOffset) {
                    return STATUS_INVALID_PARAMETER;
                }
            }

            *LogicalOffset = logicalOffset;
            return status;
        }        
    }

  return STATUS_INVALID_PARAMETER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\parity.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    parity.cxx

Abstract:

    This module contains code specific to the parity io manager.

    The purpose of this module is to help serialize parity updates that
    overlaps with each other.  This class is used by stripes with parity.

Author:

    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
PARITY_IO_MANAGER::Initialize(
    IN  ULONG   BucketSize,
    IN  ULONG   SectorSize
    )

/*++

Routine Description:

    This routine initializes a parity io manager.

Arguments:

    BucketSize  - Supplies the bucket size.  Any I/O to this class may
                    not span more than one bucket.  In the case of stripes
                    with parity, the bucket size is the stripe size.

    SectorSize  - Supplies the sector size.

Return Value:

    NTSTATUS

--*/

{
    ULONG   i;

    _numQueues = 256;
    _bucketSize = BucketSize;
    _sectorSize = SectorSize;
    _spinLock = (PKSPIN_LOCK)
                ExAllocatePool(NonPagedPool, _numQueues*sizeof(KSPIN_LOCK));
    if (!_spinLock) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _ioQueue = (PLIST_ENTRY)
               ExAllocatePool(NonPagedPool, _numQueues*sizeof(LIST_ENTRY));
    if (!_ioQueue) {
        ExFreePool(_spinLock);
        _spinLock = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (i = 0; i < _numQueues; i++) {
        KeInitializeSpinLock(&_spinLock[i]);
        InitializeListHead(&_ioQueue[i]);
    }

    _ePacket = new PARITY_TP;
    if (_ePacket && !_ePacket->AllocateMdl(_bucketSize)) {
        delete _ePacket;
        _ePacket = NULL;
    }
    if (!_ePacket) {
        ExFreePool(_spinLock);
        _spinLock = NULL;
        ExFreePool(_ioQueue);
        _ioQueue = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    _ePacketInUse = FALSE;
    _ePacketQueueBeingServiced = FALSE;
    InitializeListHead(&_ePacketQueue);
    KeInitializeSpinLock(&_ePacketSpinLock);

    return STATUS_SUCCESS;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

VOID
UpdateParityCompletionRoutine(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion routine for the read request associated
    with an (or many) update parity request.  This routine gets the
    update parity requests in the queue that follow it and smash them into
    its buffer and then write the parity block out to disk.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PPARITY_TP          transferPacket = (PPARITY_TP) TransferPacket;
    PPARITY_IO_MANAGER  t = transferPacket->ParityIoManager;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    ULONG               queueNumber;
    PLIST_ENTRY         q, qq;
    PKSPIN_LOCK         spin;
    KIRQL               irql, irql2;
    PLIST_ENTRY         l;
    PPARITY_TP          p, packet, ep;
    PCHAR               target;
    ULONG               bucketOffset;
    PVOID               source;
    BOOLEAN             tpRemoved;
    BOOLEAN             wasIdle, wasReadPacket;

    if (!transferPacket->ReadPacket) {

        if (!NT_SUCCESS(status) && !transferPacket->OneWriteFailed &&
            !FsRtlIsTotalDeviceFailure(status)) {

            transferPacket->OneWriteFailed = TRUE;
            t->CarefulWrite(transferPacket);
            return;
        }

        q = &transferPacket->UpdateQueue;
        while (!IsListEmpty(q)) {
            l = RemoveHeadList(q);
            p = CONTAINING_RECORD(l, PARITY_TP, UpdateQueue);

            p->IoStatus.Status = status;
            if (NT_SUCCESS(status)) {
                p->IoStatus.Information = p->Length;
            } else {
                p->IoStatus.Information = 0;
                p->ReadPacket = FALSE;  // Indicate a write failure.
            }

            p->CompletionRoutine(p);
        }
    }

    wasReadPacket = transferPacket->ReadPacket;
    transferPacket->ReadPacket = FALSE;

    queueNumber = (ULONG) (transferPacket->BucketNumber%t->_numQueues);
    q = &t->_ioQueue[queueNumber];
    spin = &t->_spinLock[queueNumber];

    KeAcquireSpinLock(spin, &irql);
    for (l = transferPacket->OverlapQueue.Flink; l != q; l = l->Flink) {

        p = CONTAINING_RECORD(l, PARITY_TP, OverlapQueue);

        if (p->BucketNumber == transferPacket->BucketNumber) {
            RemoveEntryList(&p->OverlapQueue);
            InsertTailList(&transferPacket->UpdateQueue, &p->UpdateQueue);

            if (p->Offset < transferPacket->Offset) {
                transferPacket->Length += (ULONG) (transferPacket->Offset - p->Offset);
                transferPacket->Offset = p->Offset;
                transferPacket->ReadPacket = TRUE;
            }

            if (p->Offset + p->Length >
                transferPacket->Offset + transferPacket->Length) {

                transferPacket->Length += (ULONG)
                        ((p->Offset + p->Length) -
                         (transferPacket->Offset + transferPacket->Length));
                transferPacket->ReadPacket = TRUE;
            }
        }
    }
    if (!NT_SUCCESS(status) || IsListEmpty(&transferPacket->UpdateQueue)) {
        if (wasReadPacket && IsListEmpty(&transferPacket->UpdateQueue)) {
            transferPacket->ReadPacket = TRUE;
            transferPacket->Idle = TRUE;
            KeReleaseSpinLock(spin, irql);
            return;
        }

        RemoveEntryList(&transferPacket->OverlapQueue);
        KeReleaseSpinLock(spin, irql);
        tpRemoved = TRUE;

    } else {
        KeReleaseSpinLock(spin, irql);
        tpRemoved = FALSE;
    }

    if (tpRemoved) {

        q = &transferPacket->UpdateQueue;
        while (!IsListEmpty(q)) {

            l = RemoveHeadList(q);
            p = CONTAINING_RECORD(l, PARITY_TP, UpdateQueue);

            p->IoStatus.Status = status;
            p->IoStatus.Information = 0;
            p->ReadPacket = wasReadPacket; // Indicate whether a read failure.

            p->CompletionRoutine(p);
        }

        if (transferPacket != t->_ePacket) {
            delete transferPacket;
        }

        KeAcquireSpinLock(&t->_ePacketSpinLock, &irql);
        if (t->_ePacketInUse && !t->_ePacketQueueBeingServiced) {
            t->_ePacketQueueBeingServiced = TRUE;
        } else {
            if (transferPacket == t->_ePacket) {
                t->_ePacketInUse = FALSE;
            }
            KeReleaseSpinLock(&t->_ePacketSpinLock, irql);
            return;
        }
        KeReleaseSpinLock(&t->_ePacketSpinLock, irql);

        for (;;) {

            KeAcquireSpinLock(&t->_ePacketSpinLock, &irql);
            if (IsListEmpty(&t->_ePacketQueue)) {
                if (transferPacket == t->_ePacket) {
                    t->_ePacketInUse = FALSE;
                }
                t->_ePacketQueueBeingServiced = FALSE;
                KeReleaseSpinLock(&t->_ePacketSpinLock, irql);
                break;
            }
            l = RemoveHeadList(&t->_ePacketQueue);
            KeReleaseSpinLock(&t->_ePacketSpinLock, irql);

            ep = CONTAINING_RECORD(l, PARITY_TP, OverlapQueue);

            queueNumber = (ULONG) (ep->BucketNumber%t->_numQueues);
            q = &t->_ioQueue[queueNumber];
            spin = &t->_spinLock[queueNumber];

            KeAcquireSpinLock(spin, &irql);
            for (l = q->Blink; l != q; l = l->Blink) {

                p = CONTAINING_RECORD(l, PARITY_TP, OverlapQueue);

                if (p->BucketNumber == ep->BucketNumber) {
                    break;
                }
            }
            if (l != q) {
                InsertTailList(q, &ep->OverlapQueue);
                wasIdle = p->Idle;
                p->Idle =  FALSE;
                KeReleaseSpinLock(spin, irql);
                if (wasIdle) {
                    p->CompletionRoutine(p);
                }
                continue;
            }

            packet = new PARITY_TP;
            if (packet && !packet->AllocateMdl(t->_bucketSize)) {
                delete packet;
                packet = NULL;
            }
            if (!packet) {
                if (transferPacket != t->_ePacket) {
                    KeAcquireSpinLock(&t->_ePacketSpinLock, &irql2);
                    if (t->_ePacketInUse) {
                        InsertHeadList(&t->_ePacketQueue, &ep->OverlapQueue);
                        t->_ePacketQueueBeingServiced = FALSE;
                        KeReleaseSpinLock(&t->_ePacketSpinLock, irql2);
                        KeReleaseSpinLock(spin, irql);
                        break;
                    }
                    t->_ePacketInUse = TRUE;
                    KeReleaseSpinLock(&t->_ePacketSpinLock, irql2);
                }
                packet = t->_ePacket;
            }

            packet->Length = t->_bucketSize;
            packet->Offset = ep->BucketNumber*t->_bucketSize;
            packet->CompletionRoutine = UpdateParityCompletionRoutine;
            packet->TargetVolume = ep->TargetVolume;
            packet->Thread = ep->Thread;
            packet->IrpFlags = ep->IrpFlags;
            packet->ReadPacket = TRUE;
            packet->Idle = FALSE;
            packet->OneWriteFailed = FALSE;
            InitializeListHead(&packet->UpdateQueue);
            packet->ParityIoManager = t;
            packet->BucketNumber = ep->BucketNumber;

            InsertTailList(q, &packet->OverlapQueue);
            InsertTailList(q, &ep->OverlapQueue);

            KeAcquireSpinLock(&t->_ePacketSpinLock, &irql2);
            qq = &t->_ePacketQueue;
            for (l = qq->Flink; l != qq; ) {
                p = CONTAINING_RECORD(l, PARITY_TP, OverlapQueue);
                l = l->Flink;
                if (p->BucketNumber == ep->BucketNumber) {
                    RemoveEntryList(&p->OverlapQueue);
                    InsertTailList(q, &p->OverlapQueue);
                }
            }
            KeReleaseSpinLock(&t->_ePacketSpinLock, irql2);
            KeReleaseSpinLock(spin, irql);

            TRANSFER(packet);

            if (packet == t->_ePacket) {
                KeAcquireSpinLock(&t->_ePacketSpinLock, &irql);
                if (!t->_ePacketInUse) {
                    KeReleaseSpinLock(&t->_ePacketSpinLock, irql);
                    continue;
                }
                t->_ePacketQueueBeingServiced = FALSE;
                KeReleaseSpinLock(&t->_ePacketSpinLock, irql);
                break;
            }
        }
        return;
    }

    if (!transferPacket->ReadPacket) {
        target = (PCHAR) MmGetSystemAddressForMdl(transferPacket->Mdl);
        q = &transferPacket->UpdateQueue;
        for (l = q->Flink; l != q; l = l->Flink) {

            p = CONTAINING_RECORD(l, PARITY_TP, UpdateQueue);

            bucketOffset = (ULONG) (p->Offset - transferPacket->Offset);
            source = MmGetSystemAddressForMdl(p->Mdl);
            FtpComputeParity(target + bucketOffset, source, p->Length);
        }
    }

    TRANSFER(transferPacket);
}

VOID
PARITY_IO_MANAGER::StartReadForUpdateParity(
    IN  LONGLONG    Offset,
    IN  ULONG       Length,
    IN  PFT_VOLUME  TargetVolume,
    IN  PETHREAD    Thread,
    IN  UCHAR       IrpFlags
    )

/*++

Routine Description:

    This routine lets the parity manager know that an update for the
    given offset and length will be coming so that the PARITY_IO_MANAGER
    can start the read ahead of the parity buffer.

Arguments:

    Offset          - Supplies the request offset.

    Length          - Supplies the request length.

    TargetVolume    - Supplies the target volume.

    Thread          - Supplies the thread context for this request.

    IrpFlags        - Supplies the irp flags for this request.

Return Value:

    None.

--*/

{
    KIRQL       irql;
    LONGLONG    bucketNumber;
    ULONG       queueNumber;
    PLIST_ENTRY q, l;
    PKSPIN_LOCK spin;
    PPARITY_TP  p;

    KeAcquireSpinLock(&_ePacketSpinLock, &irql);
    if (_ePacketInUse || _ePacketQueueBeingServiced) {
        KeReleaseSpinLock(&_ePacketSpinLock, irql);
        return;
    }
    KeReleaseSpinLock(&_ePacketSpinLock, irql);

    bucketNumber = Offset/_bucketSize;
    queueNumber = (ULONG) (bucketNumber%_numQueues);
    q = &_ioQueue[queueNumber];
    spin = &_spinLock[queueNumber];
    KeAcquireSpinLock(spin, &irql);
    for (l = q->Blink; l != q; l = l->Blink) {

        p = CONTAINING_RECORD(l, PARITY_TP, OverlapQueue);

        if (bucketNumber == p->BucketNumber) {
            KeReleaseSpinLock(spin, irql);
            return;
        }
    }
    p = new PARITY_TP;
    if (p && !p->AllocateMdl(_bucketSize)) {
        delete p;
        p = NULL;
    }
    if (!p) {
        KeReleaseSpinLock(spin, irql);
        return;
    }
    p->Length = Length;
    p->Offset = Offset;
    p->CompletionRoutine = UpdateParityCompletionRoutine;
    p->TargetVolume = TargetVolume;
    p->Thread = Thread;
    p->IrpFlags = IrpFlags;
    p->ReadPacket = TRUE;
    p->Idle = FALSE;
    p->OneWriteFailed = FALSE;
    InitializeListHead(&p->UpdateQueue);
    p->ParityIoManager = this;
    p->BucketNumber = bucketNumber;
    InsertTailList(q, &p->OverlapQueue);
    KeReleaseSpinLock(spin, irql);

    TRANSFER(p);
}

VOID
PARITY_IO_MANAGER::UpdateParity(
    IN OUT  PPARITY_TP  TransferPacket
    )

/*++

Routine Description:

    This routine xors the given buffer with the corresponding
    parity on disk and then writes out the result.

Arguments:

    TransferPacket  - Supplies the transfer packet containing the parity update.

Return Value:

    None.

--*/

{
    KIRQL               irql, irql2;
    ULONG               queueNumber;
    PLIST_ENTRY         q;
    PKSPIN_LOCK         spin;
    BOOLEAN             wasIdle;
    PLIST_ENTRY         l;
    PPARITY_TP          p, packet;

    TransferPacket->ReadPacket = FALSE;
    TransferPacket->Idle = FALSE;
    TransferPacket->ParityIoManager = this;
    TransferPacket->BucketNumber = TransferPacket->Offset/_bucketSize;

    queueNumber = (ULONG) (TransferPacket->BucketNumber%_numQueues);
    q = &_ioQueue[queueNumber];
    spin = &_spinLock[queueNumber];

    //
    // First figure out if there's already a read in progress for
    // the given parity bucket.  If there is then there is no
    // reason to queue another.  In this way, we can increase the
    // throughput on the parity section by collapsing the parity
    // updates.
    //

    KeAcquireSpinLock(spin, &irql);
    for (l = q->Blink; l != q; l = l->Blink) {

        p = CONTAINING_RECORD(l, PARITY_TP, OverlapQueue);

        if (p->BucketNumber == TransferPacket->BucketNumber) {
            break;
        }
    }
    if (l == q) {

        KeAcquireSpinLock(&_ePacketSpinLock, &irql2);
        if (_ePacketInUse || _ePacketQueueBeingServiced) {
            InsertTailList(&_ePacketQueue, &TransferPacket->OverlapQueue);
            KeReleaseSpinLock(&_ePacketSpinLock, irql2);
            KeReleaseSpinLock(spin, irql);
            return;
        }
        KeReleaseSpinLock(&_ePacketSpinLock, irql2);

        packet = new PARITY_TP;
        if (packet && !packet->AllocateMdl(_bucketSize)) {
            delete packet;
            packet = NULL;
        }
        if (!packet) {
            KeAcquireSpinLock(&_ePacketSpinLock, &irql2);
            if (_ePacketInUse || _ePacketQueueBeingServiced) {
                InsertTailList(&_ePacketQueue, &TransferPacket->OverlapQueue);
                KeReleaseSpinLock(&_ePacketSpinLock, irql2);
                KeReleaseSpinLock(spin, irql);
                return;
            }
            _ePacketInUse = TRUE;
            KeReleaseSpinLock(&_ePacketSpinLock, irql2);
            packet = _ePacket;
        }

        packet->Length = TransferPacket->Length;
        packet->Offset = TransferPacket->Offset;
        packet->CompletionRoutine = UpdateParityCompletionRoutine;
        packet->TargetVolume = TransferPacket->TargetVolume;
        packet->Thread = TransferPacket->Thread;
        packet->IrpFlags = TransferPacket->IrpFlags;
        packet->ReadPacket = TRUE;
        packet->Idle = FALSE;
        packet->OneWriteFailed = FALSE;
        InitializeListHead(&packet->UpdateQueue);
        packet->ParityIoManager = this;
        packet->BucketNumber = TransferPacket->BucketNumber;

        InsertTailList(q, &packet->OverlapQueue);
        InsertTailList(q, &TransferPacket->OverlapQueue);
        KeReleaseSpinLock(spin, irql);

        TRANSFER(packet);

    } else {
        wasIdle = p->Idle;
        p->Idle = FALSE;
        InsertTailList(q, &TransferPacket->OverlapQueue);
        KeReleaseSpinLock(spin, irql);
        if (wasIdle) {
            p->CompletionRoutine(p);
        }
    }
}

PARITY_IO_MANAGER::~PARITY_IO_MANAGER(
    )

{
    if (_spinLock) {
        ExFreePool(_spinLock);
        _spinLock = NULL;
    }
    if (_ioQueue) {
        ExFreePool(_ioQueue);
        _ioQueue = NULL;
    }
    if (_ePacket) {
        delete _ePacket;
        _ePacket = NULL;
    }
}

VOID
ParityCarefulWritePhase2(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a sector replacement
    for a careful write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PPARITY_RECOVER_TP  subPacket = (PPARITY_RECOVER_TP) TransferPacket;

    subPacket->CompletionRoutine = ParityCarefulWritePhase1;
    TRANSFER(subPacket);
}

VOID
ParityCarefulWritePhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a first attempt of a single sector write
    for a careful write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PPARITY_RECOVER_TP  subPacket = (PPARITY_RECOVER_TP) TransferPacket;
    NTSTATUS            status = subPacket->IoStatus.Status;
    PPARITY_TP          masterPacket = (PPARITY_TP) subPacket->MasterPacket;
    PPARITY_IO_MANAGER  t = masterPacket->ParityIoManager;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        masterPacket->CompletionRoutine(masterPacket);
        delete subPacket;
        return;
    }

    if (!NT_SUCCESS(status)) {
        if (!subPacket->OneWriteFailed) {
            subPacket->CompletionRoutine = ParityCarefulWritePhase2;
            subPacket->OneWriteFailed = TRUE;
            subPacket->TargetVolume->ReplaceBadSector(subPacket);
            return;
        }

        masterPacket->IoStatus = subPacket->IoStatus;
    }

    if (masterPacket->Offset + masterPacket->Length ==
        subPacket->Offset + subPacket->Length) {

        masterPacket->CompletionRoutine(masterPacket);
        delete subPacket;
        return;
    }

    subPacket->Offset += subPacket->Length;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);
    subPacket->OneWriteFailed = FALSE;

    TRANSFER(subPacket);
}

VOID
PARITY_IO_MANAGER::CarefulWrite(
    IN OUT  PPARITY_TP  TransferPacket
    )

/*++

Routine Description:

    This routine writes out the given transfer packet one sector at a time.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PPARITY_RECOVER_TP  subPacket;
    KIRQL               irql;

    ASSERT(!TransferPacket->ReadPacket);

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;

    subPacket = new PARITY_RECOVER_TP;
    if (subPacket &&
        !subPacket->AllocateMdl((PVOID) (PAGE_SIZE - 1), _sectorSize)) {

        delete subPacket;
        subPacket = NULL;
    }
    if (!subPacket) {
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    IoBuildPartialMdl(TransferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl),
                      _sectorSize);

    subPacket->Length = _sectorSize;
    subPacket->Offset = TransferPacket->Offset;
    subPacket->CompletionRoutine = ParityCarefulWritePhase1;
    subPacket->TargetVolume = TransferPacket->TargetVolume;
    subPacket->Thread = TransferPacket->Thread;
    subPacket->IrpFlags = TransferPacket->IrpFlags;
    subPacket->ReadPacket = FALSE;
    subPacket->OneWriteFailed = FALSE;
    subPacket->MasterPacket = TransferPacket;

    TRANSFER(subPacket);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\partitio.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    partitio.cxx

Abstract:

    This module contains the code specific to partitions for the fault
    tolerance driver.

Author:

    Bob Rinne   (bobri)  2-Feb-1992
    Mike Glass  (mglass)
    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>

class REPLACE_BAD_SECTOR_CONTEXT : public WORK_QUEUE_ITEM {

    public:

        PDEVICE_OBJECT  TargetObject;
        PIRP            Irp;

};

typedef REPLACE_BAD_SECTOR_CONTEXT *PREPLACE_BAD_SECTOR_CONTEXT;

NTSTATUS
PartitionBroadcastIrpCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           CompletionContext
    );


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
PARTITION::Initialize(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN OUT  PDEVICE_OBJECT      TargetObject,
    IN OUT  PDEVICE_OBJECT      WholeDiskPdo
    )

/*++

Routine Description:

    Initialize routine for FT_VOLUME of type PARTITION.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id for this volume.

    TargetObject    - Supplies the partition to which transfer requests are
                        forwarded to.

    WholeDiskPdo    - Supplies the whole disk for this partition.

Return Value:

    None.

--*/

{
    KEVENT          event;
    PIRP            irp;
    DISK_GEOMETRY   geometry;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS        status;
    ULONG           diskNumber, otherDiskNumber;
    LONGLONG        offset, partitionSize;

    FT_VOLUME::Initialize(RootExtension, LogicalDiskId);

    _targetObject = TargetObject;
    _wholeDiskPdo = WholeDiskPdo;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        TargetObject, NULL, 0, &geometry,
                                        sizeof(geometry), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    _sectorSize = geometry.BytesPerSector;

    status = FtpQueryPartitionInformation(RootExtension, TargetObject,
                                          &diskNumber, &_partitionOffset,
                                          NULL, NULL, &_partitionLength,
                                          NULL, NULL, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (!_diskInfoSet->QueryFtPartitionInformation(LogicalDiskId,
                                                   &offset, NULL,
                                                   &otherDiskNumber, NULL,
                                                   &partitionSize)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (partitionSize > 0 && partitionSize <= _partitionLength) {
        _partitionLength = partitionSize;
    }

    if (offset != _partitionOffset || diskNumber != otherDiskNumber) {
        return STATUS_INVALID_PARAMETER;
    }

    _emergencyIrp = IoAllocateIrp(_targetObject->StackSize, FALSE);
    if (!_emergencyIrp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    _emergencyIrpInUse = FALSE;
    InitializeListHead(&_emergencyIrpQueue);

    return STATUS_SUCCESS;
}

FT_LOGICAL_DISK_TYPE
PARTITION::QueryLogicalDiskType(
    )

/*++

Routine Description:

    This routine returns the type of the logical disk.

Arguments:

    None.

Return Value:

    The type of the logical disk.

--*/

{
    return FtPartition;
}

NTSTATUS
PARTITION::OrphanMember(
    IN  USHORT                  MemberNumber,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine tries to orphan the given member of this logical disk.
    A completion routine will be called if and only if this attempt is successful.

Arguments:

    MemberNumber        - Supplies the member number to orphan.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_PARAMETER;
}

NTSTATUS
PARTITION::RegenerateMember(
    IN      USHORT                  MemberNumber,
    IN OUT  PFT_VOLUME              NewMember,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This routine regenerates the given member of this volume with
    the given volume.

Arguments:

    MemberNumber    - Supplies the member number to regenerate.

    NewMember       - Supplies the new member to regenerate to.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_PARAMETER;
}

VOID
PartitionReplaceBadSectorWorker(
    IN  PVOID   Context
    )

{
    PREPLACE_BAD_SECTOR_CONTEXT context = (PREPLACE_BAD_SECTOR_CONTEXT) Context;

    IoCallDriver(context->TargetObject, context->Irp);
}

VOID
PARTITION::StopSyncOperations(
    )

/*++

Routine Description:

    This routine stops all sync operations.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
PARTITION::BroadcastIrp(
    IN  PIRP                    Irp,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine broadcasts a copy of the given IRP to every partition that
    is a member of the logical disk.

Arguments:

    Irp                 - Supplies the I/O request packet.

    CompletionRoutine   - Supplies the routine to be called when the operation
                            completes.

    Context             - Supplies the completion routine context.

Return Value:

    None.

--*/

{
    PIRP                            irp;
    PIO_STACK_LOCATION              irpSp, sp;
    PFT_COMPLETION_ROUTINE_CONTEXT  completionContext;

    irp = IoAllocateIrp(_targetObject->StackSize, FALSE);
    if (!irp) {
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    completionContext = (PFT_COMPLETION_ROUTINE_CONTEXT)
                        ExAllocatePool(NonPagedPool,
                                       sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    if (!completionContext) {
        IoFreeIrp(irp);
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    completionContext->CompletionRoutine = CompletionRoutine;
    completionContext->Context = Context;

    irpSp = IoGetNextIrpStackLocation(irp);
    sp = IoGetCurrentIrpStackLocation(Irp);
    *irpSp = *sp;

    IoSetCompletionRoutine(irp, PartitionBroadcastIrpCompletionRoutine,
                           completionContext, TRUE, TRUE, TRUE);

    IoCallDriver(_targetObject, irp);
}

PFT_VOLUME
PARTITION::GetParentLogicalDisk(
    IN  PFT_VOLUME  Volume
    )

/*++

Routine Description:

    This routine returns the parent of the given logical disk within
    this volume.

Arguments:

    Volume  - Supplies the sub-volume of which we are looking for the parent.

Return Value:

    The parent volume or NULL;

--*/

{
    return NULL;
}

VOID
PARTITION::SetDirtyBit(
    IN  BOOLEAN                 IsDirty,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine sets the dirty bit on the volume.  This bit is used at
    startup to determine whether or not there was a clean shutdown.

Arguments:

    IsDirty - Supplies the value of the dirty bit.

Return Value:

    None.

--*/

{
    if (CompletionRoutine) {
        CompletionRoutine(Context, STATUS_SUCCESS);
    }
}

NTSTATUS
PARTITION::CheckIo(
    OUT PBOOLEAN    IsIoOk
    )

/*++

Routine Description:

    This routine returns whether or not IO is possible on the given
    partition.

Arguments:

    IsIoOk  - Returns the state of IO.

Return Value:

    NTSTATUS

--*/

{
    PVOID               buffer;
    LARGE_INTEGER       offset;
    KEVENT              event;
    PIRP                irp;
    IO_STATUS_BLOCK     ioStatus;
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp;

    buffer = ExAllocatePool(NonPagedPoolCacheAligned, PAGE_SIZE);
    if (!buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    offset.QuadPart = 0;
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildSynchronousFsdRequest(IRP_MJ_READ, _targetObject,
                                       buffer, PAGE_SIZE, &offset, &event,
                                       &ioStatus);
    if (!irp) {
        ExFreePool(buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

    status = IoCallDriver(_targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (FsRtlIsTotalDeviceFailure(status)) {
        *IsIoOk = FALSE;
    } else {
        *IsIoOk = TRUE;
    }

    ExFreePool(buffer);

    return STATUS_SUCCESS;
}

NTSTATUS
PARTITION::SetPartitionType(
    IN  UCHAR   PartitionType
    )

/*++

Routine Description:

    This routine sets the partition type on all the members of the
    FT set.

Arguments:

    PartitionType   - Supplies the partition type.

Return Value:

    NTSTATUS

--*/

{
    KEVENT                      event;
    SET_PARTITION_INFORMATION   partInfo;
    PIRP                        irp;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    partInfo.PartitionType = (PartitionType | 0x80);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_SET_PARTITION_INFO,
                                        _targetObject, &partInfo,
                                        sizeof(partInfo), NULL, 0, FALSE,
                                        &event, &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(_targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    return status;
}

UCHAR
PARTITION::QueryPartitionType(
    )

/*++

Routine Description:

    This routine queries the partition type.

Arguments:

    None.

Return Value:

    The partition type.

--*/

{
    KEVENT                      event;
    PIRP                        irp;
    PARTITION_INFORMATION       partInfo;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO,
                                        _targetObject, NULL, 0, &partInfo,
                                        sizeof(partInfo), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return 0;
    }

    status = IoCallDriver(_targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return 0;
    }

    return partInfo.PartitionType;
}

UCHAR
PARTITION::QueryStackSize(
    )

/*++

Routine Description:

    This routine queries IRP stack size.

Arguments:

    None.

Return Value:

    The IRP stack size.

--*/

{
    return _targetObject->StackSize;
}

VOID
PARTITION::CreateLegacyNameLinks(
    IN  PUNICODE_STRING DeviceName
    )

/*++

Routine Description:

    This routine creates the \Device\HarddiskN\PartitionM links for
    this object to the given device name.

Arguments:

    DeviceName  - Supplies the device name.

Return Value:

    None.

--*/

{
    NTSTATUS        status;
    ULONG           diskNumber, partitionNumber;
    WCHAR           buf[80];
    UNICODE_STRING  symName;

    status = FtpQueryPartitionInformation(_rootExtension, _targetObject,
                                          &diskNumber, NULL, &partitionNumber,
                                          NULL, NULL, NULL, NULL, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        return;
    }

    swprintf(buf, L"\\Device\\Harddisk%d\\Partition%d", diskNumber,
             partitionNumber);
    RtlInitUnicodeString(&symName, buf);

    IoDeleteSymbolicLink(&symName);

    if (DeviceName) {
        IoCreateSymbolicLink(&symName, DeviceName);
    }
}

NTSTATUS
PARTITION::QueryPhysicalOffsets(
    IN  LONGLONG                    LogicalOffset,
    OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
    OUT PULONG                      NumberOfPhysicalOffsets
    )
/*++

Routine Description:

    This routine returns physical disk and offset for a given volume
    logical offset.

Arguments:

    LogicalOffset           - Supplies the logical offset

    PhysicalOffsets         - Returns the physical offsets

    NumberOfPhysicalOffsets - Returns the number of physical offsets

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    ULONG                   diskNumber;
    PVOLUME_PHYSICAL_OFFSET physicalOffset;
    
    status = FtpQueryPartitionInformation(_rootExtension, _targetObject,
                                          &diskNumber, NULL, NULL,
                                          NULL, NULL, NULL, NULL, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (LogicalOffset < 0 ||
        _partitionLength <= LogicalOffset) {
        return STATUS_INVALID_PARAMETER;
    }

    physicalOffset = (PVOLUME_PHYSICAL_OFFSET) ExAllocatePool(PagedPool, sizeof(VOLUME_PHYSICAL_OFFSET));
    if (!physicalOffset) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    physicalOffset->DiskNumber = diskNumber;
    physicalOffset->Offset = _partitionOffset + LogicalOffset;
    
    *PhysicalOffsets = physicalOffset;
    *NumberOfPhysicalOffsets = 1;

    return status;
}

NTSTATUS
PARTITION::QueryLogicalOffset(
    IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
    OUT PLONGLONG               LogicalOffset
    )
/*++

Routine Description:

    This routine returns the volume logical offset for a given disk number
    and physical offset.

Arguments:

    PhysicalOffset          - Supplies the physical offset

    LogicalOffset           - Returns the logical offset

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    ULONG                   diskNumber;
    PVOLUME_PHYSICAL_OFFSET physicalOffset;
    
    status = FtpQueryPartitionInformation(_rootExtension, _targetObject,
                                          &diskNumber, NULL, NULL,
                                          NULL, NULL, NULL, NULL, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (PhysicalOffset->DiskNumber != diskNumber ||
        PhysicalOffset->Offset < _partitionOffset ||
        _partitionOffset + _partitionLength <= PhysicalOffset->Offset) {

            return STATUS_INVALID_PARAMETER;
    }
    
    *LogicalOffset = PhysicalOffset->Offset - _partitionOffset;

    return status;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

PARTITION::~PARTITION(
    )

{
    if (_emergencyIrp) {
        IoFreeIrp(_emergencyIrp);
        _emergencyIrp = NULL;
    }
}

USHORT
PARTITION::QueryNumberOfMembers(
    )

/*++

Routine Description:

    This routine returns the number of members in this volume.

Arguments:

    None.

Return Value:

    0   - A volume of type partition has no members.

--*/

{
    return 0;
}

PFT_VOLUME
PARTITION::GetMember(
    IN  USHORT  MemberNumber
    )

/*++

Routine Description:

    This routine returns the 'MemberNumber'th member of this volume.

Arguments:

    MemberNumber    - Supplies the zero based member number desired.

Return Value:

    A pointer to the 'MemberNumber'th member or NULL if no such member.

--*/

{
    ASSERT(FALSE);
    return NULL;
}

NTSTATUS
PartitionTransferCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           TransferPacket
    )

/*++

Routine Description:

    Completion routine for PARTITION::Transfer function.

Arguments:

    Irp             - Supplies the IRP.

    TransferPacket  - Supplies the transfer packet.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    PTRANSFER_PACKET    transferPacket = (PTRANSFER_PACKET) TransferPacket;
    PPARTITION          t = (PPARTITION) transferPacket->TargetVolume;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PIRP                irp;
    PTRANSFER_PACKET    p;
    PIO_STACK_LOCATION  irpSp;

    transferPacket->IoStatus = Irp->IoStatus;
    if (Irp == transferPacket->OriginalIrp) {
        transferPacket->CompletionRoutine(transferPacket);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (Irp->AssociatedIrp.SystemBuffer) {
        ExFreePool(Irp->AssociatedIrp.SystemBuffer);
    }

    if (Irp == t->_emergencyIrp) {

        for (;;) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            if (IsListEmpty(&t->_emergencyIrpQueue)) {
                t->_emergencyIrpInUse = FALSE;
                KeReleaseSpinLock(&t->_spinLock, irql);
                break;
            }

            l = RemoveHeadList(&t->_emergencyIrpQueue);
            KeReleaseSpinLock(&t->_spinLock, irql);

            irp = IoAllocateIrp(t->_targetObject->StackSize, FALSE);
            if (!irp) {
                irp = t->_emergencyIrp;
                IoReuseIrp(irp, STATUS_SUCCESS);
            }

            p = CONTAINING_RECORD(l, TRANSFER_PACKET, QueueEntry);
            irpSp = IoGetNextIrpStackLocation(irp);
            irp->MdlAddress = p->Mdl;
            irpSp->Parameters.Write.ByteOffset.QuadPart = p->Offset;
            irpSp->Parameters.Write.Length = p->Length;
            if (p->ReadPacket) {
                irpSp->MajorFunction = IRP_MJ_READ;
            } else {
                irpSp->MajorFunction = IRP_MJ_WRITE;
            }

            irpSp->DeviceObject = t->_targetObject;
            irp->Tail.Overlay.Thread = p->Thread;
            irpSp->Flags = p->IrpFlags;

            IoSetCompletionRoutine(irp, PartitionTransferCompletionRoutine,
                                   p, TRUE, TRUE, TRUE);

            if (irp == Irp) {
                IoCallDriver(t->_targetObject, irp);
                break;
            } else {
                IoCallDriver(t->_targetObject, irp);
            }
        }

    } else {
        IoFreeIrp(Irp);
    }

    transferPacket->CompletionRoutine(transferPacket);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
PARTITION::Transfer(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Transfer routine for PARTITION type FT_VOLUME.  Basically,
    just pass the request down to the target object.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    KIRQL               irql;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;
    PVERIFY_INFORMATION verifyInfo;

    irp = TransferPacket->OriginalIrp;
    if (!irp) {
        irp = IoAllocateIrp(_targetObject->StackSize, FALSE);
        if (!irp) {
            if (!TransferPacket->Mdl) {
                TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                TransferPacket->IoStatus.Information = 0;
                TransferPacket->CompletionRoutine(TransferPacket);
                return;
            }
            KeAcquireSpinLock(&_spinLock, &irql);
            if (_emergencyIrpInUse) {
                InsertTailList(&_emergencyIrpQueue, &TransferPacket->QueueEntry);
                KeReleaseSpinLock(&_spinLock, irql);
                return;
            }
            _emergencyIrpInUse = TRUE;
            KeReleaseSpinLock(&_spinLock, irql);
            irp = _emergencyIrp;
            IoReuseIrp(irp, STATUS_SUCCESS);                            
        }
    }

    irpSp = IoGetNextIrpStackLocation(irp);
    if (TransferPacket->Mdl) {
        irp->MdlAddress = TransferPacket->Mdl;
        irpSp->Parameters.Write.ByteOffset.QuadPart = TransferPacket->Offset;
        irpSp->Parameters.Write.Length = TransferPacket->Length;
        if (TransferPacket->ReadPacket) {
            irpSp->MajorFunction = IRP_MJ_READ;
        } else {
            irpSp->MajorFunction = IRP_MJ_WRITE;
        }
    } else {

        // Since there is no MDL, this is a verify request.

        verifyInfo = (PVERIFY_INFORMATION)
                     ExAllocatePool(NonPagedPool, sizeof(VERIFY_INFORMATION));
        if (!verifyInfo) {
            IoFreeIrp(irp);
            TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }

        verifyInfo->StartingOffset.QuadPart = TransferPacket->Offset;
        verifyInfo->Length = TransferPacket->Length;
        irp->AssociatedIrp.SystemBuffer = verifyInfo;

        irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
        irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(VERIFY_INFORMATION);
        irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_DISK_VERIFY;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
        irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    }

    irpSp->DeviceObject = _targetObject;
    irp->Tail.Overlay.Thread = TransferPacket->Thread;
    irpSp->Flags = TransferPacket->IrpFlags;

    IoSetCompletionRoutine(irp, PartitionTransferCompletionRoutine,
                           TransferPacket, TRUE, TRUE, TRUE);

    IoCallDriver(_targetObject, irp);
}

VOID
PARTITION::ReplaceBadSector(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine attempts to fix the given bad sector by performing
    a reassign blocks ioctl.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PIRP                        irp;
    PIO_STACK_LOCATION          irpSp;
    PREASSIGN_BLOCKS            badBlock;
    ULONG                       n, size, first, i;
    PREPLACE_BAD_SECTOR_CONTEXT context;

    irp = IoAllocateIrp(_targetObject->StackSize, FALSE);
    if (!irp) {
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    n = TransferPacket->Length/_sectorSize;
    size = FIELD_OFFSET(REASSIGN_BLOCKS, BlockNumber) + n*sizeof(ULONG);
    badBlock = (PREASSIGN_BLOCKS) ExAllocatePool(NonPagedPool, size);
    if (!badBlock) {
        IoFreeIrp(irp);
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    badBlock->Reserved = 0;
    badBlock->Count = 1;
    first = (ULONG) ((TransferPacket->Offset + _partitionOffset)/_sectorSize);
    for (i = 0; i < n; i++) {
        badBlock->BlockNumber[i] = first + i;
    }

    irp->AssociatedIrp.SystemBuffer = badBlock;
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = size;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_DISK_REASSIGN_BLOCKS;
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

    irpSp->DeviceObject = _targetObject;
    irp->Tail.Overlay.Thread = TransferPacket->Thread;
    irpSp->Flags = TransferPacket->IrpFlags;

    IoSetCompletionRoutine(irp, PartitionTransferCompletionRoutine,
                           TransferPacket, TRUE, TRUE, TRUE);

    context = (PREPLACE_BAD_SECTOR_CONTEXT)
              ExAllocatePool(NonPagedPool, sizeof(REPLACE_BAD_SECTOR_CONTEXT));
    if (!context) {
        ExFreePool(badBlock);
        IoFreeIrp(irp);
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    ExInitializeWorkItem(context, PartitionReplaceBadSectorWorker, context);
    context->TargetObject = _targetObject;
    context->Irp = irp;

    FtpQueueWorkItem(_rootExtension, context);
}

VOID
PARTITION::StartSyncOperations(
    IN      BOOLEAN                 RegenerateOrphans,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This routine restarts any regenerate or initialize requests that
    were suspended because of a reboot.  The volume examines the member
    state of all of its constituents and restarts any regenerations pending.

Arguments:

    RegenerateOrphans   - Supplies whether or not to try and regenerate
                            orphaned members.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the context for the completion routine.

Return Value:

    None.

--*/

{
    CompletionRoutine(Context, STATUS_SUCCESS);
}

NTSTATUS
PartitionBroadcastIrpCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           CompletionContext
    )

/*++

Routine Description:

    Completion routine for PARTITION::BroadcastIrp functions.

Arguments:

    Irp                 - Supplies the IRP.

    CompletionContext   - Supplies the completion context.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  completionContext;

    completionContext = (PFT_COMPLETION_ROUTINE_CONTEXT) CompletionContext;

    completionContext->CompletionRoutine(completionContext->Context,
                                         Irp->IoStatus.Status);

    IoFreeIrp(Irp);
    ExFreePool(CompletionContext);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

ULONG
PARTITION::QuerySectorSize(
    )

/*++

Routine Description:

    Returns the sector size for the volume.

Arguments:

    None.

Return Value:

    The volume sector size in bytes.

--*/

{
    return _sectorSize;
}

LONGLONG
PARTITION::QueryVolumeSize(
    )

/*++

Routine Description:

    Returns the number of bytes on the entire volume.

Arguments:

    None.

Return Value:

    The volume size in bytes.

--*/

{
    return _partitionLength;
}

PFT_VOLUME
PARTITION::GetContainedLogicalDisk(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine returns TRUE if the given logical disk id
    represents this logical disk or if this logical disk contains
    the given logical disk id either directly or indirectly.

Arguments:

    LogicalDiskId   - Supplies the logical disk id that we are searching for.

Return Value:

    FALSE   - The given logical disk id is not contained in this logical disk.

    TRUE    - The given logical disk id is contained in this logical disk.

--*/

{
    if (LogicalDiskId == QueryLogicalDiskId()) {
        return this;
    }

    return NULL;
}

PFT_VOLUME
PARTITION::GetContainedLogicalDisk(
    IN  PDEVICE_OBJECT  TargetObject
    )

/*++

Routine Description:

    This routine returns TRUE if the given logical disk id
    represents this logical disk or if this logical disk contains
    the given logical disk id either directly or indirectly.

Arguments:

    TargetObject    - Supplies the target object.

Return Value:

    FALSE   - The given logical disk id is not contained in this logical disk.

    TRUE    - The given logical disk id is contained in this logical disk.

--*/

{
    if (TargetObject == _targetObject) {
        return this;
    }

    return NULL;
}

PFT_VOLUME
PARTITION::GetContainedLogicalDisk(
    IN  ULONG       Signature,
    IN  LONGLONG    Offset
    )

/*++

Routine Description:

    This routine returns TRUE if the given logical disk id
    represents this logical disk or if this logical disk contains
    the given logical disk id either directly or indirectly.

Arguments:

    Signature   - Supplies the signature.

    Offset      - Supplies the partition offset.

Return Value:

    FALSE   - The given logical disk id is not contained in this logical disk.

    TRUE    - The given logical disk id is contained in this logical disk.

--*/

{
    if (Offset != _partitionOffset) {
        return NULL;
    }

    if (Signature == FtpQueryDiskSignature(_wholeDiskPdo)) {
        return this;
    }

    return NULL;
}

VOID
PARTITION::SetMember(
    IN  USHORT      MemberNumber,
    IN  PFT_VOLUME  Member
    )

/*++

Routine Description:

    This routine sets the given member in this volume.

Arguments:

    MemberNumber    - Supplies the member number.

    Member          - Supplies the member.

Return Value:

    None.

--*/

{
    ASSERT(FALSE);
}

BOOLEAN
PARTITION::IsComplete(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine computes whether or not this volume has either all
    (if IoPending is FALSE) of its members or enough (if IoPending is TRUE) of
    its members.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    return TRUE;
}

VOID
PARTITION::CompleteNotification(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine is called to notify the volume that it is complete and
    to therefore prepare for incoming requests.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
}

ULONG
PARTITION::QueryNumberOfPartitions(
    )

/*++

Routine Description:

    This routine returns the number of partitions covered by this volume
    set.

Arguments:

    None.

Return Value:

    The number of partitions covered by this volume set.

--*/

{
    return 1;
}

PDEVICE_OBJECT
PARTITION::GetLeftmostPartitionObject(
    )

{
    return _targetObject;
}

NTSTATUS
PARTITION::QueryDiskExtents(
    OUT PDISK_EXTENT*   DiskExtents,
    OUT PULONG          NumberOfDiskExtents
    )

/*++

Routine Description:

    This routine returns an array of disk extents that describe the
    location of this volume.

Arguments:

    DiskExtents         - Returns the disk extents.

    NumberOfDiskExtents - Returns the number of disk extents.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS        status;
    ULONG           diskNumber;
    PDISK_EXTENT    diskExtent;

    status = FtpQueryPartitionInformation(_rootExtension, _targetObject,
                                          &diskNumber, NULL, NULL,
                                          NULL, NULL, NULL, NULL, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    diskExtent = (PDISK_EXTENT) ExAllocatePool(PagedPool, sizeof(DISK_EXTENT));
    if (!diskExtent) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    diskExtent->DiskNumber = diskNumber;
    diskExtent->StartingOffset.QuadPart = _partitionOffset;
    diskExtent->ExtentLength.QuadPart = _partitionLength;

    *DiskExtents = diskExtent;
    *NumberOfDiskExtents = 1;

    return status;
}

BOOLEAN
PARTITION::QueryVolumeState(
    IN  PFT_VOLUME          Volume,
    OUT PFT_MEMBER_STATE    State
    )

/*++

Routine Description:

    This routine returns the state of the given volume considered as a
    member of this volume.

Arguments:

    Volume  - Supplies the volume to query the state for.

    State   - Returns the state.

Return Value:

    FALSE   - The given Volume is not a member of this volume.

    TRUE    - The state was successfully computed.

--*/

{
    if (Volume != this) {
        return FALSE;
    }

    *State = FtMemberHealthy;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\stripe.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    stripe.cxx

Abstract:

    This module contains the code specific to volume sets for the fault
    tolerance driver.

Author:

    Bob Rinne   (bobri)  2-Feb-1992
    Mike Glass  (mglass)
    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
STRIPE::Initialize(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN OUT  PFT_VOLUME*         VolumeArray,
    IN      USHORT              ArraySize,
    IN      PVOID               ConfigInfo,
    IN      PVOID               StateInfo
    )

/*++

Routine Description:

    Initialize routine for FT_VOLUME of type STRIPE.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id for this volume.

    VolumeArray     - Supplies the array of volumes for this volume set.

    ArraySize       - Supplies the number of volumes in the volume array.

    ConfigInfo      - Supplies the configuration information.

    StateInfo       - Supplies the state information.

Return Value:

    NTSTATUS

--*/

{
    BOOLEAN                                     oneGood;
    USHORT                                      i;
    NTSTATUS                                    status;
    PFT_STRIPE_SET_CONFIGURATION_INFORMATION    configInfo;
    LONGLONG                                    newSize;

    if (ArraySize < 2) {
        return STATUS_INVALID_PARAMETER;
    }
    
    oneGood = FALSE;
    for (i = 0; i < ArraySize; i++) {
        if (VolumeArray[i]) {
            oneGood = TRUE;
        }
    }

    if (!oneGood) {
        return STATUS_INVALID_PARAMETER;
    }

    status = COMPOSITE_FT_VOLUME::Initialize(RootExtension, LogicalDiskId,
                                             VolumeArray, ArraySize,
                                             ConfigInfo, StateInfo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    configInfo = (PFT_STRIPE_SET_CONFIGURATION_INFORMATION) ConfigInfo;
    _stripeSize = configInfo->StripeSize;
    if (_stripeSize < QuerySectorSize()) {
        return STATUS_INVALID_PARAMETER;
    }
    for (i = 0; _stripeSize%2 == 0; i++) {
        _stripeSize /= 2;
    }
    if (_stripeSize != 1) {
        return STATUS_INVALID_PARAMETER;
    }
    _stripeSize = configInfo->StripeSize;
    _stripeShift = i;
    _stripeMask = _stripeSize - 1;

    for (i = 0; i < ArraySize; i++) {
        if (VolumeArray[i]) {
            _memberSize = VolumeArray[i]->QueryVolumeSize();
            break;
        }
    }
    for (; i < ArraySize; i++) {
        if (VolumeArray[i]) {
            newSize = VolumeArray[i]->QueryVolumeSize();
            if (_memberSize > newSize) {
                _memberSize = newSize;
            }
        }
    }

    _memberSize = _memberSize/_stripeSize*_stripeSize;
    _volumeSize = _memberSize*ArraySize;

    _ePacket = new STRIPE_TP;
    if (_ePacket && !_ePacket->AllocateMdl((PVOID) 1, _stripeSize)) {
        delete _ePacket;
        _ePacket = NULL;
    }
    if (!_ePacket) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _ePacketInUse = FALSE;
    InitializeListHead(&_ePacketQueue);

    return status;
}

FT_LOGICAL_DISK_TYPE
STRIPE::QueryLogicalDiskType(
    )

/*++

Routine Description:

    This routine returns the type of the logical disk.

Arguments:

    None.

Return Value:

    The type of the logical disk.

--*/

{
    return FtStripeSet;
}

NTSTATUS
STRIPE::CheckIo(
    OUT PBOOLEAN    IsIoOk
    )

/*++

Routine Description:

    This routine returns whether or not IO is possible on the given
    logical disk.

Arguments:

    IsIoOk  - Returns the state of IO.

Return Value:

    NTSTATUS

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;
    NTSTATUS    status;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMemberUnprotected(i);
        if (!vol) {
            *IsIoOk = FALSE;
            return STATUS_SUCCESS;
        }
        status = vol->CheckIo(IsIoOk);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (!(*IsIoOk)) {
            return STATUS_SUCCESS;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
STRIPE::QueryPhysicalOffsets(
    IN  LONGLONG                    LogicalOffset,
    OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
    OUT PULONG                      NumberOfPhysicalOffsets
    )
/*++

Routine Description:

    This routine returns physical disk and offset for a given volume
    logical offset.

Arguments:

    LogicalOffset           - Supplies the logical offset

    PhysicalOffsets         - Returns the physical offsets

    NumberOfPhysicalOffsets - Returns the number of physical offsets

Return Value:

    NTSTATUS

--*/
{
    USHORT      n, whichMember;
    LONGLONG    whichStripe, whichRow, logicalOffsetInMember;
    PFT_VOLUME  vol;

    if (LogicalOffset < 0 ||
        _volumeSize <= LogicalOffset) {
        return STATUS_INVALID_PARAMETER;
    }    
    
    n = QueryNumMembers();
    ASSERT(n);
    ASSERT(_stripeSize);
    whichStripe = LogicalOffset/_stripeSize;
    whichMember = (USHORT) (whichStripe%n);

    vol = GetMember(whichMember);
    if (!vol) {
        return STATUS_INVALID_PARAMETER;
    }

    whichRow = whichStripe/n;
    logicalOffsetInMember = whichRow*_stripeSize + LogicalOffset%_stripeSize;
    
    return vol->QueryPhysicalOffsets(logicalOffsetInMember, PhysicalOffsets, NumberOfPhysicalOffsets);
}

NTSTATUS
STRIPE::QueryLogicalOffset(
    IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
    OUT PLONGLONG               LogicalOffset
    )
/*++

Routine Description:

    This routine returns the volume logical offset for a given disk number
    and physical offset.

Arguments:

    PhysicalOffset          - Supplies the physical offset

    LogicalOffset           - Returns the logical offset

Return Value:

    NTSTATUS

--*/
{    
    USHORT      n, i;
    LONGLONG    whichStripe, whichRow; 
    LONGLONG    logicalOffset, logicalOffsetInMember;
    NTSTATUS    status;
    PFT_VOLUME  vol;
    
    n = QueryNumMembers();
    ASSERT(_stripeSize);
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }
        status = vol->QueryLogicalOffset(PhysicalOffset, &logicalOffsetInMember);
        if (NT_SUCCESS(status)) {
            whichRow = logicalOffsetInMember/_stripeSize;
            whichStripe = whichRow*n + i;
            
            logicalOffset = whichStripe*_stripeSize + logicalOffsetInMember%_stripeSize;
            if (_volumeSize <= logicalOffset) {
                return STATUS_INVALID_PARAMETER;
            }

            *LogicalOffset = logicalOffset;
            return status;
        }        
    }

  return STATUS_INVALID_PARAMETER;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

STRIPE::~STRIPE(
    )

{
    if (_ePacket) {
        delete _ePacket;
        _ePacket = NULL;
    }
}

VOID
STRIPE::Transfer(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Transfer routine for STRIPE type FT_VOLUME.  Figure out
    which volumes this request needs to be dispatched to.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    KIRQL       irql;

    if (!LaunchParallel(TransferPacket)) {
        if (!TransferPacket->Mdl) {
            TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }

        KeAcquireSpinLock(&_spinLock, &irql);
        if (_ePacketInUse) {
            InsertTailList(&_ePacketQueue, &TransferPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _ePacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        LaunchSequential(TransferPacket);
    }
}

VOID
StripeReplaceCompletionRoutine(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a replace request.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSTRIPE_TP          transferPacket = (PSTRIPE_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;

    masterPacket->IoStatus = transferPacket->IoStatus;
    delete transferPacket;
    masterPacket->CompletionRoutine(masterPacket);
}

VOID
STRIPE::ReplaceBadSector(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine attempts to fix the given bad sector by routing
    the request to the appropriate sub-volume.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    USHORT      n, whichMember;
    LONGLONG    whichStripe, whichRow;
    PSTRIPE_TP  p;

    n = QueryNumMembers();
    whichStripe = TransferPacket->Offset/_stripeSize;
    whichMember = (USHORT) (whichStripe%n);
    whichRow = whichStripe/n;

    p = new STRIPE_TP;
    if (!p) {
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    p->Length = TransferPacket->Length;
    p->Offset = whichRow*_stripeSize + TransferPacket->Offset%_stripeSize;
    p->CompletionRoutine = StripeReplaceCompletionRoutine;
    p->TargetVolume = GetMemberUnprotected(whichMember);
    p->Thread = TransferPacket->Thread;
    p->IrpFlags = TransferPacket->IrpFlags;
    p->MasterPacket = TransferPacket;
    p->Stripe = this;
    p->WhichMember = whichMember;

    p->TargetVolume->ReplaceBadSector(p);
}

LONGLONG
STRIPE::QueryVolumeSize(
    )

/*++

Routine Description:

    Returns the number of bytes on the entire volume.

Arguments:

    None.

Return Value:

    The volume size in bytes.

--*/

{
    return _volumeSize;
}

VOID
StripeTransferParallelCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for STRIPE::Transfer function.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSTRIPE_TP          transferPacket = (PSTRIPE_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    KIRQL               irql;

    if (!NT_SUCCESS(status)) {
        KeAcquireSpinLock(&masterPacket->SpinLock, &irql);
        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
        }
        KeReleaseSpinLock(&masterPacket->SpinLock, irql);
    }

    delete transferPacket;

    if (!InterlockedDecrement(&masterPacket->RefCount)) {
        masterPacket->CompletionRoutine(masterPacket);
    }
}

VOID
STRIPE::CompleteNotification(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine is called to notify the volume that it is complete and
    to therefore prepare for incoming requests.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    COMPOSITE_FT_VOLUME::CompleteNotification(IoPending);

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (_memberSize > vol->QueryVolumeSize()) {
            _memberSize = vol->QueryVolumeSize()/_stripeSize*_stripeSize;
        }
    }
    _volumeSize = n*_memberSize;
}

BOOLEAN
STRIPE::LaunchParallel(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine lauches the given transfer packet in parallel accross
    all members.  If memory cannot be allocated to launch this request
    in parallel then a return value of FALSE will be returned.

Arguments:

    TransferPacket  - Supplies the transfer packet to launch.

Return Value:

    FALSE   - The packet was not launched because of insufficient resources.

    TRUE    - Success.

--*/

{
    LONGLONG    offset, whichStripe, whichRow, off;
    ULONG       length, stripeOffset, stripeRemainder, numRequests, len;
    USHORT      arraySize, whichMember;
    PSTRIPE_TP  p;
    ULONG       i;
    PCHAR       vp;
    LIST_ENTRY  q;
    PLIST_ENTRY l;

    offset = TransferPacket->Offset;
    length = TransferPacket->Length;

    stripeOffset = (ULONG) (offset&_stripeMask);
    stripeRemainder = _stripeSize - stripeOffset;
    if (length > stripeRemainder) {
        length -= stripeRemainder;
        numRequests = length>>_stripeShift;
        length -= numRequests<<_stripeShift;
        if (length) {
            numRequests += 2;
        } else {
            numRequests++;
        }
    } else {
        numRequests = 1;
    }

    KeInitializeSpinLock(&TransferPacket->SpinLock);
    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;
    TransferPacket->RefCount = numRequests;

    length = TransferPacket->Length;
    if (TransferPacket->Mdl && numRequests > 1) {
        vp = (PCHAR) MmGetMdlVirtualAddress(TransferPacket->Mdl);
    }
    whichStripe = offset>>_stripeShift;
    arraySize = QueryNumMembers();
    InitializeListHead(&q);
    for (i = 0; i < numRequests; i++, whichStripe++) {

        whichRow = whichStripe/arraySize;
        whichMember = (USHORT) (whichStripe%arraySize);
        if (i == 0) {
            off = (whichRow<<_stripeShift) + stripeOffset;
            len = stripeRemainder > length ? length : stripeRemainder;
        } else if (i == numRequests - 1) {
            off = whichRow<<_stripeShift;
            len = length;
        } else {
            off = whichRow<<_stripeShift;
            len = _stripeSize;
        }
        length -= len;

        p = new STRIPE_TP;
        if (p) {
            if (TransferPacket->Mdl && numRequests > 1) {
                if (p->AllocateMdl(vp, len)) {
                    IoBuildPartialMdl(TransferPacket->Mdl, p->Mdl, vp, len);
                } else {
                    delete p;
                    p = NULL;
                }
                vp += len;
            } else {
                p->Mdl = TransferPacket->Mdl;
                p->OriginalIrp = TransferPacket->OriginalIrp;
            }
        }
        if (!p) {
            while (!IsListEmpty(&q)) {
                l = RemoveHeadList(&q);
                p = CONTAINING_RECORD(l, STRIPE_TP, QueueEntry);
                delete p;
            }
            return FALSE;
        }

        p->Length = len;
        p->Offset = off;
        p->CompletionRoutine = StripeTransferParallelCompletionRoutine;
        p->TargetVolume = GetMemberUnprotected(whichMember);
        p->Thread = TransferPacket->Thread;
        p->IrpFlags = TransferPacket->IrpFlags;
        p->ReadPacket = TransferPacket->ReadPacket;
        p->SpecialRead = TransferPacket->SpecialRead;
        p->MasterPacket = TransferPacket;
        p->Stripe = this;
        p->WhichMember = whichMember;

        InsertTailList(&q, &p->QueueEntry);
    }

    while (!IsListEmpty(&q)) {
        l = RemoveHeadList(&q);
        p = CONTAINING_RECORD(l, STRIPE_TP, QueueEntry);
        TRANSFER(p);
    }

    return TRUE;
}

VOID
StripeSequentialTransferCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for STRIPE::Transfer function.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSTRIPE_TP          transferPacket = (PSTRIPE_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    PSTRIPE             t = transferPacket->Stripe;
    LONGLONG            rowNumber, stripeNumber, masterOffset;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PTRANSFER_PACKET    p;

    if (NT_SUCCESS(status)) {

        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Information +=
                    transferPacket->IoStatus.Information;
        }

    } else {

        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }
    }

    MmPrepareMdlForReuse(transferPacket->Mdl);

    rowNumber = transferPacket->Offset/t->_stripeSize;
    stripeNumber = rowNumber*t->QueryNumMembers() +
                   transferPacket->WhichMember;
    masterOffset = stripeNumber*t->_stripeSize +
                   transferPacket->Offset%t->_stripeSize;

    if (masterOffset + transferPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        masterPacket->CompletionRoutine(masterPacket);

        for (;;) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            if (IsListEmpty(&t->_ePacketQueue)) {
                t->_ePacketInUse = FALSE;
                KeReleaseSpinLock(&t->_spinLock, irql);
                break;
            }
            l = RemoveHeadList(&t->_ePacketQueue);
            KeReleaseSpinLock(&t->_spinLock, irql);

            p = CONTAINING_RECORD(l, TRANSFER_PACKET, QueueEntry);

            if (!t->LaunchParallel(p)) {
                t->LaunchSequential(p);
                break;
            }
        }
        return;
    }

    transferPacket->WhichMember++;
    if (transferPacket->WhichMember == t->QueryNumMembers()) {
        transferPacket->WhichMember = 0;
        rowNumber++;
    }
    masterOffset += transferPacket->Length;

    transferPacket->Offset = rowNumber*t->_stripeSize;
    transferPacket->Length = t->_stripeSize;

    if (masterOffset + transferPacket->Length >
        masterPacket->Offset + masterPacket->Length) {

        transferPacket->Length = (ULONG) (masterPacket->Offset +
                                          masterPacket->Length - masterOffset);
    }

    transferPacket->TargetVolume =
            t->GetMemberUnprotected(transferPacket->WhichMember);

    IoBuildPartialMdl(masterPacket->Mdl, transferPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (masterOffset - masterPacket->Offset),
                      transferPacket->Length);

    TRANSFER(transferPacket);
}

VOID
STRIPE::LaunchSequential(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine lauches the given transfer packet in sequence accross
    all members using the emergency stripe transfer packet.

Arguments:

    TransferPacket  - Supplies the transfer packet to launch.

Return Value:

    FALSE   - The packet was not launched because of insufficient resources.

    TRUE    - Success.

--*/

{
    PSTRIPE_TP  p;
    LONGLONG    offset, whichStripe, whichRow;
    USHORT      whichMember, arraySize;

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = 0;

    offset = TransferPacket->Offset;

    p = _ePacket;
    arraySize = QueryNumMembers();
    whichStripe = offset/_stripeSize;
    whichRow = whichStripe/arraySize;
    whichMember = (USHORT) (whichStripe%arraySize);
    p->Length = _stripeSize - (ULONG) (offset%_stripeSize);
    if (p->Length > TransferPacket->Length) {
        p->Length = TransferPacket->Length;
    }
    IoBuildPartialMdl(TransferPacket->Mdl, p->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl), p->Length);

    p->Offset = whichRow*_stripeSize + offset%_stripeSize;
    p->CompletionRoutine = StripeSequentialTransferCompletionRoutine;
    p->TargetVolume = GetMemberUnprotected(whichMember);
    p->Thread = TransferPacket->Thread;
    p->IrpFlags = TransferPacket->IrpFlags;
    p->ReadPacket = TransferPacket->ReadPacket;
    p->SpecialRead = TransferPacket->SpecialRead;
    p->MasterPacket = TransferPacket;
    p->Stripe = this;
    p->WhichMember = whichMember;

    TRANSFER(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\partmgr\partmgr.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    partmgr.h

Abstract:

    This file defines the internal data structure for the PARTMGR driver.

Author:

    norbertk

Revision History:

--*/

#include <partmgrp.h>

#define DEVICENAME_MAXSTR   64          // used to storage device name for WMI

#undef ExAllocatePool
#define ExAllocatePool #

#define PARTMGR_TAG_DEPENDANT_VOLUME_LIST       'vRcS'  // ScRv
#define PARTMGR_TAG_PARTITION_ENTRY             'pRcS'  // ScRp
#define PARTMGR_TAG_VOLUME_ENTRY                'VRcS'  // ScRV
#define PARTMGR_TAG_TABLE_ENTRY                 'tRcS'  // ScRt
#define PARTMGR_TAG_POWER_WORK_ITEM             'wRcS'  // ScRw
#define PARTMGR_TAG_IOCTL_BUFFER                'iRcS'  // ScRi

#define PARTMGR_TAG_REMOVE_LOCK                 'rRcS'  // ScRr

typedef struct _VOLMGR_LIST_ENTRY {
    LIST_ENTRY      ListEntry;
    UNICODE_STRING  VolumeManagerName;
    LONG            RefCount;
    PDEVICE_OBJECT  VolumeManager;
    PFILE_OBJECT    VolumeManagerFileObject;
} VOLMGR_LIST_ENTRY, *PVOLMGR_LIST_ENTRY;

typedef struct _PARTITION_LIST_ENTRY {
    LIST_ENTRY          ListEntry;
    PDEVICE_OBJECT      TargetObject;
    PDEVICE_OBJECT      WholeDiskPdo;
    PVOLMGR_LIST_ENTRY  VolumeManagerEntry;
} PARTITION_LIST_ENTRY, *PPARTITION_LIST_ENTRY;

//
// Allow usage of different clocks
//
#define USE_PERF_CTR                // default to KeQueryPerformanceCounter

#ifdef  USE_PERF_CTR
#define PmWmiGetClock(a, b) (a) = KeQueryPerformanceCounter((b))
#else
#define PmWmiGetClock(a, b) KeQuerySystemTime(&(a))
#endif

typedef
VOID
(*PPHYSICAL_DISK_IO_NOTIFY_ROUTINE)(     // callout for disk I/O tracing
    IN ULONG DiskNumber,
    IN PIRP Irp,
    IN PDISK_PERFORMANCE PerfCounters
    );

typedef struct _DO_EXTENSION {

    //
    // A pointer to the driver object.
    //

    PDRIVER_OBJECT DriverObject;

    //
    // A list of volume managers to pass partitions to.  Protect with
    // 'Mutex'.
    //

    LIST_ENTRY VolumeManagerList;

    //
    // The list of device extensions in EpochNumber order (highest at the head).
    //  Protect with 'Mutex'.
    //

    LIST_ENTRY DeviceExtensionList;

    //
    // The notification entry.
    //

    PVOID NotificationEntry;

    //
    // For synchronization.
    //

    KMUTEX Mutex;

    //
    // Am I past Driver Reinit?
    //

    LONG PastReinit;

    //
    // A table to keep track disk signatures which includes signatures
    // on MBR disks and squashed disk GUIDs on GPT disks.
    //

    RTL_GENERIC_TABLE SignatureTable;

    //
    // A table to keep track of GPT disk and partition GUIDs.
    //

    RTL_GENERIC_TABLE GuidTable;

    //
    // Registry Path.
    //
 
    UNICODE_STRING DiskPerfRegistryPath;        // for WMI QueryRegInfo

    //
    // BootDiskSig for OEM pre-install.
    //

    ULONG BootDiskSig;

    //
    // BootPartitionGuid for OEM pre-install on GPT disks.
    //

    BOOLEAN BootPartitionGuidPresent;
    GUID BootPartitionGuid;

    //
    // The current Epoch Number.  Protect with 'Mutex'.
    //

    ULONG CurrentEpochNumber;

    //
    // Queue of pending notifications for signature checks
    // Protect with 'Mutex'
    //

    LIST_ENTRY SignatureCheckNotificationIrpQueue;

} DO_EXTENSION, *PDO_EXTENSION;

typedef struct _DEVICE_EXTENSION {

    //
    // Indicates that a surprise remove has occurred.
    //

    BOOLEAN RemoveProcessed;

    //
    // Whether or not the counters are running.
    //

    BOOLEAN CountersEnabled;

    //
    // Indicates that this is a redundant path to a disk.
    //

    BOOLEAN IsRedundantPath;

    //
    // Indicates that the device is started.  Protect with 'Mutex'.
    //

    BOOLEAN IsStarted;

    //
    // Indicates that signatures have not yet been checked.
    //

    BOOLEAN SignaturesNotChecked;

    //
    // A pointer to our own device object.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // A pointer to the driver extension.
    //

    PDO_EXTENSION DriverExtension;

    //
    // A pointer to the device object that we are layered above -- a whole
    // disk.
    //

    PDEVICE_OBJECT TargetObject;

    //
    // A pointer to the PDO.
    //

    PDEVICE_OBJECT Pdo;

    //
    // A list of partitions allocated from paged pool.  Protect with
    // 'Mutex'.
    //

    LIST_ENTRY PartitionList;

    //
    // A list entry for the device extension list in the driver extension.
    //

    LIST_ENTRY ListEntry;

    //
    // For paging notifications
    //

    ULONG PagingPathCount;
    KEVENT PagingPathCountEvent;

    //
    // Remember the disk signature so that you can write it out later.
    //

    ULONG DiskSignature;

    //
    // Keep a list of Signatures used on this disk.
    //

    LIST_ENTRY SignatureList;

    //
    // Keep a list of GUIDs used on this disk.
    //

    LIST_ENTRY GuidList;

    //
    // Leave counters always enabled if we see IOCTL_DISK_PERFORMANCE
    //

    LONG EnableAlways;

    //
    // Disk Number.
    //

    ULONG DiskNumber;

    //
    // The Epoch Number for this disk.  Protect with 'Root->Mutex'.
    //

    ULONG EpochNumber;

    //
    // Counter structure.
    //

    PVOID PmWmiCounterContext;

    //
    // Device Name
    //

    UNICODE_STRING PhysicalDeviceName;
    WCHAR PhysicalDeviceNameBuffer[DEVICENAME_MAXSTR];

    //
    // Routine to notify on IO completion.
    //

    PPHYSICAL_DISK_IO_NOTIFY_ROUTINE PhysicalDiskIoNotifyRoutine;

    //
    // Table of WmiLib Functions.
    //

    PWMILIB_CONTEXT WmilibContext;

    //
    //  Work queue for power mgmt processing
    //  Protected by "SpinLock"
    //

    LIST_ENTRY PowerQueue;

    //
    // Spinlock used to protect the power mgmt work queue
    //

    KSPIN_LOCK  SpinLock;

    //
    // Lock structure used to block the device deletion
    // as a result of IRP_MN_REMOVE_DEVICE
    //
    
    IO_REMOVE_LOCK RemoveLock;


} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct _SIGNATURE_TABLE_ENTRY {
    LIST_ENTRY          ListEntry;
    PDEVICE_EXTENSION   Extension;
    ULONG               Signature;
} SIGNATURE_TABLE_ENTRY, *PSIGNATURE_TABLE_ENTRY;

typedef struct _GUID_TABLE_ENTRY {
    LIST_ENTRY          ListEntry;
    PDEVICE_EXTENSION   Extension;
    GUID                Guid;
} GUID_TABLE_ENTRY, *PGUID_TABLE_ENTRY;

//
//  Work item for PmPowerNotify
//

typedef struct _PM_POWER_WORK_ITEM {
    LIST_ENTRY          ListEntry;
    DEVICE_POWER_STATE  DevicePowerState;    
} PM_POWER_WORK_ITEM, *PPM_POWER_WORK_ITEM;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\stripewp.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    stripewp.cxx

Abstract:

    This module contains the code specific to stripes with parity for the fault
    tolerance driver.

Author:

    Bob Rinne   (bobri)  2-Feb-1992
    Mike Glass  (mglass)
    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
STRIPE_WP::Initialize(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN OUT  PFT_VOLUME*         VolumeArray,
    IN      USHORT              ArraySize,
    IN      PVOID               ConfigInfo,
    IN      PVOID               StateInfo
    )

/*++

Routine Description:

    Initialize routine for FT_VOLUME of type STRIPE with PARITY.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id for this volume.

    VolumeArray     - Supplies the array of volumes for this volume set.

    ArraySize       - Supplies the number of volumes in the volume array.

    ConfigInfo      - Supplies the configuration information.

    StateInfo       - Supplies the state information.

Return Value:

    None.

--*/

{
    PFT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION    configInfo;
    NTSTATUS                                                status;
    USHORT                                                  i;

    if (ArraySize < 3) {
        return STATUS_INVALID_PARAMETER;
    }

    status = COMPOSITE_FT_VOLUME::Initialize(RootExtension, LogicalDiskId,
                                             VolumeArray, ArraySize,
                                             ConfigInfo, StateInfo);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    configInfo = (PFT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION) ConfigInfo;
    _stripeSize = configInfo->StripeSize;
    if (_stripeSize < QuerySectorSize()) {
        return STATUS_INVALID_PARAMETER;
    }
    for (i = 0; _stripeSize%2 == 0; i++) {
        _stripeSize /= 2;
    }
    if (_stripeSize != 1) {
        return STATUS_INVALID_PARAMETER;
    }
    _stripeSize = configInfo->StripeSize;
    _memberSize = configInfo->MemberSize;

    for (i = 0; i < ArraySize; i++) {
        if (VolumeArray[i] &&
            VolumeArray[i]->QueryVolumeSize() < _memberSize) {

            break;
        }
    }
    if (i < ArraySize) {
        return STATUS_INVALID_PARAMETER;
    }

    _memberSize = _memberSize/_stripeSize*_stripeSize;
    _volumeSize = _memberSize*(ArraySize - 1);

    RtlCopyMemory(&_state, StateInfo, sizeof(_state));
    _originalDirtyBit = _state.IsDirty;
    _orphanedBecauseOfMissingMember = FALSE;
    _syncOk = TRUE;
    _stopSyncs = FALSE;

    status = _overlappedIoManager.Initialize(_stripeSize);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = _parityIoManager.Initialize(_stripeSize, QuerySectorSize());
    if (!NT_SUCCESS(status)) {
        return status;
    }

    _ePacket = new SWP_WRITE_TP;
    if (!_ePacket ||
        !_ePacket->AllocateMdls(_stripeSize) ||
        !_ePacket->AllocateMdl((PVOID) 1, _stripeSize)) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _ePacketInUse = FALSE;
    _ePacketQueueBeingServiced = FALSE;
    InitializeListHead(&_ePacketQueue);

    _eRegeneratePacket = new SWP_REGENERATE_TP;
    if (!_eRegeneratePacket ||
        !_eRegeneratePacket->AllocateMdl(_stripeSize)) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _eRegeneratePacketInUse = FALSE;
    InitializeListHead(&_eRegeneratePacketQueue);

    _eRecoverPacket = new SWP_RECOVER_TP;
    if (!_eRecoverPacket ||
        !_eRecoverPacket->AllocateMdls(QuerySectorSize())) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _eRecoverPacketInUse = FALSE;
    InitializeListHead(&_eRecoverPacketQueue);

    return STATUS_SUCCESS;
}

FT_LOGICAL_DISK_TYPE
STRIPE_WP::QueryLogicalDiskType(
    )

/*++

Routine Description:

    This routine returns the type of the logical disk.

Arguments:

    None.

Return Value:

    The type of the logical disk.

--*/

{
    return FtStripeSetWithParity;
}

NTSTATUS
STRIPE_WP::QueryPhysicalOffsets(
    IN  LONGLONG                    LogicalOffset,
    OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
    OUT PULONG                      NumberOfPhysicalOffsets
    )
/*++

Routine Description:

    This routine returns physical disk and offset for a given volume
    logical offset.

Arguments:

    LogicalOffset           - Supplies the logical offset

    PhysicalOffsets         - Returns the physical offsets

    NumberOfPhysicalOffsets - Returns the number of physical offsets

Return Value:

    NTSTATUS

--*/
{
    USHORT      n, whichMember, parityStripe;
    LONGLONG    whichStripe, whichRow, logicalOffsetInMember;
    PFT_VOLUME  vol;

    if (LogicalOffset < 0 ||
        _volumeSize <= LogicalOffset) {
        return STATUS_INVALID_PARAMETER;
    }    
    
    n = QueryNumMembers();
    ASSERT(n > 1);
    ASSERT(_stripeSize);
    whichStripe = LogicalOffset/_stripeSize;
    whichRow = whichStripe/(n - 1);
    whichMember = (USHORT) (whichStripe%(n - 1));
    parityStripe = (USHORT) (whichRow%n);
    if (whichMember >= parityStripe) {
        whichMember++;        
    }

    vol = GetMember(whichMember);
    if (!vol) {
        return STATUS_INVALID_PARAMETER;
    }

    logicalOffsetInMember = whichRow*_stripeSize + LogicalOffset%_stripeSize;
    
    return vol->QueryPhysicalOffsets(logicalOffsetInMember, PhysicalOffsets, NumberOfPhysicalOffsets);
}

NTSTATUS
STRIPE_WP::QueryLogicalOffset(
    IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
    OUT PLONGLONG               LogicalOffset
    )
/*++

Routine Description:

    This routine returns the volume logical offset for a given disk number
    and physical offset.

Arguments:

    PhysicalOffset          - Supplies the physical offset

    LogicalOffset           - Returns the logical offset

Return Value:

    NTSTATUS

--*/
{    
    USHORT      n, i, parityStripe;
    LONGLONG    whichStripe, whichRow;
    LONGLONG    logicalOffset, logicalOffsetInMember;
    NTSTATUS    status;
    PFT_VOLUME  vol;
    
    n = QueryNumMembers();
    ASSERT(_stripeSize);
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }
        status = vol->QueryLogicalOffset(PhysicalOffset, &logicalOffsetInMember);
        if (NT_SUCCESS(status)) {
            whichRow = logicalOffsetInMember/_stripeSize;
            parityStripe = (USHORT) (whichRow%n);
            
            if (i == parityStripe) {
                return STATUS_INVALID_PARAMETER;
            }

            whichStripe = whichRow*(n-1) + i;
            if (parityStripe < i) {
                whichStripe--;
            }

            logicalOffset = whichStripe*_stripeSize + logicalOffsetInMember%_stripeSize;
            if (_volumeSize <= logicalOffset) {
                return STATUS_INVALID_PARAMETER;
            }

            *LogicalOffset = logicalOffset;
            return status;
        }        
    }

    return STATUS_INVALID_PARAMETER;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

NTSTATUS
STRIPE_WP::OrphanMember(
    IN  USHORT                  MemberNumber,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine tries to orphan the given member of this logical disk.
    A completion routine will be called if and only if this attempt is successful.

Arguments:

    MemberNumber    - Supplies the member number to orphan.

Return Value:

    NTSTATUS

--*/

{
    KIRQL       irql;
    NTSTATUS    status = STATUS_SUCCESS;
    BOOLEAN     b;

    if (MemberNumber >= QueryNumMembers()) {
        return STATUS_INVALID_PARAMETER;
    }

    KeAcquireSpinLock(&_spinLock, &irql);
    b = SetMemberState(MemberNumber, FtMemberOrphaned);
    KeReleaseSpinLock(&_spinLock, irql);

    if (b) {
        PropogateStateChanges(CompletionRoutine, Context);
        Notify();
        FtpLogError(_rootExtension, QueryLogicalDiskId(), FT_ORPHANING,
                    STATUS_SUCCESS, 2);
    }

    return b ? STATUS_SUCCESS : STATUS_INVALID_PARAMETER;
}

VOID
StripeWpCompositeVolumeCompletionRoutine(
    IN  PVOID       Context,
    IN  NTSTATUS    Status
    )

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    KIRQL                           irql;
    LONG                            count;

    context = (PFT_COMPLETION_ROUTINE_CONTEXT) Context;

    KeAcquireSpinLock(&context->SpinLock, &irql);
    if (!NT_SUCCESS(Status) &&
        FtpIsWorseStatus(Status, context->Status)) {

        context->Status = Status;
    }

    count = --context->RefCount;
    KeReleaseSpinLock(&context->SpinLock, irql);

    if (!count) {
        context->CompletionRoutine(context->Context, STATUS_SUCCESS);
        ExFreePool(context);
    }
}

VOID
StripeWpSyncCleanup(
    IN  PSWP_REBUILD_TP TransferPacket
    )

/*++

Routine Description:

    This is the cleanup routine for the initialize check data process.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;

    context = TransferPacket->Context;
    delete TransferPacket;
    StripeWpCompositeVolumeCompletionRoutine(context, STATUS_SUCCESS);
}

VOID
StripeWpSyncCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for an initialize check data request.
    This routine is called over and over again until the volume
    is completely initialized.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_REBUILD_TP transferPacket = (PSWP_REBUILD_TP) TransferPacket;
    PSTRIPE_WP      t = transferPacket->StripeWithParity;
    NTSTATUS        status = transferPacket->IoStatus.Status;
    KIRQL           irql;
    ULONG           parityMember;
    BOOLEAN         b;

    KeAcquireSpinLock(&t->_spinLock, &irql);
    if (t->_stopSyncs ||
        t->QueryMemberState(transferPacket->WhichMember) == FtMemberOrphaned) {

        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        t->_overlappedIoManager.ReleaseIoRegion(transferPacket);
        StripeWpSyncCleanup(transferPacket);
        return;
    }
    KeReleaseSpinLock(&t->_spinLock, irql);

    if (!NT_SUCCESS(status)) {

        // We can't get a VERIFY_REQUIRED because we put IrpFlags equal
        // to SL_OVERRIDE_VERIFY_VOLUME.

        ASSERT(status != STATUS_VERIFY_REQUIRED);

        if (FsRtlIsTotalDeviceFailure(status)) {

            if (!transferPacket->ReadPacket) {
                KeAcquireSpinLock(&t->_spinLock, &irql);
                b = t->SetMemberState(transferPacket->WhichMember,
                                      FtMemberOrphaned);
                KeReleaseSpinLock(&t->_spinLock, irql);

                if (b) {
                    t->PropogateStateChanges(NULL, NULL);
                    t->Notify();
                    FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                                FT_ORPHANING, STATUS_SUCCESS, 3);
                    IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL,
                                                  NULL);
                }
            }

            // The initialize cannot continue.

            KeAcquireSpinLock(&t->_spinLock, &irql);
            t->_syncOk = TRUE;
            KeReleaseSpinLock(&t->_spinLock, irql);

            t->_overlappedIoManager.ReleaseIoRegion(transferPacket);
            StripeWpSyncCleanup(transferPacket);
            return;
        }

        // Transfer the maximum amount that we can.  This will always
        // complete successfully and log bad sector errors for
        // those sectors that it could not transfer.

        t->MaxTransfer(transferPacket);
        return;
    }

    transferPacket->Thread = PsGetCurrentThread();

    if (transferPacket->ReadPacket) {
        transferPacket->ReadPacket = FALSE;
        TRANSFER(transferPacket);
        return;
    }

    t->_overlappedIoManager.ReleaseIoRegion(transferPacket);

    transferPacket->ReadPacket = TRUE;
    transferPacket->Offset += t->_stripeSize;
    if (transferPacket->Initialize) {
        transferPacket->WhichMember = (transferPacket->WhichMember + 1)%
                                      t->QueryNumMembers();
        transferPacket->TargetVolume = t->GetMemberUnprotected(
                                       transferPacket->WhichMember);
    }

    if (transferPacket->Offset < t->_memberSize) {
        t->RegeneratePacket(transferPacket, TRUE);
        return;
    }

    if (transferPacket->Initialize) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        t->_state.IsInitializing = FALSE;
        t->_syncOk = TRUE;
        t->_originalDirtyBit = FALSE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        t->PropogateStateChanges(NULL, NULL);
        t->Notify();
    } else {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        b = t->SetMemberState(transferPacket->WhichMember, FtMemberHealthy);
        t->_syncOk = TRUE;
        t->_originalDirtyBit = FALSE;
        KeReleaseSpinLock(&t->_spinLock, irql);

        if (b) {
            t->PropogateStateChanges(NULL, NULL);
            t->Notify();
        }
    }

    FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                FT_REGENERATION_ENDED, STATUS_SUCCESS, 0);

    StripeWpSyncCleanup(transferPacket);
}

NTSTATUS
STRIPE_WP::RegenerateMember(
    IN      USHORT                  MemberNumber,
    IN OUT  PFT_VOLUME              NewMember,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This routine regenerates the given member of this volume with
    the given volume.

Arguments:

    MemberNumber        - Supplies the member number to regenerate.

    NewMember           - Supplies the new member to regenerate to.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    NTSTATUS

--*/

{
    KIRQL                           irql;
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    BOOLEAN                         b;
    PSWP_REBUILD_TP                 packet;
    USHORT                          i, n;
    NTSTATUS                        status;

    n = QueryNumMembers();
    if (MemberNumber >= n ||
        NewMember->QueryVolumeSize() < _memberSize) {

        return STATUS_INVALID_PARAMETER;
    }

    context = (PFT_COMPLETION_ROUTINE_CONTEXT)
              ExAllocatePool(NonPagedPool,
                             sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    packet = new SWP_REBUILD_TP;
    if (packet && !packet->AllocateMdl(_stripeSize)) {
        delete packet;
        packet = NULL;
    }
    if (!context || !packet) {
        if (context) {
            ExFreePool(context);
        }
        if (packet) {
            delete packet;
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeSpinLock(&context->SpinLock);
    context->Status = STATUS_SUCCESS;
    context->RefCount = 1;
    context->CompletionRoutine = CompletionRoutine;
    context->Context = Context;
    context->ParentVolume = this;

    packet->Length = _stripeSize;
    packet->Offset = 0;
    packet->CompletionRoutine = StripeWpSyncCompletionRoutine;
    packet->Thread = PsGetCurrentThread();
    packet->IrpFlags = SL_OVERRIDE_VERIFY_VOLUME;
    packet->ReadPacket = TRUE;
    packet->StripeWithParity = this;
    packet->Context = context;
    packet->Initialize = FALSE;

    KeAcquireSpinLock(&_spinLock, &irql);
    if (_syncOk) {
        _syncOk = FALSE;
        _stopSyncs = FALSE;
    } else {
        KeReleaseSpinLock(&_spinLock, irql);
        delete packet;
        ExFreePool(context);
        return STATUS_INVALID_PARAMETER;
    }

    status = STATUS_SUCCESS;
    if (_state.IsInitializing) {
        status = STATUS_INVALID_PARAMETER;
    } else {
        if (_state.UnhealthyMemberState != FtMemberHealthy) {
            if (MemberNumber == _state.UnhealthyMemberNumber) {
                if (_state.UnhealthyMemberState == FtMemberRegenerating) {
                    status = STATUS_INVALID_PARAMETER;
                }
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
    }

    if (!NT_SUCCESS(status)) {
        _syncOk = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);
        ExFreePool(context);
        delete packet;
        return status;
    }

    packet->WhichMember = MemberNumber;
    packet->TargetVolume = NewMember;

    SetMemberUnprotected(MemberNumber, NewMember);
    b = SetMemberState(MemberNumber, FtMemberRegenerating);
    KeReleaseSpinLock(&_spinLock, irql);

    ASSERT(b);

    PropogateStateChanges(NULL, NULL);
    Notify();

    FtpLogError(_rootExtension, QueryLogicalDiskId(), FT_REGENERATION_STARTED,
                STATUS_SUCCESS, 0);

    RegeneratePacket(packet, TRUE);

    return STATUS_SUCCESS;
}

VOID
STRIPE_WP::Transfer(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Transfer routine for STRIPE_WP type FT_VOLUME.  Figure out
    which volumes this request needs to be dispatched to.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    KIRQL       irql;

    if (TransferPacket->Offset + TransferPacket->Length > _volumeSize) {
        TransferPacket->IoStatus.Status = STATUS_INVALID_PARAMETER;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    KeAcquireSpinLock(&_spinLock, &irql);
    if ((_ePacketInUse  || _ePacketQueueBeingServiced) &&
        TransferPacket->Mdl) {

        InsertTailList(&_ePacketQueue, &TransferPacket->QueueEntry);
        KeReleaseSpinLock(&_spinLock, irql);
        return;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (!TransferPacket->Mdl) {
        TransferPacket->ReadPacket = TRUE;
    }

    if (!LaunchParallel(TransferPacket)) {
        if (!TransferPacket->Mdl) {
            TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }

        KeAcquireSpinLock(&_spinLock, &irql);
        if (_ePacketInUse || _ePacketQueueBeingServiced) {
            InsertTailList(&_ePacketQueue, &TransferPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _ePacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        LaunchSequential(TransferPacket);
    }
}

VOID
STRIPE_WP::ReplaceBadSector(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is a no-op since replacing bad sectors doesn't make sense
    on an FT component with redundancy built in to it.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    TransferPacket->IoStatus.Status = STATUS_UNSUCCESSFUL;
    TransferPacket->IoStatus.Information = 0;
    TransferPacket->CompletionRoutine(TransferPacket);
}

VOID
STRIPE_WP::StartSyncOperations(
    IN      BOOLEAN                 RegenerateOrphans,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This aroutine restarts any regenerate or initialize requests that
    were suspended because of a reboot.  The volume examines the member
    state of all of its constituents and restarts any regenerations pending.

Arguments:

    RegenerateOrphans   - Supplies whether or not to try and regenerate
                            orphaned members.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the context for the completion routine.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    BOOLEAN                         dirty, regen, init;
    KIRQL                           irql;
    PFT_VOLUME                      vol;
    PSWP_REBUILD_TP                 packet;
    PVOID                           buffer;
    LONG                            regenMember;

    context = (PFT_COMPLETION_ROUTINE_CONTEXT)
              ExAllocatePool(NonPagedPool,
                             sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    if (!context) {
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    KeInitializeSpinLock(&context->SpinLock);
    context->Status = STATUS_SUCCESS;
    context->RefCount = 2;
    context->CompletionRoutine = CompletionRoutine;
    context->Context = Context;
    context->ParentVolume = this;

    // Kick off the recursive initialize.

    COMPOSITE_FT_VOLUME::StartSyncOperations(RegenerateOrphans,
            StripeWpCompositeVolumeCompletionRoutine, context);

    if (_orphanedBecauseOfMissingMember) {
        RegenerateOrphans = TRUE;
        _orphanedBecauseOfMissingMember = FALSE;
    }

    // Make sure that all member are healthy.

    dirty = FALSE;
    regen = FALSE;
    init = FALSE;
    KeAcquireSpinLock(&_spinLock, &irql);
    if (_syncOk) {
        _syncOk = FALSE;
        _stopSyncs = FALSE;
    } else {
        KeReleaseSpinLock(&_spinLock, irql);
        StripeWpCompositeVolumeCompletionRoutine(context, STATUS_SUCCESS);
        return;
    }
    if (_state.UnhealthyMemberState == FtMemberOrphaned &&
        RegenerateOrphans &&
        GetMemberUnprotected(_state.UnhealthyMemberNumber)) {

        _state.UnhealthyMemberState = FtMemberRegenerating;
        PropogateStateChanges(NULL, NULL);
    }
    if (_state.IsInitializing) {
        regenMember = -1;
        init = TRUE;
    } else if (_state.UnhealthyMemberState == FtMemberRegenerating) {
        regenMember = _state.UnhealthyMemberNumber;
        regen = TRUE;
    } else if (_originalDirtyBit &&
               _state.UnhealthyMemberState == FtMemberHealthy) {

        regenMember = -1;
        dirty = TRUE;
    } else {
        regenMember = -2;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (dirty) {
        FtpLogError(_rootExtension, QueryLogicalDiskId(),
                    FT_DIRTY_SHUTDOWN, STATUS_SUCCESS, 0);
    }

    if (regen) {
        FtpLogError(_rootExtension, QueryLogicalDiskId(),
                    FT_REGENERATION_STARTED, STATUS_SUCCESS, 0);
        Notify();
    }

    if (init) {
        FtpLogError(_rootExtension, QueryLogicalDiskId(),
                    FT_PARITY_INITIALIZATION_STARTED, STATUS_SUCCESS, 0);
        Notify();
    }

    if (regenMember == -2) {
        KeAcquireSpinLock(&_spinLock, &irql);
        _syncOk = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);
        StripeWpCompositeVolumeCompletionRoutine(context, STATUS_SUCCESS);
        return;
    }

    packet = new SWP_REBUILD_TP;
    if (packet && !packet->AllocateMdl(_stripeSize)) {
        delete packet;
        packet = NULL;
    }
    if (!packet) {
        KeAcquireSpinLock(&_spinLock, &irql);
        _syncOk = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);
        StripeWpCompositeVolumeCompletionRoutine(context,
                                                 STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    packet->Length = _stripeSize;
    packet->Offset = 0;
    packet->CompletionRoutine = StripeWpSyncCompletionRoutine;
    packet->Thread = PsGetCurrentThread();
    packet->IrpFlags = SL_OVERRIDE_VERIFY_VOLUME;
    packet->ReadPacket = TRUE;
    packet->MasterPacket = NULL;
    packet->StripeWithParity = this;
    packet->Context = context;
    if (regenMember >= 0) {
        packet->WhichMember = (USHORT) regenMember;
        packet->Initialize = FALSE;
    } else {
        packet->WhichMember = 0;
        packet->Initialize = TRUE;
    }
    packet->TargetVolume = GetMemberUnprotected(packet->WhichMember);

    RegeneratePacket(packet, TRUE);
}

VOID
STRIPE_WP::StopSyncOperations(
    )

/*++

Routine Description:

    This routine stops all sync operations.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KIRQL   irql;

    COMPOSITE_FT_VOLUME::StopSyncOperations();

    KeAcquireSpinLock(&_spinLock, &irql);
    if (!_syncOk) {
        _stopSyncs = TRUE;
    }
    KeReleaseSpinLock(&_spinLock, irql);
}

LONGLONG
STRIPE_WP::QueryVolumeSize(
    )

/*++

Routine Description:

    Returns the number of bytes on the entire volume.

Arguments:

    None.

Return Value:

    The volume size in bytes.

--*/

{
    return _volumeSize;
}

VOID
STRIPE_WP::SetDirtyBit(
    IN  BOOLEAN                 IsDirty,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine sets the dirty bit on the volume.  This bit is used at
    startup to determine whether or not there was a clean shutdown.

Arguments:

    IsDirty - Supplies the value of the dirty bit.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    KIRQL                           irql;

    if (CompletionRoutine) {

        context = (PFT_COMPLETION_ROUTINE_CONTEXT)
                  ExAllocatePool(NonPagedPool,
                                 sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
        if (!context) {
            CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
            return;
        }

        KeInitializeSpinLock(&context->SpinLock);
        context->Status = STATUS_SUCCESS;
        context->RefCount = 2;
        context->CompletionRoutine = CompletionRoutine;
        context->Context = Context;
        context->ParentVolume = this;

        COMPOSITE_FT_VOLUME::SetDirtyBit(IsDirty,
                StripeWpCompositeVolumeCompletionRoutine, context);

    } else {
        COMPOSITE_FT_VOLUME::SetDirtyBit(IsDirty, NULL, NULL);
    }

    KeAcquireSpinLock(&_spinLock, &irql);
    if (IsDirty || _syncOk) {
        if (!_stopSyncs) {
            _state.IsDirty = IsDirty;
        }
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (CompletionRoutine) {
        PropogateStateChanges(StripeWpCompositeVolumeCompletionRoutine, context);
    } else {
        PropogateStateChanges(NULL, NULL);
    }
}

BOOLEAN
STRIPE_WP::IsComplete(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine computes whether or not this volume has either all
    (if IoPending is FALSE) of its members or enough (if IoPending is TRUE) of
    its members.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    BOOLEAN     b;
    USHORT      n, i, orphanMember;
    PFT_VOLUME  vol;

    b = COMPOSITE_FT_VOLUME::IsComplete(IoPending);
    if (b) {
        return TRUE;
    }

    if (!IoPending || _state.IsInitializing) {
        return FALSE;
    }

    n = QueryNumMembers();
    orphanMember = n;
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol || !vol->IsComplete(IoPending)) {
            if (orphanMember < n) {
                return FALSE;
            }
            orphanMember = i;
        }
    }

    if (orphanMember < n) {
        if (_state.UnhealthyMemberState != FtMemberHealthy &&
            _state.UnhealthyMemberNumber != orphanMember) {

            return FALSE;
        }
    }

    return TRUE;
}

VOID
STRIPE_WP::CompleteNotification(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine is called to notify the volume that it is complete and
    to therefore prepare for incoming requests.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    USHORT      n, i, orphanMember;
    PFT_VOLUME  vol;

    COMPOSITE_FT_VOLUME::CompleteNotification(IoPending);

    n = QueryNumMembers();
    orphanMember = n;
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol || !vol->IsComplete(IoPending)) {
            orphanMember = i;
            break;
        }
    }

    if (orphanMember < n) {
        if (SetMemberState(orphanMember, FtMemberOrphaned)) {
            PropogateStateChanges(NULL, NULL);
            Notify();
            FtpLogError(_rootExtension, QueryLogicalDiskId(),
                        FT_ORPHANING, STATUS_SUCCESS, 1);
            IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
            _orphanedBecauseOfMissingMember = TRUE;
        }
    }
}

NTSTATUS
STRIPE_WP::CheckIo(
    OUT PBOOLEAN    IsIoOk
    )

/*++

Routine Description:

    This routine returns whether or not IO is possible on the given
    logical disk.

Arguments:

    IsIoOk  - Returns the state of IO.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS    status;
    KIRQL       irql;
    USHORT      n, numOk, skipVol, i;
    PFT_VOLUME  vol;
    BOOLEAN     ok, b;

    n = QueryNumMembers();
    numOk = 0;
    KeAcquireSpinLock(&_spinLock, &irql);
    if (_state.UnhealthyMemberState == FtMemberHealthy) {
        skipVol = n;
    } else {
        skipVol = _state.UnhealthyMemberNumber;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    for (i = 0; i < n; i++) {
        if (i == skipVol) {
            continue;
        }
        vol = GetMemberUnprotected(i);
        if (!vol) {
            continue;
        }

        status = vol->CheckIo(&ok);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (ok) {
            numOk++;
        }
    }

    if (numOk >= n - 1) {
        *IsIoOk = TRUE;
    } else {
        *IsIoOk = FALSE;
    }

    return STATUS_SUCCESS;
}

BOOLEAN
STRIPE_WP::IsVolumeSuitableForRegenerate(
    IN  USHORT      MemberNumber,
    IN  PFT_VOLUME  Volume
    )

/*++

Routine Description:

    This routine computes whether or not the given volume is suitable
    for a regenerate operation.

Arguments:

    MemberNumber    - Supplies the member number.

    Volume          - Supplies the volume.

Return Value:

    FALSE   - The volume is not suitable.

    TRUE    - The volume is suitable.

--*/

{
    KIRQL   irql;

    if (Volume->QueryVolumeSize() < _memberSize) {
        return FALSE;
    }

    KeAcquireSpinLock(&_spinLock, &irql);
    if (!_syncOk ||
        _state.IsInitializing ||
        _state.UnhealthyMemberState != FtMemberOrphaned ||
        _state.UnhealthyMemberNumber != MemberNumber) {

        KeReleaseSpinLock(&_spinLock, irql);
        return FALSE;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    return TRUE;
}

VOID
STRIPE_WP::NewStateArrival(
    IN  PVOID   NewStateInstance
    )

/*++

Routine Description:

    This routine takes the new state instance arrival combined with its
    current state to come up with the new current state for the volume.
    If the two states cannot be reconciled then this routine returns FALSE
    indicating that the volume is invalid and should be broken into its
    constituant parts.

Arguments:

    NewStateInstance    - Supplies the new state instance.

Return Value:

    None.

--*/

{
    BOOLEAN                                 changed = FALSE;
    BOOLEAN                                 severeInconsistency = FALSE;
    PFT_MIRROR_AND_SWP_STATE_INFORMATION    state;

    state = (PFT_MIRROR_AND_SWP_STATE_INFORMATION) NewStateInstance;
    if (state->IsDirty) {
        if (!_state.IsDirty) {
            _originalDirtyBit = _state.IsDirty = state->IsDirty;
            changed = TRUE;
        }
    }

    if (state->IsInitializing) {
        if (_state.UnhealthyMemberState == FtMemberHealthy) {
            if (!_state.IsInitializing) {
                _state.IsInitializing = TRUE;
                changed = TRUE;
            }
        } else {
            severeInconsistency = TRUE;
        }
    } else if (state->UnhealthyMemberState != FtMemberHealthy) {
        if (state->UnhealthyMemberNumber >= QueryNumMembers()) {
            severeInconsistency = TRUE;
        } else if (_state.IsInitializing) {
            severeInconsistency = TRUE;
        } else if (_state.UnhealthyMemberState == FtMemberHealthy) {
            _state.UnhealthyMemberState = state->UnhealthyMemberState;
            _state.UnhealthyMemberNumber = state->UnhealthyMemberNumber;
            changed = TRUE;
        } else if (_state.UnhealthyMemberNumber == state->UnhealthyMemberNumber) {
            if (state->UnhealthyMemberState == FtMemberOrphaned) {
                if (_state.UnhealthyMemberState != FtMemberOrphaned) {
                    _state.UnhealthyMemberState = FtMemberOrphaned;
                    changed = TRUE;
                }
            }
        } else {
            severeInconsistency = TRUE;
        }
    }

    if (severeInconsistency) {
        _state.IsInitializing = TRUE;
        _state.UnhealthyMemberState = FtMemberHealthy;
        changed = TRUE;
        FtpLogError(_rootExtension, QueryLogicalDiskId(),
                    FT_SWP_STATE_CORRUPTION, STATUS_SUCCESS,
                    0);
    }

    if (changed) {
        PropogateStateChanges(NULL, NULL);
    }
}

BOOLEAN
STRIPE_WP::QueryVolumeState(
    IN  PFT_VOLUME          Volume,
    OUT PFT_MEMBER_STATE    State
    )

/*++

Routine Description:

    This routine returns the state of the given volume considered as a
    member of this volume.

Arguments:

    Volume  - Supplies the volume to query the state for.

    State   - Returns the state.

Return Value:

    FALSE   - The given Volume is not a member of this volume.

    TRUE    - The state was successfully computed.

--*/

{
    USHORT          n, i;
    PFT_VOLUME      vol;
    KIRQL           irql;
    FT_MEMBER_STATE state;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }

        if (!vol->QueryVolumeState(Volume, State)) {
            continue;
        }

        KeAcquireSpinLock(&_spinLock, &irql);
        state = QueryMemberState(i);
        if (state != FtMemberHealthy) {
            if (*State != FtMemberOrphaned) {
                *State = state;
            }
        }
        KeReleaseSpinLock(&_spinLock, irql);

        return TRUE;
    }

    return FALSE;
}

STRIPE_WP::STRIPE_WP(
    )

/*++

Routine Description:

    Constructor.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _ePacket = NULL;
    _eRegeneratePacket = NULL;
    _eRecoverPacket = NULL;
}

STRIPE_WP::~STRIPE_WP(
    )

/*++

Routine Description:

    Routine called to cleanup resources being used by the object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (_ePacket) {
        delete _ePacket;
        _ePacket = NULL;
    }
    if (_eRegeneratePacket) {
        delete _eRegeneratePacket;
        _eRegeneratePacket = NULL;
    }
    if (_eRecoverPacket) {
        delete _eRecoverPacket;
        _eRecoverPacket = NULL;
    }
}

BOOLEAN
STRIPE_WP::SetMemberState(
    IN  USHORT          MemberNumber,
    IN  FT_MEMBER_STATE MemberState
    )

/*++

Routine Description:

    This routine sets the given member to the given state.

Arguments:

    MemberNumber    - Supplies the member number.

    MemberState     - Supplies the member state.

Return Value:

    FALSE   - There was no state change.

    TRUE    - A state change took place.

Notes:

    The caller must be holding the class spin lock.

--*/

{
    if (_state.IsInitializing) {
        return FALSE;
    }

    if (_state.UnhealthyMemberState == FtMemberHealthy) {
        if (MemberNumber >= QueryNumMembers()) {
            KeBugCheckEx(FTDISK_INTERNAL_ERROR, (ULONG_PTR) this,
                         MemberNumber, MemberState, 0);
        }
        _state.UnhealthyMemberNumber = MemberNumber;
        _state.UnhealthyMemberState = MemberState;
        return TRUE;
    }

    if (_state.UnhealthyMemberNumber == MemberNumber &&
        _state.UnhealthyMemberState != MemberState) {

        _state.UnhealthyMemberState = MemberState;
        return TRUE;
    }

    return FALSE;
}

VOID
StripeWpParallelTransferCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for STRIPE_WP::Transfer function.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_TP             transferPacket = (PSWP_TP) TransferPacket;
    PSTRIPE_WP          t = (PSTRIPE_WP) transferPacket->StripeWithParity;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PTRANSFER_PACKET    p;
    LONG                count;
    BOOLEAN             b, serviceQueue;
    PSWP_WRITE_TP       writePacket;

    if (NT_SUCCESS(status)) {

        KeAcquireSpinLock(&masterPacket->SpinLock, &irql);

        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Information +=
                    transferPacket->IoStatus.Information;
        }

        if (transferPacket->OneReadFailed &&
            FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {

            masterPacket->IoStatus.Status = status;
        }

    } else {

        // Should we orphan the drive?

        if (transferPacket->ReadPacket &&
            !transferPacket->OneReadFailed &&
            status != STATUS_VERIFY_REQUIRED) {

            if (FsRtlIsTotalDeviceFailure(status)) {
                KeAcquireSpinLock(&t->_spinLock, &irql);
                b = t->SetMemberState(transferPacket->WhichMember,
                                      FtMemberOrphaned);
                KeReleaseSpinLock(&t->_spinLock, irql);

                if (b) {
                    t->PropogateStateChanges(NULL, NULL);
                    t->Notify();
                    FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                                FT_ORPHANING, STATUS_SUCCESS, 4);
                    IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL,
                                                  NULL);
                }

                t->RegeneratePacket(transferPacket, TRUE);
                return;
            }

            // Is this something that we should retry for bad sectors?

            if (transferPacket->Mdl) {
                transferPacket->OneReadFailed = TRUE;
                t->Recover(transferPacket, TRUE);
                return;
            }
        }

        KeAcquireSpinLock(&masterPacket->SpinLock, &irql);

        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }
    }

    count = --masterPacket->RefCount;

    KeReleaseSpinLock(&masterPacket->SpinLock, irql);

    serviceQueue = FALSE;
    KeAcquireSpinLock(&t->_spinLock, &irql);
    if (t->_ePacketInUse && !t->_ePacketQueueBeingServiced) {
        t->_ePacketQueueBeingServiced = TRUE;
        serviceQueue = TRUE;
    }
    KeReleaseSpinLock(&t->_spinLock, irql);

    delete transferPacket;

    if (!count) {
        masterPacket->CompletionRoutine(masterPacket);
    }

    if (serviceQueue) {

        for (;;) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            if (IsListEmpty(&t->_ePacketQueue)) {
                t->_ePacketQueueBeingServiced = FALSE;
                KeReleaseSpinLock(&t->_spinLock, irql);
                break;
            }
            l = RemoveHeadList(&t->_ePacketQueue);
            KeReleaseSpinLock(&t->_spinLock, irql);

            p = CONTAINING_RECORD(l, TRANSFER_PACKET, QueueEntry);

            if (!t->LaunchParallel(p)) {
                KeAcquireSpinLock(&t->_spinLock, &irql);
                if (t->_ePacketInUse) {
                    InsertHeadList(&t->_ePacketQueue, l);
                    t->_ePacketQueueBeingServiced = FALSE;
                    KeReleaseSpinLock(&t->_spinLock, irql);
                } else {
                    t->_ePacketInUse = TRUE;
                    KeReleaseSpinLock(&t->_spinLock, irql);
                    t->LaunchSequential(p);
                    KeAcquireSpinLock(&t->_spinLock, &irql);
                    if (!t->_ePacketInUse) {
                        KeReleaseSpinLock(&t->_spinLock, irql);
                        continue;
                    }
                    t->_ePacketQueueBeingServiced = FALSE;
                    KeReleaseSpinLock(&t->_spinLock, irql);
                }
                break;
            }
        }
    }
}

BOOLEAN
STRIPE_WP::LaunchParallel(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine launches a transfer packet in parallel accross the
    stripe members.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    FALSE   - Insufficient resources.

    TRUE    - Success.

--*/

{
    LONGLONG    offset, whichStripe, whichRow, off;
    ULONG       length, stripeRemainder, numRequests, arraySize;
    USHORT      whichMember, parityStripe;
    ULONG       len;
    PSWP_TP     p;
    ULONG       i;
    PCHAR       vp;
    LIST_ENTRY  q;
    PLIST_ENTRY l;

    // Compute the number of pieces for this transfer.

    offset = TransferPacket->Offset;
    length = TransferPacket->Length;

    stripeRemainder = _stripeSize - (ULONG) (offset%_stripeSize);
    if (length > stripeRemainder) {
        length -= stripeRemainder;
        numRequests = length/_stripeSize;
        length -= numRequests*_stripeSize;
        if (length) {
            numRequests += 2;
        } else {
            numRequests++;
        }
    } else {
        numRequests = 1;
    }

    KeInitializeSpinLock(&TransferPacket->SpinLock);
    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = 0;
    TransferPacket->RefCount = numRequests;

    length = TransferPacket->Length;
    if (TransferPacket->Mdl && numRequests > 1) {
        vp = (PCHAR) MmGetMdlVirtualAddress(TransferPacket->Mdl);
    }
    whichStripe = offset/_stripeSize;
    arraySize = QueryNumMembers();
    InitializeListHead(&q);
    for (i = 0; i < numRequests; i++, whichStripe++) {

        whichRow = whichStripe/(arraySize - 1);
        whichMember = (USHORT) (whichStripe%(arraySize - 1));
        parityStripe = (USHORT) (whichRow%arraySize);
        if (whichMember >= parityStripe) {
            whichMember++;
        }
        if (i == 0) {
            off = whichRow*_stripeSize + offset%_stripeSize;
            len = stripeRemainder > length ? length : stripeRemainder;
        } else if (i == numRequests - 1) {
            off = whichRow*_stripeSize;
            len = length;
        } else {
            off = whichRow*_stripeSize;
            len = _stripeSize;
        }
        length -= len;

        if (TransferPacket->ReadPacket) {
            p = new SWP_TP;
        } else {
            p = new SWP_WRITE_TP;
            if (p && !((PSWP_WRITE_TP) p)->AllocateMdls(len)) {
                delete p;
                p = NULL;
            }
        }
        if (p) {
            if (TransferPacket->Mdl && numRequests > 1) {
                if (p->AllocateMdl(vp, len)) {
                    IoBuildPartialMdl(TransferPacket->Mdl, p->Mdl, vp, len);
                } else {
                    delete p;
                    p = NULL;
                }
                vp += len;
            } else {
                p->Mdl = TransferPacket->Mdl;
            }
        }
        if (!p) {
            while (!IsListEmpty(&q)) {
                l = RemoveHeadList(&q);
                p = CONTAINING_RECORD(l, SWP_TP, QueueEntry);
                delete p;
            }
            return FALSE;
        }

        p->Length = len;
        p->Offset = off;
        p->CompletionRoutine = StripeWpParallelTransferCompletionRoutine;
        p->Thread = TransferPacket->Thread;
        p->IrpFlags = TransferPacket->IrpFlags;
        p->ReadPacket = TransferPacket->ReadPacket;
        p->MasterPacket = TransferPacket;
        p->StripeWithParity = this;
        p->WhichMember = whichMember;
        p->SavedCompletionRoutine = StripeWpParallelTransferCompletionRoutine;
        p->OneReadFailed = FALSE;

        InsertTailList(&q, &p->QueueEntry);
    }

    while (!IsListEmpty(&q)) {
        l = RemoveHeadList(&q);
        p = CONTAINING_RECORD(l, SWP_TP, QueueEntry);
        ASSERT(p->ReadPacket == TransferPacket->ReadPacket);
        if (p->ReadPacket) {
            ReadPacket(p);
        } else {
            WritePacket((PSWP_WRITE_TP) p);
        }
    }

    return TRUE;
}

VOID
StripeWpSequentialTransferCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for STRIPE::Transfer function.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_TP             transferPacket = (PSWP_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    PSTRIPE_WP          t = transferPacket->StripeWithParity;
    LONGLONG            rowNumber, stripeNumber, masterOffset;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PTRANSFER_PACKET    p;
    USHORT              parityStripe;
    BOOLEAN             b;
    PSWP_WRITE_TP       writePacket;

    if (NT_SUCCESS(status)) {

        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Information +=
                    transferPacket->IoStatus.Information;
        }

        if (transferPacket->OneReadFailed &&
            FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {

            masterPacket->IoStatus.Status = status;
        }

    } else {

        // Should we orphan the drive?

        if (transferPacket->ReadPacket &&
            !transferPacket->OneReadFailed &&
            status != STATUS_VERIFY_REQUIRED) {

            if (FsRtlIsTotalDeviceFailure(status)) {
                KeAcquireSpinLock(&t->_spinLock, &irql);
                b = t->SetMemberState(transferPacket->WhichMember,
                                      FtMemberOrphaned);
                KeReleaseSpinLock(&t->_spinLock, irql);

                if (b) {
                    t->PropogateStateChanges(NULL, NULL);
                    t->Notify();
                    FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                                FT_ORPHANING, STATUS_SUCCESS, 5);
                    IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL,
                                                  NULL);
                }

                t->RegeneratePacket(transferPacket, TRUE);
                return;

            }

            // Is this something that we should retry for bad sectors.

            if (transferPacket->Mdl) {
                transferPacket->OneReadFailed = TRUE;
                t->Recover(transferPacket, TRUE);
                return;
            }
        }

        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }
    }

    MmPrepareMdlForReuse(transferPacket->Mdl);

    t->_overlappedIoManager.ReleaseIoRegion(transferPacket);

    rowNumber = transferPacket->Offset/t->_stripeSize;
    parityStripe = (USHORT) rowNumber%t->QueryNumMembers();
    stripeNumber = rowNumber*(t->QueryNumMembers() - 1) +
                   transferPacket->WhichMember;
    if (transferPacket->WhichMember > parityStripe) {
        stripeNumber--;
    }

    masterOffset = stripeNumber*t->_stripeSize +
                   transferPacket->Offset%t->_stripeSize +
                   transferPacket->Length;

    if (masterOffset == masterPacket->Offset + masterPacket->Length) {

        masterPacket->CompletionRoutine(masterPacket);

        KeAcquireSpinLock(&t->_spinLock, &irql);
        if (t->_ePacketQueueBeingServiced) {
            t->_ePacketInUse = FALSE;
            KeReleaseSpinLock(&t->_spinLock, irql);
            return;
        }
        t->_ePacketQueueBeingServiced = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);

        for (;;) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            if (IsListEmpty(&t->_ePacketQueue)) {
                t->_ePacketInUse = FALSE;
                t->_ePacketQueueBeingServiced = FALSE;
                KeReleaseSpinLock(&t->_spinLock, irql);
                break;
            }
            l = RemoveHeadList(&t->_ePacketQueue);
            KeReleaseSpinLock(&t->_spinLock, irql);

            p = CONTAINING_RECORD(l, TRANSFER_PACKET, QueueEntry);

            if (!t->LaunchParallel(p)) {
                t->LaunchSequential(p);
                KeAcquireSpinLock(&t->_spinLock, &irql);
                if (!t->_ePacketInUse) {
                    KeReleaseSpinLock(&t->_spinLock, irql);
                    continue;
                }
                t->_ePacketQueueBeingServiced = FALSE;
                KeReleaseSpinLock(&t->_spinLock, irql);
                break;
            }
        }
        return;
    }

    transferPacket->WhichMember++;
    if (transferPacket->WhichMember == t->QueryNumMembers()) {
        transferPacket->WhichMember = 0;
        rowNumber++;
    } else if (transferPacket->WhichMember == parityStripe) {
        transferPacket->WhichMember++;
        if (transferPacket->WhichMember == t->QueryNumMembers()) {
            transferPacket->WhichMember = 1;
            rowNumber++;
        }
    }

    transferPacket->Offset = rowNumber*t->_stripeSize;
    transferPacket->Length = t->_stripeSize;

    if (masterOffset + transferPacket->Length >
        masterPacket->Offset + masterPacket->Length) {

        transferPacket->Length = (ULONG) (masterPacket->Offset +
                                          masterPacket->Length - masterOffset);
    }

    IoBuildPartialMdl(masterPacket->Mdl, transferPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (masterOffset - masterPacket->Offset),
                      transferPacket->Length);

    if (transferPacket->ReadPacket) {
        t->ReadPacket(transferPacket);
    } else {
        t->WritePacket((PSWP_WRITE_TP) transferPacket);
    }
}

VOID
STRIPE_WP::LaunchSequential(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine launches a transfer packet sequentially accross the
    stripe members using the emergency packet.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    FALSE   - Insufficient resources.

    TRUE    - Success.

--*/

{
    PSWP_WRITE_TP   p;
    LONGLONG        offset, whichStripe, whichRow, o;
    USHORT          whichMember, arraySize, parityStripe;
    ULONG           l, stripeRemainder;

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = 0;

    offset = TransferPacket->Offset;

    p = _ePacket;
    arraySize = QueryNumMembers();
    stripeRemainder = _stripeSize - (ULONG) (offset%_stripeSize);
    whichStripe = offset/_stripeSize;
    whichRow = whichStripe/(arraySize - 1);
    whichMember = (USHORT) (whichStripe%(arraySize - 1));
    parityStripe = (USHORT) (whichRow%arraySize);
    if (whichMember >= parityStripe) {
        whichMember++;
    }
    o = whichRow*_stripeSize + offset%_stripeSize;
    l = stripeRemainder;
    if (l > TransferPacket->Length) {
        l = TransferPacket->Length;
    }
    IoBuildPartialMdl(TransferPacket->Mdl, p->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl), l);

    p->Length = l;
    p->Offset = o;
    p->CompletionRoutine = StripeWpSequentialTransferCompletionRoutine;
    p->Thread = TransferPacket->Thread;
    p->IrpFlags = TransferPacket->IrpFlags;
    p->ReadPacket = TransferPacket->ReadPacket;
    p->MasterPacket = TransferPacket;
    p->StripeWithParity = this;
    p->WhichMember = whichMember;
    p->SavedCompletionRoutine = StripeWpSequentialTransferCompletionRoutine;
    p->OneReadFailed = FALSE;

    if (p->ReadPacket) {
        ReadPacket(p);
    } else {
        WritePacket(p);
    }
}

VOID
STRIPE_WP::ReadPacket(
    IN OUT  PSWP_TP    TransferPacket
    )

/*++

Routine Description:

    This routine takes a packet that is restricted to a single
    stripe region and reads that data.

Arguments:

    TransferPacket  - Supplies the main read packet.

Return Value:

    None.

--*/

{
    PTRANSFER_PACKET    masterPacket = TransferPacket->MasterPacket;
    KIRQL               irql;

    TransferPacket->TargetVolume = GetMemberUnprotected(TransferPacket->WhichMember);
    KeAcquireSpinLock(&_spinLock, &irql);
    if (QueryMemberState(TransferPacket->WhichMember) != FtMemberHealthy ||
        masterPacket->SpecialRead == TP_SPECIAL_READ_SECONDARY) {

        KeReleaseSpinLock(&_spinLock, irql);
        RegeneratePacket(TransferPacket, TRUE);
    } else {
        KeReleaseSpinLock(&_spinLock, irql);
        TRANSFER(TransferPacket);
    }
}

VOID
StripeWpWritePhase31(
    IN OUT  PTRANSFER_PACKET    Packet
    )

/*++

Routine Description:

    This is the completion routine for the final data write and the
    final parity write of the write process.  This packet's master packet
    is the original write packet.  This write packet exists because the data
    has to be copied from the original write packet so that parity
    may be correctly computed.

Arguments:

    Packet  - Supplies the update parity packet.

Return Value:

    None.

--*/

{
    PSWP_WRITE_TP       masterPacket;
    PSTRIPE_WP          t;
    KIRQL               irql;
    LONG                count;

    masterPacket = CONTAINING_RECORD(Packet, SWP_WRITE_TP, ParityPacket);
    t = masterPacket->StripeWithParity;

    KeAcquireSpinLock(&masterPacket->SpinLock, &irql);
    count = --masterPacket->RefCount;
    KeReleaseSpinLock(&masterPacket->SpinLock, irql);

    if (!count) {
        t->CompleteWrite(masterPacket);
    }
}

VOID
StripeWpWritePhase30(
    IN OUT  PTRANSFER_PACKET    Packet
    )

/*++

Routine Description:

    This is the completion routine for the final data write and the
    final parity write of the write process.  This packet's master packet
    is the original write packet.  This write packet exists because the data
    has to be copied from the original write packet so that parity
    may be correctly computed.

Arguments:

    Packet  - Supplies the write packet.

Return Value:

    None.

--*/

{
    PSWP_TP         writePacket = (PSWP_TP) Packet;
    PSWP_WRITE_TP   masterPacket = (PSWP_WRITE_TP) writePacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    KIRQL           irql;
    LONG            count;
    BOOLEAN         b;
    PPARITY_TP      parityPacket;

    KeAcquireSpinLock(&masterPacket->SpinLock, &irql);
    count = --masterPacket->RefCount;
    b = (masterPacket->IrpFlags&SL_FT_SEQUENTIAL_WRITE) ? TRUE : FALSE;
    KeReleaseSpinLock(&masterPacket->SpinLock, irql);

    if (count) {
        if (b) {
            parityPacket = &masterPacket->ParityPacket;
            t->_parityIoManager.UpdateParity(parityPacket);
        }
    } else {
        t->CompleteWrite(masterPacket);
    }
}

VOID
StripeWpWriteRecover(
    IN OUT  PTRANSFER_PACKET    MasterPacket
    )

/*++

Routine Description:

    A bad sector on a read before write caused a promote to all members
    in preparation for a recover.

Arguments:

    TransferPacket  - Supplies the master write packet.

Return Value:

    None.

--*/

{
    PSWP_WRITE_TP   masterPacket = (PSWP_WRITE_TP) MasterPacket;
    PSWP_TP         readPacket = &masterPacket->ReadWritePacket;
    PSTRIPE_WP      t = (PSTRIPE_WP) readPacket->StripeWithParity;

    masterPacket->CompletionRoutine = masterPacket->SavedCompletionRoutine;
    readPacket->CompletionRoutine = StripeWpWritePhase2;
    t->Recover(readPacket, FALSE);
}

VOID
StripeWpWritePhase2(
    IN OUT  PTRANSFER_PACKET    ReadPacket
    )

/*++

Routine Description:

    This routine describes phase 3 of the write process.  The region
    that we are about to write has been preread.  If the read was
    successful then queue write and parity requests.  If the read
    was not successful then propogate the error and cleanup.

Arguments:

    TransferPacket  - Supplies the read packet.

Return Value:

    None.

--*/

{
    PSWP_TP             readPacket = (PSWP_TP) ReadPacket;
    PSTRIPE_WP          t = readPacket->StripeWithParity;
    PSWP_WRITE_TP       masterPacket = (PSWP_WRITE_TP) readPacket->MasterPacket;
    PPARITY_TP          parityPacket = &masterPacket->ParityPacket;
    PSWP_TP             writePacket = &masterPacket->ReadWritePacket;
    NTSTATUS            status;
    KIRQL               irql;
    FT_PARTITION_STATE  state;
    BOOLEAN             b;

    status = readPacket->IoStatus.Status;
    if (!NT_SUCCESS(status)) {

        if (!readPacket->OneReadFailed && status != STATUS_VERIFY_REQUIRED) {

            if (FsRtlIsTotalDeviceFailure(status)) {

                // Orphan this unit and then try again with a regenerate.

                KeAcquireSpinLock(&t->_spinLock, &irql);
                b = t->SetMemberState(readPacket->WhichMember, FtMemberOrphaned);
                KeReleaseSpinLock(&t->_spinLock, irql);

                if (b) {
                    t->PropogateStateChanges(NULL, NULL);
                    t->Notify();
                    FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                                FT_ORPHANING, STATUS_SUCCESS, 6);
                    IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL,
                                                  NULL);
                }

                readPacket->OneReadFailed = TRUE;
                masterPacket->CompletionRoutine = StripeWpWritePhase1;
                t->_overlappedIoManager.PromoteToAllMembers(masterPacket);
                return;
            }

            // Bad sector case.

            readPacket->OneReadFailed = TRUE;
            masterPacket->SavedCompletionRoutine = masterPacket->CompletionRoutine;
            masterPacket->CompletionRoutine = StripeWpWriteRecover;
            t->_overlappedIoManager.PromoteToAllMembers(masterPacket);
            return;
        }

        masterPacket->IoStatus = readPacket->IoStatus;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    KeInitializeSpinLock(&masterPacket->SpinLock);
    masterPacket->IoStatus.Status = STATUS_SUCCESS;
    masterPacket->IoStatus.Information = 0;

    writePacket->Mdl = masterPacket->WriteMdl;
    writePacket->CompletionRoutine = StripeWpWritePhase30;
    writePacket->ReadPacket = FALSE;

    parityPacket->Mdl = masterPacket->ReadAndParityMdl;
    parityPacket->CompletionRoutine = StripeWpWritePhase31;

    if (masterPacket->TargetState != FtMemberOrphaned) {

        RtlCopyMemory(MmGetSystemAddressForMdl(writePacket->Mdl),
                      MmGetSystemAddressForMdl(masterPacket->Mdl),
                      writePacket->Length);

        if (parityPacket->TargetVolume) {

            FtpComputeParity(MmGetSystemAddressForMdl(parityPacket->Mdl),
                             MmGetSystemAddressForMdl(writePacket->Mdl),
                             parityPacket->Length);

            masterPacket->RefCount = 2;

            if (!(masterPacket->IrpFlags&SL_FT_SEQUENTIAL_WRITE)) {
                t->_parityIoManager.UpdateParity(parityPacket);
            }

        } else {
            masterPacket->RefCount = 1;
            parityPacket->IoStatus.Status = STATUS_SUCCESS;
            parityPacket->IoStatus.Information = parityPacket->Length;
        }

        TRANSFER(writePacket);

    } else if (parityPacket->TargetVolume) {

        FtpComputeParity(MmGetSystemAddressForMdl(parityPacket->Mdl),
                         MmGetSystemAddressForMdl(masterPacket->Mdl),
                         readPacket->Length);

        masterPacket->RefCount = 1;
        writePacket->IoStatus.Status = STATUS_SUCCESS;
        writePacket->IoStatus.Information = writePacket->Length;

        t->_parityIoManager.UpdateParity(parityPacket);

    } else {

        masterPacket->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        masterPacket->IoStatus.Information = 0;
        masterPacket->CompletionRoutine(masterPacket);
    }
}

VOID
StripeWpWritePhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine describes phase 2 of the write process.  This io
    region has been acquired.  We now send out the read packet and
    wait until it completes.

Arguments:

    TransferPacket  - Supplies the main write packet.

Return Value:

    None.

--*/

{
    PSWP_WRITE_TP   transferPacket = (PSWP_WRITE_TP) TransferPacket;
    PSTRIPE_WP      t = transferPacket->StripeWithParity;
    PSWP_TP         readPacket;
    PPARITY_TP      parityPacket;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    parityPacket = &transferPacket->ParityPacket;
    if (parityPacket->TargetVolume) {
        t->_parityIoManager.StartReadForUpdateParity(
                parityPacket->Offset, parityPacket->Length,
                parityPacket->TargetVolume, parityPacket->Thread,
                parityPacket->IrpFlags);
    }

    readPacket = &transferPacket->ReadWritePacket;
    readPacket->CompletionRoutine = StripeWpWritePhase2;
    if (readPacket->OneReadFailed) {
        t->RegeneratePacket(readPacket, FALSE);
    } else {
        TRANSFER(readPacket);
    }
}

VOID
STRIPE_WP::WritePacket(
    IN OUT  PSWP_WRITE_TP   TransferPacket
    )

/*++

Routine Description:

    This routine takes a packet that is restricted to a single
    stripe region and writes out that data along with the parity.

Arguments:

    TransferPacket  - Supplies the main write packet.

Return Value:

    None.

--*/

{
    USHORT          parityMember;
    KIRQL           irql;
    FT_MEMBER_STATE state, parityState;
    PSWP_TP         readPacket;
    PPARITY_TP      parityPacket;

    parityMember = (USHORT) ((TransferPacket->Offset/_stripeSize)%
                             QueryNumMembers());

    TransferPacket->TargetVolume =
            GetMemberUnprotected(TransferPacket->WhichMember);

    KeAcquireSpinLock(&_spinLock, &irql);
    state = QueryMemberState(TransferPacket->WhichMember);
    parityState = QueryMemberState(parityMember);
    KeReleaseSpinLock(&_spinLock, irql);

    readPacket = &TransferPacket->ReadWritePacket;
    readPacket->Mdl = TransferPacket->ReadAndParityMdl;
    readPacket->Length = TransferPacket->Length;
    readPacket->Offset = TransferPacket->Offset;
    readPacket->TargetVolume = TransferPacket->TargetVolume;
    readPacket->Thread = TransferPacket->Thread;
    readPacket->IrpFlags = TransferPacket->IrpFlags;
    readPacket->ReadPacket = TRUE;
    readPacket->MasterPacket = TransferPacket;
    readPacket->StripeWithParity = this;
    readPacket->WhichMember = TransferPacket->WhichMember;
    readPacket->OneReadFailed = FALSE;

    parityPacket = &TransferPacket->ParityPacket;
    parityPacket->Length = TransferPacket->Length;
    parityPacket->Offset = TransferPacket->Offset;
    if (parityState != FtMemberOrphaned) {
        parityPacket->TargetVolume = GetMemberUnprotected(parityMember);
    } else {
        parityPacket->TargetVolume = NULL;
    }
    parityPacket->Thread = TransferPacket->Thread;
    parityPacket->IrpFlags = TransferPacket->IrpFlags;
    parityPacket->ReadPacket = FALSE;

    TransferPacket->CompletionRoutine = StripeWpWritePhase1;
    TransferPacket->TargetState = state;
    TransferPacket->ParityMember = parityMember;

    if (state == FtMemberHealthy) {
        if (TransferPacket->IrpFlags&SL_FT_SEQUENTIAL_WRITE) {
            _overlappedIoManager.AcquireIoRegion(TransferPacket, TRUE);
        } else {
            _overlappedIoManager.AcquireIoRegion(TransferPacket, FALSE);
        }
    } else {
        readPacket->OneReadFailed = TRUE;
        _overlappedIoManager.AcquireIoRegion(TransferPacket, TRUE);
    }
}

VOID
StripeWpSequentialRegenerateCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a regenerate operation where all of
    the reads are being performed sequentially.

Arguments:

    TransferPacket  - Supplies the completed transfer packet.

Return Value:

    None.

--*/

{
    PSWP_REGENERATE_TP  transferPacket = (PSWP_REGENERATE_TP) TransferPacket;
    PSWP_TP             masterPacket = transferPacket->MasterPacket;
    PSTRIPE_WP          t = masterPacket->StripeWithParity;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    KIRQL               irql;
    ULONG               count;
    PLIST_ENTRY         l;
    PTRANSFER_PACKET    packet;
    USHORT              i, n;
    BOOLEAN             b;
    ULONG               parityMember;

    if (NT_SUCCESS(status)) {

        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus = transferPacket->IoStatus;
        }

    } else {

        if (FsRtlIsTotalDeviceFailure(status) &&
            status != STATUS_VERIFY_REQUIRED) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            b = t->SetMemberState(transferPacket->WhichMember,
                                  FtMemberOrphaned);
            KeReleaseSpinLock(&t->_spinLock, irql);

            if (b) {
                t->PropogateStateChanges(NULL, NULL);
                t->Notify();
                FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                            FT_ORPHANING, STATUS_SUCCESS, 7);
                IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
            }
        }

        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }
    }

    count = (ULONG) (--masterPacket->RefCount);

    if (masterPacket->Mdl) {
        FtpComputeParity(MmGetSystemAddressForMdl(masterPacket->Mdl),
                         MmGetSystemAddressForMdl(transferPacket->Mdl),
                         masterPacket->Length);
    }

    n = t->QueryNumMembers();

    if (count) {
        transferPacket->WhichMember++;
        if (transferPacket->WhichMember == masterPacket->WhichMember) {
            transferPacket->WhichMember++;
        }
        transferPacket->TargetVolume = t->GetMemberUnprotected(
                                       transferPacket->WhichMember);
        TRANSFER(transferPacket);
        return;
    }

    masterPacket->CompletionRoutine(masterPacket);

    KeAcquireSpinLock(&t->_spinLock, &irql);
    if (IsListEmpty(&t->_eRegeneratePacketQueue)) {
        t->_eRegeneratePacketInUse = FALSE;
        packet = NULL;
    } else {
        l = RemoveHeadList(&t->_eRegeneratePacketQueue);
        packet = CONTAINING_RECORD(l, SWP_TP, QueueEntry);
    }
    KeReleaseSpinLock(&t->_spinLock, irql);

    if (packet) {
        packet->CompletionRoutine(packet);
    }
}

VOID
StripeWpSequentialEmergencyCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine after waiting for an emergency
    regenerate buffer.

Arguments:

    TransferPacket  - Supplies the completed transfer packet.

Return Value:

    None.

--*/

{
    PSWP_TP             transferPacket = (PSWP_TP) TransferPacket;
    PSTRIPE_WP          t = transferPacket->StripeWithParity;
    PSWP_REGENERATE_TP  p = t->_eRegeneratePacket;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    p->Length = transferPacket->Length;
    p->Offset = transferPacket->Offset;
    p->CompletionRoutine = StripeWpSequentialRegenerateCompletion;
    p->TargetVolume = t->GetMemberUnprotected(0);
    p->Thread = transferPacket->Thread;
    p->IrpFlags = transferPacket->IrpFlags;
    p->ReadPacket = TRUE;
    p->MasterPacket = transferPacket;
    p->WhichMember = 0;
    if (transferPacket->TargetVolume == p->TargetVolume) {
        p->WhichMember = 1;
        p->TargetVolume = t->GetMemberUnprotected(1);
    }

    TRANSFER(p);
}

VOID
StripeWpParallelRegenerateCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a regenerate operation where all of
    the reads are being performed in parallel.

Arguments:

    TransferPacket  - Supplies the completed transfer packet.

Return Value:

    None.

--*/

{
    PSWP_REGENERATE_TP  transferPacket = (PSWP_REGENERATE_TP) TransferPacket;
    PSWP_TP             masterPacket = transferPacket->MasterPacket;
    PSTRIPE_WP          t = masterPacket->StripeWithParity;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    KIRQL               irql;
    LONG                count;
    PLIST_ENTRY         l, s;
    PTRANSFER_PACKET    packet;
    PVOID               target, source;
    BOOLEAN             b;
    USHORT              i, n;

    if (NT_SUCCESS(status)) {

        KeAcquireSpinLock(&masterPacket->SpinLock, &irql);

        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus = transferPacket->IoStatus;
        }

    } else {

        if (FsRtlIsTotalDeviceFailure(status) &&
            status != STATUS_VERIFY_REQUIRED) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            b = t->SetMemberState(transferPacket->WhichMember,
                                  FtMemberOrphaned);
            KeReleaseSpinLock(&t->_spinLock, irql);

            if (b) {
                t->PropogateStateChanges(NULL, NULL);
                t->Notify();
                FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                            FT_ORPHANING, STATUS_SUCCESS, 8);
                IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
            }
        }

        KeAcquireSpinLock(&masterPacket->SpinLock, &irql);

        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }
    }

    count = --masterPacket->RefCount;

    KeReleaseSpinLock(&masterPacket->SpinLock, irql);

    if (count) {
        return;
    }

    s = &masterPacket->QueueEntry;
    l = RemoveHeadList(s);
    packet = CONTAINING_RECORD(l, SWP_REGENERATE_TP, RegenPacketList);
    if (masterPacket->Mdl) {
        target = MmGetSystemAddressForMdl(masterPacket->Mdl);
        source = MmGetSystemAddressForMdl(packet->Mdl);
        RtlCopyMemory(target, source, masterPacket->Length);
    }
    for (;;) {

        delete packet;

        if (IsListEmpty(s)) {
            break;
        }

        l = RemoveHeadList(s);
        packet = CONTAINING_RECORD(l, SWP_REGENERATE_TP, RegenPacketList);
        if (masterPacket->Mdl) {
            source = MmGetSystemAddressForMdl(packet->Mdl);
            FtpComputeParity(target, source, masterPacket->Length);
        }
    }

    masterPacket->CompletionRoutine(masterPacket);
}

VOID
StripeWpRegeneratePacketPhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is called after the io regions necessary for a regenerate
    have been allocated.  This routine spawns the reads necessary for
    regeneration.

Arguments:

    TransferPacket  - Supplies the main write packet.

Return Value:

    None.

--*/

{
    PSWP_TP             transferPacket = (PSWP_TP) TransferPacket;
    PSTRIPE_WP          t = transferPacket->StripeWithParity;
    USHORT              i, n;
    PSWP_REGENERATE_TP  packet;
    BOOLEAN             sequential;
    PLIST_ENTRY         l, s;
    ULONG               r;
    ULONG               parityMember;
    KIRQL               irql;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    // Determine whether we're going to do this in parallel or
    // sequentially by trying to allocate the memory.

    n = t->QueryNumMembers();
    InitializeListHead(&transferPacket->QueueEntry);
    for (i = 0; i < n; i++) {
        if (i == transferPacket->WhichMember) {
            continue;
        }
        packet = new SWP_REGENERATE_TP;
        if (packet && !packet->AllocateMdl(transferPacket->Length)) {
            delete packet;
            packet = NULL;
        }
        if (!packet) {
            break;
        }
        packet->Length = transferPacket->Length;
        packet->Offset = transferPacket->Offset;
        packet->CompletionRoutine = StripeWpParallelRegenerateCompletion;
        packet->TargetVolume = t->GetMemberUnprotected(i);
        packet->Thread = transferPacket->Thread;
        packet->IrpFlags = transferPacket->IrpFlags;
        packet->ReadPacket = TRUE;
        packet->MasterPacket = transferPacket;
        packet->WhichMember = i;

        InsertTailList(&transferPacket->QueueEntry, &packet->RegenPacketList);
    }
    if (i < n) {
        sequential = TRUE;
        s = &transferPacket->QueueEntry;
        while (!IsListEmpty(s)) {
            l = RemoveHeadList(s);
            packet = CONTAINING_RECORD(l, SWP_REGENERATE_TP, RegenPacketList);
            delete packet;
        }
    } else {
        sequential = FALSE;
    }

    KeInitializeSpinLock(&transferPacket->SpinLock);
    transferPacket->IoStatus.Status = STATUS_SUCCESS;
    transferPacket->IoStatus.Information = 0;
    transferPacket->RefCount = n - 1;

    if (sequential) {

        transferPacket->CompletionRoutine = StripeWpSequentialEmergencyCompletion;

        RtlZeroMemory(MmGetSystemAddressForMdl(transferPacket->Mdl),
                      transferPacket->Length);

        KeAcquireSpinLock(&t->_spinLock, &irql);
        if (t->_eRegeneratePacketInUse) {
            InsertTailList(&t->_eRegeneratePacketQueue, &transferPacket->QueueEntry);
            KeReleaseSpinLock(&t->_spinLock, irql);
            return;
        }
        t->_eRegeneratePacketInUse = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);

        transferPacket->CompletionRoutine(transferPacket);

    } else {

        s = &transferPacket->QueueEntry;
        l = s->Flink;
        for (;;) {
            packet = CONTAINING_RECORD(l, SWP_REGENERATE_TP, RegenPacketList);
            l = l->Flink;
            if (l == s) {
                TRANSFER(packet);
                break;
            }
            TRANSFER(packet);
        }
    }
}

VOID
STRIPE_WP::RegeneratePacket(
    IN OUT  PSWP_TP TransferPacket,
    IN      BOOLEAN AllocateRegion
    )

/*++

Routine Description:

    This routine regenerate the given transfer packet by reading
    from the other drives and performing the xor.  This routine first
    attempts to do all of the read concurently but if the memory is
    not available then the reads are done sequentially.

Arguments:

    TransferPacket  - Supplies the transfer packet to regenerate.

    AllocateRegion  - Supplies whether or not we need to acquire the
                        io region via the overlapped io manager before
                        starting the regenerate operation.  This should
                        usually be set to TRUE unless the region has
                        already been allocated.

Return Value:

    None.

--*/

{
    USHORT              i, n, parityMember;
    KIRQL               irql;
    PFT_VOLUME          vol;
    BOOLEAN             ok;

    TransferPacket->OneReadFailed = TRUE;

    // First make sure that all of the members are healthy.

    n = QueryNumMembers();
    parityMember = (USHORT) ((TransferPacket->Offset/_stripeSize)%n);
    KeAcquireSpinLock(&_spinLock, &irql);
    if (_state.IsInitializing) {
        if (parityMember == TransferPacket->WhichMember) {
            ok = TRUE;
        } else {
            ok = FALSE;
        }
    } else if (_state.UnhealthyMemberState == FtMemberHealthy ||
               _state.UnhealthyMemberNumber == TransferPacket->WhichMember) {

        ok = TRUE;
    } else {
        ok = FALSE;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (!ok) {
        TransferPacket->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    TransferPacket->SavedCompletionRoutine = TransferPacket->CompletionRoutine;
    TransferPacket->CompletionRoutine = StripeWpRegeneratePacketPhase1;

    if (AllocateRegion) {
        _overlappedIoManager.AcquireIoRegion(TransferPacket, TRUE);
    } else {
        TransferPacket->CompletionRoutine(TransferPacket);
    }
}

VOID
StripeWpRecoverPhase8(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector read
    of the main member after a write was done to check for
    data integrity.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;
    PSWP_TP         masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    NTSTATUS        status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status) ||
        RtlCompareMemory(MmGetSystemAddressForMdl(subPacket->PartialMdl),
                         MmGetSystemAddressForMdl(subPacket->VerifyMdl),
                         subPacket->Length) != subPacket->Length) {

        masterPacket->IoStatus.Status = STATUS_FT_READ_RECOVERY_FROM_BACKUP;

        FtpLogError(t->_rootExtension,
                    subPacket->TargetVolume->QueryLogicalDiskId(),
                    FT_SECTOR_FAILURE, status,
                    (ULONG) (subPacket->Offset/t->QuerySectorSize()));
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    subPacket->Offset += subPacket->Length;
    subPacket->CompletionRoutine = StripeWpRecoverPhase2;
    subPacket->ReadPacket = TRUE;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
StripeWpRecoverPhase7(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector write
    of the main member after a replace sector was done.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;
    PSWP_TP         masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    NTSTATUS        status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status)) {

        masterPacket->IoStatus.Status = STATUS_FT_READ_RECOVERY_FROM_BACKUP;

        FtpLogError(t->_rootExtension,
                    subPacket->TargetVolume->QueryLogicalDiskId(),
                    FT_SECTOR_FAILURE, status,
                    (ULONG) (subPacket->Offset/t->QuerySectorSize()));

        if (subPacket->Offset + subPacket->Length ==
            masterPacket->Offset + masterPacket->Length) {

            t->RecycleRecoverTp(subPacket);
            masterPacket->CompletionRoutine(masterPacket);
            return;
        }

        subPacket->Mdl = subPacket->PartialMdl;
        subPacket->Offset += subPacket->Length;
        subPacket->CompletionRoutine = StripeWpRecoverPhase2;
        subPacket->ReadPacket = TRUE;
        MmPrepareMdlForReuse(subPacket->Mdl);
        IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                          (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                          (ULONG) (subPacket->Offset - masterPacket->Offset),
                          subPacket->Length);

        TRANSFER(subPacket);
        return;
    }

    subPacket->Mdl = subPacket->VerifyMdl;
    subPacket->CompletionRoutine = StripeWpRecoverPhase8;
    subPacket->ReadPacket = TRUE;

    TRANSFER(subPacket);
}

VOID
StripeWpRecoverPhase6(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector replace
    of the main member.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;
    PSWP_TP         masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    NTSTATUS        status = subPacket->IoStatus.Status;

    if (!NT_SUCCESS(status)) {

        masterPacket->IoStatus.Status = STATUS_FT_READ_RECOVERY_FROM_BACKUP;

        FtpLogError(t->_rootExtension,
                    subPacket->TargetVolume->QueryLogicalDiskId(),
                    FT_SECTOR_FAILURE, status,
                    (ULONG) (subPacket->Offset/t->QuerySectorSize()));

        if (subPacket->Offset + subPacket->Length ==
            masterPacket->Offset + masterPacket->Length) {

            t->RecycleRecoverTp(subPacket);
            masterPacket->CompletionRoutine(masterPacket);
            return;
        }

        subPacket->Mdl = subPacket->PartialMdl;
        subPacket->Offset += subPacket->Length;
        subPacket->CompletionRoutine = StripeWpRecoverPhase2;
        subPacket->ReadPacket = TRUE;
        MmPrepareMdlForReuse(subPacket->Mdl);
        IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                          (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                          (ULONG) (subPacket->Offset - masterPacket->Offset),
                          subPacket->Length);

        TRANSFER(subPacket);
        return;
    }

    // We were able to relocate the bad sector so now do a write and
    // then read to make sure it's ok.

    subPacket->Mdl = subPacket->PartialMdl;
    subPacket->CompletionRoutine = StripeWpRecoverPhase7;
    subPacket->ReadPacket = FALSE;

    TRANSFER(subPacket);
}

VOID
StripeWpRecoverPhase5(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector read
    of the main member after a successful write to check and
    see if the write was successful.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;
    PSWP_TP         masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    NTSTATUS        status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status) ||
        RtlCompareMemory(MmGetSystemAddressForMdl(subPacket->PartialMdl),
                         MmGetSystemAddressForMdl(subPacket->VerifyMdl),
                         subPacket->Length) != subPacket->Length) {

        subPacket->Mdl = subPacket->PartialMdl;
        subPacket->CompletionRoutine = StripeWpRecoverPhase6;
        subPacket->TargetVolume->ReplaceBadSector(subPacket);
        return;
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    subPacket->Offset += subPacket->Length;
    subPacket->CompletionRoutine = StripeWpRecoverPhase2;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
StripeWpRecoverPhase4(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector write
    of the main member.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;
    PSWP_TP         masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    NTSTATUS        status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status)) {
        subPacket->CompletionRoutine = StripeWpRecoverPhase6;
        subPacket->TargetVolume->ReplaceBadSector(subPacket);
        return;
    }

    // Write was successful so try a read and then compare.

    subPacket->Mdl = subPacket->VerifyMdl;
    subPacket->CompletionRoutine = StripeWpRecoverPhase5;
    subPacket->ReadPacket = TRUE;

    TRANSFER(subPacket);
}

VOID
StripeWpRecoverPhase3(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector read
    of the other member.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;
    PSWP_TP         masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    NTSTATUS        status = subPacket->IoStatus.Status;
    KIRQL           irql;
    BOOLEAN         b;

    if (!NT_SUCCESS(status)) {
        if (status != STATUS_VERIFY_REQUIRED) {
            status = STATUS_DEVICE_DATA_ERROR;
            FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                        FT_DOUBLE_FAILURE, status,
                        (ULONG) (subPacket->Offset/t->QuerySectorSize()));
        }

        masterPacket->IoStatus.Status = status;
        masterPacket->IoStatus.Information = 0;
        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    // We have the data required in the subpacket partial mdl.
    // Try writting it back to where the read failed and see
    // if the sector just fixes itself.

    subPacket->CompletionRoutine = StripeWpRecoverPhase4;
    subPacket->ReadPacket = FALSE;
    TRANSFER(subPacket);
}

VOID
StripeWpRecoverPhase2(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector transfer
    that is part of a larger recover operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;
    PSWP_TP         masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    NTSTATUS        status = subPacket->IoStatus.Status;
    KIRQL           irql;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (NT_SUCCESS(status)) {
        if (subPacket->Offset + subPacket->Length ==
            masterPacket->Offset + masterPacket->Length) {

            t->RecycleRecoverTp(subPacket);
            masterPacket->CompletionRoutine(masterPacket);
            return;
        }

        subPacket->Offset += subPacket->Length;
        MmPrepareMdlForReuse(subPacket->Mdl);
        IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                          (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                          (ULONG) (subPacket->Offset - masterPacket->Offset),
                          subPacket->Length);

        TRANSFER(subPacket);
        return;
    }

    // This read sector failed from a bad sector error.  Try
    // regenerating the data from the other members.

    subPacket->CompletionRoutine = StripeWpRecoverPhase3;
    t->RegeneratePacket(subPacket, FALSE);
}

VOID
StripeWpRecoverEmergencyCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for use of the emergency recover packet
    in a recover operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_TP             transferPacket = (PSWP_TP) TransferPacket;
    PSTRIPE_WP          t = transferPacket->StripeWithParity;
    PSWP_RECOVER_TP     subPacket = t->_eRecoverPacket;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(transferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(transferPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = transferPacket->Offset;
    subPacket->CompletionRoutine = StripeWpRecoverPhase2;
    subPacket->TargetVolume = transferPacket->TargetVolume;
    subPacket->Thread = transferPacket->Thread;
    subPacket->IrpFlags = transferPacket->IrpFlags;
    subPacket->ReadPacket = TRUE;
    subPacket->MasterPacket = transferPacket;
    subPacket->StripeWithParity = t;
    subPacket->WhichMember = transferPacket->WhichMember;

    TRANSFER(subPacket);
}

VOID
StripeWpRecoverPhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for an acquire io region
    to a recover operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_TP             transferPacket = (PSWP_TP) TransferPacket;
    PSTRIPE_WP          t = transferPacket->StripeWithParity;
    PSWP_RECOVER_TP     subPacket;
    KIRQL               irql;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;
    transferPacket->IoStatus.Status = STATUS_SUCCESS;
    transferPacket->IoStatus.Information = transferPacket->Length;

    subPacket = new SWP_RECOVER_TP;
    if (subPacket && !subPacket->AllocateMdls(t->QuerySectorSize())) {
        delete subPacket;
        subPacket = NULL;
    }
    if (!subPacket) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        if (t->_eRecoverPacketInUse) {
            transferPacket->SavedCompletionRoutine =
                    transferPacket->CompletionRoutine;
            transferPacket->CompletionRoutine = StripeWpRecoverEmergencyCompletion;
            InsertTailList(&t->_eRecoverPacketQueue, &transferPacket->QueueEntry);
            KeReleaseSpinLock(&t->_spinLock, irql);
            return;
        }
        t->_eRecoverPacketInUse = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);

        subPacket = t->_eRecoverPacket;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(transferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(transferPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = transferPacket->Offset;
    subPacket->CompletionRoutine = StripeWpRecoverPhase2;
    subPacket->TargetVolume = transferPacket->TargetVolume;
    subPacket->Thread = transferPacket->Thread;
    subPacket->IrpFlags = transferPacket->IrpFlags;
    subPacket->ReadPacket = TRUE;
    subPacket->MasterPacket = transferPacket;
    subPacket->StripeWithParity = t;
    subPacket->WhichMember = transferPacket->WhichMember;

    TRANSFER(subPacket);
}

VOID
STRIPE_WP::Recover(
    IN OUT  PSWP_TP TransferPacket,
    IN      BOOLEAN NeedAcquire
    )

{
    ASSERT(TransferPacket->ReadPacket);
    TransferPacket->SavedCompletionRoutine = TransferPacket->CompletionRoutine;
    TransferPacket->CompletionRoutine = StripeWpRecoverPhase1;

    if (NeedAcquire) {
        _overlappedIoManager.AcquireIoRegion(TransferPacket, TRUE);
    } else {
        TransferPacket->CompletionRoutine(TransferPacket);
    }
}

VOID
StripeWpMaxTransferCompletionRoutine(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a sector transfer subordinate
    to a MAX transfer operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;
    PSWP_TP         masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    NTSTATUS        status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Offset += subPacket->Length;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    if (subPacket->ReadPacket) {
        t->RegeneratePacket(subPacket, FALSE);
    } else {
        TRANSFER(subPacket);
    }
}

VOID
StripeWpMaxTransferEmergencyCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for use of the emergency recover packet
    in a max transfer operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_TP         transferPacket = (PSWP_TP) TransferPacket;
    PSTRIPE_WP      t = transferPacket->StripeWithParity;
    PSWP_RECOVER_TP subPacket = t->_eRecoverPacket;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(transferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(transferPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = transferPacket->Offset;
    subPacket->CompletionRoutine = StripeWpMaxTransferCompletionRoutine;
    subPacket->TargetVolume = transferPacket->TargetVolume;
    subPacket->Thread = transferPacket->Thread;
    subPacket->IrpFlags = transferPacket->IrpFlags;
    subPacket->ReadPacket = transferPacket->ReadPacket;
    subPacket->MasterPacket = transferPacket;
    subPacket->StripeWithParity = t;
    subPacket->WhichMember = transferPacket->WhichMember;

    if (subPacket->ReadPacket) {
        t->RegeneratePacket(subPacket, FALSE);
    } else {
        TRANSFER(subPacket);
    }
}

VOID
STRIPE_WP::MaxTransfer(
    IN OUT  PSWP_TP TransferPacket
    )

/*++

Routine Description:

    This routine transfers the maximum possible subset of the given transfer
    by doing it one sector at a time.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket;
    KIRQL           irql;

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;

    subPacket = new SWP_RECOVER_TP;
    if (subPacket && !subPacket->AllocateMdls(QuerySectorSize())) {
        delete subPacket;
        subPacket = NULL;
    }
    if (!subPacket) {
        KeAcquireSpinLock(&_spinLock, &irql);
        if (_eRecoverPacketInUse) {
            TransferPacket->SavedCompletionRoutine =
                    TransferPacket->CompletionRoutine;
            TransferPacket->CompletionRoutine = StripeWpMaxTransferEmergencyCompletion;
            InsertTailList(&_eRecoverPacketQueue, &TransferPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _eRecoverPacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        subPacket = _eRecoverPacket;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(TransferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl),
                      QuerySectorSize());

    subPacket->Length = QuerySectorSize();
    subPacket->Offset = TransferPacket->Offset;
    subPacket->CompletionRoutine = StripeWpMaxTransferCompletionRoutine;
    subPacket->TargetVolume = TransferPacket->TargetVolume;
    subPacket->Thread = TransferPacket->Thread;
    subPacket->IrpFlags = TransferPacket->IrpFlags;
    subPacket->ReadPacket = TransferPacket->ReadPacket;
    subPacket->MasterPacket = TransferPacket;
    subPacket->StripeWithParity = this;
    subPacket->WhichMember = TransferPacket->WhichMember;

    if (subPacket->ReadPacket) {
        RegeneratePacket(subPacket, FALSE);
    } else {
        TRANSFER(subPacket);
    }
}

VOID
STRIPE_WP::RecycleRecoverTp(
    IN OUT  PSWP_RECOVER_TP TransferPacket
    )

/*++

Routine Description:

    This routine recycles the given recover transfer packet and services
    the emergency queue if need be.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    KIRQL               irql;
    PLIST_ENTRY         l;
    PTRANSFER_PACKET    p;

    if (TransferPacket != _eRecoverPacket) {
        delete TransferPacket;
        return;
    }

    MmPrepareMdlForReuse(_eRecoverPacket->PartialMdl);
    KeAcquireSpinLock(&_spinLock, &irql);
    if (IsListEmpty(&_eRecoverPacketQueue)) {
        _eRecoverPacketInUse = FALSE;
        KeReleaseSpinLock(&_spinLock, irql);
        return;
    }
    l = RemoveHeadList(&_eRecoverPacketQueue);
    KeReleaseSpinLock(&_spinLock, irql);
    p = CONTAINING_RECORD(l, TRANSFER_PACKET, QueueEntry);
    p->CompletionRoutine(p);
    return;
}

class FTP_SWP_STATE_WORK_ITEM : public WORK_QUEUE_ITEM {

    public:

        FT_COMPLETION_ROUTINE   CompletionRoutine;
        PVOID                   Context;
        PSTRIPE_WP              StripeWp;

};

typedef FTP_SWP_STATE_WORK_ITEM* PFTP_SWP_STATE_WORK_ITEM;

VOID
StripeWpPropogateStateChangesWorker(
    IN  PVOID   Context
    )

/*++

Routine Description:

    This routine is a worker thread routine for propogating state changes.

Arguments:

    Context  - Supplies the context of the worker item

Return Value:

    None.

--*/

{
    PFTP_SWP_STATE_WORK_ITEM            context = (PFTP_SWP_STATE_WORK_ITEM) Context;
    PSTRIPE_WP                          t = context->StripeWp;
    KIRQL                               irql;
    FT_MIRROR_AND_SWP_STATE_INFORMATION state;
    NTSTATUS                            status;

    FtpAcquire(t->_rootExtension);

    KeAcquireSpinLock(&t->_spinLock, &irql);
    RtlCopyMemory(&state, &t->_state, sizeof(state));
    KeReleaseSpinLock(&t->_spinLock, irql);

    status = t->_diskInfoSet->WriteStateInformation(t->QueryLogicalDiskId(),
                                                    &state, sizeof(state));

    FtpRelease(t->_rootExtension);

    if (context->CompletionRoutine) {
        context->CompletionRoutine(context->Context, status);
    }
}

VOID
STRIPE_WP::PropogateStateChanges(
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine propogates the changes in the local memory state to
    the on disk state.

Arguments:

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    None.

--*/

{
    PFTP_SWP_STATE_WORK_ITEM    workItem;

    workItem = (PFTP_SWP_STATE_WORK_ITEM)
               ExAllocatePool(NonPagedPool,
                              sizeof(FTP_SWP_STATE_WORK_ITEM));
    if (!workItem) {
        return;
    }
    ExInitializeWorkItem(workItem, StripeWpPropogateStateChangesWorker,
                         workItem);

    workItem->CompletionRoutine = CompletionRoutine;
    workItem->Context = Context;
    workItem->StripeWp = this;

    FtpQueueWorkItem(_rootExtension, workItem);
}

VOID
StripeWpCompleteWritePhase4(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for a careful update of the parity block.

Arguments:

    TransferPacket  - Supplies the parity packet.

Return Value:

    None.

--*/

{
    PSWP_TP         transferPacket = (PSWP_TP) TransferPacket;
    PSWP_WRITE_TP   masterPacket = (PSWP_WRITE_TP) transferPacket->MasterPacket;
    NTSTATUS        status = transferPacket->IoStatus.Status;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    KIRQL           irql;
    BOOLEAN         b;

    if (NT_SUCCESS(status)) {
        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus = transferPacket->IoStatus;
        }
    } else if (status == STATUS_VERIFY_REQUIRED) {

        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }

    } else if (FsRtlIsTotalDeviceFailure(status)) {

        KeAcquireSpinLock(&t->_spinLock, &irql);
        b = t->SetMemberState(masterPacket->ParityMember, FtMemberOrphaned);
        KeReleaseSpinLock(&t->_spinLock, irql);

        if (b) {
            t->PropogateStateChanges(NULL, NULL);
            t->Notify();
            FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                        FT_ORPHANING, STATUS_SUCCESS, 9);
            IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
        }

    } else {

        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }
    }

    masterPacket->CompletionRoutine(masterPacket);
}

VOID
StripeWpCompleteWritePhase3(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for a recover of the parity block.

Arguments:

    TransferPacket  - Supplies the recover packet.

Return Value:

    None.

--*/

{
    PSWP_TP         recoverPacket = (PSWP_TP) TransferPacket;
    PSWP_WRITE_TP   masterPacket = (PSWP_WRITE_TP) recoverPacket->MasterPacket;
    NTSTATUS        status = recoverPacket->IoStatus.Status;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    KIRQL           irql;
    BOOLEAN         b;

    if (status == STATUS_VERIFY_REQUIRED) {
        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }

        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (FsRtlIsTotalDeviceFailure(status)) {

        KeAcquireSpinLock(&t->_spinLock, &irql);
        b = t->SetMemberState(recoverPacket->WhichMember, FtMemberOrphaned);
        KeReleaseSpinLock(&t->_spinLock, irql);

        if (b) {
            t->PropogateStateChanges(NULL, NULL);
            t->Notify();
            FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                        FT_ORPHANING, STATUS_SUCCESS, 10);
            IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
        }

        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    recoverPacket->CompletionRoutine = StripeWpCompleteWritePhase4;
    t->CarefulUpdate(recoverPacket);
}

VOID
StripeWpCompleteWritePhase2(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for the careful write.

Arguments:

    TransferPacket  - Supplies the write packet.

Return Value:

    None.

--*/

{
    PSWP_TP         writePacket = (PSWP_TP) TransferPacket;
    PSWP_WRITE_TP   masterPacket = (PSWP_WRITE_TP) writePacket->MasterPacket;
    NTSTATUS        status = writePacket->IoStatus.Status;
    PPARITY_TP      parityPacket = &masterPacket->ParityPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;

    if (NT_SUCCESS(status)) {
        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus = writePacket->IoStatus;
        }
    } else {
        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }
    }

    if (!NT_SUCCESS(parityPacket->IoStatus.Status)) {
        writePacket->Mdl = parityPacket->Mdl;
        writePacket->CompletionRoutine = StripeWpCompleteWritePhase3;
        writePacket->TargetVolume = parityPacket->TargetVolume;
        writePacket->ReadPacket = TRUE;
        writePacket->WhichMember = masterPacket->ParityMember;
        t->Recover(writePacket, FALSE);
        return;
    }

    masterPacket->CompletionRoutine(masterPacket);
}

VOID
StripeWpCompleteWritePhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the first phase after a bad sector error during the write
    or update parity phase of a SWP write operation.

Arguments:

    TransferPacket  - Supplies the main write packet.

Return Value:

    None.

--*/

{
    PSWP_WRITE_TP   transferPacket = (PSWP_WRITE_TP) TransferPacket;
    PSWP_TP         writePacket = &transferPacket->ReadWritePacket;
    PPARITY_TP      parityPacket = &transferPacket->ParityPacket;
    PSTRIPE_WP      t = transferPacket->StripeWithParity;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    if (!NT_SUCCESS(writePacket->IoStatus.Status)) {
        writePacket->CompletionRoutine = StripeWpCompleteWritePhase2;
        t->CarefulWrite(writePacket);
        return;
    }

    ASSERT(!NT_SUCCESS(parityPacket->IoStatus.Status));

    writePacket->Mdl = parityPacket->Mdl;
    writePacket->CompletionRoutine = StripeWpCompleteWritePhase3;
    writePacket->TargetVolume = parityPacket->TargetVolume;
    writePacket->ReadPacket = TRUE;
    writePacket->WhichMember = transferPacket->ParityMember;
    t->Recover(writePacket, FALSE);
}

VOID
STRIPE_WP::CompleteWrite(
    IN OUT  PSWP_WRITE_TP   TransferPacket
    )

/*++

Routine Description:

    This routine completes the given write master packets after verifying
    the status of the block write and the parity update.

Arguments:

    TransferPacket  - Supplies a write master packet.

Return Value:

    None.

--*/

{
    PSWP_TP     writePacket = &TransferPacket->ReadWritePacket;
    PPARITY_TP  parityPacket = &TransferPacket->ParityPacket;
    BOOLEAN     doCarefulWrite = FALSE;
    BOOLEAN     doRecover = FALSE;
    NTSTATUS    status;
    KIRQL       irql;
    BOOLEAN     b;


    // Check on the write status.

    status = writePacket->IoStatus.Status;
    if (NT_SUCCESS(status)) {

        if (NT_SUCCESS(TransferPacket->IoStatus.Status)) {
            TransferPacket->IoStatus = writePacket->IoStatus;
        }

    } else if (status == STATUS_VERIFY_REQUIRED) {

        if (FtpIsWorseStatus(status, TransferPacket->IoStatus.Status)) {
            TransferPacket->IoStatus.Status = status;
            TransferPacket->IoStatus.Information = 0;
        }

    } else if (FsRtlIsTotalDeviceFailure(status)) {

        KeAcquireSpinLock(&_spinLock, &irql);
        b = SetMemberState(writePacket->WhichMember, FtMemberOrphaned);
        KeReleaseSpinLock(&_spinLock, irql);

        if (b) {
            PropogateStateChanges(NULL, NULL);
            Notify();
            FtpLogError(_rootExtension, QueryLogicalDiskId(), FT_ORPHANING,
                        STATUS_SUCCESS, 11);
            IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
        }

    } else {
        doCarefulWrite = TRUE;
    }


    // Check on the update parity status.

    status = parityPacket->IoStatus.Status;
    if (NT_SUCCESS(status)) {

        if (NT_SUCCESS(TransferPacket->IoStatus.Status)) {
            TransferPacket->IoStatus = parityPacket->IoStatus;
        }

    } else if (status == STATUS_VERIFY_REQUIRED) {

        if (FtpIsWorseStatus(status, TransferPacket->IoStatus.Status)) {
            TransferPacket->IoStatus.Status = status;
            TransferPacket->IoStatus.Information = 0;
        }

    } else if (FsRtlIsTotalDeviceFailure(status)) {

        KeAcquireSpinLock(&_spinLock, &irql);
        b = SetMemberState(TransferPacket->ParityMember, FtMemberOrphaned);
        KeReleaseSpinLock(&_spinLock, irql);

        if (b) {
            PropogateStateChanges(NULL, NULL);
            Notify();
            FtpLogError(_rootExtension, QueryLogicalDiskId(), FT_ORPHANING,
                        STATUS_SUCCESS, 12);
            IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
        }

    } else {

        // Bad sector case.

        if (parityPacket->ReadPacket) { // Bad sector on read?
            doRecover = TRUE;
        } else {
            if (FtpIsWorseStatus(status, TransferPacket->IoStatus.Status)) {
                TransferPacket->IoStatus.Status = status;
                TransferPacket->IoStatus.Information = 0;
            }
        }
    }


    // Complete the request if no bad sector handling is required.

    if (!doCarefulWrite && !doRecover) {
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }


    // Handling for bad sectors is required.

    if (!doCarefulWrite) {
        writePacket->IoStatus.Status = STATUS_SUCCESS;
    }

    if (!doRecover) {
        parityPacket->IoStatus.Status = STATUS_SUCCESS;
    }

    TransferPacket->SavedCompletionRoutine = TransferPacket->CompletionRoutine;
    TransferPacket->CompletionRoutine = StripeWpCompleteWritePhase1;
    _overlappedIoManager.PromoteToAllMembers(TransferPacket);
}

VOID
StripeWpCarefulWritePhase2(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a sector replacement
    for a careful write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;

    subPacket->CompletionRoutine = StripeWpCarefulWritePhase1;
    TRANSFER(subPacket);
}

VOID
StripeWpCarefulWritePhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a first attempt of a single sector write
    for a careful write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP     subPacket = (PSWP_RECOVER_TP) TransferPacket;
    NTSTATUS            status = subPacket->IoStatus.Status;
    PSWP_TP             masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP          t = subPacket->StripeWithParity;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        masterPacket->CompletionRoutine(masterPacket);
        t->RecycleRecoverTp(subPacket);
        return;
    }

    if (!NT_SUCCESS(status)) {
        if (!subPacket->OneReadFailed) {
            subPacket->CompletionRoutine = StripeWpCarefulWritePhase2;
            subPacket->OneReadFailed = TRUE;
            subPacket->TargetVolume->ReplaceBadSector(subPacket);
            return;
        }

        masterPacket->IoStatus = subPacket->IoStatus;
    }

    if (masterPacket->Offset + masterPacket->Length ==
        subPacket->Offset + subPacket->Length) {

        masterPacket->CompletionRoutine(masterPacket);
        t->RecycleRecoverTp(subPacket);
        return;
    }

    subPacket->Offset += subPacket->Length;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);
    subPacket->OneReadFailed = FALSE;

    TRANSFER(subPacket);
}

VOID
StripeWpCarefulWriteEmergencyCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for use of the emergency recover packet
    in a careful write operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_TP             transferPacket = (PSWP_TP) TransferPacket;
    PSTRIPE_WP          t = transferPacket->StripeWithParity;
    PSWP_RECOVER_TP     subPacket = t->_eRecoverPacket;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(transferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(transferPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = transferPacket->Offset;
    subPacket->CompletionRoutine = StripeWpCarefulWritePhase1;
    subPacket->TargetVolume = transferPacket->TargetVolume;
    subPacket->Thread = transferPacket->Thread;
    subPacket->IrpFlags = transferPacket->IrpFlags;
    subPacket->ReadPacket = FALSE;
    subPacket->MasterPacket = transferPacket;
    subPacket->StripeWithParity = t;
    subPacket->WhichMember = transferPacket->WhichMember;
    subPacket->OneReadFailed = FALSE;

    TRANSFER(subPacket);
}

VOID
STRIPE_WP::CarefulWrite(
    IN OUT  PSWP_TP TransferPacket
    )

/*++

Routine Description:

    This routine writes the given transfer packet one sector at a time.

Arguments:

    TransferPacket  - Supplies a write packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket;
    KIRQL           irql;

    ASSERT(!TransferPacket->ReadPacket);

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;

    subPacket = new SWP_RECOVER_TP;
    if (subPacket && !subPacket->AllocateMdls(QuerySectorSize())) {
        delete subPacket;
        subPacket = NULL;
    }
    if (!subPacket) {
        KeAcquireSpinLock(&_spinLock, &irql);
        if (_eRecoverPacketInUse) {
            TransferPacket->SavedCompletionRoutine =
                    TransferPacket->CompletionRoutine;
            TransferPacket->CompletionRoutine = StripeWpCarefulWriteEmergencyCompletion;
            InsertTailList(&_eRecoverPacketQueue, &TransferPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _eRecoverPacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        subPacket = _eRecoverPacket;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(TransferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl),
                      QuerySectorSize());

    subPacket->Length = QuerySectorSize();
    subPacket->Offset = TransferPacket->Offset;
    subPacket->CompletionRoutine = StripeWpCarefulWritePhase1;
    subPacket->TargetVolume = TransferPacket->TargetVolume;
    subPacket->Thread = TransferPacket->Thread;
    subPacket->IrpFlags = TransferPacket->IrpFlags;
    subPacket->ReadPacket = FALSE;
    subPacket->MasterPacket = TransferPacket;
    subPacket->StripeWithParity = this;
    subPacket->WhichMember = TransferPacket->WhichMember;
    subPacket->OneReadFailed = FALSE;

    TRANSFER(subPacket);
}

VOID
StripeWpCarefulUpdateCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a single sector update parity
    for a careful update operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PPARITY_TP      subPacket = (PPARITY_TP) TransferPacket;
    NTSTATUS        status = subPacket->IoStatus.Status;
    PSWP_RECOVER_TP rPacket;
    PSWP_TP         masterPacket;
    PSTRIPE_WP      t;

    rPacket = CONTAINING_RECORD(subPacket, SWP_RECOVER_TP, ParityPacket);
    masterPacket = (PSWP_TP) rPacket->MasterPacket;
    t = masterPacket->StripeWithParity;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        masterPacket->CompletionRoutine(masterPacket);
        t->RecycleRecoverTp(rPacket);
        return;
    }

    if (!NT_SUCCESS(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
    }

    if (masterPacket->Offset + masterPacket->Length ==
        subPacket->Offset + subPacket->Length) {

        masterPacket->CompletionRoutine(masterPacket);
        t->RecycleRecoverTp(rPacket);
        return;
    }

    subPacket->Offset += subPacket->Length;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    t->_parityIoManager.UpdateParity(subPacket);
}

VOID
StripeWpCarefulUpdateEmergencyCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for use of the emergency recover packet
    in a careful udpate operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_TP         parityPacket = (PSWP_TP) TransferPacket;
    PSTRIPE_WP      t = parityPacket->StripeWithParity;
    PSWP_RECOVER_TP rPacket = t->_eRecoverPacket;
    PPARITY_TP      subPacket = &rPacket->ParityPacket;

    parityPacket->CompletionRoutine = parityPacket->SavedCompletionRoutine;

    rPacket->MasterPacket = parityPacket;
    rPacket->StripeWithParity = t;
    rPacket->WhichMember = parityPacket->WhichMember;

    subPacket = &rPacket->ParityPacket;

    subPacket->Mdl = rPacket->PartialMdl;
    IoBuildPartialMdl(parityPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(parityPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = parityPacket->Offset;
    subPacket->CompletionRoutine = StripeWpCarefulUpdateCompletion;
    subPacket->TargetVolume = parityPacket->TargetVolume;
    subPacket->Thread = parityPacket->Thread;
    subPacket->IrpFlags = parityPacket->IrpFlags;
    subPacket->ReadPacket = FALSE;

    t->_parityIoManager.UpdateParity(subPacket);
}

VOID
STRIPE_WP::CarefulUpdate(
    IN OUT  PSWP_TP ParityPacket
    )

/*++

Routine Description:

    This routine updates the given parity block one sector at a time.

Arguments:

    ParityPacket    - Supplies an update parity packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP rPacket;
    KIRQL           irql;
    PPARITY_TP      subPacket;

    ParityPacket->IoStatus.Status = STATUS_SUCCESS;
    ParityPacket->IoStatus.Information = ParityPacket->Length;

    rPacket = new SWP_RECOVER_TP;
    if (rPacket && !rPacket->AllocateMdls(QuerySectorSize())) {
        delete rPacket;
        rPacket = NULL;
    }
    if (!rPacket) {
        KeAcquireSpinLock(&_spinLock, &irql);
        if (_eRecoverPacketInUse) {
            ParityPacket->SavedCompletionRoutine =
                    ParityPacket->CompletionRoutine;
            ParityPacket->CompletionRoutine =
                    StripeWpCarefulUpdateEmergencyCompletion;
            InsertTailList(&_eRecoverPacketQueue, &ParityPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _eRecoverPacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        rPacket = _eRecoverPacket;
    }

    rPacket->MasterPacket = ParityPacket;
    rPacket->StripeWithParity = this;
    rPacket->WhichMember = ParityPacket->WhichMember;

    subPacket = &rPacket->ParityPacket;

    subPacket->Mdl = rPacket->PartialMdl;
    IoBuildPartialMdl(ParityPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(ParityPacket->Mdl),
                      QuerySectorSize());

    subPacket->Length = QuerySectorSize();
    subPacket->Offset = ParityPacket->Offset;
    subPacket->CompletionRoutine = StripeWpCarefulUpdateCompletion;
    subPacket->TargetVolume = ParityPacket->TargetVolume;
    subPacket->Thread = ParityPacket->Thread;
    subPacket->IrpFlags = ParityPacket->IrpFlags;
    subPacket->ReadPacket = FALSE;

    _parityIoManager.UpdateParity(subPacket);
}

VOID
STRIPE_WP::ModifyStateForUser(
    IN OUT  PVOID   State
    )

/*++

Routine Description:

    This routine modifies the state for the user to see, possibly adding
    non-persistant state different than what is stored on disk.

Arguments:

    State   - Supplies and returns the state for the logical disk.

Return Value:

    None.

--*/

{
    KIRQL                                   irql;
    BOOLEAN                                 isDirty;
    PFT_MIRROR_AND_SWP_STATE_INFORMATION    state;

    KeAcquireSpinLock(&_spinLock, &irql);
    if (_syncOk && !_stopSyncs) {
        isDirty = FALSE;
    } else {
        isDirty = TRUE;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (!isDirty) {
        return;
    }

    state = (PFT_MIRROR_AND_SWP_STATE_INFORMATION) State;
    if (state->UnhealthyMemberState == FtMemberHealthy) {
        state->IsInitializing = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\newft\volset.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    volset.cxx

Abstract:

    This module contains the code specific to volume sets for the fault
    tolerance driver.

Author:

    Bob Rinne   (bobri)  2-Feb-1992
    Mike Glass  (mglass)
    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
VOLUME_SET::Initialize(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN OUT  PFT_VOLUME*         VolumeArray,
    IN      USHORT              ArraySize,
    IN      PVOID               ConfigInfo,
    IN      PVOID               StateInfo
    )

/*++

Routine Description:

    Initialize routine for FT_VOLUME of type VOLUME SET.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id for this volume.

    VolumeArray     - Supplies the array of volumes for this volume set.

    ArraySize       - Supplies the number of volumes in the volume array.

    ConfigInfo      - Supplies the configuration information.

    StateInfo       - Supplies the state information.

Return Value:

    NTSTATUS

--*/

{
    BOOLEAN     oneGood;
    USHORT      i;
    NTSTATUS    status;

    oneGood = FALSE;
    for (i = 0; i < ArraySize; i++) {
        if (VolumeArray[i]) {
            oneGood = TRUE;
        }
    }

    if (!oneGood) {
        return STATUS_INVALID_PARAMETER;
    }

    status = COMPOSITE_FT_VOLUME::Initialize(RootExtension, LogicalDiskId,
                                             VolumeArray, ArraySize,
                                             ConfigInfo, StateInfo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    _volumeSize = 0;
    for (i = 0; i < ArraySize; i++) {
        if (VolumeArray[i]) {
            _volumeSize += VolumeArray[i]->QueryVolumeSize();
        }
    }

    _ePacket = new VOLSET_TP;
    if (_ePacket && !_ePacket->AllocateMdl((PVOID) 1, STRIPE_SIZE)) {
        delete _ePacket;
        _ePacket = NULL;
    }
    if (!_ePacket) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _ePacketInUse = FALSE;
    InitializeListHead(&_ePacketQueue);

    return status;
}

FT_LOGICAL_DISK_TYPE
VOLUME_SET::QueryLogicalDiskType(
    )

/*++

Routine Description:

    This routine returns the type of the logical disk.

Arguments:

    None.

Return Value:

    The type of the logical disk.

--*/

{
    return FtVolumeSet;
}

NTSTATUS
VOLUME_SET::CheckIo(
    OUT PBOOLEAN    IsIoOk
    )

/*++

Routine Description:

    This routine returns whether or not IO is possible on the given
    logical disk.

Arguments:

    IsIoOk  - Returns the state of IO.

Return Value:

    NTSTATUS

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;
    NTSTATUS    status;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMemberUnprotected(i);
        if (!vol) {
            *IsIoOk = FALSE;
            return STATUS_SUCCESS;
        }
        status = vol->CheckIo(IsIoOk);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (!(*IsIoOk)) {
            return STATUS_SUCCESS;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VOLUME_SET::QueryPhysicalOffsets(
    IN  LONGLONG                    LogicalOffset,
    OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
    OUT PULONG                      NumberOfPhysicalOffsets
    )
/*++

Routine Description:

    This routine returns physical disk and offset for a given volume
    logical offset.

Arguments:

    LogicalOffset           - Supplies the logical offset

    PhysicalOffsets         - Returns the physical offsets

    NumberOfPhysicalOffsets - Returns the number of physical offsets

Return Value:

    NTSTATUS

--*/
{
    USHORT      n, i;
    PFT_VOLUME  vol;
    LONGLONG    logicalOffsetInMember = LogicalOffset, volumeSize;
    
    if (LogicalOffset < 0) {
        return STATUS_INVALID_PARAMETER;
    }

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            return STATUS_INVALID_PARAMETER;
        }
        volumeSize = vol->QueryVolumeSize();
        if (logicalOffsetInMember < volumeSize) {
            return vol->QueryPhysicalOffsets(logicalOffsetInMember, PhysicalOffsets, NumberOfPhysicalOffsets);
        }
        logicalOffsetInMember -= volumeSize;
    }

    return STATUS_INVALID_PARAMETER;
}

NTSTATUS
VOLUME_SET::QueryLogicalOffset(
    IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
    OUT PLONGLONG               LogicalOffset
    )
/*++

Routine Description:

    This routine returns the volume logical offset for a given disk number
    and physical offset.

Arguments:

    PhysicalOffset          - Supplies the physical offset

    LogicalOffset           - Returns the logical offset

Return Value:

    NTSTATUS

--*/
{    
    USHORT      n, i;
    PFT_VOLUME  vol;
    LONGLONG    memberStartOffset = 0, logicalOffsetInMember;
    NTSTATUS    status;
    
    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            return STATUS_INVALID_PARAMETER;
        }
        
        status = vol->QueryLogicalOffset(PhysicalOffset, &logicalOffsetInMember);        
        if (NT_SUCCESS(status)) {
            *LogicalOffset = memberStartOffset + logicalOffsetInMember;
            return status;            
        }
        
        memberStartOffset += vol->QueryVolumeSize();
    }

    return STATUS_INVALID_PARAMETER;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

VOLUME_SET::~VOLUME_SET(
    )

{
    if (_ePacket) {
        delete _ePacket;
        _ePacket = NULL;
    }
}

VOID
VOLUME_SET::Transfer(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Transfer routine for STRIPE type FT_VOLUME.  Figure out
    which volumes this request needs to be dispatched to.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    KIRQL       irql;

    if (TransferPacket->Offset + TransferPacket->Length > _volumeSize) {
        TransferPacket->IoStatus.Status = STATUS_INVALID_PARAMETER;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    if (!LaunchParallel(TransferPacket)) {
        if (!TransferPacket->Mdl) {
            TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }

        KeAcquireSpinLock(&_spinLock, &irql);
        if (_ePacketInUse) {
            InsertTailList(&_ePacketQueue, &TransferPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _ePacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        LaunchSequential(TransferPacket);
    }
}

VOID
VolsetReplaceCompletionRoutine(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a replace request.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PVOLSET_TP          transferPacket = (PVOLSET_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;

    masterPacket->IoStatus = transferPacket->IoStatus;
    delete transferPacket;
    masterPacket->CompletionRoutine(masterPacket);
}

VOID
VOLUME_SET::ReplaceBadSector(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine attempts to fix the given bad sector by routing
    the request to the appropriate sub-volume.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    LONGLONG    offset = TransferPacket->Offset;
    USHORT      n, i;
    PVOLSET_TP  p;
    LONGLONG    volumeSize;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        volumeSize = GetMemberUnprotected(i)->QueryVolumeSize();
        if (offset < volumeSize) {
            break;
        }
        offset -= volumeSize;
    }

    p = new VOLSET_TP;
    if (!p) {
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    p->Length = TransferPacket->Length;
    p->Offset = offset;
    p->CompletionRoutine = VolsetReplaceCompletionRoutine;
    p->TargetVolume = GetMemberUnprotected(i);
    p->Thread = TransferPacket->Thread;
    p->IrpFlags = TransferPacket->IrpFlags;
    p->MasterPacket = TransferPacket;
    p->VolumeSet = this;
    p->WhichMember = i;

    p->TargetVolume->ReplaceBadSector(p);
}

LONGLONG
VOLUME_SET::QueryVolumeSize(
    )

/*++

Routine Description:

    Returns the number of bytes on the entire volume.

Arguments:

    None.

Return Value:

    The volume size in bytes.

--*/

{
    return _volumeSize;
}

VOID
VOLUME_SET::CompleteNotification(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine is called to notify the volume that it is complete and
    to therefore prepare for incoming requests.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    COMPOSITE_FT_VOLUME::CompleteNotification(IoPending);

    _volumeSize = 0;
    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        _volumeSize += vol->QueryVolumeSize();
    }
}

VOID
VolsetTransferParallelCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for VOLUME_SET::Transfer function.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PVOLSET_TP          transferPacket = (PVOLSET_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    KIRQL               irql;

    if (!NT_SUCCESS(status)) {
        KeAcquireSpinLock(&masterPacket->SpinLock, &irql);
        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
        }
        KeReleaseSpinLock(&masterPacket->SpinLock, irql);
    }

    delete transferPacket;

    if (!InterlockedDecrement(&masterPacket->RefCount)) {
        masterPacket->CompletionRoutine(masterPacket);
    }
}

BOOLEAN
VOLUME_SET::LaunchParallel(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine lauches the given transfer packet in parallel accross
    all members.  If memory cannot be allocated to launch this request
    in parallel then a return value of FALSE will be returned.

Arguments:

    TransferPacket  - Supplies the transfer packet to launch.

Return Value:

    FALSE   - The packet was not launched because of insufficient resources.

    TRUE    - Success.

--*/

{
    USHORT      arraySize, i;
    ULONG       length, len;
    LONGLONG    offset, volumeSize;
    BOOLEAN     multiple;
    PCHAR       vp;
    LIST_ENTRY  q;
    PVOLSET_TP  p;
    PLIST_ENTRY l;

    KeInitializeSpinLock(&TransferPacket->SpinLock);
    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;
    TransferPacket->RefCount = 0;

    arraySize = QueryNumMembers();
    offset = TransferPacket->Offset;
    length = TransferPacket->Length;
    for (i = 0; i < arraySize; i++) {
        volumeSize = GetMemberUnprotected(i)->QueryVolumeSize();
        if (offset < volumeSize) {
            if (offset + length <= volumeSize) {
                multiple = FALSE;
            } else {
                multiple = TRUE;
            }
            break;
        }
        offset -= volumeSize;
    }

    if (TransferPacket->Mdl && multiple) {
        vp = (PCHAR) MmGetMdlVirtualAddress(TransferPacket->Mdl);
    }

    InitializeListHead(&q);
    for (;;) {

        len = length;
        if (len > volumeSize - offset) {
            len = (ULONG) (volumeSize - offset);
        }

        p = new VOLSET_TP;
        if (p) {
            if (TransferPacket->Mdl && multiple) {
                if (p->AllocateMdl(vp, len)) {
                    IoBuildPartialMdl(TransferPacket->Mdl, p->Mdl, vp, len);
                } else {
                    delete p;
                    p = NULL;
                }
                vp += len;
            } else {
                p->Mdl = TransferPacket->Mdl;
                p->OriginalIrp = TransferPacket->OriginalIrp;
            }
        }
        if (!p) {
            while (!IsListEmpty(&q)) {
                l = RemoveHeadList(&q);
                p = CONTAINING_RECORD(l, VOLSET_TP, QueueEntry);
                delete p;
            }
            return FALSE;
        }

        p->Length = len;
        p->Offset = offset;
        p->CompletionRoutine = VolsetTransferParallelCompletionRoutine;
        p->TargetVolume = GetMemberUnprotected(i);
        p->Thread = TransferPacket->Thread;
        p->IrpFlags = TransferPacket->IrpFlags;
        p->ReadPacket = TransferPacket->ReadPacket;
        p->SpecialRead = TransferPacket->SpecialRead;
        p->MasterPacket = TransferPacket;
        p->VolumeSet = this;
        p->WhichMember = i;

        InsertTailList(&q, &p->QueueEntry);

        TransferPacket->RefCount++;

        if (len == length) {
            break;
        }

        offset = 0;
        length -= p->Length;
        volumeSize = GetMemberUnprotected(++i)->QueryVolumeSize();
    }

    while (!IsListEmpty(&q)) {
        l = RemoveHeadList(&q);
        p = CONTAINING_RECORD(l, VOLSET_TP, QueueEntry);
        TRANSFER(p);
    }

    return TRUE;
}

VOID
VolsetTransferSequentialCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for VOLUME_SET::Transfer function.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PVOLSET_TP          transferPacket = (PVOLSET_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    PVOLUME_SET         t = transferPacket->VolumeSet;
    LONGLONG            masterOffset, volumeSize;
    USHORT              i;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PTRANSFER_PACKET    p;

    if (NT_SUCCESS(status)) {

        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Information +=
                    transferPacket->IoStatus.Information;
        }

    } else {

        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
        }
    }

    MmPrepareMdlForReuse(transferPacket->Mdl);

    masterOffset = 0;
    for (i = 0; i < transferPacket->WhichMember; i++) {
        masterOffset += t->GetMemberUnprotected(i)->QueryVolumeSize();
    }
    masterOffset += transferPacket->Offset;
    masterOffset += transferPacket->Length;

    if (masterOffset == masterPacket->Offset + masterPacket->Length) {

        masterPacket->CompletionRoutine(masterPacket);

        for (;;) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            if (IsListEmpty(&t->_ePacketQueue)) {
                t->_ePacketInUse = FALSE;
                KeReleaseSpinLock(&t->_spinLock, irql);
                break;
            }
            l = RemoveHeadList(&t->_ePacketQueue);
            KeReleaseSpinLock(&t->_spinLock, irql);

            p = CONTAINING_RECORD(l, TRANSFER_PACKET, QueueEntry);

            if (!t->LaunchParallel(p)) {
                t->LaunchSequential(p);
                break;
            }
        }
        return;
    }

    volumeSize = transferPacket->TargetVolume->QueryVolumeSize();
    transferPacket->Offset += transferPacket->Length;
    transferPacket->Length = STRIPE_SIZE;

    if (transferPacket->Offset >= volumeSize) {
        transferPacket->Offset -= volumeSize;
        transferPacket->WhichMember++;
        transferPacket->TargetVolume =
                t->GetMemberUnprotected(transferPacket->WhichMember);
        volumeSize = transferPacket->TargetVolume->QueryVolumeSize();
    }

    if (masterOffset + transferPacket->Length >
        masterPacket->Offset + masterPacket->Length) {

        transferPacket->Length = (ULONG) (masterPacket->Offset +
                                          masterPacket->Length - masterOffset);
    }

    if (transferPacket->Offset + transferPacket->Length > volumeSize) {
        transferPacket->Length = (ULONG) (volumeSize - transferPacket->Offset);
    }

    IoBuildPartialMdl(masterPacket->Mdl, transferPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (masterOffset - masterPacket->Offset),
                      transferPacket->Length);

    TRANSFER(transferPacket);
}

VOID
VOLUME_SET::LaunchSequential(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine lauches the given transfer packet in sequence accross
    all members using the emergency stripe transfer packet.

Arguments:

    TransferPacket  - Supplies the transfer packet to launch.

Return Value:

    FALSE   - The packet was not launched because of insufficient resources.

    TRUE    - Success.

--*/

{
    USHORT      arraySize, i;
    ULONG       length;
    LONGLONG    offset, volumeSize;
    PVOLSET_TP  p;

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = 0;

    arraySize = QueryNumMembers();
    offset = TransferPacket->Offset;
    length = TransferPacket->Length;
    for (i = 0; i < arraySize; i++) {
        volumeSize = GetMemberUnprotected(i)->QueryVolumeSize();
        if (offset < volumeSize) {
            break;
        }
        offset -= volumeSize;
    }

    p = _ePacket;
    p->Length = STRIPE_SIZE;
    p->Offset = offset;
    p->CompletionRoutine = VolsetTransferSequentialCompletionRoutine;
    p->Thread = TransferPacket->Thread;
    p->IrpFlags = TransferPacket->IrpFlags;
    p->ReadPacket = TransferPacket->ReadPacket;
    p->SpecialRead = TransferPacket->SpecialRead;
    p->MasterPacket = TransferPacket;
    p->VolumeSet = this;
    p->WhichMember = i;

    if (p->Length > TransferPacket->Length) {
        p->Length = TransferPacket->Length;
    }

    if (p->Offset + p->Length > volumeSize) {
        p->Length = (ULONG) (volumeSize - p->Offset);
    }

    IoBuildPartialMdl(TransferPacket->Mdl, p->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl), p->Length);

    TRANSFER(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\partmgr\partmgr.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    partmgr.c

Abstract:

    This driver manages hides partitions from user mode, allowing access
    only from other device drivers.  This driver implements a notification
    protocol for other drivers that want to be alerted of changes to the
    partitions in the system.

Author:

    Norbert Kusters      18-Apr-1997

Environment:

    kernel mode only

Notes:
    PartMgr calls out to the volume managers using the IOCTL_INTERNAL_VOLMGR_XXXX 
    IOCTLs in a number of places having acquired the driver extension mutex.
    The Volume manager may then call back into PartMgr with that lock still held. 
    In these call backs manipulation of the structures utilised in the code which
    issued the IOCTL_INTERNAL_VOLMGR_XXXXs should be avoided. This includes the 
    following:-

        DriverExtension->VolumeManagerList
        DriverExtension->DeviceExtensionList
        DeviceExtension->PartitionList


Revision History:

--*/

#define RTL_USE_AVL_TABLES 0

#include <ntosp.h>
#include <stdio.h>
#include <ntddvol.h>
#include <initguid.h>
#include <ntdddisk.h>
#include <volmgr.h>
#include <wmikm.h>
#include <wmilib.h>
#include <pmwmireg.h>
#include <pmwmicnt.h>
#include <partmgr.h>
#include <ntiologc.h>
#include <ioevent.h>


#ifndef UMAX
#define UMAX(_P1, _P2) (((_P1) > (_P2)) ? (_P1) : (_P2))
#endif

#define LockDriver(_DriverExtension)    (KeWaitForSingleObject (&(_DriverExtension)->Mutex,     \
                                                               Executive,                       \
                                                               KernelMode,                      \
                                                               FALSE,                           \
                                                               NULL))

#define UnlockDriver(_DriverExtension)  (KeReleaseMutex (&(_DriverExtension)->Mutex, FALSE))



NTSTATUS
PmReadPartitionTableEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRIVE_LAYOUT_INFORMATION_EX* DriveLayout
    );


NTSTATUS
PmWritePartitionTableEx(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PDRIVE_LAYOUT_INFORMATION_EX    DriveLayout
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
PmTakePartition(
    IN  PVOLMGR_LIST_ENTRY  VolumeManagerEntry,
    IN  PDEVICE_OBJECT      Partition,
    IN  PDEVICE_OBJECT      WholeDiskPdo
    );

NTSTATUS
PmGivePartition(
    IN  PVOLMGR_LIST_ENTRY  VolumeManagerEntry,
    IN  PDEVICE_OBJECT      Partition,
    IN  PDEVICE_OBJECT      WholeDiskPdo
    );

NTSTATUS
PmFindPartition(
    IN  PDEVICE_EXTENSION       Extension,
    IN  ULONG                   PartitionNumber,
    OUT PPARTITION_LIST_ENTRY   *PartitionEntry
    );

NTSTATUS
PmQueryDeviceRelations(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    );

NTSTATUS
PmRemoveDevice(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    );

NTSTATUS
PmCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
PmPowerNotify (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            WorkItem
    );

NTSTATUS
PmAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
PmVolumeManagerNotification(
    IN  PVOID   NotificationStructure,
    IN  PVOID   DriverExtension
    );

NTSTATUS
PmNotifyPartitions(
    IN PDEVICE_EXTENSION DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
PmBuildDependantVolumeRelations(
    IN PDEVICE_EXTENSION Extension,
    OUT PDEVICE_RELATIONS *Relations
    );

NTSTATUS
PmQueryDependantVolumeList(
    IN  PDEVICE_OBJECT VolumeManager,
    IN  PDEVICE_OBJECT Partition,
    IN  PDEVICE_OBJECT WholeDiskPdo,
    OUT PDEVICE_RELATIONS *DependantVolumes
    );

NTSTATUS
PmQueryRemovalRelations(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    );

NTSTATUS
PmStartPartition(
    IN  PDEVICE_OBJECT  Partition
    );

NTSTATUS
PmRemovePartition(
    IN PPARTITION_LIST_ENTRY Partition
    );

NTSTATUS
PmDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmGetPartitionInformation(
    IN  PDEVICE_OBJECT  Partition,
    IN  PFILE_OBJECT    FileObject,
    OUT PLONGLONG       PartitionOffset,
    OUT PLONGLONG       PartitionLength
    );

NTSTATUS
PmDiskGrowPartition(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
PmCheckForUnclaimedPartitions(
    IN  PDEVICE_OBJECT  DeviceObject
    );

NTSTATUS
PmChangePartitionIoctl(
    IN  PDEVICE_EXTENSION       Extension,
    IN  PPARTITION_LIST_ENTRY   Partition,
    IN  ULONG                   IoctlCode
    );

NTSTATUS
PmEjectVolumeManagers(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
PmAddSignatures(
    IN  PDEVICE_EXTENSION               Extension,
    IN  PDRIVE_LAYOUT_INFORMATION_EX    Layout
    );

RTL_GENERIC_COMPARE_RESULTS
PmTableSignatureCompareRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               First,
    IN  PVOID               Second
    );

RTL_GENERIC_COMPARE_RESULTS
PmTableGuidCompareRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               First,
    IN  PVOID               Second
    );

PVOID
PmTableAllocateRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  CLONG               Size
    );

VOID
PmTableFreeRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               Buffer
    );

NTSTATUS
PmQueryDiskSignature(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
PmReadWrite(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
PmIoCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS PmWmi(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
PmWmiFunctionControl(
    IN PDEVICE_OBJECT           DeviceObject,
    IN PIRP                     Irp,
    IN ULONG                    GuidIndex,
    IN WMIENABLEDISABLECONTROL  Function,
    IN BOOLEAN                  Enable
    );

VOID
PmDriverReinit(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PVOID           DriverExtension,
    IN  ULONG           Count
    );

BOOLEAN
PmIsRedundantPath(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PDEVICE_EXTENSION   WinningExtension,
    IN  ULONG               Signature,
    IN  GUID*               Guid
    );

VOID
PmLogError(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PDEVICE_EXTENSION   WinningExtension,
    IN  NTSTATUS            SpecificIoStatus
    );

ULONG
PmQueryRegistrySignature(
    );

VOID
PmQueryRegistryGuid(
    IN  PDO_EXTENSION   DriverExtension
    );

NTSTATUS
PmQueryRegistryGuidQueryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    );

VOID 
PmSigCheckUpdateEpoch (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PLIST_ENTRY       CompletionList
    );

VOID
PmSigCheckCompleteNotificationIrps(
    IN PLIST_ENTRY CompletionList
    );

NTSTATUS
PmSigCheckFillInNotificationIrp (
    IN PDO_EXTENSION DriverExtension,
    IN PIRP          Irp
    );

NTSTATUS
PmSigCheckNotificationInsert (
    IN PDEVICE_EXTENSION DeviceExtension, 
    IN PIRP              Irp
    );

NTSTATUS
PmSigCheckNotificationCancel (
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PmCheckAndUpdateSignature (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN           IssueSigCheckNotifications,
    IN BOOLEAN           ForceSignatureCheck
    );

BOOLEAN
LockDriverWithTimeout(
    IN  PDO_EXTENSION   DriverExtension
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, PmQueryRegistrySignature)
#pragma alloc_text(INIT, PmQueryRegistryGuid)
#pragma alloc_text(INIT, PmQueryRegistryGuidQueryRoutine)
#pragma alloc_text(PAGE, PmTakePartition)
#pragma alloc_text(PAGE, PmGivePartition)
#pragma alloc_text(PAGE, PmFindPartition)
#pragma alloc_text(PAGE, PmQueryDeviceRelations)
#pragma alloc_text(PAGE, PmRemoveDevice)
#pragma alloc_text(PAGE, PmCreateClose)
#pragma alloc_text(PAGE, PmPnp)
#pragma alloc_text(PAGE, PmAddDevice)
#pragma alloc_text(PAGE, PmVolumeManagerNotification)
#pragma alloc_text(PAGE, PmNotifyPartitions)
#pragma alloc_text(PAGE, PmBuildDependantVolumeRelations)
#pragma alloc_text(PAGE, PmQueryDependantVolumeList)
#pragma alloc_text(PAGE, PmQueryRemovalRelations)
#pragma alloc_text(PAGE, PmStartPartition)
#pragma alloc_text(PAGE, PmDeviceControl)
#pragma alloc_text(PAGE, PmGetPartitionInformation)
#pragma alloc_text(PAGE, PmDiskGrowPartition)
#pragma alloc_text(PAGE, PmCheckForUnclaimedPartitions)
#pragma alloc_text(PAGE, PmChangePartitionIoctl)
#pragma alloc_text(PAGE, PmEjectVolumeManagers)
#pragma alloc_text(PAGE, PmAddSignatures)
#pragma alloc_text(PAGE, PmTableSignatureCompareRoutine)
#pragma alloc_text(PAGE, PmTableGuidCompareRoutine)
#pragma alloc_text(PAGE, PmTableAllocateRoutine)
#pragma alloc_text(PAGE, PmTableFreeRoutine)
#pragma alloc_text(PAGE, PmQueryDiskSignature)
#pragma alloc_text(PAGE, PmWmi)
#pragma alloc_text(PAGE, PmWmiFunctionControl)
#pragma alloc_text(PAGE, PmReadPartitionTableEx)
#pragma alloc_text(PAGE, PmWritePartitionTableEx)
#pragma alloc_text(PAGE, PmDriverReinit)
#pragma alloc_text(PAGE, PmIsRedundantPath)
#pragma alloc_text(PAGE, PmLogError)
#pragma alloc_text(PAGE, PmSigCheckCompleteNotificationIrps)
#pragma alloc_text(PAGE, PmSigCheckFillInNotificationIrp)
#pragma alloc_text(PAGE, PmCheckAndUpdateSignature)
#pragma alloc_text(PAGE, LockDriverWithTimeout)
#endif

const GUID guidNull = { 0 };


BOOLEAN
LockDriverWithTimeout(
    IN  PDO_EXTENSION   DriverExtension
    )
{
    LARGE_INTEGER   timeout;
    NTSTATUS        status;

    timeout.QuadPart = -10*1000*1000*6; // 6 seconds.
    status = KeWaitForSingleObject(&DriverExtension->Mutex, Executive,
                                   KernelMode, FALSE, &timeout);

    return (status != STATUS_TIMEOUT);
}

NTSTATUS
PmPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_PNP_POWER.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   extension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(extension->TargetObject, Irp);
}

NTSTATUS
PmSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Event
    )

/*++

Routine Description:

    This routine will signal the event given as context.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

    Event           - Supplies the event to signal.

Return Value:

    NTSTATUS

--*/

{
    KeSetEvent((PKEVENT) Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
PmTakePartition(
    IN  PVOLMGR_LIST_ENTRY  VolumeManagerEntry,
    IN  PDEVICE_OBJECT      Partition,
    IN  PDEVICE_OBJECT      WholeDiskPdo
    )

/*++

Routine Description:

    This routine passes the given partition to the given volume manager
    and waits to see if the volume manager accepts the partition.  A success
    status indicates that the volume manager has accepted the partition.

Arguments:

    VolumeManager   - Supplies a volume manager.

    Partition       - Supplies a partition.

    WholeDiskPdo    - Supplies the whole disk PDO.

Return Value:

    NTSTATUS

--*/

{
    KEVENT                          event;
    VOLMGR_PARTITION_INFORMATION    input;
    PIRP                            irp;
    IO_STATUS_BLOCK                 ioStatus;
    NTSTATUS                        status;

    if (!VolumeManagerEntry) {
        return;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    input.PartitionDeviceObject = Partition;
    input.WholeDiskPdo = WholeDiskPdo;

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_VOLMGR_PARTITION_REMOVED,
                                        VolumeManagerEntry->VolumeManager,
                                        &input, sizeof(input), NULL, 0, TRUE,
                                        &event, &ioStatus);
    if (!irp) {
        return;
    }

    status = IoCallDriver(VolumeManagerEntry->VolumeManager, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }

    VolumeManagerEntry->RefCount--;
    if (!VolumeManagerEntry->RefCount) {
        VolumeManagerEntry->VolumeManager = NULL;
        ObDereferenceObject(VolumeManagerEntry->VolumeManagerFileObject);
        VolumeManagerEntry->VolumeManagerFileObject = NULL;
    }
}

NTSTATUS
PmGivePartition(
    IN  PVOLMGR_LIST_ENTRY  VolumeManagerEntry,
    IN  PDEVICE_OBJECT      Partition,
    IN  PDEVICE_OBJECT      WholeDiskPdo
    )

/*++

Routine Description:

    This routine passes the given partition to the given volume manager
    and waits to see if the volume manager accepts the partition.  A success
    status indicates that the volume manager has accepted the partition.

Arguments:

    VolumeManager   - Supplies a volume manager.

    Partition       - Supplies a partition.

    WholeDiskPdo    - Supplies the whole disk PDO.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                        status;
    KEVENT                          event;
    VOLMGR_PARTITION_INFORMATION    input;
    PIRP                            irp;
    IO_STATUS_BLOCK                 ioStatus;

    if (!VolumeManagerEntry->RefCount) {
        status = IoGetDeviceObjectPointer(
                 &VolumeManagerEntry->VolumeManagerName, FILE_READ_DATA,
                 &VolumeManagerEntry->VolumeManagerFileObject,
                 &VolumeManagerEntry->VolumeManager);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    input.PartitionDeviceObject = Partition;
    input.WholeDiskPdo = WholeDiskPdo;

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_VOLMGR_PARTITION_ARRIVED,
                                        VolumeManagerEntry->VolumeManager,
                                        &input, sizeof(input),
                                        NULL, 0, TRUE, &event, &ioStatus);
    if (!irp) {
        if (!VolumeManagerEntry->RefCount) {
            VolumeManagerEntry->VolumeManager = NULL;
            ObDereferenceObject(VolumeManagerEntry->VolumeManagerFileObject);
            VolumeManagerEntry->VolumeManagerFileObject = NULL;
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(VolumeManagerEntry->VolumeManager, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (NT_SUCCESS(status)) {
        VolumeManagerEntry->RefCount++;
    } else {
        if (!VolumeManagerEntry->RefCount) {
            VolumeManagerEntry->VolumeManager = NULL;
            ObDereferenceObject(VolumeManagerEntry->VolumeManagerFileObject);
            VolumeManagerEntry->VolumeManagerFileObject = NULL;
        }
    }

    return status;
}

NTSTATUS
PmFindPartition(
    IN  PDEVICE_EXTENSION       Extension,
    IN  ULONG                   PartitionNumber,
    OUT PPARTITION_LIST_ENTRY*  Partition
    )

{
    PLIST_ENTRY             l;
    PPARTITION_LIST_ENTRY   partition;
    KEVENT                  event;
    PIRP                    irp;
    STORAGE_DEVICE_NUMBER   deviceNumber;
    IO_STATUS_BLOCK         ioStatus;
    NTSTATUS                status;

    ASSERT(Partition);
    *Partition = NULL;

    for (l = Extension->PartitionList.Flink; l != &Extension->PartitionList;
         l = l->Flink) {

        partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                            partition->TargetObject, NULL, 0,
                                            &deviceNumber,
                                            sizeof(deviceNumber), FALSE,
                                            &event, &ioStatus);
        if (!irp) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = IoCallDriver(partition->TargetObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        if (NT_SUCCESS(status) &&
            PartitionNumber == deviceNumber.PartitionNumber) {

            *Partition = partition;
            return status;
        }
    }

    return STATUS_NOT_FOUND;
}

NTSTATUS
PmChangePartitionIoctl(
    IN  PDEVICE_EXTENSION       Extension,
    IN  PPARTITION_LIST_ENTRY   Partition,
    IN  ULONG                   IoctlCode
    )

{
    PVOLMGR_LIST_ENTRY              volumeEntry;
    KEVENT                          event;
    VOLMGR_PARTITION_INFORMATION    input;
    PIRP                            irp;
    IO_STATUS_BLOCK                 ioStatus;
    NTSTATUS                        status;

    volumeEntry = Partition->VolumeManagerEntry;
    if (!volumeEntry) {
        return STATUS_SUCCESS;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    input.PartitionDeviceObject = Partition->TargetObject;
    input.WholeDiskPdo = Partition->WholeDiskPdo;

    irp = IoBuildDeviceIoControlRequest(
            IoctlCode, volumeEntry->VolumeManager, &input, sizeof(input),
            NULL, 0, TRUE, &event, &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(volumeEntry->VolumeManager, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    return status;
}

NTSTATUS
PmStartPartition(
    IN  PDEVICE_OBJECT  Partition
    )

{
    PIRP                    irp;
    KEVENT                  event;
    PIO_STACK_LOCATION      irpSp;
    NTSTATUS                status;

    irp = IoAllocateIrp(Partition->StackSize, FALSE);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = IRP_MJ_PNP;
    irpSp->MinorFunction = IRP_MN_START_DEVICE;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    IoSetCompletionRoutine(irp, PmSignalCompletion, &event, TRUE, TRUE, TRUE);

    IoCallDriver(Partition, irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    status = irp->IoStatus.Status;

    IoFreeIrp(irp);

    return status;
}

NTSTATUS
PmQueryDeviceRelations(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine processes the query device relations request.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                        status;
    PDRIVE_LAYOUT_INFORMATION_EX    newLayout;
    KEVENT                          event;
    PDEVICE_RELATIONS               deviceRelations;
    PLIST_ENTRY                     l, b;
    PPARTITION_LIST_ENTRY           partition;
    ULONG                           i;
    PVOLMGR_LIST_ENTRY              volmgrEntry;
    LIST_ENTRY                      completionList;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, PmSignalCompletion, &event, TRUE, TRUE, TRUE);
    IoCallDriver(Extension->TargetObject, Irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        return Irp->IoStatus.Status;
    }

    deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;


    PmCheckAndUpdateSignature (Extension, TRUE, FALSE);



    //
    // First notify clients of partitions that have gone away.
    //

    LockDriver (Extension->DriverExtension);


    for (l = Extension->PartitionList.Flink; l != &Extension->PartitionList;
         l = l->Flink) {

        partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);

        for (i = 0; i < deviceRelations->Count; i++) {
            if (partition->TargetObject == deviceRelations->Objects[i]) {
                break;
            }
        }

        if (i < deviceRelations->Count) {
            continue;
        }

        PmTakePartition(partition->VolumeManagerEntry,
                        partition->TargetObject, partition->WholeDiskPdo);

        //
        // We're pretending to be pnp.  Send a remove to the partition
        // object so it can delete it.
        //

        PmRemovePartition(partition);

        b = l->Blink;
        RemoveEntryList(l);
        l = b;

        ExFreePool(partition);
    }

    //
    // Then notify clients of new partitions.
    //

    for (i = 0; i < deviceRelations->Count; i++) {

        for (l = Extension->PartitionList.Flink;
             l != &Extension->PartitionList; l = l->Flink) {

            partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);

            if (deviceRelations->Objects[i] == partition->TargetObject) {
                break;
            }
        }

        if (l != &Extension->PartitionList) {
            
            //
            // Must attempt to start the partition even if it is in our list
            // because it may be stopped and need restarting.
            //

            PmStartPartition(deviceRelations->Objects[i]);
            continue;
        }

        if (Extension->DriverExtension->PastReinit) {

            //
            // Now that this partition is owned by the partition manager
            // make sure that nobody can open it another way.
            //

            deviceRelations->Objects[i]->Flags |= DO_DEVICE_INITIALIZING;
        }

        status = PmStartPartition(deviceRelations->Objects[i]);
        if (!NT_SUCCESS(status)) {
            continue;
        }

        partition = ExAllocatePoolWithTag(NonPagedPool,
                                          sizeof(PARTITION_LIST_ENTRY),
                                          PARTMGR_TAG_PARTITION_ENTRY);
        if (!partition) {
            continue;
        }

        partition->TargetObject = deviceRelations->Objects[i];
        partition->WholeDiskPdo = Extension->Pdo;
        partition->VolumeManagerEntry = NULL;
        InsertHeadList(&Extension->PartitionList, &partition->ListEntry);

        if (Extension->IsRedundantPath) {
            continue;
        }

        for (l = Extension->DriverExtension->VolumeManagerList.Flink;
             l != &Extension->DriverExtension->VolumeManagerList; l = l->Flink) {

            volmgrEntry = CONTAINING_RECORD(l, VOLMGR_LIST_ENTRY, ListEntry);

            status = PmGivePartition(volmgrEntry,
                                     partition->TargetObject,
                                     partition->WholeDiskPdo);

            if (NT_SUCCESS(status)) {
                partition->VolumeManagerEntry = volmgrEntry;
                break;
            }
        }
    }


    UnlockDriver (Extension->DriverExtension);

    deviceRelations->Count = 0;

    return Irp->IoStatus.Status;
}

VOID
PmTakeWholeDisk(
    IN  PVOLMGR_LIST_ENTRY  VolumeManagerEntry,
    IN  PDEVICE_OBJECT      WholeDiskPdo
    )

/*++

Routine Description:

    This routine alerts the volume manager that the given PDO is going away.

Arguments:

    VolumeManager   - Supplies a volume manager.

    WholeDiskPdo    - Supplies the whole disk PDO.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                        status;
    KEVENT                          event;
    VOLMGR_WHOLE_DISK_INFORMATION   input;
    PIRP                            irp;
    IO_STATUS_BLOCK                 ioStatus;

    if (!VolumeManagerEntry) {
        return;
    }

    if (!VolumeManagerEntry->RefCount) {
        status = IoGetDeviceObjectPointer(
                 &VolumeManagerEntry->VolumeManagerName, FILE_READ_DATA,
                 &VolumeManagerEntry->VolumeManagerFileObject,
                 &VolumeManagerEntry->VolumeManager);
        if (!NT_SUCCESS(status)) {
            return;
        }
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    input.WholeDiskPdo = WholeDiskPdo;

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_VOLMGR_WHOLE_DISK_REMOVED,
                                        VolumeManagerEntry->VolumeManager,
                                        &input, sizeof(input), NULL, 0, TRUE,
                                        &event, &ioStatus);
    if (!irp) {
        if (!VolumeManagerEntry->RefCount) {
            VolumeManagerEntry->VolumeManager = NULL;
            ObDereferenceObject(VolumeManagerEntry->VolumeManagerFileObject);
            VolumeManagerEntry->VolumeManagerFileObject = NULL;
        }
        return;
    }

    status = IoCallDriver(VolumeManagerEntry->VolumeManager, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }

    if (!VolumeManagerEntry->RefCount) {
        VolumeManagerEntry->VolumeManager = NULL;
        ObDereferenceObject(VolumeManagerEntry->VolumeManagerFileObject);
        VolumeManagerEntry->VolumeManagerFileObject = NULL;
    }
}

NTSTATUS
PmNotifyPartitions(
    IN PDEVICE_EXTENSION Extension,
    IN PIRP              Irp
    )

/*++

Routine Description:

    This routine notifies each partition stolen by the partmgr that it is
    about to be removed.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION      irpStack = IoGetCurrentIrpStackLocation(Irp);
    PLIST_ENTRY             l;
    PPARTITION_LIST_ENTRY   partition;
    NTSTATUS                status = STATUS_SUCCESS;
    KEVENT event;

    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    LockDriver (Extension->DriverExtension);

    for(l = Extension->PartitionList.Flink;
        l != &(Extension->PartitionList);
        l = l->Flink) {

        partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               PmSignalCompletion,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE);

        status = IoCallDriver(partition->TargetObject, Irp);

        if(status == STATUS_PENDING) {

            KeWaitForSingleObject(&event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            status = Irp->IoStatus.Status;
        }

        if(!NT_SUCCESS(status)) {
            break;
        }
    }

    UnlockDriver (Extension->DriverExtension);

    return status;
}

NTSTATUS
PmRemoveDevice(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine processes the query device relations request.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                        status;
    PDRIVE_LAYOUT_INFORMATION_EX    layout;
    PLIST_ENTRY                     l;
    PPARTITION_LIST_ENTRY           partition;
    PVOLMGR_LIST_ENTRY              volmgrEntry;


    LockDriver (Extension->DriverExtension);

    if (Extension->RemoveProcessed) {
        UnlockDriver (Extension->DriverExtension);
        return STATUS_SUCCESS;
    }

    Extension->RemoveProcessed = TRUE;

    Extension->IsStarted = FALSE;

    PmAddSignatures(Extension, NULL);

    for (l = Extension->PartitionList.Flink;
         l != &Extension->PartitionList; l = l->Flink) {

        partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);
        PmTakePartition(partition->VolumeManagerEntry,
                        partition->TargetObject, NULL);
    }

    status = PmNotifyPartitions(Extension, Irp);

    ASSERT(NT_SUCCESS(status));

    while (!IsListEmpty(&Extension->PartitionList)) {
        l = RemoveHeadList(&Extension->PartitionList);
        partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);
        ExFreePool(partition);
    }

    for (l = Extension->DriverExtension->VolumeManagerList.Flink;
         l != &Extension->DriverExtension->VolumeManagerList; l = l->Flink) {

        volmgrEntry = CONTAINING_RECORD(l, VOLMGR_LIST_ENTRY, ListEntry);
        PmTakeWholeDisk(volmgrEntry, Extension->Pdo);
    }

    RemoveEntryList(&Extension->ListEntry);

    if (Extension->WmilibContext != NULL) { // just to be safe
        IoWMIRegistrationControl(Extension->DeviceObject,
                                 WMIREG_ACTION_DEREGISTER);
        ExFreePool(Extension->WmilibContext);
        Extension->WmilibContext = NULL;
        PmWmiCounterDisable(&Extension->PmWmiCounterContext,
                            TRUE, TRUE);
        Extension->CountersEnabled = FALSE;
    }


    UnlockDriver (Extension->DriverExtension);

    return status;
}

VOID
PmPowerNotify (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            PublicWorkItem
    )

/*++

Routine Description:

    This routine notifies volume managers about changes in
    the power state of the given disk.

Arguments:

    DeviceObject    - Supplies the device object.

    PublicWorkItem  - Supplies the public work item

Return Value:

    None    

--*/

{
    PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;
    PDO_EXTENSION           driverExtension = deviceExtension->DriverExtension;
    KEVENT                  event;
    KIRQL                   irql;
    LIST_ENTRY              q;
    PLIST_ENTRY             l;
    BOOLEAN                 empty;
    PPM_POWER_WORK_ITEM     privateWorkItem; 
    PPARTITION_LIST_ENTRY   partition;
    VOLMGR_POWER_STATE      input;
    PIRP                    irp;
    IO_STATUS_BLOCK         ioStatus;
    NTSTATUS                status;
        

    LockDriver (driverExtension);

    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    if (IsListEmpty(&deviceExtension->PowerQueue)) {
        empty = TRUE;
    } else {
        empty = FALSE;
        q = deviceExtension->PowerQueue;
        InitializeListHead(&deviceExtension->PowerQueue);
    }
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

    if (empty) {
        UnlockDriver (driverExtension);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, NULL);
        IoFreeWorkItem((PIO_WORKITEM) PublicWorkItem);
        return;
    }

    q.Flink->Blink = &q;
    q.Blink->Flink = &q;
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    while (!IsListEmpty(&q)) {

        l = RemoveHeadList(&q);
        privateWorkItem = CONTAINING_RECORD(l, PM_POWER_WORK_ITEM, ListEntry);

        for (l = deviceExtension->PartitionList.Flink; 
             l != &deviceExtension->PartitionList; l = l->Flink) {

            partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);
            if (!partition->VolumeManagerEntry) {
                continue;
            }
        
            input.PartitionDeviceObject = partition->TargetObject;
            input.WholeDiskPdo = partition->WholeDiskPdo;
            input.PowerState = privateWorkItem->DevicePowerState;

            irp = IoBuildDeviceIoControlRequest(
                                    IOCTL_INTERNAL_VOLMGR_SET_POWER_STATE,
                                    partition->VolumeManagerEntry->VolumeManager,
                                    &input, sizeof(input), NULL, 0, TRUE,
                                    &event, &ioStatus);
            if (!irp) {
                continue;
            }
            status = IoCallDriver(partition->VolumeManagerEntry->VolumeManager, 
                                  irp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            }
            KeClearEvent(&event);
        }

        ExFreePool(privateWorkItem);        
    }
            
    UnlockDriver (driverExtension);
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, NULL);
    IoFreeWorkItem((PIO_WORKITEM) PublicWorkItem);    
} 

NTSTATUS
PmPowerCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )

/*++

Routine Description:

    This routine handles completion of an IRP_MN_SET_POWER irp.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

    Context         - Not used.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation(Irp);
    PIO_WORKITEM        publicWorkItem;
    PPM_POWER_WORK_ITEM privateWorkItem; 
    KIRQL               irql;

    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER &&
           irpStack->MinorFunction == IRP_MN_SET_POWER);
    ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);
    
    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        PoStartNextPowerIrp(Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, NULL);
        return STATUS_SUCCESS;
    }

    publicWorkItem = IoAllocateWorkItem(DeviceObject);
    if (!publicWorkItem) {
        PoStartNextPowerIrp(Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, NULL);
        return STATUS_SUCCESS;
    }
    
    privateWorkItem = (PPM_POWER_WORK_ITEM) ExAllocatePoolWithTag(NonPagedPool,
                                          sizeof(PM_POWER_WORK_ITEM),
                                          PARTMGR_TAG_POWER_WORK_ITEM);
    if (!privateWorkItem) {
        PoStartNextPowerIrp(Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, NULL);
        IoFreeWorkItem(publicWorkItem);
        return STATUS_SUCCESS;
    }
    
    privateWorkItem->DevicePowerState = 
                        irpStack->Parameters.Power.State.DeviceState;
    
    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    InsertTailList(&deviceExtension->PowerQueue, &privateWorkItem->ListEntry);
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
    
    IoQueueWorkItem(publicWorkItem, PmPowerNotify, DelayedWorkQueue, 
                    publicWorkItem);
    
    PoStartNextPowerIrp(Irp);
    return STATUS_SUCCESS;        
}

NTSTATUS
PmPower(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_POWER.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION   deviceExtension = 
                        (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    NTSTATUS            status;
       
    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, NULL);
    if (!NT_SUCCESS (status)) {
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }
    
    if (irpSp->MinorFunction == IRP_MN_SET_POWER &&
        irpSp->Parameters.Power.Type == DevicePowerState) {

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, PmPowerCompletion, NULL, TRUE, 
                               TRUE, TRUE);
        IoMarkIrpPending(Irp);
        PoCallDriver(deviceExtension->TargetObject, Irp);
        return STATUS_PENDING;
    }   
    
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);    
    status = PoCallDriver(deviceExtension->TargetObject, Irp);
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, NULL);
    return status;
}

NTSTATUS
PmQueryRemovalRelations(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine processes the query removal relations request.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                status;
    KEVENT                  event;
    PDEVICE_RELATIONS       childRelationsList;
    PDEVICE_RELATIONS       volumeRelationsList;
    PDEVICE_RELATIONS       combinedRelationsList;
    ULONG                   i;
    ULONG                   j;
    ULONG                   combinedCount;


    status = Irp->IoStatus.Status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, PmSignalCompletion, &event, TRUE, TRUE, TRUE);
    IoCallDriver(Extension->TargetObject, Irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        Irp->IoStatus.Information = 0;
        if (status != Irp->IoStatus.Status) {
            return Irp->IoStatus.Status;
        }
    }


    childRelationsList = (PDEVICE_RELATIONS)Irp->IoStatus.Information;
    status = PmBuildDependantVolumeRelations(Extension, &volumeRelationsList);


    //
    // Enumerate and combine the two lists. For lack of a better
    // tag, use PARTMGR_TAG_DEPENDANT_VOLUME_LIST to represent
    // the combined list
    //

    if (!NT_SUCCESS(status)) {

        volumeRelationsList = NULL;

    } else {

        combinedCount =  ((NULL == volumeRelationsList) ? 0 : volumeRelationsList->Count)
                       + ((NULL == childRelationsList)  ? 0 : childRelationsList->Count);
    
        combinedRelationsList = ExAllocatePoolWithTag (
                                        PagedPool,
                                        (sizeof (DEVICE_RELATIONS) +
                                        (sizeof (PDEVICE_OBJECT) * combinedCount)),
                                        PARTMGR_TAG_DEPENDANT_VOLUME_LIST);


        if (NULL == combinedRelationsList) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }


    if (NT_SUCCESS(status)) {
        RtlZeroMemory (combinedRelationsList,
                       (sizeof(DEVICE_RELATIONS) +
                       (sizeof(PDEVICE_OBJECT) * combinedCount)));

        combinedRelationsList->Count = combinedCount;

        i = j = 0;

        if (NULL != volumeRelationsList) {
            for (; i < volumeRelationsList->Count; i++) {
                combinedRelationsList->Objects [i] = volumeRelationsList->Objects [i];
            }
	}


        if (NULL != childRelationsList) {
            for (; j < childRelationsList->Count; i++, j++) {
                combinedRelationsList->Objects [i] = childRelationsList->Objects [j];
            }
        }
 

	status = STATUS_SUCCESS;
        Irp->IoStatus.Information = (ULONG_PTR) combinedRelationsList;

    } else {

        if (NULL != childRelationsList) {
            for (i = 0; i < childRelationsList->Count; i++) {
                ObDereferenceObject (childRelationsList->Objects [i]);
            }
        }

	if (NULL != volumeRelationsList) {
            for (i = 0; i < volumeRelationsList->Count; i++) {
                ObDereferenceObject (volumeRelationsList->Objects [i]);
            }
	}

        
        Irp->IoStatus.Information = 0;
    }



    if (NULL != childRelationsList) {
        ExFreePool (childRelationsList);
    }

    if (NULL != volumeRelationsList) {
        ExFreePool (volumeRelationsList);
    }

    return (status);
}

BOOLEAN
PmIsRedundantPath(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PDEVICE_EXTENSION   WinningExtension,
    IN  ULONG               Signature,
    IN  GUID*               Guid
    )

{
    PDO_EXTENSION           driverExtension = Extension->DriverExtension;
    PDEVICE_EXTENSION       extension = WinningExtension;
    PGUID_TABLE_ENTRY       guidEntry;
    PSIGNATURE_TABLE_ENTRY  sigEntry;
    KEVENT                  event;
    PIRP                    irp;
    DISK_GEOMETRY           geometry, geometry2;
    IO_STATUS_BLOCK         ioStatus;
    NTSTATUS                status;
    ULONG                   bufferSize;
    ULONG                   readSize;
    PVOID                   buffer;
    LARGE_INTEGER           byteOffset;
    PUSHORT                 testWord;
    BOOLEAN                 isRedundant;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        Extension->TargetObject, NULL, 0,
                                        &geometry, sizeof(geometry), FALSE,
                                        &event, &ioStatus);
    if (!irp) {
        return TRUE;
    }
    status = IoCallDriver(Extension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        return TRUE;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        extension->TargetObject, NULL, 0,
                                        &geometry2, sizeof(geometry2), FALSE,
                                        &event, &ioStatus);
    if (!irp) {
        return TRUE;
    }
    status = IoCallDriver(extension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        return TRUE;
    }

    if (geometry2.BytesPerSector > geometry.BytesPerSector) {
        geometry.BytesPerSector = geometry2.BytesPerSector;
    }

    byteOffset.QuadPart = 0;
    readSize = 512;
    if (readSize < geometry.BytesPerSector) {
        readSize = geometry.BytesPerSector;
    }

    bufferSize = 2*readSize;
    buffer = ExAllocatePoolWithTag(NonPagedPool, bufferSize < PAGE_SIZE ?
                                   PAGE_SIZE : bufferSize,
                                   PARTMGR_TAG_IOCTL_BUFFER);
    if (!buffer) {
        return TRUE;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildSynchronousFsdRequest(IRP_MJ_READ, Extension->TargetObject,
                                       buffer, readSize, &byteOffset, &event,
                                       &ioStatus);
    if (!irp) {
        ExFreePool(buffer);
        return TRUE;
    }
    status = IoCallDriver(Extension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        ExFreePool(buffer);
        return TRUE;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildSynchronousFsdRequest(IRP_MJ_READ, extension->TargetObject,
                                       (PCHAR) buffer + readSize, readSize,
                                       &byteOffset, &event, &ioStatus);
    if (!irp) {
        ExFreePool(buffer);
        return TRUE;
    }
    status = IoCallDriver(extension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        ExFreePool(buffer);
        return TRUE;
    }

    if (RtlCompareMemory(buffer, (PCHAR) buffer + readSize, readSize) !=
                         readSize) {

        ExFreePool(buffer);
        return FALSE;
    }

    testWord = (PUSHORT) ((PCHAR) buffer + 0x1BC);
    (*testWord)++;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildSynchronousFsdRequest(IRP_MJ_WRITE, Extension->TargetObject,
                                       buffer, readSize, &byteOffset, &event,
                                       &ioStatus);
    if (!irp) {
        ExFreePool(buffer);
        return TRUE;
    }
    status = IoCallDriver(Extension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        ExFreePool(buffer);
        return TRUE;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildSynchronousFsdRequest(IRP_MJ_READ, extension->TargetObject,
                                       (PCHAR) buffer + readSize, readSize,
                                       &byteOffset, &event, &ioStatus);
    if (!irp) {
        isRedundant = TRUE;
        goto ResetTestWord;
    }
    status = IoCallDriver(extension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        isRedundant = TRUE;
        goto ResetTestWord;
    }

    if (RtlCompareMemory(buffer, (PCHAR) buffer + readSize, readSize) !=
                         readSize) {

        isRedundant = FALSE;
        goto ResetTestWord;
    }

    isRedundant = TRUE;

ResetTestWord:
    (*testWord)--;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildSynchronousFsdRequest(IRP_MJ_WRITE, Extension->TargetObject,
                                       buffer, readSize, &byteOffset, &event,
                                       &ioStatus);
    if (!irp) {
        ExFreePool(buffer);
        return isRedundant;
    }
    status = IoCallDriver(Extension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        ExFreePool(buffer);
        return isRedundant;
    }

    ExFreePool(buffer);

    return isRedundant;
}

VOID
PmLogError(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PDEVICE_EXTENSION   WinningExtension,
    IN  NTSTATUS            SpecificIoStatus
    )

{
    KEVENT                                  event;
    PIRP                                    irp;
    STORAGE_DEVICE_NUMBER                   deviceNumber, winningDeviceNumber;
    IO_STATUS_BLOCK                         ioStatus;
    NTSTATUS                                status;
    WCHAR                                   buffer1[30], buffer2[30];
    UNICODE_STRING                          number, winningNumber;
    ULONG                                   extraSpace;
    PIO_ERROR_LOG_PACKET                    errorLogPacket;
    PWCHAR                                  p;
    GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION  diskCloneArrivalInfo;
    UCHAR                                   notificationBuffer[sizeof(TARGET_DEVICE_CUSTOM_NOTIFICATION) + sizeof(GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION)];
    PTARGET_DEVICE_CUSTOM_NOTIFICATION      notification = (PTARGET_DEVICE_CUSTOM_NOTIFICATION) notificationBuffer;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                        Extension->TargetObject, NULL, 0,
                                        &deviceNumber, sizeof(deviceNumber),
                                        FALSE, &event, &ioStatus);
    if (!irp) {
        return;
    }

    status = IoCallDriver(Extension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                        WinningExtension->TargetObject, NULL,
                                        0, &winningDeviceNumber,
                                        sizeof(winningDeviceNumber),
                                        FALSE, &event, &ioStatus);
    if (!irp) {
        return;
    }

    status = IoCallDriver(WinningExtension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return;
    }

    swprintf(buffer1, L"%d", deviceNumber.DeviceNumber);
    RtlInitUnicodeString(&number, buffer1);
    swprintf(buffer2, L"%d", winningDeviceNumber.DeviceNumber);
    RtlInitUnicodeString(&winningNumber, buffer2);
    extraSpace = number.Length + winningNumber.Length + 2*sizeof(WCHAR);
    extraSpace += sizeof(IO_ERROR_LOG_PACKET);
    if (extraSpace > 0xFF) {
        return;
    }

    errorLogPacket = (PIO_ERROR_LOG_PACKET)
                     IoAllocateErrorLogEntry(Extension->DeviceObject,
                                             (UCHAR) extraSpace);
    if (!errorLogPacket) {
        return;
    }

    errorLogPacket->ErrorCode = SpecificIoStatus;
    errorLogPacket->SequenceNumber = 0;
    errorLogPacket->FinalStatus = 0;
    errorLogPacket->UniqueErrorValue = 0;
    errorLogPacket->DumpDataSize = 0;
    errorLogPacket->RetryCount = 0;
    errorLogPacket->NumberOfStrings = 2;
    errorLogPacket->StringOffset = sizeof(IO_ERROR_LOG_PACKET);
    p = (PWCHAR) ((PCHAR) errorLogPacket + sizeof(IO_ERROR_LOG_PACKET));
    RtlCopyMemory(p, number.Buffer, number.Length);
    p[number.Length/sizeof(WCHAR)] = 0;
    p = (PWCHAR) ((PCHAR) errorLogPacket + sizeof(IO_ERROR_LOG_PACKET) +
                  number.Length + sizeof(WCHAR));
    RtlCopyMemory(p, winningNumber.Buffer, winningNumber.Length);
    p[winningNumber.Length/sizeof(WCHAR)] = 0;

    IoWriteErrorLogEntry(errorLogPacket);

    if (SpecificIoStatus == IO_WARNING_DUPLICATE_SIGNATURE) {
        diskCloneArrivalInfo.DiskNumber = deviceNumber.DeviceNumber;
        notification->Version = 1;
        notification->Size = (USHORT)
                             (FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION,
                                           CustomDataBuffer) +
                              sizeof(diskCloneArrivalInfo));
        RtlCopyMemory(&notification->Event, &GUID_IO_DISK_CLONE_ARRIVAL,
                      sizeof(GUID_IO_DISK_CLONE_ARRIVAL));
        notification->FileObject = NULL;
        notification->NameBufferOffset = -1;
        RtlCopyMemory(notification->CustomDataBuffer, &diskCloneArrivalInfo,
                      sizeof(diskCloneArrivalInfo));

        IoReportTargetDeviceChangeAsynchronous(WinningExtension->Pdo,
                                               notification, NULL, NULL);
    }
}

ULONG
PmQueryRegistrySignature(
    )

/*++

Routine Description:

    This routine checks a registry value for an MBR signature to be used
    for the bad signature case.  This is to facilitate OEM pre-install.

Arguments:

    None.

Return Value:

    A valid signature or 0.

--*/

{
    ULONG                       zero, signature;
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    NTSTATUS                    status;

    zero = 0;
    signature = 0;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[0].Name = L"BootDiskSig";
    queryTable[0].EntryContext = &signature;
    queryTable[0].DefaultType = REG_DWORD;
    queryTable[0].DefaultData = &zero;
    queryTable[0].DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    L"\\Registry\\Machine\\System\\Setup",
                                    queryTable, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        signature = zero;
    }

    RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                           L"\\Registry\\Machine\\System\\Setup",
                           L"BootDiskSig");

    return signature;
}

NTSTATUS
PmQueryRegistryGuidQueryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine queries the unique id for the given value.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Pointer to the DeviceExtension->BootPartitionGuid field.

    EntryContext    - Not used.

Return Value:

    NTSTATUS

--*/

{
    if ((REG_BINARY == ValueType) && (sizeof (GUID) == ValueLength)) {
        RtlCopyMemory (Context, ValueData, sizeof (GUID));
    } else {
        RtlCopyMemory (Context, &guidNull, sizeof (GUID));
    }

    return (STATUS_SUCCESS);
}
VOID
PmQueryRegistryGuid(
    IN  PDO_EXTENSION   DriverExtension
    )

/*++

Routine Description:

    This routine checks a registry value for an GPT partition GUID to be used
    for the bad signature case.  This is to facilitate OEM pre-install.

Arguments:

    None.

Return Value:

    A valid signature or 0.

--*/

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    NTSTATUS                    status;


    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));

    queryTable[0].QueryRoutine  = PmQueryRegistryGuidQueryRoutine;
    queryTable[0].Flags         = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name          = L"BootPartitionGuid";

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    L"\\Registry\\Machine\\System\\Setup",
                                    queryTable, 
                                    &DriverExtension->BootPartitionGuid, 
                                    NULL);

    if (NT_SUCCESS (status) && !IsEqualGUID (&guidNull, &DriverExtension->BootPartitionGuid)) {
        DriverExtension->BootPartitionGuidPresent = TRUE;
    } else {
        DriverExtension->BootPartitionGuid        = guidNull;
        DriverExtension->BootPartitionGuidPresent = FALSE;
    }

    RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                           L"\\Registry\\Machine\\System\\Setup",
                           L"BootPartitionGuid");
}

VOID
PmAddSignatures(
    IN  PDEVICE_EXTENSION               Extension,
    IN  PDRIVE_LAYOUT_INFORMATION_EX    Layout
    )

/*++

Routine Description:

    This routine adds the disk and partition signature to their
    respective tables.  If a collision is detected, the signatures are
    changed and written back out.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    NTSTATUS

--*/

{
    PDO_EXTENSION           driverExtension = Extension->DriverExtension;
    PLIST_ENTRY             l;
    PSIGNATURE_TABLE_ENTRY  s;
    PGUID_TABLE_ENTRY       g;
    SIGNATURE_TABLE_ENTRY   sigEntry;
    GUID_TABLE_ENTRY        guidEntry;
    NTSTATUS                status;
    PVOID                   nodeOrParent, nodeOrParent2;
    TABLE_SEARCH_RESULT     searchResult, searchResult2;
    UUID                    uuid;
    PULONG                  p;
    ULONG                   i;
    BOOLEAN                 hasBootPartitionType;

    while (!IsListEmpty(&Extension->SignatureList)) {
        l = RemoveHeadList(&Extension->SignatureList);
        s = CONTAINING_RECORD(l, SIGNATURE_TABLE_ENTRY, ListEntry);
        RtlDeleteElementGenericTable(&driverExtension->SignatureTable, s);
    }

    while (!IsListEmpty(&Extension->GuidList)) {
        l = RemoveHeadList(&Extension->GuidList);
        g = CONTAINING_RECORD(l, GUID_TABLE_ENTRY, ListEntry);
        RtlDeleteElementGenericTable(&driverExtension->GuidTable, g);
    }

    if (!Layout) {
        return;
    }

    if (Layout->PartitionStyle == PARTITION_STYLE_MBR) {

        if (!Layout->PartitionCount && !Layout->Mbr.Signature) {
            // RAW disk.  No signature to validate.
            return;
        }

        if (Layout->PartitionCount > 0 &&
            Layout->PartitionEntry[0].PartitionLength.QuadPart > 0 &&
            Layout->PartitionEntry[0].StartingOffset.QuadPart == 0) {

            // Super floppy.  No signature to validate.
            return;
        }

        sigEntry.Signature = Layout->Mbr.Signature;
        s = RtlLookupElementGenericTableFull(
                &driverExtension->SignatureTable, &sigEntry,
                &nodeOrParent, &searchResult);
        if (s || !sigEntry.Signature ||
            Extension->DriverExtension->BootDiskSig) {

            if (s) {
                if (PmIsRedundantPath(Extension, s->Extension,
                                      sigEntry.Signature, NULL)) {

                    PmLogError(Extension, s->Extension,
                               IO_WARNING_DUPLICATE_PATH);

                    Extension->IsRedundantPath = TRUE;
                    return;
                }

                PmLogError(Extension, s->Extension,
                           IO_WARNING_DUPLICATE_SIGNATURE);
            }

            if (Extension->DriverExtension->BootDiskSig) {
                Layout->Mbr.Signature =
                        Extension->DriverExtension->BootDiskSig;
                Extension->DriverExtension->BootDiskSig = 0;
            } else {
                status = ExUuidCreate(&uuid);
                if (!NT_SUCCESS(status)) {
                    Extension->IsRedundantPath = TRUE;
                    return;
                }

                p = (PULONG) &uuid;
                Layout->Mbr.Signature = p[0] ^ p[1] ^ p[2] ^ p[3];
            }
            sigEntry.Signature = Layout->Mbr.Signature;

            if (driverExtension->PastReinit) {
                status = PmWritePartitionTableEx(Extension->TargetObject,
                                                 Layout);
                if (!NT_SUCCESS(status)) {
                    Extension->IsRedundantPath = TRUE;
                    return;
                }
            } else {
                Extension->DiskSignature = Layout->Mbr.Signature;
            }

            RtlLookupElementGenericTableFull(
                &driverExtension->SignatureTable, &sigEntry,
                &nodeOrParent, &searchResult);
        }

        s = RtlInsertElementGenericTableFull(&driverExtension->SignatureTable,
                                             &sigEntry, sizeof(sigEntry), NULL,
                                             nodeOrParent, searchResult);
        if (!s) {
            return;
        }

        InsertTailList(&Extension->SignatureList, &s->ListEntry);
        s->Extension = Extension;

        return;
    }

    ASSERT(Layout->PartitionStyle == PARTITION_STYLE_GPT);

    if (Layout->PartitionStyle != PARTITION_STYLE_GPT) {
        return;
    }

    if (Extension->DriverExtension->PastReinit) {

        p = (PULONG) &Layout->Gpt.DiskId;
        sigEntry.Signature = p[0] ^ p[1] ^ p[2] ^ p[3];
        guidEntry.Guid = Layout->Gpt.DiskId;

        s = RtlLookupElementGenericTableFull(
                &driverExtension->SignatureTable, &sigEntry,
                &nodeOrParent, &searchResult);
        g = RtlLookupElementGenericTableFull(
                &driverExtension->GuidTable, &guidEntry,
                &nodeOrParent2, &searchResult2);
        if (s || g || !sigEntry.Signature) {

            if (g) {
                if (PmIsRedundantPath(Extension, g->Extension, 0,
                                      &guidEntry.Guid)) {

                    PmLogError(Extension, g->Extension,
                               IO_WARNING_DUPLICATE_PATH);

                    Extension->IsRedundantPath = TRUE;
                    return;
                }

                PmLogError(Extension, g->Extension,
                           IO_WARNING_DUPLICATE_SIGNATURE);
            }

            status = ExUuidCreate(&uuid);
            if (!NT_SUCCESS(status)) {
                Extension->IsRedundantPath = TRUE;
                return;
            }

            Layout->Gpt.DiskId = uuid;
            status = PmWritePartitionTableEx(Extension->TargetObject, Layout);
            if (!NT_SUCCESS(status)) {
                Extension->IsRedundantPath = TRUE;
                return;
            }

            p = (PULONG) &Layout->Gpt.DiskId;
            sigEntry.Signature = p[0] ^ p[1] ^ p[2] ^ p[3];
            guidEntry.Guid = Layout->Gpt.DiskId;

            RtlLookupElementGenericTableFull(
                    &driverExtension->SignatureTable, &sigEntry,
                    &nodeOrParent, &searchResult);
            RtlLookupElementGenericTableFull(
                    &driverExtension->GuidTable, &guidEntry,
                    &nodeOrParent2, &searchResult2);
        }

        s = RtlInsertElementGenericTableFull(
                &driverExtension->SignatureTable, &sigEntry,
                sizeof(sigEntry), NULL, nodeOrParent, searchResult);
        if (!s) {
            return;
        }

        InsertTailList(&Extension->SignatureList, &s->ListEntry);
        s->Extension = Extension;

        g = RtlInsertElementGenericTableFull(
                &driverExtension->GuidTable, &guidEntry,
                sizeof(guidEntry), NULL, nodeOrParent2, searchResult2);
        if (!g) {
            return;
        }

        InsertTailList(&Extension->GuidList, &g->ListEntry);
        g->Extension = Extension;
    }

    for (i = 0; i < Layout->PartitionCount; i++) {

        p = (PULONG) &Layout->PartitionEntry[i].Gpt.PartitionId;
        sigEntry.Signature = p[0] | p[1] | p[2] | p[3];
        guidEntry.Guid = Layout->PartitionEntry[i].Gpt.PartitionId;

        if (driverExtension->BootPartitionGuidPresent) {

            hasBootPartitionType = 
                IsEqualGUID(&Layout->PartitionEntry[i].Gpt.PartitionType, &PARTITION_BASIC_DATA_GUID) || 
                IsEqualGUID(&Layout->PartitionEntry[i].Gpt.PartitionType, &PARTITION_LDM_DATA_GUID);
        }


        g = RtlLookupElementGenericTableFull(
                &driverExtension->GuidTable, &guidEntry,
                &nodeOrParent, &searchResult);
        if (g || !sigEntry.Signature ||
            (driverExtension->BootPartitionGuidPresent && hasBootPartitionType)) {

            if (driverExtension->BootPartitionGuidPresent && hasBootPartitionType) {
                uuid = Extension->DriverExtension->BootPartitionGuid;
                driverExtension->BootPartitionGuidPresent = FALSE;
            } else {
                status = ExUuidCreate(&uuid);
                if (!NT_SUCCESS(status)) {
                    Extension->IsRedundantPath = TRUE;
                    return;
                }
            }

            Layout->PartitionEntry[i].Gpt.PartitionId = uuid;
            status = PmWritePartitionTableEx(Extension->TargetObject, Layout);
            if (!NT_SUCCESS(status)) {
                Extension->IsRedundantPath = TRUE;
                return;
            }

            guidEntry.Guid = Layout->PartitionEntry[i].Gpt.PartitionId;

            RtlLookupElementGenericTableFull(
                    &driverExtension->GuidTable, &guidEntry,
                    &nodeOrParent, &searchResult);
        }

        g = RtlInsertElementGenericTableFull(
                &driverExtension->GuidTable, &guidEntry,
                sizeof(guidEntry), NULL, nodeOrParent, searchResult);
        if (!g) {
            return;
        }

        InsertTailList(&Extension->GuidList, &g->ListEntry);
        g->Extension = Extension;
    }
}

NTSTATUS
PmPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_PNP.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION               extension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    KEVENT                          event;
    NTSTATUS                        status;
    PDEVICE_OBJECT                  targetObject;
    PDRIVE_LAYOUT_INFORMATION_EX    layout;
    LIST_ENTRY                      completionList;
    ULONG                           wmiRegistrationFlags;

    if (irpSp->MinorFunction == IRP_MN_DEVICE_USAGE_NOTIFICATION &&
        irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging) {

        ULONG count;
        BOOLEAN setPagable;

        //
        // synchronize these irps.
        //

        KeWaitForSingleObject(&extension->PagingPathCountEvent,
                              Executive, KernelMode, FALSE, NULL);

        //
        // if removing last paging device, need to set DO_POWER_PAGABLE
        // bit here, and possible re-set it below on failure.
        //

        setPagable = FALSE;
        if (!irpSp->Parameters.UsageNotification.InPath &&
            extension->PagingPathCount == 0 ) {

            //
            // removing a paging file. if last removal,
            // must have DO_POWER_PAGABLE bits set
            //

            if (extension->PagingPathCount == 0) {
                if (!(DeviceObject->Flags & DO_POWER_INRUSH)) {
                    DeviceObject->Flags |= DO_POWER_PAGABLE;
                    setPagable = TRUE;
                }
            }

        }

        //
        // send the irp synchronously
        //

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, PmSignalCompletion, &event, TRUE, TRUE, TRUE);
        status = IoCallDriver(extension->TargetObject, Irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = Irp->IoStatus.Status;
        }

        //
        // now deal with the failure and success cases.
        // note that we are not allowed to fail the irp
        // once it is sent to the lower drivers.
        //

        if (NT_SUCCESS(status)) {

            IoAdjustPagingPathCount(
                &extension->PagingPathCount,
                irpSp->Parameters.UsageNotification.InPath);

            if (irpSp->Parameters.UsageNotification.InPath) {

                if (extension->PagingPathCount == 1) {
                    DeviceObject->Flags &= ~DO_POWER_PAGABLE;
                }
            }

        } else {

            //
            // cleanup the changes done above
            //

            if (setPagable == TRUE) {
                DeviceObject->Flags &= ~DO_POWER_PAGABLE;
                setPagable = FALSE;
            }

        }

        //
        // set the event so the next one can occur.
        //

        KeSetEvent(&extension->PagingPathCountEvent,
                   IO_NO_INCREMENT, FALSE);

        //
        // and complete the irp
        //
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;

    }

    if (extension->TargetObject->Characteristics & FILE_REMOVABLE_MEDIA) {

        targetObject = extension->TargetObject;

        if (IRP_MN_REMOVE_DEVICE == irpSp->MinorFunction) {

            KeWaitForSingleObject (&extension->DriverExtension->Mutex, 
                                   Executive,
                                   KernelMode, 
                                   FALSE,
                                   NULL);

            if (extension->WmilibContext != NULL) { 
                IoWMIRegistrationControl (extension->DeviceObject, WMIREG_ACTION_DEREGISTER);
                ExFreePool (extension->WmilibContext);
                extension->WmilibContext = NULL;
                PmWmiCounterDisable (&extension->PmWmiCounterContext, TRUE, TRUE);
                extension->CountersEnabled = FALSE;
            }

            RemoveEntryList (&extension->ListEntry);
            KeReleaseMutex (&extension->DriverExtension->Mutex, FALSE);

            IoDetachDevice (targetObject);
            IoDeleteDevice (extension->DeviceObject);
            }

        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(targetObject, Irp);
    }

    switch (irpSp->MinorFunction) {

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            switch (irpSp->Parameters.QueryDeviceRelations.Type) {
                case BusRelations:
                    status = PmQueryDeviceRelations(extension, Irp);
                    break;

                case RemovalRelations:
                    status = PmQueryRemovalRelations(extension, Irp);
                    break;

                default:
                    IoSkipCurrentIrpStackLocation(Irp);
                    return IoCallDriver(extension->TargetObject, Irp);

            }
            break;

        case IRP_MN_START_DEVICE:
            KeInitializeEvent(&event, NotificationEvent, FALSE);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp, PmSignalCompletion, &event,
                                   TRUE, TRUE, TRUE);
            IoCallDriver(extension->TargetObject, Irp);
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = Irp->IoStatus.Status;

            if (!NT_SUCCESS(status)) {
                break;
            }

            if (extension->TargetObject->Characteristics&
                FILE_REMOVABLE_MEDIA) {

                break;
            }

            PmDetermineDeviceNameAndNumber (DeviceObject, &wmiRegistrationFlags);


            LockDriver (extension->DriverExtension);
            extension->IsStarted = TRUE;
            UnlockDriver (extension->DriverExtension);

            PmCheckAndUpdateSignature (extension, TRUE, TRUE);


            //
            // Register its existence with WMI
            //
            PmRegisterDevice(DeviceObject, wmiRegistrationFlags);
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_CANCEL_STOP_DEVICE:
        case IRP_MN_STOP_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            status = PmNotifyPartitions(extension, Irp);
            if (!NT_SUCCESS(status)) {
                break;
            }

            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(extension->TargetObject, Irp);

        case IRP_MN_SURPRISE_REMOVAL:
        case IRP_MN_REMOVE_DEVICE:

            //
            // Notify all the children of their imminent removal.
            //

            PmRemoveDevice(extension, Irp);
            targetObject = extension->TargetObject;

            if (irpSp->MinorFunction == IRP_MN_REMOVE_DEVICE) {
                status = IoAcquireRemoveLock (&extension->RemoveLock, Irp);
                ASSERT(NT_SUCCESS(status));
                IoReleaseRemoveLockAndWait(&extension->RemoveLock, Irp);
                IoDetachDevice(targetObject);
                IoDeleteDevice(extension->DeviceObject);
            }

            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(targetObject, Irp);

        default:
            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(extension->TargetObject, Irp);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
PmAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates and initializes a new FDO for the corresponding
    PDO.

Arguments:

    DriverObject            - Supplies the FTDISK driver object.

    PhysicalDeviceObject    - Supplies the physical device object.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_OBJECT      attachedDevice;
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   extension;

    attachedDevice = IoGetAttachedDeviceReference(PhysicalDeviceObject);
    if (attachedDevice) {
        if (attachedDevice->Characteristics&FILE_REMOVABLE_MEDIA) {
            ObDereferenceObject(attachedDevice);
            return STATUS_SUCCESS;
        }
        ObDereferenceObject(attachedDevice);
    }

    status = IoCreateDevice(DriverObject, sizeof(DEVICE_EXTENSION),
                            NULL, FILE_DEVICE_UNKNOWN, 0, FALSE, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    deviceObject->Flags |= DO_DIRECT_IO;

    //
    // the storage stack explicitly requires DO_POWER_PAGABLE to be
    // set in all filter drivers *unless* DO_POWER_INRUSH is set.
    // this is true even if the attached device doesn't set DO_POWER_PAGABLE
    //
    if (attachedDevice->Flags & DO_POWER_INRUSH) {
        deviceObject->Flags |= DO_POWER_INRUSH;
    } else {
        deviceObject->Flags |= DO_POWER_PAGABLE;
    }

    extension = deviceObject->DeviceExtension;
    RtlZeroMemory(extension, sizeof(DEVICE_EXTENSION));
    extension->DeviceObject = deviceObject;
    extension->DriverExtension = IoGetDriverObjectExtension(DriverObject,
                                                            PmAddDevice);
    extension->TargetObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);
    if (!extension->TargetObject) {
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }
    extension->Pdo = PhysicalDeviceObject;
    InitializeListHead(&extension->PartitionList);
    KeInitializeEvent(&extension->PagingPathCountEvent,
                      SynchronizationEvent, TRUE);
    InitializeListHead(&extension->SignatureList);
    InitializeListHead(&extension->GuidList);

    LockDriver (extension->DriverExtension);
    InsertTailList(&extension->DriverExtension->DeviceExtensionList,
                   &extension->ListEntry);
    UnlockDriver (extension->DriverExtension);

    deviceObject->DeviceType = extension->TargetObject->DeviceType;

    deviceObject->AlignmentRequirement =
            extension->TargetObject->AlignmentRequirement;

    extension->PhysicalDeviceName.Buffer
            = extension->PhysicalDeviceNameBuffer;

    // Allocate WMI library context

    extension->WmilibContext =
        ExAllocatePoolWithTag(PagedPool, sizeof(WMILIB_CONTEXT),
                                          PARTMGR_TAG_PARTITION_ENTRY);
    if (extension->WmilibContext != NULL)
    {
        RtlZeroMemory(extension->WmilibContext, sizeof(WMILIB_CONTEXT));
        extension->WmilibContext->GuidCount          = DiskperfGuidCount;
        extension->WmilibContext->GuidList           = DiskperfGuidList;
        extension->WmilibContext->QueryWmiRegInfo    = PmQueryWmiRegInfo;
        extension->WmilibContext->QueryWmiDataBlock  = PmQueryWmiDataBlock;
        extension->WmilibContext->WmiFunctionControl = PmWmiFunctionControl;
    }


    KeInitializeSpinLock(&extension->SpinLock);
    InitializeListHead(&extension->PowerQueue);    

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    IoInitializeRemoveLock (&extension->RemoveLock, PARTMGR_TAG_REMOVE_LOCK,
                            2, 5); 

    return STATUS_SUCCESS;
}

VOID
PmUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )

/*++

Routine Description:

    This routine unloads.

Arguments:

    DriverObject    - Supplies the driver object.

Return Value:

    None.

--*/

{
    PDO_EXTENSION   driverExtension;
    PDEVICE_OBJECT  deviceObject;

    while (deviceObject = DriverObject->DeviceObject) {
        IoDeleteDevice(deviceObject);
    }

    driverExtension = IoGetDriverObjectExtension(DriverObject, PmAddDevice);
    if (driverExtension) {
        IoUnregisterPlugPlayNotification(driverExtension->NotificationEntry);
    }
}

NTSTATUS
PmVolumeManagerNotification(
    IN  PVOID   NotificationStructure,
    IN  PVOID   DriverExtension
    )

/*++

Routine Description:

    This routine is called whenever a volume comes or goes.

Arguments:

    NotificationStructure   - Supplies the notification structure.

    RootExtension           - Supplies the root extension.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_INTERFACE_CHANGE_NOTIFICATION   notification = (PDEVICE_INTERFACE_CHANGE_NOTIFICATION) NotificationStructure;
    PDO_EXTENSION                           driverExtension = (PDO_EXTENSION) DriverExtension;
    PVOLMGR_LIST_ENTRY                      volmgrEntry;
    NTSTATUS                                status;
    PLIST_ENTRY                             l, ll;
    PDEVICE_EXTENSION                       extension;
    PPARTITION_LIST_ENTRY                   partition;
    PMWMICOUNTERLIB_CONTEXT                 input;
    PIRP                                    irp;
    KEVENT                                  event;
    IO_STATUS_BLOCK                         ioStatus;
    PFILE_OBJECT                            fileObject;
    PDEVICE_OBJECT                          deviceObject;

    LockDriver (driverExtension);

    if (IsEqualGUID(&notification->Event, &GUID_DEVICE_INTERFACE_ARRIVAL)) {

        for (l = driverExtension->VolumeManagerList.Flink;
             l != &driverExtension->VolumeManagerList; l = l->Flink) {

            volmgrEntry = CONTAINING_RECORD(l, VOLMGR_LIST_ENTRY, ListEntry);
            if (RtlEqualUnicodeString(notification->SymbolicLinkName,
                                      &volmgrEntry->VolumeManagerName,
                                      TRUE)) {

                UnlockDriver (driverExtension);
                return STATUS_SUCCESS;
            }
        }

        volmgrEntry = (PVOLMGR_LIST_ENTRY)
                      ExAllocatePoolWithTag(NonPagedPool,
                                            sizeof(VOLMGR_LIST_ENTRY),
                                            PARTMGR_TAG_VOLUME_ENTRY
                                            );
        if (!volmgrEntry) {
            UnlockDriver (driverExtension);
            return STATUS_SUCCESS;
        }

        volmgrEntry->VolumeManagerName.Length =
                notification->SymbolicLinkName->Length;
        volmgrEntry->VolumeManagerName.MaximumLength =
                volmgrEntry->VolumeManagerName.Length + sizeof(WCHAR);
        volmgrEntry->VolumeManagerName.Buffer = ExAllocatePoolWithTag(
                PagedPool, volmgrEntry->VolumeManagerName.MaximumLength,
                PARTMGR_TAG_VOLUME_ENTRY);
        if (!volmgrEntry->VolumeManagerName.Buffer) {
            ExFreePool(volmgrEntry);
            UnlockDriver (driverExtension);
            return STATUS_SUCCESS;
        }
        RtlCopyMemory(volmgrEntry->VolumeManagerName.Buffer,
                      notification->SymbolicLinkName->Buffer,
                      volmgrEntry->VolumeManagerName.Length);
        volmgrEntry->VolumeManagerName.Buffer[
                volmgrEntry->VolumeManagerName.Length/sizeof(WCHAR)] = 0;

        volmgrEntry->RefCount = 0;
        InsertTailList(&driverExtension->VolumeManagerList,
                       &volmgrEntry->ListEntry);
        volmgrEntry->VolumeManager = NULL;
        volmgrEntry->VolumeManagerFileObject = NULL;

        status = IoGetDeviceObjectPointer(&volmgrEntry->VolumeManagerName,
                                          FILE_READ_DATA, &fileObject,
                                          &deviceObject);

        if (NT_SUCCESS(status)) {
            input.PmWmiCounterEnable     = PmWmiCounterEnable;
            input.PmWmiCounterDisable    = PmWmiCounterDisable;
            input.PmWmiCounterIoStart    = PmWmiCounterIoStart;
            input.PmWmiCounterIoComplete = PmWmiCounterIoComplete;
            input.PmWmiCounterQuery      = PmWmiCounterQuery;

            KeInitializeEvent(&event, NotificationEvent, FALSE);

            irp = IoBuildDeviceIoControlRequest(
                    IOCTL_INTERNAL_VOLMGR_PMWMICOUNTERLIB_CONTEXT,
                    deviceObject, &input, sizeof(input), NULL, 0, TRUE,
                    &event, &ioStatus);

            if (irp) {
                status = IoCallDriver(deviceObject, irp);
                if (status == STATUS_PENDING) {
                    KeWaitForSingleObject(&event, Executive, KernelMode,
                                          FALSE, NULL);
                }
            }

            ObDereferenceObject(fileObject);
        }

        for (l = driverExtension->DeviceExtensionList.Flink;
             l != &driverExtension->DeviceExtensionList; l = l->Flink) {

            extension = CONTAINING_RECORD(l, DEVICE_EXTENSION, ListEntry);

            if (extension->IsRedundantPath) {
                continue;
            }

            for (ll = extension->PartitionList.Flink;
                 ll != &extension->PartitionList; ll = ll->Flink) {

                partition = CONTAINING_RECORD(ll, PARTITION_LIST_ENTRY,
                                              ListEntry);

                if (!partition->VolumeManagerEntry) {
                    status = PmGivePartition(volmgrEntry,
                                             partition->TargetObject,
                                             partition->WholeDiskPdo);
                    if (NT_SUCCESS(status)) {
                        partition->VolumeManagerEntry = volmgrEntry;
                    }
                }
            }
        }

        status = STATUS_SUCCESS;

    } else if (IsEqualGUID(&notification->Event,
                           &GUID_DEVICE_INTERFACE_REMOVAL)) {

        for (l = driverExtension->VolumeManagerList.Flink;
             l != &driverExtension->VolumeManagerList; l = l->Flink) {

            volmgrEntry = CONTAINING_RECORD(l, VOLMGR_LIST_ENTRY, ListEntry);
            if (RtlEqualUnicodeString(&volmgrEntry->VolumeManagerName,
                                      notification->SymbolicLinkName, TRUE)) {

                if (!volmgrEntry->RefCount) {
                    RemoveEntryList(l);
                    ExFreePool(volmgrEntry->VolumeManagerName.Buffer);
                    ExFreePool(volmgrEntry);
                }
                break;
            }
        }

        status = STATUS_SUCCESS;

    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    UnlockDriver (driverExtension);

    return STATUS_SUCCESS;
}

NTSTATUS
PmGetPartitionInformation(
    IN  PDEVICE_OBJECT  Partition,
    IN  PFILE_OBJECT    FileObject,
    OUT PLONGLONG       PartitionOffset,
    OUT PLONGLONG       PartitionLength
    )

{
    KEVENT                  event;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpSp;
    PARTITION_INFORMATION   partInfo;
    IO_STATUS_BLOCK         ioStatus;
    NTSTATUS                status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO,
                                        Partition, NULL, 0, &partInfo,
                                        sizeof(partInfo), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->FileObject = FileObject;

    status = IoCallDriver(Partition, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    *PartitionOffset = partInfo.StartingOffset.QuadPart;
    *PartitionLength = partInfo.PartitionLength.QuadPart;

    return status;
}

VOID
PmDriverReinit(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PVOID           DriverExtension,
    IN  ULONG           Count
    )

{
    PDO_EXTENSION                   driverExtension = DriverExtension;
    PLIST_ENTRY                     l, ll;
    PDEVICE_EXTENSION               extension;
    PPARTITION_LIST_ENTRY           partition;
    NTSTATUS                        status;
    PDRIVE_LAYOUT_INFORMATION_EX    layout;


    LockDriver (driverExtension);

    InterlockedExchange(&driverExtension->PastReinit, TRUE);

    for (l = driverExtension->DeviceExtensionList.Flink;
         l != &driverExtension->DeviceExtensionList; l = l->Flink) {

        extension = CONTAINING_RECORD(l, DEVICE_EXTENSION, ListEntry);

        if (extension->TargetObject->Characteristics&FILE_REMOVABLE_MEDIA) {
            continue;
        }

        if (!extension->IsStarted) {
            continue;
        }

        for (ll = extension->PartitionList.Flink;
             ll != &extension->PartitionList; ll = ll->Flink) {

            partition = CONTAINING_RECORD(ll, PARTITION_LIST_ENTRY,
                                          ListEntry);

            partition->TargetObject->Flags |= DO_DEVICE_INITIALIZING;
        }

        status = PmReadPartitionTableEx(extension->TargetObject, &layout);
        if (!NT_SUCCESS(status)) {
            continue;
        }

        if (extension->DiskSignature) {
            if (layout->PartitionStyle == PARTITION_STYLE_MBR) {
                layout->Mbr.Signature = extension->DiskSignature;
                PmWritePartitionTableEx(extension->TargetObject, layout);
            }
            extension->DiskSignature = 0;
        }

        if (layout->PartitionStyle == PARTITION_STYLE_GPT) {
            PmAddSignatures(extension, layout);
        }

        ExFreePool(layout);
    }

    UnlockDriver (driverExtension);
}

VOID
PmBootDriverReinit(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PVOID           DriverExtension,
    IN  ULONG           Count
    )

{
    IoRegisterDriverReinitialization(DriverObject, PmDriverReinit,
                                     DriverExtension);    
}

NTSTATUS
PmCheckForUnclaimedPartitions(
    IN  PDEVICE_OBJECT  DeviceObject
    )

{
    PDEVICE_EXTENSION       extension = DeviceObject->DeviceExtension;
    PDO_EXTENSION           driverExtension = extension->DriverExtension;
    NTSTATUS                status, status2;
    PLIST_ENTRY             l, ll;
    PPARTITION_LIST_ENTRY   partition;
    PVOLMGR_LIST_ENTRY      volmgrEntry;

    LockDriver (driverExtension);

    if (extension->IsRedundantPath) {
        UnlockDriver (driverExtension);
        return STATUS_SUCCESS;
    }

    status = STATUS_SUCCESS;
    for (l = extension->PartitionList.Flink; l != &extension->PartitionList;
         l = l->Flink) {

        partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);
        if (partition->VolumeManagerEntry) {
            continue;
        }

        for (ll = driverExtension->VolumeManagerList.Flink;
             ll != &driverExtension->VolumeManagerList; ll = ll->Flink) {

            volmgrEntry = CONTAINING_RECORD(ll, VOLMGR_LIST_ENTRY, ListEntry);

            status2 = PmGivePartition(volmgrEntry,
                                      partition->TargetObject,
                                      partition->WholeDiskPdo);

            if (NT_SUCCESS(status2)) {
                partition->VolumeManagerEntry = volmgrEntry;
                break;
            }
        }

        if (ll == &driverExtension->VolumeManagerList) {
            status = STATUS_UNSUCCESSFUL;
        }
    }

    UnlockDriver (driverExtension);

    return status;
}

NTSTATUS
PmDiskGrowPartition(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

{
    PDEVICE_EXTENSION       extension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PDISK_GROW_PARTITION    input;
    NTSTATUS                status;
    PPARTITION_LIST_ENTRY   partition;
    KEVENT                  event;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(DISK_GROW_PARTITION)) {

        return STATUS_INVALID_PARAMETER;
    }

    LockDriver (extension->DriverExtension);

    input = (PDISK_GROW_PARTITION) Irp->AssociatedIrp.SystemBuffer;

    status = PmFindPartition(extension, input->PartitionNumber, &partition);
    if (!NT_SUCCESS(status)) {
        UnlockDriver (extension->DriverExtension);
        return status;
    }

    status = PmChangePartitionIoctl(extension, partition,
             IOCTL_INTERNAL_VOLMGR_QUERY_CHANGE_PARTITION);
    if (!NT_SUCCESS(status)) {
        UnlockDriver (extension->DriverExtension);
        return status;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, PmSignalCompletion, &event, TRUE, TRUE, TRUE);
    IoCallDriver(extension->TargetObject, Irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    status = Irp->IoStatus.Status;

    if (NT_SUCCESS(status)) {
        PmChangePartitionIoctl(extension, partition,
                               IOCTL_INTERNAL_VOLMGR_PARTITION_CHANGED);
    } else {
        PmChangePartitionIoctl(extension, partition,
                               IOCTL_INTERNAL_VOLMGR_CANCEL_CHANGE_PARTITION);
    }

    UnlockDriver (extension->DriverExtension);

    return status;
}

NTSTATUS
PmEjectVolumeManagers(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine goes through the list of partitions for the given disk
    and takes the partition away from the owning volume managers.  It then
    goes through initial arbitration for each partition on the volume.

    This has the effect that each volume manager forgets any cached disk
    information and then start fresh on the disk as it may have been changed
    by another cluster member.

Arguments:

    DeviceObject    - Supplies the device object.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION       extension = DeviceObject->DeviceExtension;
    PDO_EXTENSION           driverExtension = extension->DriverExtension;
    PPARTITION_LIST_ENTRY   partition;
    PLIST_ENTRY             l;
    PVOLMGR_LIST_ENTRY      volmgrEntry;

    LockDriver (driverExtension);

    for (l = extension->PartitionList.Flink; l != &extension->PartitionList;
         l = l->Flink) {

        partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);
        if (!partition->VolumeManagerEntry) {
            continue;
        }

        PmTakePartition(partition->VolumeManagerEntry,
                        partition->TargetObject, NULL);

        partition->VolumeManagerEntry = NULL;
    }

    for (l = driverExtension->VolumeManagerList.Flink;
         l != &driverExtension->VolumeManagerList; l = l->Flink) {

        volmgrEntry = CONTAINING_RECORD(l, VOLMGR_LIST_ENTRY, ListEntry);
        PmTakeWholeDisk(volmgrEntry, extension->Pdo);
    }

    UnlockDriver (driverExtension);

    return STATUS_SUCCESS;
}

NTSTATUS
PmQueryDiskSignature(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine returns the disk signature for the disk.  If the
    volume is not an MBR disk then this call will fail.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION               extension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PPARTMGR_DISK_SIGNATURE         partSig = Irp->AssociatedIrp.SystemBuffer;
    NTSTATUS                        status;
    PDRIVE_LAYOUT_INFORMATION_EX    layout;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(PARTMGR_DISK_SIGNATURE)) {

        return STATUS_INVALID_PARAMETER;
    }

    Irp->IoStatus.Information = sizeof(PARTMGR_DISK_SIGNATURE);

    if (extension->DiskSignature) {
        partSig->Signature = extension->DiskSignature;
        return STATUS_SUCCESS;
    }

    status = PmReadPartitionTableEx(extension->TargetObject, &layout);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 0;
        return status;
    }

    if (layout->PartitionStyle != PARTITION_STYLE_MBR) {
        ExFreePool(layout);
        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    partSig->Signature = layout->Mbr.Signature;

    ExFreePool(layout);

    return status;
}

NTSTATUS
PmDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_PNP.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION               extension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    KEVENT                          event;
    NTSTATUS                        status;
    PDRIVE_LAYOUT_INFORMATION       layout;
    PDRIVE_LAYOUT_INFORMATION_EX    newLayout;
    BOOLEAN                         issueSigCheckNotification;
    LIST_ENTRY                      completionList;

    if (extension->TargetObject->Characteristics&FILE_REMOVABLE_MEDIA) {
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(extension->TargetObject, Irp);
    }


    
    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_DISK_SET_DRIVE_LAYOUT:
        case IOCTL_DISK_SET_DRIVE_LAYOUT_EX:
        case IOCTL_DISK_CREATE_DISK:
        case IOCTL_DISK_DELETE_DRIVE_LAYOUT:
        case IOCTL_DISK_UPDATE_PROPERTIES:


            LockDriver (extension->DriverExtension);

            issueSigCheckNotification = !extension->SignaturesNotChecked || 
                                        (IOCTL_DISK_UPDATE_PROPERTIES == 
                                         irpSp->Parameters.DeviceIoControl.IoControlCode);

            extension->SignaturesNotChecked = TRUE;

            UnlockDriver (extension->DriverExtension);


            KeInitializeEvent(&event, NotificationEvent, FALSE);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp, PmSignalCompletion, &event, TRUE,
                                   TRUE, TRUE);
            IoCallDriver(extension->TargetObject, Irp);
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                  NULL);

            status = Irp->IoStatus.Status;

            if (NT_SUCCESS(status)) {
                status = PmCheckAndUpdateSignature (extension, 
                                                    issueSigCheckNotification, 
                                                    TRUE);
            }

            break;


        case IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS:
            status = PmCheckForUnclaimedPartitions(DeviceObject);
            Irp->IoStatus.Information = 0;
            break;

        case IOCTL_DISK_GROW_PARTITION:
            status = PmDiskGrowPartition(DeviceObject, Irp);
            break;

        case IOCTL_PARTMGR_EJECT_VOLUME_MANAGERS:
            status = PmEjectVolumeManagers(DeviceObject);
            break;

        case IOCTL_PARTMGR_NOTIFY_SIGNATURE_CHECK:
            status = PmSigCheckNotificationInsert (extension, Irp);

            if (STATUS_PENDING == status) {
                return (STATUS_PENDING);                    
	    }

            break;

        case IOCTL_DISK_PERFORMANCE:
            //
            // Verify user buffer is large enough for the performance data.
            //

            status = STATUS_SUCCESS;
            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(DISK_PERFORMANCE)) {

                //
                // Indicate unsuccessful status and no data transferred.
                //

                status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = 0;
            }
            else if (!(extension->CountersEnabled)) {
                if (!PmQueryEnableAlways(DeviceObject)) {
                    status = STATUS_UNSUCCESSFUL;
                    Irp->IoStatus.Information = 0;
                }
            }
            if (status == STATUS_SUCCESS) {
                PmWmiCounterQuery(extension->PmWmiCounterContext,
                                  (PDISK_PERFORMANCE) Irp->AssociatedIrp.SystemBuffer,
                                  L"Partmgr ",
                                  extension->DiskNumber);
                Irp->IoStatus.Information = sizeof(DISK_PERFORMANCE);
            }
            break;

        case IOCTL_DISK_PERFORMANCE_OFF:
            //
            // Turns off counting
            //
            if (extension->CountersEnabled) {
                if (InterlockedCompareExchange(&extension->EnableAlways, 0, 1) == 1) {
                    if (!PmWmiCounterDisable(&extension->PmWmiCounterContext, FALSE, FALSE)) {
                        extension->CountersEnabled = FALSE;
                    }
                }
            }
            Irp->IoStatus.Information = 0;
            status = STATUS_SUCCESS;
            break;

        case IOCTL_PARTMGR_QUERY_DISK_SIGNATURE:
        case IOCTL_DISK_GET_DRIVE_LAYOUT:
        case IOCTL_DISK_GET_DRIVE_LAYOUT_EX:

            status = PmCheckAndUpdateSignature (extension, TRUE, FALSE);

            if (NT_SUCCESS (status) && 
                (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_PARTMGR_QUERY_DISK_SIGNATURE)) {

                status = PmQueryDiskSignature(DeviceObject, Irp);
                break;
            }

            // Fall through.

        default:
            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(extension->TargetObject, Irp);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

RTL_GENERIC_COMPARE_RESULTS
PmTableSignatureCompareRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               First,
    IN  PVOID               Second
    )

{
    PSIGNATURE_TABLE_ENTRY  f = First;
    PSIGNATURE_TABLE_ENTRY  s = Second;

    if (f->Signature < s->Signature) {
        return GenericLessThan;
    }

    if (f->Signature > s->Signature) {
        return GenericGreaterThan;
    }

    return GenericEqual;
}

RTL_GENERIC_COMPARE_RESULTS
PmTableGuidCompareRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               First,
    IN  PVOID               Second
    )

{
    PGUID_TABLE_ENTRY   f = First;
    PGUID_TABLE_ENTRY   s = Second;
    PULONGLONG          p1, p2;

    p1 = (PULONGLONG) &f->Guid;
    p2 = (PULONGLONG) &s->Guid;

    if (p1[0] < p2[0]) {
        return GenericLessThan;
    }

    if (p1[0] > p2[0]) {
        return GenericGreaterThan;
    }

    if (p1[1] < p2[1]) {
        return GenericLessThan;
    }

    if (p1[1] > p2[1]) {
        return GenericGreaterThan;
    }

    return GenericEqual;
}

PVOID
PmTableAllocateRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  CLONG               Size
    )

{
    return ExAllocatePoolWithTag(PagedPool, Size, PARTMGR_TAG_TABLE_ENTRY);
}

VOID
PmTableFreeRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               Buffer
    )

{
    ExFreePool(Buffer);
}

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the entry point for the driver.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    NTSTATUS

--*/

{
    ULONG           i;
    NTSTATUS        status;
    PDO_EXTENSION   driverExtension;
    PDEVICE_OBJECT  deviceObject;

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = PmPassThrough;
    }

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = PmDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP] = PmPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = PmPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PmWmi;
    DriverObject->MajorFunction[IRP_MJ_READ] = PmReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = PmReadWrite;

    DriverObject->DriverExtension->AddDevice = PmAddDevice;
    DriverObject->DriverUnload = PmUnload;

    status = IoAllocateDriverObjectExtension(DriverObject, PmAddDevice,
                                             sizeof(DO_EXTENSION),
                                             &driverExtension);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    driverExtension->DiskPerfRegistryPath.MaximumLength =
        RegistryPath->Length + sizeof(UNICODE_NULL);
    driverExtension->DiskPerfRegistryPath.Buffer =
        ExAllocatePoolWithTag(
            PagedPool,
            driverExtension->DiskPerfRegistryPath.MaximumLength,
            PARTMGR_TAG_PARTITION_ENTRY);
    if (driverExtension->DiskPerfRegistryPath.Buffer != NULL)
    {
        RtlCopyUnicodeString(&driverExtension->DiskPerfRegistryPath,
                             RegistryPath);
    } else {
        driverExtension->DiskPerfRegistryPath.Length = 0;
        driverExtension->DiskPerfRegistryPath.MaximumLength = 0;
    }

    driverExtension->DriverObject = DriverObject;
    driverExtension->CurrentEpochNumber = 0;
    InitializeListHead(&driverExtension->VolumeManagerList);
    InitializeListHead(&driverExtension->DeviceExtensionList);
    InitializeListHead(&driverExtension->SignatureCheckNotificationIrpQueue);  

    KeInitializeMutex(&driverExtension->Mutex, 0);
    driverExtension->PastReinit = FALSE;

    RtlInitializeGenericTable(&driverExtension->SignatureTable,
                              PmTableSignatureCompareRoutine,
                              PmTableAllocateRoutine,
                              PmTableFreeRoutine, driverExtension);

    RtlInitializeGenericTable(&driverExtension->GuidTable,
                              PmTableGuidCompareRoutine,
                              PmTableAllocateRoutine,
                              PmTableFreeRoutine, driverExtension);    

    IoRegisterBootDriverReinitialization(DriverObject, PmBootDriverReinit,
                                         driverExtension);    

    status = IoRegisterPlugPlayNotification(
             EventCategoryDeviceInterfaceChange,
             PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
             (PVOID) &VOLMGR_VOLUME_MANAGER_GUID, DriverObject,
             PmVolumeManagerNotification, driverExtension,
             &driverExtension->NotificationEntry);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    driverExtension->BootDiskSig = PmQueryRegistrySignature();
    PmQueryRegistryGuid(driverExtension);

    return STATUS_SUCCESS;
}

NTSTATUS
PmBuildDependantVolumeRelations(
    IN  PDEVICE_EXTENSION Extension,
    OUT PDEVICE_RELATIONS *Relations
    )
/*++

Routine Description:

    This routine builds a list of volumes which are dependant on a given
    physical disk.  This list can be used for reporting removal relations
    to the pnp system.

Arguments:

    Extension   - Supplies the device extension for the pm filter.

    Relations   - Supplies a location to store the relations list.

Return Value:

    NTSTATUS

--*/

{
    ULONG                   partitionCount;
    PIRP                    irp;
    PDEVICE_RELATIONS       relationsList;
    PDEVICE_RELATIONS       combinedList;

    ULONG                   dependantVolumeCount = 0;

    PLIST_ENTRY             l;
    PPARTITION_LIST_ENTRY   partition;
    NTSTATUS                status = STATUS_SUCCESS;
    ULONG i;

    KEVENT event;

    PAGED_CODE();

    LockDriver (Extension->DriverExtension);

    //
    // Count the number of partitions we know about.  If there aren't any then
    // there aren't any relations either.
    //

    for(l = Extension->PartitionList.Flink, partitionCount = 0;
        l != &(Extension->PartitionList);
        l = l->Flink, partitionCount++);

    //
    // Allocate the relations list.
    //

    relationsList = ExAllocatePoolWithTag(
                        PagedPool,
                        (sizeof(DEVICE_RELATIONS) +
                        (sizeof(PDEVICE_RELATIONS) * partitionCount)),
                        PARTMGR_TAG_DEPENDANT_VOLUME_LIST);

    if(relationsList== NULL) {
        UnlockDriver (Extension->DriverExtension);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(relationsList, (sizeof(DEVICE_RELATIONS) +
                                  sizeof(PDEVICE_OBJECT) * partitionCount));

    if(partitionCount == 0) {
        *Relations = relationsList;
        UnlockDriver (Extension->DriverExtension);
        return STATUS_SUCCESS;
    }

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    for(l = Extension->PartitionList.Flink, i = 0, dependantVolumeCount = 0;
        l != &(Extension->PartitionList);
        l = l->Flink, i++) {

        PDEVICE_RELATIONS dependantVolumes;

        partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);

        //
        // Check to make sure the volume has a volume manager.  If it doesn't
        // then just skip to the next one.
        //

        if(partition->VolumeManagerEntry == NULL) {
            continue;
        }

        status = PmQueryDependantVolumeList(
                    partition->VolumeManagerEntry->VolumeManager,
                    partition->TargetObject,
                    partition->WholeDiskPdo,
                    &dependantVolumes);

        if(!NT_SUCCESS(status)) {

            //
            // Error getting this list.  We'll need to release the lists from
            // the other partitions.
            //

            break;
        }

        dependantVolumeCount += dependantVolumes->Count;
        relationsList->Objects[i] = (PDEVICE_OBJECT) dependantVolumes;
    }

    UnlockDriver (Extension->DriverExtension);

    relationsList->Count = i;

    if(NT_SUCCESS(status)) {

        //
        // Allocate a new device relations list which can hold all the dependant
        // volumes for all the partitions.
        //

        combinedList = ExAllocatePoolWithTag(
                            PagedPool,
                            (sizeof(DEVICE_RELATIONS) +
                            (sizeof(PDEVICE_OBJECT) * dependantVolumeCount)),
                            PARTMGR_TAG_DEPENDANT_VOLUME_LIST);
    } else {
        combinedList = NULL;
    }

    if(combinedList != NULL) {

        RtlZeroMemory(combinedList,
                      (sizeof(DEVICE_RELATIONS) +
                       (sizeof(PDEVICE_OBJECT) * dependantVolumeCount)));

        //
        // For each partition list ...
        //

        for(i = 0; i < relationsList->Count; i++) {

            PDEVICE_RELATIONS volumeList;
            ULONG j;

            volumeList = (PDEVICE_RELATIONS) relationsList->Objects[i];

            //
            // We might have skipped this volume above.  If we did the object
            // list should be NULL;
            //

            if(volumeList == NULL) {
                continue;
            }

            //
            // For each dependant volume in that list ...
            //

            for(j = 0; j < volumeList->Count; j++) {

                PDEVICE_OBJECT volume;
                ULONG k;

                volume = volumeList->Objects[j];

                //
                // Check to see if there's a duplicate in our combined list.
                //

                for(k = 0; k < combinedList->Count; k++) {
                    if(combinedList->Objects[k] == volume) {
                        break;
                    }
                }

                if(k == combinedList->Count) {

                    //
                    // We found no match - shove this object onto the end of
                    // the set.
                    //

                    combinedList->Objects[k] = volume;
                    combinedList->Count++;

                } else {

                    //
                    // We've got a spare reference to this device object.
                    // release it.
                    //

                    ObDereferenceObject(volume);
                }

            }

            //
            // Free the list.
            //

            ExFreePool(volumeList);
            relationsList->Objects[i] = NULL;
        }

        status = STATUS_SUCCESS;

    } else {


        //
        // For each partition list ...
        //

        for(i = 0; i < relationsList->Count; i++) {

            PDEVICE_RELATIONS volumeList;
            ULONG j;

            volumeList = (PDEVICE_RELATIONS) relationsList->Objects[i];

            //
            // For each dependant volume in that list ...
            //

            for(j = 0; j < volumeList->Count; j++) {

                PDEVICE_OBJECT volume;

                volume = volumeList->Objects[j];

                //
                // Dereference the volume.
                //

                ObDereferenceObject(volume);
            }

            //
            // Free the list.
            //

            ExFreePool(volumeList);
            relationsList->Objects[i] = NULL;
        }

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Free the list of lists.
    //

    ExFreePool(relationsList);

    *Relations = combinedList;

    return status;
}

NTSTATUS
PmQueryDependantVolumeList(
    IN  PDEVICE_OBJECT VolumeManager,
    IN  PDEVICE_OBJECT Partition,
    IN  PDEVICE_OBJECT WholeDiskPdo,
    OUT PDEVICE_RELATIONS *DependantVolumes
    )
{
    KEVENT                                  event;
    PIRP                                    irp;

    IO_STATUS_BLOCK                         ioStatus;
    NTSTATUS                                status;
    VOLMGR_PARTITION_INFORMATION            input;
    VOLMGR_DEPENDANT_VOLUMES_INFORMATION    output;

    PAGED_CODE();

    ASSERT(DependantVolumes != NULL);

    if (!VolumeManager) {
        *DependantVolumes = ExAllocatePoolWithTag(PagedPool,
                            sizeof(DEVICE_RELATIONS),
                            PARTMGR_TAG_DEPENDANT_VOLUME_LIST);
        if (*DependantVolumes == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        (*DependantVolumes)->Count = 0;

        return STATUS_SUCCESS;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    input.PartitionDeviceObject = Partition;
    input.WholeDiskPdo = WholeDiskPdo;

    irp = IoBuildDeviceIoControlRequest(
            IOCTL_INTERNAL_VOLMGR_REFERENCE_DEPENDANT_VOLUMES, VolumeManager,
            &input, sizeof(input), &output, sizeof(output), TRUE, &event,
            &ioStatus);

    if (!irp) {
        *DependantVolumes = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(VolumeManager, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (NT_SUCCESS(status)) {
        *DependantVolumes = output.DependantVolumeReferences;
    }

    return status;
}


NTSTATUS
PmRemovePartition(
    IN PPARTITION_LIST_ENTRY Partition
    )
{
    PIRP irp;
    KEVENT event;

    PIO_STACK_LOCATION nextStack;

    NTSTATUS status;

    PAGED_CODE();

    irp = IoAllocateIrp(Partition->TargetObject->StackSize, FALSE);

    if(irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_PNP;
    nextStack->MinorFunction = IRP_MN_REMOVE_DEVICE;

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    IoSetCompletionRoutine(irp,
                           PmSignalCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    IoCallDriver(Partition->TargetObject, irp);

    KeWaitForSingleObject(&event,
                          KernelMode,
                          Executive,
                          FALSE,
                          NULL);

    status = irp->IoStatus.Status;

    IoFreeIrp(irp);

    return status;
}


NTSTATUS
PmReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_READ & _WRITE.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   extension =
        (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if (extension->CountersEnabled || extension->PhysicalDiskIoNotifyRoutine) {
        PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
        PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);

        *nextIrpStack = *currentIrpStack;

        if (extension->CountersEnabled) {
            PmWmiCounterIoStart(extension->PmWmiCounterContext,
                (PLARGE_INTEGER) &currentIrpStack->Parameters.Read);
        }
        else {      // need to calculate response time for tracing
            PmWmiGetClock(
                *((PLARGE_INTEGER)&currentIrpStack->Parameters.Read), NULL);
        }

        IoMarkIrpPending(Irp);
        IoSetCompletionRoutine(Irp, PmIoCompletion, DeviceObject,
                               TRUE, TRUE, TRUE);
        IoCallDriver(extension->TargetObject, Irp);
        return STATUS_PENDING;
    }

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(extension->TargetObject, Irp);
}



NTSTATUS
PmIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )

/*++

Routine Description:

    This routine will get control from the system at the completion of an IRP.

Arguments:

    DeviceObject - for the IRP.

    Irp          - The I/O request that just completed.

    Context      - Not used.

Return Value:

    The IRP status.

--*/

{
    PDEVICE_EXTENSION  deviceExtension   = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack          = IoGetCurrentIrpStackLocation(Irp);
    PPHYSICAL_DISK_IO_NOTIFY_ROUTINE notifyRoutine;

    UNREFERENCED_PARAMETER(Context);

    if (deviceExtension->CountersEnabled) {
        PmWmiCounterIoComplete(deviceExtension->PmWmiCounterContext, Irp,
                             (PLARGE_INTEGER) &irpStack->Parameters.Read);
    }

    notifyRoutine = deviceExtension->PhysicalDiskIoNotifyRoutine;
    if (notifyRoutine) {
#ifdef NTPERF
        //
        // For now, only NTPERF needs this for tracing. Remove ifdef if it
        // is required for tracing in retail build
        //
        if (deviceExtension->CountersEnabled) {
            DISK_PERFORMANCE   PerfCounters;
            PmWmiCounterQuery(deviceExtension->PmWmiCounterContext,
                              &PerfCounters,
                              L"Partmgr ",
                              deviceExtension->DiskNumber);
            (*notifyRoutine) (deviceExtension->DiskNumber, Irp, &PerfCounters);
        } else {
            (*notifyRoutine) (deviceExtension->DiskNumber, Irp, NULL);
        }
#else
        if (!deviceExtension->CountersEnabled) {
            LARGE_INTEGER completeTime;
            PLARGE_INTEGER response;
            response = (PLARGE_INTEGER) &irpStack->Parameters.Read;
            PmWmiGetClock(completeTime, NULL);
            response->QuadPart = completeTime.QuadPart - response->QuadPart;
        }
        (*notifyRoutine) (deviceExtension->DiskNumber, Irp, NULL);
#endif
    }

    return STATUS_SUCCESS;

}



NTSTATUS
PmWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles any WMI requests for information.

Arguments:

    DeviceObject - Context for the activity.

    Irp          - The device control argument block.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION      irpSp;
    NTSTATUS status;
    SYSCTL_IRP_DISPOSITION disposition;
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (irpSp->MinorFunction == IRP_MN_SET_TRACE_NOTIFY)
    {
        PVOID buffer = irpSp->Parameters.WMI.Buffer;
        ULONG bufferSize = irpSp->Parameters.WMI.BufferSize;

        if (bufferSize < sizeof(PPHYSICAL_DISK_IO_NOTIFY_ROUTINE))
        {
            status = STATUS_BUFFER_TOO_SMALL;
        } else {
#ifdef NTPERF
        //
        // For NTPERF Build, automatically turn on counters for tracing
        //
        if ((deviceExtension->PhysicalDiskIoNotifyRoutine == NULL) &&
            (*((PVOID *)buffer) != NULL)) {
            PmWmiCounterEnable(&deviceExtension->PmWmiCounterContext);
            deviceExtension->CountersEnabled = TRUE;
        } else
        if ((deviceExtension->PhysicalDiskIoNotifyRoutine != NULL) &&
            (*((PVOID *)buffer) == NULL)) {
            deviceExtension->CountersEnabled =
                PmWmiCounterDisable(&deviceExtension->PmWmiCounterContext,
                                    FALSE, FALSE);
        }
#endif
            deviceExtension->PhysicalDiskIoNotifyRoutine
                = (PPHYSICAL_DISK_IO_NOTIFY_ROUTINE)
                    *((PVOID *)buffer);

            status = STATUS_SUCCESS;
        }

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    } else {
        if (deviceExtension->WmilibContext == NULL) {
            disposition = IrpForward;
            status = STATUS_SUCCESS;
        }
        else {
            status = WmiSystemControl(deviceExtension->WmilibContext,
                                      DeviceObject,
                                      Irp,
                                      &disposition);
        }
        switch (disposition)
        {
            case IrpProcessed:
            {
                break;
            }

            case IrpNotCompleted:
            {
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;
            }

            default:
            {
                IoSkipCurrentIrpStackLocation(Irp);

                status = IoCallDriver(deviceExtension->TargetObject, Irp);
                break;
            }
        }
    }
    return(status);

}

NTSTATUS
PmWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for enabling or
    disabling events and data collection.  When the driver has finished it
    must call WmiCompleteRequest to complete the irp. The driver can return
    STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose events or data collection are being
        enabled or disabled

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function differentiates between event and data collection operations

    Enable indicates whether to enable or disable


Return Value:

    status

--*/
{
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    if (GuidIndex == 0)
    {
        status = STATUS_SUCCESS;
        if (Function == WmiDataBlockControl) {
            if (!Enable) {
                deviceExtension->CountersEnabled =
                    PmWmiCounterDisable(&deviceExtension->PmWmiCounterContext,
                                        FALSE, FALSE);
            } else
            if (NT_SUCCESS(status =
                PmWmiCounterEnable(&deviceExtension->PmWmiCounterContext))) {
                deviceExtension->CountersEnabled = TRUE;
            }
        }
    } else {
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(
                                 DeviceObject,
                                 Irp,
                                 status,
                                 0,
                                 IO_NO_INCREMENT);
    return(status);
}

NTSTATUS
PmReadPartitionTableEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRIVE_LAYOUT_INFORMATION_EX* DriveLayout
    )

/*++

Routine Description:

    This routine reads the partition table for the disk.

    The partition list is built in nonpaged pool that is allocated by this
    routine. It is the caller's responsability to free this memory when it
    is finished with the data.

Arguments:

    DeviceObject - Pointer for device object for this disk.

    DriveLayout - Pointer to the pointer that will return the patition list.
            This buffer is allocated in nonpaged pool by this routine. It is
            the responsability of the caller to free this memory if this
            routine is successful.

Return Values:

    Status.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    PIRP Irp;
    KEVENT Event;
    PVOID IoCtlBuffer;
    ULONG IoCtlBufferSize;
    ULONG NewAllocationSize;
    ULONG NumTries;

    //
    // Initialize locals.
    //

    NumTries = 0;
    IoCtlBuffer = NULL;
    IoCtlBufferSize = 0;
    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    //
    // Initialize the IOCTL buffer.
    //

    IoCtlBuffer = ExAllocatePoolWithTag(NonPagedPool, 
                                        PAGE_SIZE,
                                        PARTMGR_TAG_IOCTL_BUFFER);
    
    if (!IoCtlBuffer) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }
    
    IoCtlBufferSize = PAGE_SIZE;

    //
    // First try to get the partition table by issuing an IOCTL.
    //
    
    do {

        //
        // Make sure the event is reset.
        //

        KeClearEvent(&Event);

        //
        // Build an IOCTL Irp.
        //

        Irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                            DeviceObject,
                                            NULL, 
                                            0, 
                                            IoCtlBuffer, 
                                            IoCtlBufferSize, 
                                            FALSE,
                                            &Event, 
                                            &IoStatus);
        if (!Irp) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        //
        // Call the driver.
        //

        Status = IoCallDriver(DeviceObject, Irp);

        if (Status == STATUS_PENDING) {
            KeWaitForSingleObject(&Event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            //
            // Update status.
            //
            
            Status = IoStatus.Status;
        }
    
        if (NT_SUCCESS(Status)) {
            
            //
            // We got it!
            //

            break;
        }

        if (Status != STATUS_BUFFER_TOO_SMALL) {
            
            //
            // It is a real error.
            //

            goto cleanup;
        }

        //
        // Resize IOCTL buffer. We should not enter the loop with a
        // NULL buffer.
        //

        ASSERT(IoCtlBuffer && IoCtlBufferSize);

        NewAllocationSize = IoCtlBufferSize * 2;

        ExFreePool(IoCtlBuffer);
        IoCtlBufferSize = 0;
        
        IoCtlBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                            NewAllocationSize,
                                            PARTMGR_TAG_IOCTL_BUFFER);
        
        if (!IoCtlBuffer) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }
        
        IoCtlBufferSize = NewAllocationSize;

        //
        // Try again with the new buffer but do not loop forever.
        //

        NumTries++;

        if (NumTries > 32) {
            Status = STATUS_UNSUCCESSFUL;
            goto cleanup;
        }

    } while (TRUE);

    //
    // If we came here we should have acquired the partition tables in
    // IoCtlBuffer.
    //
    
    ASSERT(NT_SUCCESS(Status));
    ASSERT(IoCtlBuffer && IoCtlBufferSize);
    
    //
    // Set the output parameter and clear IoCtlBuffer so we don't free
    // it when we are cleaning up.
    //

    (*DriveLayout) = (PDRIVE_LAYOUT_INFORMATION_EX) IoCtlBuffer;

    IoCtlBuffer = NULL;
    IoCtlBufferSize = 0;

    Status = STATUS_SUCCESS;

 cleanup:
    
    if (IoCtlBuffer) {
        ASSERT(IoCtlBufferSize);
        ExFreePool(IoCtlBuffer);
    }

    //
    // If we were not successful with the IOCTL, pass the request off
    // to IoReadPartitionTableEx.
    //

    if (!NT_SUCCESS(Status)) {
        
        Status = IoReadPartitionTableEx(DeviceObject,
                                        DriveLayout);

    }
    
    return Status;
}

NTSTATUS
PmWritePartitionTableEx(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PDRIVE_LAYOUT_INFORMATION_EX    DriveLayout
    )

{
    ULONG           layoutSize;
    KEVENT          event;
    PIRP            irp;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS        status;

    layoutSize = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry) +
                 DriveLayout->PartitionCount*sizeof(PARTITION_INFORMATION_EX);

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_SET_DRIVE_LAYOUT_EX,
                                        DeviceObject, DriveLayout,
                                        layoutSize, NULL, 0, FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(DeviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    return status;
}


VOID
PmSigCheckUpdateEpoch (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PLIST_ENTRY       CompletionList
    )
    {
    NTSTATUS                       status;
    PIRP                           irp;
    PIO_STACK_LOCATION             irpSp;
    KIRQL                          oldIrql;
    PLIST_ENTRY                    listElement;


    //
    // Update the epoch for this disk and move it to the head of the queue
    //
    DeviceExtension->EpochNumber = ++DeviceExtension->DriverExtension->CurrentEpochNumber;

    RemoveEntryList (&DeviceExtension->ListEntry);

    InsertHeadList (&DeviceExtension->DriverExtension->DeviceExtensionList,
                    &DeviceExtension->ListEntry);


    //
    // Now scan the list of outstanding notification irps and for those that
    // are not yet cancelled move them to the completion list and fill in the
    // buffers with the appropriate contents. Separating out the completion
    // of the irps from their preparation means that we can avoid all the
    // mucking around with the mutex and opening shynchronisation holes.
    //
    InitializeListHead (CompletionList);

    listElement = DeviceExtension->DriverExtension->SignatureCheckNotificationIrpQueue.Flink;


    while (listElement != &DeviceExtension->DriverExtension->SignatureCheckNotificationIrpQueue) {

        irp = CONTAINING_RECORD (listElement, IRP, Tail.Overlay.ListEntry); 

        listElement = listElement->Flink;


        IoAcquireCancelSpinLock (&oldIrql);

        //
        // Check if the cancel routine has been called. If so
        // don't complete this irp.
        //
        status = (NULL == IoSetCancelRoutine (irp, NULL))
                    ? STATUS_CANCELLED
                    : STATUS_SUCCESS;

        if (NT_SUCCESS (status)) {
            RemoveEntryList (&irp->Tail.Overlay.ListEntry);
        }

        IoReleaseCancelSpinLock (oldIrql);


        if (NT_SUCCESS (status)) {
            InsertTailList (CompletionList, &irp->Tail.Overlay.ListEntry);

            status = PmSigCheckFillInNotificationIrp (DeviceExtension->DriverExtension, irp);

            irp->IoStatus.Status = status;
        }
    }


    return;
}



VOID
PmSigCheckCompleteNotificationIrps(
    IN PLIST_ENTRY CompletionList
    )
{
    PIRP        irp;
    PLIST_ENTRY listElement;


    PAGED_CODE();


    while (!IsListEmpty (CompletionList)) {
        //
        // There's an Irp waiting on the completion queue.
        // The notification buffer is already filled in so 
        // we just need to send it back to the caller.
        //
        listElement = RemoveHeadList (CompletionList);

        irp = CONTAINING_RECORD (listElement, IRP, Tail.Overlay.ListEntry); 

        IoCompleteRequest (irp, IO_NO_INCREMENT);
    }

    return;
}



NTSTATUS
PmSigCheckFillInNotificationIrp (
    IN PDO_EXTENSION DriverExtension,
    IN PIRP          Irp
    )
{
    PDEVICE_EXTENSION              deviceExtension;
    NTSTATUS                       status                 = STATUS_SUCCESS;
    PIO_STACK_LOCATION             irpSp                  = IoGetCurrentIrpStackLocation (Irp);
    PPARTMGR_SIGNATURE_CHECK_EPOCH sigCheckEpoch          = Irp->AssociatedIrp.SystemBuffer;
    PPARTMGR_SIGNATURE_CHECK_DISKS sigCheckDisks          = Irp->AssociatedIrp.SystemBuffer;
    ULONG                          highestDiskEpochNumber = 0;
    ULONG                          disksInBuffer          = 0;
    ULONG                          maxDisksInBuffer;
    PLIST_ENTRY                    listElement;


    PAGED_CODE();


    maxDisksInBuffer = ((irpSp->Parameters.DeviceIoControl.OutputBufferLength - 
                         FIELD_OFFSET (PARTMGR_SIGNATURE_CHECK_DISKS, DiskNumber)) 
                       / sizeof (sigCheckDisks->DiskNumber[0])) ;

    ASSERT (maxDisksInBuffer >= 1);


    //
    // Walk down the list of disks until either we run out of disks with 
    // an epoch higher than the request or we reach the head. Then we 
    // turn around and start filling in the buffer until we either 
    // run out of disks or run out of buffer.
    //
    listElement = DriverExtension->DeviceExtensionList.Flink;

    while (listElement != &DriverExtension->DeviceExtensionList) {

        deviceExtension = CONTAINING_RECORD (listElement, DEVICE_EXTENSION, ListEntry); 

        if (deviceExtension->EpochNumber <= sigCheckEpoch->RequestEpoch) {
            //
            // We have stepped past the device of interest so
            // back up one place. Note that for single entries
            // this will in fact take us back to the queue head
            // so make sure we can handle that case in the
            // following loop.
            //
            listElement = listElement->Blink;
            break;
        } else {
            listElement = listElement->Flink;
        }
    }


    //
    // Now move back towards the head of the list recording entries
    // in the buffer as we go
    //
    while ((listElement != &DriverExtension->DeviceExtensionList) &&
           (disksInBuffer < maxDisksInBuffer))  {

        deviceExtension = CONTAINING_RECORD (listElement, DEVICE_EXTENSION, ListEntry); 

        listElement = listElement->Blink;

        sigCheckDisks->DiskNumber [disksInBuffer++] = deviceExtension->DiskNumber;

        highestDiskEpochNumber = UMAX (highestDiskEpochNumber, deviceExtension->EpochNumber);
    }


    if ((listElement != &DriverExtension->DeviceExtensionList) &&
        (disksInBuffer == maxDisksInBuffer)) {
        //
        // We ran out of buffer before we ran out of disks. 
        // Return STATUS_BUFFER_OVERFLOW
        //
        status = STATUS_BUFFER_OVERFLOW;

    } else {

        status = STATUS_SUCCESS;
    }



    sigCheckDisks->CurrentEpoch             = DriverExtension->CurrentEpochNumber;
    sigCheckDisks->HighestDiskEpochReturned = highestDiskEpochNumber;
    sigCheckDisks->DiskNumbersReturned      = disksInBuffer;

    Irp->IoStatus.Information = UMAX (sizeof (PARTMGR_SIGNATURE_CHECK_DISKS),
                                      FIELD_OFFSET (PARTMGR_SIGNATURE_CHECK_DISKS, DiskNumber) +
                                      (sizeof (sigCheckDisks->DiskNumber[0]) * disksInBuffer));

    return (status);
}


NTSTATUS
PmSigCheckNotificationInsert (
    IN PDEVICE_EXTENSION DeviceExtension, 
    IN PIRP              Irp) 

{
    NTSTATUS                       status = STATUS_CANCELLED;
    PIO_STACK_LOCATION             irpSp  = IoGetCurrentIrpStackLocation (Irp);
    PPARTMGR_SIGNATURE_CHECK_EPOCH sigCheckEpoch;
    PPARTMGR_SIGNATURE_CHECK_DISKS sigCheckDisks;


    if ((irpSp->Parameters.DeviceIoControl.InputBufferLength  < sizeof (PARTMGR_SIGNATURE_CHECK_EPOCH)) ||
        (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof (PARTMGR_SIGNATURE_CHECK_DISKS))) {

        Irp->IoStatus.Information = 0;
        status = STATUS_BUFFER_TOO_SMALL;

    } else {

        sigCheckEpoch = Irp->AssociatedIrp.SystemBuffer;
        sigCheckDisks = Irp->AssociatedIrp.SystemBuffer;

        LockDriver (DeviceExtension->DriverExtension);

        if (PARTMGR_REQUEST_CURRENT_DISK_EPOCH == sigCheckEpoch->RequestEpoch) {

            //
            // Caller requesting the current epoch number. Return the epoch 
            // number but no disks
            //

            sigCheckDisks->CurrentEpoch             = DeviceExtension->DriverExtension->CurrentEpochNumber;
            sigCheckDisks->HighestDiskEpochReturned = 0;
            sigCheckDisks->DiskNumbersReturned      = 0;
            sigCheckDisks->DiskNumber [0]           = 0;


            Irp->IoStatus.Information = sizeof (PARTMGR_SIGNATURE_CHECK_DISKS);
            status = STATUS_SUCCESS;

        } else if (sigCheckEpoch->RequestEpoch > DeviceExtension->DriverExtension->CurrentEpochNumber) {

            //
            // Something wrong here. Caller asking about an epoch which hasn't 
            // happened yet.
            //

            Irp->IoStatus.Information = 0;
            status = STATUS_NOT_FOUND;

        } else if (sigCheckEpoch->RequestEpoch < DeviceExtension->DriverExtension->CurrentEpochNumber) {

            //
            // Caller asking about an epoch which ended a while back. Fill in the 
            // request now with as much information as we can.
            //
            status = PmSigCheckFillInNotificationIrp (DeviceExtension->DriverExtension, Irp);

        } else {
            KIRQL    oldIrql;

            //
            // The only thing left is that the request epoch is the same as the current 
            // epoch. Queue this Irp which will be completed when the epoch changes.
            //

            IoAcquireCancelSpinLock (&oldIrql);

            InsertTailList (&DeviceExtension->DriverExtension->SignatureCheckNotificationIrpQueue, 
                            &Irp->Tail.Overlay.ListEntry);

            if (!Irp->Cancel) {
                IoSetCancelRoutine (Irp, PmSigCheckNotificationCancel);
                IoMarkIrpPending (Irp);
                status = STATUS_PENDING;
            } else {
                RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
                Irp->IoStatus.Information = 0;
                status = STATUS_CANCELLED;
            }

            IoReleaseCancelSpinLock (oldIrql);

        }
	    

        UnlockDriver (DeviceExtension->DriverExtension);
    }


    return (status);
}


NTSTATUS
PmSigCheckNotificationCancel (
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp) 

/*++

Routine Description

    This function filters cancels an outstanding IOCTL IRP


Arguments:

    DeviceObject - Pointer to the target device object of the create/open.
    Irp          - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.
--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS          status          = STATUS_CANCELLED;
    KIRQL             oldIrql;


    RemoveEntryList (&Irp->Tail.Overlay.ListEntry);

    IoReleaseCancelSpinLock (Irp->CancelIrql);

    Irp->IoStatus.Status      = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return (STATUS_SUCCESS);
}


NTSTATUS
PmCheckAndUpdateSignature (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN           IssueSigCheckNotifications,
    IN BOOLEAN           ForceSignatureCheck) 

/*++

Routine Description

    This function ...


Arguments:

    DeviceExtension


Return Value:

    The function value is the status of the call to the file system's entry
    point.
--*/

{
    NTSTATUS                        status                = STATUS_SUCCESS;
    BOOLEAN                         processCompletionList = FALSE;
    PDRIVE_LAYOUT_INFORMATION_EX    newLayout;
    LIST_ENTRY                      completionList;


    if (ForceSignatureCheck || DeviceExtension->SignaturesNotChecked) {

        status = PmReadPartitionTableEx (DeviceExtension->TargetObject, &newLayout);


        /*
        ** If by the time we complete the read of the partition table
        ** the SignaturesNotChecked flag has been cleared there is no
        ** need to proceed further. 
        **
        ** Alternatively if we failed to read the partition table (eg
        ** due to a timeout from the disk) and the
        ** SignaturesNotChecked flag is already set then bail and
        ** leave a future pass to fix up the signatures.
        */
        if (!(ForceSignatureCheck || DeviceExtension->SignaturesNotChecked)) {

            if (NT_SUCCESS (status)) {
                ExFreePool (newLayout);
            }

            return (STATUS_SUCCESS);

        } else if (!NT_SUCCESS(status) && DeviceExtension->SignaturesNotChecked) {

            return status;

        }



        /*
        ** If we can't get the lock avoid the deadlock and just
        ** leave. Shouldn't happen with FtDisk and basic disks
        ** (recursive acquire) and dmio with dynamic disks doesn't
        ** really care about the (potentially bad) signature anyway.
        */
        if (!LockDriverWithTimeout (DeviceExtension->DriverExtension)) {

            if (NT_SUCCESS (status)) {
                ExFreePool (newLayout);
            }

            return status;
        }


        if (NT_SUCCESS (status)) {
    
            if (IssueSigCheckNotifications) {
                PmSigCheckUpdateEpoch (DeviceExtension, &completionList);
                processCompletionList = TRUE;
            }

            PmAddSignatures (DeviceExtension, newLayout);

            ExFreePool(newLayout);
        }

        DeviceExtension->SignaturesNotChecked = NT_SUCCESS (status) ? FALSE : TRUE;

        UnlockDriver (DeviceExtension->DriverExtension);


        if (processCompletionList) {
            PmSigCheckCompleteNotificationIrps (&completionList);
        }
    }



    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\partmgr\pmwmireg.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    pmwmireg.h

Abstract:

    This file contains the prototypes of the routines to register for 
    and handle WMI queries.

Author:

    Bruce Worthington      26-Oct-1998

Environment:

    kernel mode only

Notes:

Revision History:

--*/


#include <ntddk.h>
#include <wdmguid.h>

NTSTATUS
PmDetermineDeviceNameAndNumber(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG        WmiRegistrationFlags
    );

NTSTATUS PmRegisterDevice(
    IN PDEVICE_OBJECT DeviceObject,
    ULONG             WmiRegistrationFlags
    );

NTSTATUS
PmQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
PmQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

BOOLEAN
PmQueryEnableAlways(
    IN PDEVICE_OBJECT DeviceObject
    );

extern WMIGUIDREGINFO DiskperfGuidList[];

extern ULONG DiskperfGuidCount;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\partmgr\pmwmicnt.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    pmwmicnt.c

Abstract:

    This file contains the routines to manage and maintain the disk perf
    counters.  The counter structure is hidden from the various drivers.

Author:

    Bruce Worthington      26-Oct-1998

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#define RTL_USE_AVL_TABLES 0

#include <ntosp.h>
#include <stdio.h>
#include <ntddvol.h>
#include <ntdddisk.h>
#include <wmilib.h>
#include <partmgr.h>

// Round off freq to 100 microsecs prevent overflow
#define CTR_TO_100NS(ctr, freq)  ((freq).QuadPart > 0) ? \
                                 ((ctr).QuadPart / ((freq).QuadPart / 10000)) * 1000 : \
                                 (ctr).QuadPart;

typedef struct _PMWMICOUNTER_CONTEXT
{
  ULONG EnableCount;
  ULONG Processors;
  ULONG QueueDepth;
  PDISK_PERFORMANCE *DiskCounters;
  LARGE_INTEGER LastIdleClock;
} PMWMICOUNTER_CONTEXT, *PPMWMICOUNTER_CONTEXT;


NTSTATUS
PmWmiCounterEnable(
    IN OUT PPMWMICOUNTER_CONTEXT* CounterContext
    );

BOOLEAN
PmWmiCounterDisable(
    IN PPMWMICOUNTER_CONTEXT* CounterContext,
    IN BOOLEAN ForceDisable,
    IN BOOLEAN DeallocateOnZero
    );

VOID
PmWmiCounterIoStart(
    IN PPMWMICOUNTER_CONTEXT CounterContext,
    OUT PLARGE_INTEGER TimeStamp
    );

VOID
PmWmiCounterIoComplete(
    IN PPMWMICOUNTER_CONTEXT CounterContext,
    IN PIRP Irp,
    IN PLARGE_INTEGER TimeStamp
    );

VOID
PmWmiCounterQuery(
    IN PPMWMICOUNTER_CONTEXT CounterContext,
    IN OUT PDISK_PERFORMANCE CounterBuffer,
    IN PWCHAR StorageManagerName,
    IN ULONG StorageDeviceNumber
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PmWmiCounterEnable)
#pragma alloc_text(PAGE, PmWmiCounterDisable)
#pragma alloc_text(PAGE, PmWmiCounterQuery)
#endif


NTSTATUS
PmWmiCounterEnable(
    IN OUT PPMWMICOUNTER_CONTEXT* CounterContext
    )
/*++

Routine Description:

    This routine will allocate and initialize a PMWMICOUNTER_CONTEXT structure
    for *CounterContext if it is NULL.  Otherwise, an enable count is
    incremented.
    Must be called at IRQ <= SYNCH_LEVEL (APC)

Arguments:

    CounterContext - Supplies a pointer to the PMWMICOUNTER_CONTEXT pointer

Return Value:

    status

--*/
{
    ULONG buffersize;
    ULONG processors;
    ULONG i = 0;
    PCHAR buffer;
    PPMWMICOUNTER_CONTEXT HoldContext;   // Holds context during initialization

    PAGED_CODE();

    if (CounterContext == NULL)
        return STATUS_INVALID_PARAMETER;

    if (*CounterContext != NULL) {
        if ((*CounterContext)->EnableCount == 0) {
            (*CounterContext)->QueueDepth = 0;
            PmWmiGetClock((*CounterContext)->LastIdleClock, NULL);
        }
        InterlockedIncrement(& (*CounterContext)->EnableCount);
        return STATUS_SUCCESS;
    }

    processors = KeNumberProcessors;

    buffersize= sizeof(PMWMICOUNTER_CONTEXT) +
                ((sizeof(PDISK_PERFORMANCE) + sizeof(DISK_PERFORMANCE))
                 * processors);
    buffer =  (PCHAR) ExAllocatePoolWithTag(NonPagedPool, buffersize,
                                            PARTMGR_TAG_PARTITION_ENTRY);

    if (buffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(buffer, buffersize);
    HoldContext = (PPMWMICOUNTER_CONTEXT) buffer;
    buffer += sizeof(PMWMICOUNTER_CONTEXT);
    HoldContext->DiskCounters = (PDISK_PERFORMANCE*) buffer;
    buffer += sizeof(PDISK_PERFORMANCE) * processors;
    for (i=0; i<processors; i++) {
        HoldContext->DiskCounters[i] = (PDISK_PERFORMANCE) buffer;
        buffer += sizeof(DISK_PERFORMANCE);
    }

    HoldContext->EnableCount = 1;
    HoldContext->Processors = processors;
    PmWmiGetClock(HoldContext->LastIdleClock, NULL);

    *CounterContext = HoldContext;

    return STATUS_SUCCESS;
}



BOOLEAN               // Return value indicates if counters are still enabled
PmWmiCounterDisable(
    IN PPMWMICOUNTER_CONTEXT* CounterContext,
    IN BOOLEAN ForceDisable,
    IN BOOLEAN DeallocateOnZero
    )
/*++

Routine Description:

    This routine decrements the enable count and, if deallocation is requested,
    frees the *CounterContext PMWMICOUNTER_CONTEXT data structure when the
    enable count reaches zero.  The enable count may also be forced to zero,
    if explicitly requested.
    Must be called at IRQ <= SYNCH_LEVEL (APC)

Arguments:

    CounterContext - Supplies a pointer to the PMWMICOUNTER_CONTEXT pointer

    ForceDisable - If TRUE, force enable count to zero (rather than decrement)

    DeallocateOnZero - If TRUE, deallocate PMWMICOUNTER_CONTEXT when enable
       count reaches zero

Return Value:

    Boolean indicating if the enable count is still non-zero (i.e., counters
       are still enabled!)

--*/
{
    LONG enablecount = 0;

    PAGED_CODE();

    if (CounterContext == NULL)
        return FALSE;

    if (*CounterContext != NULL) {
        if (ForceDisable) {
            InterlockedExchange(& (*CounterContext)->EnableCount, enablecount);
            enablecount = 0;
        } else if ((enablecount =
                    InterlockedDecrement(&(*CounterContext)->EnableCount))!=0) {
            if (enablecount > 0) {
            return TRUE;
            }
            enablecount = InterlockedIncrement(&(*CounterContext)->EnableCount);
    }
    if (!enablecount && DeallocateOnZero) {
            ExFreePool(*CounterContext);
            *CounterContext = NULL;
        }
    }

    return FALSE;  // counters disabled
}



VOID
PmWmiCounterIoStart(
    IN PPMWMICOUNTER_CONTEXT CounterContext,
    OUT PLARGE_INTEGER TimeStamp
    )
/*++

Routine Description:

    This routine increments the queue counter in CounterContext and records
    the current time in TimeStamp.  If the queue was empty prior to this call,
    the idle time counter is also accumulated.
    Can be called at IRQ <= DISPATCH_LEVEL

Arguments:

    CounterContext - Supplies a pointer to a PMWMICOUNTER_CONTEXT structure.

    TimeStamp - Address at which to store the current time

Return Value:

    void

--*/
{
    ULONG              processor = (ULONG) KeGetCurrentProcessorNumber();
    ULONG              queueLen;
    LARGE_INTEGER      time;

    //
    // Increment queue depth counter.
    //

    queueLen = InterlockedIncrement(&CounterContext->QueueDepth);

    //
    // Time stamp current request start.
    //

    PmWmiGetClock(time, NULL);

    if (queueLen == 1) {
        CounterContext->DiskCounters[processor]->IdleTime.QuadPart += 
	  time.QuadPart - CounterContext->LastIdleClock.QuadPart;
    }
    TimeStamp->QuadPart = time.QuadPart;
}



VOID
PmWmiCounterIoComplete(
    IN PPMWMICOUNTER_CONTEXT CounterContext,
    IN PIRP Irp,
    IN PLARGE_INTEGER TimeStamp
    )
/*++

Routine Description:

    This routine decrements the queue counter in CounterContext and increments
    the split counter and read or write byte, time, and count counters with
    information from the Irp.  If the queue is now empty, the current
    time is stored for future use in accumulating the idle time counter.
    Can be called at IRQ <= DISPATCH_LEVEL

Arguments:

    CounterContext - Supplies a pointer to a PMWMICOUNTER_CONTEXT structure.

    Irp - relevant IRP

    TimeStamp - Time of the corresponding PmWmiCounterIoStart call

Return Value:

    void

--*/
{
    PIO_STACK_LOCATION irpStack          = IoGetCurrentIrpStackLocation(Irp);
    PDISK_PERFORMANCE  partitionCounters;
    LARGE_INTEGER      timeStampComplete;
    LONG               queueLen;

    partitionCounters
        = CounterContext->DiskCounters[(ULONG)KeGetCurrentProcessorNumber()];
    //
    // Time stamp current request complete.
    //

    PmWmiGetClock(timeStampComplete, NULL);
    TimeStamp->QuadPart = timeStampComplete.QuadPart - TimeStamp->QuadPart;

    //
    // Decrement the queue depth counters for the volume.  This is
    // done without the spinlock using the Interlocked functions.
    // This is the only
    // legal way to do this.
    //

    queueLen = InterlockedDecrement(&CounterContext->QueueDepth);

    if (queueLen < 0) {
        queueLen = InterlockedIncrement(&CounterContext->QueueDepth);
    }

    if (queueLen == 0) {
        CounterContext->LastIdleClock = timeStampComplete;
    }

    //
    // Update counters protection.
    //

    if (irpStack->MajorFunction == IRP_MJ_READ) {

        //
        // Add bytes in this request to bytes read counters.
        //

        partitionCounters->BytesRead.QuadPart += Irp->IoStatus.Information;

        //
        // Increment read requests processed counters.
        //

        partitionCounters->ReadCount++;

        //
        // Calculate request processing time.
        //

        partitionCounters->ReadTime.QuadPart += TimeStamp->QuadPart;
    }

    else {

        //
        // Add bytes in this request to bytes write counters.
        //

        partitionCounters->BytesWritten.QuadPart += Irp->IoStatus.Information;

        //
        // Increment write requests processed counters.
        //

        partitionCounters->WriteCount++;

        //
        // Calculate request processing time.
        //

        partitionCounters->WriteTime.QuadPart += TimeStamp->QuadPart;
    }

    if (Irp->Flags & IRP_ASSOCIATED_IRP) {
        partitionCounters->SplitCount++;
    }
}



VOID
PmWmiCounterQuery(
    IN PPMWMICOUNTER_CONTEXT CounterContext,
    IN OUT PDISK_PERFORMANCE TotalCounters,
    IN PWCHAR StorageManagerName,
    IN ULONG StorageDeviceNumber
    )
/*++

Routine Description:

    This routine combines all of the per-processor counters in CounterContext
    into TotalCounters.  The current time is also included.
    Must be called at IRQ <= SYNCH_LEVEL (APC)

Arguments:

    CounterContext - Supplies a pointer to a PMWMICOUNTER_CONTEXT structure.

    TotalCounters - Pointer to a DISK_PERFORMANCE structure to fill with the
       current counter status

    StorageManagerName - Supplies an 8-character storage manager unicode string

    StorageDeviceNumber - Supplies a storage device number (unique within
       the storage manager)

Return Value:

    void

--*/
{
    ULONG i;
    LARGE_INTEGER frequency;
#ifdef USE_PERF_CTR
    LARGE_INTEGER perfctr;
#endif

    PAGED_CODE();

    RtlZeroMemory(TotalCounters, sizeof(DISK_PERFORMANCE));

    KeQuerySystemTime(&TotalCounters->QueryTime);
    frequency.QuadPart = 0;

#ifdef USE_PERF_CTR
    perfctr = KeQueryPerformanceCounter(&frequency);
#endif

    TotalCounters->QueueDepth = CounterContext->QueueDepth;
    for (i = 0; i < CounterContext->Processors; i++) {
        PDISK_PERFORMANCE IndividualCounter = CounterContext->DiskCounters[i];
        TotalCounters->BytesRead.QuadPart
            += IndividualCounter->BytesRead.QuadPart;
        TotalCounters->BytesWritten.QuadPart
            += IndividualCounter->BytesWritten.QuadPart;
        TotalCounters->ReadCount   += IndividualCounter->ReadCount;
        TotalCounters->WriteCount  += IndividualCounter->WriteCount;
        TotalCounters->SplitCount  += IndividualCounter->SplitCount;
#ifdef USE_PERF_CTR
        TotalCounters->ReadTime.QuadPart    +=
            CTR_TO_100NS(IndividualCounter->ReadTime, frequency);
        TotalCounters->WriteTime.QuadPart   +=
            CTR_TO_100NS(IndividualCounter->WriteTime, frequency);
        TotalCounters->IdleTime.QuadPart    +=
            CTR_TO_100NS(IndividualCounter->IdleTime, frequency);
#else
        TotalCounters->ReadTime.QuadPart
            += IndividualCounter->ReadTime.QuadPart;
        TotalCounters->WriteTime.QuadPart
            += IndividualCounter->WriteTime.QuadPart;
        TotalCounters->IdleTime.QuadPart
            += IndividualCounter->IdleTime.QuadPart;
#endif
    }


    if (TotalCounters->QueueDepth == 0) {
        LARGE_INTEGER difference;

        difference.QuadPart
#ifdef USE_PERF_CTR
            = perfctr.QuadPart -
#else
            = TotalCounters->QueryTime.QuadPart -
#endif
                  CounterContext->LastIdleClock.QuadPart;

        TotalCounters->IdleTime.QuadPart +=
#ifdef USE_PERF_CTR
            CTR_TO_100NS(difference, frequency);
#else
            difference.QuadPart;
#endif
    }

    TotalCounters->StorageDeviceNumber = StorageDeviceNumber;
    RtlCopyMemory(
        &TotalCounters->StorageManagerName[0],
        &StorageManagerName[0],
        sizeof(WCHAR) * 8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\partmgr\pmwmireg.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    pmwmireg.c

Abstract:

    This file contains routines to register for and handle WMI queries.

Author:

    Bruce Worthington      26-Oct-1998

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#define RTL_USE_AVL_TABLES 0

#include <ntosp.h>
#include <stdio.h>
#include <ntddvol.h>
#include <ntdddisk.h>
#include <wdmguid.h>
#include <volmgr.h>
#include <wmistr.h>
#include <wmikm.h>
#include <wmilib.h>
#include <partmgr.h>
#include <pmwmicnt.h>
#include <initguid.h>
#include <wmiguid.h>
#include <zwapi.h>

NTSTATUS
PmDetermineDeviceNameAndNumber(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG        WmiRegistrationFlags
    );

NTSTATUS PmRegisterDevice(
    IN PDEVICE_OBJECT DeviceObject,
    ULONG             WmiRegistrationFlags
    );

NTSTATUS
PmQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
PmQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

BOOLEAN
PmQueryEnableAlways(
    IN PDEVICE_OBJECT DeviceObject
    );

WMIGUIDREGINFO DiskperfGuidList[] =
{
    { &DiskPerfGuid,
      1,
      0
    }
};

ULONG DiskperfGuidCount = (sizeof(DiskperfGuidList) / sizeof(WMIGUIDREGINFO));

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, PmDetermineDeviceNameAndNumber)
#pragma alloc_text (PAGE, PmRegisterDevice)
#pragma alloc_text (PAGE, PmQueryWmiRegInfo)
#pragma alloc_text (PAGE, PmQueryWmiDataBlock)
#pragma alloc_text (PAGE, PmQueryEnableAlways)
#endif



NTSTATUS
PmDetermineDeviceNameAndNumber(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG        WmiRegistrationFlags
    )

/*++

Routine Description:

    Routine to initialize a proper name for the device object

Arguments:

    DeviceObject - pointer to a device object to be initialized.

Return Value:

    Status of the initialization. NOTE: If the registration fails,
    the device name in the DeviceExtension will be left as empty.

--*/

{
    NTSTATUS                status;
    IO_STATUS_BLOCK         ioStatus;
    KEVENT                  event;
    PDEVICE_EXTENSION       deviceExtension;
    PIRP                    irp;
    STORAGE_DEVICE_NUMBER   number;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Request for the device number
    //
    irp = IoBuildDeviceIoControlRequest(
                    IOCTL_STORAGE_GET_DEVICE_NUMBER,
                    deviceExtension->TargetObject,
                    NULL,
                    0,
                    &number,
                    sizeof(number),
                    FALSE,
                    &event,
                    &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(deviceExtension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Remember the disk number for use as parameter in 
    // PhysicalDiskIoNotifyRoutine and for epoch update 
    // notifications
    //

    deviceExtension->DiskNumber = number.DeviceNumber;

    //
    // Create device name for each partition
    //
    deviceExtension->PhysicalDeviceName.MaximumLength = sizeof (deviceExtension->PhysicalDeviceNameBuffer);
    deviceExtension->PhysicalDeviceName.Buffer        = deviceExtension->PhysicalDeviceNameBuffer;
    deviceExtension->PhysicalDeviceName.Length        = 
                  sizeof (WCHAR) * _snwprintf (deviceExtension->PhysicalDeviceNameBuffer,
                                               deviceExtension->PhysicalDeviceName.MaximumLength / sizeof (WCHAR),
                                               L"\\Device\\Harddisk%d\\Partition%d",
                                               number.DeviceNumber, 
                                               number.PartitionNumber);

    *WmiRegistrationFlags = (0 == number.PartitionNumber) 
                                ? WMIREG_FLAG_TRACE_PROVIDER | WMIREG_NOTIFY_DISK_IO
                                : 0;

    return status;
}



NTSTATUS
PmRegisterDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG          WmiRegistrationFlags
    )

/*++

Routine Description:

    Routine to register the device with WMI

Arguments:

    DeviceObject - pointer to a device object to be initialized.

Return Value:

    Status of the initialization. 
--*/

{
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       deviceExtension;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;


    if (deviceExtension->PhysicalDeviceName.Length > 0) {

        // Create device name for each partition

        status = IoWMIRegistrationControl(DeviceObject,
                                          WMIREG_ACTION_REGISTER | WmiRegistrationFlags );

        if (NT_SUCCESS(status)) {
            PmWmiCounterEnable(&deviceExtension->PmWmiCounterContext);
            PmWmiCounterDisable(&deviceExtension->PmWmiCounterContext,
                                FALSE, FALSE);
        }
    }

    return status;
}



NTSTATUS
PmQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned unmodified. If a value is returned then
        it is NOT freed.
        The MOF file is assumed to be already included in wmicore.mof

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    NTSTATUS status;
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    RtlInitUnicodeString (InstanceName, NULL);
    *RegistryPath = &deviceExtension->DriverExtension->DiskPerfRegistryPath;
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO | WMIREG_FLAG_EXPENSIVE;
    *Pdo = deviceExtension->Pdo;
    status = STATUS_SUCCESS;

    return(status);
}



NTSTATUS
PmQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. When the driver has finished filling the
    data block it must call WmiCompleteRequest to complete the irp. The
    driver can return STATUS_PENDING if the irp cannot be completed
    immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry.


Return Value:

    status

--*/
{
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    ULONG sizeNeeded = 0;
    KIRQL        currentIrql;
    PWCHAR diskNamePtr;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    if (GuidIndex == 0)
    {
        if (!(deviceExtension->CountersEnabled)) {
            status = STATUS_UNSUCCESSFUL;
        } else {
            sizeNeeded = ((sizeof(DISK_PERFORMANCE) + 1) & ~1)
                         + deviceExtension->PhysicalDeviceName.Length 
                         + sizeof(UNICODE_NULL);
            if (BufferAvail >= sizeNeeded) {
                PmWmiCounterQuery(deviceExtension->PmWmiCounterContext, 
                                  (PDISK_PERFORMANCE) Buffer, L"Partmgr ", 
                                  deviceExtension->DiskNumber);
                diskNamePtr = (PWCHAR)(Buffer +
                              ((sizeof(DISK_PERFORMANCE) + 1) & ~1));
                *diskNamePtr++ = deviceExtension->PhysicalDeviceName.Length;
                RtlCopyMemory(diskNamePtr,
                              deviceExtension->PhysicalDeviceName.Buffer,
                              deviceExtension->PhysicalDeviceName.Length);
                *InstanceLengthArray = sizeNeeded;
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
        }

    } else {
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest( DeviceObject, Irp, status, sizeNeeded,
                                 IO_NO_INCREMENT);
    return status;
}


BOOLEAN
PmQueryEnableAlways(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    NTSTATUS status;
    UNICODE_STRING uString;
    OBJECT_ATTRIBUTES objAttributes;
    PKEY_VALUE_PARTIAL_INFORMATION keyValue;
    ULONG Buffer[4];            // sizeof keyValue + ULONG
    ULONG enableAlways = 0;
    PDEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    HANDLE keyHandle;
    ULONG returnLength;

    PAGED_CODE();

    RtlInitUnicodeString(&uString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Partmgr");
    InitializeObjectAttributes(
        &objAttributes,
        &uString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = ZwOpenKey(&keyHandle, KEY_READ, &objAttributes);
    if (NT_SUCCESS(status)) {
        RtlInitUnicodeString(&uString, L"EnableCounterForIoctl");
        status = ZwQueryValueKey(keyHandle, &uString,
                    KeyValuePartialInformation,
                    Buffer,
                    sizeof(Buffer),
                    &returnLength);
        keyValue = (PKEY_VALUE_PARTIAL_INFORMATION) &Buffer[0];
        if (NT_SUCCESS(status) && (keyValue->DataLength == sizeof(ULONG))) {
            enableAlways = *((PULONG) keyValue->Data);
        }
        ZwClose(keyHandle);
    }

    if (enableAlways == 1) {
        if (InterlockedCompareExchange(&extension->EnableAlways, 1, 0) == 0) {
            status = PmWmiCounterEnable(&extension->PmWmiCounterContext);
            if (NT_SUCCESS(status)) {
                extension->CountersEnabled = TRUE;
                return TRUE;
            }
            else {
                InterlockedExchange(&extension->EnableAlways, 0);
            }
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\partmgr\pmwmicnt.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    pmwmicnt.h

Abstract:

    This file contains the prototypes of the routines to manage and 
    maintain the disk perf counters.  

Author:

    Bruce Worthington      26-Oct-1998

Environment:

    kernel mode only

Notes:

Revision History:

--*/


#include <ntddk.h>
#include <ntddvol.h>
#include <ntdddisk.h>

NTSTATUS
PmWmiCounterEnable(
    IN OUT PVOID* CounterContext
    );

BOOLEAN
PmWmiCounterDisable(
    IN PVOID* CounterContext,
    IN BOOLEAN ForceDisable,
    IN BOOLEAN DeallocateOnZero
    );

VOID
PmWmiCounterIoStart(
    IN PVOID CounterContext,
    OUT PLARGE_INTEGER TimeStamp
    );

VOID
PmWmiCounterIoComplete(
    IN PVOID CounterContext,
    IN PIRP Irp,
    IN PLARGE_INTEGER TimeStamp
    );

VOID
PmWmiCounterQuery(
    IN PVOID CounterContext,
    IN OUT PDISK_PERFORMANCE CounterBuffer,
    IN PWCHAR StorageManagerName,
    IN ULONG StorageDeviceNumber
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\partmgr\tests\mondisk\mondisks.cpp ===
#define INITGUID 1

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <partmgrp.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>


#define	PROGRAM_TITLE				L"MonDisks - Monitor Disk Arrivals Program V0.1"


#define HandleInvalid(_Handle)			((NULL == (_Handle)) || (INVALID_HANDLE_VALUE == (_Handle)))
#define HandleValid(_Handle)			(!HandleInvalid (_Handle))

#define	GET_STATUS_FROM_BOOL(_bSucceeded)	((_bSucceeded)             ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_HANDLE(_handle)		((!HandleInvalid(_handle)) ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_POINTER(_ptr)		((NULL != (_ptr))          ? NOERROR : E_OUTOFMEMORY)

#define SIZEOF_ARRAY(_aBase)			(sizeof (_aBase) / sizeof ((_aBase)[0]))


DWORD WINAPI MonitorThread (LPVOID lpvThreadParam);
void PrintResults (PPARTMGR_SIGNATURE_CHECK_DISKS	pSignatureCheckBufferDisks);



PSTR PartitionName    = "\\Device\\Harddisk%d\\Partition%d";
PSTR DefaultDevice    = "\\Device\\Harddisk0\\Partition0";
BOOL bExitApplication = FALSE;



HANDLE handleEventCancelIo = INVALID_HANDLE_VALUE;



VOID PrintError (IN DWORD ErrorCode)
    {
    PWSTR pMsgBuf;
    ULONG count;

    count = FormatMessageW (FORMAT_MESSAGE_ALLOCATE_BUFFER | 
			    FORMAT_MESSAGE_FROM_SYSTEM     |
			    FORMAT_MESSAGE_IGNORE_INSERTS,
			    NULL,
			    ErrorCode,
			    0,
			    (LPWSTR) &pMsgBuf,
			    0,
			    NULL);

    if (count != 0)
	{
        printf ("  (0x%08x) %ws\n", ErrorCode, pMsgBuf);
        LocalFree (pMsgBuf);
	}
    else
	{
        printf ("Format message failed.  Error: 0x%08x\n", GetLastError());
	}
    }



BOOL WINAPI CtrlC_HandlerRoutine (IN DWORD /* dwType */)
	{
	bExitApplication = TRUE;

	if (HandleValid (handleEventCancelIo))
	    {
	    SetEvent (handleEventCancelIo);
	    }



	// Mark that the break was handled.
	return TRUE;
	}





extern "C" __cdecl wmain (int argc, WCHAR *argv [])
    {
    HRESULT		hrStatus;
    NTSTATUS		ntStatus;
    HANDLE		handlePartitionManager = INVALID_HANDLE_VALUE;
    HANDLE		handleMonitorThread    = INVALID_HANDLE_VALUE;
    DWORD		idMonitorThread        = 0;
    DWORD		accessMode;
    DWORD		shareMode;
    DWORD		bytesReturned;
    DWORD		errorCode;
    BOOL		bSucceeded;


    ANSI_STRING		objName;
    UNICODE_STRING	unicodeName;
    OBJECT_ATTRIBUTES	objAttributes;
    IO_STATUS_BLOCK	ioStatusBlock;


    UNREFERENCED_PARAMETER (argc);
    UNREFERENCED_PARAMETER (argv);


    SetConsoleCtrlHandler (CtrlC_HandlerRoutine, TRUE);


    handleEventCancelIo = CreateEvent (NULL, FALSE, FALSE, NULL);


    //
    // Note it is important to access the device with 0 access mode so that
    // the file open code won't do extra I/O to the device
    //
    shareMode  = FILE_SHARE_READ | FILE_SHARE_WRITE;
    accessMode = GENERIC_READ | GENERIC_WRITE;


    RtlInitString (&objName, DefaultDevice);

    ntStatus = RtlAnsiStringToUnicodeString (&unicodeName,
					     &objName,
					     TRUE);

    hrStatus = HRESULT_FROM_NT (ntStatus);


    if (FAILED (hrStatus))
	{
	printf("Error converting device name %s to unicode. Error: 0x%08x\n",
	       DefaultDevice, 
	       hrStatus);
	}

    else
	{
        InitializeObjectAttributes (&objAttributes,
                                    &unicodeName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL);

        ntStatus = NtCreateFile (&handlePartitionManager,
                                 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                                 &objAttributes,
                                 &ioStatusBlock,
                                 NULL,
                                 FILE_ATTRIBUTE_NORMAL,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 FILE_OPEN,
                                 0,
                                 NULL,
                                 0);


        RtlFreeUnicodeString (&unicodeName);

	hrStatus = HRESULT_FROM_NT (ntStatus);
	}




    if (FAILED (hrStatus))
	{
	printf ("Error opening device %s. Error: 0x%08x.\n",
		DefaultDevice, 
		hrStatus );
	}

    else
	{
	handleMonitorThread = CreateThread (NULL, 
					    0,
					    MonitorThread,
					    handlePartitionManager,
					    0,
					    &idMonitorThread);

	hrStatus = GET_STATUS_FROM_HANDLE (handleMonitorThread);
	}




    if (SUCCEEDED (hrStatus))
	{
	/*
	** Loop pinging various disks until we tire of life.
	*/
	while (SUCCEEDED (hrStatus) && !bExitApplication)
	    {
	    char line [80];
	    fgets(line, sizeof (line), stdin);


	    bSucceeded = DeviceIoControl (handlePartitionManager,
					  IOCTL_DISK_UPDATE_PROPERTIES,
					  NULL,
					  0,
					  NULL,
					  0,
					  &bytesReturned,
					  NULL);


	    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	    if (FAILED (hrStatus))
		{
		errorCode = GetLastError ();

		printf ("Error updating disk properties; error was 0x%08x\n", hrStatus);

		PrintError (errorCode);
		}
	    }
	}



    if (HandleValid (handleMonitorThread))
	{
	bSucceeded = SetEvent (handleEventCancelIo);

	WaitForSingleObject (handleMonitorThread, INFINITE);

	CloseHandle (handleMonitorThread);
    	}


    if (HandleValid (handlePartitionManager))
	{
	ntStatus = NtClose (handlePartitionManager);
	}


    if (HandleValid (handleEventCancelIo))
	{
	CloseHandle (handleEventCancelIo);
	}


    return (hrStatus);
    }





DWORD WINAPI MonitorThread (LPVOID lpvThreadParam)
    {
    NTSTATUS				ntStatus;
    HRESULT				hrStatus;
    HANDLE				handlePartitionManager = (HANDLE) lpvThreadParam;
    DWORD				bytesReturned;
    ULONG				bufferLength;
    PARTMGR_SIGNATURE_CHECK_EPOCH	SignatureCheckBufferEpoch;
    PPARTMGR_SIGNATURE_CHECK_DISKS	pSignatureCheckBufferDisks;
    BOOL				bSucceeded;
    DWORD				errorCode;
    OVERLAPPED				asyncContext;
    IO_STATUS_BLOCK			ioStatusBlock;




    memset (&asyncContext, 0x00, sizeof (asyncContext));

    asyncContext.hEvent = CreateEvent (NULL, TRUE, FALSE, NULL);



    bufferLength = sizeof (PARTMGR_SIGNATURE_CHECK_DISKS) + sizeof (ULONG) * 10;

    pSignatureCheckBufferDisks = (PPARTMGR_SIGNATURE_CHECK_DISKS) malloc (bufferLength);


    SignatureCheckBufferEpoch.RequestEpoch = PARTMGR_REQUEST_CURRENT_DISK_EPOCH;

    bSucceeded = DeviceIoControl (handlePartitionManager,
				  IOCTL_PARTMGR_NOTIFY_SIGNATURE_CHECK,
				  &SignatureCheckBufferEpoch,
				  sizeof (SignatureCheckBufferEpoch),
				  pSignatureCheckBufferDisks,
				  bufferLength,
				  &bytesReturned,
				  NULL);


    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

    if (SUCCEEDED (hrStatus))
	{
	PrintResults (pSignatureCheckBufferDisks);
	}
    else
	{
	errorCode = GetLastError ();

	printf ("Error determining current epoch; error was 0x%08x\n", hrStatus);

	PrintError (errorCode);
	}




    while (SUCCEEDED (hrStatus) && (pSignatureCheckBufferDisks->CurrentEpoch > 0))
        {
	SignatureCheckBufferEpoch.RequestEpoch = pSignatureCheckBufferDisks->CurrentEpoch;


	bSucceeded = DeviceIoControl (handlePartitionManager,
				      IOCTL_PARTMGR_NOTIFY_SIGNATURE_CHECK,
				      &SignatureCheckBufferEpoch,
				      sizeof (SignatureCheckBufferEpoch),
				      pSignatureCheckBufferDisks,
				      bufferLength,
				      &bytesReturned,
				      &asyncContext);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	if (HRESULT_FROM_WIN32 (ERROR_IO_PENDING) == hrStatus)
	    {
	    DWORD	Result;
	    HANDLE	aWaitHandles [2];


	    aWaitHandles [0] = handleEventCancelIo;
	    aWaitHandles [1] = asyncContext.hEvent;

	    Result = WaitForMultipleObjects (SIZEOF_ARRAY (aWaitHandles),
					     aWaitHandles,
					     FALSE,
					     INFINITE);


	    switch (Result)
		{
		case WAIT_OBJECT_0 + 0:
		    ntStatus = NtCancelIoFile (handlePartitionManager, 
					       &ioStatusBlock);

		    /*
		    ** FALL THROUGH
		    */

		case WAIT_OBJECT_0 + 1:
		    bSucceeded = GetOverlappedResult (handlePartitionManager, 
						      &asyncContext,
						      &bytesReturned,
						      TRUE);

		    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

		    if (SUCCEEDED (hrStatus))
			{
			PrintResults (pSignatureCheckBufferDisks);
			}
		    else
			{
			errorCode = GetLastError ();
			printf ("Error waiting for notification; error was 0x%08x\n", hrStatus);
			PrintError (errorCode);
			}


		    ResetEvent (asyncContext.hEvent);
		    break;


		default:
		    ASSERT (FALSE);
		    break;
		}
	    }
	}





    free (pSignatureCheckBufferDisks);

    return (hrStatus);
    
    }


void PrintResults (PPARTMGR_SIGNATURE_CHECK_DISKS	pSignatureCheckBufferDisks)
    {
    ULONG	disk;

    printf ("Returned Values\n"
	    "\tCurrent Epoch:                    0x%08x\n"
	    "\tHighest Epoch for returned disks: 0x%08x\n"
	    "\tNumber of disks returned:         0x%08x\n"
	    "\tDisks\n",
	    pSignatureCheckBufferDisks->CurrentEpoch,
	    pSignatureCheckBufferDisks->HighestDiskEpochReturned,
	    pSignatureCheckBufferDisks->DiskNumbersReturned);

    for (disk = 0; disk < pSignatureCheckBufferDisks->DiskNumbersReturned; disk++)
	{
	printf ("\t\t0x%08x\n", pSignatureCheckBufferDisks->DiskNumber [disk]);
	}
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\partmgr\tests\sigcheck\sigcheck.cpp ===
#define INITGUID 1

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <partmgrp.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>


#define	PROGRAM_TITLE				L"SigCheck - Signature Check Program V0.1"


#define HandleInvalid(_Handle)			((NULL == (_Handle)) || (INVALID_HANDLE_VALUE == (_Handle)))

#define	GET_STATUS_FROM_BOOL(_bSucceeded)	((_bSucceeded)             ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_HANDLE(_handle)		((!HandleInvalid(_handle)) ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_POINTER(_ptr)		((NULL != (_ptr))          ? NOERROR : E_OUTOFMEMORY)


void PrintResults (PPARTMGR_SIGNATURE_CHECK_DISKS	pSignatureCheckBufferDisks);



PSTR PartitionName = "\\Device\\Harddisk%d\\Partition%d";
PSTR DeviceName    = "Harddisk0";



VOID PrintError (IN DWORD ErrorCode)
    {
    LPVOID lpMsgBuf;
    ULONG count;

    count = FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | 
			   FORMAT_MESSAGE_FROM_SYSTEM     |
			   FORMAT_MESSAGE_IGNORE_INSERTS,
			   NULL,
			   ErrorCode,
			   0,
			   (LPTSTR) &lpMsgBuf,
			   0,
			   NULL);

    if (count != 0)
	{
        printf ("  (%d) %s\n", ErrorCode, (LPCTSTR) lpMsgBuf);
        LocalFree (lpMsgBuf);
	}
    else
	{
        printf ("Format message failed.  Error: %d\n", GetLastError());
	}
    }   // PrintError
      


extern "C" __cdecl wmain (int argc, WCHAR *argv [])
    {
    NTSTATUS		ntStatus;
    HANDLE		fileHandle;
    DWORD		accessMode;
    DWORD		shareMode;
    DWORD		errorCode;
    BOOL		failed = FALSE;
    CHAR		deviceNameString [128];
    DWORD		bytesReturned;
    ULONG		bufferLength;
   

    ANSI_STRING		objName;
    UNICODE_STRING	unicodeName;
    OBJECT_ATTRIBUTES	objAttributes;
    IO_STATUS_BLOCK	ioStatusBlock;

    PARTMGR_SIGNATURE_CHECK_EPOCH	SignatureCheckBufferEpoch;
    PPARTMGR_SIGNATURE_CHECK_DISKS	pSignatureCheckBufferDisks;



    UNREFERENCED_PARAMETER (argc);
    UNREFERENCED_PARAMETER (argv);


    //
    // Note it is important to access the device with 0 access mode so that
    // the file open code won't do extra I/O to the device
    //
    shareMode  = FILE_SHARE_READ | FILE_SHARE_WRITE;
    accessMode = GENERIC_READ | GENERIC_WRITE;

    strcpy (deviceNameString, "\\\\.\\");
    strcat (deviceNameString, DeviceName);

    fileHandle = CreateFileA (deviceNameString,
			      accessMode,
			      shareMode,
			      NULL,
			      OPEN_EXISTING,
			      0,
			      NULL);

    if (fileHandle == INVALID_HANDLE_VALUE) 
	{
	errorCode = GetLastError ();
        if ((errorCode == ERROR_PATH_NOT_FOUND) ||
            (errorCode == ERROR_FILE_NOT_FOUND)) 
	    {
            strcpy (deviceNameString, "\\Device\\");
            strcat (deviceNameString, DeviceName);
            RtlInitString (&objName, deviceNameString);

            ntStatus = RtlAnsiStringToUnicodeString (&unicodeName,
                                                     &objName,
                                                     TRUE);

            if (!NT_SUCCESS(ntStatus))
		{
                printf ("Error converting device name %s to unicode. Error: %lx\n",
			deviceNameString, 
			ntStatus);

                return -1;
		}


            InitializeObjectAttributes (&objAttributes,
                                        &unicodeName,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL);

            ntStatus = NtCreateFile (&fileHandle,
                                     SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                                     &objAttributes,
                                     &ioStatusBlock,
                                     NULL,
                                     FILE_ATTRIBUTE_NORMAL,
                                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                                     FILE_OPEN,
                                     0,
                                     NULL,
                                     0);

            if (!NT_SUCCESS (ntStatus))
		{
                failed = TRUE;
		}

            RtlFreeUnicodeString (&unicodeName);
	    } 
	else
	    {
	    printf ("Error opening %s. Error: %d\n",
		    deviceNameString,
		    errorCode = GetLastError());

	    PrintError (errorCode);
	    return -1;
	    }
	}


    if (failed)
	{
        strcpy (deviceNameString, "\\Device\\");
        strcat (deviceNameString, DeviceName);
        strcat(deviceNameString, "\\Partition0");

        RtlInitString (&objName, deviceNameString);

        ntStatus = RtlAnsiStringToUnicodeString (&unicodeName,
                                                 &objName,
                                                 TRUE);

        if (!NT_SUCCESS(ntStatus))
	    {
            printf("Error converting device name %s to unicode. Error: %lx\n",
		   deviceNameString, ntStatus);
            return -1;
	    }


        InitializeObjectAttributes (&objAttributes,
                                    &unicodeName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL);

        ntStatus = NtCreateFile (&fileHandle,
                                 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                                 &objAttributes,
                                 &ioStatusBlock,
                                 NULL,
                                 FILE_ATTRIBUTE_NORMAL,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 FILE_OPEN,
                                 0,
                                 NULL,
                                 0);

        if (!NT_SUCCESS (ntStatus))
	    {
            printf("Error opening device %ws. Error: %lx.\n",
                   unicodeName.Buffer, ntStatus );
            return -1;
	    }


        RtlFreeUnicodeString (&unicodeName);
	}


    //printf("Accessing %s ... \n", deviceNameString);


    bufferLength = sizeof (PARTMGR_SIGNATURE_CHECK_DISKS) + sizeof (ULONG) * 10;

    pSignatureCheckBufferDisks = (PPARTMGR_SIGNATURE_CHECK_DISKS) malloc (bufferLength);


    SignatureCheckBufferEpoch.RequestEpoch = PARTMGR_REQUEST_CURRENT_DISK_EPOCH;

    failed = !DeviceIoControl (fileHandle,
			       IOCTL_PARTMGR_NOTIFY_SIGNATURE_CHECK,
			       &SignatureCheckBufferEpoch,
			       sizeof (SignatureCheckBufferEpoch),
			       pSignatureCheckBufferDisks,
			       bufferLength,
			       &bytesReturned,
			       FALSE);

    if (failed)
	{
	printf ("Error performing Claim; error was %d\n", errorCode = GetLastError());
	PrintError (errorCode);
	return errorCode;
	}
    else
	{
	PrintResults (pSignatureCheckBufferDisks);
	}





    SignatureCheckBufferEpoch.RequestEpoch = 9999999;

    failed = !DeviceIoControl (fileHandle,
			       IOCTL_PARTMGR_NOTIFY_SIGNATURE_CHECK,
			       &SignatureCheckBufferEpoch,
			       sizeof (SignatureCheckBufferEpoch),
			       pSignatureCheckBufferDisks,
			       bufferLength,
			       &bytesReturned,
			       FALSE);

    if (failed)
	{
	printf ("Error performing Claim; error was %d\n", errorCode = GetLastError());
	PrintError (errorCode);
	// return errorCode;
	}
    else
	{
	PrintResults (pSignatureCheckBufferDisks);
	}





    SignatureCheckBufferEpoch.RequestEpoch = PARTMGR_REQUEST_CURRENT_DISK_EPOCH;

    failed = !DeviceIoControl (fileHandle,
			       IOCTL_PARTMGR_NOTIFY_SIGNATURE_CHECK,
			       &SignatureCheckBufferEpoch,
			       sizeof (SignatureCheckBufferEpoch),
			       pSignatureCheckBufferDisks,
			       bufferLength,
			       &bytesReturned,
			       FALSE);

    if (failed)
	{
	printf ("Error performing Claim; error was %d\n", errorCode = GetLastError());
	PrintError (errorCode);
	return errorCode;
	}
    else
	{
	PrintResults (pSignatureCheckBufferDisks);
	}



    if (pSignatureCheckBufferDisks->CurrentEpoch > 0)
        {
	SignatureCheckBufferEpoch.RequestEpoch = pSignatureCheckBufferDisks->CurrentEpoch - 1;


	failed = !DeviceIoControl (fileHandle,
				   IOCTL_PARTMGR_NOTIFY_SIGNATURE_CHECK,
				   &SignatureCheckBufferEpoch,
				   sizeof (SignatureCheckBufferEpoch),
				   pSignatureCheckBufferDisks,
				   bufferLength,
				   &bytesReturned,
				   FALSE);

	if (failed)
	    {
	    printf ("Error performing Claim; error was %d\n", errorCode = GetLastError());
	    PrintError (errorCode);
	    return errorCode;
	    }
	else
	    {
	    PrintResults (pSignatureCheckBufferDisks);
	    }
	}




    SignatureCheckBufferEpoch.RequestEpoch = 0;

    failed = !DeviceIoControl (fileHandle,
			       IOCTL_PARTMGR_NOTIFY_SIGNATURE_CHECK,
			       &SignatureCheckBufferEpoch,
			       sizeof (SignatureCheckBufferEpoch),
			       pSignatureCheckBufferDisks,
			       bufferLength,
			       &bytesReturned,
			       FALSE);

    if (failed)
	{
	printf ("Error performing Claim; error was %d\n", errorCode = GetLastError());
	PrintError (errorCode);
	return errorCode;
	}
    else
	{
	PrintResults (pSignatureCheckBufferDisks);
	}




    SignatureCheckBufferEpoch.RequestEpoch = pSignatureCheckBufferDisks->CurrentEpoch;

    failed = !DeviceIoControl (fileHandle,
			       IOCTL_PARTMGR_NOTIFY_SIGNATURE_CHECK,
			       &SignatureCheckBufferEpoch,
			       sizeof (SignatureCheckBufferEpoch),
			       pSignatureCheckBufferDisks,
			       bufferLength,
			       &bytesReturned,
			       FALSE);

    if (failed)
	{
	printf ("Error performing Claim; error was %d\n", errorCode = GetLastError());
	PrintError (errorCode);
	return errorCode;
	}
    else
	{
	PrintResults (pSignatureCheckBufferDisks);
	}






    ntStatus = NtCancelIoFile (fileHandle, &ioStatusBlock);

    ntStatus = NtClose (fileHandle);

    return ERROR_SUCCESS;
    
    }


void PrintResults (PPARTMGR_SIGNATURE_CHECK_DISKS	pSignatureCheckBufferDisks)
    {
    ULONG	disk;

    printf ("Returned Values\n"
	    "\tCurrent Epoch:                    0x%08x\n"
	    "\tHighest Epoch for returned disks: 0x%08x\n"
	    "\tNumber of disks returned:         0x%08x\n"
	    "\tDisks\n",
	    pSignatureCheckBufferDisks->CurrentEpoch,
	    pSignatureCheckBufferDisks->HighestDiskEpochReturned,
	    pSignatureCheckBufferDisks->DiskNumbersReturned);

    for (disk = 0; disk < pSignatureCheckBufferDisks->DiskNumbersReturned; disk++)
	{
	printf ("\t\t0x%08x\n", pSignatureCheckBufferDisks->DiskNumber [disk]);
	}
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\lib\map.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

Abstract:

    The format of the SCSI (port driver) device map is as follows:
    
    Scsi Port 0 - KEY

        Driver - REG_SZ specifying the drive name, e.g., aha154x.

        Interrupt - REG_DWORD specifying the interrupt vector that the HBA
            uses. For example, 58.
            
        IOAddress - REG_DWORD specifying the IO address the HBA uses;
            for example, 0xd800.

        Dma64BidAddresses  - REG_DWORD specifying whether the HBA is using
            64 bit addresses or not. Should always be 1 if present.

        PCCARD - REG_DWORD specifying whether this is a PCCARD bus or not.
            The value will always be 1 if present.

        SCSI Bus 0 - KEY
        
            Initiator Id 7 - KEY
            
            Target Id 0 - KEY
            
                Logical Unit ID 0 - KEY
                
                    Identifier - REG_SZ specifying the SCSI Vendor ID from
                            the LUNs inquiry data.
                            
                    InquiryData - REG_BINARY specifies the SCSI Inquiry Data
                            for the LUN.
                            
                    SerialNumber - REG_SZ specifies the SCSI Serial Number
                            for the LUN if present.
                            
                    Type - REG_SZ specifies the SCSI device type for the LUN.

Usage:

    The module exports the following functions:

        PortOpenMapKey - Opens a handle to the root of the SCSI device map.

        PortBuildAdapterEntry - Creates an entry for the specified adapter
            in the SCSI device map.

        PortBuildBusEntry - Creates an entry for the specified bus in the
            SCSI device map.

        PortBuildTargetEntry - Creates an entry for the specified target in
            the SCSI device map.

        PortBuildLunEntry - Creates an entry for the specified LUN in the
            SCSI device map.
            
Author:

    Matthew D Hendel (math) 18-July-2002

Revision History:

--*/

#include "precomp.h"
#include <wdmguid.h>


//
// Defines
//


#define SCSI_DEVMAP_KEY_NAME \
    (L"\\Registry\\Machine\\Hardware\\DeviceMap\\Scsi")

#define SCSI_LUN_KEY_NAME\
    (L"%s\\Scsi Port %d\\SCSI Bus %d\\Target Id %d\\Logical Unit Id %d")



//
// Implementation
//

NTSTATUS
PortOpenMapKey(
    OUT PHANDLE DeviceMapKey
    )
/*++

Routine Description:

    Open a handle to the root of the SCSI Device Map.

    The handle must be  closed with ZwClose.
    
Arguments:

    DeviceMapKey - Supplies a buffer where the device map handle should
        be stored on success.

Return Value:

    NTSTATUS code.

--*/
{
    UNICODE_STRING name;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE mapKey;
    ULONG disposition;
    NTSTATUS status;

    ASSERT (DeviceMapKey != NULL);
    
    PAGED_CODE();

    //
    // Open the SCSI key in the device map.
    //

    RtlInitUnicodeString(&name, SCSI_DEVMAP_KEY_NAME);

    InitializeObjectAttributes(&objectAttributes,
                               &name,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    //
    // Create or open the key.
    //

    status = ZwCreateKey(&mapKey,
                         KEY_READ | KEY_WRITE,
                         &objectAttributes,
                         0,
                         (PUNICODE_STRING) NULL,
                         REG_OPTION_VOLATILE,
                         &disposition);

    if(NT_SUCCESS(status)) {
        *DeviceMapKey = mapKey;
    } else {
        *DeviceMapKey = NULL;
    }

    return status;
    
}
    

NTSTATUS
PortMapBuildAdapterEntry(
    IN HANDLE DeviceMapKey,
    IN ULONG PortNumber,
    IN ULONG InterruptLevel,    OPTIONAL
    IN ULONG IoAddress, OPTIONAL
    IN ULONG Dma64BitAddresses,
    IN PUNICODE_STRING DriverName,
    IN PGUID BusType, OPTIONAL
    OUT PHANDLE AdapterKeyBuffer OPTIONAL
    )
/*++

Routine Description:

    Create a device map entry for the SCSI HBA. We also include device
    map entries for each of the Busses attached to the HBA, and the initiator
    for each bus.

Arguments:

    DeviceMapKey -  Supplies the handle to the device map key.

    PortNumber -  Supplies the port number that this HBA represents.

    InterruptLevel - Supplies the interrupt level, or 0 for none.
    
    IoAddress - Supplies the IoAddress or 0 for none.

    Dma64BitAddress -

    DriverName - NULL terminated unicode string that is the driver name.

    BusType - Bus type that this HBA is on.

    AdapterKeyBuffer - 

Return Value:

    NTSTATUS code.
    
--*/
{
    NTSTATUS Status;
    ULONG Temp;
    HANDLE AdapterKey;
    

    PAGED_CODE();

    //
    // String must be NULL terminated.
    //
    
    ASSERT (DriverName->Buffer [DriverName->Length / sizeof (WCHAR)] == UNICODE_NULL);

    Status = PortCreateKeyEx (DeviceMapKey,
                              REG_OPTION_VOLATILE,
                              &AdapterKey,
                              L"Scsi Port %d",
                              PortNumber);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Add interrupt level if non-zero.
    //
    
    if (InterruptLevel) {
        Status = PortSetValueKey (AdapterKey,
                                  L"Interrupt", 
                                  REG_DWORD,
                                  &InterruptLevel,
                                  sizeof (ULONG));
    }

    //
    // Add IoAddress if non-zero.
    //
    
    if (IoAddress) {
        Status = PortSetValueKey (AdapterKey,
                                  L"IOAddress",
                                  REG_DWORD,
                                  &IoAddress,
                                  sizeof (ULONG));
    }

    //
    // Add Dma64BitAddresses if non-zero.
    //
    
    if (Dma64BitAddresses) {
        Temp = 1;
        Status = PortSetValueKey (AdapterKey,
                                  L"Dma64BitAddresses",
                                  REG_DWORD,
                                  &Temp,
                                  sizeof (ULONG));
    }


    //
    // Add the driver name.
    //
    
    Status = PortSetValueKey (AdapterKey,
                              L"Driver",
                              REG_SZ,
                              DriverName->Buffer,
                              DriverName->Length + sizeof (WCHAR));

    //
    // If this is a PCMCIA card, set the PCCARD flag.
    //
    
    if (BusType != NULL &&
        IsEqualGUID (BusType, &GUID_BUS_TYPE_PCMCIA)) {

        Temp = 1;
        Status = PortSetValueKey (AdapterKey,
                                  L"PCCARD",
                                  REG_DWORD,
                                  &Temp,
                                  sizeof (ULONG));
    }

    if (AdapterKeyBuffer != NULL) {
        *AdapterKeyBuffer = AdapterKey;
    } else {
        ZwClose (AdapterKey);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
PortMapBuildBusEntry(
    IN HANDLE AdapterKey,
    IN ULONG BusId,
    IN ULONG InitiatorId,
    OUT PHANDLE BusKeyBuffer OPTIONAL
    )
/*++

Routine Description:

    Build the BusId device map entry under the adapters device map entry. The
    bus entry is populated with an entry for the initiator ID only.

Arguments:

    AdapterKey - Handle to the adapter's device map entry.

    BusId - Supplies the ID of this bus.

    InitiatorId - Supplies the initiator target ID.

    BusKeyBuffer _ Supplies an optional pointer to a buffer to receive the
        opened bus key.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    HANDLE BusKey;

    ASSERT (BusId <= 255);
    ASSERT (InitiatorId <= 255);

    PAGED_CODE();

    Status = PortCreateKeyEx (AdapterKey,
                              REG_OPTION_VOLATILE,
                              &BusKey,
                              L"SCSI Bus %d",
                              BusId);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }
        
    PortCreateKeyEx (BusKey,
                     REG_OPTION_VOLATILE,
                     NULL,
                     L"Initiator Id %d",
                     InitiatorId);
    
    if (BusKeyBuffer) {
        *BusKeyBuffer = BusKey;
    } else {
        ZwClose (BusKey);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PortMapBuildTargetEntry(
    IN HANDLE BusKey,
    IN ULONG TargetId,
    OUT PHANDLE TargetKey OPTIONAL
    )
{
    NTSTATUS Status;

    ASSERT (TargetId <= 255);
    
    PAGED_CODE();

    Status = PortCreateKeyEx (BusKey,
                              REG_OPTION_VOLATILE,
                              TargetKey,
                              L"Target Id %d",
                              TargetId);

    return Status;
}

NTSTATUS
PortMapBuildLunEntry(
    IN HANDLE TargetKey,
    IN ULONG Lun,
    IN PINQUIRYDATA InquiryData,
    IN PANSI_STRING SerialNumber, OPTIONAL
    PVOID DeviceId,
    IN ULONG DeviceIdLength,
    OUT PHANDLE LunKeyBuffer OPTIONAL
    )
/*++

Routine Description:

    Create and populate the Logical Unit Device Map Entry with the following
    information:

        Identifier - REG_SZ specifying the SCSI Vendor Id from the inquriy
            data.

        InquiryData - REG_BINARY specifying the SCSI InquiryData.

        SerialNumber - REG_SZ specifying the serial number (page 80 of Inquriy
            VPD).

        Type - REG_SZ specifying the SCSI device type.

        DeviceIdentifierPage - REG_BINARY specifying the binary device
            identifier data (page 83 of VPD).

Arguments:

    TargetKey - Specifies the Target's previously opened key.
    
    Lun - Specifies the Logical Unit ID for this LUN.
    
    InquiryData - Specifies the binary inquriy data for this LUN. NOTE: Only
        the first INQUIRYDATABUFFERSIZE bytes of the Inquiry data are used.
        
    SerialNumber - Specifies the ANSI Serial Number (page 80) for the LUN. May
        be NULL if there is no serial number.
    
    DeviceId - Specifies the device identifier page (page 83) for the LUN. May
        be NULL if the device does not support page 83.
    
    DeviceIdLength - Specifies the length of the DeviceId parameter. Not used
        when DeviceId is NULL.
    
    LunKeyReturn - Specifies the buffer for key for the logical unit to
        be copied to. May be NULL if not necessary.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    HANDLE LunKey;
    PCSCSI_DEVICE_TYPE DeviceEntry;
    ULONG Length;

    ASSERT (Lun <= 255);
    ASSERT (InquiryData != NULL);

    PAGED_CODE();

    Status = PortCreateKeyEx (TargetKey,
                              REG_OPTION_VOLATILE,
                              &LunKey,
                              L"Logical Unit Id %d",
                              Lun);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Write out the INQUIRY DATA in binary form.
    //
    
    PortSetValueKey (LunKey,
                     L"InquiryData",
                     REG_BINARY,
                     InquiryData,
                     INQUIRYDATABUFFERSIZE);

    //
    // Write out the SERIAL NUMBER as a string.
    //

    if (SerialNumber->Length != 0) {
        PortSetValueKey (LunKey,
                         L"SerialNumber",
                         PORT_REG_ANSI_STRING,
                         SerialNumber->Buffer,
                         SerialNumber->Length);
    }
    
    //
    // Write the SCSI VendorId.
    //

    PortSetValueKey (LunKey,
                     L"Identifier",
                     PORT_REG_ANSI_STRING,
                     InquiryData->VendorId,
                     sizeof (InquiryData->VendorId));
    //
    // Add the DeviceType entry as a string.
    //

    DeviceEntry = PortGetDeviceType (InquiryData->DeviceType);
    Length = wcslen (DeviceEntry->DeviceMap);
    
    PortSetValueKey (LunKey,
                    L"DeviceType",
                    REG_SZ,
                    (PVOID)DeviceEntry->DeviceMap,
                    (Length + 1) * sizeof (WCHAR));

    //
    // Write out the DeviceIdentifierPage if it was given.
    //
    
    if (DeviceId != NULL) {
        PortSetValueKey (LunKey,
                         L"DeviceIdentifierPage",
                         REG_BINARY,
                         DeviceId,
                         DeviceIdLength);
    }

    if (LunKeyBuffer) {
        *LunKeyBuffer = LunKey;
    }

    return STATUS_SUCCESS;
}
    

NTSTATUS
PortMapDeleteAdapterEntry(
    IN ULONG PortId
    )
/*++

Routine Description:

    Delete the Adapter's SCSI DeviceMap entry from the registry.

Arguments:

    PortId - PortId associated with the adapter.

Return Value:

    NTSTATUS code.

--*/
{
    HANDLE AdapterKey;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyName;
    WCHAR KeyNameBuffer[256];
    
    PAGED_CODE();

    swprintf (KeyNameBuffer,
              L"%s\\Scsi Port %d",
              SCSI_DEVMAP_KEY_NAME,
              PortId);

    RtlInitUnicodeString (&KeyName, KeyNameBuffer);

    InitializeObjectAttributes (&ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);

    Status = ZwOpenKey (&AdapterKey,
                        KEY_ALL_ACCESS,
                        &ObjectAttributes);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ZwDeleteKey (AdapterKey);
    ZwClose (AdapterKey);

    return Status;
}
    
    
    
NTSTATUS
PortMapDeleteLunEntry(
    IN ULONG PortId,
    IN ULONG BusId,
    IN ULONG TargetId,
    IN ULONG Lun
    )
/*++

Routine Description:

    Delete the logical unit's SCSI DeviceMap entry from the registry.

Arguments:

    PortId - Port ID associaed with the adapter.

    BusId - Bus ID / PathId that this logical unit is on.

    TargetId - Target that this logical unit is on.

    Lun - Logical unit ID for this LUN.

Return Value:

    NTSTATUS code.

--*/
{
    HANDLE LunKey;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyName;
    WCHAR KeyNameBuffer[256];
    
    PAGED_CODE();

    swprintf (KeyNameBuffer,
              SCSI_LUN_KEY_NAME,
              SCSI_DEVMAP_KEY_NAME,
              PortId,
              BusId,
              TargetId,
              Lun);

    RtlInitUnicodeString (&KeyName, KeyNameBuffer);

    InitializeObjectAttributes (&ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);

    Status = ZwOpenKey (&LunKey,
                        KEY_ALL_ACCESS,
                        &ObjectAttributes);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ZwDeleteKey (LunKey);
    ZwClose (LunKey);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\diskdump\diskdump.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    diskdump.c

Abstract:

    This is a special SCSI driver that serves as a combined SCSI disk
    class driver and SCSI manager for SCSI miniport drivers. It's sole
    responsibility is to provide disk services to copy physical memory
    into a portion of the disk as a record of a system crash.

Author:

    Mike Glass

Notes:

    Ported from osloader SCSI modules which were originally developed by
    Jeff Havens and Mike Glass.

Revision History:

--*/


#include "ntosp.h"
#include "stdarg.h"
#include "stdio.h"
#include "storport.h"
#include "ntdddisk.h"
#include "diskdump.h"

//
// Need a couple of aliases since we build w/ storport.h vs srb.h.
//

enum {
    CallDisableInterrupts = _obsolete1,
    CallEnableInterrupts = _obsolete2
};

typedef PHYSICAL_ADDRESS SCSI_PHYSICAL_ADDRESS, *PSCSI_PHYSICAL_ADDRESS;

#undef ScsiPortConvertPhysicalAddressToUlong

#if DBG
#undef DebugPrint
#define DebugPrint(x) ScsiDebugPrint x
#endif

extern PBOOLEAN Mm64BitPhysicalAddress;

//
// The scsi dump driver needs to allocate memory out of it's own, private
// allocation pool. This necessary to prevent pool corruption from
// preventing a successful crashdump.
//

#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#ifdef ExFreePool
#undef ExFreePool
#endif

#define ExAllocatePool C_ASSERT (FALSE)
#define ExFreePool     C_ASSERT (FALSE)

PDEVICE_EXTENSION DeviceExtension;

#define SECONDS         (1000 * 1000)
#define RESET_DELAY     (4 * SECONDS)

typedef
BOOLEAN
(*PSTOR_SYNCHRONIZED_ACCESS)(
    IN PVOID HwDeviceExtension,
    IN PVOID Context
    );
            
VOID
ExecuteSrb(
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN
ResetBus(
    IN PDEVICE_EXTENSION pDevExt,
    IN ULONG PathId
    );


VOID
FreeScatterGatherList(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );
    
ULONG
ScsiPortConvertPhysicalAddressToUlong(
    PHYSICAL_ADDRESS Address
    );

VOID
ScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );
    
//
// Routines start
//


VOID
FreePool(
    IN PVOID Ptr
    )

/*++

Routine Description:

    free block of memory.

Arguments:

    ptr - The memory to free.

Return Value:

    None.

--*/

{
    PMEMORY_HEADER freedBlock;

    //
    // Don't try to coalesce.  They will probably just ask for something
    // of just this size again.
    //

    freedBlock = (PMEMORY_HEADER)Ptr - 1;
    freedBlock->Next = DeviceExtension->FreeMemory;
    DeviceExtension->FreeMemory = freedBlock;

}


PVOID
AllocatePool(
    IN ULONG Size
    )

/*++

Routine Description:

    Allocate block of memory. Uses first fit algorithm.
    The free memory pointer always points to the beginning of the zone.

Arguments:

    Size - size of memory to be allocated.

Return Value:

    Address of memory block.

--*/

{
    PMEMORY_HEADER descriptor = DeviceExtension->FreeMemory;
    PMEMORY_HEADER previous = NULL;
    ULONG length;

    //
    // Adjust size for memory header and round up memory to 16 bytes.
    //

    length = (Size + sizeof(MEMORY_HEADER) + 15) & ~15;

    //
    // Walk free list looking for first block of memory equal to
    // or greater than (adjusted) size requested.
    //

    while (descriptor) {
        if (descriptor->Length >= length) {

            //
            // Update free list eliminating as much of this block as necessary.
            //
            // Make sure if we don't have enough of the block left for a
            // memory header we just point to the next block (and adjust
            // length accordingly).
            //

            if (!previous) {

                if (descriptor->Length < (length+sizeof(MEMORY_HEADER))) {
                    DeviceExtension->FreeMemory = DeviceExtension->FreeMemory->Next;
                } else {
                    DeviceExtension->FreeMemory =
                        (PMEMORY_HEADER)((PUCHAR)descriptor + length);
                    previous = DeviceExtension->FreeMemory;
                    previous->Length = descriptor->Length - length;
                    previous->Next = descriptor->Next;
                    descriptor->Length = length;
                }
            } else {
                if (descriptor->Length < (length+sizeof(MEMORY_HEADER))) {
                    previous->Next = descriptor->Next;
                } else {
                    previous->Next =
                        (PMEMORY_HEADER)((PUCHAR)descriptor + length);
                    previous->Next->Length = descriptor->Length - length;
                    previous->Next->Next = descriptor->Next;
                    descriptor->Length = length;
                }
            }

            //
            // Update memory header for allocated block.
            //

            descriptor->Next = NULL;

            //
            // Adjust address past header.
            //

            (PUCHAR)descriptor += sizeof(MEMORY_HEADER);

            break;
        }

        previous = descriptor;
        descriptor = descriptor->Next;
    }

    return descriptor;
}

BOOLEAN
DiskDumpOpen(
    IN LARGE_INTEGER PartitionOffset
    )

/*++

Routine Description:

    This is the entry point for open requests to the diskdump driver.

Arguments:

    PartitionOffset - Byte offset of partition on disk.

Return Value:

    TRUE

--*/

{
    //
    // Update partition object in device extension for this partition.
    //

    DeviceExtension->PartitionOffset = PartitionOffset;

    return TRUE;

}


VOID
WorkHorseDpc(
    )

/*++

Routine Description:

    Handle miniport notification.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->Srb;

    //
    // Check for a flush DMA adapter object request.  Note that
    // on the finish up code this will have been already cleared.
    //
    if (DeviceExtension->InterruptFlags & PD_FLUSH_ADAPTER_BUFFERS) {

        //
        // Call IoFlushAdapterBuffers using the parameters saved from the last
        // IoMapTransfer call.
        //

        IoFlushAdapterBuffers(
            DeviceExtension->DmaAdapterObject,
            DeviceExtension->Mdl,
            DeviceExtension->MapRegisterBase[1],
            DeviceExtension->FlushAdapterParameters.LogicalAddress,
            DeviceExtension->FlushAdapterParameters.Length,
            (BOOLEAN)(DeviceExtension->FlushAdapterParameters.Srb->SrbFlags
                & SRB_FLAGS_DATA_OUT ? TRUE : FALSE));

        DeviceExtension->InterruptFlags &= ~PD_FLUSH_ADAPTER_BUFFERS;
    }

    //
    // Check for an IoMapTransfer DMA request.  Note that on the finish
    // up code, this will have been cleared.
    //

    if (DeviceExtension->InterruptFlags & PD_MAP_TRANSFER) {

        //
        // Call IoMapTransfer using the parameters saved from the
        // interrupt level.
        //

        IoMapTransfer(
            DeviceExtension->DmaAdapterObject,
            DeviceExtension->Mdl,
            DeviceExtension->MapRegisterBase[1],
            DeviceExtension->MapTransferParameters.LogicalAddress,
            &DeviceExtension->MapTransferParameters.Length,
            (BOOLEAN)(DeviceExtension->MapTransferParameters.Srb->SrbFlags
                      & SRB_FLAGS_DATA_OUT ? TRUE : FALSE));

        //
        // Save the paramters for IoFlushAdapterBuffers.
        //

        DeviceExtension->FlushAdapterParameters =
            DeviceExtension->MapTransferParameters;

        DeviceExtension->InterruptFlags &= ~PD_MAP_TRANSFER;
        DeviceExtension->Flags |= PD_CALL_DMA_STARTED;
    }

    //
    // Process any completed requests.
    //

    if (DeviceExtension->RequestComplete) {

        //
        // Reset request timeout counter.
        //

        DeviceExtension->RequestTimeoutCounter = -1;
        DeviceExtension->RequestComplete = FALSE;
        DeviceExtension->RequestPending = FALSE;

        //
        // Flush the adapter buffers if necessary.
        //

        if (DeviceExtension->MasterWithAdapter) {
            FreeScatterGatherList (DeviceExtension, srb);
        }

        if (srb->SrbStatus != SRB_STATUS_SUCCESS) {
            
            if ( ((srb->ScsiStatus == SCSISTAT_BUSY) || 
                  (srb->SrbStatus == SRB_STATUS_BUSY) )&&
                 (DeviceExtension->RetryCount++ < 20)) {

                //
                // If busy status is returned, then indicate that the logical
                // unit is busy.  The timeout code will restart the request
                // when it fires. Reset the status to pending.
                //

                srb->SrbStatus = SRB_STATUS_PENDING;
                DeviceExtension->Flags |= PD_LOGICAL_UNIT_IS_BUSY;

                //
                // Restore the data transfer length.
                //

                srb->DataTransferLength = DeviceExtension->ByteCount;
                DeviceExtension->RequestPending = TRUE;
            }
        }

        //
        // Make MDL pointer NULL to show there is no outstanding request.
        //

        DeviceExtension->Mdl = NULL;
    }
}


VOID
RequestSenseCompletion(
    )

/*++

Routine Description:

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->RequestSenseSrb;
    PSCSI_REQUEST_BLOCK failingSrb = &DeviceExtension->Srb;
    PSENSE_DATA senseBuffer = DeviceExtension->RequestSenseBuffer;

    //
    // Request sense completed. If successful or data over/underrun
    // get the failing SRB and indicate that the sense information
    // is valid. The class driver will check for underrun and determine
    // if there is enough sense information to be useful.
    //

    if ((SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS) ||
        (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN)) {

        //
        // Check that request sense buffer is valid.
        //

        if (srb->DataTransferLength >= FIELD_OFFSET(SENSE_DATA, CommandSpecificInformation)) {

            DebugPrint((1,"RequestSenseCompletion: Error code is %x\n",
                        senseBuffer->ErrorCode));
            DebugPrint((1,"RequestSenseCompletion: Sense key is %x\n",
                        senseBuffer->SenseKey));
            DebugPrint((1, "RequestSenseCompletion: Additional sense code is %x\n",
                        senseBuffer->AdditionalSenseCode));
            DebugPrint((1, "RequestSenseCompletion: Additional sense code qualifier is %x\n",
                      senseBuffer->AdditionalSenseCodeQualifier));
        }
    }

    //
    // Complete original request.
    //

    DeviceExtension->RequestComplete = TRUE;
    WorkHorseDpc();

}


VOID
IssueRequestSense(
    )

/*++

Routine Description:

    This routine creates a REQUEST SENSE request and sends it to the miniport
    driver.
    The completion routine cleans up the data structures
    and processes the logical unit queue according to the flags.

    A pointer to failing SRB is stored at the end of the request sense
    Srb, so that the completion routine can find it.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->RequestSenseSrb;
    PCDB cdb = (PCDB)srb->Cdb;
    PPFN_NUMBER page;
    PFN_NUMBER localMdl[ (sizeof(MDL)/sizeof(PFN_NUMBER)) + (MAXIMUM_TRANSFER_SIZE / PAGE_SIZE) + 2];

    //
    // Zero SRB.
    //

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Build REQUEST SENSE SRB.
    //

    srb->TargetId = DeviceExtension->Srb.TargetId;
    srb->Lun = DeviceExtension->Srb.Lun;
    srb->PathId = DeviceExtension->Srb.PathId;
    srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->DataBuffer = DeviceExtension->RequestSenseBuffer;
    srb->DataTransferLength = sizeof(SENSE_DATA);
    srb->ScsiStatus = srb->SrbStatus = 0;
    srb->NextSrb = 0;
    srb->CdbLength = 6;
    srb->TimeOutValue = 5;

    //
    // Build MDL and map it so that it can be used.
    //

    DeviceExtension->Mdl = (PMDL) &localMdl[0];
    MmInitializeMdl(DeviceExtension->Mdl,
                    srb->DataBuffer,
                    srb->DataTransferLength);

    page = MmGetMdlPfnArray ( DeviceExtension->Mdl );
    *page = (PFN_NUMBER)(DeviceExtension->PhysicalAddress[1].QuadPart >> PAGE_SHIFT);
    MmMapMemoryDumpMdl(DeviceExtension->Mdl);

    //
    // Disable auto request sense.
    //

    srb->SenseInfoBufferLength = 0;
    srb->SenseInfoBuffer = NULL;

    //
    // Set read and bypass frozen queue bits in flags.
    //

    srb->SrbFlags = SRB_FLAGS_DATA_IN |
                    SRB_FLAGS_BYPASS_FROZEN_QUEUE |
                    SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_AUTOSENSE |
                    SRB_FLAGS_DISABLE_DISCONNECT;

    //
    // REQUEST SENSE cdb looks like INQUIRY cdb.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
    cdb->CDB6INQUIRY.AllocationLength = sizeof(SENSE_DATA);

    //
    // Send SRB to miniport driver.
    //

    ExecuteSrb(srb);
}



ULONG
StartDevice(
    IN UCHAR    TargetId,
    IN UCHAR    Lun
    )
/*++

Routine Description:

    Starts up the target device.

Arguments:

    TargetId - the id of the device

    Lun - The logical unit number

Return Value:

    SRB status

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->RequestSenseSrb;
    PCDB cdb = (PCDB)srb->Cdb;
    ULONG retry;

    retry  = 0;
    DebugPrint((1,"StartDevice: Attempt to start device\n"));

retry_start:

    //
    // Zero SRB.
    //
    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));
    RtlZeroMemory(cdb, sizeof(CDB));

    srb->TargetId               = TargetId;
    srb->Lun                    = Lun;
    srb->PathId                 = DeviceExtension->Srb.PathId;
    srb->Length                 = sizeof(SCSI_REQUEST_BLOCK);
    srb->Function               = SRB_FUNCTION_EXECUTE_SCSI;

    srb->SrbFlags               = SRB_FLAGS_NO_DATA_TRANSFER |
                                    SRB_FLAGS_DISABLE_AUTOSENSE |
                                    SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                                    SRB_FLAGS_BYPASS_LOCKED_QUEUE;

    srb->CdbLength              = 6;

    srb->SrbStatus              = 0;
    srb->ScsiStatus             = 0;
    srb->NextSrb                = 0;
    srb->TimeOutValue           = 30;

    cdb->START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
    cdb->START_STOP.Start = 1;

    //
    // Send SRB to miniport driver.
    //
    ExecuteSrb(srb);

    if (srb->SrbStatus != SRB_STATUS_SUCCESS) {
        if (retry++ < 4) {
            DebugPrint((1,"StartDevice: Failed SRB STATUS: %x Retry #: %x\n",
                           srb->SrbStatus,retry));
            goto retry_start;
        }
    }

    return srb->SrbStatus;
}



VOID
AllocateScatterGatherList(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    Create a scatter/gather list for the specified IO.

Arguments:

    DeviceExtension - Device extension.

    Srb - Scsi Request block to create the scatter/gather list for.

Return Value:

    None.

--*/
{
    BOOLEAN succ;
    BOOLEAN writeToDevice;
    ULONG totalLength;
    PSCATTER_GATHER_ELEMENT scatterList;

    //
    // Calculate the number of map registers needed for this transfer.
    //

    DeviceExtension->NumberOfMapRegisters =
        ADDRESS_AND_SIZE_TO_SPAN_PAGES(Srb->DataBuffer,
                                       Srb->DataTransferLength);

    //
    // Build the scatter/gather list.
    //

    scatterList = DeviceExtension->ScatterGatherList.Elements;
    totalLength = 0;
    DeviceExtension->ScatterGatherList.NumberOfElements = 0;

    //
    // Build the scatter/gather list by looping through the transfer
    // calling I/O map transfer.
    //

    writeToDevice = Srb->SrbFlags & SRB_FLAGS_DATA_OUT ? TRUE : FALSE;

    while (totalLength < Srb->DataTransferLength) {

        //
        // Request that the rest of the transfer be mapped.
        //

        scatterList->Length = Srb->DataTransferLength - totalLength;

        //
        // Io is always done through the second map register.
        //

        scatterList->Address =
            IoMapTransfer (
                DeviceExtension->DmaAdapterObject,
                DeviceExtension->Mdl,
                DeviceExtension->MapRegisterBase[1],
                (PCCHAR) Srb->DataBuffer + totalLength,
                &scatterList->Length,
                writeToDevice);

        totalLength += scatterList->Length;
        scatterList++;
        DeviceExtension->ScatterGatherList.NumberOfElements++;
    }

}


VOID
FreeScatterGatherList(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    Free a scatter/gather list, freeing all resources associated with it.

Arguments:

    DeviceExtension - Device extension.

    Srb - Scsi Request block to free the scatter/gather list for.

Return Value:

    None.

--*/
{
    BOOLEAN succ;
    BOOLEAN writeToDevice;
    ULONG totalLength;
    PSCATTER_GATHER_ELEMENT scatterList;

    if (DeviceExtension->Mdl == NULL) {
        return;
    }
    
    scatterList = DeviceExtension->ScatterGatherList.Elements;
    totalLength = 0;

    //
    // Loop through the list, call IoFlushAdapterBuffers for each entry in
    // the list.
    //

    writeToDevice = Srb->SrbFlags & SRB_FLAGS_DATA_OUT ? TRUE : FALSE;

    while (totalLength < Srb->DataTransferLength) {

        //
        // Io is always done through the second map register.
        //

        succ = IoFlushAdapterBuffers(
                    DeviceExtension->DmaAdapterObject,
                    DeviceExtension->Mdl,
                    DeviceExtension->MapRegisterBase[1],
                    (PCCHAR)Srb->DataBuffer + totalLength,
                    scatterList->Length,
                    writeToDevice);
        ASSERT (succ == TRUE);
                
        totalLength += scatterList->Length;
        scatterList++;
    }
}


    

VOID
StartIo(
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

Arguments:

    Srb - Request to start.

Return Value:

    Nothing.

--*/

{
    ULONG totalLength;
    BOOLEAN writeToDevice;

    //
    // Set up SRB extension.
    //

    Srb->SrbExtension = DeviceExtension->SrbExtension;

    //
    // Flush the data buffer if necessary.
    //

    if (Srb->SrbFlags & (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)) {

        if (Srb->DataTransferLength > DeviceExtension->Capabilities.MaximumTransferLength) {

            DebugPrint((1,
                "StartIo: StartIo Length Exceeds limit (%x > %x)\n",
                Srb->DataTransferLength,
                DeviceExtension->Capabilities.MaximumTransferLength));
        }

        HalFlushIoBuffers(
            DeviceExtension->Mdl,
            (BOOLEAN) (Srb->SrbFlags & SRB_FLAGS_DATA_IN ? TRUE : FALSE),
            TRUE);

        //
        // Determine if this adapter needs map registers.
        //

        if (DeviceExtension->MasterWithAdapter) {
            AllocateScatterGatherList (DeviceExtension, Srb);
        }
    }

    //
    // Set request timeout value from Srb SCSI.
    //

    DeviceExtension->RequestTimeoutCounter = Srb->TimeOutValue;

    //
    // Send SRB to miniport driver. Miniport driver will notify when
    // it completes.
    //

    if (DeviceExtension->PortType == StorPort &&
        DeviceExtension->HwBuildIo != NULL) {

        DeviceExtension->HwBuildIo (DeviceExtension->HwDeviceExtension, Srb);
    }
    
    DeviceExtension->HwStartIo(DeviceExtension->HwDeviceExtension, Srb);
}


VOID
TickHandler(
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine simulates a 1-second tickhandler and is used to time
    requests.

Arguments:

    Srb - request being timed.

Return Value:

    None.

--*/

{
    if (DeviceExtension->RequestPending) {

        //
        // Check for busy requests.
        //

        if (DeviceExtension->Flags & PD_LOGICAL_UNIT_IS_BUSY) {

            DebugPrint((1,"TickHandler: Retrying busy status request\n"));

            //
            // Clear the busy flag and retry the request.
            //

            DeviceExtension->Flags &= ~PD_LOGICAL_UNIT_IS_BUSY;
            StartIo(Srb);

        } else if (DeviceExtension->RequestTimeoutCounter == 0) {

            ULONG i;

            //
            // Request timed out.
            //

            DebugPrint((1, "TickHandler: Request timed out\n"));
            DebugPrint((1,
                       "TickHandler: CDB operation code %x\n",
                       DeviceExtension->Srb.Cdb[0]));
            DebugPrint((1,
                       "TickHandler: Retry count %x\n",
                       DeviceExtension->RetryCount));

            //
            // Reset request timeout counter to unused state.
            //

            DeviceExtension->RequestTimeoutCounter = -1;

            if (!ResetBus(DeviceExtension, 0)) {

                DebugPrint((1,"Reset SCSI bus failed\n"));
            }

            //
            // Call the interupt handler for a few microseconds to clear any reset
            // interrupts.
            //

            for (i = 0; i < 1000 * 100; i++) {

                DeviceExtension->StallRoutine(10);

                if (DeviceExtension->HwInterrupt != NULL) {
                    DeviceExtension->HwInterrupt(DeviceExtension->HwDeviceExtension);
                }
            }

            //
            // Wait 2 seconds for the devices to recover after the reset.
            //

            DeviceExtension->StallRoutine(2 * SECONDS);

        } else if (DeviceExtension->RequestTimeoutCounter != -1) {

            DeviceExtension->RequestTimeoutCounter--;
        }
    }
}


VOID
ExecuteSrb(
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine calls the start I/O routine an waits for the request to
    complete.  During the wait for complete the interrupt routine is called,
    also the timer routines are called at the appropriate times.  After the
    request completes a check is made to determine if an request sense needs
    to be issued.

Arguments:

    Srb - Request to execute.

Return Value:

    Nothing.

--*/

{
    ULONG milliSecondTime;
    ULONG secondTime;
    ULONG completionDelay;

    //
    // Show request is pending.
    //

    DeviceExtension->RequestPending = TRUE;

    //
    // Start the request.
    //

    StartIo(Srb);

    //
    // The completion delay controls how long interrupts are serviced after
    // a request has been completed.  This allows interrupts which occur after
    // a completion to be serviced.
    //

    completionDelay = COMPLETION_DELAY;

    //
    // Wait for the SRB to complete.
    //

    while (DeviceExtension->RequestPending) {

        //
        // Wait 1 second then call the scsi port timer routine.
        //

        for (secondTime = 0; secondTime < 1000/ 250; secondTime++) {

            for (milliSecondTime = 0; milliSecondTime < (250 * 1000 / PD_INTERLOOP_STALL); milliSecondTime++) {

                if (!(DeviceExtension->Flags & PD_DISABLE_INTERRUPTS)) {

                    //
                    // Call miniport driver's interrupt routine.
                    //

                    if (DeviceExtension->HwInterrupt != NULL) {
                        DeviceExtension->HwInterrupt(DeviceExtension->HwDeviceExtension);
                    }
                }

                //
                // If the request is complete, call the interrupt routine
                // a few more times to clean up any extra interrupts.
                //

                if (!DeviceExtension->RequestPending) {
                    if (completionDelay-- == 0) {
                        goto done;
                    }
                }

                if (DeviceExtension->Flags & PD_ENABLE_CALL_REQUEST) {

                    //
                    // Call the miniport requested routine.
                    //

                    DeviceExtension->Flags &= ~PD_ENABLE_CALL_REQUEST;
                    DeviceExtension->HwRequestInterrupt(DeviceExtension->HwDeviceExtension);

                    if (DeviceExtension->Flags & PD_DISABLE_CALL_REQUEST) {

                        DeviceExtension->Flags &= ~(PD_DISABLE_INTERRUPTS | PD_DISABLE_CALL_REQUEST);
                        DeviceExtension->HwRequestInterrupt(DeviceExtension->HwDeviceExtension);
                    }
                }

                if (DeviceExtension->Flags & PD_CALL_DMA_STARTED) {

                    DeviceExtension->Flags &= ~PD_CALL_DMA_STARTED;

                    //
                    // Notify the miniport driver that the DMA has been
                    // started.
                    //

                    if (DeviceExtension->HwDmaStarted) {
                            DeviceExtension->HwDmaStarted(
                            DeviceExtension->HwDeviceExtension
                            );
                    }
                }

                //
                // This enforces the delay between calls to the interrupt routine.
                //
                
                DeviceExtension->StallRoutine(PD_INTERLOOP_STALL);

                //
                // Check the miniport timer.
                //

                if (DeviceExtension->TimerValue != 0) {

                    DeviceExtension->TimerValue--;

                    if (DeviceExtension->TimerValue == 0) {

                        //
                        // The timer timed out so called requested timer routine.
                        //

                        DeviceExtension->HwTimerRequest(DeviceExtension->HwDeviceExtension);
                    }
                }
            }
        }

        TickHandler(Srb);

        DebugPrint((1,"ExecuteSrb: Waiting for SRB request to complete (~3 sec)\n"));
    }

done:

    if (Srb == &DeviceExtension->Srb &&
        Srb->SrbStatus != SRB_STATUS_SUCCESS) {

        //
        // Determine if a REQUEST SENSE command needs to be done.
        //

        if ((Srb->ScsiStatus == SCSISTAT_CHECK_CONDITION) &&
            !DeviceExtension->FinishingUp) {

            //
            // Call IssueRequestSense and it will complete the request after
            // the REQUEST SENSE completes.
            //

            DebugPrint((1,
                       "ExecuteSrb: Issue request sense\n"));

            IssueRequestSense();
        }
    }
}


NTSTATUS
DiskDumpWrite(
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl
    )

/*++

Routine Description:

    This is the entry point for write requests to the diskdump driver.

Arguments:

    DiskByteOffset - Byte offset relative to beginning of partition.

    Mdl - Memory descriptor list that defines this request.

Return Value:

    Status of write operation.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->Srb;
    PCDB cdb = (PCDB)&srb->Cdb;
    ULONG blockOffset;
    ULONG blockCount;
    ULONG retryCount = 0;

    //
    // ISSUE - 2000/02/29 - math:
    //
    // This is here until the StartVa is page aligned in the dump code
    // (MmMapPhysicalMdl).
    //
    
    Mdl->StartVa = PAGE_ALIGN( Mdl->StartVa );

    DebugPrint((2,
               "Write memory at %x for %x bytes\n",
               Mdl->StartVa,
               Mdl->ByteCount));


writeRetry:
    if (retryCount) {
        //
        // Remap the Mdl for dump data if IssueRequestSense() is called
        // in ExecuteSrb() due to a write error.
        //
        MmMapMemoryDumpMdl(Mdl);
    }

    //
    // Zero SRB.
    //

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Save MDL in device extension.
    //

    DeviceExtension->Mdl = Mdl;

    //
    // Initialize SRB.
    //

    srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    srb->PathId = DeviceExtension->PathId;
    srb->TargetId = DeviceExtension->TargetId;
    srb->Lun = DeviceExtension->Lun;
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->SrbFlags = SRB_FLAGS_DATA_OUT |
                    SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_DISCONNECT |
                    SRB_FLAGS_DISABLE_AUTOSENSE;
    srb->SrbStatus = srb->ScsiStatus = 0;
    srb->NextSrb = 0;
    srb->TimeOutValue = 10;
    srb->CdbLength = 10;
    srb->DataTransferLength = Mdl->ByteCount;

    //
    // See if adapter needs the memory mapped.
    //

    if (DeviceExtension->MapBuffers) {

        srb->DataBuffer = Mdl->MappedSystemVa;

        //
        // ISSUE - 2000/02/29 - math: Work-around bad callers.
        //
        // MapBuffers indicates the adapter expects srb->DataBuffer to be a valid VA reference
        // MmMapDumpMdl initializes MappedSystemVa to point to a pre-defined VA region
        // Make sure StartVa points to the same page, some callers do not initialize all mdl fields
        //
        
        Mdl->StartVa = PAGE_ALIGN( Mdl->MappedSystemVa );
        
    } else {
        srb->DataBuffer = (PVOID)((PCHAR)Mdl->StartVa + Mdl->ByteOffset);
    }

    //
    // Initialize CDB for write command.
    //

    cdb->CDB10.OperationCode = SCSIOP_WRITE;

    //
    // Convert disk byte offset to block offset.
    //

    blockOffset = (ULONG)((DeviceExtension->PartitionOffset.QuadPart +
                           (*DiskByteOffset).QuadPart) /
                          DeviceExtension->BytesPerSector);

    //
    // Fill in CDB block address.
    //

    cdb->CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&blockOffset)->Byte3;
    cdb->CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&blockOffset)->Byte2;
    cdb->CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&blockOffset)->Byte1;
    cdb->CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&blockOffset)->Byte0;

    blockCount = Mdl->ByteCount >> DeviceExtension->SectorShift;

    cdb->CDB10.TransferBlocksMsb = ((PFOUR_BYTE)&blockCount)->Byte1;
    cdb->CDB10.TransferBlocksLsb = ((PFOUR_BYTE)&blockCount)->Byte0;

    //
    // Send SRB to miniport driver.
    //

    ExecuteSrb(srb);

    //
    // Retry SRBs returned with failing status.
    //

    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        DebugPrint((0,
                   "Write request failed with SRB status %x\n",
                   srb->SrbStatus));

        //
        // If retries not exhausted then retry request.
        //

        if (retryCount < 2) {

            retryCount++;
            goto writeRetry;
        }

        return STATUS_UNSUCCESSFUL;

    } else {

        return STATUS_SUCCESS;
    }
}


VOID
DiskDumpFinish(
    VOID
    )

/*++

Routine Description:

    This routine sends ops that finish up the write

Arguments:

    None.

Return Value:

    Status of write operation.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->Srb;
    PCDB cdb = (PCDB)&srb->Cdb;
    ULONG retryCount = 0;

    //
    // No data will be transfered with these two requests.  So set up
    // our extension so that we don't try to flush any buffers.
    //

    DeviceExtension->InterruptFlags &= ~PD_FLUSH_ADAPTER_BUFFERS;
    DeviceExtension->InterruptFlags &= ~PD_MAP_TRANSFER;
    DeviceExtension->MapRegisterBase[1] = 0;
    DeviceExtension->FinishingUp = TRUE;

    //
    // Zero SRB.
    //

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Initialize SRB.
    //

    srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    srb->PathId = DeviceExtension->PathId;
    srb->TargetId = DeviceExtension->TargetId;
    srb->Lun = DeviceExtension->Lun;
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_DISCONNECT |
                    SRB_FLAGS_DISABLE_AUTOSENSE;
    srb->SrbStatus = srb->ScsiStatus = 0;
    srb->NextSrb = 0;
    srb->TimeOutValue = 10;
    srb->CdbLength = 10;

    //
    // Initialize CDB for write command.
    //

    cdb->CDB10.OperationCode = SCSIOP_SYNCHRONIZE_CACHE;

    //
    // Send SRB to miniport driver.
    //

    ExecuteSrb(srb);

    srb->CdbLength = 0;
    srb->Function = SRB_FUNCTION_SHUTDOWN;
    srb->SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_DISCONNECT |
                    SRB_FLAGS_DISABLE_AUTOSENSE;
    srb->SrbStatus = srb->ScsiStatus = 0;
    srb->NextSrb = 0;
    srb->TimeOutValue = 0;

    ExecuteSrb(srb);


}


ULONG
GetDeviceTransferSize(
    PVOID   PortConfig
    )
{
    ULONG TransferLength;

    //
    // For all other bus types ISA, EISA, MicroChannel set to the minimum
    // known supported size (ex., 32kb)
    //

    TransferLength = MINIMUM_TRANSFER_SIZE;

    //
    // Return the maximum transfer size for the adapter.
    //
    
    if ( PortConfig ) {
    
        PPORT_CONFIGURATION_INFORMATION ConfigInfo = PortConfig;

        //
        // Init the transfer length if it exists in port config
        //
        
        if ( ConfigInfo->MaximumTransferLength ) {

            TransferLength = ConfigInfo->MaximumTransferLength;

        }

        //
        // If the bus is PCI then increase the maximum transfer size
        //
        
        if ( ConfigInfo->AdapterInterfaceType == PCIBus) {

            if ( TransferLength > MAXIMUM_TRANSFER_SIZE) {
                TransferLength = MAXIMUM_TRANSFER_SIZE;
            }

        } else {

            if (TransferLength > MINIMUM_TRANSFER_SIZE) {
                TransferLength = MINIMUM_TRANSFER_SIZE;
            }
        }
    }

    return TransferLength;
}



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the system's entry point into the diskdump driver.

Arguments:

    DriverObject - Not used.

    RegistryPath - Using this field to pass initialization parameters.

Return Value:

    STATUS_SUCCESS

--*/

{
    PDUMP_INITIALIZATION_CONTEXT context = (PDUMP_INITIALIZATION_CONTEXT)RegistryPath;
    PMEMORY_HEADER memoryHeader;
    ULONG i;
    PSCSI_ADDRESS TargetAddress;

    //
    // Zero the entire device extension and memory blocks.
    //
    RtlZeroMemory( context->MemoryBlock, 8*PAGE_SIZE );
    RtlZeroMemory( context->CommonBuffer[0], context->CommonBufferSize );
    RtlZeroMemory( context->CommonBuffer[1], context->CommonBufferSize );

    //
    // Allocate device extension from free memory block.
    //

    memoryHeader = (PMEMORY_HEADER)context->MemoryBlock;
    DeviceExtension =
        (PDEVICE_EXTENSION)((PUCHAR)memoryHeader + sizeof(MEMORY_HEADER));
    //
    // Initialize memory descriptor.
    //

    memoryHeader->Length =  sizeof(DEVICE_EXTENSION) + sizeof(MEMORY_HEADER);
    memoryHeader->Next = NULL;

    //
    // Fill in first free memory header.
    //

    DeviceExtension->FreeMemory =
        (PMEMORY_HEADER)((PUCHAR)memoryHeader + memoryHeader->Length);
    DeviceExtension->FreeMemory->Length =
        (8*PAGE_SIZE) - memoryHeader->Length;
    DeviceExtension->FreeMemory->Next = NULL;

    //
    // Store away init parameters.
    //

    DeviceExtension->StallRoutine = context->StallRoutine;
    DeviceExtension->CommonBufferSize = context->CommonBufferSize;
    TargetAddress = context->TargetAddress;
    
    //
    // Make sure that the common buffer size is backed by enough crash dump ptes
    // The size is defined by MAXIMUM_TRANSFER_SIZE
    //
    
    if (DeviceExtension->CommonBufferSize > MAXIMUM_TRANSFER_SIZE) {
        DeviceExtension->CommonBufferSize = MAXIMUM_TRANSFER_SIZE;
    }

    //
    // Formerly, we allowed NULL TargetAddresses. No more. We must have
    // a valid SCSI TargetAddress to create the dump. If not, just fail
    // here.
    //
    
    if ( TargetAddress == NULL ) {
        return STATUS_INVALID_PARAMETER;
    }
    
    DeviceExtension->PathId    = TargetAddress->PathId;
    DeviceExtension->TargetId  = TargetAddress->TargetId;
    DeviceExtension->Lun       = TargetAddress->Lun;

    DebugPrint((1,"DiskDump[DriverEntry] ScsiAddress.Length     = %x\n",TargetAddress->Length));
    DebugPrint((1,"DiskDump[DriverEntry] ScsiAddress.PortNumber = %x\n",TargetAddress->PortNumber));
    DebugPrint((1,"DiskDump[DriverEntry] ScisAddress.PathId     = %x\n",TargetAddress->PathId));
    DebugPrint((1,"DiskDump[DriverEntry] ScisAddress.TargetId   = %x\n",TargetAddress->TargetId));
    DebugPrint((1,"DiskDump[DriverEntry] ScisAddress.Lun        = %x\n",TargetAddress->Lun));

    //
    // Save off common buffer's virtual and physical addresses.
    //

    for (i = 0; i < 2; i++) {
        DeviceExtension->CommonBuffer[i] = context->CommonBuffer[i];

        //
        // Convert the va of the buffer to obtain the PhysicalAddress
        //
        DeviceExtension->PhysicalAddress[i] =
            MmGetPhysicalAddress(context->CommonBuffer[i]);
    }

    //
    // Save driver parameters.
    //

    DeviceExtension->DmaAdapterObject = (PADAPTER_OBJECT)context->AdapterObject;

    DeviceExtension->ConfigurationInformation =
        context->PortConfiguration;

    //
    // We need to fixup this field of the port configuration information.
    //
    
    if (*Mm64BitPhysicalAddress) {
        DeviceExtension->ConfigurationInformation->Dma64BitAddresses = SCSI_DMA64_SYSTEM_SUPPORTED;
    }

    DeviceExtension->MappedAddressList = NULL;

    if (context->MappedRegisterBase) {
        DeviceExtension->MappedAddressList =
            *(PMAPPED_ADDRESS *) context->MappedRegisterBase;
    }

    //
    // Initialize request tracking booleans.
    //

    DeviceExtension->RequestPending = FALSE;
    DeviceExtension->RequestComplete = FALSE;

    //
    // Return major entry points.
    //

    context->OpenRoutine = DiskDumpOpen;
    context->WriteRoutine = DiskDumpWrite;
    context->FinishRoutine = DiskDumpFinish;
    context->MaximumTransferSize = GetDeviceTransferSize(context->PortConfiguration);

    return STATUS_SUCCESS;
}



NTSTATUS
InitializeConfiguration(
    IN PHW_INITIALIZATION_DATA HwInitData,
    OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN BOOLEAN InitialCall
    )
/*++

Routine Description:

    This routine initializes the port configuration information structure.
    Any necessary information is extracted from the registery.

Arguments:

    DeviceExtension - Supplies the device extension.

    HwInitializationData - Supplies the initial miniport data.

    ConfigInfo - Supplies the configuration information to be
        initialized.

    InitialCall - Indicates that this is first call to this function.
        If InitialCall is FALSE, then the perivous configuration information
        is used to determine the new information.

Return Value:

    Returns a status indicating the success or fail of the initializaiton.

--*/

{
    ULONG i;

    //
    // If this is the initial call then zero the information and set
    // the structure to the uninitialized values.
    //

    if (InitialCall) {

        RtlZeroMemory(ConfigInfo, sizeof(PORT_CONFIGURATION_INFORMATION));

        ConfigInfo->Length = sizeof(PORT_CONFIGURATION_INFORMATION);
        ConfigInfo->AdapterInterfaceType = HwInitData->AdapterInterfaceType;
        ConfigInfo->InterruptMode = Latched;
        ConfigInfo->MaximumTransferLength = 0xffffffff;
        ConfigInfo->NumberOfPhysicalBreaks = 0xffffffff;
        ConfigInfo->DmaChannel = 0xffffffff;
        ConfigInfo->NumberOfAccessRanges = HwInitData->NumberOfAccessRanges;
        ConfigInfo->MaximumNumberOfTargets = 8;

        for (i = 0; i < 8; i++) {
            ConfigInfo->InitiatorBusId[i] = ~0;
        }
    }

    return STATUS_SUCCESS;

}



PINQUIRYDATA
IssueInquiry(
    )

/*++

Routine Description:

    This routine prepares an INQUIRY command that is sent to the miniport driver.

Arguments:

    None.

Return Value:

    Address of INQUIRY data.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->Srb;
    PCDB cdb = (PCDB)&srb->Cdb;
    ULONG retryCount = 0;
    PINQUIRYDATA inquiryData = DeviceExtension->CommonBuffer[1];
    PPFN_NUMBER page;
    PFN_NUMBER localMdl[(sizeof( MDL )/sizeof(PFN_NUMBER)) + (MAXIMUM_TRANSFER_SIZE / PAGE_SIZE) + 2];

inquiryRetry:

    //
    // Zero SRB.
    //

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Initialize SRB.
    //

    srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    srb->PathId = DeviceExtension->PathId;
    srb->TargetId = DeviceExtension->TargetId;
    srb->Lun = DeviceExtension->Lun;
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->SrbFlags = SRB_FLAGS_DATA_IN |
                    SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_DISCONNECT |
                    SRB_FLAGS_DISABLE_AUTOSENSE;
    srb->SrbStatus = srb->ScsiStatus = 0;
    srb->NextSrb = 0;
    srb->TimeOutValue = 5;
    srb->CdbLength = 6;
    srb->DataBuffer = inquiryData;
    srb->DataTransferLength = INQUIRYDATABUFFERSIZE;

    //
    // Build MDL and map it so that it can be used.
    //

    DeviceExtension->Mdl = (PMDL)&localMdl[0];
    MmInitializeMdl(DeviceExtension->Mdl,
                    srb->DataBuffer,
                    srb->DataTransferLength);

    page = MmGetMdlPfnArray ( DeviceExtension->Mdl );
    *page = (PFN_NUMBER)(DeviceExtension->PhysicalAddress[1].QuadPart >> PAGE_SHIFT);
    MmMapMemoryDumpMdl(DeviceExtension->Mdl);

    //
    // Initialize CDB for INQUIRY command.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;
    cdb->CDB6INQUIRY.LogicalUnitNumber = 0;
    cdb->CDB6INQUIRY.Reserved1 = 0;
    cdb->CDB6INQUIRY.AllocationLength = INQUIRYDATABUFFERSIZE;
    cdb->CDB6INQUIRY.PageCode = 0;
    cdb->CDB6INQUIRY.IReserved = 0;
    cdb->CDB6INQUIRY.Control = 0;

    //
    // Send SRB to miniport driver.
    //

    ExecuteSrb(srb);

    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS &&
        SRB_STATUS(srb->SrbStatus) != SRB_STATUS_DATA_OVERRUN) {

        DebugPrint((2,
                   "IssueInquiry: Inquiry failed SRB status %x\n",
                   srb->SrbStatus));

        if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SELECTION_TIMEOUT &&
            retryCount < 2) {

            //
            // If the selection did not time out then retry the request.
            //

            retryCount++;
            goto inquiryRetry;

        } else {
            return NULL;
        }
    }

    return inquiryData;

}

VOID
IssueReadCapacity(
    )

/*++

Routine Description:

    This routine prepares a READ CAPACITY command that is sent to the
    miniport driver.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->Srb;
    PCDB cdb = (PCDB)&srb->Cdb;
    PREAD_CAPACITY_DATA readCapacityData = DeviceExtension->CommonBuffer[1];
    ULONG retryCount = 0;
    PPFN_NUMBER page;
    PFN_NUMBER localMdl[(sizeof( MDL )/sizeof(PFN_NUMBER)) + (MAXIMUM_TRANSFER_SIZE / PAGE_SIZE) + 2];

    //
    // Zero SRB.
    //

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

readCapacityRetry:

    //
    // Initialize SRB.
    //

    srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    srb->PathId = DeviceExtension->PathId;
    srb->TargetId = DeviceExtension->TargetId;
    srb->Lun = DeviceExtension->Lun;
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->SrbFlags = SRB_FLAGS_DATA_IN |
                    SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_AUTOSENSE |
                    SRB_FLAGS_DISABLE_DISCONNECT;
    srb->SrbStatus = srb->ScsiStatus = 0;
    srb->NextSrb = 0;
    srb->TimeOutValue = 5;
    srb->CdbLength = 10;
    srb->DataBuffer = readCapacityData;
    srb->DataTransferLength = sizeof(READ_CAPACITY_DATA);

    //
    // Build MDL and map it so that it can be used.
    //

    DeviceExtension->Mdl = (PMDL) &localMdl[0];
    MmInitializeMdl(DeviceExtension->Mdl,
                    srb->DataBuffer,
                    srb->DataTransferLength);

    page = MmGetMdlPfnArray (DeviceExtension->Mdl);
    *page = (PFN_NUMBER)(DeviceExtension->PhysicalAddress[1].QuadPart >> PAGE_SHIFT);
    MmMapMemoryDumpMdl(DeviceExtension->Mdl);

    //
    // Initialize CDB.
    //

    cdb->CDB6GENERIC.OperationCode = SCSIOP_READ_CAPACITY;

    //
    // Send SRB to miniport driver.
    //

    ExecuteSrb(srb);

    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS &&
       (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_DATA_OVERRUN || srb->Cdb[0] == SCSIOP_READ_CAPACITY)) {

        DebugPrint((1,
                   "ReadCapacity failed SRB status %x\n",
                   srb->SrbStatus));

        if (retryCount < 2) {

            //
            // If the selection did not time out then retry the request.
            //

            retryCount++;
            goto readCapacityRetry;

        } else {

            //
            // Guess and hope that the block size is 512.
            //

            DeviceExtension->BytesPerSector = 512;
            DeviceExtension->SectorShift = 9;
        }

    } else {

        //
        // Assuming that the 2 lsb is the only non-zero byte, this puts it in
        // the right place.
        //

        DeviceExtension->BytesPerSector = readCapacityData->BytesPerBlock >> 8;
        WHICH_BIT(DeviceExtension->BytesPerSector, DeviceExtension->SectorShift);

        //
        // Check for return size of zero. Set to default size and pass the problem downstream
        //
        if (!DeviceExtension->BytesPerSector) {
            DeviceExtension->BytesPerSector = 512;
            DeviceExtension->SectorShift    = 9;
        }
    }
}


ULONG
ScsiPortInitialize(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN struct _HW_INITIALIZATION_DATA *HwInitializationData,
    IN PVOID HwContext
    )

/*++

Routine Description:

    This routine is called by miniport driver to complete initialization.
    Port configuration structure contains data from the miniport's previous
    initialization and all system resources should be assigned and valid.

Arguments:

    Argument1 - Not used.

    Argument2 - Not used.

    HwInitializationData - Miniport initialization structure

    HwContext - Value passed to miniport driver's config routine

Return Value:

    NT Status - STATUS_SUCCESS if boot device found.

--*/

{
    BOOLEAN succ;
    ULONG status;
    ULONG srbStatus;
    PPORT_CONFIGURATION_INFORMATION configInfo;
    PIO_SCSI_CAPABILITIES capabilities;
    ULONG length;
    BOOLEAN callAgain;
    UCHAR dumpString[] = "dump=1;";
    UCHAR crashDump[32];
    PINQUIRYDATA inquiryData;
    BOOLEAN allocatedConfigInfo;


    ASSERT ( DeviceExtension != NULL );

    //
    // Check if boot device has already been found.
    //

    if (DeviceExtension->FoundBootDevice) {
        return (ULONG)STATUS_UNSUCCESSFUL;
    }

    //
    // Initialization
    //

    DeviceExtension->HwDeviceExtension = NULL;
    DeviceExtension->SpecificLuExtension = NULL;
    configInfo = NULL;
    capabilities = NULL;
    inquiryData = NULL;
    allocatedConfigInfo = FALSE;
    
    
    RtlCopyMemory(crashDump,
                  dumpString,
                  strlen(dumpString) + 1);

    //
    // Check size of init data structure.
    //

    if (HwInitializationData->HwInitializationDataSize > sizeof(HW_INITIALIZATION_DATA)) {
        return (ULONG) STATUS_REVISION_MISMATCH;
    } else if (HwInitializationData->HwInitializationDataSize ==
              FIELD_OFFSET (HW_INITIALIZATION_DATA, HwBuildIo)) {
        DeviceExtension->PortType = ScsiPort;
    } else {
        DeviceExtension->PortType = StorPort;
    }

    //
    // Check that each required entry is not NULL.
    //

    if ((!HwInitializationData->HwInitialize) ||
        (!HwInitializationData->HwFindAdapter) ||
        (!HwInitializationData->HwResetBus)) {

        DebugPrint((0,
                   "ScsiPortInitialize: Miniport driver missing required entry\n"));
        return (ULONG)STATUS_UNSUCCESSFUL;
    }


    //
    // Set timer to -1 to indicate no outstanding request.
    //
    
    DeviceExtension->RequestTimeoutCounter = -1;

    //
    // Allocate memory for the miniport driver's device extension.
    //

    DeviceExtension->HwDeviceExtension =
        AllocatePool(HwInitializationData->DeviceExtensionSize);

    if (!DeviceExtension->HwDeviceExtension) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    
    //
    // Allocate memory for the hardware logical unit extension and
    // zero it out.
    //

    if (HwInitializationData->SpecificLuExtensionSize) {

        DeviceExtension->HwLogicalUnitExtensionSize =
            HwInitializationData->SpecificLuExtensionSize;

        DeviceExtension->SpecificLuExtension =
            AllocatePool (HwInitializationData->SpecificLuExtensionSize);

        if ( !DeviceExtension->SpecificLuExtension ) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto done;
        }
        
        RtlZeroMemory (
            DeviceExtension->SpecificLuExtension,
            DeviceExtension->HwLogicalUnitExtensionSize);
    }

    //
    // Save the dependent driver routines in the device extension.
    //

    DeviceExtension->HwInitialize = HwInitializationData->HwInitialize;
    DeviceExtension->HwStartIo = HwInitializationData->HwStartIo;
    DeviceExtension->HwInterrupt = HwInitializationData->HwInterrupt;
    DeviceExtension->HwReset = HwInitializationData->HwResetBus;
    DeviceExtension->HwDmaStarted = HwInitializationData->HwDmaStarted;
    DeviceExtension->HwLogicalUnitExtensionSize =
        HwInitializationData->SpecificLuExtensionSize;

    //
    // If STORPORT grab the HwBuildIo routine.
    //
    
    if (DeviceExtension->PortType == StorPort) {
        DeviceExtension->HwBuildIo = HwInitializationData->HwBuildIo;
    } else {
        DeviceExtension->HwBuildIo = NULL;
    }

                
    //
    // Get pointer to capabilities structure.
    //

    capabilities = &DeviceExtension->Capabilities;
    capabilities->Length = sizeof(IO_SCSI_CAPABILITIES);

    //
    // Check if port configuration information structure passed in from
    // the system is valid.
    //

    if (configInfo = DeviceExtension->ConfigurationInformation) {

        //
        // Check to see if this structure applies to this miniport
        // initialization.  As long as they ask for more access ranges
        // here than are required when they initialized with scsiport,
        // we should be fine.
        //

        if((configInfo->AdapterInterfaceType != HwInitializationData->AdapterInterfaceType) ||
           (HwInitializationData->NumberOfAccessRanges < configInfo->NumberOfAccessRanges)) {

            //
            // Don't initialize this time.
            //

            status = STATUS_NO_SUCH_DEVICE;
            goto done;
        }

    } else {

        //
        // Allocate a new configuration information structure.
        //

        configInfo = AllocatePool(sizeof(PORT_CONFIGURATION_INFORMATION));
        allocatedConfigInfo = TRUE;

        if ( !configInfo ) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto done;
        }

        configInfo->AccessRanges = NULL;

        //
        // Set up configuration information structure.
        //

        status = InitializeConfiguration(
                        HwInitializationData,
                        configInfo,
                        TRUE);

        if (!NT_SUCCESS (status)) {
            status = STATUS_NO_SUCH_DEVICE;
            goto done;
        }

        //
        // Allocate memory for access ranges.
        //

        configInfo->NumberOfAccessRanges =
            HwInitializationData->NumberOfAccessRanges;
        configInfo->AccessRanges =
            AllocatePool(sizeof(ACCESS_RANGE) * HwInitializationData->NumberOfAccessRanges);

        if (configInfo->AccessRanges == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto done;
        }

        //
        // Zero out access ranges.
        //

        RtlZeroMemory(configInfo->AccessRanges,
                      HwInitializationData->NumberOfAccessRanges
                      * sizeof(ACCESS_RANGE));
    }

    //
    // Determine the maximum transfer size for this adapter
    //
    
    capabilities->MaximumTransferLength = GetDeviceTransferSize(configInfo);
    
    DebugPrint ((1,
                "DiskDump: Port Capabilities MaxiumTransferLength = 0x%08x\n",
                 capabilities->MaximumTransferLength));
    //
    // Get address of SRB extension.
    //

    DeviceExtension->SrbExtension = DeviceExtension->CommonBuffer[0];
    DeviceExtension->SrbExtensionSize = HwInitializationData->SrbExtensionSize;

    length = HwInitializationData->SrbExtensionSize;
    length = (length + 7) &  ~7;

    //
    // Get address of request sense buffer.
    //

    DeviceExtension->RequestSenseBuffer = (PSENSE_DATA)
        ((PUCHAR)DeviceExtension->CommonBuffer[0] + length);

    length += sizeof(SENSE_DATA);
    length = (length + 7) &  ~7;

    //
    // Use the rest of the buffer for the noncached extension.
    //

    DeviceExtension->NonCachedExtension =
        (PUCHAR)DeviceExtension->CommonBuffer[0] + length;

    //
    // Save the maximum size noncached extension can be.
    //
    DeviceExtension->NonCachedExtensionSize = DeviceExtension->CommonBufferSize - length;

    //
    // If a map registers are required, then allocate them permanently
    // here using the adapter object passed in by the system.
    //
    
    if (DeviceExtension->DmaAdapterObject != NULL ) {
        LARGE_INTEGER pfn;
        PPFN_NUMBER page;
        PMDL mdl;
        ULONG numberOfPages;
        ULONG i;
        PFN_NUMBER localMdl[(sizeof( MDL )/sizeof (PFN_NUMBER)) + (MAXIMUM_TRANSFER_SIZE / PAGE_SIZE) + 2];

        //
        // Determine how many map registers are needed by considering
        // the maximum transfer size and the size of the two common buffers.
        //

        numberOfPages = capabilities->MaximumTransferLength / PAGE_SIZE;

        DeviceExtension->MapRegisterBase[0] =
            HalAllocateCrashDumpRegisters(DeviceExtension->DmaAdapterObject,
                                          &numberOfPages);


        numberOfPages = capabilities->MaximumTransferLength / PAGE_SIZE;

        DeviceExtension->MapRegisterBase[1] =
            HalAllocateCrashDumpRegisters(DeviceExtension->DmaAdapterObject,
                                          &numberOfPages);

        //
        // ISSUE - 2000/02/29 - math: Review.
        //
        //  We assume this always succeeds for MAX TRANSFER SIZE as long
        //  as max transfer size is less than 64k
        //

        //
        // Determine if adapter is a busmaster or uses slave DMA.
        //

        if (HwInitializationData->NeedPhysicalAddresses &&
            configInfo->Master) {

            DeviceExtension->MasterWithAdapter = TRUE;

        } else {

            DeviceExtension->MasterWithAdapter = FALSE;
        }
        //
        // Build MDL to describe the first common buffer.
        //

        mdl = (PMDL)&localMdl[0];
        MmInitializeMdl(mdl,
                        DeviceExtension->CommonBuffer[0],
                        DeviceExtension->CommonBufferSize);

        //
        // Get base of page index array at end of MDL.
        //
        page = MmGetMdlPfnArray (mdl);

        //
        // Calculate number of pages per memory block.
        //

        numberOfPages = DeviceExtension->CommonBufferSize / PAGE_SIZE;

        //
        // Fill in MDL description of first memory block.
        //

        for (i = 0; i < numberOfPages; i++) {

            //
            // Calculate first page.
            //

            *page = (PFN_NUMBER)((DeviceExtension->PhysicalAddress[0].QuadPart +
                             (PAGE_SIZE * i)) >> PAGE_SHIFT);
            page++;
        }

        mdl->MdlFlags = MDL_PAGES_LOCKED;

        //
        // We need to Map the entire buffer.
        //

        length = DeviceExtension->CommonBufferSize;

        //
        // Convert physical buffer addresses to logical.
        //

        DeviceExtension->LogicalAddress[0] =
            IoMapTransfer(
                 DeviceExtension->DmaAdapterObject,
                 mdl,
                 DeviceExtension->MapRegisterBase[0],
                 DeviceExtension->CommonBuffer[0],
                 &length,
                 FALSE);

        //
        // Build MDL to describe the second common buffer.
        //

        mdl = (PMDL)&localMdl[0];
        MmInitializeMdl(mdl,
                        DeviceExtension->CommonBuffer[1],
                        DeviceExtension->CommonBufferSize);

        //
        // Get base of page index array at end of MDL.
        //

        page = MmGetMdlPfnArray ( mdl );

        //
        // Calculate number of pages per memory block.
        //

        numberOfPages = DeviceExtension->CommonBufferSize / PAGE_SIZE;

        //
        // Fill in MDL description of first memory block.
        //

        for (i = 0; i < numberOfPages; i++) {

            //
            // Calculate first page.
            //

            *page = (PFN_NUMBER)((DeviceExtension->PhysicalAddress[1].QuadPart +
                            (PAGE_SIZE * i)) >> PAGE_SHIFT);

            page++;
        }

        //
        // We need to map the entire buffer.
        //
        
        length = DeviceExtension->CommonBufferSize;

        //
        // Convert physical buffer addresses to logical.
        //

        DeviceExtension->LogicalAddress[1] =
            IoMapTransfer(
                 DeviceExtension->DmaAdapterObject,
                 mdl,
                 DeviceExtension->MapRegisterBase[1],
                 DeviceExtension->CommonBuffer[1],
                 &length,
                 FALSE);
    } else {

        DeviceExtension->MasterWithAdapter = FALSE;

        DeviceExtension->LogicalAddress[0] =
            DeviceExtension->PhysicalAddress[0];
        DeviceExtension->LogicalAddress[1] =
            DeviceExtension->PhysicalAddress[1];

    }

    //
    // Call miniport driver's find adapter routine.
    //

    if (HwInitializationData->HwFindAdapter(DeviceExtension->HwDeviceExtension,
                                            HwContext,
                                            NULL,
                                            (PCHAR) crashDump,
                                            configInfo,
                                            &callAgain) != SP_RETURN_FOUND) {

        status = STATUS_NO_SUCH_DEVICE;
        goto done;
    }


    DebugPrint((1,
               "SCSI adapter IRQ is %d\n",
               configInfo->BusInterruptLevel));

    DebugPrint((1,
               "SCSI adapter ID is %d\n",
               configInfo->InitiatorBusId[0]));

    if (configInfo->NumberOfAccessRanges) {
        DebugPrint((1,
                   "SCSI IO address is %x\n",
                   ((*(configInfo->AccessRanges))[0]).RangeStart.LowPart));
    }

    //
    // Set indicater as to whether adapter needs mapped buffers.
    //

    DeviceExtension->MapBuffers = configInfo->MapBuffers;


    //
    // Set maximum number of page breaks.
    //

    capabilities->MaximumPhysicalPages = configInfo->NumberOfPhysicalBreaks;

    if (HwInitializationData->ReceiveEvent) {
        capabilities->SupportedAsynchronousEvents |=
            SRBEV_SCSI_ASYNC_NOTIFICATION;
    }

    capabilities->TaggedQueuing = HwInitializationData->TaggedQueuing;
    capabilities->AdapterScansDown = configInfo->AdapterScansDown;
    capabilities->AlignmentMask = configInfo->AlignmentMask;

    //
    // Make sure maximum nuber of pages is set to a reasonable value.
    // This occurs for miniports with no Dma adapter.
    //

    if (capabilities->MaximumPhysicalPages == 0) {

        capabilities->MaximumPhysicalPages =
            (ULONG)ROUND_TO_PAGES(capabilities->MaximumTransferLength) + 1;

        //
        // Honor any limit requested by the miniport.
        //

        if (configInfo->NumberOfPhysicalBreaks < capabilities->MaximumPhysicalPages) {

            capabilities->MaximumPhysicalPages =
                configInfo->NumberOfPhysicalBreaks;
        }
    }

    //
    // Get maximum target IDs.
    //

    if (configInfo->MaximumNumberOfTargets > SCSI_MAXIMUM_TARGETS_PER_BUS) {
        DeviceExtension->MaximumTargetIds = SCSI_MAXIMUM_TARGETS_PER_BUS;
    } else {
        DeviceExtension->MaximumTargetIds =
            configInfo->MaximumNumberOfTargets;
    }

    //
    // Get number of SCSI buses.
    //

    DeviceExtension->NumberOfBuses = configInfo->NumberOfBuses;

    //
    // Call the miniport driver to do its initialization.
    //

    if (!DeviceExtension->HwInitialize(DeviceExtension->HwDeviceExtension)) {
        status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // Issue the inquiry command.
    //

    inquiryData = IssueInquiry ();

    if (inquiryData == NULL) {
        status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    KdPrintEx ((
        DPFLTR_CRASHDUMP_ID,
        DPFLTR_TRACE_LEVEL,
        "DISKDUMP: Inquiry: Type %d Qual %d Mod %d %s\n",
        (LONG) inquiryData->DeviceType,
        (LONG) inquiryData->DeviceTypeQualifier,
        (LONG) inquiryData->DeviceTypeModifier,
        inquiryData->RemovableMedia ? "Removable" : "Non-Removable"));

    
    //
    // Reset the bus.
    //
    
    succ = ResetBus (DeviceExtension, DeviceExtension->PathId);

    if ( !succ ) {
        status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    //
    // Start the device.
    //
    
    srbStatus = StartDevice (
                    DeviceExtension->TargetId,
                    DeviceExtension->Lun);

    if (srbStatus != SRB_STATUS_SUCCESS) {

        //
        // SCSIOP_START_STOP_DEVICE is allowed to fail. Some adapters (AMI MegaRAID)
        // fail this request.
        //
        
        DebugPrint ((0, "DISKDUMP: PathId=%x TargetId=%x Lun=%x failed to start srbStatus = %d\n",
                    DeviceExtension->PathId, DeviceExtension->TargetId,
                    DeviceExtension->Lun, (LONG) srbStatus));
    }

    //
    // Initialize the driver's capacity data (BytesPerSector, etc.)
    //
    
    IssueReadCapacity ();
    
    //
    // NOTE: We may want to go a sanity check that we have actually found
    // the correct drive. On MBR disks this can be accomplished by looking
    // at the NTFT disk signature. On GPT disks we can look at the DiskId.
    // This only makes a difference if the crashdump code gave us the
    // wrong TargetId, Lun, which it should never do.
    //

    DeviceExtension->FoundBootDevice = TRUE;
    status = STATUS_SUCCESS;

done:

    //
    // On failure, free all resources.
    //
    
    if ( !NT_SUCCESS (status) ) {

        //
        // The config info can either come from space we allocated or from
        // the DUMP_INITIALIZATION_CONTEXT. If it was allocated and we failed
        // we need to free it.
        //

        if (allocatedConfigInfo && configInfo != NULL) {
            if (configInfo->AccessRanges != NULL) {
                FreePool (configInfo->AccessRanges);
                configInfo->AccessRanges = NULL;
            }

            FreePool (configInfo);
            configInfo = NULL;
        }

        if (DeviceExtension->HwDeviceExtension) {
            FreePool (DeviceExtension->HwDeviceExtension);
            DeviceExtension->HwDeviceExtension = NULL;
        }

        if (DeviceExtension->SpecificLuExtension) {
            FreePool (DeviceExtension->SpecificLuExtension);
            DeviceExtension->SpecificLuExtension = NULL;
        }
    }

    return (ULONG) status;
}

//
// Routines providing service to hardware dependent driver.
//


SCSI_PHYSICAL_ADDRESS
ScsiPortGetPhysicalAddress(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID VirtualAddress,
    OUT ULONG *Length
    )

/*++

Routine Description:

    This routine returns a 32-bit physical address to which a virtual address
    is mapped. There are 2 types addresses that can be translated via this call:

    - An address of memory from the two common buffers that the system provides
      for the crashdump disk drivers.

    - A data buffer address described in an MDL that the system provided with
      an IO request.

Arguments:

Return Value:

--*/

{
    PSCATTER_GATHER_ELEMENT scatterList;
    PMDL mdl;
    ULONG byteOffset;
    ULONG whichPage;
    PPFN_NUMBER pages;
    PHYSICAL_ADDRESS address;

    //
    // There are two distinct types of memory addresses for which a
    // physical address must be calculated.
    //
    // The first is the data buffer passed in an SRB.
    //
    // The second is an address within the common buffer which is
    // the noncached extension or SRB extensions.
    //

    if (Srb) {

        //
        // There are two distinct types of adapters that require physical
        // addresses.
        //
        // The first is busmaster devices for which scatter/gather lists
        // have already been built.
        //
        // The second is slave or system DMA devices. As the diskdump driver
        // will program the system DMA hardware, the miniport driver will never
        // need to see the physical addresses, so I don't think it will ever
        // make this call.
        //

        if (DeviceExtension->MasterWithAdapter) {

            //
            // A scatter/gather list has already been allocated. Use it to determine
            // the physical address and length.  Get the scatter/gather list.
            //

            scatterList = DeviceExtension->ScatterGatherList.Elements;

            //
            // Calculate byte offset into the data buffer.
            //

            byteOffset = (ULONG)((PCHAR)VirtualAddress - (PCHAR)Srb->DataBuffer);

            //
            // Find the appropriate entry in the scatter/gatter list.
            //

            while (byteOffset >= scatterList->Length) {

                byteOffset -= scatterList->Length;
                scatterList++;
            }

            //
            // Calculate the physical address and length to be returned.
            //

            *Length = scatterList->Length - byteOffset;
            address.QuadPart = scatterList->Address.QuadPart + byteOffset;

        } else {

            DebugPrint((0,
                       "DISKDUMP: Jeff led me to believe this code may never get executed.\n"));

            //
            // Get MDL.
            //

            mdl = DeviceExtension->Mdl;

            //
            // Calculate byte offset from
            // beginning of first physical page.
            //

            if (DeviceExtension->MapBuffers) {
                byteOffset = (ULONG)((PCHAR)VirtualAddress - (PCHAR)mdl->MappedSystemVa);
            } else {
                byteOffset = (ULONG)((PCHAR)VirtualAddress - (PCHAR)mdl->StartVa);
            }

            //
            // Calculate which physical page.
            //

            whichPage = byteOffset >> PAGE_SHIFT;

            //
            // Calculate beginning of physical page array.
            //

            pages = MmGetMdlPfnArray ( mdl );

            //
            // Calculate physical address.
            //

            address.QuadPart = (pages[whichPage] << PAGE_SHIFT) +
                    BYTE_OFFSET(VirtualAddress);
        }

    } else {

        //
        // Miniport SRB extensions and noncached extensions come from
        // common buffer 0.
        //

        if (VirtualAddress >= DeviceExtension->CommonBuffer[0] &&
            VirtualAddress <
                (PVOID)((PUCHAR)DeviceExtension->CommonBuffer[0] + DeviceExtension->CommonBufferSize)) {

                address.QuadPart =
                    (ULONG_PTR)((PUCHAR)VirtualAddress -
                    (PUCHAR)DeviceExtension->CommonBuffer[0]) +
                    DeviceExtension->LogicalAddress[0].QuadPart;
                *Length = (ULONG)(DeviceExtension->CommonBufferSize -
                                  ((PUCHAR)VirtualAddress -
                                   (PUCHAR)DeviceExtension->CommonBuffer[0]));

        } else if (VirtualAddress >= DeviceExtension->CommonBuffer[1] &&
                   VirtualAddress <
                       (PVOID)((PUCHAR)DeviceExtension->CommonBuffer[1] + DeviceExtension->CommonBufferSize)) {

                address.QuadPart =
                    (ULONG_PTR)((PUCHAR)VirtualAddress -
                    (PUCHAR)DeviceExtension->CommonBuffer[1]) +
                    DeviceExtension->LogicalAddress[1].QuadPart;
                *Length = (ULONG)(DeviceExtension->CommonBufferSize - 
                                  ((PUCHAR)VirtualAddress -
                                   (PUCHAR)DeviceExtension->CommonBuffer[1]));
        } else {

            DbgPrint("Crashdump: miniport attempted to get physical address "
                     "for invalid VA %#p\n", VirtualAddress);
            DbgPrint("Crashdump: Valid range 1: %p through %p\n",
                     (PUCHAR) DeviceExtension->CommonBuffer[0],
                     ((PUCHAR) DeviceExtension->CommonBuffer[0]) + DeviceExtension->CommonBufferSize);
            DbgPrint("Crashdump: Valid ranges 2: %p through %p\n",
                     (PUCHAR) DeviceExtension->CommonBuffer[1],
                     ((PUCHAR) DeviceExtension->CommonBuffer[1]) + DeviceExtension->CommonBufferSize);

            KeBugCheckEx(PORT_DRIVER_INTERNAL,
                         0x80000001,
                         (ULONG_PTR) DeviceExtension,
                         (ULONG_PTR) VirtualAddress,
                         (ULONG_PTR) NULL);

            address.QuadPart = 0;
            *Length = 0;
        }
    }

    return address;
}

#define CHECK_POINTER_RANGE(LowerBound,Address,Size)\
    ((PUCHAR)(LowerBound) <= (PUCHAR)(Address) && \
        (PUCHAR)Address < ((PUCHAR)(LowerBound) + Size))
                                                        

SCSI_PHYSICAL_ADDRESS
StorPortGetPhysicalAddress(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID VirtualAddress,
    OUT ULONG *Length
    )

/*++

Routine Description:

    This routine returns a 32-bit physical address to which a virtual address
    is mapped. There are 2 types addresses that can be translated via this call:

    - An address of memory from the two common buffers that the system provides
      for the crashdump disk drivers.

    - A data buffer address described in an MDL that the system provided with
      an IO request.

Arguments:

Return Value:

--*/

{
    //
    // Unlike SCSIPORT, STORPORT requires a SRB for the SRB's DataBuffer,
    // SenseInfoBuffer and SrbExtension. If this is one of these cases,
    // translate it back to the SCSIPORT usage.
    //
    
    if (Srb &&
        CHECK_POINTER_RANGE (Srb->SrbExtension, VirtualAddress,
                             DeviceExtension->SrbExtensionSize)) {

        Srb = NULL;
    }

    return ScsiPortGetPhysicalAddress (HwDeviceExtension,
                                       Srb,
                                       VirtualAddress,
                                       Length);
}


PVOID
ScsiPortGetVirtualAddress(
    IN PVOID HwDeviceExtension,
    IN SCSI_PHYSICAL_ADDRESS PhysicalAddress
    )

/*++

Routine Description:

    This routine is returns a virtual address associated with a
    physical address, if the physical address was obtained by a
    call to ScsiPortGetPhysicalAddress.

Arguments:

    PhysicalAddress

Return Value:

    Virtual address if physical page hashed.
    NULL if physical page not found in hash.

--*/

{
    ULONG address = ScsiPortConvertPhysicalAddressToUlong(PhysicalAddress);
    ULONG offset;

    //
    // Check if address is in the range of the first common buffer.
    //

    if (address >= DeviceExtension->PhysicalAddress[0].LowPart &&
        address < (DeviceExtension->PhysicalAddress[0].LowPart +
            DeviceExtension->CommonBufferSize)) {

        offset = address - DeviceExtension->PhysicalAddress[0].LowPart;

        return ((PUCHAR)DeviceExtension->CommonBuffer[0] + offset);
    }

    //
    // Check if the address is in the range of the second common buffer.
    //

    if (address >= DeviceExtension->PhysicalAddress[1].LowPart &&
        address < (DeviceExtension->PhysicalAddress[1].LowPart +
            DeviceExtension->CommonBufferSize)) {

        offset = address - DeviceExtension->PhysicalAddress[1].LowPart;

        return ((PUCHAR)DeviceExtension->CommonBuffer[1] + offset);
    }

    return NULL;
}


PVOID
ScsiPortGetLogicalUnit(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )

/*++

Routine Description:

    Return miniport driver's logical unit extension.

Arguments:

    HwDeviceExtension - The port driver's device extension follows
        the miniport's device extension and contains a pointer to
        the logical device extension list.

    PathId, TargetId and Lun - identify which logical unit on the
        SCSI buses.

Return Value:

    Miniport driver's logical unit extension

--*/

{
    return DeviceExtension->SpecificLuExtension;

}

VOID
ScsiPortNotification(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    )
{
    PSCSI_REQUEST_BLOCK srb = NULL;

    va_list(ap);

    va_start(ap, HwDeviceExtension);

    switch (NotificationType) {

        case NextLuRequest:
        case NextRequest:

            //
            // Start next packet on adapter's queue.
            //

            DeviceExtension->InterruptFlags |= PD_READY_FOR_NEXT_REQUEST;
            break;

        case RequestComplete:

            //
            // Record completed request.
            //

            srb = va_arg(ap, PSCSI_REQUEST_BLOCK);

            //
            // Check which SRB is completing.
            //

            if (srb == &DeviceExtension->Srb) {

                //
                // Complete this request.
                //

                DeviceExtension->RequestComplete = TRUE;

            } else if (srb == &DeviceExtension->RequestSenseSrb) {

                //
                // Process request sense.
                //

                RequestSenseCompletion();
            }

            break;

        case ResetDetected:

            //
            // Delay for 4 seconds.
            //

            DeviceExtension->StallRoutine ( RESET_DELAY );
            break;

        case CallDisableInterrupts:

            ASSERT(DeviceExtension->Flags & PD_DISABLE_INTERRUPTS);

            //
            // The miniport wants us to call the specified routine
            // with interrupts disabled.  This is done after the current
            // HwRequestInterrutp routine completes. Indicate the call is
            // needed and save the routine to be called.
            //

            DeviceExtension->Flags |= PD_DISABLE_CALL_REQUEST;

            DeviceExtension->HwRequestInterrupt = va_arg(ap, PHW_INTERRUPT);

            break;

        case CallEnableInterrupts:

            ASSERT(!(DeviceExtension->Flags & PD_DISABLE_INTERRUPTS));

            //
            // The miniport wants us to call the specified routine
            // with interrupts enabled this is done from the DPC.
            // Disable calls to the interrupt routine, indicate the call is
            // needed and save the routine to be called.
            //

            DeviceExtension->Flags |= PD_DISABLE_INTERRUPTS | PD_ENABLE_CALL_REQUEST;

            DeviceExtension->HwRequestInterrupt = va_arg(ap, PHW_INTERRUPT);

            break;

        case RequestTimerCall:

            DeviceExtension->HwTimerRequest = va_arg(ap, PHW_INTERRUPT);
            DeviceExtension->TimerValue = va_arg(ap, ULONG);

            if (DeviceExtension->TimerValue) {

                //
                // Round up the timer value to the stall time.
                //

                DeviceExtension->TimerValue = (DeviceExtension->TimerValue
                  + PD_INTERLOOP_STALL - 1)/ PD_INTERLOOP_STALL;
            }

            break;
    }

    va_end(ap);

    //
    // Check to see if the last DPC has been processed yet.  If so
    // queue another DPC.
    //

    WorkHorseDpc();

}


VOID
ScsiPortFlushDma(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine checks to see if the previous IoMapTransfer has been done
    started.  If it has not, then the PD_MAP_TRANSER flag is cleared, and the
    routine returns; otherwise, this routine schedules a DPC which will call
    IoFlushAdapter buffers.

Arguments:

    HwDeviceExtension - Supplies a the hardware device extension for the
        host bus adapter which will be doing the data transfer.


Return Value:

    None.

--*/

{
    if (DeviceExtension->InterruptFlags & PD_MAP_TRANSFER) {

        //
        // The transfer has not been started so just clear the map transfer
        // flag and return.
        //

        DeviceExtension->InterruptFlags &= ~PD_MAP_TRANSFER;
        return;
    }

    DeviceExtension->InterruptFlags |= PD_FLUSH_ADAPTER_BUFFERS;

    //
    // Check to see if the last DPC has been processed yet.  If so
    // queue another DPC.
    //

    WorkHorseDpc();

    return;

}


VOID
ScsiPortIoMapTransfer(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID LogicalAddress,
    IN ULONG Length
    )

/*++

Routine Description:

    Saves the parameters for the call to IoMapTransfer and schedules the DPC
    if necessary.

Arguments:

    HwDeviceExtension - Supplies a the hardware device extension for the
        host bus adapter which will be doing the data transfer.

    Srb - Supplies the particular request that data transfer is for.

    LogicalAddress - Supplies the logical address where the transfer should
        begin.

    Length - Supplies the maximum length in bytes of the transfer.

Return Value:

   None.

--*/

{
    //
    // Make sure this host bus adapter has an Dma adapter object.
    //
    if (DeviceExtension->DmaAdapterObject == NULL) {
        //
        // No DMA adapter, no work.
        //
        return;
    }

    DeviceExtension->MapTransferParameters.Srb = Srb;
    DeviceExtension->MapTransferParameters.LogicalAddress = LogicalAddress;
    DeviceExtension->MapTransferParameters.Length = Length;

    DeviceExtension->InterruptFlags |= PD_MAP_TRANSFER;

    //
    // Check to see if the last DPC has been processed yet.  If so
    // queue another DPC.
    //

    WorkHorseDpc();

}


VOID
ScsiPortLogError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    )

/*++

Routine Description:

    This routine does no more than put up a debug print message in a debug
    build.

Arguments:

    DeviceExtenson - Supplies the HBA miniport driver's adapter data storage.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    ErrorCode - Supplies an error code indicating the type of error.

    UniqueId - Supplies a unique identifier for the error.

Return Value:

    None.

--*/

{
    DebugPrint((0,"\n\nLogErrorEntry: Logging SCSI error packet. ErrorCode = %d.\n",
        ErrorCode));
    DebugPrint((0,
        "PathId = %2x, TargetId = %2x, Lun = %2x, UniqueId = %x.\n\n",
        PathId,
        TargetId,
        Lun,
        UniqueId));

    return;

}


VOID
ScsiPortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    )

/*++

Routine Description:

    Complete all active requests for the specified logical unit.

Arguments:

    DeviceExtenson - Supplies the HBA miniport driver's adapter data storage.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    SrbStatus - Status to be returned in each completed SRB.

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->Srb;
    PSCSI_REQUEST_BLOCK failingSrb;

    //
    // Check if a request is outstanding.
    //

    if (!DeviceExtension->Mdl) {
        return;
    }

    //
    // Just in case this is an abort request,
    // get pointer to failingSrb.
    //

    failingSrb = srb->NextSrb;

    //
    // Update SRB status and show no bytes transferred.
    //

    srb->SrbStatus = SrbStatus;
    srb->DataTransferLength = 0;

    //
    // Call notification routine.
    //

    ScsiPortNotification(RequestComplete,
                         HwDeviceExtension,
                         srb);

    //
    // Check if this was an ABORT SRB
    //

    if (failingSrb) {

        //
        // This was an abort request. The failing
        // SRB must also be completed.
        //

        failingSrb->SrbStatus = SrbStatus;
        failingSrb->DataTransferLength = 0;

        //
        // Call notification routine.
        //

        ScsiPortNotification(RequestComplete,
                             HwDeviceExtension,
                             failingSrb);
    }

    return;

}


VOID
ScsiPortMoveMemory(
    IN PVOID WriteBuffer,
    IN PVOID ReadBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    Copy from one buffer into another.

Arguments:

    ReadBuffer - source

    WriteBuffer - destination

    Length - number of bytes to copy

Return Value:

    None.

--*/

{
    RtlMoveMemory(WriteBuffer, ReadBuffer, Length);

}


VOID
ScsiPortStallExecution(
    ULONG Delay
    )
/*++

Routine Description:

    Wait number of microseconds in tight processor loop.

Arguments:

    Delay - number of microseconds to wait.

Return Value:

    None.

--*/

{
    DeviceExtension->StallRoutine(Delay);

}


VOID
ScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all SCSI drivers

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
#if DBG

    va_list ap;
    ULONG DebugLevel;

    va_start( ap, DebugMessage );

    switch (DebugPrintLevel) {
        case 0:
            DebugLevel = DPFLTR_WARNING_LEVEL;
            break;

        case 1:
        case 2:
            DebugLevel = DPFLTR_TRACE_LEVEL;
            break;

        case 3:
            DebugLevel = DPFLTR_INFO_LEVEL;
            break;

        default:
            DebugLevel = DebugPrintLevel;
            break;

    }

    vDbgPrintExWithPrefix ("DISKDUMP: ",
                            DPFLTR_CRASHDUMP_ID,
                            DebugLevel,
                            DebugMessage,
                            ap);
    va_end(ap);

#endif
}


UCHAR
ScsiPortReadPortUchar(
    IN PUCHAR Port
    )

/*++

Routine Description:

    Read from the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{
    return(READ_PORT_UCHAR(Port));
}


USHORT
ScsiPortReadPortUshort(
    IN PUSHORT Port
    )

/*++

Routine Description:

    Read from the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{
    return(READ_PORT_USHORT(Port));
}


ULONG
ScsiPortReadPortUlong(
    IN PULONG Port
    )

/*++

Routine Description:

    Read from the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{
    return(READ_PORT_ULONG(Port));
}


UCHAR
ScsiPortReadRegisterUchar(
    IN PUCHAR Register
    )

/*++

Routine Description:

    Read from the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{
    return(READ_REGISTER_UCHAR(Register));
}


USHORT
ScsiPortReadRegisterUshort(
    IN PUSHORT Register
    )

/*++

Routine Description:

    Read from the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{
    return(READ_REGISTER_USHORT(Register));
}


ULONG
ScsiPortReadRegisterUlong(
    IN PULONG Register
    )

/*++

Routine Description:

    Read from the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{
    return(READ_REGISTER_ULONG(Register));
}


VOID
ScsiPortReadRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    READ_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);
}


VOID
ScsiPortReadRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    READ_REGISTER_BUFFER_USHORT(Register, Buffer, Count);
}


VOID
ScsiPortReadRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{
    READ_REGISTER_BUFFER_ULONG(Register, Buffer, Count);
}


VOID
ScsiPortWritePortUchar(
    IN PUCHAR Port,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{
    WRITE_PORT_UCHAR(Port, Value);
}


VOID
ScsiPortWritePortUshort(
    IN PUSHORT Port,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{
    WRITE_PORT_USHORT(Port, Value);
}


VOID
ScsiPortWritePortUlong(
    IN PULONG Port,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{
    WRITE_PORT_ULONG(Port, Value);
}


VOID
ScsiPortWriteRegisterUchar(
    IN PUCHAR Register,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{
    WRITE_REGISTER_UCHAR(Register, Value);
}


VOID
ScsiPortWriteRegisterUshort(
    IN PUSHORT Register,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{
    WRITE_REGISTER_USHORT(Register, Value);
}


VOID
ScsiPortWriteRegisterUlong(
    IN PULONG Register,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{
    WRITE_REGISTER_ULONG(Register, Value);
}


VOID
ScsiPortWriteRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    WRITE_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);
}


VOID
ScsiPortWriteRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    WRITE_REGISTER_BUFFER_USHORT(Register, Buffer, Count);
}


VOID
ScsiPortWriteRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    WRITE_REGISTER_BUFFER_ULONG(Register, Buffer, Count);
}


SCSI_PHYSICAL_ADDRESS
ScsiPortConvertUlongToPhysicalAddress(
    ULONG_PTR UlongAddress
    )

{
    SCSI_PHYSICAL_ADDRESS physicalAddress;

    physicalAddress.QuadPart = UlongAddress;
    return(physicalAddress);
}


ULONG
ScsiPortConvertPhysicalAddressToUlong(
    PHYSICAL_ADDRESS Address
    )
{

    return(Address.LowPart);
}


PVOID
ScsiPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    SCSI_PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfBytes,
    BOOLEAN InIoSpace
    )

/*++

Routine Description:

    This routine maps an IO address to system address space.
    This was done during system initialization for the crash dump driver.

Arguments:

    HwDeviceExtension - used to find port device extension.

    BusType - what type of bus - eisa, mca, isa

    SystemIoBusNumber - which IO bus (for machines with multiple buses).

    IoAddress - base device address to be mapped.

    NumberOfBytes - number of bytes for which address is valid.

    InIoSpace - indicates an IO address.

Return Value:

    Mapped address

--*/

{
    PMAPPED_ADDRESS Addresses = DeviceExtension->MappedAddressList;
    PHYSICAL_ADDRESS CardAddress;
    ULONG AddressSpace = InIoSpace;
    PVOID MappedAddress = NULL;
    BOOLEAN b;

    b = HalTranslateBusAddress(
            BusType,            // AdapterInterfaceType
            SystemIoBusNumber,  // SystemIoBusNumber
            IoAddress,          // Bus Address
            &AddressSpace,      // AddressSpace
            &CardAddress
            );

    if ( !b ) {
        return NULL;
    }

    //
    // If the address space is not in I/O space, then it was mapped during
    // the original system initialization of the driver.  Therefore, it must
    // be in the list of mapped address ranges.  Look it up and return it.
    //

    if (!AddressSpace) {

        while (Addresses) {
            if (SystemIoBusNumber == Addresses->BusNumber &&
                NumberOfBytes == Addresses->NumberOfBytes &&
                IoAddress.QuadPart == Addresses->IoAddress.QuadPart) {
                MappedAddress = Addresses->MappedAddress;
                break;
            }
            Addresses = Addresses->NextMappedAddress;
        }

    } else {

        MappedAddress = (PVOID)(ULONG_PTR)CardAddress.QuadPart;
    }

    return MappedAddress;

}

VOID
ScsiPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )

/*++

Routine Description:

    This routine unmaps an IO address that has been previously mapped
    to system address space using ScsiPortGetDeviceBase().

Arguments:

    HwDeviceExtension - used to find port device extension.

    MappedAddress - address to unmap.

    NumberOfBytes - number of bytes mapped.

    InIoSpace - addresses in IO space don't get mapped.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER(HwDeviceExtension);
    UNREFERENCED_PARAMETER(MappedAddress);

    return;

}


PVOID
ScsiPortGetUncachedExtension(
    IN PVOID HwDeviceExtension,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN ULONG NumberOfBytes
    )
/*++

Routine Description:

    This function returns the address of the noncached extension for the
    miniport driver.

Arguments:

    DeviceExtension - Supplies a pointer to the miniports device extension.

    ConfigInfo - Supplies a pointer to the partially initialized configuraiton
        information.  This is used to get an DMA adapter object.

    NumberOfBytes - Supplies the size of the extension which needs to be
        allocated

Return Value:

    A pointer to the noncached device extension or
    NULL if the requested extension size is larger than the extension
    that was previously allocated.

--*/

{
    if (DeviceExtension->NonCachedExtensionSize >= NumberOfBytes) {
        return DeviceExtension->NonCachedExtension;
    } else {
        DebugPrint((0,
                   "ScsiPortGetUncachedExtension: Request %x but only %x available\n",
                   NumberOfBytes,
                   DeviceExtension->NonCachedExtensionSize));
        return NULL;
    }
}


ULONG
ScsiPortGetBusData(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the bus data for an adapter slot or CMOS address.

Arguments:

    BusDataType - Supplies the type of bus.

    BusNumber - Indicates which bus.

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/

{
    ULONG ret;
    
    //
    // If the length is non-zero, the the requested data.
    //

    if (BusDataType == PCIConfiguration) {

        ret = HalGetBusDataByOffset(
                BusDataType,
                SystemIoBusNumber,
                SlotNumber,
                Buffer,
                0,
                Length);

    } else {
        ret = 0;
    }

    return ret;
}


PSCSI_REQUEST_BLOCK
ScsiPortGetSrb(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN LONG QueueTag
    )

/*++

Routine Description:

    This routine retrieves an active SRB for a particuliar logical unit.

Arguments:

    HwDeviceExtension -
    
    PathId -

    TargetId -

    Lun - identify logical unit on SCSI bus.

    QueueTag - -1 indicates request is not tagged.

Return Value:

    SRB if outstanding request, otherwise NULL.

--*/

{
    PSCSI_REQUEST_BLOCK srb;
    
    if (DeviceExtension->RequestPending) {
        srb = &DeviceExtension->Srb;
    } else {
        srb = NULL;
    }

    return srb;
}


BOOLEAN
ScsiPortValidateRange(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN SCSI_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    )

/*++

Routine Description:

    This routine should take an IO range and make sure that it is not already
    in use by another adapter. This allows miniport drivers to probe IO where
    an adapter could be, without worrying about messing up another card.

Arguments:

    HwDeviceExtension - Used to find scsi managers internal structures

    BusType - EISA, PCI, PC/MCIA, MCA, ISA, what?

    SystemIoBusNumber - Which system bus?

    IoAddress - Start of range

    NumberOfBytes - Length of range

    InIoSpace - Is range in IO space?

Return Value:

    TRUE if range not claimed by another driver.

--*/

{
    //
    // This is not implemented in NT.
    //
    return TRUE;
}


VOID
ScsiPortReadPortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    READ_PORT_BUFFER_UCHAR(Port, Buffer, Count);
}


VOID
ScsiPortReadPortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    READ_PORT_BUFFER_USHORT(Port, Buffer, Count);
}


VOID
ScsiPortReadPortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    READ_PORT_BUFFER_ULONG(Port, Buffer, Count);
}


VOID
ScsiPortWritePortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    WRITE_PORT_BUFFER_UCHAR(Port, Buffer, Count);
}


VOID
ScsiPortWritePortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    WRITE_PORT_BUFFER_USHORT(Port, Buffer, Count);
}


VOID
ScsiPortWritePortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    WRITE_PORT_BUFFER_ULONG(Port, Buffer, Count);
}


ULONG
ScsiPortSetBusDataByOffset(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns writes bus data to a specific offset within a slot.

Arguments:

    DeviceExtension - State information for a particular adapter.

    BusDataType - Supplies the type of bus.

    SystemIoBusNumber - Indicates which system IO bus.

    SlotNumber - Indicates which slot.

    Buffer - Supplies the data to write.

    Offset - Byte offset to begin the write.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Number of bytes written.

--*/

{
    return 0;
    return(HalSetBusDataByOffset(BusDataType,
                                 SystemIoBusNumber,
                                 SlotNumber,
                                 Buffer,
                                 Offset,
                                 Length));

}

BOOLEAN
ResetBus(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN ULONG PathId
    )

/*++

Routine Description:

    This function will call the miniport's reset routine, and stall for 4 seconds
    before continuing

Arguments:

    DeviceExtension - State information for a particular adapter.

    Pathid - Identifies the SCSI bus to reset

--*/
{
    BOOLEAN result;

    ASSERT ( DeviceExtension != NULL );
    ASSERT ( DeviceExtension->HwReset != NULL );

    
    result = DeviceExtension->HwReset ( DeviceExtension->HwDeviceExtension, PathId );

    //
    // Wait for 4 seconds
    //
    
    DeviceExtension->StallRoutine( RESET_DELAY );

    //
    // Poll the interrupt handler to clear any reset interrupts.
    //

    if (DeviceExtension->HwInterrupt != NULL) {
        DeviceExtension->HwInterrupt(DeviceExtension->HwDeviceExtension);
    }

    return result;
}



VOID
ScsiPortQuerySystemTime(
    OUT PLARGE_INTEGER Time
    )
{
    Time->QuadPart = 0;
}



BOOLEAN
StorPortDeviceBusy(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG RequestsToComplete
    )
{
    return TRUE;
}


BOOLEAN
StorPortDeviceReady(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )
{
    return TRUE;
}


PSTOR_SCATTER_GATHER_LIST
StorPortGetScatterGatherList(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    // NB: Check that SG list count is correct

    return (PSTOR_SCATTER_GATHER_LIST)&DeviceExtension->ScatterGatherList;
}


BOOLEAN
StorPortResumeDevice(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )
{
    return TRUE;
}


BOOLEAN
StorPortBusy(
    IN PVOID HwDeviceExtension,
    IN ULONG RequestsToComplete
    )
{
    return TRUE;
}


BOOLEAN
StorPortReady(
    IN PVOID HwDeviceExtension
    )
{
    return TRUE;
}


BOOLEAN
StorPortPause(
    IN PVOID HwDeviceExtension,
    IN ULONG Timeout
    )
{
    ScsiPortStallExecution (Timeout * SECONDS);
    return TRUE;
}


BOOLEAN
StorPortPauseDevice(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG Timeout
    )
{
    ScsiPortStallExecution (Timeout * SECONDS);
    return TRUE;
}



BOOLEAN
StorPortResume(
    IN PVOID HwDeviceExtension
    )
{
    return TRUE;
}


BOOLEAN
StorPortSynchronizeAccess(
    IN PVOID HwDeviceExtension,
    IN PSTOR_SYNCHRONIZED_ACCESS SynchronizedAccessRoutine,
    IN PVOID Context
    )
{
    ASSERT (SynchronizedAccessRoutine != NULL);
    return SynchronizedAccessRoutine (HwDeviceExtension, Context);
}

//
// DEAD CODE: The remainder of this file is no longer used.
//

#if 0

//
// The functions ReadSector() and IssueReadCapacity() are
// no longer necessary. They are left here for reference purposes
// only
//


VOID
ReadSector(
    PLARGE_INTEGER ByteOffset
    )

/*++

Routine Description:

    Read 1 sector into common buffer.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->Srb;
    PCDB cdb = (PCDB)&srb->Cdb;
    ULONG startingSector;
    ULONG retryCount = 0;
    PPFN_NUMBER page;
    PFN_NUMBER localMdl[(sizeof( MDL )/sizeof(PFN_NUMBER)) + (MAXIMUM_TRANSFER_SIZE / PAGE_SIZE) + 2];

    //
    // Zero SRB.
    //

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

readSectorRetry:

    //
    // Initialize SRB.
    //

    srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    srb->PathId = DeviceExtension->PathId;
    srb->TargetId = DeviceExtension->TargetId;
    srb->Lun = DeviceExtension->Lun;
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->SrbFlags = SRB_FLAGS_DATA_IN |
                    SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_DISCONNECT |
                    SRB_FLAGS_DISABLE_AUTOSENSE;
    srb->SrbStatus = srb->ScsiStatus = 0;
    srb->NextSrb = 0;
    srb->TimeOutValue = 5;
    srb->CdbLength = 10;
    srb->DataBuffer = DeviceExtension->CommonBuffer[1];
    srb->DataTransferLength = DeviceExtension->BytesPerSector;

    //
    // Build MDL and map it so that it can be used.
    //

    DeviceExtension->Mdl = (PMDL)&localMdl[0];
    MmInitializeMdl(DeviceExtension->Mdl,
                    srb->DataBuffer,
                    srb->DataTransferLength);

    page = MdlGetMdlPfnArray ( DeviceExtension->Mdl );
    *page = (PFN_NUMBER)(DeviceExtension->PhysicalAddress[1].QuadPart >> PAGE_SHIFT);
    MmMapMemoryDumpMdl(DeviceExtension->Mdl);


    //
    // Initialize CDB for READ command.
    //

    cdb->CDB10.OperationCode = SCSIOP_READ;

    //
    // Calculate starting sector.
    //

    startingSector = (ULONG)((*ByteOffset).QuadPart /
                             DeviceExtension->BytesPerSector);

    //
    // SCSI CDBs use big endian.
    //

    cdb->CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&startingSector)->Byte3;
    cdb->CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&startingSector)->Byte2;
    cdb->CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&startingSector)->Byte1;
    cdb->CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&startingSector)->Byte0;

    cdb->CDB10.TransferBlocksMsb = 0;
    cdb->CDB10.TransferBlocksLsb = 1;

    //
    // Send SRB to miniport driver.
    //

    ExecuteSrb(srb);


    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS &&
        SRB_STATUS(srb->SrbStatus) != SRB_STATUS_DATA_OVERRUN) {

        DebugPrint((1,
                   "ReadSector: Read sector failed SRB status %x\n",
                   srb->SrbStatus));

        if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SELECTION_TIMEOUT &&
            retryCount < 2) {

            //
            // If the selection did not time out then retry the request.
            //

            retryCount++;
            goto readSectorRetry;
        }
    }
}
#endif


UCHAR
StorPortReadPortUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port
    )

/*++

Routine Description:

    Read from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{
    return(READ_PORT_UCHAR(Port));
}


USHORT
StorPortReadPortUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port
    )

/*++

Routine Description:

    Read from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

    return(READ_PORT_USHORT(Port));

}

ULONG
StorPortReadPortUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Port
    )

/*++

Routine Description:

    Read from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

    return(READ_PORT_ULONG(Port));

}

VOID
StorPortReadPortBufferUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_UCHAR(Port, Buffer, Count);

}

VOID
StorPortReadPortBufferUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_USHORT(Port, Buffer, Count);

}

VOID
StorPortReadPortBufferUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_ULONG(Port, Buffer, Count);

}

UCHAR
StorPortReadRegisterUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register
    )

/*++

Routine Description:

    Read from the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_UCHAR(Register));

}

USHORT
StorPortReadRegisterUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register
    )

/*++

Routine Description:

    Read from the specified register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_USHORT(Register));

}

ULONG
StorPortReadRegisterUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Register
    )

/*++

Routine Description:

    Read from the specified register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_ULONG(Register));

}

VOID
StorPortReadRegisterBufferUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
StorPortReadRegisterBufferUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
StorPortReadRegisterBufferUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

VOID
StorPortWritePortUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_PORT_UCHAR(Port, Value);

}

VOID
StorPortWritePortUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_PORT_USHORT(Port, Value);

}

VOID
StorPortWritePortUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Port,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_PORT_ULONG(Port, Value);


}

VOID
StorPortWritePortBufferUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_UCHAR(Port, Buffer, Count);

}

VOID
StorPortWritePortBufferUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_USHORT(Port, Buffer, Count);

}

VOID
StorPortWritePortBufferUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_ULONG(Port, Buffer, Count);

}

VOID
StorPortWriteRegisterUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_UCHAR(Register, Value);

}

VOID
StorPortWriteRegisterUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_USHORT(Register, Value);
}

VOID
StorPortWriteRegisterBufferUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
StorPortWriteRegisterBufferUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
StorPortWriteRegisterBufferUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

VOID
StorPortWriteRegisterUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Register,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_ULONG(Register, Value);
}


PUCHAR
StorPortAllocateRegistryBuffer(
    IN PVOID HwDeviceExtension,
    IN PULONG Length
    )
{
    return NULL;
}



VOID
StorPortFreeRegistryBuffer(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Buffer
    )
{
}


BOOLEAN
StorPortRegistryRead(
    IN PVOID HwDeviceExtension,
    IN PUCHAR ValueName,
    IN ULONG Global,
    IN ULONG Type,
    IN PUCHAR Buffer,
    IN PULONG BufferLength
    )
{
    return FALSE;
}


BOOLEAN
StorPortRegistryWrite(
    IN PVOID HwDeviceExtension,
    IN PUCHAR ValueName,
    IN ULONG Global,
    IN ULONG Type,
    IN PUCHAR Buffer,
    IN ULONG BufferLength
    )
{
    return FALSE;
}


BOOLEAN
StorPortSetDeviceQueueDepth(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG Depth
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\lib\passthru.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    passthru.c

Abstract:

    This is the storage port driver library.  This file contains code that 
    implements SCSI passthrough.

Authors:

    John Strange (JohnStra)

Environment:

    kernel mode only

Notes:

    This module implements SCSI passthru for storage port drivers.

Revision History:

--*/

#include "precomp.h"

//
// Constants and macros to enforce good use of Ex[Allocate|Free]PoolWithTag.
// Remeber that all pool tags will display in the debugger in reverse order
//

#if USE_EXFREEPOOLWITHTAG_ONLY
#define TAG(x)  (x | 0x80000000)
#else
#define TAG(x)  (x)
#endif

#define PORT_TAG_SENSE_BUFFER       TAG('iPlP')  // Sense info

#define PORT_IS_COPY(Srb)                                     \
    ((Srb)->Cdb[0] == SCSIOP_COPY)
#define PORT_IS_COMPARE(Srb)                                  \
    ((Srb)->Cdb[0] == SCSIOP_COMPARE)
#define PORT_IS_COPY_COMPARE(Srb)                             \
    ((Srb)->Cdb[0] == SCSIOP_COPY_COMPARE)

#define PORT_IS_ILLEGAL_PASSTHROUGH_COMMAND(Srb)              \
    (PORT_IS_COPY((Srb)) ||                                   \
     PORT_IS_COMPARE((Srb)) ||                                \
     PORT_IS_COPY_COMPARE((Srb)))
    
#if defined (_WIN64)
NTSTATUS
PortpTranslatePassThrough32To64(
    IN PSCSI_PASS_THROUGH32 SrbControl32,
    IN OUT PSCSI_PASS_THROUGH SrbControl64
    );

VOID
PortpTranslatePassThrough64To32(
    IN PSCSI_PASS_THROUGH SrbControl64,
    IN OUT PSCSI_PASS_THROUGH32 SrbControl32
    );
#endif

NTSTATUS
PortpSendValidPassThrough(
    IN PPORT_PASSTHROUGH_INFO PassThroughInfo,
    IN PIRP RequestIrp,
    IN ULONG SrbFlags,
    IN BOOLEAN Direct
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PortGetPassThrough)
#pragma alloc_text(PAGE, PortPassThroughInitialize)
#pragma alloc_text(PAGE, PortPassThroughInitializeSrb)
#pragma alloc_text(PAGE, PortSendPassThrough)
#pragma alloc_text(PAGE, PortpSendValidPassThrough)
#pragma alloc_text(PAGE, PortPassThroughCleanup)
#pragma alloc_text(PAGE, PortGetPassThroughAddress)
#pragma alloc_text(PAGE, PortSetPassThroughAddress)
#pragma alloc_text(PAGE, PortPassThroughMarshalResults)
#if defined (_WIN64)
#pragma alloc_text(PAGE, PortpTranslatePassThrough32To64)
#pragma alloc_text(PAGE, PortpTranslatePassThrough64To32)
#endif
#endif

NTSTATUS
PortGetPassThroughAddress(
    IN PIRP Irp,
    OUT PUCHAR PathId,
    OUT PUCHAR TargetId,
    OUT PUCHAR Lun
    )
/*++

Routine Description:

    This routine retrieves the address of the device to witch the passthrough
    request is to be sent.

Arguments:

    Irp      - Supplies a pointer to the IRP that contains the 
               SCSI_PASS_THROUGH structure.

    PathId   - Pointer to the PathId of the addressed device.

    TargetId - Pointer to the TargetId of the addressed device. 

    Lun      - Pointer to the logical unit number of the addressed device.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_PASS_THROUGH srbControl = Irp->AssociatedIrp.SystemBuffer;
    ULONG requiredSize;
    NTSTATUS status;

    PAGED_CODE();

#if defined(_WIN64)
    if (IoIs32bitProcess(Irp)) {
        requiredSize = sizeof(SCSI_PASS_THROUGH32);
    } else {
        requiredSize = sizeof(SCSI_PASS_THROUGH);
    }
#else
    requiredSize = sizeof(SCSI_PASS_THROUGH);
#endif

    if (irpStack->Parameters.DeviceIoControl.InputBufferLength < 
        requiredSize) {
        status = STATUS_BUFFER_TOO_SMALL;
    } else {
        *PathId = srbControl->PathId;
        *TargetId = srbControl->TargetId;
        *Lun = srbControl->Lun;
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
PortSetPassThroughAddress(
    IN PIRP Irp,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )
/*++

Routine Description:

    This routine initializes the address of the SCSI_PASS_THROUGH structure
    embedded in the supplied IRP.

Arguments:

    Irp      - Supplies a pointer to the IRP that contains the 
               SCSI_PASS_THROUGH structure.

    PathId   - The PathId of the addressed device.

    TargetId - The TargetId of the addressed device. 

    Lun      - The logical unit number of the addressed device.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_PASS_THROUGH srbControl = Irp->AssociatedIrp.SystemBuffer;
    ULONG requiredSize;
    NTSTATUS status;

    PAGED_CODE();

#if defined(_WIN64)
    if (IoIs32bitProcess(Irp)) {
        requiredSize = sizeof(SCSI_PASS_THROUGH32);
    } else {
        requiredSize = sizeof(SCSI_PASS_THROUGH);
    }
#else
    requiredSize = sizeof(SCSI_PASS_THROUGH);
#endif

    if (irpStack->Parameters.DeviceIoControl.InputBufferLength < 
        requiredSize) {
        status = STATUS_BUFFER_TOO_SMALL;
    } else {
        srbControl->PathId = PathId;
        srbControl->TargetId = TargetId;
        srbControl->Lun = Lun;
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
PortSendPassThrough (
    IN PDEVICE_OBJECT Pdo,
    IN PIRP RequestIrp,
    IN BOOLEAN Direct,
    IN ULONG SrbFlags,
    IN PIO_SCSI_CAPABILITIES Capabilities
    )
/*++

Routine Description:

    This function sends a user specified SCSI CDB to the device identified in
    the supplied SCSI_PASS_THROUGH structure.  It creates an srb which is 
    processed normally by the port driver.  This call is synchornous.

Arguments:

    Pdo             - Supplies a pointer to the PDO to which the passthrough
                      command will be dispatched.

    RequestIrp      - Supplies a pointer to the IRP that made the original 
                      request.

    Direct          - Boolean indicating whether this is a direct passthrough.

    SrbFlags        - The flags to copy into the SRB used for this command.

    Capabilities    - Supplies a pointer to the IO_SCSI_CAPABILITIES structure
                      describing the storage adapter.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/
{
    NTSTATUS status;
    PORT_PASSTHROUGH_INFO passThroughInfo;

    PAGED_CODE();

    RtlZeroMemory(&passThroughInfo, sizeof(PORT_PASSTHROUGH_INFO));

    //
    // Try to init a pointer to the passthrough structure in the IRP.
    //

    status = PortGetPassThrough(
                 &passThroughInfo,
                 RequestIrp,
                 Direct
                 );

    if (status == STATUS_SUCCESS) {

        //
        // Perform parameter checking and to setup the PORT_PASSTHROUGH_INFO 
        // structure.
        //

        status = PortPassThroughInitialize(
                     &passThroughInfo,
                     RequestIrp,
                     Capabilities,
                     Pdo,
                     Direct
                     );

        if (status == STATUS_SUCCESS) {

            //
            // Call helper routine to finish processing the passthrough request.
            //

            status = PortpSendValidPassThrough(
                         &passThroughInfo,
                         RequestIrp,
                         SrbFlags,
                         Direct
                         );
        }

        PortPassThroughCleanup(&passThroughInfo);
    }

    return status;
}

NTSTATUS
PortGetPassThrough(
    IN OUT PPORT_PASSTHROUGH_INFO PassThroughInfo,
    IN PIRP Irp,
    IN BOOLEAN Direct
    )
/*++

Routine Description:

    This routine returns a pointer to the user supplied SCSI_PASS_THROUGH
    structure. 

Arguments:

    PassThroughInfo - Supplies a pointer to a SCSI_PASSTHROUGH_INFO structure.
    
    Irp             - Supplies a pointer to the IRP.
    
    Direct          - Supplies a boolean that indicates whether this is a 
                      SCSI_PASS_THROUGH_DIRECT request.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpStack;
    ULONG               inputLength;

    PAGED_CODE();

    //
    // Get a pointer to the pass through structure.
    //
    
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    PassThroughInfo->SrbControl = Irp->AssociatedIrp.SystemBuffer;

    //
    // BUGBUG: Why do we need to save this pointer to the beginning of
    //         the SCSI_PASS_THROUGH structure.
    //

    PassThroughInfo->SrbBuffer = (PVOID) PassThroughInfo->SrbControl;

    //
    // Initialize a stack variable to hold the size of the input buffer.
    //

    inputLength = irpStack->Parameters.DeviceIoControl.InputBufferLength;

    //
    // For WIN64, a passthrough request from a 32-bit application requires
    // us to perform a translation on the supplied SCSI_PASS_THROUGH structure.
    // This is required because the layout of the 32-bit structure does not
    // match that of a 64-bit structure.  In this case, we translate the
    // supplied 32-bit structure into a stack-allocated 64-bit structure which
    // will be used to process the pass through request.
    //

#if defined (_WIN64)
    if (IoIs32bitProcess(Irp)) {

        if (inputLength < sizeof(SCSI_PASS_THROUGH32)){
            return STATUS_INVALID_PARAMETER;
        }

        PassThroughInfo->SrbControl32 = 
            (PSCSI_PASS_THROUGH32)(Irp->AssociatedIrp.SystemBuffer);

        if (Direct == FALSE) {
            if (PassThroughInfo->SrbControl32->Length != 
                sizeof(SCSI_PASS_THROUGH32)) {
                return STATUS_REVISION_MISMATCH;
            }
        } else {
            if (PassThroughInfo->SrbControl32->Length !=
                sizeof(SCSI_PASS_THROUGH_DIRECT32)) {
                return STATUS_REVISION_MISMATCH;
            }
        }
        
        status = PortpTranslatePassThrough32To64(
                     PassThroughInfo->SrbControl32, 
                     &PassThroughInfo->SrbControl64);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        PassThroughInfo->SrbControl = &PassThroughInfo->SrbControl64;

    } else {
#endif
        if (inputLength < sizeof(SCSI_PASS_THROUGH)){
            return(STATUS_INVALID_PARAMETER);
        }

        if (Direct == FALSE) {
            if (PassThroughInfo->SrbControl->Length != 
                sizeof(SCSI_PASS_THROUGH)) {
                return STATUS_REVISION_MISMATCH;
            }
        } else {
            if (PassThroughInfo->SrbControl->Length !=
                sizeof(SCSI_PASS_THROUGH_DIRECT)) {
                return STATUS_REVISION_MISMATCH;
            }
        }
#if defined (_WIN64)
    }
#endif

    return STATUS_SUCCESS;
}

NTSTATUS
PortPassThroughInitialize(
    IN OUT PPORT_PASSTHROUGH_INFO PassThroughInfo,
    IN PIRP Irp,
    IN PIO_SCSI_CAPABILITIES Capabilities,
    IN PDEVICE_OBJECT Pdo,
    IN BOOLEAN Direct
    )
/*++

Routine Description:

    This routine validates the caller-supplied data and initializes the
    PORT_PASSTHROUGH_INFO structure.

Arguments:

    PassThroughInfo - Supplies a pointer to a SCSI_PASSTHROUGH_INFO structure.
                      
    Irp             - Supplies a pointer to the IRP.

    Direct          - Supplies a boolean that indicates whether this is a 
                      SCSI_PASS_THROUGH_DIRECT request.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/
{
    NTSTATUS status;
    ULONG outputLength;
    ULONG inputLength;
    PIO_STACK_LOCATION irpStack;
    PSCSI_PASS_THROUGH srbControl;
    ULONG dataTransferLength;
    ULONG pages;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    srbControl = PassThroughInfo->SrbControl;
    outputLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    inputLength = irpStack->Parameters.DeviceIoControl.InputBufferLength;

    PassThroughInfo->Pdo = Pdo;

    //
    // Verify that the CDB is no greater than 16 bytes.
    //

    if (srbControl->CdbLength > 16) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If there's a sense buffer then its offset cannot be shorter than the
    // length of the srbControl block, nor can it be located after the data
    // buffer (if any).
    //

    if (srbControl->SenseInfoLength != 0) {

        //
        // Sense info offset should not be smaller than the size of the
        // pass through structure.
        //

        if (srbControl->Length > srbControl->SenseInfoOffset) {
            return STATUS_INVALID_PARAMETER;
        }

        if (!Direct) {

            //
            // Sense info buffer should precede the data buffer offset.
            //

            if ((srbControl->SenseInfoOffset >= srbControl->DataBufferOffset) ||
                ((srbControl->SenseInfoOffset + srbControl->SenseInfoLength) >
                 srbControl->DataBufferOffset)) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Sense info buffer should be within the output buffer.
            //

            if ((srbControl->SenseInfoOffset > outputLength) ||
                (srbControl->SenseInfoOffset + srbControl->SenseInfoLength >
                 outputLength)) {
                return STATUS_INVALID_PARAMETER;
            }
         
        } else {

            //
            // Sense info buffer should be within the output buffer.
            //

            if ((srbControl->SenseInfoOffset > outputLength) ||
                (srbControl->SenseInfoOffset + srbControl->SenseInfoLength >
                 outputLength)) {
                return STATUS_INVALID_PARAMETER;
            }
        }
    }
    
    if (!Direct) {

        //
        // Data buffer offset should be greater than the size of the pass 
        // through structure.
        //

        if (srbControl->Length > srbControl->DataBufferOffset &&
            srbControl->DataTransferLength != 0) {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // If this command is sending data to the device.  Make sure the data 
        // buffer lies entirely within the supplied input buffer.
        //

        if (srbControl->DataIn != SCSI_IOCTL_DATA_IN) {

            if ((srbControl->DataBufferOffset > inputLength) ||
                ((srbControl->DataBufferOffset + 
                  srbControl->DataTransferLength) >
                 inputLength)) {
                return STATUS_INVALID_PARAMETER;
            }
        }

        //
        // If this command is retrieving data from the device, make sure the 
        // data buffer lies entirely within the supplied output buffer.
        //

        if (srbControl->DataIn) {

            if ((srbControl->DataBufferOffset > outputLength) ||
                ((srbControl->DataBufferOffset + 
                  srbControl->DataTransferLength) >
                 outputLength)) {
                return STATUS_INVALID_PARAMETER;
            }
        }
    }
    
    //
    // Validate the specified timeout value.
    //
    
    if (srbControl->TimeOutValue == 0 || 
        srbControl->TimeOutValue > 30 * 60 * 60) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check for illegal command codes.
    //

    if (PORT_IS_ILLEGAL_PASSTHROUGH_COMMAND(srbControl)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (srbControl->DataTransferLength == 0) {

        PassThroughInfo->Length = 0;
        PassThroughInfo->Buffer = NULL;
        PassThroughInfo->BufferOffset = 0;
        PassThroughInfo->MajorCode = IRP_MJ_FLUSH_BUFFERS;

    } else if (Direct == TRUE) {

        PassThroughInfo->Length = (ULONG) srbControl->DataTransferLength;
        PassThroughInfo->Buffer = (PUCHAR) srbControl->DataBufferOffset;
        PassThroughInfo->BufferOffset = 0;
        PassThroughInfo->MajorCode = !srbControl->DataIn ? IRP_MJ_WRITE :
                                                           IRP_MJ_READ;
        
    } else {

        PassThroughInfo->Length = (ULONG) srbControl->DataBufferOffset + 
                                          srbControl->DataTransferLength;
        PassThroughInfo->Buffer = (PUCHAR) PassThroughInfo->SrbBuffer;
        PassThroughInfo->BufferOffset = (ULONG)srbControl->DataBufferOffset;
        PassThroughInfo->MajorCode = !srbControl->DataIn ? IRP_MJ_WRITE : 
                                                           IRP_MJ_READ;
    }

    //
    // Make sure the buffer is properly aligned.
    //

    if (Direct == TRUE) {
        
        //
        // Make sure the user buffer is valid.  IoBuildSynchronouseFsdRequest
        // calls MmProbeAndLock with AccessMode == KernelMode.  This check is
        // the extra stuff that MM would do if it were called with 
        // AccessMode == UserMode.
        // 
        // ISSUE: We should probably do an MmProbeAndLock here.
        //

        if (Irp->RequestorMode != KernelMode) {
            PVOID endByte;
            if (PassThroughInfo->Length) {
                endByte = (PVOID)((PCHAR)PassThroughInfo->Buffer + 
                                  PassThroughInfo->Length - 1);
                if ((endByte > (PVOID)MM_HIGHEST_USER_ADDRESS) ||
                    (PassThroughInfo->Buffer >= endByte)) {
                    return STATUS_INVALID_USER_BUFFER;
                }
            }
        }

        if (srbControl->DataBufferOffset &
            PassThroughInfo->Pdo->AlignmentRequirement) {
            return STATUS_INVALID_PARAMETER;
        }
    }
    
    //
    // Check if the request is too big for the adapter.
    //

    dataTransferLength = PassThroughInfo->SrbControl->DataTransferLength;

    pages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                (PUCHAR)PassThroughInfo->Buffer + PassThroughInfo->BufferOffset,
                dataTransferLength);

    if ((dataTransferLength != 0) &&
        (pages > Capabilities->MaximumPhysicalPages || 
         dataTransferLength > Capabilities->MaximumTransferLength)) {
        
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}

VOID
PortPassThroughCleanup(
    IN PPORT_PASSTHROUGH_INFO PassThroughInfo
    )
/*++

Routine Description:

    This routine performs any cleanup required after processing a SCSI
    passthrough request.

Arguments:

    PassThroughInfo - Supplies a pointer to a SCSI_PASSTHROUGH_INFO structure.

Return Value:

    VOID

--*/
{
    PAGED_CODE();

#if defined (_WIN64)
    if (PassThroughInfo->SrbControl32 != NULL) {
        PortpTranslatePassThrough64To32(
            PassThroughInfo->SrbControl, 
            PassThroughInfo->SrbControl32);
    }
#endif
}

NTSTATUS
PortPassThroughInitializeSrb(
    IN PPORT_PASSTHROUGH_INFO PassThroughInfo,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PIRP Irp,
    IN ULONG SrbFlags,
    IN PVOID SenseBuffer
    )
/*++

Routine Description:

    This routine initializes the supplied SRB to send a passthrough request.

Arguments:

    PassThroughInfo - Supplies a pointer to a SCSI_PASSTHROUGH_INFO structure.
    
    Srb             - Supplies a pointer to the SRB to initialize.
    
    Irp             - Supplies a pointer to the IRP.
    
    SrbFlags        - Supplies the appropriate SRB flags for the request.

    SenseBuffer     - Supplies a pointer to request sense buffer to put in
                      the SRB.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/
{
    PSCSI_PASS_THROUGH srbControl;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Zero out the srb.
    //

    RtlZeroMemory(Srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Fill in the srb.
    //

    srbControl = PassThroughInfo->SrbControl;
    Srb->Length = SCSI_REQUEST_BLOCK_SIZE;
    Srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    Srb->SrbStatus = SRB_STATUS_PENDING;
    Srb->PathId = srbControl->PathId;
    Srb->TargetId = srbControl->TargetId;
    Srb->Lun = srbControl->Lun;
    Srb->CdbLength = srbControl->CdbLength;
    Srb->SenseInfoBufferLength = srbControl->SenseInfoLength;

    switch (srbControl->DataIn) {
        case SCSI_IOCTL_DATA_OUT:
            if (srbControl->DataTransferLength) {
                Srb->SrbFlags = SRB_FLAGS_DATA_OUT;
            }
            break;

        case SCSI_IOCTL_DATA_IN:
            if (srbControl->DataTransferLength) {
                Srb->SrbFlags = SRB_FLAGS_DATA_IN;
            }
            break;

        default:
            Srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT;
            break;
    }

    if (srbControl->DataTransferLength == 0) {

        Srb->SrbFlags = 0;
    } else {

        //
        // Flush the data buffer for output. This will insure that the data is
        // written back to memory.
        //

        if (Irp != NULL) {
            KeFlushIoBuffers(Irp->MdlAddress, FALSE, TRUE);
        }
    }

    Srb->SrbFlags |= (SrbFlags | SRB_FLAGS_NO_QUEUE_FREEZE);
    Srb->DataTransferLength = srbControl->DataTransferLength;
    Srb->TimeOutValue = srbControl->TimeOutValue;
    Srb->DataBuffer = (PCHAR) PassThroughInfo->Buffer + 
                             PassThroughInfo->BufferOffset;
    Srb->SenseInfoBuffer = SenseBuffer;
    Srb->OriginalRequest = Irp;

    RtlCopyMemory(Srb->Cdb, srbControl->Cdb, srbControl->CdbLength);

    //
    // Disable autosense if there's no sense buffer to put the data in.
    //

    if (SenseBuffer == NULL) {
        Srb->SrbFlags |= SRB_FLAGS_DISABLE_AUTOSENSE;
    }

    return STATUS_SUCCESS;
}

#if defined (_WIN64)
NTSTATUS
PortpTranslatePassThrough32To64(
    IN PSCSI_PASS_THROUGH32 SrbControl32,
    IN OUT PSCSI_PASS_THROUGH SrbControl64
    )
/*++

Routine Description:

    On WIN64, a SCSI_PASS_THROUGH structure sent down by a 32-bit application 
    must be marshaled into a 64-bit version of the structure.  This function
    performs that marshaling.

Arguments:

    SrbControl32    - Supplies a pointer to a 32-bit SCSI_PASS_THROUGH struct.

    SrbControl64    - Supplies the address of a pointer to a 64-bit
                      SCSI_PASS_THROUGH structure, into which we'll copy the
                      marshaled 32-bit data.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/
{
    PAGED_CODE();

    //
    // Copy the first set of fields out of the 32-bit structure.  These 
    // fields all line up between the 32 & 64 bit versions.
    //
    // Note that we do NOT adjust the length in the srbControl.  This is to 
    // allow the calling routine to compare the length of the actual 
    // control area against the offsets embedded within.  If we adjusted the 
    // length then requests with the sense area backed against the control 
    // area would be rejected because the 64-bit control area is 4 bytes
    // longer.
    //

    RtlCopyMemory(SrbControl64, 
                  SrbControl32, 
                  FIELD_OFFSET(SCSI_PASS_THROUGH, DataBufferOffset)
                  );

    //
    // Copy over the CDB.
    //

    RtlCopyMemory(SrbControl64->Cdb,
                  SrbControl32->Cdb,
                  16 * sizeof(UCHAR)
                  );

    //
    // Copy the fields that follow the ULONG_PTR.
    //

    SrbControl64->DataBufferOffset = (ULONG_PTR)SrbControl32->DataBufferOffset;
    SrbControl64->SenseInfoOffset = SrbControl32->SenseInfoOffset;

    return STATUS_SUCCESS;
}


VOID
PortpTranslatePassThrough64To32(
    IN PSCSI_PASS_THROUGH SrbControl64,
    IN OUT PSCSI_PASS_THROUGH32 SrbControl32
    )
/*++

Routine Description:

    On WIN64, a SCSI_PASS_THROUGH structure sent down by a 32-bit application 
    must be marshaled into a 64-bit version of the structure.  This function
    marshals a 64-bit version of the structure back into a 32-bit version.

Arguments:

    SrbControl64    - Supplies a pointer to a 64-bit SCSI_PASS_THROUGH struct.

    SrbControl32    - Supplies the address of a pointer to a 32-bit
                      SCSI_PASS_THROUGH structure, into which we'll copy the
                      marshaled 64-bit data.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/
{
    PAGED_CODE();

    //
    // Copy back the fields through the data offsets.
    //

    RtlCopyMemory(SrbControl32, 
                  SrbControl64,
                  FIELD_OFFSET(SCSI_PASS_THROUGH, DataBufferOffset));
    return;
}
#endif

NTSTATUS
PortpSendValidPassThrough(
    IN PPORT_PASSTHROUGH_INFO PassThroughInfo,
    IN PIRP RequestIrp,
    IN ULONG SrbFlags,
    IN BOOLEAN Direct
    )
/*++

Routine Description:

    This routine sends the SCSI passthrough request described by the supplied
    PORT_PASSTHROUGH_INFO.

Arguments:

    PassThroughInfo - Supplies a pointer to a SCSI_PASSTHROUGH_INFO structure.
    RequestIrp      - Supplies a pointer to the IRP.
    SrbFlags        - Supplies the appropriate SRB flags for the request.
    Direct          - Indicates whether this is a SCSO_PASS_THROUGH_DIRECT.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/
{
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;
    PIRP                    irp;
    PVOID                   senseBuffer;
    KEVENT                  event;
    LARGE_INTEGER           startingOffset;
    IO_STATUS_BLOCK         ioStatusBlock;
    SCSI_REQUEST_BLOCK      srb;

    PAGED_CODE();

    //
    // Allocate an aligned sense buffer if one is required.
    //

    if (PassThroughInfo->SrbControl->SenseInfoLength != 0) {

        senseBuffer = ExAllocatePoolWithTag(
                        NonPagedPoolCacheAligned,
                        PassThroughInfo->SrbControl->SenseInfoLength,
                        PORT_TAG_SENSE_BUFFER
                        );

        if (senseBuffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        senseBuffer = NULL;
    }

    //
    // Must be at PASSIVE_LEVEL to use synchronous FSD.
    //

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Initialize the notification event.
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Build IRP for this request.
    // Note we do this synchronously for two reasons.  If it was done
    // asynchonously then the completion code would have to make a special
    // check to deallocate the buffer.  Second if a completion routine were
    // used then an addation stack locate would be needed.
    //

    startingOffset.QuadPart = (LONGLONG) 1;

    irp = IoBuildSynchronousFsdRequest(
              PassThroughInfo->MajorCode,
              PassThroughInfo->Pdo,
              PassThroughInfo->Buffer,
              PassThroughInfo->Length,
              &startingOffset,
              &event,
              &ioStatusBlock);

    if (irp == NULL) {

        if (senseBuffer != NULL) {
            ExFreePool(senseBuffer);
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set major code.
    //

    irpStack = IoGetNextIrpStackLocation(irp);
    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->MinorFunction = 1;

    //
    // Initialize the IRP stack location to point to the SRB.
    //

    irpStack->Parameters.Others.Argument1 = &srb;

    //
    // Have the port library initialize the SRB for us.
    //

    status = PortPassThroughInitializeSrb(
                 PassThroughInfo,
                 &srb,
                 irp,
                 SrbFlags,
                 senseBuffer);

    //
    // Call port driver to handle this request and wait for the request to
    // complete.
    //

    status = IoCallDriver(PassThroughInfo->Pdo, irp);

    if (status == STATUS_PENDING) {

          KeWaitForSingleObject(&event,
                                Executive,
                                KernelMode,
                                FALSE,
                                NULL);
    } else {

        ioStatusBlock.Status = status;
    }

    PortPassThroughMarshalResults(PassThroughInfo,
                                  &srb,
                                  RequestIrp,
                                  &ioStatusBlock,
                                  Direct);
             
    //
    // Free the sense buffer.
    //

    if (senseBuffer != NULL) {
        ExFreePool(senseBuffer);
    }

    return ioStatusBlock.Status;
}

VOID
PortPassThroughMarshalResults(
    IN PPORT_PASSTHROUGH_INFO PassThroughInfo,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PIRP RequestIrp,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN BOOLEAN Direct
    )
{
    PAGED_CODE();

    //
    // Copy the returned values from the srb to the control structure.
    //

    PassThroughInfo->SrbControl->ScsiStatus = Srb->ScsiStatus;
    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        //
        // Set the status to success so that the data is returned.
        //

        IoStatusBlock->Status = STATUS_SUCCESS;
        PassThroughInfo->SrbControl->SenseInfoLength = 
            Srb->SenseInfoBufferLength;

        //
        // Copy the sense data to the system buffer.
        //

        RtlCopyMemory(
            (PUCHAR)PassThroughInfo->SrbBuffer + 
                    PassThroughInfo->SrbControl->SenseInfoOffset,
            Srb->SenseInfoBuffer,
            Srb->SenseInfoBufferLength);

    } else {
        PassThroughInfo->SrbControl->SenseInfoLength = 0;
    }

    //
    // If the srb status is buffer underrun then set the status to success.
    // This insures that the data will be returned to the caller.
    //

    if (SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {
        IoStatusBlock->Status = STATUS_SUCCESS;
    }

    //
    // Set the information length
    //

    PassThroughInfo->SrbControl->DataTransferLength = Srb->DataTransferLength;

    if (Direct == TRUE) {

        RequestIrp->IoStatus.Information =
            PassThroughInfo->SrbControl->SenseInfoOffset +
            PassThroughInfo->SrbControl->SenseInfoLength;
    } else {

        if (!PassThroughInfo->SrbControl->DataIn || 
            PassThroughInfo->BufferOffset == 0) {

            RequestIrp->IoStatus.Information = 
                PassThroughInfo->SrbControl->SenseInfoOffset + 
                PassThroughInfo->SrbControl->SenseInfoLength;

        } else {

            RequestIrp->IoStatus.Information = 
                PassThroughInfo->SrbControl->DataBufferOffset + 
                PassThroughInfo->SrbControl->DataTransferLength;
        }
    }

    ASSERT((Srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) == 0);

    RequestIrp->IoStatus.Status = IoStatusBlock->Status;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\lib\mpiosup.c ===
/*++

Copyright (C) 2002  Microsoft Corporation

Module Name:

    mpiosup.c

Abstract:

    This module contains routines that port drivers can use for support of the MPIO package.
    
Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "precomp.h"

BOOLEAN
PortpFindMPIOSupportedDevice(
    IN PUNICODE_STRING DeviceName,
    IN PUNICODE_STRING SupportedDevices
    );

BOOLEAN
PortpMPIOLoaded(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PortGetMPIODeviceList)
#pragma alloc_text(PAGE, PortpFindMPIOSupportedDevice)
#pragma alloc_text(PAGE, PortpMPIOLoaded)
#pragma alloc_text(PAGE, PortIsDeviceMPIOSupported)
#endif



NTSTATUS
PortGetMPIODeviceList(
    IN PUNICODE_STRING RegistryPath,
    OUT PUNICODE_STRING MPIODeviceList 
    )
/*++

Routine Description:

    This routine builds and returns the MPIO SupportedDeviceList by querying the value 
    MPIOSupportedDeviceList under the key 'RegistryPath' (which should be
    HKLM\System\CurrentControlSet\Control\MPDEV). 

Arguments:

    RegistryPath - The Absolute registry path under which MPIOSupportDeviceList lives.
    
Return Value:

    The MULTI_SZ SupportedDeviceList or NULL.
    
--*/
{
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    WCHAR defaultIDs[] = { L"\0" };
    NTSTATUS status;

    PAGED_CODE();

    //
    // Zero the table entries.
    // 
    RtlZeroMemory(queryTable, sizeof(queryTable));

    //
    // The query table has two entries. One for the supporteddeviceList and
    // the second which is the 'NULL' terminator.
    // 
    // Indicate that there is NO call-back routine, and to give back the MULTI_SZ as
    // one blob, as opposed to individual unicode strings.
    // 
    queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND;

    //
    // The value to query.
    // 
    queryTable[0].Name = L"MPIOSupportedDeviceList";

    //
    // Where to put the strings, the type of the key, default values and length.
    // 
    queryTable[0].EntryContext = MPIODeviceList;
    queryTable[0].DefaultType = REG_MULTI_SZ;
    queryTable[0].DefaultData = defaultIDs;
    queryTable[0].DefaultLength = sizeof(defaultIDs);

    //
    // Try to get the device list.
    //
    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    RegistryPath->Buffer,
                                    queryTable,
                                    NULL,
                                    NULL);
    return status; 
}


BOOLEAN
PortpFindMPIOSupportedDevice(
    IN PUNICODE_STRING DeviceName,
    IN PUNICODE_STRING SupportedDevices
    )
/*++

Routine Description:

    This internal routine compares the two unicode strings for a match.

Arguments:

    DeviceName - String built from the current device's inquiry data.
    SupportedDevices - MULTI_SZ of devices that are supported.

Return Value:

    TRUE - If VendorId/ProductId is found.

--*/
{
    PWSTR devices = SupportedDevices->Buffer;
    UNICODE_STRING unicodeString;
    LONG compare;

    PAGED_CODE();

    //
    // 'devices' is the current buffer in the MULTI_SZ built from
    // the registry.
    //
    while (devices[0]) {

        //
        // Make the current entry into a unicode string.
        //
        RtlInitUnicodeString(&unicodeString, devices);

        //
        // Compare this one with the current device.
        //
        compare = RtlCompareUnicodeString(&unicodeString, DeviceName, TRUE);
        if (compare == 0) {
            return TRUE;
        }

        //
        // Advance to next entry in the MULTI_SZ.
        //
        devices += (unicodeString.MaximumLength / sizeof(WCHAR));
    }        
  
    return FALSE;
}


BOOLEAN
PortpMPIOLoaded(
    VOID
    )
/*++

Routine Description:

    This internal routine is used to determine whether an mpio package is installed by trying to
    open the MPIO SymLink.
    
    NOTE: Perhaps a more exhaustive method can be used in the future.

Arguments:

    NONE

Return Value:

    TRUE - If MPIO is present. 

--*/
{
    UNICODE_STRING unicodeName;
    PDEVICE_OBJECT controlDeviceObject;
    PFILE_OBJECT fileObject;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Build the symlink name.
    // 
    RtlInitUnicodeString(&unicodeName, L"\\DosDevices\\MPIOControl");

    //
    // Get mpio's deviceObject.
    //
    status = IoGetDeviceObjectPointer(&unicodeName,
                                      FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                                      &fileObject,
                                      &controlDeviceObject);

    if (NT_SUCCESS(status)) {
        ObDereferenceObject(fileObject);
    }
    return ((status == STATUS_SUCCESS) ? TRUE : FALSE);
}


BOOLEAN
PortIsDeviceMPIOSupported(
    IN PUNICODE_STRING DeviceList,
    IN PUCHAR VendorId,
    IN PUCHAR ProductId
    )
/*++

Routine Description:

    This routine determines whether the device is supported by traversing the SupportedDevice
    list and comparing to the VendorId/ProductId values passed in.

Arguments:

    DeviceList - MULTI_SZ retrieved from the registry by PortGetDeviceList
    VendorId - Pointer to the inquiry data VendorId.
    ProductId - Pointer to the inquiry data ProductId.

Return Value:

    TRUE - If VendorId/ProductId is found.

--*/
{
    UNICODE_STRING deviceName;
    UNICODE_STRING productName;
    ANSI_STRING ansiVendor;
    ANSI_STRING ansiProduct;
    NTSTATUS status;
    BOOLEAN supported = FALSE;
   
    PAGED_CODE();

    //
    // The SupportedDevice list was built in DriverEntry from the services key.
    // 
    if (DeviceList->MaximumLength == 0) {

        //
        // List is empty.
        //
        return FALSE;
    }

    //
    // If MPIO isn't loaded, don't claim support for the device.
    //
    if (!PortpMPIOLoaded()) {
        return FALSE;
    }
    
    //
    // Convert the inquiry fields into ansi strings.
    // 
    RtlInitAnsiString(&ansiVendor, VendorId);
    RtlInitAnsiString(&ansiProduct, ProductId);

    //
    // Allocate the deviceName buffer. Needs to be 8+16 plus NULL.
    // (productId length + vendorId length + NULL).
    // Add another 4 bytes for revision plus one pad, if anyone happens to jam that in.
    // 
    deviceName.MaximumLength = 30 * sizeof(WCHAR);
    deviceName.Buffer = ExAllocatePool(PagedPool, deviceName.MaximumLength);
    
    //
    // Convert the vendorId to unicode.
    // 
    RtlAnsiStringToUnicodeString(&deviceName, &ansiVendor, FALSE);

    //
    // Convert the productId to unicode.
    // 
    RtlAnsiStringToUnicodeString(&productName, &ansiProduct, TRUE);

    //
    // 'cat' them.
    // 
    status = RtlAppendUnicodeStringToString(&deviceName, &productName);

    if (status == STATUS_SUCCESS) {

        // 
        // Run the list of supported devices that was captured from the registry
        // and see if this one is in the list.
        // 
        supported = PortpFindMPIOSupportedDevice(&deviceName,
                                                 DeviceList);


    } 
    return supported;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\diskdump\diskdump.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    diskdump.h

Abstract:

    This file defines the necessary structures, defines, and functions for
    the common SCSI boot port driver.

Author:

    Mike Glass (Ported from Jeff Havens and Mike Glass loader development.)

Revision History:

--*/

#include "ntddscsi.h"

#define INITIAL_MEMORY_BLOCK_SIZE 0x2000
#define MAXIMUM_TRANSFER_SIZE 0x10000
#define MINIMUM_TRANSFER_SIZE 0x8000

//
// SCSI Get Configuration Information
//
// LUN Information
//

typedef struct _LUNINFO {
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    BOOLEAN DeviceClaimed;
    PVOID DeviceObject;
    struct _LUNINFO *NextLunInfo;
    UCHAR InquiryData[INQUIRYDATABUFFERSIZE];
} LUNINFO, *PLUNINFO;

typedef struct _SCSI_BUS_SCAN_DATA {
    USHORT Length;
    UCHAR InitiatorBusId;
    UCHAR NumberOfLogicalUnits;
    PLUNINFO LunInfoList;
} SCSI_BUS_SCAN_DATA, *PSCSI_BUS_SCAN_DATA;

typedef struct _SCSI_CONFIGURATION_INFO {
    UCHAR NumberOfBuses;
    PSCSI_BUS_SCAN_DATA BusScanData[1];
} SCSI_CONFIGURATION_INFO, *PSCSI_CONFIGURATION_INFO;

#define MAXIMUM_RETRIES 4

//
// System provided stall routine.
//

typedef
VOID
(*PSTALL_ROUTINE) (
    IN ULONG Delay
    );

//
// Define memory block header -- ensure always quad-aligned (code assumes that
// it is always aligned)
//

typedef struct _MEMORY_HEADER {
    struct _MEMORY_HEADER *Next;
    PVOID Address;
    ULONG Length;
    ULONG Spare;
} MEMORY_HEADER, *PMEMORY_HEADER;

//
// SCSI device timeout values in seconds
//

#define SCSI_DISK_TIMEOUT   10

//
// Adapter object transfer information.
//

typedef struct _ADAPTER_TRANSFER {
    PSCSI_REQUEST_BLOCK Srb;
    PVOID LogicalAddress;
    ULONG Length;
} ADAPTER_TRANSFER, *PADAPTER_TRANSFER;

typedef struct _DUMP_SCATTER_GATHER_LIST {
    ULONG NumberOfElements;
    ULONG_PTR Reserved;
    SCATTER_GATHER_ELEMENT Elements[17];
} DUMP_SCATTER_GATHER_LIST, *PDUMP_SCATTER_GATHER_LIST;

//
// Check that this is the same as the DDK's definition.
//

C_ASSERT (FIELD_OFFSET (DUMP_SCATTER_GATHER_LIST, Elements) ==
          FIELD_OFFSET (SCATTER_GATHER_LIST, Elements));

typedef enum _PORT_TYPE {
    ScsiPort = 1,
    StorPort = 2
} PORT_TYPE;

//
// Device extension
//

typedef struct _DEVICE_EXTENSION {

    PDEVICE_OBJECT DeviceObject;
    PSTALL_ROUTINE StallRoutine;
    PPORT_CONFIGURATION_INFORMATION ConfigurationInformation;

    //
    // Port driver we are operating on: SCSIPORT or STORPORT.
    //
    
    PORT_TYPE PortType;

    //
    // Partition information
    //

    LARGE_INTEGER PartitionOffset;

    //
    // Memory management
    //
    //

    PMEMORY_HEADER FreeMemory;
    PVOID CommonBuffer[2];
    PHYSICAL_ADDRESS PhysicalAddress[2];
    PHYSICAL_ADDRESS LogicalAddress[2];

    //
    // SRBs
    //

    SCSI_REQUEST_BLOCK Srb;
    SCSI_REQUEST_BLOCK RequestSenseSrb;

    //
    // Current request
    //

    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    ULONG LuFlags;
    PMDL Mdl;
    PVOID SpecificLuExtension;
    LONG RequestTimeoutCounter;
    ULONG RetryCount;
    ULONG ByteCount;
    DUMP_SCATTER_GATHER_LIST ScatterGatherList;
    //
    // Noncached breakout.
    //

    PVOID NonCachedExtension;
    ULONG NonCachedExtensionSize;
    PSENSE_DATA RequestSenseBuffer;
    PVOID SrbExtension;
    ULONG SrbExtensionSize;

    //
    // Dma Adapter information.
    //

    PVOID MapRegisterBase[2];
    PADAPTER_OBJECT DmaAdapterObject;
    ADAPTER_TRANSFER FlushAdapterParameters;
    ULONG NumberOfMapRegisters;

    //
    // Number of SCSI buses
    //

    UCHAR NumberOfBuses;

    //
    // Maximum targets per bus
    //

    UCHAR MaximumTargetIds;

    //
    // Disk block size
    //

    ULONG BytesPerSector;

    //
    // Sector shift count
    //

    ULONG SectorShift;

    //
    // SCSI Capabilities structure
    //

    IO_SCSI_CAPABILITIES Capabilities;

    //
    // SCSI configuration information from inquiries.
    //

    LUNINFO LunInfo;

    //
    // SCSI port driver flags
    //

    ULONG Flags;

    //
    // SCSI port interrupt flags
    //

    ULONG InterruptFlags;

    //
    // Adapter object transfer parameters.
    //

    ADAPTER_TRANSFER MapTransferParameters;

    KSPIN_LOCK SpinLock;

    //
    // Mapped address list
    //

    PMAPPED_ADDRESS MappedAddressList;

    //
    // Miniport entry points
    //

    PHW_INITIALIZE HwInitialize;
    PHW_STARTIO HwStartIo;
    PHW_INTERRUPT HwInterrupt;
    PHW_RESET_BUS HwReset;
    PHW_DMA_STARTED HwDmaStarted;
    PHW_BUILDIO HwBuildIo;

    //
    // Buffers must be mapped into system space.
    //

    BOOLEAN MapBuffers;

    //
    // Is this device a bus master and does it require map registers.
    //

    BOOLEAN MasterWithAdapter;

    //
    // Indicates that adapter with boot device has been found.
    //

    BOOLEAN FoundBootDevice;

    //
    // Device extension for miniport routines.
    //

    PVOID HwDeviceExtension;

    //
    // Miniport request interrupt enabled/disable routine.
    //

    PHW_INTERRUPT HwRequestInterrupt;

    //
    // Miniport timer request routine.
    //

    PHW_INTERRUPT HwTimerRequest;

    //
    // Indicates request has been submitted to miniport and
    // has not yet been completed.
    //

    BOOLEAN RequestPending;

    //
    // Indicates that request has been completed.
    //

    BOOLEAN RequestComplete;

    //
    // Physical address of zone pool
    //

    ULONG PhysicalZoneBase;

    //
    // Logical Unit Extension
    //

    ULONG HwLogicalUnitExtensionSize;

    ULONG TimerValue;

    //
    // Value is set to true when the dump is done.  We use this so that
    // we don't do a request sense incase one of the shutdown operations
    // fail.
    //
    BOOLEAN FinishingUp;

    //
    // The common buffer size is saved during initialization
    //
    ULONG CommonBufferSize;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#define DEVICE_EXTENSION_SIZE sizeof(DEVICE_EXTENSION)

//
// Port driver extension flags.
//

#define PD_CURRENT_IRP_VALID         0X0001
#define PD_RESET_DETECTED            0X0002
#define PD_NOTIFICATION_IN_PROGRESS  0X0004
#define PD_READY_FOR_NEXT_REQUEST    0X0008
#define PD_FLUSH_ADAPTER_BUFFERS     0X0010
#define PD_MAP_TRANSFER              0X0020
#define PD_CALL_DMA_STARTED          0X01000
#define PD_DISABLE_CALL_REQUEST      0X02000
#define PD_DISABLE_INTERRUPTS        0X04000
#define PD_ENABLE_CALL_REQUEST       0X08000
#define PD_TIMER_CALL_REQUEST        0X10000

//
// Logical unit extension flags.
//

#define PD_QUEUE_FROZEN              0X0001
#define PD_LOGICAL_UNIT_IS_ACTIVE    0X0002
#define PD_CURRENT_REQUEST_COMPLETE  0X0004
#define PD_LOGICAL_UNIT_IS_BUSY      0X0008

//
// The timer interval for the miniport timer routine specified in
// units of 100 nanoseconds.
//
#define PD_TIMER_INTERVAL (250 * 1000 * 10)   // 250 ms

//
// The define the interloop stall.
//

#define PD_INTERLOOP_STALL 5

#define COMPLETION_DELAY 10

//
// Define global data structures
//

extern ULONG ScsiPortCount;

//
// Define HalFlushIoBuffers for i386 and AMD64.
//

#if defined(i386) || defined(_AMD64_)
#define HalFlushIoBuffers
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\lib\precomp.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompiled header file for port driver library.

--*/

#include <ntddk.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>
#include <stdarg.h>
#include <scsi.h>
#include <ntddscsi.h>
#include <portlib.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\lib\bugcheck.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    bugcheck.c

Abstract:

    Port library routines for handling bugcheck callbacks.

Author:

    Matthew D Hendel (math) 4-April-2002

Revision History:

--*/

#include "precomp.h"


//
// Definitions
//

#define PORT_BUGCHECK_TAG   ('dBlP')


//
// Internal structures.
//

typedef struct _PORT_BUGCHECK_DATA {
    PVOID Buffer;
    ULONG BufferLength;
    ULONG BufferUsed;
    GUID Guid;
    PPORT_BUGCHECK_CALLBACK_ROUTINE CallbackRoutine;
    KBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord;
    KBUGCHECK_REASON_CALLBACK_RECORD SecondaryCallbackRecord;
} PORT_BUGCHECK_DATA, *PPORT_BUGCHECK_DATA;
    
    

//
// Global Variables
//

PPORT_BUGCHECK_DATA PortBugcheckData;



//
// Imports
//

extern PULONG_PTR KiBugCheckData;


//
// Prototypes
//

VOID
PortBugcheckGatherDataCallback(
    IN KBUGCHECK_CALLBACK_REASON Reason,
    IN PKBUGCHECK_REASON_CALLBACK_RECORD Record,
    IN OUT PVOID ReasonSpecificData,
    IN ULONG ReasonSpecificDataLength
    );

VOID
PortBugcheckWriteDataCallback(
    IN KBUGCHECK_CALLBACK_REASON Reason,
    IN PKBUGCHECK_REASON_CALLBACK_RECORD Record,
    IN OUT PVOID ReasonSpecificData,
    IN ULONG ReasonSpecificDataLength
    );

//
// Implementation
//

NTSTATUS
PortRegisterBugcheckCallback(
    IN PCGUID BugcheckDataGuid,
    IN PPORT_BUGCHECK_CALLBACK_ROUTINE BugcheckRoutine
    )
/*++

Routine Description:

    Register a bugcheck callback routine.

Arguments:

    BugcheckDataGuid - A GUID used to identify the data in the dump.

    BugcheckRoutine - Routine called when a bugcheck occurs.

Return Value:

    NTSTATUS code.

--*/
{
    BOOLEAN Succ;
    NTSTATUS Status;
    PVOID Temp;
    PPORT_BUGCHECK_DATA BugcheckData;
    PVOID Buffer;

    ASSERT (KeGetCurrentIrql() <= DISPATCH_LEVEL);

    Status = STATUS_SUCCESS;

    BugcheckData = ExAllocatePoolWithTag (NonPagedPool,
                                          sizeof (PORT_BUGCHECK_DATA),
                                          PORT_BUGCHECK_TAG);

    if (BugcheckData == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    RtlZeroMemory (BugcheckData, sizeof (PORT_BUGCHECK_DATA));

    Buffer = ExAllocatePoolWithTag (NonPagedPool,
                                    PAGE_SIZE,
                                    PORT_BUGCHECK_TAG);

    if (Buffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    
    BugcheckData->Buffer = Buffer;
    BugcheckData->BufferLength = 2 * PAGE_SIZE;
    BugcheckData->CallbackRoutine = BugcheckRoutine;
    BugcheckData->Guid = *BugcheckDataGuid;

    //
    // If PortBugcheckData == NULL, swap the values, otherwise fail the
    // function.
    //
    
    Temp = InterlockedCompareExchangePointer (&PortBugcheckData,
                                              BugcheckData,
                                              NULL);

    if (Temp != NULL) {
        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }
        

    KeInitializeCallbackRecord (&BugcheckData->CallbackRecord);
    KeInitializeCallbackRecord (&BugcheckData->SecondaryCallbackRecord);

    //
    // This registers the bugcheck "gather data" function.
    //
    
    Succ = KeRegisterBugCheckReasonCallback (&BugcheckData->CallbackRecord,
                                             PortBugcheckGatherDataCallback,
                                             KbCallbackReserved1,
                                             "PL");


    if (!Succ) {
        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    Succ = KeRegisterBugCheckReasonCallback (&BugcheckData->SecondaryCallbackRecord,
                                             PortBugcheckWriteDataCallback,
                                             KbCallbackSecondaryDumpData,
                                             "PL");

    if (!Succ) {
        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }

done:

    if (!NT_SUCCESS (Status)) {
        PortDeregisterBugcheckCallback (BugcheckDataGuid);
    }

    return STATUS_SUCCESS;
}



NTSTATUS
PortDeregisterBugcheckCallback(
    IN PCGUID BugcheckDataGuid
    )
/*++

Routine Description:

    Deregister a bugcheck callback routine previously registered by
    PortRegisterBugcheckCallback.

Arguments:

    BugcheckDataGuid - Guid associated with the data stream to deregister.

Return Value:

    NTSTATUS code.

--*/
{
    PPORT_BUGCHECK_DATA BugcheckData;
    
    BugcheckData = InterlockedExchangePointer (&PortBugcheckData, NULL);

    if (BugcheckData == NULL ||
        !IsEqualGUID (&BugcheckData->Guid, BugcheckDataGuid)) {

        return STATUS_UNSUCCESSFUL;
    }

    KeDeregisterBugCheckReasonCallback (&BugcheckData->SecondaryCallbackRecord);
    KeDeregisterBugCheckReasonCallback (&BugcheckData->CallbackRecord);

    if (BugcheckData->Buffer != NULL) {
        ExFreePoolWithTag (BugcheckData->Buffer, PORT_BUGCHECK_TAG);
        BugcheckData->Buffer = NULL;
    }
    
    ExFreePoolWithTag (BugcheckData, PORT_BUGCHECK_TAG);

    return STATUS_SUCCESS;
}



VOID
PortBugcheckGatherDataCallback(
    IN KBUGCHECK_CALLBACK_REASON Reason,
    IN PKBUGCHECK_REASON_CALLBACK_RECORD Record,
    IN OUT PVOID ReasonSpecificData,
    IN ULONG ReasonSpecificDataLength
    )
/*++

Routine Description:

    Port driver routine to gather data during a bugcheck.

Arguments:

    Reason - Must be KbCallbackReserved1.

    Record - Supplies the bugcheck record previously registered.

    ReasonSpecificData - Not used.

    ReasonSpecificDataLength - Not used.

Return Value:

    None.

Environment:

    The routine is called from bugcheck context: at HIGH_LEVEL, with
    interrupts disabled and other processors stalled.
    
--*/
{
    NTSTATUS Status;
    KBUGCHECK_DATA BugcheckData;
    
    //
    // On multiproc we only go till IPI_LEVEL
    //
    ASSERT (KeGetCurrentIrql() >= IPI_LEVEL);
    ASSERT (Reason == KbCallbackReserved1);
    ASSERT (PortBugcheckData != NULL);
    ASSERT (PortBugcheckData->BufferUsed == 0);

    BugcheckData.BugCheckCode = (ULONG)KiBugCheckData[0];
    BugcheckData.BugCheckParameter1 = KiBugCheckData[1];
    BugcheckData.BugCheckParameter2 = KiBugCheckData[2];
    BugcheckData.BugCheckParameter3 = KiBugCheckData[3];
    BugcheckData.BugCheckParameter4 = KiBugCheckData[4];
    
    //
    // Gather data, put it in the buffer.
    //

    Status = PortBugcheckData->CallbackRoutine (&BugcheckData,
                                                PortBugcheckData->Buffer,
                                                PortBugcheckData->BufferLength,
                                                &PortBugcheckData->BufferUsed);

    if (!NT_SUCCESS (Status)) {
        PortBugcheckData->BufferUsed = 0;
    }
}


VOID
PortBugcheckWriteDataCallback(
    IN KBUGCHECK_CALLBACK_REASON Reason,
    IN PKBUGCHECK_REASON_CALLBACK_RECORD Record,
    IN OUT PVOID ReasonSpecificData,
    IN ULONG ReasonSpecificDataLength
    )
/*++

Routine Description:

    Port driver routine to write data out during a bugcheck.

Arguments:

    Reason - Must be KbCallbackSecondaryData.

    Record - Supplies the bugcheck record previously registered.

    ReasonSpecificData - Pointer to KBUGCHECK_SECONDARY_DUMP_DATA structure.

    ReasonSpecificDataLength - Sizeof ReasonSpecificData buffer.

Return Value:

    None.

Environment:

    The routine is called from bugcheck context: at HIGH_LEVEL, with
    interrupts disabled and other processors stalled.
    
--*/
{
    PKBUGCHECK_SECONDARY_DUMP_DATA SecondaryData;
    
    //
    // On multiproc we only go till IPI_LEVEL
    //
    ASSERT (KeGetCurrentIrql() >= IPI_LEVEL);
    ASSERT (ReasonSpecificDataLength >= sizeof(KBUGCHECK_SECONDARY_DUMP_DATA));
    ASSERT (Reason == KbCallbackSecondaryDumpData);

    SecondaryData = (PKBUGCHECK_SECONDARY_DUMP_DATA)ReasonSpecificData;

    //
    // This means we have no data to provide.
    //
    
    if (PortBugcheckData->BufferUsed == 0) {
        return ;
    }
    
    //
    // If OutBuffer is NULL, then this is a request for sizing information
    // only. Do not fill in the rest of the data.
    //
    
    if (SecondaryData->OutBuffer == NULL) {
        SecondaryData->Guid = PortBugcheckData->Guid;
        SecondaryData->OutBuffer = PortBugcheckData->Buffer;
        SecondaryData->OutBufferLength = PortBugcheckData->BufferUsed;
        return ;
    }

    //
    // Is there enough space?
    //
    
    if (SecondaryData->MaximumAllowed < PortBugcheckData->BufferUsed) {
        return ;
    }
        

    SecondaryData->Guid = PortBugcheckData->Guid;
    SecondaryData->OutBuffer = PortBugcheckData->Buffer;
    SecondaryData->OutBufferLength = PortBugcheckData->BufferUsed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\ext\kdext.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "pch.h"


//
// globals
//

WINDBG_EXTENSION_APIS  ExtensionApis;


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}



extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(
    PULONG Version,
    PULONG Flags
    )
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;


    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C" void CALLBACK
DebugExtensionUninitialize(void)
{
//    g_ExcepCallbacks.Uninitialize();
//    g_FnProfCallbacks.Uninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\ext\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntosp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <storport.h>

#define KDEXT_64BIT
#include <wdbgexts.h>
#include <dbgeng.h>

//
// undef the wdbgexts
//
#undef DECLARE_API
#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define MINIPKD_PRINT_ERROR(r)\
    dprintf("minipkd error (%x): %s @ line %d\n", (r), __FILE__, __LINE__);

#define RECUR  DBG_DUMP_FIELD_RECUR_ON_THIS
#define F_ADDR DBG_DUMP_FIELD_RETURN_ADDRESS
#define COPY   DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_COPY_FIELD_DATA | DBG_DUMP_FIELD_RETURN_ADDRESS
#define ADDROF DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_FULL_NAME

// Stolen from ntrtl.h to override RECOMASSERT
#undef ASSERT
#undef ASSERTMSG

#if DBG
#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG

extern WINDBG_EXTENSION_APIS64 ExtensionApis;

#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#define _DRIVER

#define KDBG_EXT

#include "wmistr.h"

#ifdef __cplusplus
extern "C" {
#endif

#define PRINT_FLAGS(Flags,b)      if (Flags & b) {dprintf(#b", ");}

__inline 
VOID
xdindent(
    ULONG Depth
    )
{
    ULONG i;
    for (i=0; i<Depth; i++)
        dprintf("  ");
}

#define xdprintfEx(d, expr)\
    xdindent((d));\
    dprintf expr

typedef struct {
    ULONG Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

#define FLAG_NAME(flag)           {flag, #flag}

extern FLAG_NAME SrbFlags[];

PUCHAR
DevicePowerStateToString(
    IN DEVICE_POWER_STATE State
    );

VOID
GetAddressAndDetailLevel(
    IN  PCSTR      Args,
    OUT PULONG64   Address,
    OUT PLONG      Detail
    );

VOID
GetAddress(
    IN  PCSTR      Args,
    OUT PULONG64   Address
    );

PUCHAR
SystemPowerStateToString(
    IN DEVICE_POWER_STATE State
    );

VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    );

VOID
DumpFlags(
    ULONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    );

BOOLEAN
GetAnsiString(
    IN ULONG_PTR Address,
    IN PUCHAR Buffer,
    IN OUT PULONG Length
    );

PCHAR
GuidToString(
    GUID* GUID
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\lib\registry.c ===
/*++

Copyright (C) 2002  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    This module contains routines that port drivers export to miniports to allow
    them to read and write registry data. The Keys are relative to the miniport's
    <ServiceName>\Parameters key.
    
Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "precomp.h"

#define MAX_REGISTRY_BUFFER_SIZE 0x10000
#define PORT_TAG_REGISTRY_BUFFER 'BRlP'


#define PORT_REGISTRY_INFO_INITIALIZED 0x00000001
#define PORT_REGISTRY_BUFFER_ALLOCATED 0x00000002



NTSTATUS
PortMiniportRegistryInitialize(
    IN OUT PPORT_REGISTRY_INFO PortContext
    )
/*++

Routine Description:

    This routine is called by the port driver to init the registry routine's internal
    data.

Arguments:

    PortContext -  Used to identify the caller and instatiation of the caller.

Return Value:

    STATUS_SUCCESS for now. If this is extended, it might require allocations, etc.

--*/
{
    NTSTATUS status;

    ASSERT(PortContext->Size == sizeof(PORT_REGISTRY_INFO));

    //
    // Initialize the spinlock and list entry.
    // 
    KeInitializeSpinLock(&PortContext->SpinLock);
    InitializeListHead(&PortContext->ListEntry);
    
    //
    // Ensure that buffer is NULL at this time. It's only valid after we allocate it.
    //
    PortContext->Buffer = NULL;

    //
    // Indiacate that this is ready to go.
    //
    PortContext->Flags = PORT_REGISTRY_INFO_INITIALIZED;

    return STATUS_SUCCESS;
}   


VOID
PortMiniportRegistryDestroy(
    IN PPORT_REGISTRY_INFO PortContext
    )
/*++

Routine Description:

    This routine is called by the port driver when it unloads a miniport.
    It will free the resources and cleanup whatever else.

Arguments:

    PortContext -  Used to identify the caller and instatiation of the caller.

Return Value:

    NOTHING

--*/
{
    KIRQL irql;

    KeAcquireSpinLock(&PortContext->SpinLock, &irql);
    
    //
    // See whether there is still a buffer hanging around.
    // 
    if (PortContext->Flags & PORT_REGISTRY_BUFFER_ALLOCATED) {
        ASSERT(PortContext->Buffer);

        //
        // Free it.
        //
        ExFreePool(PortContext->Buffer);
    } else {

        //
        // This should be NULL if it's not allocated.
        //
        ASSERT(PortContext->Buffer == NULL);
    }

    //
    // Clean up.
    //
    PortContext->Flags = 0;
    PortContext->Buffer = NULL;
    
    KeReleaseSpinLock(&PortContext->SpinLock, irql);
    return;
}


NTSTATUS
PortAllocateRegistryBuffer(
    IN PPORT_REGISTRY_INFO PortContext
    )
/*++

Routine Description:

    This routine is called by the port driver to allocate a registry buffer of Length for the
    miniport. 
    The caller should initialize Length before calling this routine.

    Length is checked against a max. and alignment requirements and updated accordingly, if
    necessary.

Arguments:

    PortContext - Value used to identify the caller and instatiation of the caller.

Return Value:

    The buffer field is updated or NULL if some error prevents the allocation. 
    Length is updated to reflect the actual size.
    SUCCESS, INSUFFICIENT_RESOURCES, or BUSY if the miniport already has a buffer.

--*/
{
    PUCHAR buffer = NULL;
    ULONG length;
    NTSTATUS status;

    //
    // The size must be correct.
    // 
    ASSERT(PortContext->Size == sizeof(PORT_REGISTRY_INFO));

    //
    // Must be initialized via the init routine.
    // 
    ASSERT(PortContext->Flags & PORT_REGISTRY_INFO_INITIALIZED );

    //
    // Can't be here twice.
    // 
    ASSERT((PortContext->Flags & PORT_REGISTRY_BUFFER_ALLOCATED) == 0);
       
    //
    // Capture the length.
    // 
    length = PortContext->LengthNeeded;

    //
    // See if the miniport is attempted a double allocate.
    // 
    if (PortContext->Flags & PORT_REGISTRY_BUFFER_ALLOCATED) {

        //
        // This would say that there better be a buffer.
        // 
        ASSERT(PortContext->Buffer);
        
        //
        // Buffer already outstanding, so don't allow this.
        //
        status = STATUS_DEVICE_BUSY;

    } else {    
            
        //
        // Check the upper bound.
        // 
        if (length > MAX_REGISTRY_BUFFER_SIZE) {

            //
            // The request is too large, reset it. The port driver or miniport will have
            // to deal with the change.
            //
            length = MAX_REGISTRY_BUFFER_SIZE;
        }    

        //
        // Allocate the buffer.
        // 
        buffer = ExAllocatePoolWithTag(NonPagedPool,
                                       length,
                                       PORT_TAG_REGISTRY_BUFFER);
        if (buffer == NULL) {

            //
            // Set the caller's length to 0 as the allocation failed.
            //
            PortContext->AllocatedLength = 0;
            status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            //
            // Indicate that the allocation of Length was successful, and
            // that the miniport has a registry buffer.
            //
            PortContext->Flags |= PORT_REGISTRY_BUFFER_ALLOCATED;
            PortContext->Buffer = buffer;
            PortContext->AllocatedLength = length;

            //
            // Zero it for them to be nice.
            //
            RtlZeroMemory(buffer, length);

            status = STATUS_SUCCESS;
        }     
    }    

    return status;
}    


NTSTATUS
PortFreeRegistryBuffer(
    IN PPORT_REGISTRY_INFO PortContext
    )
/*++

Routine Description:

    Frees the buffer allocated via PortAllocateRegistryBuffer. 

Arguments:

    PortContext - Value used to identify the caller and instatiation of the caller.

Return Value:

    INVALID_PARAMETER if the buffer isn't already allocated.
    SUCCESS

--*/
{
    //
    // The size must be correct.
    // 
    ASSERT(PortContext->Size == sizeof(PORT_REGISTRY_INFO));

    //
    // Must be initialized via the init routine.
    // 
    ASSERT(PortContext->Flags & PORT_REGISTRY_INFO_INITIALIZED );

    //
    // Can't be here, unless a buffer has been allocated.
    // 
    ASSERT(PortContext->Flags & PORT_REGISTRY_BUFFER_ALLOCATED);

    //
    // If it's not allocated, return an error.
    //
    if ((PortContext->Flags & PORT_REGISTRY_BUFFER_ALLOCATED) == 0) {

        ASSERT(PortContext->Buffer == NULL);
        
        return STATUS_INVALID_PARAMETER;
    }    
   
    //
    // Poison the buffer to catch poorly-written miniports.
    //
    RtlZeroMemory(PortContext->Buffer, PortContext->AllocatedLength);
    
    //
    // Free the buffer.
    // 
    ExFreePool(PortContext->Buffer);

    //
    // Indicate that it's gone.
    //
    PortContext->Flags &= ~PORT_REGISTRY_BUFFER_ALLOCATED;
    PortContext->AllocatedLength = 0;
    PortContext->Buffer = NULL;

    return STATUS_SUCCESS;
}


ULONG
WCharToAscii(
    OUT PUCHAR Destination,
    IN  PWCHAR Source,
    IN  ULONG   BufferSize
    )
/*+++

Routine Description:

    This routine is used to convert the Source buffer into ASCII.

    NOTE: BufferSize should include the NULL-Terminator, while the return value does not.

Arguements:

    Destination - ASCII buffer to place the converted values.
    Source - WCHAR buffer containing the string to convert.
    BufferSize - Size, in bytes, of Destination.

Return Value:

    The converted buffer and the count of converted chars. The NULL-termination
    isn't included.

--*/
{
    ULONG convertedCount = 0;
    ULONG i;

    RtlZeroMemory(Destination, BufferSize);
    
    if (Source) {

        //
        // Run through the Source buffer and convert the WCHAR to ASCII, placing
        // the converted value in Destination. Ensure that the destination buffer
        // isn't overflowed.
        //
        for (i = 0; (i < (BufferSize - 1)) && (*Source); i++, convertedCount++) {
            *Destination = (UCHAR)*Source;
            Destination++;
            Source++;
        }    
    }

    return convertedCount;
}    


ULONG
AsciiToWChar(
    IN PWCHAR Destination,
    IN PUCHAR Source,
    IN ULONG BufferSize
    )
/*+++

Routine Description:

    This routine is used to convert the Source buffer into WCHAR.

    NOTE: BufferSize should include the NULL-Terminator, while the return value does not.

Arguements:

    Destination - WCHAR buffer to place the converted values.
    Source - ASCII buffer containing the string to convert.
    BufferSize - Size, in bytes, of Destination.

Return Value:

    The converted buffer and the count of converted chars. The NULL-termination
    isn't included.

--*/
{
    ULONG convertedCount = 0;
    ULONG i;
    
    RtlZeroMemory(Destination, BufferSize);
    
    if (Source) {

        //
        // Run through source buffer and convert the ascii values to WCHAR and put
        // the convert into Destination. Ensure that neither source nor dest are
        // overflowed.
        // 
        for (i = 0; (i < (BufferSize - 1)) && (*Source); i++, convertedCount++) {
            *Destination = (WCHAR)*Source;
            Destination++;
            Source++;
        }    
    }
    return convertedCount;
}


NTSTATUS
PortAsciiToUnicode(
    IN PUCHAR AsciiString,
    OUT PUNICODE_STRING UnicodeString
    )
{
    ANSI_STRING ansiString;
    
    //
    // Convert ValueName to Unicode.
    //
    RtlInitAnsiString(&ansiString, AsciiString);
    return RtlAnsiStringToUnicodeString(UnicodeString, &ansiString, TRUE);
}


NTSTATUS
PortpBinaryReadCallBack(
   IN PWSTR ValueName,
   IN ULONG Type,
   IN PVOID Buffer,
   IN ULONG BufferLength,
   IN PVOID Context,
   IN PVOID EntryContext
   )
/*++

Routine Description:

    This routine is the callback function for handling REG_BINARY reads. It will determine
    whether the buffer in the PORT_REGISTRY_INFO is of sufficient size to handle the data,
    and copy it over, if necessary. Otherwise the data length needed is updated.

Arguments:

    ValueName - The name of the data to be returned.
    Type - The reg. data type for this request.
    ValueLength - Size, in bytes, of ValueData
    Context - Not used.
    PortContext -  Blob containing the miniports buffer and it's size.

Return Value:

    SUCCESS or BUFFER_TOO_SMALL (which unfortunately gets updated by the RTL function to
    SUCCESS. InternalStatus is updated to the real status and the length field within
    the REGISTRY_INFO struct. is updated.
    
--*/
{
    PPORT_REGISTRY_INFO portContext = EntryContext;
    PUCHAR currentBuffer;
    NTSTATUS status = STATUS_BUFFER_TOO_SMALL;
  
    //
    // Determine whether the supplied buffer is big enough to hold the data.
    //
    if (portContext->CurrentLength >= BufferLength) {

        //
        // Determine the correct offset into the buffer.
        //
        currentBuffer = portContext->Buffer + portContext->Offset;

        //
        // The Rtl routine will free it's buffer, so get the data now.
        //
        RtlCopyMemory(currentBuffer, Buffer, BufferLength);

        //
        // Update the status to show the data in the buffer is valid.
        //
        status = STATUS_SUCCESS;

    }

    //
    // Update the length. This will either tell them how big the buffer
    // should be, or how large the returned data actually is.
    // The Read routine will handle the rest.
    //
    portContext->CurrentLength = BufferLength;
    portContext->InternalStatus = status;

    //
    // Return the status to the Read routine.
    // 
    return status;
}


NTSTATUS
PortRegistryRead(
    IN PUNICODE_STRING RegistryKeyName,
    IN PUNICODE_STRING ValueName,
    IN ULONG Type,
    IN PPORT_REGISTRY_INFO PortContext
    )
/*++

Routine Description:

    This routine is used by the portdriver to read the info. at ValueName from the regkey

    This assumes that the data is a REG_SZ, REG_DWORD, or REG_BINARY only.
    REG_SZ data is converted into a NULL-terminiated ASCII string from the UNICODE.
    DWORD and BINARY data are directly copied into the caller's buffer if it's of
    correct size.
    
Arguments:

    RegistryKeyName - The absolute key name where ValueName lives.
    ValueName - The name of the data to be returned.
    Type - The reg. data type for this request.
    PortContext -  Blob containing the miniports buffer and it's size.

Return Value:

    STATUS of the registry routines, INSUFFICIENT_RESOURCES, or BUFFER_TOO_SMALL.
    If TOO_SMALL, LengthNeeded within the PortContext is updated to reflect the size needed.
    
--*/
{
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    WCHAR defaultData[] = { L"\0" };
    ULONG defaultUlong = (ULONG)-1;
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    ULONG length;
    PUCHAR currentBuffer;

    RtlZeroMemory(queryTable, sizeof(queryTable));
   
    //
    // Calculate the actual buffer location where this data should go.
    // This presupposes that the port-driver has done all the validation, otherwise
    // this will be blindly copying into who-knows-where.
    //
    currentBuffer = PortContext->Buffer + PortContext->Offset;

    //
    // Looking for what lives at ValueName.
    //
    queryTable[0].Name = ValueName->Buffer;

    //
    // Indicate that there is no call-back routine and to return everything as one big
    // blob.
    //
    queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND;

    //
    // Handle setting up for the various types that are supported.
    // 
    if (Type == REG_SZ) {
        
        RtlZeroMemory(&unicodeString, sizeof(UNICODE_STRING));

        //
        // Local storage for the returned data. The routine will allocate the buffer
        // and set Length.
        //
        queryTable[0].EntryContext = &unicodeString;
        queryTable[0].DefaultData = defaultData;
        queryTable[0].DefaultLength = sizeof(defaultData);

    } else if (Type == REG_DWORD) {
     
        //
        // The data will be placed in the first ulong of the caller's 
        // buffer.
        // 
        queryTable[0].EntryContext = currentBuffer;
        queryTable[0].DefaultData = &defaultUlong;
        queryTable[0].DefaultLength = sizeof(ULONG);

    } else {

        //
        // Clear the flags because we need a callback to determine
        // the real size of the binary data.
        //
        queryTable[0].Flags = 0; 
        queryTable[0].QueryRoutine = PortpBinaryReadCallBack;
        queryTable[0].EntryContext = PortContext; 
        queryTable[0].DefaultData = &defaultUlong;
        queryTable[0].DefaultLength = sizeof(ULONG); 
    }    

    //
    // Set the type. 
    //
    queryTable[0].DefaultType = Type;

    //
    // Call the query routine. This will either be direct, or result in the callback
    // function getting invoked.
    // 
    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    RegistryKeyName->Buffer,
                                    queryTable,
                                    NULL,
                                    NULL);
    if (NT_SUCCESS(status)) {
    
        if (Type == REG_SZ) {
           
            //
            // Have their data. Now figure out whether it fits. The Query function allocates
            // the unicode string buffer.
            //
            if ((unicodeString.Length) && 
                ((unicodeString.Length / sizeof(WCHAR)) <= PortContext->CurrentLength)) {

                //
                // Magically convert.
                //
                length = WCharToAscii(currentBuffer,
                                      unicodeString.Buffer,
                                      PortContext->CurrentLength);

                //
                // Set the length of the buffer.
                //
                PortContext->CurrentLength = length;

            } else {
                ASSERT(unicodeString.Length);

                //
                // Update the Length to indicate how big it should actually be.
                //
                PortContext->LengthNeeded = (unicodeString.Length + 1) / sizeof(WCHAR);
                PortContext->CurrentLength = 0;
                status = STATUS_BUFFER_TOO_SMALL;

            }    
           
            //
            // Free our string, as the data has already been copied, or won't be copied
            // into the caller's buffer.
            // 
            ExFreePool(unicodeString.Buffer);
           
        } else if (Type == REG_DWORD) {

            //
            // The data should already be there.
            // 
            PortContext->CurrentLength = sizeof(ULONG);

        } else {

            //
            // The Rtl routine has this annoying effect of fixing up BUFFER_TOO_SMALL
            // into SUCCESS. Check for this case.
            //
            if (PortContext->InternalStatus == STATUS_BUFFER_TOO_SMALL) {

                //
                // Reset the status correctly for the caller.
                // 
                status = PortContext->InternalStatus;
                
                //
                // Update length needed, so that the miniport can realloc.
                // 
                PortContext->LengthNeeded = PortContext->CurrentLength;
                PortContext->CurrentLength = 0;

            } else {

                //
                // The callback did all the necessary work.
                //
                NOTHING;
            }    
        }    
    } else {

        //
        // Indicate to the caller that the error is NOT due to a length mismatch or
        // that the Buffer is too small. The difference is that if too small, the callback
        // routine adjusted CurrentLength.
        //
        PortContext->LengthNeeded = PortContext->CurrentLength;
        PortContext->CurrentLength = 0;
    }    

    return status;
}



NTSTATUS
PortRegistryWrite(
    IN PUNICODE_STRING RegistryKeyName,
    IN PUNICODE_STRING ValueName,
    IN ULONG Type,
    IN PPORT_REGISTRY_INFO PortContext
    )
/*++

Routine Description:

    This routine is used by the port-driver to write the contents of Buffer to ValueName
    which is located at the reg. key RegistryKeyName.

    Buffer is first converted to UNICODE then the write takes place.

Arguments:

    RegistryKeyName - The absolute path to the key name.
    ValueName - The name of the data to be written.
    Type - The reg. data type for this operation.
    PortContext -  Blob containing the miniports buffer and it's size.

Return Value:

    STATUS from the registry routines, or INSUFFICIENT_RESOURCES

--*/
{
    UNICODE_STRING unicodeString;
    ULONG bufferLength;
    PUCHAR currentBuffer;
    LONG offset;
    ULONG length;
    NTSTATUS status;
   
    //
    // Determine whether the field exists.
    //
    status = RtlCheckRegistryKey(RTL_REGISTRY_ABSOLUTE,
                                 RegistryKeyName->Buffer);

    if (!NT_SUCCESS(status)) {

        //
        // The key doesn't exist. Create it.
        // 
        status = RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE,
                                      RegistryKeyName->Buffer);
    }

    if (!NT_SUCCESS(status)) {

        //
        // Can't go on. Return the error to the port-driver and it can figure
        // out what best to do.
        //
        return status;
    }    

    //
    // Calculate the actual buffer location where this data lives. 
    // This presupposes that the port-driver has done all the validation.
    //
    currentBuffer = PortContext->Buffer + PortContext->Offset;

    if (Type == REG_SZ) {

        //
        // Determine the size needed for the WCHAR.
        // 
        bufferLength = PortContext->CurrentLength * sizeof(WCHAR);
        
        //
        // Allocate a buffer to build the converted data in.
        //
        unicodeString.Buffer = ExAllocatePool(NonPagedPool, bufferLength + sizeof(UNICODE_NULL));
        if (unicodeString.Buffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }    

        RtlZeroMemory(unicodeString.Buffer, bufferLength + sizeof(UNICODE_NULL));

        //
        // Set the lengths.
        // 
        unicodeString.MaximumLength = (USHORT)(bufferLength + sizeof(UNICODE_NULL));
        unicodeString.Length = (USHORT)bufferLength;


        //
        // Convert it.
        //
        length = AsciiToWChar(unicodeString.Buffer,
                              currentBuffer,
                              unicodeString.Length);

        //
        // Length is now set for the call below. Get the buffer by resetting
        // currentbuffer to that of the unicode string's.
        //
        currentBuffer = (PUCHAR)unicodeString.Buffer;

    } else if (Type == REG_DWORD){

        //
        // always this size.
        // 
        length = sizeof(ULONG);
        
    } else {    

        //
        // For BINARY use the passed in buffer (currentBuffer) and length.
        //
        length = PortContext->CurrentLength;
    }    

    //
    // Write the data to the specified key/Value
    // 
    status = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                   RegistryKeyName->Buffer,
                                   ValueName->Buffer,
                                   Type,
                                   currentBuffer,
                                   length);
      
    return status;
}


NTSTATUS
PortBuildRegKeyName(
    IN PUNICODE_STRING RegistryPath,
    IN OUT PUNICODE_STRING KeyName,
    IN ULONG PortNumber, 
    IN ULONG Global
    )
/*++

Routine Description:

    This routine will build the registry keyname to the miniport's
    Device(N) key based on RegistryPath and whether the key is for global miniport
    data, or specific to one scsiN.

Arguments:

    RegistryPath - The path to the miniport's service key.
    KeyName - Storage for the whole path.
    PortNumber - The adapter ordinal. Valid only if Global is FALSE.
    Global - Indicates whether the Device or Device(N) path should be built.

Return Value:

    SUCCESS - KeyName is valid.
    INSUFFICIENT_RESOURCES

--*/
{
    UNICODE_STRING unicodeValue;
    UNICODE_STRING tempKeyName; 
    ANSI_STRING ansiKeyName;
    ULONG maxLength;
    NTSTATUS status;
    UCHAR paramsBuffer[24];
    
    //
    // If this is global, it represents ALL adapters being controlled by
    // the miniport. Otherwise, it's the scsiN key only.
    // 
    if (Global) {
        
        RtlInitAnsiString(&ansiKeyName, "\\Parameters\\Device");
        RtlAnsiStringToUnicodeString(&tempKeyName, &ansiKeyName, TRUE);
    } else {

        //
        // Get the scsiport'N'.
        //
        sprintf(paramsBuffer, "\\Parameters\\Device%d", PortNumber);
        RtlInitAnsiString(&ansiKeyName, paramsBuffer);
        RtlAnsiStringToUnicodeString(&tempKeyName, &ansiKeyName, TRUE);
    }

    //
    // The total length will be the size of the path to <services> plus the parameters\device
    // string. Add enough for a NULL at the end.
    // 
    maxLength = RegistryPath->MaximumLength + tempKeyName.MaximumLength + 2;
    KeyName->Buffer = ExAllocatePool(NonPagedPool, maxLength);
    if (KeyName->Buffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(KeyName->Buffer, maxLength);

    //
    // Clone the Reg.Path.
    //
    KeyName->MaximumLength = (USHORT)maxLength;
    RtlCopyUnicodeString(KeyName,
                         RegistryPath);

    //
    // Have a copy of the path to the services name. Add the rest of the keyname
    // to it.
    //
    status = RtlAppendUnicodeStringToString(KeyName, &tempKeyName);
    
    //
    // Free the buffer allocated above.
    //
    RtlFreeUnicodeString(&tempKeyName);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\inc\sldefs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sldefs.h

Abstract:

    Simple macro definitions exported by the storlib library.

Author:

    Matthew D Hendel (math) 13-Feb-2001

Revision History:

--*/

#pragma once

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   (((Flags) & (Bit)) != 0)

#define min(a,b) (((a) < (b)) ? (a) : (b))
#define max(a,b) (((a) > (b)) ? (a) : (b))

#define ARRAY_COUNT(Array) (sizeof(Array)/sizeof(Array[0]))
#define IN_RANGE(a,b,c) ((a) <= (b) && (b) < (c))

#define INLINE __inline

typedef const GUID *PCGUID;

//
// NT uses a system time measured in 100 nanosecond intervals.  define
// conveninent constants for setting the timer.
//

#define MICROSECONDS        10              // 10 nanoseconds
#define MILLISECONDS        (MICROSECONDS * 1000)
#define SECONDS             (MILLISECONDS * 1000)
#define MINUTES             (SECONDS * 60)

#define RELATIVE_TIMEOUT    (-1)


//
// The standard definition of RemoveListHead is not an expression, hence
// cannot be used in loops, etc.
//

PLIST_ENTRY
INLINE
_RemoveHeadList(
    IN PLIST_ENTRY ListHead
    )
{
    return RemoveHeadList (ListHead);
}

#undef RemoveHeadList
#define RemoveHeadList _RemoveHeadList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\inc\sldict.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	dict.h

Abstract:

	Simple dictionary data structure based on a hash table. The hash
	table gives constant time performance if the number of elements in
	the table is close to the number of bins allocated for the table.

	The dictionary does not provide automatic synchronization.

Author:

	Matthew D Hendel (math) 8-Feb-2001

Revision History:

--*/

#pragma once

//
// Dictionary entry. Use this the same way the LIST_ENTRY
// structure is used; i.e., by embedding it into the structure you
// will be adding to the list. By doing this we avoid a per-element
// memory allocation.
//

typedef LIST_ENTRY STOR_DICTIONARY_ENTRY, *PSTOR_DICTIONARY_ENTRY;


//
// User-supplied GetKey routine.
//

typedef PVOID
(*STOR_DICTIONARY_GET_KEY_ROUTINE)(
	IN PSTOR_DICTIONARY_ENTRY Entry
	);

//
// User-supplied compare key routine.
//

typedef LONG
(*STOR_DICTIONARY_COMPARE_KEY_ROUTINE)(
	IN PVOID Key1,
	IN PVOID Key2
	);

//
// User-supplied hash routine.
//

typedef ULONG
(*STOR_DICTIONARY_HASH_KEY_ROUTINE)(
	IN PVOID Key
	);

//
// Dictionary sstructure.
//

typedef struct _STOR_DICTIONARY {
	ULONG EntryCount;
	ULONG MaxEntryCount;
	POOL_TYPE PoolType;
	PSTOR_DICTIONARY_ENTRY Entries;
	STOR_DICTIONARY_GET_KEY_ROUTINE GetKeyRoutine;
	STOR_DICTIONARY_COMPARE_KEY_ROUTINE CompareKeyRoutine;
	STOR_DICTIONARY_HASH_KEY_ROUTINE HashKeyRoutine;
} STOR_DICTIONARY, *PSTOR_DICTIONARY;


//
// Enumerator structure used for enumerating the elements in the dictionary.
//

typedef
BOOLEAN
(*STOR_ENUMERATE_ROUTINE)(
	IN struct _STOR_DICTIONARY_ENUMERATOR* Enumerator,
	IN PLIST_ENTRY Entry
	);
	
typedef struct _STOR_DICTIONARY_ENUMERATOR {
	PVOID Context;
	STOR_ENUMERATE_ROUTINE EnumerateEntry;
} STOR_DICTIONARY_ENUMERATOR, *PSTOR_DICTIONARY_ENUMERATOR;


//
// Default compare-key routine when the keys are ULONGs.
//

LONG
StorCompareUlongKey(
	IN PVOID Key1,
	IN PVOID Key2
	);

//
// Default hash-key routine when the keys are ULONGs.
//

ULONG
StorHashUlongKey(
	IN PVOID Key
	);

NTSTATUS
StorCreateDictionary(
	IN PSTOR_DICTIONARY Dictionary,
	IN ULONG EntryCount,
	IN POOL_TYPE PoolType,
	IN STOR_DICTIONARY_GET_KEY_ROUTINE GetKeyRoutine,
	IN STOR_DICTIONARY_COMPARE_KEY_ROUTINE CompareKeyRoutine, OPTIONAL
	IN STOR_DICTIONARY_HASH_KEY_ROUTINE HashKeyRoutine OPTIONAL
	);

NTSTATUS
StorInsertDictionary(
	IN PSTOR_DICTIONARY Dictionary,
	IN PSTOR_DICTIONARY_ENTRY Entry
	);
		
NTSTATUS
StorRemoveDictionary(
	IN PSTOR_DICTIONARY Dictionary,
	IN PVOID Key,
	OUT PSTOR_DICTIONARY_ENTRY* Entry OPTIONAL
	);

NTSTATUS
StorFindDictionary(
	IN PSTOR_DICTIONARY Dictionary,
	IN PVOID Key,
	OUT PSTOR_DICTIONARY_ENTRY* Entry OPTIONAL
	);

VOID
StorEnumerateDictionary(
	IN PSTOR_DICTIONARY Dict,
	IN PSTOR_DICTIONARY_ENUMERATOR Enumerator
	);

ULONG
INLINE
StorGetDictionaryCount(
	IN PSTOR_DICTIONARY Dictionary
	)
{
	return Dictionary->EntryCount;
}

ULONG
INLINE
StorGetDictionaryMaxCount(
	IN PSTOR_DICTIONARY Dictionary
	)
{
	return Dictionary->MaxEntryCount;
}

ULONG
INLINE
StorGetDictionaryFullness(
	IN PSTOR_DICTIONARY Dictionary
	)
/*++

Routine Description:

	Return the 'fullness' of the dictionary. As a general rule, when the
	dictionary reaches XXX % full, it should be expanded to 

Arguments:

	Dictionary - 

Return Value:

	This is returned as a percentage, e.g., 50 = 50% full, 100 = 100%
	full, 200 = 200% full, etc.

--*/
{
	return ((Dictionary->MaxEntryCount * 100) / Dictionary->EntryCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\lib\utils.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    Simple macro definitions and utility functions.

Author:

    Matthew D Hendel (math) 13-Feb-2001

Revision History:

--*/

#pragma once

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   (((Flags) & (Bit)) != 0)

#define min(a,b) (((a) < (b)) ? (a) : (b))
#define max(a,b) (((a) > (b)) ? (a) : (b))

#define ARRAY_COUNT(Array) (sizeof(Array)/sizeof(Array[0]))
#define IN_RANGE(a,b,c) ((a) <= (b) && (b) < (c))

#define INLINE __inline

typedef const GUID *PCGUID;

//
// NT uses a system time measured in 100 nanosecond intervals.  define
// conveninent constants for setting the timer.
//

#define MICROSECONDS        10              // 10 nanoseconds
#define MILLISECONDS        (MICROSECONDS * 1000)
#define SECONDS             (MILLISECONDS * 1000)
#define MINUTES             (SECONDS * 60)

#define RELATIVE_TIMEOUT    (-1)


//
// The standard definition of RemoveListHead is not an expression, hence
// cannot be used in loops, etc.
//

PLIST_ENTRY
INLINE
_RemoveHeadList(
    IN PLIST_ENTRY ListHead
    )
{
    return RemoveHeadList (ListHead);
}

#undef RemoveHeadList
#define RemoveHeadList _RemoveHeadList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\lib\rgstry.c ===
#include "precomp.h"

#include "utils.h"

#define PORT_TAG_MINIPORT_PARAM  ('pMlP')

#define PORT_REG_BUFFER_SIZE 512

#define DISK_SERVICE_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Disk"

HANDLE
PortpOpenParametersKey(
    IN PUNICODE_STRING RegistryPath
    );

BOOLEAN
PortpReadDriverParameterEntry(
    IN HANDLE Key,
    OUT PVOID * DriverParameters
    );

BOOLEAN
PortpReadLinkTimeoutValue(
    IN HANDLE Key,
    OUT PULONG LinkTimeout
    );

HANDLE
PortOpenDeviceKey(
    IN PUNICODE_STRING RegistryPath,
    IN ULONG DeviceNumber
    );

VOID
PortFreeDriverParameters(
    PVOID DriverParameters
    );

VOID
PortGetDriverParameters(
    IN PUNICODE_STRING RegistryPath,
    IN ULONG DeviceNumber,
    OUT PVOID * DriverParameters
    );

BOOLEAN
PortpReadMaximumLogicalUnitEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    );

BOOLEAN
PortpReadInitiatorTargetIdEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    );

BOOLEAN
PortpReadDebugEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    );

BOOLEAN
PortpReadBreakPointEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    );

BOOLEAN
PortpReadDisableSynchronousTransfersEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    );

BOOLEAN
PortpReadDisableDisconnectsEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    );

BOOLEAN
PortpReadDisableTaggedQueuingEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    );

BOOLEAN
PortpReadDisableMultipleRequestsEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    );

BOOLEAN
PortpReadMinimumUCXAddressEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    );

BOOLEAN
PortpReadMaximumUCXAddressEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    );

BOOLEAN
PortpReadMaximumSGListEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    );

BOOLEAN
PortpReadNumberOfRequestsEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    );

BOOLEAN
PortpReadResourceListEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    );

BOOLEAN
PortpReadUncachedExtAlignmentEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    );

BOOLEAN
PortpReadInquiryTimeoutEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    );

BOOLEAN
PortpReadResetHoldTimeEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    );

BOOLEAN
PortpReadCreateInitiatorLUEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    );

#if 0
VOID
PortReadRegistrySettings(
    IN HANDLE Key,
    IN PPORT_ADAPTER_REGISTRY_VALUES Context,
    IN ULONG Fields
    );

VOID
PortGetRegistrySettings(
    IN PUNICODE_STRING RegistryPath,
    IN ULONG DeviceNumber,
    IN PPORT_ADAPTER_REGISTRY_VALUES Context,
    IN ULONG Fields
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PortpOpenParametersKey)
#pragma alloc_text(PAGE, PortOpenDeviceKey)
#pragma alloc_text(PAGE, PortpReadDriverParameterEntry)
#pragma alloc_text(PAGE, PortFreeDriverParameters)
#pragma alloc_text(PAGE, PortGetDriverParameters)
#pragma alloc_text(PAGE, PortpReadLinkTimeoutValue)
#pragma alloc_text(PAGE, PortpReadMaximumLogicalUnitEntry)
#pragma alloc_text(PAGE, PortpReadInitiatorTargetIdEntry)
#pragma alloc_text(PAGE, PortpReadDebugEntry)
#pragma alloc_text(PAGE, PortpReadBreakPointEntry)
#pragma alloc_text(PAGE, PortpReadDisableSynchronousTransfersEntry)
#pragma alloc_text(PAGE, PortpReadDisableDisconnectsEntry)
#pragma alloc_text(PAGE, PortpReadDisableTaggedQueuingEntry)
#pragma alloc_text(PAGE, PortpReadDisableMultipleRequestsEntry)
#pragma alloc_text(PAGE, PortpReadMinimumUCXAddressEntry)
#pragma alloc_text(PAGE, PortpReadMaximumUCXAddressEntry)
#pragma alloc_text(PAGE, PortpReadMaximumSGListEntry)
#pragma alloc_text(PAGE, PortpReadNumberOfRequestsEntry)
#pragma alloc_text(PAGE, PortpReadResourceListEntry)
#pragma alloc_text(PAGE, PortpReadUncachedExtAlignmentEntry)
#pragma alloc_text(PAGE, PortpReadInquiryTimeoutEntry)
#pragma alloc_text(PAGE, PortpReadResetHoldTimeEntry)
#pragma alloc_text(PAGE, PortpReadCreateInitiatorLUEntry)
#pragma alloc_text(PAGE, PortReadRegistrySettings)
#pragma alloc_text(PAGE, PortGetRegistrySettings)
#pragma alloc_text(PAGE, PortCreateKeyEx)
#pragma alloc_text(PAGE, PortSetValueKey)
#pragma alloc_text(PAGE, PortGetDiskTimeoutValue)
#endif

HANDLE
PortpOpenParametersKey(
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine will open the services keys for the miniport and put handles
    to them into the configuration context structure.

Arguments:

    RegistryPath - a pointer to the service key name for this miniport

Return Value:

    status

--*/
{
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;
    HANDLE serviceKey;
    NTSTATUS status;
    HANDLE parametersKey;

    PAGED_CODE();

    //
    // Open the service node.
    //
    InitializeObjectAttributes(&objectAttributes,
                               RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey(&serviceKey, KEY_READ, &objectAttributes);

    //
    // Try to open the parameters key.  If it exists then replace the service
    // key with the new key.  This allows the device nodes to be placed
    // under DriverName\Parameters\Device or DriverName\Device.
    //
    if (NT_SUCCESS(status)) {

        ASSERT(serviceKey != NULL);

        //
        // Check for a device node.  The device node applies to every device.
        //
        RtlInitUnicodeString(&unicodeString, L"Parameters");

        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   serviceKey,
                                   (PSECURITY_DESCRIPTOR) NULL);

        //
        // Attempt to open the parameters key.
        //
        status = ZwOpenKey(&parametersKey,
                           KEY_READ,
                           &objectAttributes);

        if (NT_SUCCESS(status)) {

            //
            // There is a Parameters key.  Use that instead of the service
            // node key.  Close the service node and set the new value.
            //
            ZwClose(serviceKey);
            serviceKey = parametersKey;
        }
    }

    return serviceKey;
}

HANDLE
PortOpenDeviceKey(
    IN PUNICODE_STRING RegistryPath,
    IN ULONG DeviceNumber
    )
/*++

Routine Description:

    This routine will open the services keys for the miniport and put handles
    to them into the configuration context structure.

Arguments:

    RegistryPath - a pointer to the service key name for this miniport

    DeviceNumber - which device too search for under the service key.  -1
                   indicates that the default device key should be opened.

Return Value:

    status

--*/
{
    OBJECT_ATTRIBUTES objectAttributes;
    WCHAR buffer[64];
    UNICODE_STRING unicodeString;
    HANDLE serviceKey;
    HANDLE deviceKey;
    NTSTATUS status;

    PAGED_CODE();

    deviceKey = NULL;

    //
    // Open the service's parameters key.
    //
    serviceKey = PortpOpenParametersKey(RegistryPath);

    if (serviceKey != NULL) {

        //
        // Check for a Device Node. The device node applies to every device.
        //
        if(DeviceNumber == (ULONG) -1) {
            swprintf(buffer, L"Device");
        } else {
            swprintf(buffer, L"Device%d", DeviceNumber);
        }

        //
        // Initialize an object attributes structure in preparation for opening
        // the DeviceN key.
        //
        RtlInitUnicodeString(&unicodeString, buffer);
        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   serviceKey,
                                   (PSECURITY_DESCRIPTOR) NULL);

        //
        // It doesn't matter if this call fails or not.  If it fails, then there
        // is no default device node.  If it works then the handle will be set.
        //
        ZwOpenKey(&deviceKey, KEY_READ, &objectAttributes);

        //
        // Close the service's parameters key.
        //
        ZwClose(serviceKey);
    }

    return deviceKey;
}

BOOLEAN
PortpReadDriverParameterEntry(
    IN HANDLE Key,
    OUT PVOID * DriverParameters
    )
{
    NTSTATUS status;
    UCHAR buffer[PORT_REG_BUFFER_SIZE];
    ULONG length;
    UNICODE_STRING valueName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;
    ULONG result;

    PAGED_CODE();

    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) buffer;

    //
    // Try to find a DriverParameter value under the current key.
    //
    RtlInitUnicodeString(&valueName, L"DriverParameter");
    status = ZwQueryValueKey(Key,
                             &valueName,
                             KeyValueFullInformation,
                             buffer,
                             PORT_REG_BUFFER_SIZE,
                             &length);

    if (!NT_SUCCESS(status)) {

        return FALSE;
    }

    //
    // Check that the length is reasonable.
    //
    if ((keyValueInformation->Type == REG_DWORD) &&
        (keyValueInformation->DataLength != sizeof(ULONG))) {

        return FALSE;
    }

    //
    // Verify that the name is what we expect.
    //
    result = _wcsnicmp(keyValueInformation->Name, 
                       L"DriverParameter",
                       keyValueInformation->NameLength / 2);

    if (result != 0) {

        return FALSE;

    }

    //
    // If the data length is invalid, abort.
    //
    if (keyValueInformation->DataLength == 0) {

        return FALSE;
    }

    //
    // If we already have a non-NULL driver parameter entry, delete it
    // and replace it with the one we've found.
    //
    if (*DriverParameters != NULL) {
        ExFreePool(*DriverParameters);
    }

    //
    // Allocate non-paged pool to hold the data.
    //
    *DriverParameters =
        ExAllocatePoolWithTag(
                              NonPagedPool,
                              keyValueInformation->DataLength,
                              PORT_TAG_MINIPORT_PARAM);

    //
    // If we failed to allocate the necessary pool, abort.
    //
    if (*DriverParameters == NULL) {

        return FALSE;
    }

    if (keyValueInformation->Type != REG_SZ) {

        //
        // The data is not a unicode string, so just copy the bytes into the
        // buffer we allocated.
        //

        RtlCopyMemory(*DriverParameters,
                      (PCCHAR) keyValueInformation + 
                      keyValueInformation->DataOffset,
                      keyValueInformation->DataLength);

    } else {

        //
        // This is a unicode string. Convert it to a ANSI string.
        //

        unicodeString.Buffer = 
            (PWSTR) ((PCCHAR) keyValueInformation +
                     keyValueInformation->DataOffset);

        unicodeString.Length = 
            (USHORT) keyValueInformation->DataLength;

        unicodeString.MaximumLength = 
            (USHORT) keyValueInformation->DataLength;

        ansiString.Buffer = (PCHAR) *DriverParameters;
        ansiString.Length = 0;
        ansiString.MaximumLength = 
            (USHORT) keyValueInformation->DataLength;

        status = RtlUnicodeStringToAnsiString(&ansiString,
                                              &unicodeString,
                                              FALSE);
        if (!NT_SUCCESS(status)) {

            //
            // We could not convert the unicode string to ansi.  Free the
            // buffer we allocated and abort.
            //

            ExFreePool(*DriverParameters);
            *DriverParameters = NULL;
        }
    }

    return TRUE;
}

BOOLEAN
PortpReadLinkTimeoutValue(
    IN HANDLE Key,
    OUT PULONG LinkTimeout
    )
{
    NTSTATUS status;
    UCHAR buffer[PORT_REG_BUFFER_SIZE];
    ULONG length;
    UNICODE_STRING valueName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING unicodeString;
    ULONG result;

    PAGED_CODE();

    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) buffer;

    //
    // Try to find a DriverParameter value under the current key.
    //
    RtlInitUnicodeString(&valueName, L"LinkTimeout");
    status = ZwQueryValueKey(Key,
                             &valueName,
                             KeyValueFullInformation,
                             buffer,
                             PORT_REG_BUFFER_SIZE,
                             &length);

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    //
    // Check that the length is reasonable.
    //
    if ((keyValueInformation->Type == REG_DWORD) &&
        (keyValueInformation->DataLength != sizeof(ULONG))) {
        return FALSE;
    }

    //
    // Verify that the name is what we expect.
    //
    result = _wcsnicmp(keyValueInformation->Name, 
                       L"LinkTimeout",
                       keyValueInformation->NameLength / 2);

    if (result != 0) {
        return FALSE;
    }

    //
    // If the data length is invalid, abort.
    //
    if (keyValueInformation->DataLength == 0) {
        return FALSE;
    }

    //
    // Data type must be REG_DWORD.
    //
    if (keyValueInformation->Type != REG_DWORD) {
        return FALSE;
    }

    //
    // Extract the value.
    // 
    *LinkTimeout = *((PULONG)(buffer + keyValueInformation->DataOffset));

    //
    // Check that the value is sane.
    //
    if (*LinkTimeout > 600) {
        *LinkTimeout = 600;
    }
    
    return TRUE;
}

VOID
PortFreeDriverParameters(
    PVOID DriverParameters
    )
{
    PAGED_CODE();

    ExFreePool(DriverParameters);
}

VOID
PortGetDriverParameters(
    IN PUNICODE_STRING RegistryPath,
    IN ULONG DeviceNumber,
    OUT PVOID * DriverParameters
    )
{
    HANDLE key;

    PAGED_CODE();
    
    key = PortOpenDeviceKey(RegistryPath, -1);
    if (key != NULL) {
        PortpReadDriverParameterEntry(key, DriverParameters);
        ZwClose(key);
    }

    key = PortOpenDeviceKey(RegistryPath, DeviceNumber);
    if (key != NULL) {
        PortpReadDriverParameterEntry(key, DriverParameters);
        ZwClose(key);
    }
}

VOID
PortGetLinkTimeoutValue(
    IN PUNICODE_STRING RegistryPath,
    IN ULONG DeviceNumber,
    OUT PULONG LinkTimeoutValue
    )
{
    HANDLE key;

    PAGED_CODE();
    
    key = PortOpenDeviceKey(RegistryPath, -1);
    if (key != NULL) {
        PortpReadLinkTimeoutValue(key, LinkTimeoutValue);
        ZwClose(key);
    }

    key = PortOpenDeviceKey(RegistryPath, DeviceNumber);
    if (key != NULL) {
        PortpReadLinkTimeoutValue(key, LinkTimeoutValue);
        ZwClose(key);
    }
}

BOOLEAN
PortpReadMaximumLogicalUnitEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    )
{
    NTSTATUS status;
    ULONG length;
    UNICODE_STRING valueName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    PAGED_CODE();                                   

    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

    RtlInitUnicodeString(&valueName, L"MaximumLogicalUnit");
    
    status = ZwQueryValueKey(Key,
                             &valueName,
                             KeyValueFullInformation,
                             Buffer,
                             PORT_REG_BUFFER_SIZE,
                             &length);

    if (!NT_SUCCESS(status)) {

        return FALSE;

    }
    
    if (keyValueInformation->Type != REG_DWORD) {

        return FALSE;

    }

    if (keyValueInformation->DataLength != sizeof(ULONG)) {
        
        return FALSE;

    }

    Context->MaxLuCount = *((PUCHAR)
                            (Buffer + keyValueInformation->DataOffset)); 

    //
    // If the value is out of bounds, then reset it.
    //

    if (Context->MaxLuCount > PORT_MAXIMUM_LOGICAL_UNITS) {

        Context->MaxLuCount = PORT_MAXIMUM_LOGICAL_UNITS;

    }

    return TRUE;

}


BOOLEAN
PortpReadInitiatorTargetIdEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    )
{
    NTSTATUS status;
    ULONG length;
    UNICODE_STRING valueName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    PAGED_CODE();               

    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

    RtlInitUnicodeString(&valueName, L"InitiatorTargetId");
    
    status = ZwQueryValueKey(Key,
                             &valueName,
                             KeyValueFullInformation,
                             Buffer,
                             PORT_REG_BUFFER_SIZE,
                             &length);
    
    if (!NT_SUCCESS(status)) {

        return FALSE;

    }
    
    if (keyValueInformation->Type != REG_DWORD) {

        return FALSE;

    }

    if (keyValueInformation->DataLength != sizeof(ULONG)) {
        
        return FALSE;

    }

    
    Context->PortConfig.InitiatorBusId[0] = *((PUCHAR)(Buffer + keyValueInformation->DataOffset));

    //
    // IF the value is out of bounds, then reset it.
    //

    if (Context->PortConfig.InitiatorBusId[0] > 
        Context->PortConfig.MaximumNumberOfTargets - 1) {
        Context->PortConfig.InitiatorBusId[0] = (UCHAR)PORT_UNINITIALIZED_VALUE; 
    }

    return TRUE;

}


BOOLEAN
PortpReadDebugEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    )
{
   NTSTATUS status;
   ULONG length;
   UNICODE_STRING valueName;
   PKEY_VALUE_FULL_INFORMATION keyValueInformation;

   PAGED_CODE();  

   keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

   RtlInitUnicodeString(&valueName, L"ScsiDebug");

   status = ZwQueryValueKey(Key,
                            &valueName,
                            KeyValueFullInformation,
                            Buffer,
                            PORT_REG_BUFFER_SIZE,
                            &length);

   if (!NT_SUCCESS(status)) {

       return FALSE;

   }

   if (keyValueInformation->Type != REG_DWORD) {

        return FALSE;

    }

    if (keyValueInformation->DataLength != sizeof(ULONG)) {
        
        return FALSE;

    }

   Context->EnableDebugging = *((PULONG)(Buffer + keyValueInformation->DataOffset));

   return TRUE;

}


BOOLEAN
PortpReadBreakPointEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    )
{
    NTSTATUS status;
    ULONG length;
    ULONG value;
    UNICODE_STRING valueName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    PAGED_CODE();  

    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

    RtlInitUnicodeString(&valueName, L"BreakPointOnEntry");
    
    status = ZwQueryValueKey(Key,
                             &valueName,
                             KeyValueFullInformation,
                             Buffer,
                             PORT_REG_BUFFER_SIZE,
                             &length);
    
    if (!NT_SUCCESS(status)) {

        return FALSE;

    }
    
    if (keyValueInformation->Type == REG_DWORD && 
        keyValueInformation->DataLength != sizeof(ULONG)) {
        
        return FALSE;

    }

    value = *((PULONG)(Buffer + keyValueInformation->DataOffset));

    if (value > 0) {

        DbgBreakPoint();

    }
    
    return TRUE;

}


BOOLEAN
PortpReadDisableSynchronousTransfersEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    )
{
   NTSTATUS status;
   ULONG length;
   ULONG value;
   UNICODE_STRING valueName;
   PKEY_VALUE_FULL_INFORMATION keyValueInformation;

   PAGED_CODE();  

   keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

   RtlInitUnicodeString(&valueName, L"DisableSynchronousTransfers");

   status = ZwQueryValueKey(Key,
                            &valueName,
                            KeyValueFullInformation,
                            Buffer,
                            PORT_REG_BUFFER_SIZE,
                            &length);

       
   if (!NT_SUCCESS(status)) {

        return FALSE;

   }
    
   if (keyValueInformation->Type == REG_DWORD && 
       keyValueInformation->DataLength != sizeof(ULONG)) {
        
       return FALSE;

   }
   
   value = *((PULONG)(Buffer + keyValueInformation->DataOffset));

   if (value > 0) {

       Context->SrbFlags |= SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

   }

   return TRUE;
   
}


BOOLEAN
PortpReadDisableDisconnectsEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    )
{
   NTSTATUS status;
   ULONG length;
   ULONG value;
   UNICODE_STRING valueName;
   PKEY_VALUE_FULL_INFORMATION keyValueInformation;

   PAGED_CODE();

   keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

   RtlInitUnicodeString(&valueName, L"DisableDisconnects");

   status = ZwQueryValueKey(Key,
                            &valueName,
                            KeyValueFullInformation,
                            Buffer,
                            PORT_REG_BUFFER_SIZE,
                            &length);

   if (!NT_SUCCESS(status)) {

        return FALSE;

   }
    
   if (keyValueInformation->Type == REG_DWORD && 
       keyValueInformation->DataLength != sizeof(ULONG)) {
        
       return FALSE;

   }

   value = *((PULONG)(Buffer + keyValueInformation->DataOffset));

   if (value > 0) {

       Context->SrbFlags |= SRB_FLAGS_DISABLE_DISCONNECT;

   }

   return TRUE;

}


BOOLEAN
PortpReadDisableTaggedQueuingEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    )
{
   NTSTATUS status;
   ULONG length;
   ULONG value;
   UNICODE_STRING valueName;
   PKEY_VALUE_FULL_INFORMATION keyValueInformation;

   PAGED_CODE();  

   keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

   RtlInitUnicodeString(&valueName, L"DisableTaggedQueuing");

   status = ZwQueryValueKey(Key,
                            &valueName,
                            KeyValueFullInformation,
                            Buffer,
                            PORT_REG_BUFFER_SIZE,
                            &length);

   if (!NT_SUCCESS(status)) {

        return FALSE;

   }
    
   if (keyValueInformation->Type == REG_DWORD && 
       keyValueInformation->DataLength != sizeof(ULONG)) {
        
       return FALSE;

   }

   value = *((PULONG)(Buffer + keyValueInformation->DataOffset));

   if (value > 0) {

       Context->DisableTaggedQueueing = TRUE;

   }

   return TRUE;

}


BOOLEAN
PortpReadDisableMultipleRequestsEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    )
{
   NTSTATUS status;
   ULONG length;
   ULONG value;
   UNICODE_STRING valueName;
   PKEY_VALUE_FULL_INFORMATION keyValueInformation;

   PAGED_CODE();                                   

   keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

   RtlInitUnicodeString(&valueName, L"DisableMultipleRequests");

   status = ZwQueryValueKey(Key,
                            &valueName,
                            KeyValueFullInformation,
                            Buffer,
                            PORT_REG_BUFFER_SIZE,
                            &length);

   if (!NT_SUCCESS(status)) {

        return FALSE;

   }
    
   if (keyValueInformation->Type == REG_DWORD && 
       keyValueInformation->DataLength != sizeof(ULONG)) {
        
       return FALSE;

   }

   value = *((PULONG)(Buffer + keyValueInformation->DataOffset));

   if (value > 0) {

       Context->DisableMultipleLu = TRUE;

   }

   return TRUE;

}


BOOLEAN
PortpReadMinimumUCXAddressEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    )
{
   NTSTATUS status;
   ULONG length;
   UNICODE_STRING valueName;
   PKEY_VALUE_FULL_INFORMATION keyValueInformation;

   PAGED_CODE();                                   

   keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

   RtlInitUnicodeString(&valueName, L"MinimumUCXAddress");

   status = ZwQueryValueKey(Key,
                            &valueName,
                            KeyValueFullInformation,
                            Buffer,
                            PORT_REG_BUFFER_SIZE,
                            &length);

   if (!NT_SUCCESS(status)) {

        return FALSE;

   }
    
   /*
   if (keyValueInformation->Type == REG_DWORD && 
       keyValueInformation->DataLength != sizeof(ULONG)) {
        
       return FALSE;

   }
   */

   if (keyValueInformation->Type != REG_BINARY) {

       return FALSE;

   }

   if (keyValueInformation->DataLength != sizeof(ULONGLONG)) {

       return FALSE;

   }

   Context->MinimumCommonBufferBase.QuadPart = 
       *((PULONGLONG)(Buffer + keyValueInformation->DataOffset)); 

   //
   // Ensure that the minimum and maximum parameters are valid.
   // If there's not at least one valid page between them then reset 
   // minimum to zero.
   //

   if (Context->MinimumCommonBufferBase.QuadPart >=
       (Context->MaximumCommonBufferBase.QuadPart - PAGE_SIZE)) {

       Context->MinimumCommonBufferBase.QuadPart = 0;
       
   }

   return TRUE;
   
}


BOOLEAN
PortpReadMaximumUCXAddressEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    )
{
   NTSTATUS status;
   ULONG length;
   UNICODE_STRING valueName;
   PKEY_VALUE_FULL_INFORMATION keyValueInformation;

   PAGED_CODE();                                   

   keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

   RtlInitUnicodeString(&valueName, L"MaximumUCXAddress");

   status = ZwQueryValueKey(Key,
                            &valueName,
                            KeyValueFullInformation,
                            Buffer,
                            PORT_REG_BUFFER_SIZE,
                            &length);

   if (!NT_SUCCESS(status)) {

        return FALSE;

   }
    
   /*
   if (keyValueInformation->Type == REG_DWORD && 
       keyValueInformation->DataLength != sizeof(ULONG)) {
        
       return FALSE;

   }
   */

   if (keyValueInformation->Type != REG_BINARY) {

       return FALSE;

   }

   if (keyValueInformation->DataLength != sizeof(ULONGLONG)) {

       return FALSE;

   }

   Context->MaximumCommonBufferBase.QuadPart = 
       *((PULONGLONG)(Buffer + keyValueInformation->DataOffset)); 

   if (Context->MaximumCommonBufferBase.QuadPart == 0) {

       Context->MaximumCommonBufferBase.LowPart = 0xffffffff;
       Context->MaximumCommonBufferBase.HighPart = 0x0;

   }

   return TRUE;
   
}


BOOLEAN
PortpReadMaximumSGListEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    )
{
   NTSTATUS status;
   ULONG length;
   UNICODE_STRING valueName;
   ULONG maxBreaks, minBreaks;
   PKEY_VALUE_FULL_INFORMATION keyValueInformation;

   PAGED_CODE();                                   

   keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

   RtlInitUnicodeString(&valueName, L"MaximumSGList");

   status = ZwQueryValueKey(Key,
                            &valueName,
                            KeyValueFullInformation,
                            Buffer,
                            PORT_REG_BUFFER_SIZE,
                            &length);

   if (!NT_SUCCESS(status)) {

        return FALSE;

   }
    
   if (keyValueInformation->Type != REG_DWORD) {

        return FALSE;

    }

    if (keyValueInformation->DataLength != sizeof(ULONG)) {
        
        return FALSE;

    }

   Context->PortConfig.NumberOfPhysicalBreaks = 
       *((PUCHAR)(Buffer + keyValueInformation->DataOffset));

   //
   // If the value is out of bounds, then reset it.
   //

   if ((Context->PortConfig.MapBuffers) && (!Context->PortConfig.Master)) { 
       
       maxBreaks = PORT_UNINITIALIZED_VALUE;
       minBreaks = PORT_MINIMUM_PHYSICAL_BREAKS;
   
   } else {
       
       maxBreaks = PORT_MAXIMUM_PHYSICAL_BREAKS;
       minBreaks = PORT_MINIMUM_PHYSICAL_BREAKS;
   
   }

   if (Context->PortConfig.NumberOfPhysicalBreaks > maxBreaks) {
       
       Context->PortConfig.NumberOfPhysicalBreaks = maxBreaks;
   
   } else if (Context->PortConfig.NumberOfPhysicalBreaks < minBreaks) {
       
       Context->PortConfig.NumberOfPhysicalBreaks = minBreaks;
   
   }

   return TRUE;

}


BOOLEAN
PortpReadNumberOfRequestsEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    )
{
   NTSTATUS status;
   ULONG length;
   UNICODE_STRING valueName;
   ULONG value;
   PKEY_VALUE_FULL_INFORMATION keyValueInformation;

   PAGED_CODE();                                   

   keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

   RtlInitUnicodeString(&valueName, L"NumberOfRequests");

   status = ZwQueryValueKey(Key,
                            &valueName,
                            KeyValueFullInformation,
                            Buffer,
                            PORT_REG_BUFFER_SIZE,
                            &length);

   if (!NT_SUCCESS(status)) {

        return FALSE;

   }
    
   if (keyValueInformation->Type != REG_DWORD) {

        return FALSE;

    }

    if (keyValueInformation->DataLength != sizeof(ULONG)) {
        
        return FALSE;

    }

   value = *((PULONG)(Buffer + keyValueInformation->DataOffset));

   //
   // If the value is out of bounds, then reset it.
   //

   if (value < MINIMUM_EXTENSIONS) {
       
       Context->NumberOfRequests = MINIMUM_EXTENSIONS;
   
   } else if (value > MAXIMUM_EXTENSIONS) {
       
       Context->NumberOfRequests = MAXIMUM_EXTENSIONS;
   
   } else {
       
       Context->NumberOfRequests = value;
   
   }

   return TRUE;

}


BOOLEAN
PortpReadResourceListEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    )
{
   NTSTATUS status;
   ULONG length;
   UNICODE_STRING valueName;
   ULONG value;
   ULONG count;
   ULONG rangeCount;
   PCM_SCSI_DEVICE_DATA scsiData;
   PCM_FULL_RESOURCE_DESCRIPTOR resource;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;
   PKEY_VALUE_FULL_INFORMATION keyValueInformation;

   PAGED_CODE();    

   rangeCount = 0;

   keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

   RtlInitUnicodeString(&valueName, L"ResourceList");

   status = ZwQueryValueKey(Key,
                            &valueName,
                            KeyValueFullInformation,
                            Buffer,
                            PORT_REG_BUFFER_SIZE,
                            &length);

   if (!NT_SUCCESS(status)) {

       RtlInitUnicodeString(&valueName, L"Configuration Data");

       status = ZwQueryValueKey(Key,
                                &valueName,
                                KeyValueFullInformation,
                                Buffer,
                                PORT_REG_BUFFER_SIZE,
                                &length);

       if (!NT_SUCCESS(status)) {

           return FALSE;

       }
        
   }
    
   if (keyValueInformation->Type != REG_FULL_RESOURCE_DESCRIPTOR || 
       keyValueInformation->DataLength < sizeof(CM_FULL_RESOURCE_DESCRIPTOR)) {
        
       return FALSE;

   }

   resource = (PCM_FULL_RESOURCE_DESCRIPTOR)
              (Buffer + keyValueInformation->DataOffset);

   //
   // Set the bus number equal to the bus number for the
   // resouce.  Note the context value is also set to the
   // new bus number.
   //

   Context->BusNumber = resource->BusNumber;
   Context->PortConfig.SystemIoBusNumber = resource->BusNumber;

   //
   // Walk the resource list and update the configuration.
   //

   for (count = 0; count < resource->PartialResourceList.Count; count++) {
       
       descriptor = &resource->PartialResourceList.PartialDescriptors[count];

       //
       // Verify size is ok.
       //

       if ((ULONG)((PCHAR) (descriptor + 1) - (PCHAR) resource) >
           keyValueInformation->DataLength) {

           //
           //Resource data too small.
           //

           return FALSE;
       }

       //
       // Switch on descriptor type;
       //

       switch (descriptor->Type) {
       case CmResourceTypePort:

           if (rangeCount >= Context->PortConfig.NumberOfAccessRanges) {

               //
               //Too many access ranges.
               //

               continue;
                        
           }

           Context->AccessRanges[rangeCount].RangeStart =
               descriptor->u.Port.Start;
           Context->AccessRanges[rangeCount].RangeLength =
               descriptor->u.Port.Length;
           Context->AccessRanges[rangeCount].RangeInMemory = FALSE;
           
           rangeCount++;

           break;

       case CmResourceTypeMemory:

           if (rangeCount >= Context->PortConfig.NumberOfAccessRanges) {
                        
               //
               //Too many access ranges.
               //
               
               continue;
           }

           Context->AccessRanges[rangeCount].RangeStart =
               descriptor->u.Memory.Start;
           Context->AccessRanges[rangeCount].RangeLength =
               descriptor->u.Memory.Length;
           Context->AccessRanges[rangeCount].RangeInMemory = TRUE;
                    
           rangeCount++;

           break;

       case CmResourceTypeInterrupt:

           Context->PortConfig.BusInterruptVector =
               descriptor->u.Interrupt.Vector;
           Context->PortConfig.BusInterruptLevel =
               descriptor->u.Interrupt.Level;
                    
           break;

       case CmResourceTypeDma:
           Context->PortConfig.DmaChannel = descriptor->u.Dma.Channel;
           Context->PortConfig.DmaPort = descriptor->u.Dma.Port;
                    
           break;

       case CmResourceTypeDeviceSpecific:

           if (descriptor->u.DeviceSpecificData.DataSize < sizeof(CM_SCSI_DEVICE_DATA) ||
               (PCHAR) (descriptor + 1) - 
               (PCHAR) resource + descriptor->u.DeviceSpecificData.DataSize >
               keyValueInformation->DataLength) {

               //
               //Device specific resource data too small.
               //

               break;

           }

           scsiData = (PCM_SCSI_DEVICE_DATA) (descriptor+1);
           Context->PortConfig.InitiatorBusId[0] = scsiData->HostIdentifier;
           break;

           
       }
   }

   return TRUE;

}


BOOLEAN
PortpReadUncachedExtAlignmentEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    )
{
   NTSTATUS status;
   ULONG length;
   ULONG value;
   UNICODE_STRING valueName;
   PKEY_VALUE_FULL_INFORMATION keyValueInformation;

   PAGED_CODE();  

   keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

   RtlInitUnicodeString(&valueName, L"UncachedExtAlignment");

   status = ZwQueryValueKey(Key,
                            &valueName,
                            KeyValueFullInformation,
                            Buffer,
                            PORT_REG_BUFFER_SIZE,
                            &length);

   if (!NT_SUCCESS(status)) {

        return FALSE;

   }
    
   if (keyValueInformation->Type != REG_DWORD) {

        return FALSE;

    }

    if (keyValueInformation->DataLength != sizeof(ULONG)) {
        
        return FALSE;

    }

   value = *((PULONG)(Buffer + keyValueInformation->DataOffset));

   //
   // Specified alignment must be 3 to 16, which equates to 8-byte and
   // 64k-byte alignment, respectively.
   //

   if (value > MAX_UNCACHED_EXT_ALIGNMENT) {
       
       value = MAX_UNCACHED_EXT_ALIGNMENT;
   
   } else if (value < MIN_UNCACHED_EXT_ALIGNMENT) {
                
       value = MIN_UNCACHED_EXT_ALIGNMENT;
            
   }

   Context->UncachedExtAlignment = 1 << value;

   return TRUE;

}


BOOLEAN
PortpReadInquiryTimeoutEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    )
{
   NTSTATUS status;
   ULONG length;
   ULONG value;

   UNICODE_STRING valueName;
   PKEY_VALUE_FULL_INFORMATION keyValueInformation;

   PAGED_CODE();                                   

   keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

   RtlInitUnicodeString(&valueName, L"InquiryTimeout");

   status = ZwQueryValueKey(Key,
                            &valueName,
                            KeyValueFullInformation,
                            Buffer,
                            PORT_REG_BUFFER_SIZE,
                            &length);

   if (!NT_SUCCESS(status)) {

        return FALSE;

   }
    
   if (keyValueInformation->Type != REG_DWORD) {

        return FALSE;

    }

    if (keyValueInformation->DataLength != sizeof(ULONG)) {
        
        return FALSE;

    }

   value = *((PULONG)(Buffer + keyValueInformation->DataOffset));

   Context->InquiryTimeout = (value <= MAX_TIMEOUT_VALUE) ? value : MAX_TIMEOUT_VALUE;

   return TRUE;

}


BOOLEAN
PortpReadResetHoldTimeEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    )
{
   NTSTATUS status;
   ULONG length;
   ULONG value;
   UNICODE_STRING valueName;
   PKEY_VALUE_FULL_INFORMATION keyValueInformation;

   PAGED_CODE(); 

   keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

   RtlInitUnicodeString(&valueName, L"ResetHoldTime");

   status = ZwQueryValueKey(Key,
                            &valueName,
                            KeyValueFullInformation,
                            Buffer,
                            PORT_REG_BUFFER_SIZE,
                            &length);

   if (!NT_SUCCESS(status)) {

        return FALSE;

   }
    
   if (keyValueInformation->Type != REG_DWORD) {

        return FALSE;

    }

    if (keyValueInformation->DataLength != sizeof(ULONG)) {
        
        return FALSE;

    }

   value = *((PULONG)(Buffer + keyValueInformation->DataOffset));

   Context->ResetHoldTime = (value <= MAX_RESET_HOLD_TIME) ? value : MAX_RESET_HOLD_TIME;

   return TRUE;

}


BOOLEAN
PortpReadCreateInitiatorLUEntry(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    OUT PPORT_ADAPTER_REGISTRY_VALUES Context
    )
{
   NTSTATUS status;
   ULONG length;
   ULONG value;

   UNICODE_STRING valueName;
   PKEY_VALUE_FULL_INFORMATION keyValueInformation;

   PAGED_CODE(); 

   keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

   RtlInitUnicodeString(&valueName, L"CreateInitiatorLU");

   status = ZwQueryValueKey(Key,
                            &valueName,
                            KeyValueFullInformation,
                            Buffer,
                            PORT_REG_BUFFER_SIZE,
                            &length);

   if (!NT_SUCCESS(status)) {

        return FALSE;

   }
    
   if (keyValueInformation->Type != REG_DWORD) {

        return FALSE;

    }

    if (keyValueInformation->DataLength != sizeof(ULONG)) {
        
        return FALSE;

    }

   value = *((PULONG)(Buffer + keyValueInformation->DataOffset));

   Context->CreateInitiatorLU = (value == 0) ? FALSE : TRUE;

   return TRUE;

}


VOID
PortReadRegistrySettings(
    IN HANDLE Key,
    IN PPORT_ADAPTER_REGISTRY_VALUES Context,
    IN ULONG Fields
    )
/*++

Routine Description:

    This routine parses a device key node and updates the configuration 
    information.
    
Arguments:

    Key - an open key to the device node.
            
    Context - a pointer to the configuration context structure.
    
    Fields - a bit-field indicating which registry parameters to fetch.
    
Return Value:

    None
    
--*/

{
    UCHAR buffer[PORT_REG_BUFFER_SIZE];
        
    PAGED_CODE();

    if (Fields & MAXIMUM_LOGICAL_UNIT) {

        PortpReadMaximumLogicalUnitEntry(Key, buffer, Context);

    }

    if (Fields & INITIATOR_TARGET_ID) {

        PortpReadInitiatorTargetIdEntry(Key, buffer, Context);

    }

    if (Fields & SCSI_DEBUG) {

        PortpReadDebugEntry(Key, buffer, Context);

    }

    if (Fields & BREAK_POINT_ON_ENTRY) {

        PortpReadBreakPointEntry(Key, buffer, Context);

    }

    if (Fields & DISABLE_SYNCHRONOUS_TRANSFERS) {

        PortpReadDisableSynchronousTransfersEntry(Key, buffer, Context);

    }

    if (Fields & DISABLE_DISCONNECTS) {

        PortpReadDisableDisconnectsEntry(Key, buffer, Context);

    }

    if (Fields & DISABLE_TAGGED_QUEUING) {

        PortpReadDisableTaggedQueuingEntry(Key, buffer, Context);

    }

    if (Fields & DISABLE_MULTIPLE_REQUESTS) {

        PortpReadDisableMultipleRequestsEntry(Key, buffer, Context);

    }

    if (Fields & MAXIMUM_UCX_ADDRESS) {

        PortpReadMaximumUCXAddressEntry(Key, buffer, Context);

    }

    if (Fields & MINIMUM_UCX_ADDRESS) {

        PortpReadMinimumUCXAddressEntry(Key, buffer, Context);

    }

    if (Fields & DRIVER_PARAMETERS) {

        PortpReadDriverParameterEntry(Key, &(Context->Parameter));

    }

    if (Fields & MAXIMUM_SG_LIST) {

        PortpReadMaximumSGListEntry(Key, buffer, Context);

    }

    if (Fields & NUMBER_OF_REQUESTS) {

        PortpReadNumberOfRequestsEntry(Key, buffer, Context);

    }

    if (Fields & RESOURCE_LIST) {

        PortpReadResourceListEntry(Key, buffer, Context);

    }

    if (Fields & CONFIGURATION_DATA) {

        PortpReadResourceListEntry(Key, buffer, Context);

    }

    if (Fields & UNCACHED_EXT_ALIGNMENT) {

        PortpReadUncachedExtAlignmentEntry(Key, buffer, Context);

    }

    if (Fields & INQUIRY_TIMEOUT) {

        PortpReadInquiryTimeoutEntry(Key, buffer, Context);

    }

    if (Fields & RESET_HOLD_TIME) {

        PortpReadResetHoldTimeEntry(Key, buffer, Context);

    }

    if (Fields & CREATE_INITIATOR_LU) {

        PortpReadCreateInitiatorLUEntry(Key, buffer, Context);

    }

}


VOID
PortGetRegistrySettings(
    IN PUNICODE_STRING RegistryPath,
    IN ULONG DeviceNumber,
    IN PPORT_ADAPTER_REGISTRY_VALUES Context,
    IN ULONG Fields
    )
{
    HANDLE key;
    PUNICODE_STRING value;

    PAGED_CODE();

    //DbgPrint("\nRegistryPath: %ws\n", RegistryPath->Buffer);

    key = PortOpenDeviceKey(RegistryPath, -1);
    if (key != NULL) {

        PortReadRegistrySettings(key, Context, Fields);
        ZwClose(key);

    }

        
    key = PortOpenDeviceKey(RegistryPath, DeviceNumber);
    if (key != NULL) {

        PortReadRegistrySettings(key, Context, Fields);
        ZwClose(key);

    }

}


NTSTATUS
PortCreateKeyEx(
    IN HANDLE Key,
    IN ULONG CreateOptions,
    OUT PHANDLE NewKeyBuffer, OPTIONAL
    IN PCWSTR Format,
    ...
    )
/*++

Routine Description:

    Create a key using a printf style string.

Arguments:

    Key - Supplies the root key under which this key will be created. The
        key is always created with a DesiredAccess of KEY_ALL_ACCESS.

    CreateOptions - Supplies the CreateOptions parameter to ZwCreateKey.

    NewKeyBuffer - Optional buffer to return the created key.

    Format - Format specifier for the key name.

    ... - Variable arguments necessary for the specific format.

Return Value:

    NTSTATUS code - STATUS_OBJECT_NAME_EXISTS if the key already existed
        before opening.

--*/
{
    NTSTATUS Status;
    HANDLE NewKey;
    ULONG Disposition;
    UNICODE_STRING String;
    WCHAR Buffer[64];
    va_list arglist;
    OBJECT_ATTRIBUTES ObjectAttributes;
    

    PAGED_CODE();

    va_start (arglist, Format);

    _vsnwprintf (Buffer, ARRAY_COUNT (Buffer) - 1, Format, arglist);

    //
    // If we overflow the buffer, there will not be a terminating NULL.
    // Fix this problem.
    //
    
    Buffer [ARRAY_COUNT (Buffer) - 1] = UNICODE_NULL;

    RtlInitUnicodeString (&String, Buffer);
    InitializeObjectAttributes (&ObjectAttributes,
                                &String,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                Key,
                                NULL);

    Status = ZwCreateKey (&NewKey,
                          KEY_ALL_ACCESS,
                          &ObjectAttributes,
                          0,
                          NULL,
                          CreateOptions,
                          &Disposition);


    //
    // If the key already existed, return STATUS_OBJECT_NAME_EXISTS.
    //
    
    if (NT_SUCCESS (Status) && Disposition == REG_OPENED_EXISTING_KEY) {
        Status = STATUS_OBJECT_NAME_EXISTS;
    }

    //
    // Pass back the new key value if desired, otherwise close it.
    //
    
    if (NT_SUCCESS (Status)) {
        if (NewKeyBuffer) {
            *NewKeyBuffer = NewKey;
        } else {
            ZwClose (NewKey);
        }
    }

    va_end (arglist);

    return Status;
}


NTSTATUS
PortSetValueKey(
    IN HANDLE KeyHandle,
    IN PCWSTR ValueName,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    )
/*++

Routine Description:

    Simple wrapper around ZwSetValueKey that includes support for NULL-
    terminated ValueName parameter and ANSI string type.

Arguments:

    KeyHandle - Supplies the key to set the value for.

    ValueName - Supplies a NULL terminated unicode string representing the
        value. This may be NULL to pass in NULL to ZwSetValueKey.

    Type - Specifies the type of data to be written for ValueName. See
        ZwSetValueKey for more information.

        In addition to the value types specified in the DDK for ZwSetValueKey,
        Type may also be PORT_REG_ANSI_STRING if the data is an ANSI string.
        If the type is ANSI string, the data will be converted to a unicode
        string before being written to the registry. The ansi string does
        not need to be NULL terminated. Instead, the size of the ansi string
        must be specified in the DataSize field below.

    Data - Supplies the data to be written for the key specified in ValueName.

    DataSize - Supplies the size of the data to be written. If the data type
        is PORT_REG_ANSI_STRING, DataSize need not include the terminating
        NULL character for the ansi string (but it may). The converted
        Unicode string will be NULL terminated whether or not the ANSI
        string was NULL terminated.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING UncValueNameBuffer;
    UNICODE_STRING UncDataString;
    PUNICODE_STRING UncValueName;

    PAGED_CODE();

    //
    // If ValueName == NULL, need to pass NULL down to ZwSetValueKey.
    //
    
    if (ValueName) {
        RtlInitUnicodeString (&UncValueNameBuffer, ValueName);
        UncValueName = &UncValueNameBuffer;
    } else {
        UncValueName = NULL;
    }

    //
    // If this is our special, extended port type, then convert the ANSI
    // string to unicode.
    //
    
    if (Type == PORT_REG_ANSI_STRING) {

        //
        // We use the DataSize as the length.
        //

        ASSERT (DataSize <= MAXUSHORT);
        AnsiString.Length = (USHORT)DataSize;
        AnsiString.MaximumLength = (USHORT)DataSize;
        AnsiString.Buffer = Data;

        //
        // NB: RtlAnsiStringToUnicodeString always returns a NULL terminated
        // Unicode string, whether or not the ANSI version of the string
        // is NULL terminated.
        //
        
        Status = RtlAnsiStringToUnicodeString (&UncDataString,
                                               &AnsiString,
                                               TRUE);

        if (!NT_SUCCESS (Status)) {
            return Status;
        }

        Data = UncDataString.Buffer;
        DataSize = UncDataString.Length + sizeof (WCHAR);
        Type = REG_SZ;
    }

    Status = ZwSetValueKey (KeyHandle,
                            UncValueName,
                            0,
                            Type,
                            Data,
                            DataSize);

    if (Type == PORT_REG_ANSI_STRING) {
        RtlFreeUnicodeString (&UncDataString);
    }

    return Status;
}

VOID
PortGetDiskTimeoutValue(
    OUT PULONG DiskTimeout
    )
/*++
Routine Description:

    This routine will open the disk services key, and read the TimeOutValue 
    field, which should be used as the timeoutvalue for all srb's(like 
    inquiry, report-luns) created by the Port driver.

Arguments:

    DiskTimeout - Will be unchanged if we could not read the registry, or the
    timeout value(in the registry) was 0. Else the registry value is returned. 
--*/
{
    NTSTATUS status;
    UCHAR buffer[PORT_REG_BUFFER_SIZE];
    ULONG length;
    UNICODE_STRING valueName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;
    ULONG result;
    IN HANDLE Key;
    ULONG TimeoutValue;

    PAGED_CODE();

    RtlInitUnicodeString(&unicodeString, DISK_SERVICE_KEY);
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    status = ZwOpenKey(&Key,
                       KEY_READ,
                       &objectAttributes);

    if(!NT_SUCCESS(status)) {
        return;
    }

    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) buffer;

    //
    // Try to find the Timeout value under disk services key.
    //
    RtlInitUnicodeString(&valueName, L"TimeoutValue");
    status = ZwQueryValueKey(Key,
                             &valueName,
                             KeyValueFullInformation,
                             buffer,
                             PORT_REG_BUFFER_SIZE,
                             &length);

    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Check that the length is reasonable.
    //
    if ((keyValueInformation->Type == REG_DWORD) &&
        (keyValueInformation->DataLength != sizeof(ULONG))) {
        return;
    }

    //
    // Verify that the name is what we expect.
    //
    result = _wcsnicmp(keyValueInformation->Name, 
                       L"TimeoutValue",
                       keyValueInformation->NameLength / 2);

    if (result != 0) {
        return;
    }

    //
    // If the data length is invalid, abort.
    //
    if (keyValueInformation->DataLength == 0) {
        return;
    }

    //
    // Data type must be REG_DWORD.
    //
    if (keyValueInformation->Type != REG_DWORD) {
        return;
    }

    //
    // Extract the value.
    // 
    TimeoutValue = *((PULONG)(buffer + keyValueInformation->DataOffset));

    if(!TimeoutValue){
        return;
    }
    
    *DiskTimeout = TimeoutValue;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\lib\utils.c ===
#include "precomp.h"
#include "utils.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PortGetDeviceType)
#endif // ALLOC_PRAGMA



//
// Port Driver Data
//

#ifdef ALLOC_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

const SCSI_DEVICE_TYPE PortScsiDeviceTypes [] = {
//  Name            Generic Name        DeviceMap                           IsStorage
    {"Disk",        "GenDisk",          L"DiskPeripheral",                  TRUE},
    {"Sequential",  "",                 L"TapePeripheral",                  TRUE},
    {"Printer",     "GenPrinter",       L"PrinterPeripheral",               FALSE},
    {"Processor",   "",                 L"OtherPeripheral",                 FALSE},
    {"Worm",        "GenWorm",          L"WormPeripheral",                  TRUE},
    {"CdRom",       "GenCdRom",         L"CdRomPeripheral",                 TRUE},
    {"Scanner",     "GenScanner",       L"ScannerPeripheral",               FALSE},
    {"Optical",     "GenOptical",       L"OpticalDiskPeripheral",           TRUE},
    {"Changer",     "ScsiChanger",      L"MediumChangerPeripheral",         TRUE},
    {"Net",         "ScsiNet",          L"CommunicationsPeripheral",        FALSE},
    {"ASCIT8",      "ScsiASCIT8",       L"ASCPrePressGraphicsPeripheral",   FALSE},
    {"ASCIT8",      "ScsiASCIT8",       L"ASCPrePressGraphicsPeripheral",   FALSE},
    {"Array",       "ScsiArray",        L"ArrayPeripheral",                 FALSE},
    {"Enclosure",   "ScsiEnclosure",    L"EnclosurePeripheral",             FALSE},
    {"RBC",         "ScsiRBC",          L"RBCPeripheral",                   TRUE},
    {"CardReader",  "ScsiCardReader",   L"CardReaderPeripheral",            FALSE},
    {"Bridge",      "ScsiBridge",       L"BridgePeripheral",                FALSE},
    {"Other",       "ScsiOther",        L"OtherPeripheral",                 FALSE}
};

#ifdef ALLOC_PRAGMA
#pragma data_seg()
#endif


//
// Functions
//

PCSCSI_DEVICE_TYPE
PortGetDeviceType(
    IN ULONG DeviceType
    )
/*++

Routine Description:

    Get the SCSI_DEVICE_TYPE record for the specified device.

Arguments:

    DeviceType - SCSI device type from the DeviceType field of the SCSI
        inquiry data.

Return Value:

    Pointer to a SCSI device type record. This record must not be modified.

--*/
{
    PAGED_CODE();
    
    if (DeviceType >= ARRAY_COUNT (PortScsiDeviceTypes)) {
        DeviceType = ARRAY_COUNT (PortScsiDeviceTypes) - 1;
    }
    
    return &PortScsiDeviceTypes[DeviceType];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\inc\sldebug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sldebug.h

Abstract:

    Debugging functions exported from the storlib library.

Author:

    Matthew D Hendel (math) 24-Apr-2000

Revision History:

--*/

#pragma once

#undef ASSERT
#undef VERIFY
#undef ASSERTMSG
#undef KdBreakPoint
#undef DebugPrint

#if !DBG

#define DebugTrace(arg)
#define DebugPrint(arg)
#define DebugWarn(arg)
#define ASSERT(arg)
#define VERIFY(arg) (arg)
#define ASSERTMSG(arg)
#define KdBreakPoint()
#define StorSetDebugPrefixAndId(Prefix,ComponentId)

#define NYI()
#define REVIEW()

//
// DbgFillMemory does nothing
// in a free build.
//

#define DbgFillMemory(Ptr,Size,Fill)

#else // DBG

VOID
vStorDebugPrintEx(
    IN ULONG Level,
    IN PCSTR Format,
    va_list arglist
    );

VOID
StorDebugTrace(
    IN PCSTR Format,
    ...
    );

VOID
StorDebugWarn(
    IN PCSTR Format,
    ...
    );

VOID
StorDebugPrint(
    IN PCSTR Format,
    ...
    );


VOID
StorSetDebugPrefixAndId(
    IN PCSTR Prefix,
    IN ULONG DebugId
    );
    
#define DebugTrace(arg) StorDebugTrace  arg
#define DebugWarn(arg)  StorDebugWarn   arg
#define DebugPrint(arg) StorDebugPrint  arg

//
// On X86 use _asm int 3 instead of DbgBreakPoint because
// it leaves us in same context frame as the break,
// instead of a frame up that we have to step out of.
//

#if defined (_X86_)
#define KdBreakPoint()  _asm { int 3 }
#else
#define KdBreakPoint()  DbgBreakPoint()
#endif


//++
//
// VOID
// DbgFillMemory(
//     PVOID Destination,
//     SIZE_T Length,
//     UCHAR Fill
//     );
//
// Routine Description:
//
// In a checked build, DbgFillMemory expands to RtlFillMemory. In a free
// build, it expands to nothing. Use DbgFillMemory to initialize structures
// to invalid bit patterns before deallocating them.
//
// Return Value:
//
// None.
//
//--

VOID
INLINE
DbgFillMemory(
    PVOID Destination,
    SIZE_T Length,
    UCHAR Fill
    )
{
    RtlFillMemory (Destination, Length, Fill);
}


//
// Use a different ASSERT macro than the vanilla DDK ASSERT. 
//

BOOLEAN
StorAssertHelper(
    PCHAR Expression,
    PCHAR File,
    ULONG Line,
    PBOOLEAN Ignore
    );

//++
//
// VOID
// ASSERT(
//     LOGICAL Expression
//     );
//
// Routine Description:
//
// The ASSERT improves upon the DDK's ASSERT macro in several ways.
// In source mode, it breaks directly on the line where the assert
// failed, instead of several frames up. Additionally, there is a
// way to repeatedly ignore the assert.
//
// Return Value:
//
// None.
//
//--

#define ASSERT(exp)\
    do {                                                                    \
        static BOOLEAN Ignore = FALSE;                                      \
                                                                            \
        if (!(exp)) {                                                       \
            BOOLEAN Break;                                                  \
            Break = StorAssertHelper (#exp, __FILE__, __LINE__, &Ignore);   \
            if (!Ignore && Break) {                                         \
                KdBreakPoint();                                             \
            }                                                               \
        }                                                                   \
    } while (0)

#define VERIFY(_x) ASSERT(_x)

#define NYI() ASSERT (!"NYI")
#define REVIEW()\
    {\
        DebugPrint (("***** REVIEW: This code needs to be reviewed."    \
                     "      Source File %s, line %ld\n",                \
                  __FILE__, __LINE__));                                 \
        KdBreakPoint();                                                 \
    }

#define DBG_DEALLOCATED_FILL    (0xDE)
#define DBG_UNINITIALIZED_FILL  (0xCE)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\ext\ext.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	raid.c

Abstract:

	Extensions for RAID port driver.

Author:

	Matthew D Hendel (math) 14-June-2000

Revision History:


!raid.help

!raid.help

	adapter - Dump an adapter object.

	unit - Dump a unit object.

Type !raid.help "command" for more information about the command.
	


NAME:

	unit

USAGE:

	unit [UNIT-OBJECT [DETAIL]]

ARGUMENTS:

	UNIT-OBJECT - 

	DETAIL - 

----------------------------------------------------------------------------

!raid.adapter

RAID Adapters:

	Name		   DO		  Ext
	-------------------------------------
	dac960nt	84000000	84100000
	foobar		84000000	84100000
	ami95044	84000000	84100000
	XXAABB		84000000	84100000

RAID Units:

	Product         SCSI ID	      DO	      Ext		Reqs
	--------------------------------------------------------------------
	MYLEX DAC960    3   1	1	84000000	84100000	200
	AMI DDD5455	  200 200 200	84000000	84100000	  0

!raid.unit
	Dump a raid unit
	
!raid.adapter
	Dump a raid adapter


--*/

#include "pch.h"
#include "precomp.h"


//
// Prototypes
//

VOID
DumpUnit(
	IN ULONG64 Unit,
	IN ULONG Level
	);

VOID
DumpAdapter(
	IN ULONG64 Adapter,
	IN ULONG Level
	);

//
// Data
//

PCHAR StateTable [] = {
	"Removed",	// not present
	"Working",	// working
	"Stopped",	// stopped
	"P-Stop",	// pending stop
	"P-Remove",	// pending remove
	"Surprise",	// surprise remove
};


BOOLEAN Verbose = FALSE;

//
// Functions
//


BOOLEAN
CheckRaidObject(
	IN ULONG64 Object,
	IN RAID_OBJECT_TYPE ObjectType
	)
{

	ULONG Ret;

	if (Object == 0) {
		return FALSE;
	}
	
	Ret = GetFieldData (Object,
						"raidport!RAID_COMMON_EXTENSION",
						"ObjectType",
						sizeof (ObjectType),
						&ObjectType);
						  

	if (Ret != 0 || ObjectType != ObjectType) {
		return FALSE;
	}

	return TRUE;
}


ULONG64
GetListHead(
	IN ULONG64 Object,
	IN PSZ ObjectType,
	IN PSZ FieldName,
	OUT PULONG64 ListHead
	)
{
	ULONG64 NextEntry;
	ULONG Offset;
	ULONG Ret;

	Ret = GetFieldOffset (ObjectType, FieldName, &Offset);

	if (Ret != 0) {
		return 0;
	}

	*ListHead = (Object + Offset);
	ReadPointer (*ListHead, &NextEntry);

	return NextEntry;
}
	

ULONG64
GetNextListEntry(
	IN ULONG64 ListElement
	)
{
	ULONG64 NextEntry;
	ULONG Ret;
	
	Ret = GetFieldData (ListElement,
						"raidport!LIST_ENTRY",
						"Flink",
						sizeof (NextEntry),
						&NextEntry);

	if (Ret != 0) {
		dprintf ("ERROR: Couldn't get next list entry for element %08x\n", ListElement);
		return 0;
	}
	
	return NextEntry;
}

ULONG64
ContainingRecord(
	IN ULONG64 Object,
	IN PSZ ObjectType,
	IN PSZ FieldName
	)
{
	ULONG Offset;
	ULONG Ret;
	
	Ret = GetFieldOffset (ObjectType, FieldName, &Offset);

	if (Ret != 0) {
		return 0;
	}
	
	return (Object - Offset);
}

	

VOID
ListDriverAdapters(
	IN ULONG64 Driver,
	IN ULONG Level
	)
{
	ULONG64 ListHead;
	ULONG64 Adapter;
	ULONG64 NextEntry;
	
#if 0
	BOOLEAN Succ;
	
	Succ = GetDriverInformation (Driver,
								 DriverName,
								 &BaseAddress,
								 &CreationTime);

	if (!Succ) {
		return;
	}

	GetFieldOffset ("raidport!RAID_DRIVER_EXTENSION",
					"AdapterList.List",
					&Offset);

	ListHead = Driver + Offset;
#endif

	NextEntry = GetListHead (Driver,
							 "raidport!RAID_DRIVER_EXTENSION",
							 "AdapterList.List.Flink",
							 &ListHead);

	if (Verbose) {
		dprintf ("VERBOSE: ListHead = %08x, NextEntry = %08x\n",
				 (ULONG)ListHead, (ULONG)NextEntry);
	}
	for ( /* NOTHING */ ;
		 NextEntry != 0 && NextEntry != ListHead;
		 NextEntry = GetNextListEntry (NextEntry)) {

		if (Verbose) {
			dprintf ("VERBOSE: Adapter ListEntry %08x\n", NextEntry);
		}
		
		Adapter = ContainingRecord (NextEntry,
									"raidport!RAID_ADAPTER_EXTENSION",
									"NextAdapter");

		if (!CheckRaidObject (Adapter, RaidAdapterObject)) {
			dprintf ("ERROR: Object at %08x not an raid adapter\n", Adapter);
			return;
		}

		if (CheckControlC()) {
			return;
		}

		DumpAdapter (Adapter, Level);
	}
}

ULONG64
GetPortData(
	)
{	
	ULONG Ret;
	ULONG64 PortDataPtr;
	ULONG64 PortData;
	
	PortDataPtr = GetExpression ("raidport!RaidpPortData");
	if (PortDataPtr == 0) {
		dprintf ("ERROR: couldn't get raidport!RaidpPortData\n");
		return 0;
	}
	ReadPointer (PortDataPtr, &PortData);

	return PortData;
}


VOID
ListAllAdapters(
	IN ULONG Level
	)
{
	ULONG Ret;
	ULONG64 PortDataPtr;
	ULONG64 PortData;
	ULONG64 ListHead;
	ULONG64 NextEntry;
	ULONG64 Driver;
	ULONG Offset;

	
	PortDataPtr = GetExpression ("raidport!RaidpPortData");
	if (PortDataPtr == 0) {
		dprintf ("ERROR: couldn't get raidport!RaidpPortData\n");
		return;
	}
	ReadPointer (PortDataPtr, &PortData);
	Ret = GetFieldOffset ("raidport!RAID_PORT_DATA",
						  "DriverList.List",
						  &Offset);

	if (Ret != 0) {
		dprintf ("ERROR: Could lookup RAID_PORT_DATA structure\n");
		return ;
	}

	ListHead = PortData + Offset;

	if (Verbose) {
		dprintf ("VERBOSE: dumping adapter list at %I64x\n", ListHead);
	}

	dprintf ("Driver     Object     Ext     State\n");
	dprintf ("--------------------------------------------------------\n");

	for (GetFieldValue (ListHead, "raidport!LIST_ENTRY", "Flink", NextEntry);
		 NextEntry != 0 && NextEntry != ListHead;
		 GetFieldValue (NextEntry, "raidport!LIST_ENTRY", "Flink", NextEntry)) {

		GetFieldOffset ("raidport!RAID_DRIVER_EXTENSION", "DriverLink", &Offset);

		if (Verbose) {
			dprintf ("VERBOSE: ListEntry at %08x\n", NextEntry);
		}
			
		Driver = NextEntry - Offset;

		if (Verbose) {
			dprintf ("VERBOSE: Driver at %08x\n", Driver);
		}
		
		if (!CheckRaidObject (Driver, RaidDriverObject)) {
			dprintf ("ERROR: %08x is not a driver object\n", Driver);
			return;
		}

		if (CheckControlC()) {
			return;
		}
			
		if (Verbose) {
			dprintf ("VERBOSE: dumping driver at %I64x\n", Driver);
		}

		ListDriverAdapters (Driver, Level);
	}

	dprintf ("\n");
}

VOID
ListAdapterUnits(
	IN ULONG64 Adapter,
	IN ULONG Level
	)
{
	ULONG64 NextEntry;
	ULONG64 Unit;
	ULONG64 ListHead;
	
	NextEntry = GetListHead (Adapter,
							 "raidport!RAID_ADAPTER_EXTENSION",
							 "UnitList.List.Flink",
							 &ListHead);

	for ( ;
		 NextEntry != 0 && NextEntry != ListHead;
		 NextEntry = GetNextListEntry (NextEntry)) {

		Unit = ContainingRecord (NextEntry,
								 "raidport!RAID_UNIT_EXTENSION",
								 "NextUnit");

		if (!CheckRaidObject (Unit, RaidUnitObject)) {
			dprintf ("ERROR: Object at %08x is not a raid unit object\n", Unit);
			return;
		}

		if (CheckControlC()) {
			return;
		}

		DumpUnit (Unit, Level);
	}
}

VOID
ListDriverUnits(
	IN ULONG64 Driver,
	IN ULONG Level
	)
{
	ULONG64 ListHead;
	ULONG64 Adapter;
	ULONG64 NextEntry;
	
	NextEntry = GetListHead (Driver,
							 "raidport!RAID_DRIVER_EXTENSION",
							 "AdapterList.List.Flink",
							 &ListHead);

	if (Verbose) {
		dprintf ("VERBOSE: ListHead = %08x, NextEntry = %08x\n",
				 (ULONG)ListHead, (ULONG)NextEntry);
	}

	for ( ;
		 NextEntry != 0 && NextEntry != ListHead;
		 NextEntry = GetNextListEntry (NextEntry)) {

		if (Verbose) {
			dprintf ("VERBOSE: Adapter ListEntry %08x\n", NextEntry);
		}
		
		Adapter = ContainingRecord (NextEntry,
									"raidport!RAID_ADAPTER_EXTENSION",
									"NextAdapter");

		if (!CheckRaidObject (Adapter, RaidAdapterObject)) {
			dprintf ("ERROR: Object at %08x not an raid adapter\n", Adapter);
			return;
		}

		if (CheckControlC()) {
			return;
		}

		ListAdapterUnits (Adapter, Level);
	}
}

VOID
ListAllUnits(
	IN ULONG Level
	)
{
	ULONG64 PortData;
	ULONG64 NextEntry;
	ULONG64 Driver;
	ULONG64 ListHead;
	
	PortData = GetPortData ();

	NextEntry = GetListHead (PortData,
							 "raidport!RAID_PORT_DATA",
							 "DriverList.List.Flink",
							 &ListHead);

	dprintf ("Product           SCSI ID     OBJ        EXT       Reqs   State\n");
	dprintf ("--------------------------------------------------------------\n");

	for ( ;
	     NextEntry != 0 && NextEntry != ListHead;
		 NextEntry = GetNextListEntry (NextEntry)) {

		Driver = ContainingRecord (NextEntry,
								   "raidport!RAID_DRIVER_EXTENSION",
								   "DriverLink");

		if (Verbose) {
			dprintf ("VERBOSE: dumping driver %08x\n", Driver);
		}
								   
		if (!CheckRaidObject (Driver, RaidDriverObject)) {
			dprintf ("ERROR: Object at %08x not a raid driver\n", Driver);
			return;
		}
		
		if (CheckControlC()) {
			return;
		}

		ListDriverUnits (Driver, Level);
	}

	dprintf ("\n");
}



PCHAR
StateToString(
	IN ULONG State
	)
{
	if (State > 5) {
		return "invalid state";
	}
	return StateTable[State];
}


ULONG64
GetDriverObject(
	IN ULONG64 Driver
	)
{
	ULONG Ret;
	CSHORT Type;
	ULONG64 DriverObject;
	
	if (CheckRaidObject (Driver, RaidDriverObject)) {
		Ret = GetFieldData (Driver,
						    "raidport!RAID_DRIVER_EXTENSION",
						    "DriverObject",
						    sizeof (DriverObject),
							&DriverObject);

		if (Ret != 0) {
			DriverObject = 0;
		}
	} else {
		DriverObject = Driver;
	}

	Ret = GetFieldValue (DriverObject, "raidport!DRIVER_OBJECT", "Type", Type);

	if (Ret != 0 || Type != IO_TYPE_DRIVER) {
		DriverObject = 0;
		if (Verbose) {
			dprintf ("VERBOSE: %08x is not a RAID_DRIVER_EXTENSION or DRIVER_OBJECT\n");
		}
	}

	return DriverObject;
}


VOID
GetDriverName(
	IN ULONG64 Driver,
	IN PUCHAR Buffer
	)
{
	ULONG Count;
	ULONG Offset;
	WCHAR UnicodeBuffer[256];
	ULONG Ret;
	ULONG BytesRead;
	ULONG64 DriverObject;
	ULONG64 String;
	PWCHAR DriverName;

	DriverObject = GetDriverObject (Driver);

	if (DriverObject == 0) {
		dprintf ("ERROR: %08x is not a driver\n", DriverObject);
		return;
	}

	if (Verbose) {
		dprintf ("VERBOSE: Getting driver name for DRIVER_OBJECT %08x\n", DriverObject);
	}

	Ret = GetFieldData (DriverObject,
				        "raidport!DRIVER_OBJECT",
						"DriverName.Length",
						sizeof (Count),
						&Count);

	if (Ret != 0) {
		dprintf ("ERROR: couldn't get field of DRIVER_OBJECT. Symbols may be bad.\n");
		return;
	}

	Ret = GetFieldOffset("raidport!DRIVER_OBJECT",
						 "DriverName.Buffer",
						 &Offset);

	if (Ret != 0) {
		dprintf ("ERROR: couldn't get field of DRIVER_OBJECT. Symbols may be bad.\n");
		return;
	}
	
	if (Count > 0 && Count <= 256) {
		ReadPointer (DriverObject + Offset, &String);
		ReadMemory (String, UnicodeBuffer, Count, &BytesRead);
	}

	UnicodeBuffer[Count++] = '\000';
	DriverName = wcsrchr (UnicodeBuffer, L'\\');
	if (DriverName == NULL) {
		DriverName = UnicodeBuffer;
	} else {
		DriverName++;
	}

	sprintf (Buffer, "%ws", DriverName);
}
	

BOOLEAN
IsDeviceObject(
	IN ULONG64 DeviceObject
	)
{
	CSHORT Type;

	GetFieldValue (DeviceObject, "raidport!DEVICE_OBJECT", "Type", Type);

	return (Type == IO_TYPE_DEVICE);
}


ULONG64
GetDeviceExtension(
	IN ULONG64 DeviceObject
	)
{
	ULONG Ret;
	ULONG Offset;
	ULONG64 Extension = -1;

	Ret = GetFieldOffset ("raidport!DEVICE_OBJECT",
						  "DeviceExtension",
						  &Offset);

	if (Ret != 0) {
		if (Verbose) {
			dprintf ("VERBOSE: couldn't read DeviceExtension\n");
		}

		return 0;
	}

	ReadPointer (DeviceObject + Offset, &Extension);

	return Extension;
}

ULONG
GetEmbeddedRemlockCount(
	IN ULONG64 ObjectPtr,
	IN PSZ ObjectType,
	IN PSZ FieldName
	)
{
	ULONG Ret;
	ULONG Remlock_IoCount;
	ULONG Remlock_Offset;
	ULONG Remlock_Common_Offset;
	
	
	Remlock_IoCount = -1;
	Ret = GetFieldOffset (ObjectType,
						  FieldName,
						  &Remlock_Offset);
	if (Ret == STATUS_SUCCESS) {
		Ret = GetFieldOffset ("raidport!IO_REMOVE_LOCK",
							  "Common",
							  &Remlock_Common_Offset);
		if (Ret == STATUS_SUCCESS) {
			GetFieldData (ObjectPtr + Remlock_Offset + Remlock_Common_Offset,
						  "raidport!IO_REMOVE_LOCK_COMMON_BLOCK",
						  "IoCount",
						  sizeof (Remlock_IoCount),
						  &Remlock_IoCount);
		}
	}

	if (Ret != STATUS_SUCCESS) {
		printf ("WARN: couldn't get IO_REMOVE_LOCK status\n");
	}

	return Remlock_IoCount;
}

	

ULONG64
GetAdapterExtension(
	IN ULONG64 Adapter
	)
{
	ULONG64 Temp;
	ULONG64 AdapterExt;
	ULONG64 DeviceObject;

	
	if (CheckRaidObject (Adapter, RaidAdapterObject)) {
		AdapterExt = Adapter;
		InitTypeRead (AdapterExt, raidport!RAID_ADAPTER_EXTENSION);
		DeviceObject = ReadField (DeviceObject);
		if (Verbose) {
			dprintf ("VERBOSE: Checking if %08x is a device object\n", DeviceObject);
		}
		if (IsDeviceObject (DeviceObject)) {
			Temp = GetDeviceExtension (DeviceObject);
			if (Verbose) {
				dprintf ("VERBOSE: Ext = %08x, Computed Ext = %08x\n",
						 AdapterExt, Temp);
			}
			if (Temp == AdapterExt) {
				return AdapterExt;
			}
		} else {
			if (Verbose) {
				dprintf ("VERBOSE: %08x is not a device object\n", DeviceObject);
			}
		}
	} else {
		if (Verbose) {
			dprintf ("VERBOSE: %08x not a RaidAdapterObject\n");
		}
	}

	if (IsDeviceObject (Adapter)) {
		AdapterExt = GetDeviceExtension (Adapter);
		if (Verbose) {
			dprintf ("VERBOSE: Checking if %08x is an adapter extension\n", AdapterExt);
		}
		if (CheckRaidObject (AdapterExt, RaidAdapterObject)) {
			InitTypeRead (AdapterExt, raidport!RAID_ADAPTER_EXTENSION);
			DeviceObject = ReadField (DeviceObject);
			if (DeviceObject == Adapter) {
				return AdapterExt;
			} else if (Verbose) {
				dprintf ("VERBOSE: DO %I64x != Adapter %I64x\n",
						 (ULONG)DeviceObject,
						 (ULONG)Adapter);
			}
				
		} else if (Verbose) {
			dprintf ("VERBOSE: Ext %08x not RaidAdapterObject\n",
					 (ULONG)AdapterExt);
		}
	}


	return 0;
}

VOID
DumpMiniport(
	IN ULONG64 AdapterPtr
	)
{
	ULONG Ret;
	ULONG Offset;
	ULONG64 HwDeviceExt;
	ULONG64 DeviceExtPtr;
	ULONG64 MiniportPtr;
	ULONG64 HwInitData;

	//
	// PortConfig 80000000  HwInitData 77000000 HwDeviceExt a0000000 27 bytes
	// LuExt 32 bytes SrbExt 32 bytes
	//
	
	GetFieldOffset ("raidport!RAID_ADAPTER_EXTENSION",
					"Miniport",
					&Offset);
	MiniportPtr = AdapterPtr + Offset;

	InitTypeRead (MiniportPtr, raidport!RAID_MINIPORT);

	HwInitData = ReadField (HwInitializationData);

	GetFieldOffset ("raidport!RAID_MINIPORT",
					"PortConfiguration",
					&Offset);

	dprintf ("  PortConfig %08x HwInit %08x\n", (ULONG)(MiniportPtr + Offset),
			  (ULONG)HwInitData);
	
	DeviceExtPtr = ReadField (PrivateDeviceExt);

	if (DeviceExtPtr == 0) {
		HwDeviceExt = 0;
	} else {
		Ret = GetFieldOffset ("raidport!RAID_HW_DEVICE_EXT",
							  "HwDeviceExtension",
							  &Offset);
		if (Ret != 0) {
			HwDeviceExt = 0;
		} else {
			HwDeviceExt = DeviceExtPtr + Offset;
		}
	}

	InitTypeRead (HwInitData, raidport!HW_INITIALIZATION_DATA);

	dprintf ("  HwDeviceExt %08x %d bytes\n",
				(ULONG)HwDeviceExt, (ULONG)ReadField (DeviceExtensionSize));

	dprintf ("  LuExt %d bytes  SrbExt %d bytes\n",
				(ULONG)ReadField (SpecificLuExtensionSize),
				(ULONG)ReadField (SrbExtensionSize));
}
	
VOID
DumpAdapter(
	IN ULONG64 Adapter,
	IN ULONG Level
	)
/*++

ADAPTER f0345600
  Ext 8e000000 Driver 8000000 Next 8000000 Working
  LDO 80000000 PDO 00000000 HwExt 00000000 
  SlowLock Free  RemLock 10 Power D0 S0  Full Duplex
  Bus 08080808 Number 1 Slot 0 Dma 88888888 Interrupt 88888888
  AdQueue: Outstanding 200, Low 100, High 200 Busy
  ResourceList: Allocated 80808080 Translated 80808080

  MappedAddressList:

	Virtual  Physical         Size Bus
	80808080 8000000000000000 1500  1
	80808080 8000000000000000 1500  1
	80808080 8000000000000000 1500  1
	80808080 8000000000000000 1500  1
	80808080 8000000000000000 1500  1
	80808080 8000000000000000 1500  1

*/
	

  
 
{
	ULONG64 AdapterPtr;
	ULONG64 Driver;
	CHAR DriverName[100];

	if (Verbose) {
		dprintf ("VERBOSE: dumping adapter %08x\n", Adapter);
	}

	AdapterPtr = GetAdapterExtension (Adapter);

	if (AdapterPtr == 0) {
		dprintf ("ERROR: %08x is not a valid adapter object\n", Adapter);
		return;
	}
	
	if (Level == 0) {

		Driver = ReadField (Driver);
		GetDriverName (Driver, DriverName);
		dprintf ("%8.8s  %08x  %08x  %s\n",
				 DriverName,
				 (ULONG)ReadField (DeviceObject),
				 (ULONG)Adapter,
				 StateToString ((ULONG)ReadField (DeviceState))
				 );
	} else {
		PSZ Adapter_SlowLock;
		ULONG Remlock_IoCount;
		

		dprintf ("ADAPTER %08x\n", ReadField (DeviceObject));
		dprintf ("  Ext %08x  Driver %08x  Next %08x  %s\n",
					(ULONG)AdapterPtr,
					(ULONG)ReadField (Driver),
					(ULONG)0,
					StateToString ((ULONG)ReadField (DeviceState)));


		dprintf ("  LDO %08x  PDO %08x\n",
				  (ULONG)ReadField (LowerDeviceObject),
				  (ULONG)ReadField (PhysicalDeviceObject));

		if (ReadField ("SlowLock") == 0) {
			Adapter_SlowLock = "Free";
		} else {
			Adapter_SlowLock = "Held";
		}

		Remlock_IoCount = GetEmbeddedRemlockCount (AdapterPtr,
												   "raidport!RAID_ADAPTER_EXTENSION",
												   "RemoveLock");

		dprintf ("  SlowLock %s  RemLock %d  Power %s %s  %s\n",
				  Adapter_SlowLock,
				  Remlock_IoCount,
				  "S0", "D0",
				  (ReadField (Mode) == RaidSynchronizeFullDuplex ?
														"Full Duplex" : 
														"Half Duplex")
				  );
				  
		dprintf ("  Bus %08x Number %d Slot %d  Dma %08x  Interrupt %08x\n",
				  (ULONG)0,
				  (ULONG)ReadField (BusNumber),
				  (ULONG)ReadField (SlotNumber),
				  (ULONG)ReadField (Dma.DmaAdapter),
				  (ULONG)ReadField (Interrupt));

		dprintf ("  ResourceList: Allocated %08x Translated %08x\n",
				  (ULONG)ReadField (ResourceList.AllocatedResources),
				  (ULONG)ReadField (ResourceList.TranslatedResources));

		dprintf ("  Gateway: Outstanding %d Lower %d High %d\n",
					ReadField (AdapterQueue->Outstanding),
					ReadField (AdapterQueue->LowWaterMark),
					ReadField (AdapterQueue->HighWaterMark));

		DumpMiniport (AdapterPtr);
		
					
	}
}


VOID
FixPaddedString(
	PSZ String
	)
{
	ULONG Pos;
	
	Pos = strlen (String);
	if (Pos > 0) {
		Pos--;
	}
	
	while (Pos && String[Pos] == ' ') {
		String[Pos--] = '\000';
	}
}


VOID
GetUnitProductInfo(
	ULONG64 Unit,
	PSZ VendorId,
	PSZ ProductId,
	PSZ Revision
	)
{
	ULONG Offset;
	ULONG64 InquiryData;
	
	GetFieldOffset ("raidport!RAID_UNIT_EXTENSION",
					"InquiryData",
					&Offset);

	ReadPointer (Unit + Offset, &InquiryData);

	if (VendorId) {
		ZeroMemory (VendorId, 9);
		GetFieldData (InquiryData,
				  "raidport!INQUIRYDATA",
				  "VendorId",
				  8,
				  VendorId);
		FixPaddedString (VendorId);
	}

	if (ProductId) {
		ZeroMemory (ProductId, 17);
		GetFieldData (InquiryData,
				  "raidport!INQUIRYDATA",
				  "ProductId",
				  16,
				  ProductId);
		FixPaddedString (ProductId);
	}

	if (Revision) {
		ZeroMemory (Revision, 5);
		GetFieldData (InquiryData,
				  "raidport!INQUIRYDATA",
				  "ProductRevisionLevel",
				  4,
				  Revision);
		FixPaddedString (Revision);
	}
}


ULONG
GetUnitIoQueueRequests(
	IN ULONG64 UnitPtr
	)
{
	ULONG Ret;
	ULONG64 Unit_IoQueue;
	ULONG64 IoQueue_DeviceQueue;
	ULONG Offset;
	ULONG Requests;
	
	Ret = GetFieldOffset ("raidport!RAID_UNIT_EXTENSION",
						  "IoQueue",
						  &Offset);

	if (Ret != STATUS_SUCCESS) {
		dprintf ("WARN: failed to get IoQueue offset from unit.\n");
	}

	Unit_IoQueue = UnitPtr + Offset;

	Ret = GetFieldOffset ("raidport!IO_QUEUE",
						  "DeviceQueue",
						  &Offset);
	if (Ret != STATUS_SUCCESS) {
		dprintf ("WARN: failed to get DeviceQueue offset from unit(1).\n");
	}

	IoQueue_DeviceQueue = Unit_IoQueue + Offset;

	GetFieldData (IoQueue_DeviceQueue,
				  "raidport!EXTENDED_DEVICE_QUEUE",
				  "OutstandingRequests",
				  sizeof (Requests),
				  &Requests);

	return Requests;
}


VOID
DumpUnit(
	IN ULONG64 Unit,
	IN ULONG Level
	)
{
	ULONG64 UnitPtr;
	CSHORT DeviceObject_Type;
	
	GetFieldValue (Unit, "raidport!DEVICE_OBJECT", "Type", DeviceObject_Type);

	if (DeviceObject_Type == IO_TYPE_DEVICE) {
		GetFieldValue (Unit, "raidport!DEVICE_OBJECT", "DeviceExtension", UnitPtr);
		if (!CheckRaidObject (UnitPtr, RaidUnitObject)) {
			dprintf ("ERROR: DeviceObject %8.8x is not a raid unit\n", UnitPtr);
			return;
		}
	} else if (CheckRaidObject (Unit, RaidUnitObject)) {
		UnitPtr = Unit;
	} else {
		dprintf ("ERROR: Pointer %8.8x is not a device object or raid unit object\n",
				  Unit);
		return;
	}

	InitTypeRead (UnitPtr, raidport!RAID_UNIT_EXTENSION);

	if (Level == 0) {
		
		CHAR VendorId[9] = {0};
		CHAR ProductId[17] = {0};
		CHAR Product[25];

		GetUnitProductInfo (UnitPtr, VendorId, ProductId, NULL);

		sprintf (Product, "%s %s", VendorId, ProductId);
		
		
		dprintf ("%-15.15s %3d %3d %3d   %08x   %08x   %-3d   %-8.8s\n",
				 Product,
				 (ULONG)ReadField (PathId),
				 (ULONG)ReadField (TargetId),
				 (ULONG)ReadField (Lun),				 
				 (ULONG)ReadField (DeviceObject),
				 (ULONG)UnitPtr,
				 GetUnitIoQueueRequests (UnitPtr),
				 StateToString ((ULONG)ReadField (DeviceState)));
	} else {

		ULONG Ret;
		ULONG Remlock_IoCount;
		ULONG Remlock_Offset;
		ULONG Remlock_Common_Offset;
		PCHAR SlowLock;
		ULONG64 Unit_QueueFrozen;
		ULONG64 Unit_QueueLocked;
		ULONG64 Unit_TagList;
		ULONG64 Unit_IoQueue;
		ULONG64 IoQueue_DeviceQueue;
		ULONG Offset;
		ULONG Device_Offset;
		ULONG ByPass_Offset;
		ULONG64 Pointer;
		CHAR VendorId[9] = {0};
		CHAR ProductId[17] = {0};
		CHAR Revision[5] = {0};
		ULONG64 InquiryData;
		
		
		dprintf ("UNIT %08x\n", ReadField (DeviceObject));
		dprintf ("  Ext %08x  Adapter %08x  Next %08x %s\n",
				  (ULONG)UnitPtr,
				  (ULONG)ReadField(Adapter),
				  (ULONG) 0 /*BUGBUG: pull out NextField*/,
				  StateToString((ULONG)ReadField(DeviceState)));

		GetFieldOffset ("raidport!RAID_UNIT_EXTENSION",
					"InquiryData",
					&Offset);

		ReadPointer (UnitPtr + Offset, &InquiryData);
		
		GetUnitProductInfo (UnitPtr, VendorId, ProductId, Revision);

		dprintf ("  SCSI %d %d %d  %s %s %s  Inquiry %08x\n",
				  (ULONG)ReadField(PathId),
				  (ULONG)ReadField(TargetId),
				  (ULONG)ReadField(Lun),
				  VendorId,
				  ProductId,
				  Revision,
				  (ULONG)InquiryData);
				  
		Remlock_IoCount = -1;
		Ret = GetFieldOffset ("raidport!RAID_UNIT_EXTENSION",
							  "RemoveLock",
							  &Remlock_Offset);
		if (Ret == STATUS_SUCCESS) {
			Ret = GetFieldOffset ("raidport!IO_REMOVE_LOCK",
								  "Common",
								  &Remlock_Common_Offset);
			if (Ret == STATUS_SUCCESS) {
				GetFieldData (UnitPtr + Remlock_Offset + Remlock_Common_Offset,
							  "raidport!IO_REMOVE_LOCK_COMMON_BLOCK",
							  "IoCount",
							  sizeof (Remlock_IoCount),
							  &Remlock_IoCount);
			}
		}

		if (Ret != STATUS_SUCCESS) {
			printf ("WARN: couldn't get IO_REMOVE_LOCK status\n");
		}


		if (ReadField ("SlowLock") == 0) {
			SlowLock = "Free";
		} else {
			SlowLock = "Held";
		}
		
		dprintf ("  SlowLock %s  RemLock %d  PageCount %d\n",
				 SlowLock,
				 Remlock_IoCount,
				 (ULONG)ReadField (PagingPathCount));

		Pointer = ReadField (SrbExtensionRegion.VirtualBase);
		dprintf ("  SrbExtension Size %d  Start %08x  End %08x\n",
				 0, // BUGBUG: Get srb extension size from the miniport
				 (ULONG)Pointer,
				 (ULONG)Pointer + (ULONG)ReadField (SrbExtensionRegion.Length));

		Ret = GetFieldOffset ("raidport!RAID_UNIT_EXTENSION",
							  "TagList",
							  &Offset);

		if (Ret != STATUS_SUCCESS) {
			dprintf ("WARN: Couldn't read TagList field\n");
		}

		Unit_QueueFrozen = ReadField (Flags.QueueFrozen);
		Unit_QueueLocked = ReadField (Flags.QueueLocked);
		
		Unit_TagList = UnitPtr + Offset;
		
		dprintf ("  TagList %08x (%d of %d used)\n",
				 (ULONG)(Unit_TagList),
				 (ULONG)ReadField(TagList.OutstandingTags),
				 (ULONG)ReadField(TagList.Count));

		Ret = GetFieldOffset ("raidport!RAID_UNIT_EXTENSION",
							  "IoQueue",
							  &Offset);

		if (Ret != STATUS_SUCCESS) {
			dprintf ("WARN: failed to get IoQueue offset from unit.\n");
		}
		Unit_IoQueue = UnitPtr + Offset;

		Ret = GetFieldOffset ("raidport!IO_QUEUE",
							  "DeviceQueue",
							  &Offset);
		if (Ret != STATUS_SUCCESS) {
			dprintf ("WARN: failed to get DeviceQueue offset from unit.\n");
		}

		IoQueue_DeviceQueue = Unit_IoQueue + Offset;
		InitTypeRead (IoQueue_DeviceQueue, raidport!EXTENDED_DEVICE_QUEUE);

		dprintf ("  IoQueue %s %s; Outstanding %d  Device %d  ByPass %d\n",
				  Unit_QueueFrozen ? "Frozen" : "Unfrozen",
				  Unit_QueueLocked ? "Locked" : "Unlocked",
				  (ULONG)ReadField(OutstandingRequests),
				  (ULONG)ReadField(DeviceRequests),
				  (ULONG)ReadField(ByPassRequests));

		Ret = GetFieldOffset ("raidport!EXTENDED_DEVICE_QUEUE",
							  "DeviceListHead",
							  &Device_Offset);

		if (Ret != STATUS_SUCCESS) {
			dprintf ("WARN: offset of DeviceListHead within EXTENDED_DEVICE_QUEUE failed\n");
		}

		Ret = GetFieldOffset ("raidport!EXTENDED_DEVICE_QUEUE",
							  "ByPassListHead",
							  &ByPass_Offset);


		if (Ret != STATUS_SUCCESS) {
			dprintf ("WARN: offset of ByPassListHead within EXTENDED_DEVICE_QUEUE failed\n");
		}

		dprintf ("          Depth %d DeviceList %08x ByPassList %08x\n",
				 (ULONG)ReadField(Depth),
				 (ULONG)(IoQueue_DeviceQueue + Device_Offset),
				 (ULONG)(IoQueue_DeviceQueue + ByPass_Offset));
	}
				 
				 
/*

UNIT 8f888888
  Ext 8e000000 Adapter 8100000000  Next 8e888888 Working
  SCSI [3, 0, 0]  MYLEX DAC960 122222  InquiryData 08080808
  SlowLock Free  RemLock 10  PageCount 20
  SrbExtension Size 20  VA Start 90000000 End 20000000
  TagList 08080808 (20 of 256 used)
  IoQueue Unfrozen Unlocked; Outstanding 200, Device 200, ByPass 200
          Depth 254 DeviceListHead 00000000 ByPassListHead 88888888

  Outstanding IRPs:

	IRP 00000000 Scsi ExecuteScsi function
	IRP 00000000 Scsi ExecuteScsi function
	IRP 00000000 Scsi ExecuteScsi function
	IRP 00000000 Scsi ExecuteScsi function
	IRP 00000000 Scsi ExecuteScsi function
	IRP 00000000 Scsi ExecuteScsi function
	IRP 00000000 Scsi ExecuteScsi function
	IRP 00000000 Scsi ExecuteScsi function

  Device IRPs:

	IRP 00000000 ssssssssssssssssssssssss
	IRP 00000000 ssssssssssssssssssssssss
	IRP 00000000 ssssssssssssssssssssssss
	IRP 00000000 ssssssssssssssssssssssss
	IRP 00000000 ssssssssssssssssssssssss

  ByPass IRPs:

	IRP 00000000 ssssssssssssssssssssssss
	IRP 00000000 ssssssssssssssssssssssss
	IRP 00000000 ssssssssssssssssssssssss
	IRP 00000000 ssssssssssssssssssssssss
	IRP 00000000 ssssssssssssssssssssssss


*/
}


VOID
ParseArgs(
	IN PSZ Args,
	OUT PULONG64 UnitPtr,
	OUT PULONG Level
	)
{
	LONG Unit;
	
	*UnitPtr = -1;
	*Level = 0;

	if (Args[0] != '\000') {
		Unit = (LONG)strtoul (Args, &Args, 16);
		*UnitPtr = (ULONG64)(LONG64)Unit;
		
		if (Args[0] != '\000') {
			strtoul (Args, &Args, 10);
		}
	}
}

	

DECLARE_API ( unit )
{
	ULONG Level;
	ULONG64 Unit;

	Unit = -1;
	Level = -1;

	ParseArgs ( (PSZ)args, &Unit, &Level);

	if (Unit == -1) {
		if (Level == -1) {
			Level = 1;
		}
		ListAllUnits (Level);
	} else {
		if (Level == -1) {
			Level = 2;
		}
		DumpUnit (Unit, 2);
	}

	return S_OK;
}


DECLARE_API ( adapter )
{
	ULONG Level;
	ULONG64 Adapter;

	Adapter = -1;
	Level = -1;
	
	ParseArgs ( (PSZ)args, &Adapter, &Level);

	if (Adapter == -1) {
		if (Level == -1) {
			Level = 1;
		}
		ListAllAdapters (Level);
	} else {
		if (Level == -1) {
			Level = 2;
		}
		DumpAdapter (Adapter, 2);
	}

	return S_OK;
}


DECLARE_API ( verbose )
{
	ULONG NewValue;
	
	NewValue = strtoul (args, NULL, 16);
	dprintf ("Setting Verbose from %d to %d\n", (ULONG)Verbose, (ULONG)NewValue);
	Verbose = (BOOLEAN) NewValue;

	return S_OK;
}


	

	

DECLARE_API ( help )
{
		dprintf ("  !raid.help [command]             -  Get help.\n");
		dprintf ("  !raid.adapter [adapter [detail]] -  Get adapter information.\n");
		dprintf ("  !raid.unit [unit [detail]]       -  Get unit information.\n");

#if 0
	if (args != NULL && (_stricmp (args, "adapter") == 00)) {
		dprintf ("------------------------------------------------------------------------------\n");
		dprintf ("\n");
		dprintf ("NAME:\n");
		dprintf ("\n");
		dprintf ("    !raid.adapter\n");
		dprintf ("\n");
		dprintf ("USAGE:\n");
		dprintf ("\n");
		dprintf ("    adapter [ADAPTER-OBJECT [DETAIL-LEVEL]]\n");
		dprintf ("\n");
		dprintf ("ARGUMENTS:\n");
		dprintf ("\n");
		dprintf ("    ADAPTER-OBJECT - Pointer to a device object representing an adapter\n");
		dprintf ("    or pointer to an adapter extension. If ADAPTER is 0 or the\n");
		dprintf ("    argument is not present, the command will dump information about\n");
		dprintf ("    all adapters, not just the adapter specified.\n");
		dprintf ("\n");
		dprintf ("    DETAIL-LEVEL - Detail level for dump adapter structs.\n");
		dprintf ("\n");
		dprintf ("-----------------------------------------------------------------------------\n");
	} else if (args != NULL && (_stricmp (args, "unit") == 00)) {
		dprintf ("Unit help\n");
	} else {
		dprintf ("  !raid.help [command]             -  Get help.\n");
		dprintf ("  !raid.adapter [adapter [detail]] -  Get adapter information.\n");
		dprintf ("  !raid.unit [unit [detail]]       -  Get unit information.\n");
	}
#endif

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\inc\storlib.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    storlib.h

Abstract:

    Root include file for the storlib library. This include file includes
    all other necessary to use the library.
    
Author:

    Matthew D Hendel (math) 13-Feb-2001

Revision History:

--*/

#pragma once

#include "sldefs.h"
#include "sldebug.h"
#include "sldict.h"
#include "slgateway.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\inc\slgateway.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

	slgateway.h

Abstract:

	Declaration of a gateway class that manages multiple interrelated
	sub-devices on a device.

	See gateway.c for more information.
	
Author:

	Matthew D Hendel (math) 15-June-2000

Revision History:

--*/

#pragma once

typedef
VOID
(*PSTOR_IO_GATEWAY_BUSY_ROUTINE)(
	IN PVOID Context,
	IN LONG OutstandingRequests,
	OUT PLONG HighWaterMark,
	OUT PLONG LowWaterMark
	);

typedef struct _STOR_IO_GATEWAY {

    //
    // Spinlock that protects the data in the adapter queue.
    //
    // PERF NOTE: This lock is the only adapter-wide lock
    // acquired in the IO path. Therefore, it is probably
    // the hottest lock in raidport. We should investigate
    // to accomplish this functionality without locking or
    // using only interlocked operations.
    //
    
    KSPIN_LOCK Lock;

    //
    // At the high water mark we should stop submitting requests to
    // the adapter.
    //
    // Protected by: Lock
    //
    
    LONG HighWaterMark;

    //
    // If we are busy and have dropped below the low water mark, we
    // can continue submitting requests to the unit queue.
    //
    // Protected by: Lock
    //
    
    LONG LowWaterMark;

    //
    // The number of outstanding requests the adapter is currently
    // processing.
    //
    // Protected by: Lock
    //
    
    LONG Outstanding;

    //
	// Count of how many times the gateway has been busied.
    //
    // Protected by: Lock
    //
    
	LONG BusyCount;

	//
	// Count of how many time the gateway has been paused.
	//

	LONG PauseCount;

    //
    // Information about how elements are queued to the device when it's
    // busy.
    //

	PSTOR_IO_GATEWAY_BUSY_ROUTINE BusyRoutine;

	//
	// Context information for the busy routine.
	//
	
	PVOID BusyContext;

	//
	// If non-NULL points to an event that should be set when the queue is
	// empty.
	//
	
	PKEVENT EmptyEvent;

} STOR_IO_GATEWAY, *PSTOR_IO_GATEWAY;



VOID
StorCreateIoGateway(
	IN PSTOR_IO_GATEWAY Gateway,
	IN PSTOR_IO_GATEWAY_BUSY_ROUTINE BusyRoutine,
	IN PVOID BusyContext
    );

BOOLEAN
StorSubmitIoGatewayItem(
    IN PSTOR_IO_GATEWAY Gateway
    );

BOOLEAN
StorRemoveIoGatewayItem(
    IN PSTOR_IO_GATEWAY Gateway
    );

//
// Busy processing on the gateway.
//

VOID
StorBusyIoGateway(
    IN PSTOR_IO_GATEWAY Gateway
    );

VOID
StorBusyIoGatewayEx(
	IN PSTOR_IO_GATEWAY Gateway,
	IN ULONG RequestsToComplete
	);

BOOLEAN
StorIsIoGatewayBusy(
    IN PSTOR_IO_GATEWAY Queue
    );

VOID
StorReadyIoGateway(
	IN PSTOR_IO_GATEWAY Gateway
	);

LONG
StorPauseIoGateway(
	IN PSTOR_IO_GATEWAY Gateway
	);

BOOLEAN
StorIsIoGatewayPaused(
	IN PSTOR_IO_GATEWAY Gateway
	);

LONG
StorResumeIoGateway(
	IN PSTOR_IO_GATEWAY Gateway
	);
	
VOID
StorSetIoGatewayEmptyEvent(
	IN PSTOR_IO_GATEWAY Gateway,
	IN PKEVENT Event
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\adapter.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    adapter.h
    
Abstract:

    This file contains the definitions and operations for the RAID_ADPATER
    object.
    
Author:

    Matthew D Hendel (math) 19-Apr-2000.

Revision History:

--*/

#pragma once


C_ASSERT (sizeof (LONG) == sizeof (DEVICE_STATE));

//
// Definition of adapter deferred queue elements.
//

typedef enum _RAID_DEFERRED_TYPE {
    RaidDeferredTimerRequest    = 0x01,
    RaidDeferredError           = 0x02,
    RaidDeferredPause           = 0x03,
    RaidDeferredResume          = 0x04,
    RaidDeferredPauseDevice     = 0x05,
    RaidDeferredResumeDevice    = 0x06,
    RaidDeferredBusy            = 0x07,
    RaidDeferredReady           = 0x08,
    RaidDeferredDeviceBusy      = 0x09,
    RaidDeferredDeviceReady     = 0x0A
} RAID_DEFERRED_TYPE;


typedef struct _RAID_DEFERRED_ELEMENT {

    RAID_DEFERRED_HEADER Header;
    RAID_DEFERRED_TYPE Type;

    //
    // SCSI Target address for this request. Will not be necessary for
    // all requests. Some requests require Lun field to be filled in,
    // others do not.
    //

    RAID_ADDRESS Address;
    
    union {
        struct {
            PHW_INTERRUPT HwTimerRoutine;
            ULONG Timeout;
        } Timer;

        struct {
            PSCSI_REQUEST_BLOCK Srb;
            ULONG ErrorCode;
            ULONG UniqueId;
        } Error;

        struct {
            ULONG Timeout;
        } Pause;

        //
        // Resume doesn't require any parameters.
        //

        struct {
            ULONG Timeout;
        } PauseDevice;

        //
        // ResumeDevice doesn't require any parameters.
        //

        struct {
            ULONG RequestsToComplete;
        } Busy;

        //
        // Ready doesn't require any parameteres.
        //

        struct {
            ULONG RequestsToComplete;
        } DeviceBusy;

        //
        // DeviceReady doesn't require any parameters.
        //
    };
} RAID_DEFERRED_ELEMENT, *PRAID_DEFERRED_ELEMENT;


typedef struct _RAID_UNIT_LIST {
    
    //
    // Executive resource to protect the unit list.
    //
    // Protected by: RemoveLock
    //

    KSPIN_LOCK Lock;

    //
    // List of logical units attached to this adapter.
    //
    // Protected by: UnitList.Lock AND AdapterIoCount.
    // The list can only be modified when the adapter
    // Outstanding Io count is at zero. This is 
    // necessary because the get logical unit function
    // which can be called from the ISR needs to be
    // able to walk this list.
    //
    // BUGUBG: At this time we are not explicitly
    // enforcing this. We need to fix this before PnP
    // works reliably.
    //

    LIST_ENTRY List;

    STOR_DICTIONARY Dictionary;

    //
    // Count of elements on the unit list.
    //
    // Protected by: UnitList.Lock

    ULONG Count;

} RAID_UNIT_LIST, *PRAID_UNIT_LIST;


//
// Registry parameters for the adapter.
//

typedef struct _RAID_ADAPTER_PARAMETERS {

//    ULONG MaximumSgList;

    ULONG NumberOfHbaRequests;

    STORAGE_BUS_TYPE BusType;

    ULONG UncachedExtAlignment;

    ULONG64 MaximumUncachedAddress;

    ULONG64 MinimumUncachedAddress;

} RAID_ADAPTER_PARAMETERS, *PRAID_ADAPTER_PARAMETERS;

    
//
// The adapter extension contains everything necessary about
// a host adapter.
//

typedef struct _RAID_ADAPTER_EXTENSION {

    //
    // The device type for this device. Either RaidAdapterObject or
    // RaidControllerObject.
    //
    // Protected by: RemoveLock
    //
    
    RAID_OBJECT_TYPE ObjectType;

    //
    // Back pointer to the the DeviceObject this Extension is for.
    //
    // Protected by: RemoveLock
    //
    
    PDEVICE_OBJECT DeviceObject;

    //
    // Back pointer to the driver that owns this adapter.
    //
    // Protected by: RemoveLock
    //

    PRAID_DRIVER_EXTENSION Driver;

    //
    // Pointer to the lower level device object.
    //
    // Protected by: RemoveLock
    //
    
    PDEVICE_OBJECT LowerDeviceObject;

    //
    // The Physical Device Object associated with this FDO.
    //
    // Protected by: RemoveLock
    //

    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // The name of this device.
    //
    // Protected by: Read only.
    //
    
    UNICODE_STRING DeviceName;

    //
    // The port number of this device.
    //

    ULONG PortNumber;
    
    //
    // Doubly linked list of adapters owned by this driver.
    //
    // Protected by: Driver's AdapterList lock. Never
    // accessed by the adapter.
    //

    LIST_ENTRY NextAdapter;
    
    //
    // Slow lock for any data not protected by another
    // lock.
    //
    // NB: The slow lock should not be used to access
    // data on the common read/write io path. A separate
    // lock should be used for that.
    //
    
    KSPIN_LOCK SlowLock;

    //
    // The PnP Device State
    //
    // Protected by: Interlocked access
    //

    DEVICE_STATE DeviceState;

    //
    // Count of devices that are in the paging/hiber/dump path.
    // We use a single count for all three paging, hiber and dump,
    // since there is no need (at this time) to distinguish between
    // the three.
    //
    // Protected by: Interlocked access
    //

    ULONG PagingPathCount;
    ULONG CrashDumpPathCount;
    ULONG HiberPathCount;

    //
    // Flags for the adapter.
    //

    struct {

        //
        // Have we called the miniport's HwInitialize routine yet?
        //
        // Protected by: not addressed by MP.
        //

        BOOLEAN InitializedMiniport : 1;

        //
        // Has the miniport been initialized for WMI.
        //

        BOOLEAN WmiMiniPortInitialized : 1;


        //
        // Has WMI been initialized for this device object?
        //
        
        BOOLEAN WmiInitialized : 1;
        

#if 0
        //
        // Has a DPC been requested.
        //
        
        BOOLEAN DpcRequested;
#endif

        //
        // This flag is set if the miniport should invalidate it's bus
        // relations at the next opportunity. Note, this is NOT the same
        // thing as rescanning the bus (see RescanBus flag below).
        // Invalidating the bus relations and rescanning the bus are
        // two independant operations. Since IoInvalidateDeviceRelations
        // can be called at IRQL <= DISPATCH_LEVEL, this will only
        // be set during an operation at IRQL > DISPATCH_LEVEL to
        // request an invalidation of bus relations after we drop IRQL.
        //
        // Protected by: All architectures can perform byte assignment
        //               in an MP safe manner.
        //

        BOOLEAN InvalidateBusRelations;

        //
        // This flag is set when we need to physically rescan the bus. Do not
        // confuse this flag with the InvalidateBusRelations flag (see above).
        //
        // Protected by: All architectures can perform byte assignment
        //               in an MP safe manner.
        //

        BOOLEAN RescanBus;

        //
        // Are interrupts enabled for this adapter?
        //
        // Protected by: All architectures can perform byte assignment
        //               in an MP safe manner.
        //
        
        BOOLEAN InterruptsEnabled;

    } Flags;
    
    RAID_UNIT_LIST UnitList;
    
    //
    // This is the list of XRBs that the miniport has completed, but that
    // have not yet had the dpc run for them.
    //
    // Protected by: Interlocked access.
    //
    
    SLIST_HEADER CompletedList;

    //
    // Fields specific to PnP Device Removal.
    //
    // Protected by: RemoveLock
    //

    IO_REMOVE_LOCK RemoveLock;

    //
    // Information about the current power state.
    //
    //
    
    RAID_POWER_STATE Power;

    //
    // PnP assigned resources.
    //
    // Protected by: RemoveLock
    //
    
    RAID_RESOURCE_LIST ResourceList;

    //
    // Miniport object
    //
    // Protected by: RemoveLock
    //
    
    RAID_MINIPORT Miniport;

    //
    // Object representing a bus interface.
    //
    // Protected by: RemoveLock
    //
    
    RAID_BUS_INTERFACE Bus;

    //
    // Interrupt object
    //
    // Protected by: RemoveLock
    //
    
    PKINTERRUPT Interrupt;

    //
    // Interrupt Level
    //
    // Protected by: RemoveLock
    //

    ULONG InterruptIrql;
    
    //
    // When we are operating in full duplex mode, we allow IO
    // to be initiated at the same time as we are receiving
    // interrupts that IO has completed. In half duplex mode,
    // requests to the miniport's StartIo routine are protected
    // by the Interrupt spinlock. In full duplex StartIo is
    // protected by the StartIoLock and interrupts are protected
    // by the interrupt lock. Note that in half duplex mode, the
    // StartIoLock is never used, although it is always
    // initialized.
    //
    // Protected by: RemoveLock
    //

    KSPIN_LOCK StartIoLock;

    //
    // See discussion of StartIoLock above.
    //
    // Protected by: RemoveLock
    
    STOR_SYNCHRONIZATION_MODEL IoModel;
    
    //
    // DMA Adapter for this Controller.
    //
    //
    
    RAID_DMA_ADAPTER Dma;

    //
    // Uncached extension memory region.
    //
    
    RAID_MEMORY_REGION UncachedExtension;

    //
    // This is the real bus number for the device. This is necessary to
    // we can build the configuration information structure that gets
    // passed to crashdump and hiber.
    //
    // Protected by: Read only.
    
    ULONG BusNumber;

    //
    // This is the real slot number (see above discussion about bus number).
    //
    // Protected by: Read only.
    
    ULONG SlotNumber;


    //
    // List of mapped addresses used by the adapter. These are allocated
    // by calls to GetDeviceBase and freed by calls to FreeDeviceBase.
    //
    // Protected by: 
    //
    // NOTE: If we can have several raidport adapters processing a start
    // device IRP at the same time, then this needs to be protected.
    // Otherwise, it is protected by the fact that multiple start device
    // irps will not be issued at the same time.
    //

    PMAPPED_ADDRESS MappedAddressList;


    //
    // The IO gateway manages the state between the differet per-unit
    // device queues.
    //
    // Protected by: Interlocked access.
    //
    
    STOR_IO_GATEWAY Gateway;

    //
    // DeferredQueue defers requests made at DPC level that can only be
    // executed at dispatch level for execution later. It is very similiar
    // to a DPC queue, but allows multiple entries.
    //
    // Protected by: Read only.
    //

    RAID_DEFERRED_QUEUE DeferredQueue;

    struct {

        RAID_DEFERRED_ELEMENT Timer;

    } DeferredList;

    //
    // Queued WMI request items.
    //
    
    RAID_DEFERRED_QUEUE WmiDeferredQueue;

    //
    // Timer DPC for miniport timer.
    //
    
    KDPC TimerDpc;

    //
    // Timer for miniport.
    //
    
    KTIMER Timer;

    //
    // Pause timer DPC routine.
    //

    KDPC PauseTimerDpc;

    //
    // Pause timer.
    //
    
    KTIMER PauseTimer;
    
    //
    // SCSI HW timer routine. Only one timer routine may be outstanding
    // at a time.
    //
    
    PHW_INTERRUPT HwTimerRoutine;

    //
    // DPC for completion requests.
    //
    
    KDPC CompletionDpc;

    //
    // DPC for when the miniport issues us a BusChangeDetected.
    //
    
    KDPC BusChangeDpc;


    //
    // Interface name for PNP.
    //
    // Protected by: PNP. Only accessed during creation and deletion
    // of adapter.
    //

    UNICODE_STRING PnpInterfaceName;

#if DBG && 0

    //
    // Address of the StartIo lock owner. Used for debugging
    // deadlocks on the StartIo lock.
    //
    // Synchronized by: StartIo lock.
    //

    PVOID StartIoLockOwner;

#endif

    //
    // Numeric identifier for each instance of a given adapter.  This value
    // is used to locate device specific parameters for the adapter in the
    // registry.
    //

    ULONG AdapterNumber;

    //
    // This is an opaque blob of parameter information stored in the registry 
    // on a per-device basis.  We supply this information to the miniport when
    // we call its HwFindAdapter routine.
    //
    
    PVOID DriverParameters;

    PORT_REGISTRY_INFO RegistryInfo;

    //
    // Specifies how long we wait for the link to come back up after we are
    // notified by the miniport that the link is down.
    //

    ULONG LinkDownTimeoutValue;

    //
    // Indicates whether the link is down or up.
    //

    ULONG LinkUp;

    //
    // Array of handles to Bus keys in the device map.
    //
    
    HANDLE BusKeyArray[8];

    //
    // If non-zero, implies we are processing deferred items for the adapter
    // queue. Otherwise, nobody is processing deferred itesms for the HBA.
    //
    // Protected by: interlocked access.
    //
    
    LONG ProcessingDeferredItems;

    //
    // Default timeout for I/O initiated by the port driver, e.g., inquiry
    // and report luns.
    //

    ULONG DefaultTimeout;

    //
    // Timer and DPC for the reset hold period.
    //
    
    KTIMER ResetHoldTimer;
    
    KDPC ResetHoldDpc;

    //
    // Timestamp of the last time we scanned the bus.
    //
    
    LARGE_INTEGER LastScanTime;
    

    RAID_ADAPTER_PARAMETERS Parameters;
    
} RAID_ADAPTER_EXTENSION, *PRAID_ADAPTER_EXTENSION;





typedef struct _RAID_WMI_DEFERRED_ELEMENT {

    RAID_DEFERRED_HEADER Header;

    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    
    WNODE_EVENT_ITEM WnodeEventItem;
    UCHAR Buffer[WMI_MINIPORT_EVENT_ITEM_MAX_SIZE - sizeof(WNODE_EVENT_ITEM)];
        
} RAID_WMI_DEFERRED_ELEMENT, *PRAID_WMI_DEFERRED_ELEMENT;


//
// The deferred queue depth should be large enough to hold one of
// each type of deferred item. Since have per-unit items AND per adapter
// items in the queue, this should also be increased for each unit
// that is attached to the adapter.
//
// NB: It may be smarter to have per-unit deferred queues as well
// as per-adapter deferred queues.
//

#define ADAPTER_DEFERRED_QUEUE_DEPTH (10)


//
// Control list structure, used for querying the supported adapter types
// from the miniport. Note: this structure must match the
// SCSI_SUPPORTED_TYPE_LIST structure.
//

typedef struct _ADAPTER_CONTROL_LIST {
    ULONG MaxControlType;
    BOOLEAN SupportedTypeList[ScsiAdapterControlMax + 1];
} ADAPTER_CONTROL_LIST, *PADAPTER_CONTROL_LIST;

//
// Verify that the ADAPTER_CONTROL_LIST structure matches the
// SCSI_SUPPORTED_CONTROL_TYPE_LIST structure.
//

C_ASSERT (FIELD_OFFSET (ADAPTER_CONTROL_LIST, SupportedTypeList) ==
          FIELD_OFFSET (SCSI_SUPPORTED_CONTROL_TYPE_LIST, SupportedTypeList));

//
// Adapter operations
//

//
// Adapter creation and destruction functions
//


VOID
RaidCreateAdapter(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

VOID
RaidDeleteAdapter(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidInitializeAdapter(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN PRAID_DRIVER_EXTENSION Driver,
    IN PDEVICE_OBJECT LowerDeviceObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PUNICODE_STRING DeviceName,
    IN ULONG AdapterNumber
    );

//
// Adapter IRP handler functions
//


//
// Create, Close
//

NTSTATUS
RaidAdapterCreateIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterCloseIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

//
// Device Control
//

NTSTATUS
RaidAdapterDeviceControlIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterScsiIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

//
// Adapter PnP Functions
//


NTSTATUS
RaidAdapterPnpIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterQueryDeviceRelationsIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterStartDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterConfigureResources(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PCM_RESOURCE_LIST AllocatedResources,
    IN PCM_RESOURCE_LIST TranslatedResources
    );

NTSTATUS
RaidAdapterInitializeWmi(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidAdapterStopDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterStartMiniport(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );
    
NTSTATUS
RaidAdapaterRemoveDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterCompleteInitialization(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidAdapterQueryStopDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterCancelStopDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterQueryRemoveDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterCancelRemoveDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterSurpriseRemovalIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterRemoveDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterQueryIdIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterQueryPnpDeviceStateIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterDeviceUsageNotificationIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterFilterResourceRequirementsIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );
    
NTSTATUS
RaidAdapterPnpUnknownIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );


//
// Ioctl handlers
//

//
// Storage Ioctls
//

NTSTATUS
RaidAdapterStorageQueryPropertyIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterStorageResetBusIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterStorageBreakReservationIoctl(
    IN PRAID_ADAPTER_EXTENSION Adpater,
    IN PIRP Irp
    );

//
// Scsi Ioctls
//

NTSTATUS
RaidAdapterScsiMiniportIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterScsiGetCapabilitiesIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterScsiRescanBusIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterScsiPassThroughIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP PassThroughIrp
    );

NTSTATUS
RaidAdapterScsiPassThroughDirectIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP PassThroughIrp
    );

NTSTATUS
RaidAdapterScsiGetInquiryDataIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

//
// Adapter Power Functions
//

NTSTATUS
RaidAdapterPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterQueryPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterSetPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdatperUnknownPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );


//
// Other (non-IRP handler) functions
//

VOID
RaidAdapterRequestComplete(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    );

NTSTATUS
RaidAdapterExecuteXrb(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    );

NTSTATUS
RaidGetStorageAdapterProperty(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PSTORAGE_ADAPTER_DESCRIPTOR Descriptor,
    IN OUT PSIZE_T DescriptorLength
    );

ULONG
RaidGetMaximumLun(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

ULONG
RaidGetSrbExtensionSize(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

ULONG
RaidGetMaximumTargetId(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

typedef
NTSTATUS
(*PADAPTER_ENUMERATION_ROUTINE)(
    IN PVOID Context,
    IN RAID_ADDRESS Address
    );

NTSTATUS
RaidAdapterEnumerateBus(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PADAPTER_ENUMERATION_ROUTINE EnumRoutine,
    IN PVOID Context
    );
//
// Private adapter operations
//

NTSTATUS
RaidAdapterRescanBus(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );
    
NTSTATUS
RaidpBuildAdapterBusRelations(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    OUT PDEVICE_RELATIONS * DeviceRelationsPointer
    );

NTSTATUS
RaidAdapterCreateUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN PINQUIRYDATA InquiryData,
    IN PVOID UnitExtension,
    OUT PRAID_UNIT_EXTENSION * UnitBuffer OPTIONAL
    );

VOID
RaidpAdapterDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
RaidPauseTimerDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    );
    
VOID
RaidpAdapterTimerDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    );

VOID
RaidResetHoldDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    );

PHW_INITIALIZATION_DATA
RaidpFindAdapterInitData(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidAdaterRegisterDeviceInterface(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

VOID
RaidAdapterDisableDeviceInterface(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

BOOLEAN
RaidpAdapterInterruptRoutine(
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    );

ULONG
RaidpAdapterQueryBusNumber(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidAdapterSetSystemPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterSetDevicePowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterPowerDownDevice(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterPowerUpDevice(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterPowerUpDeviceCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
RaidpAdapterEnterD3Completion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP SystemPowerIrp,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
RaidpAdapterRequestTimer(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PHW_INTERRUPT HwTimerRoutine,
    IN ULONG Timeout
    );
    
VOID
RaidAdapterRestartQueues(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

PRAID_UNIT_EXTENSION
RaidAdapterFindUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN RAID_ADDRESS Address
    );

VOID
RaidAdapterDeferredRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PRAID_DEFERRED_HEADER Item
    );

VOID
RaidAdapterRequestTimer(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PHW_INTERRUPT HwTimerRoutine,
    IN ULONG Timeout
    );

BOOLEAN
RaidAdapterRequestTimerDeferred(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PHW_INTERRUPT HwTimerRoutine,
    IN ULONG Timeout
    );

VOID
RaidAdapterLogIoErrorDeferred(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    );

NTSTATUS
RaidAdapterMapBuffers(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

VOID
RaidBackOffBusyGateway(
    IN PVOID Context,
    IN LONG OutstandingRequests,
    IN OUT PLONG HighWaterMark,
    IN OUT PLONG LowWaterMark
    );
VOID
RaidAdapterResumeGateway(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidAdapterRaiseIrqlAndExecuteXrb(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    );

NTSTATUS
RaidAdapterResetBus(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN UCHAR PathId
    );

VOID
RaidCompletionDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    );

VOID
RaidAdapterInsertUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaidAdapterAddUnitToTable(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaidAdapterInitializeRegistry(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidAdapterStop(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidAdapterRestart(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidAdapterCreateDevmapEntry(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidAdapterRemoveDevmapEntry(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

HANDLE
RaidAdapterGetBusKey(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN ULONG BusId
    );
VOID
RaidAdapterProcessDeferredItems(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidAdapterPassThrough(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP PassThroughIrp,
    IN BOOLEAN Direct
    );

NTSTATUS
RaidAdapterStopAdapter(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

typedef
NTSTATUS
(*PADAPTER_REMOVE_CHILD_ROUTINE)(
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaidAdapterRemoveChildren(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PADAPTER_REMOVE_CHILD_ROUTINE RemoveRoutine OPTIONAL
    );
    
VOID
RaidAdapterDeleteChildren(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

VOID
RaidAdapterMarkChildrenMissing(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

BOOLEAN
RaidAdapterSetPauseTimer(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PKTIMER Timer,
    IN PKDPC Dpc,
    IN ULONG TimeoutInSeconds
    );

VOID
RaidAdapterBusChangeDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\adapter.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adapter.c

Abstract:

    This module implements the adapter routines for the raidport device
    driver.

Author:

    Matthew D. Hendel (math) 06-April-2000

Environment:

    Kernel mode.

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaidInitializeAdapter)
#pragma alloc_text(PAGE, RaidpFindAdapterInitData)
#pragma alloc_text(PAGE, RaidpAdapterQueryBusNumber)
#pragma alloc_text(PAGE, RaidAdapterCreateIrp)
#pragma alloc_text(PAGE, RaidAdapterCloseIrp)
#pragma alloc_text(PAGE, RaidAdapterDeviceControlIrp)
#pragma alloc_text(PAGE, RaidAdapterPnpIrp)
#pragma alloc_text(PAGE, RaidAdapterQueryDeviceRelationsIrp)
#pragma alloc_text(PAGE, RaidAdapterStartDeviceIrp)
#pragma alloc_text(PAGE, RaidAdapterStopDeviceIrp)
#pragma alloc_text(PAGE, RaidAdapterRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaidAdapterQueryStopDeviceIrp)
#pragma alloc_text(PAGE, RaidAdapterCancelStopDeviceIrp)
#pragma alloc_text(PAGE, RaidAdapterQueryRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaidAdapterCancelRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaidAdapterSurpriseRemovalIrp)
#pragma alloc_text(PAGE, RaidAdapterQueryPnpDeviceStateIrp)
#pragma alloc_text(PAGE, RaidAdapterScsiIrp)
#pragma alloc_text(PAGE, RaidAdapterStorageQueryPropertyIoctl)
#pragma alloc_text(PAGE, RaidGetStorageAdapterProperty)
#pragma alloc_text(PAGE, RaidAdapterPassThrough)
#endif // ALLOC_PRAGMA


//
// Globals
//

#if DBG

//
// For testing purposes to simulate dropping requests. To start, set
// DropRequestRate to non-zero value, then every DropRequestRate-th
// request will be dropped.
//

LONG DropRequest = 0;
LONG DropRequestRate = 0;

#endif

//
// Routines
//

VOID
RaidCreateAdapter(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Initialize the adapter object to a known state.

Arguments:

    Adapter - The adapter to create.

Return Value:

    None.

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    RtlZeroMemory (Adapter, sizeof (*Adapter));
    Adapter->ObjectType = RaidAdapterObject;

    InitializeListHead (&Adapter->UnitList.List);
    InitializeSListHead (&Adapter->CompletedList);

    Status = StorCreateDictionary (&Adapter->UnitList.Dictionary,
                                   20,
                                   NonPagedPool,
                                   RaidGetKeyFromUnit,
                                   NULL,
                                   NULL);
                             
    if (!NT_SUCCESS (Status)) {
        return;
    }
                
    KeInitializeSpinLock (&Adapter->UnitList.Lock);
    IoInitializeRemoveLock (&Adapter->RemoveLock,
                            REMLOCK_TAG,
                            REMLOCK_MAX_WAIT,
                            REMLOCK_HIGH_MARK);
    

    RaCreateMiniport (&Adapter->Miniport);
    RaidCreateDma (&Adapter->Dma);
    RaCreatePower (&Adapter->Power);
    RaidCreateResourceList (&Adapter->ResourceList);
    RaCreateBus (&Adapter->Bus);
    RaidCreateRegion (&Adapter->UncachedExtension);

    StorCreateIoGateway (&Adapter->Gateway,
                         RaidBackOffBusyGateway,
                         NULL);

    RaidCreateDeferredQueue (&Adapter->DeferredQueue);
    RaidCreateDeferredQueue (&Adapter->WmiDeferredQueue);
    RaidInitializeDeferredItem (&Adapter->DeferredList.Timer.Header);

    //
    // Initialize timers here, so we may cancel them in the delete
    // routine.
    //
    
    KeInitializeTimer (&Adapter->Timer);
    KeInitializeTimer (&Adapter->PauseTimer);
    KeInitializeTimer (&Adapter->ResetHoldTimer);

    //
    // Initialize the PNP device state
    //
    
    Adapter->DeviceState = DeviceStateStopped;
    
    //
    // Initialize RescanBus to TRUE so we rescan the bus when get the
    // initial query device relations IRP.
    //
    
    Adapter->Flags.RescanBus = TRUE;
}


VOID
RaidDeleteAdapter(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Destroy the adapter object and deallocate any resources associated
    with the adapter.

Arguments:

    Adapter - The adapter to destroy.

Return Value:

    None.

--*/
{
    //
    // All logical units should have been removed from the adapter's unit
    // list before the adapter's delete routine is called. Verify this
    // for checked builds.
    //
      
    ASSERT (IsListEmpty (&Adapter->UnitList.List));
    ASSERT (Adapter->UnitList.Count == 0);
    ASSERT (StorGetDictionaryCount (&Adapter->UnitList.Dictionary) == 0);

    //
    // These resources are owned by somebody else, so do not delete them.
    // Just NULL them out.
    //

    Adapter->DeviceObject = NULL;
    Adapter->Driver = NULL;
    Adapter->LowerDeviceObject = NULL;
    Adapter->PhysicalDeviceObject = NULL;

    //
    // Delete all resources we actually own.
    //

    PortMiniportRegistryDestroy (&Adapter->RegistryInfo); 
    RaidDeleteResourceList (&Adapter->ResourceList);
    RaDeleteMiniport (&Adapter->Miniport);

    //
    // Delete the uncached extension region.
    //
    
    if (RaidIsRegionInitialized (&Adapter->UncachedExtension)) {
        RaidDmaFreeUncachedExtension (&Adapter->Dma,
                                      &Adapter->UncachedExtension);
        RaidDeleteRegion (&Adapter->UncachedExtension);
    }

    RaidDeleteDma (&Adapter->Dma);
    RaDeletePower (&Adapter->Power);
    RaDeleteBus (&Adapter->Bus);

    RaidDeleteDeferredQueue (&Adapter->DeferredQueue);
    RaidDeleteDeferredQueue (&Adapter->WmiDeferredQueue);

    Adapter->ObjectType = RaidUnknownObject;

    if (Adapter->DriverParameters != NULL) {
        PortFreeDriverParameters (Adapter->DriverParameters);
        Adapter->DriverParameters = NULL;
    }

    //
    // Free PNP interface name.
    //
    
    RtlFreeUnicodeString (&Adapter->PnpInterfaceName);
}


NTSTATUS
RaidInitializeAdapter(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN PRAID_DRIVER_EXTENSION Driver,
    IN PDEVICE_OBJECT LowerDeviceObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PUNICODE_STRING DeviceName,
    IN ULONG AdapterNumber
    )
/*++

Routine Description:

    Initialize the adapter.

Arguments:

    Adapter - The adapter to initialize.

    DeviceObject - The device object who owns this
        Adapter Extension.

    Driver - The parent DriverObject for this Adapter.

    LowerDeviceObject -

    PhysicalDeviceObject -

    DeviceName - 

    AdapterNumber -

Return Value:

    None.

--*/
{
    ULONG Flags;
    PORT_ADAPTER_REGISTRY_VALUES RegistryValues;
    PRAID_ADAPTER_PARAMETERS Parameters;

    
    PAGED_CODE ();
    ASSERT (IsAdapter (DeviceObject));

    ASSERT_ADAPTER (Adapter);
    ASSERT (DeviceObject != NULL);
    ASSERT (Driver != NULL);
    ASSERT (LowerDeviceObject != NULL);
    ASSERT (PhysicalDeviceObject != NULL);
    
    ASSERT (Adapter->DeviceObject == NULL);
    ASSERT (Adapter->Driver == NULL);
    ASSERT (Adapter->PhysicalDeviceObject == NULL);
    ASSERT (Adapter->LowerDeviceObject == NULL);
    ASSERT (DeviceObject->DeviceExtension == Adapter);

    Adapter->DeviceObject = DeviceObject;
    Adapter->Driver = Driver;
    Adapter->PhysicalDeviceObject = PhysicalDeviceObject;
    Adapter->LowerDeviceObject = LowerDeviceObject;
    Adapter->DeviceName = *DeviceName;
    Adapter->AdapterNumber = AdapterNumber;
    Adapter->LinkUp = TRUE;

    //
    // Retrieve miniport's parameters.
    //

    PortGetDriverParameters (&Adapter->Driver->RegistryPath,
                             AdapterNumber,
                             &Adapter->DriverParameters);

    //
    // Retrieve the default link down timeout value from the registry.
    //

    Adapter->LinkDownTimeoutValue = DEFAULT_LINK_TIMEOUT;

    PortGetLinkTimeoutValue (&Adapter->Driver->RegistryPath,
                             AdapterNumber,
                             &Adapter->LinkDownTimeoutValue);

    Adapter->DefaultTimeout = DEFAULT_IO_TIMEOUT;
    
    PortGetDiskTimeoutValue (&Adapter->DefaultTimeout);

    Flags = MAXIMUM_LOGICAL_UNIT   |
            MAXIMUM_UCX_ADDRESS    |
            MINIMUM_UCX_ADDRESS    |
            NUMBER_OF_REQUESTS     |
            UNCACHED_EXT_ALIGNMENT;

    Parameters = &Adapter->Parameters;

    //
    // Initialize default parameters. NB: Although the parameters refer to
    // "common buffer base" these are actually uncached extension parameters.
    //

    RtlZeroMemory (&RegistryValues, sizeof (PORT_ADAPTER_REGISTRY_VALUES));
    
    RegistryValues.MaxLuCount               = 255;
    RegistryValues.MinimumCommonBufferBase  = LARGE (0x0000000000000000);
    RegistryValues.MaximumCommonBufferBase  = LARGE (0x00000000FFFFFFFF);
    RegistryValues.UncachedExtAlignment     = 0;
    RegistryValues.NumberOfRequests         = 0xFFFFFFFF;


    PortGetRegistrySettings (&Adapter->Driver->RegistryPath,
                             AdapterNumber,
                             &RegistryValues,
                             Flags);

    Parameters->MaximumUncachedAddress  = RegistryValues.MaximumCommonBufferBase.QuadPart;
    Parameters->MinimumUncachedAddress  = RegistryValues.MinimumCommonBufferBase.QuadPart;
    Parameters->NumberOfHbaRequests     = RegistryValues.NumberOfRequests;
    Parameters->UncachedExtAlignment    = RegistryValues.UncachedExtAlignment;
    Parameters->BusType                 = BusTypeFibre;

    return STATUS_SUCCESS;
}


PHW_INITIALIZATION_DATA
RaidpFindAdapterInitData(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Find the HW_INITIALIZATION_DATA associated with this
    adapter.

Arguments:

    Adapter - The adapter whose HwInitData needs to be found.

Return Value:

    A pointer to the HW_INITIALIZATION_DATA for this adapter
    on success.

    NULL on failure.

--*/
{
    INTERFACE_TYPE BusInterface;
    PHW_INITIALIZATION_DATA HwInitializationData;
    
    PAGED_CODE ();

    HwInitializationData = NULL;
    BusInterface = RaGetBusInterface (Adapter->PhysicalDeviceObject);

    //
    // If there was no matching bus interface type, default to internal
    // bus type. This allows miniports that have no hardware (iSCSI) to
    // specify an interface type of Internal and still work.
    //
    
    if (BusInterface == InterfaceTypeUndefined) {
        BusInterface = Internal;
    }
    
    HwInitializationData =
        RaFindDriverInitData (Adapter->Driver, BusInterface);

    return HwInitializationData;
}


NTSTATUS
RaidAdapterCreateDevmapEntry(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Create an SCSI devicemap entry in the Hardware\SCSI key.

Arguments:

    Adapter - Adapter to create devmap entry for.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    HANDLE MapKey;
    HANDLE AdapterKey;
    ULONG BusCount;
    ULONG BusId;
    UNICODE_STRING DriverName;
    PPORT_CONFIGURATION_INFORMATION Config;

    PAGED_CODE();

    AdapterKey = (HANDLE) -1;
    MapKey = (HANDLE) -1;
    Status = PortOpenMapKey (&MapKey);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    RaidDriverGetName (Adapter->Driver, &DriverName);

    Status = PortMapBuildAdapterEntry (MapKey,
                                    Adapter->PortNumber,
                                    Adapter->InterruptIrql,
                                    0,
                                    TRUE,
                                    &DriverName,
                                    NULL,
                                    &AdapterKey);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    BusCount = RiGetNumberOfBuses (Adapter);
    Config = RaidGetPortConfigurationInformation (Adapter);
    
    for (BusId = 0; BusId < BusCount; BusId++) {

        Status = PortMapBuildBusEntry (AdapterKey,
                                       BusId,
                                       (UCHAR)Config->InitiatorBusId [BusId],
                                       &Adapter->BusKeyArray [BusId]);
    }


done:

    if (AdapterKey != (HANDLE) -1) {
        ZwClose (AdapterKey);
    }

    if (MapKey != (HANDLE) -1) {
        ZwClose (MapKey);
    }
    
    return STATUS_SUCCESS;
}


NTSTATUS
RaidAdapterDeleteDevmapEntry(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Delete the devmap entry created by RaidAdapterCreateDevmapEntry().

Arguments:

    Adapter - Adapter to delete devmap entry for.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG BusCount;
    ULONG BusId;
    
    PAGED_CODE();

    BusCount = RiGetNumberOfBuses (Adapter);

    //
    // Close the BusKeyArray handles.
    //
    
    for (BusId = 0; BusId < BusCount; BusId++) {
        ZwClose (Adapter->BusKeyArray [BusId]);
    }

    PortMapDeleteAdapterEntry (Adapter->PortNumber);

    return STATUS_SUCCESS;
}

NTSTATUS
RaidAdapterRegisterDeviceInterface(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Register the adapter's device interface.

Arguments:

    Adapter - Supplies the adapter to register the device interface for.

Return Value:

    NTSTATUS code.

Bugs:

    Should log an error if this fails.

--*/
{
    NTSTATUS Status;
    
    PAGED_CODE();
    
    Status = IoRegisterDeviceInterface (Adapter->PhysicalDeviceObject,
                                        &StoragePortClassGuid,
                                        NULL,
                                        &Adapter->PnpInterfaceName);

    Status = IoSetDeviceInterfaceState (&Adapter->PnpInterfaceName, TRUE);

    if (!NT_SUCCESS (Status)) {
        RtlFreeUnicodeString (&Adapter->PnpInterfaceName);
    }

    RaidAdapterCreateDevmapEntry (Adapter);

    return STATUS_SUCCESS;
}

VOID
RaidAdapterDisableDeviceInterface(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Disable an interface previously registerd by the
    RaidAdapterRegisterDeviceInterface routine.

Arguments:

    Adapter - Supplies the adapter to disable the device interface for.

Return Value:

    None.

--*/
{
    PAGED_CODE();
    
    //
    // Delete the pnp interface, if present.
    //
    
    if (Adapter->PnpInterfaceName.Buffer != NULL) {
        IoSetDeviceInterfaceState (&Adapter->PnpInterfaceName, FALSE);
    }

    //
    // Remove the device map entry.
    //
    
    RaidAdapterDeleteDevmapEntry (Adapter);


    //
    // Disable WMI support, if it was enabled.
    //
    
    if (Adapter->Flags.WmiInitialized) {
        IoWMIRegistrationControl (Adapter->DeviceObject,
                                  WMIREG_ACTION_DEREGISTER);
        Adapter->Flags.WmiInitialized = FALSE;
        Adapter->Flags.WmiMiniPortInitialized = FALSE;
    }

    //
    // Delete the SCSI symbolic links.
    //
    
    StorDeleteScsiSymbolicLink (Adapter->PortNumber);
}

BOOLEAN
RaidpAdapterInterruptRoutine(
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )
/*++

Routine Description:

    Interrupt routine for IO requests sent to the miniport.

Arguments:

    Interrupt - Supplies interrupt object this interrupt is for.

    ServiceContext - Supplies service context representing a RAID
            adapter extension.

Return Value:

    TRUE - to signal the interrupt has been handled.

    FALSE - to signal the interrupt has not been handled.

--*/
{
    BOOLEAN Handled;
    PRAID_ADAPTER_EXTENSION Adapter;

    //
    // Get the adapter from the Interrupt's ServiceContext.
    //
    
    Adapter = (PRAID_ADAPTER_EXTENSION) ServiceContext;
    ASSERT_ADAPTER (Adapter);

    //
    // If interrupts are disabled, simply return.
    //
    
    if (!RaidAdapterQueryInterruptsEnabled (Adapter)) {
        return FALSE;
    }

    //
    // Call into the Miniport to see if this is it's interrupt.
    //
    
    Handled = RaCallMiniportInterrupt (&Adapter->Miniport);

    return Handled;
}


VOID
RaidpAdapterDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    DPC routine for the Adapter. This routine is called in the context of
    an arbitrary thread to complete an io request.

    The DPC routine is only called once even if there are multiple calls
    to IoRequestDpc(). Therefore, we need to queue completion requests
    onto the adapter, and we should not inspect the Dpc, Irp and Context
    parameters.
    

Arguments:

    Dpc - Unreference parameter, do not use.

    DeviceObject - Adapter this DPC is for.

    Irp - Unreferenced parameter, do not use.

    Context - Unreferenced parameter, do not use.

Return Value:

    None.

--*/
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PSLIST_ENTRY Entry;
    PEXTENDED_REQUEST_BLOCK Xrb;

    //
    // The count is a temporary hack to prevent an "infinite loop" between
    // the interrupt and the DPC on busy requests for adapters that have
    // not implemented pause yet. It should be removed in the future.
    //
    
    ULONG Count = 0;

    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (Irp);
    UNREFERENCED_PARAMETER (Context);

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT (IsAdapter (DeviceObject));

    //
    // Dequeue items from the adapter's completion queue and call the
    // item's completion routine.
    //

    Adapter = (PRAID_ADAPTER_EXTENSION) DeviceObject->DeviceExtension;


    for (Entry = InterlockedPopEntrySList (&Adapter->CompletedList);
         Entry != NULL;
         Entry = InterlockedPopEntrySList (&Adapter->CompletedList)) {


        Xrb = CONTAINING_RECORD (Entry,
                                 EXTENDED_REQUEST_BLOCK,
                                 CompletedLink);
        ASSERT_XRB (Xrb);
        Xrb->CompletionRoutine (Xrb);

        if (Count++ > 255) {
            break;
        }
            
    }
}



ULONG
RaidpAdapterQueryBusNumber(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    NTSTATUS Status;
    ULONG BusNumber;
    ULONG Size;

    PAGED_CODE ();
    
    Status = IoGetDeviceProperty (Adapter->PhysicalDeviceObject,
                                  DevicePropertyBusNumber,
                                  sizeof (ULONG),
                                  &BusNumber,
                                  &Size);

    if (!NT_SUCCESS (Status)) {
        BusNumber = -1;
    }

    return BusNumber;
}


//
// IRP Handler functions
//

NTSTATUS
RaidAdapterCreateIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the create device irp.

Arguments:

    Adapter - Adapter to create.

    Irp - Create device irp.

Return Value:

    NTSTATUS code.

--*/
{
    PAGED_CODE ();

    return RaidHandleCreateCloseIrp (Adapter->DeviceState, Irp);
}


NTSTATUS
RaidAdapterCloseIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the close device irp.

Arguments:

    Adapter - Adapter to close.

    Irp - Close device irp.

Return Value:

    NTSTATUS code.

--*/
{
    PAGED_CODE ();

    return RaidHandleCreateCloseIrp (Adapter->DeviceState, Irp);
}


ULONG
INLINE
DbgFunctionFromIoctl(
    IN ULONG Ioctl
    )
{
    return ((Ioctl & 0x3FFC) >> 2);
}

ULONG
INLINE
DbgDeviceFromIoctl(
    IN ULONG Ioctl
    )
{
    return DEVICE_TYPE_FROM_CTL_CODE (Ioctl);
}

NTSTATUS
RaidAdapterDeviceControlIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the handler routine for the adapter's ioctl irps.

Arguments:

    Adapter - The adapter device extension associated with the
            device object this irp is for.

    Irp - The irp to process.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Ioctl;

    Status = IoAcquireRemoveLock (&Adapter->RemoveLock, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp, Status);
    }

    Ioctl = RaidIoctlFromIrp (Irp);

    DebugTrace (("Adapter %p Irp %p Ioctl (Dev, Fn) (%x, %x)\n",
                  Adapter, Irp, DbgDeviceFromIoctl (Ioctl),
                  DbgFunctionFromIoctl (Ioctl)));
    
    switch (Ioctl) {

        //
        // Storage IOCTLs
        //

        case IOCTL_STORAGE_QUERY_PROPERTY:
            Status = RaidAdapterStorageQueryPropertyIoctl (Adapter, Irp);
            break;

        case IOCTL_STORAGE_RESET_BUS:
            Status = RaidAdapterStorageResetBusIoctl (Adapter, Irp);
            break;

        case IOCTL_STORAGE_BREAK_RESERVATION:
            Status = RaidAdapterStorageBreakReservationIoctl (Adapter, Irp);
            break;

        //
        // SCSI IOCTLs
        //
        
        case IOCTL_SCSI_MINIPORT:
            Status = RaidAdapterScsiMiniportIoctl (Adapter, Irp);
            break;

        case IOCTL_SCSI_GET_CAPABILITIES:
            Status = RaidAdapterScsiGetCapabilitiesIoctl (Adapter, Irp);
            break;

        case IOCTL_SCSI_RESCAN_BUS:
            Status = RaidAdapterScsiRescanBusIoctl (Adapter, Irp);
            break;
            
        case IOCTL_SCSI_PASS_THROUGH:
            Status = RaidAdapterScsiPassThroughIoctl (Adapter, Irp);
            break;

        case IOCTL_SCSI_PASS_THROUGH_DIRECT:
            Status = RaidAdapterScsiPassThroughDirectIoctl (Adapter, Irp);
            break;

        case IOCTL_SCSI_GET_INQUIRY_DATA:
            Status = RaidAdapterScsiGetInquiryDataIoctl (Adapter, Irp);
            break;

        default:
            Status = RaidCompleteRequest (Irp,
                                          
                                          STATUS_NOT_SUPPORTED);
    }

    IoReleaseRemoveLock (&Adapter->RemoveLock, Irp);

    DebugTrace (("Adapter %p Irp %p Ioctl %x, ret = %08x\n",
                  Adapter, Irp, Ioctl, Status));
                  
    return Status;
}

//
// Second level dispatch functions.
//

NTSTATUS
RaidAdapterPnpIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles all PnP irps for the adapter by forwarding them
    on to routines based on the irps's minor code.

Arguments:

    Adapter - The adapter object this irp is for.

    Irp - The irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Minor;
    BOOLEAN RemlockHeld;

    PAGED_CODE ();
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);

    Status = IoAcquireRemoveLock (&Adapter->RemoveLock, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp,  Status);
    }

    RemlockHeld = TRUE;
    Minor = RaidMinorFunctionFromIrp (Irp);

    DebugPnp (("Adapter %p, Irp %p, Pnp %x\n",
                 Adapter,
                 Irp,
                 Minor));

    //
    // Dispatch the IRP to one of our handlers.
    //
    
    switch (Minor) {

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            Status = RaidAdapterQueryDeviceRelationsIrp (Adapter, Irp);
            break;

        case IRP_MN_START_DEVICE:
            Status = RaidAdapterStartDeviceIrp (Adapter, Irp);
            break;

        case IRP_MN_STOP_DEVICE:
            Status = RaidAdapterStopDeviceIrp (Adapter, Irp);
            break;

        case IRP_MN_REMOVE_DEVICE:
            RemlockHeld = FALSE;
            Status = RaidAdapterRemoveDeviceIrp (Adapter, Irp);
            break;

        case IRP_MN_SURPRISE_REMOVAL:
            Status = RaidAdapterSurpriseRemovalIrp (Adapter, Irp);
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
            Status = RaidAdapterQueryStopDeviceIrp (Adapter, Irp);
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:
            Status = RaidAdapterCancelStopDeviceIrp (Adapter, Irp);
            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:
            Status = RaidAdapterQueryRemoveDeviceIrp (Adapter, Irp);
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            Status = RaidAdapterCancelRemoveDeviceIrp (Adapter, Irp);
            break;

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            Status = RaidAdapterFilterResourceRequirementsIrp (Adapter, Irp);
            break;

        case IRP_MN_QUERY_ID:
            Status = RaidAdapterQueryIdIrp (Adapter, Irp);
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            Status = RaidAdapterQueryPnpDeviceStateIrp (Adapter, Irp);
            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            Status = RaidAdapterDeviceUsageNotificationIrp (Adapter, Irp);
            break;
            
        default:
            IoReleaseRemoveLock (&Adapter->RemoveLock, Irp);
            RemlockHeld = FALSE;
            Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);
    }

    DebugPnp (("Adapter %p, Irp %p, Pnp %x ret = %x\n",
                  Adapter,
                  Irp,
                  Minor,
                  Status));

    //
    // If the remove lock has not already been released, release it now.
    //
    
    if (RemlockHeld) {
        IoReleaseRemoveLock (&Adapter->RemoveLock, Irp);
    }
    
    return Status;
}



NTSTATUS
RaidAdapterQueryDeviceRelationsIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    The is the handler routine for the (PNP, QUERY_DEVICE_RELATION) irp
    on the Adapter object.

Arguments:

    Adapter - The adapter that is receiving the irp.
    
    Irp - The IRP to handle, which must be a pnp, query device relations
          irp.  The adapter only handles BusRelations, so this must be a
          device relations irp with subcode BusRelations. Otherwise, we
          fail the call.

Return Value:

    NTSTATUS code.

Bugs:

    We do the bus enumeration synchronously; SCSIPORT does this async.
    
--*/
{
    NTSTATUS Status;
    DEVICE_RELATION_TYPE RelationType;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_RELATIONS DeviceRelations;
    LARGE_INTEGER CurrentTime;
    LONGLONG TimeDifference;


    PAGED_CODE();
    
    ASSERT_ADAPTER (Adapter);
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);


    DebugPnp (("Adapter %p, Irp %p, Pnp DeviceRelations\n",
                 Adapter,
                 Irp));
                 
    DeviceRelations = NULL;
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    RelationType = IrpStack->Parameters.QueryDeviceRelations.Type;

    //
    // BusRelations is the only type of device relations we support on
    // the adapter object.
    //
    
    if (RelationType != BusRelations) {
        return RaForwardIrp (Adapter->LowerDeviceObject, Irp);
    }

    //
    // This is a hack to support "rescan" from within device manager. The
    // correct way to fix this is to force applications that want a bus
    // rescan to issue an IOCTL_SCSI_RESCAN_BUS.
    //

    KeQuerySystemTime (&CurrentTime);
    TimeDifference = CurrentTime.QuadPart - Adapter->LastScanTime.QuadPart;
    
    if (TimeDifference > DEFAULT_RESCAN_PERIOD) {
        Adapter->Flags.RescanBus = TRUE;
    }

    //
    // Rescan the bus if necessary.
    //
    
    Status = RaidAdapterRescanBus (Adapter);

    //
    // If enumeration was successful, build the device relations
    // list.
    //

    if (NT_SUCCESS (Status)) {
        Status = RaidpBuildAdapterBusRelations (Adapter, &DeviceRelations);
    }

    Irp->IoStatus.Information = (ULONG_PTR) DeviceRelations;
    Irp->IoStatus.Status = Status;

    //
    // If successful, call next lower driver, otherwise, fail.
    //

    if (NT_SUCCESS (Status)) {
        IoCopyCurrentIrpStackLocationToNext (Irp);
        Status = IoCallDriver (Adapter->LowerDeviceObject, Irp);
    } else {
        Status = RaidCompleteRequest (Irp,
                                      
                                      Irp->IoStatus.Status);
    }

    DebugPnp (("Adapter: %p Irp: %p, Pnp DeviceRelations, ret = %08x\n",
                 Adapter,
                 Irp,
                 Status));
                 
    return Status;
}

NTSTATUS
RaidAdapterRaiseIrqlAndExecuteXrb(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    Raise the IRQL to dispatch levela nd call the execute XRB routine.

Arguments:

    Adapter - Adapter to execute the XRB on.

    Xrb - Xrb to execute.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    KIRQL OldIrql;

    KeRaiseIrql (DISPATCH_LEVEL, &OldIrql);
    Status = RaidAdapterExecuteXrb (Adapter, Xrb);
    KeLowerIrql (OldIrql);

    return Status;
}


NTSTATUS
RaidAdapterStartDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called in response to the PnP manager's StartDevice
    call. It needs to complete any initialization of the adapter that had
    been postponed until now, the call the required miniport routines to
    initialize the HBA. This includes calling at least the miniport's
    HwFindAdapter() and HwInitialize() routines.

Arguments:

    Adapter - The adapter that needs to be started.

    Irp - The PnP start IRP.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    PCM_RESOURCE_LIST AllocatedResources;
    PCM_RESOURCE_LIST TranslatedResources;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    ASSERT_ADAPTER (Adapter);

    DebugPnp (("Adapter %p, Irp %p, Pnp StartDevice\n", Adapter, Irp));

    PriorState = StorSetDeviceState (&Adapter->DeviceState, DeviceStateWorking);
    ASSERT (PriorState == DeviceStateStopped);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    AllocatedResources = IrpStack->Parameters.StartDevice.AllocatedResources;
    TranslatedResources = IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated;

    
    //
    // Forward the irp to the lower level device to start and wait for
    // completion.
    //
    
    Status = RaForwardIrpSynchronous (Adapter->LowerDeviceObject, Irp);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }
    //
    // Completes the initialization of the device, assigns resources,
    // connects up the resources, etc.
    // The miniport has not been started at this point.
    //
    
    Status = RaidAdapterConfigureResources (Adapter,
                                            AllocatedResources,
                                            TranslatedResources);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    //
    // Initialize the miniport's registry access routine library.
    //
    Adapter->RegistryInfo.Size = sizeof(PORT_REGISTRY_INFO);
    RaidAdapterInitializeRegistry(Adapter);

    Status = RaidAdapterStartMiniport (Adapter);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    Status = RaidAdapterCompleteInitialization (Adapter);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    //
    // Initialize WMI support. We ignore the return value since it's OK to
    // continue even if we fail WMI registration.
    //
    
    RaidAdapterInitializeWmi (Adapter);

    //
    // Register the adapter's PnP interface. Ignore the return value so
    // we will continue to function even if we fail.
    //
    
    RaidAdapterRegisterDeviceInterface (Adapter);
    
done:

    //
    // If we failed the start, reset the device state to stopped. This ensures
    // that we don't get a remove from a working state.
    //
    
    if (!NT_SUCCESS (Status)) {
        StorSetDeviceState (&Adapter->DeviceState, DeviceStateStopped);
    }

    DebugPnp (("Adapter %p, Irp %p, Pnp StartDevice, ret = %08x\n",
                 Adapter, Irp, Status));

    return RaidCompleteRequest (Irp,  Status);
}


NTSTATUS
RaidAdapterConfigureResources(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PCM_RESOURCE_LIST AllocatedResources,
    IN PCM_RESOURCE_LIST TranslatedResources
    )
/*++

Routine Description:

    Assign and configure resources for an HBA.

Arguments:

    Adapter - Supplies adapter the resources are for.

    AllocatedResources - Supplies the raw resources for this adapter.

    TranslatedResources - Supplies the translated resources for this
            adapter.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;

    PAGED_CODE();
    
    //
    // Save off the resources we were assigned.
    //

    Status = RaidInitializeResourceList (&Adapter->ResourceList,
                                         AllocatedResources,
                                         TranslatedResources);
    
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Initialize the bus we are sitting on top of. 
    //
    
    Status = RaInitializeBus (&Adapter->Bus,
                              Adapter->LowerDeviceObject);

    //
    // We failed to initialize the bus. If the bus type is internal, then
    // this is not a fatal error. We use a bus-type of internal for miniports
    // that do not have associated hardware (e.g., iSCSI). For all other
    // bus types, this is a failure.
    //
    
    if (Status == STATUS_NOT_SUPPORTED) {
        PHW_INITIALIZATION_DATA HwInitData;

        //
        // We check if the bus type is internal by searching for a HW
        // init data with type internal.
        //
        
        HwInitData = RaFindDriverInitData (Adapter->Driver, Internal);

        //
        // If we failed to find an init data for bus type internal,
        // fail, otherwise, consider this "success".
        //
        
        if (HwInitData == NULL) {
            return Status;
        }
        Status = STATUS_SUCCESS;
    }
    
    //
    // Initialize deferred work queues and related timer objects. This must
    // be done before we call find adapter.
    //

    RaidInitializeDeferredQueue (&Adapter->DeferredQueue,
                                 Adapter->DeviceObject,
                                 ADAPTER_DEFERRED_QUEUE_DEPTH,
                                 sizeof (RAID_DEFERRED_ELEMENT),
                                 RaidAdapterDeferredRoutine);

    KeInitializeDpc (&Adapter->TimerDpc,
                     RaidpAdapterTimerDpcRoutine,
                     Adapter->DeviceObject);
                     

    KeInitializeDpc (&Adapter->PauseTimerDpc,
                     RaidPauseTimerDpcRoutine,
                     Adapter->DeviceObject);

    KeInitializeDpc (&Adapter->CompletionDpc,
                     RaidCompletionDpcRoutine,
                     Adapter->DeviceObject);

    KeInitializeDpc (&Adapter->ResetHoldDpc,
                     RaidResetHoldDpcRoutine,
                     Adapter->DeviceObject);

    KeInitializeDpc (&Adapter->BusChangeDpc,
                     RaidAdapterBusChangeDpcRoutine,
                     Adapter->DeviceObject);
    
    //
    // Initialize the system DpcForIsr routine.
    //
    
    IoInitializeDpcRequest (Adapter->DeviceObject, RaidpAdapterDpcRoutine);


    return STATUS_SUCCESS;
}

NTSTATUS
RaidAdapterConnectInterrupt(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine connects the devices interrupt.

Arguments:

    Adapter - Pointer to the adapter extension.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    KIRQL InterruptIrql;
    ULONG InterruptVector;
    KAFFINITY InterruptAffinity;
    KINTERRUPT_MODE InterruptMode;
    BOOLEAN InterruptSharable;


    PAGED_CODE();

    //
    // We don't have any resources, so this is vacuously true.
    //
    
    if (((Adapter->ResourceList.AllocatedResources) == NULL) ||
        ((Adapter->ResourceList.TranslatedResources) == NULL)) {
        return STATUS_SUCCESS;
    }

    Status = RaidGetResourceListInterrupt (&Adapter->ResourceList,
                                           &InterruptVector,
                                           &InterruptIrql,
                                           &InterruptMode,
                                           &InterruptSharable,
                                           &InterruptAffinity);
                                           
    if (!NT_SUCCESS (Status)) {
        DebugPrint (("ERROR: Couldn't find interrupt in resource list!\n"));
        return Status;
    }

    Status = IoConnectInterrupt (&Adapter->Interrupt,
                                 RaidpAdapterInterruptRoutine,
                                 Adapter,
                                 NULL,
                                 InterruptVector,
                                 InterruptIrql,
                                 InterruptIrql,
                                 InterruptMode,
                                 InterruptSharable,
                                 InterruptAffinity,
                                 FALSE);

    if (!NT_SUCCESS (Status)) {
        DebugPrint (("ERROR: Couldn't connect to interrupt!\n"));
        return Status;
    }

    //
    // NB: Fetching the interrupt IRQL from the interrupt object is
    // looked down upon, so save it off here.
    //
    
    Adapter->InterruptIrql = InterruptIrql;

    return Status;
}


NTSTATUS
RaidAdapterInitializeWmi(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Perform the necessary steps for initializing WMI for the specified
    adapter.

Arguments:

    Adapter - Supplies the adapter to 

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Action;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    
    if (!Adapter->Flags.WmiMiniPortInitialized &&
        Adapter->Miniport.PortConfiguration.WmiDataProvider) {
   
   
        //
        // Decide whether we are registering or reregistering WMI for the FDO.
        //

        if (!Adapter->Flags.WmiInitialized) {
            Action = WMIREG_ACTION_REGISTER;
        } else {
            Action = WMIREG_ACTION_REREGISTER;
        }
        
        //
        // Perform the registration. NOTE: We can get WMI irps as soon as we
        // do this.
        //
   
        Status = IoWMIRegistrationControl (Adapter->DeviceObject, Action);

        if (!NT_SUCCESS (Status)) {
            goto done;
        }

        Adapter->Flags.WmiInitialized = TRUE;

        //
        // Finally, initialize the WMI-specific deferred queue.
        //
           
       Status = RaidInitializeDeferredQueue (&Adapter->WmiDeferredQueue,
                                             Adapter->DeviceObject,
                                             ADAPTER_DEFERRED_QUEUE_DEPTH,
                                             sizeof (RAID_WMI_DEFERRED_ELEMENT),
                                             RaidAdapterWmiDeferredRoutine);

        if (!NT_SUCCESS (Status)) {
            goto done;
        }
    }

done:

    //
    // Cleanup on failure.
    //
    
    if (!NT_SUCCESS (Status)) {
        if (Adapter->Flags.WmiInitialized) {
            IoWMIRegistrationControl (Adapter->DeviceObject,
                                      WMIREG_ACTION_DEREGISTER);
            Adapter->Flags.WmiInitialized = FALSE;
        }
        RaidDeleteDeferredQueue (&Adapter->WmiDeferredQueue);
    }

    //
    // NB: What exactly does this flag signify?
    //
    
    Adapter->Flags.WmiMiniPortInitialized = TRUE;

    return Status;
}
    

NTSTATUS
RaidAdapterInitializeRegistry(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This will ready the library's registry routines for use.
    
Arguments:

    Adapter - Supplies the adapter extension.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status;

    //
    // Call the library to do the work.
    // 
    Adapter->RegistryInfo.Size = sizeof(PORT_REGISTRY_INFO);
    status = PortMiniportRegistryInitialize(&Adapter->RegistryInfo);
    
    return status;
}

NTSTATUS
RaidAdapterStartMiniport(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Start the miniport by calling the miniport's HwInitialize routine.

Arguments:

    Adapter - Pointer to the adapter whose miniport will be started.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    LOCK_CONTEXT LockContext;
    PHW_INITIALIZATION_DATA HwInitializationData;

    PAGED_CODE();
    
    //
    // Find the HwInitializationData associated with this adapter. This
    // requires a search through the driver's extension.
    //
    
    HwInitializationData = RaidpFindAdapterInitData (Adapter);

    if (HwInitializationData == NULL) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Initialize the Port->Miniport interface.
    //
    
    Status = RaInitializeMiniport (&Adapter->Miniport,
                                   HwInitializationData,
                                   Adapter,
                                   &Adapter->ResourceList,
                                   RaidpAdapterQueryBusNumber (Adapter));

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // At this point, the miniport has been initialized, but we have not made
    // any calls on the miniport. Call HwFindAdapter to find this adapter.
    //
    
    Status = RaCallMiniportFindAdapter (&Adapter->Miniport, 
                                        Adapter->DriverParameters);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Initialize the IO Mode and StartIo lock, if necessary.
    //

    Adapter->IoModel = Adapter->Miniport.PortConfiguration.SynchronizationModel;
    
    if (Adapter->IoModel == StorSynchronizeFullDuplex) {
        KeInitializeSpinLock (&Adapter->StartIoLock);
    }

    //
    // Disable interrupts until we call HwInitialize routine.
    //
    
    RaidAdapterDisableInterrupts (Adapter);
    
    //
    // Connect the interrupt; after we do this, we may begin receiving
    // interrupts for the device.
    //

    Status = RaidAdapterConnectInterrupt (Adapter);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }
    
    //
    // Call the miniport's HwInitialize routine. This will set the device
    // to start receiving interrupts. For compatability, we always do this
    // synchronized with the adapters ISR. In the future, when we fix
    // SCSIPORT's brain-dead initialization, this will NOT be
    // done synchronized with the ISR.
    //

    RaidAdapterAcquireHwInitializeLock (Adapter, &LockContext);

    //
    // Re-enable interrupts.
    //

    RaidAdapterEnableInterrupts (Adapter);

    Status = RaCallMiniportHwInitialize (&Adapter->Miniport);

    if (NT_SUCCESS (Status)) {
        Adapter->Flags.InitializedMiniport = TRUE;
    }
    
    RaidAdapterReleaseHwInitializeLock (Adapter, &LockContext);

    
    return Status;
}

NTSTATUS
RaidAdapterCompleteInitialization(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Perform the final steps in initializing the adapter. This routine is
    called only have HwFindAdapter and HwInitialize have both been called.

Arguments:

    Adapter - HBA object to complete initialization for.

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS Status;
    
    PAGED_CODE();

    //
    // Initialize the DMA Adapter. This will ususally be done in the
    // GetUncachedExtension routine, before we get here. If by the time
    // we get here it hasn't been initialized, initialize it now.
    //

    if (!RaidIsDmaInitialized (&Adapter->Dma)) {
        
        Status = RaidInitializeDma (&Adapter->Dma,
                                    Adapter->PhysicalDeviceObject,
                                    &Adapter->Miniport.PortConfiguration);
        if (!NT_SUCCESS (Status)) {
            return Status;
        }
    }

    //
    // Set maximum transfer length
    //
    
    //
    // Set alignment requirements for adapter's IO.
    //
    
    if (Adapter->Miniport.PortConfiguration.AlignmentMask >
        Adapter->DeviceObject->AlignmentRequirement) {

        Adapter->DeviceObject->AlignmentRequirement =
            Adapter->Miniport.PortConfiguration.AlignmentMask;
    }

    //
    // Create the symbolic link for the adapter object.
    //
    
    Status = StorCreateScsiSymbolicLink (&Adapter->DeviceName,
                                         &Adapter->PortNumber);
                                         
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // NB: should these be before the HwInitialize call?
    //
    
    //
    // Setup the Adapter's power state.
    //

    RaInitializePower (&Adapter->Power);
    RaSetSystemPowerState (&Adapter->Power, PowerSystemWorking);
    RaSetDevicePowerState (&Adapter->Power, PowerDeviceD0);

    return STATUS_SUCCESS;
}


NTSTATUS
RaidAdapterStopDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Stop the device.

Arguments:

    Adapter - The adapter to stop.

    Irp - Stop device irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();
    ASSERT (Irp != NULL);

    PriorState = InterlockedExchange ((PLONG)&Adapter->DeviceState,
                                      DeviceStateStopped);
    ASSERT (PriorState == DeviceStatePendingStop);
    
    //
    // Forward the irp to the lower level device to handle.
    //
    
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);
    
    return Status;
}

VOID
RaidAdapterDeleteAsyncCallbacks(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Delete / disable any async callbacks that the port driver may have. This
    included timer callbacks, interrupts, etc.

Arguments:

    Adapter - Adapter on which async callbacks should be disabled.

Return Value:

    None.

--*/
{
    PAGED_CODE();
    
    //
    // Disable the timers.
    //

    KeCancelTimer (&Adapter->Timer);
    KeCancelTimer (&Adapter->PauseTimer);
    KeCancelTimer (&Adapter->ResetHoldTimer);

    //
    // Disconnect interrupt.
    //
    
    if (Adapter->Interrupt) {
        IoDisconnectInterrupt (Adapter->Interrupt);
    }
}

NTSTATUS
RaidAdapterRemoveDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Remove the device.

Arguments:

    Adapter - Adapter to remove.

    Irp - Remove device Irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    PDEVICE_OBJECT DeviceObject;
    PDEVICE_OBJECT LowerDeviceObject;
    
    PAGED_CODE ();
    ASSERT (Irp != NULL);

    //
    // Save pointers to the device object and lower device object.
    //
    
    DeviceObject = Adapter->DeviceObject;
    LowerDeviceObject = Adapter->LowerDeviceObject;

    PriorState = StorSetDeviceState (&Adapter->DeviceState,
                                     DeviceStateDeleted);

    ASSERT (PriorState == DeviceStateStopped ||
            PriorState == DeviceStatePendingRemove ||
            PriorState == DeviceStateSurpriseRemoval);

    //
    // Disable interfaces before waiting for outstanding requests to
    // complete. This will prevent new things from trying to access the
    // adapter while we are deleting. Note, there is still a window between
    // the time that we transition the adapter into Deleted state and the
    // time that  we disable the interfaces that an application could
    // access our interface and attempt to send us a new request. This
    // will be failed because we're in deleted state.
    //

    RaidAdapterDisableDeviceInterface (Adapter);

    //
    // Wait for outstanding I/O to complete.
    //
    
    IoReleaseRemoveLockAndWait (&Adapter->RemoveLock, Irp);

    //
    // Disable any async callbacks into the port driver, so we don't get
    // timer callbacks, interrupts, etc. while we're removing.
    //
    
    RaidAdapterDeleteAsyncCallbacks (Adapter);

    //
    // All I/O has stopped and interrupts, timers, etc. have been disabled.
    // Shutdown the adapter.
    //
    
    RaidAdapterStopAdapter (Adapter);
    
    //
    // When the FDO is removed, it is necessary for it to delete any
    // children that are not in the surprise remove state.
    //
    
    RaidAdapterDeleteChildren (Adapter);

    //
    // Free adapter resources.
    //
    
    RaidDeleteAdapter (Adapter);

    Status = RaForwardIrpSynchronous (LowerDeviceObject, Irp);
    ASSERT (NT_SUCCESS (Status));

    //
    // Complete the remove IRP.
    //

    Status = RaidCompleteRequest (Irp, STATUS_SUCCESS);

    IoDetachDevice (LowerDeviceObject);
    IoDeleteDevice (DeviceObject);

    return Status;
}

NTSTATUS
RaidAdapterQueryStopDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Query if we can stop the device.

Arguments:

    Adapter - Adapter we are looking to stop.

    Irp - Query stop irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    PriorState = InterlockedExchange ((PLONG)&Adapter->DeviceState,
                                      DeviceStatePendingStop);
    ASSERT (PriorState == DeviceStateWorking);
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);

    return Status;
}


NTSTATUS
RaidAdapterCancelStopDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Cancel a stop request on the adapter.

Arguments:

    Adapter - Adapter that was previously querried for stop.

    Irp - Cancel stop irp.

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = InterlockedExchange ((PLONG)&Adapter->DeviceState,
                                      DeviceStateWorking);

    ASSERT (PriorState == DeviceStatePendingStop ||
            PriorState == DeviceStateWorking);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);

    return Status;
}


NTSTATUS
RaidAdapterQueryRemoveDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Query if the adapter can be removed.

Arguments:

    Adapter - Adapter to query for remove.

    Irp - Remove device irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;

    PAGED_CODE ();

    PriorState = InterlockedExchange ((PLONG)&Adapter->DeviceState,
                                      DeviceStatePendingRemove);
    ASSERT (PriorState == DeviceStateWorking);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);

    return Status;
}



NTSTATUS
RaidAdapterCancelRemoveDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Cancel a pending remove request on the adapter.

Arguments:

    Adapter - Adapter that is in pending remove state.

    Irp - Cancel remove irp.
    
Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = InterlockedExchange ((PLONG)&Adapter->DeviceState,
                                      DeviceStateWorking);

    ASSERT (PriorState == DeviceStateWorking ||
            PriorState == DeviceStatePendingRemove);
            
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);

    return Status;
}


NTSTATUS
RaidAdapterSurpriseRemovalIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Remove the adapter without asking if it can be removed.

Arguments:

    Adapter - Adapter to remove.

    Irp - Surprise removal irp.

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;

    PAGED_CODE ();

    PriorState = StorSetDeviceState (&Adapter->DeviceState,
                                     DeviceStateSurpriseRemoval);

    ASSERT (PriorState != DeviceStateSurpriseRemoval);

    //
    // Wait for outstanding I/O to complete.
    //
    
    IoReleaseRemoveLockAndWait (&Adapter->RemoveLock, Irp);

    //
    // The child device objects must be marked as missing.
    //
    
    RaidAdapterMarkChildrenMissing (Adapter);
    

    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);
    return Status;
}



NTSTATUS
RaidAdapterFilterResourceRequirementsIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    We handle the IRP_MN_FILTER_RESOURCE_REQUIREMENTS irp only so we
    can pull out some useful information from the irp.

Arguments:

    Adapter - Adapter this irp is for.

    Irp - FilterResourceRequirements IRP.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    PIO_RESOURCE_REQUIREMENTS_LIST Requirements;

    PAGED_CODE ();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Requirements = IrpStack->Parameters.FilterResourceRequirements.IoResourceRequirementList;

    if (Requirements) {
        Adapter->BusNumber = Requirements->BusNumber;
        Adapter->SlotNumber = Requirements->SlotNumber;
    }
    
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);
    return Status;
}

NTSTATUS
RaidAdapterQueryIdIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
{
    NTSTATUS Status;

    //
    // NB: SCSIPORT fills in some compatible IDs here. We will probably
    // need to as well.
    //
    
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);
    return Status;
}


NTSTATUS
RaidAdapterQueryPnpDeviceStateIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the query device state IRP for the adapter.

Arguments:

    Adapter - Adapter the IRP is directed to.

    Irp - Query device state IRP to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PPNP_DEVICE_STATE DeviceState;

    PAGED_CODE ();

    //
    // Get the address of the PNP device state buffer, and update
    // the state.
    //
    
    DeviceState = (PPNP_DEVICE_STATE) &(Irp->IoStatus.Information);

    //
    // If the adapter is on the paging path, we cannot disable it.
    //
    
    if (Adapter->PagingPathCount != 0 ||
        Adapter->HiberPathCount != 0 ||
        Adapter->CrashDumpPathCount != 0) {
        SET_FLAG (*DeviceState, PNP_DEVICE_NOT_DISABLEABLE);
    }
    
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);

    return Status;
}

NTSTATUS
RaidAdapterDeviceUsageNotificationIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    PULONG UsageCount;
    DEVICE_USAGE_NOTIFICATION_TYPE UsageType;
    BOOLEAN Increment;
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    UsageType = IrpStack->Parameters.UsageNotification.Type;
    Increment = IrpStack->Parameters.UsageNotification.InPath;
    
    switch (UsageType) {

        case DeviceUsageTypePaging:
            UsageCount = &Adapter->PagingPathCount;
            break;

        case DeviceUsageTypeHibernation:
            UsageCount = &Adapter->HiberPathCount;
            break;

        case DeviceUsageTypeDumpFile:
            UsageCount = &Adapter->CrashDumpPathCount;
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
            goto done;
    }

    IoAdjustPagingPathCount (UsageCount, Increment);
    IoInvalidateDeviceState (Adapter->PhysicalDeviceObject);
    Status = STATUS_SUCCESS;

done:

    if (!NT_SUCCESS (Status)) {
        Status = RaidCompleteRequest (Irp,  Status);
    } else {
        Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);
    }

    return Status;
}


NTSTATUS
RaidAdapterScsiIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
{
    PAGED_CODE ();
    ASSERT (Irp != NULL);

    //
    // SCSI requests are handled by the logical unit, not the adapter.
    // Give a warning to this effect.
    //
    
    DebugWarn (("Adapter (%p) failing SCSI Irp %p\n", Adapter, Irp));

    return RaidCompleteRequest (Irp,  STATUS_UNSUCCESSFUL);
}




NTSTATUS
RaidAdapterMapBuffers(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Some adapters require data buffers to be mapped to addressable VA
    before they can be executed. Traditionally, this was for Programmed
    IO, but raid adapters also require this because the card firmware may
    not completely implement the full SCSI command set and may require
    some commands to be simulated in software.

    Mapping requests is problematic for two reasons. First, it requires
    an aquisition of the PFN database lock, which is one of the hottest
    locks in the system. This is especially annoying on RAID cards read
    and write requests almost never need to be mapped. Rather, it's IOCTLs
    and infrequently issued SCSI commands that need to be mapped. Second,
    this is the only aquisition of resources in the IO path that can fail,
    which makes our error handling more complicated.

    The trade-off we make is as follows: we define another bit in the
    port configuration that specifies buffers need to be mapped for non-IO
    (read, write) requests.

Arguments:

    Adapter - 
    
    Irp - Supplies irp to map.

Return Value:

    NTSTATUS code.

--*/
{
    PSCSI_REQUEST_BLOCK Srb;
    MM_PAGE_PRIORITY Priority;
    PVOID SystemAddress;
    SIZE_T DataOffset;

    //
    // No MDL means nothing to map.
    //
    
    if (Irp->MdlAddress == NULL) {
        return STATUS_SUCCESS;
    }

    Srb = RaidSrbFromIrp (Irp);

    //
    // If neither of the direction flags, we also have nothing to map.
    //
    
    if ((Srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) == 0) {
        return STATUS_SUCCESS;
    }

    //
    // REVIEW:
    //
    // For now, we interpret the MappedBuffers flag to mean that you
    // need buffer mappings for NON-IO requests. If you need mapped
    // buffers for IO requests, you have a brain-dead adapter. Fix
    // this when we add another bit for mapped buffers that are not
    // read and write requests.
    //
    
    if (IsMappedSrb (Srb) ||
        (RaidAdapterRequiresMappedBuffers (Adapter) &&
         !IsExcludedFromMapping (Srb))) {

        if (Irp->RequestorMode == KernelMode) {
            Priority = HighPagePriority;
        } else {
            Priority = NormalPagePriority;
        }

        SystemAddress = RaidGetSystemAddressForMdl (Irp->MdlAddress,
                                                    Priority,
                                                    Adapter->DeviceObject);

        //
        // The assumption here (same as with scsiport) is that the data
        // buffer is at some offset from the MDL address specified in
        // the IRP.
        //
        
        DataOffset = (ULONG_PTR)Srb->DataBuffer -
                     (ULONG_PTR)MmGetMdlVirtualAddress (Irp->MdlAddress);
  
        ASSERT (DataOffset < MmGetMdlByteCount (Irp->MdlAddress));
        
        Srb->DataBuffer = (PUCHAR)SystemAddress + DataOffset;
    }

    return STATUS_SUCCESS;
}
        

NTSTATUS
RaidGetSrbIoctlFromIrp(
    IN PIRP Irp,
    OUT PSRB_IO_CONTROL* SrbIoctlBuffer,
    OUT ULONG* InputLength,
    OUT ULONG* OutputLength
    )
{
    NTSTATUS Status;
    ULONGLONG LongLength;
    ULONG Length;
    PIO_STACK_LOCATION IrpStack;
    PIRP_STACK_DEVICE_IO_CONTROL Ioctl;
    PSRB_IO_CONTROL SrbIoctl;

    PAGED_CODE();
    
    //
    // First, validate the IRP
    //

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    SrbIoctl = Irp->AssociatedIrp.SystemBuffer;
    Ioctl = (PIRP_STACK_DEVICE_IO_CONTROL)&IrpStack->Parameters.DeviceIoControl;

    if (Ioctl->InputBufferLength < sizeof (SRB_IO_CONTROL)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (SrbIoctl->HeaderLength != sizeof (SRB_IO_CONTROL)) {
        return STATUS_REVISION_MISMATCH;
    }

    //
    // Make certian the total length doesn't overflow a ULONG
    //
    
    LongLength = SrbIoctl->HeaderLength;
    LongLength += SrbIoctl->Length;
    
    if (LongLength > ULONG_MAX) {
        return STATUS_INVALID_PARAMETER;
    }

    Length = (ULONG)LongLength;

    if (Ioctl->OutputBufferLength < Length &&
        Ioctl->InputBufferLength < Length) {
        
        return STATUS_BUFFER_TOO_SMALL;
    }

    if (SrbIoctlBuffer) {
        *SrbIoctlBuffer = SrbIoctl;
    }

    if (InputLength) {
        *InputLength = Length;
    }

    if (OutputLength) {
        *OutputLength = Ioctl->OutputBufferLength;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RaidAdapterStorageQueryPropertyIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle IOCTL_STORAGE_QUERY_PROPERTY for the storage adapter.

Arguments:

    Adapter - Supplies the adapter the IOCTL is for.

    Irp - Supplies the Query Property IRP to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    PSTORAGE_PROPERTY_QUERY Query;
    SIZE_T BufferSize;
    PVOID Buffer;

    PAGED_CODE ();
    ASSERT_ADAPTER (Adapter);
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Query = Irp->AssociatedIrp.SystemBuffer;
    Buffer = Irp->AssociatedIrp.SystemBuffer;
    BufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // If the buffer is too small or this is something other than the
    // StorageAdapterProperty, fail the request immediately.
    //
    
    if (BufferSize < FIELD_OFFSET (STORAGE_PROPERTY_QUERY, AdditionalParameters) ||
        Query->PropertyId != StorageAdapterProperty) {
        
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp,
                                    
                                    STATUS_INVALID_DEVICE_REQUEST);
    }

    switch (Query->QueryType) {

        case PropertyStandardQuery:
            Status = RaidGetStorageAdapterProperty (Adapter,
                                                    Buffer,
                                                    &BufferSize);
            Irp->IoStatus.Information = BufferSize;
            break;

        case PropertyExistsQuery:
            Status = STATUS_SUCCESS;
            break;

        default:
            Irp->IoStatus.Information = 0;
            Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    return RaidCompleteRequest (Irp,  Status);
}


NTSTATUS
RaidAdapterStorageResetBusIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler routine for IOCTL_STORAGE_RESET_BUS.

Arguments:

    Adapter - Supplies a pointer to the adapter to handle this request.

    Irp - Supplies a pointer to the Reset Bus IRP.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    PIRP_STACK_DEVICE_IO_CONTROL Ioctl;
    PSTORAGE_BUS_RESET_REQUEST ResetRequest;
    
    PAGED_CODE();
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Ioctl = (PIRP_STACK_DEVICE_IO_CONTROL)&IrpStack->Parameters.DeviceIoControl;

    if (Ioctl->InputBufferLength < sizeof (STORAGE_BUS_RESET_REQUEST)) {
        Status = STATUS_INVALID_PARAMETER;
        return RaidCompleteRequest (Irp,  Status);
    }

    ResetRequest = (PSTORAGE_BUS_RESET_REQUEST)Irp->AssociatedIrp.SystemBuffer;

    Status = RaidAdapterResetBus (Adapter, ResetRequest->PathId);

    return RaidCompleteRequest (Irp,
                                Status);
}

NTSTATUS
RaidAdapterStorageBreakReservationIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Break a reservation on a logical unit by issuing unit, target and bus
    resets (in order), until one of the resets takes.
    
Arguments:

    Unit - Logical unit to reset.

    Irp - Irp representing a Break reservation IOCTL.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    RAID_ADDRESS Address;
    PIO_STACK_LOCATION IrpStack;
    PIRP_STACK_DEVICE_IO_CONTROL Ioctl;
    PSTORAGE_BREAK_RESERVATION_REQUEST BreakReservation;
    
    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Ioctl = (PIRP_STACK_DEVICE_IO_CONTROL)&IrpStack->Parameters.DeviceIoControl;

    if (Ioctl->InputBufferLength < sizeof (STORAGE_BREAK_RESERVATION_REQUEST)) {
        Status = STATUS_INVALID_PARAMETER;
        return RaidCompleteRequest (Irp,  Status);
    }

    BreakReservation = (PSTORAGE_BREAK_RESERVATION_REQUEST)Irp->AssociatedIrp.SystemBuffer;

    Address.PathId   = BreakReservation->PathId;
    Address.TargetId = BreakReservation->TargetId;
    Address.Lun      = BreakReservation->Lun;
    
    Unit = RaidAdapterFindUnit (Adapter, Address);

    if (Unit != NULL) {
        Status = RaidUnitHierarchicalReset (Unit);
    } else {
        Status = STATUS_NO_SUCH_DEVICE;
    }

    return RaidCompleteRequest (Irp,  Status);
}

NTSTATUS
RaidAdapterScsiMiniportIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle an IOCTL_SCSI_MINIPORT ioctl for this adapter.

Arguments:

    Adapter - The adapter that should handle this IOCTL.

    Irp - Irp representing a SRB IOCTL.

Algorithm:

    Unlike scsiport, which translates the IOCTL into a IRP_MJ_SCSI
    request, then executes the request on the first logical unit in the
    unit list -- we execute the IOCTL "directly" on the adapter. We will
    be able to execute even when the adapter has detected no devices, if
    this matters.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;
    PEXTENDED_REQUEST_BLOCK Xrb;
    RAID_MEMORY_REGION SrbExtensionRegion;
    PSRB_IO_CONTROL SrbIoctl;
    ULONG InputLength;
    ULONG OutputLength;

    ASSERT_ADAPTER (Adapter);
    ASSERT (Irp != NULL);
    
    PAGED_CODE();

    Srb = NULL;
    Xrb = NULL;
    RaidCreateRegion (&SrbExtensionRegion);

    Status = RaidGetSrbIoctlFromIrp (Irp, &SrbIoctl, &InputLength, &OutputLength);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // Begin allocation chain
    //
    
    Srb = RaidAllocateSrb (Adapter->DeviceObject);

    if (Srb == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    Xrb = RaidAllocateXrb (NULL, Adapter->DeviceObject);

    if (Xrb == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }


    RaidBuildMdlForXrb (Xrb, SrbIoctl, InputLength);

    //
    // Build the srb
    //

    Srb->OriginalRequest = Xrb;
    Srb->Length = sizeof (SCSI_REQUEST_BLOCK);
    Srb->Function = SRB_FUNCTION_IO_CONTROL;
    Srb->PathId = 0;
    Srb->TargetId = 0;
    Srb->Lun = 0;
    Srb->SrbFlags = SRB_FLAGS_DATA_IN ;
    Srb->DataBuffer = SrbIoctl;
    Srb->DataTransferLength = InputLength;
    Srb->TimeOutValue = SrbIoctl->Timeout;

    //
    // Fill in Xrb fields.
    //

    Xrb->Srb = Srb;
    Xrb->SrbData.OriginalRequest = Srb->OriginalRequest;
    Xrb->SrbData.DataBuffer = Srb->DataBuffer;



    //
    // Srb extension
    //


    Status = RaidDmaAllocateCommonBuffer (&Adapter->Dma,
                                          RaGetSrbExtensionSize (Adapter),
                                          &SrbExtensionRegion);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    //
    // Get the VA for the SRB's extension
    //
    
    Srb->SrbExtension = RaidRegionGetVirtualBase (&SrbExtensionRegion);


    //
    // Map buffers, if necessary.
    //
    
    RaidAdapterMapBuffers (Adapter, Irp);


    //
    // Initialize the Xrb's completion event and
    // completion routine.
    //

    KeInitializeEvent (&Xrb->u.CompletionEvent,
                       NotificationEvent,
                       FALSE);

    //
    // Set the completion routine for the Xrb. This effectivly makes the
    // XRB synchronous.
    //
    
    RaidXrbSetCompletionRoutine (Xrb,
                                 RaidXrbSignalCompletion);

    //
    // And execute the Xrb.
    //
    
    Status = RaidAdapterRaiseIrqlAndExecuteXrb (Adapter, Xrb);

    if (NT_SUCCESS (Status)) {
        KeWaitForSingleObject (&Xrb->u.CompletionEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        Status = RaidSrbStatusToNtStatus (Srb->SrbStatus);
    }


done:

    //
    // Set the information length to the min of the output buffer length
    // and the length of the data returned by the SRB.
    //
        
    if (NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = min (OutputLength,
                                         Srb->DataTransferLength);
    } else {
        Irp->IoStatus.Information = 0;
    }

    //
    // Deallocate everything
    //

    if (RaidIsRegionInitialized (&SrbExtensionRegion)) {
        RaidDmaFreeCommonBuffer (&Adapter->Dma,
                                 &SrbExtensionRegion);
        RaidDeleteRegion (&SrbExtensionRegion);
        Srb->SrbExtension = NULL;
    }


    if (Xrb != NULL) {
        RaidFreeXrb (Xrb, FALSE);
        Srb->OriginalRequest = NULL;
    }


    //
    // The SRB extension and XRB must be released before the
    // SRB is freed.
    //

    if (Srb != NULL) {
        RaidFreeSrb (Srb);
        Srb = NULL;
    }

    return RaidCompleteRequest (Irp,
                                
                                Status);
}



NTSTATUS
RaidAdapterScsiGetCapabilitiesIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the IOCTL_SCSI_GET_CAPABILITIES ioctl for the adapter.

Arguments:

    Adapter - Supplies a pointer the the adapter object to get SCSI
        capabilities for.

    Irp - Supplies an IRP describing the Get Capabilities ioctl.

Return Value:

    NTSTATUS code.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    PIRP_STACK_DEVICE_IO_CONTROL Ioctl;
    PIO_SCSI_CAPABILITIES Capabilities;
    PPORT_CONFIGURATION_INFORMATION PortConfig;

    PAGED_CODE();
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Ioctl = (PIRP_STACK_DEVICE_IO_CONTROL)&IrpStack->Parameters.DeviceIoControl;


    //
    // Is the buffer too small? Bail out immediately.
    //
    
    if (Ioctl->OutputBufferLength < sizeof(IO_SCSI_CAPABILITIES)) {
        return RaidCompleteRequest (Irp,  STATUS_BUFFER_TOO_SMALL);
    }

    PortConfig = &Adapter->Miniport.PortConfiguration;
    Capabilities = (PIO_SCSI_CAPABILITIES) Irp->AssociatedIrp.SystemBuffer;

    Capabilities->Length = sizeof(IO_SCSI_CAPABILITIES);
    Capabilities->MaximumTransferLength = PortConfig->MaximumTransferLength;
    Capabilities->MaximumPhysicalPages = PortConfig->NumberOfPhysicalBreaks;
    Capabilities->SupportedAsynchronousEvents = FALSE;
    Capabilities->AlignmentMask = PortConfig->AlignmentMask;
    Capabilities->TaggedQueuing = TRUE;
    Capabilities->AdapterScansDown = PortConfig->AdapterScansDown;
    Capabilities->AdapterUsesPio = FALSE;

    Irp->IoStatus.Information = sizeof(IO_SCSI_CAPABILITIES);

    return RaidCompleteRequest (Irp,
                                
                                STATUS_SUCCESS);
}



NTSTATUS
RaidAdapterScsiRescanBusIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler routine for rescan bus ioctl on the HBA.

Arguments:

    Adapter - Supplies a pointer to the adapter that should be rescanned.

    Irp - Supplies a pointer to the Rescan ioctl.

Return Value:

    NTSTATUS code.

--*/
{
    PAGED_CODE();
    
    //
    // Force a bus rescan.
    //
    
    Adapter->Flags.RescanBus = TRUE;
    IoInvalidateDeviceRelations (Adapter->PhysicalDeviceObject, BusRelations);

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}
    

VOID
RaidAdapterRequestComplete(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    This routine is called when an IO request to the adapter has been
    completed. It needs to put the IO on the completed queue and request
    a DPC.

Arguments:

    Adapter - Adapter on which the IO has completed.

    Xrb - Completed IO.

Return Value:

    None.

--*/
{
    PSCSI_REQUEST_BLOCK Srb;
    PEXTENDED_REQUEST_BLOCK Next;

    DbgLogRequest (LogMiniportCompletion,
                   Xrb->Irp,
                   (PVOID)(ULONG_PTR)DbgGetAddressLongFromXrb (Xrb),
                   NULL,
                   NULL);

    //
    // At this point, the only errors that are handled synchronously
    // are busy errors.

    Srb = Xrb->Srb;

    //
    // Mark both the XRB and the IRP as awaiting completion.
    //

    if (Xrb->Irp) {
        RaidSetIrpState (Xrb->Irp, RaidPendingCompletionIrp);
    }
    RaidSetXrbState (Xrb, XrbPendingCompletion);
    
    //
    // Put the request on the completing list.
    //
    
    InterlockedPushEntrySList (&Adapter->CompletedList,
                               &Xrb->CompletedLink);

    //
    // We always request the DPC.
    //
    
    IoRequestDpc (Adapter->DeviceObject, NULL, NULL);
}


LOGICAL
FORCEINLINE
IsQueueFrozen(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
{
    LOGICAL Frozen;
    PRAID_UNIT_EXTENSION Unit;
    PRAID_ADAPTER_EXTENSION Adapter;
    PSCSI_REQUEST_BLOCK Srb;

    Unit = Xrb->Unit;
    Srb = Xrb->Srb;
    
    Adapter = Xrb->Adapter;
    ASSERT (Adapter != NULL);
    
    //
    // NOTE: Not every XRB will have an associated logical unit.
    // In particular, XRB's generated in response to miniport ioctls
    // will not have an associated logical unit.
    //
    
    if (Unit && RaidIsIoQueueFrozen (&Unit->IoQueue) ||
        StorIsIoGatewayPaused (&Adapter->Gateway)) {

        //
        // If this is a bypass request, do not busy it.
        //
        
        if (TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE) ||
            TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE)) {

            Frozen = FALSE;
        } else {
            Frozen = TRUE;
        }
    } else {
        Frozen = FALSE;
    }

    return Frozen;
}


NTSTATUS
RaidAdapterPostScatterGatherExecute(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    This routine executes the SRB by calling the adapter's BuildIo (if
    present) and StartIo routine, taking into account the different locking
    schemes associated with the two different IoModels.

Arguments:

    Adapter - Supplies the XRB is executed on.

    Xrb - 

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    BOOLEAN Succ;
    LOCK_CONTEXT LockContext;
    
    ASSERT_ADAPTER (Adapter);
    ASSERT_XRB (Xrb);
    VERIFY_DISPATCH_LEVEL();
    
    Xrb->Adapter = Adapter;

#if DBG

    //
    // To simulate the adapter dropping a request.
    //

    if (DropRequestRate &&
        InterlockedIncrement (&DropRequest) >= DropRequestRate) {
        DropRequest = 0;
        
        if (Xrb->Irp) {
            RaidSetIrpState (Xrb->Irp, RaidMiniportProcessingIrp);
        }
        DebugTrace (("Dropping Xrb %p\n", Xrb));
        return STATUS_UNSUCCESSFUL;
    }

#endif


    //
    // First, execute the miniport's HwBuildIo routine, if one is present.
    //
    
    Succ = RaCallMiniportBuildIo (&Xrb->Adapter->Miniport, Xrb->Srb);

    //
    // NB: Return TRUE from HwBuildIo if the request has not been completed.
    // Return FALSE from HwBuildIo if the request has been completed.
    // This allows us to short-circut the call to StartIo.
    //
    
    if (!Succ) {
        return STATUS_SUCCESS;
    }

    //
    // Acquire the StartIo lock or interrupt lock, depending on
    // the IoModel.
    //
    
    RaidAdapterAcquireStartIoLock (Adapter, &LockContext);

    
    //
    // If the adapter or logical unit is paused, we need to complete this
    // request as BUSY.
    //

    if (IsQueueFrozen (Xrb)) {

        ASSERT (Xrb->Srb != NULL);
        Xrb->Srb->SrbStatus = SRB_STATUS_BUSY;
        RaidAdapterRequestComplete (Adapter, Xrb);
        Succ = TRUE;

    } else {

        //
        // Mark the IRP as being in the miniport. This must be the last thing
        // we do before dispatching it to the miniport.
        //

        if (Xrb->Irp) {
            RaidSetIrpState (Xrb->Irp, RaidMiniportProcessingIrp);
        }
        RaidSetXrbState (Xrb, XrbMiniportProcessing);

        DbgLogRequest (LogCallMiniport,
                       Xrb->Irp,
                       (PVOID)(ULONG_PTR)DbgGetAddressLongFromXrb (Xrb),
                       NULL,
                       NULL);
        Succ = RaCallMiniportStartIo (&Adapter->Miniport, Xrb->Srb);
    }

    RaidAdapterReleaseStartIoLock (Adapter, &LockContext);


    if (!Succ) {
        Status = STATUS_UNSUCCESSFUL;
    } else {
        Status = STATUS_SUCCESS;
    }

    return Status;
}



VOID
RaidpAdapterContinueScatterGather(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSCATTER_GATHER_LIST ScatterGatherList,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    This function is called when the scatter/gather list has been successfully
    allocated. The function associates the scatter/gather list with the XRB
    parameter then calls a lower-level routine to send the XRB to the
    miniport.

Arguments:

    DeviceObject - DeviceObject representing an adapter that this IO is
        associated with.

    Irp - Irp representing the IO to execute.

    ScatterGatherList - Allocated scatter/gather list for this IO.

    Xrb - Xrb representing the I/O to execute. Must match the IRP.

Return Value:

    None.

Comments:

    This routine can be called asynchronously from the HAL. Therefore, it
    cannot return any status to it's calling function. If we fail to issue
    an I/O, we must fail the I/O asynchronously here.

--*/
{
    NTSTATUS Status;
    PRAID_ADAPTER_EXTENSION Adapter;

    Adapter = DeviceObject->DeviceExtension;
    ASSERT_ADAPTER (Adapter);

    ASSERT_XRB (Xrb);

    //
    // NB: In checked builds, it would be nice to verify that the XRB
    // associated with this IRP is the XRB passed in.
    //

    
    //
    // Associate the allocated scatter gather list with our SRB, then
    // execute the XRB.
    //

    RaidXrbSetSgList (Xrb, Adapter, ScatterGatherList);
    Status = RaidAdapterPostScatterGatherExecute (Adapter, Xrb);

    if (Adapter->Flags.InvalidateBusRelations) {
        Adapter->Flags.InvalidateBusRelations = FALSE;
        IoInvalidateDeviceRelations (Adapter->PhysicalDeviceObject,
                                     BusRelations);
    }

    //
    // It's not possible for us to return a sensible status at this time.
    //
    
    if (!NT_SUCCESS (Status)) {
        REVIEW();
        ASSERT_XRB (Xrb);
        ASSERT (Xrb->Srb != NULL);

        //
        // We don't have any information about what error occured; just use
        // STATUS_ERROR.
        //

        Xrb->Srb->SrbStatus = SRB_STATUS_ERROR;
        RaidAdapterRequestComplete (Adapter, Xrb);
    }
        
#if 0
    if (Adapter->Flags.Busy) {
        Adapter->Flags.Busy = FALSE;
        RaidAdapterQueueMakeBusy (Adapter->AdapterQueue, TRUE);
    }
#endif
}



NTSTATUS
RaidAdapterScatterGatherExecute(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    Allocate a scatter gather list then execute the XRB.

Arguments:

    Adapter - Supplies adapter this IO is to be executed on.

    Xrb - 

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    BOOLEAN ReadData;
    BOOLEAN WriteData;
    PSCSI_REQUEST_BLOCK Srb;
    
    ASSERT_XRB (Xrb);

    Srb = Xrb->Srb;
    ReadData = TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_DATA_IN);
    WriteData = TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_DATA_OUT);
    Status = STATUS_UNSUCCESSFUL;

    KeFlushIoBuffers (Xrb->Mdl, ReadData, TRUE);

    //
    // BuildScatterGatherList is like GetScatterGatherList except
    // that it uses our private SG buffer to allocate the SG list.
    // Therefore we do not take a pool allocation hit each time
    // we call BuildScatterGatherList like we do each time we call
    // GetScatterGatherList. If our pre-allocated SG list is too
    // small for the run, the function will return STATUS_BUFFER_TOO_SMALL
    // and we retry it allowing the DMA functions to do the
    // allocation.
    //

    //
    // REVIEW: The fourth parameter to the DMA Scatter/Gather functions
    // is the original VA, not the mapped system VA, right?
    //
    
    Status = RaidDmaBuildScatterGatherList (
                                &Adapter->Dma,
                                Adapter->DeviceObject,
                                Xrb->Mdl,
                                Xrb->SrbData.DataBuffer,
                                Srb->DataTransferLength,
                                RaidpAdapterContinueScatterGather,
                                Xrb,
                                WriteData,
                                Xrb->ScatterGatherBuffer,
                                sizeof (Xrb->ScatterGatherBuffer));

    if (Status == STATUS_BUFFER_TOO_SMALL) {

        //
        // The SG list is larger than we support internally. Fall back
        // on GetScatterGatherList which uses pool allocations to
        // satisify the SG list.
        //

        Status = RaidDmaGetScatterGatherList (
                                        &Adapter->Dma,
                                        Adapter->DeviceObject,
                                        Xrb->Mdl,
                                        Xrb->SrbData.DataBuffer,
                                        Srb->DataTransferLength,
                                        RaidpAdapterContinueScatterGather,
                                        Xrb,
                                        WriteData);
    }
    
    return Status;
}



NTSTATUS
RaidAdapterExecuteXrb(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    Execute the Xrb on the specified adapter.

Arguments:

    Adapter - Adapter object that the xrb will be executed on.

    Xrb - Xrb to be executed.

Return Value:

    STATUS_SUCCESS - The IO operation has successfully started. Any IO
            errors will be asynchronously signaled. The Xrb should
            not be accessed by the caller.

    Otherwise - There was an error processing the request. The Status value
            signals what type of error. The Xrb is still valid, and needs
            to be completed by the caller.
--*/
{
    NTSTATUS Status;

    VERIFY_DISPATCH_LEVEL ();
    ASSERT_ADAPTER (Adapter);
    ASSERT_XRB (Xrb);
    
    if (TEST_FLAG (Xrb->Srb->SrbFlags, SRB_FLAGS_DATA_IN) ||
        TEST_FLAG (Xrb->Srb->SrbFlags, SRB_FLAGS_DATA_OUT)) {
        Status = RaidAdapterScatterGatherExecute (Adapter, Xrb);
    } else {
        Status = RaidAdapterPostScatterGatherExecute (Adapter, Xrb);
    }

    return Status;
}


NTSTATUS
RaidAdapterEnumerateBus(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PADAPTER_ENUMERATION_ROUTINE EnumRoutine,
    IN PVOID Context
    )
/*++

Routine Description:

    Enumerate the adapter's bus, calling the specified callback routine
    for each valid (path, target, lun) triple on the SCSI bus.

Arguments:

    Adapter - Adapter object that is to be enumerated.

    EnumRoutine - Enumeration routine used for each valid target on the
        bus.

    Context - Context data for the enumeration routine.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    RAID_ADDRESS Address;
    ULONG Path;
    ULONG Target;
    ULONG Lun;
    ULONG MaxBuses;
    ULONG MaxTargets;
    ULONG MaxLuns;
    UCHAR LunList[SCSI_MAXIMUM_LUNS_PER_TARGET];

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    
    MaxBuses = RiGetNumberOfBuses (Adapter);
    MaxTargets = RiGetMaximumTargetId (Adapter);
    MaxLuns = RiGetMaximumLun (Adapter);
    
    //
    // Begin by initializing the LunList so we'll scan all LUNs.
    //

    RtlFillMemory (LunList, SCSI_MAXIMUM_LUNS_PER_TARGET, 1);

    for (Path = 0; Path < MaxBuses; Path++) {
        for (Target = 0; Target < MaxTargets; Target++) {

            Address.PathId = (UCHAR)Path;
            Address.TargetId = (UCHAR)Target;
            Address.Lun = (UCHAR)0;
            Address.Reserved = 0;

            //
            // Let's see if the target can specify which LUNs to scan.
            //
            
            RaidBusEnumeratorGetLunList (Context, 
                                         Address,
                                         LunList);

            //
            // And now walk through the array and scan only the marked entries.
            // 

            for (Lun = 0; Lun < MaxLuns; Lun++) {
                if (LunList[Lun]) {
                    Address.Lun = (UCHAR)Lun;
                    Status = EnumRoutine (Context, Address);
                    if (!NT_SUCCESS (Status)) {
                        return Status;
                    }
                }
            }
        }
    }

    return Status;
}



NTSTATUS
RaidAdapterRescanBus(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Re-enumerate the bus and do any processing for changed devices. This
    includes creating device objects for created logical units and destroying
    device objects for deleted logical units.

Arguments:

    Adapter - Supplies the adapter object to be re-enumerated.

Return Value:

    NTSTATUS code.

Notes:

    Re-enumeration of the bus is expensive.
    
--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    BUS_ENUMERATOR Enumerator;
    PLIST_ENTRY NextEntry;

    
    //
    // The bus does not need to be rescanned, so just return success.
    //
    
    if (!Adapter->Flags.RescanBus) {
        return STATUS_SUCCESS;
    }

    //
    // Mark it as not needing to be rescanned again and update the last
    // rescan time.
    //

    Adapter->Flags.RescanBus = FALSE;
    KeQuerySystemTime (&Adapter->LastScanTime);
    
    RaidCreateBusEnumerator (&Enumerator);

    Status = RaidInitializeBusEnumerator (&Enumerator, Adapter);

    Status = RaidAdapterEnumerateBus (Adapter,
                                      RaidBusEnumeratorVisitUnit,
                                      &Enumerator);

    if (NT_SUCCESS (Status)) {
        RaidBusEnumeratorProcessModifiedNodes (&Enumerator);
    }

    RaidDeleteBusEnumerator (&Enumerator);
    
    return Status;
}



NTSTATUS
RaidpBuildAdapterBusRelations(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    OUT PDEVICE_RELATIONS * DeviceRelationsBuffer
    )
/*++

Routine Description:

    Build a device relations list representing the adapter's bus
    relations.  This routine will not enumerate the adapter. Rather, it
    will build a list from the logical units that are current in the
    adpater's logical unit list.

Arguments:

    Adapter - The adapter to build the BusRelations list for.

    DeviceRelationsBuffer - Pointer to a buffer to recieve the bus
            relations.  This memory must be freed by the caller.
    
Return Value:

    NTSTATUS code.

--*/
{
    ULONG Count;
    SIZE_T RelationsSize;
    PDEVICE_RELATIONS DeviceRelations;
    PLIST_ENTRY NextEntry;
    PRAID_UNIT_EXTENSION Unit;
    LOCK_CONTEXT Lock;
    
    
    PAGED_CODE ();
    ASSERT_ADAPTER (Adapter);
    ASSERT (DeviceRelationsBuffer != NULL);

    //
    // Acquire the unit list lock in shared mode. This lock protects both
    // the list and the list count, so it must be acquired before we inspect
    // the number of elements in the unit list.
    //
    
    RaidAcquireUnitListLock (&Adapter->UnitList, &Lock);
    
    RelationsSize = sizeof (DEVICE_RELATIONS) +
                    (Adapter->UnitList.Count * sizeof (PDEVICE_OBJECT));

    DeviceRelations = RaidAllocatePool (NonPagedPool,
                                        RelationsSize,
                                        DEVICE_RELATIONS_TAG,
                                        Adapter->DeviceObject);

    if (DeviceRelations == NULL) {
        RaidReleaseUnitListLock (&Adapter->UnitList, &Lock);
        return STATUS_NO_MEMORY;
    }


    //
    // Walk the adapter's list of units, adding an entry for each unit on
    // the adapter's unit list.
    //

    Count = 0;
    for ( NextEntry = Adapter->UnitList.List.Flink;
          NextEntry != &Adapter->UnitList.List;
          NextEntry = NextEntry->Flink ) {

        DEVICE_STATE DeviceState;

        Unit = CONTAINING_RECORD (NextEntry,
                                  RAID_UNIT_EXTENSION,
                                  NextUnit);

        //
        // We must return a reference to the unit unless it is not phyiscally
        // present on the bus. This means even if it is removed, we must
        // return a reference to it.
        //

        if (!Unit->Flags.Present) {
            
            RaidUnitSetEnumerated (Unit, FALSE);

        } else {

            //
            // Take a reference to the object that PnP will release.
            //

            RaidUnitSetEnumerated (Unit, TRUE);
            ObReferenceObject (Unit->DeviceObject);
            DeviceRelations->Objects[Count++] = Unit->DeviceObject;
        }
        
    }

    RaidReleaseUnitListLock (&Adapter->UnitList, &Lock);

    //
    // Fill in the remaining fields of the DeviceRelations structure.
    //
    
    DeviceRelations->Count = Count;
    *DeviceRelationsBuffer = DeviceRelations;
    
    return STATUS_SUCCESS;
}
                                   

NTSTATUS
RaidGetStorageAdapterProperty(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PSTORAGE_ADAPTER_DESCRIPTOR Descriptor,
    IN OUT PSIZE_T DescriptorLength
    )
{
    PPORT_CONFIGURATION_INFORMATION PortConfig;
    
    PAGED_CODE ();
    ASSERT_ADAPTER (Adapter);
    ASSERT (Descriptor != NULL);

    if (*DescriptorLength < sizeof (STORAGE_DESCRIPTOR_HEADER)) {
        *DescriptorLength = sizeof (STORAGE_ADAPTER_DESCRIPTOR);
        return STATUS_BUFFER_TOO_SMALL;
    } else if (*DescriptorLength >= sizeof (STORAGE_DESCRIPTOR_HEADER) &&
               *DescriptorLength < sizeof (STORAGE_ADAPTER_DESCRIPTOR)) {

        Descriptor->Version = sizeof (STORAGE_ADAPTER_DESCRIPTOR);
        Descriptor->Size = sizeof (STORAGE_ADAPTER_DESCRIPTOR);
        *DescriptorLength = sizeof (STORAGE_DESCRIPTOR_HEADER);
        return STATUS_SUCCESS;
    }

    PortConfig = &Adapter->Miniport.PortConfiguration;
    
    Descriptor->Version = sizeof (Descriptor);
    Descriptor->Size = sizeof (Descriptor);

    Descriptor->MaximumPhysicalPages = min (PortConfig->NumberOfPhysicalBreaks,
                                            Adapter->Dma.NumberOfMapRegisters);
    Descriptor->MaximumTransferLength = PortConfig->MaximumTransferLength;
    Descriptor->AlignmentMask = PortConfig->AlignmentMask;
    Descriptor->AdapterUsesPio = PortConfig->MapBuffers;
    Descriptor->AdapterScansDown = PortConfig->AdapterScansDown;
    Descriptor->CommandQueueing = PortConfig->TaggedQueuing; // FALSE
    Descriptor->AcceleratedTransfer = TRUE;

    Descriptor->BusType = Adapter->Parameters.BusType;
    Descriptor->BusMajorVersion = 2;
    Descriptor->BusMinorVersion = 0;

    *DescriptorLength = sizeof (*Descriptor);

    return STATUS_SUCCESS;
}

VOID
RaidAdapterRestartQueues(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Restart Queues for all Logical Units on this adapter.

Arguments:

    Adapter - Supplies the adapter to restart the logical unit queues on.

Return Value:

    None.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    PLIST_ENTRY NextEntry;
    PRAID_UNIT_EXTENSION Unit;
    LOCK_CONTEXT Lock;

    ASSERT (KeGetCurrentIrql () <= DISPATCH_LEVEL);

    //
    // Loop through all of the logical units on the logical unit list
    // and call RaidUnitRestartQueue for each.
    //
    
    RaidAcquireUnitListLock (&Adapter->UnitList, &Lock);
    
    for ( NextEntry = Adapter->UnitList.List.Flink;
          NextEntry != &Adapter->UnitList.List;
          NextEntry = NextEntry->Flink ) {

        
        Unit = CONTAINING_RECORD (NextEntry,
                                  RAID_UNIT_EXTENSION,
                                  NextUnit);

        RaidUnitRestartQueue (Unit);
    }

    RaidReleaseUnitListLock (&Adapter->UnitList, &Lock);
}



VOID
RaidAdapterInsertUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Insert the logical unit into the adapter's logical unit queue.

Arguments:

    Adapter - Supplies the adapter to insert the logical unit into.

    Unit - Supplies the logical unit to be inserted.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    LOCK_CONTEXT Lock;
    
    //
    // Acquire the Unit list lock in exclusive mode. This can only be
    // done when APCs are disabled, hence the call to KeEnterCriticalRegion.
    //
    
    RaidAcquireUnitListLock (&Adapter->UnitList, &Lock);

#if DBG

    //
    // In checked build, check that we are not adding the same unit to the
    // list a second time.
    //

    {
        LONG Comparison;
        PLIST_ENTRY NextEntry;
        PRAID_UNIT_EXTENSION TempUnit;
        
        for ( NextEntry = Adapter->UnitList.List.Flink;
              NextEntry != &Adapter->UnitList.List;
              NextEntry = NextEntry->Flink ) {
        
            TempUnit = CONTAINING_RECORD (NextEntry,
                                          RAID_UNIT_EXTENSION,
                                          NextUnit);

            Comparison = StorCompareScsiAddress (TempUnit->Address,
                                                 Unit->Address);
            ASSERT (Comparison != 0);
        }

    }
#endif  // DBG

    //
    // Insert the element.
    //
    
    InsertTailList (&Adapter->UnitList.List, &Unit->NextUnit);
    Adapter->UnitList.Count++;

    Status = RaidAdapterAddUnitToTable (Adapter, Unit);

    //
    // The only failure case is duplicate unit, which is a programming
    // error.
    //
    
    ASSERT (NT_SUCCESS (Status));

    RaidReleaseUnitListLock (&Adapter->UnitList, &Lock);

}



NTSTATUS
RaidAdapterAddUnitToTable(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    KIRQL Irql;
    NTSTATUS Status;
    
    if (Adapter->Interrupt) {
        Irql = KeAcquireInterruptSpinLock (Adapter->Interrupt);
    }

    Status = StorInsertDictionary (&Adapter->UnitList.Dictionary,
                                   &Unit->UnitTableLink);
    ASSERT (NT_SUCCESS (Status));

    if (Adapter->Interrupt) {
        KeReleaseInterruptSpinLock (Adapter->Interrupt, Irql);
    }

    return Status;
}



VOID
RaidAdapterRemoveUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Remove the specified unit from the adapter's unit list.

Arguments:

    Adapter - Supplies the adapter whose unit needs to be removed.

    Unit - Supplies the unit object to remove.

Return Value:

    None.

--*/
{
    KIRQL Irql;
    NTSTATUS Status;
    LOCK_CONTEXT Lock;
    
    //
    // Remove it from the table first.
    //
    
    if (Adapter->Interrupt) {
        Irql = KeAcquireInterruptSpinLock (Adapter->Interrupt);
    }

    //
    // NB: Add function to remove from dictionary using the actual
    // STOR_DICTIONARY_ENTRY. This will improve speed (no need to
    // look up to remove).
    //
    
    Status = StorRemoveDictionary (&Adapter->UnitList.Dictionary,
                                   RaidAddressToKey (Unit->Address),
                                   NULL);
    ASSERT (NT_SUCCESS (Status));
    //
    // NB: ASSERT that returned entry is one we actually were trying to
    // remove.
    //

    if (Adapter->Interrupt) {
        KeReleaseInterruptSpinLock (Adapter->Interrupt, Irql);
    }

    //
    // Next remove it from the list.
    //
    
    RaidAcquireUnitListLock (&Adapter->UnitList, &Lock);
    RemoveEntryList (&Unit->NextUnit);
    Adapter->UnitList.Count--;
    RaidReleaseUnitListLock (&Adapter->UnitList, &Lock);
}



PRAID_UNIT_EXTENSION
RaidAdapterFindUnitAtDirql(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN RAID_ADDRESS Address
    )
/*++

Routine Description:

    Find the logical unit described by Address at a raised IRQL.

Arguments:

    Adapter - Adapter to search on.

    Address - Address to search for.

Return Value:

    Non-NULL - The logical unit identified by PathId, TargetId, Lun.

    NULL - If the logical unit was not found.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PSTOR_DICTIONARY_ENTRY Entry;

    ASSERT (KeGetCurrentIrql() == Adapter->InterruptIrql);

    Status = StorFindDictionary (&Adapter->UnitList.Dictionary,
                                 RaidAddressToKey (Address),
                                 &Entry);

    if (NT_SUCCESS (Status)) {
        Unit = CONTAINING_RECORD (Entry,
                                  RAID_UNIT_EXTENSION,
                                  UnitTableLink);
        ASSERT_UNIT (Unit);

    } else {
        Unit = NULL;
    }

    return Unit;
}

PRAID_UNIT_EXTENSION
RaidAdapterFindUnitAtPassive(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN RAID_ADDRESS Address
    )
/*++

Routine Description:

    Find the logical unit described by Address at PASSIVE LEVEL. The
    algorithm used here is slower than the one in FindAdapterAtDirql,
    but it also doen't acquire any if the I/O locks, unlike
    FindAdapterAtDirql.

Arguments:

    Adapter - Supplies adapter to search on.

    Address - Supplies address to search for.

Return Value:

    Non-NULL - The logical unit identified by PathId, TargetId and Lun.

    NULL - If the logical unit was not found.

--*/
{
    PRAID_UNIT_EXTENSION Unit;
    PLIST_ENTRY NextEntry;
    LONG Comparison;
    LOCK_CONTEXT Lock;

    RaidAcquireUnitListLock (&Adapter->UnitList, &Lock);
    
    for (NextEntry = Adapter->UnitList.List.Flink;
         NextEntry != &Adapter->UnitList.List;
         NextEntry = NextEntry->Flink) {

        Unit = CONTAINING_RECORD (NextEntry,
                                  RAID_UNIT_EXTENSION,
                                  NextUnit);

        ASSERT_UNIT (Unit);

        Comparison = StorCompareScsiAddress (Unit->Address, Address);

        //
        // If they match, we're done.
        //
        
        if (Comparison == 0) {
            break;
        }
    }

    //
    // Failed to find the requested unit.
    //
    
    if (NextEntry == &Adapter->UnitList.List) {
        Unit = NULL;
    }
    
    RaidReleaseUnitListLock (&Adapter->UnitList, &Lock);

    return Unit;
}

PRAID_UNIT_EXTENSION
RaidAdapterFindUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN RAID_ADDRESS Address
    )
/*++

Routine Description:

    Find a specific logical unit from a given target address.

Arguments:

    Adapter - Adapter extension to search on.

    Address - RAID address of the logical unit we're searching for.

Return Value:

    Non-NULL - Address of logical unit with matching address.

    NULL - If no matching unit was found.

--*/
{
    BOOLEAN Acquired;
    KIRQL Irql;
    PRAID_UNIT_EXTENSION Unit;
    
    ASSERT_ADAPTER (Adapter);

    Irql = KeGetCurrentIrql();


    //
    // It is important to realize that in full duplex mode, we can be
    // called from the miniport with the Adapter's StartIo lock held.
    // Since we acquire the Interrupt lock after the StartIo lock,
    // we enforce the following lock heirarchy:
    //
    //      Adapter::StartIoLock < Adapter::Interrupt::SpinLock
    //
    // where the '<' operator reads as preceeds.
    //

    //
    // NB: The only three levels we can be at are PASSIVE, DISPATCH
    // and DIRQL, right?
    //
    
    if (Irql == PASSIVE_LEVEL) {

        Unit = RaidAdapterFindUnitAtPassive (Adapter, Address);

    } else if (Irql < Adapter->InterruptIrql) {
        
        Irql = KeAcquireInterruptSpinLock (Adapter->Interrupt);
        Unit = RaidAdapterFindUnitAtDirql (Adapter, Address);
        KeReleaseInterruptSpinLock (Adapter->Interrupt, Irql);

    } else {

        Unit = RaidAdapterFindUnitAtDirql (Adapter, Address);
    }
        
    return Unit;
}

    
VOID
RaidpAdapterTimerDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    )
/*++

Routine Description:

    This DPC routine is called when the timer expires. It notifies the
    miniport that the timer has expired.

Arguments:

    Dpc -

    DeviceObject -

    Context1 -

    Context2 -

Return Value:

    None.

--*/
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PHW_INTERRUPT HwTimerRequest;
    LOCK_CONTEXT LockContext;

    VERIFY_DISPATCH_LEVEL();
    
    Adapter = (PRAID_ADAPTER_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT_ADAPTER (Adapter);

    HwTimerRequest = (PHW_INTERRUPT)InterlockedExchangePointer (
                                            (PVOID*)&Adapter->HwTimerRoutine,
                                            NULL);

    if (HwTimerRequest == NULL) {
        return;
    }

    //
    // Acquire appropiate lock.
    //
    
    RaidAdapterAcquireStartIoLock (Adapter, &LockContext);

    //
    // Call timer function.
    //
    
    HwTimerRequest (RaidAdapterGetHwDeviceExtension (Adapter));

    //
    // Release lock.
    //

    RaidAdapterReleaseStartIoLock (Adapter, &LockContext);

    VERIFY_DISPATCH_LEVEL();

    if (Adapter->Flags.InvalidateBusRelations) {
        Adapter->Flags.InvalidateBusRelations = FALSE;
        IoInvalidateDeviceRelations (Adapter->PhysicalDeviceObject,
                                     BusRelations);
    }
}

VOID
RaidPauseTimerDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    )
/*++

Routine Description:

    DPC routine to be called when the adapter's pause timer expires.

Arguments:

    Dpc - Supplies pointer to the DPC this DPC routine is for.

    DeviceObjectd - Supplies pointer to the device object this DPC is for.

    Context1, Context2 - Unused.
    
Return Value:

    None.

--*/
{
    LONG Count;
    PRAID_ADAPTER_EXTENSION Adapter;

    VERIFY_DISPATCH_LEVEL();

    Adapter = (PRAID_ADAPTER_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT_ADAPTER (Adapter);

    //
    // Timeout has expired, resume the adapter and restart queues if necessary.
    //
    
    Count = RaidResumeAdapterQueue (Adapter);

    if (Count == 0) {
        RaidAdapterRestartQueues (Adapter);
    }
}

VOID
RaidResetHoldDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    )
/*++

Routine Description:

    DPC routine that is called when the reset-hold timer expires.

Arguments:

    Dpc - Supplies pointer to the DPC this DPC routine is for.

    DeviceObjectd - Supplies pointer to the device object this DPC is for.

    Context1, Context2 - Unused.
    
Return Value:

    None.

--*/
{
    LONG Count;
    PRAID_ADAPTER_EXTENSION Adapter;

    VERIFY_DISPATCH_LEVEL();

    Adapter = (PRAID_ADAPTER_EXTENSION)DeviceObject->DeviceExtension;
    ASSERT_ADAPTER (Adapter);

    Count = RaidResumeAdapterQueue (Adapter);

    if (Count == 0) {
        RaidAdapterRestartQueues (Adapter);
    }
}


VOID
RaidAdapterLogIoError(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN RAID_ADDRESS Address,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    )
/*++

Routine Description:

    Log an IO error to the system event log.

Arguments:

    Adapter - Adapter the error is for.

    Address - Address of the adapter.
    
    ErrorCode - Specific error code representing this error.

    UniqueId - UniqueId of the error.

Return Value:

    None.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    PRAID_IO_ERROR Error;
    
    VERIFY_DISPATCH_LEVEL();

    Error = IoAllocateErrorLogEntry (Adapter->DeviceObject,
                                     sizeof (RAID_IO_ERROR));

    if (Error == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return ;
    }
        
    Error->Packet.DumpDataSize = sizeof (RAID_IO_ERROR) -
        sizeof (IO_ERROR_LOG_PACKET);
    Error->Packet.SequenceNumber = 0;
//  Error->Packet.SequenceNumber = InterlockedIncrement (&Adapter->ErrorSequenceNumber);
    Error->Packet.MajorFunctionCode = IRP_MJ_SCSI;
    Error->Packet.RetryCount = 0;
    Error->Packet.UniqueErrorValue = UniqueId;
    Error->Packet.FinalStatus = STATUS_SUCCESS;
    Error->PathId = Address.PathId;
    Error->TargetId = Address.TargetId;
    Error->Lun = Address.Lun;
    Error->ErrorCode = RaidScsiErrorToIoError (ErrorCode);

    IoWriteErrorLogEntry (&Error->Packet);
}


VOID
RaidAdapterLogIoErrorDeferred(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    )
/*++

Routine Description:

    Asychronously log an event to the system event log.

Arguments:

    Adapter - Adapter the error is for.

    PathId - PathId the error is for.

    TargetId - TargetId the error is for.

    ErrorCode - Specific error code representing this error.

    UniqueId - UniqueId of the error.

Return Value:

    None.

Environment:

    May be called from DIRQL. For IRQL < DIRQL use the synchronous
    RaidAdapterLogIoError call.

--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    
    Entry = RaidAllocateDeferredItem (&Adapter->DeferredQueue);

    //
    // It is unlikely that we will not be able to allocate a deferred
    // item, but if so, there's not much we can do.
    //
    
    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return ;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);
    Item->Type = RaidDeferredError;
    Item->Address.PathId = PathId;
    Item->Address.TargetId = TargetId;
    Item->Address.Lun = Lun;
    Item->Error.ErrorCode = ErrorCode;
    Item->Error.UniqueId = UniqueId;

    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);
}
    

VOID
RaidAdapterRequestTimer(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PHW_INTERRUPT HwTimerRoutine,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Synchronously request a timer callback.

Arguments:

    Adapter - Supplies the adapter the timer callback is for.

    HwTimerRoutine - Supplies the miniport callback routine to
            be called when the timer expires.

    Timeout - Supplies the timeout IN SECONDS.
    
Return Value:

    None.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    LARGE_INTEGER LargeTimeout;

    VERIFY_DISPATCH_LEVEL();

    //
    // NB: The granularity of the timer is much smaller than the granularity
    // of the pause/resume timers.
    //
    
    LargeTimeout.QuadPart = Timeout;
    LargeTimeout.QuadPart *= -10;

    Adapter->HwTimerRoutine = HwTimerRoutine;
    KeSetTimer (&Adapter->Timer,
                LargeTimeout,
                &Adapter->TimerDpc);
}


BOOLEAN
RaidAdapterRequestTimerDeferred(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PHW_INTERRUPT HwTimerRoutine,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Asynchronously request a timer callback.

Arguments:

    Adapter - Supplies the adapter the timer callback is for.

    HwTimerRoutine - Supplies the miniport callback routine to
            be called when the timer expires.

    Timeout - Supplies the timeout IN SECONDS.
    
Return Value:

    None.

Environment:

    May be called from DIRQL. For IRQL <= DISPATCH_LEVEL, use
    RaidAdapterRequestTimer instead.

--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;

    Entry = &Adapter->DeferredList.Timer.Header;
    Entry = RaidAllocateDeferredItemFromFixed (Entry);

    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return FALSE;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);
    Item->Type = RaidDeferredTimerRequest;
    Item->Timer.HwTimerRoutine = HwTimerRoutine;
    Item->Timer.Timeout = Timeout;

    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);

    return TRUE;
}


VOID
RaidAdapterPauseGateway(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Pause the IO gateway associated with the adapter.

Arguments:

    Adapter - Adapter to pause the IO gateway for.

    Timeout - Period of time to pause the IO gateway for.

Return Value:

    None.

--*/
{
    LARGE_INTEGER LargeTimeout;
    LONG Resumed;
    BOOLEAN Reset;
    
    VERIFY_DISPATCH_LEVEL();

    RaidAdapterSetPauseTimer (Adapter,
                              &Adapter->PauseTimer,
                              &Adapter->PauseTimerDpc,
                              Timeout);
}



BOOLEAN
RaidAdapterSetPauseTimer(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PKTIMER Timer,
    IN PKDPC Dpc,
    IN ULONG TimeoutInSeconds
    )
/*++

Routine Description:

    This routine sets a timer for use by the adapter. It takes care of
    correctly referencing and dereferncing the pause count associated with
    the adapter.

    This function assumes a separate function has set the pause timer.

Arguments:

    Adapter - Supplies a pointer to the adapter extension this timer is for.

    Timer - Supplies the timer to use.

    Dpc - Supplies a DPC routine to use.

    TimeoutInSeconds - Supplies a timeout in seconds when this timer will
        expire.

Return Value:

    TRUE if a previous timer was reset.

    FALSE otherwise.

--*/
{
    BOOLEAN Reset;
    LARGE_INTEGER Timeout;
    LONG Resumed;
    
    Timeout.QuadPart = TimeoutInSeconds;
    Timeout.QuadPart *= RELATIVE_TIMEOUT * SECONDS;
    
    Reset = KeSetTimer (Timer, Timeout, Dpc);

    if (Reset) {
        
        //
        // The timer was already in use, which means we cancelled it.
        // By cancelling it, we loose the dereference that would have
        // been done when the timer routine was called. To compensate
        // for that, deref the adapter pause count now.
        //

        Resumed = RaidResumeAdapterQueue (Adapter);

        //
        // The deref of the gateway pause count resumed the gateway. This
        // would be a very unusual situation. It would mean that between
        // the time we cancelled the timer and the time that we called
        // ResumeAdapterQueue the timer that we set for the gatway expired.
        // We need to restart the adapter queue and investigate this.
        //

        if (Resumed == 0) {
            REVIEW();
            RaidAdapterRestartQueues (Adapter);
        }
    }

    return Reset;
}

BOOLEAN
RaidAdapterCancelPauseTimer(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PKTIMER Timer
    )
/*++

Routine Description:

    Cancel an outstanding pause timer and resume the gateway, if necessary.

Arguments:

    Adapter - Supplies a pointer to the adapter that owns the timer to be
            cancelled.

    Timer - Supplies a pointer to the timer.

Return Value:

    TRUE  - if the timer was successfully cancelled.

    FALSE - otherwise.

--*/
{
    BOOLEAN Canceled;
    LONG Count;

    Canceled = KeCancelTimer (Timer);

    if (Canceled) {

        Count = RaidResumeAdapterQueue (Adapter);

        //
        // If our timer count is at zero, restart the adapter queue.
        //
        
        if (Count == 0) {
            RaidAdapterRestartQueues (Adapter);
        }
    }

    return Canceled;
}

    
VOID
RaidAdapterResumeGateway(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Perform the gateway resume operation. This cancels the outstnading
    timer, and, if necessary, resumes the gateway.

Arguments:

    Adapter - Supplies the adapter on which the pause timer should be
        cancelled.

Return Value:

    None.

--*/
{
    RaidAdapterCancelPauseTimer (Adapter, &Adapter->PauseTimer);
}



VOID
RaidAdapterPauseUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN RAID_ADDRESS Address,
    IN ULONG TimeoutSecs
    )
/*++

Routine Description:

    Implements the pause-unit function that is responsible for pausing
    a logical unit.

Arguments:

    Adapter - Adapter that the logical unit is attached to.

    Address - Address of the logical unit.

    Timeout - Period of time to pause the logical unit for in seconds.

Return Value:

    None.

--*/
{
    PRAID_UNIT_EXTENSION Unit;
    
    VERIFY_DISPATCH_LEVEL();

    Unit = RaidAdapterFindUnit (Adapter, Address);

    if (Unit == NULL) {
        DebugWarn (("Could not find logical unit for (%d %d %d)\n",
                    "    Pause unit request ignored.\n",
                    (ULONG)Address.PathId,
                    (ULONG)Address.TargetId,
                    (ULONG)Address.Lun));
        return;
    }
    
    RaidSetUnitPauseTimer (Unit, TimeoutSecs);
}



VOID
RaidAdapterResumeUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN RAID_ADDRESS Address
    )
{
    PRAID_UNIT_EXTENSION Unit;

    Unit = RaidAdapterFindUnit (Adapter, Address);

    if (Unit == NULL) {
        DebugWarn (("Could not find logical unit for (%d %d %d)\n",
                    "    Resume unit request ignored.\n",
                    (ULONG)Address.PathId,
                    (ULONG)Address.TargetId,
                    (ULONG)Address.Lun));
        return;
    }

    RaidCancelTimerResumeUnit (Unit);
}


VOID
RaidAdapterDeviceBusy(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN RAID_ADDRESS Address,
    IN ULONG RequestsToComplete
    )
{
    PRAID_UNIT_EXTENSION Unit;

    Unit = RaidAdapterFindUnit (Adapter, Address);

    if (Unit == NULL) {
        DebugWarn (("Could not find logical unit for (%d %d %d)\n",
                    "    Busy unit request ignored.\n",
                    (ULONG)Address.PathId,
                    (ULONG)Address.TargetId,
                    (ULONG)Address.Lun));
        return;
    }

    RaidUnitBusy (Unit, RequestsToComplete);
}

VOID
RaidAdapterDeviceReady(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN RAID_ADDRESS Address
    )
{
    PRAID_UNIT_EXTENSION Unit;

    Unit = RaidAdapterFindUnit (Adapter, Address);

    if (Unit == NULL) {
        DebugWarn (("Could not find logical unit for (%d %d %d)\n",
                    "    Busy unit request ignored.\n",
                    (ULONG)Address.PathId,
                    (ULONG)Address.TargetId,
                    (ULONG)Address.Lun));
        return;
    }

    RaidUnitReady (Unit);
}

    

VOID
RaidAdapterBusy(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN ULONG ReqsToComplete
    )
/*++

Routine Description:

    Put an adapter in the busy state.

Arguments:

    Adapter - Adapter to make busy.

    ReqsToComplete - Number of requests to complete.
    
Return Value:

    None.

--*/
{
    PSTOR_IO_GATEWAY Gateway;

    VERIFY_DISPATCH_LEVEL();

    Gateway = &Adapter->Gateway;

    //
    // NB: This needs to be in a separate gateway-specific function.
    //
    
    if (Gateway->BusyCount) {
        return;
    }

    //
    // NB: This needs to allows drain to zero.
    //

    Gateway->LowWaterMark = max (2, Gateway->Outstanding - (LONG)ReqsToComplete);
    Gateway->BusyCount = TRUE;
}



VOID
RaidAdapterReady(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Put a busy adapter in ready state again.

Arguments:

    Adapter - Adapter to make ready.

Return Value:

    None.

--*/
{
    PSTOR_IO_GATEWAY Gateway;
    
    VERIFY_DISPATCH_LEVEL();

    Gateway = &Adapter->Gateway;
    
    //
    // NB: Needs to be in a gateway-specific function.
    //
    
    if (Gateway->BusyCount == 0) {
        return ;
    }

    Gateway->BusyCount = FALSE;
    RaidAdapterRestartQueues (Adapter);
}


VOID
RaidAdapterDeferredRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PRAID_DEFERRED_HEADER Entry
    )
/*++

Routine Description:

    Deferred routine for the adapter deferred queue.

Arguments:

    DeviceObject - DeviceObject representing the the RAID adapter.

    Item -  Deferred item to process.

Return Value:

    None.

--*/
{
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;
    LONG Count;

    VERIFY_DISPATCH_LEVEL();
    ASSERT (Entry != NULL);
    ASSERT (IsAdapter (DeviceObject));

    Adapter = (PRAID_ADAPTER_EXTENSION) DeviceObject->DeviceExtension;
    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);

    Count = InterlockedIncrement (&Adapter->ProcessingDeferredItems);
    ASSERT (Count >= 1);

    switch (Item->Type) {

        case RaidDeferredTimerRequest:
            RaidAdapterRequestTimer (Adapter,
                                     Item->Timer.HwTimerRoutine,
                                     Item->Timer.Timeout);
            break;

        case RaidDeferredError:
            RaidAdapterLogIoError (Adapter,
                                   Item->Address,
                                   Item->Error.ErrorCode,
                                   Item->Error.UniqueId);
            break;

        case RaidDeferredPause:
            RaidAdapterPauseGateway (Adapter, Item->Pause.Timeout);
            break;

        case RaidDeferredResume:
            RaidAdapterResumeGateway (Adapter);
            break;

        case RaidDeferredPauseDevice:
            RaidAdapterPauseUnit (Adapter,
                                  Item->Address,
                                  Item->PauseDevice.Timeout);
            break;

        case RaidDeferredResumeDevice:
            RaidAdapterResumeUnit (Adapter,
                                   Item->Address);
            break;

        case RaidDeferredBusy:
            RaidAdapterBusy (Adapter,
                             Item->Busy.RequestsToComplete);
            break;

        case RaidDeferredReady:
            RaidAdapterReady (Adapter);
            break;

        case RaidDeferredDeviceBusy:
            RaidAdapterDeviceBusy (Adapter,
                                   Item->Address,
                                   Item->DeviceBusy.RequestsToComplete);
            break;

        case RaidDeferredDeviceReady:
            RaidAdapterDeviceReady (Adapter,
                                    Item->Address);
            break;

        default:
            ASSERT (FALSE);
    }

    Count = InterlockedDecrement (&Adapter->ProcessingDeferredItems);
    ASSERT (Count >= 0);
}

VOID
RaidAdapterProcessDeferredItems(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Process any deferred items on the HBA's deferred queue.

Arguments:

    Adapter - Supplies the HBA to check for deferred items on.

Return Value:

    None.

Notes:

    This function can be called recursively in the following manner.

    RaUnitStartIo
    RaidRestartIoQueue
    RaidUnitRestartQueue
    RaidCancelTimerResumeUnit
    RaidAdapterResumeUnit
    RaidAdapterDeferredRoutine
    RaidProcessDeferredItemsWorker
    RaidProcessDeferredItems
    RaUnitStartIo

    The solution is not to process deferred items from within StartIo
    if we're being called from within a deferred item.

--*/
{
    LONG Count;
    
    //
    // Only process deferred items if we're not already processing deferred
    // items. This prevents the invocation of this function from within
    // the StartIo routine from recursivly calling itself.
    //
    
    if (Adapter->ProcessingDeferredItems > 0) {
        return ;
    }
    

    Count = InterlockedIncrement (&Adapter->ProcessingDeferredItems);

    ASSERT (Count > 0);
    if (Count == 1) {
        RaidProcessDeferredItems (&Adapter->DeferredQueue,
                                  Adapter->DeviceObject);

    }

    InterlockedDecrement (&Adapter->ProcessingDeferredItems);
}

VOID
RaidBackOffBusyGateway(
    IN PVOID Context,
    IN LONG OutstandingRequests,
    IN OUT PLONG HighWaterMark,
    IN OUT PLONG LowWaterMark
    )
{
    //
    // We do not enforce a high water mark. Instead, we fill the queue
    // until the adapter is busy, then drain to a low water mark.
    //
    
    *HighWaterMark = max ((6 * OutstandingRequests)/5, 10);
    *LowWaterMark = max ((2 * OutstandingRequests)/5, 5);
}

NTSTATUS
RaidAdapterPassThrough(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP PassThroughIrp,
    IN BOOLEAN Direct
    )
/*++

Routine Description:

    Handle an SCSI Pass through IOCTL.

Arguments:

    Adapter - Supplies the adapter the IRP was issued to.

    PassThroughIrp - Supplies the irp to process.

    Direct - Indicates whether this is a direct or buffered passthrough request.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIRP Irp;
    PRAID_UNIT_EXTENSION Unit;
    KEVENT Event;
    IO_STATUS_BLOCK IoStatus;
    SCSI_REQUEST_BLOCK Srb;
    RAID_ADDRESS Address;
    PORT_PASSTHROUGH_INFO PassThroughInfo;
    IO_SCSI_CAPABILITIES Capabilities;
    PVOID SenseBuffer;
    PPORT_CONFIGURATION_INFORMATION PortConfig;
    ULONG SenseLength;

    PAGED_CODE();

    Irp = NULL;
    SenseBuffer = NULL;
    
    //
    // Zero out the passthrough info structure.
    //

    RtlZeroMemory (&PassThroughInfo, sizeof (PORT_PASSTHROUGH_INFO));
    
    //
    // Try to initialize a pointer to the passthrough structure in the IRP.
    // This routine will fail if the IRP does not contain a valid passthrough
    // structure.
    //

    Status = PortGetPassThrough (&PassThroughInfo, PassThroughIrp, Direct);
    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    //
    // The port library requires a subset of the SCSI_CAPABILITIES information
    // to do parameter validation.  Initialize just the parts we need.
    //

    PortConfig = &Adapter->Miniport.PortConfiguration;
    Capabilities.MaximumTransferLength = PortConfig->MaximumTransferLength;
    Capabilities.MaximumPhysicalPages = PortConfig->NumberOfPhysicalBreaks;

    //
    // Extract the address of the device the request is intended for.
    //
    
    Status = PortGetPassThroughAddress (PassThroughIrp,
                                        &Address.PathId,
                                        &Address.TargetId,
                                        &Address.Lun);
    if (!NT_SUCCESS(Status)) {
        goto done;
    }
    
    //
    // Find the unit the request is intended for.
    //
    
    Unit = RaidAdapterFindUnit (Adapter, Address);
    if (Unit == NULL) {
        Status = STATUS_NO_SUCH_DEVICE;
        goto done;
    }

    //
    // Now that we have the unit, we can finish initializing and validating 
    // parameters.
    //

    Status = PortPassThroughInitialize (&PassThroughInfo,
                                        PassThroughIrp,
                                        &Capabilities,
                                        Unit->DeviceObject,
                                        Direct);
    if (!NT_SUCCESS(Status)) {
        goto done;
    }

    //
    // Allocate a request sense buffer.
    //

    SenseLength = PassThroughInfo.SrbControl->SenseInfoLength;

    if (SenseLength != 0) {
        SenseBuffer = RaidAllocatePool (NonPagedPool,
                                        PassThroughInfo.SrbControl->SenseInfoLength,
                                        SENSE_TAG,
                                        Adapter->DeviceObject);
    
        if (SenseBuffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto done;
        }
    }


    //
    // Call out to the port driver library to build the passthrough SRB.
    //

    Status = PortPassThroughInitializeSrb (&PassThroughInfo,
                                           &Srb,
                                           NULL,
                                           0,
                                           SenseBuffer);
    if (!NT_SUCCESS(Status)) {
        goto done;
    }

    //
    // Initialize the notification event and build a synchronous IRP.
    //

    KeInitializeEvent (&Event,
                       NotificationEvent,
                       FALSE);
    
    Irp = StorBuildSynchronousScsiRequest (Unit->DeviceObject,
                                           &Srb,
                                           &Event,
                                           &IoStatus);

    if (Irp == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }
    
    //
    // We must do this ourselves since we're not calling IoCallDriver.
    //

    IoSetNextIrpStackLocation (Irp);

    //
    // Submit the request to the unit.
    //

    Status = RaidUnitSubmitRequest (Unit, Irp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject (&Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        Status = IoStatus.Status;
    }

    //
    // Call out to the port driver to marshal the results from the SRB back
    // into the passthrough IRP.
    //

    PortPassThroughMarshalResults (&PassThroughInfo,
                                   &Srb,
                                   PassThroughIrp,
                                   &IoStatus,
                                   Direct);

    Status = IoStatus.Status;

done:

    //
    // If we allocated a request sense buffer, free it. 
    //

    if (SenseBuffer != NULL) {
        RaidFreePool (SenseBuffer, SENSE_TAG);
        SenseBuffer = NULL;
    }
    
    return RaidCompleteRequest (PassThroughIrp,  Status);
}


NTSTATUS
RaidAdapterScsiPassThroughIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler routine for IOCTL_SCSI_PASS_THROUGH.

Arguments:

    Adapter - Adapter the pass through ioctl is for.

    Irp - Pass through IRP.

Return Value:

    NTSTATUS code.

--*/
{
    return RaidAdapterPassThrough (Adapter, Irp, FALSE);
}


NTSTATUS
RaidAdapterScsiPassThroughDirectIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler routine for IOCTL_SCSI_PASS_THROUGH.

Arguments:

    Adapter - Adapter the pass through ioctl is for.

    Irp - Pass through IRP.

Return Value:

    NTSTATUS code.

--*/
{
    return RaidAdapterPassThrough (Adapter, Irp, TRUE);
}


NTSTATUS
RaidAdapterScsiGetInquiryDataIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler for the IOCTL_SCSI_GET_INQUIRY_DATA call.

Arguments:

    Adapter - Adapter to process the get inquiry data call.

    Irp - Pointer to the IOCTL_GET_INQUIRY_DATA Irp. The IRP is completed
          by this function.

Return Value:

    NTSTATUS code.

Notes:

    We should make this routine a little more generic and move it to the
    port driver library.
    
--*/
{
    PLIST_ENTRY NextEntry;
    PRAID_UNIT_EXTENSION Unit;
    ULONG PreceedingLuns;
    ULONG NumberOfBuses;
    ULONG NumberOfLuns;
    ULONG RequiredSize;
    ULONG InquiryDataOffset;
    RAID_ADDRESS Address;
    ULONG Bus;
    PSCSI_BUS_DATA BusData;
    PSCSI_BUS_DATA BusDataArray;
    PSCSI_ADAPTER_BUS_INFO AdapterBusInfo;
    PSCSI_INQUIRY_DATA_INTERNAL InquiryBuffer;
    PSCSI_INQUIRY_DATA_INTERNAL InquiryDataArray;
    PTEMPORARY_INQUIRY_BUS_INFO BusInfo;
    TEMPORARY_INQUIRY_BUS_INFO BusInfoArray [SCSI_MAXIMUM_BUSES];
    PIRP_STACK_DEVICE_IO_CONTROL Ioctl;
    PIO_STACK_LOCATION IrpStack;
    PINQUIRYDATA InquiryData;
    LOCK_CONTEXT Lock;
    

    RtlZeroMemory (BusInfoArray, sizeof (BusInfoArray));

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Ioctl = (PIRP_STACK_DEVICE_IO_CONTROL)&IrpStack->Parameters.DeviceIoControl;
    AdapterBusInfo = (PSCSI_ADAPTER_BUS_INFO)Irp->AssociatedIrp.SystemBuffer;

    //
    // We need to hold the unit list lock across the calculation of
    // the size of the buffer. Otherwise, new logical units could come in
    // and modify the size.
    //

    RaidAcquireUnitListLock (&Adapter->UnitList, &Lock);

    NumberOfLuns = Adapter->UnitList.Count;
    NumberOfBuses = RiGetNumberOfBuses (Adapter);

    RequiredSize =
        sizeof (SCSI_INQUIRY_DATA_INTERNAL) * NumberOfLuns +
        sizeof (SCSI_BUS_DATA) * NumberOfBuses +
        FIELD_OFFSET (SCSI_ADAPTER_BUS_INFO, BusData);
    
    InquiryDataOffset =
        sizeof (SCSI_BUS_DATA) * NumberOfBuses +
        FIELD_OFFSET (SCSI_ADAPTER_BUS_INFO, BusData);

    
    InquiryDataArray =
        (PSCSI_INQUIRY_DATA_INTERNAL)((PUCHAR)AdapterBusInfo +
            InquiryDataOffset);
            

    //
    // Verify that we're properly aligned.
    //

    ASSERT_POINTER_ALIGNED (InquiryDataArray);

    //
    // If the buffer it too small, fail. We do not copy partial buffers.
    //
    
    if (Ioctl->OutputBufferLength < RequiredSize) {
        RaidReleaseUnitListLock (&Adapter->UnitList, &Lock);
        return RaidCompleteRequest (Irp,  STATUS_BUFFER_TOO_SMALL);
    }

    //
    // Build the Logical Unit Inquiry Data Array. Unfortunately, since the
    // logical unit list is not sorted by bus number, we need to take two
    // passes on the logical unit array.
    //

    //
    // Pass 1: get the number of Luns for each bus.
    //
    
    for (NextEntry = Adapter->UnitList.List.Flink;
         NextEntry != &Adapter->UnitList.List;
         NextEntry = NextEntry->Flink) {

        Unit = CONTAINING_RECORD (NextEntry,
                                      RAID_UNIT_EXTENSION,
                                      NextUnit);

        ASSERT_UNIT (Unit);

        if (Unit->Flags.Temporary) {
            continue;
        }

        Address = RaidUnitGetAddress (Unit);
        BusInfoArray[ Address.PathId ].NumberOfLogicalUnits++;
    }

    //
    // Now that we know the number of LUNs per bus, build the BusInfo
    // entries.
    //
    //
    
    PreceedingLuns = 0;
    for (Bus = 0; Bus < NumberOfBuses; Bus++) {
        BusInfo = &BusInfoArray[ Bus ];
        BusInfo->InquiryArray = &InquiryDataArray[ PreceedingLuns ];
        PreceedingLuns += BusInfo->NumberOfLogicalUnits;
    }


    //
    // Pass 2: Copy each lun's data into the array in the appropiate
    // location.
    //

    InquiryBuffer = NULL;
    
    for (NextEntry = Adapter->UnitList.List.Flink;
         NextEntry != &Adapter->UnitList.List;
         NextEntry = NextEntry->Flink) {

        Unit = CONTAINING_RECORD (NextEntry,
                                  RAID_UNIT_EXTENSION,
                                  NextUnit);

        ASSERT_UNIT (Unit);

        if (Unit->Flags.Temporary) {
            continue;
        }

        Address = RaidUnitGetAddress (Unit);
        InquiryData = StorGetIdentityInquiryData (&Unit->Identity);
        
        BusInfo = &BusInfoArray[ Address.PathId ];
        InquiryBuffer = &BusInfo->InquiryArray[ BusInfo->CurrentLun++ ];

        ASSERT_POINTER_ALIGNED (InquiryBuffer);

        //
        // ASSERT that we're still within range.
        //
        
        ASSERT (IN_RANGE ((PUCHAR)AdapterBusInfo,
                          (PUCHAR)(InquiryBuffer + 1) - 1,
                          (PUCHAR)AdapterBusInfo + Ioctl->OutputBufferLength));
        
        InquiryBuffer->PathId = Address.PathId;
        InquiryBuffer->TargetId = Address.TargetId;
        InquiryBuffer->Lun = Address.Lun;
        InquiryBuffer->DeviceClaimed = Unit->Flags.DeviceClaimed;
        InquiryBuffer->InquiryDataLength = INQUIRYDATABUFFERSIZE;
        InquiryBuffer->NextInquiryDataOffset =
                (ULONG)((PUCHAR)(InquiryBuffer + 1) - (PUCHAR)AdapterBusInfo);
        RtlCopyMemory (&InquiryBuffer->InquiryData,
                       InquiryData,
                       INQUIRYDATABUFFERSIZE);
        
    }

    //
    // The last Inquiry structure's NextInquiryDataOffset must be zero.
    //
    
    if (InquiryBuffer) {
        InquiryBuffer->NextInquiryDataOffset =  0;
    }
    
    RaidReleaseUnitListLock (&Adapter->UnitList, &Lock);

    //
    // Build the bus array.
    //
    
    BusDataArray = AdapterBusInfo->BusData;

    for (Bus = 0; Bus < NumberOfBuses; Bus++) {

        BusData = &BusDataArray[ Bus ];
        BusInfo = &BusInfoArray[ Bus ];
        
        BusData->NumberOfLogicalUnits = (UCHAR)BusInfo->NumberOfLogicalUnits;
        BusData->InitiatorBusId =
                    RaidAdapterGetInitiatorBusId (Adapter, (UCHAR)Bus);

        if (BusData->NumberOfLogicalUnits != 0) {
            BusData->InquiryDataOffset =
                (ULONG)((PUCHAR)BusInfo->InquiryArray - (PUCHAR)AdapterBusInfo);
        } else {
            BusData->InquiryDataOffset = 0;
        }
    }
    
    //
    // Build the Adapter entry.
    //

    AdapterBusInfo->NumberOfBuses = (UCHAR)NumberOfBuses;

    //
    // And complete request.
    //

    Irp->IoStatus.Information = RequiredSize;
    return RaidCompleteRequest (Irp, STATUS_SUCCESS);
}
        

NTSTATUS
RaidAdapterResetBus(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN UCHAR PathId
    )
/*++

Routine Description:

    Reset the bus on the given adapter, path.

Arguments:

    Adapter - Adapter to reset.

    PathId - PathId to reset.

Return Value:

    NTSTATUS code.

Environment:

    IRQL DISPATCH_LEVEL or below.

--*/
{
    NTSTATUS Status;
    LOCK_CONTEXT LockContext;
    

    ASSERT (KeGetCurrentIrql() <= DISPATCH_LEVEL);

    RaidPauseAdapterQueue (Adapter);
    
    //
    // Acquire the interrupt spinlock or start-io lock as appropiate.
    //
    
    RaidAdapterAcquireStartIoLock (Adapter, &LockContext);

    Status = RaCallMiniportResetBus (&Adapter->Miniport, PathId);

    //
    // Release appropiate lock.
    //
    
    RaidAdapterReleaseStartIoLock (Adapter, &LockContext);

    //
    // Perform the pause even if the hardware failed to reset the bus.
    //

    RaidAdapterSetPauseTimer (Adapter,
                              &Adapter->ResetHoldTimer,
                              &Adapter->ResetHoldDpc,
                              DEFAULT_RESET_HOLD_TIME);
    return Status;
}



LOGICAL
RaidIsAdapterControlSupported(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN SCSI_ADAPTER_CONTROL_TYPE Control
    )
/*++

Routine Description:

    Query a miniport to see if the specified SCSI_ADAPTER_CONTROL_TYPE
    is supported.

Arguments:

    Adapter - Specifies the adapter to query.

    Control - Specifies the control type to query for.

Return Value:

    TRUE - If the requested type is supported.

    FALSE - If it is not.

--*/
{
    NTSTATUS Status;
    LOGICAL Succ;
    ADAPTER_CONTROL_LIST ControlList;
    
    RtlZeroMemory (&ControlList, sizeof (ADAPTER_CONTROL_LIST));

    ControlList.MaxControlType = ScsiAdapterControlMax;

    Status = RaCallMiniportAdapterControl (&Adapter->Miniport,
                                           ScsiQuerySupportedControlTypes,
                                           &ControlList);

    if (NT_SUCCESS (Status)) {
        Succ = ControlList.SupportedTypeList[Control];
    } else {
        Succ = FALSE;
    }

    return Succ;
}


NTSTATUS
RaidAdapterRestartAdapter(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Restart adapter using the ScsiRestartAdapter adapter control.

Arguments:

    Adapter - Adapter to restart.

Return Value:

    NTSTATUS code.

--*/
{
    LOGICAL Succ;
    LOCK_CONTEXT LockContext;
    SCSI_ADAPTER_CONTROL_STATUS Result;

    //
    // The calling function is responsible for ensuring that we support
    // the RestartAdapter control code.
    //
    
    ASSERT (RaidIsAdapterControlSupported (Adapter, ScsiRestartAdapter));


    //
    // If we support running config, set it now.
    //
    
    Succ = RaidIsAdapterControlSupported (Adapter, ScsiSetRunningConfig);

    if (Succ) {
        RaCallMiniportAdapterControl (&Adapter->Miniport,
                                      ScsiSetRunningConfig,
                                      NULL);
    }

    //
    // Acquire correct lock.
    //
    
    RaidAdapterAcquireHwInitializeLock (Adapter, &LockContext);

    
    //
    // Call adapter control.
    //
    
    Result = RaCallMiniportAdapterControl (&Adapter->Miniport,
                                           ScsiRestartAdapter,
                                           NULL);

    //
    // Release acquired lock.
    //
    
    RaidAdapterReleaseHwInitializeLock (Adapter, &LockContext);

    return (Result == ScsiAdapterControlSuccess)
                ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}


NTSTATUS
RaidAdapterStopAdapter(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Stop the adapter using the the HwStorAdapterControl routine.
    
Arguments:

    Adapter - Adpater to stop.
    
Return Value:

    NTSTATUS code.

--*/
{
    LOGICAL Succ;
    LOCK_CONTEXT LockContext;
    SCSI_ADAPTER_CONTROL_STATUS Result;

    //
    // If we haven't actually initialized the miniport, no need to
    // continue.
    //
    
    if (!Adapter->Flags.InitializedMiniport) {
        return STATUS_SUCCESS;
    }
        
    RaidAdapterAcquireHwInitializeLock (Adapter, &LockContext);

    ASSERT (RaidIsAdapterControlSupported (Adapter, ScsiStopAdapter));
    Result = RaCallMiniportAdapterControl (&Adapter->Miniport,
                                           ScsiStopAdapter,
                                           NULL);


    RaidAdapterReleaseHwInitializeLock (Adapter, &LockContext);


    //
    // If we need to set the boot config, do it now.
    //
    
    Succ = RaidIsAdapterControlSupported (Adapter, ScsiSetBootConfig);

    if (Succ) {
        RaCallMiniportAdapterControl (&Adapter->Miniport,
                                      ScsiSetBootConfig,
                                      NULL);
    }

    //
    // If it was initialized before, it is no longer.
    //
    
    Adapter->Flags.InitializedMiniport = FALSE;

    return (Result == ScsiAdapterControlSuccess)
                ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}


NTSTATUS
RaidAdapterReInitialize(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    ReInitialize the adapter by calling HwFindAdapter and HwInitialize
    again. This is the non-preferred way to re-initialize an adapter.

Arguments:

    Adapter - Supplies the adapter to reinitialize.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    LOCK_CONTEXT LockContext;
    UCHAR Wakeup[] = "wakeup=1";

    Status = RaCallMiniportFindAdapter (&Adapter->Miniport, Wakeup);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }
    
    RaidAdapterAcquireHwInitializeLock (Adapter, &LockContext);
    Status = RaCallMiniportHwInitialize (&Adapter->Miniport);
    RaidAdapterReleaseHwInitializeLock (Adapter, &LockContext);

    return Status;
}


NTSTATUS
RaidAdapterRestart(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Restart an adapter using either the ScsiRestartAdapter adapter control
    method or calling HwFindAdapter and HwHinitialize again.

Arguments:

    Adapter - Adapter to restart.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    LOGICAL Succ;

    Succ = RaidIsAdapterControlSupported (Adapter, ScsiRestartAdapter);

    //
    // If restart is supported, call to have the adapter restarted.
    // Otherwise, call to have it re-initialized.
    //
    // NB: If we fail restart, should we try to reinitialize?
    //
    
    if (Succ) {
        Status = RaidAdapterRestartAdapter (Adapter);
    } else {
        Status = RaidAdapterReInitialize (Adapter);
    }

    return Status;
}


NTSTATUS
RaidAdapterStop(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Stop the adapter using either the StorStopAdapter control code or via
    the non-PnP method.

Arguments:

    Adapter - Supplies the Adapter to stop.

Return Value:

    NTSTATUS code.

--*/
{
    LOGICAL Succ;
    NTSTATUS Status;
    
    Succ = RaidIsAdapterControlSupported (Adapter, ScsiStopAdapter);

    if (Succ) {
        Status = RaidAdapterStopAdapter (Adapter);
    } else {

        //
        // Vacuously true.
        //
        
        Status = STATUS_SUCCESS;
    }

    return Status;
}

VOID
RaidCompletionDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    )
/*++

Routine Description:

    Complete all requests for the specified Path, Target, Lun triplet.
    
Arguments:

    Dpc - Unused.

    DeviceObject - Device object for the adapter.

    Context1 - SCSI address of the requests to be completed.

    Context2 - Status that the requests should be completed with.
    

Return Value:

    None.

--*/
{
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    PLIST_ENTRY NextEntry;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_UNIT_EXTENSION Unit;
    RAID_ADDRESS Address;
    LOCK_CONTEXT Lock;

    VERIFY_DISPATCH_LEVEL();

    Adapter = (PRAID_ADAPTER_EXTENSION)DeviceObject->DeviceExtension;
    ASSERT_ADAPTER (Adapter);

    StorLongToScsiAddress2 ((LONG)(LONG_PTR)Context1,
                            &PathId,
                            &TargetId,
                            &Lun);

    RaidAcquireUnitListLock (&Adapter->UnitList, &Lock);
    
    for (NextEntry = Adapter->UnitList.List.Flink;
         NextEntry != &Adapter->UnitList.List;
         NextEntry = NextEntry->Flink) {

        Unit = CONTAINING_RECORD (NextEntry,
                                  RAID_UNIT_EXTENSION,
                                  NextUnit);

        ASSERT_UNIT (Unit);
        Address = Unit->Address;
        
        if ((PathId == SP_UNTAGGED   || PathId == Address.PathId) &&
            (TargetId == SP_UNTAGGED || TargetId == Address.TargetId) &&
            (Lun == SP_UNTAGGED || Lun == Address.Lun)) {

            //
            // Purge all events on the unit queue.
            //
            
            StorPurgeEventQueue (&Unit->PendingQueue,
                                 RaidCompleteMiniportRequestCallback,
                                 Context2);

        }
    }

    RaidReleaseUnitListLock (&Adapter->UnitList, &Lock);

    //
    // Check if we need to resume all of the LUNs on the HBA or just the
    // one LUN. This check must match the same check in
    // StorPortCompleteRequest that actually pauses the lun/adapter.
    //

    if (PathId   != SP_UNTAGGED &&
        TargetId != SP_UNTAGGED &&
        Lun      != SP_UNTAGGED) {

        Address.PathId = PathId;
        Address.TargetId = TargetId;
        Address.Lun = Lun;
        
        Unit = RaidAdapterFindUnit (Adapter, Address);
        if (Unit != NULL) {
            RaidResumeUnitQueue (Unit);
            RaidUnitRestartQueue (Unit);
        }
    } else {
        RaidResumeAdapterQueue (Adapter);
        RaidAdapterRestartQueues (Adapter);
    }
}


NTSTATUS
RaidAdapterRemoveChildren(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PADAPTER_REMOVE_CHILD_ROUTINE RemoveRoutine OPTIONAL
    )
/*++

Routine Description:

    This routine removes the logical unit from the HBA list then calls
    the RemoveRoutine to allow more processing to happen.

    The routine is necessary as a part of the HBA remove and surprise
    remove processing.

Arguments:

    Adapter - Pointer to an adapter that will have it's children removed.

    RemoveRoutine - Optional pointer to a remove routine that is invoked
        after the logical unit has been removed.

Return Value:

    STATUS_SUCCESS - If we removed all logical units from the adapter list.

    Failure code - If the RemoveRoutine returned invalid status. In the
            failure case, we did not necessarily remove all elements from
            the HBA list.

Environment:

    Non-paged, because we acquire a spinlock in this routine.

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY Entry;
    PRAID_UNIT_EXTENSION Unit;
    KIRQL Irql;
    LOCK_CONTEXT Lock;

    //
    // NB: A faster way to accomplish this is to add a RemoveAll routine
    // to the dictionary code that will remove all entries in the dictionary
    // in one fell swoop.
    //
    
    //
    // NB: the code below implies a lock hierarchy of InterruptSpinlock
    // preceeds HBA list lock. This should be obvious.
    //

    do {

        RaidAcquireUnitListLock (&Adapter->UnitList, &Lock);

        if (!IsListEmpty (&Adapter->UnitList.List)) {

            //
            // List is non-empty, remove the head element from the list.
            //
            
            Entry = RemoveHeadList (&Adapter->UnitList.List);
            Unit = CONTAINING_RECORD (Entry,
                                  RAID_UNIT_EXTENSION,
                                  NextUnit);
            ASSERT_UNIT (Unit);
            Adapter->UnitList.Count--;

            //
            // Remove the element from the the dictionary. This has to
            // happen at DIRQL.
            //
            
            if (Adapter->Interrupt) {
                Irql = KeAcquireInterruptSpinLock (Adapter->Interrupt);
            }

            Status = StorRemoveDictionary (&Adapter->UnitList.Dictionary,
                                           RaidAddressToKey (Unit->Address),
                                           NULL);
            ASSERT (NT_SUCCESS (Status));

            if (Adapter->Interrupt) {
                KeReleaseInterruptSpinLock (Adapter->Interrupt, Irql);
            }
            
        } else {
            Unit = NULL;
        }
        
        RaidReleaseUnitListLock (&Adapter->UnitList, &Lock);

        //
        // If we successfully removed a logical unit, call the
        // callback routine with that logical unit.
        //

        if (Unit != NULL && RemoveRoutine != NULL) {
            Status = RemoveRoutine (Unit);

            if (!NT_SUCCESS (Status)) {
                return Status;
            }
        }

    } while (Unit != NULL);

    return STATUS_SUCCESS;
}

    

VOID
RaidAdapterDeleteChildren(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine calls the delete function for all children attached
    to the adapter. This is necessary when the FDO is processing a
    remove IRP.

Arguments:

    Adapter - Adapter which must delete its children.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    
    PAGED_CODE();

    //
    // Call the lower-level RaidAdapterRemoveChildren function to do the
    // real enumeration/removal work.
    //
    
    Status = RaidAdapterRemoveChildren (Adapter,
                                        RaUnitAdapterRemove);

    ASSERT (NT_SUCCESS (Status));
}

VOID
RaidAdapterMarkChildrenMissing(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine removes all children from the adapter list and calls
    the HBA surprise-remove function for each child. This is necessary
    as a part of the HBA surprise-remove processing.

Arguments:

    Adapter - Adapter which must surprise remove children for.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    
    PAGED_CODE();

    //
    // Call the lower-level RaidAdapterRemoveChildren function to do the
    // real enumeration/removal work.
    //
    
    Status = RaidAdapterRemoveChildren (Adapter,
                                        RaUnitAdapterSurpriseRemove);

    ASSERT (NT_SUCCESS (Status));
}

VOID
RaidAdapterBusChangeDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    )
/*++

Routine Description:

    DPC routine to be called when the miniport issues a BusChangeDetected.

Arguments:

    Dpc - Unreferenced.

    DeviceObject - DeviceObject representing an ADAPTER object.

    Context1 - Unreferenced.

    Context2 - Unreferenced.

Return Value:

    None.

--*/
{
    PRAID_ADAPTER_EXTENSION Adapter;

    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (Context1);
    UNREFERENCED_PARAMETER (Context2);

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT (IsAdapter (DeviceObject));

    Adapter = (PRAID_ADAPTER_EXTENSION) DeviceObject->DeviceExtension;

    if (Adapter->Flags.InvalidateBusRelations) {
        Adapter->Flags.InvalidateBusRelations = FALSE;
        IoInvalidateDeviceRelations (Adapter->PhysicalDeviceObject,
                                     BusRelations);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\bus.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	bus.h

Abstract:

	Declaration of a bus object that wraps the BUS_INTERFACE_STANDARD
	interface.

Author:

	Matthew D Hendel (math) 25-Apr-2000

Revision History:

--*/

#pragma once

typedef struct _RAID_BUS_INTERFACE {

    //
    // Has the bus interface been initialized yet.
    //
    
    BOOLEAN Initialized;

    //
    // Standard bus interface. For translating bus addresses, getting
    // DMA adapters, getting and setting bus data.
    //

    BUS_INTERFACE_STANDARD Interface;
    
} RAID_BUS_INTERFACE, *PRAID_BUS_INTERFACE;


//
// Creation and destruction
//

VOID
RaCreateBus(
	IN PRAID_BUS_INTERFACE Bus
	);
	
NTSTATUS
RaInitializeBus(
	IN PRAID_BUS_INTERFACE Bus,
	IN PDEVICE_OBJECT LowerDeviceObject
	);

VOID
RaDeleteBus(
	IN PRAID_BUS_INTERFACE Bus
	);

//
// Operations
//

ULONG
RaGetBusData(
	IN PRAID_BUS_INTERFACE Bus,
	IN ULONG DataType,
	IN PVOID Buffer,
	IN ULONG Offset,
	IN ULONG Length
	);

ULONG
RaSetBusData(
	IN PRAID_BUS_INTERFACE Bus,
	IN ULONG DataType,
	IN PVOID Buffer,
	IN ULONG Offset,
	IN ULONG Length
	);

//
//NB: Add RaidBusTranslateAddress and RaidGetDmaAdapter
//if necessary.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\bus.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bus.c

Abstract:

    Wrapper for BUS_INTERFACE_STANDARD bus interface.

Author:

    Matthew D Hendel (math) 25-Apr-2000

Revision History:

--*/



#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaCreateBus)
#pragma alloc_text(PAGE, RaDeleteBus)
#pragma alloc_text(PAGE, RaInitializeBus)
//#pragma alloc_text(PAGE, RaGetBusData)
//#pragma alloc_text(PAGE, RaSetBusData)
#endif// ALLOC_PRAGMA


//
// Creation and Destruction
//

VOID
RaCreateBus(
    IN PRAID_BUS_INTERFACE Bus
    )
{
    PAGED_CODE ();
    Bus->Initialized = FALSE;
    RtlZeroMemory (&Bus->Interface, sizeof (Bus->Interface));
}


VOID
RaDeleteBus(
    IN PRAID_BUS_INTERFACE Bus
    )
{
    PAGED_CODE ();
    if (Bus->Initialized) {
        Bus->Interface.InterfaceDereference (Bus->Interface.Context);
        Bus->Initialized = FALSE;
        RtlZeroMemory (&Bus->Interface, sizeof (Bus->Interface));
    }
}
    

NTSTATUS
RaInitializeBus(
    IN PRAID_BUS_INTERFACE Bus,
    IN PDEVICE_OBJECT LowerDeviceObject
    )
{
    NTSTATUS Status;

    PAGED_CODE ();

    ASSERT (Bus != NULL);
    ASSERT (LowerDeviceObject != NULL);
 
    Status = RaQueryInterface (LowerDeviceObject,
                               &GUID_BUS_INTERFACE_STANDARD,
                               sizeof (Bus->Interface),
                               1,
                               (PINTERFACE) &Bus->Interface,
                               NULL);

    if (!NT_SUCCESS (Status)) {
        Bus->Initialized = FALSE;
    } else {
        Bus->Initialized = TRUE;
    }

    return Status;
}

//
// Other operations
//

ULONG
RaGetBusData(
    IN PRAID_BUS_INTERFACE Bus,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    ULONG BytesRead;
    //
    // These cannot be paged because they are called at dispatch level
    // during power. Should probably fix power.
    //
    
//    PAGED_CODE ();
    ASSERT (Bus->Initialized);
    
    BytesRead = Bus->Interface.GetBusData (
                    Bus->Interface.Context,
                    DataType,
                    Buffer,
                    Offset,
                    Length
                    );

    return BytesRead;
}


ULONG
RaSetBusData(
    IN PRAID_BUS_INTERFACE Bus,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    ULONG BytesWritten;

    //
    // These cannot be paged because they are called at dispatch level
    // during power. Should probably fix power.
    //
    
//    PAGED_CODE ();
    ASSERT (Bus->Initialized);
    
    BytesWritten = Bus->Interface.SetBusData (
                        Bus->Interface.Context,
                        DataType,
                        Buffer,
                        Offset,
                        Length
                        );

    return BytesWritten;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\busenum.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    busenum.c

Abstract:

    Definition of the bus enumerator.

Algorithm:

Author:

    Matthew D Hendel (math) 21-Feb-2001

Revision History:

--*/

#include "precomp.h"


#define ENUM_TAG ('tEaR')
#define DATA_BUFFER_SIZE    (VPD_MAX_BUFFER_SIZE)

//
// Local types
//

typedef
NTSTATUS
(*BUS_ENUM_QUERY_PROCESS_ROUTINE)(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PBUS_ENUM_UNIT EnumUnit
    );

typedef struct _BUS_ENUM_QUERY_CALLBACK {
    ULONG BuildPageCode;
    BUS_ENUM_QUERY_PROCESS_ROUTINE ProcessRoutine;
} BUS_ENUM_QUERY_CALLBACK, *PBUS_ENUM_QUERY_CALLBACK;

typedef const BUS_ENUM_QUERY_CALLBACK* PCBUS_ENUM_QUERY_CALLBACK;

//
// Local functions
//

NTSTATUS
RaidBusEnumeratorProcessInquiry(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT PBUS_ENUM_UNIT EnumUnit
    );

NTSTATUS
RaidBusEnumeratorProcessSupportedPages(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PBUS_ENUM_UNIT EnumUnit
    );

NTSTATUS
RaidBusEnumeratorProcessDeviceId(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PBUS_ENUM_UNIT EnumUnit
    );

NTSTATUS
RaidBusEnumeratorProcessSerialNumber(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PBUS_ENUM_UNIT EnumUnit
    );

NTSTATUS
RaidBusEnumeratorProcessDeviceId(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PBUS_ENUM_UNIT EnumUnit
    );

NTSTATUS
RaidBusEnumeratorGenericInquiry(
    IN PCBUS_ENUM_QUERY_CALLBACK Callback,
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    IN PBUS_ENUM_UNIT EnumUnit,
    IN ULONG RetryCount
    );

VOID
RaidBusEnumeratorProcessBusUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN PBUS_ENUM_UNIT EnumUnit
    );

NTSTATUS
RaidBusEnumeratorAllocateUnitResources(
    IN PBUS_ENUMERATOR Enumerator,
    IN OUT PBUS_ENUM_RESOURCES Resources
    );

VOID
RaidBusEnumeratorBuildVitalProductInquiry(
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    IN PBUS_ENUM_RESOURCES Resources,
    IN ULONG PageCode,
    OUT PSCSI_REQUEST_BLOCK* SrbBuffer
    );

NTSTATUS
RaidBusEnumeratorIssueSynchronousRequest(
    IN PBUS_ENUMERATOR Enumerator,
    IN PBUS_ENUM_UNIT EnumUnit,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN ULONG RetryCount
    );

NTSTATUS
RaidBusEnumeratorGetUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    OUT PBUS_ENUM_UNIT EnumUnit
    );

VOID
RaidDeleteBusEnumUnit(
    IN PBUS_ENUM_UNIT EnumUnit
    );
    
VOID
RaidBusEnumeratorReleaseUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN OUT PBUS_ENUM_UNIT EnumUnit
    );
    
VOID
RaidBusEnumeratorFreeUnitResources(
    IN PBUS_ENUMERATOR Enumerator
    );

NTSTATUS
RaidBusEnumeratorProcessProbeLunZero(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT PBUS_ENUM_UNIT EnumUnit
    );

NTSTATUS
RaidBusEnumeratorGetLunListFromTarget(
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    IN PBUS_ENUM_UNIT EnumUnit,
    IN OUT PUCHAR LunList
    );

NTSTATUS
RaidBusEnumeratorAllocateReportLunsResources(
    IN PBUS_ENUMERATOR Enumerator,
    IN ULONG DataBufferSize,
    IN OUT PBUS_ENUM_RESOURCES Resources
    );

NTSTATUS
RaidBusEnumeratorIssueReportLuns(
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    IN PBUS_ENUM_UNIT EnumUnit,
    IN OUT PULONG LunListSize,
    OUT PLUN_LIST * LunList
    );

VOID
RaidBusEnumeratorBuildReportLuns(
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    IN PBUS_ENUM_RESOURCES Resources,
    IN ULONG DataBufferSize,
    OUT PSCSI_REQUEST_BLOCK* SrbBuffer
    );

//
// Globals
//

const BUS_ENUM_QUERY_CALLBACK RaidEnumProbeLunZeroCallback = {
    -1,
    RaidBusEnumeratorProcessProbeLunZero
};

const BUS_ENUM_QUERY_CALLBACK RaidEnumInquiryCallback = {
    -1,
    RaidBusEnumeratorProcessInquiry
};

const BUS_ENUM_QUERY_CALLBACK RaidEnumSupportedPagesCallback = {
    VPD_SUPPORTED_PAGES,
    RaidBusEnumeratorProcessSupportedPages
};

const BUS_ENUM_QUERY_CALLBACK RaidEnumDeviceIdCallback = {
    VPD_DEVICE_IDENTIFIERS,
    RaidBusEnumeratorProcessDeviceId
};

const BUS_ENUM_QUERY_CALLBACK RaidEnumSerialNumber = {
    VPD_SERIAL_NUMBER,
    RaidBusEnumeratorProcessSerialNumber
};

const ANSI_STRING NullAnsiString = RTL_CONSTANT_STRING ("");



//
// Debug only functions
//

#if DBG

#define STOR_DEBUG_ENUM_MASK    (0x08000000)

VOID
INLINE
ASSERT_ENUM(
    IN PBUS_ENUMERATOR Enumerator
    )
{
    //
    // Quick and dirty sanity check.
    //
    
    ASSERT (Enumerator->Adapter != NULL);
    ASSERT (Enumerator->Adapter->DeviceObject != NULL);
    ASSERT (Enumerator->Adapter->DeviceObject->DeviceExtension ==
            Enumerator->Adapter);
}

VOID
StorDebugEnum(
    IN PCSTR Format,
    ...
    )
{
    va_list ap;

    va_start (ap, Format);
    vStorDebugPrintEx (STOR_DEBUG_ENUM_MASK,
                       Format,
                       ap);
    va_end (ap);
}

#define DebugEnum(x)    StorDebugEnum x

#else // !DBG

#define DebugEnum(x)
#define ASSERT_ENUM(x)

#endif // DBG

    
//
// Implementation
//

VOID
RaidCreateBusEnumerator(
    IN PBUS_ENUMERATOR Enumerator
    )
{
    PAGED_CODE();
    RtlZeroMemory (Enumerator, sizeof (BUS_ENUMERATOR));
    InitializeListHead (&Enumerator->EnumList);
}


NTSTATUS
RaidInitializeBusEnumerator(
    IN PBUS_ENUMERATOR Enumerator,
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    PAGED_CODE();
    Enumerator->Adapter = Adapter;
    return STATUS_SUCCESS;
}



VOID
RaidDeleteBusEnumerator(
    IN PBUS_ENUMERATOR Enumerator
    )
{
    PLIST_ENTRY NextEntry;
    PBUS_ENUM_UNIT EnumUnit;
    PRAID_UNIT_EXTENSION Unit;

    PAGED_CODE();

    //
    // Free the temporary logical unit, if one was created.
    //
    // NB: It would be more elegant if we didn't have separate logical-unit
    // resources and a logical unit object to delete. Figure out a way to
    // achieve this.
    //

    Unit = Enumerator->Resources.Unit;

    if (Unit != NULL) {
        RaidDeleteUnit (Unit);
        Enumerator->Resources.Unit = NULL;
        Unit = NULL;
    }

    //
    // Free resources associated with the logical unit.
    //
    
    RaidBusEnumeratorFreeUnitResources (Enumerator);

    
    //
    // Free the list entries.
    //

    while (!IsListEmpty (&Enumerator->EnumList)) {

        NextEntry = RemoveHeadList (&Enumerator->EnumList);

        EnumUnit = CONTAINING_RECORD (NextEntry,
                                      BUS_ENUM_UNIT,
                                      EnumLink);
        RaidDeleteBusEnumUnit (EnumUnit);
    }

    
}

VOID
RaidDeleteBusEnumUnit(
    IN PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    Delete a RAID_EUNM_UNIT object and it's associated resources.

Arguments:

    EnumUnit - Enum Unit data structure to delete.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // NB: If we reference-counted the unit associated with the BUS_ENUM_UNIT
    // we would need to dereference it here. This is probably the logically
    // correct thing to do, but we don't do it at this time.
    //

    StorDeleteScsiIdentity (&EnumUnit->Identity);

    DbgFillMemory (EnumUnit, sizeof (*EnumUnit), DBG_DEALLOCATED_FILL);
    RaidFreePool (EnumUnit, ENUM_TAG);
}


NTSTATUS
RaidBusEnumeratorVisitUnit(
    IN PVOID Context,
    IN RAID_ADDRESS Address
    )
/*++

Routine Description:

    The VisitUnit routine is invoked by the adapter bus-enumeration routine
    for each valid SCSI target address for the bus. It is the responsability
    of this routine to figure out whethre there is a logical unit at the
    target address, and to process the target unit.

Arguments:

    Context - Supplies the context passed into the AdapterEnumerateBus
        routine, which, in our case, is a pointer to a BUS_ENUMERATOR
        structure.

    Address - SCSI target address of logical unit to be enumerated.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PBUS_ENUMERATOR Enumerator;
    BUS_ENUM_UNIT EnumUnit;

    PAGED_CODE();

    Enumerator = (PBUS_ENUMERATOR) Context;
    ASSERT_ENUM (Enumerator);
    RtlZeroMemory (&EnumUnit, sizeof (EnumUnit));

    Status = RaidBusEnumeratorGetUnit (Enumerator, Address, &EnumUnit);
    ASSERT (NT_SUCCESS (Status));

    Status = RaidBusEnumeratorGenericInquiry (&RaidEnumInquiryCallback,
                                              Enumerator,
                                              Address,
                                              &EnumUnit,
                                              RAID_INQUIRY_RETRY_COUNT);
    //
    // If the inquiry succeeded, try to get the device ID and serial number
    // for the device.
    //

    if (NT_SUCCESS (Status)) {
        RaidBusEnumeratorGenericInquiry (&RaidEnumSupportedPagesCallback,
                                         Enumerator,
                                         Address,
                                         &EnumUnit,
                                         RAID_INQUIRY_RETRY_COUNT);

        if (EnumUnit.SupportsDeviceId) {
            RaidBusEnumeratorGenericInquiry (&RaidEnumDeviceIdCallback,
                                             Enumerator,
                                             Address,
                                             &EnumUnit,
                                             RAID_INQUIRY_RETRY_COUNT);
        }

        if (EnumUnit.SupportsSerialNumber) {
            RaidBusEnumeratorGenericInquiry (&RaidEnumSerialNumber,
                                             Enumerator,
                                             Address,
                                             &EnumUnit,
                                             RAID_INQUIRY_RETRY_COUNT);
        }
    }

    RaidBusEnumeratorProcessBusUnit (Enumerator, &EnumUnit);

    RaidBusEnumeratorReleaseUnit (Enumerator, &EnumUnit);
    
    return STATUS_SUCCESS;
}
    
NTSTATUS
RaidBusEnumeratorGenericInquiry(
    IN PCBUS_ENUM_QUERY_CALLBACK Callback,
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    IN PBUS_ENUM_UNIT EnumUnit,
    IN ULONG RetryCount
    )
/*++

Routine Description:

    Perform a generic inquiry query on the logical unit. This is used for the
    four types of queries issued to the bus: Inquiry, Vital Product Supported
    Pages, Vital Product Device Id, and Vital Product Serial Number.

Arguments:

    Callback - Callback information representing what vital product data
            we should obtain for this inquiry.

    Enum - Supplies the bus enumerator this call is being issued with.

    Address - Supplies the SCSI address of the logical unit to build
            this request for.

    EnumUnit - Supplies the unit object this inquiry if for.

    RetryCount - Count of the number of _retries_ will be performed on failure.
        Note, zero retries means the request is issued exactly once.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PBUS_ENUM_RESOURCES Resources;
    PSCSI_REQUEST_BLOCK Srb;
    
    Resources = &Enumerator->Resources;

    Status = RaidBusEnumeratorAllocateUnitResources (Enumerator, Resources);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    RaidBusEnumeratorBuildVitalProductInquiry (Enumerator,
                                               Address,
                                               Resources,
                                               Callback->BuildPageCode,
                                               &Srb);

    Status = RaidBusEnumeratorIssueSynchronousRequest (Enumerator,
                                                       EnumUnit,
                                                       Srb,
                                                       RetryCount);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // NOTE: We should check for frozen queue here. This will only happen
    // when the LUN overrides our NO_QUEUE_FREEZE flag. If this is possible,
    // we need to unfreeze the queue here.
    //
    
    Status = Callback->ProcessRoutine (Enumerator, Srb, EnumUnit);

    return Status;
}

NTSTATUS
RaidBusEnumeratorAllocateUnitResources(
    IN PBUS_ENUMERATOR Enumerator,
    IN OUT PBUS_ENUM_RESOURCES Resources
    )
/*++

Routine Description:

    This routine allocates any resources necessary to perform a single inquiry
    command. Resource allocation and freeing is done in a lazy manner, so in
    the most common case, there will be no resources to allocate when we come
    through this loop. Generally, new resources will need to be allocated when
    we found an interesting logical unit the previous time through the
    exterior enumeration loop.

    It is important to remember to re-initialize any objects that do not
    need to be re-allocated.

Arguments:

    Enum - Supplies the bus enumerator this call is for.

    Resources - Supplies the resources to allocate.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG SpecificLuSize;
    PRAID_ADAPTER_EXTENSION Adapter;
    
    PAGED_CODE();

    Adapter = Enumerator->Adapter;
    ASSERT_ADAPTER (Adapter);
    
    //
    // Allocate SRB if necessary; if one has already been allocated,
    // recycle it.
    //

    Status = STATUS_SUCCESS;
    
    if (Resources->Srb == NULL) {
        Resources->Srb = RaidAllocateSrb (Adapter->DeviceObject);
        if (Resources->Srb == NULL) {
            return STATUS_NO_MEMORY;
        }
    } else {
        RaidPrepareSrbForReuse (Resources->Srb);
    }

    if (Resources->SenseInfo == NULL) {
        Resources->SenseInfo = RaidAllocatePool (NonPagedPool,
                                                 SENSE_BUFFER_SIZE,
                                                 SENSE_TAG,
                                                 Adapter->DeviceObject);
        if (Resources->SenseInfo == NULL) {
            return STATUS_NO_MEMORY;
        }
    }

    if (Resources->Irp == NULL) {
        Resources->Irp = IoAllocateIrp (1, FALSE);
        if (Resources->Irp == NULL) {
            return STATUS_NO_MEMORY;
        }
    } else {
        IoReuseIrp (Resources->Irp, STATUS_UNSUCCESSFUL);
    }

    if (Resources->DataBuffer == NULL) {
        Resources->DataBuffer = RaidAllocatePool (NonPagedPool,
                                                  DATA_BUFFER_SIZE,
                                                  INQUIRY_TAG,
                                                  Adapter->DeviceObject);

        if (Resources->DataBuffer == NULL) {
            return STATUS_NO_MEMORY;
        }
        Resources->DataBufferLength = DATA_BUFFER_SIZE;
    }

    if (Resources->Mdl == NULL) {
        Resources->Mdl = IoAllocateMdl (Resources->DataBuffer,
                                        Resources->DataBufferLength,
                                        FALSE,
                                        FALSE,
                                        NULL);
        if (Resources->Mdl == NULL) {
            return STATUS_NO_MEMORY;
        }
        MmPrepareMdlForReuse (Resources->Mdl);
    } else {
        MmPrepareMdlForReuse (Resources->Mdl);
    }

    return Status;
}



VOID
RaidBusEnumeratorFreeUnitResources(
    IN PBUS_ENUMERATOR Enumerator
    )
/*++

Routine Description:

    Free any resources that were allocated by the AllocateUnitResources
    routine. This is called only at the end of the enumeration since we
    do lazy recovery of resources.

Arguments:

    Enum - Supplies the enumerator to free resources from.

Return Value:

    None.

--*/
{
    PBUS_ENUM_RESOURCES Resources;
    PRAID_ADAPTER_EXTENSION Adapter;

    Resources = &Enumerator->Resources;
    Adapter = Enumerator->Adapter;
    ASSERT_ADAPTER (Adapter);
    
    if (Resources->Irp != NULL) {
        IoFreeIrp (Resources->Irp);
        Resources->Irp = NULL;
    }

    if (Resources->Srb != NULL) {
        Resources->Srb->OriginalRequest = NULL;
        Resources->Srb->SenseInfoBuffer = NULL;
        RaidFreeSrb (Resources->Srb);
        Resources->Srb = NULL;
    }

    if (Resources->SenseInfo != NULL) {
        RaidFreePool (Resources->SenseInfo, SENSE_TAG);
        Resources->SenseInfo = NULL;
    }

    if (Resources->DataBuffer) {
        RaidFreePool (Resources->DataBuffer, INQUIRY_TAG);
        Resources->DataBuffer = NULL;
        Resources->DataBufferLength = 0;
    }

    //
    // Delete resources associated with the Report-Luns command.
    //

    Resources = &Enumerator->ReportLunsResources;

    if (Resources->Irp != NULL) {
        IoFreeIrp (Resources->Irp);
        Resources->Irp = NULL;
    }

    if (Resources->Srb != NULL) {
        Resources->Srb->OriginalRequest = NULL;
        Resources->Srb->SenseInfoBuffer = NULL;
        RaidFreeSrb (Resources->Srb);
        Resources->Srb = NULL;
    }

    if (Resources->SenseInfo != NULL) {
        RaidFreePool (Resources->SenseInfo, SENSE_TAG);
        Resources->SenseInfo = NULL;
    }

    if (Resources->DataBuffer) {
        RaidFreePool (Resources->DataBuffer, INQUIRY_TAG);
        Resources->DataBuffer = NULL;
        Resources->DataBufferLength = 0;
    }
}


VOID
RaidBusEnumeratorBuildVitalProductInquiry(
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    IN PBUS_ENUM_RESOURCES Resources,
    IN ULONG PageCode,
    OUT PSCSI_REQUEST_BLOCK* SrbBuffer
    )
/*++

Routine Description:

    Build a INQUIRY command, with an optional vital product inquiry
    page set.

Arguments:

    Enumerator -

    Address - SCSI Address the inquiry is for.

    Resources - Resources to use for the inquiry command.

    PageCode - Specifies what vital product page this inquriy is for,
            or -1 for none.

Return Value:

    None.

--*/
{
    PSCSI_REQUEST_BLOCK Srb;
    struct _CDB6INQUIRY3* Inquiry;
    PINQUIRYDATA InquiryData;
    ULONG Size;

    ASSERT (SrbBuffer != NULL);
    
    Srb = Resources->Srb;
    InquiryData = (PINQUIRYDATA)Resources->DataBuffer;
    Inquiry = NULL;
    Size = 0;

    ASSERT (Srb != NULL);
    ASSERT (InquiryData != NULL);
    
    switch (PageCode) {
        case -1:
            Size = INQUIRYDATABUFFERSIZE;
            break;

        case VPD_SUPPORTED_PAGES:
        case VPD_SERIAL_NUMBER:
        case VPD_DEVICE_IDENTIFIERS:

            //
            // All of the vital product data pages contain variable
            // length structures. Use a maximum length so we don't
            // need to know the length a priori.
            //
            
            Size = VPD_MAX_BUFFER_SIZE; 
            break;

        default:
            Size = VPD_MAX_BUFFER_SIZE;
    }
            
    RtlZeroMemory (InquiryData, DATA_BUFFER_SIZE);

    RaidInitializeInquirySrb (Srb,
                              Address.PathId,
                              Address.TargetId,
                              Address.Lun,
                              InquiryData,
                              Size);

    Inquiry = (struct _CDB6INQUIRY3*) &Srb->Cdb;

    if (PageCode == -1) {
        Inquiry->EnableVitalProductData = 0;
        Inquiry->PageCode = 0;
    } else {
        Inquiry->EnableVitalProductData = 1;
        Inquiry->PageCode = (UCHAR)PageCode;
    }
    
    Srb->SrbExtension = NULL;

    //
    // Initialize the sense info buffer.
    //

    Srb->SenseInfoBuffer = Resources->SenseInfo;
    Srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    Srb->DataBuffer = Resources->DataBuffer;
    Srb->DataTransferLength = Size;

    Srb->SrbFlags |= SRB_FLAGS_NO_QUEUE_FREEZE;
    Srb->SrbFlags |= (SRB_FLAGS_BYPASS_FROZEN_QUEUE |
                      SRB_FLAGS_BYPASS_LOCKED_QUEUE);
    
    *SrbBuffer = Srb;
}


NTSTATUS
RaidBuildScsiIrp(
    IN OUT PIRP Irp,
    IN PMDL Mdl,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    PIO_STACK_LOCATION IrpStack;
    
    //
    // Initialize the IRP
    //

    MmInitializeMdl (Mdl, Srb->DataBuffer, Srb->DataTransferLength);
    MmBuildMdlForNonPagedPool (Mdl);

    Irp->MdlAddress = Mdl;

    IrpStack = IoGetNextIrpStackLocation (Irp);
    IrpStack->MajorFunction = IRP_MJ_SCSI;
    IrpStack->MinorFunction = STOR_MN_ENUMERATION_IRP;
    IrpStack->Parameters.Scsi.Srb = Srb;

    return STATUS_SUCCESS;
}


NTSTATUS
RaidBusEnumeratorGetUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    OUT PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    Get a logical unit to use for enumeration. If there is not an existing
    logical unit, create a fake logical unit. A fake logical unit is necessary
    because other algorithms, e.g., timing-out requests, require a logical
    unit to be present.

Arguments:

    Enumerator - Supplies the enumerator including resources that this
            request is for.

    EnumUnit

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_UNIT_EXTENSION Unit;
    PBUS_ENUM_RESOURCES Resources;
    
    ASSERT (Enumerator != NULL);

    PAGED_CODE();
    ASSERT (EnumUnit != NULL);
    
    Resources = &Enumerator->Resources;
    Status = RaidBusEnumeratorAllocateUnitResources (Enumerator, Resources);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }
        
    //
    // First, try to find the unit in the adapter's unit list.
    //

    Unit = RaidAdapterFindUnit (Enumerator->Adapter, Address);

    //
    // If we didn't find a logical unit in the adapter's list, this
    // means we are querying a unit that we have not found before.
    // Use the temporary unit that is a part of the enumerations
    // resources data structure to perform I/O on.
    //
    
    if (Unit == NULL) {

        Adapter = Enumerator->Adapter;
        if (Resources->Unit == NULL) {
            Status = RaidCreateUnit (Adapter, &Unit);
            if (!NT_SUCCESS (Status)) {
                return Status;
            }
            Resources->Unit = Unit;
            Unit->Flags.Temporary = TRUE;

            //
            // When the unit is created, the queue is locked. Unlock it.
            //
            RaidUnlockUnitQueue (Unit);

        } else {
            Unit = Resources->Unit;
        }
        
        RaidUnitAssignAddress (Unit, Address);
        RaidAdapterInsertUnit (Adapter, Unit);

        //
        // Signal that this logical unit was created for the purposes of
        // enumerating the bus.
        //
        
        EnumUnit->NewUnit = TRUE;

    } else {
        ASSERT (EnumUnit->NewUnit == FALSE);
    }
    
    ASSERT (Unit != NULL);
    EnumUnit->Unit = Unit;
    EnumUnit->Address = RaidUnitGetAddress (Unit);
    EnumUnit->State = EnumUnmatchedUnit;

    return STATUS_SUCCESS;
}

VOID
RaidBusEnumeratorReleaseUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    Release the logical unit obtained through RaidBusEnumeratorGetUnit.
    If it was necessary to create a fake logical unit, this function will
    release the unit the Resources list.

Arguments:

    Enumerator - Enumerator containing resources, etc.

    Unit - Logical unit to release.

Return Value:

    None.

--*/
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_UNIT_EXTENSION Unit;

    PAGED_CODE();

    Unit = EnumUnit->Unit;
    Adapter = Enumerator->Adapter;

    if (EnumUnit->NewUnit) {
        RaidAdapterRemoveUnit (Adapter, Unit);
        RaidUnitAssignAddress (Unit, RaidNullAddress);
    }
}

NTSTATUS
RaidBusEnumeratorIssueSynchronousRequest(
    IN PBUS_ENUMERATOR Enumerator,
    IN PBUS_ENUM_UNIT EnumUnit,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN ULONG RetryCount
    )
/*++

Routine Description:

    Issue the SRB synchronously to it's specified unit.

Arguments:

    Enumerator - Specifies the enumerator this request is associated with.

    Srb - Specifies the SRB to issue.

    RetryCount - Count of the number of _retries_ will be performed on failure.
        Note, zero retries means the request is issued exactly once.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIRP Irp;
    PBUS_ENUM_RESOURCES Resources;
    PRAID_UNIT_EXTENSION Unit;
    PSENSE_DATA SenseData;

    Resources = &Enumerator->Resources;
    Irp = Resources->Irp;
    Unit = EnumUnit->Unit;
    
    do {

        //
        // Build or rebuild the IRP.
        //
        
        Status = RaidBuildScsiIrp (Irp, Resources->Mdl, Srb);

        //
        // Reset the timeout to the unit's default timeout, which may
        // be different from the default timeout the SRB creation
        // function sets it to.
        //
    
        Srb->TimeOutValue = Unit->DefaultTimeout;

        Status = RaSendIrpSynchronous (Unit->DeviceObject, Irp);

        SenseData = (PSENSE_DATA)Srb->SenseInfoBuffer;
        
        if (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_SELECTION_TIMEOUT ||
            SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_NO_DEVICE) {

            //
            // Don't retry selection timeouts.
            //
            
            Status = STATUS_INVALID_DEVICE_REQUEST;

        } else if ((Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&
                   SenseData->SenseKey == SCSI_SENSE_ILLEGAL_REQUEST) {

            //
            // LUN is probably not valid, although the target likely is.
            // Don't retry this request either.
            //
            
            Status = STATUS_NO_SUCH_DEVICE;

        } else if (Srb->SrbStatus == SRB_STATUS_DATA_OVERRUN) {

            //
            // If it was a short transfer, claim success. The miniport has
            // adjusted DataTransferLength accordingly.
            //
            
            Status = STATUS_SUCCESS;
            Srb->SrbStatus = SRB_STATUS_SUCCESS;
        }

#if DBG
        //
        // Output some useful debug info.
        //
        
        if (!NT_SUCCESS (Status) &&
            Status != STATUS_INVALID_DEVICE_REQUEST &&
            Status != STATUS_NO_SUCH_DEVICE) {

            DebugEnum (("Adapter %p, (%d %d %d) failed command %x with status %x\n"
                        "        command %s\n",
                         Enumerator->Adapter,
                         (ULONG)Srb->PathId,
                         (ULONG)Srb->TargetId,
                         (ULONG)Srb->Lun,
                         (ULONG)Srb->Cdb[0],
                         (ULONG)Srb->SrbStatus,
                         RetryCount ? "retried" : "not retried"));
        }
#endif

    } while (RetryCount-- &&
             !NT_SUCCESS (Status) &&
             Status != STATUS_INVALID_DEVICE_REQUEST &&
             Status != STATUS_NO_SUCH_DEVICE);


    return Status;
}

NTSTATUS
RaidBusEnumeratorProcessInquiry(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    This routine processes an Inquiry command by storing the relevant Inquiry
    data in the EnumUnit for later use.

Arguments:

    Enumerator - Supplies the enumerator the inquiry command is for.

    Srb - Supples the completed SCSI request block for this inquiry.

    EnumUnit - Supplies per-unit enumeration data that is modified by this
        routine.

Return Value:

    NTSTATUS code.

--*/
{
    PINQUIRYDATA InquiryData;
    PBUS_ENUM_RESOURCES Resources;

    if (SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SUCCESS) {
        return RaidSrbStatusToNtStatus (Srb->SrbStatus);
    }

    Resources = &Enumerator->Resources;
    InquiryData = (PINQUIRYDATA)Resources->DataBuffer;

    //
    // Ignore inactive devices.
    //
    
    if (InquiryData->DeviceTypeQualifier != DEVICE_QUALIFIER_ACTIVE) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // The inquiry data is now owned by the identification packet, so
    // NULL it out in the Resources structure.
    //
    
    EnumUnit->Identity.InquiryData = InquiryData;
    EnumUnit->Found = TRUE;
    
    Resources->DataBuffer = NULL;
    Resources->DataBufferLength = 0;

    return STATUS_SUCCESS;
}



NTSTATUS
RaidBusEnumeratorProcessSupportedPages(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    This routine processes an Inquiry, VPD_SUPPORTED_PAGES command by
    storing the relevant inquiry data in the EnumUnit.

Arguments:

    Enumerator - Supplies the enumerator the supported pages command was
        issued to.

    Srb - Supples the completed SCSI request block for this inquiry.

    EnumUnit - Supplies the per-unit enumeration data that is modified by this
        routine.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG i;
    PVPD_SUPPORTED_PAGES_PAGE SupportedPages;


    if (SRB_STATUS (Srb->SrbStatus) != SRB_STATUS_SUCCESS) {
        return RaidSrbStatusToNtStatus (Srb->SrbStatus);
    }

    SupportedPages = Enumerator->Resources.DataBuffer;

    for (i = 0; i < SupportedPages->PageLength; i++) {
        switch (SupportedPages->SupportedPageList[i]) {
            case VPD_SERIAL_NUMBER:
                EnumUnit->SupportsSerialNumber = TRUE;
                break;

            case VPD_DEVICE_IDENTIFIERS:
                EnumUnit->SupportsDeviceId = TRUE;
                break;
        }
    }

    return STATUS_SUCCESS;
}



NTSTATUS
RaidBusEnumeratorProcessDeviceId(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    Process an Inquiry, VPD_DEVICE_IDENTIFIERS command by storing the
    relevant inquiry data to the EnumUnit.

Arguments:

    Enumerator - Supplies the enumerator this command was issued as a part of.

    Srb - Supples the completed SCSI request block for this inquiry.

    EnumUnit - Supplies the per-unit enumeration data that is modified by this
        routine.

Return Value:

    NTSTATUS code

--*/
{
    PVPD_SUPPORTED_PAGES_PAGE SupportedPages;

    if (SRB_STATUS (Srb->SrbStatus) != SRB_STATUS_SUCCESS) {
        return RaidSrbStatusToNtStatus (Srb->SrbStatus);
    }


    //
    // Capture the raw page 0x83 data. It gets parsed and built when someone
    // asks for the STORAGE_DEVICE_ID_DESCRIPTOR.
    //
    EnumUnit->Identity.DeviceId = Enumerator->Resources.DataBuffer;

    //
    // The DeviceId data is now owned by the enum unit, so NULL it out
    // in the resources structure so it doesn't get double freed.
    //
    Enumerator->Resources.DataBuffer = NULL;
    Enumerator->Resources.DataBufferLength = 0;

    return STATUS_SUCCESS;
}



NTSTATUS
RaidBusEnumeratorProcessSerialNumber(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    Process an Inquiry, VPD_SERIAL_NUMBER command by storing the relevant
    inquiry data to the EnumUnit.

Arguments:

    Enumerator - Supplies the enumerator this command was issued as a part of.

    Srb - Supples the completed SCSI request block for this inquiry.

    EnumUnit - Supplies the per-unit enumeration data that is modified by this
        routine.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PVPD_SERIAL_NUMBER_PAGE SerialNumberPage;

    if (SRB_STATUS (Srb->SrbStatus) != SRB_STATUS_SUCCESS) {
        return RaidSrbStatusToNtStatus (Srb->SrbStatus);
    }
    
    SerialNumberPage = Srb->DataBuffer;

    Status = StorCreateAnsiString (&EnumUnit->Identity.SerialNumber,
                                   SerialNumberPage->SerialNumber,
                                   SerialNumberPage->PageLength,
                                   NonPagedPool,
                                   Enumerator->Adapter->DeviceObject);

    return Status;
}


PBUS_ENUM_UNIT
RaidBusEnumeratorFindUnitByAddress(
    IN PBUS_ENUMERATOR Enumerator,
    IN STOR_SCSI_ADDRESS Address
    )
/*++

Routine Description:

    Search for a unit in the unit list via the SCSI address.

Arguments:

    Enum - Supplies the enumerator that is currently enumerating. The
        enumerator contains resources for the enumeration that may be
        necessary in the processing of the unit.

    NewEnumUnit - Supplies the enumerated unit.

Return Value:

    Non-NULL - Represents the found enumerated unit.

    NULL - If a matching unit was not found.

--*/
{
    PLIST_ENTRY NextEntry;
    PBUS_ENUM_UNIT EnumUnit;
    LONG Comparison;

    for (NextEntry = Enumerator->EnumList.Flink;
         NextEntry != &Enumerator->EnumList;
         NextEntry = NextEntry->Flink) {
        
        EnumUnit = CONTAINING_RECORD (NextEntry,
                                      BUS_ENUM_UNIT,
                                      EnumLink);
        
        Comparison = StorCompareScsiAddress (Address, EnumUnit->Address);

        //
        // Found a matching unit: mark it as found.
        //

        if (Comparison == 0) {
            return EnumUnit;
        }
    }

    return NULL;
}



VOID
RaidBusEnumeratorProcessBusUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    This routine is called for each unit attached to the bus. It is the
    responsability of this routine to do whatever is necessary to process
    the unit.

Arguments:

    Enumerator - Supplies the enumerator that is currently enumerating. The
        enumerator contains resources for the enumeration that may be
        necessary in the processing of the unit.

    EnumUnit - Supplies the enumerated unit.

Return Value:

    None.

--*/
{
    LONG Comparison;
    LOGICAL Modified;
    PRAID_UNIT_EXTENSION Unit;
    PBUS_ENUM_RESOURCES Resources;

    
    Unit = EnumUnit->Unit;
    Resources = &Enumerator->Resources;
    Modified = FALSE;

    if (!EnumUnit->NewUnit && !EnumUnit->Found) {

        //
        // There was a logical unit at this address, but upon reenumeration,
        // we didn't find one. Mark it for deletion.
        //

        Modified = TRUE;
        ASSERT (EnumUnit->State == EnumUnmatchedUnit);
        
    } else if (!EnumUnit->NewUnit && EnumUnit->Found) {

        //
        // There was a logical unit at this address and there still is. If
        // it turns out to be the SAME logical unit, do nothing. Otherwise,
        // mark it for creation.
        //

        ASSERT (!Unit->Flags.Temporary);
        Comparison = StorCompareScsiIdentity (&EnumUnit->Identity,
                                              &Unit->Identity);

        if (Comparison == 0) {

            //
            // The new unit matches the unit we had previously enumerated.
            // Update the state and return.
            //

            ASSERT (EnumUnit->State == EnumUnmatchedUnit);
            EnumUnit->State = EnumMatchedUnit;
            Modified = FALSE;

        } else {
        
            //
            // There was a unit at this SCSI address, but this unit
            // does not match it. Mark the previous unit for deletion
            // by leaving it as unmatched and fall through to the new
            // creation code below.
            //

            ASSERT (EnumUnit->State == EnumUnmatchedUnit);
            Modified = TRUE;

            //
            // This is probably a bug. Break in and take a look.
            //
            
            ASSERT (FALSE);
            
        }

    } else if (EnumUnit->NewUnit && EnumUnit->Found) {

        //
        // We found a new unit.
        //

        EnumUnit->State = EnumNewUnit;
        Modified = TRUE;
    }

    //
    // If the logical unit at this address is new, has gone away or is
    // somehow different than the logical unit previously at this SCSI
    // address, put it on the modified list.
    //
    
    if (Modified) {
        PBUS_ENUM_UNIT NewEnumUnit;

        NewEnumUnit = RaidAllocatePool (NonPagedPool,
                                        sizeof (BUS_ENUM_UNIT),
                                        ENUM_TAG,
                                        Enumerator->Adapter->DeviceObject);
        if (NewEnumUnit == NULL) {

            //
            // REVIEW: we should revisit this path.
            //
            // This is an extrordinarily bad time for us to fail a memory
            // allocation. Try to continue on.
            //

            return;
        }
            
        *NewEnumUnit = *EnumUnit;
            

        Resources->Unit = NULL;
        InsertHeadList (&Enumerator->EnumList, &NewEnumUnit->EnumLink);
    }
}



VOID
RaidBusEnumeratorProcessNewUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    Process a unit that was newly discovered as a part of the enumeration.

Arguments:

    Enumerator - Supplies the enumerator that this unit was discovered as a
        part of.

    EnumUnit - Supplies the data necessary to create the logical unit.

Return Value:

    NTSTATUS code.

--*/
{
    PRAID_UNIT_EXTENSION Unit;

    PAGED_CODE();

    Unit = EnumUnit->Unit;

    RaidUnitAssignAddress (Unit, EnumUnit->Address);
    RaidUnitAssignIdentity (Unit, &EnumUnit->Identity);
    Unit->Flags.Temporary = FALSE;
    Unit->Flags.Present = TRUE;
    Unit->DeviceState = DeviceStateStopped;
    RaidLockUnitQueue (Unit);
    RaidAdapterInsertUnit (Unit->Adapter, Unit);
    RaidStartUnit (Unit);
}



LOGICAL
RaidBusEnumeratorProcessDeletedUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    Process a unit that was not found as a part of this enumeration.

Arguments:

    Enumerator - Supplies the enumerator that this unit was discovered as a
        part of.

    EnumUnit - Supplies the data necessary to delete the unit.

Return Value:

    NTSTATUS code.

--*/
{
    return RaidUnitNotifyHardwareGone (EnumUnit->Unit);
}



VOID
RaidBusEnumeratorProcessMatchedUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    The process routine is called for each unit on the bus that matched
    an old unit on the bus. Verify that the parameters are all still
    the same.

    NB: We assume that during a bus enumeration, the SCSI target address
    of a logical unit will not change. If it does, we will have to do
    real processing below to delete and re-create the unit.
    
Arguments:

    Enumerator - Supplies enumeration data.

    EnumUnit - Supplies information about the logical unit.

Return Value:

    None.

--*/
{
    LONG Comparison;
    ASSERT (EnumUnit->Unit != NULL);

    //
    // When the SCSI target IDs change, we treat it as a separate
    // delete and create operation.
    //

    Comparison = StorCompareScsiAddress (EnumUnit->Unit->Address,
                                         EnumUnit->Address);
    ASSERT (Comparison == 0);
}



LOGICAL
RaidBusEnumeratorProcessModifiedNodes(
    IN PBUS_ENUMERATOR Enumerator
    )
/*++

Routine Description:

    Process any units that were modified by the enumeration. Modified units
    are those that were created, deleted or changed.

Arguments:

    Enumerator - Supplies the enumerator that includes the list of all found
        units and their states.

Return Value:

    A boolean specifying whether the bus had changed (TRUE) or not (FALSE)
    from what was initialized in the enumerator. If the bus had changed, the
    caller of this routine may have invalidate the bus relations for this bus.

--*/
{
    PLIST_ENTRY NextEntry;
    PBUS_ENUM_UNIT EnumUnit;
    LOGICAL ChangeDetected;
    PRAID_ADAPTER_EXTENSION Adapter;
    

    ChangeDetected = FALSE;
    Adapter = Enumerator->Adapter;
    ASSERT_ADAPTER (Adapter);
    

    for (NextEntry = Enumerator->EnumList.Flink;
         NextEntry != &Enumerator->EnumList;
         NextEntry = NextEntry->Flink) {

        EnumUnit = CONTAINING_RECORD (NextEntry,
                                      BUS_ENUM_UNIT,
                                      EnumLink);
        
        switch (EnumUnit->State) {

            case EnumUnmatchedUnit:
                ChangeDetected =
                    RaidBusEnumeratorProcessDeletedUnit (Enumerator, EnumUnit);
                break;

            case EnumNewUnit:
                RaidBusEnumeratorProcessNewUnit (Enumerator, EnumUnit);
                ChangeDetected = TRUE;
                break;
            
            case EnumMatchedUnit:
                RaidBusEnumeratorProcessMatchedUnit (Enumerator, EnumUnit);
                break;

            default:
                ASSERT (FALSE);
        }
    }

    //
    // Return a status value to tell if the bus has changed since last time
    // we enumerated.
    //
    
    return ChangeDetected;
}
    
NTSTATUS
RaidBusEnumeratorGetLunListFromTarget(
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    IN PBUS_ENUM_UNIT EnumUnit,
    IN OUT PUCHAR ScanList
    )
/*++

Routine Description:

    This routine updates the supplied ScanList to indicate witch LUNs should 
    be scanned on the specified target.

Arguments:

    Enumerator - A pointer to a BUS_ENUMERATOR structure which holds state used
                 to enumerate the bus.

    Address - SCSI target address of logical unit to be enumerated.

    EnumUnit - Represents the device to which we will direct any commands
               required to discover information about the device.

    ScanList - An array of bytes.  On exit, each non-zero byte indicates to the
               caller, that an INQUIRY command should be sent to the corresp-
               onding LUN.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG LunListSize;
    PLUN_LIST LunList;
    USHORT Lun;
    ULONG NumberOfEntries;
    ULONG Index;

    PAGED_CODE();

    //
    // Because we do not know in advance how big the returned lun list will be,
    // we begin by assuming the returned list will contain a single entry.  If 
    // the buffer we supply is too small, we will try again with one of the
    // correct size.  For each valid LUN, the returned list will contain an
    // 8-byte entry, therefore the buffer we'll send must be big enough of the
    // LUN_LIST structure plus one 8-byte entry.
    //

    LunListSize = sizeof (LUN_LIST) + 8;

    //
    // Issue REPORT LUNS to the specified target's LUN zero.
    //

    DebugEnum (("Adapter %p, (%d %d %d) issuing report luns\n",
                Enumerator->Adapter,
                (ULONG)Address.PathId,
                (ULONG)Address.TargetId,
                (ULONG)Address.Lun));

    Status = RaidBusEnumeratorIssueReportLuns (Enumerator,
                                               Address,
                                               EnumUnit,
                                               &LunListSize,
                                               &LunList);
    if (!NT_SUCCESS (Status)) {

        //
        // The request failed.  If the reason for failure was that we gave too
        // small a buffer, retry the request.  LunListSize will have been
        // updated to an appropriate size.
        //

        if (Status == STATUS_BUFFER_TOO_SMALL) {
            Status = RaidBusEnumeratorIssueReportLuns (Enumerator,
                                                       Address,
                                                       EnumUnit,
                                                       &LunListSize,
                                                       &LunList);

            if (!NT_SUCCESS(Status)) {

                //
                // The REPORT LUNS failed after we tried using a bigger buffer.
                // Leave the ScanList alone.
                //
               
                return Status;
            }
        } else {

            //
            // The REPORT LUNS failed for some reason other than too small a
            // buffer.  We'll leave the ScanList alone.
            //

            return Status;
        }
    }

    //
    // We have a LUN_LIST from the target.  Start by zeroing out the array of 
    // LUNs to scan.
    //

    RtlZeroMemory (ScanList, SCSI_MAXIMUM_LUNS_PER_TARGET);

    //
    // Calculate the number of enties in the LUN_LIST.
    //
        
    NumberOfEntries = RaGetNumberOfEntriesFromLunList (LunList);

    //
    // Walk the LUN_LIST and for each entry, mark the corresponding entry
    // in our list to indicate that the LUN should be scanned.
    //

    for (Index = 0; Index < NumberOfEntries; Index++) {
        Lun = RaGetLUNFromLunList (LunList, Index);
        if (Lun >= SCSI_MAXIMUM_LUNS_PER_TARGET) {
            DebugWarn (("Adapter %p, REPORT LUNS reported LUN %d present, which is > 255.\n",
                        Enumerator->Adapter,
                        Lun));
            DebugWarn (("Ignoring LUN %d\n", Lun));
        
            continue;
        }
        ScanList [Lun] = TRUE;
    }

#if DBG

    //
    // In CHK builds, dump the lun scan list.
    //
    
    DebugEnum (("Adapter %p, REPORT LUNS succeeded.\n",
                 Enumerator->Adapter));
    DebugEnum (("Dump:\n"));

    for (Lun = 0; Lun < SCSI_MAXIMUM_LUNS_PER_TARGET; Lun++) {
        if (ScanList [Lun]) {
            DebugEnum (("Lun %d present\n", Lun));
        }
    }
#endif
    
    return STATUS_SUCCESS;
}

NTSTATUS
RaidBusEnumeratorIssueReportLuns(
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    IN PBUS_ENUM_UNIT EnumUnit,
    IN OUT PULONG LunListSize,
    OUT PLUN_LIST * LunList
    )
/*++

Routine Description:

    This routine issues a synchronous REPORT LUNS command to the addressed
    device.

Arguments:

    Enumerator - A pointer to a BUS_ENUMERATOR structure which holds state used
                 to enumerate the bus.

    Address    - Address of the device to which the REPORT LUNS command will
                 be sent.

    EnumUnit   - Represents the device to which we will direct any commands
                 required to discover information about the device.

    LunListSize - The size of the buffer to allocate to receive the the 
                  LUN_LIST from the device.

    LunList     - Pointer to a LUN_LIST structure.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PBUS_ENUM_RESOURCES Resources;
    PSCSI_REQUEST_BLOCK Srb;
    PLUN_LIST LocalLunList;
    ULONG LunListLength;

    PAGED_CODE();
    
    Resources = &Enumerator->ReportLunsResources;

    Status = RaidBusEnumeratorAllocateReportLunsResources (Enumerator, 
                                                           *LunListSize,
                                                           Resources);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    RaidBusEnumeratorBuildReportLuns (Enumerator,
                                      Address,
                                      Resources,
                                      *LunListSize,
                                      &Srb);

    Status = RaidBusEnumeratorIssueSynchronousRequest (Enumerator,
                                                       EnumUnit,
                                                       Srb,
                                                       RAID_INQUIRY_RETRY_COUNT);
    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_BUFFER_TOO_SMALL) {
            Status = STATUS_NO_SUCH_DEVICE;
        }
        return Status;
    }

    //
    // Get the size of the list.
    //

    LocalLunList = Srb->DataBuffer;
    LunListLength = RaGetListLengthFromLunList(LocalLunList);

    //
    // If the buffer we supplied was too small, tell the caller how big the
    // buffer needs to be.  Otherwise, return success.
    //

    if (*LunListSize < (LunListLength + sizeof (LUN_LIST))) {
        *LunListSize = LunListLength + sizeof (LUN_LIST);
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        Status = STATUS_SUCCESS;
    }

    //
    // Copy the address of the LUN list structure into the supplied address.
    //

    *LunList = LocalLunList;

    return Status;
}

NTSTATUS
RaidBusEnumeratorAllocateReportLunsResources(
    IN PBUS_ENUMERATOR Enumerator,
    IN ULONG DataBufferSize,
    IN OUT PBUS_ENUM_RESOURCES Resources
    )
/*++

Routine Description:

    This routine allocates or reinitializs any resources required to send
    a REPORT LUNS command.

    Note: If the DataBuffer or Mdl are non-NULL, they are freed and 
          reallocated.

Arguments:

    Enumerator - A pointer to a BUS_ENUMERATOR structure which 